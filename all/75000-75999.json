[{"original_method":"@Override\n  public PsiElement get() {\n    JvmPsiClass _get = this.jvmPsiClassProvider.get();\n    final Procedure1<JvmPsiClass> _function = new Procedure1<JvmPsiClass>() {\n      @Override\n      public void apply(final JvmPsiClass jvmPsiClass) {\n        PsiClass _createStub = JvmPsiClassProvider.this.createStub();\n        jvmPsiClass.setStub(_createStub);\n        jvmPsiClass.setType(JvmPsiClassProvider.this.jvmDeclaredType);\n        final Provider<PsiClass> _function = new Provider<PsiClass>() {\n          @Override\n          public PsiClass get() {\n            return JvmPsiClassProvider.this.createPsiClass();\n          }\n        };\n        jvmPsiClass.setPsiClassProvider(_function);\n      }\n    };\n    return ObjectExtensions.<JvmPsiClass>operator_doubleArrow(_get, _function);\n  }","id":75000,"modified_method":"@Override\n  public PsiElement get() {\n    final JvmPsiClass result = this.jvmPsiClassProvider.get();\n    PsiClass _createStub = this.createStub();\n    result.setStub(_createStub);\n    result.setType(this.jvmDeclaredType);\n    final Provider<PsiClass> _function = new Provider<PsiClass>() {\n      @Override\n      public PsiClass get() {\n        return JvmPsiClassProvider.this.createPsiClass();\n      }\n    };\n    result.setPsiClassProvider(_function);\n    return result;\n  }","commit_id":"8af85aa2c45607192f1ff7b9c08b02dd72bf6d03","url":"https://github.com/eclipse/xtext"},{"original_method":"public static void setLoadingTypeResource(final Notifier ctx, final boolean loadingTypeResource) {\n    final ResourceSet resourceSet = EcoreUtil2.getResourceSet(ctx);\n    if (loadingTypeResource) {\n      EList<Adapter> _eAdapters = resourceSet.eAdapters();\n      LoadingTypeResourcePhase _loadingTypeResourcePhase = new LoadingTypeResourcePhase();\n      _eAdapters.add(_loadingTypeResourcePhase);\n    } else {\n      EList<Adapter> _eAdapters_1 = resourceSet.eAdapters();\n      final Iterator<Adapter> i = _eAdapters_1.iterator();\n      while (i.hasNext()) {\n        Adapter _next = i.next();\n        boolean _isAdapterForType = _next.isAdapterForType(LoadingTypeResourcePhase.class);\n        if (_isAdapterForType) {\n          i.remove();\n          return;\n        }\n      }\n    }\n  }","id":75001,"modified_method":"public static void setLoadingTypeResource(final Notifier ctx, final boolean loadingTypeResource) {\n    ResourceSet _resourceSet = EcoreUtil2.getResourceSet(ctx);\n    final EList<Adapter> adapters = _resourceSet.eAdapters();\n    if (loadingTypeResource) {\n      adapters.add(LoadingTypeResourcePhase.INSTANCE);\n    } else {\n      adapters.remove(LoadingTypeResourcePhase.INSTANCE);\n    }\n  }","commit_id":"8af85aa2c45607192f1ff7b9c08b02dd72bf6d03","url":"https://github.com/eclipse/xtext"},{"original_method":"public static boolean isLoadingTypeResource(final Notifier ctx) {\n    boolean _xblockexpression = false;\n    {\n      final ResourceSet resourceSet = EcoreUtil2.getResourceSet(ctx);\n      boolean _equals = Objects.equal(resourceSet, null);\n      if (_equals) {\n        return false;\n      }\n      EList<Adapter> _eAdapters = resourceSet.eAdapters();\n      Adapter _adapter = EcoreUtil.getAdapter(_eAdapters, LoadingTypeResourcePhase.class);\n      _xblockexpression = (!Objects.equal(_adapter, null));\n    }\n    return _xblockexpression;\n  }","id":75002,"modified_method":"public static boolean isLoadingTypeResource(final Notifier ctx) {\n    boolean _xblockexpression = false;\n    {\n      final ResourceSet resourceSet = EcoreUtil2.getResourceSet(ctx);\n      boolean _equals = Objects.equal(resourceSet, null);\n      if (_equals) {\n        return false;\n      }\n      EList<Adapter> _eAdapters = resourceSet.eAdapters();\n      Adapter _adapter = EcoreUtil.getAdapter(_eAdapters, LoadingTypeResourcePhase.INSTANCE);\n      _xblockexpression = (!Objects.equal(_adapter, null));\n    }\n    return _xblockexpression;\n  }","commit_id":"8af85aa2c45607192f1ff7b9c08b02dd72bf6d03","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public boolean isAdapterForType(final Object type) {\n    return Objects.equal(LoadingTypeResourcePhase.class, type);\n  }","id":75003,"modified_method":"@Override\n  public boolean isAdapterForType(final Object type) {\n    return Objects.equal(LoadingTypeResourcePhase.INSTANCE, type);\n  }","commit_id":"8af85aa2c45607192f1ff7b9c08b02dd72bf6d03","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n   * @return\n   */\n  protected ITextRegion getSignificantTextRegion() {\n    ITextRegion _xtrycatchfinallyexpression = null;\n    try {\n      EObject _eObject = this.getEObject();\n      _xtrycatchfinallyexpression = this.locationInFileProvider.getSignificantTextRegion(_eObject);\n    } catch (final Throwable _t) {\n      if (_t instanceof OperationCanceledError) {\n        final OperationCanceledError e = (OperationCanceledError)_t;\n        throw e.getWrapped();\n      } else {\n        throw Exceptions.sneakyThrow(_t);\n      }\n    }\n    return _xtrycatchfinallyexpression;\n  }","id":75004,"modified_method":"protected ITextRegion getSignificantTextRegion() {\n    ITextRegion _xtrycatchfinallyexpression = null;\n    try {\n      EObject _eObject = this.getEObject();\n      _xtrycatchfinallyexpression = this.locationInFileProvider.getSignificantTextRegion(_eObject);\n    } catch (final Throwable _t) {\n      if (_t instanceof OperationCanceledError) {\n        final OperationCanceledError e = (OperationCanceledError)_t;\n        throw e.getWrapped();\n      } else {\n        throw Exceptions.sneakyThrow(_t);\n      }\n    }\n    return _xtrycatchfinallyexpression;\n  }","commit_id":"8af85aa2c45607192f1ff7b9c08b02dd72bf6d03","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public Collection<AbstractTreeNode> getChildrenImpl() {\n    XtendFileImpl _xtendFile = this.getXtendFile();\n    Iterable<PsiClass> _psiClasses = this._jvmPsiClasses.getPsiClasses(_xtendFile);\n    final Function1<PsiClass, ClassTreeNode> _function = new Function1<PsiClass, ClassTreeNode>() {\n      @Override\n      public ClassTreeNode apply(final PsiClass psiClass) {\n        Project _project = XtendFileTreeNode.this.getProject();\n        ViewSettings _settings = XtendFileTreeNode.this.getSettings();\n        return new ClassTreeNode(_project, psiClass, _settings);\n      }\n    };\n    Iterable<ClassTreeNode> _map = IterableExtensions.<PsiClass, ClassTreeNode>map(_psiClasses, _function);\n    Iterable<AbstractTreeNode> _filter = Iterables.<AbstractTreeNode>filter(_map, AbstractTreeNode.class);\n    return IterableExtensions.<AbstractTreeNode>toList(_filter);\n  }","id":75005,"modified_method":"@Override\n  public Collection<AbstractTreeNode> getChildrenImpl() {\n    List<AbstractTreeNode> _xblockexpression = null;\n    {\n      final ViewSettings viewSettings = this.getSettings();\n      XtendFileImpl _xtendFile = this.getXtendFile();\n      Iterable<PsiClass> _psiClasses = this._jvmPsiClasses.getPsiClasses(_xtendFile);\n      final Function1<PsiClass, ClassTreeNode> _function = new Function1<PsiClass, ClassTreeNode>() {\n        @Override\n        public ClassTreeNode apply(final PsiClass psiClass) {\n          Project _project = XtendFileTreeNode.this.getProject();\n          return new ClassTreeNode(_project, psiClass, viewSettings);\n        }\n      };\n      Iterable<ClassTreeNode> _map = IterableExtensions.<PsiClass, ClassTreeNode>map(_psiClasses, _function);\n      Iterable<AbstractTreeNode> _filter = Iterables.<AbstractTreeNode>filter(_map, AbstractTreeNode.class);\n      _xblockexpression = IterableExtensions.<AbstractTreeNode>toList(_filter);\n    }\n    return _xblockexpression;\n  }","commit_id":"8af85aa2c45607192f1ff7b9c08b02dd72bf6d03","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<JCStatement> getResult() {\n            List<JCStatement> stmts = transformList(conditions);\n            ListBuffer<JCStatement> result = ListBuffer.lb();\n            result.append(makeVar(ifVar, make().Type(syms().booleanType), makeBoolean(false)));\n            result.appendList(varDecls);\n            result.appendList(stmts);\n            return result.toList();   \n        }","id":75006,"modified_method":"public List<JCStatement> getResult() {\n            List<JCStatement> res;\n           if (conditions.size() == 1) {\n                final Cond transformedCond = transformCondition(conditions.get(0), thenPart);\n                JCExpression test = transformedCond.makeTest();\n                Substitution subs = getSubstitution(transformedCond);\n                JCBlock thenBlock = makeThenBlock(transformedCond, thenPart, subs);\n                if (subs != null) {\n                    subs.remove();\n                }\n                JCStatement cond1 = make().WhileLoop(\n                        makeLetExpr(make().TypeIdent(TypeTags.BOOLEAN), \n                                test), \n                                thenBlock);\n                if (transformedCond.makeTestVarDecl(0, false) != null) {\n                    res = List.<JCStatement> of(transformedCond.makeTestVarDecl(0, false), cond1);\n                } else {\n                    res = List.<JCStatement> of(cond1);\n                }\n            } else {\n                List<JCStatement> stmts = transformList(conditions);\n                ListBuffer<JCStatement> result = ListBuffer.lb();\n                result.appendList(varDecls);\n                result.appendList(stmts);\n                res =  List.<JCStatement>of(make().WhileLoop(makeBoolean(true), \n                        make().Block(0, result.toList())));\n            }\n            return res;\n        }","commit_id":"113a9831f10a436519668571a9d99e02f0900ea7","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"List<JCStatement> transform(Tree.WhileStatement stmt) {\n        Name tempForFailVariable = currentForFailVariable;\n        currentForFailVariable = null;\n        final List<JCStatement> res;\n        Tree.Block thenPart = stmt.getWhileClause().getBlock();\n        java.util.List<Condition> conditions = stmt.getWhileClause().getConditionList().getConditions();\n        if (conditions.size() == 1) {\n            final Cond transformedCond = transformCondition(conditions.get(0), thenPart);\n            JCStatement cond1 = make().WhileLoop(makeLetExpr(make().TypeIdent(TypeTags.BOOLEAN), transformedCond.makeTest()), makeThenBlock(transformedCond, thenPart));\n            if (transformedCond.makeTestVarDecl(0, false) != null) {\n                res = List.<JCStatement> of(transformedCond.makeTestVarDecl(0, false), cond1);\n            } else {\n                res = List.<JCStatement> of(cond1);\n            }\n        } else {\n            List<JCStatement> loopBody = new WhileCondList(conditions, thenPart).getResult();\n            JCStatement cond1 = make().WhileLoop(makeBoolean(true), \n                    make().Block(0, loopBody));\n            res = List.<JCStatement> of(cond1);\n            \n        }\n        currentForFailVariable = tempForFailVariable;\n        \n        return res;\n    }","id":75007,"modified_method":"List<JCStatement> transform(Tree.WhileStatement stmt) {\n        Name tempForFailVariable = currentForFailVariable;\n        currentForFailVariable = null;\n        final List<JCStatement> res;\n        Tree.Block thenPart = stmt.getWhileClause().getBlock();\n        java.util.List<Condition> conditions = stmt.getWhileClause().getConditionList().getConditions();\n        res =  new WhileCondList(conditions, thenPart).getResult();    \n        currentForFailVariable = tempForFailVariable;\n        \n        return res;\n    }","commit_id":"113a9831f10a436519668571a9d99e02f0900ea7","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n        protected List<JCStatement> transformInnermost(Condition condition) {\n            Cond transformedCond = transformCondition(condition, thenPart);\n            JCBlock thenBlock = makeThenBlock(transformedCond, thenPart);\n            return transformCommon(transformedCond, thenBlock.getStatements());\n        }","id":75008,"modified_method":"@Override\n        protected List<JCStatement> transformInnermost(Condition condition) {\n            Cond transformedCond = transformCondition(condition, thenPart);\n            // Note: The innermost test happens outside the substitution scope\n            JCExpression test = transformedCond.makeTest();\n            Substitution subs = getSubstitution(transformedCond);\n            List<JCStatement> stmts = makeThenBlock(transformedCond, thenPart, null).getStatements();\n            stmts = transformCommon(transformedCond, test, stmts, make().Break(null));\n            if (subs != null) {\n                subs.remove();\n            }\n            return stmts;\n        }","commit_id":"113a9831f10a436519668571a9d99e02f0900ea7","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"protected List<JCStatement> transformIntermediate(Condition condition, java.util.List<Condition> rest) {\n            return transformCommon(transformCondition(condition, null), transformList(rest));\n        }","id":75009,"modified_method":"protected List<JCStatement> transformIntermediate(Condition condition, java.util.List<Condition> rest) {\n            Cond intermediate = transformCondition(condition, null);\n            JCExpression test = intermediate.makeTest();\n            Substitution subs = getSubstitution(intermediate);\n            List<JCStatement> stmts = transformList(rest);\n            stmts = transformCommon(intermediate, test, stmts, make().Break(null));\n            if (subs != null) {\n                subs.remove();\n            }\n            return stmts;\n        }","commit_id":"113a9831f10a436519668571a9d99e02f0900ea7","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"protected List<JCStatement> transformCommon(Cond transformedCond, List<JCStatement> stmts) {\n            if (transformedCond.makeTestVarDecl(0, true) != null) {\n                varDecls.append(transformedCond.makeTestVarDecl(0, true));\n            }\n            if (transformedCond.hasAliasedVariable()) {\n                JCVariableDecl resultVarDecl = make().VarDef(make().Modifiers(Flags.FINAL), \n                        transformedCond.getVariableName().asName(),\n                        transformedCond.makeTypeExpr(), null);\n                varDecls.append(resultVarDecl);\n                stmts = stmts.prepend(make().Exec(make().Assign(transformedCond.getVariableName().makeIdent(), transformedCond.makeResultExpr())));\n            }\n            stmts = List.<JCStatement>of(make().If(\n                    transformedCond.makeTest(), \n                    make().Block(0, stmts), \n                    make().Break(null)));\n            return stmts;\n        }","id":75010,"modified_method":"protected List<JCStatement> transformCommon(Cond transformedCond, JCExpression test, List<JCStatement> stmts, JCStatement elseBlock) {\n            if (transformedCond.makeTestVarDecl(0, false) != null) {\n                varDecls.append(transformedCond.makeTestVarDecl(0, false));\n            }\n            if (transformedCond.hasResultDecl()) {\n                JCVariableDecl resultVarDecl = make().VarDef(make().Modifiers(Flags.FINAL), \n                        transformedCond.getVariableName().asName(), \n                        transformedCond.makeTypeExpr(), \n                        transformedCond.makeResultExpr());\n                stmts = stmts.prepend(resultVarDecl);\n            }\n            JCStatement elsePart = elseBlock;\n            stmts = List.<JCStatement>of(make().If(\n                    test, \n                    make().Block(0, stmts), \n                    elsePart));\n            return stmts;\n        }","commit_id":"113a9831f10a436519668571a9d99e02f0900ea7","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private void fillFilterCombos(ArrayList<FieldMapping> mappings){\n\t\tArrayList<String> fieldList = new ArrayList<String>();\n\t\tfor(FieldMapping map : mappings)\n\t\t\tif (!fieldList.contains(map.source_field))\n\t\t\t\tfieldList.add(map.source_field);\n\n\t\tString [] fieldStringList = new String[fieldList.size()];\n\t\tfieldStringList = fieldList.toArray(fieldStringList);\n\t\tArrays.sort(fieldStringList,String.CASE_INSENSITIVE_ORDER);\n\t\t\n\t\tfilterViewColinf[0].setComboValues(new String [] {\"\", \"NOT\", \"OR\"});\n\t\tfilterViewColinf[1].setComboValues(fieldStringList);\n\t\tfilterViewColinf[2].setComboValues(new String [] {\"=\", \"!=\", \">\", \">=\", \"<\", \"<=\", \"like\", \"ilike\", \"is null\", \"is not null\", \"in\", \"not in\", \"child_of\", \"parent_left\", \"parent_right\"});\n\t\ttableViewFilter.optWidth(true);\n\t}","id":75011,"modified_method":"private void fillFilterCombos(ArrayList<FieldMapping> mappings){\n\t\tArrayList<String> fieldList = new ArrayList<String>();\n\t\tfor(FieldMapping map : mappings)\n\t\t\tif (!fieldList.contains(map.source_field))\n\t\t\t\tfieldList.add(map.source_field);\n\n\t\tString [] fieldStringList = new String[fieldList.size()];\n\t\tfieldStringList = fieldList.toArray(fieldStringList);\n\t\tArrays.sort(fieldStringList,String.CASE_INSENSITIVE_ORDER);\n\t\t\n\t\tfilterViewColinf[0].setComboValues(FilterHelper.getOperators());\n\t\tfilterViewColinf[1].setComboValues(fieldStringList);\n\t\tfilterViewColinf[2].setComboValues(FilterHelper.getComparators());\n\t\ttableViewFilter.optWidth(true);\n\t}","commit_id":"f92944aa483d357fc4d064bbf18d85f7a0a28a8a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void StartSession() throws Exception{\n\t\topenERPConnection.startSession();\n\t}","id":75012,"modified_method":"public void StartSession() throws Exception{\n\t\topenERPConnection.startSession();\n\t\t\n\t\t// Don't automatically filter out active items in any steps \n\t\topenERPConnection.getContext().setActiveTest(false);\n\t}","commit_id":"6ba55c89ce5e5325d4a44a5527b4ed937b7f7ba5","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean processRow(final StepMetaInterface smi, final StepDataInterface sdi) throws KettleException {\n\t\tthis.logBasic(\"Getting Field Row Meta.\");\n\n\t\tthis.logBasic(\"Getting Rows.\");\n\t\tif (first == true){\n\t\t\tfirst = false;\n\t\t\ttry {\n\t\t\t\tfinal RowMetaInterface rowMeta = data.helper.getFieldRowMeta(meta.getMappings());\n\t\t\t\t\n\t\t\t\tArrayList<FieldMapping> allFields = data.helper.getDefaultFieldMappings(meta.getModelName());\n\t\t\t\t\n\t\t\t\t// Building search filter\n\t\t\t\tFilterCollection filter = new FilterCollection();\n\t\t\t\tfor(int i = 0; i < meta.getFilterList().size(); i++){\n\t\t\t\t\tReadFilter filterItem = meta.getFilterList().get(i);\n\t\t\t\t\t\n\t\t\t\t\tFieldMapping fld = null;\n\t\t\t\t\tfor (int j = 0; j < allFields.size(); j++)\n\t\t\t\t\t\tif (allFields.get(j).source_field.equals(filterItem.field_name) \n\t\t\t\t\t\t\t\t&& allFields.get(j).source_index <= 0){\n\t\t\t\t\t\t\tfld = allFields.get(j);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tObject value = filterItem.value;\n\t\t\t\t\t\n\t\t\t\t\t// Fix the value type if required\n\t\t\t\t\tif (fld == null)\n\t\t\t\t\t\tvalue = filterItem.value;\n\t\t\t\t\telse if (fld.target_field_type == ValueMetaInterface.TYPE_BOOLEAN){\n\t\t\t\t\t\tchar firstchar = filterItem.value.toLowerCase().charAt(0);\n\t\t\t\t\t\tif (firstchar == '1' || firstchar == 'y' || firstchar == 't')\n\t\t\t\t\t\t\tvalue = true;\n\t\t\t\t\t\telse if (firstchar == '0' || firstchar == 'n' || firstchar == 'f') \n\t\t\t\t\t\t\tvalue = false;\n\t\t\t\t\t\telse throw new Exception (\"Unknown boolean \" + filterItem.value);\n\t\t\t\t\t}\n\t\t\t\t\telse if (fld.target_field_type == ValueMetaInterface.TYPE_NUMBER)\n\t\t\t\t\t\tvalue = Double.parseDouble(filterItem.value);\n\t\t\t\t\telse if (fld.target_field_type == ValueMetaInterface.TYPE_INTEGER)\n\t\t\t\t\t\tvalue = Integer.parseInt(filterItem.value);\n\t\t\t\t\t\n\t\t\t\t\tfilter.add(filterItem.field_name, filterItem.operator, value);\n\t\t\t\t\t\n\t\t\t\t\tthis.logBasic(\"Setting filter: [\" + filterItem.field_name + \",\" + filterItem.operator + \",\" + value.toString() + \"]\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdata.helper.getModelData(meta.getModelName(), filter, meta.getReadBatchSize(), meta.getMappings(), new RowsReadListener() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void rowsRead(RowCollection rows) {\n\t\t\t\t\t\tfor (Row row : rows){\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tputRow(row,rowMeta);\n\t\t\t\t\t\t\t} catch (KettleStepException e) {\n\t\t\t\t\t\t\t\tlogError(\"An error occurred, processing will be stopped: \" + e.getMessage());\n\t\t\t\t\t\t\t\tsetErrors(1);\n\t\t\t\t\t\t\t\tstopAll();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tincrementLinesInput();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new KettleException(e.getMessage());\n\t\t\t}\n\t\t}\n\t\tthis.logBasic(\"Process Ended.\");\n\t\tsetOutputDone();\n\t\treturn false;\n\t}","id":75013,"modified_method":"public boolean processRow(final StepMetaInterface smi, final StepDataInterface sdi) throws KettleException {\n\t\tthis.logBasic(\"Getting Field Row Meta.\");\n\n\t\tthis.logBasic(\"Getting Rows.\");\n\t\tif (first == true){\n\t\t\tfirst = false;\n\t\t\ttry {\n\t\t\t\tfinal RowMetaInterface rowMeta = data.helper.getFieldRowMeta(meta.getMappings());\n\t\t\t\t\n\t\t\t\tArrayList<FieldMapping> allFields = data.helper.getDefaultFieldMappings(meta.getModelName());\n\t\t\t\t\n\t\t\t\t// Building search filter\n\t\t\t\tFilterCollection filter = new FilterCollection();\n\t\t\t\tfor(int i = 0; i < meta.getFilterList().size(); i++){\n\t\t\t\t\tReadFilter filterItem = meta.getFilterList().get(i);\n\t\t\t\t\t\n\t\t\t\t\t// Handle logical operators\n\t\t\t\t\tif (filterItem.operator.equalsIgnoreCase(\"not\"))\n\t\t\t\t\t\tfilter.add(FilterOperator.NOT);\n\t\t\t\t\telse if (filterItem.operator.equalsIgnoreCase(\"or\"))\n\t\t\t\t\t\tfilter.add(FilterOperator.OR);\n\t\t\t\t\t\n\t\t\t\t\t// Get the source field to filter on\n\t\t\t\t\tFieldMapping fld = null;\n\t\t\t\t\tfor (int j = 0; j < allFields.size(); j++)\n\t\t\t\t\t\tif (allFields.get(j).source_field.equals(filterItem.field_name) \n\t\t\t\t\t\t\t\t&& allFields.get(j).source_index <= 0){\n\t\t\t\t\t\t\tfld = allFields.get(j);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tString fieldName = filterItem.field_name;\n\t\t\t\t\tString operator = filterItem.comparator;\n\t\t\t\t\tObject value = filterItem.value;\n\t\t\t\t\t\n\t\t\t\t\t// Fix the value type if required\n\t\t\t\t\tif (fld == null)\n\t\t\t\t\t\tvalue = filterItem.value;\n\t\t\t\t\telse if (operator.equals(\"is null\")){\n\t\t\t\t\t\toperator = \"=\";\n\t\t\t\t\t\tvalue = false;\n\t\t\t\t\t}\n\t\t\t\t\telse if (operator.equals(\"is not null\")){\n\t\t\t\t\t\toperator = \"!=\";\n\t\t\t\t\t\tvalue = false;\n\t\t\t\t\t}\n\t\t\t\t\telse if (fld.target_field_type == ValueMetaInterface.TYPE_BOOLEAN){\n\t\t\t\t\t\tchar firstchar = filterItem.value.toLowerCase().charAt(0);\n\t\t\t\t\t\tif (firstchar == '1' || firstchar == 'y' || firstchar == 't')\n\t\t\t\t\t\t\tvalue = true;\n\t\t\t\t\t\telse if (firstchar == '0' || firstchar == 'n' || firstchar == 'f') \n\t\t\t\t\t\t\tvalue = false;\n\t\t\t\t\t\telse throw new Exception (\"Unknown boolean \" + filterItem.value);\n\t\t\t\t\t}\n\t\t\t\t\telse if (fld.target_field_type == ValueMetaInterface.TYPE_NUMBER)\n\t\t\t\t\t\tvalue = Double.parseDouble(filterItem.value);\n\t\t\t\t\telse if (fld.target_field_type == ValueMetaInterface.TYPE_INTEGER)\n\t\t\t\t\t\tvalue = Integer.parseInt(filterItem.value);\n\t\t\t\t\t\n\t\t\t\t\tfilter.add(fieldName, operator, value);\n\t\t\t\t\t\n\t\t\t\t\tthis.logBasic(\"Setting filter: [\" + filterItem.field_name + \",\" + filterItem.comparator + \",\" + value.toString() + \"]\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdata.helper.getModelData(meta.getModelName(), filter, meta.getReadBatchSize(), meta.getMappings(), new RowsReadListener() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void rowsRead(RowCollection rows) {\n\t\t\t\t\t\tfor (Row row : rows){\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tputRow(row,rowMeta);\n\t\t\t\t\t\t\t} catch (KettleStepException e) {\n\t\t\t\t\t\t\t\tlogError(\"An error occurred, processing will be stopped: \" + e.getMessage());\n\t\t\t\t\t\t\t\tsetErrors(1);\n\t\t\t\t\t\t\t\tstopAll();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tincrementLinesInput();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new KettleException(e.getMessage());\n\t\t\t}\n\t\t}\n\t\tthis.logBasic(\"Process Ended.\");\n\t\tsetOutputDone();\n\t\treturn false;\n\t}","commit_id":"6ba55c89ce5e5325d4a44a5527b4ed937b7f7ba5","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void fillFilterCombos(ArrayList<FieldMapping> mappings){\n\t\tArrayList<String> fieldList = new ArrayList<String>();\n\t\tfor(FieldMapping map : mappings)\n\t\t\tif (!fieldList.contains(map.source_field))\n\t\t\t\tfieldList.add(map.source_field);\n\n\t\tString [] fieldStringList = new String[fieldList.size()];\n\t\tfieldStringList = fieldList.toArray(fieldStringList);\n\t\tArrays.sort(fieldStringList,String.CASE_INSENSITIVE_ORDER);\n\t\t\n\t\tfilterViewColinf[0].setComboValues(fieldStringList);\n\t\tfilterViewColinf[1].setComboValues(new String [] {\"=\",\"<\", \"<=\", \">\", \">=\",\"like\", \"ilike\"});\n\t\ttableViewFilter.optWidth(true);\n\t}","id":75014,"modified_method":"private void fillFilterCombos(ArrayList<FieldMapping> mappings){\n\t\tArrayList<String> fieldList = new ArrayList<String>();\n\t\tfor(FieldMapping map : mappings)\n\t\t\tif (!fieldList.contains(map.source_field))\n\t\t\t\tfieldList.add(map.source_field);\n\n\t\tString [] fieldStringList = new String[fieldList.size()];\n\t\tfieldStringList = fieldList.toArray(fieldStringList);\n\t\tArrays.sort(fieldStringList,String.CASE_INSENSITIVE_ORDER);\n\t\t\n\t\tfilterViewColinf[0].setComboValues(new String [] {\"\", \"NOT\", \"OR\"});\n\t\tfilterViewColinf[1].setComboValues(fieldStringList);\n\t\tfilterViewColinf[2].setComboValues(new String [] {\"=\", \"!=\", \">\", \">=\", \"<\", \"<=\", \"like\", \"ilike\", \"is null\", \"is not null\", \"in\", \"not in\", \"child_of\", \"parent_left\", \"parent_right\"});\n\t\ttableViewFilter.optWidth(true);\n\t}","commit_id":"6ba55c89ce5e5325d4a44a5527b4ed937b7f7ba5","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private boolean SaveToMeta(OpenERPObjectInputMeta targetMeta) {\n\t\tstepname = textStepName.getText();\n\n\t\tDatabaseMeta dbMeta = transMeta.findDatabase(addConnectionLine.getText());\n\t\tif (dbMeta != null) {\n\t\t\ttry {\n\t\t\t\tnew OpenERPObjectInputData(dbMeta);\n\t\t\t} catch (KettleException e) {\n\t\t\t\tnew ErrorDialog(shell, BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.ConnectionTypeErrorTitle\"), BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.ConnectionTypeErrorString\"), e);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tint readBatchSize = 0;\n\t\ttry{\n\t\t\treadBatchSize = Integer.parseInt(textReadBatchSize.getText());\n\t\t}\n\t\tcatch (NumberFormatException e){\n\t\t\tnew ErrorDialog(shell, BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.ParseErrorTitle\"), BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.ParseErrorString\", textReadBatchSize.getText()), e);\n\t\t\treturn false;\n\t\t}\n\n\n\t\tArrayList<FieldMapping> mappings = new ArrayList<FieldMapping>();\n\t\tfor (int i = 0; i < tableViewFields.table.getItemCount(); i++) {\n\t\t\t\n\t\t\tFieldMapping map = null;\n\t\t\t\n\t\t\tfor (FieldMapping sourceMap : sourceListMapping){\n\t\t\t\tif (sourceMap.target_field_label.equals(tableViewFields.table.getItem(i).getText(1))\n\t\t\t\t\t\t&&sourceMap.target_model.equals(tableViewFields.table.getItem(i).getText(2))\n\t\t\t\t\t\t&& sourceMap.target_field.equals(tableViewFields.table.getItem(i).getText(3)))\n\t\t\t\t\tmap = sourceMap.Clone();\n\t\t\t}\n\t\t\t\n\t\t\tif (map == null){\n\t\t\t\tnew ErrorDialog(shell, BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.MappingErrorTitle\"), BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.MappingErrorTitle\"), new Exception(BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.MappingErrorString\", tableViewFields.table.getItem(i).getText(2))));\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tmappings.add(map);\n\n\t\t}\n\t\t\n\t\tArrayList<ReadFilter> filters = new ArrayList<ReadFilter>();\n\t\tfor (int i = 0; i < tableViewFilter.table.getItemCount(); i++) {\n\t\t\t\n\t\t\tReadFilter filter = new ReadFilter();\n\t\t\tfilter.field_name = tableViewFilter.table.getItem(i).getText(1);\n\t\t\tfilter.operator = tableViewFilter.table.getItem(i).getText(2);\n\t\t\tfilter.value = tableViewFilter.table.getItem(i).getText(3);\n\t\t\t\n\t\t\tif (filter.field_name != \"\")\n\t\t\t\tfilters.add(filter);\n\t\t}\n\n\t\ttargetMeta.setDatabaseMeta(transMeta.findDatabase(addConnectionLine.getText()));\n\t\ttargetMeta.setModelName(comboModelName.getText());\n\t\ttargetMeta.setReadBatchSize(readBatchSize);\n\t\ttargetMeta.setMappings(mappings);\n\t\ttargetMeta.setFilterList(filters);\n\t\ttargetMeta.setChanged(true);\n\n\t\treturn true;\n\n\t}","id":75015,"modified_method":"private boolean SaveToMeta(OpenERPObjectInputMeta targetMeta) {\n\t\tstepname = textStepName.getText();\n\n\t\tDatabaseMeta dbMeta = transMeta.findDatabase(addConnectionLine.getText());\n\t\tif (dbMeta != null) {\n\t\t\ttry {\n\t\t\t\tnew OpenERPObjectInputData(dbMeta);\n\t\t\t} catch (KettleException e) {\n\t\t\t\tnew ErrorDialog(shell, BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.ConnectionTypeErrorTitle\"), BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.ConnectionTypeErrorString\"), e);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tint readBatchSize = 0;\n\t\ttry{\n\t\t\treadBatchSize = Integer.parseInt(textReadBatchSize.getText());\n\t\t}\n\t\tcatch (NumberFormatException e){\n\t\t\tnew ErrorDialog(shell, BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.ParseErrorTitle\"), BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.ParseErrorString\", textReadBatchSize.getText()), e);\n\t\t\treturn false;\n\t\t}\n\n\n\t\tArrayList<FieldMapping> mappings = new ArrayList<FieldMapping>();\n\t\tfor (int i = 0; i < tableViewFields.table.getItemCount(); i++) {\n\t\t\t\n\t\t\tFieldMapping map = null;\n\t\t\t\n\t\t\tfor (FieldMapping sourceMap : sourceListMapping){\n\t\t\t\tif (sourceMap.target_field_label.equals(tableViewFields.table.getItem(i).getText(1))\n\t\t\t\t\t\t&&sourceMap.target_model.equals(tableViewFields.table.getItem(i).getText(2))\n\t\t\t\t\t\t&& sourceMap.target_field.equals(tableViewFields.table.getItem(i).getText(3)))\n\t\t\t\t\tmap = sourceMap.Clone();\n\t\t\t}\n\t\t\t\n\t\t\tif (map == null){\n\t\t\t\tnew ErrorDialog(shell, BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.MappingErrorTitle\"), BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.MappingErrorTitle\"), new Exception(BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.MappingErrorString\", tableViewFields.table.getItem(i).getText(2))));\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tmappings.add(map);\n\n\t\t}\n\t\t\n\t\tArrayList<ReadFilter> filters = new ArrayList<ReadFilter>();\n\t\tfor (int i = 0; i < tableViewFilter.table.getItemCount(); i++) {\n\t\t\t\n\t\t\tReadFilter filter = new ReadFilter();\n\t\t\tfilter.operator = tableViewFilter.table.getItem(i).getText(1);\n\t\t\tfilter.field_name = tableViewFilter.table.getItem(i).getText(2);\n\t\t\tfilter.comparator = tableViewFilter.table.getItem(i).getText(3);\n\t\t\tfilter.value = tableViewFilter.table.getItem(i).getText(4);\n\t\t\t\n\t\t\tif (filter.field_name != \"\")\n\t\t\t\tfilters.add(filter);\n\t\t}\n\n\t\ttargetMeta.setDatabaseMeta(transMeta.findDatabase(addConnectionLine.getText()));\n\t\ttargetMeta.setModelName(comboModelName.getText());\n\t\ttargetMeta.setReadBatchSize(readBatchSize);\n\t\ttargetMeta.setMappings(mappings);\n\t\ttargetMeta.setFilterList(filters);\n\t\ttargetMeta.setChanged(true);\n\n\t\treturn true;\n\n\t}","commit_id":"6ba55c89ce5e5325d4a44a5527b4ed937b7f7ba5","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private String getLocalizedFilterColumn(int columnIndex) {\n\t\tswitch (columnIndex) {\n\t\tcase 0:\n\t\t\treturn BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.TableViewFilterField\");\n\t\tcase 1:\n\t\t\treturn BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.TableViewFilterOperator\");\n\t\tcase 2:\n\t\t\treturn BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.TableViewFilterValue\");  \n\t\tdefault:\n\t\t\treturn \"\";\n\t\t}\n\t}","id":75016,"modified_method":"private String getLocalizedFilterColumn(int columnIndex) {\n\t\tswitch (columnIndex) {\n\t\t\n\t\tcase 0:\n\t\t\treturn BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.TableViewFilterOperator\");\n\t\tcase 1:\n\t\t\treturn BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.TableViewFilterField\");\n\t\tcase 2:\n\t\t\treturn BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.TableViewFilterComparator\");\n\t\tcase 3:\n\t\t\treturn BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.TableViewFilterValue\");  \n\t\tdefault:\n\t\t\treturn \"\";\n\t\t}\n\t}","commit_id":"6ba55c89ce5e5325d4a44a5527b4ed937b7f7ba5","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void fillLocalizationData() {\n\t\tshell.setText(BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.Title\"));\n\t\tlabelStepName.setText(BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.StepName\"));\n\t\tlabelModelName.setText(BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.ModelName\"));\n\t\tlabelReadBatchSize.setText(BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.ReadBatchSize\"));\n\t\tlabelFilter.setText(BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.LabelFilterSpecify\"));\n\t\tlabelFields.setText(BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.LabelSpecifyFields\"));\n\t\tbuttonGetFields.setText(BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.ButtonGetFields\"));\n\t}","id":75017,"modified_method":"private void fillLocalizationData() {\n\t\tshell.setText(BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.Title\"));\n\t\tlabelStepName.setText(BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.StepName\"));\n\t\tlabelModelName.setText(BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.ModelName\"));\n\t\tlabelReadBatchSize.setText(BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.ReadBatchSize\"));\n\t\tlabelFilter.setText(BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.LabelFilterSpecify\"));\n\t\tlabelFields.setText(BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.LabelSpecifyFields\"));\n\t\tbuttonHelpFilter.setText(BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.ButtonFilterHelp\"));\n\t\tbuttonGetFields.setText(BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.ButtonGetFields\"));\n\t}","commit_id":"6ba55c89ce5e5325d4a44a5527b4ed937b7f7ba5","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Override\n\tpublic String open() {\n\n\t\tModifyListener lsMod = new ModifyListener() {\n\t\t\tpublic void modifyText(ModifyEvent e) {\n\t\t\t\tmeta.setChanged();\n\t\t\t}\n\t\t};\n\n\t\tfinal Display display = getParent().getDisplay();\n\t\tshell = new Shell(getParent(), SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\n\t\tprops.setLook(shell);\n\t\tsetShellImage(shell, meta);\n\t\tFormLayout formLayout = new FormLayout();\n\t\tformLayout.marginWidth = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\tFormData fd;\n\n\t\tlabelStepName = new Label(shell, SWT.RIGHT);\n\t\tfd = new FormData();\n\t\tfd.left = new FormAttachment(0, 0);\n\t\tfd.right = new FormAttachment(middle, -margin);\n\t\tfd.top = new FormAttachment(0, margin);\n\t\tlabelStepName.setLayoutData(fd);\n\n\t\ttextStepName = new Text(shell, SWT.BORDER);\n\t\tfd = new FormData();\n\t\tfd.left = new FormAttachment(middle, 0);\n\t\tfd.right = new FormAttachment(100, 0);\n\t\tfd.top = new FormAttachment(0, margin);\n\t\ttextStepName.setLayoutData(fd);\n\n\t\taddConnectionLine = addConnectionLine(shell, textStepName, Const.MIDDLE_PCT, margin);\n\n\t\tlabelModelName = new Label(shell, SWT.RIGHT);\n\t\tfd = new FormData();\n\t\tfd.left = new FormAttachment(0, 0);\n\t\tfd.right = new FormAttachment(middle, -margin);\n\t\tfd.top = new FormAttachment(addConnectionLine, margin);\n\t\tlabelModelName.setLayoutData(fd);\n\n\t\tcomboModelName = new CCombo(shell, SWT.BORDER);\n\t\tfd = new FormData();\n\t\tfd.left = new FormAttachment(middle, 0);\n\t\tfd.right = new FormAttachment(100, 0);\n\t\tfd.top = new FormAttachment(addConnectionLine, margin);\n\t\tcomboModelName.setLayoutData(fd);\n\n\t\tlabelReadBatchSize = new Label(shell, SWT.RIGHT);\n\t\tfd = new FormData();\n\t\tfd.left = new FormAttachment(0, 0);\n\t\tfd.right = new FormAttachment(middle, -margin);\n\t\tfd.top = new FormAttachment(comboModelName, margin);\n\t\tlabelReadBatchSize.setLayoutData(fd);\n\n\t\ttextReadBatchSize = new Text(shell, SWT.BORDER);\n\t\tfd = new FormData();\n\t\tfd.left = new FormAttachment(middle, 0);\n\t\tfd.right = new FormAttachment(100, 0);\n\t\tfd.top = new FormAttachment(comboModelName, margin);\n\t\ttextReadBatchSize.setLayoutData(fd);\n\t\t\n\t\tlabelFilter = new Label(shell, SWT.NONE);\n\t\tfd = new FormData();\n\t\tfd.left = new FormAttachment(0, 0);\n\t\tfd.top = new FormAttachment(textReadBatchSize, margin);\n\t\tlabelFilter.setLayoutData(fd);\n\t\t\n\t\tfilterViewColinf = new ColumnInfo[] { \n\t\t\t\tnew ColumnInfo(getLocalizedFilterColumn(0), ColumnInfo.COLUMN_TYPE_CCOMBO, new String[] { \"\" }, false), \n\t\t\t\tnew ColumnInfo(getLocalizedFilterColumn(1), ColumnInfo.COLUMN_TYPE_CCOMBO, new String[] { \"\" }, false),\n\t\t\t\tnew ColumnInfo(getLocalizedFilterColumn(2), ColumnInfo.COLUMN_TYPE_TEXT, false, false)};\n\t\t\n\t\ttableViewFilter = new TableView(null, shell, SWT.MULTI | SWT.BORDER, filterViewColinf, 0, true, lsMod, props);\n\t\ttableViewFilter.setReadonly(false);\n\t\ttableViewFilter.setSortable(false);\n\t\tfd = new FormData();\n\t\tfd.left = new FormAttachment(0, margin);\n\t\tfd.top = new FormAttachment(labelFilter, 3 * margin);\n\t\tfd.right = new FormAttachment(100, -150);\n\t\tfd.bottom = new FormAttachment(labelFilter, 200);\n\t\ttableViewFilter.setLayoutData(fd);\n\n\t\tlabelFields = new Label(shell, SWT.NONE);\n\t\tfd = new FormData();\n\t\tfd.left = new FormAttachment(0, 0);\n\t\tfd.top = new FormAttachment(tableViewFilter, margin);\n\t\tlabelFields.setLayoutData(fd);\n\t\t\n\t\tColumnInfo[] colinf = new ColumnInfo[] { \n\t\t\t\tnew ColumnInfo(getLocalizedColumn(0), ColumnInfo.COLUMN_TYPE_TEXT, false, true), \n\t\t\t\tnew ColumnInfo(getLocalizedColumn(1), ColumnInfo.COLUMN_TYPE_TEXT, false, true),\n\t\t\t\tnew ColumnInfo(getLocalizedColumn(2), ColumnInfo.COLUMN_TYPE_TEXT, false, true)};\n\n\t\ttableViewFields = new TableView(null, shell, SWT.FILL | SWT.BORDER, colinf, 0, true, lsMod, props);\n\t\ttableViewFields.setSize(477, 280);\n\t\ttableViewFields.setBounds(5, 125, 477, 280);\n\t\ttableViewFields.setReadonly(false);\n\t\ttableViewFields.setSortable(true);\n\t\tfd = new FormData();\n\t\tfd.left = new FormAttachment(0, margin);\n\t\tfd.top = new FormAttachment(labelFields, 3 * margin);\n\t\tfd.right = new FormAttachment(100, -150);\n\t\tfd.bottom = new FormAttachment(100, -50);\n\t\ttableViewFields.setLayoutData(fd);\n\t\t\n\t\tbuttonGetFields = new Button(shell, SWT.NONE);\n\t\tfd = new FormData();\n\t\tfd.left = new FormAttachment(tableViewFields, margin);\n\t\tfd.top = new FormAttachment(labelFields, 3 * margin);\n\t\tfd.right = new FormAttachment(100, 0);\n\t\tbuttonGetFields.setLayoutData(fd);\n\t\t\n\t\tbuttonOk = new Button(shell, SWT.CENTER);\n\t\tbuttonCancel = new Button(shell, SWT.CENTER);\n\t\tbuttonPreview = new Button(shell, SWT.CENTER);\n\t\tbuttonOk.setText(BaseMessages.getString(\"System.Button.OK\"));\n\t\tbuttonPreview.setText(BaseMessages.getString(\"System.Button.Preview\"));\n\t\tbuttonCancel.setText(BaseMessages.getString(\"System.Button.Cancel\"));\n\t\tsetButtonPositions(new Button[] { buttonOk, buttonPreview, buttonCancel }, margin, null);\n\n\t\taddConnectionLine.addSelectionListener(new SelectionAdapter() {\n\t\t\tpublic void widgetSelected(SelectionEvent e) {\n\t\t\t\tfillModelCombo();\n\t\t\t}\n\t\t});\n\t\tcomboModelName.addSelectionListener(new SelectionAdapter() {\n\t\t\tpublic void widgetSelected(SelectionEvent e) {\n\t\t\t\tfillFilterCombos();\n\t\t\t}\n\t\t});\n\t\tcomboModelName.addFocusListener(new FocusListener() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void focusLost(FocusEvent arg0) {\n\t\t\t\tfillFilterCombos();\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void focusGained(FocusEvent arg0) {\n\t\t\t}\n\t\t});\n\t\t\n\t\tcomboModelName.addSelectionListener(new SelectionAdapter() {\n\t\t\tpublic void widgetSelected(SelectionEvent e) {\n\t\t\t\tfillFilterCombos();\n\t\t\t}\n\t\t});\n\t\tbuttonGetFields.addSelectionListener(new SelectionAdapter() {\n\t\t\tpublic void widgetSelected(SelectionEvent e) {\n\t\t\t\tgetFields();\n\t\t\t}\n\t\t});\n\t\tbuttonCancel.addSelectionListener(new SelectionAdapter() {\n\t\t\tpublic void widgetSelected(SelectionEvent e) {\n\t\t\t\tcancel();\n\t\t\t}\n\t\t});\n\t\tbuttonPreview.addSelectionListener(new SelectionAdapter() {\n\t\t\tpublic void widgetSelected(SelectionEvent e) {\n\t\t\t\tpreview();\n\t\t\t}\n\t\t});\n\t\tbuttonOk.addSelectionListener(new SelectionAdapter() {\n\t\t\tpublic void widgetSelected(SelectionEvent e) {\n\t\t\t\tok();\n\t\t\t}\n\t\t});\n\t\t\n\t\t// \n\t\t// Search the fields in the background\n\t\t//\n\t\tfinal Runnable runnable = new Runnable()\n\t\t{\n\t\t\tpublic void run()\n\t\t\t{\n\t\t\t\tfillModelCombo();\n\t\t\t}\n\t\t};\n\t\tdisplay.asyncExec(runnable);\n\n\t\tthis.fillLocalizationData();\n\t\tthis.fillStoredData();\n\n\t\tprops.setLook(labelStepName);\n\t\tprops.setLook(textStepName);\n\t\tprops.setLook(addConnectionLine);\n\t\tprops.setLook(labelModelName);\n\t\tprops.setLook(comboModelName);\n\t\tprops.setLook(labelReadBatchSize);\n\t\tprops.setLook(textReadBatchSize);\n\t\tprops.setLook(labelFilter);\n\t\tprops.setLook(tableViewFilter);\n\t\tprops.setLook(labelFields);\n\t\tprops.setLook(tableViewFields);\n\n\t\tmeta.setChanged(changed);\n\t\tsetSize();\n\t\tshell.open();\n\n\t\twhile (!shell.isDisposed()) {\n\t\t\tif (!display.readAndDispatch())\n\t\t\t\tdisplay.sleep();\n\t\t}\n\n\t\treturn stepname;\n\t}","id":75018,"modified_method":"@Override\n\tpublic String open() {\n\n\t\tModifyListener lsMod = new ModifyListener() {\n\t\t\tpublic void modifyText(ModifyEvent e) {\n\t\t\t\tmeta.setChanged();\n\t\t\t}\n\t\t};\n\n\t\tfinal Display display = getParent().getDisplay();\n\t\tshell = new Shell(getParent(), SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\n\t\tprops.setLook(shell);\n\t\tsetShellImage(shell, meta);\n\t\tFormLayout formLayout = new FormLayout();\n\t\tformLayout.marginWidth = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\tFormData fd;\n\n\t\tlabelStepName = new Label(shell, SWT.RIGHT);\n\t\tfd = new FormData();\n\t\tfd.left = new FormAttachment(0, 0);\n\t\tfd.right = new FormAttachment(middle, -margin);\n\t\tfd.top = new FormAttachment(0, margin);\n\t\tlabelStepName.setLayoutData(fd);\n\n\t\ttextStepName = new Text(shell, SWT.BORDER);\n\t\tfd = new FormData();\n\t\tfd.left = new FormAttachment(middle, 0);\n\t\tfd.right = new FormAttachment(100, 0);\n\t\tfd.top = new FormAttachment(0, margin);\n\t\ttextStepName.setLayoutData(fd);\n\n\t\taddConnectionLine = addConnectionLine(shell, textStepName, Const.MIDDLE_PCT, margin);\n\n\t\tlabelModelName = new Label(shell, SWT.RIGHT);\n\t\tfd = new FormData();\n\t\tfd.left = new FormAttachment(0, 0);\n\t\tfd.right = new FormAttachment(middle, -margin);\n\t\tfd.top = new FormAttachment(addConnectionLine, margin);\n\t\tlabelModelName.setLayoutData(fd);\n\n\t\tcomboModelName = new CCombo(shell, SWT.BORDER);\n\t\tfd = new FormData();\n\t\tfd.left = new FormAttachment(middle, 0);\n\t\tfd.right = new FormAttachment(100, 0);\n\t\tfd.top = new FormAttachment(addConnectionLine, margin);\n\t\tcomboModelName.setLayoutData(fd);\n\n\t\tlabelReadBatchSize = new Label(shell, SWT.RIGHT);\n\t\tfd = new FormData();\n\t\tfd.left = new FormAttachment(0, 0);\n\t\tfd.right = new FormAttachment(middle, -margin);\n\t\tfd.top = new FormAttachment(comboModelName, margin);\n\t\tlabelReadBatchSize.setLayoutData(fd);\n\n\t\ttextReadBatchSize = new Text(shell, SWT.BORDER);\n\t\tfd = new FormData();\n\t\tfd.left = new FormAttachment(middle, 0);\n\t\tfd.right = new FormAttachment(100, 0);\n\t\tfd.top = new FormAttachment(comboModelName, margin);\n\t\ttextReadBatchSize.setLayoutData(fd);\n\t\t\n\t\tlabelFilter = new Label(shell, SWT.NONE);\n\t\tfd = new FormData();\n\t\tfd.left = new FormAttachment(0, 0);\n\t\tfd.top = new FormAttachment(textReadBatchSize, margin);\n\t\tlabelFilter.setLayoutData(fd);\n\t\t\n\t\tfilterViewColinf = new ColumnInfo[] { \n\t\t\t\tnew ColumnInfo(getLocalizedFilterColumn(0), ColumnInfo.COLUMN_TYPE_CCOMBO, new String[] { \"\" }, false), \n\t\t\t\tnew ColumnInfo(getLocalizedFilterColumn(1), ColumnInfo.COLUMN_TYPE_CCOMBO, new String[] { \"\" }, false),\n\t\t\t\tnew ColumnInfo(getLocalizedFilterColumn(2), ColumnInfo.COLUMN_TYPE_CCOMBO, new String[] { \"\" }, false),\n\t\t\t\tnew ColumnInfo(getLocalizedFilterColumn(3), ColumnInfo.COLUMN_TYPE_TEXT, false, false)};\n\t\t\n\t\ttableViewFilter = new TableView(null, shell, SWT.MULTI | SWT.BORDER, filterViewColinf, 0, true, lsMod, props);\n\t\ttableViewFilter.setReadonly(false);\n\t\ttableViewFilter.setSortable(false);\n\t\tfd = new FormData();\n\t\tfd.left = new FormAttachment(0, margin);\n\t\tfd.top = new FormAttachment(labelFilter, 3 * margin);\n\t\tfd.right = new FormAttachment(100, -150);\n\t\tfd.bottom = new FormAttachment(labelFilter, 200);\n\t\ttableViewFilter.setLayoutData(fd);\n\t\t\n\t\tbuttonHelpFilter = new Button(shell, SWT.NONE);\n\t\tfd = new FormData();\n\t\tfd.left = new FormAttachment(tableViewFilter, margin);\n\t\tfd.top = new FormAttachment(labelFilter, 3 * margin);\n\t\tfd.right = new FormAttachment(100, 0);\n\t\tbuttonHelpFilter.setLayoutData(fd);\n\n\t\tlabelFields = new Label(shell, SWT.NONE);\n\t\tfd = new FormData();\n\t\tfd.left = new FormAttachment(0, 0);\n\t\tfd.top = new FormAttachment(tableViewFilter, margin);\n\t\tlabelFields.setLayoutData(fd);\n\t\t\n\t\tColumnInfo[] colinf = new ColumnInfo[] { \n\t\t\t\tnew ColumnInfo(getLocalizedColumn(0), ColumnInfo.COLUMN_TYPE_TEXT, false, true), \n\t\t\t\tnew ColumnInfo(getLocalizedColumn(1), ColumnInfo.COLUMN_TYPE_TEXT, false, true),\n\t\t\t\tnew ColumnInfo(getLocalizedColumn(2), ColumnInfo.COLUMN_TYPE_TEXT, false, true)};\n\n\t\ttableViewFields = new TableView(null, shell, SWT.FILL | SWT.BORDER, colinf, 0, true, lsMod, props);\n\t\ttableViewFields.setSize(477, 280);\n\t\ttableViewFields.setBounds(5, 125, 477, 280);\n\t\ttableViewFields.setReadonly(false);\n\t\ttableViewFields.setSortable(true);\n\t\tfd = new FormData();\n\t\tfd.left = new FormAttachment(0, margin);\n\t\tfd.top = new FormAttachment(labelFields, 3 * margin);\n\t\tfd.right = new FormAttachment(100, -150);\n\t\tfd.bottom = new FormAttachment(100, -50);\n\t\ttableViewFields.setLayoutData(fd);\n\t\t\n\t\tbuttonGetFields = new Button(shell, SWT.NONE);\n\t\tfd = new FormData();\n\t\tfd.left = new FormAttachment(tableViewFields, margin);\n\t\tfd.top = new FormAttachment(labelFields, 3 * margin);\n\t\tfd.right = new FormAttachment(100, 0);\n\t\tbuttonGetFields.setLayoutData(fd);\n\t\t\n\t\tbuttonOk = new Button(shell, SWT.CENTER);\n\t\tbuttonCancel = new Button(shell, SWT.CENTER);\n\t\tbuttonPreview = new Button(shell, SWT.CENTER);\n\t\tbuttonOk.setText(BaseMessages.getString(\"System.Button.OK\"));\n\t\tbuttonPreview.setText(BaseMessages.getString(\"System.Button.Preview\"));\n\t\tbuttonCancel.setText(BaseMessages.getString(\"System.Button.Cancel\"));\n\t\tsetButtonPositions(new Button[] { buttonOk, buttonPreview, buttonCancel }, margin, null);\n\n\t\taddConnectionLine.addSelectionListener(new SelectionAdapter() {\n\t\t\tpublic void widgetSelected(SelectionEvent e) {\n\t\t\t\tfillModelCombo();\n\t\t\t}\n\t\t});\n\t\tcomboModelName.addSelectionListener(new SelectionAdapter() {\n\t\t\tpublic void widgetSelected(SelectionEvent e) {\n\t\t\t\tfillFilterCombos();\n\t\t\t}\n\t\t});\n\t\tcomboModelName.addFocusListener(new FocusListener() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void focusLost(FocusEvent arg0) {\n\t\t\t\tfillFilterCombos();\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void focusGained(FocusEvent arg0) {\n\t\t\t}\n\t\t});\n\t\t\n\t\tcomboModelName.addSelectionListener(new SelectionAdapter() {\n\t\t\tpublic void widgetSelected(SelectionEvent e) {\n\t\t\t\tfillFilterCombos();\n\t\t\t}\n\t\t});\n\t\tbuttonHelpFilter.addSelectionListener(new SelectionAdapter() {\n\t\t\tpublic void widgetSelected(SelectionEvent e) {\n\t\t\t\tshowHelp();\n\t\t\t}\n\t\t});\n\t\tbuttonGetFields.addSelectionListener(new SelectionAdapter() {\n\t\t\tpublic void widgetSelected(SelectionEvent e) {\n\t\t\t\tgetFields();\n\t\t\t}\n\t\t});\n\t\tbuttonCancel.addSelectionListener(new SelectionAdapter() {\n\t\t\tpublic void widgetSelected(SelectionEvent e) {\n\t\t\t\tcancel();\n\t\t\t}\n\t\t});\n\t\tbuttonPreview.addSelectionListener(new SelectionAdapter() {\n\t\t\tpublic void widgetSelected(SelectionEvent e) {\n\t\t\t\tpreview();\n\t\t\t}\n\t\t});\n\t\tbuttonOk.addSelectionListener(new SelectionAdapter() {\n\t\t\tpublic void widgetSelected(SelectionEvent e) {\n\t\t\t\tok();\n\t\t\t}\n\t\t});\n\t\t\n\t\t// \n\t\t// Search the fields in the background\n\t\t//\n\t\tfinal Runnable runnable = new Runnable()\n\t\t{\n\t\t\tpublic void run()\n\t\t\t{\n\t\t\t\tfillModelCombo();\n\t\t\t}\n\t\t};\n\t\tdisplay.asyncExec(runnable);\n\n\t\tthis.fillLocalizationData();\n\t\tthis.fillStoredData();\n\n\t\tprops.setLook(labelStepName);\n\t\tprops.setLook(textStepName);\n\t\tprops.setLook(addConnectionLine);\n\t\tprops.setLook(labelModelName);\n\t\tprops.setLook(comboModelName);\n\t\tprops.setLook(labelReadBatchSize);\n\t\tprops.setLook(textReadBatchSize);\n\t\tprops.setLook(labelFilter);\n\t\tprops.setLook(tableViewFilter);\n\t\tprops.setLook(labelFields);\n\t\tprops.setLook(tableViewFields);\n\n\t\tmeta.setChanged(changed);\n\t\tsetSize();\n\t\tshell.open();\n\n\t\twhile (!shell.isDisposed()) {\n\t\t\tif (!display.readAndDispatch())\n\t\t\t\tdisplay.sleep();\n\t\t}\n\n\t\treturn stepname;\n\t}","commit_id":"6ba55c89ce5e5325d4a44a5527b4ed937b7f7ba5","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void populateFiltersTable(ArrayList<ReadFilter> filters){\n\t\ttableViewFilter.table.removeAll();\n\n\t\tfor (ReadFilter filter : filters)\n\t\t\ttableViewFilter.add(\n\t\t\t\t\tfilter.field_name, \n\t\t\t\t\tfilter.operator,\n\t\t\t\t\tfilter.value);\n\n\t\ttableViewFilter.add(\"\",\"\",\"\");\n\n\t\ttableViewFilter.setRowNums();\n\t\ttableViewFilter.optWidth(true);\t\t\n\t}","id":75019,"modified_method":"private void populateFiltersTable(ArrayList<ReadFilter> filters){\n\t\ttableViewFilter.table.removeAll();\n\n\t\tfor (ReadFilter filter : filters)\n\t\t\ttableViewFilter.add(\n\t\t\t\t\tfilter.operator,\n\t\t\t\t\tfilter.field_name, \n\t\t\t\t\tfilter.comparator,\n\t\t\t\t\tfilter.value);\n\n\t\ttableViewFilter.add(\"\",\"\",\"\",\"\");\n\n\t\ttableViewFilter.setRowNums();\n\t\ttableViewFilter.optWidth(true);\t\t\n\t}","commit_id":"6ba55c89ce5e5325d4a44a5527b4ed937b7f7ba5","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Override\n\tpublic void saveRep(Repository rep, ObjectId idTransformation,\n\t\t\tObjectId idStep) throws KettleException {\n\t\ttry {\n\t\t\trep.saveDatabaseMetaStepAttribute(idTransformation, idStep, \"connection\", this.databaseMeta);\n\t\t\trep.saveStepAttribute(idTransformation, idStep, \"modelName\", this.modelName);\n\t\t\trep.saveStepAttribute(idTransformation, idStep, \"readBatchSize\", this.readBatchSize);\n\t\t\t\n\t\t\tfor (int i=0;i<getMappings().size();i++) {\n\t\t\t\tFieldMapping map = this.getMappings().get(i);\n                rep.saveStepAttribute(idTransformation, idStep, i, \"source_model\", map.source_model);\n                rep.saveStepAttribute(idTransformation, idStep, i, \"source_field\", map.source_field);\n                rep.saveStepAttribute(idTransformation, idStep, i, \"source_index\", map.source_index);\n                rep.saveStepAttribute(idTransformation, idStep, i, \"target_model\", map.target_model);\n                rep.saveStepAttribute(idTransformation, idStep, i, \"target_field\", map.target_field);\n                rep.saveStepAttribute(idTransformation, idStep, i, \"target_field_label\", map.target_field_label);\n                rep.saveStepAttribute(idTransformation, idStep, i, \"target_field_type\", map.target_field_type);\n            }\n\t\t\t\n\t\t\tfor (int i=0;i<getFilterList().size();i++) {\n\t\t\t\tReadFilter filter = this.getFilterList().get(i);\n                rep.saveStepAttribute(idTransformation, idStep, i, \"field_name\", filter.field_name);\n                rep.saveStepAttribute(idTransformation, idStep, i, \"operator\", filter.operator);\n                rep.saveStepAttribute(idTransformation, idStep, i, \"value\", filter.value);\n            }\n\t\t\t\n\t\t} catch (Exception e) {\n\t\t\tthrow new KettleException(\"Unable to save step information to the repository for idStep=\" + idStep, e);\n\t\t}\n\t}","id":75020,"modified_method":"@Override\n\tpublic void saveRep(Repository rep, ObjectId idTransformation,\n\t\t\tObjectId idStep) throws KettleException {\n\t\ttry {\n\t\t\trep.saveDatabaseMetaStepAttribute(idTransformation, idStep, \"connection\", this.databaseMeta);\n\t\t\trep.saveStepAttribute(idTransformation, idStep, \"modelName\", this.modelName);\n\t\t\trep.saveStepAttribute(idTransformation, idStep, \"readBatchSize\", this.readBatchSize);\n\t\t\t\n\t\t\tfor (int i=0;i<getMappings().size();i++) {\n\t\t\t\tFieldMapping map = this.getMappings().get(i);\n                rep.saveStepAttribute(idTransformation, idStep, i, \"source_model\", map.source_model);\n                rep.saveStepAttribute(idTransformation, idStep, i, \"source_field\", map.source_field);\n                rep.saveStepAttribute(idTransformation, idStep, i, \"source_index\", map.source_index);\n                rep.saveStepAttribute(idTransformation, idStep, i, \"target_model\", map.target_model);\n                rep.saveStepAttribute(idTransformation, idStep, i, \"target_field\", map.target_field);\n                rep.saveStepAttribute(idTransformation, idStep, i, \"target_field_label\", map.target_field_label);\n                rep.saveStepAttribute(idTransformation, idStep, i, \"target_field_type\", map.target_field_type);\n            }\n\t\t\t\n\t\t\tfor (int i=0;i<getFilterList().size();i++) {\n\t\t\t\tReadFilter filter = this.getFilterList().get(i);\n\t\t\t\trep.saveStepAttribute(idTransformation, idStep, i, \"operator\", filter.operator);\n\t\t\t\trep.saveStepAttribute(idTransformation, idStep, i, \"field_name\", filter.field_name);\n                rep.saveStepAttribute(idTransformation, idStep, i, \"comparator\", filter.comparator);\n                rep.saveStepAttribute(idTransformation, idStep, i, \"value\", filter.value);\n            }\n\t\t\t\n\t\t} catch (Exception e) {\n\t\t\tthrow new KettleException(\"Unable to save step information to the repository for idStep=\" + idStep, e);\n\t\t}\n\t}","commit_id":"6ba55c89ce5e5325d4a44a5527b4ed937b7f7ba5","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public final String getXML() {\n\t\tStringBuffer retval = new StringBuffer();\n\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"connection\", this.databaseMeta == null ? \"\": this.databaseMeta.getName()));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"modelName\", this.modelName));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"readBatchSize\", this.readBatchSize));\n\t\t\n\t\tretval.append(\"    <mappings>\").append(Const.CR);\n        for (FieldMapping map : this.getMappings()) {\n            retval.append(\"      <mapping>\").append(Const.CR);\n            retval.append(\"        \").append(XMLHandler.addTagValue(\"source_model\",map.source_model));\n            retval.append(\"        \").append(XMLHandler.addTagValue(\"source_field\",map.source_field));\n            retval.append(\"        \").append(XMLHandler.addTagValue(\"source_index\",map.source_index));\n            retval.append(\"        \").append(XMLHandler.addTagValue(\"target_model\",map.target_model));\n            retval.append(\"        \").append(XMLHandler.addTagValue(\"target_field\",map.target_field));\n            retval.append(\"        \").append(XMLHandler.addTagValue(\"target_field_label\",map.target_field_label));\n            retval.append(\"        \").append(XMLHandler.addTagValue(\"target_field_type\",map.target_field_type));\n            retval.append(\"      <\/mapping>\").append(Const.CR);\n        }\n        retval.append(\"    <\/mappings>\").append(Const.CR);\n        \n        retval.append(\"    <filters>\").append(Const.CR);\n        for (ReadFilter filter : this.getFilterList()) {\n            retval.append(\"      <filter>\").append(Const.CR);\n            retval.append(\"        \").append(XMLHandler.addTagValue(\"field_name\",filter.field_name));\n            retval.append(\"        \").append(XMLHandler.addTagValue(\"operator\",filter.operator));\n            retval.append(\"        \").append(XMLHandler.addTagValue(\"value\",filter.value));\n            retval.append(\"      <\/filter>\").append(Const.CR);\n        }\n        retval.append(\"    <\/filters>\").append(Const.CR);\n\t\t\n\t\treturn retval.toString();\n\t}","id":75021,"modified_method":"public final String getXML() {\n\t\tStringBuffer retval = new StringBuffer();\n\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"connection\", this.databaseMeta == null ? \"\": this.databaseMeta.getName()));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"modelName\", this.modelName));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"readBatchSize\", this.readBatchSize));\n\t\t\n\t\tretval.append(\"    <mappings>\").append(Const.CR);\n        for (FieldMapping map : this.getMappings()) {\n            retval.append(\"      <mapping>\").append(Const.CR);\n            retval.append(\"        \").append(XMLHandler.addTagValue(\"source_model\",map.source_model));\n            retval.append(\"        \").append(XMLHandler.addTagValue(\"source_field\",map.source_field));\n            retval.append(\"        \").append(XMLHandler.addTagValue(\"source_index\",map.source_index));\n            retval.append(\"        \").append(XMLHandler.addTagValue(\"target_model\",map.target_model));\n            retval.append(\"        \").append(XMLHandler.addTagValue(\"target_field\",map.target_field));\n            retval.append(\"        \").append(XMLHandler.addTagValue(\"target_field_label\",map.target_field_label));\n            retval.append(\"        \").append(XMLHandler.addTagValue(\"target_field_type\",map.target_field_type));\n            retval.append(\"      <\/mapping>\").append(Const.CR);\n        }\n        retval.append(\"    <\/mappings>\").append(Const.CR);\n        \n        retval.append(\"    <filters>\").append(Const.CR);\n        for (ReadFilter filter : this.getFilterList()) {\n            retval.append(\"      <filter>\").append(Const.CR);\n            retval.append(\"        \").append(XMLHandler.addTagValue(\"operator\",filter.operator));\n            retval.append(\"        \").append(XMLHandler.addTagValue(\"field_name\",filter.field_name));\n            retval.append(\"        \").append(XMLHandler.addTagValue(\"comparator\",filter.comparator));\n            retval.append(\"        \").append(XMLHandler.addTagValue(\"value\",filter.value));\n            retval.append(\"      <\/filter>\").append(Const.CR);\n        }\n        retval.append(\"    <\/filters>\").append(Const.CR);\n\t\t\n\t\treturn retval.toString();\n\t}","commit_id":"6ba55c89ce5e5325d4a44a5527b4ed937b7f7ba5","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Override\n\tpublic void readRep(Repository rep, ObjectId idStep,\n\t\t\tList<DatabaseMeta> databases, Map<String, Counter> counters)\n\tthrows KettleException {\n\t\ttry {\n\t\t\tthis.databaseMeta = rep.loadDatabaseMetaFromStepAttribute(idStep, \"connection\", databases);\n\t\t\tthis.modelName = rep.getStepAttributeString(idStep, \"modelName\");\n\t\t\tthis.readBatchSize = Integer.parseInt(rep.getStepAttributeString(idStep, \"readBatchSize\"));\n\t\t\t\n\t\t\tint nrMappings = rep.countNrStepAttributes(idStep, \"source_model\");\n            \n            for (int i=0;i<nrMappings;i++) {\n            \tFieldMapping map = new FieldMapping();\n            \t\n            \tmap.source_model = rep.getStepAttributeString (idStep, i, \"source_model\");\n            \tmap.source_field = rep.getStepAttributeString (idStep, i, \"source_field\");\n            \tmap.source_index = Integer.valueOf(rep.getStepAttributeString (idStep, i, \"source_index\"));\n            \tmap.target_model = rep.getStepAttributeString (idStep, i, \"target_model\");\n            \tmap.target_field = rep.getStepAttributeString (idStep, i, \"target_field\");\n            \tmap.target_field_label = rep.getStepAttributeString (idStep, i, \"target_field_label\");\n            \tmap.target_field_type = Integer.valueOf(rep.getStepAttributeString (idStep, i, \"target_field_type\")); \n            \t\n            \tthis.getMappings().add(map);\n            }\n            \n            int nrFilters = rep.countNrStepAttributes(idStep, \"field_name\");\n            for (int i=0;i<nrFilters;i++) {\n            \tReadFilter filter = new ReadFilter();\n            \t\n            \tfilter.field_name = rep.getStepAttributeString (idStep, i, \"field_name\");\n            \tfilter.operator = rep.getStepAttributeString (idStep, i, \"operator\");\n            \tfilter.value = rep.getStepAttributeString (idStep, i, \"value\");\n            \t\n            \tthis.getFilterList().add(filter);\n            }\n            \n\t\t} catch (Exception e) {\n\t\t\tthrow new KettleException(\"Unexpected error reading step information from the repository\", e);\n\t\t}\n\t}","id":75022,"modified_method":"@Override\n\tpublic void readRep(Repository rep, ObjectId idStep,\n\t\t\tList<DatabaseMeta> databases, Map<String, Counter> counters)\n\tthrows KettleException {\n\t\ttry {\n\t\t\tthis.databaseMeta = rep.loadDatabaseMetaFromStepAttribute(idStep, \"connection\", databases);\n\t\t\tthis.modelName = rep.getStepAttributeString(idStep, \"modelName\");\n\t\t\tthis.readBatchSize = Integer.parseInt(rep.getStepAttributeString(idStep, \"readBatchSize\"));\n\t\t\t\n\t\t\tint nrMappings = rep.countNrStepAttributes(idStep, \"source_model\");\n            \n            for (int i=0;i<nrMappings;i++) {\n            \tFieldMapping map = new FieldMapping();\n            \t\n            \tmap.source_model = rep.getStepAttributeString (idStep, i, \"source_model\");\n            \tmap.source_field = rep.getStepAttributeString (idStep, i, \"source_field\");\n            \tmap.source_index = Integer.valueOf(rep.getStepAttributeString (idStep, i, \"source_index\"));\n            \tmap.target_model = rep.getStepAttributeString (idStep, i, \"target_model\");\n            \tmap.target_field = rep.getStepAttributeString (idStep, i, \"target_field\");\n            \tmap.target_field_label = rep.getStepAttributeString (idStep, i, \"target_field_label\");\n            \tmap.target_field_type = Integer.valueOf(rep.getStepAttributeString (idStep, i, \"target_field_type\")); \n            \t\n            \tthis.getMappings().add(map);\n            }\n            \n            int nrFilters = rep.countNrStepAttributes(idStep, \"field_name\");\n            for (int i=0;i<nrFilters;i++) {\n            \tReadFilter filter = new ReadFilter();\n            \t\n            \tfilter.operator = rep.getStepAttributeString (idStep, i, \"operator\");\n            \tfilter.field_name = rep.getStepAttributeString (idStep, i, \"field_name\");\n            \tfilter.comparator = rep.getStepAttributeString (idStep, i, \"comparator\");\n            \tfilter.value = rep.getStepAttributeString (idStep, i, \"value\");\n            \t\n            \tthis.getFilterList().add(filter);\n            }\n            \n\t\t} catch (Exception e) {\n\t\t\tthrow new KettleException(\"Unexpected error reading step information from the repository\", e);\n\t\t}\n\t}","commit_id":"6ba55c89ce5e5325d4a44a5527b4ed937b7f7ba5","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void readData(final Node stepnode, final List < ? extends SharedObjectInterface > databases)\n\tthrows KettleXMLException {\n\t\ttry {\n\t\t\tthis.databaseMeta = DatabaseMeta.findDatabase(databases, XMLHandler.getTagValue(stepnode, \"connection\"));\n\t\t\tthis.modelName = XMLHandler.getTagValue(stepnode, \"modelName\");\n\t\t\tthis.readBatchSize = Integer.parseInt(XMLHandler.getTagValue(stepnode, \"readBatchSize\"));\n\t\t\t\n\t\t\tthis.setMappings(new ArrayList <FieldMapping>());\n            \n            Node mappings = XMLHandler.getSubNode(stepnode,\"mappings\");\n            int nrLevels = XMLHandler.countNodes(mappings,\"mapping\");\n\n            for (int i=0;i<nrLevels;i++) {\n            \tFieldMapping map = new FieldMapping();\n            \t\n            \tNode fnode = XMLHandler.getSubNodeByNr(mappings, \"mapping\", i);\n            \t\n            \tmap.source_model = XMLHandler.getTagValue(fnode, \"source_model\");\n            \tmap.source_field = XMLHandler.getTagValue(fnode, \"source_field\");\n            \tmap.source_index = Integer.parseInt(XMLHandler.getTagValue(fnode, \"source_index\"));\n            \tmap.target_model = XMLHandler.getTagValue(fnode, \"target_model\");\n            \tmap.target_field = XMLHandler.getTagValue(fnode, \"target_field\");\n            \tmap.target_field_label = XMLHandler.getTagValue(fnode, \"target_field_label\");\n            \tmap.target_field_type = Integer.parseInt(XMLHandler.getTagValue(fnode, \"target_field_type\")); \n\n            \tthis.getMappings().add(map);\n            }\n            \n            Node filters = XMLHandler.getSubNode(stepnode,\"filters\");\n            int nrFilters = XMLHandler.countNodes(filters,\"filter\");\n\n            for (int i=0;i<nrFilters;i++) {\n            \tReadFilter filter = new ReadFilter();\n            \t\n            \tNode fnode = XMLHandler.getSubNodeByNr(filters, \"filter\", i);\n            \t\n            \tfilter.field_name = XMLHandler.getTagValue(fnode, \"field_name\");\n            \tfilter.operator = XMLHandler.getTagValue(fnode, \"operator\");\n            \tfilter.value = XMLHandler.getTagValue(fnode, \"value\");\n            \t\n            \tthis.getFilterList().add(filter);\n            }\n            \n\t\t} catch (Exception e) {\n\t\t\tthrow new KettleXMLException(\"Unable to load step info from XML\", e);\n\t\t}\n\t}","id":75023,"modified_method":"private void readData(final Node stepnode, final List < ? extends SharedObjectInterface > databases)\n\tthrows KettleXMLException {\n\t\ttry {\n\t\t\tthis.databaseMeta = DatabaseMeta.findDatabase(databases, XMLHandler.getTagValue(stepnode, \"connection\"));\n\t\t\tthis.modelName = XMLHandler.getTagValue(stepnode, \"modelName\");\n\t\t\tthis.readBatchSize = Integer.parseInt(XMLHandler.getTagValue(stepnode, \"readBatchSize\"));\n\t\t\t\n\t\t\tthis.setMappings(new ArrayList <FieldMapping>());\n            \n            Node mappings = XMLHandler.getSubNode(stepnode,\"mappings\");\n            int nrLevels = XMLHandler.countNodes(mappings,\"mapping\");\n\n            for (int i=0;i<nrLevels;i++) {\n            \tFieldMapping map = new FieldMapping();\n            \t\n            \tNode fnode = XMLHandler.getSubNodeByNr(mappings, \"mapping\", i);\n            \t\n            \tmap.source_model = XMLHandler.getTagValue(fnode, \"source_model\");\n            \tmap.source_field = XMLHandler.getTagValue(fnode, \"source_field\");\n            \tmap.source_index = Integer.parseInt(XMLHandler.getTagValue(fnode, \"source_index\"));\n            \tmap.target_model = XMLHandler.getTagValue(fnode, \"target_model\");\n            \tmap.target_field = XMLHandler.getTagValue(fnode, \"target_field\");\n            \tmap.target_field_label = XMLHandler.getTagValue(fnode, \"target_field_label\");\n            \tmap.target_field_type = Integer.parseInt(XMLHandler.getTagValue(fnode, \"target_field_type\")); \n\n            \tthis.getMappings().add(map);\n            }\n            \n            Node filters = XMLHandler.getSubNode(stepnode,\"filters\");\n            int nrFilters = XMLHandler.countNodes(filters,\"filter\");\n\n            for (int i=0;i<nrFilters;i++) {\n            \tReadFilter filter = new ReadFilter();\n            \t\n            \tNode fnode = XMLHandler.getSubNodeByNr(filters, \"filter\", i);\n            \t\n            \tfilter.operator = XMLHandler.getTagValue(fnode, \"operator\");\n            \tfilter.field_name = XMLHandler.getTagValue(fnode, \"field_name\");\n            \tfilter.comparator = XMLHandler.getTagValue(fnode, \"comparator\");\n            \tfilter.value = XMLHandler.getTagValue(fnode, \"value\");\n            \t\n            \tthis.getFilterList().add(filter);\n            }\n            \n\t\t} catch (Exception e) {\n\t\t\tthrow new KettleXMLException(\"Unable to load step info from XML\", e);\n\t\t}\n\t}","commit_id":"6ba55c89ce5e5325d4a44a5527b4ed937b7f7ba5","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private String [] getModelFieldNames(boolean showError){\n\t\t// Set table fields\n\t\tif (addConnectionLine.getText() != null) {\n\t\t\tDatabaseMeta dbMeta = transMeta.findDatabase(addConnectionLine.getText());\n\n\t\t\tif (dbMeta != null) {\n\n\t\t\t\tOpenERPObjectOutputData data = null;\n\t\t\t\ttry{\n\t\t\t\t\tdata = new OpenERPObjectOutputData(dbMeta);\n\t\t\t\t\tdata.helper.StartSession();\n\t\t\t\t\t\n\t\t\t\t\t// If errors should be reported, check that the model exists.  If we don't check the \n\t\t\t\t\t// server just returns the generic can't parse int to string xmlrpc error\n\t\t\t\t\tif (showError){\n\t\t\t\t\t\tString [] modelList = getModelList();\n\t\t\t\t\t\t\n\t\t\t\t\t\tboolean found = false;\n\t\t\t\t\t\tfor (String model : modelList)\n\t\t\t\t\t\t\tif (model.equals(comboModelName.getText())){\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!found){\n\t\t\t\t\t\t\tnew ErrorDialog(shell, BaseMessages.getString(PKG, \"OpenERPObjectOutputDialog.ConnectionErrorTitle\"), \n\t\t\t\t\t\t\t\t\tBaseMessages.getString(PKG, \"OpenERPObjectOutputDialog.ConnectionErrorString\"), \n\t\t\t\t\t\t\t\t\tnew Exception(BaseMessages.getString(PKG, \"OpenERPObjectOutputDialog.ModelNotFoundError\", comboModelName.getText())));\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn data.helper.getOutputFields(comboModelName.getText());\n\t\t\t\t}\n\t\t\t\tcatch (Exception e){\n\t\t\t\t\tif (showError)\n\t\t\t\t\t\tnew ErrorDialog(shell, BaseMessages.getString(PKG, \"OpenERPObjectOuputDialog.ConnectionErrorTitle\"), BaseMessages.getString(PKG, \"OpenERPObjectInputDialog.ConnectionErrorString\"), e);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","id":75024,"modified_method":"private String [] getModelFieldNames(boolean showError){\n\t\t// Set table fields\n\t\tif (addConnectionLine.getText() != null) {\n\t\t\tDatabaseMeta dbMeta = transMeta.findDatabase(addConnectionLine.getText());\n\n\t\t\tif (dbMeta != null) {\n\n\t\t\t\tOpenERPObjectOutputData data = null;\n\t\t\t\ttry{\n\t\t\t\t\tdata = new OpenERPObjectOutputData(dbMeta);\n\t\t\t\t\tdata.helper.StartSession();\n\t\t\t\t\t\n\t\t\t\t\t// If errors should be reported, check that the model exists.  If we don't check the \n\t\t\t\t\t// server just returns the generic can't parse int to string xmlrpc error\n\t\t\t\t\tif (showError){\n\t\t\t\t\t\tString [] modelList = getModelList();\n\t\t\t\t\t\t\n\t\t\t\t\t\tboolean found = false;\n\t\t\t\t\t\tfor (String model : modelList)\n\t\t\t\t\t\t\tif (model.equals(comboModelName.getText())){\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!found){\n\t\t\t\t\t\t\tnew ErrorDialog(shell, BaseMessages.getString(PKG, \"OpenERPObjectOutputDialog.ConnectionErrorTitle\"), \n\t\t\t\t\t\t\t\t\tBaseMessages.getString(PKG, \"OpenERPObjectOutputDialog.ConnectionErrorString\"), \n\t\t\t\t\t\t\t\t\tnew Exception(BaseMessages.getString(PKG, \"OpenERPObjectOutputDialog.ModelNotFoundError\", comboModelName.getText())));\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn data.helper.getOutputFields(comboModelName.getText());\n\t\t\t\t}\n\t\t\t\tcatch (Exception e){\n\t\t\t\t\tif (showError)\n\t\t\t\t\t\tnew ErrorDialog(shell, BaseMessages.getString(PKG, \"OpenERPObjectOuputDialog.ConnectionErrorTitle\"), BaseMessages.getString(PKG, \"OpenERPObjectOutputDialog.ConnectionErrorString\"), e);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","commit_id":"6ba55c89ce5e5325d4a44a5527b4ed937b7f7ba5","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"protected void refresh() {\n            HistoryOsmPrimitive p = getPrimitive();\n            HistoryOsmPrimitive  opposite = getOppositePrimitive();\n            if (p == null || ! ( p instanceof HistoryNode)) return;\n            if (opposite == null || ! (opposite instanceof HistoryNode)) return;\n            HistoryNode node = (HistoryNode)p;\n            HistoryNode oppositeNode = (HistoryNode) opposite;\n\n            LatLon coord = node.getCoords();\n            LatLon oppositeCoord = oppositeNode.getCoords();\n            \n            // display the coordinates\n            //\n            lblLat.setText(coord != null ? coord.latToString(CoordinateFormat.DECIMAL_DEGREES) : tr(\"Deleted\"));\n            lblLon.setText(coord != null ? coord.lonToString(CoordinateFormat.DECIMAL_DEGREES) : tr(\"Deleted\"));\n\n            // update background color to reflect differences in the coordinates\n            //\n            if (coord == oppositeCoord || \n                    (coord != null && oppositeCoord != null && coord.lat() == oppositeCoord.lat())) {\n                lblLat.setBackground(Color.WHITE);\n            } else {\n                lblLat.setBackground(BGCOLOR_DIFFERENCE);\n            }\n            if (coord == oppositeCoord || \n                    (coord != null && oppositeCoord != null && coord.lon() == oppositeCoord.lon())) {\n                lblLon.setBackground(Color.WHITE);\n            } else {\n                lblLon.setBackground(BGCOLOR_DIFFERENCE);\n            }\n        }","id":75025,"modified_method":"protected void refresh() {\n            HistoryOsmPrimitive p = getPrimitive();\n            HistoryOsmPrimitive  opposite = getOppositePrimitive();\n            if (p == null || ! ( p instanceof HistoryNode)) return;\n            if (opposite == null || ! (opposite instanceof HistoryNode)) return;\n            HistoryNode node = (HistoryNode)p;\n            HistoryNode oppositeNode = (HistoryNode) opposite;\n\n            LatLon coord = node.getCoords();\n            LatLon oppositeCoord = oppositeNode.getCoords();\n            \n            // display the coordinates\n            //\n            lblLat.setText(coord != null ? coord.latToString(CoordinateFormat.DECIMAL_DEGREES) : tr(\"(none)\"));\n            lblLon.setText(coord != null ? coord.lonToString(CoordinateFormat.DECIMAL_DEGREES) : tr(\"(none)\"));\n\n            // update background color to reflect differences in the coordinates\n            //\n            if (coord == oppositeCoord || \n                    (coord != null && oppositeCoord != null && coord.lat() == oppositeCoord.lat())) {\n                lblLat.setBackground(Color.WHITE);\n            } else {\n                lblLat.setBackground(BGCOLOR_DIFFERENCE);\n            }\n            if (coord == oppositeCoord || \n                    (coord != null && oppositeCoord != null && coord.lon() == oppositeCoord.lon())) {\n                lblLon.setBackground(Color.WHITE);\n            } else {\n                lblLon.setBackground(BGCOLOR_DIFFERENCE);\n            }\n        }","commit_id":"fb18ab022579d713f1d5c7af6b65712af05a747e","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected void refresh() {\n            HistoryOsmPrimitive p = getPrimitive();\n            HistoryOsmPrimitive opposite = getOppositePrimitive();\n            if (p == null || ! ( p instanceof HistoryNode)) return;\n            if (opposite == null || ! (opposite instanceof HistoryNode)) return;\n            HistoryNode node = (HistoryNode) p;\n            HistoryNode oppositeNode = (HistoryNode) opposite;\n\n            LatLon coord = node.getCoords();\n            LatLon oppositeCoord = oppositeNode.getCoords();\n            \n            // update distance\n            //\n            if (coord != null && oppositeCoord != null) {\n                double distance = coord.greatCircleDistance(oppositeCoord);\n                if (distance > 0) {\n                    lblDistance.setBackground(BGCOLOR_DIFFERENCE);\n                } else {\n                    lblDistance.setBackground(Color.WHITE);\n                }\n                lblDistance.setText(NavigatableComponent.getDistText(distance));\n            } else {\n                lblDistance.setBackground(coord != oppositeCoord ? BGCOLOR_DIFFERENCE : Color.WHITE);\n                lblDistance.setText(tr(\"Deleted\"));\n            }\n        }","id":75026,"modified_method":"protected void refresh() {\n            HistoryOsmPrimitive p = getPrimitive();\n            HistoryOsmPrimitive opposite = getOppositePrimitive();\n            if (p == null || ! ( p instanceof HistoryNode)) return;\n            if (opposite == null || ! (opposite instanceof HistoryNode)) return;\n            HistoryNode node = (HistoryNode) p;\n            HistoryNode oppositeNode = (HistoryNode) opposite;\n\n            LatLon coord = node.getCoords();\n            LatLon oppositeCoord = oppositeNode.getCoords();\n            \n            // update distance\n            //\n            if (coord != null && oppositeCoord != null) {\n                double distance = coord.greatCircleDistance(oppositeCoord);\n                if (distance > 0) {\n                    lblDistance.setBackground(BGCOLOR_DIFFERENCE);\n                } else {\n                    lblDistance.setBackground(Color.WHITE);\n                }\n                lblDistance.setText(NavigatableComponent.getDistText(distance));\n            } else {\n                lblDistance.setBackground(coord != oppositeCoord ? BGCOLOR_DIFFERENCE : Color.WHITE);\n                lblDistance.setText(tr(\"(none)\"));\n            }\n        }","commit_id":"fb18ab022579d713f1d5c7af6b65712af05a747e","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void searchNodes() {\n        for (Node n:dataSet.getNodes()) {\n            if (!n.isIncomplete() && !n.isDeleted()) {\n                LatLon c = n.getCoor();\n                BBox box = new BBox(new LatLon(c.lat() - 0.0001, c.lon() - 0.0001), new LatLon(c.lat() + 0.0001, c.lon() + 0.0001));\n                if (!dataSet.searchNodes(box).contains(n)) {\n                    printError(\"SEARCH NODES\", \"%s not found using Dataset.searchNodes()\", n);\n                }\n            }\n        }\n    }","id":75027,"modified_method":"public void searchNodes() {\n        for (Node n:dataSet.getNodes()) {\n            if (!n.isIncomplete() && !n.isDeleted()) {\n                LatLon c = n.getCoor();\n                if (c != null) {\n                    BBox box = new BBox(new LatLon(c.lat() - 0.0001, c.lon() - 0.0001), new LatLon(c.lat() + 0.0001, c.lon() + 0.0001));\n                    if (!dataSet.searchNodes(box).contains(n)) {\n                        printError(\"SEARCH NODES\", \"%s not found using Dataset.searchNodes()\", n);\n                    }\n                }\n            }\n        }\n    }","commit_id":"fb18ab022579d713f1d5c7af6b65712af05a747e","url":"https://github.com/openstreetmap/josm"},{"original_method":"@SuppressWarnings(\"unchecked\")\n        private LatLon getLatLon(Object o) {\n            if (o instanceof Node) {\n                if (precision==0)\n                    return ((Node) o).getCoor().getRoundedToOsmPrecision();\n                return RoundCoord((Node) o);\n            } else if (o instanceof List<?>) {\n                if (precision==0)\n                    return ((List<Node>) o).get(0).getCoor().getRoundedToOsmPrecision();\n                return RoundCoord(((List<Node>) o).get(0));\n            } else\n                throw new AssertionError();\n        }","id":75028,"modified_method":"@SuppressWarnings(\"unchecked\")\n        private LatLon getLatLon(Object o) {\n            if (o instanceof Node) {\n                LatLon coor = ((Node) o).getCoor();\n                if (coor == null)\n                    return null;\n                if (precision==0)\n                    return coor.getRoundedToOsmPrecision();\n                return roundCoord(coor);\n            } else if (o instanceof List<?>) {\n                LatLon coor = ((List<Node>) o).get(0).getCoor();\n                if (coor == null)\n                    return null;\n                if (precision==0)\n                    return coor.getRoundedToOsmPrecision();\n                return roundCoord(coor);\n            } else\n                throw new AssertionError();\n        }","commit_id":"fb18ab022579d713f1d5c7af6b65712af05a747e","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n        public int getHashCode(Object k) {\n            return getLatLon(k).hashCode();\n        }","id":75029,"modified_method":"@Override\n        public int getHashCode(Object k) {\n            LatLon coorK = getLatLon(k);\n            return coorK == null ? 0 : coorK.hashCode();\n        }","commit_id":"fb18ab022579d713f1d5c7af6b65712af05a747e","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n        public boolean equals(Object k, Object t) {\n            return getLatLon(k).equals(getLatLon(t));\n        }","id":75030,"modified_method":"@Override\n        public boolean equals(Object k, Object t) {\n            LatLon coorK = getLatLon(k);\n            LatLon coorT = getLatLon(t);\n            return coorK == coorT || (coorK != null && coorT != null && coorK.equals(coorT));\n        }","commit_id":"fb18ab022579d713f1d5c7af6b65712af05a747e","url":"https://github.com/openstreetmap/josm"},{"original_method":"/** {@inheritDoc} */\n  @Override\n  public OutputStream write(Annotation corpus, OutputStream os) throws IOException {\n    CoreNLPProtos.Document serialized = toProto(corpus);\n    serialized.writeTo(os);\n    os.flush();\n    return os;\n  }","id":75031,"modified_method":"/** {@inheritDoc} */\n  @Override\n  public OutputStream write(Annotation corpus, OutputStream os) throws IOException {\n    CoreNLPProtos.Document serialized = toProto(corpus);\n    serialized.writeDelimitedTo(os);\n    os.flush();\n    return os;\n  }","commit_id":"cc87fe3e64a1c1fa7b8b9ef71f3d871c0e82ccad","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Returns a complete document, intended to mimic a document passes as input to\n   * {@link ProtobufAnnotationSerializer#toProto(Annotation)} as closely as possible.\n   * That is, most common fields are serialized, but there is not guarantee that custom additions\n   * will be saved and retrieved.\n   *\n   * @param proto The protocol buffer to read the document from.\n   * @return An Annotation corresponding to the read protobuf.\n   */\n  public Annotation fromProto(CoreNLPProtos.Document proto) {\n    // Set text\n    Annotation ann = new Annotation(proto.getText());\n\n    // Add tokens\n    List<CoreLabel> tokens = new ArrayList<CoreLabel>();\n    if (proto.getSentenceCount() > 0) {\n      // Populate the tokens from the sentence\n      for (CoreNLPProtos.Sentence sentence : proto.getSentenceList()) {\n        for (CoreNLPProtos.Token token : sentence.getTokenList()) {\n          CoreLabel coreLabel = fromProto(token);\n          // Set docid\n          if (proto.hasDocID()) { coreLabel.setDocID(proto.getDocID()); }\n          tokens.add(coreLabel);\n        }\n      }\n    } else if (proto.getSentencelessTokenCount() > 0) {\n      // Eek -- no sentences. Try to recover tokens directly\n      if (proto.getSentencelessTokenCount() > 0) {\n        for (CoreNLPProtos.Token token : proto.getSentencelessTokenList()) {\n          CoreLabel coreLabel = fromProto(token);\n          // Set docid\n          if (proto.hasDocID()) { coreLabel.setDocID(proto.getDocID()); }\n          tokens.add(coreLabel);\n        }\n      }\n    }\n    if (!tokens.isEmpty()) { ann.set(TokensAnnotation.class, tokens); }\n\n    // Add sentences\n    List<CoreMap> sentences = new ArrayList<CoreMap>(proto.getSentenceCount());\n    for (int sentIndex = 0; sentIndex < proto.getSentenceCount(); ++sentIndex) {\n      CoreNLPProtos.Sentence sentence = proto.getSentence(sentIndex);\n      CoreMap map = fromProtoNoTokens(sentence);\n      if (!tokens.isEmpty() && sentence.hasTokenOffsetBegin() && sentence.hasTokenOffsetEnd()) {\n        // Set tokens for sentence\n        map.set(TokensAnnotation.class, tokens.subList(sentence.getTokenOffsetBegin(), sentence.getTokenOffsetEnd()));\n        // Set sentence index + token index + paragraph index\n        for (int i = sentence.getTokenOffsetBegin(); i < sentence.getTokenOffsetEnd(); ++i) {\n          tokens.get(i).setSentIndex(sentIndex);\n          tokens.get(i).setIndex(i - sentence.getTokenOffsetBegin() + 1);\n          if (sentence.hasParagraph()) { tokens.get(i).set(ParagraphAnnotation.class, sentence.getParagraph()); }\n        }\n        // Set text\n        map.set(TextAnnotation.class, proto.getText().substring(sentence.getCharacterOffsetBegin(), sentence.getCharacterOffsetEnd()));\n      }\n      // End iteration\n      sentences.add(map);\n    }\n    if (!sentences.isEmpty()) { ann.set(SentencesAnnotation.class, sentences); }\n\n    // Set DocID\n    String docid = null;\n    if (proto.hasDocID()) {\n      docid = proto.getDocID();\n      ann.set(DocIDAnnotation.class, docid);\n    }\n\n    // Set coref chain\n    Map<Integer, CorefChain> corefChains = new HashMap<Integer, CorefChain>();\n    for (CoreNLPProtos.CorefChain chainProto : proto.getCorefChainList()) {\n      CorefChain chain = fromProto(chainProto, ann);\n      corefChains.put(chain.getChainID(), chain);\n    }\n    if (!corefChains.isEmpty()) { ann.set(CorefChainAnnotation.class, corefChains); }\n\n    // Set dependency graphs\n    // We need to wait until here, since this is the first time we see tokens\n    for (int i = 0; i < proto.getSentenceCount(); ++i) {\n      CoreNLPProtos.Sentence sentence = proto.getSentenceList().get(i);\n      CoreMap map = sentences.get(i);\n      List<CoreLabel> sentenceTokens = map.get(TokensAnnotation.class);\n      if (sentence.hasBasicDependencies()) {\n        map.set(BasicDependenciesAnnotation.class, fromProto(sentence.getBasicDependencies(), sentenceTokens, docid));\n      }\n      if (sentence.hasCollapsedDependencies()) {\n        map.set(CollapsedDependenciesAnnotation.class, fromProto(sentence.getCollapsedDependencies(), sentenceTokens, docid));\n      }\n      if (sentence.hasCollapsedCCProcessedDependencies()) {\n        map.set(CollapsedCCProcessedDependenciesAnnotation.class, fromProto(sentence.getCollapsedCCProcessedDependencies(), sentenceTokens, docid));\n      }\n    }\n\n    // Redo some light annotation\n    for (CoreMap sentence : sentences) {\n      if (sentence.containsKey(TokensAnnotation.class)) {\n        sentence.set(NumerizedTokensAnnotation.class, NumberNormalizer.findAndMergeNumbers(sentence));\n      }\n    }\n\n    // Return\n    return ann;\n  }","id":75032,"modified_method":"/**\n   * Returns a complete document, intended to mimic a document passes as input to\n   * {@link ProtobufAnnotationSerializer#toProto(Annotation)} as closely as possible.\n   * That is, most common fields are serialized, but there is not guarantee that custom additions\n   * will be saved and retrieved.\n   *\n   * @param proto The protocol buffer to read the document from.\n   * @return An Annotation corresponding to the read protobuf.\n   */\n  public Annotation fromProto(CoreNLPProtos.Document proto) {\n    // Set text\n    Annotation ann = new Annotation(proto.getText());\n\n    // Add tokens\n    List<CoreLabel> tokens = new ArrayList<CoreLabel>();\n    if (proto.getSentenceCount() > 0) {\n      // Populate the tokens from the sentence\n      for (CoreNLPProtos.Sentence sentence : proto.getSentenceList()) {\n        for (CoreNLPProtos.Token token : sentence.getTokenList()) {\n          CoreLabel coreLabel = fromProto(token);\n          // Set docid\n          if (proto.hasDocID()) { coreLabel.setDocID(proto.getDocID()); }\n          tokens.add(coreLabel);\n        }\n      }\n    } else if (proto.getSentencelessTokenCount() > 0) {\n      // Eek -- no sentences. Try to recover tokens directly\n      if (proto.getSentencelessTokenCount() > 0) {\n        for (CoreNLPProtos.Token token : proto.getSentencelessTokenList()) {\n          CoreLabel coreLabel = fromProto(token);\n          // Set docid\n          if (proto.hasDocID()) { coreLabel.setDocID(proto.getDocID()); }\n          tokens.add(coreLabel);\n        }\n      }\n    }\n    if (!tokens.isEmpty()) { ann.set(TokensAnnotation.class, tokens); }\n\n    // Add sentences\n    List<CoreMap> sentences = new ArrayList<CoreMap>(proto.getSentenceCount());\n    for (int sentIndex = 0; sentIndex < proto.getSentenceCount(); ++sentIndex) {\n      CoreNLPProtos.Sentence sentence = proto.getSentence(sentIndex);\n      CoreMap map = fromProtoNoTokens(sentence);\n      if (!tokens.isEmpty() && sentence.hasTokenOffsetBegin() && sentence.hasTokenOffsetEnd()) {\n        // Set tokens for sentence\n        int tokenBegin = Math.min(sentence.getTokenOffsetBegin(), tokens.size());\n        int tokenEnd = Math.min(sentence.getTokenOffsetEnd(), tokens.size());\n        map.set(TokensAnnotation.class, tokens.subList(tokenBegin, tokenEnd));\n        // Set sentence index + token index + paragraph index\n        for (int i = tokenBegin; i < tokenEnd; ++i) {\n          tokens.get(i).setSentIndex(sentIndex);\n          tokens.get(i).setIndex(i - sentence.getTokenOffsetBegin() + 1);\n          if (sentence.hasParagraph()) { tokens.get(i).set(ParagraphAnnotation.class, sentence.getParagraph()); }\n        }\n        // Set text\n        int characterBegin = Math.min(sentence.getCharacterOffsetBegin(), proto.getText().length());\n        int characterEnd = Math.min(sentence.getCharacterOffsetEnd(), proto.getText().length());\n        map.set(TextAnnotation.class, proto.getText().substring(characterBegin, characterEnd));\n      }\n      // End iteration\n      sentences.add(map);\n    }\n    if (!sentences.isEmpty()) { ann.set(SentencesAnnotation.class, sentences); }\n\n    // Set DocID\n    String docid = null;\n    if (proto.hasDocID()) {\n      docid = proto.getDocID();\n      ann.set(DocIDAnnotation.class, docid);\n    }\n\n    // Set coref chain\n    Map<Integer, CorefChain> corefChains = new HashMap<Integer, CorefChain>();\n    for (CoreNLPProtos.CorefChain chainProto : proto.getCorefChainList()) {\n      CorefChain chain = fromProto(chainProto, ann);\n      corefChains.put(chain.getChainID(), chain);\n    }\n    if (!corefChains.isEmpty()) { ann.set(CorefChainAnnotation.class, corefChains); }\n\n    // Set dependency graphs\n    // We need to wait until here, since this is the first time we see tokens\n    for (int i = 0; i < proto.getSentenceCount(); ++i) {\n      CoreNLPProtos.Sentence sentence = proto.getSentenceList().get(i);\n      CoreMap map = sentences.get(i);\n      List<CoreLabel> sentenceTokens = map.get(TokensAnnotation.class);\n      if (sentence.hasBasicDependencies()) {\n        map.set(BasicDependenciesAnnotation.class, fromProto(sentence.getBasicDependencies(), sentenceTokens, docid));\n      }\n      if (sentence.hasCollapsedDependencies()) {\n        map.set(CollapsedDependenciesAnnotation.class, fromProto(sentence.getCollapsedDependencies(), sentenceTokens, docid));\n      }\n      if (sentence.hasCollapsedCCProcessedDependencies()) {\n        map.set(CollapsedCCProcessedDependenciesAnnotation.class, fromProto(sentence.getCollapsedCCProcessedDependencies(), sentenceTokens, docid));\n      }\n    }\n\n    // Redo some light annotation\n    for (CoreMap sentence : sentences) {\n      if (sentence.containsKey(TokensAnnotation.class)) {\n        sentence.set(NumerizedTokensAnnotation.class, NumberNormalizer.findAndMergeNumbers(sentence));\n      }\n    }\n\n    // Return\n    return ann;\n  }","commit_id":"cc87fe3e64a1c1fa7b8b9ef71f3d871c0e82ccad","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/** {@inheritDoc} */\n  @Override\n  public Pair<Annotation, InputStream> read(InputStream is) throws IOException, ClassNotFoundException, ClassCastException {\n    CoreNLPProtos.Document doc = CoreNLPProtos.Document.parseFrom(is);\n    return Pair.makePair( fromProto(doc), is );\n  }","id":75033,"modified_method":"/** {@inheritDoc} */\n  @Override\n  public Pair<Annotation, InputStream> read(InputStream is) throws IOException, ClassNotFoundException, ClassCastException {\n    CoreNLPProtos.Document doc = CoreNLPProtos.Document.parseDelimitedFrom(is);\n    return Pair.makePair( fromProto(doc), is );\n  }","commit_id":"cc87fe3e64a1c1fa7b8b9ef71f3d871c0e82ccad","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Returns a complete document, intended to mimic a document passes as input to\n   * {@link ProtobufAnnotationSerializer#toProto(Annotation)} as closely as possible.\n   * That is, most common fields are serialized, but there is not guarantee that custom additions\n   * will be saved and retrieved.\n   *\n   * @param proto The protocol buffer to read the document from.\n   * @return An Annotation corresponding to the read protobuf.\n   */\n  public Annotation fromProto(CoreNLPProtos.Document proto) {\n    // Set text\n    Annotation ann = new Annotation(proto.getText());\n\n    // Add tokens\n    List<CoreLabel> tokens = new ArrayList<CoreLabel>();\n    if (proto.getSentenceCount() > 0) {\n      // Populate the tokens from the sentence\n      for (CoreNLPProtos.Sentence sentence : proto.getSentenceList()) {\n        for (CoreNLPProtos.Token token : sentence.getTokenList()) {\n          CoreLabel coreLabel = fromProto(token);\n          // Set docid\n          if (proto.hasDocID()) { coreLabel.setDocID(proto.getDocID()); }\n          tokens.add(coreLabel);\n        }\n      }\n    } else if (proto.getSentencelessTokenCount() > 0) {\n      // Eek -- no sentences. Try to recover tokens directly\n      if (proto.getSentencelessTokenCount() > 0) {\n        for (CoreNLPProtos.Token token : proto.getSentencelessTokenList()) {\n          CoreLabel coreLabel = fromProto(token);\n          // Set docid\n          if (proto.hasDocID()) { coreLabel.setDocID(proto.getDocID()); }\n          tokens.add(coreLabel);\n        }\n      }\n    }\n    if (!tokens.isEmpty()) { ann.set(TokensAnnotation.class, tokens); }\n\n    // Add sentences\n    List<CoreMap> sentences = new ArrayList<CoreMap>(proto.getSentenceCount());\n    for (int sentIndex = 0; sentIndex < proto.getSentenceCount(); ++sentIndex) {\n      CoreNLPProtos.Sentence sentence = proto.getSentence(sentIndex);\n      CoreMap map = fromProtoNoTokens(sentence);\n      if (!tokens.isEmpty() && sentence.hasTokenOffsetBegin() && sentence.hasTokenOffsetEnd()) {\n        // Set tokens for sentence\n        map.set(TokensAnnotation.class, tokens.subList(sentence.getTokenOffsetBegin(), sentence.getTokenOffsetEnd()));\n        // Set sentence index + token index + paragraph index\n        for (int i = sentence.getTokenOffsetBegin(); i < sentence.getTokenOffsetEnd(); ++i) {\n          tokens.get(i).setSentIndex(sentIndex);\n          tokens.get(i).setIndex(i - sentence.getTokenOffsetBegin() + 1);\n          if (sentence.hasParagraph()) { tokens.get(i).set(ParagraphAnnotation.class, sentence.getParagraph()); }\n        }\n        // Set text\n        map.set(TextAnnotation.class, proto.getText().substring(sentence.getCharacterOffsetBegin(), sentence.getCharacterOffsetEnd()));\n      }\n      // End iteration\n      sentences.add(map);\n    }\n    if (!sentences.isEmpty()) { ann.set(SentencesAnnotation.class, sentences); }\n\n    // Set DocID\n    String docid = null;\n    if (proto.hasDocID()) {\n      docid = proto.getDocID();\n      ann.set(DocIDAnnotation.class, docid);\n    }\n\n    // Set coref chain\n    Map<Integer, CorefChain> corefChains = new HashMap<Integer, CorefChain>();\n    for (CoreNLPProtos.CorefChain chainProto : proto.getCorefChainList()) {\n      CorefChain chain = fromProto(chainProto, ann);\n      corefChains.put(chain.getChainID(), chain);\n    }\n    if (!corefChains.isEmpty()) { ann.set(CorefChainAnnotation.class, corefChains); }\n\n    // Set dependency graphs\n    // We need to wait until here, since this is the first time we see tokens\n    for (int i = 0; i < proto.getSentenceCount(); ++i) {\n      CoreNLPProtos.Sentence sentence = proto.getSentenceList().get(i);\n      CoreMap map = sentences.get(i);\n      List<CoreLabel> sentenceTokens = map.get(TokensAnnotation.class);\n      if (sentence.hasBasicDependencies()) {\n        map.set(BasicDependenciesAnnotation.class, fromProto(sentence.getBasicDependencies(), sentenceTokens, docid));\n      }\n      if (sentence.hasCollapsedDependencies()) {\n        map.set(CollapsedDependenciesAnnotation.class, fromProto(sentence.getCollapsedDependencies(), sentenceTokens, docid));\n      }\n      if (sentence.hasCollapsedCCProcessedDependencies()) {\n        map.set(CollapsedCCProcessedDependenciesAnnotation.class, fromProto(sentence.getCollapsedCCProcessedDependencies(), sentenceTokens, docid));\n      }\n    }\n\n    // Redo some light annotation\n    for (CoreMap sentence : sentences) {\n      if (sentence.containsKey(TokensAnnotation.class)) {\n        sentence.set(NumerizedTokensAnnotation.class, NumberNormalizer.findAndMergeNumbers(sentence));\n      }\n    }\n\n    // Return\n    return ann;\n  }","id":75034,"modified_method":"/**\n   * Returns a complete document, intended to mimic a document passes as input to\n   * {@link ProtobufAnnotationSerializer#toProto(Annotation)} as closely as possible.\n   * That is, most common fields are serialized, but there is not guarantee that custom additions\n   * will be saved and retrieved.\n   *\n   * @param proto The protocol buffer to read the document from.\n   * @return An Annotation corresponding to the read protobuf.\n   */\n  public Annotation fromProto(CoreNLPProtos.Document proto) {\n    // Set text\n    Annotation ann = new Annotation(proto.getText());\n\n    // Add tokens\n    List<CoreLabel> tokens = new ArrayList<CoreLabel>();\n    if (proto.getSentenceCount() > 0) {\n      // Populate the tokens from the sentence\n      for (CoreNLPProtos.Sentence sentence : proto.getSentenceList()) {\n        for (CoreNLPProtos.Token token : sentence.getTokenList()) {\n          CoreLabel coreLabel = fromProto(token);\n          // Set docid\n          if (proto.hasDocID()) { coreLabel.setDocID(proto.getDocID()); }\n          tokens.add(coreLabel);\n        }\n      }\n    } else if (proto.getSentencelessTokenCount() > 0) {\n      // Eek -- no sentences. Try to recover tokens directly\n      if (proto.getSentencelessTokenCount() > 0) {\n        for (CoreNLPProtos.Token token : proto.getSentencelessTokenList()) {\n          CoreLabel coreLabel = fromProto(token);\n          // Set docid\n          if (proto.hasDocID()) { coreLabel.setDocID(proto.getDocID()); }\n          tokens.add(coreLabel);\n        }\n      }\n    }\n    if (!tokens.isEmpty()) { ann.set(TokensAnnotation.class, tokens); }\n\n    // Add sentences\n    List<CoreMap> sentences = new ArrayList<CoreMap>(proto.getSentenceCount());\n    for (int sentIndex = 0; sentIndex < proto.getSentenceCount(); ++sentIndex) {\n      CoreNLPProtos.Sentence sentence = proto.getSentence(sentIndex);\n      CoreMap map = fromProtoNoTokens(sentence);\n      if (!tokens.isEmpty() && sentence.hasTokenOffsetBegin() && sentence.hasTokenOffsetEnd()) {\n        // Set tokens for sentence\n        int tokenBegin = Math.min(sentence.getTokenOffsetBegin(), tokens.size());\n        int tokenEnd = Math.min(sentence.getTokenOffsetEnd(), tokens.size());\n        map.set(TokensAnnotation.class, tokens.subList(tokenBegin, tokenEnd));\n        // Set sentence index + token index + paragraph index\n        for (int i = tokenBegin; i < tokenEnd; ++i) {\n          tokens.get(i).setSentIndex(sentIndex);\n          tokens.get(i).setIndex(i - sentence.getTokenOffsetBegin() + 1);\n          if (sentence.hasParagraph()) { tokens.get(i).set(ParagraphAnnotation.class, sentence.getParagraph()); }\n        }\n        // Set text\n        int characterBegin = Math.min(sentence.getCharacterOffsetBegin(), proto.getText().length());\n        int characterEnd = Math.min(sentence.getCharacterOffsetEnd(), proto.getText().length());\n        map.set(TextAnnotation.class, proto.getText().substring(characterBegin, characterEnd));\n      }\n      // End iteration\n      sentences.add(map);\n    }\n    if (!sentences.isEmpty()) { ann.set(SentencesAnnotation.class, sentences); }\n\n    // Set DocID\n    String docid = null;\n    if (proto.hasDocID()) {\n      docid = proto.getDocID();\n      ann.set(DocIDAnnotation.class, docid);\n    }\n\n    // Set coref chain\n    Map<Integer, CorefChain> corefChains = new HashMap<Integer, CorefChain>();\n    for (CoreNLPProtos.CorefChain chainProto : proto.getCorefChainList()) {\n      CorefChain chain = fromProto(chainProto, ann);\n      corefChains.put(chain.getChainID(), chain);\n    }\n    if (!corefChains.isEmpty()) { ann.set(CorefChainAnnotation.class, corefChains); }\n\n    // Set dependency graphs\n    // We need to wait until here, since this is the first time we see tokens\n    for (int i = 0; i < proto.getSentenceCount(); ++i) {\n      CoreNLPProtos.Sentence sentence = proto.getSentenceList().get(i);\n      CoreMap map = sentences.get(i);\n      List<CoreLabel> sentenceTokens = map.get(TokensAnnotation.class);\n      if (sentence.hasBasicDependencies()) {\n        map.set(BasicDependenciesAnnotation.class, fromProto(sentence.getBasicDependencies(), sentenceTokens, docid));\n      }\n      if (sentence.hasCollapsedDependencies()) {\n        map.set(CollapsedDependenciesAnnotation.class, fromProto(sentence.getCollapsedDependencies(), sentenceTokens, docid));\n      }\n      if (sentence.hasCollapsedCCProcessedDependencies()) {\n        map.set(CollapsedCCProcessedDependenciesAnnotation.class, fromProto(sentence.getCollapsedCCProcessedDependencies(), sentenceTokens, docid));\n      }\n    }\n\n    // Redo some light annotation\n    for (CoreMap sentence : sentences) {\n      if (sentence.containsKey(TokensAnnotation.class)) {\n        sentence.set(NumerizedTokensAnnotation.class, NumberNormalizer.findAndMergeNumbers(sentence));\n      }\n    }\n\n    // Return\n    return ann;\n  }","commit_id":"615d3043b35164888b1125ab4a677e1163c00938","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/** {@inheritDoc} */\n  @Override\n  public OutputStream write(Annotation corpus, OutputStream os) throws IOException {\n    CoreNLPProtos.Document serialized = toProto(corpus);\n    serialized.writeTo(os);\n    os.flush();\n    return os;\n  }","id":75035,"modified_method":"/** {@inheritDoc} */\n  @Override\n  public OutputStream write(Annotation corpus, OutputStream os) throws IOException {\n    CoreNLPProtos.Document serialized = toProto(corpus);\n    serialized.writeDelimitedTo(os);\n    os.flush();\n    return os;\n  }","commit_id":"615d3043b35164888b1125ab4a677e1163c00938","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/** {@inheritDoc} */\n  @Override\n  public Pair<Annotation, InputStream> read(InputStream is) throws IOException, ClassNotFoundException, ClassCastException {\n    CoreNLPProtos.Document doc = CoreNLPProtos.Document.parseFrom(is);\n    return Pair.makePair( fromProto(doc), is );\n  }","id":75036,"modified_method":"/** {@inheritDoc} */\n  @Override\n  public Pair<Annotation, InputStream> read(InputStream is) throws IOException, ClassNotFoundException, ClassCastException {\n    CoreNLPProtos.Document doc = CoreNLPProtos.Document.parseDelimitedFrom(is);\n    return Pair.makePair( fromProto(doc), is );\n  }","commit_id":"615d3043b35164888b1125ab4a677e1163c00938","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Returns a complete document, intended to mimic a document passes as input to\n   * {@link ProtobufAnnotationSerializer#toProto(Annotation)} as closely as possible.\n   * That is, most common fields are serialized, but there is not guarantee that custom additions\n   * will be saved and retrieved.\n   *\n   * @param proto The protocol buffer to read the document from.\n   * @return An Annotation corresponding to the read protobuf.\n   */\n  public Annotation fromProto(CoreNLPProtos.Document proto) {\n    // Set text\n    Annotation ann = new Annotation(proto.getText());\n\n    // Add tokens\n    List<CoreLabel> tokens = new ArrayList<CoreLabel>();\n    if (proto.getSentenceCount() > 0) {\n      // Populate the tokens from the sentence\n      for (CoreNLPProtos.Sentence sentence : proto.getSentenceList()) {\n        for (CoreNLPProtos.Token token : sentence.getTokenList()) {\n          CoreLabel coreLabel = fromProto(token);\n          // Set docid\n          if (proto.hasDocID()) { coreLabel.setDocID(proto.getDocID()); }\n          tokens.add(coreLabel);\n        }\n      }\n    } else if (proto.getSentencelessTokenCount() > 0) {\n      // Eek -- no sentences. Try to recover tokens directly\n      if (proto.getSentencelessTokenCount() > 0) {\n        for (CoreNLPProtos.Token token : proto.getSentencelessTokenList()) {\n          CoreLabel coreLabel = fromProto(token);\n          // Set docid\n          if (proto.hasDocID()) { coreLabel.setDocID(proto.getDocID()); }\n          tokens.add(coreLabel);\n        }\n      }\n    }\n    if (!tokens.isEmpty()) { ann.set(TokensAnnotation.class, tokens); }\n\n    // Add sentences\n    List<CoreMap> sentences = new ArrayList<CoreMap>(proto.getSentenceCount());\n    for (int sentIndex = 0; sentIndex < proto.getSentenceCount(); ++sentIndex) {\n      CoreNLPProtos.Sentence sentence = proto.getSentence(sentIndex);\n      CoreMap map = fromProtoNoTokens(sentence);\n      if (!tokens.isEmpty() && sentence.hasTokenOffsetBegin() && sentence.hasTokenOffsetEnd()) {\n        // Set tokens for sentence\n        int tokenBegin = Math.min(sentence.getTokenOffsetBegin(), tokens.size());\n        int tokenEnd = Math.min(sentence.getTokenOffsetEnd(), tokens.size());\n        map.set(TokensAnnotation.class, tokens.subList(tokenBegin, tokenEnd));\n        // Set sentence index + token index + paragraph index\n        for (int i = tokenBegin; i < tokenEnd; ++i) {\n          tokens.get(i).setSentIndex(sentIndex);\n          tokens.get(i).setIndex(i - sentence.getTokenOffsetBegin() + 1);\n          if (sentence.hasParagraph()) { tokens.get(i).set(ParagraphAnnotation.class, sentence.getParagraph()); }\n        }\n        // Set text\n        int characterBegin = Math.min(sentence.getCharacterOffsetBegin(), proto.getText().length());\n        int characterEnd = Math.min(sentence.getCharacterOffsetEnd(), proto.getText().length());\n        map.set(TextAnnotation.class, proto.getText().substring(characterBegin, characterEnd));\n      }\n      // End iteration\n      sentences.add(map);\n    }\n    if (!sentences.isEmpty()) { ann.set(SentencesAnnotation.class, sentences); }\n\n    // Set DocID\n    String docid = null;\n    if (proto.hasDocID()) {\n      docid = proto.getDocID();\n      ann.set(DocIDAnnotation.class, docid);\n    }\n\n    // Set coref chain\n    Map<Integer, CorefChain> corefChains = new HashMap<Integer, CorefChain>();\n    for (CoreNLPProtos.CorefChain chainProto : proto.getCorefChainList()) {\n      CorefChain chain = fromProto(chainProto, ann);\n      corefChains.put(chain.getChainID(), chain);\n    }\n    if (!corefChains.isEmpty()) { ann.set(CorefChainAnnotation.class, corefChains); }\n\n    // Set dependency graphs\n    // We need to wait until here, since this is the first time we see tokens\n    for (int i = 0; i < proto.getSentenceCount(); ++i) {\n      CoreNLPProtos.Sentence sentence = proto.getSentenceList().get(i);\n      CoreMap map = sentences.get(i);\n      List<CoreLabel> sentenceTokens = map.get(TokensAnnotation.class);\n      if (sentence.hasBasicDependencies()) {\n        map.set(BasicDependenciesAnnotation.class, fromProto(sentence.getBasicDependencies(), sentenceTokens, docid));\n      }\n      if (sentence.hasCollapsedDependencies()) {\n        map.set(CollapsedDependenciesAnnotation.class, fromProto(sentence.getCollapsedDependencies(), sentenceTokens, docid));\n      }\n      if (sentence.hasCollapsedCCProcessedDependencies()) {\n        map.set(CollapsedCCProcessedDependenciesAnnotation.class, fromProto(sentence.getCollapsedCCProcessedDependencies(), sentenceTokens, docid));\n      }\n    }\n\n    // Redo some light annotation\n    for (CoreMap sentence : sentences) {\n      if (sentence.containsKey(TokensAnnotation.class)) {\n        sentence.set(NumerizedTokensAnnotation.class, NumberNormalizer.findAndMergeNumbers(sentence));\n      }\n    }\n\n    // Return\n    return ann;\n  }","id":75037,"modified_method":"/**\n   * Returns a complete document, intended to mimic a document passes as input to\n   * {@link ProtobufAnnotationSerializer#toProto(Annotation)} as closely as possible.\n   * That is, most common fields are serialized, but there is not guarantee that custom additions\n   * will be saved and retrieved.\n   *\n   * @param proto The protocol buffer to read the document from.\n   * @return An Annotation corresponding to the read protobuf.\n   */\n  public Annotation fromProto(CoreNLPProtos.Document proto) {\n    // Set text\n    Annotation ann = new Annotation(proto.getText());\n\n    // Add tokens\n    List<CoreLabel> tokens = new ArrayList<CoreLabel>();\n    if (proto.getSentenceCount() > 0) {\n      // Populate the tokens from the sentence\n      for (CoreNLPProtos.Sentence sentence : proto.getSentenceList()) {\n        // It's conceivable that the sentences are not contiguous -- pad this with nulls\n        while (sentence.hasTokenOffsetBegin() && tokens.size() < sentence.getTokenOffsetBegin()) {\n          tokens.add(null);\n        }\n        // Read the sentence\n        for (CoreNLPProtos.Token token : sentence.getTokenList()) {\n          CoreLabel coreLabel = fromProto(token);\n          // Set docid\n          if (proto.hasDocID()) { coreLabel.setDocID(proto.getDocID()); }\n          tokens.add(coreLabel);\n        }\n      }\n    } else if (proto.getSentencelessTokenCount() > 0) {\n      // Eek -- no sentences. Try to recover tokens directly\n      if (proto.getSentencelessTokenCount() > 0) {\n        for (CoreNLPProtos.Token token : proto.getSentencelessTokenList()) {\n          CoreLabel coreLabel = fromProto(token);\n          // Set docid\n          if (proto.hasDocID()) { coreLabel.setDocID(proto.getDocID()); }\n          tokens.add(coreLabel);\n        }\n      }\n    }\n    if (!tokens.isEmpty()) { ann.set(TokensAnnotation.class, tokens); }\n\n    // Add sentences\n    List<CoreMap> sentences = new ArrayList<CoreMap>(proto.getSentenceCount());\n    for (int sentIndex = 0; sentIndex < proto.getSentenceCount(); ++sentIndex) {\n      CoreNLPProtos.Sentence sentence = proto.getSentence(sentIndex);\n      CoreMap map = fromProtoNoTokens(sentence);\n      if (!tokens.isEmpty() && sentence.hasTokenOffsetBegin() && sentence.hasTokenOffsetEnd() &&\n          map.get(TokensAnnotation.class) == null) {\n        // Set tokens for sentence\n        int tokenBegin = sentence.getTokenOffsetBegin();\n        int tokenEnd = sentence.getTokenOffsetEnd();\n        assert tokenBegin <= tokens.size() && tokenBegin <= tokenEnd;\n        assert tokenEnd <= tokens.size();\n        map.set(TokensAnnotation.class, tokens.subList(tokenBegin, tokenEnd));\n        // Set sentence index + token index + paragraph index\n        for (int i = tokenBegin; i < tokenEnd; ++i) {\n          tokens.get(i).setSentIndex(sentIndex);\n          tokens.get(i).setIndex(i - sentence.getTokenOffsetBegin() + 1);\n          if (sentence.hasParagraph()) { tokens.get(i).set(ParagraphAnnotation.class, sentence.getParagraph()); }\n        }\n        // Set text\n        int characterBegin = sentence.getCharacterOffsetBegin();\n        int characterEnd = sentence.getCharacterOffsetEnd();\n        if (characterEnd <= proto.getText().length()) {\n          // The usual case -- get the text from the document text\n          map.set(TextAnnotation.class, proto.getText().substring(characterBegin, characterEnd));\n        } else {\n          // The document text is wrong -- guess the text from the tokens\n          map.set(TextAnnotation.class, recoverOriginalText(tokens.subList(tokenBegin, tokenEnd)));\n        }\n      }\n      // End iteration\n      sentences.add(map);\n    }\n    if (!sentences.isEmpty()) { ann.set(SentencesAnnotation.class, sentences); }\n\n    // Set DocID\n    String docid = null;\n    if (proto.hasDocID()) {\n      docid = proto.getDocID();\n      ann.set(DocIDAnnotation.class, docid);\n    }\n\n    // Set coref chain\n    Map<Integer, CorefChain> corefChains = new HashMap<Integer, CorefChain>();\n    for (CoreNLPProtos.CorefChain chainProto : proto.getCorefChainList()) {\n      CorefChain chain = fromProto(chainProto, ann);\n      corefChains.put(chain.getChainID(), chain);\n    }\n    if (!corefChains.isEmpty()) { ann.set(CorefChainAnnotation.class, corefChains); }\n\n    // Set dependency graphs\n    // We need to wait until here, since this is the first time we see tokens\n    for (int i = 0; i < proto.getSentenceCount(); ++i) {\n      CoreNLPProtos.Sentence sentence = proto.getSentenceList().get(i);\n      CoreMap map = sentences.get(i);\n      List<CoreLabel> sentenceTokens = map.get(TokensAnnotation.class);\n      if (sentence.hasBasicDependencies()) {\n        map.set(BasicDependenciesAnnotation.class, fromProto(sentence.getBasicDependencies(), sentenceTokens, docid));\n      }\n      if (sentence.hasCollapsedDependencies()) {\n        map.set(CollapsedDependenciesAnnotation.class, fromProto(sentence.getCollapsedDependencies(), sentenceTokens, docid));\n      }\n      if (sentence.hasCollapsedCCProcessedDependencies()) {\n        map.set(CollapsedCCProcessedDependenciesAnnotation.class, fromProto(sentence.getCollapsedCCProcessedDependencies(), sentenceTokens, docid));\n      }\n    }\n\n    // Redo some light annotation\n    for (CoreMap sentence : sentences) {\n      if (sentence.containsKey(TokensAnnotation.class)) {\n        sentence.set(NumerizedTokensAnnotation.class, NumberNormalizer.findAndMergeNumbers(sentence));\n      }\n    }\n\n    // Return\n    return ann;\n  }","commit_id":"e23af2f9b72b18996a4dbc929f81d1e7cc429458","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Create a CoreMap representing a sentence from this protocol buffer.\n   * This should not be used if you are reading a whole document, as it populates the tokens independent of the\n   * document tokens, which is not the behavior an {@link edu.stanford.nlp.pipeline.Annotation} expects.\n   *\n   * @param proto The protocol buffer to read from.\n   * @return A CoreMap representing the sentence.\n   */\n  public CoreMap fromProto(CoreNLPProtos.Sentence proto) {\n    CoreMap lossySentence = fromProtoNoTokens(proto);\n    // Add tokens -- missing by default as they're populated as sublists of the\n    // document tokens\n    List<CoreLabel> tokens = new ArrayList<CoreLabel>();\n    for (CoreNLPProtos.Token token : proto.getTokenList()) {\n      tokens.add(fromProto(token));\n    }\n    lossySentence.set(TokensAnnotation.class, tokens);\n    // Add text -- missing by default as it's populated from the Document\n    StringBuilder text = new StringBuilder();\n    if (tokens.size() > 0) {\n      if (tokens.get(0).before() != null) { text.append(tokens.get(0).before()); }\n    }\n    for (CoreLabel token : tokens) {\n      if (token.originalText() != null) { text.append(token.originalText()); } else { text.append(token.word()); }\n      if (token.after() != null) { text.append(token.after()); }\n    }\n    lossySentence.set(TextAnnotation.class, text.toString());\n    // Return\n    return lossySentence;\n  }","id":75038,"modified_method":"/**\n   * Create a CoreMap representing a sentence from this protocol buffer.\n   * This should not be used if you are reading a whole document, as it populates the tokens independent of the\n   * document tokens, which is not the behavior an {@link edu.stanford.nlp.pipeline.Annotation} expects.\n   *\n   * @param proto The protocol buffer to read from.\n   * @return A CoreMap representing the sentence.\n   */\n  public CoreMap fromProto(CoreNLPProtos.Sentence proto) {\n    CoreMap lossySentence = fromProtoNoTokens(proto);\n    // Add tokens -- missing by default as they're populated as sublists of the\n    // document tokens\n    List<CoreLabel> tokens = new ArrayList<CoreLabel>();\n    for (CoreNLPProtos.Token token : proto.getTokenList()) {\n      tokens.add(fromProto(token));\n    }\n    lossySentence.set(TokensAnnotation.class, tokens);\n    // Add text -- missing by default as it's populated from the Document\n    lossySentence.set(TextAnnotation.class, recoverOriginalText(tokens));\n    // Return\n    return lossySentence;\n  }","commit_id":"e23af2f9b72b18996a4dbc929f81d1e7cc429458","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Create a CoreMap representing a sentence from this protocol buffer.\n   * This should not be used if you are reading a whole document, as it populates the tokens independent of the\n   * document tokens, which is not the behavior an {@link edu.stanford.nlp.pipeline.Annotation} expects.\n   *\n   * @param proto The protocol buffer to read from.\n   * @return A CoreMap representing the sentence.\n   */\n  public CoreMap fromProto(CoreNLPProtos.Sentence proto) {\n    CoreMap lossySentence = fromProtoNoTokens(proto);\n    // Add tokens -- missing by default as they're populated as sublists of the\n    // document tokens\n    List<CoreLabel> tokens = new ArrayList<CoreLabel>();\n    for (CoreNLPProtos.Token token : proto.getTokenList()) {\n      tokens.add(fromProto(token));\n    }\n    lossySentence.set(TokensAnnotation.class, tokens);\n    // Add text -- missing by default as it's populated from the Document\n    StringBuilder text = new StringBuilder();\n    if (tokens.size() > 0) {\n      if (tokens.get(0).before() != null) { text.append(tokens.get(0).before()); }\n    }\n    for (CoreLabel token : tokens) {\n      if (token.originalText() != null) { text.append(token.originalText()); } else { text.append(token.word()); }\n      if (token.after() != null) { text.append(token.after()); }\n    }\n    lossySentence.set(TextAnnotation.class, text.toString());\n    // Return\n    return lossySentence;\n  }","id":75039,"modified_method":"/**\n   * Create a CoreMap representing a sentence from this protocol buffer.\n   * This should not be used if you are reading a whole document, as it populates the tokens independent of the\n   * document tokens, which is not the behavior an {@link edu.stanford.nlp.pipeline.Annotation} expects.\n   *\n   * @param proto The protocol buffer to read from.\n   * @return A CoreMap representing the sentence.\n   */\n  public CoreMap fromProto(CoreNLPProtos.Sentence proto) {\n    CoreMap lossySentence = fromProtoNoTokens(proto);\n    // Add tokens -- missing by default as they're populated as sublists of the\n    // document tokens\n    List<CoreLabel> tokens = new ArrayList<CoreLabel>();\n    for (CoreNLPProtos.Token token : proto.getTokenList()) {\n      tokens.add(fromProto(token));\n    }\n    lossySentence.set(TokensAnnotation.class, tokens);\n    // Add text -- missing by default as it's populated from the Document\n    lossySentence.set(TextAnnotation.class, recoverOriginalText(tokens));\n    // Return\n    return lossySentence;\n  }","commit_id":"691595264a59c8cf4f6b716376fd8a5cf374e119","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Returns a complete document, intended to mimic a document passes as input to\n   * {@link ProtobufAnnotationSerializer#toProto(Annotation)} as closely as possible.\n   * That is, most common fields are serialized, but there is not guarantee that custom additions\n   * will be saved and retrieved.\n   *\n   * @param proto The protocol buffer to read the document from.\n   * @return An Annotation corresponding to the read protobuf.\n   */\n  public Annotation fromProto(CoreNLPProtos.Document proto) {\n    // Set text\n    Annotation ann = new Annotation(proto.getText());\n\n    // Add tokens\n    List<CoreLabel> tokens = new ArrayList<CoreLabel>();\n    if (proto.getSentenceCount() > 0) {\n      // Populate the tokens from the sentence\n      for (CoreNLPProtos.Sentence sentence : proto.getSentenceList()) {\n        for (CoreNLPProtos.Token token : sentence.getTokenList()) {\n          CoreLabel coreLabel = fromProto(token);\n          // Set docid\n          if (proto.hasDocID()) { coreLabel.setDocID(proto.getDocID()); }\n          tokens.add(coreLabel);\n        }\n      }\n    } else if (proto.getSentencelessTokenCount() > 0) {\n      // Eek -- no sentences. Try to recover tokens directly\n      if (proto.getSentencelessTokenCount() > 0) {\n        for (CoreNLPProtos.Token token : proto.getSentencelessTokenList()) {\n          CoreLabel coreLabel = fromProto(token);\n          // Set docid\n          if (proto.hasDocID()) { coreLabel.setDocID(proto.getDocID()); }\n          tokens.add(coreLabel);\n        }\n      }\n    }\n    if (!tokens.isEmpty()) { ann.set(TokensAnnotation.class, tokens); }\n\n    // Add sentences\n    List<CoreMap> sentences = new ArrayList<CoreMap>(proto.getSentenceCount());\n    for (int sentIndex = 0; sentIndex < proto.getSentenceCount(); ++sentIndex) {\n      CoreNLPProtos.Sentence sentence = proto.getSentence(sentIndex);\n      CoreMap map = fromProtoNoTokens(sentence);\n      if (!tokens.isEmpty() && sentence.hasTokenOffsetBegin() && sentence.hasTokenOffsetEnd()) {\n        // Set tokens for sentence\n        int tokenBegin = Math.min(sentence.getTokenOffsetBegin(), tokens.size());\n        int tokenEnd = Math.min(sentence.getTokenOffsetEnd(), tokens.size());\n        map.set(TokensAnnotation.class, tokens.subList(tokenBegin, tokenEnd));\n        // Set sentence index + token index + paragraph index\n        for (int i = tokenBegin; i < tokenEnd; ++i) {\n          tokens.get(i).setSentIndex(sentIndex);\n          tokens.get(i).setIndex(i - sentence.getTokenOffsetBegin() + 1);\n          if (sentence.hasParagraph()) { tokens.get(i).set(ParagraphAnnotation.class, sentence.getParagraph()); }\n        }\n        // Set text\n        int characterBegin = Math.min(sentence.getCharacterOffsetBegin(), proto.getText().length());\n        int characterEnd = Math.min(sentence.getCharacterOffsetEnd(), proto.getText().length());\n        map.set(TextAnnotation.class, proto.getText().substring(characterBegin, characterEnd));\n      }\n      // End iteration\n      sentences.add(map);\n    }\n    if (!sentences.isEmpty()) { ann.set(SentencesAnnotation.class, sentences); }\n\n    // Set DocID\n    String docid = null;\n    if (proto.hasDocID()) {\n      docid = proto.getDocID();\n      ann.set(DocIDAnnotation.class, docid);\n    }\n\n    // Set coref chain\n    Map<Integer, CorefChain> corefChains = new HashMap<Integer, CorefChain>();\n    for (CoreNLPProtos.CorefChain chainProto : proto.getCorefChainList()) {\n      CorefChain chain = fromProto(chainProto, ann);\n      corefChains.put(chain.getChainID(), chain);\n    }\n    if (!corefChains.isEmpty()) { ann.set(CorefChainAnnotation.class, corefChains); }\n\n    // Set dependency graphs\n    // We need to wait until here, since this is the first time we see tokens\n    for (int i = 0; i < proto.getSentenceCount(); ++i) {\n      CoreNLPProtos.Sentence sentence = proto.getSentenceList().get(i);\n      CoreMap map = sentences.get(i);\n      List<CoreLabel> sentenceTokens = map.get(TokensAnnotation.class);\n      if (sentence.hasBasicDependencies()) {\n        map.set(BasicDependenciesAnnotation.class, fromProto(sentence.getBasicDependencies(), sentenceTokens, docid));\n      }\n      if (sentence.hasCollapsedDependencies()) {\n        map.set(CollapsedDependenciesAnnotation.class, fromProto(sentence.getCollapsedDependencies(), sentenceTokens, docid));\n      }\n      if (sentence.hasCollapsedCCProcessedDependencies()) {\n        map.set(CollapsedCCProcessedDependenciesAnnotation.class, fromProto(sentence.getCollapsedCCProcessedDependencies(), sentenceTokens, docid));\n      }\n    }\n\n    // Redo some light annotation\n    for (CoreMap sentence : sentences) {\n      if (sentence.containsKey(TokensAnnotation.class)) {\n        sentence.set(NumerizedTokensAnnotation.class, NumberNormalizer.findAndMergeNumbers(sentence));\n      }\n    }\n\n    // Return\n    return ann;\n  }","id":75040,"modified_method":"/**\n   * Returns a complete document, intended to mimic a document passes as input to\n   * {@link ProtobufAnnotationSerializer#toProto(Annotation)} as closely as possible.\n   * That is, most common fields are serialized, but there is not guarantee that custom additions\n   * will be saved and retrieved.\n   *\n   * @param proto The protocol buffer to read the document from.\n   * @return An Annotation corresponding to the read protobuf.\n   */\n  public Annotation fromProto(CoreNLPProtos.Document proto) {\n    // Set text\n    Annotation ann = new Annotation(proto.getText());\n\n    // Add tokens\n    List<CoreLabel> tokens = new ArrayList<CoreLabel>();\n    if (proto.getSentenceCount() > 0) {\n      // Populate the tokens from the sentence\n      for (CoreNLPProtos.Sentence sentence : proto.getSentenceList()) {\n        // It's conceivable that the sentences are not contiguous -- pad this with nulls\n        while (sentence.hasTokenOffsetBegin() && tokens.size() < sentence.getTokenOffsetBegin()) {\n          tokens.add(null);\n        }\n        // Read the sentence\n        for (CoreNLPProtos.Token token : sentence.getTokenList()) {\n          CoreLabel coreLabel = fromProto(token);\n          // Set docid\n          if (proto.hasDocID()) { coreLabel.setDocID(proto.getDocID()); }\n          tokens.add(coreLabel);\n        }\n      }\n    } else if (proto.getSentencelessTokenCount() > 0) {\n      // Eek -- no sentences. Try to recover tokens directly\n      if (proto.getSentencelessTokenCount() > 0) {\n        for (CoreNLPProtos.Token token : proto.getSentencelessTokenList()) {\n          CoreLabel coreLabel = fromProto(token);\n          // Set docid\n          if (proto.hasDocID()) { coreLabel.setDocID(proto.getDocID()); }\n          tokens.add(coreLabel);\n        }\n      }\n    }\n    if (!tokens.isEmpty()) { ann.set(TokensAnnotation.class, tokens); }\n\n    // Add sentences\n    List<CoreMap> sentences = new ArrayList<CoreMap>(proto.getSentenceCount());\n    for (int sentIndex = 0; sentIndex < proto.getSentenceCount(); ++sentIndex) {\n      CoreNLPProtos.Sentence sentence = proto.getSentence(sentIndex);\n      CoreMap map = fromProtoNoTokens(sentence);\n      if (!tokens.isEmpty() && sentence.hasTokenOffsetBegin() && sentence.hasTokenOffsetEnd() &&\n          map.get(TokensAnnotation.class) == null) {\n        // Set tokens for sentence\n        int tokenBegin = sentence.getTokenOffsetBegin();\n        int tokenEnd = sentence.getTokenOffsetEnd();\n        assert tokenBegin <= tokens.size() && tokenBegin <= tokenEnd;\n        assert tokenEnd <= tokens.size();\n        map.set(TokensAnnotation.class, tokens.subList(tokenBegin, tokenEnd));\n        // Set sentence index + token index + paragraph index\n        for (int i = tokenBegin; i < tokenEnd; ++i) {\n          tokens.get(i).setSentIndex(sentIndex);\n          tokens.get(i).setIndex(i - sentence.getTokenOffsetBegin() + 1);\n          if (sentence.hasParagraph()) { tokens.get(i).set(ParagraphAnnotation.class, sentence.getParagraph()); }\n        }\n        // Set text\n        int characterBegin = sentence.getCharacterOffsetBegin();\n        int characterEnd = sentence.getCharacterOffsetEnd();\n        if (characterEnd <= proto.getText().length()) {\n          // The usual case -- get the text from the document text\n          map.set(TextAnnotation.class, proto.getText().substring(characterBegin, characterEnd));\n        } else {\n          // The document text is wrong -- guess the text from the tokens\n          map.set(TextAnnotation.class, recoverOriginalText(tokens.subList(tokenBegin, tokenEnd)));\n        }\n      }\n      // End iteration\n      sentences.add(map);\n    }\n    if (!sentences.isEmpty()) { ann.set(SentencesAnnotation.class, sentences); }\n\n    // Set DocID\n    String docid = null;\n    if (proto.hasDocID()) {\n      docid = proto.getDocID();\n      ann.set(DocIDAnnotation.class, docid);\n    }\n\n    // Set coref chain\n    Map<Integer, CorefChain> corefChains = new HashMap<Integer, CorefChain>();\n    for (CoreNLPProtos.CorefChain chainProto : proto.getCorefChainList()) {\n      CorefChain chain = fromProto(chainProto, ann);\n      corefChains.put(chain.getChainID(), chain);\n    }\n    if (!corefChains.isEmpty()) { ann.set(CorefChainAnnotation.class, corefChains); }\n\n    // Set dependency graphs\n    // We need to wait until here, since this is the first time we see tokens\n    for (int i = 0; i < proto.getSentenceCount(); ++i) {\n      CoreNLPProtos.Sentence sentence = proto.getSentenceList().get(i);\n      CoreMap map = sentences.get(i);\n      List<CoreLabel> sentenceTokens = map.get(TokensAnnotation.class);\n      if (sentence.hasBasicDependencies()) {\n        map.set(BasicDependenciesAnnotation.class, fromProto(sentence.getBasicDependencies(), sentenceTokens, docid));\n      }\n      if (sentence.hasCollapsedDependencies()) {\n        map.set(CollapsedDependenciesAnnotation.class, fromProto(sentence.getCollapsedDependencies(), sentenceTokens, docid));\n      }\n      if (sentence.hasCollapsedCCProcessedDependencies()) {\n        map.set(CollapsedCCProcessedDependenciesAnnotation.class, fromProto(sentence.getCollapsedCCProcessedDependencies(), sentenceTokens, docid));\n      }\n    }\n\n    // Redo some light annotation\n    for (CoreMap sentence : sentences) {\n      if (sentence.containsKey(TokensAnnotation.class)) {\n        sentence.set(NumerizedTokensAnnotation.class, NumberNormalizer.findAndMergeNumbers(sentence));\n      }\n    }\n\n    // Return\n    return ann;\n  }","commit_id":"691595264a59c8cf4f6b716376fd8a5cf374e119","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"protected void doInvokeDeploy(HotDeployEvent event) throws Exception {\n\t\tServletContext servletContext = event.getServletContext();\n\n\t\tString servletContextName = servletContext.getServletContextName();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking deploy for \" + servletContextName);\n\t\t}\n\n\t\tString xml = HttpUtil.URLtoString(\n\t\t\tservletContext.getResource(\"/WEB-INF/liferay-hook.xml\"));\n\n\t\tif (xml == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Registering hook for \" + servletContextName);\n\t\t}\n\n\t\t_servletContextNames.add(servletContextName);\n\n\t\tClassLoader portletClassLoader = event.getContextClassLoader();\n\n\t\tDocument doc = SAXReaderUtil.read(xml, true);\n\n\t\tElement root = doc.getRootElement();\n\n\t\tString portalPropertiesLocation = root.elementText(\"portal-properties\");\n\n\t\tif (Validator.isNotNull(portalPropertiesLocation)) {\n\t\t\tConfiguration portalPropertiesConfiguration = null;\n\n\t\t\ttry {\n\t\t\t\tString name = portalPropertiesLocation;\n\n\t\t\t\tint pos = name.lastIndexOf(\".properties\");\n\n\t\t\t\tif (pos != -1) {\n\t\t\t\t\tname = name.substring(0, pos);\n\t\t\t\t}\n\n\t\t\t\tportalPropertiesConfiguration =\n\t\t\t\t\tConfigurationFactoryUtil.getConfiguration(\n\t\t\t\t\t\tportletClassLoader, name);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(\"Unable to read \" + portalPropertiesLocation, e);\n\t\t\t}\n\n\t\t\tif (portalPropertiesConfiguration != null) {\n\t\t\t\tProperties portalProperties =\n\t\t\t\t\tportalPropertiesConfiguration.getProperties();\n\n\t\t\t\tif (portalProperties.size() > 0) {\n\t\t\t\t\t_portalPropertiesMap.put(\n\t\t\t\t\t\tservletContextName, portalProperties);\n\n\t\t\t\t\t// Initialize properties, auto logins, model listeners, and\n\t\t\t\t\t// events in that specific order. Events have to be loaded\n\t\t\t\t\t// last because they may require model listeners to have\n\t\t\t\t\t// been registered.\n\n\t\t\t\t\tinitPortalProperties(\n\t\t\t\t\t\tservletContextName, portletClassLoader,\n\t\t\t\t\t\tportalProperties);\n\t\t\t\t\tinitAuthFailures(\n\t\t\t\t\t\tservletContextName, portletClassLoader,\n\t\t\t\t\t\tportalProperties);\n\t\t\t\t\tinitAutoDeployListeners(\n\t\t\t\t\t\tservletContextName, portletClassLoader,\n\t\t\t\t\t\tportalProperties);\n\t\t\t\t\tinitAutoLogins(\n\t\t\t\t\t\tservletContextName, portletClassLoader,\n\t\t\t\t\t\tportalProperties);\n\t\t\t\t\tinitAuthenticators(\n\t\t\t\t\t\tservletContextName, portletClassLoader,\n\t\t\t\t\t\tportalProperties);\n\t\t\t\t\tinitHotDeployListeners(\n\t\t\t\t\t\tservletContextName, portletClassLoader,\n\t\t\t\t\t\tportalProperties);\n\t\t\t\t\tinitModelListeners(\n\t\t\t\t\t\tservletContextName, portletClassLoader,\n\t\t\t\t\t\tportalProperties);\n\t\t\t\t\tinitEvents(\n\t\t\t\t\t\tservletContextName, portletClassLoader,\n\t\t\t\t\t\tportalProperties);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tLanguagesContainer languagesContainer = new LanguagesContainer();\n\n\t\t_languagesContainerMap.put(servletContextName, languagesContainer);\n\n\t\tList<Element> languagePropertiesEls = root.elements(\n\t\t\t\"language-properties\");\n\n\t\tfor (Element languagePropertiesEl : languagePropertiesEls) {\n\t\t\tString languagePropertiesLocation = languagePropertiesEl.getText();\n\n\t\t\ttry {\n\t\t\t\tURL url = portletClassLoader.getResource(\n\t\t\t\t\tlanguagePropertiesLocation);\n\n\t\t\t\tif (url == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tInputStream is = url.openStream();\n\n\t\t\t\tProperties properties = new Properties();\n\n\t\t\t\tproperties.load(is);\n\n\t\t\t\tis.close();\n\n\t\t\t\tMap<String, String> languageMap = new HashMap<String, String>();\n\t\t\t\tfor(Map.Entry<Object, Object> entry : properties.entrySet()) {\n\t\t\t\t\tlanguageMap.put((String)entry.getKey(),\n\t\t\t\t\t\t(String)entry.getValue());\n\t\t\t\t}\n\n\t\t\t\tLocale locale = getLocale(languagePropertiesLocation);\n\n\t\t\t\tif (locale != null) {\n\t\t\t\t\tlanguagesContainer.addLanguage(locale, languageMap);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(\"Unable to read \" + languagePropertiesLocation, e);\n\t\t\t}\n\t\t}\n\n\t\tString customJspDir = root.elementText(\"custom-jsp-dir\");\n\n\t\tif (Validator.isNotNull(customJspDir)) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Custom JSP directory: \" + customJspDir);\n\t\t\t}\n\n\t\t\tList<String> customJsps = new ArrayList<String>();\n\n\t\t\tString webDir = servletContext.getRealPath(StringPool.SLASH);\n\n\t\t\tgetCustomJsps(servletContext, webDir, customJspDir, customJsps);\n\n\t\t\tif (customJsps.size() > 0) {\n\t\t\t\tCustomJspBag customJspBag = new CustomJspBag(\n\t\t\t\t\tcustomJspDir, customJsps);\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\tStringBundler sb = new StringBundler(customJsps.size() * 2);\n\n\t\t\t\t\tsb.append(\"Custom JSP files:\\n\");\n\n\t\t\t\t\tIterator<String> itr = customJsps.iterator();\n\n\t\t\t\t\twhile (itr.hasNext()) {\n\t\t\t\t\t\tString customJsp = itr.next();\n\n\t\t\t\t\t\tsb.append(customJsp);\n\n\t\t\t\t\t\tif (itr.hasNext()) {\n\t\t\t\t\t\t\tsb.append(StringPool.NEW_LINE);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t_log.debug(sb.toString());\n\t\t\t\t}\n\n\t\t\t\t_customJspBagsMap.put(servletContextName, customJspBag);\n\n\t\t\t\tinitCustomJspBag(customJspBag);\n\t\t\t}\n\t\t}\n\n\t\tList<Element> serviceEls = root.elements(\"service\");\n\n\t\tfor (Element serviceEl : serviceEls) {\n\t\t\tString serviceType = serviceEl.elementText(\"service-type\");\n\t\t\tString serviceImpl = serviceEl.elementText(\"service-impl\");\n\n\t\t\tClass<?> serviceTypeClass = portletClassLoader.loadClass(\n\t\t\t\tserviceType);\n\t\t\tClass<?> serviceImplClass = portletClassLoader.loadClass(\n\t\t\t\tserviceImpl);\n\n\t\t\tConstructor<?> serviceImplConstructor =\n\t\t\t\tserviceImplClass.getConstructor(\n\t\t\t\t\tnew Class<?>[] {serviceTypeClass});\n\n\t\t\tObject serviceProxy = PortalBeanLocatorUtil.locate(serviceType);\n\n\t\t\tif (Proxy.isProxyClass(serviceProxy.getClass())) {\n\t\t\t\tinitServices(\n\t\t\t\t\tservletContextName, portletClassLoader, serviceType,\n\t\t\t\t\tserviceTypeClass, serviceImplConstructor, serviceProxy);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.error(\n\t\t\t\t\t\"Service hooks require Spring to be configured to use \" +\n\t\t\t\t\t\t\"JdkDynamicProxy and will not work with CGLIB\");\n\t\t\t}\n\t\t}\n\n\t\t// Begin backwards compatibility for 5.1.0\n\n\t\tModelListenersContainer modelListenersContainer =\n\t\t\t_modelListenersContainerMap.get(servletContextName);\n\n\t\tif (modelListenersContainer == null) {\n\t\t\tmodelListenersContainer = new ModelListenersContainer();\n\n\t\t\t_modelListenersContainerMap.put(\n\t\t\t\tservletContextName, modelListenersContainer);\n\t\t}\n\n\t\tList<Element> modelListenerEls = root.elements(\"model-listener\");\n\n\t\tfor (Element modelListenerEl : modelListenerEls) {\n\t\t\tString modelName = modelListenerEl.elementText(\"model-name\");\n\t\t\tString modelListenerClassName = modelListenerEl.elementText(\n\t\t\t\t\"model-listener-class\");\n\n\t\t\tModelListener<BaseModel<?>> modelListener = initModelListener(\n\t\t\t\tmodelName, modelListenerClassName, portletClassLoader);\n\n\t\t\tif (modelListener != null) {\n\t\t\t\tmodelListenersContainer.registerModelListener(\n\t\t\t\t\tmodelName, modelListener);\n\t\t\t}\n\t\t}\n\n\t\tEventsContainer eventsContainer = _eventsContainerMap.get(\n\t\t\tservletContextName);\n\n\t\tif (eventsContainer == null) {\n\t\t\teventsContainer = new EventsContainer();\n\n\t\t\t_eventsContainerMap.put(servletContextName, eventsContainer);\n\t\t}\n\n\t\tList<Element> eventEls = root.elements(\"event\");\n\n\t\tfor (Element eventEl : eventEls) {\n\t\t\tString eventName = eventEl.elementText(\"event-type\");\n\t\t\tString eventClassName = eventEl.elementText(\"event-class\");\n\n\t\t\tObject obj = initEvent(\n\t\t\t\teventName, eventClassName, portletClassLoader);\n\n\t\t\tif (obj != null) {\n\t\t\t\teventsContainer.registerEvent(eventName, obj);\n\t\t\t}\n\t\t}\n\n\t\t// End backwards compatibility for 5.1.0\n\n\t\tregisterClpMessageListeners(servletContext, portletClassLoader);\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Hook for \" + servletContextName + \" is available for use\");\n\t\t}\n\t}","id":75041,"modified_method":"protected void doInvokeDeploy(HotDeployEvent event) throws Exception {\n\t\tServletContext servletContext = event.getServletContext();\n\n\t\tString servletContextName = servletContext.getServletContextName();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking deploy for \" + servletContextName);\n\t\t}\n\n\t\tString xml = HttpUtil.URLtoString(\n\t\t\tservletContext.getResource(\"/WEB-INF/liferay-hook.xml\"));\n\n\t\tif (xml == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Registering hook for \" + servletContextName);\n\t\t}\n\n\t\t_servletContextNames.add(servletContextName);\n\n\t\tClassLoader portletClassLoader = event.getContextClassLoader();\n\n\t\tDocument doc = SAXReaderUtil.read(xml, true);\n\n\t\tElement root = doc.getRootElement();\n\n\t\tString portalPropertiesLocation = root.elementText(\"portal-properties\");\n\n\t\tif (Validator.isNotNull(portalPropertiesLocation)) {\n\t\t\tConfiguration portalPropertiesConfiguration = null;\n\n\t\t\ttry {\n\t\t\t\tString name = portalPropertiesLocation;\n\n\t\t\t\tint pos = name.lastIndexOf(\".properties\");\n\n\t\t\t\tif (pos != -1) {\n\t\t\t\t\tname = name.substring(0, pos);\n\t\t\t\t}\n\n\t\t\t\tportalPropertiesConfiguration =\n\t\t\t\t\tConfigurationFactoryUtil.getConfiguration(\n\t\t\t\t\t\tportletClassLoader, name);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(\"Unable to read \" + portalPropertiesLocation, e);\n\t\t\t}\n\n\t\t\tif (portalPropertiesConfiguration != null) {\n\t\t\t\tProperties portalProperties =\n\t\t\t\t\tportalPropertiesConfiguration.getProperties();\n\n\t\t\t\tif (portalProperties.size() > 0) {\n\t\t\t\t\t_portalPropertiesMap.put(\n\t\t\t\t\t\tservletContextName, portalProperties);\n\n\t\t\t\t\t// Initialize properties, auto logins, model listeners, and\n\t\t\t\t\t// events in that specific order. Events have to be loaded\n\t\t\t\t\t// last because they may require model listeners to have\n\t\t\t\t\t// been registered.\n\n\t\t\t\t\tinitPortalProperties(\n\t\t\t\t\t\tservletContextName, portletClassLoader,\n\t\t\t\t\t\tportalProperties);\n\t\t\t\t\tinitAuthFailures(\n\t\t\t\t\t\tservletContextName, portletClassLoader,\n\t\t\t\t\t\tportalProperties);\n\t\t\t\t\tinitAutoDeployListeners(\n\t\t\t\t\t\tservletContextName, portletClassLoader,\n\t\t\t\t\t\tportalProperties);\n\t\t\t\t\tinitAutoLogins(\n\t\t\t\t\t\tservletContextName, portletClassLoader,\n\t\t\t\t\t\tportalProperties);\n\t\t\t\t\tinitAuthenticators(\n\t\t\t\t\t\tservletContextName, portletClassLoader,\n\t\t\t\t\t\tportalProperties);\n\t\t\t\t\tinitHotDeployListeners(\n\t\t\t\t\t\tservletContextName, portletClassLoader,\n\t\t\t\t\t\tportalProperties);\n\t\t\t\t\tinitModelListeners(\n\t\t\t\t\t\tservletContextName, portletClassLoader,\n\t\t\t\t\t\tportalProperties);\n\t\t\t\t\tinitEvents(\n\t\t\t\t\t\tservletContextName, portletClassLoader,\n\t\t\t\t\t\tportalProperties);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tLanguagesContainer languagesContainer = new LanguagesContainer();\n\n\t\t_languagesContainerMap.put(servletContextName, languagesContainer);\n\n\t\tList<Element> languagePropertiesEls = root.elements(\n\t\t\t\"language-properties\");\n\n\t\tfor (Element languagePropertiesEl : languagePropertiesEls) {\n\t\t\tString languagePropertiesLocation = languagePropertiesEl.getText();\n\n\t\t\ttry {\n\t\t\t\tURL url = portletClassLoader.getResource(\n\t\t\t\t\tlanguagePropertiesLocation);\n\n\t\t\t\tif (url == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tInputStream is = url.openStream();\n\n\t\t\t\tProperties properties = new Properties();\n\n\t\t\t\tproperties.load(is);\n\n\t\t\t\tis.close();\n\n\t\t\t\tMap<String, String> languageMap = new HashMap<String, String>();\n\n\t\t\t\tfor (Map.Entry<Object, Object> entry : properties.entrySet()) {\n\t\t\t\t\tString key = (String)entry.getKey();\n\t\t\t\t\tString value = (String)entry.getValue();\n\n\t\t\t\t\tlanguageMap.put(key, value);\n\t\t\t\t}\n\n\t\t\t\tLocale locale = getLocale(languagePropertiesLocation);\n\n\t\t\t\tif (locale != null) {\n\t\t\t\t\tlanguagesContainer.addLanguage(locale, languageMap);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(\"Unable to read \" + languagePropertiesLocation, e);\n\t\t\t}\n\t\t}\n\n\t\tString customJspDir = root.elementText(\"custom-jsp-dir\");\n\n\t\tif (Validator.isNotNull(customJspDir)) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Custom JSP directory: \" + customJspDir);\n\t\t\t}\n\n\t\t\tList<String> customJsps = new ArrayList<String>();\n\n\t\t\tString webDir = servletContext.getRealPath(StringPool.SLASH);\n\n\t\t\tgetCustomJsps(servletContext, webDir, customJspDir, customJsps);\n\n\t\t\tif (customJsps.size() > 0) {\n\t\t\t\tCustomJspBag customJspBag = new CustomJspBag(\n\t\t\t\t\tcustomJspDir, customJsps);\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\tStringBundler sb = new StringBundler(customJsps.size() * 2);\n\n\t\t\t\t\tsb.append(\"Custom JSP files:\\n\");\n\n\t\t\t\t\tIterator<String> itr = customJsps.iterator();\n\n\t\t\t\t\twhile (itr.hasNext()) {\n\t\t\t\t\t\tString customJsp = itr.next();\n\n\t\t\t\t\t\tsb.append(customJsp);\n\n\t\t\t\t\t\tif (itr.hasNext()) {\n\t\t\t\t\t\t\tsb.append(StringPool.NEW_LINE);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t_log.debug(sb.toString());\n\t\t\t\t}\n\n\t\t\t\t_customJspBagsMap.put(servletContextName, customJspBag);\n\n\t\t\t\tinitCustomJspBag(customJspBag);\n\t\t\t}\n\t\t}\n\n\t\tList<Element> serviceEls = root.elements(\"service\");\n\n\t\tfor (Element serviceEl : serviceEls) {\n\t\t\tString serviceType = serviceEl.elementText(\"service-type\");\n\t\t\tString serviceImpl = serviceEl.elementText(\"service-impl\");\n\n\t\t\tClass<?> serviceTypeClass = portletClassLoader.loadClass(\n\t\t\t\tserviceType);\n\t\t\tClass<?> serviceImplClass = portletClassLoader.loadClass(\n\t\t\t\tserviceImpl);\n\n\t\t\tConstructor<?> serviceImplConstructor =\n\t\t\t\tserviceImplClass.getConstructor(\n\t\t\t\t\tnew Class<?>[] {serviceTypeClass});\n\n\t\t\tObject serviceProxy = PortalBeanLocatorUtil.locate(serviceType);\n\n\t\t\tif (Proxy.isProxyClass(serviceProxy.getClass())) {\n\t\t\t\tinitServices(\n\t\t\t\t\tservletContextName, portletClassLoader, serviceType,\n\t\t\t\t\tserviceTypeClass, serviceImplConstructor, serviceProxy);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.error(\n\t\t\t\t\t\"Service hooks require Spring to be configured to use \" +\n\t\t\t\t\t\t\"JdkDynamicProxy and will not work with CGLIB\");\n\t\t\t}\n\t\t}\n\n\t\t// Begin backwards compatibility for 5.1.0\n\n\t\tModelListenersContainer modelListenersContainer =\n\t\t\t_modelListenersContainerMap.get(servletContextName);\n\n\t\tif (modelListenersContainer == null) {\n\t\t\tmodelListenersContainer = new ModelListenersContainer();\n\n\t\t\t_modelListenersContainerMap.put(\n\t\t\t\tservletContextName, modelListenersContainer);\n\t\t}\n\n\t\tList<Element> modelListenerEls = root.elements(\"model-listener\");\n\n\t\tfor (Element modelListenerEl : modelListenerEls) {\n\t\t\tString modelName = modelListenerEl.elementText(\"model-name\");\n\t\t\tString modelListenerClassName = modelListenerEl.elementText(\n\t\t\t\t\"model-listener-class\");\n\n\t\t\tModelListener<BaseModel<?>> modelListener = initModelListener(\n\t\t\t\tmodelName, modelListenerClassName, portletClassLoader);\n\n\t\t\tif (modelListener != null) {\n\t\t\t\tmodelListenersContainer.registerModelListener(\n\t\t\t\t\tmodelName, modelListener);\n\t\t\t}\n\t\t}\n\n\t\tEventsContainer eventsContainer = _eventsContainerMap.get(\n\t\t\tservletContextName);\n\n\t\tif (eventsContainer == null) {\n\t\t\teventsContainer = new EventsContainer();\n\n\t\t\t_eventsContainerMap.put(servletContextName, eventsContainer);\n\t\t}\n\n\t\tList<Element> eventEls = root.elements(\"event\");\n\n\t\tfor (Element eventEl : eventEls) {\n\t\t\tString eventName = eventEl.elementText(\"event-type\");\n\t\t\tString eventClassName = eventEl.elementText(\"event-class\");\n\n\t\t\tObject obj = initEvent(\n\t\t\t\teventName, eventClassName, portletClassLoader);\n\n\t\t\tif (obj != null) {\n\t\t\t\teventsContainer.registerEvent(eventName, obj);\n\t\t\t}\n\t\t}\n\n\t\t// End backwards compatibility for 5.1.0\n\n\t\tregisterClpMessageListeners(servletContext, portletClassLoader);\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Hook for \" + servletContextName + \" is available for use\");\n\t\t}\n\t}","commit_id":"82c6ed6661cc601fdaae0aee8c59b2dcc05e4340","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addLanguage(\n\t\t\tLocale locale, Map<String, String> languageMap) {\n\n\t\t\tMap<String, String> oldLanguageMap =\n\t\t\t\tLanguageResources.putLanguageMap(locale, languageMap);\n\n\t\t\t_oldLocaleLanguageMap.put(locale, oldLanguageMap);\n\t\t}","id":75042,"modified_method":"public void addLanguage(\n\t\t\tLocale locale, Map<String, String> languageMap) {\n\n\t\t\tMap<String, String> oldLanguageMap =\n\t\t\t\tLanguageResources.putLanguageMap(locale, languageMap);\n\n\t\t\t_languagesMap.put(locale, oldLanguageMap);\n\t\t}","commit_id":"82c6ed6661cc601fdaae0aee8c59b2dcc05e4340","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void unregisterLanguages() {\n\n\t\t\tfor(Map.Entry<Locale, Map<String, String>> localeEntry :\n\t\t\t\t_oldLocaleLanguageMap.entrySet()) {\n\t\t\t\tLanguageResources.putLanguageMap(localeEntry.getKey(),\n\t\t\t\t\tlocaleEntry.getValue());\n\t\t\t}\n\t\t}","id":75043,"modified_method":"public void unregisterLanguages() {\n\t\t\tfor (Map.Entry<Locale, Map<String, String>> entry :\n\t\t\t\t\t_languagesMap.entrySet()) {\n\n\t\t\t\tLocale locale = entry.getKey();\n\t\t\t\tMap<String, String> languageMap = entry.getValue();\n\n\t\t\t\tLanguageResources.putLanguageMap(locale, languageMap);\n\t\t\t}\n\t\t}","commit_id":"82c6ed6661cc601fdaae0aee8c59b2dcc05e4340","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static Locale getSuperLocale(Locale locale) {\n\t\tif (!locale.getVariant().equals(StringPool.BLANK)) {\n\t\t\treturn new Locale(locale.getLanguage(), locale.getCountry());\n\t\t}\n\n\t\tif (!locale.getCountry().equals(StringPool.BLANK)) {\n\t\t\treturn new Locale(locale.getLanguage());\n\t\t}\n\n\t\tif (!locale.getLanguage().equals(StringPool.BLANK)) {\n\t\t\treturn new Locale(StringPool.BLANK);\n\t\t}\n\n\t\treturn null;\n\t}","id":75044,"modified_method":"private static Locale getSuperLocale(Locale locale) {\n\t\tif (Validator.isNotNull(locale.getVariant())) {\n\t\t\treturn new Locale(locale.getLanguage(), locale.getCountry());\n\t\t}\n\n\t\tif (Validator.isNotNull(locale.getCountry())) {\n\t\t\treturn new Locale(locale.getLanguage());\n\t\t}\n\n\t\tif (Validator.isNotNull(locale.getLanguage())) {\n\t\t\treturn new Locale(StringPool.BLANK);\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"82c6ed6661cc601fdaae0aee8c59b2dcc05e4340","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Map<String, String> putLanguageMap(\n\t\tLocale locale, Map<String, String> languageMap) {\n\t\treturn _localeLanguageMap.put(locale, languageMap);\n\t}","id":75045,"modified_method":"public static Map<String, String> putLanguageMap(\n\t\tLocale locale, Map<String, String> languageMap) {\n\n\t\treturn _languageMaps.put(locale, languageMap);\n\t}","commit_id":"82c6ed6661cc601fdaae0aee8c59b2dcc05e4340","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static Properties loadProperties(String name) {\n\n\t\tProperties properties = new Properties();\n\n\t\ttry {\n\t\t\tClassLoader classLoader =\n\t\t\t\tLanguageResources.class.getClassLoader();\n\t\t\tURL url = classLoader.getResource(name);\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Attempting to load \" + name);\n\t\t\t}\n\n\t\t\tif (url != null) {\n\t\t\t\tInputStream is = url.openStream();\n\n\t\t\t\tproperties.load(is);\n\n\t\t\t\tis.close();\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\"Loading \" + url + \" with \" + properties.size() +\n\t\t\t\t\t\t\t\" values\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.warn(e);\n\t\t}\n\n\t\treturn properties;\n\t}","id":75046,"modified_method":"private static Properties loadProperties(String name) {\n\t\tProperties properties = new Properties();\n\n\t\ttry {\n\t\t\tClassLoader classLoader = LanguageResources.class.getClassLoader();\n\n\t\t\tURL url = classLoader.getResource(name);\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\"Attempting to load \" + name);\n\t\t\t}\n\n\t\t\tif (url != null) {\n\t\t\t\tInputStream inputStream = url.openStream();\n\n\t\t\t\tproperties.load(inputStream);\n\n\t\t\t\tinputStream.close();\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\"Loading \" + url + \" with \" + properties.size() +\n\t\t\t\t\t\t\t\" values\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(e, e);\n\t\t\t}\n\t\t}\n\n\t\treturn properties;\n\t}","commit_id":"82c6ed6661cc601fdaae0aee8c59b2dcc05e4340","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static Map<String, String> loadLocale(Locale locale) {\n\n\t\tString[] names = StringUtil.split(\n\t\t\t_config.replace(StringPool.PERIOD, StringPool.SLASH));\n\t\tMap<String, String> languageMap = null;\n\t\tif (names.length > 0) {\n\t\t\tString localeName = locale.toString();\n\t\t\tlanguageMap = new HashMap<String, String>();\n\t\t\tfor (int i = 0; i < names.length; i++) {\n\t\t\t\tString name = names[i];\n\t\t\t\tStringBundler sb = new StringBundler(4);\n\t\t\t\tsb.append(name);\n\t\t\t\tif (localeName.length() > 0) {\n\t\t\t\t\tsb.append(\"_\");\n\t\t\t\t\tsb.append(localeName);\n\t\t\t\t}\n\t\t\t\tsb.append(\".properties\");\n\n\t\t\t\tProperties properties = loadProperties(sb.toString());\n\t\t\t\tfor(Map.Entry<Object, Object> entry : properties.entrySet()) {\n\t\t\t\t\tlanguageMap.put(\n\t\t\t\t\t\t(String)entry.getKey(), (String)entry.getValue());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlanguageMap = Collections.emptyMap();\n\t\t}\n\t\t_localeLanguageMap.put(locale, languageMap);\n\t\treturn languageMap;\n\t}","id":75047,"modified_method":"private static Map<String, String> loadLocale(Locale locale) {\n\t\tString[] names = StringUtil.split(\n\t\t\t_config.replace(StringPool.PERIOD, StringPool.SLASH));\n\n\t\tMap<String, String> languageMap = null;\n\n\t\tif (names.length > 0) {\n\t\t\tString localeName = locale.toString();\n\n\t\t\tlanguageMap = new HashMap<String, String>();\n\n\t\t\tfor (String name : names) {\n\t\t\t\tStringBundler sb = new StringBundler(4);\n\n\t\t\t\tsb.append(name);\n\n\t\t\t\tif (localeName.length() > 0) {\n\t\t\t\t\tsb.append(StringPool.UNDERLINE);\n\t\t\t\t\tsb.append(localeName);\n\t\t\t\t}\n\n\t\t\t\tsb.append(\".properties\");\n\n\t\t\t\tProperties properties = loadProperties(sb.toString());\n\n\t\t\t\tfor (Map.Entry<Object, Object> entry : properties.entrySet()) {\n\t\t\t\t\tString key = (String)entry.getKey();\n\t\t\t\t\tString value = (String)entry.getValue();\n\n\t\t\t\t\tlanguageMap.put(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlanguageMap = Collections.EMPTY_MAP;\n\t\t}\n\n\t\t_languageMaps.put(locale, languageMap);\n\n\t\treturn languageMap;\n\t}","commit_id":"82c6ed6661cc601fdaae0aee8c59b2dcc05e4340","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String getMessage(Locale locale, String key) {\n\t\tif (locale == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tMap<String, String> languageMap = _localeLanguageMap.get(locale);\n\t\tif (languageMap == null) {\n\t\t\tlanguageMap = loadLocale(locale);\n\t\t}\n\n\t\tString value = languageMap.get(key);\n\t\tif (value == null) {\n\t\t\treturn getMessage(getSuperLocale(locale), key);\n\t\t}\n\t\telse {\n\t\t\treturn value;\n\t\t}\n\t}","id":75048,"modified_method":"public static String getMessage(Locale locale, String key) {\n\t\tif (locale == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tMap<String, String> languageMap = _languageMaps.get(locale);\n\n\t\tif (languageMap == null) {\n\t\t\tlanguageMap = loadLocale(locale);\n\t\t}\n\n\t\tString value = languageMap.get(key);\n\n\t\tif (value == null) {\n\t\t\treturn getMessage(getSuperLocale(locale), key);\n\t\t}\n\t\telse {\n\t\t\treturn value;\n\t\t}\n\t}","commit_id":"82c6ed6661cc601fdaae0aee8c59b2dcc05e4340","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Since the search server does not carry channel information, we do any channel\n     * filtering in the Java stack. This method will return a new list of packages that\n     * containing packages that are present in the given channel; others returned from\n     * the search will be removed.\n     *\n     * @param user      user making the request\n     * @param channelId channel against which the filter should be run\n     * @param pkgs      list of packages returned from the search query that should be\n     *                  filtered\n     * @return new list object with duplicates removed; does not change the list in place\n     */\n    private List<PackageOverview> filterByChannel(User user, Long channelId,\n                                                  List<PackageOverview> pkgs) {\n\n        Channel channel = ChannelManager.lookupByIdAndUser(channelId, user);\n        List<PackageDto> allPackagesList = ChannelManager.listAllPackages(channel);\n\n        // Convert the package list into a map for quicker lookup\n        Map<String, String> packageNamesMap =\n            new HashMap<String, String>(allPackagesList.size());\n\n        for (PackageDto dto : allPackagesList) {\n            String name = dto.getName();\n            packageNamesMap.put(name, name);\n        }\n\n        // Iterate results and remove if not in the channel\n        List<PackageOverview> newResult = new ArrayList<PackageOverview>();\n        for (PackageOverview pkg : pkgs) {\n            String packageName = pkg.getPackageName();\n            if (packageNamesMap.get(packageName) != null) {\n                newResult.add(pkg);\n            }\n        }\n\n        return newResult;\n    }","id":75049,"modified_method":"/**\n     * Since the search server does not carry channel information, we do any\n     * channel filtering in the Java stack. This method will return a new list\n     * containing packages that are present in the given channel; others\n     * returned from the search will be removed.\n     *\n     * @param user      user making the request\n     * @param channelId channel against which the filter should be run\n     * @param pkgs      list of packages returned from the search query that should be\n     *                  filtered\n     * @return new list object with duplicates removed; does not change the list in place\n     */\n    private List<PackageOverview> filterByChannel(User user, Long channelId,\n                                                  List<PackageOverview> pkgs) {\n\n        Channel channel = ChannelManager.lookupByIdAndUser(channelId, user);\n        List<PackageDto> allPackagesList = ChannelManager.listAllPackages(channel);\n\n        // Convert the package list into a set for quicker lookup\n        Set<String> packageNameSet = new HashSet<String>();\n        for (PackageDto dto : allPackagesList) {\n            packageNameSet.add(dto.getName());\n        }\n\n        // Iterate results and remove if not in the channel\n        List<PackageOverview> newResult = new ArrayList<PackageOverview>();\n        for (PackageOverview pkg : pkgs) {\n            if (packageNameSet.contains(pkg.getPackageName())) {\n                newResult.add(pkg);\n            }\n        }\n\n        return newResult;\n    }","commit_id":"24ee3a62be4144e05b714eccd0f1e6b83dde9a56","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Package Search returns a list of all matching packages, this will likely\n     * include multiple packages with the same name but different version, release,\n     * epoch.  WebUI only wants a list of unique package names, so we need\n     * to strip the duplicate names while preserving order.\n     *\n     * @param pkgs packages returned from search that should be cleaned\n     * @return new list object with duplicates removed; does not change the list in place\n     */\n    private List<PackageOverview> removeDuplicateNames(List<PackageOverview> pkgs) {\n\n        List<PackageOverview> result = new ArrayList<PackageOverview>();\n        for (PackageOverview pkgOver : pkgs) {\n            boolean addPkg = true;\n            for (PackageOverview temp : result) {\n                if (StringUtils.equals(temp.getPackageName(), pkgOver.getPackageName())) {\n                    addPkg = false;\n                    break;\n                }\n            }\n            if (addPkg) {\n                result.add(pkgOver);\n            }\n        }\n        return result;\n    }","id":75050,"modified_method":"/**\n     * Package Search returns a list of all matching packages, this will likely\n     * include multiple packages with the same name but different version, release,\n     * epoch.  WebUI only wants a list of unique package names, so we need\n     * to strip the duplicate names while preserving order.\n     *\n     * @param pkgs packages returned from search that should be cleaned\n     * @return new list object with duplicates removed; does not change the list in place\n     */\n    private List<PackageOverview> removeDuplicateNames(List<PackageOverview> pkgs) {\n\n        List<PackageOverview> result = new ArrayList<PackageOverview>();\n        Set<String> addedNames = new HashSet<String>();\n        for (PackageOverview pkgOver : pkgs) {\n            if (!addedNames.contains(pkgOver.getPackageName())) {\n                addedNames.add(pkgOver.getPackageName());\n                result.add(pkgOver);\n            }\n        }\n        return result;\n    }","commit_id":"24ee3a62be4144e05b714eccd0f1e6b83dde9a56","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"@Override\n    protected Object doExecute() throws Exception {\n        OsgiModuleRegistry registry = Activator.registry;\n        List<ModuleRegistry.Module> modules = registry.getApplicationModules();\n\n        println(\"%s\\t%s\\t%s\", \"Name\",  \"Version\", \"Description\");\n        for (ModuleRegistry.Module module : modules) {\n            ModuleRegistry.VersionedModule latest = module.latest();\n            if( name!=null && name.equals(module.getName()) ) {\n                println(\"%s\\t%s\\t%s\", module.getName(), latest.getId().getVersion(), latest.getDescription());\n            }\n        }\n\n        return null;\n    }","id":75051,"modified_method":"@Override\n    protected Object doExecute() throws Exception {\n        OsgiModuleRegistry registry = Activator.registry;\n        List<ModuleRegistry.Module> modules = registry.getApplicationModules();\n\n        println(\"%-20s\\t%-10s\\t%-40s\", \"Name\",  \"Version\", \"Description\");\n        for (ModuleRegistry.Module module : modules) {\n            ModuleRegistry.VersionedModule latest = module.latest();\n            if( name==null || name.equals(module.getName()) ) {\n                println(\"%-20s\\t%-10s\\t%-40s\", module.getName(), latest.getId().getVersion(), latest.getDescription());\n            }\n        }\n\n        return null;\n    }","commit_id":"3c7230ecd8460609327c6a5c350ac0c7134b4cbd","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    protected Object doExecute() throws Exception {\n        OsgiModuleRegistry registry = Activator.registry;\n        List<ModuleRegistry.Module> modules = registry.getApplicationModules();\n\n        for (ModuleRegistry.Module module : modules) {\n            if( module.getName().equals(name) ) {\n\n                ModuleRegistry.VersionedModule selected = null;\n\n                TreeSet<String> versions = new TreeSet<String>();\n                for (ModuleRegistry.VersionedModule mv : module.getVersions()) {\n                    String v = mv.getId().getVersion();\n                    versions.add(v);\n                    if( version!=null && version.equals(v) ) {\n                        selected = mv;\n                    }\n                }\n\n                if( version==null ) {\n                    selected = module.latest();\n                } else {\n                    if( selected==null ) {\n                        println(\"Unknown version: %s\", version);\n                        return null;\n                    }\n                }\n\n                println(\"Name    : %s\", selected.getName());\n                println(\"Version : %s\", selected.getId().getVersion());\n                versions.remove(selected.getId().getVersion());\n                if( !versions.isEmpty() ) {\n                println(\"  Available: %s\", join(versions, \", \"));\n                }\n\n                println(\"Description    : %s\", notEmpty(selected.getLongDescription()) ? selected.getLongDescription() : selected.getDescription());\n                Map<String,ModuleRegistry.VersionedModule> extensions = selected.getAvailableExtensions();\n                if( extensions.size() > 0 ) {\n                    println(\"Extensions\");\n                    println(\"  Default: %s\", join(selected.getDefaultExtensions(), \", \"));\n                    println(\"  Enabled: %s\", join(selected.getEnabledExtensions(), \", \"));\n                    println(\"  Available: %s\\t%s\\t%s\", \"Name\",  \"Version\", \"Description\");\n                    println(\"             %s\\t%s\\t%s\", \"Name\",  \"Version\", \"Description\");\n                    for (Map.Entry<String, ModuleRegistry.VersionedModule> entry : extensions.entrySet()) {\n                        ModuleRegistry.VersionedModule extension = entry.getValue();\n                        if( name!=null && name.equals(extension.getName()) ) {\n                            println(\"            %s\\t%s\\t%s\", extension.getName(), extension.getId().getVersion(), extension.getDescription());\n                        }\n                    }\n                }\n\n            }\n        }\n\n        return null;\n    }","id":75052,"modified_method":"@Override\n    protected Object doExecute() throws Exception {\n        OsgiModuleRegistry registry = Activator.registry;\n        List<ModuleRegistry.Module> modules = registry.getApplicationModules();\n\n        for (ModuleRegistry.Module module : modules) {\n            if( module.getName().equals(name) ) {\n\n                ModuleRegistry.VersionedModule selected = null;\n\n                TreeSet<String> versions = new TreeSet<String>();\n                for (ModuleRegistry.VersionedModule mv : module.getVersions()) {\n                    String v = mv.getId().getVersion();\n                    versions.add(v);\n                    if( version!=null && version.equals(v) ) {\n                        selected = mv;\n                    }\n                }\n\n                if( version==null ) {\n                    selected = module.latest();\n                } else {\n                    if( selected==null ) {\n                        println(\"Unknown version: %s\", version);\n                        return null;\n                    }\n                }\n\n                println(\"%15s: %s\", \"Name\", selected.getName());\n                println(\"%15s: %s\", \"Version\", selected.getId());\n                println(\"%15s: %s\", \"Artifact Id\", selected.getId());\n\n                versions.remove(selected.getId().getVersion());\n                if( !versions.isEmpty() ) {\n                    println(\"%20s: %s\", \"Available\", join(versions, \", \"));\n                }\n\n                String desc = notEmpty(selected.getLongDescription()) ? selected.getLongDescription() : selected.getDescription();\n                String lines[] = wordWrap(desc, 60);\n                println(\"%15s: %s\", \"Description\", lines[0]);\n                for( int i=1; i < lines.length; i++ ) {\n                    println(\"%15s  %s\", \"\", lines[i]);\n                }\n\n                Map<String,ModuleRegistry.VersionedModule> extensions = selected.getAvailableExtensions();\n                if( extensions.size() > 0 ) {\n                    HashSet enabled = new HashSet<String>(selected.getEnabledExtensions());\n                    println(\"Extensions:\");\n                    println(\"  * %-20s\\t%-10s\\t%-40s\", \"Name\",  \"Version\", \"Description\");\n\n                    for (Map.Entry<String, ModuleRegistry.VersionedModule> entry : extensions.entrySet()) {\n                        ModuleRegistry.VersionedModule extension = entry.getValue();\n                        println(\"  %s %-20s\\t%-10s\\t%-40s\", enabled.contains(extension.getName()) ? \"+\" : \"-\", extension.getName(), extension.getId().getVersion(), extension.getDescription());\n                    }\n                }\n\n            }\n        }\n\n        return null;\n    }","commit_id":"3c7230ecd8460609327c6a5c350ac0c7134b4cbd","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        UUID controller = null;\r\n        int maxPower = -1;\r\n        for (Permanent permanent : game.getBattlefield().getAllActivePermanents(filter, game)) {\r\n            if (permanent != null) {\r\n                if (maxPower == -1 || permanent.getPower().getValue() >= maxPower) {\r\n                    maxPower = permanent.getPower().getValue();\r\n                    controller = (permanent.getControllerId());\r\n                }\r\n            }\r\n        }\r\n        return controller != null && controller.equals(source.getControllerId());\r\n    }","id":75053,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Set<UUID> controllers = new HashSet<UUID>();\r\n        Integer maxPower = null;\r\n\r\n        List<Permanent> permanents = game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getId(), game);\r\n        for (Permanent permanent : permanents) {\r\n            if (permanent == null) {\r\n                continue;\r\n            }\r\n\r\n            int power = permanent.getPower().getValue();\r\n            if (maxPower == null || power > maxPower) {\r\n                maxPower = permanent.getPower().getValue();\r\n                controllers.clear();\r\n            }\r\n            if (power == maxPower) {\r\n                controllers.add(permanent.getControllerId());\r\n            }\r\n        }\r\n        return controllers.contains(source.getControllerId());\r\n    }","commit_id":"976a9724cd056afcd41b6cd4bbc58ceb938880ea","url":"https://github.com/magefree/mage"},{"original_method":"public JCCompilationUnit convert(CeylonTree.CompilationUnit t) {\n        final ListBuffer<JCTree> defs = new ListBuffer<JCTree>();\n        \n        defs.append(make(t).Import(makeIdent(Arrays.asList(\"ceylon\", \"*\")), false));\n                \n        t.visitChildren(new CeylonTree.Visitor () {\n            public void visit(CeylonTree.ClassDeclaration decl) {\n                defs.append(convert(decl));\n            }\n            public void visit(CeylonTree.MethodDeclaration decl) {\n                // This is a top-level method.  Generate a class with the\n                // name of the method and a corresponding run() method.\n                \n                final ListBuffer<JCVariableDecl> params = \n                    new ListBuffer<JCVariableDecl>();\n                final ListBuffer<JCStatement> annotations = \n                    new ListBuffer<JCStatement>();\n                final Singleton<JCBlock> body = \n                    new Singleton<JCBlock>();\n                Singleton<JCExpression> restype =\n                    new Singleton<JCExpression>();\n                \n                processMethodDeclaration(decl, params, body, restype, (ListBuffer<JCTypeParameter>)null,\n                        annotations);\n                \n                JCMethodDecl meth = make(decl).MethodDef(make().Modifiers(PUBLIC|STATIC),\n                        names.fromString(\"run\"),\n                        make().TypeIdent(VOID),\n                        List.<JCTypeParameter>nil(),\n                        params.toList(),\n                        List.<JCExpression>nil(), body.thing(), null);\n                \n                \n                List<JCTree> innerDefs = List.<JCTree>of(meth);\n                \n                // FIXME: This is wrong because the annotation registration is done\n                // within the scope of the class, but the annotations are lexically\n                // outside it.\n                if (annotations.length() > 0) {\n                    innerDefs = innerDefs.append(registerAnnotations(annotations.toList()));\n                }\n                \n                JCClassDecl classDef = \n                    make(decl).ClassDef(make().Modifiers(PUBLIC, List.<JCAnnotation>nil()),\n                            names.fromString(decl.nameAsString()),\n                            List.<JCTypeParameter>nil(), null,\n                            List.<JCExpression>nil(),\n                            innerDefs);\n                \n                defs.append(classDef);\n            }\n        });\n\n        JCCompilationUnit topLev =\n            make(t).TopLevel(List.<JCTree.JCAnnotation>nil(),\n                    /* package id*/ null, defs.toList());\n\n        System.out.println(topLev);\n        return topLev;\n    }","id":75054,"modified_method":"public JCCompilationUnit convert(CeylonTree.CompilationUnit t) {\n        final ListBuffer<JCTree> defs = new ListBuffer<JCTree>();\n        \n        defs.append(make(t).Import(makeIdent(Arrays.asList(\"ceylon\", \"*\")), false));\n                \n        t.visitChildren(new CeylonTree.Visitor () {\n            public void visit(CeylonTree.ClassDeclaration decl) {\n                defs.append(convert(decl));\n            }\n            public void visit(CeylonTree.MethodDeclaration decl) {\n                // This is a top-level method.  Generate a class with the\n                // name of the method and a corresponding run() method.\n                \n                final ListBuffer<JCVariableDecl> params = \n                    new ListBuffer<JCVariableDecl>();\n                final ListBuffer<JCStatement> annotations = \n                    new ListBuffer<JCStatement>();\n                final Singleton<JCBlock> body = \n                    new Singleton<JCBlock>();\n                Singleton<JCExpression> restype =\n                    new Singleton<JCExpression>();\n                \n                processMethodDeclaration(decl, params, body, restype, (ListBuffer<JCTypeParameter>)null,\n                        annotations);\n                \n                JCMethodDecl meth = make(decl).MethodDef(make().Modifiers(PUBLIC|STATIC),\n                        names.fromString(\"run\"),\n                        make().TypeIdent(VOID),\n                        List.<JCTypeParameter>nil(),\n                        params.toList(),\n                        List.<JCExpression>nil(), body.thing(), null);\n                \n                \n                List<JCTree> innerDefs = List.<JCTree>of(meth);\n                \n                // FIXME: This is wrong because the annotation registration is done\n                // within the scope of the class, but the annotations are lexically\n                // outside it.\n                if (annotations.length() > 0) {\n                    innerDefs = innerDefs.append(registerAnnotations(annotations.toList()));\n                }\n                \n                JCClassDecl classDef = \n                    make(decl).ClassDef(make().Modifiers(PUBLIC, List.<JCAnnotation>nil()),\n                            names.fromString(decl.nameAsString()),\n                            List.<JCTypeParameter>nil(), makeSelect(\"ceylon\", \"Object\"),\n                            List.<JCExpression>nil(),\n                            innerDefs);\n                \n                defs.append(classDef);\n            }\n        });\n\n        JCCompilationUnit topLev =\n            make(t).TopLevel(List.<JCTree.JCAnnotation>nil(),\n                    /* package id*/ null, defs.toList());\n\n        System.out.println(topLev);\n        return topLev;\n    }","commit_id":"35447321623bb78ebed54b075e507c8c42426612","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"JCExpression convert(CeylonTree.UserAnnotation userAnn) {\n       List<JCExpression> values = List.<JCExpression>nil();\n        for (CeylonTree expr: userAnn.values()) {\n            values = values.append(convertExpression(expr));\n        }\n        return make(userAnn).Apply(null, makeSelect(userAnn.name, \"run\"),\n                values);\n    }","id":75055,"modified_method":"JCExpression convert(CeylonTree.UserAnnotation userAnn) {\n       List<JCExpression> values = List.<JCExpression>nil();\n        for (CeylonTree expr: userAnn.values()) {\n            values = values.append(convertExpression(expr));\n        }\n        JCExpression result = make().Apply(null, makeSelect(userAnn.name, \"run\"),\n                values);\n        JCIdent addAnnotation = make(userAnn).Ident(names.fromString(\"addAnnotation\"));\n        result = make().Apply(null, addAnnotation, List.<JCExpression>of(result));\n        return result;\n    }","commit_id":"35447321623bb78ebed54b075e507c8c42426612","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"/** A developer-friendly string representing the instance. */\n    public abstract ceylon.String string();","id":75056,"modified_method":"/** A developer-friendly string representing the instance. */\n    public ceylon.String string() {\n        return String.instance(\"\");\n    }","commit_id":"35447321623bb78ebed54b075e507c8c42426612","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public static void run(ceylon.String... value) {\n    }","id":75057,"modified_method":"public static ceylon.Annotation run(ceylon.String... value) {\n        return null;\n    }","commit_id":"35447321623bb78ebed54b075e507c8c42426612","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private JCExpression convert(Tree.NotOp op) {\n        return at(op).Apply(null, makeSelect(makeIdent(syms().ceylonBooleanType), \"instance\"), List.<JCExpression> of(at(op).Conditional(convertExpression(op.getTerm()), make().Literal(TypeTags.BOOLEAN, 0), make().Literal(TypeTags.BOOLEAN, 1))));\n    }","id":75058,"modified_method":"private JCExpression convert(Tree.NotOp op) {\n        JCExpression result = null;\n        JCExpression term = convertExpression(op.getTerm());\n        JCExpression arg1 = gen.makeSelect(\"Boolean\", \"instance\");\n        JCExpression field1 = at(op.getTerm()).Apply(null, makeSelect(term, \"booleanValue\"), List.<JCExpression>nil());\n        JCUnary jcu = at(op).Unary(JCTree.NOT, field1);\n        List<JCExpression> arg2= List.of((JCExpression)jcu);\n        result = at(op).Apply(null, arg1, arg2);\n        return result;\n    }","commit_id":"cb2da334ff6d4656b1c2720200ffab9e0f6cfa5d","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public static NonCodeMembersHolder generateMembers(Set<Map> methods, final PsiFile place) {\n    return CachedValuesManager.getManager(place.getProject()).getCachedValue(place, CACHED_HOLDERS, new CachedValueProvider<ConcurrentFactoryMap<Set<Map>, NonCodeMembersHolder>>() {\n      public Result<ConcurrentFactoryMap<Set<Map>, NonCodeMembersHolder>> compute() {\n        final ConcurrentFactoryMap<Set<Map>, NonCodeMembersHolder> map = new ConcurrentFactoryMap<Set<Map>, NonCodeMembersHolder>() {\n          @Override\n          protected NonCodeMembersHolder create(Set<Map> key) {\n            return new NonCodeMembersHolder(key, place);\n          }\n        };\n        return Result.create(map, PsiModificationTracker.MODIFICATION_COUNT);\n      }\n    }, false).get(methods);\n  }","id":75059,"modified_method":"public static NonCodeMembersHolder generateMembers(Set<Map> methods, final PsiFile place) {\n    Map<Set<Map>, NonCodeMembersHolder> map = CachedValuesManager.getManager(place.getProject()).getCachedValue(\n      place, new CachedValueProvider<Map<Set<Map>, NonCodeMembersHolder>>() {\n      public Result<Map<Set<Map>, NonCodeMembersHolder>> compute() {\n        final Map<Set<Map>, NonCodeMembersHolder> map = new ConcurrentSoftHashMap<Set<Map>, NonCodeMembersHolder>();\n        return Result.create(map, PsiModificationTracker.MODIFICATION_COUNT);\n      }\n    });\n\n    NonCodeMembersHolder result = map.get(methods);\n    if (result == null) {\n      map.put(methods, result = new NonCodeMembersHolder(methods, place));\n    }\n    return result;\n  }","commit_id":"7dec69fd9710f33f2ba193c68b0a9869f0f5657d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public NonCodeMembersHolder(Set<Map> data, PsiElement place) {\n    final PsiManager manager = place.getManager();\n    for (Map prop : data) {\n      String name = String.valueOf(prop.get(\"name\"));\n\n      final GrLightMethodBuilder method = new GrLightMethodBuilder(manager, name).addModifier(PsiModifier.PUBLIC);\n\n      if (Boolean.TRUE.equals(prop.get(\"constructor\"))) {\n        method.setConstructor(true);\n      } else {\n        method.setReturnType(convertToPsiType(String.valueOf(prop.get(\"type\")), place));\n      }\n\n      final Object params = prop.get(\"params\");\n      if (params instanceof Map) {\n        boolean first = true;\n        for (Object paramName : ((Map)params).keySet()) {\n          Object value = ((Map)params).get(paramName);\n          boolean isNamed = first && value instanceof List;\n          first = false;\n          String typeName = isNamed ? CommonClassNames.JAVA_UTIL_MAP : String.valueOf(value);\n          method.addParameter(String.valueOf(paramName), convertToPsiType(typeName, place), false);\n\n          if (isNamed) {\n            Map<String, NamedArgumentDescriptor> namedParams = Maps.newHashMap();\n            for (Object o : (List)value) {\n              if (o instanceof CustomMembersGenerator.ParameterDescriptor) {\n                namedParams.put(((CustomMembersGenerator.ParameterDescriptor)o).name,\n                                ((CustomMembersGenerator.ParameterDescriptor)o).descriptor);\n              }\n            }\n            method.setNamedParameters(namedParams);\n          }\n        }\n      }\n\n      if (Boolean.TRUE.equals(prop.get(\"isStatic\"))) {\n        method.addModifier(PsiModifier.STATIC);\n      }\n\n      final Object bindsTo = prop.get(\"bindsTo\");\n      if (bindsTo instanceof PsiElement) {\n        method.setNavigationElement((PsiElement)bindsTo);\n      }\n\n      final Object toThrow = prop.get(CustomMembersGenerator.THROWS);\n      if (toThrow instanceof List) {\n        for (Object o : ((List)toThrow)) {\n          final PsiType psiType = convertToPsiType(String.valueOf(o), place);\n          if (psiType instanceof PsiClassType) {\n            method.addException((PsiClassType)psiType);\n          }\n        }\n      }\n\n      Object doc = prop.get(\"doc\");\n      if (doc instanceof String) {\n        method.putUserData(DOCUMENTATION, (String)doc);\n      }\n\n      Object docUrl = prop.get(\"docUrl\");\n      if (docUrl instanceof String) {\n        method.putUserData(DOCUMENTATION_URL, (String)docUrl);\n      }\n\n      myMethods.add(method);\n    }\n  }","id":75060,"modified_method":"private NonCodeMembersHolder(Set<Map> data, PsiElement place) {\n    final PsiManager manager = place.getManager();\n    for (Map prop : data) {\n      String name = String.valueOf(prop.get(\"name\"));\n\n      final GrLightMethodBuilder method = new GrLightMethodBuilder(manager, name).addModifier(PsiModifier.PUBLIC);\n\n      if (Boolean.TRUE.equals(prop.get(\"constructor\"))) {\n        method.setConstructor(true);\n      } else {\n        method.setReturnType(convertToPsiType(String.valueOf(prop.get(\"type\")), place));\n      }\n\n      final Object params = prop.get(\"params\");\n      if (params instanceof Map) {\n        boolean first = true;\n        for (Object paramName : ((Map)params).keySet()) {\n          Object value = ((Map)params).get(paramName);\n          boolean isNamed = first && value instanceof List;\n          first = false;\n          String typeName = isNamed ? CommonClassNames.JAVA_UTIL_MAP : String.valueOf(value);\n          method.addParameter(String.valueOf(paramName), convertToPsiType(typeName, place), false);\n\n          if (isNamed) {\n            Map<String, NamedArgumentDescriptor> namedParams = Maps.newHashMap();\n            for (Object o : (List)value) {\n              if (o instanceof CustomMembersGenerator.ParameterDescriptor) {\n                namedParams.put(((CustomMembersGenerator.ParameterDescriptor)o).name,\n                                ((CustomMembersGenerator.ParameterDescriptor)o).descriptor);\n              }\n            }\n            method.setNamedParameters(namedParams);\n          }\n        }\n      }\n\n      if (Boolean.TRUE.equals(prop.get(\"isStatic\"))) {\n        method.addModifier(PsiModifier.STATIC);\n      }\n\n      final Object bindsTo = prop.get(\"bindsTo\");\n      if (bindsTo instanceof PsiElement) {\n        method.setNavigationElement((PsiElement)bindsTo);\n      }\n\n      final Object toThrow = prop.get(CustomMembersGenerator.THROWS);\n      if (toThrow instanceof List) {\n        for (Object o : ((List)toThrow)) {\n          final PsiType psiType = convertToPsiType(String.valueOf(o), place);\n          if (psiType instanceof PsiClassType) {\n            method.addException((PsiClassType)psiType);\n          }\n        }\n      }\n\n      Object doc = prop.get(\"doc\");\n      if (doc instanceof String) {\n        method.putUserData(DOCUMENTATION, (String)doc);\n      }\n\n      Object docUrl = prop.get(\"docUrl\");\n      if (docUrl instanceof String) {\n        method.putUserData(DOCUMENTATION_URL, (String)docUrl);\n      }\n\n      myMethods.add(method);\n    }\n  }","commit_id":"7dec69fd9710f33f2ba193c68b0a9869f0f5657d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static ClassLoader getAntClassLoader(final GroovyFile groovyFile) {\n    return CachedValuesManager\n      .getManager(groovyFile.getProject()).getCachedValue(groovyFile, CLASS_LOADER, new CachedValueProvider<ClassLoader>() {\n        @Override\n        public Result<ClassLoader> compute() {\n          final Module module = ModuleUtil.findModuleForPsiElement(groovyFile);\n          Set<VirtualFile> jars = new HashSet<VirtualFile>();\n          if (module != null) {\n            jars.addAll(Arrays.asList(ModuleRootManager.getInstance(module).getFiles(OrderRootType.CLASSES)));\n          }\n\n          if (groovyFile.isScript() && GroovyScriptType.getScriptType(groovyFile) instanceof GantScriptType) {\n            jars.addAll(GantScriptType.additionalScopeFiles(groovyFile));\n          }\n\n          final ArrayList<URL> urls = new ArrayList<URL>();\n          for (VirtualFile jar : jars) {\n            urls.add(VfsUtil.convertToURL(PathUtil.getLocalFile(jar).getUrl()));\n          }\n          final ClassLoader loader = new UrlClassLoader(urls, null);\n          return Result.create(loader, ProjectRootManager.getInstance(groovyFile.getProject()));\n        }\n\n      }, false);\n  }","id":75061,"modified_method":"private static Map<String, Class> getAntObjects(final GroovyFile groovyFile) {\n    return CachedValuesManager\n      .getManager(groovyFile.getProject()).getCachedValue(groovyFile, ANT_OBJECTS, new CachedValueProvider<Map<String, Class>>() {\n        @Override\n        public Result<Map<String, Class>> compute() {\n          final Module module = ModuleUtil.findModuleForPsiElement(groovyFile);\n          Set<VirtualFile> jars = new HashSet<VirtualFile>();\n          if (module != null) {\n            jars.addAll(Arrays.asList(ModuleRootManager.getInstance(module).getFiles(OrderRootType.CLASSES)));\n          }\n\n          if (groovyFile.isScript() && GroovyScriptType.getScriptType(groovyFile) instanceof GantScriptType) {\n            jars.addAll(GantScriptType.additionalScopeFiles(groovyFile));\n          }\n\n          final ArrayList<URL> urls = new ArrayList<URL>();\n          for (VirtualFile jar : jars) {\n            urls.add(VfsUtil.convertToURL(PathUtil.getLocalFile(jar).getUrl()));\n          }\n          final ClassLoader loader = new UrlClassLoader(urls, null);\n          final ReflectedProject antProject = ReflectedProject.getProject(loader);\n\n          final Map<String, Class> result = new HashMap<String, Class>();\n          result.putAll(antProject.getTaskDefinitions());\n          result.putAll(antProject.getDataTypeDefinitions());\n          return Result.create(result, ProjectRootManager.getInstance(groovyFile.getProject()));\n        }\n\n      }, false);\n  }","commit_id":"924df680ad13934e296e20e8b55ac577d3655193","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Set<LightMethodBuilder> getAntTasks(PsiElement place) {\n    final PsiFile file = place.getContainingFile();\n    if (!(file instanceof GroovyFile)) {\n      return Collections.emptySet();\n    }\n\n    return CachedValuesManager.getManager(file.getProject()).getCachedValue(file, ANT_OBJECTS, new CachedValueProvider<Set<LightMethodBuilder>>() {\n      @Override\n      public Result<Set<LightMethodBuilder>> compute() {\n        return Result.create(findAntTasks((GroovyFile)file), PsiModificationTracker.JAVA_STRUCTURE_MODIFICATION_COUNT, ProjectRootManager.getInstance(file.getProject()));\n      }\n    }, false);\n  }","id":75062,"modified_method":"public static Set<LightMethodBuilder> getAntTasks(PsiElement place) {\n    final PsiFile file = place.getContainingFile();\n    if (!(file instanceof GroovyFile)) {\n      return Collections.emptySet();\n    }\n\n    return CachedValuesManager.getManager(file.getProject()).getCachedValue(file, GANT_METHODS, new CachedValueProvider<Set<LightMethodBuilder>>() {\n      @Override\n      public Result<Set<LightMethodBuilder>> compute() {\n        Map<String, Class> antObjects = getAntObjects((GroovyFile)file);\n\n        final Set<LightMethodBuilder> result = new HashSet<LightMethodBuilder>();\n\n        final Project project = file.getProject();\n        final JavaPsiFacade facade = JavaPsiFacade.getInstance(project);\n        final GlobalSearchScope scope = file.getResolveScope();\n\n        final PsiType closureType = JavaPsiFacade.getElementFactory(project).createTypeFromText(GrClosableBlock.GROOVY_LANG_CLOSURE,\n                                                                                                file);\n\n        for (String name : antObjects.keySet()) {\n          final PsiClass psiClass = facade.findClass(antObjects.get(name).getName(), scope);\n\n          final LightMethodBuilder tdMethod =\n            new LightMethodBuilder(PsiManager.getInstance(project), GroovyFileType.GROOVY_LANGUAGE, name).\n              setModifiers(PsiModifier.PUBLIC).\n              addParameter(\"args\", CommonClassNames.JAVA_UTIL_MAP).\n              setBaseIcon(GantIcons.ANT_TASK);\n\n          tdMethod.addParameter(new GrLightParameter(\"body\", closureType, tdMethod).setOptional(true));\n\n          if (psiClass != null) {\n            tdMethod.setNavigationElement(psiClass);\n          }\n          result.add(tdMethod);\n        }\n        return Result.create(result, PsiModificationTracker.JAVA_STRUCTURE_MODIFICATION_COUNT, ProjectRootManager.getInstance(file.getProject()));\n      }\n    }, false);\n  }","commit_id":"924df680ad13934e296e20e8b55ac577d3655193","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Create a cached value with the given provider and non-tracked return value, store it in PSI element's user data. If it's already stored, reuse it.\n   * @return The cached value\n   */\n  public static <T> T getCachedValue(@NotNull PsiElement psi, @NotNull CachedValueProvider<T> provider) {\n    CachedValuesManager manager = getManager(psi.getProject());\n    return manager.getCachedValue(psi, manager.<T>getKeyForClass(provider.getClass()), provider, false);\n  }","id":75063,"modified_method":"/**\n   * Create a cached value with the given provider and non-tracked return value, store it in PSI element's user data. If it's already stored, reuse it.\n   * @return The cached value\n   */\n  public static <T> T getCachedValue(@NotNull final PsiElement psi, @NotNull final CachedValueProvider<T> provider) {\n    CachedValuesManager manager = getManager(psi.getProject());\n    return manager.getCachedValue(psi, manager.<T>getKeyForClass(provider.getClass()), new CachedValueProvider<T>() {\n      @Nullable\n      @Override\n      public Result<T> compute() {\n        Result<T> result = provider.compute();\n        if (result != null && !psi.isPhysical()) {\n          return Result.create(result.getValue(), ArrayUtil.append(result.getDependencyItems(), psi));\n        }\n        return result;\n      }\n    }, false);\n  }","commit_id":"ac22a507da875d8ea0a29b4ff22af92186ae37a0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Map<String, PsiType> getAllSuperTypes(PsiType base, final PsiElement place) {\n    final Project project = place.getProject();\n    return CachedValuesManager.getManager(project).getCachedValue(project, SUPER_TYPES, new CachedValueProvider<FactoryMap<PsiType, Map<String, PsiType>>>() {\n      @Override\n      public Result<FactoryMap<PsiType, Map<String, PsiType>>> compute() {\n        final FactoryMap<PsiType, Map<String, PsiType>> map = new ConcurrentFactoryMap<PsiType, Map<String, PsiType>>() {\n\n          @Override\n          protected Map<PsiType, Map<String, PsiType>> createMap() {\n            return new ConcurrentHashMap<PsiType, Map<String, PsiType>>(RAW_TYPE_HASHING_STRATEGY);\n          }\n\n          @Override\n          protected Map<String, PsiType> create(PsiType key) {\n            final HashMap<String, PsiType> visited = new HashMap<String, PsiType>();\n            collectSuperTypes(key, visited);\n            if (key instanceof PsiArrayType) {\n              final PsiElementFactory factory = JavaPsiFacade.getElementFactory(project);\n              collectSuperTypes(factory.createTypeFromText(CommonClassNames.JAVA_LANG_COMPARABLE, null), visited);\n              collectSuperTypes(factory.createTypeFromText(CommonClassNames.JAVA_IO_SERIALIZABLE, null), visited);\n            }\n            return visited;\n          }\n        };\n        return Result.create(map, PsiModificationTracker.JAVA_STRUCTURE_MODIFICATION_COUNT, ProjectRootManager.getInstance(project));\n      }\n    }, false).get(base);\n  }","id":75064,"modified_method":"public static Map<String, PsiType> getAllSuperTypes(PsiType base, final PsiElement place) {\n    final Project project = place.getProject();\n    final Map<String, Map<String, PsiType>> cache =\n      CachedValuesManager.getManager(project).getCachedValue(project, new CachedValueProvider<Map<String, Map<String, PsiType>>>() {\n        @Override\n        public Result<Map<String, Map<String, PsiType>>> compute() {\n          final Map<String, Map<String, PsiType>> result = new ConcurrentHashMap<String, Map<String, PsiType>>();\n          return Result.create(result, PsiModificationTracker.JAVA_STRUCTURE_MODIFICATION_COUNT, ProjectRootManager.getInstance(project));\n        }\n      });\n\n    final PsiClass cls = PsiUtil.resolveClassInType(base);\n    //noinspection ConstantConditions\n    String key = cls instanceof PsiTypeParameter ? cls.getName() + cls.getSuperClass().getName() : rawCanonicalText(base);\n    Map<String, PsiType> result = cache.get(key);\n    if (result == null) {\n      result = new HashMap<String, PsiType>();\n      collectSuperTypes(base, result, project);\n      cache.put(key, result);\n    }\n    return result;\n  }","commit_id":"3e398c62cb824287f46d8891b4aaf6fcebcd0caf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void collectSuperTypes(PsiType type, Map<String, PsiType> visited) {\n    String qName = rawCanonicalText(type);\n\n    if (visited.put(qName, type) != null) {\n      return;\n    }\n\n    for (PsiType superType : type.getSuperTypes()) {\n      collectSuperTypes(TypeConversionUtil.erasure(superType), visited);\n    }\n\n  }","id":75065,"modified_method":"private static void collectSuperTypes(PsiType type, Map<String, PsiType> visited, Project project) {\n    String qName = rawCanonicalText(type);\n\n    if (visited.put(qName, type) != null) {\n      return;\n    }\n\n    final PsiType[] superTypes = type.getSuperTypes();\n    for (PsiType superType : superTypes) {\n      collectSuperTypes(TypeConversionUtil.erasure(superType), visited, project);\n    }\n\n    if (type instanceof PsiArrayType && superTypes.length == 0) {\n      final PsiElementFactory factory = JavaPsiFacade.getElementFactory(project);\n      collectSuperTypes(factory.createTypeFromText(CommonClassNames.JAVA_LANG_COMPARABLE, null), visited, project);\n      collectSuperTypes(factory.createTypeFromText(CommonClassNames.JAVA_IO_SERIALIZABLE, null), visited, project);\n    }\n\n  }","commit_id":"3e398c62cb824287f46d8891b4aaf6fcebcd0caf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void validateAdapter(ETLStage source, ETLStage sink, List<ETLStage> transformList)\n    throws IllegalArgumentException {\n    if (transformList.size() == 0) {\n      // No transforms. Check only source and sink.\n      if (!(TypeToken.of(batchSink.getKeyType()).isAssignableFrom(batchSource.getKeyType()) &&\n        TypeToken.of(batchSink.getValueType()).isAssignableFrom(batchSource.getValueType()))) {\n        throw new IllegalArgumentException(String.format(\"Source %s and Sink %s Types don't match\",\n                                                         source.getName(), sink.getName()));\n      }\n    } else {\n      // Check the first and last transform with source and sink.\n      ETLStage firstStage = Iterables.getFirst(transformList, null);\n      ETLStage lastStage = Iterables.getLast(transformList);\n      Transform firstTransform = Iterables.getFirst(transforms, null);\n      Transform lastTransform = Iterables.getLast(transforms);\n\n      if (!(TypeToken.of(firstTransform.getKeyInType()).isAssignableFrom(batchSource.getKeyType()) &&\n        TypeToken.of(firstTransform.getValueInType()).isAssignableFrom(batchSource.getValueType()))) {\n        throw new IllegalArgumentException(String.format(\"Source %s and Transform %s Types don't match\",\n                                                         source.getName(), firstStage.getName()));\n      }\n\n      if (!(TypeToken.of(lastTransform.getKeyOutType()).isAssignableFrom(batchSink.getKeyType()) &&\n        TypeToken.of(lastTransform.getValueOutType()).isAssignableFrom(batchSink.getValueType()))) {\n        throw new IllegalArgumentException(String.format(\"Sink %s and Transform %s Types don't match\",\n                                                         sink.getName(), lastStage.getName()));\n      }\n\n      if (transformList.size() > 1) {\n        // Check transform stages.\n        validateTransforms(transformList);\n      }\n    }\n  }","id":75066,"modified_method":"private void validateAdapter(ETLStage source, ETLStage sink, List<ETLStage> transformList)\n    throws IllegalArgumentException {\n    if (transformList.size() == 0) {\n      // No transforms. Check only source and sink.\n      if (!(isAssignable(batchSource.getKeyType(), batchSink.getKeyType()) &&\n        (isAssignable(batchSource.getValueType(), batchSink.getValueType())))) {\n        throw new IllegalArgumentException(String.format(\"Source %s and Sink %s Types don't match\",\n                                                         source.getName(), sink.getName()));\n      }\n    } else {\n      // Check the first and last transform with source and sink.\n      ETLStage firstStage = Iterables.getFirst(transformList, null);\n      ETLStage lastStage = Iterables.getLast(transformList);\n      Transform firstTransform = Iterables.getFirst(transforms, null);\n      Transform lastTransform = Iterables.getLast(transforms);\n\n      if (!(isAssignable(batchSource.getKeyType(), firstTransform.getKeyInType()) &&\n        (isAssignable(batchSource.getValueType(), firstTransform.getValueInType())))) {\n        throw new IllegalArgumentException(String.format(\"Source %s and Transform %s Types don't match\",\n                                                         source.getName(), firstStage.getName()));\n      }\n\n      if (!(isAssignable(lastTransform.getKeyOutType(), batchSink.getKeyType()) &&\n        (isAssignable(lastTransform.getValueOutType(), batchSink.getValueType())))) {\n        throw new IllegalArgumentException(String.format(\"Sink %s and Transform %s Types don't match\",\n                                                         sink.getName(), lastStage.getName()));\n      }\n\n      if (transformList.size() > 1) {\n        // Check transform stages.\n        validateTransforms(transformList);\n      }\n    }\n  }","commit_id":"327a19abf7cc8e420a293214848dccc109b6012e","url":"https://github.com/caskdata/cdap"},{"original_method":"private void validateTransforms(List<ETLStage> transformList) throws IllegalArgumentException {\n    for (int i = 0; i < transformList.size() - 1; i++) {\n      ETLStage currStage = transformList.get(i);\n      ETLStage nextStage = transformList.get(i + 1);\n      Transform firstTransform = transforms.get(i);\n      Transform secondTransform = transforms.get(i + 1);\n\n      if (!(TypeToken.of(secondTransform.getKeyInType()).isAssignableFrom(firstTransform.getKeyOutType()) &&\n        TypeToken.of(secondTransform.getValueInType()).isAssignableFrom(firstTransform.getValueOutType()))) {\n        throw new IllegalArgumentException(String.format(\"Transform %s and Transform %s Types don't match\",\n                                                         currStage.getName(), nextStage.getName()));\n      }\n    }\n  }","id":75067,"modified_method":"private void validateTransforms(List<ETLStage> transformList) throws IllegalArgumentException {\n    for (int i = 0; i < transformList.size() - 1; i++) {\n      ETLStage currStage = transformList.get(i);\n      ETLStage nextStage = transformList.get(i + 1);\n      Transform firstTransform = transforms.get(i);\n      Transform secondTransform = transforms.get(i + 1);\n\n      if (!(isAssignable(firstTransform.getKeyOutType(), secondTransform.getKeyInType()) &&\n        (isAssignable(firstTransform.getValueOutType(), secondTransform.getValueInType())))) {\n        throw new IllegalArgumentException(String.format(\"Transform %s and Transform %s Types don't match\",\n                                                         currStage.getName(), nextStage.getName()));\n      }\n    }\n  }","commit_id":"327a19abf7cc8e420a293214848dccc109b6012e","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void transform(Object keyIn, Object valueIn, Emitter<Object, Object> emitter) {\n    emitter.emit(keyIn, valueIn);\n  }","id":75068,"modified_method":"@Override\n  public void transform(A keyIn, B valueIn, Emitter<A, B> emitter) {\n    emitter.emit(keyIn, valueIn);\n  }","commit_id":"327a19abf7cc8e420a293214848dccc109b6012e","url":"https://github.com/caskdata/cdap"},{"original_method":"public static String getExportThreadsText(VirtualMachineProxyImpl vmProxy) {\n    StringBuffer buffer = new StringBuffer(512);\n    List<ThreadReference> threads = vmProxy.getVirtualMachine().allThreads();\n    for (ThreadReference threadReference : threads) {\n      buffer.append(threadName(threadReference));\n      ReferenceType referenceType = threadReference.referenceType();\n      if (referenceType != null) {\n        //noinspection HardCodedStringLiteral\n        Field daemon = referenceType.fieldByName(\"daemon\");\n        if (daemon != null) {\n          Value value = threadReference.getValue(daemon);\n          if (value instanceof BooleanValue && ((BooleanValue)value).booleanValue()) {\n            buffer.append(\" \").append(DebuggerBundle.message(\"threads.export.attribute.label.daemon\"));\n          }\n        }\n\n        //noinspection HardCodedStringLiteral\n        Field priority = referenceType.fieldByName(\"priority\");\n        if (priority != null) {\n          Value value = threadReference.getValue(priority);\n          if (value instanceof IntegerValue) {\n            buffer.append(\", \").append(DebuggerBundle.message(\"threads.export.attribute.label.priority\", ((IntegerValue)value).intValue()));\n          }\n        }\n      }\n\n      ThreadGroupReference groupReference = threadReference.threadGroup();\n      if (groupReference != null) {\n        buffer.append(\", \").append(DebuggerBundle.message(\"threads.export.attribute.label.group\", groupReference.name()));\n      }\n      buffer.append(\", \").append(\n        DebuggerBundle.message(\"threads.export.attribute.label.status\", DebuggerUtilsEx.getThreadStatusText(threadReference.status())));\n\n      try {\n        if (vmProxy.canGetOwnedMonitorInfo() && vmProxy.canGetMonitorInfo()) {\n          List<ObjectReference> list = threadReference.ownedMonitors();\n          for (ObjectReference reference : list) {\n            final List<ThreadReference> waiting = reference.waitingThreads();\n            for (ThreadReference thread : waiting) {\n              buffer.append(\"\\n\\t \").append(DebuggerBundle.message(\"threads.export.attribute.label.blocks.thread\", threadName(thread)));\n            }\n          }\n        }\n\n        ObjectReference waitedMonitor = vmProxy.canGetCurrentContendedMonitor() ? threadReference.currentContendedMonitor() : null;\n        if (waitedMonitor != null) {\n          if (vmProxy.canGetMonitorInfo()) {\n            ThreadReference waitedThread = waitedMonitor.owningThread();\n            if (waitedThread != null) {\n              buffer.append(\"\\n\\t \")\n                .append(DebuggerBundle.message(\"threads.export.attribute.label.waiting.for.thread\", threadName(waitedThread)));\n            }\n          }\n        }\n\n        final List<StackFrame> frames = threadReference.frames();\n        for (StackFrame stackFrame : frames) {\n          final Location location = stackFrame.location();\n          buffer.append(\"\\n\\t  \").append(renderLocation(location));\n        }\n      }\n      catch (IncompatibleThreadStateException e) {\n        buffer.append(\"\\n\\t \").append(DebuggerBundle.message(\"threads.export.attribute.error.incompatible.state\"));\n      }\n      buffer.append(\"\\n\\n\");\n    }\n    return buffer.toString();\n  }","id":75069,"modified_method":"public static String getExportThreadsText(VirtualMachineProxyImpl vmProxy) {\n    final StringBuffer buffer = new StringBuffer(512);\n    List<ThreadReference> threads = vmProxy.getVirtualMachine().allThreads();\n    for (ThreadReference threadReference : threads) {\n      final String name = threadName(threadReference);\n      if (name == null) {\n        continue;\n      }\n      buffer.append(name);\n      ReferenceType referenceType = threadReference.referenceType();\n      if (referenceType != null) {\n        //noinspection HardCodedStringLiteral\n        Field daemon = referenceType.fieldByName(\"daemon\");\n        if (daemon != null) {\n          Value value = threadReference.getValue(daemon);\n          if (value instanceof BooleanValue && ((BooleanValue)value).booleanValue()) {\n            buffer.append(\" \").append(DebuggerBundle.message(\"threads.export.attribute.label.daemon\"));\n          }\n        }\n\n        //noinspection HardCodedStringLiteral\n        Field priority = referenceType.fieldByName(\"priority\");\n        if (priority != null) {\n          Value value = threadReference.getValue(priority);\n          if (value instanceof IntegerValue) {\n            buffer.append(\", \").append(DebuggerBundle.message(\"threads.export.attribute.label.priority\", ((IntegerValue)value).intValue()));\n          }\n        }\n      }\n\n      ThreadGroupReference groupReference = threadReference.threadGroup();\n      if (groupReference != null) {\n        buffer.append(\", \").append(DebuggerBundle.message(\"threads.export.attribute.label.group\", groupReference.name()));\n      }\n      buffer.append(\", \").append(\n        DebuggerBundle.message(\"threads.export.attribute.label.status\", DebuggerUtilsEx.getThreadStatusText(threadReference.status())));\n\n      try {\n        if (vmProxy.canGetOwnedMonitorInfo() && vmProxy.canGetMonitorInfo()) {\n          List<ObjectReference> list = threadReference.ownedMonitors();\n          for (ObjectReference reference : list) {\n            final List<ThreadReference> waiting = reference.waitingThreads();\n            for (ThreadReference thread : waiting) {\n              final String waitingThreadName = threadName(thread);\n              if (waitingThreadName != null) {\n                buffer.append(\"\\n\\t \").append(DebuggerBundle.message(\"threads.export.attribute.label.blocks.thread\", waitingThreadName));\n              }\n            }\n          }\n        }\n\n        ObjectReference waitedMonitor = vmProxy.canGetCurrentContendedMonitor() ? threadReference.currentContendedMonitor() : null;\n        if (waitedMonitor != null) {\n          if (vmProxy.canGetMonitorInfo()) {\n            ThreadReference waitedThread = waitedMonitor.owningThread();\n            if (waitedThread != null) {\n              final String waitedThreadName = threadName(waitedThread);\n              if (waitedThreadName != null) {\n                buffer.append(\"\\n\\t \").append(DebuggerBundle.message(\"threads.export.attribute.label.waiting.for.thread\", waitedThreadName));\n              }\n            }\n          }\n        }\n\n        final List<StackFrame> frames = threadReference.frames();\n        for (StackFrame stackFrame : frames) {\n          final Location location = stackFrame.location();\n          buffer.append(\"\\n\\t  \").append(renderLocation(location));\n        }\n      }\n      catch (IncompatibleThreadStateException e) {\n        buffer.append(\"\\n\\t \").append(DebuggerBundle.message(\"threads.export.attribute.error.incompatible.state\"));\n      }\n      buffer.append(\"\\n\\n\");\n    }\n    return buffer.toString();\n  }","commit_id":"c1e6928bb750e53fdb2f76abc0bfb3d947f46a31","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String threadName(ThreadReference threadReference) {\n    return threadReference.name() + \"@\" + threadReference.uniqueID();\n  }","id":75070,"modified_method":"private static String threadName(ThreadReference threadReference) {\n    try {\n      return threadReference.name() + \"@\" + threadReference.uniqueID();\n    }\n    catch (ObjectCollectedException e) {\n      return null;\n    }\n  }","commit_id":"c1e6928bb750e53fdb2f76abc0bfb3d947f46a31","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n\tpublic int getSpecificity() {\n\t\treturn 1;\n\t}","id":75071,"modified_method":"private ConsumeRequestCondition getMostSpecificCondition() {\n\t\tList<ConsumeRequestCondition> conditions = new ArrayList<ConsumeRequestCondition>(getConditions());\n\t\tCollections.sort(conditions);\n\t\treturn conditions.get(0);\n\t}","commit_id":"71aae405d57288e83086e36143df3eb9bd6dba39","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public boolean match(HttpServletRequest request) {\n\t\tMediaType contentType;\n\t\tif (StringUtils.hasLength(request.getContentType())) {\n\t\t\tcontentType = MediaType.parseMediaType(request.getContentType());\n\t\t}\n\t\telse {\n\t\t\tcontentType = MediaType.APPLICATION_OCTET_STREAM;\n\t\t}\n\t\treturn this.mediaType.includes(contentType);\n\t}","id":75072,"modified_method":"/**\n\t * Returns a new {@code RequestCondition} that contains all conditions of this key that match the request.\n\t *\n\t * @param request the request\n\t * @return a new request condition that contains all matching attributes, or {@code null} if not all conditions match\n\t */\n\tpublic ConsumesRequestCondition getMatchingCondition(HttpServletRequest request) {\n\t\tSet<ConsumeRequestCondition> matchingConditions = new LinkedHashSet<ConsumeRequestCondition>(getConditions());\n\t\tfor (Iterator<ConsumeRequestCondition> iterator = matchingConditions.iterator(); iterator.hasNext();) {\n\t\t\tConsumeRequestCondition condition = iterator.next();\n\t\t\tif (!condition.match(request)) {\n\t\t\t\titerator.remove();\n\t\t\t}\n\t\t}\n\t\tif (matchingConditions.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\treturn new ConsumesRequestCondition(matchingConditions);\n\t\t}\n\t}","commit_id":"71aae405d57288e83086e36143df3eb9bd6dba39","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"ConsumesRequestCondition(String mediaType) {\n\t\tthis.mediaType = MediaType.parseMediaType(mediaType);\n\t}","id":75073,"modified_method":"ConsumesRequestCondition(String... consumes) {\n\t\tthis(parseConditions(Arrays.asList(consumes)));\n\t}","commit_id":"71aae405d57288e83086e36143df3eb9bd6dba39","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"LogicalConjunctionRequestCondition(List<RequestCondition> conditions) {\n\t\tsuper(conditions);\n\t}","id":75074,"modified_method":"LogicalConjunctionRequestCondition(Collection<T> conditions) {\n\t\tsuper(conditions);\n\t}","commit_id":"71aae405d57288e83086e36143df3eb9bd6dba39","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public boolean match(HttpServletRequest request) {\n\t\tfor (RequestCondition condition : conditions) {\n\t\t\tif (!condition.match(request)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}","id":75075,"modified_method":"public boolean match(HttpServletRequest request) {\n\t\tSet<T> conditions = getConditions();\n\t\tif (conditions.isEmpty()) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (T condition : conditions) {\n\t\t\tif (!condition.match(request)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}","commit_id":"71aae405d57288e83086e36143df3eb9bd6dba39","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public boolean match(HttpServletRequest request) {\n\t\tfor (RequestCondition condition : conditions) {\n\t\t\tif (condition.match(request)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":75076,"modified_method":"public boolean match(HttpServletRequest request) {\n\t\tfor (RequestCondition condition : getConditions()) {\n\t\t\tif (condition.match(request)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","commit_id":"71aae405d57288e83086e36143df3eb9bd6dba39","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"LogicalDisjunctionRequestCondition(List<RequestCondition> conditions) {\n\t\tsuper(conditions);\n\t}","id":75077,"modified_method":"LogicalDisjunctionRequestCondition(Collection<T> conditions) {\n\t\tsuper(conditions);\n\t}","commit_id":"71aae405d57288e83086e36143df3eb9bd6dba39","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic String toString() {\n\t\tStringBuilder builder = new StringBuilder(\"[\");\n\t\tString infix = getToStringInfix();\n\t\tfor (Iterator<RequestCondition> iterator = conditions.iterator(); iterator.hasNext();) {\n\t\t\tRequestCondition condition = iterator.next();\n\t\t\tbuilder.append(condition.toString());\n\t\t\tif (iterator.hasNext()) {\n\t\t\t\tbuilder.append(infix);\n\t\t\t}\n\t\t}\n\t\tbuilder.append(\"]\");\n\t\treturn builder.toString();\n\t}","id":75078,"modified_method":"@Override\n\tpublic String toString() {\n\t\tStringBuilder builder = new StringBuilder(\"[\");\n\t\tString infix = getToStringInfix();\n\t\tfor (Iterator<T> iterator = conditions.iterator(); iterator.hasNext();) {\n\t\t\tRequestCondition condition = iterator.next();\n\t\t\tbuilder.append(condition.toString());\n\t\t\tif (iterator.hasNext()) {\n\t\t\t\tbuilder.append(infix);\n\t\t\t}\n\t\t}\n\t\tbuilder.append(\"]\");\n\t\treturn builder.toString();\n\t}","commit_id":"71aae405d57288e83086e36143df3eb9bd6dba39","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"protected RequestConditionComposite(List<RequestCondition> conditions) {\n\t\tAssert.notEmpty(conditions, \"'conditions' must not be empty\");\n\t\tthis.conditions = Collections.unmodifiableList(conditions);\n\t}","id":75079,"modified_method":"protected RequestConditionComposite(Collection<T> conditions) {\n\t\tthis.conditions = Collections.unmodifiableSet(new LinkedHashSet<T>(conditions));\n\t}","commit_id":"71aae405d57288e83086e36143df3eb9bd6dba39","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Parses the given parameters, and returns them as a single request conditions.\n\t *\n\t * @param params the parameters\n\t * @return the request condition\n\t * @see org.springframework.web.bind.annotation.RequestMapping#params()\n\t */\n\tpublic static RequestCondition parseParams(String... params) {\n\t\tif (ObjectUtils.isEmpty(params)) {\n\t\t\treturn trueCondition();\n\t\t}\n\t\tRequestCondition[] result = new RequestCondition[params.length];\n\t\tfor (int i = 0; i < params.length; i++) {\n\t\t\tresult[i] = new ParamRequestCondition(params[i]);\n\t\t}\n\t\treturn and(result);\n\t}","id":75080,"modified_method":"/**\n\t * Parses the given parameters, and returns them as a single request conditions.\n\t *\n\t * @param params the parameters\n\t * @return the request condition\n\t * @see org.springframework.web.bind.annotation.RequestMapping#params()\n\t */\n\tpublic static ParamsRequestCondition parseParams(String... params) {\n\t\treturn new ParamsRequestCondition(params);\n\t}","commit_id":"71aae405d57288e83086e36143df3eb9bd6dba39","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Parses the given headers, and returns them as a single request condition.\n\t *\n\t * @param headers the headers\n\t * @return the request condition\n\t * @see org.springframework.web.bind.annotation.RequestMapping#headers()\n\t */\n\tpublic static RequestCondition parseHeaders(String... headers) {\n\t\tif (ObjectUtils.isEmpty(headers)) {\n\t\t\treturn trueCondition();\n\t\t}\n\t\tRequestCondition[] result = new RequestCondition[headers.length];\n\t\tfor (int i = 0; i < headers.length; i++) {\n\t\t\tHeaderRequestCondition header = new HeaderRequestCondition(headers[i]);\n\t\t\tif (\"Content-Type\".equalsIgnoreCase(header.name) && StringUtils.hasLength(header.value)) {\n\t\t\t\tRequestCondition consumesCondition = new ConsumesRequestCondition(header.value);\n\t\t\t\tresult[i] = header.isNegated ? not(consumesCondition) : consumesCondition;\n\t\t\t}\n\t\t\telse if (isMediaTypeHeader(header.name)) {\n\t\t\t\tresult[i] = new MediaTypeHeaderRequestCondition(headers[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult[i] = header;\n\t\t\t}\n\t\t}\n\t\treturn and(result);\n\t}","id":75081,"modified_method":"/**\n\t * Parses the given headers, and returns them as a single request condition.\n\t *\n\t * @param headers the headers\n\t * @return the request condition\n\t * @see org.springframework.web.bind.annotation.RequestMapping#headers()\n\t */\n\tpublic static HeadersRequestCondition parseHeaders(String... headers) {\n\t\tHeadersRequestCondition headersCondition = new HeadersRequestCondition(headers);\n\n\t\t// filter out Accept and Content-Type headers, they are dealt with by produces and consumes respectively\n\t\tSet<HeadersRequestCondition.HeaderRequestCondition> filteredConditions =\n\t\t\t\tnew LinkedHashSet<HeadersRequestCondition.HeaderRequestCondition>(headersCondition.getConditions());\n\n\t\tfor (Iterator<HeadersRequestCondition.HeaderRequestCondition> iterator = filteredConditions.iterator();\n\t\t\t\titerator.hasNext();) {\n\t\t\tHeadersRequestCondition.HeaderRequestCondition headerCondition = iterator.next();\n\t\t\tif (ACCEPT_HEADER.equalsIgnoreCase(headerCondition.name) ||\n\t\t\t\t\tCONTENT_TYPE_HEADER.equalsIgnoreCase(headerCondition.name)) {\n\t\t\t\titerator.remove();\n\t\t\t}\n\t\t}\n\t\treturn new HeadersRequestCondition(filteredConditions);\n\t}","commit_id":"71aae405d57288e83086e36143df3eb9bd6dba39","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Parses the given consumes, and returns them as a single request condition.\n\t *\n\t * @param consumes the consumes\n\t * @return the request condition\n\t * @see org.springframework.web.bind.annotation.RequestMapping#consumes()\n\t */\n\tpublic static RequestCondition parseConsumes(String... consumes) {\n\t\tif (ObjectUtils.isEmpty(consumes)) {\n\t\t\treturn trueCondition();\n\t\t}\n\t\tRequestCondition[] result = new RequestCondition[consumes.length];\n\t\tfor (int i = 0; i < consumes.length; i++) {\n\t\t\tresult[i] = new ConsumesRequestCondition(consumes[i]);\n\t\t}\n\t\treturn or(result);\n\t}","id":75082,"modified_method":"/**\n\t * Parses the given consumes, and returns them as a single request condition.\n\t *\n\t * @param consumes the consumes\n\t * @return the request condition\n\t * @see org.springframework.web.bind.annotation.RequestMapping#consumes()\n\t */\n\tpublic static ConsumesRequestCondition parseConsumes(String... consumes) {\n\t\treturn new ConsumesRequestCondition(consumes);\n\t}","commit_id":"71aae405d57288e83086e36143df3eb9bd6dba39","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private static RequestMappingInfo createFromRequestMapping(RequestMapping annotation) {\n\t\treturn new RequestMappingInfo(Arrays.asList(annotation.value()), Arrays.asList(annotation.method()),\n\t\t\t\t\t\tRequestConditionFactory.parseParams(annotation.params()),\n\t\t\t\t\t\tRequestConditionFactory.parseHeaders(annotation.headers()),\n\t\t\t\t\t\tRequestConditionFactory.parseConsumes());\n\t}","id":75083,"modified_method":"private static RequestMappingInfo createFromRequestMapping(RequestMapping annotation) {\n\t\treturn new RequestMappingInfo(Arrays.asList(annotation.value()), Arrays.asList(annotation.method()),\n\t\t\t\t\t\tRequestConditionFactory.parseParams(annotation.params()),\n\t\t\t\t\t\tRequestConditionFactory.parseHeaders(annotation.headers()),\n\t\t\t\t\t\tRequestConditionFactory.parseConsumes(annotation.consumes(), annotation.headers()));\n\t}","commit_id":"71aae405d57288e83086e36143df3eb9bd6dba39","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public int compare(RequestMappingInfo mapping, RequestMappingInfo otherMapping) {\n\t\t\tint result = comparePatterns(mapping.getPatterns(), otherMapping.getPatterns());\n\t\t\tif (result != 0) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tresult = mapping.getParams().compareTo(otherMapping.getParams());\n\t\t\tif (result != 0) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tresult = mapping.getHeaders().compareTo(otherMapping.getHeaders());\n\t\t\tif (result != 0) {\n\t\t\t\treturn result;\n\t\t\t}\n/*\n\t\t\tTODO: fix\n\t\t\tresult = compareAcceptHeaders(mapping.getAcceptHeaderMediaTypes(), otherMapping.getAcceptHeaderMediaTypes());\n\t\t\tif (result != 0) {\n\t\t\t\treturn result;\n\t\t\t}\n*/\n\t\t\tresult = otherMapping.getMethods().size() - mapping.getMethods().size();\n\t\t\tif (result != 0) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}","id":75084,"modified_method":"public int compare(RequestMappingInfo mapping, RequestMappingInfo otherMapping) {\n\t\t\tint result = comparePatterns(mapping.getPatterns(), otherMapping.getPatterns());\n\t\t\tif (result != 0) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tresult = mapping.getParams().compareTo(otherMapping.getParams());\n\t\t\tif (result != 0) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tresult = mapping.getHeaders().compareTo(otherMapping.getHeaders());\n\t\t\tif (result != 0) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tresult = mapping.getConsumes().compareTo(otherMapping.getConsumes());\n\t\t\tif (result != 0) {\n\t\t\t\treturn result;\n\t\t\t}\n/*\n\t\t\tTODO: fix\n\t\t\tresult = compareAcceptHeaders(mapping.getAcceptHeaderMediaTypes(), otherMapping.getAcceptHeaderMediaTypes());\n\t\t\tif (result != 0) {\n\t\t\t\treturn result;\n\t\t\t}\n*/\n\t\t\tresult = otherMapping.getMethods().size() - mapping.getMethods().size();\n\t\t\tif (result != 0) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}","commit_id":"71aae405d57288e83086e36143df3eb9bd6dba39","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Combines this {@code RequestKey} with another as follows: \n\t * <ul>\n\t * <li>URL patterns:\n\t * \t<ul>\n\t * \t  <li>If both have patterns combine them according to the rules of the given {@link PathMatcher}\n\t * \t  <li>If either contains patterns, but not both, use the available pattern\n\t * \t  <li>If neither contains patterns use \"\"\n\t * \t<\/ul>\n\t * <li>HTTP methods are combined as union of all HTTP methods listed in both keys.\n\t * <li>Request parameter are combined into a logical AND.\n\t * <li>Request header are combined into a logical AND.\n\t * <li>Consumes .. TODO\n\t * <\/ul>\n\t * @param methodKey the key to combine with\n\t * @param pathMatcher to {@linkplain PathMatcher#combine(String, String) combine} the patterns\n\t * @return a new request key containing conditions from both keys\n\t */\n\tpublic RequestMappingInfo combine(RequestMappingInfo methodKey, PathMatcher pathMatcher) {\n\t\tSet<String> patterns = combinePatterns(this.patterns, methodKey.patterns, pathMatcher);\n\t\tSet<RequestMethod> methods = union(this.methods, methodKey.methods);\n\t\tRequestCondition params = RequestConditionFactory.and(this.paramsCondition, methodKey.paramsCondition);\n\t\tRequestCondition headers = RequestConditionFactory.and(this.headersCondition, methodKey.headersCondition);\n\t\tRequestCondition consumes = RequestConditionFactory.mostSpecific(methodKey.consumesCondition, this.consumesCondition);\n\n\t\treturn new RequestMappingInfo(patterns, methods, params, headers, consumes);\n\t}","id":75085,"modified_method":"/**\n\t * Combines this {@code RequestMappingInfo} with another as follows:\n\t * <ul>\n\t * <li>URL patterns:\n\t * \t<ul>\n\t * \t  <li>If both have patterns combine them according to the rules of the given {@link PathMatcher}\n\t * \t  <li>If either contains patterns, but not both, use the available pattern\n\t * \t  <li>If neither contains patterns use \"\"\n\t * \t<\/ul>\n\t * <li>HTTP methods are combined as union of all HTTP methods listed in both keys.\n\t * <li>Request parameters are combined as per {@link ParamsRequestCondition#combine(ParamsRequestCondition)}.\n\t * <li>Request headers are combined as per {@link HeadersRequestCondition#combine(HeadersRequestCondition)}.\n\t * <li>Consumes are combined as per {@link ConsumesRequestCondition#combine(ConsumesRequestCondition)}.\n\t * <\/ul>\n\t * @param methodKey the key to combine with\n\t * @param pathMatcher to {@linkplain PathMatcher#combine(String, String) combine} the patterns\n\t * @return a new request key containing conditions from both keys\n\t */\n\tpublic RequestMappingInfo combine(RequestMappingInfo methodKey, PathMatcher pathMatcher) {\n\t\tSet<String> patterns = combinePatterns(this.patterns, methodKey.patterns, pathMatcher);\n\t\tSet<RequestMethod> methods = union(this.methods, methodKey.methods);\n\t\tParamsRequestCondition params = this.paramsCondition.combine(methodKey.paramsCondition);\n\t\tHeadersRequestCondition headers = this.headersCondition.combine(methodKey.headersCondition);\n\t\tConsumesRequestCondition consumes = this.consumesCondition.combine(methodKey.consumesCondition);\n\n\t\treturn new RequestMappingInfo(patterns, methods, params, headers, consumes);\n\t}","commit_id":"71aae405d57288e83086e36143df3eb9bd6dba39","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Creates a new {@code RequestKey} instance with a full set of conditions.\n\t */\n\tpublic RequestMappingInfo(Collection<String> patterns,\n\t\t\t\t\t\t\t Collection<RequestMethod> methods,\n\t\t\t\t\t\t\t RequestCondition paramsCondition,\n\t\t\t\t\t\t\t RequestCondition headersCondition,\n\t\t\t\t\t\t\t RequestCondition consumesCondition) {\n\t\tthis.patterns = asUnmodifiableSet(prependLeadingSlash(patterns));\n\t\tthis.methods = asUnmodifiableSet(methods);\n\t\tthis.paramsCondition = paramsCondition != null ? paramsCondition : RequestConditionFactory.trueCondition();\n\t\tthis.headersCondition = headersCondition != null ? headersCondition : RequestConditionFactory.trueCondition();\n\t\tthis.consumesCondition = consumesCondition != null ? consumesCondition : RequestConditionFactory.trueCondition();\n\t}","id":75086,"modified_method":"/**\n\t * Creates a new {@code RequestMappingInfo} instance with a full set of conditions.\n\t */\n\tpublic RequestMappingInfo(Collection<String> patterns,\n\t\t\t\t\t\t\t Collection<RequestMethod> methods,\n\t\t\t\t\t\t\t ParamsRequestCondition paramsCondition,\n\t\t\t\t\t\t\t HeadersRequestCondition headersCondition,\n\t\t\t\t\t\t\t ConsumesRequestCondition consumesCondition) {\n\t\tthis.patterns = asUnmodifiableSet(prependLeadingSlash(patterns));\n\t\tthis.methods = asUnmodifiableSet(methods);\n\t\tthis.paramsCondition = paramsCondition != null ? paramsCondition : new ParamsRequestCondition();\n\t\tthis.headersCondition = headersCondition != null ? headersCondition : new HeadersRequestCondition();\n\t\tthis.consumesCondition = consumesCondition != null ? consumesCondition : new ConsumesRequestCondition();\n\t}","commit_id":"71aae405d57288e83086e36143df3eb9bd6dba39","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic int hashCode() {\n\t\tint result = hash;\n\t\tif (result == 0) {\n\t\t\tresult = patterns.hashCode();\n\t\t\tresult = 31 * result + methods.hashCode();\n\t\t\tresult = 31 * result + paramsCondition.hashCode();\n\t\t\tresult = 31 * result + headersCondition.hashCode();\n\t\t\thash = result;\n\t\t}\n\t\treturn result;\n\t}","id":75087,"modified_method":"@Override\n\tpublic int hashCode() {\n\t\tint result = hash;\n\t\tif (result == 0) {\n\t\t\tresult = patterns.hashCode();\n\t\t\tresult = 31 * result + methods.hashCode();\n\t\t\tresult = 31 * result + paramsCondition.hashCode();\n\t\t\tresult = 31 * result + headersCondition.hashCode();\n\t\t\tresult = 31 * result + consumesCondition.hashCode();\n\t\t\thash = result;\n\t\t}\n\t\treturn result;\n\t}","commit_id":"71aae405d57288e83086e36143df3eb9bd6dba39","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Returns the request parameters of this request key.\n\t */\n\tpublic RequestCondition getParams() {\n\t\treturn paramsCondition;\n\t}","id":75088,"modified_method":"/**\n\t * Returns the request parameters conditions of this request key.\n\t */\n\tpublic ParamsRequestCondition getParams() {\n\t\treturn paramsCondition;\n\t}","commit_id":"71aae405d57288e83086e36143df3eb9bd6dba39","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Returns a new {@code RequestKey} that contains all conditions of this key that are relevant to the request.\n\t * <ul>\n\t * <li>The list of URL path patterns is trimmed to contain the patterns that match the URL with matching patterns \n\t * sorted via {@link PathMatcher#getPatternComparator(String)}. \n\t * <li>The list of HTTP methods is trimmed to contain only the method of the request. \n\t * <li>Request parameter and request header conditions are included in full. \n\t * <li>The list of consumes conditions is trimmed and sorted to match the request \"Content-Type\" header.\n\t * <\/ul>   \n\t * @param lookupPath mapping lookup path within the current servlet mapping if applicable\n\t * @param request the current request\n\t * @param pathMatcher to check for matching patterns\n\t * @return a new request key that contains all matching attributes, or {@code null} if not all conditions match\n\t */\n\tpublic RequestMappingInfo getMatchingRequestMapping(String lookupPath, HttpServletRequest request, PathMatcher pathMatcher) {\n\t\tif (!checkMethod(request) || !paramsCondition.match(request) || !headersCondition.match(request) ||\n\t\t\t\t!consumesCondition.match(request)) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tList<String> matchingPatterns = getMatchingPatterns(lookupPath, request, pathMatcher);\n\t\t\tif (!matchingPatterns.isEmpty()) {\n\t\t\t\tSet<RequestMethod> matchingMethods = getMatchingMethod(request);\n\t\t\t\treturn new RequestMappingInfo(matchingPatterns, matchingMethods, this.paramsCondition, this.headersCondition,\n\t\t\t\t\t\tthis.consumesCondition);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}","id":75089,"modified_method":"/**\n\t * Returns a new {@code RequestMappingInfo} that contains all conditions of this key that are relevant to the request.\n\t * <ul>\n\t * <li>The list of URL path patterns is trimmed to contain the patterns that match the URL with matching patterns \n\t * sorted via {@link PathMatcher#getPatternComparator(String)}. \n\t * <li>The list of HTTP methods is trimmed to contain only the method of the request. \n\t * <li>Request parameter and request header conditions are included in full. \n\t * <li>The list of consumes conditions is trimmed and sorted to match the request \"Content-Type\" header.\n\t * <\/ul>   \n\t * @param lookupPath mapping lookup path within the current servlet mapping if applicable\n\t * @param request the current request\n\t * @param pathMatcher to check for matching patterns\n\t * @return a new request key that contains all matching attributes, or {@code null} if not all conditions match\n\t */\n\tpublic RequestMappingInfo getMatchingRequestMapping(String lookupPath, HttpServletRequest request, PathMatcher pathMatcher) {\n\t\tParamsRequestCondition matchingParamsCondition = paramsCondition.getMatchingCondition(request);\n\t\tHeadersRequestCondition matchingHeadersCondition = headersCondition.getMatchingCondition(request);\n\t\tConsumesRequestCondition matchingConsumesCondition = consumesCondition.getMatchingCondition(request);\n\n\t\tif (!checkMethod(request) || matchingParamsCondition == null || matchingHeadersCondition == null ||\n\t\t\t\tmatchingConsumesCondition == null) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tList<String> matchingPatterns = getMatchingPatterns(lookupPath, request, pathMatcher);\n\t\t\tif (!matchingPatterns.isEmpty()) {\n\t\t\t\tSet<RequestMethod> matchingMethods = getMatchingMethod(request);\n\t\t\t\treturn new RequestMappingInfo(matchingPatterns, matchingMethods, matchingParamsCondition,\n\t\t\t\t\t\tmatchingHeadersCondition, matchingConsumesCondition);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}","commit_id":"71aae405d57288e83086e36143df3eb9bd6dba39","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj) {\n\t\t\treturn true;\n\t\t}\n\t\tif (obj != null && obj instanceof RequestMappingInfo) {\n\t\t\tRequestMappingInfo other = (RequestMappingInfo) obj;\n\t\t\treturn (this.patterns.equals(other.patterns) && this.methods.equals(other.methods) &&\n\t\t\t\t\tthis.paramsCondition.equals(other.paramsCondition) &&\n\t\t\t\t\tthis.headersCondition.equals(other.headersCondition));\n\t\t}\n\t\treturn false;\n\t}","id":75090,"modified_method":"@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj) {\n\t\t\treturn true;\n\t\t}\n\t\tif (obj != null && obj instanceof RequestMappingInfo) {\n\t\t\tRequestMappingInfo other = (RequestMappingInfo) obj;\n\t\t\treturn (this.patterns.equals(other.patterns) && this.methods.equals(other.methods) &&\n\t\t\t\t\tthis.paramsCondition.equals(other.paramsCondition) &&\n\t\t\t\t\tthis.headersCondition.equals(other.headersCondition) &&\n\t\t\t\t\tthis.consumesCondition.equals(other.consumesCondition));\n\t\t}\n\t\treturn false;\n\t}","commit_id":"71aae405d57288e83086e36143df3eb9bd6dba39","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Returns the request headers of this request key.\n\t */\n\tpublic RequestCondition getHeaders() {\n\t\treturn headersCondition;\n\t}","id":75091,"modified_method":"/**\n\t * Returns the request headers conditions of this request key.\n\t */\n\tpublic HeadersRequestCondition getHeaders() {\n\t\treturn headersCondition;\n\t}","commit_id":"71aae405d57288e83086e36143df3eb9bd6dba39","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n     * Set the <tt>MediaDevice<\/tt> used for the audio.\n     *\n     * @param dev audio <tt>MediaDevice<\/tt>\n     */\n    public void setAudioDevice(MediaDevice dev)\n    {\n        if (audioDevice != dev)\n        {\n            MediaDevice oldAudioDevice = audioDevice;\n\n            audioDevice = dev;\n\n            if (conferenceAudioMixer instanceof MediaDeviceWrapper)\n            {\n                MediaDevice wrappedDevice\n                    = ((MediaDeviceWrapper) conferenceAudioMixer)\n                        .getWrappedDevice();\n\n                if (wrappedDevice != audioDevice)\n                {\n                    conferenceAudioMixer = null;\n\n                    /*\n                     * XXX While we know the old and the new master/wrapped\n                     * devices, we are not sure whether conferenceAudioMixer has\n                     * been used. Anyway, we have to report different values in\n                     * order to have PropertyChangeSupport really fire the\n                     * event.\n                     */\n                    propertyChangeSupport.firePropertyChange(\n                        DEFAULT_DEVICE,\n                        wrappedDevice, audioDevice);\n                }\n            }\n            else if (conferenceAudioMixer == null)\n            {\n                propertyChangeSupport.firePropertyChange(\n                    DEFAULT_DEVICE,\n                    oldAudioDevice, audioDevice);\n            }\n        }\n    }","id":75092,"modified_method":"/**\n     * Sets the <tt>MediaDevice<\/tt> to be used by this <tt>Call<\/tt> for the\n     * audio.\n     *\n     * @param dev the <tt>MediaDevice<\/tt> to be used by this <tt>Call<\/tt> for\n     * the audio\n     */\n    public void setAudioDevice(MediaDevice dev)\n    {\n        if (audioDevice != dev)\n        {\n            /*\n             * XXX While we know the old and the new master/wrapped devices, we\n             * are not sure whether conferenceAudioMixer has been used. Anyway,\n             * we have to report different values in order to have\n             * PropertyChangeSupport really fire the event.\n             */\n            MediaDevice oldValue\n                = (conferenceAudioMixer instanceof MediaDeviceWrapper)\n                    ? ((MediaDeviceWrapper) conferenceAudioMixer)\n                            .getWrappedDevice()\n                    : audioDevice;\n\n            audioDevice = dev;\n\n            MediaDevice newValue = audioDevice;\n\n            if (oldValue != newValue)\n            {\n                conferenceAudioMixer = null;\n                propertyChangeSupport.firePropertyChange(\n                        DEFAULT_DEVICE,\n                        oldValue, newValue);\n            }\n        }\n    }","commit_id":"81b590fac3ce98f8d10a1a755fd97d2f32f5d348","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Notifies this instance about a change of the value of a specific property\n     * from a specific old value to a specific new value. At the time of this\n     * writing, <tt>MediaAwareCall<\/tt> listeners to the property value changes\n     * of <tt>MediaService<\/tt> in order to track the changes of the default\n     * <tt>MediaDevice<\/tt>.\n     *\n     * @param event a <tt>PropertyChangeEvent<\/tt> which specifies the name of\n     * the property which has its value changed and the old and new values\n     */\n    public void propertyChange(PropertyChangeEvent event)\n    {\n        if (MediaService.DEFAULT_DEVICE.equals(event.getPropertyName()))\n        {\n            // if we change the device, do it only for the first member\n            if(getCallGroup() != null &&\n                this != getCallGroup().getCalls().get(0))\n            {\n                return;\n            }\n\n            /*\n             * XXX We only support changing the default audio device at the time\n             * of this writing.\n             */\n            MediaDevice oldValue = null;\n            MediaDevice newValue\n                = (audioDevice == null)\n                    ? ProtocolMediaActivator.getMediaService().getDefaultDevice(\n                            MediaType.AUDIO,\n                            mediaUseCase)\n                    : audioDevice;\n\n            if (conferenceAudioMixer instanceof MediaDeviceWrapper)\n            {\n                oldValue\n                    = ((MediaDeviceWrapper) conferenceAudioMixer)\n                        .getWrappedDevice();\n            }\n\n            /*\n             * XXX If MediaService#getDefaultDevice(MediaType, MediaUseCase)\n             * above returns null and its earlier return value was not null, we\n             * will not notify of an actual change in the value of the user's\n             * choice with respect to the default audio device.\n             */\n            if (oldValue != newValue)\n            {\n                conferenceAudioMixer = null;\n                propertyChangeSupport.firePropertyChange(\n                        DEFAULT_DEVICE,\n                        oldValue, newValue);\n            }\n\n            // now the first member of the group is configured so let's\n            // configure the others\n            if(getCallGroup() != null)\n            {\n                List<Call> calls = getCallGroup().getCalls();\n\n                for(Call c : calls)\n                {\n                    if(c == this)\n                        continue;\n\n                    MediaAwareCall<?,?,?> call = (MediaAwareCall<?,?,?>)c;\n\n                    call.conferenceAudioMixer = null;\n                    call.propertyChangeSupport.firePropertyChange(\n                        DEFAULT_DEVICE, oldValue, newValue);\n                }\n            }\n        }\n    }","id":75093,"modified_method":"/**\n     * Notifies this instance about a change of the value of a specific property\n     * from a specific old value to a specific new value. At the time of this\n     * writing, <tt>MediaAwareCall<\/tt> listens to the property value changes of\n     * <tt>MediaService<\/tt> in order to track the changes of the default\n     * <tt>MediaDevice<\/tt>.\n     *\n     * @param event a <tt>PropertyChangeEvent<\/tt> which specifies the name of\n     * the property which has its value changed and the old and new values\n     */\n    public void propertyChange(PropertyChangeEvent event)\n    {\n        if (MediaService.DEFAULT_DEVICE.equals(event.getPropertyName()))\n        {\n            /*\n             * The first Call in a CallGroup will process the property change\n             * for all Calls in the CallGroup (because they share one and the\n             * same device).\n             */\n            CallGroup callGroup = getCallGroup();\n\n            if ((callGroup != null) && (this != callGroup.getCalls().get(0)))\n                return;\n\n            /*\n             * XXX We only support changing the default audio device at the time\n             * of this writing.\n             */\n            MediaDevice oldValue\n                = (conferenceAudioMixer instanceof MediaDeviceWrapper)\n                    ? ((MediaDeviceWrapper) conferenceAudioMixer)\n                            .getWrappedDevice()\n                    : null;\n            MediaDevice newValue\n                = (audioDevice == null)\n                    ? ProtocolMediaActivator.getMediaService().getDefaultDevice(\n                            MediaType.AUDIO,\n                            mediaUseCase)\n                    : audioDevice;\n\n            /*\n             * XXX If MediaService#getDefaultDevice(MediaType, MediaUseCase)\n             * above returns null and its earlier return value was not null, we\n             * will not notify of an actual change in the value of the user's\n             * choice with respect to the default audio device.\n             */\n            if (oldValue != newValue)\n            {\n                conferenceAudioMixer = null;\n                propertyChangeSupport.firePropertyChange(\n                        DEFAULT_DEVICE,\n                        oldValue, newValue);\n\n                /*\n                 * As previously stated, the first Call in a CallGroup will\n                 * process the property change for all Calls in the CallGroup.\n                 * Now that the first Call has responded to the change in the\n                 * DEFAULT_DEVICE, the other Calls in the CallGroup can be\n                 * notified about the change as well and they can consult the\n                 * device configured by the first Call. \n                 */\n                callGroup = getCallGroup();\n                if (callGroup != null)\n                {\n                    List<Call> calls = callGroup.getCalls();\n\n                    for (Call c : calls)\n                    {\n                        if (c != this)\n                        {\n                            MediaAwareCall<?,?,?> call\n                                = (MediaAwareCall<?,?,?>) c;\n\n                            call.conferenceAudioMixer = null;\n                            call.propertyChangeSupport.firePropertyChange(\n                                    DEFAULT_DEVICE,\n                                    oldValue, newValue);\n                        }\n                    }\n                }\n            }\n        }\n    }","commit_id":"81b590fac3ce98f8d10a1a755fd97d2f32f5d348","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Gets a <tt>MediaDevice<\/tt> which is capable of capture and/or playback\n     * of media of the specified <tt>MediaType<\/tt>, is the default choice of\n     * the user for a <tt>MediaDevice<\/tt> with the specified <tt>MediaType<\/tt>\n     * and is appropriate for the current state of this <tt>Call<\/tt>.\n     * <p>\n     * For example, when the local peer represented by this <tt>Call<\/tt>\n     * instance is acting as a conference focus, the audio device must be a\n     * mixer.\n     * <\/p>\n     *\n     * @param mediaType the <tt>MediaType<\/tt> in which the retrieved\n     * <tt>MediaDevice<\/tt> is to capture and/or play back media\n     * @return a <tt>MediaDevice<\/tt> which is capable of capture and/or\n     * playback of media of the specified <tt>mediaType<\/tt>, is the default\n     * choice of the user for a <tt>MediaDevice<\/tt> with the specified\n     * <tt>mediaType<\/tt> and is appropriate for the current state of this\n     * <tt>Call<\/tt>\n     */\n    public MediaDevice getDefaultDevice(MediaType mediaType)\n    {\n        MediaDevice device;\n        List<Call> callGroupCalls;\n\n        if ((mediaType == MediaType.AUDIO)\n                && (conferenceAudioMixer == null)\n                && (callGroup != null)\n                && ((callGroupCalls = callGroup.getCalls()).size() > 0))\n        {\n            conferenceAudioMixer\n                = ((MediaAwareCall<?,?,?>) callGroupCalls.get(0))\n                    .conferenceAudioMixer;\n            device = conferenceAudioMixer;\n        }\n\n        switch (mediaType)\n        {\n        case AUDIO:\n            device = audioDevice;\n            break;\n        case VIDEO:\n            device = videoDevice;\n            break;\n        default:\n            /* no other type supported */\n            return null;\n        }\n\n        MediaService mediaService = ProtocolMediaActivator.getMediaService();\n\n        if (device == null)\n            device = mediaService.getDefaultDevice(mediaType, mediaUseCase);\n\n        /*\n         * Make sure that the audio device has an AudioMixer in order to support\n         * conferencing and call recording.\n         */\n        switch (mediaType)\n        {\n        case AUDIO:\n            if ((conferenceAudioMixer == null)\n                    && (device != null)\n                    /*\n                     * TODO AudioMixer leads to very poor audio quality on\n                     * Android so do not use it unless it is really really\n                     * necessary.\n                     */\n                    && (!OSUtils.IS_ANDROID || isConferenceFocus())\n                    /*\n                     * We can use the AudioMixer only if the device is able to\n                     * capture (because the AudioMixer will push when the\n                     * capture device pushes).\n                     */\n                    && device.getDirection().allowsSending())\n                conferenceAudioMixer = mediaService.createMixer(device);\n            if (conferenceAudioMixer != null)\n                device = conferenceAudioMixer;\n            break;\n\n        case VIDEO:\n            if (isConferenceFocus())\n            {\n                if ((conferenceVideoMixer == null) && (device != null))\n                    conferenceVideoMixer = mediaService.createMixer(device);\n                if (conferenceVideoMixer != null)\n                    device = conferenceVideoMixer;\n            }\n            break;\n        }\n\n        return device;\n    }","id":75094,"modified_method":"/**\n     * Gets a <tt>MediaDevice<\/tt> which is capable of capture and/or playback\n     * of media of the specified <tt>MediaType<\/tt>, is the default choice of\n     * the user for a <tt>MediaDevice<\/tt> with the specified <tt>MediaType<\/tt>\n     * and is appropriate for the current state of this <tt>Call<\/tt>.\n     * <p>\n     * For example, when the local peer represented by this <tt>Call<\/tt>\n     * instance is acting as a conference focus, the audio device must be a\n     * mixer.\n     * <\/p>\n     *\n     * @param mediaType the <tt>MediaType<\/tt> in which the retrieved\n     * <tt>MediaDevice<\/tt> is to capture and/or play back media\n     * @return a <tt>MediaDevice<\/tt> which is capable of capture and/or\n     * playback of media of the specified <tt>mediaType<\/tt>, is the default\n     * choice of the user for a <tt>MediaDevice<\/tt> with the specified\n     * <tt>mediaType<\/tt> and is appropriate for the current state of this\n     * <tt>Call<\/tt>\n     */\n    public MediaDevice getDefaultDevice(MediaType mediaType)\n    {\n        MediaDevice device;\n\n        switch (mediaType)\n        {\n        case AUDIO:\n            {\n                /*\n                 * TODO There must be something wrong related to the CallGroup\n                 * functionality because the end product is that the local\n                 * variable device gets assigned a CallGroup-dependent value and\n                 * then it gets overwritten.\n                 */\n                List<Call> callGroupCalls;\n\n                if ((conferenceAudioMixer == null)\n                        && (callGroup != null)\n                        && ((callGroupCalls = callGroup.getCalls()).size() > 0))\n                {\n                    conferenceAudioMixer\n                        = ((MediaAwareCall<?,?,?>) callGroupCalls.get(0))\n                            .conferenceAudioMixer;\n                    device = conferenceAudioMixer;\n                }\n\n                device = audioDevice;\n            }\n            break;\n        case VIDEO:\n            device = videoDevice;\n            break;\n        default:\n            /*\n             * There is no other MediaType value (at the time of this writing).\n             */\n            return null;\n        }\n\n        MediaService mediaService = ProtocolMediaActivator.getMediaService();\n\n        if (device == null)\n            device = mediaService.getDefaultDevice(mediaType, mediaUseCase);\n\n        /*\n         * Make sure that the audio device has an AudioMixer in order to support\n         * conferencing and call recording.\n         */\n        switch (mediaType)\n        {\n        case AUDIO:\n            if ((conferenceAudioMixer == null)\n                    && (device != null)\n                    /*\n                     * TODO AudioMixer leads to very poor audio quality on\n                     * Android so do not use it unless it is really really\n                     * necessary.\n                     */\n                    && (!OSUtils.IS_ANDROID || isConferenceFocus())\n                    /*\n                     * We can use the AudioMixer only if the device is able to\n                     * capture (because the AudioMixer will push when the\n                     * capture device pushes).\n                     */\n                    && device.getDirection().allowsSending())\n                conferenceAudioMixer = mediaService.createMixer(device);\n            if (conferenceAudioMixer != null)\n                device = conferenceAudioMixer;\n            break;\n\n        case VIDEO:\n            if (isConferenceFocus())\n            {\n                if ((conferenceVideoMixer == null) && (device != null))\n                    conferenceVideoMixer = mediaService.createMixer(device);\n                if (conferenceVideoMixer != null)\n                    device = conferenceVideoMixer;\n            }\n            break;\n        }\n\n        return device;\n    }","commit_id":"81b590fac3ce98f8d10a1a755fd97d2f32f5d348","url":"https://github.com/jitsi/jitsi"},{"original_method":"public ObservableMap() {\r\n        this( new HashMap(), null );\r\n    }","id":75095,"modified_method":"public ObservableMap() {\r\n        this(new LinkedHashMap(), null);\r\n    }","commit_id":"acc97950a3038d608048f21fb36b59f9e1a28e03","url":"https://github.com/apache/groovy"},{"original_method":"public void putAll( Map map ) {\r\n        if( map != null ){\r\n            for( Iterator entries = map.entrySet()\r\n                    .iterator(); entries.hasNext(); ){\r\n                Map.Entry entry = (Map.Entry) entries.next();\r\n                String key = String.valueOf( entry.getKey() );\r\n                Object value = entry.getValue();\r\n\r\n                // copy the code from put() that would make this one a little\r\n                // bit faster\r\n                Object oldValue = null;\r\n                if( test != null ){\r\n                    Object result = null;\r\n                    if( test.getMaximumNumberOfParameters() == 2 ){\r\n                        result = test.call( new Object[] { key, value } );\r\n                    }else{\r\n                        result = test.call( value );\r\n                    }\r\n                    if( result != null && result instanceof Boolean\r\n                            && ((Boolean) result).booleanValue() ){\r\n                        oldValue = delegate.put( key, value );\r\n                        pcs.firePropertyChange( String.valueOf( key ), oldValue, value );\r\n                    }\r\n                }else{\r\n                    oldValue = delegate.put( key, value );\r\n                    pcs.firePropertyChange( String.valueOf( key ), oldValue, value );\r\n                }\r\n            }\r\n        }\r\n    }","id":75096,"modified_method":"public void putAll(Map map) {\r\n        if (map != null) {\r\n            for (Iterator entries = map.entrySet()\r\n                    .iterator(); entries.hasNext();) {\r\n                Map.Entry entry = (Map.Entry) entries.next();\r\n\r\n                put(entry.getKey(), entry.getValue());\r\n            }\r\n        }\r\n    }","commit_id":"acc97950a3038d608048f21fb36b59f9e1a28e03","url":"https://github.com/apache/groovy"},{"original_method":"public Object put( Object key, Object value ) {\r\n        Object oldValue = null;\r\n        if( test != null ){\r\n            Object result = null;\r\n            if( test.getMaximumNumberOfParameters() == 2 ){\r\n                result = test.call( new Object[] { key, value } );\r\n            }else{\r\n                result = test.call( value );\r\n            }\r\n            if( result != null && result instanceof Boolean && ((Boolean) result).booleanValue() ){\r\n                oldValue = delegate.put( key, value );\r\n                pcs.firePropertyChange( String.valueOf( key ), oldValue, value );\r\n            }\r\n        }else{\r\n            oldValue = delegate.put( key, value );\r\n            pcs.firePropertyChange( String.valueOf( key ), oldValue, value );\r\n        }\r\n        return oldValue;\r\n    }","id":75097,"modified_method":"public Object put(Object key, Object value) {\r\n        Object oldValue = null;\r\n        if (test != null) {\r\n            Object result = null;\r\n            if (test.getMaximumNumberOfParameters() == 2) {\r\n                result = test.call(new Object[] {key, value});\r\n            } else {\r\n                result = test.call(value);\r\n            }\r\n            if (result != null && result instanceof Boolean && ((Boolean) result).booleanValue()) {\r\n                oldValue = delegate.put(key, value);\r\n                if (oldValue != value) {\r\n                    pcs.firePropertyChange(String.valueOf(key), oldValue, value);\r\n                }\r\n            }\r\n        } else {\r\n            oldValue = delegate.put(key, value);\r\n            if (oldValue != value) {\r\n                pcs.firePropertyChange(String.valueOf(key), oldValue, value);\r\n            }\r\n        }\r\n        return oldValue;\r\n    }","commit_id":"acc97950a3038d608048f21fb36b59f9e1a28e03","url":"https://github.com/apache/groovy"},{"original_method":"public ObservableMap( Closure test ) {\r\n        this( new HashMap(), test );\r\n    }","id":75098,"modified_method":"public ObservableMap(Closure test) {\r\n        this(new LinkedHashMap(), test);\r\n    }","commit_id":"acc97950a3038d608048f21fb36b59f9e1a28e03","url":"https://github.com/apache/groovy"},{"original_method":"protected List<ObjectValuePair<String, Long>> restoreRename(\n\t\t\tActionRequest actionRequest)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong trashEntryId = ParamUtil.getLong(actionRequest, \"trashEntryId\");\n\n\t\tTrashEntry entry = TrashEntryLocalServiceUtil.getTrashEntry(\n\t\t\ttrashEntryId);\n\n\t\tTrashHandler trashHandler = TrashHandlerRegistryUtil.getTrashHandler(\n\t\t\tentry.getClassName());\n\n\t\tString newName = ParamUtil.getString(actionRequest, \"newName\");\n\n\t\tif (Validator.isNull(newName)) {\n\t\t\tString oldName = ParamUtil.getString(actionRequest, \"oldName\");\n\n\t\t\tnewName = TrashUtil.getNewName(themeDisplay, oldName);\n\t\t}\n\n\t\ttrashHandler.updateTitle(entry.getClassPK(), newName);\n\n\t\ttrashHandler.restoreTrashEntry(entry.getClassPK());\n\n\t\treturn getEntryOVPs(entry);\n\t}","id":75099,"modified_method":"protected List<ObjectValuePair<String, Long>> restoreRename(\n\t\t\tActionRequest actionRequest)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong trashEntryId = ParamUtil.getLong(actionRequest, \"trashEntryId\");\n\n\t\tTrashEntry entry = TrashEntryLocalServiceUtil.getTrashEntry(\n\t\t\ttrashEntryId);\n\n\t\tTrashHandler trashHandler = TrashHandlerRegistryUtil.getTrashHandler(\n\t\t\tentry.getClassName());\n\n\t\tString newName = ParamUtil.getString(actionRequest, \"newName\");\n\n\t\tif (Validator.isNull(newName)) {\n\t\t\tString oldName = ParamUtil.getString(actionRequest, \"oldName\");\n\n\t\t\tnewName = TrashUtil.getNewName(themeDisplay, oldName);\n\t\t}\n\n\t\ttrashHandler.updateTitle(entry.getClassPK(), newName);\n\n\t\ttrashHandler.restoreTrashEntry(entry.getClassPK());\n\n\t\treturn getEntryOVPs(entry.getClassName(), entry.getClassPK());\n\t}","commit_id":"2e4c6f5c42970342dab22ed3f8e7f9ece6873333","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected List<ObjectValuePair<String, Long>> restoreOverride(\n\t\t\tActionRequest actionRequest)\n\t\tthrows Exception {\n\n\t\tlong trashEntryId = ParamUtil.getLong(actionRequest, \"trashEntryId\");\n\n\t\tTrashEntry entry = TrashEntryLocalServiceUtil.getTrashEntry(\n\t\t\ttrashEntryId);\n\n\t\tTrashHandler trashHandler = TrashHandlerRegistryUtil.getTrashHandler(\n\t\t\tentry.getClassName());\n\n\t\tlong duplicateEntryId = ParamUtil.getLong(\n\t\t\tactionRequest, \"duplicateEntryId\");\n\n\t\ttrashHandler.deleteTrashEntries(new long[] {duplicateEntryId});\n\n\t\ttrashHandler.restoreTrashEntry(entry.getClassPK());\n\n\t\treturn getEntryOVPs(entry);\n\t}","id":75100,"modified_method":"protected List<ObjectValuePair<String, Long>> restoreOverride(\n\t\t\tActionRequest actionRequest)\n\t\tthrows Exception {\n\n\t\tlong trashEntryId = ParamUtil.getLong(actionRequest, \"trashEntryId\");\n\n\t\tTrashEntry entry = TrashEntryLocalServiceUtil.getTrashEntry(\n\t\t\ttrashEntryId);\n\n\t\tTrashHandler trashHandler = TrashHandlerRegistryUtil.getTrashHandler(\n\t\t\tentry.getClassName());\n\n\t\tlong duplicateEntryId = ParamUtil.getLong(\n\t\t\tactionRequest, \"duplicateEntryId\");\n\n\t\ttrashHandler.deleteTrashEntries(new long[] {duplicateEntryId});\n\n\t\ttrashHandler.restoreTrashEntry(entry.getClassPK());\n\n\t\treturn getEntryOVPs(entry.getClassName(), entry.getClassPK());\n\t}","commit_id":"2e4c6f5c42970342dab22ed3f8e7f9ece6873333","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected List<ObjectValuePair<String, Long>> restoreEntry(\n\t\t\tlong trashEntryId)\n\t\tthrows Exception {\n\n\t\tTrashEntry entry = TrashEntryLocalServiceUtil.getTrashEntry(\n\t\t\ttrashEntryId);\n\n\t\tTrashHandler trashHandler = TrashHandlerRegistryUtil.getTrashHandler(\n\t\t\tentry.getClassName());\n\n\t\ttrashHandler.checkDuplicateTrashEntry(\n\t\t\tentry, TrashEntryConstants.DEFAULT_CONTAINER_ID, StringPool.BLANK);\n\n\t\ttrashHandler.restoreTrashEntry(entry.getClassPK());\n\n\t\treturn getEntryOVPs(entry);\n\t}","id":75101,"modified_method":"protected List<ObjectValuePair<String, Long>> restoreEntry(\n\t\t\tlong trashEntryId)\n\t\tthrows Exception {\n\n\t\tTrashEntry entry = TrashEntryLocalServiceUtil.getTrashEntry(\n\t\t\ttrashEntryId);\n\n\t\tTrashHandler trashHandler = TrashHandlerRegistryUtil.getTrashHandler(\n\t\t\tentry.getClassName());\n\n\t\ttrashHandler.checkDuplicateTrashEntry(\n\t\t\tentry, TrashEntryConstants.DEFAULT_CONTAINER_ID, StringPool.BLANK);\n\n\t\ttrashHandler.restoreTrashEntry(entry.getClassPK());\n\n\t\treturn getEntryOVPs(entry.getClassName(), entry.getClassPK());\n\t}","commit_id":"2e4c6f5c42970342dab22ed3f8e7f9ece6873333","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void deleteEntries(ActionRequest actionRequest) throws Exception {\n\t\tlong trashEntryId = ParamUtil.getLong(actionRequest, \"trashEntryId\");\n\n\t\tlong[] deleteEntryIds = StringUtil.split(\n\t\t\tParamUtil.getString(actionRequest, \"deleteThrashEntryIds\"), 0L);\n\n\t\tif (trashEntryId > 0) {\n\t\t\tTrashEntry entry = TrashEntryLocalServiceUtil.getTrashEntry(\n\t\t\t\ttrashEntryId);\n\n\t\t\tdeleteEntry(entry.getClassName(), entry.getClassPK());\n\t\t}\n\t\telse if (deleteEntryIds.length > 0) {\n\t\t\tfor (int i = 0; i < deleteEntryIds.length; i++) {\n\t\t\t\tTrashEntry entry = TrashEntryLocalServiceUtil.getTrashEntry(\n\t\t\t\t\tdeleteEntryIds[i]);\n\n\t\t\t\tdeleteEntry(entry.getClassName(), entry.getClassPK());\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tString className = ParamUtil.getString(actionRequest, \"className\");\n\t\t\tlong classPK = ParamUtil.getLong(actionRequest, \"classPK\");\n\n\t\t\tdeleteEntry(className, classPK);\n\t\t}\n\t}","id":75102,"modified_method":"protected void deleteEntries(ActionRequest actionRequest) throws Exception {\n\t\tlong trashEntryId = ParamUtil.getLong(actionRequest, \"trashEntryId\");\n\n\t\tif (trashEntryId > 0) {\n\t\t\tTrashEntry entry = TrashEntryLocalServiceUtil.getTrashEntry(\n\t\t\t\ttrashEntryId);\n\n\t\t\tdeleteEntry(entry.getClassName(), entry.getClassPK());\n\n\t\t\treturn;\n\t\t}\n\n\t\tlong[] deleteEntryIds = StringUtil.split(\n\t\t\tParamUtil.getString(actionRequest, \"deleteThrashEntryIds\"), 0L);\n\n\t\tif (deleteEntryIds.length > 0) {\n\t\t\tfor (int i = 0; i < deleteEntryIds.length; i++) {\n\t\t\t\tTrashEntry entry = TrashEntryLocalServiceUtil.getTrashEntry(\n\t\t\t\t\tdeleteEntryIds[i]);\n\n\t\t\t\tdeleteEntry(entry.getClassName(), entry.getClassPK());\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tString className = ParamUtil.getString(actionRequest, \"className\");\n\t\tlong classPK = ParamUtil.getLong(actionRequest, \"classPK\");\n\n\t\tif (Validator.isNotNull(className) && (classPK > 0)) {\n\t\t\tdeleteEntry(className, classPK);\n\t\t}\n\t}","commit_id":"2e4c6f5c42970342dab22ed3f8e7f9ece6873333","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n  protected Entry<EditorCell> createEntry(@NotNull EditorCell item) {\n    if (item instanceof Entry) {\n      //noinspection unchecked\n      Entry<EditorCell> entry = (Entry<EditorCell>) item;\n      attachParent(item);\n      return entry;\n// TODO: switch on\n//      if (item.getParent() == null) {\n//        attachParent(item);\n//        return entry;\n//      } else if (item.getParent() == myCell) {\n//        return null;\n//      } else {\n//  setting parent for this cell will detach it from current parent /  what should we do here?\n//  two options:\n//  1) attach new parent silently\n//  2) throw exception / assert\n//\n//  we cannot continue with the default logic here because if we create user object (EntryImpl) for this cell,\n//  set new parent for this cell & return created Entry instance, then subsequent getEntry() call will not\n//  work consistently.\n//      }\n    }\n\n    Entry<EditorCell> entry = super.createEntry(item);\n    attachParent(item);\n    return entry;\n  }","id":75103,"modified_method":"@Override\n  protected Entry<EditorCell> createEntry(@NotNull EditorCell item) {\n    Entry<EditorCell> entry;\n    if (item instanceof Entry) {\n      if (item.getParent() == null) {\n        //noinspection unchecked\n        entry = (Entry<EditorCell>) item;\n      } else {\n        // Two cases are mixed here: item.getParent() == myCell & item.getParent() == anotherCell.\n        // We did that intentionally because it's hard to implement contract otherwise.\n        //\n        // super.createEntry(item) cannot be used for instances of Entry interface - subsequent\n        // attachParent() method call will change parent of this cell used in the condition above\n        // and inside getEntry() method implementation\n        return null;\n      }\n    } else {\n      entry = super.createEntry(item);\n    }\n    attachParent(item);\n    return entry;\n  }","commit_id":"c375154c8255f769aa880055c08d8fd10a4119f4","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  protected Entry<EditorCell> deleteEntry(@NotNull Entry<EditorCell> entry) {\n    if (entry.getItem() == entry) {\n      detachParent(entry.getItem());\n      return entry;\n// TODO: switch on\n//      if (entry.getItem().getParent() == myCell) {\n//        detachParent(entry.getItem());\n//        return entry;\n//      } else if (entry.getItem().getParent() == null) {\n//        return null;\n//      } else {\n//  setting parent to null for this cell later will potentially break an association of this cell in another container /  what should we do here?\n//  two options:\n//  1) detach new parent silently\n//  2) throw exception / assert\n//\n//  we probably shoudl not continue with the default logic here...\n//      }\n    }\n\n    detachParent(entry.getItem());\n    return super.deleteEntry(entry);\n  }","id":75104,"modified_method":"@Override\n  protected Entry<EditorCell> deleteEntry(@NotNull Entry<EditorCell> entry) {\n    if (entry.getItem() == entry && entry.getItem().getParent() != myCell) {\n      // Two cases are mixed here: item.getParent() == null & item.getParent() == anotherCell.\n      // We did that intentionally because it's hard to implement contract otherwise.\n      //\n      // super.deleteEntry(item) cannot be used for instances of Entry interface - subsequent\n      // detachParent() method remove this call from the parent cell used in the condition above\n      // and inside getEntry() method implementation\n      return null;\n    }\n\n    detachParent(entry.getItem());\n    return entry.getItem() == entry ? entry : super.deleteEntry(entry);\n  }","commit_id":"c375154c8255f769aa880055c08d8fd10a4119f4","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void doPut(K key, V value) throws IOException {\n    final long hashCode = keyHashFunction.hashCode(key);\n\n    final BucketPath bucketPath = getBucket(hashCode);\n    long[] node = hashTree[bucketPath.nodeIndex];\n\n    final long bucketPointer = node[bucketPath.itemIndex + bucketPath.hashMapOffset];\n    if (bucketPointer == 0)\n      throw new IllegalStateException(\"In this version of hash table buckets are added through split only.\");\n\n    final long pageIndex = getPageIndex(bucketPointer);\n    final int fileLevel = getFileLevel(bucketPointer);\n\n    final OCacheEntry cacheEntry = loadPageEntry(pageIndex, fileLevel);\n    final OCachePointer pagePointer = cacheEntry.getCachePointer();\n\n    pagePointer.acquireExclusiveLock();\n    try {\n      final OHashIndexBucket<K, V> bucket = new OHashIndexBucket<K, V>(pagePointer.getDataPointer(), keySerializer,\n          valueSerializer, keyTypes);\n      final int index = bucket.getIndex(hashCode, key);\n\n      if (index > -1) {\n        bucket.deleteEntry(index);\n        size--;\n        cacheEntry.markDirty();\n      }\n\n      if (bucket.addEntry(hashCode, key, value)) {\n        cacheEntry.markDirty();\n\n        size++;\n        return;\n      }\n\n      final BucketSplitResult splitResult = splitBucket(bucket, fileLevel, pageIndex);\n\n      final long updatedBucketPointer = splitResult.updatedBucketPointer;\n      final long newBucketPointer = splitResult.newBucketPointer;\n      final int bucketDepth = splitResult.newDepth;\n\n      if (bucketDepth <= bucketPath.nodeGlobalDepth) {\n        updateNodeAfterBucketSplit(bucketPath, bucketDepth, newBucketPointer, updatedBucketPointer);\n      } else {\n        if (bucketPath.nodeLocalDepth < MAX_LEVEL_DEPTH) {\n          final NodeSplitResult nodeSplitResult = splitNode(bucketPath, node);\n\n          assert !(nodeSplitResult.allLeftHashMapsEqual && nodeSplitResult.allRightHashMapsEqual);\n\n          final long[] newNode = nodeSplitResult.newNode;\n\n          final int nodeLocalDepth = bucketPath.nodeLocalDepth + 1;\n          final int hashMapSize = 1 << nodeLocalDepth;\n\n          assert nodeSplitResult.allRightHashMapsEqual == checkAllMapsContainSameBucket(newNode, hashMapSize);\n\n          int newNodeIndex = -1;\n          if (!nodeSplitResult.allRightHashMapsEqual || bucketPath.itemIndex >= MAX_LEVEL_SIZE / 2)\n            newNodeIndex = addNewNode(newNode, nodeLocalDepth);\n\n          final int updatedItemIndex = bucketPath.itemIndex << 1;\n          final int updatedOffset = bucketPath.hashMapOffset << 1;\n          final int updatedGlobalDepth = bucketPath.nodeGlobalDepth + 1;\n\n          boolean allLeftHashMapsEqual = nodeSplitResult.allLeftHashMapsEqual;\n          boolean allRightHashMapsEqual = nodeSplitResult.allRightHashMapsEqual;\n\n          if (updatedOffset < MAX_LEVEL_SIZE) {\n            allLeftHashMapsEqual = false;\n            final BucketPath updatedBucketPath = new BucketPath(bucketPath.parent, updatedOffset, updatedItemIndex,\n                bucketPath.nodeIndex, nodeLocalDepth, updatedGlobalDepth);\n            updateNodeAfterBucketSplit(updatedBucketPath, bucketDepth, newBucketPointer, updatedBucketPointer);\n          } else {\n            allRightHashMapsEqual = false;\n            final BucketPath newBucketPath = new BucketPath(bucketPath.parent, updatedOffset - MAX_LEVEL_SIZE, updatedItemIndex,\n                newNodeIndex, nodeLocalDepth, updatedGlobalDepth);\n            updateNodeAfterBucketSplit(newBucketPath, bucketDepth, newBucketPointer, updatedBucketPointer);\n          }\n\n          final long[] updatedNode = hashTree[bucketPath.nodeIndex];\n          updateNodesAfterSplit(bucketPath, updatedNode, newNode, nodeLocalDepth, hashMapSize, allLeftHashMapsEqual,\n              allRightHashMapsEqual, newNodeIndex);\n\n          if (allLeftHashMapsEqual)\n            deleteNode(bucketPath.nodeIndex);\n\n        } else {\n          addNewLevelNode(bucketPath, node, newBucketPointer, updatedBucketPointer);\n        }\n      }\n    } finally {\n      pagePointer.releaseExclusiveLock();\n      diskCache.release(cacheEntry);\n    }\n\n    doPut(key, value);\n  }","id":75105,"modified_method":"private void doPut(K key, V value) throws IOException {\n    final long hashCode = keyHashFunction.hashCode(key);\n\n    final BucketPath bucketPath = getBucket(hashCode);\n    long[] node = hashTree[bucketPath.nodeIndex];\n\n    final long bucketPointer = node[bucketPath.itemIndex + bucketPath.hashMapOffset];\n    if (bucketPointer == 0)\n      throw new IllegalStateException(\"In this version of hash table buckets are added through split only.\");\n\n    final long pageIndex = getPageIndex(bucketPointer);\n    final int fileLevel = getFileLevel(bucketPointer);\n\n    final OCacheEntry cacheEntry = loadPageEntry(pageIndex, fileLevel);\n    final OCachePointer pagePointer = cacheEntry.getCachePointer();\n\n    pagePointer.acquireExclusiveLock();\n    try {\n      final OHashIndexBucket<K, V> bucket = new OHashIndexBucket<K, V>(pagePointer.getDataPointer(), keySerializer,\n          valueSerializer, keyTypes);\n      final int index = bucket.getIndex(hashCode, key);\n\n      if (index > -1) {\n        final int updateResult = bucket.updateEntry(index, value);\n        if (updateResult == 0)\n          return;\n\n        if (updateResult == 1) {\n          cacheEntry.markDirty();\n          return;\n        }\n\n        assert updateResult == -1;\n\n        bucket.deleteEntry(index);\n        size--;\n      }\n\n      if (bucket.addEntry(hashCode, key, value)) {\n        cacheEntry.markDirty();\n\n        size++;\n        return;\n      }\n\n      final BucketSplitResult splitResult = splitBucket(bucket, fileLevel, pageIndex);\n\n      final long updatedBucketPointer = splitResult.updatedBucketPointer;\n      final long newBucketPointer = splitResult.newBucketPointer;\n      final int bucketDepth = splitResult.newDepth;\n\n      if (bucketDepth <= bucketPath.nodeGlobalDepth) {\n        updateNodeAfterBucketSplit(bucketPath, bucketDepth, newBucketPointer, updatedBucketPointer);\n      } else {\n        if (bucketPath.nodeLocalDepth < MAX_LEVEL_DEPTH) {\n          final NodeSplitResult nodeSplitResult = splitNode(bucketPath, node);\n\n          assert !(nodeSplitResult.allLeftHashMapsEqual && nodeSplitResult.allRightHashMapsEqual);\n\n          final long[] newNode = nodeSplitResult.newNode;\n\n          final int nodeLocalDepth = bucketPath.nodeLocalDepth + 1;\n          final int hashMapSize = 1 << nodeLocalDepth;\n\n          assert nodeSplitResult.allRightHashMapsEqual == checkAllMapsContainSameBucket(newNode, hashMapSize);\n\n          int newNodeIndex = -1;\n          if (!nodeSplitResult.allRightHashMapsEqual || bucketPath.itemIndex >= MAX_LEVEL_SIZE / 2)\n            newNodeIndex = addNewNode(newNode, nodeLocalDepth);\n\n          final int updatedItemIndex = bucketPath.itemIndex << 1;\n          final int updatedOffset = bucketPath.hashMapOffset << 1;\n          final int updatedGlobalDepth = bucketPath.nodeGlobalDepth + 1;\n\n          boolean allLeftHashMapsEqual = nodeSplitResult.allLeftHashMapsEqual;\n          boolean allRightHashMapsEqual = nodeSplitResult.allRightHashMapsEqual;\n\n          if (updatedOffset < MAX_LEVEL_SIZE) {\n            allLeftHashMapsEqual = false;\n            final BucketPath updatedBucketPath = new BucketPath(bucketPath.parent, updatedOffset, updatedItemIndex,\n                bucketPath.nodeIndex, nodeLocalDepth, updatedGlobalDepth);\n            updateNodeAfterBucketSplit(updatedBucketPath, bucketDepth, newBucketPointer, updatedBucketPointer);\n          } else {\n            allRightHashMapsEqual = false;\n            final BucketPath newBucketPath = new BucketPath(bucketPath.parent, updatedOffset - MAX_LEVEL_SIZE, updatedItemIndex,\n                newNodeIndex, nodeLocalDepth, updatedGlobalDepth);\n            updateNodeAfterBucketSplit(newBucketPath, bucketDepth, newBucketPointer, updatedBucketPointer);\n          }\n\n          final long[] updatedNode = hashTree[bucketPath.nodeIndex];\n          updateNodesAfterSplit(bucketPath, updatedNode, newNode, nodeLocalDepth, hashMapSize, allLeftHashMapsEqual,\n              allRightHashMapsEqual, newNodeIndex);\n\n          if (allLeftHashMapsEqual)\n            deleteNode(bucketPath.nodeIndex);\n\n        } else {\n          addNewLevelNode(bucketPath, node, newBucketPointer, updatedBucketPointer);\n        }\n      }\n    } finally {\n      pagePointer.releaseExclusiveLock();\n      diskCache.release(cacheEntry);\n    }\n\n    doPut(key, value);\n  }","commit_id":"f7033072d1be5819e69b19c7af754d46a977fe86","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n\t * Convert the given number into an instance of the given target class.\n\t * @param number the number to convert\n\t * @param targetClass the target class to convert to\n\t * @return the converted number\n\t * @throws IllegalArgumentException if the target class is not supported\n\t * (i.e. not a standard Number subclass as included in the JDK)\n\t * @see java.lang.Byte\n\t * @see java.lang.Short\n\t * @see java.lang.Integer\n\t * @see java.lang.Long\n\t * @see java.math.BigInteger\n\t * @see java.lang.Float\n\t * @see java.lang.Double\n\t * @see java.math.BigDecimal\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <T extends Number> T convertNumberToTargetClass(Number number, Class<T> targetClass)\n\t\t\tthrows IllegalArgumentException {\n\n\t\tAssert.notNull(number, \"Number must not be null\");\n\t\tAssert.notNull(targetClass, \"Target class must not be null\");\n\n\t\tif (targetClass.isInstance(number)) {\n\t\t\treturn (T) number;\n\t\t}\n\t\telse if (Byte.class == targetClass) {\n\t\t\tlong value = number.longValue();\n\t\t\tif (value < Byte.MIN_VALUE || value > Byte.MAX_VALUE) {\n\t\t\t\traiseOverflowException(number, targetClass);\n\t\t\t}\n\t\t\treturn (T) new Byte(number.byteValue());\n\t\t}\n\t\telse if (Short.class == targetClass) {\n\t\t\tlong value = number.longValue();\n\t\t\tif (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {\n\t\t\t\traiseOverflowException(number, targetClass);\n\t\t\t}\n\t\t\treturn (T) new Short(number.shortValue());\n\t\t}\n\t\telse if (Integer.class == targetClass) {\n\t\t\tlong value = number.longValue();\n\t\t\tif (value < Integer.MIN_VALUE || value > Integer.MAX_VALUE) {\n\t\t\t\traiseOverflowException(number, targetClass);\n\t\t\t}\n\t\t\treturn (T) new Integer(number.intValue());\n\t\t}\n\t\telse if (Long.class == targetClass) {\n\t\t\tBigInteger bigInt = null;\n\t\t\tif (number instanceof BigInteger) {\n\t\t\t\tbigInt = (BigInteger) number;\n\t\t\t}\n\t\t\telse if (number instanceof BigDecimal) {\n\t\t\t\tbigInt = ((BigDecimal) number).toBigInteger();\n\t\t\t}\n\t\t\t// Effectively analogous to JDK 8's BigInteger.longValueExact()\n\t\t\tif (bigInt != null && (bigInt.compareTo(LONG_MIN) < 0 || bigInt.compareTo(LONG_MAX) > 0)) {\n\t\t\t\traiseOverflowException(number, targetClass);\n\t\t\t}\n\t\t\treturn (T) new Long(number.longValue());\n\t\t}\n\t\telse if (BigInteger.class == targetClass) {\n\t\t\tif (number instanceof BigDecimal) {\n\t\t\t\t// do not lose precision - use BigDecimal's own conversion\n\t\t\t\treturn (T) ((BigDecimal) number).toBigInteger();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// original value is not a Big* number - use standard long conversion\n\t\t\t\treturn (T) BigInteger.valueOf(number.longValue());\n\t\t\t}\n\t\t}\n\t\telse if (Float.class == targetClass) {\n\t\t\treturn (T) new Float(number.floatValue());\n\t\t}\n\t\telse if (Double.class == targetClass) {\n\t\t\treturn (T) new Double(number.doubleValue());\n\t\t}\n\t\telse if (BigDecimal.class == targetClass) {\n\t\t\t// always use BigDecimal(String) here to avoid unpredictability of BigDecimal(double)\n\t\t\t// (see BigDecimal javadoc for details)\n\t\t\treturn (T) new BigDecimal(number.toString());\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Could not convert number [\" + number + \"] of type [\" +\n\t\t\t\t\tnumber.getClass().getName() + \"] to unsupported target class [\" + targetClass.getName() + \"]\");\n\t\t}\n\t}","id":75106,"modified_method":"/**\n\t * Convert the given number into an instance of the given target class.\n\t * @param number the number to convert\n\t * @param targetClass the target class to convert to\n\t * @return the converted number\n\t * @throws IllegalArgumentException if the target class is not supported\n\t * (i.e. not a standard Number subclass as included in the JDK)\n\t * @see java.lang.Byte\n\t * @see java.lang.Short\n\t * @see java.lang.Integer\n\t * @see java.lang.Long\n\t * @see java.math.BigInteger\n\t * @see java.lang.Float\n\t * @see java.lang.Double\n\t * @see java.math.BigDecimal\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <T extends Number> T convertNumberToTargetClass(Number number, Class<T> targetClass)\n\t\t\tthrows IllegalArgumentException {\n\n\t\tAssert.notNull(number, \"Number must not be null\");\n\t\tAssert.notNull(targetClass, \"Target class must not be null\");\n\n\t\tif (targetClass.isInstance(number)) {\n\t\t\treturn (T) number;\n\t\t}\n\t\telse if (Byte.class == targetClass) {\n\t\t\tlong value = number.longValue();\n\t\t\tif (value < Byte.MIN_VALUE || value > Byte.MAX_VALUE) {\n\t\t\t\traiseOverflowException(number, targetClass);\n\t\t\t}\n\t\t\treturn (T) Byte.valueOf(number.byteValue());\n\t\t}\n\t\telse if (Short.class == targetClass) {\n\t\t\tlong value = number.longValue();\n\t\t\tif (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {\n\t\t\t\traiseOverflowException(number, targetClass);\n\t\t\t}\n\t\t\treturn (T) Short.valueOf(number.shortValue());\n\t\t}\n\t\telse if (Integer.class == targetClass) {\n\t\t\tlong value = number.longValue();\n\t\t\tif (value < Integer.MIN_VALUE || value > Integer.MAX_VALUE) {\n\t\t\t\traiseOverflowException(number, targetClass);\n\t\t\t}\n\t\t\treturn (T) Integer.valueOf(number.intValue());\n\t\t}\n\t\telse if (Long.class == targetClass) {\n\t\t\tBigInteger bigInt = null;\n\t\t\tif (number instanceof BigInteger) {\n\t\t\t\tbigInt = (BigInteger) number;\n\t\t\t}\n\t\t\telse if (number instanceof BigDecimal) {\n\t\t\t\tbigInt = ((BigDecimal) number).toBigInteger();\n\t\t\t}\n\t\t\t// Effectively analogous to JDK 8's BigInteger.longValueExact()\n\t\t\tif (bigInt != null && (bigInt.compareTo(LONG_MIN) < 0 || bigInt.compareTo(LONG_MAX) > 0)) {\n\t\t\t\traiseOverflowException(number, targetClass);\n\t\t\t}\n\t\t\treturn (T) Long.valueOf(number.longValue());\n\t\t}\n\t\telse if (BigInteger.class == targetClass) {\n\t\t\tif (number instanceof BigDecimal) {\n\t\t\t\t// do not lose precision - use BigDecimal's own conversion\n\t\t\t\treturn (T) ((BigDecimal) number).toBigInteger();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// original value is not a Big* number - use standard long conversion\n\t\t\t\treturn (T) BigInteger.valueOf(number.longValue());\n\t\t\t}\n\t\t}\n\t\telse if (Float.class == targetClass) {\n\t\t\treturn (T) Float.valueOf(number.floatValue());\n\t\t}\n\t\telse if (Double.class == targetClass) {\n\t\t\treturn (T) Double.valueOf(number.doubleValue());\n\t\t}\n\t\telse if (BigDecimal.class == targetClass) {\n\t\t\t// always use BigDecimal(String) here to avoid unpredictability of BigDecimal(double)\n\t\t\t// (see BigDecimal javadoc for details)\n\t\t\treturn (T) new BigDecimal(number.toString());\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Could not convert number [\" + number + \"] of type [\" +\n\t\t\t\t\tnumber.getClass().getName() + \"] to unsupported target class [\" + targetClass.getName() + \"]\");\n\t\t}\n\t}","commit_id":"48b965ad333da1b4b8fb67dd5a08ad985b5ad135","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public String buildContentPutPanelContext(VelocityPortlet portlet, Context context, \n\t\t\tRunData data, SessionState state)\n\t{\n\t\tcontext.put(\"tlang\", rb);\n\t\tString stateToolId = (String) state.getAttribute(STATE_TOOL_ID);\n\t\tif ( ! ltiService.isMaintain() ) {\n\t\t\taddAlert(state,rb.getString(\"error.maintain.edit\"));\n\t\t\treturn \"lti_error\";\n\t\t}\n\t\tcontext.put(\"isAdmin\",new Boolean(ltiService.isAdmin()) );\n\t\tcontext.put(\"doAction\", BUTTON + \"doContentPut\");\n\t\tstate.removeAttribute(STATE_SUCCESS);\n\n\t\tList<Map<String,Object>> tools = ltiService.getTools(null,null,0,0);\n\t\t// only list the tools available in the system\n\t\tList<Map<String,Object>> systemTools = new ArrayList<Map<String,Object>>();\n\t\tfor(Map<String, Object> tool:tools)\n\t\t{\n\t\t\tif (!tool.containsKey(ltiService.LTI_SITE_ID) || StringUtils.trimToNull((String) tool.get(ltiService.LTI_SITE_ID)) == null)\n\t\t\t{\n\t\t\t\tsystemTools.add(tool);\n\t\t\t}\n\t\t}\n\t\tcontext.put(\"tools\", systemTools);\n\n\t\tObject previousData = null;\n\n\t\tString toolId = data.getParameters().getString(LTIService.LTI_TOOL_ID);\n\t\tif ( toolId == null ) toolId = stateToolId;\n\t\tLong key = null;\n\t\tif ( toolId != null ) key = new Long(toolId);\n\t\tMap<String,Object> tool = null;\n\t\tif ( key != null ) {\n\t\t\ttool = ltiService.getTool(key);\n\t\t\tif ( tool == null ) {\n\t\t\t\taddAlert(state, rb.getString(\"error.tool.not.found\"));\n\t\t\t\treturn \"lti_content_insert\";\n\t\t\t}\n\t\t}\n\n\t\tString contentId = data.getParameters().getString(LTIService.LTI_ID);\n\t\tif ( contentId == null ) contentId = (String) state.getAttribute(STATE_CONTENT_ID);\n\n\t\tif ( contentId == null ) {  // Insert\n\t\t\tif ( toolId == null ) {\n\t\t\t\treturn \"lti_content_insert\";\n\t\t\t}\n\t\t\tpreviousData = (Properties) state.getAttribute(STATE_POST);\n\n\t\t\t// Edit\n\t\t} else {\n\t\t\tLong contentKey = new Long(contentId);\n\t\t\tMap<String,Object> content = ltiService.getContent(contentKey);\n\t\t\tif ( content == null ) {\n\t\t\t\taddAlert(state, rb.getString(\"error.content.not.found\"));\n\t\t\t\tstate.removeAttribute(STATE_CONTENT_ID);\n\t\t\t\treturn \"lti_content\";\n\t\t\t}\n\n\t\t\tif ( key == null ) {\n\t\t\t\tkey = foorm.getLongNull(content.get(LTIService.LTI_TOOL_ID));\n\t\t\t\tif ( key != null ) tool = ltiService.getTool(key);\n\t\t\t}\n\t\t\tpreviousData = content;\n\t\t\t\n\t\t\t// whether the content has a site link created already?\n\t\t\tString plstr = (String) content.get(LTIService.LTI_PLACEMENT);\n\t\t\tToolConfiguration siteLinkTool = SiteService.findTool(plstr);\n\t\t\tif ( siteLinkTool != null ) {\n\t\t\t\tcontext.put(LTIService.LTI_PLACEMENT, plstr);\n\t\t\t}\n\t\t}\n\n\t\t// We will handle the tool_id field ourselves in the Velocity code\n\t\tString [] contentForm = foorm.filterForm(null,ltiService.getContentModel(key), null, \"^tool_id:.*\");\n\t\tif ( contentForm == null || key == null ) {\n\t\t\taddAlert(state,rb.getString(\"error.tool.not.found\"));\n\t\t\treturn \"lti_error\";\n\t\t}\n\t\tString formInput = ltiService.formInput(previousData, contentForm);\n\n\t\tcontext.put(\"formInput\",formInput);\n\t\tcontext.put(LTIService.LTI_TOOL_ID,key);\n\t\tif ( tool != null ) {\n\t\t\tcontext.put(\"tool_description\", tool.get(LTIService.LTI_DESCRIPTION));\n\t\t\tLong visible = foorm.getLong(tool.get(LTIService.LTI_VISIBLE));\n\t\t\tcontext.put(\"tool_visible\", visible);\n\t\t}\n\t\t\n\t\treturn \"lti_content_insert\";\n\t}","id":75107,"modified_method":"public String buildContentPutPanelContext(VelocityPortlet portlet, Context context, \n\t\t\tRunData data, SessionState state)\n\t{\n\t\tString contextString = toolManager.getCurrentPlacement().getContext();\n\t\tcontext.put(\"tlang\", rb);\n\t\tString stateToolId = (String) state.getAttribute(STATE_TOOL_ID);\n\t\tif ( ! ltiService.isMaintain() ) {\n\t\t\taddAlert(state,rb.getString(\"error.maintain.edit\"));\n\t\t\treturn \"lti_error\";\n\t\t}\n\t\tcontext.put(\"isAdmin\",new Boolean(ltiService.isAdmin()) );\n\t\tcontext.put(\"doAction\", BUTTON + \"doContentPut\");\n\t\tstate.removeAttribute(STATE_SUCCESS);\n\n\t\tList<Map<String,Object>> tools = ltiService.getTools(null,null,0,0);\n\t\t// only list the tools available in the system\n\t\tList<Map<String,Object>> systemTools = new ArrayList<Map<String,Object>>();\n\t\tfor(Map<String, Object> tool:tools)\n\t\t{\n\t\t\tString siteId = !tool.containsKey(ltiService.LTI_SITE_ID)?null:StringUtils.trimToNull((String) tool.get(ltiService.LTI_SITE_ID));\n\t\t\tif (siteId == null)\n\t\t\t{\n\t\t\t\t// add tool for whole system\n\t\t\t\tsystemTools.add(tool);\n\t\t\t}\n\t\t\telse if (siteId.equals(contextString))\n\t\t\t{\n\t\t\t\t// add the tool for current site only\n\t\t\t\tsystemTools.add(tool);\n\t\t\t}\n\t\t\telse if (ltiService.isAdmin())\n\t\t\t{\n\t\t\t\t// if in Admin's my workspace, show all tools\n\t\t\t\tsystemTools.add(tool);\n\t\t\t}\n\t\t}\n\t\tcontext.put(\"tools\", systemTools);\n\n\t\tObject previousData = null;\n\n\t\tString toolId = data.getParameters().getString(LTIService.LTI_TOOL_ID);\n\t\tif ( toolId == null ) toolId = stateToolId;\n\t\tLong key = null;\n\t\tif ( toolId != null ) key = new Long(toolId);\n\t\tMap<String,Object> tool = null;\n\t\tif ( key != null ) {\n\t\t\ttool = ltiService.getTool(key);\n\t\t\tif ( tool == null ) {\n\t\t\t\taddAlert(state, rb.getString(\"error.tool.not.found\"));\n\t\t\t\treturn \"lti_content_insert\";\n\t\t\t}\n\t\t}\n\n\t\tString contentId = data.getParameters().getString(LTIService.LTI_ID);\n\t\tif ( contentId == null ) contentId = (String) state.getAttribute(STATE_CONTENT_ID);\n\n\t\tif ( contentId == null ) {  // Insert\n\t\t\tif ( toolId == null ) {\n\t\t\t\treturn \"lti_content_insert\";\n\t\t\t}\n\t\t\tpreviousData = (Properties) state.getAttribute(STATE_POST);\n\n\t\t\t// Edit\n\t\t} else {\n\t\t\tLong contentKey = new Long(contentId);\n\t\t\tMap<String,Object> content = ltiService.getContent(contentKey);\n\t\t\tif ( content == null ) {\n\t\t\t\taddAlert(state, rb.getString(\"error.content.not.found\"));\n\t\t\t\tstate.removeAttribute(STATE_CONTENT_ID);\n\t\t\t\treturn \"lti_content\";\n\t\t\t}\n\n\t\t\tif ( key == null ) {\n\t\t\t\tkey = foorm.getLongNull(content.get(LTIService.LTI_TOOL_ID));\n\t\t\t\tif ( key != null ) tool = ltiService.getTool(key);\n\t\t\t}\n\t\t\tpreviousData = content;\n\t\t\t\n\t\t\t// whether the content has a site link created already?\n\t\t\tString plstr = (String) content.get(LTIService.LTI_PLACEMENT);\n\t\t\tToolConfiguration siteLinkTool = SiteService.findTool(plstr);\n\t\t\tif ( siteLinkTool != null ) {\n\t\t\t\tcontext.put(LTIService.LTI_PLACEMENT, plstr);\n\t\t\t}\n\t\t}\n\n\t\t// We will handle the tool_id field ourselves in the Velocity code\n\t\tString [] contentForm = foorm.filterForm(null,ltiService.getContentModel(key), null, \"^tool_id:.*\");\n\t\tif ( contentForm == null || key == null ) {\n\t\t\taddAlert(state,rb.getString(\"error.tool.not.found\"));\n\t\t\treturn \"lti_error\";\n\t\t}\n\t\tString formInput = ltiService.formInput(previousData, contentForm);\n\n\t\tcontext.put(\"formInput\",formInput);\n\t\tcontext.put(LTIService.LTI_TOOL_ID,key);\n\t\tif ( tool != null ) {\n\t\t\tcontext.put(\"tool_description\", tool.get(LTIService.LTI_DESCRIPTION));\n\t\t\tLong visible = foorm.getLong(tool.get(LTIService.LTI_VISIBLE));\n\t\t\tcontext.put(\"tool_visible\", visible);\n\t\t}\n\t\t\n\t\treturn \"lti_content_insert\";\n\t}","commit_id":"1b4321d4db043ec03c3354fbd064b76cbfcbb5d9","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void doContentPut(RunData data, Context context)\n\t{\n\t\tString peid = ((JetspeedRunData) data).getJs_peid();\n\t\tSessionState state = ((JetspeedRunData) data).getPortletSessionState(peid);\n\t\tstate.removeAttribute(STATE_POST);\n\t\t\n\t\tProperties reqProps = data.getParameters().getProperties();\n\t\tString id = data.getParameters().getString(LTIService.LTI_ID);\n\t\tString toolId = data.getParameters().getString(LTIService.LTI_TOOL_ID);\n\t\tString title = data.getParameters().getString(LTIService.LTI_TITLE);\n\t\tObject retval = ltiService.insertToolContent(id, toolId, reqProps);\n\t\t\n\t\tif ( retval instanceof String ) \n\t\t{\n\t\t\taddAlert(state, (String) retval);\n\t\t\tswitchPanel(state, \"Error\");\n\t\t\tstate.setAttribute(STATE_POST,reqProps);\n\t\t\tstate.setAttribute(STATE_CONTENT_ID,id);\n\t\t\treturn;\n\t\t}\n\t\telse if ( retval instanceof Boolean )\n\t\t{\n\t\t\t// TODO: returns boolean\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// the return value is the content key Long value\n\t\t\tid = ((Long) retval).toString();\n\t\t}\n\n\t\tString returnUrl = reqProps.getProperty(\"returnUrl\");\n\t\tif ( returnUrl != null )\n\t\t{\n\t\t\tif ( id != null ) {\n\t\t\t\tLong contentKey = new Long(id);\n\t\t\t\tif ( returnUrl.startsWith(\"about:blank\") ) { // Redirect to the item\n\t\t\t\t\tMap<String,Object> content = ltiService.getContent(contentKey);\n\t\t\t\t\tif ( content != null ) {\n\t\t\t\t\t\tString launch = (String) ltiService.getContentLaunch(content);\n\t\t\t\t\t\tif ( launch != null ) returnUrl = launch;\n\t\t\t\t\t}\n\t\t\t\t\tswitchPanel(state, \"Forward\");\n\t\t\t\t} else {\n\t\t\t\t\tif ( returnUrl.indexOf(\"?\") > 0 ) {\n\t\t\t\t\t\treturnUrl += \"&ltiItemId=/blti/\" + retval;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturnUrl += \"?ltiItemId=/blti/\" + retval;\n\t\t\t\t\t}\n\t\t\t\t\tswitchPanel(state, \"Redirect\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tstate.setAttribute(STATE_REDIRECT_URL,returnUrl);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tString success = null;\n\t\tif ( id == null ) \n\t\t{\n\t\t\tsuccess = rb.getString(\"success.created\");\n\t\t} else {\n\t\t\tsuccess = rb.getString(\"success.updated\");\n\t\t}\n\t\tstate.setAttribute(STATE_SUCCESS,success);\n\t\t\n\t\tif (reqProps.getProperty(\"add_site_link\") != null)\n\t\t{\n\t\t\t// this is to add site link:\n\t\t\tretval = ltiService.insertToolSiteLink(id, title);\n\t\t\tif ( retval instanceof String ) {\n\t\t\t\tString prefix = ((String) retval).substring(0,2);\n\t\t\t\taddAlert(state, ((String) retval).substring(2));\n\t\t\t\tif (\"0-\".equals(prefix))\n\t\t\t\t{\n\t\t\t\t\tswitchPanel(state, \"Main\");\n\t\t\t\t}\n\t\t\t\telse if (\"1-\".equals(prefix))\n\t\t\t\t{\n\t\t\t\t\tswitchPanel(state, \"Error\");\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tstate.setAttribute(STATE_SUCCESS,rb.getString(\"success.link.add\"));\n\t\t}\n\n\t\tswitchPanel(state, \"ToolSite\");\n\t}","id":75108,"modified_method":"public void doContentPut(RunData data, Context context)\n\t{\n\t\tString peid = ((JetspeedRunData) data).getJs_peid();\n\t\tSessionState state = ((JetspeedRunData) data).getPortletSessionState(peid);\n\t\tstate.removeAttribute(STATE_POST);\n\t\t\n\t\tProperties reqProps = data.getParameters().getProperties();\n\t\tString id = data.getParameters().getString(LTIService.LTI_ID);\n\t\tString toolId = data.getParameters().getString(LTIService.LTI_TOOL_ID);\n\t\tString title = data.getParameters().getString(LTIService.LTI_TITLE);\n\t\tObject retval = ltiService.insertToolContent(id, toolId, reqProps);\n\t\t\n\t\tif ( retval instanceof String ) \n\t\t{\n\t\t\taddAlert(state, (String) retval);\n\t\t\tswitchPanel(state, \"Error\");\n\t\t\tstate.setAttribute(STATE_POST,reqProps);\n\t\t\tstate.setAttribute(STATE_CONTENT_ID,id);\n\t\t\treturn;\n\t\t}\n\t\telse if ( retval instanceof Boolean )\n\t\t{\n\t\t\t// TODO: returns boolean\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// the return value is the content key Long value\n\t\t\tid = ((Long) retval).toString();\n\t\t}\n\n\t\tString returnUrl = reqProps.getProperty(\"returnUrl\");\n\t\tif ( returnUrl != null )\n\t\t{\n\t\t\tif ( id != null ) {\n\t\t\t\tLong contentKey = new Long(id);\n\t\t\t\tif ( returnUrl.startsWith(\"about:blank\") ) { // Redirect to the item\n\t\t\t\t\tMap<String,Object> content = ltiService.getContent(contentKey);\n\t\t\t\t\tif ( content != null ) {\n\t\t\t\t\t\tString launch = (String) ltiService.getContentLaunch(content);\n\t\t\t\t\t\tif ( launch != null ) returnUrl = launch;\n\t\t\t\t\t}\n\t\t\t\t\tswitchPanel(state, \"Forward\");\n\t\t\t\t} else {\n\t\t\t\t\tif ( returnUrl.indexOf(\"?\") > 0 ) {\n\t\t\t\t\t\treturnUrl += \"&ltiItemId=/blti/\" + retval;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturnUrl += \"?ltiItemId=/blti/\" + retval;\n\t\t\t\t\t}\n\t\t\t\t\tswitchPanel(state, \"Redirect\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tstate.setAttribute(STATE_REDIRECT_URL,returnUrl);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tString success = null;\n\t\tif ( id == null ) \n\t\t{\n\t\t\tsuccess = rb.getString(\"success.created\");\n\t\t} else {\n\t\t\tsuccess = rb.getString(\"success.updated\");\n\t\t}\n\t\tstate.setAttribute(STATE_SUCCESS,success);\n\t\t\n\t\tif (reqProps.getProperty(\"add_site_link\") != null)\n\t\t{\n\t\t\t// this is to add site link:\n\t\t\tretval = ltiService.insertToolSiteLink(id, title);\n\t\t\tif ( retval instanceof String ) {\n\t\t\t\tString prefix = ((String) retval).substring(0,2);\n\t\t\t\taddAlert(state, ((String) retval).substring(2));\n\t\t\t\tif (\"0-\".equals(prefix))\n\t\t\t\t{\n\t\t\t\t\tswitchPanel(state, \"Refresh\");\n\t\t\t\t}\n\t\t\t\telse if (\"1-\".equals(prefix))\n\t\t\t\t{\n\t\t\t\t\tswitchPanel(state, \"Error\");\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if ( retval instanceof Boolean ) {\n\t\t\t\tif (((Boolean) retval).booleanValue())\n\t\t\t\t{\n\t\t\t\t\tswitchPanel(state, \"Refresh\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tswitchPanel(state, \"Error\");\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tstate.setAttribute(STATE_SUCCESS,rb.getString(\"success.link.add\"));\n\t\t}\n\n\n\t\tswitchPanel(state, \"ToolSite\");\n\t}","commit_id":"1b4321d4db043ec03c3354fbd064b76cbfcbb5d9","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public String buildToolSystemPanelContext(VelocityPortlet portlet, Context context, \n\t\t\tRunData data, SessionState state)\n\t{\n\t\tcontext.put(\"tlang\", rb);\n\t\tif ( ! ltiService.isMaintain() ) {\n\t\t\taddAlert(state,rb.getString(\"error.maintain.edit\"));\n\t\t\treturn \"lti_error\";\n\t\t}\n\t\tString returnUrl = data.getParameters().getString(\"returnUrl\");\n\t\t// if ( returnUrl != null ) state.setAttribute(STATE_REDIRECT_URL, returnUrl);\n\t\tcontext.put(\"ltiService\", ltiService);\n\t\tcontext.put(\"isAdmin\",new Boolean(ltiService.isAdmin()) );\n\t\tcontext.put(\"inHelper\",new Boolean(inHelper));\n\t\tcontext.put(\"getContext\",toolManager.getCurrentPlacement().getContext());\n\t\tcontext.put(\"doEndHelper\", BUTTON + \"doEndHelper\");\n\t\tstate.removeAttribute(STATE_POST);\n\t\tstate.removeAttribute(STATE_SUCCESS);\n\n\t\tcontext.put(\"messageSuccess\",state.getAttribute(STATE_SUCCESS));\n\t\tcontext.put(\"isAdmin\",new Boolean(ltiService.isAdmin()) );\n\t\t// by default, site maintainer can add system-wide LTI tool\n\t\tcontext.put(\"allowMaintainerAddSystemTool\", new Boolean(serverConfigurationService.getBoolean(ALLOW_MAINTAINER_ADD_SYSTEM_TOOL, true)));\n\t\tcontext.put(\"getContext\",toolManager.getCurrentPlacement().getContext());\n\t\t\n\t\t// this is for the system tool panel\n\t\tList<Map<String,Object>> contents = ltiService.getContents(null,null,0,500);\n\t\tList<Map<String,Object>> tools = ltiService.getTools(null,null,0,0);\n\t\tif (tools != null && !tools.isEmpty())\n\t\t{\n\t\t\tList<Map<String,Object>> siteLtiTools = new ArrayList<Map<String, Object>>();\n\t\t\tList<Map<String,Object>> systemLtiTools = new ArrayList<Map<String, Object>>();\n\t\t\tHashMap<String, Map<String, Object>> systemLtiToolsMap = new HashMap<String, Map<String, Object>>();\n\t\t\tfor(Map<String, Object> tool:tools)\n\t\t\t{\n\t\t\t\tif (!tool.containsKey(ltiService.LTI_SITE_ID) || StringUtils.trimToNull((String) tool.get(ltiService.LTI_SITE_ID)) == null)\n\t\t\t\t{\n\t\t\t\t\tsystemLtiTools.add(tool);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// get invoke count for all lti tools\n\t\t\tHashMap<String, List<String>> ltiToolsCount = getLtiToolUsageCount(contents);\n\t\t\tfor (Map<String, Object> toolMap : systemLtiTools ) {\n\t\t\t\tString ltiToolId = ((Integer) toolMap.get(\"id\")).toString();\n\t\t\t\tList<String> toolSite = ltiToolsCount.containsKey(ltiToolId)?ltiToolsCount.get(ltiToolId):new ArrayList<String>();\n\t\t\t\tSet<String> toolUniqueSite = new HashSet<String>();\n\t\t\t\ttoolUniqueSite.addAll(toolSite);\n\t\t\t\ttoolMap.put(\"tool_count\", toolSite.size());\n\t\t\t\ttoolMap.put(\"tool_unique_site_count\", toolUniqueSite.size());\n\t\t\t\tsystemLtiToolsMap.put(ltiToolId, toolMap);\n\t\t\t}\n\t\t\tcontext.put(\"systemLtiToolsMap\", systemLtiToolsMap);\n\t\t\tcontext.put(\"siteLtiTools\", siteLtiTools);\n\t\t}\n\t\t\n\t\t// top navigation menu\n\t\tMenu menu = new MenuImpl(portlet, data, \"LTIAdminTool\");\n\t\tmenu.add(new MenuEntry(rb.getString(\"tool.in.site\"), true, \"doNav_tool_site\"));\n\t\tmenu.add(new MenuEntry(rb.getString(\"tool.in.system\"), false, \"doNav_tool_system\"));\n\t\tcontext.put(\"menu\", menu);\n\t\t\n\t\treturn \"lti_tool_system\";\n\t}","id":75109,"modified_method":"public String buildToolSystemPanelContext(VelocityPortlet portlet, Context context, \n\t\t\tRunData data, SessionState state)\n\t{\n\t\tcontext.put(\"tlang\", rb);\n\t\tif ( ! ltiService.isMaintain() ) {\n\t\t\taddAlert(state,rb.getString(\"error.maintain.edit\"));\n\t\t\treturn \"lti_error\";\n\t\t}\n\t\tString contextString = toolManager.getCurrentPlacement().getContext();\n\t\tString returnUrl = data.getParameters().getString(\"returnUrl\");\n\t\t// if ( returnUrl != null ) state.setAttribute(STATE_REDIRECT_URL, returnUrl);\n\t\tcontext.put(\"ltiService\", ltiService);\n\t\tcontext.put(\"isAdmin\",new Boolean(ltiService.isAdmin()) );\n\t\tcontext.put(\"inHelper\",new Boolean(inHelper));\n\t\tcontext.put(\"doEndHelper\", BUTTON + \"doEndHelper\");\n\t\tstate.removeAttribute(STATE_POST);\n\t\tstate.removeAttribute(STATE_SUCCESS);\n\n\t\tcontext.put(\"messageSuccess\",state.getAttribute(STATE_SUCCESS));\n\t\tcontext.put(\"isAdmin\",new Boolean(ltiService.isAdmin()) );\n\t\t// by default, site maintainer can add system-wide LTI tool\n\t\tcontext.put(\"allowMaintainerAddSystemTool\", new Boolean(serverConfigurationService.getBoolean(ALLOW_MAINTAINER_ADD_SYSTEM_TOOL, true)));\n\t\tcontext.put(\"getContext\", contextString);\n\t\t\n\t\t// this is for the system tool panel\n\t\tList<Map<String,Object>> contents = ltiService.getContents(null,null,0,500);\n\t\tList<Map<String,Object>> tools = ltiService.getTools(null,null,0,0);\n\t\tif (tools != null && !tools.isEmpty())\n\t\t{\n\t\t\tList<Map<String,Object>> siteLtiTools = new ArrayList<Map<String, Object>>();\n\t\t\tList<Map<String,Object>> systemLtiTools = new ArrayList<Map<String, Object>>();\n\t\t\tHashMap<String, Map<String, Object>> systemLtiToolsMap = new HashMap<String, Map<String, Object>>();\n\t\t\tfor(Map<String, Object> tool:tools)\n\t\t\t{\n\t\t\t\tif (!tool.containsKey(ltiService.LTI_SITE_ID) || StringUtils.trimToNull((String) tool.get(ltiService.LTI_SITE_ID)) == null)\n\t\t\t\t{\n\t\t\t\t\tsystemLtiTools.add(tool);\n\t\t\t\t}\n\t\t\t\telse if (((String) tool.get(ltiService.LTI_SITE_ID)).equals(contextString))\n\t\t\t\t{\n\t\t\t\t\t// if the current user is admin, add the site-range tool;\n\t\t\t\t\t// otherwise, add the site-range tool only if the tool's site_id is the same as current site\n\t\t\t\t\tsystemLtiTools.add(tool);\n\t\t\t\t}\n\t\t\t\telse if (ltiService.isAdmin())\n\t\t\t\t{\n\t\t\t\t\t// show all the tools inside Admin MyWorkspace site\n\t\t\t\t\tsystemLtiTools.add(tool);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// get invoke count for all lti tools\n\t\t\tHashMap<String, List<String>> ltiToolsCount = getLtiToolUsageCount(contents);\n\t\t\tfor (Map<String, Object> toolMap : systemLtiTools ) {\n\t\t\t\tString ltiToolId = ((Integer) toolMap.get(\"id\")).toString();\n\t\t\t\tList<String> toolSite = ltiToolsCount.containsKey(ltiToolId)?ltiToolsCount.get(ltiToolId):new ArrayList<String>();\n\t\t\t\tSet<String> toolUniqueSite = new HashSet<String>();\n\t\t\t\ttoolUniqueSite.addAll(toolSite);\n\t\t\t\ttoolMap.put(\"tool_count\", toolSite.size());\n\t\t\t\ttoolMap.put(\"tool_unique_site_count\", toolUniqueSite.size());\n\t\t\t\tsystemLtiToolsMap.put(ltiToolId, toolMap);\n\t\t\t}\n\t\t\tcontext.put(\"systemLtiToolsMap\", systemLtiToolsMap);\n\t\t\tcontext.put(\"siteLtiTools\", siteLtiTools);\n\t\t}\n\t\t\n\t\t// top navigation menu\n\t\tMenu menu = new MenuImpl(portlet, data, \"LTIAdminTool\");\n\t\tmenu.add(new MenuEntry(rb.getString(\"tool.in.site\"), true, \"doNav_tool_site\"));\n\t\tmenu.add(new MenuEntry(rb.getString(\"tool.in.system\"), false, \"doNav_tool_system\"));\n\t\tcontext.put(\"menu\", menu);\n\t\t\n\t\treturn \"lti_tool_system\";\n\t}","commit_id":"1b4321d4db043ec03c3354fbd064b76cbfcbb5d9","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Read the user form and update the realm in state.\n\t * \n\t * @return true if the form is accepted, false if there's a validation error (an alertMessage will be set)\n\t */\n\tprivate boolean readRoleForm(RunData data, SessionState state)\n\t{\n\t\t// get the realm\n\t\tAuthzGroup realm = (AuthzGroup) state.getAttribute(\"realm\");\n\n\t\t// get the locks\n\t\tString[] locks = data.getParameters().getStrings(\"locks\");\n\n\t\t// we are setting for either a new role or this role\n\t\tRole role = (Role) state.getAttribute(\"role\");\n\n\t\t//Read the locks if they're null and the role is not null to avoid passing them around\n\t\tif (locks == null && role != null) {\n\t\t\tCollection realms = new ArrayList<String>(Arrays.asList(realm.getId()));\n\t\t\tList <String> newlocks = new ArrayList(AuthzGroupService.getAllowedFunctions(role.getId(), realms));\n\t\t\tlocks = newlocks.toArray(new String[0]);\n\t\t}\n\n\t\tif (realm != null && role == null)\n\t\t{\n\t\t\t// read the form\n\t\t\tString id = StringUtils.trimToNull(data.getParameters().getString(\"id\"));\n\n\t\t\t// if the field is missing, and there are no locks, just be done with no change\n\t\t\tif ((id == null) && (locks == null)) return true;\n\n\t\t\tif (id == null)\n\t\t\t{\n\t\t\t\taddAlert(state, rb.getString(\"realm.please\"));\n\t\t\t\treturn false;\n\t\t\t\t// TODO: would be nice to read the locks, and restore them when the form returns -ggolden\n\t\t\t}\n\n\t\t\t// create the role\n\t\t\ttry\n\t\t\t{\n\t\t\t\trole = realm.addRole(id);\n\t\t\t}\n\t\t\tcatch (RoleAlreadyDefinedException e)\n\t\t\t{\n\t\t\t\taddAlert(state, rb.getFormattedMessage(\"realm.defined\", new Object[]{id}) );\n\t\t\t\treturn false;\n\t\t\t\t// TODO: would be nice to read the locks, and restore them when the form returns -ggolden\n\t\t\t}\n\t\t}\n\n\t\t// clear out the role\n\t\trole.disallowAll();\n\n\t\t// description\n\t\trole.setDescription(StringUtils.trimToNull(data.getParameters().getString(\"description\")));\n\n\t\t// providerOnly\n\t\tString providerOnlyString = (StringUtils.trimToNull(data.getParameters().getString(\"providerOnly\")));\n\t\trole.setProviderOnly(\"true\".equals(providerOnlyString));\t\t\n\n\t\t// for each lock set, give it to the role\n\t\tif (locks != null)\n\t\t{\n\t\t\tfor (int i = 0; i < locks.length; i++)\n\t\t\t{\n\t\t\t\trole.allowFunction(locks[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\n\t}","id":75110,"modified_method":"/**\n\t * Read the user form and update the realm in state.\n\t * \n\t * @return true if the form is accepted, false if there's a validation error (an alertMessage will be set)\n\t */\n\tprivate boolean readRoleForm(RunData data, SessionState state)\n\t{\n\t\t// get the realm\n\t\tAuthzGroup realm = (AuthzGroup) state.getAttribute(\"realm\");\n\n\t\t// get the locks\n\t\tString[] locks = data.getParameters().getStrings(\"locks\");\n\n\t\t// we are setting for either a new role or this role\n\t\tRole role = (Role) state.getAttribute(\"role\");\n\n\t\t//Read the locks if they're null and the role is not null to avoid passing them around\n\t\tif (locks == null && role != null) {\n\t\t\tCollection realms = new ArrayList<String>(Arrays.asList(realm.getId()));\n\t\t\tList <String> newlocks = new ArrayList(AuthzGroupService.getAllowedFunctions(role.getId(), realms));\n\t\t\tlocks = newlocks.toArray(new String[0]);\n\t\t}\n\n\t\tif (realm != null && role == null)\n\t\t{\n\t\t\t// read the form\n\t\t\tString id = StringUtils.trimToNull(data.getParameters().getString(\"id\"));\n\n\t\t\t// if the field is missing, and there are no locks, just be done with no change\n\t\t\tif ((id == null) && (locks == null)) return true;\n\n\t\t\tif (id == null)\n\t\t\t{\n\t\t\t\taddAlert(state, rb.getString(\"realm.please\"));\n\t\t\t\treturn false;\n\t\t\t\t// TODO: would be nice to read the locks, and restore them when the form returns -ggolden\n\t\t\t}\n\n\t\t\t// create the role\n\t\t\ttry\n\t\t\t{\n\t\t\t\trole = realm.addRole(id);\n\t\t\t}\n\t\t\tcatch (RoleAlreadyDefinedException e)\n\t\t\t{\n\t\t\t\taddAlert(state, rb.getFormattedMessage(\"realm.defined\", new Object[]{id}) );\n\t\t\t\treturn false;\n\t\t\t\t// TODO: would be nice to read the locks, and restore them when the form returns -ggolden\n\t\t\t}\n\t\t}\n\n\t\t// clear out the role\n\t\trole.disallowAll();\n\n\t\tString descriptionString = StringUtils.trimToNull(data.getParameters().getString(\"description\"));\n\t\tString providerOnlyString = StringUtils.trimToNull(data.getParameters().getString(\"providerOnly\"));\n\t\t\n\t\t//Role can't be null at this point\n\t\tif (descriptionString == null) {\n\t\t\tdescriptionString = role.getDescription();\n\t\t}\n\t\t\n\t\tif (providerOnlyString == null) {\n\t\t\tproviderOnlyString = String.valueOf(role.isProviderOnly());\n\t\t}\n\n\t\t// description\n\t\trole.setDescription(StringUtils.trimToNull(descriptionString));\n\n\t\t// providerOnly\n\t\trole.setProviderOnly(\"true\".equals(providerOnlyString));\t\t\n\n\t\t// for each lock set, give it to the role\n\t\tif (locks != null)\n\t\t{\n\t\t\tfor (int i = 0; i < locks.length; i++)\n\t\t\t{\n\t\t\t\trole.allowFunction(locks[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\n\t}","commit_id":"12540ca8000fcebe4eb2c19cc2afa245a131b8aa","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void flush() {\n\t\t_reentrantLock.lock();\n\n\t\ttry {\n\t\t\t_getNotificationEvents().clear();\n\t\t}\n\t\tfinally {\n\t\t\t_reentrantLock.unlock();\n\t\t}\n\t}","id":75111,"modified_method":"public void flush() {\n\t\t_reentrantLock.lock();\n\n\t\ttry {\n\t\t\tTreeSet<NotificationEvent> notificationEvents =\n\t\t\t\t_getNotificationEvents();\n\n\t\t\tnotificationEvents.clear();\n\t\t}\n\t\tfinally {\n\t\t\t_reentrantLock.unlock();\n\t\t}\n\t}","commit_id":"5b11310909ee9703129c344a0c8661d437d31e21","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void removeTransientNotificationEventsByUuid(\n\t\tCollection<String> notificationEventUuids) {\n\n\t\tSet<String> notificationEventUuidsSet = new HashSet<String>(\n\t\t\tnotificationEventUuids);\n\n\t\t_reentrantLock.lock();\n\n\t\ttry {\n\t\t\tIterator<NotificationEvent> itr =\n\t\t\t\t_getNotificationEvents().iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tNotificationEvent notificationEvent = itr.next();\n\n\t\t\t\tif (notificationEventUuidsSet.contains(\n\t\t\t\t\t\tnotificationEvent.getUuid())) {\n\n\t\t\t\t\titr.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\t_reentrantLock.unlock();\n\t\t}\n\t}","id":75112,"modified_method":"public void removeTransientNotificationEventsByUuid(\n\t\tCollection<String> notificationEventUuids) {\n\n\t\tSet<String> notificationEventUuidsSet = new HashSet<String>(\n\t\t\tnotificationEventUuids);\n\n\t\t_reentrantLock.lock();\n\n\t\ttry {\n\t\t\tTreeSet<NotificationEvent> notificationEvents =\n\t\t\t\t_getNotificationEvents();\n\n\t\t\tIterator<NotificationEvent> itr = notificationEvents.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tNotificationEvent notificationEvent = itr.next();\n\n\t\t\t\tif (notificationEventUuidsSet.contains(\n\t\t\t\t\t\tnotificationEvent.getUuid())) {\n\n\t\t\t\t\titr.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\t_reentrantLock.unlock();\n\t\t}\n\t}","commit_id":"5b11310909ee9703129c344a0c8661d437d31e21","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void confirmDelivery(String notificationEventUuid)\n\t\tthrows ChannelException {\n\n\t\t_reentrantLock.lock();\n\n\t\ttry {\n\t\t\tNotificationEvent notificationEvent =\n\t\t\t\t_getUnconfirmedNotificationEvents().remove(\n\t\t\t\t\tnotificationEventUuid);\n\n\t\t\tif (PropsValues.USER_NOTIFICATION_EVENT_CONFIRMATION_ENABLED &&\n\t\t\t\t(notificationEvent != null)) {\n\n\t\t\t\tUserNotificationEventLocalServiceUtil.\n\t\t\t\t\tdeleteUserNotificationEvent(notificationEvent.getUuid());\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new ChannelException(\n\t\t\t\t\"Uanble to confirm delivery for \" + notificationEventUuid , e);\n\t\t}\n\t\tfinally {\n\t\t\t_reentrantLock.unlock();\n\t\t}\n\t}","id":75113,"modified_method":"public void confirmDelivery(String notificationEventUuid)\n\t\tthrows ChannelException {\n\n\t\t_reentrantLock.lock();\n\n\t\ttry {\n\t\t\tMap<String, NotificationEvent> unconfirmedNotificationEvents =\n\t\t\t\t_getUnconfirmedNotificationEvents();\n\n\t\t\tNotificationEvent notificationEvent =\n\t\t\t\tunconfirmedNotificationEvents.remove(notificationEventUuid);\n\n\t\t\tif (PropsValues.USER_NOTIFICATION_EVENT_CONFIRMATION_ENABLED &&\n\t\t\t\t(notificationEvent != null)) {\n\n\t\t\t\tUserNotificationEventLocalServiceUtil.\n\t\t\t\t\tdeleteUserNotificationEvent(notificationEvent.getUuid());\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new ChannelException(\n\t\t\t\t\"Uanble to confirm delivery for \" + notificationEventUuid , e);\n\t\t}\n\t\tfinally {\n\t\t\t_reentrantLock.unlock();\n\t\t}\n\t}","commit_id":"5b11310909ee9703129c344a0c8661d437d31e21","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void removeTransientNotificationEvents(\n\t\tCollection<NotificationEvent> notificationEvents) {\n\n\t\t_reentrantLock.lock();\n\n\t\ttry {\n\t\t\t_getNotificationEvents().removeAll(notificationEvents);\n\t\t}\n\t\tfinally {\n\t\t\t_reentrantLock.unlock();\n\t\t}\n\t}","id":75114,"modified_method":"public void removeTransientNotificationEvents(\n\t\tCollection<NotificationEvent> notificationEvents) {\n\n\t\t_reentrantLock.lock();\n\n\t\ttry {\n\t\t\tTreeSet<NotificationEvent> notificationEventsSet =\n\t\t\t\t_getNotificationEvents();\n\n\t\t\tnotificationEventsSet.removeAll(notificationEvents);\n\t\t}\n\t\tfinally {\n\t\t\t_reentrantLock.unlock();\n\t\t}\n\t}","commit_id":"5b11310909ee9703129c344a0c8661d437d31e21","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void storeNotificationEvent(\n\t\tNotificationEvent notificationEvent, long currentTime) {\n\n\t\tif (isRemoveNotificationEvent(notificationEvent, currentTime)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (PropsValues.USER_NOTIFICATION_EVENT_CONFIRMATION_ENABLED &&\n\t\t\tnotificationEvent.isDeliveryRequired()) {\n\n\t\t\t_getUnconfirmedNotificationEvents().put(\n\t\t\t\tnotificationEvent.getUuid(), notificationEvent);\n\t\t}\n\t\telse {\n\t\t\tTreeSet<NotificationEvent> notificationEvents =\n\t\t\t\t_getNotificationEvents();\n\n\t\t\tnotificationEvents.add(notificationEvent);\n\n\t\t\tif (notificationEvents.size() >\n\t\t\t\t\tPropsValues.NOTIFICATIONS_MAX_EVENTS) {\n\n\t\t\t\tNotificationEvent firstNotificationEvent =\n\t\t\t\t\tnotificationEvents.first();\n\n\t\t\t\tnotificationEvents.remove(firstNotificationEvent);\n\t\t\t}\n\t\t}\n\t}","id":75115,"modified_method":"protected void storeNotificationEvent(\n\t\tNotificationEvent notificationEvent, long currentTime) {\n\n\t\tif (isRemoveNotificationEvent(notificationEvent, currentTime)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (PropsValues.USER_NOTIFICATION_EVENT_CONFIRMATION_ENABLED &&\n\t\t\tnotificationEvent.isDeliveryRequired()) {\n\n\t\t\tMap<String, NotificationEvent> unconfirmedNotificationEvents =\n\t\t\t\t_getUnconfirmedNotificationEvents();\n\n\t\t\tunconfirmedNotificationEvents.put(\n\t\t\t\tnotificationEvent.getUuid(), notificationEvent);\n\t\t}\n\t\telse {\n\t\t\tTreeSet<NotificationEvent> notificationEvents =\n\t\t\t\t_getNotificationEvents();\n\n\t\t\tnotificationEvents.add(notificationEvent);\n\n\t\t\tif (notificationEvents.size() >\n\t\t\t\t\tPropsValues.NOTIFICATIONS_MAX_EVENTS) {\n\n\t\t\t\tNotificationEvent firstNotificationEvent =\n\t\t\t\t\tnotificationEvents.first();\n\n\t\t\t\tnotificationEvents.remove(firstNotificationEvent);\n\t\t\t}\n\t\t}\n\t}","commit_id":"5b11310909ee9703129c344a0c8661d437d31e21","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void flush(long timestamp) {\n\t\t_reentrantLock.lock();\n\n\t\ttry {\n\t\t\tIterator<NotificationEvent> itr =\n\t\t\t\t_getNotificationEvents().iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tNotificationEvent notificationEvent = itr.next();\n\n\t\t\t\tif (notificationEvent.getTimestamp() < timestamp) {\n\t\t\t\t\titr.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\t_reentrantLock.unlock();\n\t\t}\n\t}","id":75116,"modified_method":"public void flush(long timestamp) {\n\t\t_reentrantLock.lock();\n\n\t\ttry {\n\t\t\tTreeSet<NotificationEvent> notificationEvents =\n\t\t\t\t_getNotificationEvents();\n\n\t\t\tIterator<NotificationEvent> itr = notificationEvents.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tNotificationEvent notificationEvent = itr.next();\n\n\t\t\t\tif (notificationEvent.getTimestamp() < timestamp) {\n\t\t\t\t\titr.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\t_reentrantLock.unlock();\n\t\t}\n\t}","commit_id":"5b11310909ee9703129c344a0c8661d437d31e21","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doCleanUp() throws Exception {\n\t\t_reentrantLock.lock();\n\n\t\ttry {\n\n\t\t\tlong currentTime = System.currentTimeMillis();\n\n\t\t\tIterator<NotificationEvent> itr1 =\n\t\t\t\t_getNotificationEvents().iterator();\n\n\t\t\twhile (itr1.hasNext()) {\n\t\t\t\tNotificationEvent notificationEvent = itr1.next();\n\n\t\t\t\tboolean remove = isRemoveNotificationEvent(\n\t\t\t\t\tnotificationEvent, currentTime);\n\n\t\t\t\tif (remove) {\n\t\t\t\t\titr1.remove();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tMap<String, NotificationEvent> unconfirmedNotificationEvents =\n\t\t\t\t_getUnconfirmedNotificationEvents();\n\n\t\t\tList<String> invalidNotificationEventUuids = new ArrayList<String>(\n\t\t\t\tunconfirmedNotificationEvents.size());\n\n\t\t\tIterator<Map.Entry<String, NotificationEvent>> itr2 =\n\t\t\t\tunconfirmedNotificationEvents.entrySet().iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tMap.Entry<String, NotificationEvent> entry =\n\t\t\t\t\titr2.next();\n\n\t\t\t\tNotificationEvent notificationEvent = entry.getValue();\n\n\t\t\t\tif (isRemoveNotificationEvent(notificationEvent, currentTime)) {\n\t\t\t\t\tinvalidNotificationEventUuids.add(entry.getKey());\n\n\t\t\t\t\titr2.remove();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (PropsValues.USER_NOTIFICATION_EVENT_CONFIRMATION_ENABLED &&\n\t\t\t\t!invalidNotificationEventUuids.isEmpty()) {\n\n\t\t\t\tUserNotificationEventLocalServiceUtil.\n\t\t\t\t\tdeleteUserNotificationEvents(invalidNotificationEventUuids);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new ChannelException(\n\t\t\t\t\"Unable to clean up channel \" + getUserId(), e);\n\t\t}\n\t\tfinally {\n\t\t\t_reentrantLock.unlock();\n\t\t}\n\t}","id":75117,"modified_method":"@Override\n\tprotected void doCleanUp() throws Exception {\n\t\t_reentrantLock.lock();\n\n\t\ttry {\n\t\t\tlong currentTime = System.currentTimeMillis();\n\n\t\t\tTreeSet<NotificationEvent> notificationEvents =\n\t\t\t\t_getNotificationEvents();\n\n\t\t\tIterator<NotificationEvent> itr1 = notificationEvents.iterator();\n\n\t\t\twhile (itr1.hasNext()) {\n\t\t\t\tNotificationEvent notificationEvent = itr1.next();\n\n\t\t\t\tif (isRemoveNotificationEvent(\n\t\t\t\t\t\tnotificationEvent, currentTime)) {\n\n\t\t\t\t\titr1.remove();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tMap<String, NotificationEvent> unconfirmedNotificationEvents =\n\t\t\t\t_getUnconfirmedNotificationEvents();\n\n\t\t\tList<String> invalidNotificationEventUuids = new ArrayList<String>(\n\t\t\t\tunconfirmedNotificationEvents.size());\n\n\t\t\tSet<Map.Entry<String, NotificationEvent>>\n\t\t\t\tunconfirmedNotificationEventsSet =\n\t\t\t\t\tunconfirmedNotificationEvents.entrySet();\n\n\t\t\tIterator<Map.Entry<String, NotificationEvent>> itr2 =\n\t\t\t\tunconfirmedNotificationEventsSet.iterator();\n\n\t\t\twhile (itr2.hasNext()) {\n\t\t\t\tMap.Entry<String, NotificationEvent> entry =\n\t\t\t\t\titr2.next();\n\n\t\t\t\tNotificationEvent notificationEvent = entry.getValue();\n\n\t\t\t\tif (isRemoveNotificationEvent(notificationEvent, currentTime)) {\n\t\t\t\t\tinvalidNotificationEventUuids.add(entry.getKey());\n\n\t\t\t\t\titr2.remove();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (PropsValues.USER_NOTIFICATION_EVENT_CONFIRMATION_ENABLED &&\n\t\t\t\t!invalidNotificationEventUuids.isEmpty()) {\n\n\t\t\t\tUserNotificationEventLocalServiceUtil.\n\t\t\t\t\tdeleteUserNotificationEvents(invalidNotificationEventUuids);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new ChannelException(\n\t\t\t\t\"Unable to clean up channel \" + getUserId(), e);\n\t\t}\n\t\tfinally {\n\t\t\t_reentrantLock.unlock();\n\t\t}\n\t}","commit_id":"5b11310909ee9703129c344a0c8661d437d31e21","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void confirmDelivery(Collection<String> notificationEventUuids)\n\t\tthrows ChannelException {\n\n\t\t_reentrantLock.lock();\n\n\t\ttry {\n\t\t\tfor (String notificationEventUuid : notificationEventUuids) {\n\t\t\t\t_getUnconfirmedNotificationEvents().remove(\n\t\t\t\t\tnotificationEventUuid);\n\t\t\t}\n\n\t\t\tif (PropsValues.USER_NOTIFICATION_EVENT_CONFIRMATION_ENABLED) {\n\t\t\t\tUserNotificationEventLocalServiceUtil.\n\t\t\t\t\tdeleteUserNotificationEvents(notificationEventUuids);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new ChannelException(\n\t\t\t\t\"Unable to confirm delivery for user \" + getUserId() , e);\n\t\t}\n\t\tfinally {\n\t\t\t_reentrantLock.unlock();\n\t\t}\n\t}","id":75118,"modified_method":"public void confirmDelivery(Collection<String> notificationEventUuids)\n\t\tthrows ChannelException {\n\n\t\t_reentrantLock.lock();\n\n\t\ttry {\n\t\t\tfor (String notificationEventUuid : notificationEventUuids) {\n\t\t\t\tMap<String, NotificationEvent> unconfirmedNotificationEvents =\n\t\t\t\t\t_getUnconfirmedNotificationEvents();\n\n\t\t\t\tunconfirmedNotificationEvents.remove(notificationEventUuid);\n\t\t\t}\n\n\t\t\tif (PropsValues.USER_NOTIFICATION_EVENT_CONFIRMATION_ENABLED) {\n\t\t\t\tUserNotificationEventLocalServiceUtil.\n\t\t\t\t\tdeleteUserNotificationEvents(notificationEventUuids);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new ChannelException(\n\t\t\t\t\"Unable to confirm delivery for user \" + getUserId() , e);\n\t\t}\n\t\tfinally {\n\t\t\t_reentrantLock.unlock();\n\t\t}\n\t}","commit_id":"5b11310909ee9703129c344a0c8661d437d31e21","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected List<NotificationEvent> doGetNotificationEvents(boolean flush)\n\t\tthrows Exception {\n\n\t\tTreeSet<NotificationEvent> notificationEventsSet =\n\t\t\t_getNotificationEvents();\n\n\t\tMap<String, NotificationEvent> unconfirmedNotificationEvents =\n\t\t\t_getUnconfirmedNotificationEvents();\n\n\t\tList<NotificationEvent> notificationEvents =\n\t\t\tnew ArrayList<NotificationEvent>(\n\t\t\t\tnotificationEventsSet.size() +\n\t\t\t\t\tunconfirmedNotificationEvents.size());\n\n\t\tlong currentTime = System.currentTimeMillis();\n\n\t\tfor (NotificationEvent notificationEvent : notificationEventsSet) {\n\t\t\tif (isRemoveNotificationEvent(notificationEvent, currentTime)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnotificationEvents.add(notificationEvent);\n\t\t\t}\n\t\t}\n\n\t\tif (flush) {\n\t\t\tnotificationEventsSet.clear();\n\t\t}\n\t\telse if (notificationEventsSet.size() != notificationEvents.size()) {\n\t\t\tnotificationEventsSet.retainAll(notificationEvents);\n\t\t}\n\n\t\tList<String> invalidNotificationEventUuids = new ArrayList<String>(\n\t\t\tunconfirmedNotificationEvents.size());\n\n\t\tIterator<Map.Entry<String, NotificationEvent>> itr =\n\t\t\tunconfirmedNotificationEvents.entrySet().iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tMap.Entry<String, NotificationEvent> entry = itr.next();\n\n\t\t\tNotificationEvent notificationEvent = entry.getValue();\n\n\t\t\tif (isRemoveNotificationEvent(notificationEvent, currentTime)) {\n\t\t\t\tinvalidNotificationEventUuids.add(\n\t\t\t\t\tnotificationEvent.getUuid());\n\n\t\t\t\titr.remove();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnotificationEvents.add(entry.getValue());\n\t\t\t}\n\t\t}\n\n\t\tif (PropsValues.USER_NOTIFICATION_EVENT_CONFIRMATION_ENABLED &&\n\t\t\t!invalidNotificationEventUuids.isEmpty()) {\n\n\t\t\tUserNotificationEventLocalServiceUtil.deleteUserNotificationEvents(\n\t\t\t\tinvalidNotificationEventUuids);\n\t\t}\n\n\t\treturn notificationEvents;\n\t}","id":75119,"modified_method":"protected List<NotificationEvent> doGetNotificationEvents(boolean flush)\n\t\tthrows Exception {\n\n\t\tlong currentTime = System.currentTimeMillis();\n\n\t\tTreeSet<NotificationEvent> notificationEventsSet =\n\t\t\t_getNotificationEvents();\n\n\t\tMap<String, NotificationEvent> unconfirmedNotificationEvents =\n\t\t\t_getUnconfirmedNotificationEvents();\n\n\t\tList<NotificationEvent> notificationEvents =\n\t\t\tnew ArrayList<NotificationEvent>(\n\t\t\t\tnotificationEventsSet.size() +\n\t\t\t\t\tunconfirmedNotificationEvents.size());\n\n\t\tfor (NotificationEvent notificationEvent : notificationEventsSet) {\n\t\t\tif (isRemoveNotificationEvent(notificationEvent, currentTime)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnotificationEvents.add(notificationEvent);\n\t\t\t}\n\t\t}\n\n\t\tif (flush) {\n\t\t\tnotificationEventsSet.clear();\n\t\t}\n\t\telse if (notificationEventsSet.size() != notificationEvents.size()) {\n\t\t\tnotificationEventsSet.retainAll(notificationEvents);\n\t\t}\n\n\t\tList<String> invalidNotificationEventUuids = new ArrayList<String>(\n\t\t\tunconfirmedNotificationEvents.size());\n\n\t\tSet<Map.Entry<String, NotificationEvent>>\n\t\t\tunconfirmedNotificationEventsSet =\n\t\t\t\tunconfirmedNotificationEvents.entrySet();\n\n\t\tIterator<Map.Entry<String, NotificationEvent>> itr =\n\t\t\tunconfirmedNotificationEventsSet.iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tMap.Entry<String, NotificationEvent> entry = itr.next();\n\n\t\t\tNotificationEvent notificationEvent = entry.getValue();\n\n\t\t\tif (isRemoveNotificationEvent(notificationEvent, currentTime)) {\n\t\t\t\tinvalidNotificationEventUuids.add(\n\t\t\t\t\tnotificationEvent.getUuid());\n\n\t\t\t\titr.remove();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnotificationEvents.add(entry.getValue());\n\t\t\t}\n\t\t}\n\n\t\tif (PropsValues.USER_NOTIFICATION_EVENT_CONFIRMATION_ENABLED &&\n\t\t\t!invalidNotificationEventUuids.isEmpty()) {\n\n\t\t\tUserNotificationEventLocalServiceUtil.deleteUserNotificationEvents(\n\t\t\t\tinvalidNotificationEventUuids);\n\t\t}\n\n\t\treturn notificationEvents;\n\t}","commit_id":"5b11310909ee9703129c344a0c8661d437d31e21","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private Object doGetAdapter(Class adapter) {\n\t\tif (adapter==IActionFilter.class) {\n\t\t\treturn new IActionFilter() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic boolean testAttribute(Object target, String name, String value) {\n\t\t\t\t\tif (!(target instanceof JcrNode)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tfinal JcrNode node = (JcrNode)target;\n\t\t\t\t\tif (\"domNode\".equals(name)) {\n\t\t\t\t\t\treturn node.domElement!=null;\t\n\t\t\t\t\t}\n\t\t\t\t\tif (\"nonDomNode\".equals(name)) {\n\t\t\t\t\t\treturn node.domElement==null;\t\n\t\t\t\t\t}\n\t\t\t\t\tif (\"browseableNode\".equals(name)) {\n\t\t\t\t\t\treturn node.isBrowsable();\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t};\n\t\t} else if (adapter==ITabbedPropertySheetPageContributor.class && \"christmas\".equals(\"christmas\")) {\n\t\t\treturn new ITabbedPropertySheetPageContributor() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic String getContributorId() {\n\t\t\t\t\treturn \"org.apache.sling.ide.eclipse-ui.propertyContributor1\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t};\n\t\t} else if (adapter==IPropertySource.class) {\n\t\t\treturn properties;\n\t\t} else if (adapter == IFile.class) {\n\t\t\tif (resource instanceof IFile) {\n\t\t\t\treturn (IFile)resource;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else if (adapter == IContributorResourceAdapter.class) {\n\t\t\t//if (resource==null) {\n\t\t\t//\treturn null;\n\t\t\t//}\n\t\t\treturn new IContributorResourceAdapter() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic IResource getAdaptedResource(IAdaptable adaptable) {\n\t\t\t\t\tif (!(adaptable instanceof JcrNode)) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tJcrNode node = (JcrNode)adaptable;\n\t\t\t\t\tif (node.resource!=null) {\n\t\t\t\t\t\treturn node.resource;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn node.underlying.file;\n\t\t\t\t\t}\n//\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t};\n\t\t} else if (adapter == IResource.class) {\n\t\t\tif (resource!=null) {\n\t\t\t\treturn resource;\n\t\t\t} else {\n\t\t\t\treturn null;//underlying.file;\n\t\t\t}\n\t\t} else if (adapter == ResourceMapping.class) { \n\t\t\tboolean t = true;\n\t\t\tif (!t) {\n\t\t\t\treturn null;\n\t\t\t}\n//\t\t\tif (resource==null) {\n//\t\t\t\treturn null;\n//\t\t\t}\n\t\t\treturn new ResourceMapping() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic ResourceTraversal[] getTraversals(ResourceMappingContext context,\n\t\t\t\t\t\tIProgressMonitor monitor) throws CoreException {\n\t\t\t\t\tif (resource!=null) {\n\t\t\t\t\t\treturn new ResourceTraversal[] { new ResourceTraversal(new IResource[] { resource }, IResource.DEPTH_INFINITE, IResource.NONE) };\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn new ResourceTraversal[] { new ResourceTraversal(new IResource[] { underlying.file }, IResource.DEPTH_INFINITE, IResource.NONE) };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic IProject[] getProjects() {\n\t\t\t\t\tif (resource!=null) {\n\t\t\t\t\t\treturn new IProject[] {resource.getProject()};\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn new IProject[] {underlying.file.getProject()};\n\t\t\t\t\t}\n//\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic String getModelProviderId() {\n\t\t\t\t\treturn \"org.apache.sling.ide.eclipse.ui.nav.model.JcrNode.ResourceMapping\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic Object getModelObject() {\n\t\t\t\t\tif (resource!=null) {\n\t\t\t\t\t\treturn resource;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn underlying.file;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\treturn null;\n\t}","id":75120,"modified_method":"private Object doGetAdapter(Class adapter) {\n\t\tif (adapter==IActionFilter.class) {\n\t\t\treturn new IActionFilter() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic boolean testAttribute(Object target, String name, String value) {\n\t\t\t\t\tif (!(target instanceof JcrNode)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tfinal JcrNode node = (JcrNode)target;\n\t\t\t\t\tif (\"domNode\".equals(name)) {\n\t\t\t\t\t\treturn node.domElement!=null;\t\n\t\t\t\t\t}\n\t\t\t\t\tif (\"nonDomNode\".equals(name)) {\n\t\t\t\t\t\treturn node.domElement==null;\t\n\t\t\t\t\t}\n\t\t\t\t\tif (\"browseableNode\".equals(name)) {\n\t\t\t\t\t\treturn node.isBrowsable();\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t};\n\t\t} else if (adapter==ITabbedPropertySheetPageContributor.class && \"christmas\".equals(\"christmas\")) {\n\t\t\treturn new ITabbedPropertySheetPageContributor() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic String getContributorId() {\n\t\t\t\t\treturn \"org.eclipse.ui.navigator.ProjectExplorer\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t};\n\t\t} else if (adapter==IPropertySource.class) {\n\t\t\treturn null;//properties;\n\t\t} else if (adapter == IFile.class) {\n\t\t\tif (resource instanceof IFile) {\n\t\t\t\treturn (IFile)resource;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else if (adapter == IContributorResourceAdapter.class) {\n\t\t\t//if (resource==null) {\n\t\t\t//\treturn null;\n\t\t\t//}\n\t\t\treturn new IContributorResourceAdapter() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic IResource getAdaptedResource(IAdaptable adaptable) {\n\t\t\t\t\tif (!(adaptable instanceof JcrNode)) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tJcrNode node = (JcrNode)adaptable;\n\t\t\t\t\tif (node.resource!=null) {\n\t\t\t\t\t\treturn node.resource;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn node.underlying.file;\n\t\t\t\t\t}\n//\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t};\n\t\t} else if (adapter == IResource.class) {\n\t\t\tif (resource!=null) {\n\t\t\t\treturn resource;\n\t\t\t} else {\n\t\t\t\treturn null;//underlying.file;\n\t\t\t}\n\t\t} else if (adapter == ResourceMapping.class) { \n\t\t\tboolean t = true;\n\t\t\tif (!t) {\n\t\t\t\treturn null;\n\t\t\t}\n//\t\t\tif (resource==null) {\n//\t\t\t\treturn null;\n//\t\t\t}\n\t\t\treturn new ResourceMapping() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic ResourceTraversal[] getTraversals(ResourceMappingContext context,\n\t\t\t\t\t\tIProgressMonitor monitor) throws CoreException {\n\t\t\t\t\tif (resource!=null) {\n\t\t\t\t\t\treturn new ResourceTraversal[] { new ResourceTraversal(new IResource[] { resource }, IResource.DEPTH_INFINITE, IResource.NONE) };\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn new ResourceTraversal[] { new ResourceTraversal(new IResource[] { underlying.file }, IResource.DEPTH_INFINITE, IResource.NONE) };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic IProject[] getProjects() {\n\t\t\t\t\tif (resource!=null) {\n\t\t\t\t\t\treturn new IProject[] {resource.getProject()};\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn new IProject[] {underlying.file.getProject()};\n\t\t\t\t\t}\n//\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic String getModelProviderId() {\n\t\t\t\t\treturn \"org.apache.sling.ide.eclipse.ui.nav.model.JcrNode.ResourceMapping\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic Object getModelObject() {\n\t\t\t\t\tif (resource!=null) {\n\t\t\t\t\t\treturn resource;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn underlying.file;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\treturn null;\n\t}","commit_id":"4bb1b17e41a92e62bd68f76f5a64e25a2552522d","url":"https://github.com/apache/sling"},{"original_method":"private void hookContextMenu() {\n\t\tMenuManager menuMgr = new MenuManager(\"#PopupMenu\");\n\t\tmenuMgr.setRemoveAllWhenShown(true);\n\t\tmenuMgr.addMenuListener(new IMenuListener() {\n\t\t\tpublic void menuAboutToShow(IMenuManager manager) {\n\t\t\t\tJcrPropertiesView.this.fillContextMenu(manager);\n\t\t\t}\n\t\t});\n\t\tMenu menu = menuMgr.createContextMenu(viewer.getControl());\n\t\tviewer.getControl().setMenu(menu);\n\t\tgetSite().registerContextMenu(menuMgr, viewer);\n\t}","id":75121,"modified_method":"private void hookContextMenu() {\n\t\tMenuManager menuMgr = new MenuManager(\"#PopupMenu\");\n\t\tmenuMgr.setRemoveAllWhenShown(true);\n\t\tmenuMgr.addMenuListener(new IMenuListener() {\n\t\t\tpublic void menuAboutToShow(IMenuManager manager) {\n\t\t\t\tJcrPropertiesView.this.fillContextMenu(manager);\n\t\t\t}\n\t\t});\n\t\tMenu menu = menuMgr.createContextMenu(viewer.getControl());\n\t\tviewer.getControl().setMenu(menu);\n\t\tIWorkbenchPartSite site = getSite();\n\t\tif (site!=null) {\n\t\t    site.registerContextMenu(menuMgr, viewer);\n\t\t}\n\t}","commit_id":"4bb1b17e41a92e62bd68f76f5a64e25a2552522d","url":"https://github.com/apache/sling"},{"original_method":"private void fillContextMenu(IMenuManager manager) {\n\t\tmanager.add(insertAction);\n        manager.add(deleteAction);\n        manager.add(showInEditorAction);\n        manager.add(pinAction);\n        manager.add(synchedAction);\n\t\t// Other plug-ins can contribute there actions here\n\t\tmanager.add(new Separator(IWorkbenchActionConstants.MB_ADDITIONS));\n\t}","id":75122,"modified_method":"private void fillContextMenu(IMenuManager manager) {\n\t\tmanager.add(insertAction);\n        manager.add(deleteAction);\n        manager.add(showInEditorAction);\n        if (pinAction!=null) {\n            manager.add(pinAction);\n        }\n        if (synchedAction!=null) {\n            manager.add(synchedAction);\n        }\n\t\t// Other plug-ins can contribute there actions here\n\t\tmanager.add(new Separator(IWorkbenchActionConstants.MB_ADDITIONS));\n\t}","commit_id":"4bb1b17e41a92e62bd68f76f5a64e25a2552522d","url":"https://github.com/apache/sling"},{"original_method":"private void contributeToActionBars() {\n\t\tIActionBars bars = getViewSite().getActionBars();\n\t\tfillLocalPullDown(bars.getMenuManager());\n\t\tfillLocalToolBar(bars.getToolBarManager());\n\t}","id":75123,"modified_method":"private void contributeToActionBars() {\n\t    if (getViewSite()!=null) {\n    \t\tIActionBars bars = getViewSite().getActionBars();\n    \t\tfillLocalPullDown(bars.getMenuManager());\n    \t\tfillLocalToolBar(bars.getToolBarManager());\n\t    }\n\t}","commit_id":"4bb1b17e41a92e62bd68f76f5a64e25a2552522d","url":"https://github.com/apache/sling"},{"original_method":"private void makeActions() {\n\t\tinsertAction = new Action() {\n\t\t\tpublic void run() {\n\t\t\t    NewRow newRow = new NewRow();\n\t\t\t    viewer.add(newRow);\n\t\t\t    viewer.getTable().setTopIndex(viewer.getTable().getItemCount());\n\t\t\t    viewer.getTable().select(viewer.getTable().getItemCount()-1);\n\t\t\t    viewer.editElement(newRow, 0);\n\t\t\t}\n\t\t};\n\t\tinsertAction.setText(\"Insert\");\n\t\tinsertAction.setToolTipText(\"Insert a property\");\n\t\tinsertAction.setImageDescriptor(PlatformUI.getWorkbench().getSharedImages().\n\t\t\tgetImageDescriptor(ISharedImages.IMG_OBJ_ADD));\n\t\t\n\t\tdeleteAction = new Action() {\n\t\t\tpublic void run() {\n\t\t\t    if (viewer.getSelection().isEmpty()) {\n\t\t\t        return;\n\t\t\t    }\n\t\t\t    ISelection sel = viewer.getSelection();\n\t\t\t    if (sel instanceof IStructuredSelection) {\n\t\t\t        IStructuredSelection iss = (IStructuredSelection)sel;\n\t\t\t        Object elem = iss.getFirstElement();\n\t\t\t        if (elem instanceof IPropertyDescriptor) {\n\t\t\t            IPropertyDescriptor pd = (IPropertyDescriptor)elem;\n\t\t\t            JcrNode jcrnode = (JcrNode)viewer.getInput();\n\t\t\t            jcrnode.deleteProperty(pd.getDisplayName());\n\t\t\t            refreshContent();\n\t\t\t        }\n\t\t\t    }\n\t\t\t}\n\t\t};\n\t\tdeleteAction.setText(\"Delete\");\n\t\tdeleteAction.setToolTipText(\"Delete a proeprty\");\n\t\tdeleteAction.setImageDescriptor(PlatformUI.getWorkbench().getSharedImages().\n\t\t\t\tgetImageDescriptor(ISharedImages.IMG_TOOL_DELETE));\n\t\tdoubleClickAction = new Action() {\n\t\t\tpublic void run() {\n\t\t\t    //TODO doesn't do anything currently..\n\t\t\t\tISelection selection = viewer.getSelection();\n//\t\t\t\tObject obj = ((IStructuredSelection)selection).getFirstElement();\n//\t\t\t\tshowMessage(\"Double-click detected on \"+obj.toString());\n\t\t\t}\n\t\t};\n\t\t\n\t\tshowInEditorAction = new Action() {\n\t\t    public void run() {\n\t\t        \n\t\t        JcrNode node = (JcrNode)viewer.getInput();\n                final IFile file = node.getFileForEditor();\n                if (file!=null) {\n                    try {\n                        IDE.openEditor(getViewSite().getPage(), file, true);\n                    } catch (PartInitException e) {\n                        e.printStackTrace(System.out);\n                    }\n                }\n\t\t    }\n\t\t};\n\t\tshowInEditorAction.setText(\"Show in editor\");\n\t\tshowInEditorAction.setToolTipText(\"Show underlying vault file in editor\");\n\t\tshowInEditorAction.setImageDescriptor(PlatformUI.getWorkbench().getSharedImages().\n                getImageDescriptor(ISharedImages.IMG_OBJ_FILE));\n\t\t\n\t\tpinAction = new Action(\"pin to selection\", IAction.AS_CHECK_BOX) {\n\t\t    public void run() {\n\t\t        if (!pinAction.isChecked()) {\n\t\t            // unpin\n\t\t            setContentDescription(\"\");\n\t\t            setInput(lastInput);\n\t\t        } else {\n\t\t            setContentDescription(\"[pinned]\");\n\t\t        }\n\t\t        // toggle state of syncedAction accordingly\n\t\t        synchedAction.setEnabled(!pinAction.isChecked());\n\t\t    }\n\t\t};\n\t\tpinAction.setText(\"Pin to selection\");\n\t\tpinAction.setToolTipText(\"Pin this property view to the current selection\");\n\t\tpinAction.setImageDescriptor(WorkbenchImages\n                .getImageDescriptor(IWorkbenchGraphicConstants.IMG_ETOOL_PIN_EDITOR));\n\t\tpinAction.setDisabledImageDescriptor(WorkbenchImages\n                .getImageDescriptor(IWorkbenchGraphicConstants.IMG_ETOOL_PIN_EDITOR_DISABLED));\n\t\tpinAction.setChecked(false);\n\t\t\n\t\tsynchedAction = new Action(\"Link with Editor and selection\", IAction.AS_CHECK_BOX) {\n            public void run() {\n                // toggle state of pinAction accordingly\n                pinAction.setEnabled(!synchedAction.isChecked());\n            }\n        };\n        synchedAction.setText(\"Link with Editor and selection\");\n        synchedAction.setToolTipText(\"Link with Editor and selection\");\n        synchedAction.setImageDescriptor(WorkbenchImages\n                .getImageDescriptor(ISharedImages.IMG_ELCL_SYNCED));\n        synchedAction.setDisabledImageDescriptor(WorkbenchImages\n                .getImageDescriptor(ISharedImages.IMG_ELCL_SYNCED_DISABLED));\n        synchedAction.setChecked(true);\n\t}","id":75124,"modified_method":"private void makeActions() {\n\t\tinsertAction = new Action() {\n\t\t\tpublic void run() {\n\t\t\t    NewRow newRow = new NewRow();\n\t\t\t    viewer.add(newRow);\n\t\t\t    viewer.getTable().setTopIndex(viewer.getTable().getItemCount());\n\t\t\t    viewer.getTable().select(viewer.getTable().getItemCount()-1);\n\t\t\t    viewer.editElement(newRow, 0);\n\t\t\t}\n\t\t};\n\t\tinsertAction.setText(\"Insert\");\n\t\tinsertAction.setToolTipText(\"Insert a property\");\n\t\tinsertAction.setImageDescriptor(PlatformUI.getWorkbench().getSharedImages().\n\t\t\tgetImageDescriptor(ISharedImages.IMG_OBJ_ADD));\n\t\t\n\t\tdeleteAction = new Action() {\n\t\t\tpublic void run() {\n\t\t\t    if (viewer.getSelection().isEmpty()) {\n\t\t\t        return;\n\t\t\t    }\n\t\t\t    ISelection sel = viewer.getSelection();\n\t\t\t    if (sel instanceof IStructuredSelection) {\n\t\t\t        IStructuredSelection iss = (IStructuredSelection)sel;\n\t\t\t        Object elem = iss.getFirstElement();\n\t\t\t        if (elem instanceof IPropertyDescriptor) {\n\t\t\t            IPropertyDescriptor pd = (IPropertyDescriptor)elem;\n\t\t\t            JcrNode jcrnode = (JcrNode)viewer.getInput();\n\t\t\t            jcrnode.deleteProperty(pd.getDisplayName());\n\t\t\t            refreshContent();\n\t\t\t        }\n\t\t\t    }\n\t\t\t}\n\t\t};\n\t\tdeleteAction.setText(\"Delete\");\n\t\tdeleteAction.setToolTipText(\"Delete a proeprty\");\n\t\tdeleteAction.setImageDescriptor(PlatformUI.getWorkbench().getSharedImages().\n\t\t\t\tgetImageDescriptor(ISharedImages.IMG_TOOL_DELETE));\n\t\tdoubleClickAction = new Action() {\n\t\t\tpublic void run() {\n\t\t\t    //TODO doesn't do anything currently..\n\t\t\t\tISelection selection = viewer.getSelection();\n//\t\t\t\tObject obj = ((IStructuredSelection)selection).getFirstElement();\n//\t\t\t\tshowMessage(\"Double-click detected on \"+obj.toString());\n\t\t\t}\n\t\t};\n\t\t\n\t\tshowInEditorAction = new Action() {\n\t\t    public void run() {\n\t\t        \n\t\t        JcrNode node = (JcrNode)viewer.getInput();\n                final IFile file = node.getFileForEditor();\n                if (file!=null) {\n                    try {\n                        IDE.openEditor(getPage(), file, true);\n                    } catch (PartInitException e) {\n                        e.printStackTrace(System.out);\n                    }\n                }\n\t\t    }\n\t\t};\n\t\tshowInEditorAction.setText(\"Show in editor\");\n\t\tshowInEditorAction.setToolTipText(\"Show underlying vault file in editor\");\n\t\tshowInEditorAction.setImageDescriptor(PlatformUI.getWorkbench().getSharedImages().\n                getImageDescriptor(ISharedImages.IMG_OBJ_FILE));\n\t\t\n\t\tif (getViewSite()!=null) {\n    \t\tpinAction = new Action(\"pin to selection\", IAction.AS_CHECK_BOX) {\n    \t\t    public void run() {\n    \t\t        if (!pinAction.isChecked()) {\n    \t\t            // unpin\n    \t\t            setContentDescription(\"\");\n    \t\t            setInput(lastInput);\n    \t\t        } else {\n    \t\t            setContentDescription(\"[pinned]\");\n    \t\t        }\n    \t\t        // toggle state of syncedAction accordingly\n    \t\t        if (synchedAction!=null) {\n    \t\t            synchedAction.setEnabled(!pinAction.isChecked());\n    \t\t        }\n    \t\t    }\n    \t\t};\n    \t\tpinAction.setText(\"Pin to selection\");\n    \t\tpinAction.setToolTipText(\"Pin this property view to the current selection\");\n    \t\tpinAction.setImageDescriptor(WorkbenchImages\n                    .getImageDescriptor(IWorkbenchGraphicConstants.IMG_ETOOL_PIN_EDITOR));\n    \t\tpinAction.setDisabledImageDescriptor(WorkbenchImages\n                    .getImageDescriptor(IWorkbenchGraphicConstants.IMG_ETOOL_PIN_EDITOR_DISABLED));\n    \t\tpinAction.setChecked(false);\n\t\t\n    \t\tsynchedAction = new Action(\"Link with Editor and selection\", IAction.AS_CHECK_BOX) {\n                public void run() {\n                    // toggle state of pinAction accordingly\n                    pinAction.setEnabled(!synchedAction.isChecked());\n                }\n            };\n            synchedAction.setText(\"Link with Editor and selection\");\n            synchedAction.setToolTipText(\"Link with Editor and selection\");\n            synchedAction.setImageDescriptor(WorkbenchImages\n                    .getImageDescriptor(ISharedImages.IMG_ELCL_SYNCED));\n            synchedAction.setDisabledImageDescriptor(WorkbenchImages\n                    .getImageDescriptor(ISharedImages.IMG_ELCL_SYNCED_DISABLED));\n            synchedAction.setChecked(true);\n\t\t}\n\t}","commit_id":"4bb1b17e41a92e62bd68f76f5a64e25a2552522d","url":"https://github.com/apache/sling"},{"original_method":"private void fillLocalToolBar(IToolBarManager manager) {\n\t\tmanager.add(insertAction);\n\t\tmanager.add(deleteAction);\n        manager.add(showInEditorAction);\n        manager.add(pinAction);\n        manager.add(synchedAction);\n\t}","id":75125,"modified_method":"private void fillLocalToolBar(IToolBarManager manager) {\n\t\tmanager.add(insertAction);\n\t\tmanager.add(deleteAction);\n        manager.add(showInEditorAction);\n        if (pinAction!=null) {\n            manager.add(pinAction);\n        }\n        if (synchedAction!=null) {\n            manager.add(synchedAction);\n        }\n\t}","commit_id":"4bb1b17e41a92e62bd68f76f5a64e25a2552522d","url":"https://github.com/apache/sling"},{"original_method":"/**\n\t * This is a callback that will allow us\n\t * to create the viewer and initialize it.\n\t */\n\tpublic void createPartControl(Composite parent) {\n\t    SyncDirManager.registerUpdateListener(new UpdateHandler() {\n            \n            @Override\n            public void syncDirUpdated(SyncDir syncDir) {\n                refreshContent();\n            }\n        });\n\t    \n\t    Composite c = new Composite(parent, SWT.NONE);\n\t    final GridLayout gridLayout = new GridLayout(1, true);\n        c.setLayout(gridLayout);\n\t    \n        titleLabel = new Label(c, SWT.WRAP);\n        titleLabel.setText(\"\");\n        GridData data = new GridData(GridData.FILL_HORIZONTAL);\n        titleLabel.setLayoutData(data);\n        \n        Label horizontalLine = new Label(c, SWT.SEPARATOR | SWT.HORIZONTAL);\n        data = new GridData(GridData.FILL_HORIZONTAL);\n        horizontalLine.setLayoutData(data);\n        Font font;\n        if (! JFaceResources.getFontRegistry().hasValueFor(TITLE_FONT)) {\n            FontData[] fontData = JFaceResources.getFontRegistry().getBold(\n                    JFaceResources.DEFAULT_FONT).getFontData();\n            /* title font is 2pt larger than that used in the tabs. */  \n            fontData[0].setHeight(fontData[0].getHeight() + 2);\n            JFaceResources.getFontRegistry().put(TITLE_FONT, fontData);\n        }\n        font = JFaceResources.getFont(TITLE_FONT);\n        titleLabel.setFont(font);\n\n        Composite tableParent = new Composite(c, SWT.NONE);\n        tableParent.setLayoutData(new GridData(GridData.FILL_BOTH));\n        TableColumnLayout tableLayout = new TableColumnLayout();\n        tableParent.setLayout(tableLayout);\n        \n        viewer = new TableViewer(tableParent, SWT.SINGLE | SWT.H_SCROLL | SWT.V_SCROLL | SWT.BORDER | SWT.HIDE_SELECTION | SWT.FULL_SELECTION);\n        TableViewerFocusCellManager focusCellManager = new TableViewerFocusCellManager(\n                viewer, new FocusCellOwnerDrawHighlighter(viewer), new CellNavigationStrategy());\n        ColumnViewerEditorActivationStrategy actSupport = new ColumnViewerEditorActivationStrategy(\n                viewer){\n\n            @Override\n            protected boolean isEditorActivationEvent(\n                    ColumnViewerEditorActivationEvent event) {\n                resetLastValueEdited();\n                return event.eventType == ColumnViewerEditorActivationEvent.TRAVERSAL\n                        || event.eventType == ColumnViewerEditorActivationEvent.MOUSE_DOUBLE_CLICK_SELECTION\n                        || (event.eventType == ColumnViewerEditorActivationEvent.KEY_PRESSED && event.keyCode == SWT.CR)\n                        || event.eventType == ColumnViewerEditorActivationEvent.PROGRAMMATIC;\n            }\n        };\n        int features = ColumnViewerEditor.TABBING_HORIZONTAL\n                | ColumnViewerEditor.TABBING_MOVE_TO_ROW_NEIGHBOR\n                | ColumnViewerEditor.TABBING_VERTICAL\n                | ColumnViewerEditor.KEYBOARD_ACTIVATION\n                | ColumnViewerEditor.KEEP_EDITOR_ON_DOUBLE_CLICK;\n        TableViewerEditor.create(viewer, focusCellManager, actSupport, features);\n        viewer.getTable().setLinesVisible(true);\n        viewer.getTable().setHeaderVisible(true);\n        viewer.setContentProvider(new ViewContentProvider());\n\t\tviewer.addSelectionChangedListener(new ISelectionChangedListener() {\n            \n            @Override\n            public void selectionChanged(SelectionChangedEvent event) {\n                final ISelection selection = event.getSelection();\n                if (selection instanceof IStructuredSelection) {\n                    IStructuredSelection iss = (IStructuredSelection)selection;\n                    if (iss.isEmpty()) {\n                        deleteAction.setEnabled(false);\n                    } else {\n                        deleteAction.setEnabled(true);\n                    }\n                } else {\n                    deleteAction.setEnabled(false);\n                }\n            }\n        });\n\t\t\n\t\tCellLabelProvider clp = new JcrCellLabelProvider(viewer);\n\n\t\tTableViewerColumn column0 = new TableViewerColumn(viewer, SWT.NONE);\n\t\tcolumn0.getColumn().setText(\"Name\");\n\t\tcolumn0.getColumn().setResizable(true);\n\t\tcolumn0.getColumn().setWidth(200);\n        tableLayout.setColumnData(column0.getColumn(), new ColumnWeightData(30, 150));\n\n        final TableViewerColumn column1 = new TableViewerColumn(viewer, SWT.NONE);\n        column1.getColumn().setText(\"Type\");\n        column1.getColumn().setResizable(true);\n        column1.getColumn().setWidth(300);\n        column1.setLabelProvider(clp);\n        tableLayout.setColumnData(column1.getColumn(), new ColumnWeightData(10, 80));\n        \n        final TableViewerColumn column2 = new TableViewerColumn(viewer, SWT.NONE);\n        column2.getColumn().setText(\"Value\");\n        column2.getColumn().setResizable(true);\n        column2.getColumn().setWidth(300);\n        tableLayout.setColumnData(column2.getColumn(), new ColumnWeightData(70, 250));\n        \n        final TableViewerColumn column3 = new TableViewerColumn(viewer, SWT.NONE);\n        column3.getColumn().setText(\"Protected\");\n        column3.getColumn().setResizable(true);\n        column3.getColumn().setWidth(300);\n        column3.setLabelProvider(clp);\n        tableLayout.setColumnData(column3.getColumn(), new ColumnWeightData(5, 57));\n\n        final TableViewerColumn column4 = new TableViewerColumn(viewer, SWT.NONE);\n        column4.getColumn().setText(\"Mandatory\");\n        column4.getColumn().setResizable(true);\n        column4.getColumn().setWidth(300);\n        column4.setLabelProvider(clp);\n        tableLayout.setColumnData(column4.getColumn(), new ColumnWeightData(5, 62));\n\n        final TableViewerColumn column5 = new TableViewerColumn(viewer, SWT.NONE);\n        column5.getColumn().setText(\"Multiple\");\n        column5.getColumn().setResizable(true);\n        column5.getColumn().setWidth(300);\n        column5.setLabelProvider(clp);\n        tableLayout.setColumnData(column5.getColumn(), new ColumnWeightData(5, 82));\n\n        final TableViewerColumn column6 = new TableViewerColumn(viewer, SWT.NONE);\n        column6.getColumn().setText(\"Auto Created\");\n        column6.getColumn().setResizable(true);\n        column6.getColumn().setWidth(300);\n        column6.setLabelProvider(clp);\n        tableLayout.setColumnData(column6.getColumn(), new ColumnWeightData(5, 77));\n\n        column0.setLabelProvider(clp);\n        column0.setEditingSupport(new JcrEditingSupport(this, viewer, ColumnId.NAME));\n\n        column1.setLabelProvider(clp);\n        column1.setEditingSupport(new JcrEditingSupport(this, viewer, ColumnId.TYPE));\n\n        column2.setLabelProvider(clp);\n\t\tcolumn2.setEditingSupport(new JcrEditingSupport(this, viewer, ColumnId.VALUE));\n\t\n        column5.setEditingSupport(new JcrEditingSupport(this, viewer, ColumnId.MULTIPLE));\n\t\t\n\t\t// Create the help context id for the viewer's control\n\t\tPlatformUI.getWorkbench().getHelpSystem().setHelp(viewer.getControl(), \"org.apache.sling.ide.eclipse-ui.viewer\");\n\t\tmakeActions();\n\t\thookContextMenu();\n\t\thookDoubleClickAction();\n\t\tcontributeToActionBars();\n\t\t\n\t\tlistener = new ISelectionListener() {\n            \n            @Override\n            public void selectionChanged(IWorkbenchPart part, ISelection selection) {\n                if (selection instanceof IStructuredSelection) {\n                    IStructuredSelection iss = (IStructuredSelection)selection;\n                    Object firstElem = iss.getFirstElement();\n                    if (firstElem instanceof JcrNode) {\n                        JcrNode jcrNode = (JcrNode)firstElem;\n                        setInput(jcrNode);\n                        return;\n                    }\n                }\n            }\n        };\n        getViewSite().getPage().addSelectionListener(listener);\n        final ISelection selection = getViewSite().getPage().getSelection();\n        Display.getCurrent().asyncExec(new Runnable() {\n\n            @Override\n            public void run() {\n                listener.selectionChanged(null, selection);\n            }\n            \n        });\n\t}","id":75126,"modified_method":"/**\n\t * This is a callback that will allow us\n\t * to create the viewer and initialize it.\n\t */\n\tpublic void createPartControl(Composite parent) {\n\t    SyncDirManager.registerUpdateListener(new UpdateHandler() {\n            \n            @Override\n            public void syncDirUpdated(SyncDir syncDir) {\n                refreshContent();\n            }\n        });\n\t    \n\t    mainControl = new Composite(parent, SWT.NONE);\n\t    final GridLayout gridLayout = new GridLayout(1, true);\n        mainControl.setLayout(gridLayout);\n\t    \n        if (getViewSite()!=null) {\n            titleLabel = new Label(mainControl, SWT.WRAP);\n            titleLabel.setText(\"\");\n            GridData data = new GridData(GridData.FILL_HORIZONTAL);\n            titleLabel.setLayoutData(data);\n            Label horizontalLine = new Label(mainControl, SWT.SEPARATOR | SWT.HORIZONTAL);\n            data = new GridData(GridData.FILL_HORIZONTAL);\n            horizontalLine.setLayoutData(data);\n        }\n        \n        Font font;\n        if (! JFaceResources.getFontRegistry().hasValueFor(TITLE_FONT)) {\n            FontData[] fontData = JFaceResources.getFontRegistry().getBold(\n                    JFaceResources.DEFAULT_FONT).getFontData();\n            /* title font is 2pt larger than that used in the tabs. */  \n            fontData[0].setHeight(fontData[0].getHeight() + 2);\n            JFaceResources.getFontRegistry().put(TITLE_FONT, fontData);\n        }\n        font = JFaceResources.getFont(TITLE_FONT);\n        if (titleLabel!=null) {\n            titleLabel.setFont(font);\n        }\n\n        Composite tableParent = new Composite(mainControl, SWT.NONE);\n//        tableParent.setBackground(new Color(Display.getDefault(), 100,20,180));\n        GridData tableLayoutData = new GridData(SWT.FILL, SWT.FILL, true, true, 1, 1);\n        tableLayoutData.widthHint = 1; // shrink to min - table settings will resize to correct ratios\n        tableLayoutData.heightHint = SWT.DEFAULT;\n        tableParent.setLayoutData(tableLayoutData);\n        TableColumnLayout tableLayout = new TableColumnLayout() {\n            @Override\n            protected Point computeSize(Composite composite, int wHint,\n                    int hHint, boolean flushCache) {\n                Point p = super.computeSize(composite, wHint, hHint, flushCache);\n                return new Point(p.x, p.y);\n            }\n        };\n        tableParent.setLayout(tableLayout);\n        \n        viewer = new TableViewer(tableParent, SWT.SINGLE | SWT.H_SCROLL | SWT.V_SCROLL | SWT.BORDER | SWT.HIDE_SELECTION | SWT.FULL_SELECTION);\n        TableViewerFocusCellManager focusCellManager = new TableViewerFocusCellManager(\n                viewer, new FocusCellOwnerDrawHighlighter(viewer), new CellNavigationStrategy());\n        ColumnViewerEditorActivationStrategy actSupport = new ColumnViewerEditorActivationStrategy(\n                viewer){\n\n            @Override\n            protected boolean isEditorActivationEvent(\n                    ColumnViewerEditorActivationEvent event) {\n                resetLastValueEdited();\n                return event.eventType == ColumnViewerEditorActivationEvent.TRAVERSAL\n                        || event.eventType == ColumnViewerEditorActivationEvent.MOUSE_DOUBLE_CLICK_SELECTION\n                        || (event.eventType == ColumnViewerEditorActivationEvent.KEY_PRESSED && event.keyCode == SWT.CR)\n                        || event.eventType == ColumnViewerEditorActivationEvent.PROGRAMMATIC;\n            }\n        };\n        int features = ColumnViewerEditor.TABBING_HORIZONTAL\n                | ColumnViewerEditor.TABBING_MOVE_TO_ROW_NEIGHBOR\n                | ColumnViewerEditor.TABBING_VERTICAL\n                | ColumnViewerEditor.KEYBOARD_ACTIVATION\n                | ColumnViewerEditor.KEEP_EDITOR_ON_DOUBLE_CLICK;\n        TableViewerEditor.create(viewer, focusCellManager, actSupport, features);\n        viewer.getTable().setLinesVisible(true);\n        viewer.getTable().setHeaderVisible(true);\n        viewer.setContentProvider(new ViewContentProvider());\n\t\tviewer.addSelectionChangedListener(new ISelectionChangedListener() {\n            \n            @Override\n            public void selectionChanged(SelectionChangedEvent event) {\n                final ISelection selection = event.getSelection();\n                if (selection instanceof IStructuredSelection) {\n                    IStructuredSelection iss = (IStructuredSelection)selection;\n                    if (iss.isEmpty()) {\n                        deleteAction.setEnabled(false);\n                    } else {\n                        deleteAction.setEnabled(true);\n                    }\n                } else {\n                    deleteAction.setEnabled(false);\n                }\n            }\n        });\n\t\t\n\t\tCellLabelProvider clp = new JcrCellLabelProvider(viewer);\n\n\t\tTableViewerColumn column0 = new TableViewerColumn(viewer, SWT.NONE);\n\t\tcolumn0.getColumn().setText(\"Name\");\n\t\tcolumn0.getColumn().setResizable(true);\n\t\tcolumn0.getColumn().setWidth(200);\n        tableLayout.setColumnData(column0.getColumn(), new ColumnWeightData(30, 140));\n\n        final TableViewerColumn column1 = new TableViewerColumn(viewer, SWT.NONE);\n        column1.getColumn().setText(\"Type\");\n        column1.getColumn().setResizable(true);\n        column1.getColumn().setWidth(300);\n        column1.setLabelProvider(clp);\n        tableLayout.setColumnData(column1.getColumn(), new ColumnWeightData(10, 80));\n        \n        final TableViewerColumn column2 = new TableViewerColumn(viewer, SWT.NONE);\n        column2.getColumn().setText(\"Value\");\n        column2.getColumn().setResizable(true);\n        column2.getColumn().setWidth(300);\n        tableLayout.setColumnData(column2.getColumn(), new ColumnWeightData(70, 220));\n        \n        final TableViewerColumn column3 = new TableViewerColumn(viewer, SWT.NONE);\n        column3.getColumn().setText(\"Protected\");\n        column3.getColumn().setResizable(true);\n        column3.getColumn().setWidth(300);\n        column3.setLabelProvider(clp);\n        tableLayout.setColumnData(column3.getColumn(), new ColumnWeightData(5, 57));\n\n        final TableViewerColumn column4 = new TableViewerColumn(viewer, SWT.NONE);\n        column4.getColumn().setText(\"Mandatory\");\n        column4.getColumn().setResizable(true);\n        column4.getColumn().setWidth(300);\n        column4.setLabelProvider(clp);\n        tableLayout.setColumnData(column4.getColumn(), new ColumnWeightData(5, 62));\n\n        final TableViewerColumn column5 = new TableViewerColumn(viewer, SWT.NONE);\n        column5.getColumn().setText(\"Multiple\");\n        column5.getColumn().setResizable(true);\n        column5.getColumn().setWidth(300);\n        column5.setLabelProvider(clp);\n        tableLayout.setColumnData(column5.getColumn(), new ColumnWeightData(5, 82));\n\n        final TableViewerColumn column6 = new TableViewerColumn(viewer, SWT.NONE);\n        column6.getColumn().setText(\"Auto Created\");\n        column6.getColumn().setResizable(true);\n        column6.getColumn().setWidth(300);\n        column6.setLabelProvider(clp);\n        tableLayout.setColumnData(column6.getColumn(), new ColumnWeightData(5, 77));\n\n        column0.setLabelProvider(clp);\n        column0.setEditingSupport(new JcrEditingSupport(this, viewer, ColumnId.NAME));\n\n        column1.setLabelProvider(clp);\n        column1.setEditingSupport(new JcrEditingSupport(this, viewer, ColumnId.TYPE));\n\n        column2.setLabelProvider(clp);\n\t\tcolumn2.setEditingSupport(new JcrEditingSupport(this, viewer, ColumnId.VALUE));\n\t\n        column5.setEditingSupport(new JcrEditingSupport(this, viewer, ColumnId.MULTIPLE));\n\t\t\n\t\t// Create the help context id for the viewer's control\n\t\tPlatformUI.getWorkbench().getHelpSystem().setHelp(viewer.getControl(), \"org.apache.sling.ide.eclipse-ui.viewer\");\n\t\tmakeActions();\n\t\thookContextMenu();\n\t\thookDoubleClickAction();\n\t\tcontributeToActionBars();\n\t\t\n\t\tlistener = new ISelectionListener() {\n            \n            @Override\n            public void selectionChanged(IWorkbenchPart part, ISelection selection) {\n                if (selection instanceof IStructuredSelection) {\n                    IStructuredSelection iss = (IStructuredSelection)selection;\n                    Object firstElem = iss.getFirstElement();\n                    if (firstElem instanceof JcrNode) {\n                        JcrNode jcrNode = (JcrNode)firstElem;\n                        setInput(jcrNode);\n                        return;\n                    }\n                }\n            }\n        };\n        if (getViewSite()!=null) {\n            getViewSite().getPage().addSelectionListener(listener);\n            final ISelection selection = getViewSite().getPage().getSelection();\n            Display.getCurrent().asyncExec(new Runnable() {\n    \n                @Override\n                public void run() {\n                    listener.selectionChanged(null, selection);\n                }\n                \n            });\n        }\n\t}","commit_id":"4bb1b17e41a92e62bd68f76f5a64e25a2552522d","url":"https://github.com/apache/sling"},{"original_method":"private void fillLocalPullDown(IMenuManager manager) {\n\t\tmanager.add(insertAction);\n//\t\tmanager.add(new Separator());\n\t\tmanager.add(deleteAction);\n        manager.add(showInEditorAction);\n        manager.add(pinAction);\n        manager.add(synchedAction);\n\t}","id":75127,"modified_method":"private void fillLocalPullDown(IMenuManager manager) {\n\t\tmanager.add(insertAction);\n//\t\tmanager.add(new Separator());\n\t\tmanager.add(deleteAction);\n        manager.add(showInEditorAction);\n        if (pinAction!=null) {\n            manager.add(pinAction);\n        }\n        if (synchedAction!=null) {\n            manager.add(synchedAction);\n        }\n\t}","commit_id":"4bb1b17e41a92e62bd68f76f5a64e25a2552522d","url":"https://github.com/apache/sling"},{"original_method":"private void setInput(JcrNode jcrNode) {\n        // reset the last edited values..:\n        resetLastValueEdited();\n\n        if (pinAction.isChecked()) {\n            lastInput = jcrNode;\n        } else {\n            if (synchedAction.isChecked()) {\n                getViewSite().getPage().bringToTop(this);\n            }\n            viewer.setInput(jcrNode);\n            titleLabel.setText(jcrNode.getJcrPath());\n            insertAction.setEnabled(!jcrNode.getPrimaryType().equals(\"nt:folder\"));\n            deleteAction.setEnabled(false);\n            showInEditorAction.setEnabled(jcrNode.getFileForEditor()!=null);\n        }\n    }","id":75128,"modified_method":"public void setInput(JcrNode jcrNode) {\n        // reset the last edited values..:\n        resetLastValueEdited();\n\n        if (pinAction!=null && pinAction.isChecked()) {\n            lastInput = jcrNode;\n        } else {\n            if (getViewSite()!=null && synchedAction!=null && synchedAction.isChecked()) {\n                getViewSite().getPage().bringToTop(this);\n            }\n            viewer.setInput(jcrNode);\n            if (titleLabel!=null) {\n                titleLabel.setText(jcrNode.getJcrPath());\n            }\n            insertAction.setEnabled(!jcrNode.getPrimaryType().equals(\"nt:folder\"));\n            deleteAction.setEnabled(false);\n            showInEditorAction.setEnabled(jcrNode.getFileForEditor()!=null);\n        }\n    }","commit_id":"4bb1b17e41a92e62bd68f76f5a64e25a2552522d","url":"https://github.com/apache/sling"},{"original_method":"/**\n\t * added by gopalrc - Nov 2007\n`\t * TODO: should perhaps bemoved to SiteService\n\t * @param siteId\n\t * @return\n\t */\n\tprivate ArrayList getSiteGroupIdsForSubmittingAgent(String agentId, String siteId) {\n\t\t//String functionName=\"assessment.takeAssessment\";\n\t\tCollection siteGroups = null;\n\t\ttry {\n\t\t\tsiteGroups = siteService.getSite(siteId).getGroupsWithMember(agentId);\n\t\t}\n\t\tcatch (IdUnusedException ex) {\n\t\t\t// no site found\n\t\t}\n\t\tfinal ArrayList groupIds = new ArrayList();\n\t\tif (siteGroups == null) {\n\t\t\treturn groupIds;\n\t\t}\n\t\tIterator groupsIter = siteGroups.iterator();\n\t\t// To accomodate the problem with Hibernate and empty array parameters \n\t\t// TODO: this should probably be handled in a more efficient way\n\t\tgroupIds.add(\"none\");  \n\t\twhile (groupsIter.hasNext()) {\n\t\t\tGroup group = (Group) groupsIter.next(); \n\t\t\t// TODO: Does this conditional check need to be done,\n\t\t\t// or is it sufficient thet the individual is in the group\n\t\t\t//if (securityService.unlock(functionName, group.getReference())) {\n\t\t\t\tgroupIds.add(group.getId());\n\t\t\t//}\n\t\t}\n\t\treturn groupIds;\n\t}","id":75129,"modified_method":"/**\n\t * added by gopalrc - Nov 2007\n`\t * TODO: should perhaps bemoved to SiteService\n\t * @param siteId\n\t * @return\n\t */\n\tprivate ArrayList getSiteGroupIdsForSubmittingAgent(String agentId, String siteId) {\n\n\t\tfinal ArrayList<String> groupIds = new ArrayList<String>();\n\t\t// To accomodate the problem with Hibernate and empty array parameters \n\t\t// TODO: this should probably be handled in a more efficient way\n\t\tgroupIds.add(\"none\");  \n\t\t\n\t\tif (siteId == null)\n\t\t\treturn groupIds;\n\t\t\n\t\tCollection siteGroups = null;\n\t\t\n\t\ttry {\n\t\t\tSite s = siteService.getSite(siteId);\n\t\t\tif (s != null)\n\t\t\t\tsiteGroups = s.getGroupsWithMember(agentId);\n\t\t}\n\t\tcatch (IdUnusedException ex) {\n\t\t\t// no site found\n\t\t\tlog.debug(\"No site found for siteid: \" + siteId + \"agentid: \" + agentId);\n\t\t}\n\n\t\tif (siteGroups != null) {\n\t\t\tIterator groupsIter = siteGroups.iterator();\n\t\t\t\n\t\t\twhile (groupsIter.hasNext()) {\n\t\t\t\tGroup group = (Group) groupsIter.next(); \n\t\t\t\tgroupIds.add(group.getId());\n\t\t\t}\n\t\t}\n\t\treturn groupIds;\n\t}","commit_id":"fbb66724215a2cc28afc60567c9654bd35eb6ccb","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void execute()\n        throws MojoExecutionException\n    {\n        File baseDir = new File( inputDirectory );\n\n        File zipFile = null;\n\n        try\n        {\n            zipFile = File.createTempFile( \"site\", \".zip\", new File( workingDirectory ) );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Cannot create site archive!\", e );\n        }\n\n        SshCommandExecutor commandExecutor = null;\n        try\n        {\n            DistributionManagement distributionManagement = project.getDistributionManagement();\n\n            if ( distributionManagement == null )\n            {\n                String msg = \"distributionManagement element is missing in the POM: \" + project.getId();\n\n                throw new MojoExecutionException( msg );\n            }\n\n            if ( distributionManagement.getSite() == null )\n            {\n                String msg = \"distributionManagement/site element is missing in the POM: \" + project.getId();\n\n                throw new MojoExecutionException( msg );\n\n            }\n\n            String url = distributionManagement.getSite().getUrl();\n\n            String id = distributionManagement.getSite().getId();\n\n            if ( url == null )\n            {\n                String msg = \"distributionManagement/site/url element is missing in the POM: \" + project.getId();\n\n                throw new MojoExecutionException( msg );\n\n            }\n\n            Repository repository = new Repository( id, url );\n\n            commandExecutor = (SshCommandExecutor) wagonManager.getWagon( \"scp\" );\n\n            commandExecutor.connect( repository, wagonManager.getAuthenticationInfo( id ) );\n\n            String basedir = repository.getBasedir();\n\n            List files = FileUtils.getFileNames( baseDir, \"**/**\", \"\", false );\n\n            createZip( files, zipFile, baseDir );\n\n            Debug debug = new Debug();\n\n            commandExecutor.addSessionListener( debug );\n\n            commandExecutor.addTransferListener( debug );\n\n            String cmd = \" mkdir -p \" + basedir;\n\n            commandExecutor.executeCommand( cmd );\n\n            commandExecutor.put( zipFile, zipFile.getName() );\n\n            cmd = \" cd \" + basedir + \";\" + unzipCommand + \" \" + zipFile.getName();\n\n            commandExecutor.executeCommand( cmd );\n\n            if ( !basedir.endsWith( \"/\" ) )\n            {\n                basedir = basedir + \"/\";\n            }\n\n            commandExecutor.executeCommand( \"rm -f \" + basedir + zipFile.getName()  );\n        }\n        catch ( Exception e )\n        {\n            throw new MojoExecutionException( \"Error transfering site archive!\", e );\n        }\n        finally\n        {\n            if ( commandExecutor != null )\n            {\n                try\n                {\n                    commandExecutor.disconnect();\n                }\n                catch ( ConnectionException e )\n                {\n                    //what to to here?\n                }\n            }\n\n            if ( !zipFile.delete() )\n            {\n\n                zipFile.deleteOnExit();\n            }\n        }\n    }","id":75130,"modified_method":"public void execute()\n        throws MojoExecutionException\n    {\n        File baseDir = new File( inputDirectory );\n\n        File zipFile;\n\n        try\n        {\n            zipFile = File.createTempFile( \"site\", \".zip\", new File( workingDirectory ) );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Cannot create site archive!\", e );\n        }\n\n        SshCommandExecutor commandExecutor = null;\n        try\n        {\n            DistributionManagement distributionManagement = project.getDistributionManagement();\n\n            if ( distributionManagement == null )\n            {\n                throw new MojoExecutionException( \"Missing distribution management information in the project\" );\n            }\n\n            Site site = distributionManagement.getSite();\n\n            if ( site == null )\n            {\n                throw new MojoExecutionException( \"Missing site information in the distribution management element in the project..\" );\n            }\n\n            String url = site.getUrl();\n\n            String id = site.getId();\n\n            if ( url == null )\n            {\n                throw new MojoExecutionException( \"The URL to the site is missing in the project descriptor.\" );\n            }\n\n            Repository repository = new Repository( id, url );\n\n            if ( !\"scp\".equals( repository.getProtocol() ) )\n            {\n                throw new MojoExecutionException( \"The deploy mojo currently only supports site deployment using the 'scp' protocol.\" );\n            }\n\n            commandExecutor = (SshCommandExecutor) wagonManager.getWagon( \"scp\" );\n\n            commandExecutor.connect( repository, wagonManager.getAuthenticationInfo( id ) );\n\n            String basedir = repository.getBasedir();\n\n            List files = FileUtils.getFileNames( baseDir, \"**/**\", \"\", false );\n\n            createZip( files, zipFile, baseDir );\n\n            Debug debug = new Debug();\n\n            commandExecutor.addSessionListener( debug );\n\n            commandExecutor.addTransferListener( debug );\n\n            String cmd = \" mkdir -p \" + basedir;\n\n            commandExecutor.executeCommand( cmd );\n\n            commandExecutor.put( zipFile, zipFile.getName() );\n\n            cmd = \" cd \" + basedir + \";\" + unzipCommand + \" \" + zipFile.getName();\n\n            commandExecutor.executeCommand( cmd );\n\n            if ( !basedir.endsWith( \"/\" ) )\n            {\n                basedir = basedir + \"/\";\n            }\n\n            commandExecutor.executeCommand( \"rm -f \" + basedir + zipFile.getName()  );\n        }\n        catch ( Exception e )\n        {\n            throw new MojoExecutionException( \"Error transfering site archive!\", e );\n        }\n        finally\n        {\n            if ( commandExecutor != null )\n            {\n                try\n                {\n                    commandExecutor.disconnect();\n                }\n                catch ( ConnectionException e )\n                {\n                    //what to to here?\n                }\n            }\n\n            if ( !zipFile.delete() )\n            {\n\n                zipFile.deleteOnExit();\n            }\n        }\n    }","commit_id":"bea3c7f17b6ab7102d0ea2332f14b9a1604e4e2e","url":"https://github.com/apache/maven"},{"original_method":"public void execute()\n        throws MojoExecutionException\n    {\n        File baseDir = new File( inputDirectory );\n\n        File zipFile = null;\n\n        try\n        {\n            zipFile = File.createTempFile( \"site\", \".zip\", new File( workingDirectory ) );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Cannot create site archive!\", e );\n        }\n\n        SshCommandExecutor commandExecutor = null;\n        try\n        {\n            DistributionManagement distributionManagement = project.getDistributionManagement();\n\n            if ( distributionManagement == null )\n            {\n                String msg = \"distributionManagement element is missing in the POM: \" + project.getId();\n\n                throw new MojoExecutionException( msg );\n            }\n\n            if ( distributionManagement.getSite() == null )\n            {\n                String msg = \"distributionManagement/site element is missing in the POM: \" + project.getId();\n\n                throw new MojoExecutionException( msg );\n\n            }\n\n            String url = distributionManagement.getSite().getUrl();\n\n            String id = distributionManagement.getSite().getId();\n\n            if ( url == null )\n            {\n                String msg = \"distributionManagement/site/url element is missing in the POM: \" + project.getId();\n\n                throw new MojoExecutionException( msg );\n\n            }\n\n            Repository repository = new Repository( id, url );\n\n            commandExecutor = (SshCommandExecutor) wagonManager.getWagon( \"scp\" );\n\n            commandExecutor.connect( repository, wagonManager.getAuthenticationInfo( id ) );\n\n            String basedir = repository.getBasedir();\n\n            List files = FileUtils.getFileNames( baseDir, \"**/**\", \"\", false );\n\n            createZip( files, zipFile, baseDir );\n\n            Debug debug = new Debug();\n\n            commandExecutor.addSessionListener( debug );\n\n            commandExecutor.addTransferListener( debug );\n\n            String cmd = \" mkdir -p \" + basedir;\n\n            commandExecutor.executeCommand( cmd );\n\n            commandExecutor.put( zipFile, zipFile.getName() );\n\n            cmd = \" cd \" + basedir + \";\" + unzipCommand + \" \" + zipFile.getName();\n\n            commandExecutor.executeCommand( cmd );\n\n            if ( !basedir.endsWith( \"/\" ) )\n            {\n                basedir = basedir + \"/\";\n            }\n\n            commandExecutor.executeCommand( \"rm -f \" + basedir + zipFile.getName()  );\n        }\n        catch ( Exception e )\n        {\n            throw new MojoExecutionException( \"Error transfering site archive!\", e );\n        }\n        finally\n        {\n            if ( commandExecutor != null )\n            {\n                try\n                {\n                    commandExecutor.disconnect();\n                }\n                catch ( ConnectionException e )\n                {\n                    //what to to here?\n                }\n            }\n\n            if ( !zipFile.delete() )\n            {\n\n                zipFile.deleteOnExit();\n            }\n        }\n    }","id":75131,"modified_method":"public void execute()\n        throws MojoExecutionException\n    {\n        File baseDir = new File( inputDirectory );\n\n        File zipFile;\n\n        try\n        {\n            zipFile = File.createTempFile( \"site\", \".zip\", new File( workingDirectory ) );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Cannot create site archive!\", e );\n        }\n\n        SshCommandExecutor commandExecutor = null;\n        try\n        {\n            DistributionManagement distributionManagement = project.getDistributionManagement();\n\n            if ( distributionManagement == null )\n            {\n                throw new MojoExecutionException( \"Missing distribution management information in the project\" );\n            }\n\n            Site site = distributionManagement.getSite();\n\n            if ( site == null )\n            {\n                throw new MojoExecutionException( \"Missing site information in the distribution management element in the project..\" );\n            }\n\n            String url = site.getUrl();\n\n            String id = site.getId();\n\n            if ( url == null )\n            {\n                throw new MojoExecutionException( \"The URL to the site is missing in the project descriptor.\" );\n            }\n\n            Repository repository = new Repository( id, url );\n\n            if ( !\"scp\".equals( repository.getProtocol() ) )\n            {\n                throw new MojoExecutionException( \"The deploy mojo currently only supports site deployment using the 'scp' protocol.\" );\n            }\n\n            commandExecutor = (SshCommandExecutor) wagonManager.getWagon( \"scp\" );\n\n            commandExecutor.connect( repository, wagonManager.getAuthenticationInfo( id ) );\n\n            String basedir = repository.getBasedir();\n\n            List files = FileUtils.getFileNames( baseDir, \"**/**\", \"\", false );\n\n            createZip( files, zipFile, baseDir );\n\n            Debug debug = new Debug();\n\n            commandExecutor.addSessionListener( debug );\n\n            commandExecutor.addTransferListener( debug );\n\n            String cmd = \" mkdir -p \" + basedir;\n\n            commandExecutor.executeCommand( cmd );\n\n            commandExecutor.put( zipFile, zipFile.getName() );\n\n            cmd = \" cd \" + basedir + \";\" + unzipCommand + \" \" + zipFile.getName();\n\n            commandExecutor.executeCommand( cmd );\n\n            if ( !basedir.endsWith( \"/\" ) )\n            {\n                basedir = basedir + \"/\";\n            }\n\n            commandExecutor.executeCommand( \"rm -f \" + basedir + zipFile.getName()  );\n        }\n        catch ( Exception e )\n        {\n            throw new MojoExecutionException( \"Error transfering site archive!\", e );\n        }\n        finally\n        {\n            if ( commandExecutor != null )\n            {\n                try\n                {\n                    commandExecutor.disconnect();\n                }\n                catch ( ConnectionException e )\n                {\n                    //what to to here?\n                }\n            }\n\n            if ( !zipFile.delete() )\n            {\n\n                zipFile.deleteOnExit();\n            }\n        }\n    }","commit_id":"8d8e0e25d6ccc3c39406794f4b717e3afc80eee3","url":"https://github.com/apache/maven-plugins"},{"original_method":"public List<LessonEntity> getEntitiesInSite() {\n\n\t//ForumEntity e = new ForumEntity(TYPE_FORUM_TOPIC, 3L, 2);\n\n\t//e.setGroups(Arrays.asList(\"1c24287b-b880-43da-8cdd-c6cdc1249c5c\", \"75184424-853e-4dd4-9e92-980c851f0580\"));\n\t//e.setGroups(Arrays.asList(\"75184424-853e-4dd4-9e92-980c851f0580\"));\n\n\tSortedSet<DiscussionForum> forums = new TreeSet<DiscussionForum>(new ForumBySortIndexAscAndCreatedDateDesc());\n\tfor (DiscussionForum forum: forumManager.getForumsForMainPage())\n\t    forums.add(forum);\n\n\tList<LessonEntity> ret = new ArrayList<LessonEntity>();\n\t// security. assume this is only used in places where it's OK, so skip security checks\n\tfor (DiscussionForum forum: forums) {\n\t    if (!forum.getDraft()) {\n\t\tForumEntity entity = new ForumEntity(TYPE_FORUM_FORUM, forum.getId(), 1);\n\t\tentity.forum = forum;\n\t\tret.add(entity);\n\t\tfor (Object o: forum.getTopicsSet()) {\n\t\t    DiscussionTopic topic = (DiscussionTopic)o;\n\t\t    if (topic.getDraft().equals(Boolean.FALSE)) {\n\t\t\tentity = new ForumEntity(TYPE_FORUM_TOPIC, topic.getId(), 2);\n\t\t\tentity.topic = topic;\n\t\t\tret.add(entity);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tif (nextEntity != null) \n\t    ret.addAll(nextEntity.getEntitiesInSite());\n\n\treturn ret;\n    }","id":75132,"modified_method":"public List<LessonEntity> getEntitiesInSite() {\n    \t\n    List<LessonEntity> ret = new ArrayList<LessonEntity>();\n    \n\t// LSNBLDR-21. If the tool is not in the current site we shouldn't query\n\t// for topics owned by the tool.\n\tSite site = null;\n\ttry {\n\t    site = SiteService.getSite(ToolManager.getCurrentPlacement().getContext());\n\t} catch (Exception impossible) {\n\t    return null;\n\t}\n    \t\n    ToolConfiguration tool = site.getToolForCommonId(\"sakai.forums\");\n\t\n    if(tool == null) {\n    \t\n    \t// Forums is not in this site. Move on to the next provider.\n    \t\n    \tif (nextEntity != null) \n    \t\tret.addAll(nextEntity.getEntitiesInSite());\n    \t\n    \treturn ret;\n    }\n\n\t//ForumEntity e = new ForumEntity(TYPE_FORUM_TOPIC, 3L, 2);\n\n\t//e.setGroups(Arrays.asList(\"1c24287b-b880-43da-8cdd-c6cdc1249c5c\", \"75184424-853e-4dd4-9e92-980c851f0580\"));\n\t//e.setGroups(Arrays.asList(\"75184424-853e-4dd4-9e92-980c851f0580\"));\n\n\tSortedSet<DiscussionForum> forums = new TreeSet<DiscussionForum>(new ForumBySortIndexAscAndCreatedDateDesc());\n\tfor (DiscussionForum forum: forumManager.getForumsForMainPage())\n\t    forums.add(forum);\n\n\t// security. assume this is only used in places where it's OK, so skip security checks\n\tfor (DiscussionForum forum: forums) {\n\t    if (!forum.getDraft()) {\n\t\tForumEntity entity = new ForumEntity(TYPE_FORUM_FORUM, forum.getId(), 1);\n\t\tentity.forum = forum;\n\t\tret.add(entity);\n\t\tfor (Object o: forum.getTopicsSet()) {\n\t\t    DiscussionTopic topic = (DiscussionTopic)o;\n\t\t    if (topic.getDraft().equals(Boolean.FALSE)) {\n\t\t\tentity = new ForumEntity(TYPE_FORUM_TOPIC, topic.getId(), 2);\n\t\t\tentity.topic = topic;\n\t\t\tret.add(entity);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tif (nextEntity != null) \n\t    ret.addAll(nextEntity.getEntitiesInSite());\n\n\treturn ret;\n    }","commit_id":"47ed9ac713fea3b2850c653ade9161e051a22281","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public LessonEntity getEntity(String ref) {\n\tint i = ref.indexOf(\"/\",1);\n\tif (i < 0)\n\t    return null;\n\tString typeString = ref.substring(1, i);\n\tString idString = ref.substring(i+1);\n\tLong id = 0L;\n\ttry {\n\t    id = Long.parseLong(idString);\n\t} catch (Exception ignore) {\n\t    return null;\n\t}\n\n\t// note: I'm returning the minimal structures, not those with\n\t// topics and postings attached\n\tif (typeString.equals(FORUM_TOPIC)) {\n\t    return new ForumEntity(TYPE_FORUM_TOPIC, id, 2);\n\t} else if (typeString.equals(FORUM_FORUM)) {\n\t    return new ForumEntity(TYPE_FORUM_FORUM, id, 1);\n\t} else if (nextEntity != null) {\n\t    return nextEntity.getEntity(ref);\n\t} else\n\t    return null;\n    }","id":75133,"modified_method":"public LessonEntity getEntity(String ref) {\n\tint i = ref.indexOf(\"/\",1);\n\tif (i < 0)\n\t    return null;\n\tString typeString = ref.substring(1, i);\n\tString idString = ref.substring(i+1);\n\tLong id = 0L;\n\tif (typeString.equals(FORUM_TOPIC) || typeString.equals(FORUM_FORUM)) {\n\t\ttry {\n\t\t\tid = Long.parseLong(idString);\n\t\t} catch (Exception ignore) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t// note: I'm returning the minimal structures, not those with\n\t// topics and postings attached\n\tif (typeString.equals(FORUM_TOPIC)) {\n\t    return new ForumEntity(TYPE_FORUM_TOPIC, id, 2);\n\t} else if (typeString.equals(FORUM_FORUM)) {\n\t    return new ForumEntity(TYPE_FORUM_FORUM, id, 1);\n\t} else if (nextEntity != null) {\n\t    return nextEntity.getEntity(ref);\n\t} else\n\t    return null;\n    }","commit_id":"47ed9ac713fea3b2850c653ade9161e051a22281","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public String getUrl() {\n\t\n\tSite site = null;\n\ttry {\n\t    site = SiteService.getSite(ToolManager.getCurrentPlacement().getContext());\n\t} catch (Exception impossible) {\n\t    return null;\n\t}\n\tToolConfiguration tool = site.getToolForCommonId(\"sakai.forums\");\n\tString placement = tool.getId();\n\n\tif (type == TYPE_FORUM_TOPIC)\n\t    return \"/messageforums-tool/jsp/discussionForum/message/dfAllMessagesDirect.jsf?topicId=\" + id + \"&placementId=\" + placement;\n\telse\n\t    return \"/direct/forum/\" + id;\n    }","id":75134,"modified_method":"public String getUrl() {\n\t\n\tSite site = null;\n\ttry {\n\t    site = SiteService.getSite(ToolManager.getCurrentPlacement().getContext());\n\t} catch (Exception impossible) {\n\t    return null;\n\t}\n\tToolConfiguration tool = site.getToolForCommonId(\"sakai.forums\");\n\t\n\t// LSNBLDR-21. If the tool is not in the current site we shouldn't return a url\n\tif(tool == null) {\n\t    return null;\n\t}\n\t\n\tString placement = tool.getId();\n\n\tif (type == TYPE_FORUM_TOPIC)\n\t    return \"/messageforums-tool/jsp/discussionForum/message/dfAllMessagesDirect.jsf?topicId=\" + id + \"&placementId=\" + placement;\n\telse\n\t    return \"/direct/forum/\" + id;\n    }","commit_id":"47ed9ac713fea3b2850c653ade9161e051a22281","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public String getUrl() {\n\tif (url != null)\n\t    return url;\n\n\tString prefix = null;\n\tString siteId = toolManager.getCurrentPlacement().getContext();\n\ttry {\n\t    Site site = SiteService.getSite(siteId);\n\t    // String toolid = \"8f83cd4b-74ca-4428-0055-85ddd19a8d00\";\n\t    ToolConfiguration siteTool = site.getToolForCommonId(\"sakai.jforum.tool\");\n\t    prefix = \"/portal/tool/\" + siteTool.getId();\n\t    // String toolid = \"8f83cd4b-74ca-4428-0055-85ddd19a8d00\";\n\t} catch (Exception e) {\n\t    System.out.println(\"tool problem \" + e);\n\t    return null;\n\t}\n\n\tif (type == TYPE_JFORUM_TOPIC)\n\t    url = prefix + \"/posts/list/\" + id + \".page\";\n\telse if (type == TYPE_JFORUM_CATEGORY)\n\t    url = prefix + \"/forums/list.page\"; // no way to go directly to a category\n\telse // forum\n\t    url = prefix + \"/forums/show/\" + id + \".page\";\n\n\treturn url;\n    }","id":75135,"modified_method":"public String getUrl() {\n\tif (url != null)\n\t    return url;\n\t\n\tString siteId = toolManager.getCurrentPlacement().getContext();\n\t\n\tSite site = null;\n\ttry {\n\t    site = SiteService.getSite(siteId);\n\t} catch (Exception impossible) {\n\t    return null;\n\t}\n\t\n\tToolConfiguration siteTool = site.getToolForCommonId(\"sakai.jforum.tool\");\n\t\n\t// LSNBLDR-21. If the tool is not in the current site we shouldn't return a url\n\tif(siteTool == null) {\n\t    return null;\n\t}\n\n\tString prefix = null;\n\ttry {\n\t    // String toolid = \"8f83cd4b-74ca-4428-0055-85ddd19a8d00\";\n\t    prefix = \"/portal/tool/\" + siteTool.getId();\n\t    // String toolid = \"8f83cd4b-74ca-4428-0055-85ddd19a8d00\";\n\t} catch (Exception e) {\n\t    System.out.println(\"tool problem \" + e);\n\t    return null;\n\t}\n\n\tif (type == TYPE_JFORUM_TOPIC)\n\t    url = prefix + \"/posts/list/\" + id + \".page\";\n\telse if (type == TYPE_JFORUM_CATEGORY)\n\t    url = prefix + \"/forums/list.page\"; // no way to go directly to a category\n\telse // forum\n\t    url = prefix + \"/forums/show/\" + id + \".page\";\n\n\treturn url;\n    }","commit_id":"47ed9ac713fea3b2850c653ade9161e051a22281","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public List<LessonEntity> getEntitiesInSite() {\n\t// all other code is driven by current objects. If we skip this code, nothing else\n\t// in this module will be called.\n\tif (!haveJforum) {\n\t    if (nextEntity != null) \n\t\treturn nextEntity.getEntitiesInSite();\n\t    else\n\t\treturn new ArrayList<LessonEntity>();\n\t}\n\n\tList<LessonEntity>ret = new ArrayList<LessonEntity>();\n\tString url = null;\n\n\tString siteId = toolManager.getCurrentPlacement().getContext();\n\ttry {\n\t    Site site = SiteService.getSite(siteId);\n\t    // String toolid = \"8f83cd4b-74ca-4428-0055-85ddd19a8d00\";\n\t    ToolConfiguration siteTool = site.getToolForCommonId(\"sakai.jforum.tool\");\n\t    url = \"/portal/tool/\" + siteTool.getId() + \"/posts/list/\";\n\n\t    // String toolid = \"8f83cd4b-74ca-4428-0055-85ddd19a8d00\";\n\t} catch (Exception e) {\n\t    System.out.println(\"tool problem \" + e);\n\t}\n\n\tConnection connection = null;\n\ttry {\n\t    connection = SqlService.borrowConnection();\n\t    // jforum_sakai_course_categories: course_id, categories_id\n\n\t    String sql=\"select b.categories_id, b.title from jforum_sakai_course_categories a, jforum_categories b where a.course_id=? and a.categories_id = b.categories_id order by b.display_order\";\n\t    Object fields[] = new Object[1];\n\t    fields[0] = siteId;\n\n\t    List<JForumEntity>categories = SqlService.dbRead(connection, sql, fields, new SqlReader()\n\t\t{\n\t\t    public Object readSqlResultRecord(ResultSet result)\n\t\t    {\n\t\t\ttry {\n\t\t\t    return new JForumEntity(TYPE_JFORUM_CATEGORY, result.getInt(1), 1, result.getString(2));\n\t\t\t} catch (Exception ignore) {};\n\t\t\treturn null;\n\t\t    }\n\t\t});\n\n\t    if (categories != null && categories.size() > 0)\n\t\tfor (JForumEntity c : categories) {\n\t\t    boolean categoryAdded = false;\n\n\t\t    sql = \"select forum_id,forum_name from jforum_forums where categories_id = ? order by forum_order\";\n\t\t    fields[0] = c.id;\n\n\t\t    List<JForumEntity>forums = SqlService.dbRead(connection, sql, fields, new SqlReader()\n\t\t\t{\n\t\t\t    public Object readSqlResultRecord(ResultSet result)\n\t\t\t    {\n\t\t\t\ttry {\n\t\t\t\t    return new JForumEntity(TYPE_JFORUM_FORUM, result.getInt(1), 1, result.getString(2));\n\t\t\t\t} catch (Exception ignore) {};\n\t\t\t\treturn null;\n\t\t\t    }\n\t\t\t});\n\n\t\t    if (forums != null && forums.size() > 0) \n\t\t\tfor (JForumEntity f : forums) {\n\t\t    \n\t\t\t    sql = \"select topic_id,topic_title from jforum_topics where forum_id = ? order by topic_time\";\n\t\t\t    fields[0] = f.id;\n\t\t\t    \n\t\t\t    List<JForumEntity>topics = SqlService.dbRead(connection, sql, fields, new SqlReader()\n\t\t\t\t{\n\t\t\t\t    public Object readSqlResultRecord(ResultSet result)\n\t\t\t\t    {\n\t\t\t\t\ttry {\n\t\t\t\t\t    return new JForumEntity(TYPE_JFORUM_TOPIC, result.getInt(1), 2, result.getString(2));\n\t\t\t\t\t} catch (Exception ignore) {};\n\t\t\t\t\treturn null;\n\t\t\t\t    }\n\t\t\t\t});\n\n\t\t\t    if (topics != null && topics.size() > 0) {\n\t\t\t\tif (!categoryAdded) {\n\t\t\t\t    ret.add(c);\n\t\t\t\t    categoryAdded = true;\n\t\t\t\t}\n\t\t\t\tret.add(f);\n\t\t\t\tfor (JForumEntity t: topics) {\n\t\t\t\t    t.url = url + t.id + \".page\";\n\t\t\t\t    ret.add(t);\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t} catch (Exception e) {\n\t    System.out.println(\"JForum Lesson Builder find all in site error \" + e);\n\t} finally {\n\t    try {\n\t\tif (connection != null)\n\t\t    SqlService.returnConnection(connection);\n\t    } catch (Exception ignore) {};\n\t}\n\n\tif (nextEntity != null) \n\t    ret.addAll(nextEntity.getEntitiesInSite());\n\n\treturn ret;\n    }","id":75136,"modified_method":"public List<LessonEntity> getEntitiesInSite() {\n\t// all other code is driven by current objects. If we skip this code, nothing else\n\t// in this module will be called.\n\tif (!haveJforum) {\n\t    if (nextEntity != null) \n\t\treturn nextEntity.getEntitiesInSite();\n\t    else\n\t\treturn new ArrayList<LessonEntity>();\n\t}\n\t\n\tList<LessonEntity>ret = new ArrayList<LessonEntity>();\n\t\n\t// LSNBLDR-21. If the tool is not in the current site we shouldn't query\n\t// for topics owned by the tool.\n\tString siteId = toolManager.getCurrentPlacement().getContext();\n\t\n\tSite site = null;\n\ttry {\n\t    site = SiteService.getSite(siteId);\n\t} catch (Exception impossible) {\n\t    return null;\n\t}\n    \t\n    ToolConfiguration siteTool = site.getToolForCommonId(\"sakai.jforum.tool\");\n\t\n    if(siteTool == null) {\n    \t\n    \t// JForum is not in this site. Move on to the next provider.\n    \t\n    \tif (nextEntity != null) \n    \t\tret.addAll(nextEntity.getEntitiesInSite());\n    \t\n    \treturn ret;\n    }\n\n\tString url = null;\n\n\ttry {\n\t    // String toolid = \"8f83cd4b-74ca-4428-0055-85ddd19a8d00\";\n\t    url = \"/portal/tool/\" + siteTool.getId() + \"/posts/list/\";\n\n\t    // String toolid = \"8f83cd4b-74ca-4428-0055-85ddd19a8d00\";\n\t} catch (Exception e) {\n\t    System.out.println(\"tool problem \" + e);\n\t}\n\n\tConnection connection = null;\n\ttry {\n\t    connection = SqlService.borrowConnection();\n\t    // jforum_sakai_course_categories: course_id, categories_id\n\n\t    String sql=\"select b.categories_id, b.title from jforum_sakai_course_categories a, jforum_categories b where a.course_id=? and a.categories_id = b.categories_id order by b.display_order\";\n\t    Object fields[] = new Object[1];\n\t    fields[0] = siteId;\n\n\t    List<JForumEntity>categories = SqlService.dbRead(connection, sql, fields, new SqlReader()\n\t\t{\n\t\t    public Object readSqlResultRecord(ResultSet result)\n\t\t    {\n\t\t\ttry {\n\t\t\t    return new JForumEntity(TYPE_JFORUM_CATEGORY, result.getInt(1), 1, result.getString(2));\n\t\t\t} catch (Exception ignore) {};\n\t\t\treturn null;\n\t\t    }\n\t\t});\n\n\t    if (categories != null && categories.size() > 0)\n\t\tfor (JForumEntity c : categories) {\n\t\t    boolean categoryAdded = false;\n\n\t\t    sql = \"select forum_id,forum_name from jforum_forums where categories_id = ? order by forum_order\";\n\t\t    fields[0] = c.id;\n\n\t\t    List<JForumEntity>forums = SqlService.dbRead(connection, sql, fields, new SqlReader()\n\t\t\t{\n\t\t\t    public Object readSqlResultRecord(ResultSet result)\n\t\t\t    {\n\t\t\t\ttry {\n\t\t\t\t    return new JForumEntity(TYPE_JFORUM_FORUM, result.getInt(1), 1, result.getString(2));\n\t\t\t\t} catch (Exception ignore) {};\n\t\t\t\treturn null;\n\t\t\t    }\n\t\t\t});\n\n\t\t    if (forums != null && forums.size() > 0) \n\t\t\tfor (JForumEntity f : forums) {\n\t\t    \n\t\t\t    sql = \"select topic_id,topic_title from jforum_topics where forum_id = ? order by topic_time\";\n\t\t\t    fields[0] = f.id;\n\t\t\t    \n\t\t\t    List<JForumEntity>topics = SqlService.dbRead(connection, sql, fields, new SqlReader()\n\t\t\t\t{\n\t\t\t\t    public Object readSqlResultRecord(ResultSet result)\n\t\t\t\t    {\n\t\t\t\t\ttry {\n\t\t\t\t\t    return new JForumEntity(TYPE_JFORUM_TOPIC, result.getInt(1), 2, result.getString(2));\n\t\t\t\t\t} catch (Exception ignore) {};\n\t\t\t\t\treturn null;\n\t\t\t\t    }\n\t\t\t\t});\n\n\t\t\t    if (topics != null && topics.size() > 0) {\n\t\t\t\tif (!categoryAdded) {\n\t\t\t\t    ret.add(c);\n\t\t\t\t    categoryAdded = true;\n\t\t\t\t}\n\t\t\t\tret.add(f);\n\t\t\t\tfor (JForumEntity t: topics) {\n\t\t\t\t    t.url = url + t.id + \".page\";\n\t\t\t\t    ret.add(t);\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t} catch (Exception e) {\n\t    System.out.println(\"JForum Lesson Builder find all in site error \" + e);\n\t} finally {\n\t    try {\n\t\tif (connection != null)\n\t\t    SqlService.returnConnection(connection);\n\t    } catch (Exception ignore) {};\n\t}\n\n\tif (nextEntity != null) \n\t    ret.addAll(nextEntity.getEntitiesInSite());\n\n\treturn ret;\n    }","commit_id":"47ed9ac713fea3b2850c653ade9161e051a22281","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public LessonEntity getEntity(String ref) {\n\tint i = ref.indexOf(\"/\",1);\n\tif (i < 0)\n\t    return null;\n\tString typeString = ref.substring(1, i);\n\tString idString = ref.substring(i+1);\n\tint id = 0;\n\ttry {\n\t    id = Integer.parseInt(idString);\n\t} catch (Exception ignore) {\n\t    return null;\n\t}\n\n\t// note: I'm returning the minimal structures, not those with\n\t// topics and postings attached\n\tif (typeString.equals(JFORUM_TOPIC)) {\n\t    return new JForumEntity(TYPE_JFORUM_TOPIC, id, 2);\n\t} else if (typeString.equals(JFORUM_FORUM)) {\n\t    return new JForumEntity(TYPE_JFORUM_FORUM, id, 1);\n\t} else if (typeString.equals(JFORUM_CATEGORY)) {\n\t    return new JForumEntity(TYPE_JFORUM_CATEGORY, id, 1);\n\t} else if (nextEntity != null) {\n\t    return nextEntity.getEntity(ref);\n\t} else\n\t    return null;\n\t    \n    }","id":75137,"modified_method":"public LessonEntity getEntity(String ref) {\n\tint i = ref.indexOf(\"/\",1);\n\tif (i < 0)\n\t    return null;\n\tString typeString = ref.substring(1, i);\n\tString idString = ref.substring(i+1);\n\tint id = 0;\n\tif (typeString.equals(JFORUM_TOPIC) || typeString.equals(JFORUM_FORUM) || typeString.equals(JFORUM_CATEGORY)) {\n\t\ttry {\n\t\t\tid = Integer.parseInt(idString);\n\t\t} catch (Exception ignore) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t// note: I'm returning the minimal structures, not those with\n\t// topics and postings attached\n\tif (typeString.equals(JFORUM_TOPIC)) {\n\t    return new JForumEntity(TYPE_JFORUM_TOPIC, id, 2);\n\t} else if (typeString.equals(JFORUM_FORUM)) {\n\t    return new JForumEntity(TYPE_JFORUM_FORUM, id, 1);\n\t} else if (typeString.equals(JFORUM_CATEGORY)) {\n\t    return new JForumEntity(TYPE_JFORUM_CATEGORY, id, 1);\n\t} else if (nextEntity != null) {\n\t    return nextEntity.getEntity(ref);\n\t} else\n\t    return null;\n\t    \n    }","commit_id":"47ed9ac713fea3b2850c653ade9161e051a22281","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public static UsagesRequiringNonNullValues getAnalysis(ClassContext classContext, Method method) {\n\t\tXMethod thisMethod = classContext.getXClass().findMethod(method.getName(), method.getSignature(), method.isStatic());\n\t\tif (DEBUG) System.out.println(thisMethod);\n\t\tUsagesRequiringNonNullValues derefs = new UsagesRequiringNonNullValues();\n\t\ttry {\n\n\t\t\tCFG cfg = classContext.getCFG(method);\n\n\t\t\tValueNumberDataflow vna = classContext.getValueNumberDataflow(method);\n\t\t\tTypeDataflow typeDataflow = classContext.getTypeDataflow(method);\n\t\t\tINullnessAnnotationDatabase db = AnalysisContext.currentAnalysisContext().getNullnessAnnotationDatabase();\n\n\t\t\tParameterNullnessPropertyDatabase unconditionalDerefParamDatabase = AnalysisContext\n\t\t\t\t\t.currentAnalysisContext().getUnconditionalDerefParamDatabase();\n\t\t\tIterator<BasicBlock> bbIter = cfg.blockIterator();\n\t\t\tConstantPoolGen cpg = classContext.getConstantPoolGen();\n\t\t\tValueNumber valueNumberForThis = null;\n\t\t\tif (!method.isStatic()) {\n\t\t\t\tValueNumberFrame frameAtEntry = vna.getStartFact(cfg.getEntry());\n\t\t\t\tvalueNumberForThis = frameAtEntry.getValue(0);\n\t\t\t}\n\n\t\t\tNullnessAnnotation methodAnnotation = getMethodNullnessAnnotation(classContext, method);\n\n\t\t\twhile (bbIter.hasNext()) {\n\t\t\t\tBasicBlock basicBlock = bbIter.next();\n\n\t\t\t\tif (basicBlock.isNullCheck()) {\n\t\t\t\t\tInstructionHandle exceptionThrowerHandle = basicBlock.getExceptionThrower();\n\t\t\t\t\tInstruction exceptionThrower = exceptionThrowerHandle.getInstruction();\n\t\t\t\t\tValueNumberFrame vnaFrame = vna.getStartFact(basicBlock);\n\t\t\t\t\tif (!vnaFrame.isValid())\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tValueNumber valueNumber = vnaFrame.getInstance(exceptionThrower, cpg);\n\n\t\t\t\t\tLocation location = new Location(exceptionThrowerHandle, basicBlock);\n\t\t\t\t\tif (valueNumberForThis != valueNumber)\n\t\t\t\t\t\tderefs.add(location, valueNumber, PointerUsageRequiringNonNullValue.getPointerDereference());\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\t\tLocation location = i.next();\n\t\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\t\tInstruction ins = handle.getInstruction();\n\t\t\t\tValueNumberFrame valueNumberFrame = vna.getFactAtLocation(location);\n\t\t\t\tTypeFrame typeFrame = typeDataflow.getFactAtLocation(location);\n\t\t\t\tif (ins instanceof InvokeInstruction) {\n\t\t\t\t\tInvokeInstruction inv = (InvokeInstruction) ins;\n\t\t\t\t\tXMethod m = XFactory.createXMethod(inv, cpg);\n\t\t\t\t\tSignatureParser sigParser = new SignatureParser(m.getSignature());\n\t\t\t\t\tint numParams = sigParser.getNumParameters();\n\n\t\t\t\t\t// Check nonnull annotations\n\n\t\t\t\t\tfor (int j = 0; j < numParams; j++)\n\t\t\t\t\t\tif (db.parameterMustBeNonNull(m, j)) {\n\t\t\t\t\t\t\tint slot = sigParser.getSlotsFromTopOfStackForParameter(j);\n\t\t\t\t\t\t\tValueNumber valueNumber = valueNumberFrame.getStackValue(slot);\n\t\t\t\t\t\t\tif (valueNumberForThis != valueNumber) derefs.add(location, valueNumber, PointerUsageRequiringNonNullValue\n\t\t\t\t\t\t\t\t\t.getPassedAsNonNullParameter(m, j));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Check actual targets\n\t\t\t\t\ttry {\n\t\t\t\t\t\tSet<JavaClassAndMethod> targetMethodSet = Hierarchy.resolveMethodCallTargets(inv, typeFrame,\n\t\t\t\t\t\t\t\tcpg);\n\t\t\t\t\t\tBitSet unconditionallyDereferencedNullArgSet = null;\n\t\t\t\t\t\t for (JavaClassAndMethod targetMethod : targetMethodSet) {\n\n\t\t\t\t\t\t\tParameterNullnessProperty property = unconditionalDerefParamDatabase\n\t\t\t\t\t\t\t\t\t.getProperty(targetMethod.toMethodDescriptor());\n\t\t\t\t\t\t\tif (property == null) {\n\t\t\t\t\t\t\t\tunconditionallyDereferencedNullArgSet = null;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tBitSet foo = property.getAsBitSet();\n\t\t\t\t\t\t\tif (unconditionallyDereferencedNullArgSet == null)\n\t\t\t\t\t\t\t\tunconditionallyDereferencedNullArgSet = foo;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tunconditionallyDereferencedNullArgSet.intersects(foo);\n\t\t\t\t\t\t\tif (unconditionallyDereferencedNullArgSet.isEmpty())\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (unconditionallyDereferencedNullArgSet != null\n\t\t\t\t\t\t\t\t&& !unconditionallyDereferencedNullArgSet.isEmpty() && valueNumberFrame.isValid())\n\t\t\t\t\t\t\tfor (int j = unconditionallyDereferencedNullArgSet.nextSetBit(0); j >= 0; j = unconditionallyDereferencedNullArgSet\n\t\t\t\t\t\t\t\t\t.nextSetBit(j + 1)) {\n\t\t\t\t\t\t\t\tint slot = sigParser.getSlotsFromTopOfStackForParameter(j);\n\t\t\t\t\t\t\t\tValueNumber valueNumber = valueNumberFrame.getStackValue(slot);\n\t\t\t\t\t\t\t\tif (valueNumberForThis != valueNumber)  derefs.add(location, valueNumber, PointerUsageRequiringNonNullValue\n\t\t\t\t\t\t\t\t\t\t.getPassedAsNonNullParameter(m, j));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\t\tAnalysisContext.reportMissingClass(e);\n\t\t\t\t\t}\n\n\t\t\t\t} else if (ins instanceof ARETURN && methodAnnotation == NullnessAnnotation.NONNULL) {\n\t\t\t\t\tValueNumber valueNumber = valueNumberFrame.getTopValue();\n\t\t\t\t\tif (valueNumberForThis != valueNumber) derefs.add(location, valueNumber, PointerUsageRequiringNonNullValue\n\t\t\t\t\t\t\t.getReturnFromNonNullMethod(thisMethod));\n\n\t\t\t\t} else if (ins instanceof PUTFIELD || ins instanceof PUTSTATIC) {\n\t\t\t\t\tFieldInstruction inf = (FieldInstruction) ins;\n\t\t\t\t\tXField field = XFactory.createXField(inf, cpg);\n\t\t\t\t\tNullnessAnnotation annotation = AnalysisContext.currentAnalysisContext()\n\t\t\t\t\t\t\t.getNullnessAnnotationDatabase().getResolvedAnnotation(field, false);\n\t\t\t\t\tif (annotation == NullnessAnnotation.NONNULL) {\n\t\t\t\t\t\tValueNumber valueNumber = valueNumberFrame.getTopValue();\n\t\t\t\t\t\tif (valueNumberForThis != valueNumber)  derefs.add(location, valueNumber, PointerUsageRequiringNonNullValue\n\t\t\t\t\t\t\t\t.getStoredIntoNonNullField(field));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t} catch (CFGBuilderException e) {\n\t\t\tAnalysisContext.logError(\"Error generating derefs for \" + thisMethod, e);\n\t\t} catch (DataflowAnalysisException e) {\n\t\t\tAnalysisContext.logError(\"Error generating derefs for \" + thisMethod, e);\n\t\t}\n\t\treturn derefs;\n\t}","id":75138,"modified_method":"public static UsagesRequiringNonNullValues getAnalysis(ClassContext classContext, Method method) {\n\t\tXMethod thisMethod = classContext.getXClass().findMethod(method.getName(), method.getSignature(), method.isStatic());\n\t\tif (DEBUG) System.out.println(thisMethod);\n\t\tUsagesRequiringNonNullValues derefs = new UsagesRequiringNonNullValues();\n\t\ttry {\n\n\t\t\tCFG cfg = classContext.getCFG(method);\n\n\t\t\tValueNumberDataflow vna = classContext.getValueNumberDataflow(method);\n\t\t\tTypeDataflow typeDataflow = classContext.getTypeDataflow(method);\n\t\t\tINullnessAnnotationDatabase db = AnalysisContext.currentAnalysisContext().getNullnessAnnotationDatabase();\n\n\t\t\tParameterNullnessPropertyDatabase unconditionalDerefParamDatabase = AnalysisContext\n\t\t\t\t\t.currentAnalysisContext().getUnconditionalDerefParamDatabase();\n\t\t\tIterator<BasicBlock> bbIter = cfg.blockIterator();\n\t\t\tConstantPoolGen cpg = classContext.getConstantPoolGen();\n\t\t\tValueNumber valueNumberForThis = null;\n\t\t\tif (!method.isStatic()) {\n\t\t\t\tValueNumberFrame frameAtEntry = vna.getStartFact(cfg.getEntry());\n\t\t\t\tvalueNumberForThis = frameAtEntry.getValue(0);\n\t\t\t}\n\n\t\t\tNullnessAnnotation methodAnnotation = getMethodNullnessAnnotation(classContext, method);\n\n\t\t\twhile (bbIter.hasNext()) {\n\t\t\t\tBasicBlock basicBlock = bbIter.next();\n\n\t\t\t\tif (basicBlock.isNullCheck()) {\n\t\t\t\t\tInstructionHandle exceptionThrowerHandle = basicBlock.getExceptionThrower();\n\t\t\t\t\tInstruction exceptionThrower = exceptionThrowerHandle.getInstruction();\n\t\t\t\t\tValueNumberFrame vnaFrame = vna.getStartFact(basicBlock);\n\t\t\t\t\tif (!vnaFrame.isValid())\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tValueNumber valueNumber = vnaFrame.getInstance(exceptionThrower, cpg);\n\n\t\t\t\t\tLocation location = new Location(exceptionThrowerHandle, basicBlock);\n\t\t\t\t\tif (valueNumberForThis != valueNumber)\n\t\t\t\t\t\tderefs.add(location, valueNumber, PointerUsageRequiringNonNullValue.getPointerDereference());\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\t\tLocation location = i.next();\n\t\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\t\tInstruction ins = handle.getInstruction();\n\t\t\t\tValueNumberFrame valueNumberFrame = vna.getFactAtLocation(location);\n\t\t\t\tTypeFrame typeFrame = typeDataflow.getFactAtLocation(location);\n\t\t\t\tif (ins instanceof InvokeInstruction) {\n\t\t\t\t\tInvokeInstruction inv = (InvokeInstruction) ins;\n\t\t\t\t\tXMethod m = XFactory.createXMethod(inv, cpg);\n\t\t\t\t\tSignatureParser sigParser = new SignatureParser(m.getSignature());\n\t\t\t\t\tint numParams = sigParser.getNumParameters();\n\n\t\t\t\t\t// Check nonnull annotations\n\n\t\t\t\t\tfor (int j = 0; j < numParams; j++)\n\t\t\t\t\t\tif (db.parameterMustBeNonNull(m, j)) {\n\t\t\t\t\t\t\tint slot = sigParser.getSlotsFromTopOfStackForParameter(j);\n\t\t\t\t\t\t\tValueNumber valueNumber = valueNumberFrame.getStackValue(slot);\n\t\t\t\t\t\t\tif (valueNumberForThis != valueNumber) derefs.add(location, valueNumber, PointerUsageRequiringNonNullValue\n\t\t\t\t\t\t\t\t\t.getPassedAsNonNullParameter(m, j));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Check actual targets\n\t\t\t\t\ttry {\n\t\t\t\t\t\tSet<JavaClassAndMethod> targetMethodSet = Hierarchy.resolveMethodCallTargets(inv, typeFrame,\n\t\t\t\t\t\t\t\tcpg);\n\t\t\t\t\t\tBitSet unconditionallyDereferencedNullArgSet = null;\n\t\t\t\t\t\t for (JavaClassAndMethod targetMethod : targetMethodSet) {\n\n\t\t\t\t\t\t\tParameterNullnessProperty property = unconditionalDerefParamDatabase\n\t\t\t\t\t\t\t\t\t.getProperty(targetMethod.toMethodDescriptor());\n\t\t\t\t\t\t\tif (property == null) {\n\t\t\t\t\t\t\t\tunconditionallyDereferencedNullArgSet = null;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tBitSet foo = property.getAsBitSet();\n\t\t\t\t\t\t\tif (unconditionallyDereferencedNullArgSet == null)\n\t\t\t\t\t\t\t\tunconditionallyDereferencedNullArgSet = foo;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tunconditionallyDereferencedNullArgSet.intersects(foo);\n\t\t\t\t\t\t\tif (unconditionallyDereferencedNullArgSet.isEmpty())\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (unconditionallyDereferencedNullArgSet != null\n\t\t\t\t\t\t\t\t&& !unconditionallyDereferencedNullArgSet.isEmpty() && valueNumberFrame.isValid())\n\t\t\t\t\t\t\tfor (int j = unconditionallyDereferencedNullArgSet.nextSetBit(0); j >= 0; j = unconditionallyDereferencedNullArgSet\n\t\t\t\t\t\t\t\t\t.nextSetBit(j + 1)) {\n\t\t\t\t\t\t\t\tint slot = sigParser.getSlotsFromTopOfStackForParameter(j);\n\t\t\t\t\t\t\t\tValueNumber valueNumber = valueNumberFrame.getStackValue(slot);\n\t\t\t\t\t\t\t\tif (valueNumberForThis != valueNumber)  derefs.add(location, valueNumber, PointerUsageRequiringNonNullValue\n\t\t\t\t\t\t\t\t\t\t.getPassedAsNonNullParameter(m, j));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\t\tAnalysisContext.reportMissingClass(e);\n\t\t\t\t\t}\n\n\t\t\t\t} else if (ins instanceof IFNONNULL && UnconditionalValueDerefAnalysis.isNullCheck(handle, cpg)) {\n\t\t\t\t\tValueNumber valueNumber = valueNumberFrame.getTopValue();\n\t\t\t\t\tderefs.add(location, valueNumber, PointerUsageRequiringNonNullValue\n\t\t\t\t\t\t\t.getPointerNullChecked());\n\t\t\t\t} else if (ins instanceof ARETURN && methodAnnotation == NullnessAnnotation.NONNULL) {\n\t\t\t\t\tValueNumber valueNumber = valueNumberFrame.getTopValue();\n\t\t\t\t\tif (valueNumberForThis != valueNumber) derefs.add(location, valueNumber, PointerUsageRequiringNonNullValue\n\t\t\t\t\t\t\t.getReturnFromNonNullMethod(thisMethod));\n\n\t\t\t\t} else if (ins instanceof PUTFIELD || ins instanceof PUTSTATIC) {\n\t\t\t\t\tFieldInstruction inf = (FieldInstruction) ins;\n\t\t\t\t\tXField field = XFactory.createXField(inf, cpg);\n\t\t\t\t\tNullnessAnnotation annotation = AnalysisContext.currentAnalysisContext()\n\t\t\t\t\t\t\t.getNullnessAnnotationDatabase().getResolvedAnnotation(field, false);\n\t\t\t\t\tif (annotation == NullnessAnnotation.NONNULL) {\n\t\t\t\t\t\tValueNumber valueNumber = valueNumberFrame.getTopValue();\n\t\t\t\t\t\tif (valueNumberForThis != valueNumber)  derefs.add(location, valueNumber, PointerUsageRequiringNonNullValue\n\t\t\t\t\t\t\t\t.getStoredIntoNonNullField(field));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t} catch (CFGBuilderException e) {\n\t\t\tAnalysisContext.logError(\"Error generating derefs for \" + thisMethod, e);\n\t\t} catch (DataflowAnalysisException e) {\n\t\t\tAnalysisContext.logError(\"Error generating derefs for \" + thisMethod, e);\n\t\t}\n\t\treturn derefs;\n\t}","commit_id":"6ddec22ac7f0e1e47f415182b1715446b3f5203d","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * If this is a method call instruction,\n\t * check to see if any of the parameters are @NonNull,\n\t * and treat them as dereferences.\n\t * @param thisMethod TODO\n\t * @param location  the Location of the instruction\n\t * @param vnaFrame  the ValueNumberFrame at the Location of the instruction\n\t * @param fact      the dataflow value to modify\n\t * \n\t * @throws DataflowAnalysisException\n\t */\n\tprivate void checkNonNullReturnValue(XMethod thisMethod, Location location, ValueNumberFrame vnaFrame, UnconditionalValueDerefSet fact) throws DataflowAnalysisException {\n\t\tINullnessAnnotationDatabase database = AnalysisContext.currentAnalysisContext().getNullnessAnnotationDatabase();\n\t\tif (database == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (database.getResolvedAnnotation(thisMethod, true) !=  NullnessAnnotation.NONNULL)\n\t\t\treturn;\n\t\tIsNullValueFrame invFrame = invDataflow.getFactAtLocation(location);\n\t\tif (!invFrame.isValid()) return;\n\n\t\t\n\t\tIsNullValue value = invFrame.getTopValue();\n\t\tif (value.isDefinitelyNotNull()) return;\n\t\tif (value.isDefinitelyNull()) return;\n\t\tValueNumber vn = vnaFrame.getTopValue();\n\t\tif (true)  fact.addDeref(vn, location);\n\t}","id":75139,"modified_method":"/**\n\t * If this is a method call instruction,\n\t * check to see if any of the parameters are @NonNull,\n\t * and treat them as dereferences.\n\t * @param thisMethod TODO\n\t * @param location  the Location of the instruction\n\t * @param vnaFrame  the ValueNumberFrame at the Location of the instruction\n\t * @param fact      the dataflow value to modify\n\t * \n\t * @throws DataflowAnalysisException\n\t */\n\tprivate void checkNonNullReturnValue(XMethod thisMethod, Location location, ValueNumberFrame vnaFrame, UnconditionalValueDerefSet fact) throws DataflowAnalysisException {\n\t\tINullnessAnnotationDatabase database = AnalysisContext.currentAnalysisContext().getNullnessAnnotationDatabase();\n\t\tif (database == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (database.getResolvedAnnotation(thisMethod, true) != NullnessAnnotation.NONNULL)\n\t\t\treturn;\n\t\tif (reportPotentialDereference(location, invDataflow.getFactAtLocation(location))) {\n\t\t\tValueNumber vn = vnaFrame.getTopValue();\n\t\t\tfact.addDeref(vn, location);\n\t\t}\n\t}","commit_id":"6ddec22ac7f0e1e47f415182b1715446b3f5203d","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private boolean isNullCheck(InstructionHandle h) {\n\t\tif (!(h.getInstruction() instanceof IFNONNULL)) \n\t\t\treturn false;\n\t\th = h.getNext();\n\t\tfinal Instruction newInstruction = h.getInstruction();\n\t\tif (!(newInstruction instanceof NEW))\n\t\t\treturn false;\n\t\tfinal ObjectType loadClassType = ((NEW)newInstruction).getLoadClassType(methodGen.getConstantPool());\n\t\tif (!loadClassType.getClassName().equals(\"java.lang.NullPointerException\"))\n\t\t\treturn false;\n\t\th = h.getNext();\n\t\treturn check(h, NULLCHECK1) || check(h, NULLCHECK2);\n\t\t\n\t}","id":75140,"modified_method":"public static boolean isNullCheck(InstructionHandle h, ConstantPoolGen cpg) {\n\t\tif (!(h.getInstruction() instanceof IFNONNULL)) \n\t\t\treturn false;\n\t\th = h.getNext();\n\t\tfinal Instruction newInstruction = h.getInstruction();\n\t\tif (!(newInstruction instanceof NEW))\n\t\t\treturn false;\n\t\tfinal ObjectType loadClassType = ((NEW)newInstruction).getLoadClassType(cpg);\n\t\tif (!loadClassType.getClassName().equals(\"java.lang.NullPointerException\"))\n\t\t\treturn false;\n\t\th = h.getNext();\n\t\treturn check(h, NULLCHECK1) || check(h, NULLCHECK2);\n\t\t\n\t}","commit_id":"6ddec22ac7f0e1e47f415182b1715446b3f5203d","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n\tpublic void transferInstruction(InstructionHandle handle,\n\t\t\tBasicBlock basicBlock, UnconditionalValueDerefSet fact)\n\t\t\tthrows DataflowAnalysisException {\n\n\t\tInstruction instruction = handle.getInstruction();\n\t    if (fact.isTop()) return;\n\t\tLocation location = new Location(handle, basicBlock);\n\n\t\t\n\t\t// If this is a call to an assertion method,\n\t\t// change the dataflow value to be TOP.\n\t\t// We don't want to report future derefs that would\n\t\t// be guaranteed only if the assertion methods\n\t\t// returns normally.\n\t\t// TODO: at some point, evaluate whether we should revisit this\n\t\tif (isAssertion(handle) // || handle.getInstruction() instanceof ATHROW \n\t\t\t\t) {\n\t\t\tif (DEBUG) System.out.println(\"MAKING BOTTOM0 AT: \" + location);\n\t\t\tfact.clear();\n\t\t\treturn;\n\t\t}\n\n\t\t// Get value number frame\n\t\tValueNumberFrame vnaFrame = vnaDataflow.getFactAtLocation(location);\n\t\tif (!vnaFrame.isValid()) {\n\t\t\tif (DEBUG) System.out.println(\"MAKING TOP1 AT: \" + location);\n\t\t\t// Probably dead code.\n\t\t\t// Assume this location can't be reached.\n\t\t\tmakeFactTop(fact);\n\t\t\treturn;\n\t\t}\n\t\tif (isNullCheck(handle)) {\n\t\t\thandleNullCheck(location, vnaFrame, fact);\n\t\t}\n\n\t\t// Check for calls to a method that unconditionally dereferences\n\t\t// a parameter.  Mark any such arguments as derefs.\n\t\tif (CHECK_CALLS && instruction instanceof InvokeInstruction) {\n\t\t\tcheckUnconditionalDerefDatabase(location, vnaFrame, fact);\n\t\t}\n\n\t\t// If this is a method call instruction,\n\t\t// check to see if any of the parameters are @NonNull,\n\t\t// and treat them as dereferences.\n\t\tif (CHECK_ANNOTATIONS && instruction instanceof InvokeInstruction) {\n\t\t\tcheckNonNullParams(location, vnaFrame, fact);\n\t\t}\n\n\t\tif (CHECK_ANNOTATIONS && instruction instanceof ARETURN) {\n\t\t\tXMethod thisMethod = XFactory.createXMethod(methodGen);\n\t\t\tcheckNonNullReturnValue(thisMethod, location, vnaFrame, fact);\n\t\t}\n\n\n\t\tif (CHECK_ANNOTATIONS && (instruction instanceof PUTFIELD || instruction instanceof PUTSTATIC)) {\n\t\t\tcheckNonNullPutField(location, vnaFrame, fact);\n\t\t}\n\n\n\t\t// Check to see if an instance value is dereferenced here\n\t\tcheckInstance(location, vnaFrame, fact);\n\n\t\tif (false) fact.cleanDerefSet(location, vnaFrame);\n\n\t\tif (DEBUG && fact.isTop()) System.out.println(\"MAKING TOP2 At: \" + location);\n\n\t}","id":75141,"modified_method":"@Override\n\tpublic void transferInstruction(InstructionHandle handle,\n\t\t\tBasicBlock basicBlock, UnconditionalValueDerefSet fact)\n\t\t\tthrows DataflowAnalysisException {\n\n\t\tInstruction instruction = handle.getInstruction();\n\t    if (fact.isTop()) return;\n\t\tLocation location = new Location(handle, basicBlock);\n\n\t\t\n\t\t// If this is a call to an assertion method,\n\t\t// change the dataflow value to be TOP.\n\t\t// We don't want to report future derefs that would\n\t\t// be guaranteed only if the assertion methods\n\t\t// returns normally.\n\t\t// TODO: at some point, evaluate whether we should revisit this\n\t\tif (isAssertion(handle) // || handle.getInstruction() instanceof ATHROW \n\t\t\t\t) {\n\t\t\tif (DEBUG) System.out.println(\"MAKING BOTTOM0 AT: \" + location);\n\t\t\tfact.clear();\n\t\t\treturn;\n\t\t}\n\n\t\t// Get value number frame\n\t\tValueNumberFrame vnaFrame = vnaDataflow.getFactAtLocation(location);\n\t\tif (!vnaFrame.isValid()) {\n\t\t\tif (DEBUG) System.out.println(\"MAKING TOP1 AT: \" + location);\n\t\t\t// Probably dead code.\n\t\t\t// Assume this location can't be reached.\n\t\t\tmakeFactTop(fact);\n\t\t\treturn;\n\t\t}\n\t\tif (isNullCheck(handle, methodGen.getConstantPool())) {\n\t\t\thandleNullCheck(location, vnaFrame, fact);\n\t\t}\n\n\t\t// Check for calls to a method that unconditionally dereferences\n\t\t// a parameter.  Mark any such arguments as derefs.\n\t\tif (CHECK_CALLS && instruction instanceof InvokeInstruction) {\n\t\t\tcheckUnconditionalDerefDatabase(location, vnaFrame, fact);\n\t\t}\n\n\t\t// If this is a method call instruction,\n\t\t// check to see if any of the parameters are @NonNull,\n\t\t// and treat them as dereferences.\n\t\tif (CHECK_ANNOTATIONS && instruction instanceof InvokeInstruction) {\n\t\t\tcheckNonNullParams(location, vnaFrame, fact);\n\t\t}\n\n\t\tif (CHECK_ANNOTATIONS && instruction instanceof ARETURN) {\n\t\t\tXMethod thisMethod = XFactory.createXMethod(methodGen);\n\t\t\tcheckNonNullReturnValue(thisMethod, location, vnaFrame, fact);\n\t\t}\n\n\n\t\tif (CHECK_ANNOTATIONS && (instruction instanceof PUTFIELD || instruction instanceof PUTSTATIC)) {\n\t\t\tcheckNonNullPutField(location, vnaFrame, fact);\n\t\t}\n\n\n\t\t// Check to see if an instance value is dereferenced here\n\t\tcheckInstance(location, vnaFrame, fact);\n\n\t\tif (false) fact.cleanDerefSet(location, vnaFrame);\n\n\t\tif (DEBUG && fact.isTop()) System.out.println(\"MAKING TOP2 At: \" + location);\n\n\t}","commit_id":"6ddec22ac7f0e1e47f415182b1715446b3f5203d","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void handleNullCheck(Location location,  ValueNumberFrame vnaFrame, UnconditionalValueDerefSet fact) throws DataflowAnalysisException {\n\t\tIsNullValueFrame invFrame = invDataflow.getFactAtLocation(location);\n\t\tif (!invFrame.isValid()) \n\t\t\treturn;\n\n\t\tIsNullValue value = invFrame.getTopValue();\n\t\tif (value.isDefinitelyNotNull()) return;\n\t\tif (value.isDefinitelyNull()) return;\n\t\tValueNumber vn = vnaFrame.getTopValue();\n\t\tif (true)  \n\t\t\tfact.addDeref(vn, location);\n\t}","id":75142,"modified_method":"private void handleNullCheck(Location location,  ValueNumberFrame vnaFrame, UnconditionalValueDerefSet fact) throws DataflowAnalysisException {\n\t\tif (reportPotentialDereference(location, invDataflow.getFactAtLocation(location))) {\n\t\t  ValueNumber vn = vnaFrame.getTopValue();\n\t\t  fact.addDeref(vn, location);\n\t\t}\n\t}","commit_id":"6ddec22ac7f0e1e47f415182b1715446b3f5203d","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Check whether or not the various interprocedural databases we can\n\t * use exist and are nonempty.\n\t */\n\tprivate void checkDatabases() {\n\t\tAnalysisContext analysisContext = AnalysisContext\n\t\t\t\t.currentAnalysisContext();\n\t\tunconditionalDerefParamDatabase = analysisContext\n\t\t\t\t.getUnconditionalDerefParamDatabase();\n\t\tif (false) {\n\t\tXFactory xFactory = AnalysisContext.currentXFactory();\n\t\t\n\t\tfor (XMethod xMethod : unconditionalDerefParamDatabase.getKeys()) {\n\t\t\tXMethod m2 = xFactory.intern(xMethod);\n\t\t\tif (!xMethod.equals(m2)) {\n\t\t\t\tSystem.out.println(\"WWW: \" + xMethod);\n\t\t\t\tSystem.out.println(\" ->: \" + m2);\n\t\t\t}\n\t\t}\n\t\t}\n\t}","id":75143,"modified_method":"/**\n\t * Check whether or not the various interprocedural databases we can\n\t * use exist and are nonempty.\n\t */\n\tprivate void checkDatabases() {\n\t\tAnalysisContext analysisContext = AnalysisContext.currentAnalysisContext();\n\t\tunconditionalDerefParamDatabase = analysisContext.getUnconditionalDerefParamDatabase();\t\n\t}","commit_id":"3d0d177fd58f919972e560279cb8945007cf8544","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Return whether or not given slot in given is-null frame\n\t * is definitely non-null.\n\t * \n\t * @param invFrame an IsNullValueFrame\n\t * @param slot     slot in the frame\n\t * @return true if value in the slot is definitely non-null, false otherwise\n\t */\n\tprivate boolean isNonNullValue(IsNullValueFrame invFrame, int slot) {\n\t\tif (invFrame == null || !invFrame.isValid()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn invFrame.getValue(slot).isDefinitelyNotNull();\n\t}","id":75144,"modified_method":"private boolean reportDereference(IsNullValueFrame invFrameAtNullCheck, int instance) {\n\t\tIsNullValue value = invFrameAtNullCheck.getValue(instance);\n\t\tif (value.isDefinitelyNotNull()) return false;\n\t\tif (value.isDefinitelyNull()) return false;\n\t\tif (IGNORE_DEREF_OF_NONNCP\n\t\t\t\t&& !value.isNullOnComplicatedPath()) return false;\n\t\treturn true;\n\t}","commit_id":"3d0d177fd58f919972e560279cb8945007cf8544","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Constructor.\n\t * \n\t * @param rdfs               the reverse depth-first-search (for the block order)\n\t * @param dfs TODO\n\t * @param cfg                the CFG for the method\n\t * @param methodGen          the MethodGen for the method\n\t * @param vnaDataflow\n\t * @param assertionMethods   AssertionMethods for the analyzed class\n\t */\n\tpublic UnconditionalValueDerefAnalysis(\n\t\t\tReverseDepthFirstSearch rdfs,\n\t\t\tDepthFirstSearch dfs,\n\t\t\tCFG cfg,\n\t\t\tMethodGen methodGen,\n\t\t\tValueNumberDataflow vnaDataflow,\n\t\t\tAssertionMethods assertionMethods\n\t\t\t) {\n\t\tsuper(rdfs, dfs);\n\t\tthis.cfg = cfg;\n\t\tthis.methodGen = methodGen;\n\t\tthis.vnaDataflow = vnaDataflow;\n\t\tthis.assertionMethods = assertionMethods;\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"UnconditionalValueDerefAnalysis analysis \" + methodGen.getClassName() + \".\" + methodGen.getName() + \" : \" + methodGen.getSignature());\n\t\t}\n\t\tif (DEBUG && IGNORE_DEREF_OF_NONNULL) {\n\t\t\tSystem.out.println(\"** Ignoring dereferences of definitely non-null values\");\n\t\t}\n\t}","id":75145,"modified_method":"/**\n\t * Constructor.\n\t * \n\t * @param rdfs               the reverse depth-first-search (for the block order)\n\t * @param dfs TODO\n\t * @param cfg                the CFG for the method\n\t * @param methodGen          the MethodGen for the method\n\t * @param vnaDataflow\n\t * @param assertionMethods   AssertionMethods for the analyzed class\n\t */\n\tpublic UnconditionalValueDerefAnalysis(\n\t\t\tReverseDepthFirstSearch rdfs,\n\t\t\tDepthFirstSearch dfs,\n\t\t\tCFG cfg,\n\t\t\tMethodGen methodGen,\n\t\t\tValueNumberDataflow vnaDataflow,\n\t\t\tAssertionMethods assertionMethods\n\t\t\t) {\n\t\tsuper(rdfs, dfs);\n\t\tthis.cfg = cfg;\n\t\tthis.methodGen = methodGen;\n\t\tthis.vnaDataflow = vnaDataflow;\n\t\tthis.assertionMethods = assertionMethods;\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"UnconditionalValueDerefAnalysis analysis \" + methodGen.getClassName() + \".\" + methodGen.getName() + \" : \" + methodGen.getSignature());\n\t\t}\n\n\t}","commit_id":"3d0d177fd58f919972e560279cb8945007cf8544","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * If this is a method call instruction,\n\t * check to see if any of the parameters are @NonNull,\n\t * and treat them as dereferences.\n\t * \n\t * @param location  the Location of the instruction\n\t * @param vnaFrame  the ValueNumberFrame at the Location of the instruction\n\t * @param fact      the dataflow value to modify\n\t * @throws DataflowAnalysisException\n\t */\n\tprivate void checkNonNullParams(Location location, ValueNumberFrame vnaFrame, UnconditionalValueDerefSet fact) throws DataflowAnalysisException {\n\t\tNullnessAnnotationDatabase database = AnalysisContext.currentAnalysisContext().getNullnessAnnotationDatabase();\n\t\tif (database == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tInvokeInstruction inv = (InvokeInstruction) location.getHandle().getInstruction(); \n\t\tXMethod called = XFactory.createXMethod(\n\t\t\t\tinv,\n\t\t\t\tmethodGen.getConstantPool());\n\t\tSignatureParser sigParser = new SignatureParser(called.getSignature());\n\t\tint numParams = sigParser.getNumParameters();\n\n\t\tfor (int i = 0; i < numParams; i++) {\n\t\t\tif (IGNORE_DEREF_OF_NONNULL\n\t\t\t\t\t&& invDataflow != null) {\n\t\t\t\tIsNullValueFrame invFrame = invDataflow.getFactAtLocation(location);\n\t\t\t\tif (isNonNullValue(invFrame, invFrame.getArgumentSlot(i, numParams))) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\tif (database.parameterMustBeNonNull(called, i)) {\n\t\t\t\t// Get the corresponding value number\n\t\t\t\tValueNumber vn = vnaFrame.getArgument(inv, methodGen.getConstantPool(), i, numParams);\n\t\t\t\tfact.addDeref(vn, location);\n\t\t\t}\n\t\t}\n\t}","id":75146,"modified_method":"/**\n\t * If this is a method call instruction,\n\t * check to see if any of the parameters are @NonNull,\n\t * and treat them as dereferences.\n\t * \n\t * @param location  the Location of the instruction\n\t * @param vnaFrame  the ValueNumberFrame at the Location of the instruction\n\t * @param fact      the dataflow value to modify\n\t * @throws DataflowAnalysisException\n\t */\n\tprivate void checkNonNullParams(Location location, ValueNumberFrame vnaFrame, UnconditionalValueDerefSet fact) throws DataflowAnalysisException {\n\t\tNullnessAnnotationDatabase database = AnalysisContext.currentAnalysisContext().getNullnessAnnotationDatabase();\n\t\tif (database == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tInvokeInstruction inv = (InvokeInstruction) location.getHandle().getInstruction(); \n\t\tXMethod called = XFactory.createXMethod(\n\t\t\t\tinv,\n\t\t\t\tmethodGen.getConstantPool());\n\t\tSignatureParser sigParser = new SignatureParser(called.getSignature());\n\t\tint numParams = sigParser.getNumParameters();\n\n\t\tfor (int i = 0; i < numParams; i++) {\n\t\t\tIsNullValueFrame invFrame = invDataflow.getFactAtLocation(location);\n\t\t\tint slot = invFrame.getArgumentSlot(i, numParams);\n\t\t\tif (reportDereference(invFrame, slot) \n\t\t\t\t\t&& database.parameterMustBeNonNull(called, i)) {\n\t\t\t\t// Get the corresponding value number\n\t\t\t\tValueNumber vn = vnaFrame.getArgument(inv, methodGen.getConstantPool(), i, numParams);\n\t\t\t\tfact.addDeref(vn, location);\n\t\t\t}\n\t\t}\n\t}","commit_id":"3d0d177fd58f919972e560279cb8945007cf8544","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Check to see if the instruction has a null check associated with it,\n\t * and if so, add a dereference.\n\t * \n\t * @param location the Location of the instruction\n\t * @param vnaFrame ValueNumberFrame at the Location of the instruction\n\t * @param fact     the dataflow value to modify\n\t * @throws DataflowAnalysisException\n\t */\n\tprivate void checkInstance(\n\t\t\tLocation location,\n\t\t\tValueNumberFrame vnaFrame,\n\t\t\tUnconditionalValueDerefSet fact) throws DataflowAnalysisException {\n\t\t// See if this instruction has a null check.\n\t\t// If it does, the fall through predecessor will be\n\t\t// identify itself as the null check.\n\t\tif (!location.isFirstInstructionInBasicBlock()) {\n\t\t\treturn;\n\t\t}\n\t\tBasicBlock fallThroughPredecessor =\n\t\t\tcfg.getPredecessorWithEdgeType(location.getBasicBlock(), EdgeTypes.FALL_THROUGH_EDGE);\n\t\tif (fallThroughPredecessor == null || !fallThroughPredecessor.isNullCheck()) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Get the null-checked value\n\t\tValueNumber vn = vnaFrame.getInstance(location.getHandle().getInstruction(), methodGen.getConstantPool()); \n\t\t\n\t\t// Ignore dereferences of this\n\t\tif (!methodGen.isStatic()) {\n\t\t\tValueNumber v = vnaFrame.getValue(0);\n\t\t\tif (v.equals(vn)) return;\n\t\t}\n\t\tif (vn.hasFlag(ValueNumber.CONSTANT_CLASS_OBJECT)) return;\n\n\t\tIsNullValueFrame startFact = null;\n\n\t\tif (invDataflow != null) {\n\t\t\tstartFact = invDataflow.getStartFact(fallThroughPredecessor);\n\t\t}\n\n\t\t// Ignore dereferences of values that are definitely non-null\n\t\tif (IGNORE_DEREF_OF_NONNULL\n\t\t\t\t&& invDataflow != null\n\t\t\t\t&& isDerefOfNonNullValue(location, startFact)) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (IGNORE_DEREF_OF_NONNCP\n\t\t\t\t&& invDataflow != null\n\t\t\t\t&& !isDerefOfNullOnComplexPathValue(location, startFact)) {\n\t\t\treturn;\n\t\t}\n\t\t\n        if ( invDataflow != null\n                && isDerefOfDefinitelyNullValue(location, startFact)) {\n            return;\n        }\n    \n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"FOUND GUARANTEED DEREFERENCE\");\n\t\t\tSystem.out.println(\"Load: \" + vnaFrame.getLoad(vn));\n\t\t\tSystem.out.println(\"Pred: \" + fallThroughPredecessor);\n\t\t\tSystem.out.println(\"startFact: \" + startFact);\n\t\t\tSystem.out.println(\"Location: \" + location);\n\t\t\tSystem.out.println(\"Value number frame: \" + vnaFrame);\n\t\t\tSystem.out.println(\"Dereferenced valueNumber: \" + vn);\n\t\t\tSystem.out.println(\"invDataflow: \" + startFact);\n\t\t\tSystem.out.println(\"IGNORE_DEREF_OF_NONNCP: \" + IGNORE_DEREF_OF_NONNCP);\n\t\t\tSystem.out.println(\"IGNORE_DEREF_OF_NONNULL: \" + IGNORE_DEREF_OF_NONNULL);\n\t\t\tSystem.out.println(\"isNonNull: \" + isDerefOfNonNullValue(location, startFact));\n\t\t\tSystem.out.println(\"isDerefOfNullOnComplexPathValue: \" + isDerefOfNullOnComplexPathValue(location, startFact));\n\n\t\t\t\n\t\t}\n\t\t// Mark the value number as being dereferenced at this location\n\t\tfact.addDeref(vn, location);\n\t}","id":75147,"modified_method":"/**\n\t * Check to see if the instruction has a null check associated with it,\n\t * and if so, add a dereference.\n\t * \n\t * @param location the Location of the instruction\n\t * @param vnaFrame ValueNumberFrame at the Location of the instruction\n\t * @param fact     the dataflow value to modify\n\t * @throws DataflowAnalysisException\n\t */\n\tprivate void checkInstance(\n\t\t\tLocation location,\n\t\t\tValueNumberFrame vnaFrame,\n\t\t\tUnconditionalValueDerefSet fact) throws DataflowAnalysisException {\n\t\t// See if this instruction has a null check.\n\t\t// If it does, the fall through predecessor will be\n\t\t// identify itself as the null check.\n\t\tif (!location.isFirstInstructionInBasicBlock()) {\n\t\t\treturn;\n\t\t}\n\t\tif (invDataflow == null) return;\n\t\tBasicBlock fallThroughPredecessor =\n\t\t\tcfg.getPredecessorWithEdgeType(location.getBasicBlock(), EdgeTypes.FALL_THROUGH_EDGE);\n\t\tif (fallThroughPredecessor == null || !fallThroughPredecessor.isNullCheck()) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Get the null-checked value\n\t\tValueNumber vn = vnaFrame.getInstance(location.getHandle().getInstruction(), methodGen.getConstantPool()); \n\t\t\n\t\t// Ignore dereferences of this\n\t\tif (!methodGen.isStatic()) {\n\t\t\tValueNumber v = vnaFrame.getValue(0);\n\t\t\tif (v.equals(vn)) return;\n\t\t}\n\t\tif (vn.hasFlag(ValueNumber.CONSTANT_CLASS_OBJECT)) return;\n\n\t\tIsNullValueFrame startFact = null;\n\n\n\t\tstartFact = invDataflow.getStartFact(fallThroughPredecessor);\n\n\n\t\tif (!startFact.isValid()) return;\n\n\t\tint slot = startFact.getInstanceSlot(\n\t\t\t\tlocation.getHandle().getInstruction(),\n\t\t\t\tmethodGen.getConstantPool());\n        if (!reportDereference(startFact, slot)) return;\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"FOUND GUARANTEED DEREFERENCE\");\n\t\t\tSystem.out.println(\"Load: \" + vnaFrame.getLoad(vn));\n\t\t\tSystem.out.println(\"Pred: \" + fallThroughPredecessor);\n\t\t\tSystem.out.println(\"startFact: \" + startFact);\n\t\t\tSystem.out.println(\"Location: \" + location);\n\t\t\tSystem.out.println(\"Value number frame: \" + vnaFrame);\n\t\t\tSystem.out.println(\"Dereferenced valueNumber: \" + vn);\n\t\t\tSystem.out.println(\"invDataflow: \" + startFact);\n\t\t\tSystem.out.println(\"IGNORE_DEREF_OF_NONNCP: \" + IGNORE_DEREF_OF_NONNCP);\n\t\t}\n\t\t// Mark the value number as being dereferenced at this location\n\t\tfact.addDeref(vn, location);\n\t}","commit_id":"3d0d177fd58f919972e560279cb8945007cf8544","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Check method call at given location to see if it unconditionally\n\t * dereferences a parameter.  Mark any such arguments as derefs.\n\t * \n\t * @param location the Location of the method call\n\t * @param vnaFrame ValueNumberFrame at the Location\n\t * @param fact     the dataflow value to modify\n\t * @throws DataflowAnalysisException \n\t */\n\tprivate void checkUnconditionalDerefDatabase(\n\t\t\tLocation location,\n\t\t\tValueNumberFrame vnaFrame,\n\t\t\tUnconditionalValueDerefSet fact) throws DataflowAnalysisException {\n\t\t\n\t\tParameterNullnessPropertyDatabase database =\n\t\t\tAnalysisContext.currentAnalysisContext().getUnconditionalDerefParamDatabase();\n\t\tif (database == null) {\n\t\t\tif (DEBUG_CHECK_CALLS) {\n\t\t\t\tSystem.out.println(\"no database!\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tInvokeInstruction inv = (InvokeInstruction) location.getHandle().getInstruction();\n\t\tTypeFrame typeFrame = typeDataflow.getFactAtLocation(location);\n\t\tif (!typeFrame.isValid()) {\n\t\t\tif (DEBUG_CHECK_CALLS) {\n\t\t\t\tSystem.out.println(\"invalid type frame!\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tSignatureParser sigParser = new SignatureParser(inv.getSignature(methodGen.getConstantPool()));\n\t\tint numParams = sigParser.getNumParameters();\n\t\t\n\t\ttry {\n\t\t\tSet<JavaClassAndMethod> targetSet = Hierarchy.resolveMethodCallTargets(\n\t\t\t\t\tinv,\n\t\t\t\t\ttypeFrame,\n\t\t\t\t\tmethodGen.getConstantPool());\n\t\t\t\n\t\t\tif (targetSet.isEmpty()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t// Compute the intersection of all properties\n\t\t\tParameterNullnessProperty derefParamSet = null;\n\t\t\tfor (JavaClassAndMethod target : targetSet) {\n\t\t\t\tif (DEBUG_CHECK_CALLS) {\n\t\t\t\t\tSystem.out.print(\"Checking \" + target + \": \");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tParameterNullnessProperty targetDerefParamSet = database.getProperty(target.toXMethod());\n\t\t\t\tif (targetDerefParamSet == null) {\n\t\t\t\t\t// Hmm...no information for this target.\n\t\t\t\t\t// assume it doesn't dereference anything\n\t\t\t\t\tif (DEBUG_CHECK_CALLS) {\n\t\t\t\t\t\tSystem.out.println(\"==> no information, assume no guaranteed dereferences\");\n\t\t\t\t\t}\n\t\t\t\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (DEBUG_CHECK_CALLS) {\n\t\t\t\t\tSystem.out.println(\"==> \" + targetDerefParamSet);\n\t\t\t\t}\n\t\t\t\tif (derefParamSet == null) {\n\t\t\t\t\tderefParamSet = new ParameterNullnessProperty();\n\t\t\t\t\tderefParamSet.copyFrom(targetDerefParamSet);\n\t\t\t\t} else {\n\t\t\t\t\tderefParamSet.intersectWith(targetDerefParamSet);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (derefParamSet == null || derefParamSet.isEmpty()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (DEBUG_CHECK_CALLS) {\n\t\t\t\tSystem.out.println(\"** Summary of call: \" + derefParamSet);\n\t\t\t}\n\t\t\t\n\t\t\tIsNullValueFrame invFrame = null;\n\t\t\tif (IGNORE_DEREF_OF_NONNULL && invDataflow != null) {\n\t\t\t\tinvFrame = invDataflow.getFactAtLocation(location);\n\t\t\t\tif (!invFrame.isValid()) {\n\t\t\t\t\tinvFrame = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tIterator<String> paramSigIterator = sigParser.parameterSignatureIterator();\n            Stack<String> paramSigStack = new Stack<String>();\n            while(paramSigIterator.hasNext()) paramSigStack.push(paramSigIterator.next());\n            \n            int stackPos = 0;\n\t\t\tfor (int i= numParams-1; i >= 0; i--) {\n                String paramSig = paramSigStack.pop();\n                if (DEBUG_CHECK_CALLS) System.out.println(\"Param# \" + i + \",  stack pos = \" + stackPos + \", sig = \" + paramSig);\n                if (paramSig.equals(\"D\") || paramSig.equals(\"F\")) {\n                    stackPos += 2;\n                    continue;\n                }\n                \n\t\t\t\tif (!derefParamSet.isNonNull(i)) {\n                    stackPos++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n                 if (DEBUG_CHECK_CALLS)  System.out.println(\"  parameter must be non null\");\n                    \n\t\t\t\tint argSlot = vnaFrame.getStackLocation(stackPos++);\n\t\t\t\tif (invFrame != null) {\n\t\t\t\t\tIsNullValue val = invFrame.getValue(argSlot);\n                     if (DEBUG_CHECK_CALLS)  System.out.println(\"inv: \" + val);\n\t\t\t\t\tif (val.isDefinitelyNotNull()) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (IGNORE_DEREF_OF_NONNCP && !val.isNullOnComplicatedPath()) continue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfact.addDeref(vnaFrame.getValue(argSlot), location);\n\t\t\t\tif (DEBUG_CHECK_CALLS ||VERBOSE_NULLARG_DEBUG) {\n\t\t\t\t\tSystem.out.println(\"Adding deref of \" + vnaFrame.getValue(argSlot) + \" at location \" + location);\n\t\t\t\t\tfor (JavaClassAndMethod target : targetSet) {\n\n\t\t\t\t\t\tSystem.out.print(\"Checking \" + target + \": \");\n\t\t\t\t\t\tParameterNullnessProperty targetDerefParamSet = database.getProperty(target.toXMethod());\n\t\t\t\t\t\tif (targetDerefParamSet == null) {\n\t\t\t\t\t\t\tSystem.out.println(\" ==> unknown\");\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tSystem.out.println(\"==> \" + targetDerefParamSet);\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tAnalysisContext.reportMissingClass(e);\n\t\t}\n\t}","id":75148,"modified_method":"/**\n\t * Check method call at given location to see if it unconditionally\n\t * dereferences a parameter.  Mark any such arguments as derefs.\n\t * \n\t * @param location the Location of the method call\n\t * @param vnaFrame ValueNumberFrame at the Location\n\t * @param fact     the dataflow value to modify\n\t * @throws DataflowAnalysisException \n\t */\n\tprivate void checkUnconditionalDerefDatabase(\n\t\t\tLocation location,\n\t\t\tValueNumberFrame vnaFrame,\n\t\t\tUnconditionalValueDerefSet fact) throws DataflowAnalysisException {\n\t\t\n\t\tParameterNullnessPropertyDatabase database =\n\t\t\tAnalysisContext.currentAnalysisContext().getUnconditionalDerefParamDatabase();\n\t\tif (database == null) {\n\t\t\tif (DEBUG_CHECK_CALLS) {\n\t\t\t\tSystem.out.println(\"no database!\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tInvokeInstruction inv = (InvokeInstruction) location.getHandle().getInstruction();\n\t\tTypeFrame typeFrame = typeDataflow.getFactAtLocation(location);\n\t\tif (!typeFrame.isValid()) {\n\t\t\tif (DEBUG_CHECK_CALLS) {\n\t\t\t\tSystem.out.println(\"invalid type frame!\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tSignatureParser sigParser = new SignatureParser(inv.getSignature(methodGen.getConstantPool()));\n\t\tint numParams = sigParser.getNumParameters();\n\t\t\n\t\ttry {\n\t\t\tSet<JavaClassAndMethod> targetSet = Hierarchy.resolveMethodCallTargets(\n\t\t\t\t\tinv,\n\t\t\t\t\ttypeFrame,\n\t\t\t\t\tmethodGen.getConstantPool());\n\t\t\t\n\t\t\tif (targetSet.isEmpty()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t// Compute the intersection of all properties\n\t\t\tParameterNullnessProperty derefParamSet = null;\n\t\t\tfor (JavaClassAndMethod target : targetSet) {\n\t\t\t\tif (DEBUG_CHECK_CALLS) {\n\t\t\t\t\tSystem.out.print(\"Checking \" + target + \": \");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tParameterNullnessProperty targetDerefParamSet = database.getProperty(target.toXMethod());\n\t\t\t\tif (targetDerefParamSet == null) {\n\t\t\t\t\t// Hmm...no information for this target.\n\t\t\t\t\t// assume it doesn't dereference anything\n\t\t\t\t\tif (DEBUG_CHECK_CALLS) {\n\t\t\t\t\t\tSystem.out.println(\"==> no information, assume no guaranteed dereferences\");\n\t\t\t\t\t}\n\t\t\t\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (DEBUG_CHECK_CALLS) {\n\t\t\t\t\tSystem.out.println(\"==> \" + targetDerefParamSet);\n\t\t\t\t}\n\t\t\t\tif (derefParamSet == null) {\n\t\t\t\t\tderefParamSet = new ParameterNullnessProperty();\n\t\t\t\t\tderefParamSet.copyFrom(targetDerefParamSet);\n\t\t\t\t} else {\n\t\t\t\t\tderefParamSet.intersectWith(targetDerefParamSet);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (derefParamSet == null || derefParamSet.isEmpty()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (DEBUG_CHECK_CALLS) {\n\t\t\t\tSystem.out.println(\"** Summary of call: \" + derefParamSet);\n\t\t\t}\n\t\t\t\n\t\t\tIsNullValueFrame invFrame = invDataflow.getFactAtLocation(location);\n\n\t\t\tif (invFrame != null && invFrame.isValid()) {\n\t\t\t\tIterator<String> paramSigIterator = sigParser.parameterSignatureIterator();\n\t\t\t\tStack<String> paramSigStack = new Stack<String>();\n\t\t\t\twhile(paramSigIterator.hasNext()) paramSigStack.push(paramSigIterator.next());\n\n\t\t\t\tint stackPos = 0;\n\t\t\t\tfor (int i= numParams-1; i >= 0; i--) {\n\t\t\t\t\tString paramSig = paramSigStack.pop();\n\t\t\t\t\tif (DEBUG_CHECK_CALLS) System.out.println(\"Param# \" + i + \",  stack pos = \" + stackPos + \", sig = \" + paramSig);\n\t\t\t\t\tif (paramSig.equals(\"D\") || paramSig.equals(\"F\")) {\n\t\t\t\t\t\tstackPos += 2;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!derefParamSet.isNonNull(i)) {\n\t\t\t\t\t\tstackPos++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (DEBUG_CHECK_CALLS)  System.out.println(\"  parameter must be non null\");\n\n\t\t\t\t\tint argSlot = vnaFrame.getStackLocation(stackPos++);\n\t\t\t\t\tif (!reportDereference(invFrame, argSlot)) continue;\n\n\t\t\t\t\tfact.addDeref(vnaFrame.getValue(argSlot), location);\n\t\t\t\t\tif (DEBUG_CHECK_CALLS ||VERBOSE_NULLARG_DEBUG) {\n\t\t\t\t\t\tSystem.out.println(\"Adding deref of \" + vnaFrame.getValue(argSlot) + \" at location \" + location);\n\t\t\t\t\t\tfor (JavaClassAndMethod target : targetSet) {\n\n\t\t\t\t\t\t\tSystem.out.print(\"Checking \" + target + \": \");\n\t\t\t\t\t\t\tParameterNullnessProperty targetDerefParamSet = database.getProperty(target.toXMethod());\n\t\t\t\t\t\t\tif (targetDerefParamSet == null) {\n\t\t\t\t\t\t\t\tSystem.out.println(\" ==> unknown\");\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\tSystem.out.println(\"==> \" + targetDerefParamSet);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tAnalysisContext.reportMissingClass(e);\n\t\t}\n\t}","commit_id":"3d0d177fd58f919972e560279cb8945007cf8544","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n    {\n        // Ajax calls are form encoded\n        boolean join = Boolean.parseBoolean(request.getParameter(\"join\"));\n        String message = request.getParameter(\"message\");\n        String username = request.getParameter(\"user\");\n\n        LOG.debug(\"doPost called. join={},message={},username={}\", join, message, username);\n        if (username == null)\n        {\n            LOG.debug(\"no paramter user set, sending 503\");\n            response.sendError(503, \"user==null\");\n            return;\n        }\n\n        Map<String, Member> room = getRoom(request.getPathInfo());\n        Member member = getMember(username, room);\n\n        if (message != null)\n        {\n            sendMessageToAllMembers(message, username, room);\n        }\n        // If a message is set, we only want to enter poll mode if the user is a new user. This is necessary to avoid\n        // two parallel requests per user (one is already in async wait and the new one). Sending a message will\n        // dispatch to an existing poll request if necessary and the client will issue a new request to receive the\n        // next message or long poll again.\n        if (message == null || join)\n        {\n            synchronized (member)\n            {\n                LOG.debug(\"Queue size: {}\", member._queue.size());\n                if (member._queue.size() > 0)\n                {\n                    sendSingleMessage(response, member);\n                }\n                else\n                {\n                    LOG.debug(\"starting async\");\n                    AsyncContext async = request.startAsync();\n                    async.setTimeout(asyncTimeout);\n                    async.addListener(member);\n                    if (!member._async.compareAndSet(null, async))\n                        throw new IllegalStateException();\n                }\n            }\n        }\n    }","id":75149,"modified_method":"@Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n    {\n        // Ajax calls are form encoded\n        boolean join = Boolean.parseBoolean(request.getParameter(\"join\"));\n        String message = request.getParameter(\"message\");\n        String username = request.getParameter(\"user\");\n\n        LOG.debug(\"doPost called. join={},message={},username={}\", join, message, username);\n        if (username == null)\n        {\n            LOG.debug(\"no paramter user set, sending 503\");\n            response.sendError(503, \"user==null\");\n            return;\n        }\n\n        Map<String, Member> room = getRoom(request.getPathInfo());\n        Member member = getMember(username, room);\n\n        if (message != null)\n        {\n            sendMessageToAllMembers(message, username, room);\n        }\n        // If a message is set, we only want to enter poll mode if the user is a new user. This is necessary to avoid\n        // two parallel requests per user (one is already in async wait and the new one). Sending a message will\n        // dispatch to an existing poll request if necessary and the client will issue a new request to receive the\n        // next message or long poll again.\n        if (message == null || join)\n        {\n            synchronized (member)\n            {\n                LOG.debug(\"Queue size: {}\", member._queue.size());\n                if (member._queue.size() > 0)\n                {\n                    sendSingleMessage(response, member);\n                }\n                else\n                {\n                    LOG.debug(\"starting async\");\n                    AsyncContext async = request.startAsync();\n                    async.setTimeout(asyncTimeout);\n                    async.addListener(member);\n                    member._async.set(async);\n                }\n            }\n        }\n    }","commit_id":"74a75e3d42e38c08fcc58c286f2dce0a70c46a9b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n    {\n        // Ajax calls are form encoded\n        boolean join = Boolean.parseBoolean(request.getParameter(\"join\"));\n        String message = request.getParameter(\"message\");\n        String username = request.getParameter(\"user\");\n\n        LOG.debug(\"doPost called. join={},message={},username={}\", join, message, username);\n        if (username == null)\n        {\n            LOG.debug(\"no paramter user set, sending 503\");\n            response.sendError(503, \"user==null\");\n            return;\n        }\n\n        Map<String, Member> room = getRoom(request.getPathInfo());\n        Member member = getMember(username, room);\n\n        if (message != null)\n        {\n            sendMessageToAllMembers(message, username, room);\n        }\n        // If a message is set, we only want to enter poll mode if the user is a new user. This is necessary to avoid\n        // two parallel requests per user (one is already in async wait and the new one). Sending a message will\n        // dispatch to an existing poll request if necessary and the client will issue a new request to receive the\n        // next message or long poll again.\n        if (message == null || join)\n        {\n            synchronized (member)\n            {\n                LOG.debug(\"Queue size: {}\", member._queue.size());\n                if (member._queue.size() > 0)\n                {\n                    sendSingleMessage(response, member);\n                }\n                else\n                {\n                    LOG.debug(\"starting async\");\n                    AsyncContext async = request.startAsync();\n                    async.setTimeout(asyncTimeout);\n                    async.addListener(member);\n                    if (!member._async.compareAndSet(null, async))\n                        throw new IllegalStateException();\n                }\n            }\n        }\n    }","id":75150,"modified_method":"@Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n    {\n        // Ajax calls are form encoded\n        boolean join = Boolean.parseBoolean(request.getParameter(\"join\"));\n        String message = request.getParameter(\"message\");\n        String username = request.getParameter(\"user\");\n\n        LOG.debug(\"doPost called. join={},message={},username={}\", join, message, username);\n        if (username == null)\n        {\n            LOG.debug(\"no paramter user set, sending 503\");\n            response.sendError(503, \"user==null\");\n            return;\n        }\n\n        Map<String, Member> room = getRoom(request.getPathInfo());\n        Member member = getMember(username, room);\n\n        if (message != null)\n        {\n            sendMessageToAllMembers(message, username, room);\n        }\n        // If a message is set, we only want to enter poll mode if the user is a new user. This is necessary to avoid\n        // two parallel requests per user (one is already in async wait and the new one). Sending a message will\n        // dispatch to an existing poll request if necessary and the client will issue a new request to receive the\n        // next message or long poll again.\n        if (message == null || join)\n        {\n            synchronized (member)\n            {\n                LOG.debug(\"Queue size: {}\", member._queue.size());\n                if (member._queue.size() > 0)\n                {\n                    sendSingleMessage(response, member);\n                }\n                else\n                {\n                    LOG.debug(\"starting async\");\n                    AsyncContext async = request.startAsync();\n                    async.setTimeout(asyncTimeout);\n                    async.addListener(member);\n                    member._async.set(async);\n                }\n            }\n        }\n    }","commit_id":"2e064351a12f68d526e5bac3e3a96a49165df7fd","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void error( ) {\n    LOG.debug( \"Transition error(): \" + this.currentTransition.get( ) );\n    if ( this.currentTransition.get( ) == null ) {\n      Exceptions.trace( new IllegalStateException( \"error() called when there is no currently pending transition: \" + this.toString( ) ) );\n    } else {\n      ActiveTransition tr = this.currentTransition.getAndSet( null );\n      if ( !this.state.compareAndSet( tr.getTransitionRule( ).getToState( ), tr.getTransitionRule( ).getErrorState( ), true,\n                                      tr.getTransitionRule( ).getErrorStateMark( ) ) ) {\n        this.state.set( this.state.getReference( ), false );\n        Exceptions.trace( new IllegalStateException( \"Failed to apply toState for the transition: \" + tr.toString( ) + \" for current state: \"\n                                                              + this.toString( ) ) );\n      }\n      if ( !this.state.getReference( ).equals( tr.getTransitionRule( ).getErrorState( ) ) ) {\n        this.state.set( tr.getTransitionRule( ).getErrorState( ), false );\n        this.fireInListeners( tr.getTransitionRule( ).getErrorState( ) );\n      } else {\n        this.state.set( tr.getTransitionRule( ).getErrorState( ), false );\n      }\n    }\n  }","id":75151,"modified_method":"private void error( ) {\n    LOG.debug( \"Transition error(): \" + this.toString( ) );\n    if ( !this.state.isMarked( ) ) {\n      Exceptions.trace( new IllegalStateException( \"commit() called when there is no currently pending transition: \" + this.toString( ) ) );\n    } else {\n      ActiveTransition tr = this.currentTransition.getAndSet( null );\n      this.state.set( tr.getTransitionRule( ).getErrorState( ), tr.getTransitionRule( ).getErrorStateMark( ) );\n      if ( !tr.getTransitionRule( ).getFromState( ).equals( tr.getTransitionRule( ).getErrorState( ) ) ) {\n        this.state.set( tr.getTransitionRule( ).getErrorState( ), false );\n        this.fireInListeners( tr.getTransitionRule( ).getErrorState( ) );\n      } else {\n        this.state.set( tr.getTransitionRule( ).getErrorState( ), false );\n      }\n    }\n  }","commit_id":"8ece14fd8607410b8d4f3c2cd907d50244cd5a83","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"/**\n   * @see com.eucalyptus.util.fsm.State#commit()\n   */\n  private void commit( ) {\n    LOG.debug( \"Transition commit(): \" + this.currentTransition.get( ) );\n    if ( this.currentTransition.get( ) == null ) {\n      Exceptions.trace( new IllegalStateException( \"commit() called when there is no currently pending transition: \" + this.toString( ) ) );\n    } else {\n      ActiveTransition tr = this.currentTransition.getAndSet( null );\n      boolean doFireInListeners = !this.state.getReference( ).equals( tr.getTransitionRule( ).getFromState( ) );\n      if ( !this.state.compareAndSet( tr.getTransitionRule( ).getToState( ), tr.getTransitionRule( ).getToState( ), true,\n                                      tr.getTransitionRule( ).getToStateMark( ) ) ) {\n        this.state.set( this.state.getReference( ), false );\n        Exceptions.trace( new IllegalStateException( \"Failed to apply toState for the transition: \" + tr.toString( ) + \" for current state: \"\n                                                              + this.toString( ) ) );\n      }\n      if ( doFireInListeners ) {\n        this.fireInListeners( tr.getTransitionRule( ).getToState( ) );\n      }\n    }\n  }","id":75152,"modified_method":"/**\n   * @see com.eucalyptus.util.fsm.State#commit()\n   */\n  private void commit( ) {\n    LOG.debug( \"Transition commit(): \" + this.currentTransition.get( ) );\n    if ( !this.state.isMarked( ) ) {\n      Exceptions.trace( new IllegalStateException( \"commit() called when there is no currently pending transition: \" + this.toString( ) ) );\n      this.currentTransition.set( null );\n    } else {\n      ActiveTransition tr = this.currentTransition.getAndSet( null );\n      this.state.set( tr.getTransitionRule( ).getToState( ), tr.getTransitionRule( ).getToStateMark( ) );\n      if ( !tr.getTransitionRule( ).getFromState( ).equals( tr.getTransitionRule( ).getToState( ) ) ) {\n        this.state.set( tr.getTransitionRule( ).getToState( ), false );\n        this.fireInListeners( tr.getTransitionRule( ).getToState( ) );\n      } else {\n        this.state.set( tr.getTransitionRule( ).getToState( ), false );\n      }\n    }\n  }","commit_id":"8ece14fd8607410b8d4f3c2cd907d50244cd5a83","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void rollback( ) {\n    LOG.debug( \"Transition debug(): \" + this.currentTransition.get( ) );\n    if ( this.currentTransition.get( ) == null ) {\n      if ( this.state.isMarked( ) ) {\n        this.state.set( this.state.getReference( ), false );\n      }\n      Exceptions.trace( new IllegalStateException( \"rollback() called when there is no currently pending transition: \" + this.toString( ) ) );\n    } else {\n      ActiveTransition tr = this.currentTransition.getAndSet( null );\n      if ( !this.state.compareAndSet( tr.getTransitionRule( ).getToState( ), tr.getTransitionRule( ).getFromState( ), true,\n                                      tr.getTransitionRule( ).getFromStateMark( ) ) ) {\n        Exceptions.trace( new IllegalStateException( \"Failed to apply toState for the transition: \" + tr.toString( ) + \" for current state: \"\n                                                            + this.toString( ) ) );\n      }\n      if ( !this.state.getReference( ).equals( tr.getTransitionRule( ).getFromState( ) ) ) {\n        this.state.set( tr.getTransitionRule( ).getFromState( ), false );\n        this.fireInListeners( tr.getTransitionRule( ).getFromState( ) );\n      } else {\n        this.state.set( tr.getTransitionRule( ).getFromState( ), false );\n      }\n    }\n  }","id":75153,"modified_method":"private void rollback( ) {\n    LOG.debug( \"Transition debug(): \" + this.toString( ) );\n    if ( !this.state.isMarked( ) ) {\n      Exceptions.trace( new IllegalStateException( \"commit() called when there is no currently pending transition: \" + this.toString( ) ) );\n    } else {\n      ActiveTransition tr = this.currentTransition.getAndSet( null );\n      this.state.set( tr.getTransitionRule( ).getFromState( ), false );\n    }\n  }","commit_id":"8ece14fd8607410b8d4f3c2cd907d50244cd5a83","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public CheckedListenableFuture<P> transitionByName( T transitionName ) throws IllegalStateException, ExistingTransitionException {\n    if ( this.state.isMarked( ) ) {\n      throw new ExistingTransitionException( \"Transition request transition=\" + transitionName + \" rejected because of an ongoing transition: \"\n                                             + this.currentTransition.get( ) );\n    } else if ( !this.transitions.containsKey( transitionName ) ) {\n      throw new NoSuchElementException( \"No such transition named: \" + transitionName.toString( ) + \". Known transitions: \" + this.getTransitions( ) );\n    } else {\n      this.checkTransition( transitionName );\n      final ActiveTransition tid = this.beforeLeave( transitionName );\n      CheckedListenableFuture<P> future = this.afterLeave( transitionName, tid );\n      return future;\n    }\n  }","id":75154,"modified_method":"@Override\n  public CheckedListenableFuture<P> transitionByName( T transitionName ) throws IllegalStateException, ExistingTransitionException {\n    if ( this.state.isMarked( ) ) {\n      throw new ExistingTransitionException( \"Transition request transition=\" + transitionName + \" rejected because of an ongoing transition: \"\n                                             + this.toString( ) );\n    } else if ( !this.transitions.containsKey( transitionName ) ) {\n      throw new NoSuchElementException( \"No such transition named: \" + transitionName.toString( ) + \". Known transitions: \" + this.getTransitions( ) );\n    } else {\n      this.checkTransition( transitionName );\n      final ActiveTransition tid = this.beforeLeave( transitionName );\n      CheckedListenableFuture<P> future = this.afterLeave( transitionName, tid );\n      return future;\n    }\n  }","commit_id":"8ece14fd8607410b8d4f3c2cd907d50244cd5a83","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public CheckedListenableFuture<P> transition( S nextState ) throws IllegalStateException, ExistingTransitionException {\n    if ( this.state.isMarked( ) ) {\n      throw new ExistingTransitionException( \"Transition request state=\" + nextState + \" rejected because of an ongoing transition: \"\n                                             + this.currentTransition.get( ) );\n    } else if ( !this.stateTransitions.get( this.state.getReference( ) ).containsKey( nextState ) ) {\n      throw new NoSuchElementException( \"No transition to \" + nextState.toString( ) + \" from current state \" + this.toString( ) + \". Known transitions: \"\n                                        + this.getTransitions( ) );\n    } else {\n      T transitionName = this.stateTransitions.get( this.state.getReference( ) ).get( nextState ).getName( );\n      this.checkTransition( transitionName );\n      final ActiveTransition tid = this.beforeLeave( transitionName );\n      CheckedListenableFuture<P> future = this.afterLeave( transitionName, tid );\n      return future;\n    }\n  }","id":75155,"modified_method":"@Override\n  public CheckedListenableFuture<P> transition( S nextState ) throws IllegalStateException, ExistingTransitionException {\n    if ( this.state.isMarked( ) ) {\n      throw new ExistingTransitionException( \"Transition request state=\" + nextState + \" rejected because of an ongoing transition: \"\n                                             + this.toString( ) );\n    } else if ( !this.stateTransitions.get( this.state.getReference( ) ).containsKey( nextState ) ) {\n      throw new NoSuchElementException( \"No transition to \" + nextState.toString( ) + \" from current state \" + this.toString( ) + \". Known transitions: \"\n                                        + this.getTransitions( ) );\n    } else {\n      T transitionName = this.stateTransitions.get( this.state.getReference( ) ).get( nextState ).getName( );\n      this.checkTransition( transitionName );\n      final ActiveTransition tid = this.beforeLeave( transitionName );\n      CheckedListenableFuture<P> future = this.afterLeave( transitionName, tid );\n      return future;\n    }\n  }","commit_id":"8ece14fd8607410b8d4f3c2cd907d50244cd5a83","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"/**\n   * @see com.eucalyptus.util.fsm.State#request(com.eucalyptus.util.fsm.TransitionRule)\n   * @param rule\n   * @return\n   * @throws ExistingTransitionException\n   */\n  protected ActiveTransition request( T transitionName ) throws ExistingTransitionException {\n    TransitionHandler<P, S, T> transition = lookupTransition( transitionName );\n    TransitionRule<S, T> rule = transition.getRule( );\n    if ( !this.currentTransition.compareAndSet( null, new ActiveTransition( this.id.incrementAndGet( ), rule, transition ) ) ) {\n      throw new ExistingTransitionException( \"Transition request \" + transitionName + \" rejected because of an ongoing transition: \"\n                                             + this.currentTransition.get( ) );\n    } else if ( !this.state.compareAndSet( rule.getFromState( ), rule.getToState( ), rule.getFromStateMark( ), true ) ) {\n      this.id.decrementAndGet( );\n      this.currentTransition.set( null );\n      throw new IllegalStateException( \"Failed to validate expected preconditions for transition: \" + transition.getRule( ).toString( )\n                                       + \" for current state: \" + this.toString( ) );\n    } else {\n      return this.currentTransition.get( );\n    }\n  }","id":75156,"modified_method":"/**\n   * @see com.eucalyptus.util.fsm.State#request(com.eucalyptus.util.fsm.TransitionRule)\n   * @param rule\n   * @return\n   * @throws ExistingTransitionException\n   */\n  protected ActiveTransition request( T transitionName ) throws ExistingTransitionException {\n    TransitionHandler<P, S, T> transition = lookupTransition( transitionName );\n    TransitionRule<S, T> rule = transition.getRule( );\n    if ( !this.state.compareAndSet( rule.getFromState( ), rule.getToState( ), rule.getFromStateMark( ), true ) ) {\n      throw new ExistingTransitionException( \"Transition request \" + transitionName + \" rejected because of an ongoing transition: \"\n                                             + this.toString( ) );\n    } else {\n      this.currentTransition.set( new ActiveTransition( this.id.incrementAndGet( ), rule, transition ) );\n      return this.currentTransition.get( );\n    }\n  }","commit_id":"8ece14fd8607410b8d4f3c2cd907d50244cd5a83","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"Issue toIssue(Violation violation) {\n    DefaultIssue issue = new DefaultIssue();\n    issue.setComponentKey(violation.getResource().getEffectiveKey());\n    issue.setKey(UUID.randomUUID().toString());\n    issue.setRuleRepositoryKey(violation.getRule().getRepositoryKey());\n    issue.setRuleKey(violation.getRule().getKey());\n    issue.setCost(violation.getCost());\n    issue.setChecksum(violation.getChecksum());\n    issue.setCreatedAt(violation.getCreatedAt());\n    // FIXME\n    //issue.setPerson(violation.getPersonId());\n    issue.setLine(violation.getLineId());\n    issue.setMessage(violation.getMessage());\n    if (violation.getSeverity() != null) {\n      issue.setSeverity(violation.getSeverity().name());\n    }\n    return issue;\n  }","id":75157,"modified_method":"Issue toIssue(Violation violation) {\n    DefaultIssue issue = new DefaultIssue()\n        .setComponentKey(violation.getResource().getEffectiveKey())\n        .setKey(UUID.randomUUID().toString())\n        .setRuleRepositoryKey(violation.getRule().getRepositoryKey())\n        .setRuleKey(violation.getRule().getKey())\n        .setCost(violation.getCost())\n        .setLine(violation.getLineId())\n        .setMessage(violation.getMessage())\n        .setStatus(Issue.STATUS_OPEN);\n    if (violation.getSeverity() != null) {\n      issue.setSeverity(violation.getSeverity().name());\n    }\n    // FIXME\n    //issue.setPerson(violation.getPersonId());\n    return issue;\n  }","commit_id":"19a8496f9cfa0aa861a09fbf6e4fded5cd6b80f4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private List<DefaultIssue> prepareNewIssues(List<DefaultIssue> issues, String source) {\n    List<DefaultIssue> result = newArrayList();\n    List<String> checksums = SourceChecksum.lineChecksumsOfFile(source);\n    for (DefaultIssue issue : issues) {\n      issue.setChecksum(SourceChecksum.getChecksumForLine(checksums, issue.line()));\n      result.add(issue);\n    }\n    return result;\n  }","id":75158,"modified_method":"private void setChecksumOnNewIssues(List<DefaultIssue> issues, String source) {\n    List<String> checksums = SourceChecksum.lineChecksumsOfFile(source);\n    for (DefaultIssue issue : issues) {\n      issue.setChecksum(SourceChecksum.getChecksumForLine(checksums, issue.line()));\n    }\n  }","commit_id":"19a8496f9cfa0aa861a09fbf6e4fded5cd6b80f4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void decorate(Resource resource, DecoratorContext context) {\n    referenceIssuesMap.clear();\n\n    String source = index.getSource(resource);\n\n    // Load new issues\n    Issuable issuable = perspectives.as(Issuable.class, resource);\n    List<DefaultIssue> newIssues = prepareNewIssues(toDefaultIssues(issuable.issues()), source);\n\n    // Load existing issues\n    Collection<IssueDto> referenceIssues = loadExistingOpenIssues(resource);\n\n    // Map new issues with old ones\n    mapIssues(newIssues, referenceIssues, source, resource);\n  }","id":75159,"modified_method":"@Override\n  public void decorate(Resource resource, DecoratorContext context) {\n    referenceIssuesMap.clear();\n\n    String source = index.getSource(resource);\n\n    // Load new issues\n    Issuable issuable = perspectives.as(Issuable.class, resource);\n    List<DefaultIssue> newIssues = toDefaultIssues(issuable.issues());\n    setChecksumOnNewIssues(newIssues, source);\n\n    // Load existing issues\n    Collection<IssueDto> referenceIssues = loadExistingOpenIssues(resource);\n\n    // Map new issues with old ones\n    mapIssues(newIssues, referenceIssues, source, resource);\n  }","commit_id":"19a8496f9cfa0aa861a09fbf6e4fded5cd6b80f4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@VisibleForTesting\n  Map<DefaultIssue, IssueDto> mapIssues(List<DefaultIssue> newIssues, @Nullable Collection<IssueDto> lastIssues, @Nullable String source, @Nullable Resource resource) {\n    boolean hasLastScan = false;\n    Multimap<Integer, IssueDto> lastIssuesByRule = LinkedHashMultimap.create();\n\n    if (lastIssues != null) {\n      hasLastScan = true;\n      unmappedLastIssues.addAll(lastIssues);\n\n      for (IssueDto lastIssue : lastIssues) {\n        lastIssuesByRule.put(getRule(lastIssue), lastIssue);\n      }\n\n      // Match the key of the issue. (For manual issues)\n      for (DefaultIssue newIssue : newIssues) {\n        mapIssue(newIssue,\n            findLastIssueWithSameKey(newIssue, lastIssuesByRule.get(getRule(newIssue))),\n            lastIssuesByRule, referenceIssuesMap);\n      }\n\n      // Try first to match issues on same rule with same line and with same checksum (but not necessarily with same message)\n      for (DefaultIssue newIssue : newIssues) {\n        if (isNotAlreadyMapped(newIssue)) {\n          mapIssue(newIssue,\n              findLastIssueWithSameLineAndChecksum(newIssue, lastIssuesByRule.get(getRule(newIssue))),\n              lastIssuesByRule, referenceIssuesMap);\n        }\n      }\n    }\n\n    // If each new issue matches an old one we can stop the matching mechanism\n    if (referenceIssuesMap.size() != newIssues.size()) {\n      if (source != null && resource != null && hasLastScan) {\n        String referenceSource = lastSnapshots.getSource(resource);\n        if (referenceSource != null) {\n          HashedSequence<StringText> hashedReference = HashedSequence.wrap(new StringText(referenceSource), StringTextComparator.IGNORE_WHITESPACE);\n          HashedSequence<StringText> hashedSource = HashedSequence.wrap(new StringText(source), StringTextComparator.IGNORE_WHITESPACE);\n          HashedSequenceComparator<StringText> hashedComparator = new HashedSequenceComparator<StringText>(StringTextComparator.IGNORE_WHITESPACE);\n\n          ViolationTrackingBlocksRecognizer rec = new ViolationTrackingBlocksRecognizer(hashedReference, hashedSource, hashedComparator);\n\n          Multimap<Integer, DefaultIssue> newIssuesByLines = newIssuesByLines(newIssues, rec);\n          Multimap<Integer, IssueDto> lastIssuesByLines = lastIssuesByLines(unmappedLastIssues, rec);\n\n          RollingHashSequence<HashedSequence<StringText>> a = RollingHashSequence.wrap(hashedReference, hashedComparator, 5);\n          RollingHashSequence<HashedSequence<StringText>> b = RollingHashSequence.wrap(hashedSource, hashedComparator, 5);\n          RollingHashSequenceComparator<HashedSequence<StringText>> cmp = new RollingHashSequenceComparator<HashedSequence<StringText>>(hashedComparator);\n\n          Map<Integer, HashOccurrence> map = Maps.newHashMap();\n\n          for (Integer line : lastIssuesByLines.keySet()) {\n            int hash = cmp.hash(a, line - 1);\n            HashOccurrence hashOccurrence = map.get(hash);\n            if (hashOccurrence == null) {\n              // first occurrence in A\n              hashOccurrence = new HashOccurrence();\n              hashOccurrence.lineA = line;\n              hashOccurrence.countA = 1;\n              map.put(hash, hashOccurrence);\n            } else {\n              hashOccurrence.countA++;\n            }\n          }\n\n          for (Integer line : newIssuesByLines.keySet()) {\n            int hash = cmp.hash(b, line - 1);\n            HashOccurrence hashOccurrence = map.get(hash);\n            if (hashOccurrence != null) {\n              hashOccurrence.lineB = line;\n              hashOccurrence.countB++;\n            }\n          }\n\n          for (HashOccurrence hashOccurrence : map.values()) {\n            if (hashOccurrence.countA == 1 && hashOccurrence.countB == 1) {\n              // Guaranteed that lineA has been moved to lineB, so we can map all issues on lineA to all issues on lineB\n              map(newIssuesByLines.get(hashOccurrence.lineB), lastIssuesByLines.get(hashOccurrence.lineA), lastIssuesByRule);\n              lastIssuesByLines.removeAll(hashOccurrence.lineA);\n              newIssuesByLines.removeAll(hashOccurrence.lineB);\n            }\n          }\n\n          // Check if remaining number of lines exceeds threshold\n          if (lastIssuesByLines.keySet().size() * newIssuesByLines.keySet().size() < 250000) {\n            List<LinePair> possibleLinePairs = Lists.newArrayList();\n            for (Integer oldLine : lastIssuesByLines.keySet()) {\n              for (Integer newLine : newIssuesByLines.keySet()) {\n                int weight = rec.computeLengthOfMaximalBlock(oldLine - 1, newLine - 1);\n                possibleLinePairs.add(new LinePair(oldLine, newLine, weight));\n              }\n            }\n            Collections.sort(possibleLinePairs, LINE_PAIR_COMPARATOR);\n            for (LinePair linePair : possibleLinePairs) {\n              // High probability that lineA has been moved to lineB, so we can map all Issues on lineA to all Issues on lineB\n              map(newIssuesByLines.get(linePair.lineB), lastIssuesByLines.get(linePair.lineA), lastIssuesByRule);\n            }\n          }\n        }\n      }\n\n      // Try then to match issues on same rule with same message and with same checksum\n      for (DefaultIssue newIssue : newIssues) {\n        if (isNotAlreadyMapped(newIssue)) {\n          mapIssue(newIssue,\n              findLastIssueWithSameChecksumAndMessage(newIssue, lastIssuesByRule.get(getRule(newIssue))),\n              lastIssuesByRule, referenceIssuesMap);\n        }\n      }\n\n      // Try then to match issues on same rule with same line and with same message\n      for (DefaultIssue newIssue : newIssues) {\n        if (isNotAlreadyMapped(newIssue)) {\n          mapIssue(newIssue,\n              findLastIssueWithSameLineAndMessage(newIssue, lastIssuesByRule.get(getRule(newIssue))),\n              lastIssuesByRule, referenceIssuesMap);\n        }\n      }\n\n      // Last check: match issue if same rule and same checksum but different line and different message\n      // See SONAR-2812\n      for (DefaultIssue newIssue : newIssues) {\n        if (isNotAlreadyMapped(newIssue)) {\n          mapIssue(newIssue,\n              findLastIssueWithSameChecksum(newIssue, lastIssuesByRule.get(getRule(newIssue))),\n              lastIssuesByRule, referenceIssuesMap);\n        }\n      }\n    }\n\n    unmappedLastIssues.clear();\n    return referenceIssuesMap;\n  }","id":75160,"modified_method":"@VisibleForTesting\n  Map<DefaultIssue, IssueDto> mapIssues(List<DefaultIssue> newIssues, @Nullable Collection<IssueDto> lastIssues, @Nullable String source, @Nullable Resource resource) {\n    boolean hasLastScan = false;\n    Multimap<Integer, IssueDto> lastIssuesByRule = LinkedHashMultimap.create();\n\n    if (lastIssues != null) {\n      hasLastScan = true;\n      mapLastIssues(newIssues, lastIssues, lastIssuesByRule);\n    }\n\n    // If each new issue matches an old one we can stop the matching mechanism\n    if (referenceIssuesMap.size() != newIssues.size()) {\n      if (source != null && resource != null && hasLastScan) {\n        String referenceSource = lastSnapshots.getSource(resource);\n        if (referenceSource != null) {\n          HashedSequence<StringText> hashedReference = HashedSequence.wrap(new StringText(referenceSource), StringTextComparator.IGNORE_WHITESPACE);\n          HashedSequence<StringText> hashedSource = HashedSequence.wrap(new StringText(source), StringTextComparator.IGNORE_WHITESPACE);\n          HashedSequenceComparator<StringText> hashedComparator = new HashedSequenceComparator<StringText>(StringTextComparator.IGNORE_WHITESPACE);\n\n          ViolationTrackingBlocksRecognizer rec = new ViolationTrackingBlocksRecognizer(hashedReference, hashedSource, hashedComparator);\n\n          Multimap<Integer, DefaultIssue> newIssuesByLines = newIssuesByLines(newIssues, rec);\n          Multimap<Integer, IssueDto> lastIssuesByLines = lastIssuesByLines(unmappedLastIssues, rec);\n\n          RollingHashSequence<HashedSequence<StringText>> a = RollingHashSequence.wrap(hashedReference, hashedComparator, 5);\n          RollingHashSequence<HashedSequence<StringText>> b = RollingHashSequence.wrap(hashedSource, hashedComparator, 5);\n          RollingHashSequenceComparator<HashedSequence<StringText>> cmp = new RollingHashSequenceComparator<HashedSequence<StringText>>(hashedComparator);\n\n          Map<Integer, HashOccurrence> map = Maps.newHashMap();\n\n          for (Integer line : lastIssuesByLines.keySet()) {\n            int hash = cmp.hash(a, line - 1);\n            HashOccurrence hashOccurrence = map.get(hash);\n            if (hashOccurrence == null) {\n              // first occurrence in A\n              hashOccurrence = new HashOccurrence();\n              hashOccurrence.lineA = line;\n              hashOccurrence.countA = 1;\n              map.put(hash, hashOccurrence);\n            } else {\n              hashOccurrence.countA++;\n            }\n          }\n\n          for (Integer line : newIssuesByLines.keySet()) {\n            int hash = cmp.hash(b, line - 1);\n            HashOccurrence hashOccurrence = map.get(hash);\n            if (hashOccurrence != null) {\n              hashOccurrence.lineB = line;\n              hashOccurrence.countB++;\n            }\n          }\n\n          for (HashOccurrence hashOccurrence : map.values()) {\n            if (hashOccurrence.countA == 1 && hashOccurrence.countB == 1) {\n              // Guaranteed that lineA has been moved to lineB, so we can map all issues on lineA to all issues on lineB\n              map(newIssuesByLines.get(hashOccurrence.lineB), lastIssuesByLines.get(hashOccurrence.lineA), lastIssuesByRule);\n              lastIssuesByLines.removeAll(hashOccurrence.lineA);\n              newIssuesByLines.removeAll(hashOccurrence.lineB);\n            }\n          }\n\n          // Check if remaining number of lines exceeds threshold\n          if (lastIssuesByLines.keySet().size() * newIssuesByLines.keySet().size() < 250000) {\n            List<LinePair> possibleLinePairs = Lists.newArrayList();\n            for (Integer oldLine : lastIssuesByLines.keySet()) {\n              for (Integer newLine : newIssuesByLines.keySet()) {\n                int weight = rec.computeLengthOfMaximalBlock(oldLine - 1, newLine - 1);\n                possibleLinePairs.add(new LinePair(oldLine, newLine, weight));\n              }\n            }\n            Collections.sort(possibleLinePairs, LINE_PAIR_COMPARATOR);\n            for (LinePair linePair : possibleLinePairs) {\n              // High probability that lineA has been moved to lineB, so we can map all Issues on lineA to all Issues on lineB\n              map(newIssuesByLines.get(linePair.lineB), lastIssuesByLines.get(linePair.lineA), lastIssuesByRule);\n            }\n          }\n        }\n      }\n\n      // Try then to match issues on same rule with same message and with same checksum\n      for (DefaultIssue newIssue : newIssues) {\n        if (isNotAlreadyMapped(newIssue)) {\n          mapIssue(newIssue,\n              findLastIssueWithSameChecksumAndMessage(newIssue, lastIssuesByRule.get(getRule(newIssue))),\n              lastIssuesByRule, referenceIssuesMap);\n        }\n      }\n\n      // Try then to match issues on same rule with same line and with same message\n      for (DefaultIssue newIssue : newIssues) {\n        if (isNotAlreadyMapped(newIssue)) {\n          mapIssue(newIssue,\n              findLastIssueWithSameLineAndMessage(newIssue, lastIssuesByRule.get(getRule(newIssue))),\n              lastIssuesByRule, referenceIssuesMap);\n        }\n      }\n\n      // Last check: match issue if same rule and same checksum but different line and different message\n      // See SONAR-2812\n      for (DefaultIssue newIssue : newIssues) {\n        if (isNotAlreadyMapped(newIssue)) {\n          mapIssue(newIssue,\n              findLastIssueWithSameChecksum(newIssue, lastIssuesByRule.get(getRule(newIssue))),\n              lastIssuesByRule, referenceIssuesMap);\n        }\n      }\n    }\n\n    unmappedLastIssues.clear();\n    return referenceIssuesMap;\n  }","commit_id":"19a8496f9cfa0aa861a09fbf6e4fded5cd6b80f4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void mapIssue(DefaultIssue newIssue, IssueDto pastIssue, Multimap<Integer, IssueDto> lastIssuesByRule, Map<DefaultIssue, IssueDto> issueMap) {\n    if (pastIssue != null) {\n      newIssue.setCreatedAt(pastIssue.getCreatedAt());\n      newIssue.setKey(pastIssue.getUuid());\n      // TODO\n//      newIssue.setPersonId(pastIssue.getPersonId());\n      newIssue.setNew(false);\n\n      lastIssuesByRule.remove(getRule(newIssue), pastIssue);\n      issueMap.put(newIssue, pastIssue);\n      unmappedLastIssues.remove(pastIssue);\n    } else {\n      newIssue.setNew(true);\n      newIssue.setCreatedAt(project.getAnalysisDate());\n    }\n  }","id":75161,"modified_method":"private void mapIssue(DefaultIssue newIssue, IssueDto pastIssue, Multimap<Integer, IssueDto> lastIssuesByRule, Map<DefaultIssue, IssueDto> issueMap) {\n    if (pastIssue != null) {\n      newIssue.setCreatedAt(pastIssue.getCreatedAt());\n      newIssue.setUpdatedAt(project.getAnalysisDate());\n      newIssue.setKey(pastIssue.getUuid());\n      // TODO\n//      newIssue.setPersonId(pastIssue.getPersonId());\n      newIssue.setNew(false);\n\n      lastIssuesByRule.remove(getRule(newIssue), pastIssue);\n      issueMap.put(newIssue, pastIssue);\n      unmappedLastIssues.remove(pastIssue);\n    } else {\n      newIssue.setNew(true);\n      newIssue.setCreatedAt(project.getAnalysisDate());\n    }\n  }","commit_id":"19a8496f9cfa0aa861a09fbf6e4fded5cd6b80f4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/** {@inheritDoc} */\n    @Override public void start0() throws IgniteCheckedException {\n        CacheConfiguration cfg = cctx.config();\n\n        plc = cctx.isNear() ? cfg.getNearConfiguration().getNearEvictionPolicy() : cfg.getEvictionPolicy();\n\n        memoryMode = cctx.config().getMemoryMode();\n\n        plcEnabled = plc != null && memoryMode != OFFHEAP_TIERED;\n\n        filter = cfg.getEvictionFilter();\n\n        if (cfg.getEvictMaxOverflowRatio() < 0)\n            throw new IgniteCheckedException(\"Configuration parameter 'maxEvictOverflowRatio' cannot be negative.\");\n\n        if (cfg.getEvictSynchronizedKeyBufferSize() < 0)\n            throw new IgniteCheckedException(\"Configuration parameter 'evictSynchronizedKeyBufferSize' cannot be negative.\");\n\n        if (!cctx.isLocal()) {\n            evictSync = cfg.isEvictSynchronized() && !cctx.isNear() && !cctx.isSwapOrOffheapEnabled();\n\n            nearSync = isNearEnabled(cctx) && !cctx.isNear() && cfg.isEvictSynchronized();\n        }\n        else {\n            if (cfg.isEvictSynchronized())\n                U.warn(log, \"Ignored 'evictSynchronized' configuration property for LOCAL cache: \" + cctx.namexx());\n\n            if (cfg.getNearConfiguration() != null && cfg.isEvictSynchronized())\n                U.warn(log, \"Ignored 'evictNearSynchronized' configuration property for LOCAL cache: \" + cctx.namexx());\n        }\n\n        if (cctx.isDht() && !nearSync && evictSync && isNearEnabled(cctx))\n            throw new IgniteCheckedException(\"Illegal configuration (may lead to data inconsistency) \" +\n                \"[evictSync=true, evictNearSync=false]\");\n\n        reportConfigurationProblems();\n\n        evictSyncAgr = evictSync || nearSync;\n\n        if (evictSync && !cctx.isNear() && plcEnabled) {\n            backupWorker = new BackupWorker();\n\n            cctx.events().addListener(\n                new GridLocalEventListener() {\n                    @Override public void onEvent(Event evt) {\n                        assert evt.type() == EVT_NODE_FAILED || evt.type() == EVT_NODE_LEFT ||\n                            evt.type() == EVT_NODE_JOINED;\n\n                        DiscoveryEvent discoEvt = (DiscoveryEvent)evt;\n\n                        // Notify backup worker on each topology change.\n                        if (cctx.discovery().cacheAffinityNode(discoEvt.eventNode(), cctx.name()))\n                            backupWorker.addEvent(discoEvt);\n                    }\n                },\n                EVT_NODE_FAILED, EVT_NODE_LEFT, EVT_NODE_JOINED);\n        }\n\n        if (evictSyncAgr) {\n            if (cfg.getEvictSynchronizedTimeout() <= 0)\n                throw new IgniteCheckedException(\"Configuration parameter 'evictSynchronousTimeout' should be positive.\");\n\n            if (cfg.getEvictSynchronizedConcurrencyLevel() <= 0)\n                throw new IgniteCheckedException(\"Configuration parameter 'evictSynchronousConcurrencyLevel' \" +\n                    \"should be positive.\");\n\n            maxActiveFuts = cfg.getEvictSynchronizedConcurrencyLevel();\n\n            cctx.io().addHandler(cctx.cacheId(), GridCacheEvictionRequest.class, new CI2<UUID, GridCacheEvictionRequest>() {\n                @Override public void apply(UUID nodeId, GridCacheEvictionRequest msg) {\n                    processEvictionRequest(nodeId, msg);\n                }\n            });\n\n            cctx.io().addHandler(cctx.cacheId(), GridCacheEvictionResponse.class, new CI2<UUID, GridCacheEvictionResponse>() {\n                @Override public void apply(UUID nodeId, GridCacheEvictionResponse msg) {\n                    processEvictionResponse(nodeId, msg);\n                }\n            });\n\n            cctx.events().addListener(\n                new GridLocalEventListener() {\n                    @Override public void onEvent(Event evt) {\n                        assert evt.type() == EVT_NODE_FAILED || evt.type() == EVT_NODE_LEFT;\n\n                        DiscoveryEvent discoEvt = (DiscoveryEvent)evt;\n\n                        for (EvictionFuture fut : futs.values())\n                            fut.onNodeLeft(discoEvt.eventNode().id());\n                    }\n                },\n                EVT_NODE_FAILED, EVT_NODE_LEFT);\n        }\n\n        if (log.isDebugEnabled())\n            log.debug(\"Eviction manager started on node: \" + cctx.nodeId());\n    }","id":75162,"modified_method":"/** {@inheritDoc} */\n    @Override public void start0() throws IgniteCheckedException {\n        CacheConfiguration cfg = cctx.config();\n\n        plc = cctx.isNear() ? cfg.getNearConfiguration().getNearEvictionPolicy() : cfg.getEvictionPolicy();\n\n        memoryMode = cctx.config().getMemoryMode();\n\n        plcEnabled = plc != null && (cctx.isNear() || memoryMode != OFFHEAP_TIERED);\n\n        filter = cfg.getEvictionFilter();\n\n        if (cfg.getEvictMaxOverflowRatio() < 0)\n            throw new IgniteCheckedException(\"Configuration parameter 'maxEvictOverflowRatio' cannot be negative.\");\n\n        if (cfg.getEvictSynchronizedKeyBufferSize() < 0)\n            throw new IgniteCheckedException(\"Configuration parameter 'evictSynchronizedKeyBufferSize' cannot be negative.\");\n\n        if (!cctx.isLocal()) {\n            evictSync = cfg.isEvictSynchronized() && !cctx.isNear() && !cctx.isSwapOrOffheapEnabled();\n\n            nearSync = isNearEnabled(cctx) && !cctx.isNear() && cfg.isEvictSynchronized();\n        }\n        else {\n            if (cfg.isEvictSynchronized())\n                U.warn(log, \"Ignored 'evictSynchronized' configuration property for LOCAL cache: \" + cctx.namexx());\n\n            if (cfg.getNearConfiguration() != null && cfg.isEvictSynchronized())\n                U.warn(log, \"Ignored 'evictNearSynchronized' configuration property for LOCAL cache: \" + cctx.namexx());\n        }\n\n        if (cctx.isDht() && !nearSync && evictSync && isNearEnabled(cctx))\n            throw new IgniteCheckedException(\"Illegal configuration (may lead to data inconsistency) \" +\n                \"[evictSync=true, evictNearSync=false]\");\n\n        reportConfigurationProblems();\n\n        evictSyncAgr = evictSync || nearSync;\n\n        if (evictSync && !cctx.isNear() && plcEnabled) {\n            backupWorker = new BackupWorker();\n\n            cctx.events().addListener(\n                new GridLocalEventListener() {\n                    @Override public void onEvent(Event evt) {\n                        assert evt.type() == EVT_NODE_FAILED || evt.type() == EVT_NODE_LEFT ||\n                            evt.type() == EVT_NODE_JOINED;\n\n                        DiscoveryEvent discoEvt = (DiscoveryEvent)evt;\n\n                        // Notify backup worker on each topology change.\n                        if (cctx.discovery().cacheAffinityNode(discoEvt.eventNode(), cctx.name()))\n                            backupWorker.addEvent(discoEvt);\n                    }\n                },\n                EVT_NODE_FAILED, EVT_NODE_LEFT, EVT_NODE_JOINED);\n        }\n\n        if (evictSyncAgr) {\n            if (cfg.getEvictSynchronizedTimeout() <= 0)\n                throw new IgniteCheckedException(\"Configuration parameter 'evictSynchronousTimeout' should be positive.\");\n\n            if (cfg.getEvictSynchronizedConcurrencyLevel() <= 0)\n                throw new IgniteCheckedException(\"Configuration parameter 'evictSynchronousConcurrencyLevel' \" +\n                    \"should be positive.\");\n\n            maxActiveFuts = cfg.getEvictSynchronizedConcurrencyLevel();\n\n            cctx.io().addHandler(cctx.cacheId(), GridCacheEvictionRequest.class, new CI2<UUID, GridCacheEvictionRequest>() {\n                @Override public void apply(UUID nodeId, GridCacheEvictionRequest msg) {\n                    processEvictionRequest(nodeId, msg);\n                }\n            });\n\n            cctx.io().addHandler(cctx.cacheId(), GridCacheEvictionResponse.class, new CI2<UUID, GridCacheEvictionResponse>() {\n                @Override public void apply(UUID nodeId, GridCacheEvictionResponse msg) {\n                    processEvictionResponse(nodeId, msg);\n                }\n            });\n\n            cctx.events().addListener(\n                new GridLocalEventListener() {\n                    @Override public void onEvent(Event evt) {\n                        assert evt.type() == EVT_NODE_FAILED || evt.type() == EVT_NODE_LEFT;\n\n                        DiscoveryEvent discoEvt = (DiscoveryEvent)evt;\n\n                        for (EvictionFuture fut : futs.values())\n                            fut.onNodeLeft(discoEvt.eventNode().id());\n                    }\n                },\n                EVT_NODE_FAILED, EVT_NODE_LEFT);\n        }\n\n        if (log.isDebugEnabled())\n            log.debug(\"Eviction manager started on node: \" + cctx.nodeId());\n    }","commit_id":"90a4594b603eb15c754b18989af94f3cd50c02cc","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testAtomicNearEvictionMaxSize() throws Exception {\n        atomicityMode = ATOMIC;\n\n        checkNearEvictionMaxSize();\n    }","id":75163,"modified_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testAtomicNearEvictionMaxSize() throws Exception {\n        atomicityMode = ATOMIC;\n        memMode = ONHEAP_TIERED;\n\n        checkNearEvictionMaxSize();\n    }","commit_id":"90a4594b603eb15c754b18989af94f3cd50c02cc","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testTransactionalNearEvictionMaxSize() throws Exception {\n        atomicityMode = TRANSACTIONAL;\n\n        checkNearEvictionMaxSize();\n    }","id":75164,"modified_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testTransactionalNearEvictionMaxSize() throws Exception {\n        atomicityMode = TRANSACTIONAL;\n        memMode = ONHEAP_TIERED;\n\n        checkNearEvictionMaxSize();\n    }","commit_id":"90a4594b603eb15c754b18989af94f3cd50c02cc","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override protected IgniteConfiguration getConfiguration(String gridName) throws Exception {\n        IgniteConfiguration c = super.getConfiguration(gridName);\n\n        CacheConfiguration cc = new CacheConfiguration();\n\n        cc.setAtomicityMode(atomicityMode);\n        cc.setCacheMode(PARTITIONED);\n        cc.setWriteSynchronizationMode(PRIMARY_SYNC);\n        cc.setRebalanceMode(SYNC);\n        cc.setStartSize(100);\n        cc.setBackups(0);\n\n        NearCacheConfiguration nearCfg = new NearCacheConfiguration();\n\n        LruEvictionPolicy plc = new LruEvictionPolicy();\n        plc.setMaxSize(EVICTION_MAX_SIZE);\n\n        nearCfg.setNearEvictionPolicy(plc);\n        cc.setNearConfiguration(nearCfg);\n\n        c.setCacheConfiguration(cc);\n\n        TcpDiscoverySpi disco = new TcpDiscoverySpi();\n\n        disco.setIpFinder(ipFinder);\n\n        c.setDiscoverySpi(disco);\n\n        return c;\n    }","id":75165,"modified_method":"/** {@inheritDoc} */\n    @Override protected IgniteConfiguration getConfiguration(String gridName) throws Exception {\n        IgniteConfiguration c = super.getConfiguration(gridName);\n\n        CacheConfiguration cc = new CacheConfiguration();\n\n        cc.setCacheMode(PARTITIONED);\n        cc.setAtomicityMode(atomicityMode);\n        cc.setMemoryMode(memMode);\n        cc.setWriteSynchronizationMode(PRIMARY_SYNC);\n        cc.setRebalanceMode(SYNC);\n        cc.setStartSize(100);\n        cc.setBackups(0);\n\n        NearCacheConfiguration nearCfg = new NearCacheConfiguration();\n\n        LruEvictionPolicy plc = new LruEvictionPolicy();\n        plc.setMaxSize(EVICTION_MAX_SIZE);\n\n        nearCfg.setNearEvictionPolicy(plc);\n        cc.setNearConfiguration(nearCfg);\n\n        c.setCacheConfiguration(cc);\n\n        TcpDiscoverySpi disco = new TcpDiscoverySpi();\n\n        disco.setIpFinder(ipFinder);\n\n        c.setDiscoverySpi(disco);\n\n        return c;\n    }","commit_id":"90a4594b603eb15c754b18989af94f3cd50c02cc","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override protected IgniteConfiguration getConfiguration(String gridName) throws Exception {\n        IgniteConfiguration c = super.getConfiguration(gridName);\n\n        if (cnt == 0)\n            c.setClientMode(true);\n        else {\n            CacheConfiguration cc = new CacheConfiguration();\n\n            cc.setAtomicityMode(atomicityMode);\n            cc.setCacheMode(cacheMode);\n            cc.setWriteSynchronizationMode(PRIMARY_SYNC);\n            cc.setRebalanceMode(SYNC);\n            cc.setStartSize(100);\n            cc.setBackups(0);\n\n            c.setCacheConfiguration(cc);\n        }\n\n        c.setDiscoverySpi(new TcpDiscoverySpi().setIpFinder(ipFinder).setForceServerMode(true));\n\n        cnt++;\n\n        return c;\n    }","id":75166,"modified_method":"/** {@inheritDoc} */\n    @Override protected IgniteConfiguration getConfiguration(String gridName) throws Exception {\n        IgniteConfiguration c = super.getConfiguration(gridName);\n\n        if (cnt == 0)\n            c.setClientMode(true);\n        else {\n            CacheConfiguration cc = new CacheConfiguration();\n\n            cc.setCacheMode(cacheMode);\n            cc.setAtomicityMode(atomicityMode);\n            cc.setMemoryMode(memMode);\n            cc.setWriteSynchronizationMode(PRIMARY_SYNC);\n            cc.setRebalanceMode(SYNC);\n            cc.setStartSize(100);\n            cc.setBackups(0);\n\n            c.setCacheConfiguration(cc);\n        }\n\n        c.setDiscoverySpi(new TcpDiscoverySpi().setIpFinder(ipFinder).setForceServerMode(true));\n\n        cnt++;\n\n        return c;\n    }","commit_id":"90a4594b603eb15c754b18989af94f3cd50c02cc","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testPartitionedTransactionalNearEvictionMaxSize() throws Exception {\n        atomicityMode = TRANSACTIONAL;\n        cacheMode = PARTITIONED;\n\n        checkNearEvictionMaxSize();\n    }","id":75167,"modified_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testPartitionedTransactionalNearEvictionMaxSize() throws Exception {\n        atomicityMode = TRANSACTIONAL;\n        cacheMode = PARTITIONED;\n        memMode = ONHEAP_TIERED;\n\n        checkNearEvictionMaxSize();\n    }","commit_id":"90a4594b603eb15c754b18989af94f3cd50c02cc","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testReplicatedTransactionalNearEvictionMaxSize() throws Exception {\n        atomicityMode = TRANSACTIONAL;\n        cacheMode = REPLICATED;\n\n        checkNearEvictionMaxSize();\n    }","id":75168,"modified_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testReplicatedTransactionalNearEvictionMaxSize() throws Exception {\n        atomicityMode = TRANSACTIONAL;\n        cacheMode = REPLICATED;\n        memMode = ONHEAP_TIERED;\n\n        checkNearEvictionMaxSize();\n    }","commit_id":"90a4594b603eb15c754b18989af94f3cd50c02cc","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testReplicatedAtomicNearEvictionMaxSize() throws Exception {\n        atomicityMode = ATOMIC;\n        cacheMode = REPLICATED;\n\n        checkNearEvictionMaxSize();\n    }","id":75169,"modified_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testReplicatedAtomicNearEvictionMaxSize() throws Exception {\n        atomicityMode = ATOMIC;\n        cacheMode = REPLICATED;\n        memMode = ONHEAP_TIERED;\n\n        checkNearEvictionMaxSize();\n    }","commit_id":"90a4594b603eb15c754b18989af94f3cd50c02cc","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testPartitionedAtomicNearEvictionMaxSize() throws Exception {\n        atomicityMode = ATOMIC;\n        cacheMode = PARTITIONED;\n\n        checkNearEvictionMaxSize();\n    }","id":75170,"modified_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testPartitionedAtomicNearEvictionMaxSize() throws Exception {\n        atomicityMode = ATOMIC;\n        cacheMode = PARTITIONED;\n        memMode = ONHEAP_TIERED;\n\n        checkNearEvictionMaxSize();\n    }","commit_id":"90a4594b603eb15c754b18989af94f3cd50c02cc","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override public void start0() throws IgniteCheckedException {\n        CacheConfiguration cfg = cctx.config();\n\n        plc = cctx.isNear() ? cfg.getNearConfiguration().getNearEvictionPolicy() : cfg.getEvictionPolicy();\n\n        memoryMode = cctx.config().getMemoryMode();\n\n        plcEnabled = plc != null && memoryMode != OFFHEAP_TIERED;\n\n        filter = cfg.getEvictionFilter();\n\n        if (cfg.getEvictMaxOverflowRatio() < 0)\n            throw new IgniteCheckedException(\"Configuration parameter 'maxEvictOverflowRatio' cannot be negative.\");\n\n        if (cfg.getEvictSynchronizedKeyBufferSize() < 0)\n            throw new IgniteCheckedException(\"Configuration parameter 'evictSynchronizedKeyBufferSize' cannot be negative.\");\n\n        if (!cctx.isLocal()) {\n            evictSync = cfg.isEvictSynchronized() && !cctx.isNear() && !cctx.isSwapOrOffheapEnabled();\n\n            nearSync = isNearEnabled(cctx) && !cctx.isNear() && cfg.isEvictSynchronized();\n        }\n        else {\n            if (cfg.isEvictSynchronized())\n                U.warn(log, \"Ignored 'evictSynchronized' configuration property for LOCAL cache: \" + cctx.namexx());\n\n            if (cfg.getNearConfiguration() != null && cfg.isEvictSynchronized())\n                U.warn(log, \"Ignored 'evictNearSynchronized' configuration property for LOCAL cache: \" + cctx.namexx());\n        }\n\n        if (cctx.isDht() && !nearSync && evictSync && isNearEnabled(cctx))\n            throw new IgniteCheckedException(\"Illegal configuration (may lead to data inconsistency) \" +\n                \"[evictSync=true, evictNearSync=false]\");\n\n        reportConfigurationProblems();\n\n        evictSyncAgr = evictSync || nearSync;\n\n        if (evictSync && !cctx.isNear() && plcEnabled) {\n            backupWorker = new BackupWorker();\n\n            cctx.events().addListener(\n                new GridLocalEventListener() {\n                    @Override public void onEvent(Event evt) {\n                        assert evt.type() == EVT_NODE_FAILED || evt.type() == EVT_NODE_LEFT ||\n                            evt.type() == EVT_NODE_JOINED;\n\n                        DiscoveryEvent discoEvt = (DiscoveryEvent)evt;\n\n                        // Notify backup worker on each topology change.\n                        if (cctx.discovery().cacheAffinityNode(discoEvt.eventNode(), cctx.name()))\n                            backupWorker.addEvent(discoEvt);\n                    }\n                },\n                EVT_NODE_FAILED, EVT_NODE_LEFT, EVT_NODE_JOINED);\n        }\n\n        if (evictSyncAgr) {\n            if (cfg.getEvictSynchronizedTimeout() <= 0)\n                throw new IgniteCheckedException(\"Configuration parameter 'evictSynchronousTimeout' should be positive.\");\n\n            if (cfg.getEvictSynchronizedConcurrencyLevel() <= 0)\n                throw new IgniteCheckedException(\"Configuration parameter 'evictSynchronousConcurrencyLevel' \" +\n                    \"should be positive.\");\n\n            maxActiveFuts = cfg.getEvictSynchronizedConcurrencyLevel();\n\n            cctx.io().addHandler(cctx.cacheId(), GridCacheEvictionRequest.class, new CI2<UUID, GridCacheEvictionRequest>() {\n                @Override public void apply(UUID nodeId, GridCacheEvictionRequest msg) {\n                    processEvictionRequest(nodeId, msg);\n                }\n            });\n\n            cctx.io().addHandler(cctx.cacheId(), GridCacheEvictionResponse.class, new CI2<UUID, GridCacheEvictionResponse>() {\n                @Override public void apply(UUID nodeId, GridCacheEvictionResponse msg) {\n                    processEvictionResponse(nodeId, msg);\n                }\n            });\n\n            cctx.events().addListener(\n                new GridLocalEventListener() {\n                    @Override public void onEvent(Event evt) {\n                        assert evt.type() == EVT_NODE_FAILED || evt.type() == EVT_NODE_LEFT;\n\n                        DiscoveryEvent discoEvt = (DiscoveryEvent)evt;\n\n                        for (EvictionFuture fut : futs.values())\n                            fut.onNodeLeft(discoEvt.eventNode().id());\n                    }\n                },\n                EVT_NODE_FAILED, EVT_NODE_LEFT);\n        }\n\n        if (log.isDebugEnabled())\n            log.debug(\"Eviction manager started on node: \" + cctx.nodeId());\n    }","id":75171,"modified_method":"/** {@inheritDoc} */\n    @Override public void start0() throws IgniteCheckedException {\n        CacheConfiguration cfg = cctx.config();\n\n        plc = cctx.isNear() ? cfg.getNearConfiguration().getNearEvictionPolicy() : cfg.getEvictionPolicy();\n\n        memoryMode = cctx.config().getMemoryMode();\n\n        plcEnabled = plc != null && (cctx.isNear() || memoryMode != OFFHEAP_TIERED);\n\n        filter = cfg.getEvictionFilter();\n\n        if (cfg.getEvictMaxOverflowRatio() < 0)\n            throw new IgniteCheckedException(\"Configuration parameter 'maxEvictOverflowRatio' cannot be negative.\");\n\n        if (cfg.getEvictSynchronizedKeyBufferSize() < 0)\n            throw new IgniteCheckedException(\"Configuration parameter 'evictSynchronizedKeyBufferSize' cannot be negative.\");\n\n        if (!cctx.isLocal()) {\n            evictSync = cfg.isEvictSynchronized() && !cctx.isNear() && !cctx.isSwapOrOffheapEnabled();\n\n            nearSync = isNearEnabled(cctx) && !cctx.isNear() && cfg.isEvictSynchronized();\n        }\n        else {\n            if (cfg.isEvictSynchronized())\n                U.warn(log, \"Ignored 'evictSynchronized' configuration property for LOCAL cache: \" + cctx.namexx());\n\n            if (cfg.getNearConfiguration() != null && cfg.isEvictSynchronized())\n                U.warn(log, \"Ignored 'evictNearSynchronized' configuration property for LOCAL cache: \" + cctx.namexx());\n        }\n\n        if (cctx.isDht() && !nearSync && evictSync && isNearEnabled(cctx))\n            throw new IgniteCheckedException(\"Illegal configuration (may lead to data inconsistency) \" +\n                \"[evictSync=true, evictNearSync=false]\");\n\n        reportConfigurationProblems();\n\n        evictSyncAgr = evictSync || nearSync;\n\n        if (evictSync && !cctx.isNear() && plcEnabled) {\n            backupWorker = new BackupWorker();\n\n            cctx.events().addListener(\n                new GridLocalEventListener() {\n                    @Override public void onEvent(Event evt) {\n                        assert evt.type() == EVT_NODE_FAILED || evt.type() == EVT_NODE_LEFT ||\n                            evt.type() == EVT_NODE_JOINED;\n\n                        DiscoveryEvent discoEvt = (DiscoveryEvent)evt;\n\n                        // Notify backup worker on each topology change.\n                        if (cctx.discovery().cacheAffinityNode(discoEvt.eventNode(), cctx.name()))\n                            backupWorker.addEvent(discoEvt);\n                    }\n                },\n                EVT_NODE_FAILED, EVT_NODE_LEFT, EVT_NODE_JOINED);\n        }\n\n        if (evictSyncAgr) {\n            if (cfg.getEvictSynchronizedTimeout() <= 0)\n                throw new IgniteCheckedException(\"Configuration parameter 'evictSynchronousTimeout' should be positive.\");\n\n            if (cfg.getEvictSynchronizedConcurrencyLevel() <= 0)\n                throw new IgniteCheckedException(\"Configuration parameter 'evictSynchronousConcurrencyLevel' \" +\n                    \"should be positive.\");\n\n            maxActiveFuts = cfg.getEvictSynchronizedConcurrencyLevel();\n\n            cctx.io().addHandler(cctx.cacheId(), GridCacheEvictionRequest.class, new CI2<UUID, GridCacheEvictionRequest>() {\n                @Override public void apply(UUID nodeId, GridCacheEvictionRequest msg) {\n                    processEvictionRequest(nodeId, msg);\n                }\n            });\n\n            cctx.io().addHandler(cctx.cacheId(), GridCacheEvictionResponse.class, new CI2<UUID, GridCacheEvictionResponse>() {\n                @Override public void apply(UUID nodeId, GridCacheEvictionResponse msg) {\n                    processEvictionResponse(nodeId, msg);\n                }\n            });\n\n            cctx.events().addListener(\n                new GridLocalEventListener() {\n                    @Override public void onEvent(Event evt) {\n                        assert evt.type() == EVT_NODE_FAILED || evt.type() == EVT_NODE_LEFT;\n\n                        DiscoveryEvent discoEvt = (DiscoveryEvent)evt;\n\n                        for (EvictionFuture fut : futs.values())\n                            fut.onNodeLeft(discoEvt.eventNode().id());\n                    }\n                },\n                EVT_NODE_FAILED, EVT_NODE_LEFT);\n        }\n\n        if (log.isDebugEnabled())\n            log.debug(\"Eviction manager started on node: \" + cctx.nodeId());\n    }","commit_id":"132734040374203d36a7f35b9c5e3cc1651034a6","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testAtomicNearEvictionMaxSize() throws Exception {\n        atomicityMode = ATOMIC;\n\n        checkNearEvictionMaxSize();\n    }","id":75172,"modified_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testAtomicNearEvictionMaxSize() throws Exception {\n        atomicityMode = ATOMIC;\n        memMode = ONHEAP_TIERED;\n\n        checkNearEvictionMaxSize();\n    }","commit_id":"132734040374203d36a7f35b9c5e3cc1651034a6","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override protected IgniteConfiguration getConfiguration(String gridName) throws Exception {\n        IgniteConfiguration c = super.getConfiguration(gridName);\n\n        CacheConfiguration cc = new CacheConfiguration();\n\n        cc.setAtomicityMode(atomicityMode);\n        cc.setCacheMode(PARTITIONED);\n        cc.setWriteSynchronizationMode(PRIMARY_SYNC);\n        cc.setRebalanceMode(SYNC);\n        cc.setStartSize(100);\n        cc.setBackups(0);\n\n        NearCacheConfiguration nearCfg = new NearCacheConfiguration();\n\n        LruEvictionPolicy plc = new LruEvictionPolicy();\n        plc.setMaxSize(EVICTION_MAX_SIZE);\n\n        nearCfg.setNearEvictionPolicy(plc);\n        cc.setNearConfiguration(nearCfg);\n\n        c.setCacheConfiguration(cc);\n\n        TcpDiscoverySpi disco = new TcpDiscoverySpi();\n\n        disco.setIpFinder(ipFinder);\n\n        c.setDiscoverySpi(disco);\n\n        return c;\n    }","id":75173,"modified_method":"/** {@inheritDoc} */\n    @Override protected IgniteConfiguration getConfiguration(String gridName) throws Exception {\n        IgniteConfiguration c = super.getConfiguration(gridName);\n\n        CacheConfiguration cc = new CacheConfiguration();\n\n        cc.setCacheMode(PARTITIONED);\n        cc.setAtomicityMode(atomicityMode);\n        cc.setMemoryMode(memMode);\n        cc.setWriteSynchronizationMode(PRIMARY_SYNC);\n        cc.setRebalanceMode(SYNC);\n        cc.setStartSize(100);\n        cc.setBackups(0);\n\n        NearCacheConfiguration nearCfg = new NearCacheConfiguration();\n\n        LruEvictionPolicy plc = new LruEvictionPolicy();\n        plc.setMaxSize(EVICTION_MAX_SIZE);\n\n        nearCfg.setNearEvictionPolicy(plc);\n        cc.setNearConfiguration(nearCfg);\n\n        c.setCacheConfiguration(cc);\n\n        TcpDiscoverySpi disco = new TcpDiscoverySpi();\n\n        disco.setIpFinder(ipFinder);\n\n        c.setDiscoverySpi(disco);\n\n        return c;\n    }","commit_id":"132734040374203d36a7f35b9c5e3cc1651034a6","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testTransactionalNearEvictionMaxSize() throws Exception {\n        atomicityMode = TRANSACTIONAL;\n\n        checkNearEvictionMaxSize();\n    }","id":75174,"modified_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testTransactionalNearEvictionMaxSize() throws Exception {\n        atomicityMode = TRANSACTIONAL;\n        memMode = ONHEAP_TIERED;\n\n        checkNearEvictionMaxSize();\n    }","commit_id":"132734040374203d36a7f35b9c5e3cc1651034a6","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testReplicatedAtomicNearEvictionMaxSize() throws Exception {\n        atomicityMode = ATOMIC;\n        cacheMode = REPLICATED;\n\n        checkNearEvictionMaxSize();\n    }","id":75175,"modified_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testReplicatedAtomicNearEvictionMaxSize() throws Exception {\n        atomicityMode = ATOMIC;\n        cacheMode = REPLICATED;\n        memMode = ONHEAP_TIERED;\n\n        checkNearEvictionMaxSize();\n    }","commit_id":"132734040374203d36a7f35b9c5e3cc1651034a6","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testPartitionedTransactionalNearEvictionMaxSize() throws Exception {\n        atomicityMode = TRANSACTIONAL;\n        cacheMode = PARTITIONED;\n\n        checkNearEvictionMaxSize();\n    }","id":75176,"modified_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testPartitionedTransactionalNearEvictionMaxSize() throws Exception {\n        atomicityMode = TRANSACTIONAL;\n        cacheMode = PARTITIONED;\n        memMode = ONHEAP_TIERED;\n\n        checkNearEvictionMaxSize();\n    }","commit_id":"132734040374203d36a7f35b9c5e3cc1651034a6","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testPartitionedAtomicNearEvictionMaxSize() throws Exception {\n        atomicityMode = ATOMIC;\n        cacheMode = PARTITIONED;\n\n        checkNearEvictionMaxSize();\n    }","id":75177,"modified_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testPartitionedAtomicNearEvictionMaxSize() throws Exception {\n        atomicityMode = ATOMIC;\n        cacheMode = PARTITIONED;\n        memMode = ONHEAP_TIERED;\n\n        checkNearEvictionMaxSize();\n    }","commit_id":"132734040374203d36a7f35b9c5e3cc1651034a6","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override protected IgniteConfiguration getConfiguration(String gridName) throws Exception {\n        IgniteConfiguration c = super.getConfiguration(gridName);\n\n        if (cnt == 0)\n            c.setClientMode(true);\n        else {\n            CacheConfiguration cc = new CacheConfiguration();\n\n            cc.setAtomicityMode(atomicityMode);\n            cc.setCacheMode(cacheMode);\n            cc.setWriteSynchronizationMode(PRIMARY_SYNC);\n            cc.setRebalanceMode(SYNC);\n            cc.setStartSize(100);\n            cc.setBackups(0);\n\n            c.setCacheConfiguration(cc);\n        }\n\n        c.setDiscoverySpi(new TcpDiscoverySpi().setIpFinder(ipFinder).setForceServerMode(true));\n\n        cnt++;\n\n        return c;\n    }","id":75178,"modified_method":"/** {@inheritDoc} */\n    @Override protected IgniteConfiguration getConfiguration(String gridName) throws Exception {\n        IgniteConfiguration c = super.getConfiguration(gridName);\n\n        if (cnt == 0)\n            c.setClientMode(true);\n        else {\n            CacheConfiguration cc = new CacheConfiguration();\n\n            cc.setCacheMode(cacheMode);\n            cc.setAtomicityMode(atomicityMode);\n            cc.setMemoryMode(memMode);\n            cc.setWriteSynchronizationMode(PRIMARY_SYNC);\n            cc.setRebalanceMode(SYNC);\n            cc.setStartSize(100);\n            cc.setBackups(0);\n\n            c.setCacheConfiguration(cc);\n        }\n\n        c.setDiscoverySpi(new TcpDiscoverySpi().setIpFinder(ipFinder).setForceServerMode(true));\n\n        cnt++;\n\n        return c;\n    }","commit_id":"132734040374203d36a7f35b9c5e3cc1651034a6","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testReplicatedTransactionalNearEvictionMaxSize() throws Exception {\n        atomicityMode = TRANSACTIONAL;\n        cacheMode = REPLICATED;\n\n        checkNearEvictionMaxSize();\n    }","id":75179,"modified_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testReplicatedTransactionalNearEvictionMaxSize() throws Exception {\n        atomicityMode = TRANSACTIONAL;\n        cacheMode = REPLICATED;\n        memMode = ONHEAP_TIERED;\n\n        checkNearEvictionMaxSize();\n    }","commit_id":"132734040374203d36a7f35b9c5e3cc1651034a6","url":"https://github.com/apache/ignite"},{"original_method":"@Override\n   public TableRowElement getRowForItem(CompilePdfError entry)\n   {\n      TableRowElement tr = Document.get().createTRElement();\n      tr.setAttribute(DATA_PATH,\n                      entry.getPath());\n      tr.setAttribute(DATA_LINE,\n                      entry.getLine() + \"\");\n\n      TableCellElement tdIcon = Document.get().createTDElement();\n      tdIcon.setClassName(resources_.styles().iconCell());\n      DivElement iconDiv = Document.get().createDivElement();\n      iconDiv.setClassName(\n            entry.getType() == CompilePdfError.ERROR ? resources_.styles().errorIcon() :\n            entry.getType() == CompilePdfError.WARNING ? resources_.styles().warningIcon() :\n            resources_.styles().boxIcon());\n      tdIcon.appendChild(iconDiv);\n      tr.appendChild(tdIcon);\n\n      TableCellElement tdLine = Document.get().createTDElement();\n      tdLine.setClassName(resources_.styles().lineCell());\n      tdLine.setInnerText(\"Line \" + entry.getLine());\n      tr.appendChild(tdLine);\n\n      TableCellElement tdMsg = Document.get().createTDElement();\n      tdMsg.setClassName(resources_.styles().messageCell());\n      tdMsg.setInnerText(entry.getMessage());\n      tr.appendChild(tdMsg);\n\n      return tr;\n\n   }","id":75180,"modified_method":"@Override\n   public TableRowElement getRowForItem(CompilePdfError entry)\n   {\n      TableRowElement tr = Document.get().createTRElement();\n      tr.setAttribute(DATA_PATH,\n                      entry.getPath());\n      tr.setAttribute(DATA_LINE,\n                      entry.getLine() + \"\");\n\n      TableCellElement tdIcon = Document.get().createTDElement();\n      tdIcon.setClassName(resources_.styles().iconCell());\n      DivElement iconDiv = Document.get().createDivElement();\n      iconDiv.setClassName(\n            entry.getType() == CompilePdfError.ERROR ? resources_.styles().errorIcon() :\n            entry.getType() == CompilePdfError.WARNING ? resources_.styles().warningIcon() :\n            resources_.styles().boxIcon());\n      tdIcon.appendChild(iconDiv);\n      tr.appendChild(tdIcon);\n\n      TableCellElement tdLine = Document.get().createTDElement();\n      tdLine.setClassName(resources_.styles().lineCell());\n      if (entry.getLine() >= 0)\n         tdLine.setInnerText(\"Line \" + entry.getLine());\n      tr.appendChild(tdLine);\n\n      TableCellElement tdMsg = Document.get().createTDElement();\n      tdMsg.setClassName(resources_.styles().messageCell());\n      tdMsg.setInnerText(entry.getMessage());\n      tr.appendChild(tdMsg);\n\n      return tr;\n\n   }","commit_id":"302a69ecfb5cb4a0e03b571a77e7ab82531b0139","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public CodeNavigationTarget getOutputForRow(TableRowElement row)\n   {\n      String path = row.getAttribute(DATA_PATH);\n      int line = Integer.parseInt(row.getAttribute(DATA_LINE));\n      return new CodeNavigationTarget(path,\n                                      FilePosition.create(line, 0));\n   }","id":75181,"modified_method":"@Override\n   public CodeNavigationTarget getOutputForRow(TableRowElement row)\n   {\n      String path = row.getAttribute(DATA_PATH);\n      int line = Integer.parseInt(row.getAttribute(DATA_LINE));\n      if (line < 0) // If we couldn't figure out the line\n         line = 1;\n      return new CodeNavigationTarget(path,\n                                      FilePosition.create(line, 0));\n   }","commit_id":"302a69ecfb5cb4a0e03b571a77e7ab82531b0139","url":"https://github.com/rstudio/rstudio"},{"original_method":"private static JetProperty getCorrespondingProperty(Editor editor, JetFile file) {\n        PsiElement elementAtCaret = file.findElementAt(editor.getCaretModel().getOffset());\n        JetProperty property = PsiTreeUtil.getParentOfType(elementAtCaret, JetProperty.class);\n        if (property != null) return property;\n        JetSimpleNameExpression simpleNameExpression = PsiTreeUtil.getParentOfType(elementAtCaret, JetSimpleNameExpression.class);\n        if (simpleNameExpression != null) {\n            BindingContext bindingContext = getContextForSingleFile(file);\n            VariableDescriptor descriptor = BindingContextUtils.extractVariableDescriptorIfAny(bindingContext, simpleNameExpression, true);\n            if (descriptor != null) {\n                PsiElement declaration = BindingContextUtils.descriptorToDeclaration(bindingContext, descriptor);\n                if (declaration instanceof JetProperty) {\n                    return (JetProperty) declaration;\n                }\n            }\n        }\n        return null;\n    }","id":75182,"modified_method":"private static JetProperty getCorrespondingProperty(Editor editor, JetFile file) {\n        PsiElement elementAtCaret = file.findElementAt(editor.getCaretModel().getOffset());\n        JetProperty property = PsiTreeUtil.getParentOfType(elementAtCaret, JetProperty.class);\n        if (property != null) return property;\n        JetSimpleNameExpression simpleNameExpression = PsiTreeUtil.getParentOfType(elementAtCaret, JetSimpleNameExpression.class);\n        if (simpleNameExpression != null) {\n            BindingContext bindingContext = AnalyzerFacadeWithCache.analyzeFileWithCache(file).getBindingContext();\n            VariableDescriptor descriptor = BindingContextUtils.extractVariableDescriptorIfAny(bindingContext, simpleNameExpression, true);\n            if (descriptor != null) {\n                PsiElement declaration = BindingContextUtils.descriptorToDeclaration(bindingContext, descriptor);\n                if (declaration instanceof JetProperty) {\n                    return (JetProperty) declaration;\n                }\n            }\n        }\n        return null;\n    }","commit_id":"e1dece43455587c0d7cf572bd7a49f3b81118882","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private JetKeywordToken findVisibilityChangeTo(JetFile file) {\n        BindingContext bindingContext = AnalyzeSingleFileUtil.getContextForSingleFile(file);\n        DeclarationDescriptor descriptor;\n        if (element instanceof JetParameter) {\n            descriptor = bindingContext.get(BindingContext.PRIMARY_CONSTRUCTOR_PARAMETER, element);\n        }\n        else {\n            descriptor = bindingContext.get(BindingContext.DECLARATION_TO_DESCRIPTOR, element);\n        }\n        if (!(descriptor instanceof CallableMemberDescriptor)) return null;\n\n        CallableMemberDescriptor memberDescriptor = (CallableMemberDescriptor)descriptor;\n        Visibility maxVisibility = null;\n        for (CallableMemberDescriptor overriddenDescriptor : memberDescriptor.getOverriddenDescriptors()) {\n            Visibility overriddenDescriptorVisibility = overriddenDescriptor.getVisibility();\n            if (maxVisibility == null) {\n                maxVisibility = overriddenDescriptorVisibility;\n                continue;\n            }\n            Integer compare = Visibilities.compare(maxVisibility, overriddenDescriptorVisibility);\n            if (compare == null) {\n                maxVisibility = Visibilities.PUBLIC;\n            }\n            else if (compare < 0) {\n                maxVisibility = overriddenDescriptorVisibility;\n            }\n        }\n        if (maxVisibility == memberDescriptor.getVisibility()) {\n            return null;\n        }\n        JetKeywordToken modifier = null;\n        if (maxVisibility == Visibilities.PUBLIC) {\n            modifier = JetTokens.PUBLIC_KEYWORD;\n        }\n        else if (maxVisibility == Visibilities.PROTECTED) {\n            modifier = JetTokens.PROTECTED_KEYWORD;\n        }\n        else if (maxVisibility == Visibilities.INTERNAL) {\n            modifier = JetTokens.INTERNAL_KEYWORD;\n        }\n        return modifier;\n    }","id":75183,"modified_method":"private JetKeywordToken findVisibilityChangeTo(JetFile file) {\n        BindingContext bindingContext = AnalyzerFacadeWithCache.analyzeFileWithCache(file).getBindingContext();\n        DeclarationDescriptor descriptor;\n        if (element instanceof JetParameter) {\n            descriptor = bindingContext.get(BindingContext.PRIMARY_CONSTRUCTOR_PARAMETER, element);\n        }\n        else {\n            descriptor = bindingContext.get(BindingContext.DECLARATION_TO_DESCRIPTOR, element);\n        }\n        if (!(descriptor instanceof CallableMemberDescriptor)) return null;\n\n        CallableMemberDescriptor memberDescriptor = (CallableMemberDescriptor)descriptor;\n        Visibility maxVisibility = null;\n        for (CallableMemberDescriptor overriddenDescriptor : memberDescriptor.getOverriddenDescriptors()) {\n            Visibility overriddenDescriptorVisibility = overriddenDescriptor.getVisibility();\n            if (maxVisibility == null) {\n                maxVisibility = overriddenDescriptorVisibility;\n                continue;\n            }\n            Integer compare = Visibilities.compare(maxVisibility, overriddenDescriptorVisibility);\n            if (compare == null) {\n                maxVisibility = Visibilities.PUBLIC;\n            }\n            else if (compare < 0) {\n                maxVisibility = overriddenDescriptorVisibility;\n            }\n        }\n        if (maxVisibility == memberDescriptor.getVisibility()) {\n            return null;\n        }\n        JetKeywordToken modifier = null;\n        if (maxVisibility == Visibilities.PUBLIC) {\n            modifier = JetTokens.PUBLIC_KEYWORD;\n        }\n        else if (maxVisibility == Visibilities.PROTECTED) {\n            modifier = JetTokens.PROTECTED_KEYWORD;\n        }\n        else if (maxVisibility == Visibilities.INTERNAL) {\n            modifier = JetTokens.INTERNAL_KEYWORD;\n        }\n        return modifier;\n    }","commit_id":"e1dece43455587c0d7cf572bd7a49f3b81118882","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n     * Add import directive corresponding to a type to file when it is needed.\n     *\n     * @param type type to import\n     * @param file file where import directive should be added\n     */\n    public static void addImportDirectivesIfNeeded(@NotNull JetType type, @NotNull JetFile file) {\n        if (JetPluginUtil.checkTypeIsStandard(type, file.getProject()) || ErrorUtils.isErrorType(type)) {\n            return;\n        }\n        BindingContext bindingContext = getContextForSingleFile(file);\n        PsiElement element = BindingContextUtils.descriptorToDeclaration(bindingContext, type.getMemberScope().getContainingDeclaration());\n        if (element != null && element.getContainingFile() == file) { //declaration is in the same file, so no import is needed\n            return;\n        }\n        for (ClassDescriptor clazz : TypeUtils.getAllClassDescriptors(type)) {\n            addImportDirectiveIfNeeded(DescriptorUtils.getFQName(getTopLevelClass(clazz)).toSafe(), file);\n        }\n    }","id":75184,"modified_method":"/**\n     * Add import directive corresponding to a type to file when it is needed.\n     *\n     * @param type type to import\n     * @param file file where import directive should be added\n     */\n    public static void addImportDirectivesIfNeeded(@NotNull JetType type, @NotNull JetFile file) {\n        if (JetPluginUtil.checkTypeIsStandard(type, file.getProject()) || ErrorUtils.isErrorType(type)) {\n            return;\n        }\n        BindingContext bindingContext = AnalyzerFacadeWithCache.analyzeFileWithCache(file).getBindingContext();\n        PsiElement element = BindingContextUtils.descriptorToDeclaration(bindingContext, type.getMemberScope().getContainingDeclaration());\n        if (element != null && element.getContainingFile() == file) { //declaration is in the same file, so no import is needed\n            return;\n        }\n        for (ClassDescriptor clazz : TypeUtils.getAllClassDescriptors(type)) {\n            addImportDirectiveIfNeeded(DescriptorUtils.getFQName(getTopLevelClass(clazz)).toSafe(), file);\n        }\n    }","commit_id":"e1dece43455587c0d7cf572bd7a49f3b81118882","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public void updateUI(Object descriptor, ParameterInfoUIContext context) {\n        //todo: when we will have ability to pass Array as vararg, implement such feature here too?\n        if (context == null || context.getParameterOwner() == null || !context.getParameterOwner().isValid()) {\n            return;\n        }\n\n        PsiElement parameterOwner = context.getParameterOwner();\n        if (!(parameterOwner instanceof JetValueArgumentList)) {\n            return;\n        }\n\n        JetValueArgumentList argumentList = (JetValueArgumentList) parameterOwner;\n\n        if (!(descriptor instanceof FunctionDescriptor)) {\n            context.setUIComponentEnabled(false);\n            return;\n        }\n\n        FunctionDescriptor functionDescriptor = (FunctionDescriptor) descriptor;\n\n        JetFile file = (JetFile) argumentList.getContainingFile();\n        BindingContext bindingContext = AnalyzeSingleFileUtil.getContextForSingleFile(file);\n        List<ValueParameterDescriptor> valueParameters = functionDescriptor.getValueParameters();\n        List<JetValueArgument> valueArguments = argumentList.getArguments();\n\n        StringBuilder builder = new StringBuilder();\n        int currentParameterIndex = context.getCurrentParameterIndex();\n        int boldStartOffset = -1;\n        int boldEndOffset = -1;\n        boolean isGrey = false;\n        boolean isDeprecated = false; //todo: add deprecation check\n\n        boolean[] usedIndexes = new boolean[valueParameters.size()];\n        boolean namedMode = false;\n        Arrays.fill(usedIndexes, false);\n\n        if ((currentParameterIndex >= valueParameters.size() && (valueParameters.size() > 0 || currentParameterIndex > 0)) &&\n            (valueParameters.size() == 0 || valueParameters.get(valueParameters.size() - 1).getVarargElementType() == null)) {\n            isGrey = true;\n        }\n\n        if (valueParameters.size() == 0) {\n            builder.append(CodeInsightBundle.message(\"parameter.info.no.parameters\"));\n        }\n\n        for (int i = 0; i < valueParameters.size(); ++i) {\n            if (i != 0) {\n                builder.append(\", \");\n            }\n\n            boolean highlightParameter = i == currentParameterIndex ||\n                    (!namedMode && i < currentParameterIndex && valueParameters.get(valueParameters.size() - 1).getVarargElementType() != null);\n\n            if (highlightParameter) {\n                boldStartOffset = builder.length();\n            }\n\n            if (!namedMode) {\n                if (valueArguments.size() > i) {\n                    JetValueArgument argument = valueArguments.get(i);\n                    if (argument.isNamed()) {\n                        namedMode = true;\n                    }\n                    else {\n                        ValueParameterDescriptor param = valueParameters.get(i);\n                        builder.append(renderParameter(param, false, bindingContext));\n                        if (i < currentParameterIndex) {\n                            if (argument.getArgumentExpression() != null) {\n                                //check type\n                                JetType paramType = getActualParameterType(param);\n                                JetType exprType = bindingContext.get(BindingContext.EXPRESSION_TYPE, argument.getArgumentExpression());\n                                if (exprType != null && !JetTypeChecker.INSTANCE.isSubtypeOf(exprType, paramType)) {\n                                    isGrey = true;\n                                }\n                            }\n                            else {\n                                isGrey = true;\n                            }\n                        }\n                        usedIndexes[i] = true;\n                    }\n                }\n                else {\n                    ValueParameterDescriptor param = valueParameters.get(i);\n                    builder.append(renderParameter(param, false, bindingContext));\n                }\n            }\n            if (namedMode) {\n                boolean takeAnyArgument = true;\n                if (valueArguments.size() > i) {\n                    JetValueArgument argument = valueArguments.get(i);\n                    if (argument.isNamed()) {\n                        for (int j = 0; j < valueParameters.size(); ++j) {\n                            JetSimpleNameExpression referenceExpression = argument.getArgumentName().getReferenceExpression();\n                            ValueParameterDescriptor param = valueParameters.get(j);\n                            if (referenceExpression != null && !usedIndexes[j] &&\n                                param.getName().equals(referenceExpression.getReferencedNameAsName())) {\n                                takeAnyArgument = false;\n                                usedIndexes[j] = true;\n                                builder.append(renderParameter(param, true, bindingContext));\n                                if (i < currentParameterIndex) {\n                                    if (argument.getArgumentExpression() != null) {\n                                        //check type\n                                        JetType paramType = getActualParameterType(param);\n                                        JetType exprType = bindingContext.get(BindingContext.EXPRESSION_TYPE, argument.getArgumentExpression());\n                                        if (exprType != null && !JetTypeChecker.INSTANCE.isSubtypeOf(exprType, paramType)) isGrey = true;\n                                    }\n                                    else {\n                                        isGrey = true;\n                                    }\n                                }\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if (takeAnyArgument) {\n                    if (i < currentParameterIndex) {\n                        isGrey = true;\n                    }\n\n                    for (int j = 0; j < valueParameters.size(); ++j) {\n                        ValueParameterDescriptor param = valueParameters.get(j);\n                        if (!usedIndexes[j]) {\n                            usedIndexes[j] = true;\n                            builder.append(renderParameter(param, true, bindingContext));\n                            break;\n                        }\n                    }\n                }\n            }\n\n            if (highlightParameter) {\n                boldEndOffset = builder.length();\n            }\n        }\n\n        Color color = getBackgroundColor(context, argumentList, functionDescriptor, bindingContext);\n\n        if (builder.toString().isEmpty()) {\n            context.setUIComponentEnabled(false);\n        }\n        else {\n            context.setupUIComponentPresentation(builder.toString(), boldStartOffset, boldEndOffset, isGrey,\n                                                 isDeprecated, false, color);\n        }\n    }","id":75185,"modified_method":"@Override\n    public void updateUI(Object descriptor, ParameterInfoUIContext context) {\n        //todo: when we will have ability to pass Array as vararg, implement such feature here too?\n        if (context == null || context.getParameterOwner() == null || !context.getParameterOwner().isValid()) {\n            return;\n        }\n\n        PsiElement parameterOwner = context.getParameterOwner();\n        if (!(parameterOwner instanceof JetValueArgumentList)) {\n            return;\n        }\n\n        JetValueArgumentList argumentList = (JetValueArgumentList) parameterOwner;\n\n        if (!(descriptor instanceof FunctionDescriptor)) {\n            context.setUIComponentEnabled(false);\n            return;\n        }\n\n        FunctionDescriptor functionDescriptor = (FunctionDescriptor) descriptor;\n\n        JetFile file = (JetFile) argumentList.getContainingFile();\n        BindingContext bindingContext = AnalyzerFacadeWithCache.analyzeFileWithCache(file).getBindingContext();\n        List<ValueParameterDescriptor> valueParameters = functionDescriptor.getValueParameters();\n        List<JetValueArgument> valueArguments = argumentList.getArguments();\n\n        StringBuilder builder = new StringBuilder();\n        int currentParameterIndex = context.getCurrentParameterIndex();\n        int boldStartOffset = -1;\n        int boldEndOffset = -1;\n        boolean isGrey = false;\n        boolean isDeprecated = false; //todo: add deprecation check\n\n        boolean[] usedIndexes = new boolean[valueParameters.size()];\n        boolean namedMode = false;\n        Arrays.fill(usedIndexes, false);\n\n        if ((currentParameterIndex >= valueParameters.size() && (valueParameters.size() > 0 || currentParameterIndex > 0)) &&\n            (valueParameters.size() == 0 || valueParameters.get(valueParameters.size() - 1).getVarargElementType() == null)) {\n            isGrey = true;\n        }\n\n        if (valueParameters.size() == 0) {\n            builder.append(CodeInsightBundle.message(\"parameter.info.no.parameters\"));\n        }\n\n        for (int i = 0; i < valueParameters.size(); ++i) {\n            if (i != 0) {\n                builder.append(\", \");\n            }\n\n            boolean highlightParameter = i == currentParameterIndex ||\n                    (!namedMode && i < currentParameterIndex && valueParameters.get(valueParameters.size() - 1).getVarargElementType() != null);\n\n            if (highlightParameter) {\n                boldStartOffset = builder.length();\n            }\n\n            if (!namedMode) {\n                if (valueArguments.size() > i) {\n                    JetValueArgument argument = valueArguments.get(i);\n                    if (argument.isNamed()) {\n                        namedMode = true;\n                    }\n                    else {\n                        ValueParameterDescriptor param = valueParameters.get(i);\n                        builder.append(renderParameter(param, false, bindingContext));\n                        if (i < currentParameterIndex) {\n                            if (argument.getArgumentExpression() != null) {\n                                //check type\n                                JetType paramType = getActualParameterType(param);\n                                JetType exprType = bindingContext.get(BindingContext.EXPRESSION_TYPE, argument.getArgumentExpression());\n                                if (exprType != null && !JetTypeChecker.INSTANCE.isSubtypeOf(exprType, paramType)) {\n                                    isGrey = true;\n                                }\n                            }\n                            else {\n                                isGrey = true;\n                            }\n                        }\n                        usedIndexes[i] = true;\n                    }\n                }\n                else {\n                    ValueParameterDescriptor param = valueParameters.get(i);\n                    builder.append(renderParameter(param, false, bindingContext));\n                }\n            }\n            if (namedMode) {\n                boolean takeAnyArgument = true;\n                if (valueArguments.size() > i) {\n                    JetValueArgument argument = valueArguments.get(i);\n                    if (argument.isNamed()) {\n                        for (int j = 0; j < valueParameters.size(); ++j) {\n                            JetSimpleNameExpression referenceExpression = argument.getArgumentName().getReferenceExpression();\n                            ValueParameterDescriptor param = valueParameters.get(j);\n                            if (referenceExpression != null && !usedIndexes[j] &&\n                                param.getName().equals(referenceExpression.getReferencedNameAsName())) {\n                                takeAnyArgument = false;\n                                usedIndexes[j] = true;\n                                builder.append(renderParameter(param, true, bindingContext));\n                                if (i < currentParameterIndex) {\n                                    if (argument.getArgumentExpression() != null) {\n                                        //check type\n                                        JetType paramType = getActualParameterType(param);\n                                        JetType exprType = bindingContext.get(BindingContext.EXPRESSION_TYPE, argument.getArgumentExpression());\n                                        if (exprType != null && !JetTypeChecker.INSTANCE.isSubtypeOf(exprType, paramType)) isGrey = true;\n                                    }\n                                    else {\n                                        isGrey = true;\n                                    }\n                                }\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if (takeAnyArgument) {\n                    if (i < currentParameterIndex) {\n                        isGrey = true;\n                    }\n\n                    for (int j = 0; j < valueParameters.size(); ++j) {\n                        ValueParameterDescriptor param = valueParameters.get(j);\n                        if (!usedIndexes[j]) {\n                            usedIndexes[j] = true;\n                            builder.append(renderParameter(param, true, bindingContext));\n                            break;\n                        }\n                    }\n                }\n            }\n\n            if (highlightParameter) {\n                boldEndOffset = builder.length();\n            }\n        }\n\n        Color color = getBackgroundColor(context, argumentList, functionDescriptor, bindingContext);\n\n        if (builder.toString().isEmpty()) {\n            context.setUIComponentEnabled(false);\n        }\n        else {\n            context.setupUIComponentPresentation(builder.toString(), boldStartOffset, boldEndOffset, isGrey,\n                                                 isDeprecated, false, color);\n        }\n    }","commit_id":"e1dece43455587c0d7cf572bd7a49f3b81118882","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static JetValueArgumentList findCall(CreateParameterInfoContext context) {\n        //todo: calls to this constructors, when we will have auxiliary constructors\n        PsiFile file = context.getFile();\n        if (!(file instanceof JetFile)) {\n            return null;\n        }\n\n        JetValueArgumentList argumentList = PsiTreeUtil.getParentOfType(file.findElementAt(context.getOffset()), JetValueArgumentList.class);\n        if (argumentList == null) {\n            return null;\n        }\n\n        JetSimpleNameExpression callNameExpression = getCallSimpleNameExpression(argumentList);\n        if (callNameExpression == null) {\n            return null;\n        }\n\n        PsiReference[] references = callNameExpression.getReferences();\n        if (references.length == 0) {\n            return null;\n        }\n\n        BindingContext bindingContext = AnalyzeSingleFileUtil.getContextForSingleFile((JetFile)file);\n        JetScope scope = bindingContext.get(BindingContext.RESOLUTION_SCOPE, callNameExpression);\n        DeclarationDescriptor placeDescriptor = null;\n        if (scope != null) {\n            placeDescriptor = scope.getContainingDeclaration();\n        }\n\n        Collection<DeclarationDescriptor> variants = TipsManager.getReferenceVariants(callNameExpression, bindingContext);\n        Name refName = callNameExpression.getReferencedNameAsName();\n\n        Collection<DeclarationDescriptor> itemsToShow = new ArrayList<DeclarationDescriptor>();\n        for (DeclarationDescriptor variant : variants) {\n            if (variant instanceof FunctionDescriptor) {\n                FunctionDescriptor functionDescriptor = (FunctionDescriptor) variant;\n                if (functionDescriptor.getName().equals(refName)) {\n                    //todo: renamed functions?\n                    if (placeDescriptor != null && !JetVisibilityChecker.isVisible(placeDescriptor, functionDescriptor)) {\n                        continue;\n                    }\n                    itemsToShow.add(functionDescriptor);\n                }\n            }\n            else if (variant instanceof ClassDescriptor) {\n                ClassDescriptor classDescriptor = (ClassDescriptor) variant;\n                if (classDescriptor.getName().equals(refName)) {\n                    //todo: renamed classes?\n                    for (ConstructorDescriptor constructorDescriptor : classDescriptor.getConstructors()) {\n                        if (placeDescriptor != null && !JetVisibilityChecker.isVisible(placeDescriptor, constructorDescriptor)) {\n                            continue;\n                        }\n                        itemsToShow.add(constructorDescriptor);\n                    }\n                }\n            }\n        }\n\n        context.setItemsToShow(ArrayUtil.toObjectArray(itemsToShow));\n        return argumentList;\n    }","id":75186,"modified_method":"private static JetValueArgumentList findCall(CreateParameterInfoContext context) {\n        //todo: calls to this constructors, when we will have auxiliary constructors\n        PsiFile file = context.getFile();\n        if (!(file instanceof JetFile)) {\n            return null;\n        }\n\n        JetValueArgumentList argumentList = PsiTreeUtil.getParentOfType(file.findElementAt(context.getOffset()), JetValueArgumentList.class);\n        if (argumentList == null) {\n            return null;\n        }\n\n        JetSimpleNameExpression callNameExpression = getCallSimpleNameExpression(argumentList);\n        if (callNameExpression == null) {\n            return null;\n        }\n\n        PsiReference[] references = callNameExpression.getReferences();\n        if (references.length == 0) {\n            return null;\n        }\n\n        BindingContext bindingContext = AnalyzerFacadeWithCache.analyzeFileWithCache((JetFile) file).getBindingContext();\n        JetScope scope = bindingContext.get(BindingContext.RESOLUTION_SCOPE, callNameExpression);\n        DeclarationDescriptor placeDescriptor = null;\n        if (scope != null) {\n            placeDescriptor = scope.getContainingDeclaration();\n        }\n\n        Collection<DeclarationDescriptor> variants = TipsManager.getReferenceVariants(callNameExpression, bindingContext);\n        Name refName = callNameExpression.getReferencedNameAsName();\n\n        Collection<DeclarationDescriptor> itemsToShow = new ArrayList<DeclarationDescriptor>();\n        for (DeclarationDescriptor variant : variants) {\n            if (variant instanceof FunctionDescriptor) {\n                FunctionDescriptor functionDescriptor = (FunctionDescriptor) variant;\n                if (functionDescriptor.getName().equals(refName)) {\n                    //todo: renamed functions?\n                    if (placeDescriptor != null && !JetVisibilityChecker.isVisible(placeDescriptor, functionDescriptor)) {\n                        continue;\n                    }\n                    itemsToShow.add(functionDescriptor);\n                }\n            }\n            else if (variant instanceof ClassDescriptor) {\n                ClassDescriptor classDescriptor = (ClassDescriptor) variant;\n                if (classDescriptor.getName().equals(refName)) {\n                    //todo: renamed classes?\n                    for (ConstructorDescriptor constructorDescriptor : classDescriptor.getConstructors()) {\n                        if (placeDescriptor != null && !JetVisibilityChecker.isVisible(placeDescriptor, constructorDescriptor)) {\n                            continue;\n                        }\n                        itemsToShow.add(constructorDescriptor);\n                    }\n                }\n            }\n        }\n\n        context.setItemsToShow(ArrayUtil.toObjectArray(itemsToShow));\n        return argumentList;\n    }","commit_id":"e1dece43455587c0d7cf572bd7a49f3b81118882","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static void doRefactoring(@NotNull final Project project, final Editor editor, @Nullable JetExpression _expression) {\n        if (_expression == null) {\n            showErrorHint(project, editor, JetRefactoringBundle.message(\"cannot.refactor.no.expression\"));\n            return;\n        }\n        if (_expression.getParent() instanceof JetParenthesizedExpression) {\n            _expression = (JetExpression)_expression.getParent();\n        }\n        final JetExpression expression = _expression;\n        boolean noTypeInference = false;\n        boolean needParentheses = false;\n        if (expression.getParent() instanceof JetQualifiedExpression) {\n            JetQualifiedExpression qualifiedExpression = (JetQualifiedExpression)expression.getParent();\n            if (qualifiedExpression.getReceiverExpression() != expression) {\n                showErrorHint(project, editor, JetRefactoringBundle.message(\"cannot.refactor.no.expression\"));\n                return;\n            }\n        }\n        else if (expression instanceof JetStatementExpression) {\n            showErrorHint(project, editor, JetRefactoringBundle.message(\"cannot.refactor.no.expression\"));\n            return;\n        } else if (expression.getParent() instanceof JetCallElement) {\n            if (expression instanceof JetFunctionLiteralExpression) {\n                needParentheses = true;\n            } else {\n                showErrorHint(project, editor, JetRefactoringBundle.message(\"cannot.refactor.no.expression\"));\n                return;\n            }\n        }\n        else if (expression.getParent() instanceof JetOperationExpression) {\n            JetOperationExpression operationExpression = (JetOperationExpression)expression.getParent();\n            if (operationExpression.getOperationReference() == expression) {\n                showErrorHint(project, editor, JetRefactoringBundle.message(\"cannot.refactor.no.expression\"));\n                return;\n            }\n        }\n        AnalyzeExhaust analyzeExhaust = AnalyzeSingleFileUtil.analyzeSingleFileWithCache((JetFile) expression.getContainingFile());\n        BindingContext bindingContext = analyzeExhaust.getBindingContext();\n        final JetType expressionType = bindingContext.get(BindingContext.EXPRESSION_TYPE, expression); //can be null or error type\n        JetScope scope = bindingContext.get(BindingContext.RESOLUTION_SCOPE, expression);\n        if (scope != null) {\n            DataFlowInfo dataFlowInfo = bindingContext.get(BindingContext.NON_DEFAULT_EXPRESSION_DATA_FLOW, expression);\n            if (dataFlowInfo == null) {\n                dataFlowInfo = DataFlowInfo.EMPTY;\n            }\n\n            ObservableBindingTrace bindingTrace = new ObservableBindingTrace(new BindingTraceContext());\n            InjectorForMacros injector = new InjectorForMacros(project, analyzeExhaust.getModuleConfiguration());\n            JetType typeNoExpectedType = injector.getExpressionTypingServices().getType(scope, expression,\n                                                                                TypeUtils.NO_EXPECTED_TYPE, dataFlowInfo,\n                                                                                bindingTrace);\n            if (expressionType != null && typeNoExpectedType != null && !JetTypeChecker.INSTANCE.equalTypes(expressionType,\n                                                                                                           typeNoExpectedType)) {\n                noTypeInference = true;\n            }\n        }\n        if (expressionType instanceof NamespaceType) {\n            showErrorHint(project, editor, JetRefactoringBundle.message(\"cannot.refactor.namespace.expression\"));\n            return;\n        }\n        if (expressionType != null &&\n            JetTypeChecker.INSTANCE.equalTypes(KotlinBuiltIns.getInstance().getUnitType(), expressionType)) {\n            showErrorHint(project, editor, JetRefactoringBundle.message(\"cannot.refactor.expression.has.unit.type\"));\n            return;\n        }\n        if (expressionType == null && noTypeInference) {\n            showErrorHint(project, editor, JetRefactoringBundle.message(\"cannot.refactor.expression.should.have.inferred.type\"));\n            return;\n        }\n        final PsiElement container = getContainer(expression);\n        PsiElement occurrenceContainer = getOccurrenceContainer(expression);\n        if (container == null) {\n            showErrorHint(project, editor, JetRefactoringBundle.message(\"cannot.refactor.no.container\"));\n            return;\n        }\n        final boolean isInplaceAvailableOnDataContext =\n            editor.getSettings().isVariableInplaceRenameEnabled() &&\n            !ApplicationManager.getApplication().isUnitTestMode();\n        final List<JetExpression> allOccurrences = findOccurrences(occurrenceContainer, expression);\n        final boolean finalNoTypeInference = noTypeInference;\n        final boolean finalNeedParentheses = needParentheses;\n        Pass<OccurrencesChooser.ReplaceChoice> callback = new Pass<OccurrencesChooser.ReplaceChoice>() {\n            @Override\n            public void pass(OccurrencesChooser.ReplaceChoice replaceChoice) {\n                boolean replaceOccurrence = container != expression.getParent();\n                List<JetExpression> allReplaces;\n                if (OccurrencesChooser.ReplaceChoice.ALL == replaceChoice) {\n                    if (allOccurrences.size() > 1) replaceOccurrence = true;\n                    allReplaces = allOccurrences;\n                }\n                else {\n                    allReplaces = Collections.singletonList(expression);\n                }\n\n                PsiElement commonParent = PsiTreeUtil.findCommonParent(allReplaces);\n                PsiElement commonContainer = getContainer(commonParent);\n                JetNameValidatorImpl validator = new JetNameValidatorImpl(commonContainer,\n                                                                          calculateAnchor(commonParent,\n                                                                                          commonContainer,\n                                                                                          allReplaces));\n                String[] suggestedNames = JetNameSuggester.suggestNames(expression, validator);\n                final LinkedHashSet<String> suggestedNamesSet = new LinkedHashSet<String>();\n                Collections.addAll(suggestedNamesSet, suggestedNames);\n                final Ref<JetProperty> propertyRef = new Ref<JetProperty>();\n                final ArrayList<JetExpression> references = new ArrayList<JetExpression>();\n                final Ref<JetExpression> reference = new Ref<JetExpression>();\n                final Runnable introduceRunnable = introduceVariable(project, expression, suggestedNames, allReplaces, commonContainer,\n                                                                     commonParent, replaceOccurrence, propertyRef, references,\n                                                                     reference, finalNoTypeInference, finalNeedParentheses, expressionType);\n                final boolean finalReplaceOccurrence = replaceOccurrence;\n                CommandProcessor.getInstance().executeCommand(project, new Runnable() {\n                    @Override\n                    public void run() {\n                        ApplicationManager.getApplication().runWriteAction(introduceRunnable);\n                        JetProperty property = propertyRef.get();\n                        if (property != null) {\n                            editor.getCaretModel().moveToOffset(property.getTextOffset());\n                            editor.getSelectionModel().removeSelection();\n                            if (isInplaceAvailableOnDataContext) {\n                                PsiDocumentManager.getInstance(project).commitDocument(editor.getDocument());\n                                PsiDocumentManager.getInstance(project).\n                                    doPostponedOperationsAndUnblockDocument(editor.getDocument());\n                                JetInplaceVariableIntroducer variableIntroducer =\n                                    new JetInplaceVariableIntroducer(property, editor, project, INTRODUCE_VARIABLE,\n                                                                     references.toArray(new JetExpression[references.size()]),\n                                                                     reference.get(), finalReplaceOccurrence,\n                                                                     property, /*todo*/false, /*todo*/false,\n                                                                     expressionType, finalNoTypeInference);\n                                variableIntroducer.performInplaceRefactoring(suggestedNamesSet);\n                            }\n                        }\n                    }\n                }, INTRODUCE_VARIABLE, null);\n            }\n        };\n        if (isInplaceAvailableOnDataContext) {\n            OccurrencesChooser.<JetExpression>simpleChooser(editor).\n                showChooser(expression, allOccurrences, callback);\n        }\n        else {\n            callback.pass(OccurrencesChooser.ReplaceChoice.ALL);\n        }\n    }","id":75187,"modified_method":"private static void doRefactoring(@NotNull final Project project, final Editor editor, @Nullable JetExpression _expression) {\n        if (_expression == null) {\n            showErrorHint(project, editor, JetRefactoringBundle.message(\"cannot.refactor.no.expression\"));\n            return;\n        }\n        if (_expression.getParent() instanceof JetParenthesizedExpression) {\n            _expression = (JetExpression)_expression.getParent();\n        }\n        final JetExpression expression = _expression;\n        boolean noTypeInference = false;\n        boolean needParentheses = false;\n        if (expression.getParent() instanceof JetQualifiedExpression) {\n            JetQualifiedExpression qualifiedExpression = (JetQualifiedExpression)expression.getParent();\n            if (qualifiedExpression.getReceiverExpression() != expression) {\n                showErrorHint(project, editor, JetRefactoringBundle.message(\"cannot.refactor.no.expression\"));\n                return;\n            }\n        }\n        else if (expression instanceof JetStatementExpression) {\n            showErrorHint(project, editor, JetRefactoringBundle.message(\"cannot.refactor.no.expression\"));\n            return;\n        } else if (expression.getParent() instanceof JetCallElement) {\n            if (expression instanceof JetFunctionLiteralExpression) {\n                needParentheses = true;\n            } else {\n                showErrorHint(project, editor, JetRefactoringBundle.message(\"cannot.refactor.no.expression\"));\n                return;\n            }\n        }\n        else if (expression.getParent() instanceof JetOperationExpression) {\n            JetOperationExpression operationExpression = (JetOperationExpression)expression.getParent();\n            if (operationExpression.getOperationReference() == expression) {\n                showErrorHint(project, editor, JetRefactoringBundle.message(\"cannot.refactor.no.expression\"));\n                return;\n            }\n        }\n        AnalyzeExhaust analyzeExhaust = AnalyzerFacadeWithCache.analyzeFileWithCache((JetFile) expression.getContainingFile());\n        BindingContext bindingContext = analyzeExhaust.getBindingContext();\n        final JetType expressionType = bindingContext.get(BindingContext.EXPRESSION_TYPE, expression); //can be null or error type\n        JetScope scope = bindingContext.get(BindingContext.RESOLUTION_SCOPE, expression);\n        if (scope != null) {\n            DataFlowInfo dataFlowInfo = bindingContext.get(BindingContext.NON_DEFAULT_EXPRESSION_DATA_FLOW, expression);\n            if (dataFlowInfo == null) {\n                dataFlowInfo = DataFlowInfo.EMPTY;\n            }\n\n            ObservableBindingTrace bindingTrace = new ObservableBindingTrace(new BindingTraceContext());\n            InjectorForMacros injector = new InjectorForMacros(project, analyzeExhaust.getModuleConfiguration());\n            JetType typeNoExpectedType = injector.getExpressionTypingServices().getType(scope, expression,\n                                                                                TypeUtils.NO_EXPECTED_TYPE, dataFlowInfo,\n                                                                                bindingTrace);\n            if (expressionType != null && typeNoExpectedType != null && !JetTypeChecker.INSTANCE.equalTypes(expressionType,\n                                                                                                           typeNoExpectedType)) {\n                noTypeInference = true;\n            }\n        }\n        if (expressionType instanceof NamespaceType) {\n            showErrorHint(project, editor, JetRefactoringBundle.message(\"cannot.refactor.namespace.expression\"));\n            return;\n        }\n        if (expressionType != null &&\n            JetTypeChecker.INSTANCE.equalTypes(KotlinBuiltIns.getInstance().getUnitType(), expressionType)) {\n            showErrorHint(project, editor, JetRefactoringBundle.message(\"cannot.refactor.expression.has.unit.type\"));\n            return;\n        }\n        if (expressionType == null && noTypeInference) {\n            showErrorHint(project, editor, JetRefactoringBundle.message(\"cannot.refactor.expression.should.have.inferred.type\"));\n            return;\n        }\n        final PsiElement container = getContainer(expression);\n        PsiElement occurrenceContainer = getOccurrenceContainer(expression);\n        if (container == null) {\n            showErrorHint(project, editor, JetRefactoringBundle.message(\"cannot.refactor.no.container\"));\n            return;\n        }\n        final boolean isInplaceAvailableOnDataContext =\n            editor.getSettings().isVariableInplaceRenameEnabled() &&\n            !ApplicationManager.getApplication().isUnitTestMode();\n        final List<JetExpression> allOccurrences = findOccurrences(occurrenceContainer, expression);\n        final boolean finalNoTypeInference = noTypeInference;\n        final boolean finalNeedParentheses = needParentheses;\n        Pass<OccurrencesChooser.ReplaceChoice> callback = new Pass<OccurrencesChooser.ReplaceChoice>() {\n            @Override\n            public void pass(OccurrencesChooser.ReplaceChoice replaceChoice) {\n                boolean replaceOccurrence = container != expression.getParent();\n                List<JetExpression> allReplaces;\n                if (OccurrencesChooser.ReplaceChoice.ALL == replaceChoice) {\n                    if (allOccurrences.size() > 1) replaceOccurrence = true;\n                    allReplaces = allOccurrences;\n                }\n                else {\n                    allReplaces = Collections.singletonList(expression);\n                }\n\n                PsiElement commonParent = PsiTreeUtil.findCommonParent(allReplaces);\n                PsiElement commonContainer = getContainer(commonParent);\n                JetNameValidatorImpl validator = new JetNameValidatorImpl(commonContainer,\n                                                                          calculateAnchor(commonParent,\n                                                                                          commonContainer,\n                                                                                          allReplaces));\n                String[] suggestedNames = JetNameSuggester.suggestNames(expression, validator);\n                final LinkedHashSet<String> suggestedNamesSet = new LinkedHashSet<String>();\n                Collections.addAll(suggestedNamesSet, suggestedNames);\n                final Ref<JetProperty> propertyRef = new Ref<JetProperty>();\n                final ArrayList<JetExpression> references = new ArrayList<JetExpression>();\n                final Ref<JetExpression> reference = new Ref<JetExpression>();\n                final Runnable introduceRunnable = introduceVariable(project, expression, suggestedNames, allReplaces, commonContainer,\n                                                                     commonParent, replaceOccurrence, propertyRef, references,\n                                                                     reference, finalNoTypeInference, finalNeedParentheses, expressionType);\n                final boolean finalReplaceOccurrence = replaceOccurrence;\n                CommandProcessor.getInstance().executeCommand(project, new Runnable() {\n                    @Override\n                    public void run() {\n                        ApplicationManager.getApplication().runWriteAction(introduceRunnable);\n                        JetProperty property = propertyRef.get();\n                        if (property != null) {\n                            editor.getCaretModel().moveToOffset(property.getTextOffset());\n                            editor.getSelectionModel().removeSelection();\n                            if (isInplaceAvailableOnDataContext) {\n                                PsiDocumentManager.getInstance(project).commitDocument(editor.getDocument());\n                                PsiDocumentManager.getInstance(project).\n                                    doPostponedOperationsAndUnblockDocument(editor.getDocument());\n                                JetInplaceVariableIntroducer variableIntroducer =\n                                    new JetInplaceVariableIntroducer(property, editor, project, INTRODUCE_VARIABLE,\n                                                                     references.toArray(new JetExpression[references.size()]),\n                                                                     reference.get(), finalReplaceOccurrence,\n                                                                     property, /*todo*/false, /*todo*/false,\n                                                                     expressionType, finalNoTypeInference);\n                                variableIntroducer.performInplaceRefactoring(suggestedNamesSet);\n                            }\n                        }\n                    }\n                }, INTRODUCE_VARIABLE, null);\n            }\n        };\n        if (isInplaceAvailableOnDataContext) {\n            OccurrencesChooser.<JetExpression>simpleChooser(editor).\n                showChooser(expression, allOccurrences, callback);\n        }\n        else {\n            callback.pass(OccurrencesChooser.ReplaceChoice.ALL);\n        }\n    }","commit_id":"e1dece43455587c0d7cf572bd7a49f3b81118882","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static ArrayList<JetExpression> findOccurrences(PsiElement occurrenceContainer, @NotNull JetExpression expression) {\n        if (expression instanceof JetParenthesizedExpression) {\n            JetParenthesizedExpression parenthesizedExpression = (JetParenthesizedExpression)expression;\n            JetExpression innerExpression = parenthesizedExpression.getExpression();\n            if (innerExpression != null) {\n                expression = innerExpression;\n            }\n        }\n        final JetExpression actualExpression = expression;\n\n        final ArrayList<JetExpression> result = new ArrayList<JetExpression>();\n\n        final BindingContext bindingContext = AnalyzeSingleFileUtil.getContextForSingleFile((JetFile)expression.getContainingFile());\n\n        JetVisitorVoid visitor = new JetVisitorVoid() {\n            @Override\n            public void visitJetElement(JetElement element) {\n                element.acceptChildren(this);\n                super.visitJetElement(element);\n            }\n\n            @Override\n            public void visitExpression(JetExpression expression) {\n                if (PsiEquivalenceUtil.areElementsEquivalent(expression, actualExpression, null, new Comparator<PsiElement>() {\n                    @Override\n                    public int compare(PsiElement element1, PsiElement element2) {\n                        if (element1.getNode().getElementType() == JetTokens.IDENTIFIER &&\n                            element2.getNode().getElementType() == JetTokens.IDENTIFIER) {\n                            if (element1.getParent() instanceof JetSimpleNameExpression &&\n                                element2.getParent() instanceof JetSimpleNameExpression) {\n                                JetSimpleNameExpression expr1 = (JetSimpleNameExpression)element1.getParent();\n                                JetSimpleNameExpression expr2 = (JetSimpleNameExpression)element2.getParent();\n                                DeclarationDescriptor descr1 = bindingContext.get(BindingContext.REFERENCE_TARGET, expr1);\n                                DeclarationDescriptor descr2 = bindingContext.get(BindingContext.REFERENCE_TARGET, expr2);\n                                if (descr1 != descr2) {\n                                    return 1;\n                                }\n                                else {\n                                    return 0;\n                                }\n                            }\n                        }\n                        if (!element1.textMatches(element2)) {\n                            return 1;\n                        }\n                        else {\n                            return 0;\n                        }\n                    }\n                }, null, false)) {\n                    PsiElement parent = expression.getParent();\n                    if (parent instanceof JetParenthesizedExpression) {\n                        result.add((JetParenthesizedExpression)parent);\n                    }\n                    else {\n                        result.add(expression);\n                    }\n                }\n                else {\n                    super.visitExpression(expression);\n                }\n            }\n        };\n        occurrenceContainer.accept(visitor);\n        return result;\n    }","id":75188,"modified_method":"private static ArrayList<JetExpression> findOccurrences(PsiElement occurrenceContainer, @NotNull JetExpression expression) {\n        if (expression instanceof JetParenthesizedExpression) {\n            JetParenthesizedExpression parenthesizedExpression = (JetParenthesizedExpression)expression;\n            JetExpression innerExpression = parenthesizedExpression.getExpression();\n            if (innerExpression != null) {\n                expression = innerExpression;\n            }\n        }\n        final JetExpression actualExpression = expression;\n\n        final ArrayList<JetExpression> result = new ArrayList<JetExpression>();\n\n        final BindingContext bindingContext = AnalyzerFacadeWithCache.analyzeFileWithCache((JetFile) expression.getContainingFile()).getBindingContext();\n\n        JetVisitorVoid visitor = new JetVisitorVoid() {\n            @Override\n            public void visitJetElement(JetElement element) {\n                element.acceptChildren(this);\n                super.visitJetElement(element);\n            }\n\n            @Override\n            public void visitExpression(JetExpression expression) {\n                if (PsiEquivalenceUtil.areElementsEquivalent(expression, actualExpression, null, new Comparator<PsiElement>() {\n                    @Override\n                    public int compare(PsiElement element1, PsiElement element2) {\n                        if (element1.getNode().getElementType() == JetTokens.IDENTIFIER &&\n                            element2.getNode().getElementType() == JetTokens.IDENTIFIER) {\n                            if (element1.getParent() instanceof JetSimpleNameExpression &&\n                                element2.getParent() instanceof JetSimpleNameExpression) {\n                                JetSimpleNameExpression expr1 = (JetSimpleNameExpression)element1.getParent();\n                                JetSimpleNameExpression expr2 = (JetSimpleNameExpression)element2.getParent();\n                                DeclarationDescriptor descr1 = bindingContext.get(BindingContext.REFERENCE_TARGET, expr1);\n                                DeclarationDescriptor descr2 = bindingContext.get(BindingContext.REFERENCE_TARGET, expr2);\n                                if (descr1 != descr2) {\n                                    return 1;\n                                }\n                                else {\n                                    return 0;\n                                }\n                            }\n                        }\n                        if (!element1.textMatches(element2)) {\n                            return 1;\n                        }\n                        else {\n                            return 0;\n                        }\n                    }\n                }, null, false)) {\n                    PsiElement parent = expression.getParent();\n                    if (parent instanceof JetParenthesizedExpression) {\n                        result.add((JetParenthesizedExpression)parent);\n                    }\n                    else {\n                        result.add(expression);\n                    }\n                }\n                else {\n                    super.visitExpression(expression);\n                }\n            }\n        };\n        occurrenceContainer.accept(visitor);\n        return result;\n    }","commit_id":"e1dece43455587c0d7cf572bd7a49f3b81118882","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n     * Name suggestion types:\n     * 1. According to type:\n     * 1a. Primitive types to some short name\n     * 1b. Class types according to class name camel humps: (AbCd => {abCd, cd})\n     * 1c. Arrays => arrayOfInnerType\n     * 2. Reference expressions according to reference name camel humps\n     * 3. Method call expression according to method callee expression\n     * @param expression to suggest name for variable\n     * @param validator to check scope for such names\n     * @return possible names\n     */\n    public static String[] suggestNames(JetExpression expression, JetNameValidator validator) {\n        ArrayList<String> result = new ArrayList<String>();\n\n        BindingContext bindingContext = AnalyzeSingleFileUtil.getContextForSingleFile((JetFile)expression.getContainingFile());\n        JetType jetType = bindingContext.get(BindingContext.EXPRESSION_TYPE, expression);\n        if (jetType != null) {\n            addNamesForType(result, jetType, validator);\n        }\n        addNamesForExpression(result, expression, validator);\n\n        if (result.isEmpty()) addName(result, \"value\", validator);\n        return ArrayUtil.toStringArray(result);\n    }","id":75189,"modified_method":"/**\n     * Name suggestion types:\n     * 1. According to type:\n     * 1a. Primitive types to some short name\n     * 1b. Class types according to class name camel humps: (AbCd => {abCd, cd})\n     * 1c. Arrays => arrayOfInnerType\n     * 2. Reference expressions according to reference name camel humps\n     * 3. Method call expression according to method callee expression\n     * @param expression to suggest name for variable\n     * @param validator to check scope for such names\n     * @return possible names\n     */\n    public static String[] suggestNames(JetExpression expression, JetNameValidator validator) {\n        ArrayList<String> result = new ArrayList<String>();\n\n        BindingContext bindingContext = AnalyzerFacadeWithCache.analyzeFileWithCache((JetFile) expression.getContainingFile()).getBindingContext();\n        JetType jetType = bindingContext.get(BindingContext.EXPRESSION_TYPE, expression);\n        if (jetType != null) {\n            addNamesForType(result, jetType, validator);\n        }\n        addNamesForExpression(result, expression, validator);\n\n        if (result.isEmpty()) addName(result, \"value\", validator);\n        return ArrayUtil.toStringArray(result);\n    }","commit_id":"e1dece43455587c0d7cf572bd7a49f3b81118882","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static void smartSelectExpression(@NotNull Editor editor, @NotNull PsiFile file, int offset,\n                                             @NotNull final SelectExpressionCallback callback)\n            throws IntroduceRefactoringException {\n        if (offset < 0) throw new IntroduceRefactoringException(JetRefactoringBundle.message(\"cannot.refactor.not.expression\"));\n        PsiElement element = file.findElementAt(offset);\n        if (element == null) throw new IntroduceRefactoringException(JetRefactoringBundle.message(\"cannot.refactor.not.expression\"));\n        if (element instanceof PsiWhiteSpace) {\n            smartSelectExpression(editor, file, offset - 1, callback);\n            return;\n        }\n        ArrayList<JetExpression> expressions = new ArrayList<JetExpression>();\n        while (element != null && !(element instanceof JetBlockExpression && !(element.getParent() instanceof JetFunctionLiteral)) &&\n               !(element instanceof JetNamedFunction)\n               && !(element instanceof JetClassBody)) {\n            if (element instanceof JetExpression && !(element instanceof JetStatementExpression)) {\n                boolean addExpression = true;\n                if (element.getParent() instanceof JetQualifiedExpression) {\n                    JetQualifiedExpression qualifiedExpression = (JetQualifiedExpression) element.getParent();\n                    if (qualifiedExpression.getReceiverExpression() != element) {\n                        addExpression = false;\n                    }\n                }\n                else if (element.getParent() instanceof JetCallElement) {\n                    addExpression = false;\n                }\n                else if (element.getParent() instanceof JetOperationExpression) {\n                    JetOperationExpression operationExpression = (JetOperationExpression) element.getParent();\n                    if (operationExpression.getOperationReference() == element) {\n                        addExpression = false;\n                    }\n                }\n                if (addExpression) {\n                    JetExpression expression = (JetExpression)element;\n                    BindingContext bindingContext = getContextForSingleFile((JetFile)expression.getContainingFile());\n                    JetType expressionType = bindingContext.get(BindingContext.EXPRESSION_TYPE, expression);\n                    if (expressionType == null || !(expressionType instanceof NamespaceType) &&\n                                                  !JetTypeChecker.INSTANCE.equalTypes(KotlinBuiltIns.\n                                                          getInstance().getUnitType(), expressionType)) {\n                        expressions.add(expression);\n                    }\n                }\n            }\n            element = element.getParent();\n        }\n        if (expressions.size() == 0) throw new IntroduceRefactoringException(JetRefactoringBundle.message(\"cannot.refactor.not.expression\"));\n\n        final DefaultListModel model = new DefaultListModel();\n        for (JetExpression expression : expressions) {\n            model.addElement(expression);\n        }\n\n        final ScopeHighlighter highlighter = new ScopeHighlighter(editor);\n\n        final JList list = new JBList(model);\n        \n        list.setCellRenderer(new DefaultListCellRenderer() {\n            @Override\n            public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {\n                Component rendererComponent = super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);\n                JetExpression element = (JetExpression) value;\n                if (element.isValid()) {\n                    setText(getExpressionShortText(element));\n                }\n                return rendererComponent;\n            }\n        });\n\n        list.addListSelectionListener(new ListSelectionListener() {\n            @Override\n            public void valueChanged(ListSelectionEvent e) {\n                highlighter.dropHighlight();\n                int selectedIndex = list.getSelectedIndex();\n                if (selectedIndex < 0) return;\n                JetExpression expression = (JetExpression) model.get(selectedIndex);\n                ArrayList<PsiElement> toExtract = new ArrayList<PsiElement>();\n                toExtract.add(expression);\n                highlighter.highlight(expression, toExtract);\n            }\n        });\n\n        JBPopupFactory.getInstance().createListPopupBuilder(list).\n                setTitle(JetRefactoringBundle.message(\"expressions.title\")).setMovable(false).setResizable(false).\n                setRequestFocus(true).setItemChoosenCallback(new Runnable() {\n            @Override\n            public void run() {\n                callback.run((JetExpression) list.getSelectedValue());\n            }\n        }).addListener(new JBPopupAdapter() {\n            @Override\n            public void onClosed(LightweightWindowEvent event) {\n                highlighter.dropHighlight();\n            }\n        }).createPopup().showInBestPositionFor(editor);\n        \n    }","id":75190,"modified_method":"private static void smartSelectExpression(@NotNull Editor editor, @NotNull PsiFile file, int offset,\n                                             @NotNull final SelectExpressionCallback callback)\n            throws IntroduceRefactoringException {\n        if (offset < 0) throw new IntroduceRefactoringException(JetRefactoringBundle.message(\"cannot.refactor.not.expression\"));\n        PsiElement element = file.findElementAt(offset);\n        if (element == null) throw new IntroduceRefactoringException(JetRefactoringBundle.message(\"cannot.refactor.not.expression\"));\n        if (element instanceof PsiWhiteSpace) {\n            smartSelectExpression(editor, file, offset - 1, callback);\n            return;\n        }\n        ArrayList<JetExpression> expressions = new ArrayList<JetExpression>();\n        while (element != null && !(element instanceof JetBlockExpression && !(element.getParent() instanceof JetFunctionLiteral)) &&\n               !(element instanceof JetNamedFunction)\n               && !(element instanceof JetClassBody)) {\n            if (element instanceof JetExpression && !(element instanceof JetStatementExpression)) {\n                boolean addExpression = true;\n                if (element.getParent() instanceof JetQualifiedExpression) {\n                    JetQualifiedExpression qualifiedExpression = (JetQualifiedExpression) element.getParent();\n                    if (qualifiedExpression.getReceiverExpression() != element) {\n                        addExpression = false;\n                    }\n                }\n                else if (element.getParent() instanceof JetCallElement) {\n                    addExpression = false;\n                }\n                else if (element.getParent() instanceof JetOperationExpression) {\n                    JetOperationExpression operationExpression = (JetOperationExpression) element.getParent();\n                    if (operationExpression.getOperationReference() == element) {\n                        addExpression = false;\n                    }\n                }\n                if (addExpression) {\n                    JetExpression expression = (JetExpression)element;\n                    BindingContext bindingContext = AnalyzerFacadeWithCache.analyzeFileWithCache((JetFile) expression.getContainingFile()).getBindingContext();\n                    JetType expressionType = bindingContext.get(BindingContext.EXPRESSION_TYPE, expression);\n                    if (expressionType == null || !(expressionType instanceof NamespaceType) &&\n                                                  !JetTypeChecker.INSTANCE.equalTypes(KotlinBuiltIns.\n                                                          getInstance().getUnitType(), expressionType)) {\n                        expressions.add(expression);\n                    }\n                }\n            }\n            element = element.getParent();\n        }\n        if (expressions.size() == 0) throw new IntroduceRefactoringException(JetRefactoringBundle.message(\"cannot.refactor.not.expression\"));\n\n        final DefaultListModel model = new DefaultListModel();\n        for (JetExpression expression : expressions) {\n            model.addElement(expression);\n        }\n\n        final ScopeHighlighter highlighter = new ScopeHighlighter(editor);\n\n        final JList list = new JBList(model);\n        \n        list.setCellRenderer(new DefaultListCellRenderer() {\n            @Override\n            public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {\n                Component rendererComponent = super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);\n                JetExpression element = (JetExpression) value;\n                if (element.isValid()) {\n                    setText(getExpressionShortText(element));\n                }\n                return rendererComponent;\n            }\n        });\n\n        list.addListSelectionListener(new ListSelectionListener() {\n            @Override\n            public void valueChanged(ListSelectionEvent e) {\n                highlighter.dropHighlight();\n                int selectedIndex = list.getSelectedIndex();\n                if (selectedIndex < 0) return;\n                JetExpression expression = (JetExpression) model.get(selectedIndex);\n                ArrayList<PsiElement> toExtract = new ArrayList<PsiElement>();\n                toExtract.add(expression);\n                highlighter.highlight(expression, toExtract);\n            }\n        });\n\n        JBPopupFactory.getInstance().createListPopupBuilder(list).\n                setTitle(JetRefactoringBundle.message(\"expressions.title\")).setMovable(false).setResizable(false).\n                setRequestFocus(true).setItemChoosenCallback(new Runnable() {\n            @Override\n            public void run() {\n                callback.run((JetExpression) list.getSelectedValue());\n            }\n        }).addListener(new JBPopupAdapter() {\n            @Override\n            public void onClosed(LightweightWindowEvent event) {\n                highlighter.dropHighlight();\n            }\n        }).createPopup().showInBestPositionFor(editor);\n        \n    }","commit_id":"e1dece43455587c0d7cf572bd7a49f3b81118882","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    public static JetType getDeclarationReturnType(JetNamedDeclaration declaration) {\n        PsiFile file = declaration.getContainingFile();\n        if (!(file instanceof JetFile)) return null;\n        BindingContext bindingContext = getContextForSingleFile((JetFile)file);\n        DeclarationDescriptor descriptor = bindingContext.get(BindingContext.DECLARATION_TO_DESCRIPTOR, declaration);\n        if (!(descriptor instanceof CallableDescriptor)) return null;\n        JetType type = ((CallableDescriptor) descriptor).getReturnType();\n        if (type instanceof DeferredType) {\n            type = ((DeferredType) type).getActualType();\n        }\n        return type;\n    }","id":75191,"modified_method":"@Nullable\n    public static JetType getDeclarationReturnType(JetNamedDeclaration declaration) {\n        PsiFile file = declaration.getContainingFile();\n        if (!(file instanceof JetFile)) return null;\n        BindingContext bindingContext = AnalyzerFacadeWithCache.analyzeFileWithCache((JetFile) file).getBindingContext();\n        DeclarationDescriptor descriptor = bindingContext.get(BindingContext.DECLARATION_TO_DESCRIPTOR, declaration);\n        if (!(descriptor instanceof CallableDescriptor)) return null;\n        JetType type = ((CallableDescriptor) descriptor).getReturnType();\n        if (type instanceof DeferredType) {\n            type = ((DeferredType) type).getActualType();\n        }\n        return type;\n    }","commit_id":"e1dece43455587c0d7cf572bd7a49f3b81118882","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public static JetType getTypeForDeclaration(@NotNull JetNamedDeclaration declaration) {\n        BindingContext bindingContext = AnalyzeSingleFileUtil.getContextForSingleFile((JetFile) declaration.getContainingFile());\n        DeclarationDescriptor descriptor = bindingContext.get(BindingContext.DECLARATION_TO_DESCRIPTOR, declaration);\n\n        JetType type;\n        if (descriptor instanceof VariableDescriptor) {\n            type = ((VariableDescriptor) descriptor).getType();\n        }\n        else if (descriptor instanceof SimpleFunctionDescriptor) {\n            type = ((SimpleFunctionDescriptor) descriptor).getReturnType();\n        }\n        else {\n            return ErrorUtils.createErrorType(\"unknown declaration type\");\n        }\n\n        return type == null ? ErrorUtils.createErrorType(\"null type\") : type;\n    }","id":75192,"modified_method":"@NotNull\n    public static JetType getTypeForDeclaration(@NotNull JetNamedDeclaration declaration) {\n        BindingContext bindingContext = AnalyzerFacadeWithCache.analyzeFileWithCache((JetFile) declaration.getContainingFile()).getBindingContext();\n        DeclarationDescriptor descriptor = bindingContext.get(BindingContext.DECLARATION_TO_DESCRIPTOR, declaration);\n\n        JetType type;\n        if (descriptor instanceof VariableDescriptor) {\n            type = ((VariableDescriptor) descriptor).getType();\n        }\n        else if (descriptor instanceof SimpleFunctionDescriptor) {\n            type = ((SimpleFunctionDescriptor) descriptor).getReturnType();\n        }\n        else {\n            return ErrorUtils.createErrorType(\"unknown declaration type\");\n        }\n\n        return type == null ? ErrorUtils.createErrorType(\"null type\") : type;\n    }","commit_id":"e1dece43455587c0d7cf572bd7a49f3b81118882","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static boolean hasPublicMemberDiagnostic(@NotNull JetNamedDeclaration declaration) {\n        BindingContext bindingContext = AnalyzeSingleFileUtil.getContextForSingleFile((JetFile) declaration.getContainingFile());\n        for (Diagnostic diagnostic : bindingContext.getDiagnostics()) {\n            //noinspection ConstantConditions\n            if (Errors.PUBLIC_MEMBER_SHOULD_SPECIFY_TYPE == diagnostic.getFactory() && declaration == diagnostic.getPsiElement()) {\n                return true;\n            }\n        }\n        return false;\n    }","id":75193,"modified_method":"private static boolean hasPublicMemberDiagnostic(@NotNull JetNamedDeclaration declaration) {\n        BindingContext bindingContext = AnalyzerFacadeWithCache.analyzeFileWithCache((JetFile) declaration.getContainingFile()).getBindingContext();\n        for (Diagnostic diagnostic : bindingContext.getDiagnostics()) {\n            //noinspection ConstantConditions\n            if (Errors.PUBLIC_MEMBER_SHOULD_SPECIFY_TYPE == diagnostic.getFactory() && declaration == diagnostic.getPsiElement()) {\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"e1dece43455587c0d7cf572bd7a49f3b81118882","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static boolean isStatic(ClassDescriptor declarationClassDescriptor) {\n        DeclarationDescriptor containingDescriptor = declarationClassDescriptor.getContainingDeclaration();\n        if (containingDescriptor instanceof NamespaceDescriptor) {\n            return true;\n        }\n        else if (containingDescriptor instanceof ClassDescriptor) {\n            ClassDescriptor containingClassDescriptor = (ClassDescriptor) containingDescriptor;\n            return containingClassDescriptor.getKind().isObject() || declarationClassDescriptor.getKind() == ClassKind.ENUM_CLASS;\n        }\n        else {\n            return false;\n        }\n    }","id":75194,"modified_method":"private static boolean isStatic(ClassDescriptor declarationClassDescriptor) {\n        if (declarationClassDescriptor.getKind() == ClassKind.ENUM_CLASS) {\n            return true;\n        }\n        DeclarationDescriptor containingDescriptor = declarationClassDescriptor.getContainingDeclaration();\n        if (containingDescriptor instanceof NamespaceDescriptor) {\n            return true;\n        }\n        else if (containingDescriptor instanceof ClassDescriptor) {\n            ClassDescriptor containingClassDescriptor = (ClassDescriptor) containingDescriptor;\n            return containingClassDescriptor.getKind().isObject();\n        }\n        else {\n            return false;\n        }\n    }","commit_id":"4db732c11bb2865be8daed2101c87ddf095b4599","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/** Return all the frames. */\n  public Schema list(int version, Frames f) {\n    final Key[] frameKeys = KeySnapshot.globalSnapshot().filter(new KeySnapshot.KVFilter() {\n        @Override\n        public boolean filter(KeySnapshot.KeyInfo k) {\n          return k._type == TypeMap.FRAME;\n        }\n      }).keys();\n\n    f.frames = new Frame[frameKeys.length];\n    for (int i = 0; i < frameKeys.length; i++) {\n      Frame frame = getFromDKV(frameKeys[i]);\n      f.frames[i] = frame;\n    }\n    return this.schema(version).fillFromImpl(f);\n  }","id":75195,"modified_method":"/** Return all the frames. */\n  public Schema list(int version, Frames f) {\n    f.frames = Frames.fetchAll();\n    return this.schema(version).fillFromImpl(f);\n  }","commit_id":"0a041b1c18398be7b948b848ac33358e1c0db2ed","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public boolean isClassifier() { return classNames() != null ; }","id":75196,"modified_method":"/** Is this model a classification model? (v. a regression or clustering model) */\n    public boolean isClassifier() { return classNames() != null ; }","commit_id":"0a041b1c18398be7b948b848ac33358e1c0db2ed","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public String[] classNames() { return _domains[_domains.length-1]; }","id":75197,"modified_method":"/** The names of the levels for an enum (categorical) response column. */\n    public String[] classNames() { return _domains[_domains.length-1]; }","commit_id":"0a041b1c18398be7b948b848ac33358e1c0db2ed","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public String[] allNames() { return _names; }","id":75198,"modified_method":"/** The names of all the columns, including the response column (which comes last). */\n    public String[] allNames() { return _names; }","commit_id":"0a041b1c18398be7b948b848ac33358e1c0db2ed","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public String responseName() { return   _names[  _names.length-1]; }","id":75199,"modified_method":"/** The name of the response column (which is always the last column). */\n    public String responseName() { return   _names[  _names.length-1]; }","commit_id":"0a041b1c18398be7b948b848ac33358e1c0db2ed","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override\n  public AutoBuffer writeJSON_impl( AutoBuffer ab ) {\n    ab.putJSONStr(\"key\", key.toString());\n    ab.put1(',');\n\n    // Builds ModelParameterSchemaV2 objects for each field, and then calls writeJSON on the array\n    ModelParametersSchema.writeParametersJSON(ab, parameters, createParametersSchema());\n    ab.put1(',');\n\n    // Let output render itself:\n    ab.putJSON (\"output\", output);\n    return ab;\n  }","id":75200,"modified_method":"@Override\n  public AutoBuffer writeJSON_impl( AutoBuffer ab ) {\n    ab.putJSONStr(\"key\", key.toString());\n    ab.put1(',');\n\n    // Builds ModelParameterSchemaV2 objects for each field, and then calls writeJSON on the array\n    ModelParametersSchema.writeParametersJSON(ab, parameters, createParametersSchema());\n    ab.put1(',');\n\n    // Let output render itself:\n    ab.putJSON (\"output\", output);\n    ab.put1(',');\n\n    // TODO: compatible_frames should only have the list of keys; the containing request should contain all the frames.\n    // Let the compatible_frames render themselves:\n    ab.putJSON(\"compatible_frames\", compatible_frames);\n    return ab;\n  }","commit_id":"0a041b1c18398be7b948b848ac33358e1c0db2ed","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override public Models createImpl() {\n    Models m = new Models();\n    m.key = this.key;\n\n    if (null != models) {\n      m.models = new Model[models.length];\n\n      int i = 0;\n      for (ModelSchema model : this.models) {\n        m.models[i++] = model.createImpl();\n      }\n    }\n    return m;\n  }","id":75201,"modified_method":"@Override public Models createImpl() {\n    Models m = new Models();\n    // TODO: this is failing in BeanUtils with an IllegalAccessException.  Why?  Different class loaders?\n    // BeanUtils.copyProperties(m, this, BeanUtils.FieldNaming.CONSISTENT);\n\n    // Shouldn't need to do this manually. . .\n    m.key = this.key;\n    m.find_compatible_frames = this.find_compatible_frames;\n\n    if (null != models) {\n      m.models = new Model[models.length];\n\n      int i = 0;\n      for (ModelSchema model : this.models) {\n        m.models[i++] = model.createImpl();\n      }\n    }\n    return m;\n  }","commit_id":"0a041b1c18398be7b948b848ac33358e1c0db2ed","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override public ModelsBase fillFromImpl(Models m) {\n    this.key = m.key;\n\n    if (null != m.models) {\n      this.models = new ModelSchema[m.models.length];\n\n      int i = 0;\n      for (Model model : m.models) {\n        this.models[i++] = model.schema().fillFromImpl(model);\n      }\n    }\n    return this;\n  }","id":75202,"modified_method":"@Override public ModelsBase fillFromImpl(Models m) {\n    // TODO: this is failing in BeanUtils with an IllegalAccessException.  Why?  Different class loaders?\n    // BeanUtils.copyProperties(this, m, BeanUtils.FieldNaming.CONSISTENT);\n\n    // Shouldn't need to do this manually. . .\n    this.key = m.key;\n    this.find_compatible_frames = m.find_compatible_frames;\n\n    if (null != m.models) {\n      this.models = new ModelSchema[m.models.length];\n\n      int i = 0;\n      for (Model model : m.models) {\n        this.models[i++] = model.schema().fillFromImpl(model);\n      }\n    }\n    return this;\n  }","commit_id":"0a041b1c18398be7b948b848ac33358e1c0db2ed","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/** Return all the models. */\n  public Schema list(int version, Models m) {\n    final Key[] modelKeys = KeySnapshot.globalSnapshot().filter(new KeySnapshot.KVFilter() {\n        @Override\n        public boolean filter(KeySnapshot.KeyInfo k) {\n          return Value.isSubclassOf(k._type, Model.class);\n        }\n      }).keys();\n\n    m.models = new Model[modelKeys.length];\n    for (int i = 0; i < modelKeys.length; i++) {\n      Model model = getFromDKV(modelKeys[i]);\n      m.models[i] = model;\n    }\n    return this.schema(version).fillFromImpl(m);\n  }","id":75203,"modified_method":"/** Return all the models. */\n  public Schema list(int version, Models m) {\n    m.models = Models.fetchAll();\n    return this.schema(version).fillFromImpl(m);\n  }","commit_id":"0a041b1c18398be7b948b848ac33358e1c0db2ed","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/** Return a single model. */\n  public Schema fetch(int version, Models m) {\n    Model model = getFromDKV(m.key);\n    m.models = new Model[1];\n    m.models[0] = model;\n    return this.schema(version).fillFromImpl(m);\n  }","id":75204,"modified_method":"/** Return a single model. */\n  public Schema fetch(int version, Models m) {\n    Model model = getFromDKV(m.key);\n    m.models = new Model[1];\n    m.models[0] = model;\n    ModelsBase schema = this.schema(version).fillFromImpl(m);\n    if (m.find_compatible_frames) {\n      Frames compatible = new Frames();\n      compatible.frames = Models.findCompatibleFrames(model, Frames.fetchAll(), m.fetchFrameCols());\n      schema.models[0].compatible_frames = (new FramesHandler()).schema(version).fillFromImpl(compatible);\n    }\n    return schema;\n  }","commit_id":"0a041b1c18398be7b948b848ac33358e1c0db2ed","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/** Return a single frame. */\n  public Schema fetch(int version, Frames f) {\n    Frame frame = getFromDKV(f.key);\n    f.frames = new Frame[1];\n    f.frames[0] = frame;\n\n    FramesBase schema = this.schema(version).fillFromImpl(f);\n    if (f.find_compatible_models) {\n      Model[] compatible = Frames.findCompatibleModels(frame, Models.fetchAll(), f.fetchModelCols());\n      schema.compatible_models = new ModelSchema[compatible.length];\n      schema.frames[0].compatible_models = new String[compatible.length];\n      int i = 0;\n      for (Model m : compatible) {\n        schema.compatible_models[i] = m.schema().fillFromImpl(m);\n        schema.frames[0].compatible_models[i] = m._key.toString();\n        i++;\n      }\n    }\n    return schema;\n  }","id":75205,"modified_method":"/** Return a single frame. */\n  public Schema fetch(int version, Frames f) {\n    Frame frame = getFromDKV(f.key);\n    f.frames = new Frame[1];\n    f.frames[0] = frame;\n\n    FramesBase schema = this.schema(version).fillFromImpl(f);\n\n    // Summary data is big, and not always there: null it out here.  You have to call columnSummary\n    // to force computation of the summary data.\n    for (FrameV2 a_frame: schema.frames) {\n      a_frame.clearSummaryFields();\n\n    }\n    if (f.find_compatible_models) {\n      Model[] compatible = Frames.findCompatibleModels(frame, Models.fetchAll(), f.fetchModelCols());\n      schema.compatible_models = new ModelSchema[compatible.length];\n      schema.frames[0].compatible_models = new String[compatible.length];\n      int i = 0;\n      for (Model m : compatible) {\n        schema.compatible_models[i] = m.schema().fillFromImpl(m);\n        schema.frames[0].compatible_models[i] = m._key.toString();\n        i++;\n      }\n    }\n    return schema;\n  }","commit_id":"087423d8560efe693b831ff1dbf0186dd21520fb","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/** Return all the frames. */\n  public Schema list(int version, Frames f) {\n    f.frames = Frames.fetchAll();\n    return this.schema(version).fillFromImpl(f);\n  }","id":75206,"modified_method":"/** Return all the frames. */\n  public Schema list(int version, Frames f) {\n    f.frames = Frames.fetchAll();\n\n    FramesBase schema = this.schema(version).fillFromImpl(f);\n\n    // Summary data is big, and not always there: null it out here.  You have to call columnSummary\n    // to force computation of the summary data.\n    for (FrameV2 a_frame: schema.frames) {\n      a_frame.clearSummaryFields();\n    }\n\n    return schema;\n  }","commit_id":"087423d8560efe693b831ff1dbf0186dd21520fb","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/** Return a single column from the frame. */\n  public Schema column(int version, Frames f) { // TODO: should return a Vec schema\n    Frame frame = getFromDKV(f.key);\n\n    // TODO: We really want to return a different schema here!\n    Vec vec = frame.vec(f.column);\n    if (null == vec)\n      throw new IllegalArgumentException(\"Did not find column: \" + f.column + \" in frame: \" + f.key.toString());\n\n    Vec[] vecs = { vec };\n    String[] names = { f.column };\n    Frame new_frame = new Frame(names, vecs);\n    f.frames = new Frame[1];\n    f.frames[0] = new_frame;\n    return this.schema(version).fillFromImpl(f);\n  }","id":75207,"modified_method":"/** Return a single column from the frame. */\n  public Schema column(int version, Frames f) { // TODO: should return a Vec schema\n    Frame frame = getFromDKV(f.key);\n\n    // TODO: We really want to return a different schema here!\n    Vec vec = frame.vec(f.column);\n    if (null == vec)\n      throw new IllegalArgumentException(\"Did not find column: \" + f.column + \" in frame: \" + f.key.toString());\n\n    Vec[] vecs = { vec };\n    String[] names = { f.column };\n    Frame new_frame = new Frame(names, vecs);\n    f.frames = new Frame[1];\n    f.frames[0] = new_frame;\n    FramesBase schema = this.schema(version).fillFromImpl(f);\n    schema.frames[0].clearSummaryFields();\n    return schema;\n  }","commit_id":"087423d8560efe693b831ff1dbf0186dd21520fb","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override public FramesBase fillFromImpl(Frames f) {\n    this.key = f.key;\n    this.column = f.column; // NOTE: this is needed for request handling, but isn't really partof state; base\n\n    if (null != f.frames) {\n      this.frames = new FrameV2[f.frames.length];\n\n      int i = 0;\n      for (Frame frame : f.frames) {\n        this.frames[i++] = new FrameV2(frame, 0, 100);\n      }\n    }\n    return this;\n  }","id":75208,"modified_method":"@Override public FramesBase fillFromImpl(Frames f) {\n    this.key = f.key;\n    this.column = f.column; // NOTE: this is needed for request handling, but isn't really part of state\n    this.find_compatible_models = f.find_compatible_models;\n\n    if (null != f.frames) {\n      this.frames = new FrameV2[f.frames.length];\n\n      int i = 0;\n      for (Frame frame : f.frames) {\n        this.frames[i++] = new FrameV2(frame, 0, 100);\n      }\n    }\n    return this;\n  }","commit_id":"187d67a0ac750d8c042bb84deb2ede7d144428fa","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override public Frames createImpl() {\n    Frames f = new Frames();\n    f.key = this.key;\n    f.column = this.column; // NOTE: this is needed for request handling, but isn't really part of state\n\n    if (null != frames) {\n      f.frames = new Frame[frames.length];\n\n      int i = 0;\n      for (FrameV2 frame : this.frames) {\n        f.frames[i++] = frame._fr;\n      }\n    }\n    return f;\n  }","id":75209,"modified_method":"@Override public Frames createImpl() {\n    Frames f = new Frames();\n    // TODO: c'mon, use PojoUtils.copyProperties(). . .\n    f.key = this.key;\n    f.column = this.column; // NOTE: this is needed for request handling, but isn't really part of state\n    f.find_compatible_models = this.find_compatible_models;\n\n    if (null != frames) {\n      f.frames = new Frame[frames.length];\n\n      int i = 0;\n      for (FrameV2 frame : this.frames) {\n        f.frames[i++] = frame._fr;\n      }\n    }\n    return f;\n  }","commit_id":"187d67a0ac750d8c042bb84deb2ede7d144428fa","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/** Return a single frame. */\n  public Schema fetch(int version, Frames f) {\n    Frame frame = getFromDKV(f.key);\n    f.frames = new Frame[1];\n    f.frames[0] = frame;\n    return this.schema(version).fillFromImpl(f);\n  }","id":75210,"modified_method":"/** Return a single frame. */\n  public Schema fetch(int version, Frames f) {\n    Frame frame = getFromDKV(f.key);\n    f.frames = new Frame[1];\n    f.frames[0] = frame;\n\n    FramesBase schema = this.schema(version).fillFromImpl(f);\n    if (f.find_compatible_models) {\n      Model[] compatible = Frames.findCompatibleModels(frame, Models.fetchAll(), f.fetchModelCols());\n      schema.compatible_models = new ModelSchema[compatible.length];\n      schema.frames[0].compatible_models = new String[compatible.length];\n      int i = 0;\n      for (Model m : compatible) {\n        schema.compatible_models[i] = m.schema().fillFromImpl(m);\n        schema.frames[0].compatible_models[i++] = m._key.toString();\n      }\n    }\n    return schema;\n  }","commit_id":"187d67a0ac750d8c042bb84deb2ede7d144428fa","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public KubernetesClient getKubernetes() {\n        if (kubernetes == null) {\n            String kubernetesAddress = kubernetesUrl.getValue();\n            if (Strings.isNotBlank(kubernetesAddress)) {\n                kubernetes = new KubernetesClient(new KubernetesFactory(kubernetesAddress));\n            } else {\n                kubernetes = new KubernetesClient();\n            }\n        }\n        Objects.notNull(kubernetes, \"kubernetes\");\n        return kubernetes;\n    }","id":75211,"modified_method":"public KubernetesClient getKubernetes() {\n        if (kubernetes == null) {\n            String kubernetesAddress = kubernetesUrl.getValue();\n            if (Strings.isNotBlank(kubernetesAddress)) {\n                kubernetes = new DefaultKubernetesClient(new DefaultKubernetesClient.ConfigBuilder().masterUrl(kubernetesAddress).build());\n            } else {\n                kubernetes = new DefaultKubernetesClient();\n            }\n        }\n        Objects.notNull(kubernetes, \"kubernetes\");\n        return kubernetes;\n    }","commit_id":"3994edc36aa49cf0429c5be9129b3c106cbe64eb","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public KubernetesClient getKubernetes() {\n        if (kubernetes == null) {\n            String kubernetesAddress = kubernetesUrl.getValue();\n            if (Strings.isNotBlank(kubernetesAddress)) {\n                kubernetes = new KubernetesClient(new KubernetesFactory(kubernetesAddress));\n            } else {\n                kubernetes = new KubernetesClient();\n            }\n            if (namespace != null) {\n                kubernetes.setNamespace(namespace);\n            }\n        }\n        Objects.notNull(kubernetes, \"kubernetes\");\n        return kubernetes;\n    }","id":75212,"modified_method":"public KubernetesClient getKubernetes() {\n        if (kubernetes == null) {\n            String kubernetesAddress = kubernetesUrl.getValue();\n            if (Strings.isNotBlank(kubernetesAddress)) {\n                kubernetes = new DefaultKubernetesClient(new DefaultKubernetesClient.ConfigBuilder().masterUrl(kubernetesAddress).build());\n            } else {\n                kubernetes = new DefaultKubernetesClient();\n            }\n        }\n        Objects.notNull(kubernetes, \"kubernetes\");\n        return kubernetes;\n    }","commit_id":"3994edc36aa49cf0429c5be9129b3c106cbe64eb","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public String getNamespace() {\n        return getKubernetes().getNamespace();\n    }","id":75213,"modified_method":"public String getNamespace() {\n        return namespace;\n    }","commit_id":"3994edc36aa49cf0429c5be9129b3c106cbe64eb","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void setNamespace(String namespace) {\n        AbstractKubernetesCommand.namespace = namespace;\n        if (kubernetes != null) {\n            kubernetes.setNamespace(namespace);\n        }\n    }","id":75214,"modified_method":"public void setNamespace(String namespace) {\n        AbstractKubernetesCommand.namespace = namespace;\n    }","commit_id":"3994edc36aa49cf0429c5be9129b3c106cbe64eb","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public Result execute(UIExecutionContext context) throws Exception {\n        Kubernetes kubernetes = getKubernetes();\n\n        String podIdText = podId.getValue();\n        Pod podInfo = getKubernetes().getPod(podIdText);\n        if (podInfo == null) {\n            System.out.println(\"No pod for id: \" + podIdText);\n        } else {\n            executePod(podInfo, podIdText);\n        }\n        return null;\n    }","id":75215,"modified_method":"@Override\n    public Result execute(UIExecutionContext context) throws Exception {\n        KubernetesClient kubernetes = getKubernetes();\n\n        String podIdText = podId.getValue();\n        Pod podInfo = getKubernetes().pods().inNamespace(getNamespace()).withName(podIdText).get();\n        if (podInfo == null) {\n            System.out.println(\"No pod for id: \" + podIdText);\n        } else {\n            executePod(podInfo, podIdText);\n        }\n        return null;\n    }","commit_id":"3994edc36aa49cf0429c5be9129b3c106cbe64eb","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public void initializeUI(UIBuilder builder) throws Exception {\n        super.initializeUI(builder);\n\n        // populate autocompletion options\n        podId.setCompleter(new UICompleter<String>() {\n            @Override\n            public Iterable<String> getCompletionProposals(UIContext context, InputComponent<?, String> input, String value) {\n                List<String> list = new ArrayList<String>();\n                PodList pods = getKubernetes().getPods();\n                if (pods != null) {\n                    List<Pod> items = pods.getItems();\n                    if (items != null) {\n                        for (Pod item : items) {\n                            String id = KubernetesHelper.getName(item);\n                            list.add(id);\n                        }\n                    }\n                }\n                Collections.sort(list);\n                System.out.println(\"Completion list is \" + list);\n                return list;\n            }\n        });\n\n        builder.add(podId);\n    }","id":75216,"modified_method":"@Override\n    public void initializeUI(UIBuilder builder) throws Exception {\n        super.initializeUI(builder);\n\n        // populate autocompletion options\n        podId.setCompleter(new UICompleter<String>() {\n            @Override\n            public Iterable<String> getCompletionProposals(UIContext context, InputComponent<?, String> input, String value) {\n                List<String> list = new ArrayList<String>();\n                PodList pods = getKubernetes().pods().list();\n                if (pods != null) {\n                    List<Pod> items = pods.getItems();\n                    if (items != null) {\n                        for (Pod item : items) {\n                            String id = KubernetesHelper.getName(item);\n                            list.add(id);\n                        }\n                    }\n                }\n                Collections.sort(list);\n                System.out.println(\"Completion list is \" + list);\n                return list;\n            }\n        });\n\n        builder.add(podId);\n    }","commit_id":"3994edc36aa49cf0429c5be9129b3c106cbe64eb","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public TaigaClient getTaiga() {\n        if (taiga == null) {\n            taiga = TaigaKubernetes.createTaiga(getKubernetes());\n        }\n        return taiga;\n    }","id":75217,"modified_method":"public TaigaClient getTaiga() {\n        if (taiga == null) {\n            taiga = TaigaKubernetes.createTaiga(getKubernetes(),namespace);\n        }\n        return taiga;\n    }","commit_id":"3994edc36aa49cf0429c5be9129b3c106cbe64eb","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public KubernetesClient getKubernetes() {\n        if (kubernetes == null) {\n            kubernetes = new KubernetesClient();\n        }\n        return kubernetes;\n    }","id":75218,"modified_method":"public KubernetesClient getKubernetes() {\n        return new DefaultKubernetesClient();\n    }","commit_id":"3994edc36aa49cf0429c5be9129b3c106cbe64eb","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Lets create an ImageRegistry, BuildConfig and DeploymentConfig for the new project\n     */\n    protected void createKubernetesResources(String user, String buildName, String remote, String branch, GitRepoClient repoClient, String address) throws Exception {\n        String imageTag = \"test\";\n        String secret = \"secret101\";\n        String builderImage = \"fabric8/java-main\";\n        String osapiVersion = \"v1\";\n        String namespace = kubernetes.getNamespace();\n        if (Strings.isNullOrEmpty(namespace)) {\n            namespace = KubernetesClient.defaultNamespace();\n            kubernetes.setNamespace(namespace);\n        }\n        String gitServiceName = \"gogs\";\n\n\n        // TODO we should replace the remote with the actual service IP address???\n\n        String gitAddress = getServiceAddress(gitServiceName, namespace);\n        if (gitAddress == null) {\n            LOG.warn(\"Could not find service \" + gitServiceName + \" for namespace \" + namespace);\n            gitAddress = address;\n        }\n\n        String json = \"\\n\" +\n                \"{\\n\" +\n                \"   \\\"annotations\\\":{\\n\" +\n                \"      \\\"description\\\":\\\"This is an end to end example of a Continuous Delivery pipeline running on OpenShift v3\\\"\\n\" +\n                \"   },\\n\" +\n                \"   \\\"apiVersion\\\":\\\"\" + osapiVersion + \"\\\",\\n\" +\n                \"   \\\"kind\\\":\\\"List\\\",\\n\" +\n                \"   \\\"items\\\":[\\n\" +\n                \"      {\\n\" +\n                \"         \\\"apiVersion\\\":\\\"\" + osapiVersion + \"\\\",\\n\" +\n                \"         \\\"kind\\\":\\\"ImageStream\\\",\\n\" +\n                \"         \\\"metadata\\\":{\\n\" +\n                \"            \\\"labels\\\":{\\n\" +\n                \"               \\\"name\\\":\\\"\" + buildName + \"\\\",\\n\" +\n                \"               \\\"user\\\":\\\"\" + user + \"\\\"\\n\" +\n                \"            },\\n\" +\n                \"            \\\"name\\\":\\\"\" + buildName + \"\\\"\\n\" +\n                \"         }\\n\" +\n                \"      },\\n\" +\n                \"      {\\n\" +\n                \"         \\\"apiVersion\\\":\\\"\" + osapiVersion + \"\\\",\\n\" +\n                \"         \\\"kind\\\":\\\"BuildConfig\\\",\\n\" +\n                \"         \\\"metadata\\\":{\\n\" +\n                \"            \\\"labels\\\":{\\n\" +\n                \"               \\\"name\\\":\\\"\" + buildName + \"\\\",\\n\" +\n                \"               \\\"user\\\":\\\"\" + user + \"\\\"\\n\" +\n                \"            },\\n\" +\n                \"            \\\"name\\\":\\\"\" + buildName + \"\\\"\\n\" +\n                \"         },\\n\" +\n                \"         \\\"parameters\\\":{\\n\" +\n                \"            \\\"output\\\":{\\n\" +\n                \"               \\\"to\\\":{\\n\" +\n                \"                  \\\"name\\\":\\\"\" + buildName + \"\\\"\\n\" +\n                \"               },\\n\" +\n                \"               \\\"tag\\\":\\\"test\\\"\\n\" +\n                \"            },\\n\" +\n                \"            \\\"source\\\":{\\n\" +\n                \"               \\\"git\\\":{\\n\" +\n                \"                  \\\"uri\\\":\\\"\" + gitAddress + \"/\" + user + \"/\" + buildName + \".git\\\"\\n\" +\n                \"               },\\n\" +\n                \"               \\\"type\\\":\\\"Git\\\"\\n\" +\n                \"            },\\n\" +\n                \"            \\\"strategy\\\":{\\n\" +\n                \"               \\\"stiStrategy\\\":{\\n\" +\n                \"                  \\\"builderImage\\\":\\\"\" + builderImage + \"\\\",\\n\" +\n                \"                  \\\"image\\\":\\\"\" + builderImage + \"\\\"\\n\" +\n                \"               },\\n\" +\n                \"               \\\"type\\\":\\\"STI\\\"\\n\" +\n                \"            }\\n\" +\n                \"         },\\n\" +\n                \"         \\\"triggers\\\":[\\n\" +\n                \"            {\\n\" +\n                \"               \\\"github\\\":{\\n\" +\n                \"                  \\\"secret\\\":\\\"\" + secret + \"\\\"\\n\" +\n                \"               },\\n\" +\n                \"               \\\"type\\\":\\\"github\\\"\\n\" +\n                \"            },\\n\" +\n                \"            {\\n\" +\n                \"               \\\"generic\\\":{\\n\" +\n                \"                  \\\"secret\\\":\\\"\" + secret + \"\\\"\\n\" +\n                \"               },\\n\" +\n                \"               \\\"type\\\":\\\"generic\\\"\\n\" +\n                \"            }\\n\" +\n                \"         ]\\n\" +\n                \"      },\\n\" +\n                \"      {\\n\" +\n                \"         \\\"apiVersion\\\":\\\"\" + osapiVersion + \"\\\",\\n\" +\n                \"         \\\"kind\\\":\\\"DeploymentConfig\\\",\\n\" +\n                \"         \\\"metadata\\\":{\\n\" +\n                \"            \\\"name\\\":\\\"\" + buildName + \"-deploy\\\"\\n\" +\n                \"         },\\n\" +\n                \"         \\\"template\\\":{\\n\" +\n                \"            \\\"controllerTemplate\\\":{\\n\" +\n                \"               \\\"podTemplate\\\":{\\n\" +\n                \"                  \\\"desiredState\\\":{\\n\" +\n                \"                     \\\"manifest\\\":{\\n\" +\n                \"                        \\\"containers\\\":[\\n\" +\n                \"                           {\\n\" +\n                \"                              \\\"image\\\":\\\"\" + buildName + \"\\\",\\n\" +\n                \"                              \\\"name\\\":\\\"\" + buildName + \"\\\",\\n\" +\n                \"                              \\\"ports\\\":[\\n\" +\n                \"                                 {\\n\" +\n                \"                                    \\\"containerPort\\\":8778\\n\" +\n                \"                                 }\\n\" +\n                \"                              ]\\n\" +\n                \"                           }\\n\" +\n                \"                        ],\\n\" +\n                \"                        \\\"version\\\":\\\"\" + imageTag + \"\\\"\\n\" +\n                \"                     }\\n\" +\n                \"                  },\\n\" +\n                \"                  \\\"labels\\\":{\\n\" +\n                \"                     \\\"name\\\":\\\"\" + buildName + \"\\\",\\n\" +\n                \"                     \\\"user\\\":\\\"\" + user + \"\\\"\\n\" +\n                \"                  }\\n\" +\n                \"               },\\n\" +\n                \"               \\\"replicaSelector\\\":{\\n\" +\n                \"                  \\\"name\\\":\\\"\" + buildName + \"\\\",\\n\" +\n                \"                  \\\"user\\\":\\\"\" + user + \"\\\"\\n\" +\n                \"               },\\n\" +\n                \"               \\\"replicas\\\":1\\n\" +\n                \"            },\\n\" +\n                \"            \\\"strategy\\\":{\\n\" +\n                \"               \\\"type\\\":\\\"Recreate\\\"\\n\" +\n                \"            }\\n\" +\n                \"         },\\n\" +\n                \"         \\\"triggers\\\":[\\n\" +\n                \"            {\\n\" +\n                \"               \\\"type\\\":\\\"ImageChange\\\",\\n\" +\n                \"               \\\"imageChangeParams\\\":{\\n\" +\n                \"                  \\\"automatic\\\":true,\\n\" +\n                \"                  \\\"containerNames\\\":[\\n\" +\n                \"                     \\\"\" + buildName + \"\\\"\\n\" +\n                \"                  ],\\n\" +\n                \"                  \\\"from\\\":{\\n\" +\n                \"                     \\\"name\\\":\\\"\" + buildName + \"\\\"\\n\" +\n                \"                  },\\n\" +\n                \"                  \\\"tag\\\":\\\"\" + imageTag + \"\\\"\\n\" +\n                \"               }\\n\" +\n                \"            }\\n\" +\n                \"         ]\\n\" +\n                \"      }\" +\n                \"   ]\\n\" +\n                \"}\";\n\n        if (createOpenShiftBuildResources) {\n            Controller controller = new Controller(kubernetes);\n            controller.applyJson(json);\n\n\n            String type = \"generic\";\n\n            // TODO due to https://github.com/openshift/origin/issues/1317 we can't use the direct kube REST API\n            // so we need to use a workaround using the fabric8 console service's proxy which hides the payload for us\n            String webhookUrl = null;\n            String kubeAddress = null;\n            boolean appendNamespaceQuery = true;\n\n            // lets try the cdelivery first\n            if (kubeAddress == null) {\n                try {\n                    kubeAddress = kubernetes.getServiceURL(ServiceNames.CDELIVERY_API, namespace, \"http\", false);\n                    webhookUrl = URLUtils.pathJoin(kubeAddress, \"buildConfigHooks\", namespace, buildName);\n                    appendNamespaceQuery = false;\n                } catch (Exception e) {\n                    LOG.warn(\"failed to find cdelivery service URL: \" + e, e);\n                }\n            }\n/*\n        if (kubeAddress == null) {\n            try {\n                kubeAddress = kubernetes.getServiceURL(\"fabric8\", namespace, \"http\", false);\n                webhookUrl = URLUtils.pathJoin(kubeAddress, \"oapi\", KubernetesHelper.defaultOsApiVersion, \"buildConfigHooks\", buildName, secret, type);\n            } catch (Exception e) {\n                LOG.warn(\"failed to find fabric8 console service URL: \" + e, e);\n            }\n        }\n*/\n            if (kubeAddress == null) {\n                kubeAddress = kubernetes.getAddress();\n            }\n            String namespacePath = \"\";\n            if (appendNamespaceQuery && !Strings.isNullOrEmpty(namespace)) {\n                namespacePath = \"/namespace=\" + namespace;\n            }\n\n            if (webhookUrl == null) {\n                webhookUrl = URLUtils.pathJoin(kubeAddress, \"oapi\", KubernetesHelper.defaultOsApiVersion + namespacePath, \"buildConfigHooks\", buildName, secret, type);\n            }\n\n            LOG.info(\"creating a web hook at: \" + webhookUrl);\n            try {\n                CreateWebhookDTO createWebhook = new CreateWebhookDTO();\n                createWebhook.setType(\"gogs\");\n                WebhookConfig config = createWebhook.getConfig();\n                config.setUrl(webhookUrl);\n                config.setSecret(secret);\n                WebHookDTO webhook = repoClient.createWebhook(user, buildName, createWebhook);\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Got web hook: \" + toJson(webhook));\n                }\n            } catch (Exception e) {\n                LOG.warn(\"Failed to create web hook in git repo: \" + e, e);\n            }\n        }\n\n\n\n/*        Map<String,String> labels = new LinkedHashMap<>();\n        labels.put(\"name\", buildName);\n        labels.put(\"user\", user);\n\n        Map<String,String> to = new LinkedHashMap<>();\n        to.put(\"name\", buildName);\n\n        ImageStream imageRepository = new ImageStream();\n        imageRepository.setKind(\"ImageStream\");\n        imageRepository.setApiVersion(osapiVersion);\n        imageRepository.setName(buildName);\n        imageRepository.setLabels(labels);\n        handleKubernetesResourceCreation(imageRepository.getKind(), imageRepository, kubernetes.createImageStream(imageRepository));\n\n        BuildConfig buildConfig = new BuildConfig();\n        buildConfig.setKind(\"BuildConfig\");\n        buildConfig.setApiVersion(osapiVersion);\n        buildConfig.setName(buildName);\n        buildConfig.setLabels(labels);\n\n        BuildOutput output = new BuildOutput();\n        // TODO should be to: { labels }\n        //output.setRegistry(buildName);\n        output.getAdditionalProperties().put(\"to\", to);\n        output.setImageTag(imageTag);\n\n        BuildSource source = new BuildSource();\n        source.setType(\"Git\");\n        GitBuildSource git = new GitBuildSource();\n        git.setUri(remote);\n        source.setGit(git);\n\n        BuildStrategy strategy = new BuildStrategy();\n        strategy.setType(\"STI\");\n        STIBuildStrategy stiStrategy = new STIBuildStrategy();\n        stiStrategy.setImage(builderImage);\n        // TODO\n        //stiStrategy.setBuilderImage(builderImage);\n        stiStrategy.getAdditionalProperties().put(\"builderImage\", builderImage);\n        strategy.setStiStrategy(stiStrategy);\n\n        BuildParameters parameters = new BuildParameters();\n        parameters.setOutput(output);\n        parameters.setSource(source);\n        parameters.setStrategy(strategy);\n        buildConfig.setParameters(parameters);\n\n        BuildTriggerPolicy github = new BuildTriggerPolicy();\n        github.setType(\"github\");\n        WebHookTrigger githubTrigger = new WebHookTrigger();\n        githubTrigger.setSecret(secret);\n        github.setGithub(githubTrigger);\n\n        BuildTriggerPolicy generic = new BuildTriggerPolicy();\n        generic.setType(\"generic\");\n        WebHookTrigger genericTrigger = new WebHookTrigger();\n        genericTrigger.setSecret(secret);\n        generic.setGeneric(genericTrigger);\n\n        List<BuildTriggerPolicy> triggers = new ArrayList<>();\n        triggers.add(github);\n        triggers.add(generic);\n        buildConfig.setTriggers(triggers);\n        \n        handleKubernetesResourceCreation(buildConfig.getKind(), buildConfig, kubernetes.createBuildConfig(buildConfig));*/\n    }","id":75219,"modified_method":"/**\n     * Lets create an ImageRegistry, BuildConfig and DeploymentConfig for the new project\n     */\n    protected void createKubernetesResources(String user, String buildName, String remote, String branch, GitRepoClient repoClient, String address) throws Exception {\n        String imageTag = \"test\";\n        String secret = \"secret101\";\n        String builderImage = \"fabric8/java-main\";\n        String osapiVersion = \"v1\";\n        String namespace = KubernetesHelper.defaultNamespace();\n        String gitServiceName = \"gogs\";\n\n\n        // TODO we should replace the remote with the actual service IP address???\n\n        String gitAddress = getServiceAddress(gitServiceName, namespace);\n        if (gitAddress == null) {\n            LOG.warn(\"Could not find service \" + gitServiceName + \" for namespace \" + namespace);\n            gitAddress = address;\n        }\n\n        String json = \"\\n\" +\n                \"{\\n\" +\n                \"   \\\"annotations\\\":{\\n\" +\n                \"      \\\"description\\\":\\\"This is an end to end example of a Continuous Delivery pipeline running on OpenShift v3\\\"\\n\" +\n                \"   },\\n\" +\n                \"   \\\"apiVersion\\\":\\\"\" + osapiVersion + \"\\\",\\n\" +\n                \"   \\\"kind\\\":\\\"List\\\",\\n\" +\n                \"   \\\"items\\\":[\\n\" +\n                \"      {\\n\" +\n                \"         \\\"apiVersion\\\":\\\"\" + osapiVersion + \"\\\",\\n\" +\n                \"         \\\"kind\\\":\\\"ImageStream\\\",\\n\" +\n                \"         \\\"metadata\\\":{\\n\" +\n                \"            \\\"labels\\\":{\\n\" +\n                \"               \\\"name\\\":\\\"\" + buildName + \"\\\",\\n\" +\n                \"               \\\"user\\\":\\\"\" + user + \"\\\"\\n\" +\n                \"            },\\n\" +\n                \"            \\\"name\\\":\\\"\" + buildName + \"\\\"\\n\" +\n                \"         }\\n\" +\n                \"      },\\n\" +\n                \"      {\\n\" +\n                \"         \\\"apiVersion\\\":\\\"\" + osapiVersion + \"\\\",\\n\" +\n                \"         \\\"kind\\\":\\\"BuildConfig\\\",\\n\" +\n                \"         \\\"metadata\\\":{\\n\" +\n                \"            \\\"labels\\\":{\\n\" +\n                \"               \\\"name\\\":\\\"\" + buildName + \"\\\",\\n\" +\n                \"               \\\"user\\\":\\\"\" + user + \"\\\"\\n\" +\n                \"            },\\n\" +\n                \"            \\\"name\\\":\\\"\" + buildName + \"\\\"\\n\" +\n                \"         },\\n\" +\n                \"         \\\"parameters\\\":{\\n\" +\n                \"            \\\"output\\\":{\\n\" +\n                \"               \\\"to\\\":{\\n\" +\n                \"                  \\\"name\\\":\\\"\" + buildName + \"\\\"\\n\" +\n                \"               },\\n\" +\n                \"               \\\"tag\\\":\\\"test\\\"\\n\" +\n                \"            },\\n\" +\n                \"            \\\"source\\\":{\\n\" +\n                \"               \\\"git\\\":{\\n\" +\n                \"                  \\\"uri\\\":\\\"\" + gitAddress + \"/\" + user + \"/\" + buildName + \".git\\\"\\n\" +\n                \"               },\\n\" +\n                \"               \\\"type\\\":\\\"Git\\\"\\n\" +\n                \"            },\\n\" +\n                \"            \\\"strategy\\\":{\\n\" +\n                \"               \\\"stiStrategy\\\":{\\n\" +\n                \"                  \\\"builderImage\\\":\\\"\" + builderImage + \"\\\",\\n\" +\n                \"                  \\\"image\\\":\\\"\" + builderImage + \"\\\"\\n\" +\n                \"               },\\n\" +\n                \"               \\\"type\\\":\\\"STI\\\"\\n\" +\n                \"            }\\n\" +\n                \"         },\\n\" +\n                \"         \\\"triggers\\\":[\\n\" +\n                \"            {\\n\" +\n                \"               \\\"github\\\":{\\n\" +\n                \"                  \\\"secret\\\":\\\"\" + secret + \"\\\"\\n\" +\n                \"               },\\n\" +\n                \"               \\\"type\\\":\\\"github\\\"\\n\" +\n                \"            },\\n\" +\n                \"            {\\n\" +\n                \"               \\\"generic\\\":{\\n\" +\n                \"                  \\\"secret\\\":\\\"\" + secret + \"\\\"\\n\" +\n                \"               },\\n\" +\n                \"               \\\"type\\\":\\\"generic\\\"\\n\" +\n                \"            }\\n\" +\n                \"         ]\\n\" +\n                \"      },\\n\" +\n                \"      {\\n\" +\n                \"         \\\"apiVersion\\\":\\\"\" + osapiVersion + \"\\\",\\n\" +\n                \"         \\\"kind\\\":\\\"DeploymentConfig\\\",\\n\" +\n                \"         \\\"metadata\\\":{\\n\" +\n                \"            \\\"name\\\":\\\"\" + buildName + \"-deploy\\\"\\n\" +\n                \"         },\\n\" +\n                \"         \\\"template\\\":{\\n\" +\n                \"            \\\"controllerTemplate\\\":{\\n\" +\n                \"               \\\"podTemplate\\\":{\\n\" +\n                \"                  \\\"desiredState\\\":{\\n\" +\n                \"                     \\\"manifest\\\":{\\n\" +\n                \"                        \\\"containers\\\":[\\n\" +\n                \"                           {\\n\" +\n                \"                              \\\"image\\\":\\\"\" + buildName + \"\\\",\\n\" +\n                \"                              \\\"name\\\":\\\"\" + buildName + \"\\\",\\n\" +\n                \"                              \\\"ports\\\":[\\n\" +\n                \"                                 {\\n\" +\n                \"                                    \\\"containerPort\\\":8778\\n\" +\n                \"                                 }\\n\" +\n                \"                              ]\\n\" +\n                \"                           }\\n\" +\n                \"                        ],\\n\" +\n                \"                        \\\"version\\\":\\\"\" + imageTag + \"\\\"\\n\" +\n                \"                     }\\n\" +\n                \"                  },\\n\" +\n                \"                  \\\"labels\\\":{\\n\" +\n                \"                     \\\"name\\\":\\\"\" + buildName + \"\\\",\\n\" +\n                \"                     \\\"user\\\":\\\"\" + user + \"\\\"\\n\" +\n                \"                  }\\n\" +\n                \"               },\\n\" +\n                \"               \\\"replicaSelector\\\":{\\n\" +\n                \"                  \\\"name\\\":\\\"\" + buildName + \"\\\",\\n\" +\n                \"                  \\\"user\\\":\\\"\" + user + \"\\\"\\n\" +\n                \"               },\\n\" +\n                \"               \\\"replicas\\\":1\\n\" +\n                \"            },\\n\" +\n                \"            \\\"strategy\\\":{\\n\" +\n                \"               \\\"type\\\":\\\"Recreate\\\"\\n\" +\n                \"            }\\n\" +\n                \"         },\\n\" +\n                \"         \\\"triggers\\\":[\\n\" +\n                \"            {\\n\" +\n                \"               \\\"type\\\":\\\"ImageChange\\\",\\n\" +\n                \"               \\\"imageChangeParams\\\":{\\n\" +\n                \"                  \\\"automatic\\\":true,\\n\" +\n                \"                  \\\"containerNames\\\":[\\n\" +\n                \"                     \\\"\" + buildName + \"\\\"\\n\" +\n                \"                  ],\\n\" +\n                \"                  \\\"from\\\":{\\n\" +\n                \"                     \\\"name\\\":\\\"\" + buildName + \"\\\"\\n\" +\n                \"                  },\\n\" +\n                \"                  \\\"tag\\\":\\\"\" + imageTag + \"\\\"\\n\" +\n                \"               }\\n\" +\n                \"            }\\n\" +\n                \"         ]\\n\" +\n                \"      }\" +\n                \"   ]\\n\" +\n                \"}\";\n\n        if (createOpenShiftBuildResources) {\n            Controller controller = new Controller(kubernetes);\n            controller.applyJson(json);\n\n\n            String type = \"generic\";\n\n            // TODO due to https://github.com/openshift/origin/issues/1317 we can't use the direct kube REST API\n            // so we need to use a workaround using the fabric8 console service's proxy which hides the payload for us\n            String webhookUrl = null;\n            String kubeAddress = null;\n            boolean appendNamespaceQuery = true;\n\n            // lets try the cdelivery first\n            if (kubeAddress == null) {\n                try {\n                    kubeAddress = KubernetesHelper.getServiceURL(kubernetes,ServiceNames.CDELIVERY_API, namespace, \"http\", false);\n                    webhookUrl = URLUtils.pathJoin(kubeAddress, \"buildConfigHooks\", namespace, buildName);\n                    appendNamespaceQuery = false;\n                } catch (Exception e) {\n                    LOG.warn(\"failed to find cdelivery service URL: \" + e, e);\n                }\n            }\n/*\n        if (kubeAddress == null) {\n            try {\n                kubeAddress = kubernetes.getServiceURL(\"fabric8\", namespace, \"http\", false);\n                webhookUrl = URLUtils.pathJoin(kubeAddress, \"oapi\", KubernetesHelper.defaultOsApiVersion, \"buildConfigHooks\", buildName, secret, type);\n            } catch (Exception e) {\n                LOG.warn(\"failed to find fabric8 console service URL: \" + e, e);\n            }\n        }\n*/\n            if (kubeAddress == null) {\n                kubeAddress = kubernetes.getMasterUrl().toString();\n            }\n            String namespacePath = \"\";\n            if (appendNamespaceQuery && !Strings.isNullOrEmpty(namespace)) {\n                namespacePath = \"/namespace=\" + namespace;\n            }\n\n            if (webhookUrl == null) {\n                webhookUrl = URLUtils.pathJoin(kubeAddress, \"oapi\", KubernetesHelper.defaultOsApiVersion + namespacePath, \"buildConfigHooks\", buildName, secret, type);\n            }\n\n            LOG.info(\"creating a web hook at: \" + webhookUrl);\n            try {\n                CreateWebhookDTO createWebhook = new CreateWebhookDTO();\n                createWebhook.setType(\"gogs\");\n                WebhookConfig config = createWebhook.getConfig();\n                config.setUrl(webhookUrl);\n                config.setSecret(secret);\n                WebHookDTO webhook = repoClient.createWebhook(user, buildName, createWebhook);\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Got web hook: \" + toJson(webhook));\n                }\n            } catch (Exception e) {\n                LOG.warn(\"Failed to create web hook in git repo: \" + e, e);\n            }\n        }\n\n\n\n/*        Map<String,String> labels = new LinkedHashMap<>();\n        labels.put(\"name\", buildName);\n        labels.put(\"user\", user);\n\n        Map<String,String> to = new LinkedHashMap<>();\n        to.put(\"name\", buildName);\n\n        ImageStream imageRepository = new ImageStream();\n        imageRepository.setKind(\"ImageStream\");\n        imageRepository.setApiVersion(osapiVersion);\n        imageRepository.setName(buildName);\n        imageRepository.setLabels(labels);\n        handleKubernetesResourceCreation(imageRepository.getKind(), imageRepository, kubernetes.createImageStream(imageRepository));\n\n        BuildConfig buildConfig = new BuildConfig();\n        buildConfig.setKind(\"BuildConfig\");\n        buildConfig.setApiVersion(osapiVersion);\n        buildConfig.setName(buildName);\n        buildConfig.setLabels(labels);\n\n        BuildOutput output = new BuildOutput();\n        // TODO should be to: { labels }\n        //output.setRegistry(buildName);\n        output.getAdditionalProperties().put(\"to\", to);\n        output.setImageTag(imageTag);\n\n        BuildSource source = new BuildSource();\n        source.setType(\"Git\");\n        GitBuildSource git = new GitBuildSource();\n        git.setUri(remote);\n        source.setGit(git);\n\n        BuildStrategy strategy = new BuildStrategy();\n        strategy.setType(\"STI\");\n        STIBuildStrategy stiStrategy = new STIBuildStrategy();\n        stiStrategy.setImage(builderImage);\n        // TODO\n        //stiStrategy.setBuilderImage(builderImage);\n        stiStrategy.getAdditionalProperties().put(\"builderImage\", builderImage);\n        strategy.setStiStrategy(stiStrategy);\n\n        BuildParameters parameters = new BuildParameters();\n        parameters.setOutput(output);\n        parameters.setSource(source);\n        parameters.setStrategy(strategy);\n        buildConfig.setParameters(parameters);\n\n        BuildTriggerPolicy github = new BuildTriggerPolicy();\n        github.setType(\"github\");\n        WebHookTrigger githubTrigger = new WebHookTrigger();\n        githubTrigger.setSecret(secret);\n        github.setGithub(githubTrigger);\n\n        BuildTriggerPolicy generic = new BuildTriggerPolicy();\n        generic.setType(\"generic\");\n        WebHookTrigger genericTrigger = new WebHookTrigger();\n        genericTrigger.setSecret(secret);\n        generic.setGeneric(genericTrigger);\n\n        List<BuildTriggerPolicy> triggers = new ArrayList<>();\n        triggers.add(github);\n        triggers.add(generic);\n        buildConfig.setTriggers(triggers);\n        \n        handleKubernetesResourceCreation(buildConfig.getKind(), buildConfig, kubernetes.createBuildConfig(buildConfig));*/\n    }","commit_id":"3994edc36aa49cf0429c5be9129b3c106cbe64eb","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * We've created a project so lets try trigger a jenkins seed build\n     */\n    protected void triggerJenkinsSeedBuild() {\n        if (!Strings.isNullOrEmpty(jenkinsSeedJob)) {\n            String address = kubernetes.getServiceURL(ServiceNames.JENKINS, kubernetes.getNamespace(), \"http\", false);\n            if (!Strings.isNullOrEmpty(address)) {\n                String jobUrl = URLUtils.pathJoin(address, \"/job/\", jenkinsSeedJob, \"/build\");\n\n                LOG.info(\"Attempting to trigger the jenkins seed build on: \" + jobUrl);\n\n                String json = \"{}\";\n                HttpURLConnection connection = null;\n                try {\n                    URL url = new URL(jobUrl);\n                    connection = (HttpURLConnection) url.openConnection();\n                    connection.setRequestMethod(\"POST\");\n                    connection.setRequestProperty(\"Content-Type\", \"application/json\");\n                    connection.setDoOutput(true);\n\n                    OutputStreamWriter out = new OutputStreamWriter(\n                            connection.getOutputStream());\n                    out.write(json);\n\n                    out.close();\n                    int status = connection.getResponseCode();\n                    String message = connection.getResponseMessage();\n                    LOG.info(\"Got response code from Jenkins: \" + status + \" message: \" + message);\n                    if (status != 200) {\n                        LOG.error(\"Failed to trigger job \" + jenkinsSeedJob + \" on \" + jobUrl + \". Status: \" + status + \" message: \" + message);\n                    }\n                } catch (Exception e) {\n                    LOG.error(\"Failed to trigger jenkins on \" + jobUrl + \". \" + e, e);\n                } finally {\n                    if (connection != null) {\n                        connection.disconnect();\n                    }\n                }\n            }\n        }\n    }","id":75220,"modified_method":"/**\n     * We've created a project so lets try trigger a jenkins seed build\n     */\n    protected void triggerJenkinsSeedBuild() {\n        if (!Strings.isNullOrEmpty(jenkinsSeedJob)) {\n            String address = KubernetesHelper.getServiceURL(kubernetes, ServiceNames.JENKINS, KubernetesHelper.defaultNamespace(), \"http\", false);\n            if (!Strings.isNullOrEmpty(address)) {\n                String jobUrl = URLUtils.pathJoin(address, \"/job/\", jenkinsSeedJob, \"/build\");\n\n                LOG.info(\"Attempting to trigger the jenkins seed build on: \" + jobUrl);\n\n                String json = \"{}\";\n                HttpURLConnection connection = null;\n                try {\n                    URL url = new URL(jobUrl);\n                    connection = (HttpURLConnection) url.openConnection();\n                    connection.setRequestMethod(\"POST\");\n                    connection.setRequestProperty(\"Content-Type\", \"application/json\");\n                    connection.setDoOutput(true);\n\n                    OutputStreamWriter out = new OutputStreamWriter(\n                            connection.getOutputStream());\n                    out.write(json);\n\n                    out.close();\n                    int status = connection.getResponseCode();\n                    String message = connection.getResponseMessage();\n                    LOG.info(\"Got response code from Jenkins: \" + status + \" message: \" + message);\n                    if (status != 200) {\n                        LOG.error(\"Failed to trigger job \" + jenkinsSeedJob + \" on \" + jobUrl + \". Status: \" + status + \" message: \" + message);\n                    }\n                } catch (Exception e) {\n                    LOG.error(\"Failed to trigger jenkins on \" + jobUrl + \". \" + e, e);\n                } finally {\n                    if (connection != null) {\n                        connection.disconnect();\n                    }\n                }\n            }\n        }\n    }","commit_id":"3994edc36aa49cf0429c5be9129b3c106cbe64eb","url":"https://github.com/fabric8io/fabric8"},{"original_method":"protected String getServiceAddress(String serviceName, String namespace) {\n        LOG.info(\"Looking up service \" + serviceName + \" for namespace: \" + namespace);\n        io.fabric8.kubernetes.api.model.Service service = kubernetes.getService(serviceName, namespace);\n\n        String serviceAddress = null;\n        if (service != null) {\n            String portalIP = service.getSpec().getClusterIP();\n            if (!Strings.isNullOrEmpty(portalIP)) {\n                List<ServicePort> servicePorts = service.getSpec().getPorts();\n                if (servicePorts != null && !servicePorts.isEmpty()) {\n                    Integer port = servicePorts.iterator().next().getPort();\n                    String prefix = \"http://\";\n                    String postfix = \"\";\n                    if (port != null) {\n                        if (port == 443) {\n                            prefix = \"https://\";\n                        }\n\n                        if (port != 80) {\n                            postfix = \":\" + port;\n                        }\n                    }\n                    serviceAddress = prefix + portalIP + postfix;\n                }\n            }\n        }\n        return serviceAddress;\n    }","id":75221,"modified_method":"protected String getServiceAddress(String serviceName, String namespace) {\n        LOG.info(\"Looking up service \" + serviceName + \" for namespace: \" + namespace);\n        io.fabric8.kubernetes.api.model.Service service = kubernetes.services().inNamespace(namespace).withName(serviceName).get();\n\n        String serviceAddress = null;\n        if (service != null) {\n            String portalIP = service.getSpec().getClusterIP();\n            if (!Strings.isNullOrEmpty(portalIP)) {\n                List<ServicePort> servicePorts = service.getSpec().getPorts();\n                if (servicePorts != null && !servicePorts.isEmpty()) {\n                    Integer port = servicePorts.iterator().next().getPort();\n                    String prefix = \"http://\";\n                    String postfix = \"\";\n                    if (port != null) {\n                        if (port == 443) {\n                            prefix = \"https://\";\n                        }\n\n                        if (port != 80) {\n                            postfix = \":\" + port;\n                        }\n                    }\n                    serviceAddress = prefix + portalIP + postfix;\n                }\n            }\n        }\n        return serviceAddress;\n    }","commit_id":"3994edc36aa49cf0429c5be9129b3c106cbe64eb","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public Result execute(UIExecutionContext context) throws Exception {\n        String buildConfigName = buildName.getValue();\n        Objects.assertNotNull(buildConfigName, \"buildName\");\n        Map<String, String> labels = BuildConfigs.createBuildLabels(buildConfigName);\n        String ouputImageName = imageName.getValue();\n        String gitUrlText = getOrFindGitUrl(context, gitUri.getValue());\n        String imageText = outputImage.getValue();\n        Model mavenModel = getMavenModel(context);\n        if (Strings.isNullOrBlank(imageText) && mavenModel != null) {\n            imageText = mavenModel.getProperties().getProperty(\"docker.image\");\n        }\n\n        String webhookSecretText = webHookSecret.getValue();\n        if (Strings.isNullOrBlank(webhookSecretText)) {\n            // TODO generate a really good secret!\n            webhookSecretText = \"secret101\";\n        }\n        BuildConfig buildConfig = BuildConfigs.createBuildConfig(buildConfigName, labels, gitUrlText, ouputImageName, imageText, webhookSecretText);\n\n        System.out.println(\"Generated BuildConfig: \" + toJson(buildConfig));\n\n        ImageStream imageRepository = BuildConfigs.imageRepository(buildConfigName, labels);\n\n        Controller controller = createController();\n        controller.applyImageStream(imageRepository, \"generated ImageStream: \" + toJson(imageRepository));\n        controller.applyBuildConfig(buildConfig, \"generated BuildConfig: \" + toJson(buildConfig));\n        return Results.success(\"Added BuildConfig: \" + Builds.getName(buildConfig) + \" to OpenShift at master: \" + getKubernetes().getAddress());\n    }","id":75222,"modified_method":"@Override\n    public Result execute(UIExecutionContext context) throws Exception {\n        String buildConfigName = buildName.getValue();\n        Objects.assertNotNull(buildConfigName, \"buildName\");\n        Map<String, String> labels = BuildConfigs.createBuildLabels(buildConfigName);\n        String ouputImageName = imageName.getValue();\n        String gitUrlText = getOrFindGitUrl(context, gitUri.getValue());\n        String imageText = outputImage.getValue();\n        Model mavenModel = getMavenModel(context);\n        if (Strings.isNullOrBlank(imageText) && mavenModel != null) {\n            imageText = mavenModel.getProperties().getProperty(\"docker.image\");\n        }\n\n        String webhookSecretText = webHookSecret.getValue();\n        if (Strings.isNullOrBlank(webhookSecretText)) {\n            // TODO generate a really good secret!\n            webhookSecretText = \"secret101\";\n        }\n        BuildConfig buildConfig = BuildConfigs.createBuildConfig(buildConfigName, labels, gitUrlText, ouputImageName, imageText, webhookSecretText);\n\n        System.out.println(\"Generated BuildConfig: \" + toJson(buildConfig));\n\n        ImageStream imageRepository = BuildConfigs.imageRepository(buildConfigName, labels);\n\n        Controller controller = createController();\n        controller.applyImageStream(imageRepository, \"generated ImageStream: \" + toJson(imageRepository));\n        controller.applyBuildConfig(buildConfig, \"generated BuildConfig: \" + toJson(buildConfig));\n        return Results.success(\"Added BuildConfig: \" + Builds.getName(buildConfig) + \" to OpenShift at master: \" + getKubernetes().getMasterUrl());\n    }","commit_id":"3994edc36aa49cf0429c5be9129b3c106cbe64eb","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public Result execute(UIExecutionContext context) throws Exception {\n        String buildConfigName = buildName.getValue();\n        Objects.assertNotNull(buildConfigName, \"buildName\");\n        Map<String, String> labels = BuildConfigs.createBuildLabels(buildConfigName);\n        String gitUrlText = getOrFindGitUrl(context, gitUri.getValue());\n        String imageText = image.getValue();\n        List<EnvVar> envVars = createEnvVars(buildConfigName, gitUrlText, mavenCommand.getValue());\n        BuildConfig buildConfig = BuildConfigs.createIntegrationTestBuildConfig(buildConfigName, labels, gitUrlText, imageText, envVars);\n\n        System.out.println(\"Generated BuildConfig: \" + toJson(buildConfig));\n\n        ImageStream imageRepository = BuildConfigs.imageRepository(buildConfigName, labels);\n\n        Controller controller = createController();\n        controller.applyImageStream(imageRepository, \"generated ImageStream: \" + toJson(imageRepository));\n        controller.applyBuildConfig(buildConfig, \"generated BuildConfig: \" + toJson(buildConfig));\n        return Results.success(\"Added BuildConfig: \" + Builds.getName(buildConfig) + \" to OpenShift at master: \" + getKubernetes().getAddress());\n    }","id":75223,"modified_method":"@Override\n    public Result execute(UIExecutionContext context) throws Exception {\n        String buildConfigName = buildName.getValue();\n        Objects.assertNotNull(buildConfigName, \"buildName\");\n        Map<String, String> labels = BuildConfigs.createBuildLabels(buildConfigName);\n        String gitUrlText = getOrFindGitUrl(context, gitUri.getValue());\n        String imageText = image.getValue();\n        List<EnvVar> envVars = createEnvVars(buildConfigName, gitUrlText, mavenCommand.getValue());\n        BuildConfig buildConfig = BuildConfigs.createIntegrationTestBuildConfig(buildConfigName, labels, gitUrlText, imageText, envVars);\n\n        System.out.println(\"Generated BuildConfig: \" + toJson(buildConfig));\n\n        ImageStream imageRepository = BuildConfigs.imageRepository(buildConfigName, labels);\n\n        Controller controller = createController();\n        controller.applyImageStream(imageRepository, \"generated ImageStream: \" + toJson(imageRepository));\n        controller.applyBuildConfig(buildConfig, \"generated BuildConfig: \" + toJson(buildConfig));\n        return Results.success(\"Added BuildConfig: \" + Builds.getName(buildConfig) + \" to OpenShift at master: \" + getKubernetes().getMasterUrl());\n    }","commit_id":"3994edc36aa49cf0429c5be9129b3c106cbe64eb","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    protected void executePod(Pod pod, String podId) throws Exception {\n        System.out.println(\"Deleting pod \" + podId);\n        getKubernetes().deletePod(podId);\n    }","id":75224,"modified_method":"@Override\n    protected void executePod(Pod pod, String podId) throws Exception {\n        System.out.println(\"Deleting pod \" + podId);\n        getKubernetes().pods().inNamespace(getNamespace()).withName(podId).delete();\n    }","commit_id":"3994edc36aa49cf0429c5be9129b3c106cbe64eb","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public Result execute(UIExecutionContext uiExecutionContext) throws Exception {\n        PodList pods = getKubernetes().getPods();\n        KubernetesHelper.removeEmptyPods(pods);\n        TablePrinter table = podsAsTable(pods);\n        return tableResults(table);\n    }","id":75225,"modified_method":"@Override\n    public Result execute(UIExecutionContext uiExecutionContext) throws Exception {\n        PodList pods = getKubernetes().pods().inNamespace(getNamespace()).list();\n        KubernetesHelper.removeEmptyPods(pods);\n        TablePrinter table = podsAsTable(pods);\n        return tableResults(table);\n    }","commit_id":"3994edc36aa49cf0429c5be9129b3c106cbe64eb","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public Result execute(UIExecutionContext context) throws Exception {\n        String idText = replicationControllerId.getValue();\n        ReplicationController replicationController = getKubernetes().getReplicationController(idText);\n        if (replicationController == null) {\n            System.out.println(\"No replicationController for id: \" + idText);\n        } else {\n            executeReplicationController(replicationController);\n        }\n        return null;\n    }","id":75226,"modified_method":"@Override\n    public Result execute(UIExecutionContext context) throws Exception {\n        String idText = replicationControllerId.getValue();\n        ReplicationController replicationController = getKubernetes().replicationControllers().inNamespace(getNamespace()).withName(idText).get();\n        if (replicationController == null) {\n            System.out.println(\"No replicationController for id: \" + idText);\n        } else {\n            executeReplicationController(replicationController);\n        }\n        return null;\n    }","commit_id":"3994edc36aa49cf0429c5be9129b3c106cbe64eb","url":"https://github.com/fabric8io/fabric8"},{"original_method":"protected void executeReplicationController(ReplicationController replicationController) throws Exception {\n        getKubernetes().deleteReplicationController(KubernetesHelper.getName(replicationController));\n    }","id":75227,"modified_method":"protected void executeReplicationController(ReplicationController replicationController) throws Exception {\n        getKubernetes().replicationControllers().inNamespace(getNamespace()).withName(KubernetesHelper.getName(replicationController)).delete();\n    }","commit_id":"3994edc36aa49cf0429c5be9129b3c106cbe64eb","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public void initializeUI(UIBuilder builder) throws Exception {\n        super.initializeUI(builder);\n\n        // populate autocompletion options\n        replicationControllerId.setCompleter(new UICompleter<String>() {\n            @Override\n            public Iterable<String> getCompletionProposals(UIContext context, InputComponent<?, String> input, String value) {\n                List<String> list = new ArrayList<String>();\n                ReplicationControllerList replicationControllers = getKubernetes().getReplicationControllers();\n                if (replicationControllers != null) {\n                    List<ReplicationController> items = replicationControllers.getItems();\n                    if (items != null) {\n                        for (ReplicationController item : items) {\n                            String id = KubernetesHelper.getName(item);\n                            list.add(id);\n                        }\n                    }\n                }\n                Collections.sort(list);\n                return list;\n            }\n        });\n\n        builder.add(replicationControllerId);\n    }","id":75228,"modified_method":"@Override\n    public void initializeUI(UIBuilder builder) throws Exception {\n        super.initializeUI(builder);\n\n        // populate autocompletion options\n        replicationControllerId.setCompleter(new UICompleter<String>() {\n            @Override\n            public Iterable<String> getCompletionProposals(UIContext context, InputComponent<?, String> input, String value) {\n                List<String> list = new ArrayList<String>();\n                ReplicationControllerList replicationControllers = getKubernetes().replicationControllers().inNamespace(getNamespace()).list();\n                if (replicationControllers != null) {\n                    List<ReplicationController> items = replicationControllers.getItems();\n                    if (items != null) {\n                        for (ReplicationController item : items) {\n                            String id = KubernetesHelper.getName(item);\n                            list.add(id);\n                        }\n                    }\n                }\n                Collections.sort(list);\n                return list;\n            }\n        });\n\n        builder.add(replicationControllerId);\n    }","commit_id":"3994edc36aa49cf0429c5be9129b3c106cbe64eb","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public Result execute(UIExecutionContext uiExecutionContext) throws Exception {\n        ReplicationControllerList replicationControllers = getKubernetes().getReplicationControllers();\n        printReplicationControllers(replicationControllers, System.out);\n        return null;\n    }","id":75229,"modified_method":"@Override\n    public Result execute(UIExecutionContext uiExecutionContext) throws Exception {\n        ReplicationControllerList replicationControllers = getKubernetes().replicationControllers().inNamespace(getNamespace()).list();\n        printReplicationControllers(replicationControllers, System.out);\n        return null;\n    }","commit_id":"3994edc36aa49cf0429c5be9129b3c106cbe64eb","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public void initializeUI(UIBuilder builder) throws Exception {\n        super.initializeUI(builder);\n\n        // populate autocompletion options\n        serviceId.setCompleter(new UICompleter<String>() {\n            @Override\n            public Iterable<String> getCompletionProposals(UIContext context, InputComponent<?, String> input, String value) {\n                List<String> list = new ArrayList<String>();\n                ServiceList services = getKubernetes().getServices();\n                if (services != null) {\n                    List<Service> items = services.getItems();\n                    if (items != null) {\n                        for (Service item : items) {\n                            String id = KubernetesHelper.getName(item);\n                            list.add(id);\n                        }\n                    }\n                }\n                Collections.sort(list);\n                return list;\n            }\n        });\n\n        builder.add(serviceId);\n    }","id":75230,"modified_method":"@Override\n    public void initializeUI(UIBuilder builder) throws Exception {\n        super.initializeUI(builder);\n\n        // populate autocompletion options\n        serviceId.setCompleter(new UICompleter<String>() {\n            @Override\n            public Iterable<String> getCompletionProposals(UIContext context, InputComponent<?, String> input, String value) {\n                List<String> list = new ArrayList<String>();\n                ServiceList services = getKubernetes().services().inNamespace(getNamespace()).list();\n                if (services != null) {\n                    List<Service> items = services.getItems();\n                    if (items != null) {\n                        for (Service item : items) {\n                            String id = KubernetesHelper.getName(item);\n                            list.add(id);\n                        }\n                    }\n                }\n                Collections.sort(list);\n                return list;\n            }\n        });\n\n        builder.add(serviceId);\n    }","commit_id":"3994edc36aa49cf0429c5be9129b3c106cbe64eb","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public Result execute(UIExecutionContext context) throws Exception {\n        String idText = serviceId.getValue();\n        Service service = getKubernetes().getService(idText);\n        if (service == null) {\n            System.out.println(\"No service for id: \" + idText);\n        } else {\n            executeService(service);\n        }\n        return null;\n    }","id":75231,"modified_method":"@Override\n    public Result execute(UIExecutionContext context) throws Exception {\n        String idText = serviceId.getValue();\n        Service service = getKubernetes().services().inNamespace(getNamespace()).withName(idText).get();\n        if (service == null) {\n            System.out.println(\"No service for id: \" + idText);\n        } else {\n            executeService(service);\n        }\n        return null;\n    }","commit_id":"3994edc36aa49cf0429c5be9129b3c106cbe64eb","url":"https://github.com/fabric8io/fabric8"},{"original_method":"protected void executeService(Service service) throws Exception {\n        getKubernetes().deleteService(KubernetesHelper.getName(service));\n    }","id":75232,"modified_method":"protected void executeService(Service service) throws Exception {\n        getKubernetes().services().inNamespace(getNamespace()).withName(KubernetesHelper.getName(service)).delete();\n    }","commit_id":"3994edc36aa49cf0429c5be9129b3c106cbe64eb","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public Result execute(UIExecutionContext uiExecutionContext) throws Exception {\n        ServiceList services = getKubernetes().getServices();\n        printServices(services, System.out);\n        return null;\n    }","id":75233,"modified_method":"@Override\n    public Result execute(UIExecutionContext uiExecutionContext) throws Exception {\n        ServiceList services = getKubernetes().services().list();\n        printServices(services, System.out);\n        return null;\n    }","commit_id":"3994edc36aa49cf0429c5be9129b3c106cbe64eb","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testProperties() throws IOException, ParserConfigurationException, SAXException, ConfigurationException\n    {\n        IEndpointSnitch snitch = new PropertyFileSnitch();\n        TokenMetadata metadata = new TokenMetadata();\n        createDummyTokens(metadata);\n\n        Map<String, String> configOptions = new HashMap<String, String>();\n        configOptions.put(\"DC1\", \"3\");\n        configOptions.put(\"DC2\", \"2\");\n        configOptions.put(\"DC3\", \"1\");\n\n        // Set the localhost to the tokenmetadata. Embedded cassandra way?\n        NetworkTopologyStrategy strategy = new NetworkTopologyStrategy(table, metadata, snitch, configOptions);\n        assert strategy.getReplicationFactor(\"DC1\") == 3;\n        assert strategy.getReplicationFactor(\"DC2\") == 2;\n        assert strategy.getReplicationFactor(\"DC3\") == 1;\n        // Query for the natural hosts\n        ArrayList<InetAddress> endpoints = strategy.getNaturalEndpoints(new StringToken(\"123\"));\n        assert 6 == endpoints.size();\n        assert 6 == new HashSet<InetAddress>(endpoints).size(); // ensure uniqueness\n    }","id":75234,"modified_method":"@Test\n    public void testProperties() throws IOException, ParserConfigurationException, SAXException, ConfigurationException\n    {\n        IEndpointSnitch snitch = new PropertyFileSnitch();\n        TokenMetadata metadata = new TokenMetadata();\n        createDummyTokens(metadata, true);\n\n        Map<String, String> configOptions = new HashMap<String, String>();\n        configOptions.put(\"DC1\", \"3\");\n        configOptions.put(\"DC2\", \"2\");\n        configOptions.put(\"DC3\", \"1\");\n\n        // Set the localhost to the tokenmetadata. Embedded cassandra way?\n        NetworkTopologyStrategy strategy = new NetworkTopologyStrategy(table, metadata, snitch, configOptions);\n        assert strategy.getReplicationFactor(\"DC1\") == 3;\n        assert strategy.getReplicationFactor(\"DC2\") == 2;\n        assert strategy.getReplicationFactor(\"DC3\") == 1;\n        // Query for the natural hosts\n        ArrayList<InetAddress> endpoints = strategy.getNaturalEndpoints(new StringToken(\"123\"));\n        assert 6 == endpoints.size();\n        assert 6 == new HashSet<InetAddress>(endpoints).size(); // ensure uniqueness\n    }","commit_id":"402e1edeb7302112e6ea532bf77f1d6a3eb81c78","url":"https://github.com/apache/cassandra"},{"original_method":"public void createDummyTokens(TokenMetadata metadata) throws UnknownHostException\n    {\n        // DC 1\n        tokenFactory(metadata, \"123\", new byte[]{ 10, 0, 0, 10 });\n        tokenFactory(metadata, \"234\", new byte[]{ 10, 0, 0, 11 });\n        tokenFactory(metadata, \"345\", new byte[]{ 10, 0, 0, 12 });\n        // Tokens for DC 2\n        tokenFactory(metadata, \"789\", new byte[]{ 10, 20, 114, 10 });\n        tokenFactory(metadata, \"890\", new byte[]{ 10, 20, 114, 11 });\n        //tokens for DC3\n        tokenFactory(metadata, \"456\", new byte[]{ 10, 21, 119, 13 });\n        tokenFactory(metadata, \"567\", new byte[]{ 10, 21, 119, 10 });\n        // Extra Tokens\n        tokenFactory(metadata, \"90A\", new byte[]{ 10, 0, 0, 13 });\n        tokenFactory(metadata, \"0AB\", new byte[]{ 10, 21, 119, 14 });\n        tokenFactory(metadata, \"ABC\", new byte[]{ 10, 20, 114, 15 });\n    }","id":75235,"modified_method":"public void createDummyTokens(TokenMetadata metadata, boolean populateDC3) throws UnknownHostException\n    {\n        // DC 1\n        tokenFactory(metadata, \"123\", new byte[]{ 10, 0, 0, 10 });\n        tokenFactory(metadata, \"234\", new byte[]{ 10, 0, 0, 11 });\n        tokenFactory(metadata, \"345\", new byte[]{ 10, 0, 0, 12 });\n        // Tokens for DC 2\n        tokenFactory(metadata, \"789\", new byte[]{ 10, 20, 114, 10 });\n        tokenFactory(metadata, \"890\", new byte[]{ 10, 20, 114, 11 });\n        //tokens for DC3\n        if (populateDC3)\n        {\n            tokenFactory(metadata, \"456\", new byte[]{ 10, 21, 119, 13 });\n            tokenFactory(metadata, \"567\", new byte[]{ 10, 21, 119, 10 });\n        }\n        // Extra Tokens\n        tokenFactory(metadata, \"90A\", new byte[]{ 10, 0, 0, 13 });\n        if (populateDC3)\n            tokenFactory(metadata, \"0AB\", new byte[]{ 10, 21, 119, 14 });\n        tokenFactory(metadata, \"ABC\", new byte[]{ 10, 20, 114, 15 });\n    }","commit_id":"402e1edeb7302112e6ea532bf77f1d6a3eb81c78","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * iterator over the Tokens in the given ring, starting with the token for the node owning start\n     * (which does not have to be a Token in the ring)\n     * @param includeMin True if the minimum token should be returned in the ring even if it has no owner.\n     */\n    public static Iterator<Token> ringIterator(final ArrayList<Token> ring, Token start, boolean includeMin)\n    {\n        final boolean insertMin = (includeMin && !ring.get(0).equals(StorageService.getPartitioner().getMinimumToken())) ? true : false;\n        final int startIndex = firstTokenIndex(ring, start, insertMin);\n        return new AbstractIterator<Token>()\n        {\n            int j = startIndex;\n            protected Token computeNext()\n            {\n                if (j < -1)\n                    return endOfData();\n                try\n                {\n                    // return minimum for index == -1\n                    if (j == -1)\n                        return StorageService.getPartitioner().getMinimumToken();\n                    // return ring token for other indexes\n                    return ring.get(j);\n                }\n                finally\n                {\n                    j++;\n                    if (j == ring.size())\n                        j = insertMin ? -1 : 0;\n                    if (j == startIndex)\n                        // end iteration\n                        j = -2;\n                }\n            }\n        };\n    }","id":75236,"modified_method":"/**\n     * iterator over the Tokens in the given ring, starting with the token for the node owning start\n     * (which does not have to be a Token in the ring)\n     * @param includeMin True if the minimum token should be returned in the ring even if it has no owner.\n     */\n    public static Iterator<Token> ringIterator(final ArrayList<Token> ring, Token start, boolean includeMin)\n    {\n        if (ring.isEmpty())\n            return includeMin ? Iterators.singletonIterator(StorageService.getPartitioner().getMinimumToken())\n                              : Iterators.<Token>emptyIterator();\n\n        final boolean insertMin = (includeMin && !ring.get(0).equals(StorageService.getPartitioner().getMinimumToken())) ? true : false;\n        final int startIndex = firstTokenIndex(ring, start, insertMin);\n        return new AbstractIterator<Token>()\n        {\n            int j = startIndex;\n            protected Token computeNext()\n            {\n                if (j < -1)\n                    return endOfData();\n                try\n                {\n                    // return minimum for index == -1\n                    if (j == -1)\n                        return StorageService.getPartitioner().getMinimumToken();\n                    // return ring token for other indexes\n                    return ring.get(j);\n                }\n                finally\n                {\n                    j++;\n                    if (j == ring.size())\n                        j = insertMin ? -1 : 0;\n                    if (j == startIndex)\n                        // end iteration\n                        j = -2;\n                }\n            }\n        };\n    }","commit_id":"402e1edeb7302112e6ea532bf77f1d6a3eb81c78","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see Range#cloneRange()\n     */\n    public native Range cloneRange() /*-{\n        return this.@com.xpn.xwiki.wysiwyg.client.selection.internal.AbstractRange::getJSRange()().cloneRange();\n    }-*/;","id":75237,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see Range#cloneRange()\n     */\n    public Range cloneRange()\n    {\n        return new DefaultRange(cloneJSRange());\n    }","commit_id":"c6508a35912b54e2f9ec1c3a9c9d1d1bbb258c7c","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see Executable#isExecuted(Element)\n     */\n    public boolean isExecuted(Element target)\n    {\n        Selection selection = SelectionManager.INSTANCE.getSelection(IFrameElement.as(target));\n        if (selection.getRangeCount() > 0) {\n            for (int i = 0; i < selection.getRangeCount(); i++) {\n                if (!isExecuted(selection.getRangeAt(i))) {\n                    return false;\n                }\n            }\n            return true;\n        } else {\n            // This should be removed after we implement the Selection and Range for IE.\n            return super.isExecuted(target);\n        }\n    }","id":75238,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see Executable#isExecuted(Element)\n     */\n    public boolean isExecuted(Element target)\n    {\n        Selection selection = SelectionManager.INSTANCE.getSelection(IFrameElement.as(target));\n        if (selection.getRangeCount() > 0) {\n            for (int i = 0; i < selection.getRangeCount(); i++) {\n                if (!isExecuted(DOMUtils.getInstance().getTextRange(selection.getRangeAt(i)))) {\n                    return false;\n                }\n            }\n            return true;\n        } else {\n            // This should be removed after we implement the Selection and Range for IE.\n            return super.isExecuted(target);\n        }\n    }","commit_id":"c6508a35912b54e2f9ec1c3a9c9d1d1bbb258c7c","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see Executable#execute(Element, String)\n     */\n    public boolean execute(Element target, String parameter)\n    {\n        boolean executed = isExecuted(target);\n        IFrameElement iframe = IFrameElement.as(target);\n        Selection selection = SelectionManager.INSTANCE.getSelection(iframe);\n        if (selection.getRangeCount() > 0) {\n            List<Range> ranges = new ArrayList<Range>();\n            for (int i = 0; i < selection.getRangeCount(); i++) {\n                if (executed) {\n                    ranges.add(removeStyle(iframe, selection.getRangeAt(i)));\n                } else {\n                    ranges.add(addStyle(iframe, selection.getRangeAt(i)));\n                }\n            }\n            selection.removeAllRanges();\n            for (Range range : ranges) {\n                selection.addRange(range);\n            }\n            return true;\n        } else {\n            // This should be removed after we implement the Selection and Range for IE.\n            return super.execute(target, parameter);\n        }\n    }","id":75239,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see Executable#execute(Element, String)\n     */\n    public boolean execute(Element target, String parameter)\n    {\n        boolean executed = isExecuted(target);\n        IFrameElement iframe = IFrameElement.as(target);\n        Selection selection = SelectionManager.INSTANCE.getSelection(iframe);\n        if (selection.getRangeCount() > 0) {\n            List<Range> ranges = new ArrayList<Range>();\n            for (int i = 0; i < selection.getRangeCount(); i++) {\n                if (executed) {\n                    ranges.add(removeStyle(iframe, DOMUtils.getInstance().getTextRange(selection.getRangeAt(i))));\n                } else {\n                    ranges.add(addStyle(iframe, DOMUtils.getInstance().getTextRange(selection.getRangeAt(i))));\n                }\n            }\n            selection.removeAllRanges();\n            for (Range range : ranges) {\n                selection.addRange(range);\n            }\n            return true;\n        } else {\n            // This should be removed after we implement the Selection and Range for IE.\n            return super.execute(target, parameter);\n        }\n    }","commit_id":"c6508a35912b54e2f9ec1c3a9c9d1d1bbb258c7c","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private boolean isEnabled(Range range)\n    {\n        return range.isCollapsed()\n            || (range.getStartContainer().getNodeType() == Node.TEXT_NODE && range.getEndContainer().getNodeType() == Node.TEXT_NODE);\n    }","id":75240,"modified_method":"private boolean isEnabled(Range range)\n    {\n        // Right now this executable is not restricted. We'll add here future restrictions.\n        return true;\n    }","commit_id":"c6508a35912b54e2f9ec1c3a9c9d1d1bbb258c7c","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private int addParams(StringBuilder replacementText,\n                        boolean addWS, Collection<DocstringParam> paramsToAdd) {\n\n    PsiWhiteSpace whitespace = null;\n    if (myDocStringOwner instanceof PyFunction) {\n      whitespace = PsiTreeUtil.getPrevSiblingOfType(((PyFunction)myDocStringOwner).getStatementList(), PsiWhiteSpace.class);\n    }\n    String ws = \"\\n\";\n    if (whitespace != null) {\n      String[] spaces = whitespace.getText().split(\"\\n\");\n      if (spaces.length > 1) {\n        ws += whitespace.getText().split(\"\\n\")[1];\n      }\n    }\n    if (replacementText.length() > 0) {\n      replacementText.deleteCharAt(replacementText.length() - 1);\n    }\n    replacementText.append(ws);\n\n    int i = 0;\n\n    if (paramsToAdd.size() == 0) {\n      throw new IllegalArgumentException(\"At least one parameter should be added\");\n    }\n\n    for (DocstringParam param : paramsToAdd) {\n      replacementText.append(getPrefix());\n      replacementText.append(param.getKind());\n      replacementText.append(\" \");\n      replacementText.append(param.getName());\n      replacementText.append(\": \");\n      int startOffset = replacementText.length();\n      int endOffset = startOffset;\n      if (param.getType() != null) {\n        replacementText.append(param.getType());\n        endOffset += param.getType().length();\n      }\n      myParamTypesOffset.put(param.getName(), Pair.create(startOffset, endOffset));\n      i++;\n      if (i < paramsToAdd.size()) {\n        replacementText.append(ws);\n      }\n    }\n\n    int offset = replacementText.length();\n    if (addWS) {\n      replacementText.append(ws);\n    }\n    else {\n      replacementText.append(\"\\n\");\n    }\n    return offset;\n  }","id":75241,"modified_method":"private int addParams(StringBuilder replacementText,\n                        boolean addWS, Collection<DocstringParam> paramsToAdd) {\n\n    PsiWhiteSpace whitespace = null;\n    if (myDocStringOwner instanceof PyFunction) {\n      final PyStatementList statementList = ((PyFunction)myDocStringOwner).getStatementList();\n      final Document document = PsiDocumentManager.getInstance(myProject).getDocument(getFile());\n      if (document != null && statementList != null && statementList.getStatements().length != 0\n          && document.getLineNumber(statementList.getTextOffset()) != document.getLineNumber(myFunction.getTextOffset())) {\n        whitespace = PsiTreeUtil.getPrevSiblingOfType(statementList, PsiWhiteSpace.class);\n      }\n    }\n    String ws = \"\\n\";\n    if (whitespace != null) {\n      String[] spaces = whitespace.getText().split(\"\\n\");\n      if (spaces.length > 1) {\n        ws += whitespace.getText().split(\"\\n\")[1];\n      }\n    }\n    else {\n      ws += StringUtil.repeat(\" \", getIndentSize(myFunction));\n    }\n    if (replacementText.length() > 0) {\n      replacementText.deleteCharAt(replacementText.length() - 1);\n    }\n    replacementText.append(ws);\n\n    int i = 0;\n\n    if (paramsToAdd.size() == 0) {\n      throw new IllegalArgumentException(\"At least one parameter should be added\");\n    }\n\n    for (DocstringParam param : paramsToAdd) {\n      replacementText.append(getPrefix());\n      replacementText.append(param.getKind());\n      replacementText.append(\" \");\n      replacementText.append(param.getName());\n      replacementText.append(\": \");\n      int startOffset = replacementText.length();\n      int endOffset = startOffset;\n      if (param.getType() != null) {\n        replacementText.append(param.getType());\n        endOffset += param.getType().length();\n      }\n      myParamTypesOffset.put(param.getName(), Pair.create(startOffset, endOffset));\n      i++;\n      if (i < paramsToAdd.size()) {\n        replacementText.append(ws);\n      }\n    }\n\n    int offset = replacementText.length();\n    if (addWS) {\n      replacementText.append(ws);\n    }\n    else {\n      replacementText.append(\"\\n\");\n    }\n    return offset;\n  }","commit_id":"5b4bc0e77196d435ff053cdfca5ab9e82732ce56","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void build() {\n    myDocStringExpression = myFunction.getDocStringExpression();\n    final Pair<String, Integer> replacementToOffset =\n      addParamToDocstring();\n\n    PyElementGenerator elementGenerator = PyElementGenerator.getInstance(myProject);\n    if (myDocStringExpression != null) {\n      PyExpression str = elementGenerator.createDocstring(replacementToOffset.getFirst()).getExpression();\n      myDocStringExpression.replace(str);\n      myFunction = CodeInsightUtilBase.forcePsiPostprocessAndRestoreElement(myFunction);\n      myDocStringExpression = myFunction.getDocStringExpression();\n    }\n    else {\n      final PyStatementList list = myFunction.getStatementList();\n      final Document document = PsiDocumentManager.getInstance(myProject).getDocument(getFile());\n\n      if (list != null && list.getStatements().length != 0) {\n        if (document.getLineNumber(list.getTextOffset()) == document.getLineNumber(myFunction.getTextOffset())) {\n          PyFunction func = elementGenerator.createFromText(LanguageLevel.forElement(myFunction),\n                                                            PyFunction.class,\n                                                            \"def \" + myFunction.getName() + myFunction.getParameterList().getText()\n                                                            + \":\\n\\t\" + replacementToOffset.getFirst() + \"\\n\\t\" + list.getText());\n\n          myFunction = (PyFunction)myFunction.replace(func);\n        }\n        else {\n          PyExpressionStatement str = elementGenerator.createDocstring(replacementToOffset.getFirst());\n          list.addBefore(str, list.getStatements()[0]);\n        }\n      }\n\n      myFunction = CodeInsightUtilBase.forcePsiPostprocessAndRestoreElement(myFunction);\n      myDocStringExpression = myFunction.getDocStringExpression();\n    }\n  }","id":75242,"modified_method":"public void build() {\n    myDocStringExpression = myFunction.getDocStringExpression();\n    final Pair<String, Integer> replacementToOffset =\n      addParamToDocstring();\n\n    PyElementGenerator elementGenerator = PyElementGenerator.getInstance(myProject);\n    if (myDocStringExpression != null) {\n      PyExpression str = elementGenerator.createDocstring(replacementToOffset.getFirst()).getExpression();\n      myDocStringExpression.replace(str);\n      myFunction = CodeInsightUtilBase.forcePsiPostprocessAndRestoreElement(myFunction);\n      myDocStringExpression = myFunction.getDocStringExpression();\n    }\n    else {\n      final PyStatementList list = myFunction.getStatementList();\n      final Document document = PsiDocumentManager.getInstance(myProject).getDocument(getFile());\n\n      if (document != null && list != null) {\n        if (document.getLineNumber(list.getTextOffset()) == document.getLineNumber(myFunction.getTextOffset()) ||\n          list.getStatements().length == 0) {\n          PyFunction func = elementGenerator.createFromText(LanguageLevel.forElement(myFunction),\n                                                        PyFunction.class,\n                                                        \"def \" + myFunction.getName() + myFunction.getParameterList().getText()\n                                                        + \":\\n\" + StringUtil.repeat(\" \",  getIndentSize(myFunction))\n                                                        + replacementToOffset.getFirst() + \"\\n\" +\n                                                        StringUtil.repeat(\" \", getIndentSize(myFunction)) + list.getText());\n\n          myFunction = (PyFunction)myFunction.replace(func);\n        }\n        else {\n          PyExpressionStatement str = elementGenerator.createDocstring(replacementToOffset.getFirst());\n          list.addBefore(str, list.getStatements()[0]);\n        }\n      }\n\n      myFunction = CodeInsightUtilBase.forcePsiPostprocessAndRestoreElement(myFunction);\n      myDocStringExpression = myFunction.getDocStringExpression();\n    }\n  }","commit_id":"5b4bc0e77196d435ff053cdfca5ab9e82732ce56","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testTypeInDocstring() {\n    doTest(PyBundle.message(\"INTN.specify.type\"));\n  }","id":75243,"modified_method":"public void testTypeInDocstring() {\n    doDocReferenceTest();\n  }","commit_id":"5b4bc0e77196d435ff053cdfca5ab9e82732ce56","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testTypeInDocstring3() {\n    doTest(PyBundle.message(\"INTN.specify.type\"));\n  }","id":75244,"modified_method":"public void testTypeInDocstring3() {\n    doDocReferenceTest();\n  }","commit_id":"5b4bc0e77196d435ff053cdfca5ab9e82732ce56","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void collectInstanceAttributes(PyFunction method, final Map<String, PyTargetExpression> result) {\n    final PyParameter[] params = method.getParameterList().getParameters();\n    if (params.length == 0) {\n      return;\n    }\n    final String selfName = params [0].getName();\n\n    final PyFunctionStub methodStub = method.getStub();\n    if (methodStub != null) {\n      final PyTargetExpression[] targets = methodStub.getChildrenByType(PyElementTypes.TARGET_EXPRESSION, PyTargetExpression.EMPTY_ARRAY);\n      for (PyTargetExpression target : targets) {\n        if (!result.containsKey(target.getName())) {\n          result.put(target.getName(), target);\n        }\n      }\n    }\n    else {\n      // NOTE: maybe treeCrawlUp would be more precise, but currently it works well enough; don't care.\n      method.getStatementList().accept(new PyRecursiveElementVisitor() {\n        public void visitPyAssignmentStatement(final PyAssignmentStatement node) {\n          super.visitPyAssignmentStatement(node);\n          final PyExpression[] targets = node.getTargets();\n          for (PyExpression target : targets) {\n            if (PyUtil.isInstanceAttribute(target) && !result.containsKey(target.getName())) {\n              result.put(target.getName(), (PyTargetExpression) target);\n            }\n          }\n        }\n      });\n    }\n  }","id":75245,"modified_method":"private static void collectInstanceAttributes(PyFunction method, final Map<String, PyTargetExpression> result) {\n    final PyParameter[] params = method.getParameterList().getParameters();\n    if (params.length == 0) {\n      return;\n    }\n    final String selfName = params [0].getName();\n\n    final PyFunctionStub methodStub = method.getStub();\n    if (methodStub != null) {\n      final PyTargetExpression[] targets = methodStub.getChildrenByType(PyElementTypes.TARGET_EXPRESSION, PyTargetExpression.EMPTY_ARRAY);\n      for (PyTargetExpression target : targets) {\n        if (!result.containsKey(target.getName())) {\n          result.put(target.getName(), target);\n        }\n      }\n    }\n    else {\n      // NOTE: maybe treeCrawlUp would be more precise, but currently it works well enough; don't care.\n      final PyStatementList statementList = method.getStatementList();\n      if (statementList != null) {\n        statementList.accept(new PyRecursiveElementVisitor() {\n          public void visitPyAssignmentStatement(final PyAssignmentStatement node) {\n            super.visitPyAssignmentStatement(node);\n            final PyExpression[] targets = node.getTargets();\n            for (PyExpression target : targets) {\n              if (PyUtil.isInstanceAttribute(target) && !result.containsKey(target.getName())) {\n                result.put(target.getName(), (PyTargetExpression) target);\n              }\n            }\n          }\n        });\n      }\n    }\n  }","commit_id":"8800c99ab5a9b63afe34919d4e9f81966664db1d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitPyExceptBlock(final PyExceptPart node){\n      PyExpression exceptClass = node.getExceptClass();\n      if (reRaised(node))\n        return;\n      if (exceptClass == null) {\n        registerProblem(node.getFirstChild(), \"Too broad exception clause\");\n      }\n      else if (\"Exception\".equals(exceptClass.getName())) {\n        PyExpression target = node.getTarget();\n        if (target != null && isExceptionUsed(node, target.getText()))\n          return;\n        if (exceptClass instanceof PyReferenceExpression) {\n          PyReferenceExpression exceptClassRef = (PyReferenceExpression)exceptClass;\n          PyType classRefType = myTypeEvalContext.getType(exceptClassRef);\n          if (classRefType != null) {\n            if (classRefType.isBuiltin(myTypeEvalContext))\n              registerProblem(exceptClassRef, \"Too broad exception clause\");\n          }\n        }\n      }\n    }","id":75246,"modified_method":"@Override\n    public void visitPyExceptBlock(final PyExceptPart node){\n      PyExpression exceptClass = node.getExceptClass();\n      if (reRaised(node))\n        return;\n      if (exceptClass == null) {\n        registerProblem(node.getFirstChild(), \"Too broad exception clause\");\n      }\n      if (exceptClass != null) {\n        final PyType type = exceptClass.getType(myTypeEvalContext);\n        if (type instanceof PyClassType) {\n          final PyClass cls = ((PyClassType)type).getPyClass();\n          final PyExpression target = node.getTarget();\n          if (cls != null && equalsException(cls, myTypeEvalContext) &&\n              (target == null || !isExceptionUsed(node, target.getText()))) {\n            registerProblem(exceptClass, \"Too broad exception clause\");\n          }\n        }\n      }\n    }","commit_id":"cb7dd4d11f5338da99138b3227687b72afcabb20","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * detects reraising of exception\n     * @param node\n     * @return\n     */\n    private static boolean reRaised(PyExceptPart node) {\n      for (PyStatement st : node.getStatementList().getStatements()) {\n        if (st instanceof PyRaiseStatement)\n          return true;\n      }\n      return false;\n    }","id":75247,"modified_method":"private static boolean reRaised(PyExceptPart node) {\n      final PyStatementList statementList = node.getStatementList();\n      if (statementList != null) {\n        for (PyStatement st : statementList.getStatements()) {\n          if (st instanceof PyRaiseStatement)\n            return true;\n        }\n      }\n      return false;\n    }","commit_id":"cb7dd4d11f5338da99138b3227687b72afcabb20","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public PyType getReturnType() {\n    final PyType docStringType = getReturnTypeFromDocString();\n    if (docStringType != null) {\n      return docStringType;\n    }\n    ReturnVisitor visitor = new ReturnVisitor();\n    getStatementList().accept(visitor);\n    if (isGeneratedStub() && !visitor.myHasReturns) {\n      return null;\n    }\n    return visitor.result();\n  }","id":75248,"modified_method":"@Nullable\n  public PyType getReturnType() {\n    final PyType docStringType = getReturnTypeFromDocString();\n    if (docStringType != null) {\n      return docStringType;\n    }\n    ReturnVisitor visitor = new ReturnVisitor();\n    final PyStatementList statements = getStatementList();\n    if (statements != null) {\n      statements.accept(visitor);\n      if (isGeneratedStub() && !visitor.myHasReturns) {\n        return null;\n      }\n    }\n    return visitor.result();\n  }","commit_id":"cf2ed2084105cf4e8825b4c5fe88d05e783fab5f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testJoinIf() {\n    doTest(PyBundle.message(\"INTN.join.if\"));\n  }","id":75249,"modified_method":"public void testJoinIf() {\n    doTest(PyBundle.message(\"INTN.join.if.text\"));\n  }","commit_id":"078d4b5bb0d75ec2500ea395e8cd9945cec1db0e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public String getText() {\n    return PyBundle.message(\"INTN.join.if\");\n  }","id":75250,"modified_method":"@NotNull\n  public String getText() {\n    return PyBundle.message(\"INTN.join.if.text\");\n  }","commit_id":"078d4b5bb0d75ec2500ea395e8cd9945cec1db0e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {\n    PyIfStatement expression =\n      PsiTreeUtil.getParentOfType(file.findElementAt(editor.getCaretModel().getOffset()), PyIfStatement.class);\n    while (expression != null) {\n      PyStatement firstStatement = expression.getIfPart().getStatementList().getStatements()[0];\n      if (firstStatement instanceof PyIfStatement) {\n        return true;\n      }\n      expression = PsiTreeUtil.getParentOfType(file.findElementAt(editor.getCaretModel().getOffset()), PyIfStatement.class);\n    }\n    return false;\n  }","id":75251,"modified_method":"public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {\n    PyIfStatement expression =\n      PsiTreeUtil.getParentOfType(file.findElementAt(editor.getCaretModel().getOffset()), PyIfStatement.class);\n    while (expression != null) {\n      PyStatementList stList = expression.getIfPart().getStatementList();\n      if (stList != null) {\n        if (stList.getStatements().length != 0) {\n          PyStatement firstStatement = stList.getStatements()[0];\n          if (firstStatement instanceof PyIfStatement) {\n            return true;\n          }\n        }\n      }\n      expression = PsiTreeUtil.getParentOfType(expression, PyIfStatement.class);\n    }\n    expression = PsiTreeUtil.getParentOfType(file.findElementAt(editor.getCaretModel().getOffset()), PyIfStatement.class);\n    while (expression != null) {\n      PyStatementList stList = expression.getIfPart().getStatementList();\n      if (stList != null) {\n        if (stList.getStatements().length != 0) {\n          PyStatement firstStatement = stList.getStatements()[0];\n          if (firstStatement instanceof PyIfStatement) {\n            return true;\n          }\n        }\n      }\n      expression = PsiTreeUtil.getChildOfType(expression, PyIfStatement.class);\n    }\n    return false;\n  }","commit_id":"078d4b5bb0d75ec2500ea395e8cd9945cec1db0e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    PyIfStatement expression =\n      PsiTreeUtil.getParentOfType(file.findElementAt(editor.getCaretModel().getOffset()), PyIfStatement.class);\n    PyStatement firstStatement = null;\n\n    while (expression != null) {\n      firstStatement = expression.getIfPart().getStatementList().getStatements()[0];\n      if (firstStatement instanceof PyIfStatement) {\n        break;\n      }\n      expression = PsiTreeUtil.getParentOfType(file.findElementAt(editor.getCaretModel().getOffset()), PyIfStatement.class);\n    }\n    if (firstStatement != null && firstStatement instanceof PyIfStatement) {\n      PyExpression condition = ((PyIfStatement)firstStatement).getIfPart().getCondition();\n      PyElementGenerator elementGenerator = PyElementGenerator.getInstance(project);\n      PyExpression newCondition = elementGenerator.createExpressionFromText(expression.getIfPart().getCondition().getText() + \" and \" + condition.getText());\n      expression.getIfPart().getCondition().replace(newCondition);\n\n      PyStatementList stList = ((PyIfStatement)firstStatement).getIfPart().getStatementList();\n      expression.getIfPart().getStatementList().replace(stList);\n    }\n  }","id":75252,"modified_method":"public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    PyIfStatement expression =\n      PsiTreeUtil.getParentOfType(file.findElementAt(editor.getCaretModel().getOffset()), PyIfStatement.class);\n    PyStatement firstStatement = null;\n\n    while (expression != null) {\n      firstStatement = expression.getIfPart().getStatementList().getStatements()[0];\n      if (firstStatement instanceof PyIfStatement) {\n        break;\n      }\n      expression = PsiTreeUtil.getParentOfType(expression, PyIfStatement.class);\n    }\n    if (firstStatement != null && firstStatement instanceof PyIfStatement) {\n      PyExpression condition = ((PyIfStatement)firstStatement).getIfPart().getCondition();\n      PyElementGenerator elementGenerator = PyElementGenerator.getInstance(project);\n      PyExpression newCondition = elementGenerator.createExpressionFromText(expression.getIfPart().getCondition().getText() + \" and \" + condition.getText());\n      expression.getIfPart().getCondition().replace(newCondition);\n\n      PyStatementList stList = ((PyIfStatement)firstStatement).getIfPart().getStatementList();\n      expression.getIfPart().getStatementList().replace(stList);\n    }\n  }","commit_id":"078d4b5bb0d75ec2500ea395e8cd9945cec1db0e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void applyFix(@NotNull final Project project, @NotNull final ProblemDescriptor descriptor) {\n    PyFunction problemFunction = PsiTreeUtil.getParentOfType(descriptor.getPsiElement(), PyFunction.class);\n    if (problemFunction == null) return;\n    PyFunction superInit = mySuper.findMethodByName(PyNames.INIT, false);\n    if (superInit == null) return;\n    StringBuilder superCall = new StringBuilder();\n    PyClass klass = problemFunction.getContainingClass();\n    boolean addComma = true;\n    if (klass != null && klass.isNewStyleClass()) {\n      addComma = false;\n      if (LanguageLevel.forElement(klass).isPy3K())\n        superCall.append(\"super().__init__(\");\n      else\n        superCall.append(\"super(\"+klass.getName()+\", self).__init__(\");\n    }\n    else {\n      superCall.append(mySuperName);\n      superCall.append(\".__init__(self\");\n    }\n    StringBuilder newFunction = new StringBuilder(\"def __init__(self\");\n\n    PyParameter[] parameters = problemFunction.getParameterList().getParameters();\n    List<String> problemParams = new ArrayList<String>();\n    List<String> functionParams = new ArrayList<String>();\n    String starName = null;\n    String doubleStarName = null;\n    for (int i = 1; i != parameters.length; i++) {\n      PyParameter p = parameters[i];\n      functionParams.add(p.getName());\n      if (p.getText().startsWith(\"**\")) {\n        doubleStarName = p.getText();\n        continue;\n      }\n      if (p.getText().startsWith(\"*\")) {\n        starName = p.getText();\n        continue;\n      }\n      if (p.getDefaultValue() != null) {\n        problemParams.add(p.getText());\n        continue;\n      }\n      newFunction.append(\",\").append(p.getText());\n    }\n\n    PyParameterList paramList = superInit.getParameterList();\n    if (paramList == null) return;\n    parameters = paramList.getParameters();\n    boolean addDouble = false;\n    boolean addStar = false;\n    for (int i = 1; i != parameters.length; i++) {\n      PyParameter p = parameters[i];\n      if (p.getDefaultValue() != null) continue;\n      String param;\n      param = p.getText();\n      if (param.startsWith(\"**\")) {\n        addDouble = true;\n        if (doubleStarName == null)\n          doubleStarName = p.getText();\n        continue;\n      }\n      if (param.startsWith(\"*\")) {\n        addStar = true;\n        if (starName == null)\n          starName = p.getText();\n        continue;\n      }\n      if (addComma)\n        superCall.append(\",\");\n      superCall.append(param);\n      if (!functionParams.contains(param))\n        newFunction.append(\",\").append(param);\n      addComma = true;\n    }\n    for(String p : problemParams)\n      newFunction.append(\",\").append(p);\n    if (addStar) {\n      newFunction.append(\",\").append(starName);\n      if (addComma) superCall.append(\",\");\n      superCall.append(starName);\n      addComma = true;\n    }\n    if (addDouble) {\n      if (addComma) superCall.append(\",\");\n      superCall.append(doubleStarName);\n      newFunction.append(\",\").append(doubleStarName);\n    }\n\n    superCall.append(\")\");\n    newFunction.append(\"):\\n\\t\").append(superCall).append(\"\\n\\t\").append(problemFunction.getStatementList().getText());\n\n    problemFunction.replace(\n      PyElementGenerator.getInstance(project).createFromText(LanguageLevel.forElement(problemFunction), PyFunction.class,\n                                                             newFunction.toString()));\n  }","id":75253,"modified_method":"public void applyFix(@NotNull final Project project, @NotNull final ProblemDescriptor descriptor) {\n    PyFunction problemFunction = PsiTreeUtil.getParentOfType(descriptor.getPsiElement(), PyFunction.class);\n    if (problemFunction == null) return;\n    PyFunction superInit = mySuper.findMethodByName(PyNames.INIT, false);\n    if (superInit == null) return;\n    StringBuilder superCall = new StringBuilder();\n    PyClass klass = problemFunction.getContainingClass();\n    boolean addComma = true;\n    if (klass != null && klass.isNewStyleClass()) {\n      addComma = false;\n      if (LanguageLevel.forElement(klass).isPy3K())\n        superCall.append(\"super().__init__(\");\n      else\n        superCall.append(\"super(\"+klass.getName()+\", self).__init__(\");\n    }\n    else {\n      superCall.append(mySuperName);\n      superCall.append(\".__init__(self\");\n    }\n    StringBuilder newFunction = new StringBuilder(\"def __init__(self\");\n\n    PyParameter[] parameters = problemFunction.getParameterList().getParameters();\n    List<String> problemParams = new ArrayList<String>();\n    List<String> functionParams = new ArrayList<String>();\n    String starName = null;\n    String doubleStarName = null;\n    for (int i = 1; i != parameters.length; i++) {\n      PyParameter p = parameters[i];\n      functionParams.add(p.getName());\n      if (p.getText().startsWith(\"**\")) {\n        doubleStarName = p.getText();\n        continue;\n      }\n      if (p.getText().startsWith(\"*\")) {\n        starName = p.getText();\n        continue;\n      }\n      if (p.getDefaultValue() != null) {\n        problemParams.add(p.getText());\n        continue;\n      }\n      newFunction.append(\",\").append(p.getText());\n    }\n\n    PyParameterList paramList = superInit.getParameterList();\n    if (paramList == null) return;\n    parameters = paramList.getParameters();\n    boolean addDouble = false;\n    boolean addStar = false;\n    for (int i = 1; i != parameters.length; i++) {\n      PyParameter p = parameters[i];\n      if (p.getDefaultValue() != null) continue;\n      String param;\n      param = p.getText();\n      if (param.startsWith(\"**\")) {\n        addDouble = true;\n        if (doubleStarName == null)\n          doubleStarName = p.getText();\n        continue;\n      }\n      if (param.startsWith(\"*\")) {\n        addStar = true;\n        if (starName == null)\n          starName = p.getText();\n        continue;\n      }\n      if (addComma)\n        superCall.append(\",\");\n      superCall.append(param);\n      if (!functionParams.contains(param))\n        newFunction.append(\",\").append(param);\n      addComma = true;\n    }\n    for(String p : problemParams)\n      newFunction.append(\",\").append(p);\n    if (addStar) {\n      newFunction.append(\",\").append(starName);\n      if (addComma) superCall.append(\",\");\n      superCall.append(starName);\n      addComma = true;\n    }\n    if (addDouble) {\n      if (addComma) superCall.append(\",\");\n      superCall.append(doubleStarName);\n      newFunction.append(\",\").append(doubleStarName);\n    }\n\n    superCall.append(\")\");\n    final PyStatementList statementList = problemFunction.getStatementList();\n    PyExpression docstring = null;\n    final PyStatement[] statements = statementList.getStatements();\n    if (statements.length != 0 && statements[0] instanceof PyExpressionStatement) {\n      PyExpressionStatement st = (PyExpressionStatement)statements[0];\n      if (st.getExpression() instanceof PyStringLiteralExpression)\n        docstring = st.getExpression();\n    }\n\n    newFunction.append(\"):\\n\\t\");\n    if (docstring != null)\n      newFunction.append(docstring.getText()).append(\"\\n\\t\");\n    newFunction.append(superCall).append(\"\\n\\t\");\n    boolean first = true;\n    for (PyStatement statement : statements) {\n      if (first && docstring != null) {\n        first = false;\n        continue;\n      }\n      newFunction.append(statement.getText()).append(\"\\n\\t\");\n    }\n\n    problemFunction.replace(\n      PyElementGenerator.getInstance(project).createFromText(LanguageLevel.forElement(problemFunction), PyFunction.class,\n                                                             newFunction.toString()));\n  }","commit_id":"55daee04cb7b41a33ba126a7da9ee4bc1651f1b3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void showErrorMessage(ITemplateGenerator generator) {\n    generator.showErrorMessage(getOutputSourceNode(), \"couldn't resolve reference '\" + getReferenceRole() + \"' in output node \" + getOutputSourceNode().getDebugText());\n    generator.showErrorMessage(myReferenceMacro.getParent().getNode(), \"-- original reference was \" + myReferenceMacro.getParent().getNode().getDebugText());\n    generator.showErrorMessage(getInputNode(), \"-- input node was \" + getInputNode().getDebugText());\n  }","id":75254,"modified_method":"public void showErrorMessage(ITemplateGenerator generator) {\n    generator.showErrorMessage(getOutputSourceNode(), \"couldn't resolve reference '\" + getReferenceRole() + \"' in output node \" + getOutputSourceNode().getDebugText());\n    generator.showErrorMessage(myReferenceMacro.getParent().getNode(), \"-- original reference was \" + myReferenceMacro.getParent().getNode().getDebugText());\n    SNode inputNode = getInputNode();\n    generator.showErrorMessage(inputNode, \"-- input node was \" + (inputNode != null ? inputNode.getDebugText(): \"NULL\"));\n  }","commit_id":"1470553d3b2bce48a3a6c68f3dd8395b92bb4155","url":"https://github.com/JetBrains/MPS"},{"original_method":"private final void reportErrorWithOrigin(String message) {\n    if (myOrigin != null) {\n      List<ProblemDescription> result = new ArrayList<ProblemDescription>(2);\n      if (myOrigin.getInputNode() != null) {\n        result.add(new ProblemDescription(myOrigin.getInputNode(), \" -- was input: \" + myOrigin.getInputNode().getDebugText()));\n      }\n      if (myOrigin.getTemplate() != null) {\n        result.add(new ProblemDescription(myOrigin.getTemplate(), \" -- was template: \" + myOrigin.getTemplate().getDebugText()));\n      }\n      if (result.size() > 0) {\n        error(message, result.toArray(new ProblemDescription[result.size()]));\n        return;\n      }\n    }\n    error(message);\n  }","id":75255,"modified_method":"private void reportErrorWithOrigin(String message) {\n    if (myOrigin != null) {\n      List<ProblemDescription> result = new ArrayList<ProblemDescription>(2);\n      SNodePointer inputNode = myOrigin.getInputNode();\n      if (inputNode != null) {\n        SNode node = inputNode.getNode();\n        String dt = node == null ? \"<unknown node> model=\" + inputNode.getModelReference() + \" node id=\" + inputNode.getNodeId() : org.jetbrains.mps.openapi.model.SNodeUtil.getDebugText(node);\n        result.add(new ProblemDescription(inputNode, \" -- was input: \" + dt));\n      }\n      SNodePointer template = myOrigin.getTemplate();\n      if (template != null) {\n        SNode node = template.getNode();\n        String dt = node == null ? \"<unknown node> model=\" + template.getModelReference() + \" node id=\" + template.getNodeId() : org.jetbrains.mps.openapi.model.SNodeUtil.getDebugText(node);\n        result.add(new ProblemDescription(template, \" -- was template: \" + dt));\n      }\n      if (result.size() > 0) {\n        error(message, result.toArray(new ProblemDescription[result.size()]));\n        return;\n      }\n    }\n    error(message);\n  }","commit_id":"c4272f1d5fbf102db0711e68d9a9512f3fe90e79","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void showErrorMessage(ITemplateGenerator generator) {\n    generator.showErrorMessage(getOutputSourceNode(), \"couldn't resolve reference '\" + getReferenceRole() + \"' in output node \" + getOutputSourceNode().getDebugText());\n    generator.showErrorMessage(myTemplateSourceNode, \"-- original reference was \" + myTemplateSourceNode.getDebugText());\n    generator.showErrorMessage(getInputNode(), \"-- input node was \" + getInputNode().getDebugText());\n  }","id":75256,"modified_method":"public void showErrorMessage(ITemplateGenerator generator) {\n    generator.showErrorMessage(getOutputSourceNode(), \"couldn't resolve reference '\" + getReferenceRole() + \"' in output node \" + getOutputSourceNode().getDebugText());\n    generator.showErrorMessage(myTemplateSourceNode, \"-- original reference was \" + myTemplateSourceNode.getDebugText());\n    SNode inputNode = getInputNode();\n    generator.showErrorMessage(inputNode, \"-- input node was \" + (inputNode != null ? inputNode.getDebugText() : \"NULL\"));\n  }","commit_id":"859ed7034bce7de3bd6f16bfac653b088bf3060e","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test(dependsOnMethods = \"cleanAll\")\r\n\tpublic void create() {\r\n\t\tdatabase = ODatabaseDocumentPool.global().acquire(url, \"admin\", \"admin\");\r\n\r\n\t\tstartRecordNumber = database.countClusterElements(\"Account\");\r\n\r\n\t\trecord.setClassName(\"Account\");\r\n\r\n\t\tbyte[] binary = new byte[100];\r\n\t\tfor (int b = 0; b < binary.length; ++b)\r\n\t\t\tbinary[b] = (byte) b;\r\n\r\n\t\tbase64 = OBase64Utils.encodeBytes(binary);\r\n\r\n\t\tfor (long i = startRecordNumber; i < startRecordNumber + TOT_RECORDS; ++i) {\r\n\t\t\trecord.reset();\r\n\r\n\t\t\trecord.field(\"id\", i);\r\n\t\t\trecord.field(\"name\", \"Gipsy\");\r\n\t\t\trecord.field(\"location\", \"Italy\");\r\n\t\t\trecord.field(\"salary\", (i + 300));\r\n\t\t\trecord.field(\"binary\", binary);\r\n\t\t\trecord.field(\"nonSchemaBinary\", binary);\r\n\t\t\trecord.field(\"testLong\", 10000000000L); // TEST LONG\r\n\t\t\trecord.field(\"extra\", \"This is an extra field not included in the schema\");\r\n\t\t\trecord.field(\"value\", (byte) 10);\r\n\r\n\t\t\trecord.save(\"Account\");\r\n\t\t}\r\n\r\n\t\tdatabase.close();\r\n\t}","id":75257,"modified_method":"@Test(dependsOnMethods = \"cleanAll\")\r\n\tpublic void create() {\r\n\t\tdatabase = ODatabaseDocumentPool.global().acquire(url, \"admin\", \"admin\");\r\n\r\n\t\tstartRecordNumber = database.countClusterElements(\"Account\");\r\n\r\n\t\trecord.setClassName(\"Account\");\r\n\r\n\t\tbyte[] binary = new byte[100];\r\n\t\tfor (int b = 0; b < binary.length; ++b)\r\n\t\t\tbinary[b] = (byte) b;\r\n\r\n\t\tbase64 = OBase64Utils.encodeBytes(binary);\r\n\r\n\t\tfinal int accountClusterId = database.getClusterIdByName(\"Account\");\r\n\r\n\t\tfor (long i = startRecordNumber; i < startRecordNumber + TOT_RECORDS; ++i) {\r\n\t\t\trecord.reset();\r\n\r\n\t\t\trecord.field(\"id\", i);\r\n\t\t\trecord.field(\"name\", \"Gipsy\");\r\n\t\t\trecord.field(\"location\", \"Italy\");\r\n\t\t\trecord.field(\"salary\", (i + 300));\r\n\t\t\trecord.field(\"binary\", binary);\r\n\t\t\trecord.field(\"nonSchemaBinary\", binary);\r\n\t\t\trecord.field(\"testLong\", 10000000000L); // TEST LONG\r\n\t\t\trecord.field(\"extra\", \"This is an extra field not included in the schema\");\r\n\t\t\trecord.field(\"value\", (byte) 10);\r\n\r\n\t\t\trecord.save(\"Account\");\r\n\t\t\tAssert.assertEquals(record.getIdentity().getClusterId(), accountClusterId);\r\n\t\t}\r\n\r\n\t\tdatabase.close();\r\n\t}","commit_id":"4ba1673f636e7272893228498915bab82d36b311","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test(dependsOnMethods = \"testUpdate\")\r\n\tpublic void testDoubleChanges() {\r\n\t\tdatabase = ODatabaseDocumentPool.global().acquire(url, \"admin\", \"admin\");\r\n\r\n\t\tODocument vDoc = database.newInstance();\r\n\t\tvDoc.setClassName(\"Profile\");\r\n\t\tvDoc.field(\"nick\", \"JayM1\").field(\"name\", \"Jay\").field(\"surname\", \"Miner\");\r\n\t\tvDoc.save();\r\n\r\n\t\tvDoc = database.load(vDoc.getIdentity());\r\n\t\tvDoc.field(\"nick\", \"JayM2\");\r\n\t\tvDoc.field(\"nick\", \"JayM3\");\r\n\t\tvDoc.save();\r\n\r\n\t\tSet<OIndex<?>> indexes = database.getMetadata().getSchema().getClass(\"Profile\").getProperty(\"nick\").getIndexes();\r\n\r\n\t\tAssert.assertEquals(indexes.size(), 1);\r\n\r\n\t\tOIndex indexDefinition = indexes.iterator().next();\r\n\t\tOIdentifiable vOldName = (OIdentifiable) indexDefinition.get(\"JayM1\");\r\n\t\tAssert.assertNull(vOldName);\r\n\r\n\t\tOIdentifiable vIntermediateName = (OIdentifiable) indexDefinition.get(\"JayM2\");\r\n\t\tAssert.assertNull(vIntermediateName);\r\n\r\n\t\tOIdentifiable vNewName = (OIdentifiable) indexDefinition.get(\"JayM3\");\r\n\t\tAssert.assertNotNull(vNewName);\r\n\r\n\t\tdatabase.close();\r\n\t}","id":75258,"modified_method":"@Test(dependsOnMethods = \"testUpdate\")\r\n\tpublic void testDoubleChanges() {\r\n\t\tdatabase = ODatabaseDocumentPool.global().acquire(url, \"admin\", \"admin\");\r\n\r\n\t\tODocument vDoc = database.newInstance();\r\n\t\tvDoc.setClassName(\"Profile\");\r\n\t\tvDoc.field(\"nick\", \"JayM1\").field(\"name\", \"Jay\").field(\"surname\", \"Miner\");\r\n\t\tvDoc.save();\r\n\r\n\t\tAssert.assertEquals(vDoc.getIdentity().getClusterId(), vDoc.getSchemaClass().getDefaultClusterId());\r\n\r\n\t\tvDoc = database.load(vDoc.getIdentity());\r\n\t\tvDoc.field(\"nick\", \"JayM2\");\r\n\t\tvDoc.field(\"nick\", \"JayM3\");\r\n\t\tvDoc.save();\r\n\r\n\t\tSet<OIndex<?>> indexes = database.getMetadata().getSchema().getClass(\"Profile\").getProperty(\"nick\").getIndexes();\r\n\r\n\t\tAssert.assertEquals(indexes.size(), 1);\r\n\r\n\t\tOIndex indexDefinition = indexes.iterator().next();\r\n\t\tOIdentifiable vOldName = (OIdentifiable) indexDefinition.get(\"JayM1\");\r\n\t\tAssert.assertNull(vOldName);\r\n\r\n\t\tOIdentifiable vIntermediateName = (OIdentifiable) indexDefinition.get(\"JayM2\");\r\n\t\tAssert.assertNull(vIntermediateName);\r\n\r\n\t\tOIdentifiable vNewName = (OIdentifiable) indexDefinition.get(\"JayM3\");\r\n\t\tAssert.assertNotNull(vNewName);\r\n\r\n\t\tdatabase.close();\r\n\t}","commit_id":"4ba1673f636e7272893228498915bab82d36b311","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test\r\n\tpublic void testTransactionWithDuplicateUniqueIndexValues() {\r\n\t\tODatabaseDocumentTx db = new ODatabaseDocumentTx(url);\r\n\t\tdb.open(\"admin\", \"admin\");\r\n\r\n\t\tif (!db.getMetadata().getSchema().existsClass(\"Fruit\")) {\r\n\t\t\tOClass fruitClass = db.getMetadata().getSchema().createClass(\"Fruit\");\r\n\t\t\tfruitClass.createProperty(\"name\", OType.STRING);\r\n\t\t\tfruitClass.createProperty(\"color\", OType.STRING);\r\n\r\n\t\t\tdb.getMetadata().getSchema().getClass(\"Fruit\").getProperty(\"color\").createIndex(OClass.INDEX_TYPE.UNIQUE);\r\n\t\t}\r\n\r\n\t\tAssert.assertEquals(db.countClusterElements(\"Fruit\"), 0);\r\n\r\n\t\ttry {\r\n\t\t\tdb.begin();\r\n\r\n\t\t\tODocument apple = new ODocument(db, \"Fruit\").field(\"name\", \"Apple\").field(\"color\", \"Red\");\r\n\t\t\tODocument orange = new ODocument(db, \"Fruit\").field(\"name\", \"Orange\").field(\"color\", \"Orange\");\r\n\t\t\tODocument banana = new ODocument(db, \"Fruit\").field(\"name\", \"Banana\").field(\"color\", \"Yellow\");\r\n\t\t\tODocument kumquat = new ODocument(db, \"Fruit\").field(\"name\", \"Kumquat\").field(\"color\", \"Orange\");\r\n\r\n\t\t\tapple.save();\r\n\t\t\torange.save();\r\n\t\t\tbanana.save();\r\n\t\t\tkumquat.save();\r\n\r\n\t\t\tdb.commit();\r\n\t\t\tAssert.assertTrue(false);\r\n\r\n\t\t} catch (OIndexException e) {\r\n\t\t\tAssert.assertTrue(true);\r\n\t\t\tdb.rollback();\r\n\r\n\t\t}\r\n\r\n\t\tAssert.assertEquals(db.countClusterElements(\"Fruit\"), 0);\r\n\r\n\t\tdb.close();\r\n\t}","id":75259,"modified_method":"@Test\r\n\tpublic void testTransactionWithDuplicateUniqueIndexValues() {\r\n\t\tODatabaseDocumentTx db = new ODatabaseDocumentTx(url);\r\n\t\tdb.open(\"admin\", \"admin\");\r\n\r\n\t\tOClass fruitClass = db.getMetadata().getSchema().getClass(\"Fruit\");\r\n\r\n\t\tif (fruitClass == null) {\r\n\t\t\tfruitClass = db.getMetadata().getSchema().createClass(\"Fruit\");\r\n\r\n\t\t\tfruitClass.createProperty(\"name\", OType.STRING);\r\n\t\t\tfruitClass.createProperty(\"color\", OType.STRING);\r\n\r\n\t\t\tdb.getMetadata().getSchema().getClass(\"Fruit\").getProperty(\"color\").createIndex(OClass.INDEX_TYPE.UNIQUE);\r\n\t\t}\r\n\r\n\t\tAssert.assertEquals(db.countClusterElements(\"Fruit\"), 0);\r\n\r\n\t\ttry {\r\n\t\t\tdb.begin();\r\n\r\n\t\t\tODocument apple = new ODocument(db, \"Fruit\").field(\"name\", \"Apple\").field(\"color\", \"Red\");\r\n\t\t\tODocument orange = new ODocument(db, \"Fruit\").field(\"name\", \"Orange\").field(\"color\", \"Orange\");\r\n\t\t\tODocument banana = new ODocument(db, \"Fruit\").field(\"name\", \"Banana\").field(\"color\", \"Yellow\");\r\n\t\t\tODocument kumquat = new ODocument(db, \"Fruit\").field(\"name\", \"Kumquat\").field(\"color\", \"Orange\");\r\n\r\n\t\t\tapple.save();\r\n\t\t\tAssert.assertEquals(apple.getIdentity().getClusterId(), fruitClass.getDefaultClusterId());\r\n\r\n\t\t\torange.save();\r\n\t\t\tAssert.assertEquals(orange.getIdentity().getClusterId(), fruitClass.getDefaultClusterId());\r\n\r\n\t\t\tbanana.save();\r\n\t\t\tAssert.assertEquals(banana.getIdentity().getClusterId(), fruitClass.getDefaultClusterId());\r\n\r\n\t\t\tkumquat.save();\r\n\t\t\tAssert.assertEquals(kumquat.getIdentity().getClusterId(), fruitClass.getDefaultClusterId());\r\n\r\n\t\t\tdb.commit();\r\n\t\t\tAssert.assertTrue(false);\r\n\r\n\t\t} catch (OIndexException e) {\r\n\t\t\tAssert.assertTrue(true);\r\n\t\t\tdb.rollback();\r\n\r\n\t\t}\r\n\r\n\t\tAssert.assertEquals(db.countClusterElements(\"Fruit\"), 0);\r\n\r\n\t\tdb.close();\r\n\t}","commit_id":"4ba1673f636e7272893228498915bab82d36b311","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void checkForGraphSchema() {\r\n\t\tif (!underlying.getMetadata().getSchema().existsClass(OGraphVertex.CLASS_NAME)) {\r\n\t\t\t// CREATE THE META MODEL USING THE ORIENT SCHEMA\r\n\t\t\tfinal OClass vertex = underlying.getMetadata().getSchema()\r\n\t\t\t\t\t.createClass(OGraphVertex.CLASS_NAME, underlying.addPhysicalCluster(OGraphVertex.CLASS_NAME));\r\n\t\t\tfinal OClass edge = underlying.getMetadata().getSchema()\r\n\t\t\t\t\t.createClass(OGraphEdge.CLASS_NAME, underlying.addPhysicalCluster(OGraphEdge.CLASS_NAME));\r\n\r\n\t\t\tedge.createProperty(OGraphEdge.IN, OType.LINK, vertex);\r\n\t\t\tedge.createProperty(OGraphEdge.OUT, OType.LINK, vertex);\r\n\r\n\t\t\tvertex.createProperty(OGraphVertex.FIELD_IN_EDGES, OType.LINKLIST, edge);\r\n\t\t\tvertex.createProperty(OGraphVertex.FIELD_OUT_EDGES, OType.LINKLIST, edge);\r\n\r\n\t\t\tunderlying.getMetadata().getSchema().save();\r\n\t\t}\r\n\t}","id":75260,"modified_method":"private void checkForGraphSchema() {\r\n\t\tif (!underlying.getMetadata().getSchema().existsClass(OGraphDatabase.VERTEX_CLASS_NAME)) {\r\n\t\t\t// CREATE THE META MODEL USING THE ORIENT SCHEMA\r\n\t\t\tfinal OClass vertex = underlying.getMetadata().getSchema()\r\n\t\t\t\t\t.createClass(OGraphDatabase.VERTEX_CLASS_NAME, underlying.addPhysicalCluster(OGraphDatabase.VERTEX_CLASS_NAME));\r\n\t\t\tfinal OClass edge = underlying.getMetadata().getSchema()\r\n\t\t\t\t\t.createClass(OGraphDatabase.EDGE_CLASS_NAME, underlying.addPhysicalCluster(OGraphDatabase.EDGE_CLASS_NAME));\r\n\r\n\t\t\tedge.createProperty(OGraphDatabase.EDGE_FIELD_IN, OType.LINK, vertex);\r\n\t\t\tedge.createProperty(OGraphDatabase.EDGE_FIELD_OUT, OType.LINK, vertex);\r\n\r\n\t\t\tvertex.createProperty(OGraphDatabase.VERTEX_FIELD_IN_EDGES, OType.LINKLIST, edge);\r\n\t\t\tvertex.createProperty(OGraphDatabase.VERTEX_FIELD_OUT_EDGES, OType.LINKLIST, edge);\r\n\r\n\t\t\tunderlying.getMetadata().getSchema().save();\r\n\t\t}\r\n\t}","commit_id":"b7ceb0a66fb54321009d280fae4a9805d34cd13f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OClass createVertexType(final String iClassName) {\r\n\t\tOClass cls = getMetadata().getSchema().createClass(iClassName).setSuperClass(getMetadata().getSchema().getClass(VERTEX_CLASS_NAME));\r\n\t\tgetMetadata().getSchema().save();\r\n\t\treturn cls;\r\n\t}","id":75261,"modified_method":"public OClass createVertexType(final String iClassName) {\r\n\t\treturn createVertexType(iClassName, vertexBaseClass);\r\n\t}","commit_id":"b7ceb0a66fb54321009d280fae4a9805d34cd13f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void checkForGraphSchema() {\r\n\t\tif (!getMetadata().getSchema().existsClass(VERTEX_CLASS_NAME)) {\r\n\t\t\t// CREATE THE META MODEL USING THE ORIENT SCHEMA\r\n\t\t\tfinal OClass vertex = getMetadata().getSchema().createClass(VERTEX_CLASS_NAME, addPhysicalCluster(VERTEX_CLASS_NAME));\r\n\t\t\tfinal OClass edge = getMetadata().getSchema().createClass(EDGE_CLASS_NAME, addPhysicalCluster(EDGE_CLASS_NAME));\r\n\r\n\t\t\tedge.createProperty(EDGE_FIELD_IN, OType.LINK, vertex);\r\n\t\t\tedge.createProperty(EDGE_FIELD_OUT, OType.LINK, vertex);\r\n\r\n\t\t\tvertex.createProperty(VERTEX_FIELD_IN_EDGES, OType.LINKLIST, edge);\r\n\t\t\tvertex.createProperty(VERTEX_FIELD_OUT_EDGES, OType.LINKLIST, edge);\r\n\r\n\t\t\tgetMetadata().getSchema().save();\r\n\t\t}\r\n\t}","id":75262,"modified_method":"private void checkForGraphSchema() {\r\n\t\tvertexBaseClass = getMetadata().getSchema().getClass(VERTEX_CLASS_NAME);\r\n\t\tedgeBaseClass = getMetadata().getSchema().getClass(EDGE_CLASS_NAME);\r\n\r\n\t\tif (vertexBaseClass == null) {\r\n\t\t\t// CREATE THE META MODEL USING THE ORIENT SCHEMA\r\n\t\t\tvertexBaseClass = getMetadata().getSchema().createClass(VERTEX_CLASS_NAME, addPhysicalCluster(VERTEX_CLASS_NAME));\r\n\r\n\t\t\tif (edgeBaseClass == null)\r\n\t\t\t\tedgeBaseClass = getMetadata().getSchema().createClass(EDGE_CLASS_NAME, addPhysicalCluster(EDGE_CLASS_NAME));\r\n\r\n\t\t\tvertexBaseClass.createProperty(VERTEX_FIELD_IN_EDGES, OType.LINKLIST, edgeBaseClass);\r\n\t\t\tvertexBaseClass.createProperty(VERTEX_FIELD_OUT_EDGES, OType.LINKLIST, edgeBaseClass);\r\n\t\t\tedgeBaseClass.createProperty(EDGE_FIELD_IN, OType.LINK, vertexBaseClass);\r\n\t\t\tedgeBaseClass.createProperty(EDGE_FIELD_OUT, OType.LINK, vertexBaseClass);\r\n\t\t}\r\n\t\tgetMetadata().getSchema().save();\r\n\t}","commit_id":"b7ceb0a66fb54321009d280fae4a9805d34cd13f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void setIn(final OGraphVertex iSource) {\r\n\t\tthis.in = new SoftReference<OGraphVertex>(iSource);\r\n\t\tdocument.field(IN, iSource.getDocument());\r\n\t}","id":75263,"modified_method":"protected void setIn(final OGraphVertex iSource) {\r\n\t\tthis.in = new SoftReference<OGraphVertex>(iSource);\r\n\t\tdocument.field(OGraphDatabase.EDGE_FIELD_IN, iSource.getDocument());\r\n\t}","commit_id":"b7ceb0a66fb54321009d280fae4a9805d34cd13f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void setOut(final OGraphVertex iDestination) {\r\n\t\tthis.out = new SoftReference<OGraphVertex>(iDestination);\r\n\t\tdocument.field(OUT, iDestination.getDocument());\r\n\t}","id":75264,"modified_method":"protected void setOut(final OGraphVertex iDestination) {\r\n\t\tthis.out = new SoftReference<OGraphVertex>(iDestination);\r\n\t\tdocument.field(OGraphDatabase.EDGE_FIELD_OUT, iDestination.getDocument());\r\n\t}","commit_id":"b7ceb0a66fb54321009d280fae4a9805d34cd13f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public static void delete(final ODatabaseGraphTx iDatabase, final ODocument iEdge) {\r\n\t\tfinal ODocument sourceVertex = (ODocument) iEdge.field(OUT);\r\n\t\tfinal ODocument targetVertex = (ODocument) iEdge.field(IN);\r\n\r\n\t\tList<OGraphEdge> edges;\r\n\r\n\t\tif (iDatabase.existsUserObjectByRID(sourceVertex.getIdentity())) {\r\n\t\t\t// WORK ALSO WITH IN MEMORY OBJECTS\r\n\r\n\t\t\tfinal OGraphVertex vertex = (OGraphVertex) iDatabase.getUserObjectByRecord(sourceVertex, null);\r\n\t\t\t// REMOVE THE EDGE OBJECT\r\n\t\t\tedges = vertex.getOutEdges();\r\n\t\t\tif (edges != null) {\r\n\t\t\t\tfor (OGraphEdge e : edges)\r\n\t\t\t\t\tif (e.getDocument().equals(iEdge)) {\r\n\t\t\t\t\t\tedges.remove(e);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (iDatabase.existsUserObjectByRID(targetVertex.getIdentity())) {\r\n\t\t\t// WORK ALSO WITH IN MEMORY OBJECTS\r\n\r\n\t\t\tfinal OGraphVertex vertex = (OGraphVertex) iDatabase.getUserObjectByRecord(targetVertex, null);\r\n\t\t\t// REMOVE THE EDGE OBJECT FROM THE TARGET VERTEX\r\n\t\t\tedges = vertex.getInEdges();\r\n\t\t\tif (edges != null) {\r\n\t\t\t\tfor (OGraphEdge e : edges)\r\n\t\t\t\t\tif (e.getDocument().equals(iEdge)) {\r\n\t\t\t\t\t\tedges.remove(e);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// REMOVE THE EDGE DOCUMENT\r\n\t\tList<ODocument> docs = sourceVertex.field(OGraphVertex.FIELD_OUT_EDGES);\r\n\t\tif (docs != null)\r\n\t\t\tdocs.remove(iEdge);\r\n\r\n\t\tsourceVertex.setDirty();\r\n\t\tsourceVertex.save();\r\n\r\n\t\t// REMOVE THE EDGE DOCUMENT FROM THE TARGET VERTEX\r\n\t\tdocs = targetVertex.field(OGraphVertex.FIELD_IN_EDGES);\r\n\t\tif (docs != null)\r\n\t\t\tdocs.remove(iEdge);\r\n\r\n\t\ttargetVertex.setDirty();\r\n\t\ttargetVertex.save();\r\n\r\n\t\tif (iDatabase.existsUserObjectByRID(iEdge.getIdentity())) {\r\n\t\t\tfinal OGraphEdge edge = (OGraphEdge) iDatabase.getUserObjectByRecord(iEdge, null);\r\n\t\t\tiDatabase.unregisterPojo(edge, iEdge);\r\n\t\t}\r\n\r\n\t\tiEdge.delete();\r\n\t}","id":75265,"modified_method":"public static void delete(final ODatabaseGraphTx iDatabase, final ODocument iEdge) {\r\n\t\tfinal ODocument sourceVertex = (ODocument) iEdge.field(OGraphDatabase.EDGE_FIELD_OUT);\r\n\t\tfinal ODocument targetVertex = (ODocument) iEdge.field(OGraphDatabase.EDGE_FIELD_IN);\r\n\r\n\t\tList<OGraphEdge> edges;\r\n\r\n\t\tif (iDatabase.existsUserObjectByRID(sourceVertex.getIdentity())) {\r\n\t\t\t// WORK ALSO WITH OGraphDatabase.EDGE_FIELD_IN MEMORY OBJECTS\r\n\r\n\t\t\tfinal OGraphVertex vertex = (OGraphVertex) iDatabase.getUserObjectByRecord(sourceVertex, null);\r\n\t\t\t// REMOVE THE EDGE OBJECT\r\n\t\t\tedges = vertex.getOutEdges();\r\n\t\t\tif (edges != null) {\r\n\t\t\t\tfor (OGraphEdge e : edges)\r\n\t\t\t\t\tif (e.getDocument().equals(iEdge)) {\r\n\t\t\t\t\t\tedges.remove(e);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (iDatabase.existsUserObjectByRID(targetVertex.getIdentity())) {\r\n\t\t\t// WORK ALSO WITH OGraphDatabase.EDGE_FIELD_IN MEMORY OBJECTS\r\n\r\n\t\t\tfinal OGraphVertex vertex = (OGraphVertex) iDatabase.getUserObjectByRecord(targetVertex, null);\r\n\t\t\t// REMOVE THE EDGE OBJECT FROM THE TARGET VERTEX\r\n\t\t\tedges = vertex.getInEdges();\r\n\t\t\tif (edges != null) {\r\n\t\t\t\tfor (OGraphEdge e : edges)\r\n\t\t\t\t\tif (e.getDocument().equals(iEdge)) {\r\n\t\t\t\t\t\tedges.remove(e);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// REMOVE THE EDGE DOCUMENT\r\n\t\tList<ODocument> docs = sourceVertex.field(OGraphDatabase.VERTEX_FIELD_OUT_EDGES);\r\n\t\tif (docs != null)\r\n\t\t\tdocs.remove(iEdge);\r\n\r\n\t\tsourceVertex.setDirty();\r\n\t\tsourceVertex.save();\r\n\r\n\t\t// REMOVE THE EDGE DOCUMENT FROM THE TARGET VERTEX\r\n\t\tdocs = targetVertex.field(OGraphDatabase.VERTEX_FIELD_IN_EDGES);\r\n\t\tif (docs != null)\r\n\t\t\tdocs.remove(iEdge);\r\n\r\n\t\ttargetVertex.setDirty();\r\n\t\ttargetVertex.save();\r\n\r\n\t\tif (iDatabase.existsUserObjectByRID(iEdge.getIdentity())) {\r\n\t\t\tfinal OGraphEdge edge = (OGraphEdge) iDatabase.getUserObjectByRecord(iEdge, null);\r\n\t\t\tiDatabase.unregisterPojo(edge, iEdge);\r\n\t\t}\r\n\r\n\t\tiEdge.delete();\r\n\t}","commit_id":"b7ceb0a66fb54321009d280fae4a9805d34cd13f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OGraphEdge(final ODatabaseGraphTx iDatabase, final OGraphVertex iOutNode, final OGraphVertex iInNode) {\r\n\t\tthis(iDatabase, CLASS_NAME, iOutNode, iInNode);\r\n\t}","id":75266,"modified_method":"public OGraphEdge(final ODatabaseGraphTx iDatabase, final OGraphVertex iOutNode, final OGraphVertex iInNode) {\r\n\t\tthis(iDatabase, OGraphDatabase.EDGE_CLASS_NAME, iOutNode, iInNode);\r\n\t}","commit_id":"b7ceb0a66fb54321009d280fae4a9805d34cd13f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OGraphEdge(final ODatabaseGraphTx iDatabase, final String iClassName, final OGraphVertex iOutNode, final OGraphVertex iInNode) {\r\n\t\tthis(iDatabase, iClassName);\r\n\t\tin = new SoftReference<OGraphVertex>(iInNode);\r\n\t\tout = new SoftReference<OGraphVertex>(iOutNode);\r\n\t\tset(IN, iInNode.getDocument());\r\n\t\tset(OUT, iOutNode.getDocument());\r\n\t}","id":75267,"modified_method":"public OGraphEdge(final ODatabaseGraphTx iDatabase, final String iClassName, final OGraphVertex iOutNode,\r\n\t\t\tfinal OGraphVertex iInNode) {\r\n\t\tthis(iDatabase, iClassName);\r\n\t\tin = new SoftReference<OGraphVertex>(iInNode);\r\n\t\tout = new SoftReference<OGraphVertex>(iOutNode);\r\n\t\tset(OGraphDatabase.EDGE_FIELD_IN, iInNode.getDocument());\r\n\t\tset(OGraphDatabase.EDGE_FIELD_OUT, iOutNode.getDocument());\r\n\t}","commit_id":"b7ceb0a66fb54321009d280fae4a9805d34cd13f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OGraphEdge(final ODatabaseGraphTx iDatabase) {\r\n\t\tsuper(iDatabase, CLASS_NAME);\r\n\t}","id":75268,"modified_method":"public OGraphEdge(final ODatabaseGraphTx iDatabase) {\r\n\t\tsuper(iDatabase, OGraphDatabase.EDGE_CLASS_NAME);\r\n\t}","commit_id":"b7ceb0a66fb54321009d280fae4a9805d34cd13f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OGraphEdge(final ODatabaseGraphTx iDatabase, final String iClassName) {\r\n\t\tsuper(iDatabase, iClassName != null ? iClassName : CLASS_NAME);\r\n\t}","id":75269,"modified_method":"public OGraphEdge(final ODatabaseGraphTx iDatabase, final String iClassName) {\r\n\t\tsuper(iDatabase, iClassName != null ? iClassName : OGraphDatabase.EDGE_CLASS_NAME);\r\n\t}","commit_id":"b7ceb0a66fb54321009d280fae4a9805d34cd13f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OGraphVertex getIn() {\r\n\t\tif (in == null || in.get() == null)\r\n\t\t\tin = new SoftReference<OGraphVertex>((OGraphVertex) database.getUserObjectByRecord((ODocument) document.field(IN), null));\r\n\r\n\t\treturn in.get();\r\n\t}","id":75270,"modified_method":"public OGraphVertex getIn() {\r\n\t\tif (in == null || in.get() == null)\r\n\t\t\tin = new SoftReference<OGraphVertex>((OGraphVertex) database.getUserObjectByRecord(\r\n\t\t\t\t\t(ODocument) document.field(OGraphDatabase.EDGE_FIELD_IN), null));\r\n\r\n\t\treturn in.get();\r\n\t}","commit_id":"b7ceb0a66fb54321009d280fae4a9805d34cd13f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OGraphVertex getOut() {\r\n\t\tif (out == null || out.get() == null)\r\n\t\t\tout = new SoftReference<OGraphVertex>((OGraphVertex) database.getUserObjectByRecord((ODocument) document.field(OUT), null));\r\n\r\n\t\treturn out.get();\r\n\t}","id":75271,"modified_method":"public OGraphVertex getOut() {\r\n\t\tif (out == null || out.get() == null)\r\n\t\t\tout = new SoftReference<OGraphVertex>((OGraphVertex) database.getUserObjectByRecord(\r\n\t\t\t\t\t(ODocument) document.field(OGraphDatabase.EDGE_FIELD_OUT), null));\r\n\r\n\t\treturn out.get();\r\n\t}","commit_id":"b7ceb0a66fb54321009d280fae4a9805d34cd13f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public int findOutVertex(final OGraphVertex iVertexDocument) {\r\n\t\tfinal List<ODocument> docs = document.field(FIELD_OUT_EDGES);\r\n\t\tif (docs == null || docs.size() == 0)\r\n\t\t\treturn -1;\r\n\r\n\t\tfor (int i = 0; i < docs.size(); ++i) {\r\n\t\t\tif (docs.get(i).field(OGraphEdge.OUT).equals(iVertexDocument.getDocument()))\r\n\t\t\t\treturn i;\r\n\t\t}\r\n\r\n\t\treturn -1;\r\n\t}","id":75272,"modified_method":"public int findOutVertex(final OGraphVertex iVertexDocument) {\r\n\t\tfinal List<ODocument> docs = document.field(OGraphDatabase.VERTEX_FIELD_OUT_EDGES);\r\n\t\tif (docs == null || docs.size() == 0)\r\n\t\t\treturn -1;\r\n\r\n\t\tfor (int i = 0; i < docs.size(); ++i) {\r\n\t\t\tif (docs.get(i).field(OGraphDatabase.EDGE_FIELD_OUT).equals(iVertexDocument.getDocument()))\r\n\t\t\t\treturn i;\r\n\t\t}\r\n\r\n\t\treturn -1;\r\n\t}","commit_id":"b7ceb0a66fb54321009d280fae4a9805d34cd13f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n\t * Returns the outgoing vertex at given position.\r\n\t * \r\n\t * @param iIndex\r\n\t *          edge position\r\n\t * @param iCurrentVertex\r\n\t *          Object to recycle to save memory. Used on iteration\r\n\t * @param iCurrentVertex\r\n\t */\r\n\tpublic OGraphVertex getOutEdgeVertex(int iIndex, final OGraphVertex iCurrentVertex) {\r\n\t\tfinal List<ODocument> docs = document.field(FIELD_OUT_EDGES);\r\n\t\tiCurrentVertex.fromStream((ODocument) docs.get(iIndex).field(OGraphEdge.OUT));\r\n\t\treturn iCurrentVertex;\r\n\t}","id":75273,"modified_method":"/**\r\n\t * Returns the outgoing vertex at given position.\r\n\t * \r\n\t * @param iIndex\r\n\t *          edge position\r\n\t * @param iCurrentVertex\r\n\t *          Object to recycle to save memory. Used on iteration\r\n\t * @param iCurrentVertex\r\n\t */\r\n\tpublic OGraphVertex getOutEdgeVertex(int iIndex, final OGraphVertex iCurrentVertex) {\r\n\t\tfinal List<ODocument> docs = document.field(OGraphDatabase.VERTEX_FIELD_OUT_EDGES);\r\n\t\tiCurrentVertex.fromStream((ODocument) docs.get(iIndex).field(OGraphDatabase.EDGE_FIELD_OUT));\r\n\t\treturn iCurrentVertex;\r\n\t}","commit_id":"b7ceb0a66fb54321009d280fae4a9805d34cd13f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n\t * Returns the list of Vertexes from the incoming edges. It avoids to unmarshall edges.\r\n\t */\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tpublic List<OGraphVertex> browseInEdgesVertexes() {\r\n\t\tfinal List<OGraphVertex> resultset = new ArrayList<OGraphVertex>();\r\n\r\n\t\tList<OGraphEdge> tempList = inEdges != null ? inEdges.get() : null;\r\n\r\n\t\tif (tempList == null) {\r\n\t\t\tfinal List<ODocument> docEdges = (List<ODocument>) document.field(FIELD_IN_EDGES);\r\n\r\n\t\t\t// TRANSFORM ALL THE EDGES\r\n\t\t\tif (docEdges != null)\r\n\t\t\t\tfor (ODocument d : docEdges) {\r\n\t\t\t\t\tresultset.add((OGraphVertex) database.getUserObjectByRecord((ODocument) d.field(OGraphEdge.OUT), null));\r\n\t\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (OGraphEdge edge : tempList) {\r\n\t\t\t\tresultset.add(edge.getOut());\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn resultset;\r\n\t}","id":75274,"modified_method":"/**\r\n\t * Returns the list of Vertexes from the incoming edges. It avoids to unmarshall edges.\r\n\t */\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tpublic List<OGraphVertex> browseInEdgesVertexes() {\r\n\t\tfinal List<OGraphVertex> resultset = new ArrayList<OGraphVertex>();\r\n\r\n\t\tList<OGraphEdge> tempList = inEdges != null ? inEdges.get() : null;\r\n\r\n\t\tif (tempList == null) {\r\n\t\t\tfinal List<ODocument> docEdges = (List<ODocument>) document.field(OGraphDatabase.VERTEX_FIELD_IN_EDGES);\r\n\r\n\t\t\t// TRANSFORM ALL THE EDGES\r\n\t\t\tif (docEdges != null)\r\n\t\t\t\tfor (ODocument d : docEdges) {\r\n\t\t\t\t\tresultset.add((OGraphVertex) database.getUserObjectByRecord((ODocument) d.field(OGraphDatabase.EDGE_FIELD_OUT), null));\r\n\t\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (OGraphEdge edge : tempList) {\r\n\t\t\t\tresultset.add(edge.getOut());\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn resultset;\r\n\t}","commit_id":"b7ceb0a66fb54321009d280fae4a9805d34cd13f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n\t@Override\r\n\tpublic void delete() {\r\n\t\t// DELETE ALL THE IN-OUT EDGES FROM RAM\r\n\t\tif (inEdges != null && inEdges.get() != null)\r\n\t\t\tinEdges.get().clear();\r\n\t\tinEdges = null;\r\n\r\n\t\tif (outEdges != null && outEdges.get() != null)\r\n\t\t\toutEdges.get().clear();\r\n\t\toutEdges = null;\r\n\r\n\t\tList<ODocument> docs = (List<ODocument>) document.field(FIELD_IN_EDGES);\r\n\t\tif (docs != null)\r\n\t\t\twhile (!docs.isEmpty())\r\n\t\t\t\tOGraphEdge.delete(database, docs.get(0));\r\n\r\n\t\tdocs = (List<ODocument>) document.field(FIELD_OUT_EDGES);\r\n\t\tif (docs != null)\r\n\t\t\twhile (!docs.isEmpty())\r\n\t\t\t\tOGraphEdge.delete(database, docs.get(0));\r\n\r\n\t\tdatabase.unregisterPojo(this, document);\r\n\r\n\t\tdocument.delete();\r\n\t\tdocument = null;\r\n\t}","id":75275,"modified_method":"@SuppressWarnings(\"unchecked\")\r\n\t@Override\r\n\tpublic void delete() {\r\n\t\t// DELETE ALL THE IN-OUT EDGES FROM RAM\r\n\t\tif (inEdges != null && inEdges.get() != null)\r\n\t\t\tinEdges.get().clear();\r\n\t\tinEdges = null;\r\n\r\n\t\tif (outEdges != null && outEdges.get() != null)\r\n\t\t\toutEdges.get().clear();\r\n\t\toutEdges = null;\r\n\r\n\t\tList<ODocument> docs = (List<ODocument>) document.field(OGraphDatabase.VERTEX_FIELD_IN_EDGES);\r\n\t\tif (docs != null)\r\n\t\t\twhile (!docs.isEmpty())\r\n\t\t\t\tOGraphEdge.delete(database, docs.get(0));\r\n\r\n\t\tdocs = (List<ODocument>) document.field(OGraphDatabase.VERTEX_FIELD_OUT_EDGES);\r\n\t\tif (docs != null)\r\n\t\t\twhile (!docs.isEmpty())\r\n\t\t\t\tOGraphEdge.delete(database, docs.get(0));\r\n\r\n\t\tdatabase.unregisterPojo(this, document);\r\n\r\n\t\tdocument.delete();\r\n\t\tdocument = null;\r\n\t}","commit_id":"b7ceb0a66fb54321009d280fae4a9805d34cd13f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OGraphVertex(final ODatabaseGraphTx iDatabase) {\r\n\t\tsuper(iDatabase, CLASS_NAME);\r\n\t}","id":75276,"modified_method":"public OGraphVertex(final ODatabaseGraphTx iDatabase) {\r\n\t\tsuper(iDatabase, OGraphDatabase.VERTEX_CLASS_NAME);\r\n\t}","commit_id":"b7ceb0a66fb54321009d280fae4a9805d34cd13f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n\t * Returns the list of Vertexes from the outgoing edges. It avoids to unmarshall edges.\r\n\t */\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tpublic List<OGraphVertex> browseOutEdgesVertexes() {\r\n\t\tfinal List<OGraphVertex> resultset = new ArrayList<OGraphVertex>();\r\n\r\n\t\tList<OGraphEdge> tempList = outEdges != null ? outEdges.get() : null;\r\n\r\n\t\tif (tempList == null) {\r\n\t\t\tfinal List<ODocument> docEdges = (List<ODocument>) document.field(FIELD_OUT_EDGES);\r\n\r\n\t\t\t// TRANSFORM ALL THE EDGES\r\n\t\t\tif (docEdges != null)\r\n\t\t\t\tfor (ODocument d : docEdges) {\r\n\t\t\t\t\tresultset.add((OGraphVertex) database.getUserObjectByRecord((ODocument) d.field(OGraphEdge.IN), null));\r\n\t\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (OGraphEdge edge : tempList) {\r\n\t\t\t\tresultset.add(edge.getIn());\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn resultset;\r\n\t}","id":75277,"modified_method":"/**\r\n\t * Returns the list of Vertexes from the outgoing edges. It avoids to unmarshall edges.\r\n\t */\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tpublic List<OGraphVertex> browseOutEdgesVertexes() {\r\n\t\tfinal List<OGraphVertex> resultset = new ArrayList<OGraphVertex>();\r\n\r\n\t\tList<OGraphEdge> tempList = outEdges != null ? outEdges.get() : null;\r\n\r\n\t\tif (tempList == null) {\r\n\t\t\tfinal List<ODocument> docEdges = (List<ODocument>) document.field(OGraphDatabase.VERTEX_FIELD_OUT_EDGES);\r\n\r\n\t\t\t// TRANSFORM ALL THE EDGES\r\n\t\t\tif (docEdges != null)\r\n\t\t\t\tfor (ODocument d : docEdges) {\r\n\t\t\t\t\tresultset.add((OGraphVertex) database.getUserObjectByRecord((ODocument) d.field(OGraphDatabase.EDGE_FIELD_IN), null));\r\n\t\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (OGraphEdge edge : tempList) {\r\n\t\t\t\tresultset.add(edge.getIn());\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn resultset;\r\n\t}","commit_id":"b7ceb0a66fb54321009d280fae4a9805d34cd13f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n\t * Returns the outgoing edges of current node. If there are no edged, then an empty list is returned.\r\n\t */\r\n\tpublic List<OGraphEdge> getOutEdges() {\r\n\t\tList<OGraphEdge> tempList = outEdges != null ? outEdges.get() : null;\r\n\r\n\t\tif (tempList == null) {\r\n\t\t\ttempList = new ArrayList<OGraphEdge>();\r\n\t\t\toutEdges = new SoftReference<List<OGraphEdge>>(tempList);\r\n\r\n\t\t\tfinal List<Object> docs = document.field(FIELD_OUT_EDGES);\r\n\r\n\t\t\tif (docs != null) {\r\n\t\t\t\t// TRANSFORM ALL THE ARCS\r\n\t\t\t\tODocument doc;\r\n\t\t\t\tfor (Object o : docs) {\r\n\t\t\t\t\tif (o instanceof ODocument)\r\n\t\t\t\t\t\tdoc = (ODocument) o;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tdoc = database.getRecordById((ORID) o);\r\n\r\n\t\t\t\t\ttempList.add((OGraphEdge) database.getUserObjectByRecord(doc, null));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn tempList;\r\n\t}","id":75278,"modified_method":"/**\r\n\t * Returns the outgoing edges of current node. If there are no edged, then an empty list is returned.\r\n\t */\r\n\tpublic List<OGraphEdge> getOutEdges() {\r\n\t\tList<OGraphEdge> tempList = outEdges != null ? outEdges.get() : null;\r\n\r\n\t\tif (tempList == null) {\r\n\t\t\ttempList = new ArrayList<OGraphEdge>();\r\n\t\t\toutEdges = new SoftReference<List<OGraphEdge>>(tempList);\r\n\r\n\t\t\tfinal List<Object> docs = document.field(OGraphDatabase.VERTEX_FIELD_OUT_EDGES);\r\n\r\n\t\t\tif (docs != null) {\r\n\t\t\t\t// TRANSFORM ALL THE ARCS\r\n\t\t\t\tODocument doc;\r\n\t\t\t\tfor (Object o : docs) {\r\n\t\t\t\t\tif (o instanceof ODocument)\r\n\t\t\t\t\t\tdoc = (ODocument) o;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tdoc = database.getRecordById((ORID) o);\r\n\r\n\t\t\t\t\ttempList.add((OGraphEdge) database.getUserObjectByRecord(doc, null));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn tempList;\r\n\t}","commit_id":"b7ceb0a66fb54321009d280fae4a9805d34cd13f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n\t * Returns the incoming edges of current node. If there are no edged, then an empty list is returned.\r\n\t */\r\n\tpublic List<OGraphEdge> getInEdges() {\r\n\t\tList<OGraphEdge> tempList = inEdges != null ? inEdges.get() : null;\r\n\r\n\t\tif (tempList == null) {\r\n\t\t\ttempList = new ArrayList<OGraphEdge>();\r\n\t\t\tinEdges = new SoftReference<List<OGraphEdge>>(tempList);\r\n\r\n\t\t\tfinal List<Object> docs = document.field(FIELD_IN_EDGES);\r\n\r\n\t\t\tif (docs != null) {\r\n\t\t\t\t// TRANSFORM ALL THE ARCS\r\n\t\t\t\tODocument doc;\r\n\t\t\t\tfor (Object o : docs) {\r\n\t\t\t\t\tif (o instanceof ODocument)\r\n\t\t\t\t\t\tdoc = (ODocument) o;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tdoc = database.getRecordById((ORID) o);\r\n\r\n\t\t\t\t\ttempList.add((OGraphEdge) database.getUserObjectByRecord(doc, null));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn tempList;\r\n\t}","id":75279,"modified_method":"/**\r\n\t * Returns the incoming edges of current node. If there are no edged, then an empty list is returned.\r\n\t */\r\n\tpublic List<OGraphEdge> getInEdges() {\r\n\t\tList<OGraphEdge> tempList = inEdges != null ? inEdges.get() : null;\r\n\r\n\t\tif (tempList == null) {\r\n\t\t\ttempList = new ArrayList<OGraphEdge>();\r\n\t\t\tinEdges = new SoftReference<List<OGraphEdge>>(tempList);\r\n\r\n\t\t\tfinal List<Object> docs = document.field(OGraphDatabase.VERTEX_FIELD_IN_EDGES);\r\n\r\n\t\t\tif (docs != null) {\r\n\t\t\t\t// TRANSFORM ALL THE ARCS\r\n\t\t\t\tODocument doc;\r\n\t\t\t\tfor (Object o : docs) {\r\n\t\t\t\t\tif (o instanceof ODocument)\r\n\t\t\t\t\t\tdoc = (ODocument) o;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tdoc = database.getRecordById((ORID) o);\r\n\r\n\t\t\t\t\ttempList.add((OGraphEdge) database.getUserObjectByRecord(doc, null));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn tempList;\r\n\t}","commit_id":"b7ceb0a66fb54321009d280fae4a9805d34cd13f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public int getInEdgeCount() {\r\n\t\tfinal List<ODocument> docs = document.field(FIELD_IN_EDGES);\r\n\t\treturn docs == null ? 0 : docs.size();\r\n\t}","id":75280,"modified_method":"public int getInEdgeCount() {\r\n\t\tfinal List<ODocument> docs = document.field(OGraphDatabase.VERTEX_FIELD_IN_EDGES);\r\n\t\treturn docs == null ? 0 : docs.size();\r\n\t}","commit_id":"b7ceb0a66fb54321009d280fae4a9805d34cd13f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n\t * Create a link between the current vertex and the target one. The link is of type iClassName.\r\n\t * \r\n\t * @param iTargetVertex\r\n\t *          Target vertex where to create the connection\r\n\t * @param iClassName\r\n\t *          The name of the class to use for the Edge\r\n\t * @return The new edge created\r\n\t */\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tpublic OGraphEdge link(final OGraphVertex iTargetVertex, final String iClassName) {\r\n\t\tif (iTargetVertex == null)\r\n\t\t\tthrow new IllegalArgumentException(\"Missed the target vertex\");\r\n\r\n\t\t// CREATE THE EDGE BETWEEN ME AND THE TARGET\r\n\t\tfinal OGraphEdge edge = new OGraphEdge(database, iClassName, this, iTargetVertex);\r\n\t\tgetOutEdges().add(edge);\r\n\r\n\t\tList<ODocument> recordEdges = ((List<ODocument>) document.field(FIELD_OUT_EDGES));\r\n\t\tif (recordEdges == null) {\r\n\t\t\trecordEdges = new ArrayList<ODocument>();\r\n\t\t\tdocument.field(FIELD_OUT_EDGES, recordEdges);\r\n\t\t}\r\n\t\trecordEdges.add(edge.getDocument());\r\n\t\tdocument.setDirty();\r\n\r\n\t\t// INSERT INTO THE INGOING EDGES OF TARGET\r\n\t\tiTargetVertex.getInEdges().add(edge);\r\n\r\n\t\trecordEdges = ((List<ODocument>) iTargetVertex.getDocument().field(FIELD_IN_EDGES));\r\n\t\tif (recordEdges == null) {\r\n\t\t\trecordEdges = new ArrayList<ODocument>();\r\n\t\t\tiTargetVertex.getDocument().field(FIELD_IN_EDGES, recordEdges);\r\n\t\t}\r\n\r\n\t\trecordEdges.add(edge.getDocument());\r\n\t\tiTargetVertex.getDocument().setDirty();\r\n\r\n\t\treturn edge;\r\n\t}","id":75281,"modified_method":"/**\r\n\t * Create a link between the current vertex and the target one. The link is of type iClassName.\r\n\t * \r\n\t * @param iTargetVertex\r\n\t *          Target vertex where to create the connection\r\n\t * @param iClassName\r\n\t *          The name of the class to use for the Edge\r\n\t * @return The new edge created\r\n\t */\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tpublic OGraphEdge link(final OGraphVertex iTargetVertex, final String iClassName) {\r\n\t\tif (iTargetVertex == null)\r\n\t\t\tthrow new IllegalArgumentException(\"Missed the target vertex\");\r\n\r\n\t\t// CREATE THE EDGE BETWEEN ME AND THE TARGET\r\n\t\tfinal OGraphEdge edge = new OGraphEdge(database, iClassName, this, iTargetVertex);\r\n\t\tgetOutEdges().add(edge);\r\n\r\n\t\tList<ODocument> recordEdges = ((List<ODocument>) document.field(OGraphDatabase.VERTEX_FIELD_OUT_EDGES));\r\n\t\tif (recordEdges == null) {\r\n\t\t\trecordEdges = new ArrayList<ODocument>();\r\n\t\t\tdocument.field(OGraphDatabase.VERTEX_FIELD_OUT_EDGES, recordEdges);\r\n\t\t}\r\n\t\trecordEdges.add(edge.getDocument());\r\n\t\tdocument.setDirty();\r\n\r\n\t\t// INSERT INTO THE INGOING EDGES OF TARGET\r\n\t\tiTargetVertex.getInEdges().add(edge);\r\n\r\n\t\trecordEdges = ((List<ODocument>) iTargetVertex.getDocument().field(OGraphDatabase.VERTEX_FIELD_IN_EDGES));\r\n\t\tif (recordEdges == null) {\r\n\t\t\trecordEdges = new ArrayList<ODocument>();\r\n\t\t\tiTargetVertex.getDocument().field(OGraphDatabase.VERTEX_FIELD_IN_EDGES, recordEdges);\r\n\t\t}\r\n\r\n\t\trecordEdges.add(edge.getDocument());\r\n\t\tiTargetVertex.getDocument().setDirty();\r\n\r\n\t\treturn edge;\r\n\t}","commit_id":"b7ceb0a66fb54321009d280fae4a9805d34cd13f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n\t * Returns the incoming vertex at given position.\r\n\t * \r\n\t * @param iIndex\r\n\t *          edge position\r\n\t * @param iCurrentVertex\r\n\t *          Object to recycle to save memory. Used on iteration\r\n\t * @param iCurrentVertex\r\n\t */\r\n\tpublic OGraphVertex getInEdgeVertex(int iIndex, final OGraphVertex iCurrentVertex) {\r\n\t\tfinal List<ODocument> docs = document.field(FIELD_IN_EDGES);\r\n\t\tiCurrentVertex.fromStream((ODocument) docs.get(iIndex).field(OGraphEdge.IN));\r\n\t\treturn iCurrentVertex;\r\n\t}","id":75282,"modified_method":"/**\r\n\t * Returns the incoming vertex at given position.\r\n\t * \r\n\t * @param iIndex\r\n\t * \r\n\t *          edge position\r\n\t * @param iCurrentVertex\r\n\t *          Object to recycle to save memory. Used on iteration\r\n\t * @param iCurrentVertex\r\n\t */\r\n\tpublic OGraphVertex getInEdgeVertex(int iIndex, final OGraphVertex iCurrentVertex) {\r\n\t\tfinal List<ODocument> docs = document.field(OGraphDatabase.VERTEX_FIELD_IN_EDGES);\r\n\t\tiCurrentVertex.fromStream((ODocument) docs.get(iIndex).field(OGraphDatabase.EDGE_FIELD_IN));\r\n\t\treturn iCurrentVertex;\r\n\t}","commit_id":"b7ceb0a66fb54321009d280fae4a9805d34cd13f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n\t * Unlinks all the edges between iSourceVertex and iTargetVertex\r\n\t * \r\n\t * @param iDatabase\r\n\t * @param iSourceVertex\r\n\t * @param iTargetVertex\r\n\t */\r\n\tpublic static void unlink(final ODatabaseGraphTx iDatabase, final ODocument iSourceVertex, final ODocument iTargetVertex) {\r\n\t\tif (iTargetVertex == null)\r\n\t\t\tthrow new IllegalArgumentException(\"Missed the target vertex\");\r\n\r\n\t\tif (iDatabase.existsUserObjectByRID(iSourceVertex.getIdentity())) {\r\n\t\t\t// WORK ALSO WITH IN MEMORY OBJECTS\r\n\r\n\t\t\tfinal OGraphVertex vertex = (OGraphVertex) iDatabase.getUserObjectByRecord(iSourceVertex, null);\r\n\t\t\t// REMOVE THE EDGE OBJECT\r\n\t\t\tif (vertex.outEdges != null && vertex.outEdges.get() != null) {\r\n\t\t\t\tfor (OGraphEdge e : vertex.outEdges.get())\r\n\t\t\t\t\tif (e.getIn().getDocument().equals(iTargetVertex)) {\r\n\t\t\t\t\t\tvertex.outEdges.get().remove(e);\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (iDatabase.existsUserObjectByRID(iTargetVertex.getIdentity())) {\r\n\t\t\t// WORK ALSO WITH IN MEMORY OBJECTS\r\n\r\n\t\t\tfinal OGraphVertex vertex = (OGraphVertex) iDatabase.getUserObjectByRecord(iTargetVertex, null);\r\n\t\t\t// REMOVE THE EDGE OBJECT FROM THE TARGET VERTEX\r\n\t\t\tif (vertex.inEdges != null && vertex.inEdges.get() != null) {\r\n\t\t\t\tfor (OGraphEdge e : vertex.inEdges.get())\r\n\t\t\t\t\tif (e.getOut().getDocument().equals(iSourceVertex)) {\r\n\t\t\t\t\t\tvertex.inEdges.get().remove(e);\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// REMOVE THE EDGE DOCUMENT\r\n\t\tODocument edge = null;\r\n\t\tList<ODocument> docs = iSourceVertex.field(FIELD_OUT_EDGES);\r\n\t\tif (docs != null) {\r\n\t\t\tfor (ODocument d : docs)\r\n\t\t\t\tif (d.field(OGraphEdge.IN).equals(iTargetVertex)) {\r\n\t\t\t\t\tdocs.remove(d);\r\n\t\t\t\t\tedge = d;\r\n\t\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (edge == null)\r\n\t\t\tthrow new OGraphException(\"Edge not found between the ougoing edges\");\r\n\r\n\t\tiSourceVertex.setDirty();\r\n\t\tiSourceVertex.save();\r\n\r\n\t\tdocs = iTargetVertex.field(FIELD_IN_EDGES);\r\n\r\n\t\t// REMOVE THE EDGE DOCUMENT FROM THE TARGET VERTEX\r\n\t\tif (docs != null) {\r\n\t\t\tfor (ODocument d : docs)\r\n\t\t\t\tif (d.field(OGraphEdge.IN).equals(iTargetVertex)) {\r\n\t\t\t\t\tdocs.remove(d);\r\n\t\t\t\t}\r\n\t\t}\r\n\r\n\t\tiTargetVertex.setDirty();\r\n\t\tiTargetVertex.save();\r\n\r\n\t\tedge.delete();\r\n\t}","id":75283,"modified_method":"/**\r\n\t * Unlinks all the edges between iSourceVertex and iTargetVertex\r\n\t * \r\n\t * @param iDatabase\r\n\t * @param iSourceVertex\r\n\t * @param iTargetVertex\r\n\t */\r\n\tpublic static void unlink(final ODatabaseGraphTx iDatabase, final ODocument iSourceVertex, final ODocument iTargetVertex) {\r\n\t\tif (iTargetVertex == null)\r\n\t\t\tthrow new IllegalArgumentException(\"Missed the target vertex\");\r\n\r\n\t\tif (iDatabase.existsUserObjectByRID(iSourceVertex.getIdentity())) {\r\n\t\t\t// WORK ALSO WITH IN MEMORY OBJECTS\r\n\r\n\t\t\tfinal OGraphVertex vertex = (OGraphVertex) iDatabase.getUserObjectByRecord(iSourceVertex, null);\r\n\t\t\t// REMOVE THE EDGE OBJECT\r\n\t\t\tif (vertex.outEdges != null && vertex.outEdges.get() != null) {\r\n\t\t\t\tfor (OGraphEdge e : vertex.outEdges.get())\r\n\t\t\t\t\tif (e.getIn().getDocument().equals(iTargetVertex)) {\r\n\t\t\t\t\t\tvertex.outEdges.get().remove(e);\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (iDatabase.existsUserObjectByRID(iTargetVertex.getIdentity())) {\r\n\t\t\t// WORK ALSO WITH IN MEMORY OBJECTS\r\n\r\n\t\t\tfinal OGraphVertex vertex = (OGraphVertex) iDatabase.getUserObjectByRecord(iTargetVertex, null);\r\n\t\t\t// REMOVE THE EDGE OBJECT FROM THE TARGET VERTEX\r\n\t\t\tif (vertex.inEdges != null && vertex.inEdges.get() != null) {\r\n\t\t\t\tfor (OGraphEdge e : vertex.inEdges.get())\r\n\t\t\t\t\tif (e.getOut().getDocument().equals(iSourceVertex)) {\r\n\t\t\t\t\t\tvertex.inEdges.get().remove(e);\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// REMOVE THE EDGE DOCUMENT\r\n\t\tODocument edge = null;\r\n\t\tList<ODocument> docs = iSourceVertex.field(OGraphDatabase.VERTEX_FIELD_OUT_EDGES);\r\n\t\tif (docs != null) {\r\n\t\t\tfor (ODocument d : docs)\r\n\t\t\t\tif (d.field(OGraphDatabase.EDGE_FIELD_IN).equals(iTargetVertex)) {\r\n\t\t\t\t\tdocs.remove(d);\r\n\t\t\t\t\tedge = d;\r\n\t\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (edge == null)\r\n\t\t\tthrow new OGraphException(\"Edge not found between the ougoing edges\");\r\n\r\n\t\tiSourceVertex.setDirty();\r\n\t\tiSourceVertex.save();\r\n\r\n\t\tdocs = iTargetVertex.field(OGraphDatabase.VERTEX_FIELD_IN_EDGES);\r\n\r\n\t\t// REMOVE THE EDGE DOCUMENT FROM THE TARGET VERTEX\r\n\t\tif (docs != null) {\r\n\t\t\tfor (ODocument d : docs)\r\n\t\t\t\tif (d.field(OGraphDatabase.EDGE_FIELD_IN).equals(iTargetVertex)) {\r\n\t\t\t\t\tdocs.remove(d);\r\n\t\t\t\t}\r\n\t\t}\r\n\r\n\t\tiTargetVertex.setDirty();\r\n\t\tiTargetVertex.save();\r\n\r\n\t\tedge.delete();\r\n\t}","commit_id":"b7ceb0a66fb54321009d280fae4a9805d34cd13f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public int getOutEdgeCount() {\r\n\t\tfinal List<ODocument> docs = document.field(FIELD_OUT_EDGES);\r\n\t\treturn docs == null ? 0 : docs.size();\r\n\t}","id":75284,"modified_method":"public int getOutEdgeCount() {\r\n\t\tfinal List<ODocument> docs = document.field(OGraphDatabase.VERTEX_FIELD_OUT_EDGES);\r\n\t\treturn docs == null ? 0 : docs.size();\r\n\t}","commit_id":"b7ceb0a66fb54321009d280fae4a9805d34cd13f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n\t * Returns true if the vertex has at least one incoming edge, otherwise false.\r\n\t */\r\n\tpublic boolean hasInEdges() {\r\n\t\tfinal List<ODocument> docs = document.field(FIELD_IN_EDGES);\r\n\t\treturn docs != null && !docs.isEmpty();\r\n\t}","id":75285,"modified_method":"/**\r\n\t * Returns true if the vertex has at least one incoming edge, otherwise false.\r\n\t */\r\n\tpublic boolean hasInEdges() {\r\n\t\tfinal List<ODocument> docs = document.field(OGraphDatabase.VERTEX_FIELD_IN_EDGES);\r\n\t\treturn docs != null && !docs.isEmpty();\r\n\t}","commit_id":"b7ceb0a66fb54321009d280fae4a9805d34cd13f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OGraphVertex(final ODatabaseGraphTx iDatabase, final String iClassName) {\r\n\t\tsuper(iDatabase, iClassName != null ? iClassName : CLASS_NAME);\r\n\t}","id":75286,"modified_method":"public OGraphVertex(final ODatabaseGraphTx iDatabase, final String iClassName) {\r\n\t\tsuper(iDatabase, iClassName != null ? iClassName : OGraphDatabase.VERTEX_CLASS_NAME);\r\n\t}","commit_id":"b7ceb0a66fb54321009d280fae4a9805d34cd13f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n\t * Returns true if the vertex has at least one outgoing edge, otherwise false.\r\n\t */\r\n\tpublic boolean hasOutEdges() {\r\n\t\tfinal List<ODocument> docs = document.field(FIELD_OUT_EDGES);\r\n\t\treturn docs != null && !docs.isEmpty();\r\n\t}","id":75287,"modified_method":"/**\r\n\t * Returns true if the vertex has at least one outgoing edge, otherwise false.\r\n\t */\r\n\tpublic boolean hasOutEdges() {\r\n\t\tfinal List<ODocument> docs = document.field(OGraphDatabase.VERTEX_FIELD_OUT_EDGES);\r\n\t\treturn docs != null && !docs.isEmpty();\r\n\t}","commit_id":"b7ceb0a66fb54321009d280fae4a9805d34cd13f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public int findInVertex(final OGraphVertex iVertexDocument) {\r\n\t\tfinal List<ODocument> docs = document.field(FIELD_IN_EDGES);\r\n\t\tif (docs == null || docs.size() == 0)\r\n\t\t\treturn -1;\r\n\r\n\t\tfor (int i = 0; i < docs.size(); ++i) {\r\n\t\t\tif (docs.get(i).field(OGraphEdge.IN).equals(iVertexDocument.getDocument()))\r\n\t\t\t\treturn i;\r\n\t\t}\r\n\r\n\t\treturn -1;\r\n\t}","id":75288,"modified_method":"public int findInVertex(final OGraphVertex iVertexDocument) {\r\n\t\tfinal List<ODocument> docs = document.field(OGraphDatabase.VERTEX_FIELD_IN_EDGES);\r\n\t\tif (docs == null || docs.size() == 0)\r\n\t\t\treturn -1;\r\n\r\n\t\tfor (int i = 0; i < docs.size(); ++i) {\r\n\t\t\tif (docs.get(i).field(OGraphDatabase.EDGE_FIELD_IN).equals(iVertexDocument.getDocument()))\r\n\t\t\t\treturn i;\r\n\t\t}\r\n\r\n\t\treturn -1;\r\n\t}","commit_id":"b7ceb0a66fb54321009d280fae4a9805d34cd13f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void invokeBusinessLogic( MessageContext msgContext, MessageContext newMsgContext ) throws AxisFault\n    {\n        String methodName = this.findOperation( msgContext );\n        Class serviceMethodArgType = this.findArgumentClass( methodName );\n\n        SOAPFactory factory = this.getSOAPFactory( msgContext );\n        OMElement msgBodyOm = msgContext.getEnvelope().getBody().getFirstElement();\n\n        String bindingName = this.findBindingName( msgBodyOm );\n        EucalyptusMessage wrappedParam = this.bindMessage( methodName, serviceMethodArgType, msgBodyOm, bindingName );\n\n        HttpRequest httprequest = ( HttpRequest ) msgContext.getProperty( GenericHttpDispatcher.HTTP_REQUEST );\n        if ( httprequest == null )\n        {\n          this.verifyUser( msgContext, wrappedParam );\n        }\n        else\n        {\n          bindingName = httprequest.getBindingName();\n          Policy p = new Policy();\n          newMsgContext.setProperty( RampartMessageData.KEY_RAMPART_POLICY, p );\n          //:: fixes the handling of certain kinds of client brain damage :://\n          if ( httprequest.isPureClient() ) {\n            if ( wrappedParam instanceof ModifyImageAttributeType ) {\n              ModifyImageAttributeType pure = ( ( ModifyImageAttributeType ) wrappedParam );\n              pure.setImageId( pure.getImageId().replaceFirst( \"a\", \"e\" ).toLowerCase( ) );\n            } else if ( wrappedParam instanceof DescribeImageAttributeType ) {\n              DescribeImageAttributeType pure = ( ( DescribeImageAttributeType ) wrappedParam );\n              pure.setImageId( pure.getImageId().replaceFirst( \"^a\", \"e\" ).toLowerCase( ) );\n            } else if ( wrappedParam instanceof ResetImageAttributeType ) {\n              ResetImageAttributeType pure = ( ( ResetImageAttributeType ) wrappedParam );\n              pure.setImageId( pure.getImageId().replaceFirst( \"^a\", \"e\" ).toLowerCase( ) );\n            } else if ( wrappedParam instanceof DescribeImagesType ) {\n              ArrayList<String> strs = Lists.newArrayList();\n              for ( String imgId : ( ( DescribeImagesType ) wrappedParam ).getImagesSet() ) {\n                strs.add( imgId.replaceFirst( \"^a\", \"e\" ).toLowerCase( ) );\n              }\n              ( ( DescribeImagesType ) wrappedParam ).setImagesSet( strs );\n            } else if ( wrappedParam instanceof DeregisterImageType ) {\n              DeregisterImageType pure = ( ( DeregisterImageType ) wrappedParam );\n              pure.setImageId( pure.getImageId().replaceFirst( \"^a\", \"e\" ).toLowerCase( ) );\n            } else if ( wrappedParam instanceof RunInstancesType ) {\n              RunInstancesType pure = ((RunInstancesType) wrappedParam);\n              pure.setImageId( pure.getImageId().replaceFirst( \"^a\", \"e\" ).toLowerCase( ) );\n              pure.setKernelId( pure.getKernelId().replaceFirst( \"^a\", \"e\" ).toLowerCase( )  );\n              pure.setRamdiskId( pure.getRamdiskId().replaceFirst( \"^a\", \"e\" ).toLowerCase( ) );\n            }\n          }\n\n        }\n\n        MuleMessage message = this.invokeService( methodName, wrappedParam );\n\n        if ( message == null )\n            throw new AxisFault( \"Received a NULL response. This is a bug -- it should NEVER happen.\" );\n\n        this.checkException( message );\n\n        if( httprequest != null ) {\n          //:: fixes the handling of certain kinds of client brain damage :://\n          if ( httprequest.isPureClient() ) {\n            if ( message.getPayload() instanceof DescribeImagesResponseType ) {\n              DescribeImagesResponseType purify = ( DescribeImagesResponseType ) message.getPayload();\n              for ( ImageDetails img : purify.getImagesSet() ) {\n                img.setImageId( img.getImageId().replaceFirst(\"^e\",\"a\" ).toLowerCase( ) );\n                if( img.getKernelId() != null ) img.setKernelId( img.getKernelId().replaceFirst(\"^e\",\"a\" ).toLowerCase( ) );\n                if( img.getRamdiskId() != null ) img.setRamdiskId( img.getRamdiskId().replaceFirst(\"^e\",\"a\" ).toLowerCase( ) );\n              }\n            } else if ( message.getPayload() instanceof DescribeInstancesResponseType ) {\n              DescribeInstancesResponseType purify = ( DescribeInstancesResponseType ) message.getPayload();\n              for( ReservationInfoType rsvInfo : purify.getReservationSet() ) {\n                for( RunningInstancesItemType r : rsvInfo.getInstancesSet() ) {\n                  r.setImageId( r.getImageId().replaceFirst( \"^e\", \"a\" ).toLowerCase( ) );\n                  if( r.getKernel() != null ) r.setKernel( r.getKernel().replaceFirst( \"^e\", \"a\" ).toLowerCase( ) );\n                  if( r.getRamdisk() != null ) r.setRamdisk( r.getRamdisk().replaceFirst( \"^e\", \"a\" ).toLowerCase( ) );\n                }\n              }\n            }\n\n          }\n        }\n\n        if ( newMsgContext != null )\n        {\n            SOAPEnvelope envelope = generateMessage( methodName, factory, bindingName, message.getPayload() );\n            newMsgContext.setEnvelope( envelope );\n        }\n\n        newMsgContext.setProperty( Axis2HttpWorker.REAL_HTTP_REQUEST, msgContext.getProperty( Axis2HttpWorker.REAL_HTTP_REQUEST ) );\n        newMsgContext.setProperty( Axis2HttpWorker.REAL_HTTP_RESPONSE, msgContext.getProperty( Axis2HttpWorker.REAL_HTTP_RESPONSE ) );\n\n        LOG.info(\"Returning reply: \" + message.getPayload());\n\n        if(message.getPayload() instanceof WalrusErrorMessageType) {\n            WalrusErrorMessageType errorMessage = (WalrusErrorMessageType) message.getPayload();\n            msgContext.setProperty(Axis2HttpWorker.HTTP_STATUS, errorMessage.getHttpCode());\n            newMsgContext.setProperty(Axis2HttpWorker.HTTP_STATUS, errorMessage.getHttpCode());\n            //This selects the data formatter\n            newMsgContext.setProperty( \"messageType\", \"application/walrus\" );\n            return;\n        }\n\n        Boolean putType = (Boolean) msgContext.getProperty(WalrusProperties.STREAMING_HTTP_PUT);\n        Boolean getType = (Boolean) msgContext.getProperty(WalrusProperties.STREAMING_HTTP_GET);\n\n        if(getType != null || putType != null) {\n            WalrusDataResponseType reply = (WalrusDataResponseType) message.getPayload();\n            AxisHttpResponse response = ( AxisHttpResponse ) msgContext.getProperty( Axis2HttpWorker.REAL_HTTP_RESPONSE );\n            response.addHeader( new BasicHeader( \"Last-Modified\", reply.getLastModified()));\n            response.addHeader( new BasicHeader( \"ETag\", '\\\"' + reply.getEtag() + '\\\"'));\n            if(getType != null) {\n                newMsgContext.setProperty(WalrusProperties.STREAMING_HTTP_GET, getType);\n                WalrusDataRequestType request = (WalrusDataRequestType) wrappedParam;\n                Boolean isCompressed = request.getIsCompressed();\n                if(isCompressed == null)\n                    isCompressed = false;\n                if(isCompressed) {\n                    newMsgContext.setProperty(\"GET_COMPRESSED\", isCompressed);\n                } else {\n                    Long contentLength = reply.getSize();\n                    response.addHeader(new BasicHeader(HTTP.CONTENT_LEN, String.valueOf(contentLength)));\n                }\n                List<MetaDataEntry> metaData = reply.getMetaData();\n                for(MetaDataEntry metaDataEntry: metaData) {\n                    response.addHeader(new BasicHeader(WalrusProperties.AMZ_META_HEADER_PREFIX + metaDataEntry.getName(), metaDataEntry.getValue()));\n                }\n                if(getType.equals(Boolean.TRUE)) {\n                    newMsgContext.setProperty(\"GET_KEY\", request.getBucket() + \".\" + request.getKey());\n                    newMsgContext.setProperty(\"GET_RANDOM_KEY\", request.getRandomKey());\n                }\n                //This selects the data formatter\n                newMsgContext.setProperty( \"messageType\", \"application/walrus\" );\n            } else if(putType != null) {\n                if(reply instanceof PostObjectResponseType) {\n                    PostObjectResponseType postReply = (PostObjectResponseType) reply;\n                    String redirectUrl = postReply.getRedirectUrl();\n                    if(redirectUrl != null) {\n                        response.addHeader(new BasicHeader(\"Location\", redirectUrl));\n                        msgContext.setProperty(Axis2HttpWorker.HTTP_STATUS, HttpStatus.SC_SEE_OTHER);\n                        newMsgContext.setProperty(Axis2HttpWorker.HTTP_STATUS, HttpStatus.SC_SEE_OTHER);\n                        newMsgContext.setProperty( \"messageType\", \"application/walrus\" );\n                    } else {\n                        Integer successCode = postReply.getSuccessCode();\n                        if(successCode != null) {\n                            newMsgContext.setProperty(Axis2HttpWorker.HTTP_STATUS, successCode);\n                            if(successCode == 201) {\n                                return;\n                            } else {\n                                newMsgContext.setProperty( \"messageType\", \"application/walrus\" );\n                                return;\n                            }\n\n                        }\n                    }\n                }\n                response.addHeader(new BasicHeader(HTTP.CONTENT_LEN, String.valueOf(0)));\n            }\n        }\n\n    }","id":75289,"modified_method":"public void invokeBusinessLogic( MessageContext msgContext, MessageContext newMsgContext ) throws AxisFault {\n    String methodName = this.findOperation( msgContext );\n    Class serviceMethodArgType = this.findArgumentClass( methodName );\n\n    SOAPFactory factory = this.getSOAPFactory( msgContext );\n    OMElement msgBodyOm = msgContext.getEnvelope().getBody().getFirstElement();\n\n    String bindingName = this.findBindingName( msgBodyOm );\n    EucalyptusMessage wrappedParam = this.bindMessage( methodName, serviceMethodArgType, msgBodyOm, bindingName );\n\n    HttpRequest httprequest = ( HttpRequest ) msgContext.getProperty( GenericHttpDispatcher.HTTP_REQUEST );\n    if ( httprequest == null ) {\n      this.verifyUser( msgContext, wrappedParam );\n    } else {\n      bindingName = httprequest.getBindingName();\n      Policy p = new Policy();\n      newMsgContext.setProperty( RampartMessageData.KEY_RAMPART_POLICY, p );\n      //:: fixes the handling of certain kinds of client brain damage :://\n      if ( httprequest.isPureClient() ) {\n        if ( wrappedParam instanceof ModifyImageAttributeType ) {\n          ModifyImageAttributeType pure = ( ( ModifyImageAttributeType ) wrappedParam );\n          pure.setImageId( purifyImageIn( pure.getImageId() ) );\n        } else if ( wrappedParam instanceof DescribeImageAttributeType ) {\n          DescribeImageAttributeType pure = ( ( DescribeImageAttributeType ) wrappedParam );\n          pure.setImageId( purifyImageIn( pure.getImageId() ) );\n        } else if ( wrappedParam instanceof ResetImageAttributeType ) {\n          ResetImageAttributeType pure = ( ( ResetImageAttributeType ) wrappedParam );\n          pure.setImageId( purifyImageIn( pure.getImageId() ) );\n        } else if ( wrappedParam instanceof DescribeImagesType ) {\n          ArrayList<String> strs = Lists.newArrayList();\n          for ( String imgId : ( ( DescribeImagesType ) wrappedParam ).getImagesSet() ) {\n            strs.add( purifyImageIn( imgId ) );\n          }\n          ( ( DescribeImagesType ) wrappedParam ).setImagesSet( strs );\n        } else if ( wrappedParam instanceof DeregisterImageType ) {\n          DeregisterImageType pure = ( ( DeregisterImageType ) wrappedParam );\n          pure.setImageId( purifyImageIn( pure.getImageId() ) );\n        } else if ( wrappedParam instanceof RunInstancesType ) {\n          RunInstancesType pure = ( ( RunInstancesType ) wrappedParam );\n          pure.setImageId( purifyImageIn( pure.getImageId() ) );\n          pure.setKernelId( purifyImageIn( pure.getKernelId() ) );\n          pure.setRamdiskId( purifyImageIn( pure.getRamdiskId() ) );\n        }\n      }\n\n    }\n\n    MuleMessage message = this.invokeService( methodName, wrappedParam );\n\n    if ( message == null )\n      throw new AxisFault( \"Received a NULL response. This is a bug -- it should NEVER happen.\" );\n\n    this.checkException( message );\n\n    if ( httprequest != null ) {\n      //:: fixes the handling of certain kinds of client brain damage :://\n      if ( httprequest.isPureClient() ) {\n        if ( message.getPayload() instanceof DescribeImagesResponseType ) {\n          DescribeImagesResponseType purify = ( DescribeImagesResponseType ) message.getPayload();\n          for ( ImageDetails img : purify.getImagesSet() ) {\n            img.setImageId( img.getImageId().replaceFirst( \"^e\", \"a\" ).toLowerCase() );\n            if ( img.getKernelId() != null ) img.setKernelId( img.getKernelId().replaceFirst( \"^e\", \"a\" ).toLowerCase() );\n            if ( img.getRamdiskId() != null ) img.setRamdiskId( img.getRamdiskId().replaceFirst( \"^e\", \"a\" ).toLowerCase() );\n          }\n        } else if ( message.getPayload() instanceof DescribeInstancesResponseType ) {\n          DescribeInstancesResponseType purify = ( DescribeInstancesResponseType ) message.getPayload();\n          for ( ReservationInfoType rsvInfo : purify.getReservationSet() ) {\n            for ( RunningInstancesItemType r : rsvInfo.getInstancesSet() ) {\n              r.setImageId( r.getImageId().replaceFirst( \"^e\", \"a\" ).toLowerCase() );\n              if ( r.getKernel() != null ) r.setKernel( r.getKernel().replaceFirst( \"^e\", \"a\" ).toLowerCase() );\n              if ( r.getRamdisk() != null ) r.setRamdisk( r.getRamdisk().replaceFirst( \"^e\", \"a\" ).toLowerCase() );\n            }\n          }\n        }\n\n      }\n    }\n\n    if ( newMsgContext != null ) {\n      SOAPEnvelope envelope = generateMessage( methodName, factory, bindingName, message.getPayload(), httprequest.getOriginalNamespace() );\n      newMsgContext.setEnvelope( envelope );\n    }\n\n    newMsgContext.setProperty( Axis2HttpWorker.REAL_HTTP_REQUEST, msgContext.getProperty( Axis2HttpWorker.REAL_HTTP_REQUEST ) );\n    newMsgContext.setProperty( Axis2HttpWorker.REAL_HTTP_RESPONSE, msgContext.getProperty( Axis2HttpWorker.REAL_HTTP_RESPONSE ) );\n\n    LOG.info( \"Returning reply: \" + message.getPayload() );\n\n    if ( message.getPayload() instanceof WalrusErrorMessageType ) {\n      WalrusErrorMessageType errorMessage = ( WalrusErrorMessageType ) message.getPayload();\n      msgContext.setProperty( Axis2HttpWorker.HTTP_STATUS, errorMessage.getHttpCode() );\n      newMsgContext.setProperty( Axis2HttpWorker.HTTP_STATUS, errorMessage.getHttpCode() );\n      //This selects the data formatter\n      newMsgContext.setProperty( \"messageType\", \"application/walrus\" );\n      return;\n    }\n\n    Boolean putType = ( Boolean ) msgContext.getProperty( WalrusProperties.STREAMING_HTTP_PUT );\n    Boolean getType = ( Boolean ) msgContext.getProperty( WalrusProperties.STREAMING_HTTP_GET );\n\n    if ( getType != null || putType != null ) {\n      WalrusDataResponseType reply = ( WalrusDataResponseType ) message.getPayload();\n      AxisHttpResponse response = ( AxisHttpResponse ) msgContext.getProperty( Axis2HttpWorker.REAL_HTTP_RESPONSE );\n      response.addHeader( new BasicHeader( \"Last-Modified\", reply.getLastModified() ) );\n      response.addHeader( new BasicHeader( \"ETag\", '\\\"' + reply.getEtag() + '\\\"' ) );\n      if ( getType != null ) {\n        newMsgContext.setProperty( WalrusProperties.STREAMING_HTTP_GET, getType );\n        WalrusDataRequestType request = ( WalrusDataRequestType ) wrappedParam;\n        Boolean isCompressed = request.getIsCompressed();\n        if ( isCompressed == null )\n          isCompressed = false;\n        if ( isCompressed ) {\n          newMsgContext.setProperty( \"GET_COMPRESSED\", isCompressed );\n        } else {\n          Long contentLength = reply.getSize();\n          response.addHeader( new BasicHeader( HTTP.CONTENT_LEN, String.valueOf( contentLength ) ) );\n        }\n        List<MetaDataEntry> metaData = reply.getMetaData();\n        for ( MetaDataEntry metaDataEntry : metaData ) {\n          response.addHeader( new BasicHeader( WalrusProperties.AMZ_META_HEADER_PREFIX + metaDataEntry.getName(), metaDataEntry.getValue() ) );\n        }\n        if ( getType.equals( Boolean.TRUE ) ) {\n          newMsgContext.setProperty( \"GET_KEY\", request.getBucket() + \".\" + request.getKey() );\n          newMsgContext.setProperty( \"GET_RANDOM_KEY\", request.getRandomKey() );\n        }\n        //This selects the data formatter\n        newMsgContext.setProperty( \"messageType\", \"application/walrus\" );\n      } else if ( putType != null ) {\n        if ( reply instanceof PostObjectResponseType ) {\n          PostObjectResponseType postReply = ( PostObjectResponseType ) reply;\n          String redirectUrl = postReply.getRedirectUrl();\n          if ( redirectUrl != null ) {\n            response.addHeader( new BasicHeader( \"Location\", redirectUrl ) );\n            msgContext.setProperty( Axis2HttpWorker.HTTP_STATUS, HttpStatus.SC_SEE_OTHER );\n            newMsgContext.setProperty( Axis2HttpWorker.HTTP_STATUS, HttpStatus.SC_SEE_OTHER );\n            newMsgContext.setProperty( \"messageType\", \"application/walrus\" );\n          } else {\n            Integer successCode = postReply.getSuccessCode();\n            if ( successCode != null ) {\n              newMsgContext.setProperty( Axis2HttpWorker.HTTP_STATUS, successCode );\n              if ( successCode == 201 ) {\n                return;\n              } else {\n                newMsgContext.setProperty( \"messageType\", \"application/walrus\" );\n                return;\n              }\n\n            }\n          }\n        }\n        response.addHeader( new BasicHeader( HTTP.CONTENT_LEN, String.valueOf( 0 ) ) );\n      }\n    }\n\n  }","commit_id":"c97532bc222cb6afe2e7bd4a8f4369b649616c08","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private SOAPEnvelope generateMessage( final String methodName, final SOAPFactory factory, String bindingName, final Object response )\n    {\n        SOAPEnvelope envelope = null;\n        LOG.info( \"[\" + serviceClass.getSimpleName() + \":\" + methodName + \"] Got return type \" + response.getClass().getSimpleName() );\n        if( response instanceof AddClusterResponseType )\n            bindingName = \"msgs_eucalyptus_ucsb_edu\";\n        try\n        {\n            /** construct the response **/\n            envelope = BindingManager.getBinding( bindingName, this.serviceClass ).toEnvelope( factory, response, false );\n        }\n        catch ( JiBXException e )\n        {\n            LOG.error( e, e );\n        }\n        LOG.info( \"[\" + serviceClass.getSimpleName() + \":\" + methodName + \"] Returning message of type \" + response.getClass().getSimpleName() );\n        return envelope;\n    }","id":75290,"modified_method":"private SOAPEnvelope generateMessage( final String methodName, final SOAPFactory factory, String bindingName, final Object response, final String altNs ) {\n    SOAPEnvelope envelope = null;\n    LOG.info( \"[\" + serviceClass.getSimpleName() + \":\" + methodName + \"] Got return type \" + response.getClass().getSimpleName() );\n    if ( response instanceof AddClusterResponseType )\n      bindingName = \"msgs_eucalyptus_ucsb_edu\";\n    try {\n      /** construct the response **/\n      envelope = factory.getDefaultEnvelope();\n      Binding binding = BindingManager.getBinding( bindingName, this.serviceClass );\n      OMElement msgElement = binding.toOM( response, altNs );\n      envelope.getBody().addChild( msgElement );\n    } catch ( JiBXException e ) {\n      LOG.error( e, e );\n    }\n    LOG.info( \"[\" + serviceClass.getSimpleName() + \":\" + methodName + \"] Returning message of type \" + response.getClass().getSimpleName() );\n    return envelope;\n  }","commit_id":"c97532bc222cb6afe2e7bd4a8f4369b649616c08","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void buildRest()\n  {\n    int[] indexes = null;\n    String[] prefixes = null;\n    if ( bindingFactory != null )\n    {\n      String[] nsuris = bindingFactory.getNamespaces();\n      int xsiindex = nsuris.length;\n      while ( --xsiindex >= 0 && !\"http://www.w3.org/2001/XMLSchema-instance\".equals( nsuris[ xsiindex ] ) ) ;\n      // get actual size of index and prefix arrays to be allocated\n      int nscount = 0;\n      int usecount = nscount;\n      if ( xsiindex >= 0 )\n        usecount++;\n      // allocate and initialize the arrays\n      indexes = new int[usecount];\n      prefixes = new String[usecount];\n      if ( xsiindex >= 0 )\n      {\n        indexes[ nscount ] = xsiindex;\n        prefixes[ nscount ] = \"xsi\";\n      }\n    }\n    this.bindingNamespaceIndexes = indexes;\n    this.bindingNamespacePrefixes = prefixes;\n  }","id":75291,"modified_method":"private void buildRest()\n  {\n//:: TODO: chop chop :://\n//    int[] indexes = null;\n//    String[] prefixes = null;\n//    if ( bindingFactory != null )\n//    {\n//      String[] nsuris = bindingFactory.getNamespaces();\n//      int xsiindex = nsuris.length;\n//      while ( --xsiindex >= 0 && !\"http://www.w3.org/2001/XMLSchema-instance\".equals( nsuris[ xsiindex ] ) ) ;\n//      // get actual size of index and prefix arrays to be allocated\n//      int nscount = 0;\n//      int usecount = nscount;\n//      if ( xsiindex >= 0 )\n//        usecount++;\n//      // allocate and initialize the arrays\n//      indexes = new int[usecount];\n//      prefixes = new String[usecount];\n//      if ( xsiindex >= 0 )\n//      {\n//        indexes[ nscount ] = xsiindex;\n//        prefixes[ nscount ] = \"xsi\";\n//      }\n//    }\n//    this.bindingNamespaceIndexes = indexes;\n//    this.bindingNamespacePrefixes = prefixes;\n  }","commit_id":"c97532bc222cb6afe2e7bd4a8f4369b649616c08","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public OMElement toOM( Object param )\n  {\n    return this.toOM( param, OMAbstractFactory.getOMFactory() );\n  }","id":75292,"modified_method":"public OMElement toOM( Object param ) {\n    return toOM( param, null );\n  }","commit_id":"c97532bc222cb6afe2e7bd4a8f4369b649616c08","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public OMElement toOM( Object param, OMFactory factory )\n  {\n    if ( param instanceof IMarshallable )\n    {\n      if ( bindingFactory == null )\n        try\n        {\n          bindingFactory = BindingDirectory.getFactory( this.name, param.getClass() );\n        }\n        catch ( JiBXException e )\n        {\n          LOG.error( e, e );\n          throw new RuntimeException( this.bindingErrorMsg );\n        }\n      return ( mappedChild( param, factory ) );\n    }\n    else if ( param == null )\n      throw new RuntimeException( \"Cannot bind null value\" );\n    else\n      throw new RuntimeException( \"No JiBX <mapping> defined for class \" + param.getClass() );\n  }","id":75293,"modified_method":"public OMElement toOM( Object param, String altNs ) {\n    OMFactory factory = OMAbstractFactory.getOMFactory();\n    if ( param == null )\n      throw new RuntimeException( \"Cannot bind null value\" );\n    else if ( !( param instanceof IMarshallable ) )\n      throw new RuntimeException( \"No JiBX <mapping> defined for class \" + param.getClass() );\n    if ( bindingFactory == null ) {\n      try {\n        bindingFactory = BindingDirectory.getFactory( this.name, param.getClass() );\n      }\n      catch ( JiBXException e ) {\n        LOG.error( e, e );\n        throw new RuntimeException( this.bindingErrorMsg );\n      }\n    }\n\n    IMarshallable mrshable = ( IMarshallable ) param;\n    OMDataSource src = new JiBXDataSource( mrshable, bindingFactory );\n    int index = mrshable.JiBX_getIndex();\n    OMNamespace appns = factory.createOMNamespace( bindingFactory.getElementNamespaces()[ index ], \"\" );\n    OMElement retVal = factory.createOMElement( src, bindingFactory.getElementNames()[ index ], appns );\n    String origNs = retVal.getNamespace().getNamespaceURI();\n    if( altNs != null && !altNs.equals( origNs ) ) {\n      try {\n        ByteArrayOutputStream bos = new ByteArrayOutputStream( );\n        XMLStreamWriter xmlStream = XMLOutputFactory.newInstance().createXMLStreamWriter(bos);\n        retVal.serialize( xmlStream );\n        xmlStream.flush();\n        xmlStream.close();\n        String retString = bos.toString();\n        retString = retString.replaceAll( origNs, altNs );\n        ByteArrayInputStream bis = new ByteArrayInputStream( retString.getBytes( ));\n        StAXOMBuilder stAXOMBuilder = new StAXOMBuilder(bis);\n        retVal = stAXOMBuilder.getDocumentElement();\n      } catch ( XMLStreamException e ) {\n        LOG.error( e, e );\n      }\n    }\n\n    return retVal;\n  }","commit_id":"c97532bc222cb6afe2e7bd4a8f4369b649616c08","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public UserInfo handle(String urlString, String verb, Map<String, String> parameters, Map<String, String> headers ) throws QuerySecurityException\n  {\n    this.checkParameters( parameters );\n\n    URL url = null;\n    try {\n      url = new URL( urlString );\n    } catch ( MalformedURLException e ) {\n      throw new QuerySecurityException( e.getMessage() );\n    }\n    String host = url.getHost();\n    String addr = url.getPath();\n    //:: check the signature :://\n    String sig = parameters.remove( SecurityParameter.Signature.toString() );\n    //:: check the signature version type here :://\n\n\n    String queryId = parameters.get( SecurityParameter.AWSAccessKeyId.toString() );\n    String queryKey = findQueryKey( queryId );\n\n    String paramString = makeSubjectString( parameters );\n    String paramString2 = makePlusSubjectString( parameters );\n    String paramString3 = makeV2SubjectString( verb, host, addr, parameters );\n\n    String authSig = checkSignature( queryKey, paramString );\n    String authSig2 = checkSignature( queryKey, paramString2 );\n\n    String authv2sha1 = checkSignature( queryKey, paramString3 );\n    String authv2sha256 = checkSignature256( queryKey, paramString3 );\n    LOG.info( \"VERSION2-SHA256: \" + authv2sha256 + \" -- \" + sig.replaceAll(\"=\",\"\") );\n    if ( !authSig.equals( sig ) && !authSig2.equals( sig ) && !authv2sha1.equals( sig.replaceAll(\"=\",\"\") ) && !authv2sha256.equals( sig.replaceAll(\"=\",\"\") ) )\n      throw new QuerySecurityException( \"User authentication failed.\" );\n\n    //:: check the timestamp :://\n    Calendar now = Calendar.getInstance();\n    Calendar expires = null;\n    if ( parameters.containsKey( SecurityParameter.Timestamp.toString() ) )\n    {\n      String timestamp = parameters.remove( SecurityParameter.Timestamp.toString() );\n      expires = parseTimestamp( timestamp );\n      expires.add( Calendar.MINUTE, 5 );\n    }\n    else\n    {\n      String exp = parameters.remove( SecurityParameter.Expires.toString() );\n      expires = parseTimestamp( exp );\n    }\n    if ( now.after( expires ) )\n      throw new QuerySecurityException( \"Message has expired.\" );\n\n    for ( Axis2QueryDispatcher.OperationParameter op : Axis2QueryDispatcher.OperationParameter.values() ) parameters.remove( op.name() );\n    parameters.remove( Axis2QueryDispatcher.RequiredQueryParams.SignatureVersion.toString() );\n    parameters.remove( Axis2QueryDispatcher.RequiredQueryParams.Version.toString() );\n    parameters.remove( \"SignatureMethod\" );\n\n    return findUserId( parameters.remove( SecurityParameter.AWSAccessKeyId.toString() ) );\n  }","id":75294,"modified_method":"public UserInfo handle(String urlString, String verb, Map<String, String> parameters, Map<String, String> headers ) throws QuerySecurityException\n  {\n    this.checkParameters( parameters );\n\n    URL url = null;\n    try {\n      url = new URL( urlString );\n    } catch ( MalformedURLException e ) {\n      throw new QuerySecurityException( e.getMessage() );\n    }\n    String host = url.getHost();\n    String addr = url.getPath();\n    //:: check the signature :://\n    String sig = parameters.remove( SecurityParameter.Signature.toString() );\n    //:: check the signature version type here :://\n\n\n    String queryId = parameters.get( SecurityParameter.AWSAccessKeyId.toString() );\n    String queryKey = findQueryKey( queryId );\n\n    String paramString = makeSubjectString( parameters );\n    String paramString2 = makePlusSubjectString( parameters );\n    String paramString3 = makeV2SubjectString( verb, host, addr, parameters );\n\n    String headerHost = headers.get( \"Host\" );\n    if( headerHost != null && headerHost.contains( \":\" ) ) {\n      headerHost = headerHost.split( \":\" )[0];\n    }\n    String paramString4 = makeV2SubjectString( verb, headerHost, addr, parameters );\n\n    String authSig = checkSignature( queryKey, paramString );\n    String authSig2 = checkSignature( queryKey, paramString2 );\n\n    String authv2sha1 = checkSignature( queryKey, paramString3 );\n    String authv2sha256 = checkSignature256( queryKey, paramString3 );\n\n    String authv2sha256header = checkSignature256( queryKey, paramString4 );\n\n    LOG.info( \"VERSION2-SHA256:        \" + authv2sha256 + \" -- \" + sig.replaceAll(\"=\",\"\") );\n    LOG.info( \"VERSION2-SHA256-HEADER: \" + authv2sha256header + \" -- \" + sig.replaceAll(\"=\",\"\") );\n\n    if ( !authSig.equals( sig ) && !authSig2.equals( sig ) && !authv2sha1.equals( sig.replaceAll(\"=\",\"\") ) && !authv2sha256.equals( sig.replaceAll(\"=\",\"\") ) && !authv2sha256header.equals( sig.replaceAll(\"=\",\"\") ) )\n      throw new QuerySecurityException( \"User authentication failed.\" );\n\n    //:: check the timestamp :://\n    Calendar now = Calendar.getInstance();\n    Calendar expires = null;\n    if ( parameters.containsKey( SecurityParameter.Timestamp.toString() ) )\n    {\n      String timestamp = parameters.remove( SecurityParameter.Timestamp.toString() );\n      expires = parseTimestamp( timestamp );\n      expires.add( Calendar.MINUTE, 5 );\n    }\n    else\n    {\n      String exp = parameters.remove( SecurityParameter.Expires.toString() );\n      expires = parseTimestamp( exp );\n    }\n    if ( now.after( expires ) )\n      throw new QuerySecurityException( \"Message has expired.\" );\n\n    for ( Axis2QueryDispatcher.OperationParameter op : Axis2QueryDispatcher.OperationParameter.values() ) parameters.remove( op.name() );\n    parameters.remove( Axis2QueryDispatcher.RequiredQueryParams.SignatureVersion.toString() );\n    parameters.remove( Axis2QueryDispatcher.RequiredQueryParams.Version.toString() );\n    parameters.remove( \"SignatureMethod\" );\n\n    return findUserId( parameters.remove( SecurityParameter.AWSAccessKeyId.toString() ) );\n  }","commit_id":"c97532bc222cb6afe2e7bd4a8f4369b649616c08","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public AxisOperation findOperation( AxisService service, MessageContext messageContext ) throws AxisFault {\n    if ( !( this instanceof RESTfulDispatcher ) ) return null;\n\n    RESTfulDispatcher dispatcher = ( RESTfulDispatcher ) this;\n\n    HttpRequest httpRequest = ( HttpRequest ) messageContext.getProperty( HTTP_REQUEST );\n    if ( httpRequest == null ) return null; // bail out to avoid messing with the message context.\n\n    //:: test if this dispatcher accepts this request type :://\n    if ( !dispatcher.accepts( httpRequest, messageContext ) ) return null;\n\n    String maybeVersion = httpRequest.getParameters().get( Axis2QueryDispatcher.RequiredQueryParams.Version.toString() );\n    String nameSpace = dispatcher.getNamespace();\n    if ( maybeVersion != null )\n      nameSpace = nameSpace.replaceAll( dispatcher.getBinding().getName(), maybeVersion );\n    //:: set the operation name... this looks ugly... sigh :://\n      String operationName;\n      try {\n        operationName = dispatcher.getOperation( httpRequest, messageContext );\n      } catch(Exception ex) {\n          throw new AxisFault(\"Could not process operation\\n\" + ex.getMessage());\n      }\n    httpRequest.setOperation( operationName );\n    httpRequest.setBindingName( BindingUtil.sanitizeNamespace( dispatcher.getNamespace() ) );\n\n    QuerySecurityHandler securityHandler = dispatcher.getSecurityHandler();\n    UserInfo user = securityHandler.authenticate( httpRequest );\n\n    //:: setup & verify the operation  :://\n    if ( httpRequest.getOperation() == null )\n      throw new AxisFault( \"Protocol failure: Could not identify the operation component of the request.\" ); //this is a dispatcher failure, shouldn't have \"accept()\"ed the request\n\n    //:: find the operation :://\n    AxisOperation operation = service.getOperationByAction( httpRequest.getOperation().replaceAll(\"/*\",\"\") );\n    if ( operation == null )\n      throw new AxisFault( \"Failed to process the request: Operation doesnt exist: \" + httpRequest.getOperation() ); //this is a user failure, incorrectly specified Operation perhaps?\n\n    //:: consume the request and turn it into a SOAP envelope :://\n    QueryBinding binding = dispatcher.getBinding();\n    OMElement msg = binding.bind( user, httpRequest, messageContext );\n    messageContext.getEnvelope().getBody().addChild( msg );\n\n    //:: massage rampart so it doesnt interfere :://\n    Policy p = new Policy();\n    messageContext.setProperty( RampartMessageData.KEY_RAMPART_POLICY, p );\n\n    return operation;\n  }","id":75295,"modified_method":"public AxisOperation findOperation( AxisService service, MessageContext messageContext ) throws AxisFault {\n    if ( !( this instanceof RESTfulDispatcher ) ) return null;\n\n    RESTfulDispatcher dispatcher = ( RESTfulDispatcher ) this;\n\n    HttpRequest httpRequest = ( HttpRequest ) messageContext.getProperty( HTTP_REQUEST );\n    if ( httpRequest == null ) return null; // bail out to avoid messing with the message context.\n\n    //:: test if this dispatcher accepts this request type :://\n    if ( !dispatcher.accepts( httpRequest, messageContext ) ) return null;\n\n    String maybeVersion = httpRequest.getParameters().get( Axis2QueryDispatcher.RequiredQueryParams.Version.toString() );\n    String nameSpace = dispatcher.getNamespace();\n    if ( maybeVersion != null )\n      nameSpace = nameSpace.replaceAll( dispatcher.getBinding().getName(), maybeVersion );\n    httpRequest.setOriginalNamespace( nameSpace );\n    //:: set the operation name... this looks ugly... sigh :://\n      String operationName;\n      try {\n        operationName = dispatcher.getOperation( httpRequest, messageContext );\n      } catch(Exception ex) {\n          throw new AxisFault(\"Could not process operation\\n\" + ex.getMessage());\n      }\n    httpRequest.setOperation( operationName );\n    httpRequest.setBindingName( BindingUtil.sanitizeNamespace( dispatcher.getNamespace() ) );\n\n    QuerySecurityHandler securityHandler = dispatcher.getSecurityHandler();\n    UserInfo user = securityHandler.authenticate( httpRequest );\n\n    //:: setup & verify the operation  :://\n    if ( httpRequest.getOperation() == null )\n      throw new AxisFault( \"Protocol failure: Could not identify the operation component of the request.\" ); //this is a dispatcher failure, shouldn't have \"accept()\"ed the request\n\n    //:: find the operation :://\n    AxisOperation operation = service.getOperationByAction( httpRequest.getOperation().replaceAll(\"/*\",\"\") );\n    if ( operation == null )\n      throw new AxisFault( \"Failed to process the request: Operation doesnt exist: \" + httpRequest.getOperation() ); //this is a user failure, incorrectly specified Operation perhaps?\n\n    //:: consume the request and turn it into a SOAP envelope :://\n    QueryBinding binding = dispatcher.getBinding();\n    OMElement msg = binding.bind( user, httpRequest, messageContext );\n    messageContext.getEnvelope().getBody().addChild( msg );\n\n    //:: massage rampart so it doesnt interfere :://\n    Policy p = new Policy();\n    messageContext.setProperty( RampartMessageData.KEY_RAMPART_POLICY, p );\n\n    return operation;\n  }","commit_id":"c97532bc222cb6afe2e7bd4a8f4369b649616c08","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"protected void processFilter(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tFilterChain filterChain)\n\t\tthrows Exception {\n\n\t\tboolean etag = ParamUtil.getBoolean(request, _ETAG, true);\n\n\t\tif (etag) {\n\t\t\tByteBufferServletResponse byteBufferResponse =\n\t\t\t\tnew ByteBufferServletResponse(response);\n\n\t\t\tprocessFilter(\n\t\t\t\tETagFilter.class, request, byteBufferResponse, filterChain);\n\n\t\t\tif (!ETagUtil.processETag(request, response, byteBufferResponse)) {\n\t\t\t\tServletResponseUtil.write(response, byteBufferResponse);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tprocessFilter(ETagFilter.class, request, response, filterChain);\n\t\t}\n\t}","id":75296,"modified_method":"protected void processFilter(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tFilterChain filterChain)\n\t\tthrows Exception {\n\n\t\tboolean etag = ParamUtil.getBoolean(request, _ETAG, true);\n\n\t\tif (etag) {\n\t\t\tByteBufferServletResponse byteBufferResponse =\n\t\t\t\tnew ByteBufferServletResponse(response);\n\n\t\t\tprocessFilter(\n\t\t\t\tETagFilter.class, request, byteBufferResponse, filterChain);\n\n\t\t\tif (!ETagUtil.processETag(request, response, byteBufferResponse)) {\n\t\t\t\tServletResponseUtil.write(\n\t\t\t\t\tresponse, byteBufferResponse.getByteBuffer());\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tprocessFilter(ETagFilter.class, request, response, filterChain);\n\t\t}\n\t}","commit_id":"06ca3f644e8011f77176ba324946700252b4f08e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void write(HttpServletResponse response, File file)\n\t\tthrows IOException {\n\n\t\tFileInputStream fileInputStream = new FileInputStream(file);\n\n\t\tFileChannel fileChannel = fileInputStream.getChannel();\n\n\t\ttry {\n\t\t\tint contentLength = (int)fileChannel.size();\n\n\t\t\tresponse.setContentLength(contentLength);\n\n\t\t\tfileChannel.transferTo(\n\t\t\t\t0, contentLength,\n\t\t\t\tChannels.newChannel(response.getOutputStream()));\n\t\t}\n\t\tfinally {\n\t\t\tfileChannel.close();\n\t\t}\n\t}","id":75297,"modified_method":"public static void write(HttpServletResponse response, File file)\n\t\tthrows IOException {\n\n\t\tif (response instanceof StringServletResponse) {\n\t\t\tStringServletResponse targetStringResponse =\n\t\t\t\t(StringServletResponse)response;\n\t\t\tString content = FileUtil.read(file);\n\t\t\ttargetStringResponse.setString(content);\n\t\t}\n\t\telse if (response instanceof ByteBufferServletResponse) {\n\t\t\tByteBufferServletResponse targetByteBufferResponse =\n\t\t\t\t(ByteBufferServletResponse)response;\n\t\t\tByteBuffer byteBuffer = ByteBuffer.wrap(FileUtil.getBytes(file));\n\t\t\ttargetByteBufferResponse.setByteBuffer(byteBuffer);\n\t\t}\n\t\telse {\n\t\t\tFileInputStream fileInputStream = new FileInputStream(file);\n\n\t\t\tFileChannel fileChannel = fileInputStream.getChannel();\n\n\t\t\ttry {\n\t\t\t\tint contentLength = (int)fileChannel.size();\n\n\t\t\t\tresponse.setContentLength(contentLength);\n\n\t\t\t\tfileChannel.transferTo(\n\t\t\t\t\t0, contentLength,\n\t\t\t\t\tChannels.newChannel(response.getOutputStream()));\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tfileChannel.close();\n\t\t\t}\n\t\t}\n\t}","commit_id":"06ca3f644e8011f77176ba324946700252b4f08e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void write(\n\t\t\tHttpServletResponse response, byte[] bytes, int offset,\n\t\t\tint contentLength)\n\t\tthrows IOException {\n\n\t\ttry {\n\n\t\t\t// LEP-3122\n\n\t\t\tif (!response.isCommitted()) {\n\n\t\t\t\t// LEP-536\n\n\t\t\t\tif (contentLength == 0) {\n\t\t\t\t\tcontentLength = bytes.length;\n\t\t\t\t}\n\n\t\t\t\tresponse.setContentLength(contentLength);\n\n\t\t\t\tServletOutputStream servletOutputStream =\n\t\t\t\t\tresponse.getOutputStream();\n\n\t\t\t\tservletOutputStream.write(bytes, offset, contentLength);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (ioe instanceof SocketException ||\n\t\t\t\tioe.getClass().getName().equals(_CLIENT_ABORT_EXCEPTION)) {\n\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(ioe);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow ioe;\n\t\t\t}\n\t\t}\n\t}","id":75298,"modified_method":"public static void write(\n\t\t\tHttpServletResponse response, byte[] bytes, int offset,\n\t\t\tint contentLength)\n\t\tthrows IOException {\n\n\t\ttry {\n\n\t\t\t// LEP-3122\n\n\t\t\tif (!response.isCommitted()) {\n\n\t\t\t\t// LEP-536\n\n\t\t\t\tif (contentLength == 0) {\n\t\t\t\t\tcontentLength = bytes.length;\n\t\t\t\t}\n\n\t\t\t\tresponse.setContentLength(contentLength);\n\n\t\t\t\tif (response instanceof ByteBufferServletResponse) {\n\t\t\t\t\tByteBufferServletResponse targetByteBufferResponse =\n\t\t\t\t\t\t(ByteBufferServletResponse)response;\n\t\t\t\t\ttargetByteBufferResponse.setByteBuffer(\n\t\t\t\t\t\tByteBuffer.wrap(bytes, offset, contentLength));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tServletOutputStream servletOutputStream =\n\t\t\t\t\t\tresponse.getOutputStream();\n\n\t\t\t\t\tservletOutputStream.write(bytes, offset, contentLength);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (ioe instanceof SocketException ||\n\t\t\t\tioe.getClass().getName().equals(_CLIENT_ABORT_EXCEPTION)) {\n\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(ioe);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow ioe;\n\t\t\t}\n\t\t}\n\t}","commit_id":"06ca3f644e8011f77176ba324946700252b4f08e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void write(HttpServletResponse response, String s)\n\t\tthrows IOException {\n\n\t\twrite(response, s.getBytes(StringPool.UTF8));\n\t}","id":75299,"modified_method":"public static void write(HttpServletResponse response, String s)\n\t\tthrows IOException {\n\n\t\tif (response instanceof StringServletResponse) {\n\t\t\tStringServletResponse targetStringResponse =\n\t\t\t\t(StringServletResponse)response;\n\t\t\ttargetStringResponse.setString(s);\n\t\t}\n\t\telse {\n\t\t\tByteBuffer byteBuffer =\n\t\t\t\tCharsetEncoderUtil.encode(StringPool.UTF8, s);\n\t\t\twrite(response, byteBuffer);\n\t\t}\n\t}","commit_id":"06ca3f644e8011f77176ba324946700252b4f08e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void write(\n\t\t\tHttpServletResponse response, ByteBuffer byteBuffer)\n\t\tthrows IOException {\n\n\t\twrite(\n\t\t\tresponse, byteBuffer.array(), byteBuffer.position(),\n\t\t\tbyteBuffer.limit());\n\t}","id":75300,"modified_method":"public static void write(\n\t\t\tHttpServletResponse response, ByteBuffer byteBuffer)\n\t\tthrows IOException {\n\n\t\tif (response instanceof ByteBufferServletResponse) {\n\t\t\tByteBufferServletResponse targetByteBufferResponse =\n\t\t\t\t(ByteBufferServletResponse)response;\n\t\t\ttargetByteBufferResponse.setByteBuffer(byteBuffer);\n\t\t}\n\t\telse {\n\t\t\twrite(\n\t\t\t\tresponse, byteBuffer.array(), byteBuffer.position(),\n\t\t\t\tbyteBuffer.limit());\n\t\t}\n\t}","commit_id":"06ca3f644e8011f77176ba324946700252b4f08e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public CacheResponseData(StringServletResponse stringResponse) {\n\t\tif (stringResponse.isCalledGetOutputStream()) {\n\t\t\tUnsyncByteArrayOutputStream unsyncByteArrayOutputStream =\n\t\t\t\tstringResponse.getUnsyncByteArrayOutputStream();\n\n\t\t\t_content = unsyncByteArrayOutputStream.unsafeGetByteArray();\n\t\t\t_contentLength = unsyncByteArrayOutputStream.size();\n\t\t}\n\t\telse {\n\t\t\tString content = stringResponse.getString();\n\n\t\t\t_content = content.getBytes();\n\t\t\t_contentLength = _content.length;\n\t\t}\n\n\t\t_contentType = stringResponse.getContentType();\n\t\t_headers = stringResponse.getHeaders();\n\t}","id":75301,"modified_method":"public CacheResponseData(StringServletResponse stringResponse) {\n\t\tif (stringResponse.isCalledGetOutputStream()) {\n\t\t\tUnsyncByteArrayOutputStream unsyncByteArrayOutputStream =\n\t\t\t\tstringResponse.getUnsyncByteArrayOutputStream();\n\n\t\t\t_content = unsyncByteArrayOutputStream.unsafeGetByteArray();\n\t\t\t_contentLength = unsyncByteArrayOutputStream.size();\n\t\t}\n\t\telse {\n\t\t\tString content = stringResponse.getString();\n\n\t\t\tByteBuffer contentByteBuffer = CharsetEncoderUtil.encode(\n\t\t\t\tStringPool.UTF8, content);\n\t\t\t_content = contentByteBuffer.array();\n\t\t\t_contentLength = contentByteBuffer.limit();\n\t\t}\n\n\t\t_contentType = stringResponse.getContentType();\n\t\t_headers = stringResponse.getHeaders();\n\t}","commit_id":"e19c7a674bd9a3fb048d542be5959ce76dd23648","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void service(\n\t\t\tHttpServletRequest request, HttpServletResponse response)\n\t\tthrows IOException {\n\n\t\tMap<String, String[]> parameterMap = request.getParameterMap();\n\n\t\tif (parameterMap.size() == 0) {\n\t\t\tresponse.sendError(HttpServletResponse.SC_BAD_REQUEST);\n\n\t\t\treturn;\n\t\t}\n\n\t\tbyte[] bytes = null;\n\n\t\tFile cacheFile = getCacheFile(request);\n\n\t\tif (cacheFile.exists()) {\n\t\t\tbytes = FileUtil.getBytes(cacheFile);\n\t\t}\n\t\telse {\n\t\t\tStringBundler sb = new StringBundler(parameterMap.size());\n\n\t\t\tfor (String modulePath : parameterMap.keySet()) {\n\t\t\t\tFile file = getFile(modulePath);\n\n\t\t\t\tif (file != null) {\n\t\t\t\t\tString moduleContent = FileUtil.read(file);\n\n\t\t\t\t\tsb.append(moduleContent);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString content = sb.toString();\n\n\t\t\tif (Validator.isNotNull(content)) {\n\t\t\t\tbytes = content.getBytes();\n\n\t\t\t\tFileUtil.write(cacheFile, bytes);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbytes = new byte[0];\n\t\t\t}\n\t\t}\n\n\t\tString contentType = ContentTypes.TEXT_JAVASCRIPT;\n\n\t\tString firstModulePath =\n\t\t\t(String)request.getParameterNames().nextElement();\n\n\t\tString extension = FileUtil.getExtension(firstModulePath);\n\n\t\tif (extension.equalsIgnoreCase(_CSS_EXTENSION)) {\n\t\t\tcontentType = ContentTypes.TEXT_CSS;\n\t\t}\n\n\t\tresponse.setContentType(contentType);\n\n\t\tServletResponseUtil.write(response, bytes);\n\t}","id":75302,"modified_method":"public void service(\n\t\t\tHttpServletRequest request, HttpServletResponse response)\n\t\tthrows IOException {\n\n\t\tMap<String, String[]> parameterMap = request.getParameterMap();\n\n\t\tif (parameterMap.size() == 0) {\n\t\t\tresponse.sendError(HttpServletResponse.SC_BAD_REQUEST);\n\n\t\t\treturn;\n\t\t}\n\n\t\tbyte[] bytes = null;\n\n\t\tFile cacheFile = getCacheFile(request);\n\n\t\tif (cacheFile.exists()) {\n\t\t\tbytes = FileUtil.getBytes(cacheFile);\n\t\t}\n\t\telse {\n\t\t\tStringBundler sb = new StringBundler(parameterMap.size());\n\n\t\t\tfor (String modulePath : parameterMap.keySet()) {\n\t\t\t\tFile file = getFile(modulePath);\n\n\t\t\t\tif (file != null) {\n\t\t\t\t\tString moduleContent = FileUtil.read(file);\n\n\t\t\t\t\tsb.append(moduleContent);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString content = sb.toString();\n\n\t\t\tif (Validator.isNotNull(content)) {\n\t\t\t\tByteBuffer contentByteBuffer = CharsetEncoderUtil.encode(\n\t\t\t\t\tStringPool.UTF8, content);\n\t\t\t\tbytes = contentByteBuffer.array();\n\t\t\t\tint length = contentByteBuffer.limit();\n\n\t\t\t\tFileUtil.write(cacheFile, bytes, 0, length);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbytes = new byte[0];\n\t\t\t}\n\t\t}\n\n\t\tString contentType = ContentTypes.TEXT_JAVASCRIPT;\n\n\t\tString firstModulePath =\n\t\t\t(String)request.getParameterNames().nextElement();\n\n\t\tString extension = FileUtil.getExtension(firstModulePath);\n\n\t\tif (extension.equalsIgnoreCase(_CSS_EXTENSION)) {\n\t\t\tcontentType = ContentTypes.TEXT_CSS;\n\t\t}\n\n\t\tresponse.setContentType(contentType);\n\n\t\tServletResponseUtil.write(response, bytes);\n\t}","commit_id":"e19c7a674bd9a3fb048d542be5959ce76dd23648","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void processFilter(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tFilterChain filterChain)\n\t\tthrows Exception {\n\n\t\tif (isStrip(request) && !isInclude(request) &&\n\t\t\t!isAlreadyFiltered(request)) {\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\tString completeURL = HttpUtil.getCompleteURL(request);\n\n\t\t\t\t_log.debug(\"Stripping \" + completeURL);\n\t\t\t}\n\n\t\t\trequest.setAttribute(SKIP_FILTER, Boolean.TRUE);\n\n\t\t\tStringServletResponse stringResponse = new StringServletResponse(\n\t\t\t\tresponse);\n\n\t\t\tprocessFilter(\n\t\t\t\tStripFilter.class, request, stringResponse, filterChain);\n\n\t\t\tString contentType = GetterUtil.getString(\n\t\t\t\tstringResponse.getContentType()).toLowerCase();\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Stripping content of type \" + contentType);\n\t\t\t}\n\n\t\t\tresponse.setContentType(contentType);\n\n\t\t\tif (contentType.indexOf(\"text/\") != -1) {\n\t\t\t\tbyte[] oldByteArray = null;\n\t\t\t\tint length = 0;\n\n\t\t\t\tif (stringResponse.isCalledGetOutputStream()) {\n\t\t\t\t\tUnsyncByteArrayOutputStream unsyncByteArrayOutputStream =\n\t\t\t\t\t\tstringResponse.getUnsyncByteArrayOutputStream();\n\n\t\t\t\t\toldByteArray =\n\t\t\t\t\t\tunsyncByteArrayOutputStream.unsafeGetByteArray();\n\t\t\t\t\tlength = unsyncByteArrayOutputStream.size();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString content = stringResponse.getString();\n\n\t\t\t\t\toldByteArray = content.getBytes(StringPool.UTF8);\n\t\t\t\t\tlength = oldByteArray.length;\n\t\t\t\t}\n\n\t\t\t\tUnsyncByteArrayOutputStream outputStream =\n\t\t\t\t\tnew UnsyncByteArrayOutputStream(\n\t\t\t\t\t\t(int)(length * _COMPRESSION_RATE));\n\n\t\t\t\tstrip(oldByteArray, length, outputStream);\n\n\t\t\t\tServletResponseUtil.write(\n\t\t\t\t\tresponse, outputStream.unsafeGetByteArray(),\n\t\t\t\t\toutputStream.size());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tServletResponseUtil.write(response, stringResponse);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\tString completeURL = HttpUtil.getCompleteURL(request);\n\n\t\t\t\t_log.debug(\"Not stripping \" + completeURL);\n\t\t\t}\n\n\t\t\tprocessFilter(StripFilter.class, request, response, filterChain);\n\t\t}\n\t}","id":75303,"modified_method":"protected void processFilter(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tFilterChain filterChain)\n\t\tthrows Exception {\n\n\t\tif (isStrip(request) && !isInclude(request) &&\n\t\t\t!isAlreadyFiltered(request)) {\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\tString completeURL = HttpUtil.getCompleteURL(request);\n\n\t\t\t\t_log.debug(\"Stripping \" + completeURL);\n\t\t\t}\n\n\t\t\trequest.setAttribute(SKIP_FILTER, Boolean.TRUE);\n\n\t\t\tStringServletResponse stringResponse = new StringServletResponse(\n\t\t\t\tresponse);\n\n\t\t\tprocessFilter(\n\t\t\t\tStripFilter.class, request, stringResponse, filterChain);\n\n\t\t\tString contentType = GetterUtil.getString(\n\t\t\t\tstringResponse.getContentType()).toLowerCase();\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Stripping content of type \" + contentType);\n\t\t\t}\n\n\t\t\tresponse.setContentType(contentType);\n\n\t\t\tif (contentType.indexOf(\"text/\") != -1) {\n\t\t\t\tbyte[] oldByteArray = null;\n\t\t\t\tint length = 0;\n\n\t\t\t\tif (stringResponse.isCalledGetOutputStream()) {\n\t\t\t\t\tUnsyncByteArrayOutputStream unsyncByteArrayOutputStream =\n\t\t\t\t\t\tstringResponse.getUnsyncByteArrayOutputStream();\n\n\t\t\t\t\toldByteArray =\n\t\t\t\t\t\tunsyncByteArrayOutputStream.unsafeGetByteArray();\n\t\t\t\t\tlength = unsyncByteArrayOutputStream.size();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString content = stringResponse.getString();\n\n\t\t\t\t\tByteBuffer contentByteBuffer =\n\t\t\t\t\t\tCharsetEncoderUtil.encode(StringPool.UTF8, content);\n\t\t\t\t\toldByteArray = contentByteBuffer.array();\n\t\t\t\t\tlength = contentByteBuffer.limit();\n\t\t\t\t}\n\n\t\t\t\tUnsyncByteArrayOutputStream outputStream =\n\t\t\t\t\tnew UnsyncByteArrayOutputStream(\n\t\t\t\t\t\t(int)(length * _COMPRESSION_RATE));\n\n\t\t\t\tstrip(oldByteArray, length, outputStream);\n\n\t\t\t\tServletResponseUtil.write(\n\t\t\t\t\tresponse, outputStream.unsafeGetByteArray(),\n\t\t\t\t\toutputStream.size());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tServletResponseUtil.write(response, stringResponse);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\tString completeURL = HttpUtil.getCompleteURL(request);\n\n\t\t\t\t_log.debug(\"Not stripping \" + completeURL);\n\t\t\t}\n\n\t\t\tprocessFilter(StripFilter.class, request, response, filterChain);\n\t\t}\n\t}","commit_id":"e19c7a674bd9a3fb048d542be5959ce76dd23648","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected int processCSS(\n\t\t\tbyte[] oldByteArray, OutputStream newBytes, int currentIndex)\n\t\tthrows IOException {\n\n\t\tint beginIndex = currentIndex + _MARKER_STYLE_OPEN.length + 1;\n\n\t\tint endIndex = KMPSearch.search(\n\t\t\toldByteArray, beginIndex, _MARKER_STYLE_CLOSE,\n\t\t\t_MARKER_STYLE_CLOSE_NEXTS);\n\n\t\tif (endIndex == -1) {\n\t\t\t_log.error(\"Missing <\/style>\");\n\n\t\t\treturn currentIndex + 1;\n\t\t}\n\n\t\tint newBeginIndex = endIndex + _MARKER_STYLE_CLOSE.length;\n\n\t\tnewBeginIndex += countContinuousWhiteSpace(oldByteArray, newBeginIndex);\n\n\t\tString content = new String(\n\t\t\toldByteArray, beginIndex, endIndex - beginIndex);\n\n\t\tif (Validator.isNull(content)) {\n\t\t\treturn newBeginIndex;\n\t\t}\n\n\t\tString minifiedContent = content;\n\n\t\tif (PropsValues.MINIFIER_INLINE_CONTENT_CACHE_SIZE > 0) {\n\t\t\tString key = String.valueOf(content.hashCode());\n\n\t\t\tminifiedContent = _minifierCache.get(key);\n\n\t\t\tif (minifiedContent == null) {\n\t\t\t\tminifiedContent = MinifierUtil.minifyCss(content);\n\n\t\t\t\tboolean skipCache = false;\n\n\t\t\t\tfor (String skipCss :\n\t\t\t\t\t\tPropsValues.MINIFIER_INLINE_CONTENT_CACHE_SKIP_CSS) {\n\n\t\t\t\t\tif (minifiedContent.contains(skipCss)) {\n\t\t\t\t\t\tskipCache = true;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!skipCache) {\n\t\t\t\t\t_minifierCache.put(key, minifiedContent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (Validator.isNull(minifiedContent)) {\n\t\t\treturn newBeginIndex;\n\t\t}\n\n\t\tnewBytes.write(_STYLE_TYPE_CSS);\n\t\tnewBytes.write(minifiedContent.getBytes());\n\t\tnewBytes.write(_MARKER_STYLE_CLOSE);\n\n\t\treturn newBeginIndex;\n\t}","id":75304,"modified_method":"protected int processCSS(\n\t\t\tbyte[] oldByteArray, OutputStream newBytes, int currentIndex)\n\t\tthrows IOException {\n\n\t\tint beginIndex = currentIndex + _MARKER_STYLE_OPEN.length + 1;\n\n\t\tint endIndex = KMPSearch.search(\n\t\t\toldByteArray, beginIndex, _MARKER_STYLE_CLOSE,\n\t\t\t_MARKER_STYLE_CLOSE_NEXTS);\n\n\t\tif (endIndex == -1) {\n\t\t\t_log.error(\"Missing <\/style>\");\n\n\t\t\treturn currentIndex + 1;\n\t\t}\n\n\t\tint newBeginIndex = endIndex + _MARKER_STYLE_CLOSE.length;\n\n\t\tnewBeginIndex += countContinuousWhiteSpace(oldByteArray, newBeginIndex);\n\n\t\tString content = new String(\n\t\t\toldByteArray, beginIndex, endIndex - beginIndex);\n\n\t\tif (Validator.isNull(content)) {\n\t\t\treturn newBeginIndex;\n\t\t}\n\n\t\tString minifiedContent = content;\n\n\t\tif (PropsValues.MINIFIER_INLINE_CONTENT_CACHE_SIZE > 0) {\n\t\t\tString key = String.valueOf(content.hashCode());\n\n\t\t\tminifiedContent = _minifierCache.get(key);\n\n\t\t\tif (minifiedContent == null) {\n\t\t\t\tminifiedContent = MinifierUtil.minifyCss(content);\n\n\t\t\t\tboolean skipCache = false;\n\n\t\t\t\tfor (String skipCss :\n\t\t\t\t\t\tPropsValues.MINIFIER_INLINE_CONTENT_CACHE_SKIP_CSS) {\n\n\t\t\t\t\tif (minifiedContent.contains(skipCss)) {\n\t\t\t\t\t\tskipCache = true;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!skipCache) {\n\t\t\t\t\t_minifierCache.put(key, minifiedContent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (Validator.isNull(minifiedContent)) {\n\t\t\treturn newBeginIndex;\n\t\t}\n\n\t\tByteBuffer contentByteBuffer = CharsetEncoderUtil.encode(\n\t\t\tStringPool.UTF8, minifiedContent);\n\t\tnewBytes.write(_STYLE_TYPE_CSS);\n\t\tnewBytes.write(contentByteBuffer.array(), 0, contentByteBuffer.limit());\n\t\tnewBytes.write(_MARKER_STYLE_CLOSE);\n\n\t\treturn newBeginIndex;\n\t}","commit_id":"e19c7a674bd9a3fb048d542be5959ce76dd23648","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected int processJavaScript(\n\t\t\tbyte[] oldByteArray, OutputStream newBytes, int currentIndex,\n\t\t\tbyte[] openTag)\n\t\tthrows IOException {\n\n\t\tint beginIndex = currentIndex + openTag.length + 1;\n\n\t\tint endIndex = KMPSearch.search(\n\t\t\toldByteArray, beginIndex, _MARKER_SCRIPT_CLOSE,\n\t\t\t_MARKER_SCRIPT_CLOSE_NEXTS);\n\n\t\tif (endIndex == -1) {\n\t\t\t_log.error(\"Missing <\/script>\");\n\n\t\t\treturn currentIndex + 1;\n\t\t}\n\n\t\tint newBeginIndex = endIndex + _MARKER_SCRIPT_CLOSE.length;\n\n\t\tnewBeginIndex += countContinuousWhiteSpace(oldByteArray, newBeginIndex);\n\n\t\tString content = new String(\n\t\t\toldByteArray, beginIndex, endIndex - beginIndex);\n\n\t\tif (Validator.isNull(content)) {\n\t\t\treturn newBeginIndex;\n\t\t}\n\n\t\tString minifiedContent = content;\n\n\t\tif (PropsValues.MINIFIER_INLINE_CONTENT_CACHE_SIZE > 0) {\n\t\t\tString key = String.valueOf(content.hashCode());\n\n\t\t\tminifiedContent = _minifierCache.get(key);\n\n\t\t\tif (minifiedContent == null) {\n\t\t\t\tminifiedContent = MinifierUtil.minifyJavaScript(content);\n\n\t\t\t\tboolean skipCache = false;\n\n\t\t\t\tfor (String skipJavaScript :\n\t\t\t\t\t\tPropsValues.\n\t\t\t\t\t\t\tMINIFIER_INLINE_CONTENT_CACHE_SKIP_JAVASCRIPT) {\n\n\t\t\t\t\tif (minifiedContent.contains(skipJavaScript)) {\n\t\t\t\t\t\tskipCache = true;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!skipCache) {\n\t\t\t\t\t_minifierCache.put(key, minifiedContent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (Validator.isNull(minifiedContent)) {\n\t\t\treturn newBeginIndex;\n\t\t}\n\n\t\tnewBytes.write(_SCRIPT_TYPE_JAVASCRIPT);\n\t\tnewBytes.write(_CDATA_OPEN);\n\t\tnewBytes.write(minifiedContent.getBytes());\n\t\tnewBytes.write(_CDATA_CLOSE);\n\t\tnewBytes.write(_MARKER_SCRIPT_CLOSE);\n\n\t\treturn newBeginIndex;\n\t}","id":75305,"modified_method":"protected int processJavaScript(\n\t\t\tbyte[] oldByteArray, OutputStream newBytes, int currentIndex,\n\t\t\tbyte[] openTag)\n\t\tthrows IOException {\n\n\t\tint beginIndex = currentIndex + openTag.length + 1;\n\n\t\tint endIndex = KMPSearch.search(\n\t\t\toldByteArray, beginIndex, _MARKER_SCRIPT_CLOSE,\n\t\t\t_MARKER_SCRIPT_CLOSE_NEXTS);\n\n\t\tif (endIndex == -1) {\n\t\t\t_log.error(\"Missing <\/script>\");\n\n\t\t\treturn currentIndex + 1;\n\t\t}\n\n\t\tint newBeginIndex = endIndex + _MARKER_SCRIPT_CLOSE.length;\n\n\t\tnewBeginIndex += countContinuousWhiteSpace(oldByteArray, newBeginIndex);\n\n\t\tString content = new String(\n\t\t\toldByteArray, beginIndex, endIndex - beginIndex);\n\n\t\tif (Validator.isNull(content)) {\n\t\t\treturn newBeginIndex;\n\t\t}\n\n\t\tString minifiedContent = content;\n\n\t\tif (PropsValues.MINIFIER_INLINE_CONTENT_CACHE_SIZE > 0) {\n\t\t\tString key = String.valueOf(content.hashCode());\n\n\t\t\tminifiedContent = _minifierCache.get(key);\n\n\t\t\tif (minifiedContent == null) {\n\t\t\t\tminifiedContent = MinifierUtil.minifyJavaScript(content);\n\n\t\t\t\tboolean skipCache = false;\n\n\t\t\t\tfor (String skipJavaScript :\n\t\t\t\t\t\tPropsValues.\n\t\t\t\t\t\t\tMINIFIER_INLINE_CONTENT_CACHE_SKIP_JAVASCRIPT) {\n\n\t\t\t\t\tif (minifiedContent.contains(skipJavaScript)) {\n\t\t\t\t\t\tskipCache = true;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!skipCache) {\n\t\t\t\t\t_minifierCache.put(key, minifiedContent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (Validator.isNull(minifiedContent)) {\n\t\t\treturn newBeginIndex;\n\t\t}\n\n\t\tByteBuffer contentByteBuffer = CharsetEncoderUtil.encode(\n\t\t\tStringPool.UTF8, minifiedContent);\n\t\tnewBytes.write(_SCRIPT_TYPE_JAVASCRIPT);\n\t\tnewBytes.write(_CDATA_OPEN);\n\t\tnewBytes.write(contentByteBuffer.array(), 0, contentByteBuffer.limit());\n\t\tnewBytes.write(_CDATA_CLOSE);\n\t\tnewBytes.write(_MARKER_SCRIPT_CLOSE);\n\n\t\treturn newBeginIndex;\n\t}","commit_id":"e19c7a674bd9a3fb048d542be5959ce76dd23648","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static byte[] getBytes(String s) {\n        return s.getBytes(charset);\n    }","id":75306,"modified_method":"public static byte[] getBytes(String s) {\n        return charset.encode(s).array();\n    }","commit_id":"7f9371728959bf4262d7ca94ae9c3ade86601ddb","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private TurnType attachKeepLeftInfoAndLanes(boolean leftSide, RouteSegmentResult prev, RouteSegmentResult rr, TurnType t) {\n\t\t// keep left/right\n\t\tint[] lanes =  null;\n\t\tboolean kl = false;\n\t\tboolean kr = false;\n\t\tList<RouteSegmentResult> attachedRoutes = rr.getAttachedRoutes(rr.getStartPointIndex());\n\t\tint ls = prev.getObject().getLanes();\n\t\tint left = 0;\n\t\tint right = 0;\n\t\tboolean speak = highwayLowEnd(prev.getObject().getHighway()) || highwayLowEnd(rr.getObject().getHighway());\n\t\tif (attachedRoutes != null) {\n\t\t\tfor (RouteSegmentResult rs : attachedRoutes) {\n\t\t\t\tdouble ex = MapUtils.degreesDiff(rs.getBearingBegin(), rr.getBearingBegin());\n\t\t\t\tdouble mpi = Math.abs(MapUtils.degreesDiff(prev.getBearingEnd(), rs.getBearingBegin()));\n\t\t\t\tif ((ex < TURN_DEGREE_MIN || mpi < TURN_DEGREE_MIN) && ex >= 0) {\n\t\t\t\t\tkl = true;\n\t\t\t\t\tint lns = rs.getObject().getLanes();\n\t\t\t\t\tif (lns > 0) {\n\t\t\t\t\t\tright += lns;\n\t\t\t\t\t}\n\t\t\t\t\tspeak = speak || !highwayLowEnd(rs.getObject().getHighway());\n\t\t\t\t} else if ((ex > -TURN_DEGREE_MIN || mpi < TURN_DEGREE_MIN) && ex <= 0) {\n\t\t\t\t\tkr = true;\n\t\t\t\t\tint lns = rs.getObject().getLanes();\n\t\t\t\t\tif (lns > 0) {\n\t\t\t\t\t\tleft += lns;\n\t\t\t\t\t}\n\t\t\t\t\tspeak = speak || !highwayLowEnd(rs.getObject().getHighway());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(kr && left == 0) {\n\t\t\tleft = 1;\n\t\t} else if(kl && right == 0) {\n\t\t\tright = 1;\n\t\t}\n\t\tint current = rr.getObject().getLanes();\n\t\tif (current <= 0) {\n\t\t\tcurrent = 1;\n\t\t}\n\t\tif(ls >= 0 /*&& current + left + right >= ls*/){\n\t\t\tlanes = new int[current + left + right];\n\t\t\tls = current + left + right;\n\t\t\tfor(int it=0; it< ls; it++) {\n\t\t\t\tif(it < left || it >= left + current) {\n\t\t\t\t\tlanes[it] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tlanes[it] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (kl) {\n\t\t\tt = TurnType.valueOf(TurnType.KL, leftSide);\n\t\t\tt.setSkipToSpeak(!speak);\n\t\t} else if(kr){\n\t\t\tt = TurnType.valueOf(TurnType.KR, leftSide);\n\t\t\tt.setSkipToSpeak(!speak);\n\t\t}\n\t\tif (t != null && lanes != null) {\n\t\t\tt.setLanes(lanes);\n\t\t}\n\t\treturn t;\n\t}","id":75307,"modified_method":"private TurnType attachKeepLeftInfoAndLanes(boolean leftSide, RouteSegmentResult prev, RouteSegmentResult rr, TurnType t) {\n\t\t// keep left/right\n\t\tint[] lanes =  null;\n\t\tboolean kl = false;\n\t\tboolean kr = false;\n\t\tList<RouteSegmentResult> attachedRoutes = rr.getAttachedRoutes(rr.getStartPointIndex());\n\t\tint ls = prev.getObject().getLanes();\n\t\tint left = 0;\n\t\tint right = 0;\n\t\tboolean speak = false;\n\t\tint speakPriority = Math.max(highwaySpeakPriority(prev.getObject().getHighway()), highwaySpeakPriority(rr.getObject().getHighway()));\n\t\tif (attachedRoutes != null) {\n\t\t\tfor (RouteSegmentResult rs : attachedRoutes) {\n\t\t\t\tdouble ex = MapUtils.degreesDiff(rs.getBearingBegin(), rr.getBearingBegin());\n\t\t\t\tdouble mpi = Math.abs(MapUtils.degreesDiff(prev.getBearingEnd(), rs.getBearingBegin()));\n\t\t\t\tint rsSpeakPriority = highwaySpeakPriority(rs.getObject().getHighway());\n\t\t\t\tif (rsSpeakPriority != MAX_SPEAK_PRIORITY || speakPriority == MAX_SPEAK_PRIORITY) {\n\t\t\t\t\tif ((ex < TURN_DEGREE_MIN || mpi < TURN_DEGREE_MIN) && ex >= 0) {\n\t\t\t\t\t\tkl = true;\n\t\t\t\t\t\tint lns = rs.getObject().getLanes();\n\t\t\t\t\t\tif (lns > 0) {\n\t\t\t\t\t\t\tright += lns;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tspeak = speak || rsSpeakPriority <= speakPriority;\n\t\t\t\t\t} else if ((ex > -TURN_DEGREE_MIN || mpi < TURN_DEGREE_MIN) && ex <= 0) {\n\t\t\t\t\t\tkr = true;\n\t\t\t\t\t\tint lns = rs.getObject().getLanes();\n\t\t\t\t\t\tif (lns > 0) {\n\t\t\t\t\t\t\tleft += lns;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tspeak = speak || rsSpeakPriority <= speakPriority;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(kr && left == 0) {\n\t\t\tleft = 1;\n\t\t} else if(kl && right == 0) {\n\t\t\tright = 1;\n\t\t}\n\t\tint current = rr.getObject().getLanes();\n\t\tif (current <= 0) {\n\t\t\tcurrent = 1;\n\t\t}\n\t\tif(ls >= 0 /*&& current + left + right >= ls*/){\n\t\t\tlanes = new int[current + left + right];\n\t\t\tls = current + left + right;\n\t\t\tfor(int it=0; it< ls; it++) {\n\t\t\t\tif(it < left || it >= left + current) {\n\t\t\t\t\tlanes[it] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tlanes[it] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (kl) {\n\t\t\tt = TurnType.valueOf(TurnType.KL, leftSide);\n\t\t\tt.setSkipToSpeak(!speak);\n\t\t} else if(kr){\n\t\t\tt = TurnType.valueOf(TurnType.KR, leftSide);\n\t\t\tt.setSkipToSpeak(!speak);\n\t\t}\n\t\tif (t != null && lanes != null) {\n\t\t\tt.setLanes(lanes);\n\t\t}\n\t\treturn t;\n\t}","commit_id":"6ffaaa8bec727a59318453b6b251a5987809107d","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public double directionRoute(int startPoint, boolean plus) {\n\t\tint x = getPoint31XTile(startPoint);\n\t\tint y = getPoint31YTile(startPoint);\n\t\tint nx = startPoint;\n\t\tint px = x;\n\t\tint py = y;\n\t\tdouble total = 0;\n\t\tdo {\n\t\t\tif (plus) {\n\t\t\t\tnx++;\n\t\t\t\tif (nx >= getPointsLength()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnx--;\n\t\t\t\tif (nx < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpx = getPoint31XTile(nx);\n\t\t\tpy = getPoint31YTile(nx);\n\t\t\t// translate into meters\n\t\t\ttotal += Math.abs(px - x) * 0.011d + Math.abs(py - y) * 0.01863d;\n\t\t} while (total < 70);\n\t\treturn -Math.atan2( x - px, y - py );\n\t}","id":75308,"modified_method":"public double directionRoute(int startPoint, boolean plus) {\n\t\tint x = getPoint31XTile(startPoint);\n\t\tint y = getPoint31YTile(startPoint);\n\t\tint nx = startPoint;\n\t\tint px = x;\n\t\tint py = y;\n\t\tdouble total = 0;\n\t\tdo {\n\t\t\tif (plus) {\n\t\t\t\tnx++;\n\t\t\t\tif (nx >= getPointsLength()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnx--;\n\t\t\t\tif (nx < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpx = getPoint31XTile(nx);\n\t\t\tpy = getPoint31YTile(nx);\n\t\t\t// translate into meters\n\t\t\ttotal += Math.abs(px - x) * 0.011d + Math.abs(py - y) * 0.01863d;\n\t\t\t// Victor : the problem to put more than 5 meters that BinaryRoutePlanner will treat\n\t\t\t// 2 consequent Turn Right as UT and here 2 points will have same turn angle\n\t\t\t// So it should be fix in both places\n\t\t} while (total < 5);\n\t\treturn -Math.atan2( x - px, y - py );\n\t}","commit_id":"6ffaaa8bec727a59318453b6b251a5987809107d","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void hideAll() {\n        int rowIndex = 0;\n        while (rowIndex < graph.getNodeRows().size()) {\n            Node node = commitNodeInRow(rowIndex);\n            if (node != null) {\n                NewGraphFragment fragment = fragmentGenerator.getMaximumDownFragment(node);\n                if (fragment != null) {\n                    hide(fragment);\n                }\n            }\n            rowIndex++;\n        }\n    }","id":75309,"modified_method":"public void hideAll() {\n        int rowIndex = 0;\n        while (rowIndex < graph.getNodeRows().size()) {\n            Node node = commitNodeInRow(rowIndex);\n            if (node != null) {\n                NewGraphFragment fragment = fragmentGenerator.getMaximumDownFragment(node);\n                if (fragment != null) {\n                    hide(fragment);\n                }\n            }\n            rowIndex++;\n            if (rowIndex % 100 == 0) {\n                System.out.println(rowIndex);\n            }\n        }\n    }","commit_id":"b683fd6092c335f1394c6ed1096c3d1d87233c28","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n    public NewGraphFragment relateFragment(@NotNull GraphElement graphElement) {\n        Node node = graphElement.getNode();\n        if (node != null) {\n            Edge edge = getHideEdge(node);\n            if (edge != null) {\n                NewGraphFragment fragment = hideFragments.get(edge);\n                assert fragment != null;\n                return fragment;\n            } else {\n                return getFragment(node);\n            }\n        } else {\n            Edge edge = graphElement.getEdge();\n            if (edge.getType() == Edge.Type.HIDE_FRAGMENT) {\n                NewGraphFragment fragment = hideFragments.get(edge);\n                assert fragment != null;\n                return fragment;\n            } else {\n                return getFragment(edge.getUpNode());\n            }\n        }\n    }","id":75310,"modified_method":"@Nullable\n    public NewGraphFragment relateFragment(@NotNull GraphElement graphElement) {\n        Node node = graphElement.getNode();\n        if (node != null) {\n            Edge edge = getHideEdge(node);\n            if (edge != null) {\n                NewGraphFragment fragment = hideFragments.get(edge);\n                assert fragment != null;\n                return fragment;\n            } else {\n                NewGraphFragment fragment = getFragment(node);\n                if (fragment != null && fragment.getDownNode().getRowIndex() >= node.getRowIndex()) {\n                    return fragment;\n                } else {\n                    return null;\n                }\n            }\n        } else {\n            Edge edge = graphElement.getEdge();\n            if (edge.getType() == Edge.Type.HIDE_FRAGMENT) {\n                NewGraphFragment fragment = hideFragments.get(edge);\n                assert fragment != null;\n                return fragment;\n            } else {\n                NewGraphFragment fragment = getFragment(edge.getUpNode());\n                if (fragment != null && fragment.getDownNode().getRowIndex() >= edge.getDownNode().getRowIndex()) {\n                    return fragment;\n                } else {\n                    return null;\n                }\n            }\n        }\n    }","commit_id":"b683fd6092c335f1394c6ed1096c3d1d87233c28","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void update(AnActionEvent e) {\n    if (!myView.isSingleToolInSelection()) {\n      e.getPresentation().setEnabled(false);\n      return;\n    }\n\n    //noinspection ConstantConditions\n    final @NotNull InspectionTool tool = myView.getTree().getSelectedTool();\n    final QuickFixAction[] quickFixes = myView.getProvider().getQuickFixes(tool, myView.getTree());\n    if (quickFixes == null || quickFixes.length == 0) {\n      e.getPresentation().setEnabled(false);\n      return;\n    }\n\n    e.getPresentation().setEnabled(!ActionGroupUtil.isGroupEmpty(getFixes(quickFixes), e));\n  }","id":75311,"modified_method":"public void update(AnActionEvent e) {\n    if (!myView.isSingleToolInSelection()) {\n      e.getPresentation().setEnabled(false);\n      return;\n    }\n\n    //noinspection ConstantConditions\n    final @NotNull InspectionTool tool = myView.getTree().getSelectedTool();\n    final InspectionRVContentProvider provider = myView.getProvider();\n    if (provider.isContentLoaded()) {\n      final QuickFixAction[] quickFixes = provider.getQuickFixes(tool, myView.getTree());\n      if (quickFixes == null || quickFixes.length == 0) {\n        e.getPresentation().setEnabled(false);\n        return;\n      }\n      e.getPresentation().setEnabled(!ActionGroupUtil.isGroupEmpty(getFixes(quickFixes), e));\n    }\n  }","commit_id":"078bd71e2b2274435547102056744e2f728101b3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n    final InspectionTool tool = myView.getTree().getSelectedTool();\n    assert tool != null;\n    ActionGroup fixes = getFixes(myView.getProvider().getQuickFixes(tool, myView.getTree()));\n    DataContext dataContext = e.getDataContext();\n    final ListPopup popup = JBPopupFactory.getInstance()\n      .createActionGroupPopup(InspectionsBundle.message(\"inspection.tree.popup.title\"),\n                              fixes,\n                              dataContext,\n                              JBPopupFactory.ActionSelectionAid.SPEEDSEARCH,\n                              false);\n    InspectionResultsView.showPopup(e, popup);\n  }","id":75312,"modified_method":"public void actionPerformed(AnActionEvent e) {\n    final InspectionTool tool = myView.getTree().getSelectedTool();\n    assert tool != null;\n    final QuickFixAction[] quickFixes = myView.getProvider().getQuickFixes(tool, myView.getTree());\n    if (quickFixes == null || quickFixes.length == 0) {\n      Messages.showInfoMessage(myView, \"There are no applicable quickfixes\", \"Nothing found to fix\");\n      return;\n    }\n    ActionGroup fixes = getFixes(quickFixes);\n    DataContext dataContext = e.getDataContext();\n    final ListPopup popup = JBPopupFactory.getInstance()\n      .createActionGroupPopup(InspectionsBundle.message(\"inspection.tree.popup.title\"),\n                              fixes,\n                              dataContext,\n                              JBPopupFactory.ActionSelectionAid.SPEEDSEARCH,\n                              false);\n    InspectionResultsView.showPopup(e, popup);\n  }","commit_id":"078bd71e2b2274435547102056744e2f728101b3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static LocalQuickFix[] getQuickFixes(final GenericDomValue element, PsiReference reference) {\n    final List<LocalQuickFix> result = new SmartList<LocalQuickFix>();\n    final Converter converter = WrappingConverter.getDeepestConverter(element.getConverter(), element);\n    if (converter instanceof ResolvingConverter) {\n      final ResolvingConverter resolvingConverter = (ResolvingConverter)converter;\n      ContainerUtil\n        .addAll(result, resolvingConverter.getQuickFixes(new ConvertContextImpl(DomManagerImpl.getDomInvocationHandler(element))));\n    }\n    if (reference instanceof LocalQuickFixProvider) {\n      ContainerUtil.addAll(result, ((LocalQuickFixProvider)reference).getQuickFixes());\n    }\n    return result.toArray(new LocalQuickFix[result.size()]);\n  }","id":75313,"modified_method":"private static LocalQuickFix[] getQuickFixes(final GenericDomValue element, PsiReference reference) {\n    final List<LocalQuickFix> result = new SmartList<LocalQuickFix>();\n    final Converter converter = WrappingConverter.getDeepestConverter(element.getConverter(), element);\n    if (converter instanceof ResolvingConverter) {\n      final ResolvingConverter resolvingConverter = (ResolvingConverter)converter;\n      ContainerUtil\n        .addAll(result, resolvingConverter.getQuickFixes(new ConvertContextImpl(DomManagerImpl.getDomInvocationHandler(element))));\n    }\n    if (reference instanceof LocalQuickFixProvider) {\n      final LocalQuickFix[] localQuickFixes = ((LocalQuickFixProvider)reference).getQuickFixes();\n      if (localQuickFixes != null) {\n        ContainerUtil.addAll(result, localQuickFixes);\n      }\n    }\n    return result.isEmpty() ? LocalQuickFix.EMPTY_ARRAY : result.toArray(new LocalQuickFix[result.size()]);\n  }","commit_id":"ea7b27ca314864fadf434222e32813f108ba97c7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkExtendableClassConverter(final GenericAttributeValue clazzAttributeValue) {\n    assert clazzAttributeValue.getConverter() instanceof ExtendableClassConverter :\n        \"wrong converter \" + clazzAttributeValue.getParent();\n\n    final XmlElement xmlElement = DomUtil.getValueElement(clazzAttributeValue);\n    if (xmlElement == null) {\n      return;\n    }\n\n    final PsiReference[] psiReferences = xmlElement.getReferences();\n    for (final PsiReference psiReference : psiReferences) {\n      final PsiElement resolveElement = psiReference.resolve();\n      if (resolveElement != null &&\n          resolveElement instanceof PsiClass) {\n        return;\n      }\n    }\n\n    final String[] referenceTypesUserData = clazzAttributeValue.getUserData(ExtendableClassConverter.REFERENCES_TYPES);\n    final String referenceTypes = referenceTypesUserData != null ?\n                                  StringUtil.join(referenceTypesUserData, \"|\") :\n                                  StrutsBundle.message(\"dom.extendable.class.converter.type.class\");\n\n    final String message = StrutsBundle.message(\"dom.extendable.class.converter.cannot.resolve\",\n                                                referenceTypes,\n                                                clazzAttributeValue.getStringValue());\n\n    // merge all available QuickFixes (create class/package(s)..)\n    LocalQuickFix[] quickFixes = LocalQuickFix.EMPTY_ARRAY;\n    for (final PsiReference psiReference : psiReferences) {\n      if (psiReference instanceof LocalQuickFixProvider) {\n        quickFixes = ArrayUtil.mergeArrays(((LocalQuickFixProvider) psiReference).getQuickFixes(), quickFixes,\n                                           LocalQuickFix.class);\n      }\n    }\n\n    holder.createProblem(clazzAttributeValue,\n                         HighlightSeverity.ERROR,\n                         message, quickFixes);\n\n  }","id":75314,"modified_method":"private void checkExtendableClassConverter(final GenericAttributeValue clazzAttributeValue) {\n    final XmlElement xmlElement = DomUtil.getValueElement(clazzAttributeValue);\n    if (xmlElement == null) {\n      return;\n    }\n\n    final PsiReference[] psiReferences = xmlElement.getReferences();\n    for (final PsiReference psiReference : psiReferences) {\n      final PsiElement resolveElement = psiReference.resolve();\n      if (resolveElement instanceof PsiClass) {\n        return;\n      }\n    }\n\n    final String[] referenceTypesUserData = clazzAttributeValue.getUserData(ExtendableClassConverter.REFERENCES_TYPES);\n    final String referenceTypes = referenceTypesUserData != null ?\n                                  StringUtil.join(referenceTypesUserData, \"|\") :\n                                  StrutsBundle.message(\"dom.extendable.class.converter.type.class\");\n\n    final String message = StrutsBundle.message(\"dom.extendable.class.converter.cannot.resolve\",\n                                                referenceTypes,\n                                                clazzAttributeValue.getStringValue());\n\n    // merge all available QuickFixes (create class/package(s)..)\n    LocalQuickFix[] quickFixes = LocalQuickFix.EMPTY_ARRAY;\n    for (final PsiReference psiReference : psiReferences) {\n      if (psiReference instanceof LocalQuickFixProvider) {\n        final LocalQuickFix[] fixes = ((LocalQuickFixProvider) psiReference).getQuickFixes();\n        if (fixes != null) {\n          quickFixes = ArrayUtil.mergeArrays(fixes, quickFixes, LocalQuickFix.class);\n        }\n      }\n    }\n\n    holder.createProblem(clazzAttributeValue, message, quickFixes);\n  }","commit_id":"9018c12cdcfdb9352015881393b771a4f6740891","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public String[] getFileNames(\n\t\t\tlong companyId, long repositoryId, String dirName)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<String> fileNames = new ArrayList<String>();\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = getRootNode(session, companyId);\n\t\t\tNode repositoryNode = getFolderNode(rootNode, repositoryId);\n\t\t\tNode dirNode = repositoryNode.getNode(dirName);\n\n\t\t\tNodeIterator itr = dirNode.getNodes();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tNode node = (Node)itr.next();\n\n\t\t\t\tif (node.getPrimaryNodeType().getName().equals(\n\t\t\t\t\t\tJCRConstants.NT_FILE)) {\n\n\t\t\t\t\tfileNames.add(dirName + \"/\" + node.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (PathNotFoundException pnfe) {\n\t\t\tthrow new NoSuchDirectoryException(dirName);\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow new SystemException(re);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\n\t\treturn fileNames.toArray(new String[fileNames.size()]);\n\t}","id":75315,"modified_method":"public String[] getFileNames(\n\t\t\tlong companyId, long repositoryId, String dirName)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<String> fileNames = new ArrayList<String>();\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = getRootNode(session, companyId);\n\t\t\tNode repositoryNode = getFolderNode(rootNode, repositoryId);\n\t\t\tNode dirNode = repositoryNode.getNode(dirName);\n\n\t\t\tNodeIterator itr = dirNode.getNodes();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tNode node = (Node)itr.next();\n\n\t\t\t\tNodeType primaryNodeType = node.getPrimaryNodeType();\n\n\t\t\t\tString primaryNodeTypeName = primaryNodeType.getName();\n\n\t\t\t\tif (primaryNodeTypeName.equals(JCRConstants.NT_FILE)) {\n\t\t\t\t\tfileNames.add(dirName + \"/\" + node.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (PathNotFoundException pnfe) {\n\t\t\tthrow new NoSuchDirectoryException(dirName);\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow new SystemException(re);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\n\t\treturn fileNames.toArray(new String[fileNames.size()]);\n\t}","commit_id":"5d538b5767d059d5c50024550b66fa14ffeebc50","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteFile(\n\t\t\tlong companyId, String portletId, long repositoryId,\n\t\t\tString fileName)\n\t\tthrows PortalException, SystemException {\n\n\t\tSession session = null;\n\n\t\t// A bug in Jackrabbit requires us to create a dummy node and delete the\n\t\t// version tree manually to successfully delete a file\n\n\t\t// Create a dummy node\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = getRootNode(session, companyId);\n\t\t\tNode repositoryNode = getFolderNode(rootNode, repositoryId);\n\t\t\tNode fileNode = repositoryNode.getNode(fileName);\n\t\t\tNode contentNode = fileNode.getNode(JCRConstants.JCR_CONTENT);\n\n\t\t\tcontentNode.checkout();\n\n\t\t\tcontentNode.setProperty(JCRConstants.JCR_MIME_TYPE, \"text/plain\");\n\t\t\tcontentNode.setProperty(JCRConstants.JCR_DATA, \"\");\n\t\t\tcontentNode.setProperty(\n\t\t\t\tJCRConstants.JCR_LAST_MODIFIED, Calendar.getInstance());\n\n\t\t\tsession.save();\n\n\t\t\tVersion version = contentNode.checkin();\n\n\t\t\tcontentNode.getVersionHistory().addVersionLabel(\n\t\t\t\tversion.getName(), \"0.0\", false);\n\t\t}\n\t\tcatch (PathNotFoundException pnfe) {\n\t\t\tthrow new NoSuchFileException(fileName);\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow new SystemException(re);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\n\t\t// Delete version tree\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = getRootNode(session, companyId);\n\t\t\tNode repositoryNode = getFolderNode(rootNode, repositoryId);\n\t\t\tNode fileNode = repositoryNode.getNode(fileName);\n\t\t\tNode contentNode = fileNode.getNode(JCRConstants.JCR_CONTENT);\n\n\t\t\tVersionHistory versionHistory = contentNode.getVersionHistory();\n\n\t\t\tVersionIterator itr = versionHistory.getAllVersions();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tVersion version = itr.nextVersion();\n\n\t\t\t\tif (itr.getPosition() == itr.getSize()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!StringUtils.equals(\n\t\t\t\t\t\t\tJCRConstants.JCR_ROOT_VERSION, version.getName())) {\n\n\t\t\t\t\t\tversionHistory.removeVersion(version.getName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsession.save();\n\t\t}\n\t\tcatch (PathNotFoundException pnfe) {\n\t\t\tthrow new NoSuchFileException(fileName);\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow new SystemException(re);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\n\t\t// Delete file\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = getRootNode(session, companyId);\n\t\t\tNode repositoryNode = getFolderNode(rootNode, repositoryId);\n\t\t\tNode fileNode = repositoryNode.getNode(fileName);\n\n\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\t\tFileModel.class);\n\n\t\t\tFileModel fileModel = new FileModel();\n\n\t\t\tfileModel.setCompanyId(companyId);\n\t\t\tfileModel.setFileName(fileName);\n\t\t\tfileModel.setPortletId(portletId);\n\t\t\tfileModel.setRepositoryId(repositoryId);\n\n\t\t\tindexer.delete(fileModel);\n\n\t\t\tfileNode.remove();\n\n\t\t\tsession.save();\n\t\t}\n\t\tcatch (PathNotFoundException pnfe) {\n\t\t\tthrow new NoSuchFileException(fileName);\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow new SystemException(re);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\t}","id":75316,"modified_method":"public void deleteFile(\n\t\t\tlong companyId, String portletId, long repositoryId,\n\t\t\tString fileName)\n\t\tthrows PortalException, SystemException {\n\n\t\tSession session = null;\n\n\t\t// A bug in Jackrabbit requires us to create a dummy node and delete the\n\t\t// version tree manually to successfully delete a file\n\n\t\t// Create a dummy node\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = getRootNode(session, companyId);\n\t\t\tNode repositoryNode = getFolderNode(rootNode, repositoryId);\n\t\t\tNode fileNode = repositoryNode.getNode(fileName);\n\t\t\tNode contentNode = fileNode.getNode(JCRConstants.JCR_CONTENT);\n\n\t\t\tcontentNode.checkout();\n\n\t\t\tcontentNode.setProperty(JCRConstants.JCR_MIME_TYPE, \"text/plain\");\n\t\t\tcontentNode.setProperty(JCRConstants.JCR_DATA, \"\");\n\t\t\tcontentNode.setProperty(\n\t\t\t\tJCRConstants.JCR_LAST_MODIFIED, Calendar.getInstance());\n\n\t\t\tsession.save();\n\n\t\t\tVersion version = contentNode.checkin();\n\n\t\t\tVersionHistory versionHistory = contentNode.getVersionHistory();\n\n\t\t\tversionHistory.addVersionLabel(version.getName(), \"0.0\", false);\n\t\t}\n\t\tcatch (PathNotFoundException pnfe) {\n\t\t\tthrow new NoSuchFileException(fileName);\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow new SystemException(re);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\n\t\t// Delete version tree\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = getRootNode(session, companyId);\n\t\t\tNode repositoryNode = getFolderNode(rootNode, repositoryId);\n\t\t\tNode fileNode = repositoryNode.getNode(fileName);\n\t\t\tNode contentNode = fileNode.getNode(JCRConstants.JCR_CONTENT);\n\n\t\t\tVersionHistory versionHistory = contentNode.getVersionHistory();\n\n\t\t\tVersionIterator itr = versionHistory.getAllVersions();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tVersion version = itr.nextVersion();\n\n\t\t\t\tif (itr.getPosition() == itr.getSize()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!StringUtils.equals(\n\t\t\t\t\t\t\tJCRConstants.JCR_ROOT_VERSION, version.getName())) {\n\n\t\t\t\t\t\tversionHistory.removeVersion(version.getName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsession.save();\n\t\t}\n\t\tcatch (PathNotFoundException pnfe) {\n\t\t\tthrow new NoSuchFileException(fileName);\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow new SystemException(re);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\n\t\t// Delete file\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = getRootNode(session, companyId);\n\t\t\tNode repositoryNode = getFolderNode(rootNode, repositoryId);\n\t\t\tNode fileNode = repositoryNode.getNode(fileName);\n\n\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\t\tFileModel.class);\n\n\t\t\tFileModel fileModel = new FileModel();\n\n\t\t\tfileModel.setCompanyId(companyId);\n\t\t\tfileModel.setFileName(fileName);\n\t\t\tfileModel.setPortletId(portletId);\n\t\t\tfileModel.setRepositoryId(repositoryId);\n\n\t\t\tindexer.delete(fileModel);\n\n\t\t\tfileNode.remove();\n\n\t\t\tsession.save();\n\t\t}\n\t\tcatch (PathNotFoundException pnfe) {\n\t\t\tthrow new NoSuchFileException(fileName);\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow new SystemException(re);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\t}","commit_id":"5d538b5767d059d5c50024550b66fa14ffeebc50","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addFile(\n\t\t\tlong companyId, String portletId, long groupId, long repositoryId,\n\t\t\tString fileName, long fileEntryId, String properties,\n\t\t\tDate modifiedDate, ServiceContext serviceContext, InputStream is)\n\t\tthrows PortalException, SystemException {\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = getRootNode(session, companyId);\n\t\t\tNode repositoryNode = getFolderNode(rootNode, repositoryId);\n\n\t\t\tif (repositoryNode.hasNode(fileName)) {\n\t\t\t\tthrow new DuplicateFileException(fileName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tNode fileNode = repositoryNode.addNode(\n\t\t\t\t\tfileName, JCRConstants.NT_FILE);\n\n\t\t\t\tNode contentNode = fileNode.addNode(\n\t\t\t\t\tJCRConstants.JCR_CONTENT, JCRConstants.NT_RESOURCE);\n\n\t\t\t\tcontentNode.addMixin(JCRConstants.MIX_VERSIONABLE);\n\t\t\t\tcontentNode.setProperty(\n\t\t\t\t\tJCRConstants.JCR_MIME_TYPE, \"text/plain\");\n\t\t\t\tcontentNode.setProperty(JCRConstants.JCR_DATA, is);\n\t\t\t\tcontentNode.setProperty(\n\t\t\t\t\tJCRConstants.JCR_LAST_MODIFIED, Calendar.getInstance());\n\n\t\t\t\tsession.save();\n\n\t\t\t\tVersion version = contentNode.checkin();\n\n\t\t\t\tcontentNode.getVersionHistory().addVersionLabel(\n\t\t\t\t\tversion.getName(), DEFAULT_VERSION, false);\n\n\t\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\t\t\tFileModel.class);\n\n\t\t\t\tFileModel fileModel = new FileModel();\n\n\t\t\t\tfileModel.setAssetCategoryIds(\n\t\t\t\t\tserviceContext.getAssetCategoryIds());\n\t\t\t\tfileModel.setAssetTagNames(serviceContext.getAssetTagNames());\n\t\t\t\tfileModel.setCompanyId(companyId);\n\t\t\t\tfileModel.setFileEntryId(fileEntryId);\n\t\t\t\tfileModel.setFileName(fileName);\n\t\t\t\tfileModel.setGroupId(groupId);\n\t\t\t\tfileModel.setModifiedDate(modifiedDate);\n\t\t\t\tfileModel.setPortletId(portletId);\n\t\t\t\tfileModel.setProperties(properties);\n\t\t\t\tfileModel.setRepositoryId(repositoryId);\n\n\t\t\t\tindexer.reindex(fileModel);\n\t\t\t}\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow new SystemException(re);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\t}","id":75317,"modified_method":"public void addFile(\n\t\t\tlong companyId, String portletId, long groupId, long repositoryId,\n\t\t\tString fileName, long fileEntryId, String properties,\n\t\t\tDate modifiedDate, ServiceContext serviceContext, InputStream is)\n\t\tthrows PortalException, SystemException {\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = getRootNode(session, companyId);\n\t\t\tNode repositoryNode = getFolderNode(rootNode, repositoryId);\n\n\t\t\tif (repositoryNode.hasNode(fileName)) {\n\t\t\t\tthrow new DuplicateFileException(fileName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tNode fileNode = repositoryNode.addNode(\n\t\t\t\t\tfileName, JCRConstants.NT_FILE);\n\n\t\t\t\tNode contentNode = fileNode.addNode(\n\t\t\t\t\tJCRConstants.JCR_CONTENT, JCRConstants.NT_RESOURCE);\n\n\t\t\t\tcontentNode.addMixin(JCRConstants.MIX_VERSIONABLE);\n\t\t\t\tcontentNode.setProperty(\n\t\t\t\t\tJCRConstants.JCR_MIME_TYPE, \"text/plain\");\n\t\t\t\tcontentNode.setProperty(JCRConstants.JCR_DATA, is);\n\t\t\t\tcontentNode.setProperty(\n\t\t\t\t\tJCRConstants.JCR_LAST_MODIFIED, Calendar.getInstance());\n\n\t\t\t\tsession.save();\n\n\t\t\t\tVersion version = contentNode.checkin();\n\n\t\t\t\tVersionHistory versionHistory = contentNode.getVersionHistory();\n\n\t\t\t\tversionHistory.addVersionLabel(\n\t\t\t\t\tversion.getName(), DEFAULT_VERSION, false);\n\n\t\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\t\t\tFileModel.class);\n\n\t\t\t\tFileModel fileModel = new FileModel();\n\n\t\t\t\tfileModel.setAssetCategoryIds(\n\t\t\t\t\tserviceContext.getAssetCategoryIds());\n\t\t\t\tfileModel.setAssetTagNames(serviceContext.getAssetTagNames());\n\t\t\t\tfileModel.setCompanyId(companyId);\n\t\t\t\tfileModel.setFileEntryId(fileEntryId);\n\t\t\t\tfileModel.setFileName(fileName);\n\t\t\t\tfileModel.setGroupId(groupId);\n\t\t\t\tfileModel.setModifiedDate(modifiedDate);\n\t\t\t\tfileModel.setPortletId(portletId);\n\t\t\t\tfileModel.setProperties(properties);\n\t\t\t\tfileModel.setRepositoryId(repositoryId);\n\n\t\t\t\tindexer.reindex(fileModel);\n\t\t\t}\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow new SystemException(re);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\t}","commit_id":"5d538b5767d059d5c50024550b66fa14ffeebc50","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void updateFile(\n\t\t\tlong companyId, String portletId, long groupId, long repositoryId,\n\t\t\tString fileName, String newFileName, boolean reindex)\n\t\tthrows PortalException, SystemException {\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = getRootNode(session, companyId);\n\t\t\tNode repositoryNode = getFolderNode(rootNode, repositoryId);\n\t\t\tNode fileNode = repositoryNode.getNode(fileName);\n\t\t\tNode contentNode = fileNode.getNode(JCRConstants.JCR_CONTENT);\n\n\t\t\tNode newFileNode = repositoryNode.addNode(\n\t\t\t\tnewFileName, JCRConstants.NT_FILE);\n\n\t\t\tNode newContentNode = newFileNode.addNode(\n\t\t\t\tJCRConstants.JCR_CONTENT, JCRConstants.NT_RESOURCE);\n\n\t\t\tVersionHistory versionHistory = contentNode.getVersionHistory();\n\n\t\t\tString[] versionLabels = versionHistory.getVersionLabels();\n\n\t\t\tfor (int i = (versionLabels.length - 1); i >= 0; i--) {\n\t\t\t\tVersion version = versionHistory.getVersionByLabel(\n\t\t\t\t\tversionLabels[i]);\n\n\t\t\t\tNode frozenContentNode = version.getNode(\n\t\t\t\t\tJCRConstants.JCR_FROZEN_NODE);\n\n\t\t\t\tif (i == (versionLabels.length - 1)) {\n\t\t\t\t\tnewContentNode.addMixin(JCRConstants.MIX_VERSIONABLE);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnewContentNode.checkout();\n\t\t\t\t}\n\n\t\t\t\tnewContentNode.setProperty(\n\t\t\t\t\tJCRConstants.JCR_MIME_TYPE, \"text/plain\");\n\t\t\t\tnewContentNode.setProperty(\n\t\t\t\t\tJCRConstants.JCR_DATA,\n\t\t\t\t\tfrozenContentNode.getProperty(\n\t\t\t\t\t\tJCRConstants.JCR_DATA).getStream());\n\t\t\t\tnewContentNode.setProperty(\n\t\t\t\t\tJCRConstants.JCR_LAST_MODIFIED, Calendar.getInstance());\n\n\t\t\t\tsession.save();\n\n\t\t\t\tVersion newVersion = newContentNode.checkin();\n\n\t\t\t\tnewContentNode.getVersionHistory().addVersionLabel(\n\t\t\t\t\tnewVersion.getName(), versionLabels[i],\n\t\t\t\t\tPropsValues.DL_HOOK_JCR_MOVE_VERSION_LABELS);\n\t\t\t}\n\n\t\t\tfileNode.remove();\n\n\t\t\tsession.save();\n\n\t\t\tif (reindex) {\n\t\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\t\t\tFileModel.class);\n\n\t\t\t\tFileModel fileModel = new FileModel();\n\n\t\t\t\tfileModel.setCompanyId(companyId);\n\t\t\t\tfileModel.setFileName(fileName);\n\t\t\t\tfileModel.setPortletId(portletId);\n\t\t\t\tfileModel.setRepositoryId(repositoryId);\n\n\t\t\t\tindexer.delete(fileModel);\n\n\t\t\t\tfileModel.setFileName(newFileName);\n\t\t\t\tfileModel.setGroupId(groupId);\n\n\t\t\t\tindexer.reindex(fileModel);\n\t\t\t}\n\t\t}\n\t\tcatch (PathNotFoundException pnfe) {\n\t\t\tthrow new NoSuchFileException(fileName);\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow new SystemException(re);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\t}","id":75318,"modified_method":"public void updateFile(\n\t\t\tlong companyId, String portletId, long groupId, long repositoryId,\n\t\t\tString fileName, String newFileName, boolean reindex)\n\t\tthrows PortalException, SystemException {\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = getRootNode(session, companyId);\n\t\t\tNode repositoryNode = getFolderNode(rootNode, repositoryId);\n\t\t\tNode fileNode = repositoryNode.getNode(fileName);\n\t\t\tNode contentNode = fileNode.getNode(JCRConstants.JCR_CONTENT);\n\n\t\t\tNode newFileNode = repositoryNode.addNode(\n\t\t\t\tnewFileName, JCRConstants.NT_FILE);\n\n\t\t\tNode newContentNode = newFileNode.addNode(\n\t\t\t\tJCRConstants.JCR_CONTENT, JCRConstants.NT_RESOURCE);\n\n\t\t\tVersionHistory versionHistory = contentNode.getVersionHistory();\n\n\t\t\tString[] versionLabels = versionHistory.getVersionLabels();\n\n\t\t\tfor (int i = (versionLabels.length - 1); i >= 0; i--) {\n\t\t\t\tVersion version = versionHistory.getVersionByLabel(\n\t\t\t\t\tversionLabels[i]);\n\n\t\t\t\tNode frozenContentNode = version.getNode(\n\t\t\t\t\tJCRConstants.JCR_FROZEN_NODE);\n\n\t\t\t\tif (i == (versionLabels.length - 1)) {\n\t\t\t\t\tnewContentNode.addMixin(JCRConstants.MIX_VERSIONABLE);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnewContentNode.checkout();\n\t\t\t\t}\n\n\t\t\t\tnewContentNode.setProperty(\n\t\t\t\t\tJCRConstants.JCR_MIME_TYPE, \"text/plain\");\n\t\t\t\tnewContentNode.setProperty(\n\t\t\t\t\tJCRConstants.JCR_DATA,\n\t\t\t\t\tfrozenContentNode.getProperty(\n\t\t\t\t\t\tJCRConstants.JCR_DATA).getStream());\n\t\t\t\tnewContentNode.setProperty(\n\t\t\t\t\tJCRConstants.JCR_LAST_MODIFIED, Calendar.getInstance());\n\n\t\t\t\tsession.save();\n\n\t\t\t\tVersion newVersion = newContentNode.checkin();\n\n\t\t\t\tVersionHistory newVersionHistory =\n\t\t\t\t\tnewContentNode.getVersionHistory();\n\n\t\t\t\tnewVersionHistory.addVersionLabel(\n\t\t\t\t\tnewVersion.getName(), versionLabels[i],\n\t\t\t\t\tPropsValues.DL_HOOK_JCR_MOVE_VERSION_LABELS);\n\t\t\t}\n\n\t\t\tfileNode.remove();\n\n\t\t\tsession.save();\n\n\t\t\tif (reindex) {\n\t\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\t\t\tFileModel.class);\n\n\t\t\t\tFileModel fileModel = new FileModel();\n\n\t\t\t\tfileModel.setCompanyId(companyId);\n\t\t\t\tfileModel.setFileName(fileName);\n\t\t\t\tfileModel.setPortletId(portletId);\n\t\t\t\tfileModel.setRepositoryId(repositoryId);\n\n\t\t\t\tindexer.delete(fileModel);\n\n\t\t\t\tfileModel.setFileName(newFileName);\n\t\t\t\tfileModel.setGroupId(groupId);\n\n\t\t\t\tindexer.reindex(fileModel);\n\t\t\t}\n\t\t}\n\t\tcatch (PathNotFoundException pnfe) {\n\t\t\tthrow new NoSuchFileException(fileName);\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow new SystemException(re);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\t}","commit_id":"5d538b5767d059d5c50024550b66fa14ffeebc50","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void reindex(String[] ids) throws SearchException {\n\t\tlong companyId = GetterUtil.getLong(ids[0]);\n\t\tString portletId = ids[1];\n\t\tlong groupId = GetterUtil.getLong(ids[2]);\n\t\tlong repositoryId = GetterUtil.getLong(ids[3]);\n\n\t\tCollection<Document> documents = new ArrayList<Document>();\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = getRootNode(session, companyId);\n\t\t\tNode repositoryNode = getFolderNode(rootNode, repositoryId);\n\n\t\t\tNodeIterator itr = repositoryNode.getNodes();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tNode node = (Node)itr.next();\n\n\t\t\t\tif (node.getPrimaryNodeType().getName().equals(\n\t\t\t\t\t\tJCRConstants.NT_FILE)) {\n\n\t\t\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\t\t\t\tFileModel.class);\n\n\t\t\t\t\tFileModel fileModel = new FileModel();\n\n\t\t\t\t\tfileModel.setCompanyId(companyId);\n\t\t\t\t\tfileModel.setFileName(node.getName());\n\t\t\t\t\tfileModel.setGroupId(groupId);\n\t\t\t\t\tfileModel.setPortletId(portletId);\n\t\t\t\t\tfileModel.setRepositoryId(repositoryId);\n\n\t\t\t\t\tDocument document = indexer.getDocument(fileModel);\n\n\t\t\t\t\tif (document == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tdocuments.add(document);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e1) {\n\t\t\tthrow new SearchException(e1);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tif (session != null) {\n\t\t\t\t\tsession.logout();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e);\n\t\t\t}\n\t\t}\n\n\t\tSearchEngineUtil.updateDocuments(companyId, documents);\n\t}","id":75319,"modified_method":"public void reindex(String[] ids) throws SearchException {\n\t\tlong companyId = GetterUtil.getLong(ids[0]);\n\t\tString portletId = ids[1];\n\t\tlong groupId = GetterUtil.getLong(ids[2]);\n\t\tlong repositoryId = GetterUtil.getLong(ids[3]);\n\n\t\tCollection<Document> documents = new ArrayList<Document>();\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = getRootNode(session, companyId);\n\t\t\tNode repositoryNode = getFolderNode(rootNode, repositoryId);\n\n\t\t\tNodeIterator itr = repositoryNode.getNodes();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tNode node = (Node)itr.next();\n\n\t\t\t\tNodeType primaryNodeType = node.getPrimaryNodeType();\n\n\t\t\t\tString primaryNodeTypeName = primaryNodeType.getName();\n\n\t\t\t\tif (primaryNodeTypeName.equals(JCRConstants.NT_FILE)) {\n\t\t\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\t\t\t\tFileModel.class);\n\n\t\t\t\t\tFileModel fileModel = new FileModel();\n\n\t\t\t\t\tfileModel.setCompanyId(companyId);\n\t\t\t\t\tfileModel.setFileName(node.getName());\n\t\t\t\t\tfileModel.setGroupId(groupId);\n\t\t\t\t\tfileModel.setPortletId(portletId);\n\t\t\t\t\tfileModel.setRepositoryId(repositoryId);\n\n\t\t\t\t\tDocument document = indexer.getDocument(fileModel);\n\n\t\t\t\t\tif (document == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tdocuments.add(document);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e1) {\n\t\t\tthrow new SearchException(e1);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tif (session != null) {\n\t\t\t\t\tsession.logout();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e);\n\t\t\t}\n\t\t}\n\n\t\tSearchEngineUtil.updateDocuments(companyId, documents);\n\t}","commit_id":"5d538b5767d059d5c50024550b66fa14ffeebc50","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void deleteDirectory(\n\t\t\tlong companyId, String portletId, long repositoryId, Node dirNode)\n\t\tthrows SearchException {\n\n\t\ttry {\n\t\t\tNodeIterator itr = dirNode.getNodes();\n\n\t\t\tFileModel fileModel = new FileModel();\n\n\t\t\tfileModel.setCompanyId(companyId);\n\t\t\tfileModel.setPortletId(portletId);\n\t\t\tfileModel.setRepositoryId(repositoryId);\n\n\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(FileModel.class);\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tNode node = (Node)itr.next();\n\n\t\t\t\tString primaryNodeTypeName =\n\t\t\t\t\tnode.getPrimaryNodeType().getName();\n\n\t\t\t\tif (primaryNodeTypeName.equals(JCRConstants.NT_FOLDER)) {\n\t\t\t\t\tdeleteDirectory(companyId, portletId, repositoryId, node);\n\t\t\t\t}\n\t\t\t\telse if (primaryNodeTypeName.equals(JCRConstants.NT_FILE)) {\n\t\t\t\t\tfileModel.setFileName(node.getName());\n\n\t\t\t\t\tindexer.delete(fileModel);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfileModel.setFileName(dirNode.getName());\n\n\t\t\tindexer.delete(fileModel);\n\t\t}\n\t\tcatch (RepositoryException e) {\n\t\t\t_log.error(e);\n\t\t}\n\t}","id":75320,"modified_method":"protected void deleteDirectory(\n\t\t\tlong companyId, String portletId, long repositoryId, Node dirNode)\n\t\tthrows SearchException {\n\n\t\ttry {\n\t\t\tNodeIterator itr = dirNode.getNodes();\n\n\t\t\tFileModel fileModel = new FileModel();\n\n\t\t\tfileModel.setCompanyId(companyId);\n\t\t\tfileModel.setPortletId(portletId);\n\t\t\tfileModel.setRepositoryId(repositoryId);\n\n\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(FileModel.class);\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tNode node = (Node)itr.next();\n\n\t\t\t\tNodeType primaryNodeType = node.getPrimaryNodeType();\n\n\t\t\t\tString primaryNodeTypeName = primaryNodeType.getName();\n\n\t\t\t\tif (primaryNodeTypeName.equals(JCRConstants.NT_FOLDER)) {\n\t\t\t\t\tdeleteDirectory(companyId, portletId, repositoryId, node);\n\t\t\t\t}\n\t\t\t\telse if (primaryNodeTypeName.equals(JCRConstants.NT_FILE)) {\n\t\t\t\t\tfileModel.setFileName(node.getName());\n\n\t\t\t\t\tindexer.delete(fileModel);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfileModel.setFileName(dirNode.getName());\n\n\t\t\tindexer.delete(fileModel);\n\t\t}\n\t\tcatch (RepositoryException e) {\n\t\t\t_log.error(e);\n\t\t}\n\t}","commit_id":"5d538b5767d059d5c50024550b66fa14ffeebc50","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void updateFile(\n\t\t\tlong companyId, String portletId, long groupId, long repositoryId,\n\t\t\tString fileName, String versionNumber, String sourceFileName,\n\t\t\tlong fileEntryId, String properties, Date modifiedDate,\n\t\t\tServiceContext serviceContext, InputStream is)\n\t\tthrows PortalException, SystemException {\n\n\t\tString versionLabel = versionNumber;\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = getRootNode(session, companyId);\n\t\t\tNode repositoryNode = getFolderNode(rootNode, repositoryId);\n\t\t\tNode fileNode = repositoryNode.getNode(fileName);\n\t\t\tNode contentNode = fileNode.getNode(JCRConstants.JCR_CONTENT);\n\n\t\t\tcontentNode.checkout();\n\n\t\t\tcontentNode.setProperty(JCRConstants.JCR_MIME_TYPE, \"text/plain\");\n\t\t\tcontentNode.setProperty(JCRConstants.JCR_DATA, is);\n\t\t\tcontentNode.setProperty(\n\t\t\t\tJCRConstants.JCR_LAST_MODIFIED, Calendar.getInstance());\n\n\t\t\tsession.save();\n\n\t\t\tVersion version = contentNode.checkin();\n\n\t\t\tcontentNode.getVersionHistory().addVersionLabel(\n\t\t\t\tversion.getName(), versionLabel,\n\t\t\t\tPropsValues.DL_HOOK_JCR_MOVE_VERSION_LABELS);\n\n\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\t\tFileModel.class);\n\n\t\t\tFileModel fileModel = new FileModel();\n\n\t\t\tfileModel.setAssetCategoryIds(serviceContext.getAssetCategoryIds());\n\t\t\tfileModel.setAssetTagNames(serviceContext.getAssetTagNames());\n\t\t\tfileModel.setCompanyId(companyId);\n\t\t\tfileModel.setFileEntryId(fileEntryId);\n\t\t\tfileModel.setFileName(fileName);\n\t\t\tfileModel.setGroupId(groupId);\n\t\t\tfileModel.setModifiedDate(modifiedDate);\n\t\t\tfileModel.setPortletId(portletId);\n\t\t\tfileModel.setProperties(properties);\n\t\t\tfileModel.setRepositoryId(repositoryId);\n\n\t\t\tindexer.reindex(fileModel);\n\t\t}\n\t\tcatch (PathNotFoundException pnfe) {\n\t\t\tthrow new NoSuchFileException(\n\t\t\t\t\"{fileName=\" + fileName + \", versionLabel=\" + versionLabel +\n\t\t\t\t\t\"}\");\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow new SystemException(re);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\t}","id":75321,"modified_method":"public void updateFile(\n\t\t\tlong companyId, String portletId, long groupId, long repositoryId,\n\t\t\tString fileName, String versionNumber, String sourceFileName,\n\t\t\tlong fileEntryId, String properties, Date modifiedDate,\n\t\t\tServiceContext serviceContext, InputStream is)\n\t\tthrows PortalException, SystemException {\n\n\t\tString versionLabel = versionNumber;\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = getRootNode(session, companyId);\n\t\t\tNode repositoryNode = getFolderNode(rootNode, repositoryId);\n\t\t\tNode fileNode = repositoryNode.getNode(fileName);\n\t\t\tNode contentNode = fileNode.getNode(JCRConstants.JCR_CONTENT);\n\n\t\t\tcontentNode.checkout();\n\n\t\t\tcontentNode.setProperty(JCRConstants.JCR_MIME_TYPE, \"text/plain\");\n\t\t\tcontentNode.setProperty(JCRConstants.JCR_DATA, is);\n\t\t\tcontentNode.setProperty(\n\t\t\t\tJCRConstants.JCR_LAST_MODIFIED, Calendar.getInstance());\n\n\t\t\tsession.save();\n\n\t\t\tVersion version = contentNode.checkin();\n\n\t\t\tVersionHistory versionHistory = contentNode.getVersionHistory();\n\n\t\t\tversionHistory.addVersionLabel(\n\t\t\t\tversion.getName(), versionLabel,\n\t\t\t\tPropsValues.DL_HOOK_JCR_MOVE_VERSION_LABELS);\n\n\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\t\tFileModel.class);\n\n\t\t\tFileModel fileModel = new FileModel();\n\n\t\t\tfileModel.setAssetCategoryIds(serviceContext.getAssetCategoryIds());\n\t\t\tfileModel.setAssetTagNames(serviceContext.getAssetTagNames());\n\t\t\tfileModel.setCompanyId(companyId);\n\t\t\tfileModel.setFileEntryId(fileEntryId);\n\t\t\tfileModel.setFileName(fileName);\n\t\t\tfileModel.setGroupId(groupId);\n\t\t\tfileModel.setModifiedDate(modifiedDate);\n\t\t\tfileModel.setPortletId(portletId);\n\t\t\tfileModel.setProperties(properties);\n\t\t\tfileModel.setRepositoryId(repositoryId);\n\n\t\t\tindexer.reindex(fileModel);\n\t\t}\n\t\tcatch (PathNotFoundException pnfe) {\n\t\t\tthrow new NoSuchFileException(\n\t\t\t\t\"{fileName=\" + fileName + \", versionLabel=\" + versionLabel +\n\t\t\t\t\t\"}\");\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow new SystemException(re);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\t}","commit_id":"5d538b5767d059d5c50024550b66fa14ffeebc50","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void updateFile(\n\t\t\tlong companyId, String portletId, long groupId, long repositoryId,\n\t\t\tlong newRepositoryId, String fileName, long fileEntryId)\n\t\tthrows PortalException, SystemException {\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = getRootNode(session, companyId);\n\t\t\tNode repositoryNode = getFolderNode(rootNode, repositoryId);\n\t\t\tNode fileNode = repositoryNode.getNode(fileName);\n\t\t\tNode contentNode = fileNode.getNode(JCRConstants.JCR_CONTENT);\n\n\t\t\tNode newRepositoryNode = getFolderNode(rootNode, newRepositoryId);\n\n\t\t\tif (newRepositoryNode.hasNode(fileName)) {\n\t\t\t\tthrow new DuplicateFileException(fileName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tNode newFileNode = newRepositoryNode.addNode(\n\t\t\t\t\tfileName, JCRConstants.NT_FILE);\n\n\t\t\t\tNode newContentNode = newFileNode.addNode(\n\t\t\t\t\tJCRConstants.JCR_CONTENT, JCRConstants.NT_RESOURCE);\n\n\t\t\t\tVersionHistory versionHistory = contentNode.getVersionHistory();\n\n\t\t\t\tString[] versionLabels = versionHistory.getVersionLabels();\n\n\t\t\t\tfor (int i = (versionLabels.length - 1); i >= 0; i--) {\n\t\t\t\t\tVersion version = versionHistory.getVersionByLabel(\n\t\t\t\t\t\tversionLabels[i]);\n\n\t\t\t\t\tNode frozenContentNode = version.getNode(\n\t\t\t\t\t\tJCRConstants.JCR_FROZEN_NODE);\n\n\t\t\t\t\tif (i == (versionLabels.length - 1)) {\n\t\t\t\t\t\tnewContentNode.addMixin(JCRConstants.MIX_VERSIONABLE);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnewContentNode.checkout();\n\t\t\t\t\t}\n\n\t\t\t\t\tnewContentNode.setProperty(\n\t\t\t\t\t\tJCRConstants.JCR_MIME_TYPE, \"text/plain\");\n\t\t\t\t\tnewContentNode.setProperty(\n\t\t\t\t\t\tJCRConstants.JCR_DATA,\n\t\t\t\t\t\tfrozenContentNode.getProperty(\n\t\t\t\t\t\t\tJCRConstants.JCR_DATA).getStream());\n\t\t\t\t\tnewContentNode.setProperty(\n\t\t\t\t\t\tJCRConstants.JCR_LAST_MODIFIED, Calendar.getInstance());\n\n\t\t\t\t\tsession.save();\n\n\t\t\t\t\tVersion newVersion = newContentNode.checkin();\n\n\t\t\t\t\tnewContentNode.getVersionHistory().addVersionLabel(\n\t\t\t\t\t\tnewVersion.getName(), versionLabels[i],\n\t\t\t\t\t\tPropsValues.DL_HOOK_JCR_MOVE_VERSION_LABELS);\n\t\t\t\t}\n\n\t\t\t\tfileNode.remove();\n\n\t\t\t\tsession.save();\n\n\t\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\t\t\tFileModel.class);\n\n\t\t\t\tFileModel fileModel = new FileModel();\n\n\t\t\t\tfileModel.setCompanyId(companyId);\n\t\t\t\tfileModel.setFileName(fileName);\n\t\t\t\tfileModel.setPortletId(portletId);\n\t\t\t\tfileModel.setRepositoryId(repositoryId);\n\n\t\t\t\tindexer.delete(fileModel);\n\n\t\t\t\tfileModel.setRepositoryId(newRepositoryId);\n\t\t\t\tfileModel.setGroupId(groupId);\n\n\t\t\t\tindexer.reindex(fileModel);\n\t\t\t}\n\t\t}\n\t\tcatch (PathNotFoundException pnfe) {\n\t\t\tthrow new NoSuchFileException(fileName);\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow new SystemException(re);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\t}","id":75322,"modified_method":"public void updateFile(\n\t\t\tlong companyId, String portletId, long groupId, long repositoryId,\n\t\t\tlong newRepositoryId, String fileName, long fileEntryId)\n\t\tthrows PortalException, SystemException {\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = getRootNode(session, companyId);\n\t\t\tNode repositoryNode = getFolderNode(rootNode, repositoryId);\n\t\t\tNode fileNode = repositoryNode.getNode(fileName);\n\t\t\tNode contentNode = fileNode.getNode(JCRConstants.JCR_CONTENT);\n\n\t\t\tNode newRepositoryNode = getFolderNode(rootNode, newRepositoryId);\n\n\t\t\tif (newRepositoryNode.hasNode(fileName)) {\n\t\t\t\tthrow new DuplicateFileException(fileName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tNode newFileNode = newRepositoryNode.addNode(\n\t\t\t\t\tfileName, JCRConstants.NT_FILE);\n\n\t\t\t\tNode newContentNode = newFileNode.addNode(\n\t\t\t\t\tJCRConstants.JCR_CONTENT, JCRConstants.NT_RESOURCE);\n\n\t\t\t\tVersionHistory versionHistory = contentNode.getVersionHistory();\n\n\t\t\t\tString[] versionLabels = versionHistory.getVersionLabels();\n\n\t\t\t\tfor (int i = (versionLabels.length - 1); i >= 0; i--) {\n\t\t\t\t\tVersion version = versionHistory.getVersionByLabel(\n\t\t\t\t\t\tversionLabels[i]);\n\n\t\t\t\t\tNode frozenContentNode = version.getNode(\n\t\t\t\t\t\tJCRConstants.JCR_FROZEN_NODE);\n\n\t\t\t\t\tif (i == (versionLabels.length - 1)) {\n\t\t\t\t\t\tnewContentNode.addMixin(JCRConstants.MIX_VERSIONABLE);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnewContentNode.checkout();\n\t\t\t\t\t}\n\n\t\t\t\t\tnewContentNode.setProperty(\n\t\t\t\t\t\tJCRConstants.JCR_MIME_TYPE, \"text/plain\");\n\t\t\t\t\tnewContentNode.setProperty(\n\t\t\t\t\t\tJCRConstants.JCR_DATA,\n\t\t\t\t\t\tfrozenContentNode.getProperty(\n\t\t\t\t\t\t\tJCRConstants.JCR_DATA).getStream());\n\t\t\t\t\tnewContentNode.setProperty(\n\t\t\t\t\t\tJCRConstants.JCR_LAST_MODIFIED, Calendar.getInstance());\n\n\t\t\t\t\tsession.save();\n\n\t\t\t\t\tVersion newVersion = newContentNode.checkin();\n\n\t\t\t\t\tVersionHistory newVersionHistory =\n\t\t\t\t\t\tnewContentNode.getVersionHistory();\n\n\t\t\t\t\tnewVersionHistory.addVersionLabel(\n\t\t\t\t\t\tnewVersion.getName(), versionLabels[i],\n\t\t\t\t\t\tPropsValues.DL_HOOK_JCR_MOVE_VERSION_LABELS);\n\t\t\t\t}\n\n\t\t\t\tfileNode.remove();\n\n\t\t\t\tsession.save();\n\n\t\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\t\t\tFileModel.class);\n\n\t\t\t\tFileModel fileModel = new FileModel();\n\n\t\t\t\tfileModel.setCompanyId(companyId);\n\t\t\t\tfileModel.setFileName(fileName);\n\t\t\t\tfileModel.setPortletId(portletId);\n\t\t\t\tfileModel.setRepositoryId(repositoryId);\n\n\t\t\t\tindexer.delete(fileModel);\n\n\t\t\t\tfileModel.setRepositoryId(newRepositoryId);\n\t\t\t\tfileModel.setGroupId(groupId);\n\n\t\t\t\tindexer.reindex(fileModel);\n\t\t\t}\n\t\t}\n\t\tcatch (PathNotFoundException pnfe) {\n\t\t\tthrow new NoSuchFileException(fileName);\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow new SystemException(re);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\t}","commit_id":"5d538b5767d059d5c50024550b66fa14ffeebc50","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void verify() throws InterruptedException\n    {\n        latch.await(timeout, TimeUnit.MILLISECONDS);\n        if (event == null)\n        {\n            Assert.fail(\"event is null\");\n        }\n        else if (!expressionManager.evaluateBoolean(expression, event.getMessage(), false, true))\n        {\n            Assert.fail(\"Flow assertion failed: \" + expression);\n        }\n    }","id":75323,"modified_method":"public void verify() throws InterruptedException\n    {\n        boolean didntTimeout = latch.await(timeout, TimeUnit.MILLISECONDS);\n        if (!didntTimeout || event == null)\n        {\n            Assert.fail(\"Flow assertion '\" + message + \"' failed.  No message recieved.\");\n        }\n        else if (!result)\n        {\n            Assert.fail(\"Flow assertion '\" + message + \"' failed. Expression \" + expression\n                        + \" evaluated false.\");\n        }\n    }","commit_id":"2d66b6c31951172cb29b2a72fbd7cc815a6ac291","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    public MuleEvent process(MuleEvent event) throws MuleException\n    {\n        this.event = event;\n        latch.countDown();\n        return event;\n    }","id":75324,"modified_method":"@Override\n    public MuleEvent process(MuleEvent event) throws MuleException\n    {\n        this.event = event;\n        result = result && expressionManager.evaluateBoolean(expression, event.getMessage(), false, true);\n        latch.countDown();\n        return event;\n    }","commit_id":"2d66b6c31951172cb29b2a72fbd7cc815a6ac291","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    public void start() throws InitialisationException\n    {\n        this.expressionManager = flowConstruct.getMuleContext().getExpressionManager();\n        this.expressionManager.validateExpression(expression);\n        FlowAssert.addAssertion(flowConstruct.getName(), this);\n    }","id":75325,"modified_method":"@Override\n    public void start() throws InitialisationException\n    {\n        this.expressionManager = flowConstruct.getMuleContext().getExpressionManager();\n        this.expressionManager.validateExpression(expression);\n        latch = new CountDownLatch(count);\n        FlowAssert.addAssertion(flowConstruct.getName(), this);\n    }","commit_id":"2d66b6c31951172cb29b2a72fbd7cc815a6ac291","url":"https://github.com/mulesoft/mule"},{"original_method":"public static void verify(String flowName) throws Exception\n    {\n\n        List<AssertionMessageProcessor> flowAssertions = assertions.get(flowName);\n        for (AssertionMessageProcessor assertion : flowAssertions)\n        {\n            assertion.verify();\n        }\n    }","id":75326,"modified_method":"public static void verify(String flowName) throws Exception\n    {\n\n        List<AssertionMessageProcessor> flowAssertions = assertions.get(flowName);\n        if (flowAssertions != null)\n        {\n            for (AssertionMessageProcessor assertion : flowAssertions)\n            {\n                assertion.verify();\n            }\n        }\n    }","commit_id":"2d66b6c31951172cb29b2a72fbd7cc815a6ac291","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void testPublishOnBusyPort() {\n        GreeterSessionImpl implementor = new GreeterSessionImpl();\n        String address = \"http://localhost:9020/SoapContext/GreeterPort\";\n        try {\n            Endpoint.publish(address, implementor);\n            fail(\"Should have failed to publish as the port is busy\");\n        } catch (WebServiceException ex) {\n            //ignore            \n        }\n        try {\n            //CXF-1589\n            Endpoint.publish(address, implementor);\n            fail(\"Should have failed to publish as the port is busy\");\n        } catch (WebServiceException ex) {\n            //ignore\n        }\n        \n    }","id":75327,"modified_method":"@Test\n    public void testPublishOnBusyPort() {\n        boolean isWindows = System.getProperty(\"os.name\").startsWith(\"Windows\");\n        \n        GreeterSessionImpl implementor = new GreeterSessionImpl();\n        String address = \"http://localhost:9020/SoapContext/GreeterPort\";\n        try {\n            Endpoint.publish(address, implementor);\n            if (!isWindows) {\n                fail(\"Should have failed to publish as the port is busy\");\n            } else {\n                System.err.println(\"Should have failed to publish as the port is busy, but certains \"\n                                   + \"of Windows allow this.\");\n            }\n        } catch (WebServiceException ex) {\n            //ignore            \n        }\n        try {\n            //CXF-1589\n            Endpoint.publish(address, implementor);\n            if (!isWindows) {\n                fail(\"Should have failed to publish as the port is busy\");\n            } else {\n                System.err.println(\"Should have failed to publish as the port is busy, but certains \"\n                                   + \"of Windows allow this.\");\n            }\n        } catch (WebServiceException ex) {\n            //ignore\n        }\n        \n    }","commit_id":"eab579a46aaef785b5132dbe0828e3c0a04f89d8","url":"https://github.com/apache/cxf"},{"original_method":"@Test(dataProvider = \"drfCases\")\n\tpublic void basic(String testcase_id, String test_description, String train_dataset_id, String validate_dataset_id,\n\t\t\tDataset train_dataset, Dataset validate_dataset, String[] rawInput) {\n\n\t\tDRFModel.DRFParameters DRFParameter = null;\n\t\tredirectStandardStreams();\n\n\t\tRecordingTestcase rt = new RecordingTestcase();\n\n\t\ttry {\n\t\t\tString invalidMessage = validate(train_dataset_id, train_dataset, rawInput);\n\t\t\tString notImplMessage = checkImplemented(rawInput);\n\n\t\t\tif (invalidMessage != null) {\n\t\t\t\tSystem.out.println(invalidMessage);\n\t\t\t\tAssert.fail(String.format(invalidMessage));\n\t\t\t}\n\t\t\telse if (notImplMessage != null) {\n\t\t\t\tSystem.out.println(notImplMessage);\n\t\t\t\tAssert.fail(String.format(notImplMessage));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDRFParameter = toDRFParameters(train_dataset_id, validate_dataset_id, train_dataset, validate_dataset,\n\t\t\t\t\t\trawInput);\n\n\t\t\t\t_basic(testcase_id, test_description, DRFParameter, rawInput);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\n\t\t\t// TODO: get memory by H2O's API\n\t\t\tSystem.out.println(\"Total Memory used in testcase:\" + (rt.getUsedMemory() / RecordingTestcase.MB) + \"MB\");\n\t\t\tSystem.out.println(\"Total Time used in testcase:\" + (rt.getTimeRecording()) + \"millis\");\n\t\t\t\n\t\t\t// wait 100 mili-sec for output/error to be stored\n\t\t\ttry {\n\t\t\t\tThread.sleep(100);\n\t\t\t}\n\t\t\tcatch (InterruptedException ex) {\n\t\t\t\tThread.currentThread().interrupt();\n\t\t\t}\n\n\t\t\tresetStandardStreams();\n\t\t}\n\t}","id":75328,"modified_method":"@Test(dataProvider = \"drfCases\")\n\tpublic void basic(String testcase_id, String test_description, String train_dataset_id, String validate_dataset_id,\n\t\t\tDataset train_dataset, Dataset validate_dataset, boolean isNegativeTestcase, String[] rawInput) {\n\n\t\tDRFModel.DRFParameters DRFParameter = null;\n\t\tredirectStandardStreams();\n\n\t\tRecordingTestcase rt = new RecordingTestcase();\n\n\t\ttry {\n\t\t\tString invalidMessage = validate(train_dataset_id, train_dataset, rawInput);\n\t\t\tString notImplMessage = checkImplemented(rawInput);\n\n\t\t\tif (invalidMessage != null) {\n\t\t\t\tSystem.out.println(invalidMessage);\n\t\t\t\tAssert.fail(String.format(invalidMessage));\n\t\t\t}\n\t\t\telse if (notImplMessage != null) {\n\t\t\t\tSystem.out.println(notImplMessage);\n\t\t\t\tAssert.fail(String.format(notImplMessage));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDRFParameter = toDRFParameters(train_dataset_id, validate_dataset_id, train_dataset, validate_dataset,\n\t\t\t\t\t\trawInput);\n\n\t\t\t\t_basic(testcase_id, test_description, DRFParameter, isNegativeTestcase, rawInput);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\n\t\t\t// TODO: get memory by H2O's API\n\t\t\tSystem.out.println(\"Total Memory used in testcase:\" + (rt.getUsedMemory() / RecordingTestcase.MB) + \"MB\");\n\t\t\tSystem.out.println(\"Total Time used in testcase:\" + (rt.getTimeRecording()) + \"millis\");\n\n\t\t\t// wait 100 mili-sec for output/error to be stored\n\t\t\ttry {\n\t\t\t\tThread.sleep(100);\n\t\t\t}\n\t\t\tcatch (InterruptedException ex) {\n\t\t\t\tThread.currentThread().interrupt();\n\t\t\t}\n\n\t\t\tresetStandardStreams();\n\t\t}\n\t}","commit_id":"8fe42d244831dadd9491aeef0c12b0c9199dbc9d","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private void _basic(String testcase_id, String test_description, DRFModel.DRFParameters parameter, String[] rawInput) {\n\n\t\tSystem.out.println(String.format(\"Testcase: %s\", testcase_id));\n\t\tSystem.out.println(String.format(\"Description: %s\", test_description));\n\t\tSystem.out.println(\"DRF Params:\");\n\t\tfor (Param p : params) {\n\t\t\tp.print(parameter);\n\t\t}\n\n\t\tFrame trainFrame = null;\n\t\tDRF job = null;\n\t\tDRFModel drfModel = null;\n\t\tFrame score = null;\n\n\t\ttrainFrame = parameter._train.get();\n\n\t\ttry {\n\t\t\tScope.enter();\n\n\t\t\tSystem.out.println(\"Build model\");\n\t\t\tjob = new DRF(parameter);\n\n\t\t\tSystem.out.println(\"Train model:\");\n\t\t\tdrfModel = job.trainModel().get();\n\n\t\t\tSystem.out.println(\"Predict testcase \" + testcase_id);\n\t\t\tscore = drfModel.score(trainFrame);\n\n\t\t\tSystem.out.println(\"Validate testcase \" + testcase_id);\n\t\t\t// Assert.assertTrue(drfModel.testJavaScoring(score, trainFrame, 1e-15));\n\n\t\t\tif (FunctionUtils.isNegativeTestcase(tcHeaders, rawInput)) {\n\t\t\t\tAssert.fail(\"It is negative testcase\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"Testcase is passed.\");\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tSystem.out.println(\"Testcase is failed\");\n\t\t\tex.printStackTrace();\n\t\t\tif (!FunctionUtils.isNegativeTestcase(tcHeaders, rawInput)) {\n\t\t\t\tAssert.fail(\"Testcase is failed\", ex);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tSystem.out.println(\"Testcase is failed\");\n\t\t\tex.printStackTrace();\n\t\t\tif (!FunctionUtils.isNegativeTestcase(tcHeaders, rawInput)) {\n\t\t\t\tAssert.fail(\"Testcase is failed\", ex);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (job != null) {\n\t\t\t\tjob.remove();\n\t\t\t}\n\t\t\tif (drfModel != null) {\n\t\t\t\tdrfModel.delete();\n\t\t\t}\n\t\t\tif (score != null) {\n\t\t\t\tscore.remove();\n\t\t\t\tscore.delete();\n\t\t\t}\n\t\t\tScope.exit();\n\t\t}\n\t}","id":75329,"modified_method":"private void _basic(String testcase_id, String test_description, DRFModel.DRFParameters parameter,\n\t\t\tboolean isNegativeTestcase, String[] rawInput) {\n\n\t\tSystem.out.println(String.format(\"Testcase: %s\", testcase_id));\n\t\tSystem.out.println(String.format(\"Description: %s\", test_description));\n\t\tSystem.out.println(\"DRF Params:\");\n\t\tfor (Param p : params) {\n\t\t\tp.print(parameter);\n\t\t}\n\n\t\tFrame trainFrame = null;\n\t\tDRF job = null;\n\t\tDRFModel drfModel = null;\n\t\tFrame score = null;\n\n\t\ttrainFrame = parameter._train.get();\n\n\t\ttry {\n\t\t\tScope.enter();\n\n\t\t\tSystem.out.println(\"Build model\");\n\t\t\tjob = new DRF(parameter);\n\n\t\t\tSystem.out.println(\"Train model:\");\n\t\t\tdrfModel = job.trainModel().get();\n\n\t\t\tSystem.out.println(\"Predict testcase \" + testcase_id);\n\t\t\tscore = drfModel.score(trainFrame);\n\n\t\t\tSystem.out.println(\"Validate testcase \" + testcase_id);\n\t\t\t// Assert.assertTrue(drfModel.testJavaScoring(score, trainFrame, 1e-15));\n\n\t\t\tif (isNegativeTestcase) {\n\t\t\t\tAssert.fail(\"It is negative testcase\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"Testcase is passed.\");\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tSystem.out.println(\"Testcase is failed\");\n\t\t\tex.printStackTrace();\n\t\t\tif (!isNegativeTestcase) {\n\t\t\t\tAssert.fail(\"Testcase is failed\", ex);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tSystem.out.println(\"Testcase is failed\");\n\t\t\tex.printStackTrace();\n\t\t\tif (!isNegativeTestcase) {\n\t\t\t\tAssert.fail(\"Testcase is failed\", ex);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (job != null) {\n\t\t\t\tjob.remove();\n\t\t\t}\n\t\t\tif (drfModel != null) {\n\t\t\t\tdrfModel.delete();\n\t\t\t}\n\t\t\tif (score != null) {\n\t\t\t\tscore.remove();\n\t\t\t\tscore.delete();\n\t\t\t}\n\t\t\tScope.exit();\n\t\t}\n\t}","commit_id":"8fe42d244831dadd9491aeef0c12b0c9199dbc9d","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@DataProvider(name = \"drfCases\")\n\tpublic static Object[][] drfCases() {\n\n\t\t/**\n\t\t * The first row of data is used to testing.\n\t\t */\n\t\tfinal int firstRow = 4;\n\t\tfinal String testcaseFilePath = \"h2o-testng/src/test/resources/drfCases.csv\";\n\t\tfinal String negTestcaseFilePath = \"h2o-testng/src/test/resources/drfNegCases.csv\";\n\n\t\tObject[][] data = null;\n\t\tList<String> lines = null;\n\t\tList<String> negLines = null;\n\t\tList<String> allLines = new ArrayList<String>();\n\n\t\ttry {\n\t\t\t// read data from file\n\t\t\tlines = Files.readAllLines(find_test_file_static(testcaseFilePath).toPath(), Charset.defaultCharset());\n\t\t}\n\t\tcatch (Exception ignore) {\n\t\t\tSystem.out.println(\"Cannot open file: \" + testcaseFilePath);\n\t\t\tignore.printStackTrace();\n\t\t}\n\n\t\ttry {\n\t\t\t// read data from negative file\n\t\t\tnegLines = Files\n\t\t\t\t\t.readAllLines(find_test_file_static(negTestcaseFilePath).toPath(), Charset.defaultCharset());\n\t\t}\n\t\tcatch (Exception ignore) {\n\t\t\tSystem.out.println(\"Cannot open file: \" + negTestcaseFilePath);\n\t\t\tignore.printStackTrace();\n\t\t}\n\n\t\t// remove headers and compile all lines\n\t\tif (lines != null) {\n\t\t\tallLines.addAll(lines.subList(firstRow, lines.size()));\n\t\t}\n\t\tif (negLines != null) {\n\t\t\tallLines.addAll(negLines.subList(firstRow, negLines.size()));\n\t\t}\n\n\t\tdata = new Object[allLines.size()][7];\n\t\tint r = 0;\n\t\tfor (String line : allLines) {\n\t\t\tString[] variables = line.trim().split(\",\", -1);\n\n\t\t\tdata[r][0] = variables[tcHeaders.indexOf(\"testcase_id\")];\n\t\t\tdata[r][1] = variables[tcHeaders.indexOf(\"test_description\")];\n\t\t\tdata[r][2] = variables[tcHeaders.indexOf(\"train_dataset_id\")];\n\t\t\tdata[r][3] = variables[tcHeaders.indexOf(\"validate_dataset_id\")];\n\t\t\tdata[r][4] = dataSetCharacteristic.get(variables[tcHeaders.indexOf(\"train_dataset_id\")]);\n\t\t\tdata[r][5] = dataSetCharacteristic.get(variables[tcHeaders.indexOf(\"validate_dataset_id\")]);\n\t\t\tdata[r][6] = variables;\n\n\t\t\tr++;\n\t\t}\n\n\t\treturn data;\n\t}","id":75330,"modified_method":"@DataProvider(name = \"drfCases\")\n\tpublic static Object[][] drfCases() {\n\n\t\t/**\n\t\t * The first row of data is used to testing.\n\t\t */\n\t\tfinal int firstRow = 4;\n\t\tfinal String positiveTestcaseFilePath = \"h2o-testng/src/test/resources/drfCases.csv\";\n\t\tfinal String negativeTestcaseFilePath = \"h2o-testng/src/test/resources/drfNegCases.csv\";\n\n\t\treturn FunctionUtils.dataProvider(dataSetCharacteristic, tcHeaders, positiveTestcaseFilePath,\n\t\t\t\tnegativeTestcaseFilePath, firstRow);\n\t}","commit_id":"8fe42d244831dadd9491aeef0c12b0c9199dbc9d","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private void createFrame() {\n\n\t\tSystem.out.println(\"Create frame with \" + fileName);\n\t\tthis.printDataset();\n\n\t\tif (!isAvailabel()) {\n\t\t\tSystem.out.println(\"Dataset is not available\");\n\t\t\treturn;\n\t\t}\n\n\t\tString filePath = null;\n\t\tFrame fr = null;\n\t\tFile file = null;\n\t\tNFSFileVec nfs = null;\n\t\tKey key = null;\n\t\tParseSetup ps = null;\n\n\t\tString skey = dataSetId + \".hex\";\n\n\t\tif (\"bigdata\".equals(dataSetDirectory)) {\n\t\t\tfilePath = \"bigdata/laptop/testng/\";\n\t\t}\n\t\telse {\n\t\t\tfilePath = \"smalldata/testng/\";\n\t\t}\n\n\t\tfile = TestNGUtil.find_test_file_static(filePath + fileName);\n\t\tassert file.exists();\n\n\t\tnfs = NFSFileVec.make(file);\n\t\tkey = Key.make(skey);\n\n\t\ttry {\n\t\t\tps = new ParseSetup(ParserType.CSV, (byte) ',', false, ParseSetup.HAS_HEADER, columnNames.length, columnNames,\n\t\t\t\t\tParseSetup.strToColumnTypes(columnTypes), null, null, null);\n\n\t\t\tfr = ParseDataset.parse(key, new Key[] { nfs._key }, true, ps);\n//\t\t\t fr = ParseDataset.parse(key, nfs._key);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tnfs.remove();\n\t\t\tkey.remove();\n\t\t\tthrow e;\n\t\t}\n\n\t\tframe = fr;\n\t}","id":75331,"modified_method":"private void createFrame() {\n\n\t\tSystem.out.println(\"Create frame with \" + fileName);\n\t\tthis.printDataset();\n\n\t\tif (!isAvailabel()) {\n\t\t\tSystem.out.println(\"Dataset is not available\");\n\t\t\treturn;\n\t\t}\n\n\t\tString filePath = null;\n\t\tFrame fr = null;\n\t\tFile file = null;\n\t\tNFSFileVec nfs = null;\n\t\tKey key = null;\n\t\tParseSetup ps = null;\n\n\t\tString skey = dataSetId + \".hex\";\n\n\t\tif (\"bigdata\".equals(dataSetDirectory)) {\n\t\t\tfilePath = \"bigdata/laptop/testng/\";\n\t\t}\n\t\telse {\n\t\t\tfilePath = \"smalldata/testng/\";\n\t\t}\n\n\t\tfile = TestNGUtil.find_test_file_static(filePath + fileName);\n\t\tif (file == null || !file.exists()) {\n\t\t\tSystem.out.println(\"cannot find dataset: \" + filePath + fileName);\n\t\t\tassert file.exists();\n\t\t}\n\n\t\tnfs = NFSFileVec.make(file);\n\t\tkey = Key.make(skey);\n\n\t\ttry {\n\t\t\tps = new ParseSetup(ParserType.CSV, (byte) ',', false, ParseSetup.HAS_HEADER, columnNames.length,\n\t\t\t\t\tcolumnNames, ParseSetup.strToColumnTypes(columnTypes), null, null, null);\n\n\t\t\tfr = ParseDataset.parse(key, new Key[] { nfs._key }, true, ps);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tnfs.remove();\n\t\t\tkey.remove();\n\t\t\tthrow e;\n\t\t}\n\n\t\tframe = fr;\n\t}","commit_id":"8fe42d244831dadd9491aeef0c12b0c9199dbc9d","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Test(dataProvider = \"gbmCases\")\n\tpublic void basic(String testcase_id, String test_description, String train_dataset_id,\n\t\t\tString validate_dataset_id, Dataset train_dataset, Dataset validate_dataset, String[] rawInput) {\n\n\t\tGBMParameters gbmParams = null;\n\n\t\tredirectStandardStreams();\n\n\t\ttry {\n\t\t\tString invalidMessage = validate(train_dataset_id, train_dataset, rawInput);\n\n\t\t\tif (invalidMessage != null) {\n\t\t\t\tSystem.out.println(invalidMessage);\n\t\t\t\tAssert.fail(String.format(invalidMessage));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgbmParams = toGBMParameters(train_dataset_id, validate_dataset_id, train_dataset, validate_dataset,\n\t\t\t\t\t\trawInput);\n\t\t\t\t_basic(testcase_id, test_description, gbmParams, rawInput);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\n\t\t\t// wait 100 mili-sec for output/error to be stored\n\t\t\ttry {\n\t\t\t\tThread.sleep(100);\n\t\t\t}\n\t\t\tcatch (InterruptedException ex) {\n\t\t\t\tThread.currentThread().interrupt();\n\t\t\t}\n\n\t\t\tresetStandardStreams();\n\t\t}\n\t}","id":75332,"modified_method":"@Test(dataProvider = \"gbmCases\")\n\tpublic void basic(String testcase_id, String test_description, String train_dataset_id, String validate_dataset_id,\n\t\t\tDataset train_dataset, Dataset validate_dataset, boolean isNegativeTestcase, String[] rawInput) {\n\n\t\tGBMParameters gbmParams = null;\n\n\t\tredirectStandardStreams();\n\n\t\ttry {\n\t\t\tString invalidMessage = validate(train_dataset_id, train_dataset, rawInput);\n\n\t\t\tif (invalidMessage != null) {\n\t\t\t\tSystem.out.println(invalidMessage);\n\t\t\t\tAssert.fail(String.format(invalidMessage));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgbmParams = toGBMParameters(train_dataset_id, validate_dataset_id, train_dataset, validate_dataset,\n\t\t\t\t\t\trawInput);\n\t\t\t\t_basic(testcase_id, test_description, gbmParams, isNegativeTestcase, rawInput);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\n\t\t\t// wait 100 mili-sec for output/error to be stored\n\t\t\ttry {\n\t\t\t\tThread.sleep(100);\n\t\t\t}\n\t\t\tcatch (InterruptedException ex) {\n\t\t\t\tThread.currentThread().interrupt();\n\t\t\t}\n\n\t\t\tresetStandardStreams();\n\t\t}\n\t}","commit_id":"8fe42d244831dadd9491aeef0c12b0c9199dbc9d","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@DataProvider(name = \"gbmCases\")\n\tpublic static Object[][] gbmCases() {\n\n\t\t/**\n\t\t * The first row of data is used to testing.\n\t\t */\n\t\tfinal int firstRow = 4;\n\t\tfinal String testcaseFilePath = \"h2o-testng/src/test/resources/gbmCases.csv\";\n\t\tfinal String negTestcaseFilePath = \"h2o-testng/src/test/resources/gbmNegCases.csv\";\n\n\t\tObject[][] data = null;\n\t\tList<String> lines = null;\n\t\tList<String> negLines = null;\n\t\tList<String> allLines = new ArrayList<String>();\n\n\t\ttry {\n\t\t\t// read data from file\n\t\t\tlines = Files.readAllLines(find_test_file_static(testcaseFilePath).toPath(), Charset.defaultCharset());\n\t\t}\n\t\tcatch (Exception ignore) {\n\t\t\tSystem.out.println(\"Cannot open file: \" + testcaseFilePath);\n\t\t\tignore.printStackTrace();\n\t\t}\n\n\t\ttry {\n\t\t\t// read data from negative file\n\t\t\tnegLines = Files\n\t\t\t\t\t.readAllLines(find_test_file_static(negTestcaseFilePath).toPath(), Charset.defaultCharset());\n\t\t}\n\t\tcatch (Exception ignore) {\n\t\t\tSystem.out.println(\"Cannot open file: \" + negTestcaseFilePath);\n\t\t\tignore.printStackTrace();\n\t\t}\n\n\t\t// remove headers and compile all lines\n\t\tif (lines != null) {\n\t\t\tallLines.addAll(lines.subList(firstRow, lines.size()));\n\t\t}\n\t\tif (negLines != null) {\n\t\t\tallLines.addAll(negLines.subList(firstRow, negLines.size()));\n\t\t}\n\n\t\tdata = new Object[allLines.size()][7];\n\t\tint r = 0;\n\t\tfor (String line : allLines) {\n\t\t\tString[] variables = line.trim().split(\",\", -1);\n\n\t\t\tdata[r][0] = variables[tcHeaders.indexOf(\"testcase_id\")];\n\t\t\tdata[r][1] = variables[tcHeaders.indexOf(\"test_description\")];\t\t\t\n\t\t\tdata[r][2] = variables[tcHeaders.indexOf(\"train_dataset_id\")];\n\t\t\tdata[r][3] = variables[tcHeaders.indexOf(\"validate_dataset_id\")];\n\t\t\tdata[r][4] = dataSetCharacteristic.get(variables[tcHeaders.indexOf(\"train_dataset_id\")]);\n\t\t\tdata[r][5] = dataSetCharacteristic.get(variables[tcHeaders.indexOf(\"validate_dataset_id\")]);\n\t\t\tdata[r][6] = variables;\n\n\t\t\tr++;\n\t\t}\n\n\t\treturn data;\n\t}","id":75333,"modified_method":"@DataProvider(name = \"gbmCases\")\n\tpublic static Object[][] gbmCases() {\n\n\t\t/**\n\t\t * The first row of data is used to testing.\n\t\t */\n\t\tfinal int firstRow = 4;\n\t\tfinal String positiveTestcaseFilePath = \"h2o-testng/src/test/resources/gbmCases.csv\";\n\t\tfinal String negativeTestcaseFilePath = \"h2o-testng/src/test/resources/gbmNegCases.csv\";\n\n\t\treturn FunctionUtils.dataProvider(dataSetCharacteristic, tcHeaders, positiveTestcaseFilePath,\n\t\t\t\tnegativeTestcaseFilePath, firstRow);\n\t}","commit_id":"8fe42d244831dadd9491aeef0c12b0c9199dbc9d","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private void _basic(String testcase_id, String test_description, GBMParameters parameter, String[] rawInput) {\n\n\t\tSystem.out.println(String.format(\"Testcase: %s\", testcase_id));\n\t\tSystem.out.println(String.format(\"Description: %s\", test_description));\n\t\tSystem.out.println(\"GBM Params:\");\n\t\tfor (Param p : params) {\n\t\t\tp.print(parameter);\n\t\t}\n\n\t\tFrame trainFrame = null;\n\t\tGBM job = null;\n\t\tGBMModel gbmModel = null;\n\t\tFrame score = null;\n\n\t\ttrainFrame = parameter._train.get();\n\n\t\ttry {\n\t\t\tScope.enter();\n\n\t\t\tSystem.out.println(\"Build model \");\n\t\t\tjob = new GBM(parameter);\n\t\t\tSystem.out.println(\"Train model\");\n\t\t\tgbmModel = job.trainModel().get();\n\n\t\t\tSystem.out.println(\"Predict testcase \" + testcase_id);\n\t\t\tscore = gbmModel.score(trainFrame);\n\n\t\t\tSystem.out.println(\"Validate testcase \" + testcase_id);\n\t\t\t// Assert.assertTrue(gbmModel.testJavaScoring(score, trainFrame, 1e-15));\n\n\t\t\tif (FunctionUtils.isNegativeTestcase(tcHeaders, rawInput)) {\n\t\t\t\tAssert.fail(\"It is negative testcase\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"Testcase is passed.\");\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tSystem.out.println(\"Testcase is failed.\");\n\t\t\tex.printStackTrace();\n\n\t\t\tif (!FunctionUtils.isNegativeTestcase(tcHeaders, rawInput)) {\n\t\t\t\tAssert.fail(\"Testcase is failed\", ex);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (score != null) {\n\t\t\t\tscore.remove();\n\t\t\t\tscore.delete();\n\t\t\t}\n\t\t\tif (job != null) {\n\t\t\t\tjob.remove();\n\t\t\t}\n\t\t\tif (gbmModel != null) {\n\t\t\t\tgbmModel.delete();\n\t\t\t}\n\t\t\tScope.exit();\n\t\t}\n\t}","id":75334,"modified_method":"private void _basic(String testcase_id, String test_description, GBMParameters parameter,\n\t\t\tboolean isNegativeTestcase, String[] rawInput) {\n\n\t\tSystem.out.println(String.format(\"Testcase: %s\", testcase_id));\n\t\tSystem.out.println(String.format(\"Description: %s\", test_description));\n\t\tSystem.out.println(\"GBM Params:\");\n\t\tfor (Param p : params) {\n\t\t\tp.print(parameter);\n\t\t}\n\n\t\tFrame trainFrame = null;\n\t\tGBM job = null;\n\t\tGBMModel gbmModel = null;\n\t\tFrame score = null;\n\n\t\ttrainFrame = parameter._train.get();\n\n\t\ttry {\n\t\t\tScope.enter();\n\n\t\t\tSystem.out.println(\"Build model \");\n\t\t\tjob = new GBM(parameter);\n\t\t\tSystem.out.println(\"Train model\");\n\t\t\tgbmModel = job.trainModel().get();\n\n\t\t\tSystem.out.println(\"Predict testcase \" + testcase_id);\n\t\t\tscore = gbmModel.score(trainFrame);\n\n\t\t\tSystem.out.println(\"Validate testcase \" + testcase_id);\n\t\t\t// Assert.assertTrue(gbmModel.testJavaScoring(score, trainFrame, 1e-15));\n\n\t\t\tif (isNegativeTestcase) {\n\t\t\t\tAssert.fail(\"It is negative testcase\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"Testcase is passed.\");\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tSystem.out.println(\"Testcase is failed.\");\n\t\t\tex.printStackTrace();\n\n\t\t\tif (!isNegativeTestcase) {\n\t\t\t\tAssert.fail(\"Testcase is failed\", ex);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (score != null) {\n\t\t\t\tscore.remove();\n\t\t\t\tscore.delete();\n\t\t\t}\n\t\t\tif (job != null) {\n\t\t\t\tjob.remove();\n\t\t\t}\n\t\t\tif (gbmModel != null) {\n\t\t\t\tgbmModel.delete();\n\t\t\t}\n\t\t\tScope.exit();\n\t\t}\n\t}","commit_id":"8fe42d244831dadd9491aeef0c12b0c9199dbc9d","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Test(dataProvider = \"glmCases\")\n\tpublic void basic(String testcaseId, String testDescription, String trainDatasetId,\n\t\t\tString validateDatasetId, Dataset trainDataset, Dataset validateDataset, String[] rawInput) {\n\n\t\tGLMParameters glmParams = null;\n\n\t\tredirectStandardStreams();\n\n\t\tSystem.out.println(\"\");\n\t\tSystem.out.println(String.format(\n\t\t\t\t\"Datasets: \\n\" +\n\t\t\t\t\"Train Dataset ID:      %s\\n\" +\n\t\t\t\t\"Validate Dataset ID:   %s\\n\", \n\t\t\t\ttrainDatasetId,\tvalidateDatasetId));\n\t\tSystem.out.println(\"\");\n\n\t\ttry {\n\t\t\tString validateMessage = validate(trainDatasetId, trainDataset, rawInput);\n\n\t\t\tif (validateMessage != null) {\n\t\t\t\tSystem.out.println(validateMessage);\n\t\t\t\tAssert.fail(String.format(validateMessage));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tglmParams = toGLMParameters(trainDatasetId, validateDatasetId, trainDataset, validateDataset, rawInput);\n\n\t\t\t\t_basic(testcaseId, glmParams, rawInput);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\n\t\t\t// wait 100 mili-sec for output/error to be stored\n\t\t\ttry {\n\t\t\t\tThread.sleep(100);\n\t\t\t}\n\t\t\tcatch (InterruptedException ex) {\n\t\t\t\tThread.currentThread().interrupt();\n\t\t\t}\n\n\t\t\tresetStandardStreams();\n\t\t}\n\t}","id":75335,"modified_method":"@Test(dataProvider = \"glmCases\")\n\tpublic void basic(String testcaseId, String testDescription, String trainDatasetId, String validateDatasetId,\n\t\t\tDataset trainDataset, Dataset validateDataset, boolean isNegativeTestcase, String[] rawInput) {\n\n\t\tGLMParameters glmParams = null;\n\n\t\tredirectStandardStreams();\n\n\t\tSystem.out.println(\"\");\n\t\tSystem.out.println(String.format(\n\t\t\t\t\"Datasets: \\n\" +\n\t\t\t\t\"Train Dataset ID:      %s\\n\" +\n\t\t\t\t\"Validate Dataset ID:   %s\\n\", \n\t\t\t\ttrainDatasetId,\tvalidateDatasetId));\n\t\tSystem.out.println(\"\");\n\n\t\ttry {\n\t\t\tString validateMessage = validate(trainDatasetId, trainDataset, rawInput);\n\n\t\t\tif (validateMessage != null) {\n\t\t\t\tSystem.out.println(validateMessage);\n\t\t\t\tAssert.fail(String.format(validateMessage));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tglmParams = toGLMParameters(trainDatasetId, validateDatasetId, trainDataset, validateDataset, rawInput);\n\n\t\t\t\t_basic(testcaseId, glmParams, isNegativeTestcase, rawInput);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\n\t\t\t// wait 100 mili-sec for output/error to be stored\n\t\t\ttry {\n\t\t\t\tThread.sleep(100);\n\t\t\t}\n\t\t\tcatch (InterruptedException ex) {\n\t\t\t\tThread.currentThread().interrupt();\n\t\t\t}\n\n\t\t\tresetStandardStreams();\n\t\t}\n\t}","commit_id":"8fe42d244831dadd9491aeef0c12b0c9199dbc9d","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@DataProvider(name = \"glmCases\")\n\tpublic static Object[][] glmCases() {\n\n\t\t/**\n\t\t * The first row of data is used to testing.\n\t\t */\n\t\tfinal int firstRow = 4;\n\t\tfinal String testcaseFilePath = \"h2o-testng/src/test/resources/glmCases.csv\";\n\n\t\tObject[][] data = null;\n\t\tList<String> lines = null;\n\n\t\ttry {\n\t\t\t// read data from file\n\t\t\tlines = Files.readAllLines(find_test_file_static(testcaseFilePath).toPath(), Charset.defaultCharset());\n\n\t\t}\n\t\tcatch (IOException ignore) {\n\t\t\tSystem.out.println(\"Cannot open file: \" + testcaseFilePath);\n\t\t\tignore.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\n\t\t// remove headers\n\t\tlines.removeAll(lines.subList(0, firstRow));\n\n\t\tdata = new Object[lines.size()][7];\n\t\tint r = 0;\n\n\t\tfor (String line : lines) {\n\t\t\tString[] variables = line.trim().split(\",\", -1);\n\n\t\t\tdata[r][0] = variables[tcHeaders.indexOf(\"testcase_id\")];\n\t\t\tdata[r][1] = variables[tcHeaders.indexOf(\"test_description\")];\n\t\t\tdata[r][2] = variables[tcHeaders.indexOf(\"train_dataset_id\")];\n\t\t\tdata[r][3] = variables[tcHeaders.indexOf(\"validate_dataset_id\")];\n\t\t\tdata[r][4] = dataSetCharacteristic.get(variables[tcHeaders.indexOf(\"train_dataset_id\")]);\n\t\t\tdata[r][5] = dataSetCharacteristic.get(variables[tcHeaders.indexOf(\"validate_dataset_id\")]);\n\t\t\tdata[r][6] = variables;\n\n\t\t\tr++;\n\t\t}\n\n\t\treturn data;\n\t}","id":75336,"modified_method":"@DataProvider(name = \"glmCases\")\n\tpublic static Object[][] glmCases() {\n\n\t\t/**\n\t\t * The first row of data is used to testing.\n\t\t */\n\t\tfinal int firstRow = 4;\n\t\tfinal String positiveTestcaseFilePath = \"h2o-testng/src/test/resources/glmCases.csv\";\n\t\tfinal String negativeTestcaseFilePath = \"h2o-testng/src/test/resources/glmNegCases.csv\";\n\n\t\treturn FunctionUtils.dataProvider(dataSetCharacteristic, tcHeaders, positiveTestcaseFilePath,\n\t\t\t\tnegativeTestcaseFilePath, firstRow);\n\t}","commit_id":"8fe42d244831dadd9491aeef0c12b0c9199dbc9d","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private void _basic(String testcaseId, GLMParameters glmParams, String[] rawInput) {\n\n\t\tSystem.out.println(String.format(\"Testcase: %s\", testcaseId));\n\t\t// System.out.println(String.format(\"Description: %s\", testDescription));\n\t\tSystem.out.println(\"GLM Params:\");\n\t\tfor (Param p : params) {\n\t\t\tp.print(glmParams);\n\t\t}\n\n\t\tFrame trainFrame = null;\n\t\tFrame betaConstraints = null;\n\n\t\t// Build the appropriate glm, given the above parameters\n\t\tKey modelKey = Key.make(\"model\");\n\t\tGLM job = null;\n\t\tGLMModel model = null;\n\t\tFrame score = null;\n\t\tHashMap<String, Double> coef = null;\n\n\t\ttrainFrame = glmParams._train.get();\n\t\tif (glmParams._beta_constraints != null) {\n\t\t\tbetaConstraints = glmParams._beta_constraints.get();\n\t\t}\n\n\t\ttry {\n\t\t\tScope.enter();\n\n\t\t\tSystem.out.println(\"Build model\");\n\t\t\tjob = new GLM(modelKey, \"basic glm test\", glmParams);\n\n\t\t\tSystem.out.println(\"Train model\");\n\t\t\tmodel = job.trainModel().get();\n\n\t\t\tcoef = model.coefficients();\n\n\t\t\tSystem.out.println(\"Predict testcase \" + testcaseId);\n\t\t\tscore = model.score(trainFrame);\n\n\t\t\tSystem.out.println(\"Predict success.\");\n\t\t\tSystem.out.println(\"Testcase is passed.\");\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\t// can't predict testcase\n\t\t\tex.printStackTrace();\n\t\t\tAssert.fail(\"Test is failed. It can't predict\", ex);\n\t\t}\n\t\tfinally {\n\t\t\tif (betaConstraints != null) {\n\t\t\t\tbetaConstraints.delete();\n\t\t\t}\n\t\t\tif (model != null)\n\t\t\t\tmodel.delete();\n\t\t\tif (job != null)\n\t\t\t\tjob.remove();\n\t\t\tScope.exit();\n\t\t}\n\t}","id":75337,"modified_method":"private void _basic(String testcaseId, GLMParameters glmParams, boolean isNegativeTestcase, String[] rawInput) {\n\n\t\tSystem.out.println(String.format(\"Testcase: %s\", testcaseId));\n\t\t// System.out.println(String.format(\"Description: %s\", testDescription));\n\t\tSystem.out.println(\"GLM Params:\");\n\t\tfor (Param p : params) {\n\t\t\tp.print(glmParams);\n\t\t}\n\n\t\tFrame trainFrame = null;\n\t\tFrame betaConstraints = null;\n\n\t\t// Build the appropriate glm, given the above parameters\n\t\tKey modelKey = Key.make(\"model\");\n\t\tGLM job = null;\n\t\tGLMModel model = null;\n\t\tFrame score = null;\n\t\tHashMap<String, Double> coef = null;\n\n\t\ttrainFrame = glmParams._train.get();\n\t\tif (glmParams._beta_constraints != null) {\n\t\t\tbetaConstraints = glmParams._beta_constraints.get();\n\t\t}\n\n\t\ttry {\n\t\t\tScope.enter();\n\n\t\t\tSystem.out.println(\"Build model\");\n\t\t\tjob = new GLM(modelKey, \"basic glm test\", glmParams);\n\n\t\t\tSystem.out.println(\"Train model\");\n\t\t\tmodel = job.trainModel().get();\n\n\t\t\tcoef = model.coefficients();\n\n\t\t\tSystem.out.println(\"Predict testcase \" + testcaseId);\n\t\t\tscore = model.score(trainFrame);\n\n\t\t\tSystem.out.println(\"Predict success.\");\n\n\t\t\tif (isNegativeTestcase) {\n\t\t\t\tAssert.fail(\"It is negative testcase\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"Testcase is passed.\");\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tSystem.out.println(\"Testcase is failed\");\n\t\t\tex.printStackTrace();\n\t\t\tif (!isNegativeTestcase) {\n\t\t\t\tAssert.fail(\"Testcase is failed\", ex);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (betaConstraints != null) {\n\t\t\t\tbetaConstraints.delete();\n\t\t\t}\n\t\t\tif (score != null) {\n\t\t\t\tscore.delete();\n\t\t\t}\n\t\t\tif (model != null)\n\t\t\t\tmodel.delete();\n\t\t\tif (job != null)\n\t\t\t\tjob.remove();\n\t\t\tScope.exit();\n\t\t}\n\t}","commit_id":"8fe42d244831dadd9491aeef0c12b0c9199dbc9d","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@PostConstruct\n    public void post() {\n        hello = \"hello\";\n    }","id":75338,"modified_method":"@PostConstruct\n    public void post() throws InterruptedException {\n        Thread.sleep(100);\n        hello = \"hello\";\n    }","commit_id":"e9fed888629b628677d60b00cbddbcc61699e228","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void processDependencies(final DeploymentPhaseContext phaseContext, final DeploymentUnit deploymentUnit) {\n        final DeploymentDependencies deps = deploymentUnit.getAttachment(DeploymentDependencies.ATTACHMENT_KEY);\n        if (!deps.getDependencies().isEmpty()) {\n            phaseContext.putAttachment(Attachments.NEXT_PHASE_PASSIVE, true);\n            for (final String deployment : deps.getDependencies()) {\n                final ServiceName name = Services.deploymentUnitName(deployment);\n                phaseContext.addToAttachmentList(Attachments.NEXT_PHASE_DEPS, name);\n            }\n        }\n    }","id":75339,"modified_method":"private void processDependencies(final DeploymentPhaseContext phaseContext, final DeploymentUnit deploymentUnit) {\n        final DeploymentDependencies deps = deploymentUnit.getAttachment(DeploymentDependencies.ATTACHMENT_KEY);\n        if (!deps.getDependencies().isEmpty()) {\n            for (final String deployment : deps.getDependencies()) {\n                final ServiceName name =  DeploymentCompleteServiceProcessor.serviceName(Services.deploymentUnitName(deployment));\n                phaseContext.addToAttachmentList(Attachments.NEXT_PHASE_DEPS, name);\n            }\n        }\n    }","commit_id":"e9fed888629b628677d60b00cbddbcc61699e228","url":"https://github.com/wildfly/wildfly"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public synchronized void start(final StartContext context) throws StartException {\n        final DeployerChains chains = deployerChainsInjector.getValue();\n        final DeploymentUnit deploymentUnit = this.deploymentUnit;\n        final List<RegisteredDeploymentUnitProcessor> list = chains.getChain(phase);\n        final ListIterator<RegisteredDeploymentUnitProcessor> iterator = list.listIterator();\n        final ServiceContainer container = context.getController().getServiceContainer();\n        final ServiceTarget serviceTarget = context.getChildTarget().subTarget();\n        final Phase nextPhase = phase.next();\n        final String name = deploymentUnit.getName();\n        final DeploymentUnit parent = deploymentUnit.getParent();\n        final ServiceBuilder<?> phaseServiceBuilder;\n        final DeploymentUnitPhaseService<?> phaseService;\n        if(nextPhase != null) {\n            final ServiceName serviceName = parent == null ? Services.deploymentUnitName(name, nextPhase) : Services.deploymentUnitName(parent.getName(), name, nextPhase);\n            phaseService = DeploymentUnitPhaseService.create(deploymentUnit, nextPhase);\n            phaseServiceBuilder = serviceTarget.addService(serviceName, phaseService);\n        } else {\n            phaseServiceBuilder = null;\n            phaseService = null;\n        }\n        final DeploymentPhaseContext processorContext = new DeploymentPhaseContextImpl(serviceTarget, new DelegatingServiceRegistry(container), phaseServiceBuilder, deploymentUnit, phase);\n\n        // attach any injected values from the last phase\n        for (AttachedDependency attachedDependency : injectedAttachedDependencies) {\n            final Attachable target;\n            if (attachedDependency.isDeploymentUnit()) {\n                target = deploymentUnit;\n            } else {\n                target = processorContext;\n            }\n            if (attachedDependency.getAttachmentKey() instanceof ListAttachmentKey) {\n                target.addToAttachmentList((AttachmentKey) attachedDependency.getAttachmentKey(), attachedDependency.getValue()\n                        .getValue());\n            } else {\n                target.putAttachment((AttachmentKey) attachedDependency.getAttachmentKey(), attachedDependency.getValue()\n                        .getValue());\n            }\n        }\n\n        while (iterator.hasNext()) {\n            final RegisteredDeploymentUnitProcessor processor = iterator.next();\n            try {\n                if(shouldRun(deploymentUnit, processor)) {\n                    processor.getProcessor().deploy(processorContext);\n                }\n            } catch (Throwable e) {\n                while (iterator.hasPrevious()) {\n                    final RegisteredDeploymentUnitProcessor prev = iterator.previous();\n                    safeUndeploy(deploymentUnit, phase, prev);\n                }\n                throw ServerMessages.MESSAGES.deploymentPhaseFailed(phase, deploymentUnit, e);\n            }\n        }\n        if (nextPhase != null) {\n            phaseServiceBuilder.addDependency(Services.JBOSS_DEPLOYMENT_CHAINS, DeployerChains.class, phaseService.getDeployerChainsInjector());\n            phaseServiceBuilder.addDependency(context.getController().getName());\n\n            final Boolean nextPhasePassive = processorContext.getAttachment(Attachments.NEXT_PHASE_PASSIVE);\n            if(nextPhasePassive != null && nextPhasePassive) {\n                phaseServiceBuilder.setInitialMode(ServiceController.Mode.PASSIVE);\n            }\n            final List<ServiceName> nextPhaseDeps = processorContext.getAttachment(Attachments.NEXT_PHASE_DEPS);\n            if(nextPhaseDeps != null) {\n                phaseServiceBuilder.addDependencies(nextPhaseDeps);\n            }\n            final List<AttachableDependency> nextPhaseAttachableDeps = processorContext\n                    .getAttachment(Attachments.NEXT_PHASE_ATTACHABLE_DEPS);\n            if (nextPhaseAttachableDeps != null) {\n                for (AttachableDependency attachableDep : nextPhaseAttachableDeps) {\n                    AttachedDependency result = new AttachedDependency(attachableDep.getAttachmentKey(), attachableDep\n                            .isDeploymentUnit());\n                    phaseServiceBuilder.addDependency(attachableDep.getServiceName(), result.getValue());\n                    phaseService.injectedAttachedDependencies.add(result);\n\n                }\n            }\n            if (deploymentUnit.getParent() != null) {\n                phaseServiceBuilder.addDependencies(Services.deploymentUnitName(deploymentUnit.getParent().getName(), nextPhase));\n            }\n            List<DeploymentUnit> subDeployments = deploymentUnit.getAttachmentList(Attachments.SUB_DEPLOYMENTS);\n            // make sure all sub deployments have finished this phase before moving to the next one\n            for (DeploymentUnit du : subDeployments) {\n                phaseServiceBuilder.addDependencies(du.getServiceName().append(phase.name()));\n            }\n\n            phaseServiceBuilder.install();\n        }\n    }","id":75340,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public synchronized void start(final StartContext context) throws StartException {\n        final DeployerChains chains = deployerChainsInjector.getValue();\n        final DeploymentUnit deploymentUnit = this.deploymentUnit;\n        final List<RegisteredDeploymentUnitProcessor> list = chains.getChain(phase);\n        final ListIterator<RegisteredDeploymentUnitProcessor> iterator = list.listIterator();\n        final ServiceContainer container = context.getController().getServiceContainer();\n        final ServiceTarget serviceTarget = context.getChildTarget().subTarget();\n        final Phase nextPhase = phase.next();\n        final String name = deploymentUnit.getName();\n        final DeploymentUnit parent = deploymentUnit.getParent();\n        final ServiceBuilder<?> phaseServiceBuilder;\n        final DeploymentUnitPhaseService<?> phaseService;\n        if(nextPhase != null) {\n            final ServiceName serviceName = parent == null ? Services.deploymentUnitName(name, nextPhase) : Services.deploymentUnitName(parent.getName(), name, nextPhase);\n            phaseService = DeploymentUnitPhaseService.create(deploymentUnit, nextPhase);\n            phaseServiceBuilder = serviceTarget.addService(serviceName, phaseService);\n        } else {\n            phaseServiceBuilder = null;\n            phaseService = null;\n        }\n        final DeploymentPhaseContext processorContext = new DeploymentPhaseContextImpl(serviceTarget, new DelegatingServiceRegistry(container), phaseServiceBuilder, deploymentUnit, phase);\n\n        // attach any injected values from the last phase\n        for (AttachedDependency attachedDependency : injectedAttachedDependencies) {\n            final Attachable target;\n            if (attachedDependency.isDeploymentUnit()) {\n                target = deploymentUnit;\n            } else {\n                target = processorContext;\n            }\n            if (attachedDependency.getAttachmentKey() instanceof ListAttachmentKey) {\n                target.addToAttachmentList((AttachmentKey) attachedDependency.getAttachmentKey(), attachedDependency.getValue()\n                        .getValue());\n            } else {\n                target.putAttachment((AttachmentKey) attachedDependency.getAttachmentKey(), attachedDependency.getValue()\n                        .getValue());\n            }\n        }\n\n        while (iterator.hasNext()) {\n            final RegisteredDeploymentUnitProcessor processor = iterator.next();\n            try {\n                if(shouldRun(deploymentUnit, processor)) {\n                    processor.getProcessor().deploy(processorContext);\n                }\n            } catch (Throwable e) {\n                while (iterator.hasPrevious()) {\n                    final RegisteredDeploymentUnitProcessor prev = iterator.previous();\n                    safeUndeploy(deploymentUnit, phase, prev);\n                }\n                throw ServerMessages.MESSAGES.deploymentPhaseFailed(phase, deploymentUnit, e);\n            }\n        }\n        if (nextPhase != null) {\n            phaseServiceBuilder.addDependency(Services.JBOSS_DEPLOYMENT_CHAINS, DeployerChains.class, phaseService.getDeployerChainsInjector());\n            phaseServiceBuilder.addDependency(context.getController().getName());\n\n            final List<ServiceName> nextPhaseDeps = processorContext.getAttachment(Attachments.NEXT_PHASE_DEPS);\n            if(nextPhaseDeps != null) {\n                phaseServiceBuilder.addDependencies(nextPhaseDeps);\n            }\n            final List<AttachableDependency> nextPhaseAttachableDeps = processorContext\n                    .getAttachment(Attachments.NEXT_PHASE_ATTACHABLE_DEPS);\n            if (nextPhaseAttachableDeps != null) {\n                for (AttachableDependency attachableDep : nextPhaseAttachableDeps) {\n                    AttachedDependency result = new AttachedDependency(attachableDep.getAttachmentKey(), attachableDep\n                            .isDeploymentUnit());\n                    phaseServiceBuilder.addDependency(attachableDep.getServiceName(), result.getValue());\n                    phaseService.injectedAttachedDependencies.add(result);\n\n                }\n            }\n            if (deploymentUnit.getParent() != null) {\n                phaseServiceBuilder.addDependencies(Services.deploymentUnitName(deploymentUnit.getParent().getName(), nextPhase));\n            }\n            List<DeploymentUnit> subDeployments = deploymentUnit.getAttachmentList(Attachments.SUB_DEPLOYMENTS);\n            // make sure all sub deployments have finished this phase before moving to the next one\n            for (DeploymentUnit du : subDeployments) {\n                phaseServiceBuilder.addDependencies(du.getServiceName().append(phase.name()));\n            }\n\n            phaseServiceBuilder.install();\n        }\n    }","commit_id":"e9fed888629b628677d60b00cbddbcc61699e228","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testDeploymentDependencies() throws NamingException {\n        try {\n            deployer.deploy(\"dependent\");\n\n            try {\n                new InitialContext().lookup(\"java:global/dependent/DependentEjb\");\n                Assert.fail(\"deployment should have waited\");\n            } catch (NamingException e) {\n                //expected\n            }\n\n            deployer.deploy(\"dependee\");\n\n            StringView ejb = (StringView) new InitialContext().lookup(\"java:global/dependent/DependentEjb\");\n            Assert.assertEquals(\"hello\", ejb.getString());\n\n        } finally {\n            deployer.undeploy(\"dependent\");\n            deployer.undeploy(\"dependee\");\n        }\n\n    }","id":75341,"modified_method":"@Test\n    public void testDeploymentDependencies() throws NamingException {\n        try {\n            boolean failed = true;\n            try {\n                deployer.deploy(\"dependent\");\n                failed = false;\n            } catch (Exception e) {\n\n            } finally {\n                deployer.undeploy(\"dependent\");\n            }\n            if(!failed) {\n                Assert.fail(\"Deployment did not fail\");\n            }\n            deployer.deploy(\"dependee\");\n            deployer.deploy(\"dependent\");\n\n            StringView ejb = (StringView) new InitialContext().lookup(\"java:global/dependent/DependentEjb\");\n            Assert.assertEquals(\"hello\", ejb.getString());\n\n        } finally {\n            deployer.undeploy(\"dependent\");\n            deployer.undeploy(\"dependee\");\n        }\n\n    }","commit_id":"e9fed888629b628677d60b00cbddbcc61699e228","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void remoteExecuteAgentOnServer(final InstallationDetails details, final long end, final String targetHost)\r\n\t\t\tthrows InstallerException, TimeoutException, InterruptedException {\r\n\r\n\t\t// get script for execution mode\r\n\t\tfinal String scriptFileName = getScriptFileName(details);\r\n\r\n\t\tString remoteDirectory = details.getRemoteDir();\r\n\t\tif (remoteDirectory.endsWith(\"/\")) {\r\n\t\t\tremoteDirectory = remoteDirectory.substring(0, remoteDirectory.length() - 1);\r\n\t\t}\r\n\t\tif (details.isLus()) { \r\n\t\t\t// add the relative path to the cloud file location\r\n\t\t\tremoteDirectory = remoteDirectory + \"/\" + details.getRelativeLocalDir();\r\n\t\t}\r\n\r\n\t\tfinal String scriptPath = remoteDirectory + \"/\" + scriptFileName;\r\n\r\n\t\tString authGroups = null;\r\n\t\tif (details.getAuthGroups() != null) {\r\n\t\t\t//authgroups should be a strongly typed object convertible into a String\r\n\t\t\tauthGroups = details.getAuthGroups();\r\n\t\t}\r\n\t\t\r\n\t\tfinal ShellCommandBuilder scb = new ShellCommandBuilder(details.getRemoteExecutionMode())\r\n\t\t\t\t.exportVar(LUS_IP_ADDRESS_ENV, details.getLocator())\r\n\t\t\t\t.exportVar(GSA_MODE_ENV, details.isLus() ? \"lus\" : \"agent\")\r\n\t\t\t\t.exportVar(CloudifyConstants.SPRING_ACTIVE_PROFILE_ENV_VAR,\tdetails.getSecurityProfile())\r\n\t\t\t\t.exportVar(NO_WEB_SERVICES_ENV,\r\n\t\t\t\t\t\tdetails.isNoWebServices() ? \"true\" : \"false\")\r\n\t\t\t\t.exportVar(\r\n\t\t\t\t\t\tMACHINE_IP_ADDRESS_ENV,\r\n\t\t\t\t\t\tdetails.isBindToPrivateIp() ? details.getPrivateIp()\r\n\t\t\t\t\t\t\t\t: details.getPublicIp())\r\n\t\t\t\t.exportVar(MACHINE_ZONES_ENV, details.getZones())\r\n\t\t\t\t.exportVar(CloudifyConstants.CLOUDIFY_LINK_ENV,\r\n\t\t\t\t\t\tdetails.getCloudifyUrl() != null ? \"\\\"\" + details.getCloudifyUrl() + \"\\\"\" : \"\")\r\n\t\t\t\t.exportVar(CloudifyConstants.CLOUDIFY_OVERRIDES_LINK_ENV,\r\n\t\t\t\t\t\tdetails.getOverridesUrl() != null ? \"\\\"\" + details.getOverridesUrl() + \"\\\"\" : \"\")\r\n\t\t\t\t.exportVar(WORKING_HOME_DIRECTORY_ENV, remoteDirectory)\r\n\t\t\t\t.exportVar(CloudifyConstants.GIGASPACES_AUTH_GROUPS, authGroups)\r\n\t\t\t\t.exportVar(CloudifyConstants.GIGASPACES_AGENT_ENV_PRIVATE_IP, details.getPrivateIp())\r\n\t\t\t\t.exportVar(CloudifyConstants.GIGASPACES_AGENT_ENV_PUBLIC_IP, details.getPublicIp())\r\n\t\t\t\t.exportVar(CloudifyConstants.GIGASPACES_CLOUD_TEMPLATE_NAME, details.getTemplateName())\r\n\t\t\t\t.exportVar(CloudifyConstants.GIGASPACES_CLOUD_MACHINE_ID, details.getMachineId())\r\n\t\t\t\t.exportVar(CloudifyConstants.CLOUDIFY_CLOUD_MACHINE_ID, details.getMachineId())\r\n\r\n\t\t\t\t// maintain backwards compatibility for pre 2.3.0\r\n\t\t\t\t.exportVar(CloudifyConstants.CLOUDIFY_AGENT_ENV_PRIVATE_IP, details.getPrivateIp())\r\n\t\t\t\t.exportVar(CloudifyConstants.CLOUDIFY_AGENT_ENV_PUBLIC_IP, details.getPublicIp());\r\n\t\t\t\r\n\t\tif (details.getReservationId() != null) {\r\n\t\t\tscb.exportVar(GSA_RESERVATION_ID_ENV, details.getReservationId().toString());\r\n\t\t}\r\n\r\n\t\tif (details.isLus()) {\r\n\t\t\tString remotePath = details.getRemoteDir();\r\n\t\t\tif (!remotePath.endsWith(\"/\")) {\r\n\t\t\t\tremotePath += \"/\";\r\n\t\t\t}\r\n\t\t\tscb.exportVar(CLOUD_FILE, remotePath + details.getCloudFile().getName());\r\n\t\t\t\r\n\t\t\tlogger.log(Level.FINE, \"Setting ESM/GSM/LUS/GSA/GSC java options\");\r\n\t\t\t\r\n\t\t\tscb.exportVar(\"ESM_JAVA_OPTIONS\", details.getEsmCommandlineArgs());\r\n\t\t\tscb.exportVar(\"LUS_JAVA_OPTIONS\", details.getLusCommandlineArgs());\r\n\t\t\tscb.exportVar(\"GSM_JAVA_OPTIONS\", details.getGsmCommandlineArgs());\r\n\t\t\tscb.exportVar(\"GSA_JAVA_OPTIONS\", details.getGsaCommandlineArgs());\r\n\t\t\tscb.exportVar(\"GSC_JAVA_OPTIONS\", details.getGscCommandlineArgs());\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tscb.exportVar(CloudifyConstants.REST_PORT_ENV_VAR, details.getRestPort().toString());\r\n\t\t\tscb.exportVar(CloudifyConstants.REST_MAX_MEMORY_ENVIRONMENT_VAR, details.getRestMaxMemory());\r\n\t\t\t\r\n\t\t\tscb.exportVar(CloudifyConstants.WEBUI_PORT_ENV_VAR, details.getWebuiPort().toString());\r\n\t\t\tscb.exportVar(CloudifyConstants.WEBUI_MAX_MEMORY_ENVIRONMENT_VAR, details.getWebuiMaxMemory());\r\n\t\t}\r\n\t\t\r\n\t\tif (details.getUsername() != null) {\r\n\t\t\tscb.exportVar(\"USERNAME\", details.getUsername());\r\n\t\t}\r\n\t\tif (details.getPassword() != null) {\r\n\t\t\tscb.exportVar(\"PASSWORD\", details.getPassword());\r\n\t\t}\r\n\t\tscb.exportVar(CloudifyConstants.SPRING_SECURITY_CONFIG_FILE_ENV_VAR, details.getRemoteDir() \r\n\t\t\t\t+ \"/\" + CloudifyConstants.SECURITY_FILE_NAME);\r\n\t\tif (StringUtils.isNotBlank(details.getKeystorePassword())) {\r\n\t\t\tscb.exportVar(CloudifyConstants.KEYSTORE_FILE_ENV_VAR, details.getRemoteDir() \r\n\t\t\t\t\t+ \"/\" + CloudifyConstants.KEYSTORE_FILE_NAME);\r\n\t\t\tscb.exportVar(CloudifyConstants.KEYSTORE_PASSWORD_ENV_VAR, details.getKeystorePassword());\r\n\t\t}\r\n\r\n\t\tfinal Set<Entry<String, String>> entries = details.getExtraRemoteEnvironmentVariables().entrySet();\r\n\t\tfor (final Entry<String, String> entry : entries) {\r\n\t\t\tscb.exportVar(entry.getKey(), entry.getValue());\r\n\t\t}\r\n\r\n\t\tscb.chmodExecutable(scriptPath).call(scriptPath);\r\n\r\n\t\tfinal String command = scb.toString();\r\n\r\n\t\tlogger.fine(\"Calling startup script on target: \" + targetHost + \" with LOCATOR=\" + details.getLocator()\r\n\t\t\t\t+ \"\\nThis may take a few minutes. command is: \" + command);\r\n\r\n\t\tswitch (details.getRemoteExecutionMode()) {\r\n\t\tcase SSH:\r\n\t\t\tsshCommand(targetHost, command, details.getUsername(), details.getPassword(), details.getKeyFile(),\r\n\t\t\t\t\tCalcUtils.millisUntil(end), TimeUnit.MILLISECONDS);\r\n\r\n\t\t\tbreak;\r\n\t\tcase WINRM:\r\n\t\t\tpowershellCommand(targetHost, command, details.getUsername(), details.getPassword(), details.getKeyFile(),\r\n\t\t\t\t\tCalcUtils.millisUntil(end), TimeUnit.MILLISECONDS, details.getLocalDir());\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tthrow new UnsupportedOperationException();\r\n\t\t}\r\n\t}","id":75342,"modified_method":"private void remoteExecuteAgentOnServer(final InstallationDetails details, final long end, final String targetHost)\r\n\t\t\tthrows InstallerException, TimeoutException, InterruptedException {\r\n\r\n\t\t// get script for execution mode\r\n\t\tfinal String scriptFileName = getScriptFileName(details);\r\n\r\n\t\tString remoteDirectory = details.getRemoteDir();\r\n\t\tif (remoteDirectory.endsWith(\"/\")) {\r\n\t\t\tremoteDirectory = remoteDirectory.substring(0, remoteDirectory.length() - 1);\r\n\t\t}\r\n\t\tif (details.isLus()) { \r\n\t\t\t// add the relative path to the cloud file location\r\n\t\t\tremoteDirectory = remoteDirectory + \"/\" + details.getRelativeLocalDir();\r\n\t\t}\r\n\r\n\t\tfinal String scriptPath = remoteDirectory + \"/\" + scriptFileName;\r\n\r\n\t\tString authGroups = null;\r\n\t\tif (details.getAuthGroups() != null) {\r\n\t\t\t//authgroups should be a strongly typed object convertible into a String\r\n\t\t\tauthGroups = details.getAuthGroups();\r\n\t\t}\r\n\t\t\r\n\t\tfinal ShellCommandBuilder scb = new ShellCommandBuilder(details.getRemoteExecutionMode())\r\n\t\t\t\t.exportVar(LUS_IP_ADDRESS_ENV, details.getLocator())\r\n\t\t\t\t.exportVar(GSA_MODE_ENV, details.isLus() ? \"lus\" : \"agent\")\r\n\t\t\t\t.exportVar(CloudifyConstants.SPRING_ACTIVE_PROFILE_ENV_VAR,\tdetails.getSecurityProfile())\r\n\t\t\t\t.exportVar(NO_WEB_SERVICES_ENV,\r\n\t\t\t\t\t\tdetails.isNoWebServices() ? \"true\" : \"false\")\r\n\t\t\t\t.exportVar(\r\n\t\t\t\t\t\tMACHINE_IP_ADDRESS_ENV,\r\n\t\t\t\t\t\tdetails.isBindToPrivateIp() ? details.getPrivateIp()\r\n\t\t\t\t\t\t\t\t: details.getPublicIp())\r\n\t\t\t\t.exportVar(MACHINE_ZONES_ENV, details.getZones())\r\n\t\t\t\t.exportVar(CloudifyConstants.CLOUDIFY_LINK_ENV,\r\n\t\t\t\t\t\tdetails.getCloudifyUrl() != null ? \"\\\"\" + details.getCloudifyUrl() + \"\\\"\" : \"\")\r\n\t\t\t\t.exportVar(CloudifyConstants.CLOUDIFY_OVERRIDES_LINK_ENV,\r\n\t\t\t\t\t\tdetails.getOverridesUrl() != null ? \"\\\"\" + details.getOverridesUrl() + \"\\\"\" : \"\")\r\n\t\t\t\t.exportVar(WORKING_HOME_DIRECTORY_ENV, remoteDirectory)\r\n\t\t\t\t.exportVar(CloudifyConstants.GIGASPACES_AUTH_GROUPS, authGroups)\r\n\t\t\t\t.exportVar(CloudifyConstants.GIGASPACES_AGENT_ENV_PRIVATE_IP, details.getPrivateIp())\r\n\t\t\t\t.exportVar(CloudifyConstants.GIGASPACES_AGENT_ENV_PUBLIC_IP, details.getPublicIp())\r\n\t\t\t\t.exportVar(CloudifyConstants.GIGASPACES_CLOUD_TEMPLATE_NAME, details.getTemplateName())\r\n\t\t\t\t.exportVar(CloudifyConstants.GIGASPACES_CLOUD_MACHINE_ID, details.getMachineId())\r\n\t\t\t\t.exportVar(CloudifyConstants.CLOUDIFY_CLOUD_MACHINE_ID, details.getMachineId())\r\n\r\n\t\t\t\t// maintain backwards compatibility for pre 2.3.0\r\n\t\t\t\t.exportVar(CloudifyConstants.CLOUDIFY_AGENT_ENV_PRIVATE_IP, details.getPrivateIp())\r\n\t\t\t\t.exportVar(CloudifyConstants.CLOUDIFY_AGENT_ENV_PUBLIC_IP, details.getPublicIp());\r\n\t\t\t\r\n\t\tif (details.getReservationId() != null) {\r\n\t\t\tscb.exportVar(GSA_RESERVATION_ID_ENV, details.getReservationId().toString());\r\n\t\t}\r\n\r\n\t\tif (details.isLus()) {\r\n\t\t\tString remotePath = details.getRemoteDir();\r\n\t\t\tif (!remotePath.endsWith(\"/\")) {\r\n\t\t\t\tremotePath += \"/\";\r\n\t\t\t}\r\n\t\t\tscb.exportVar(CLOUD_FILE, remotePath + details.getCloudFile().getName());\r\n\t\t\t\r\n\t\t\tlogger.log(Level.FINE, \"Setting ESM/GSM/LUS/GSA/GSC java options\");\r\n\t\t\t\r\n\t\t\tscb.exportVar(\"ESM_JAVA_OPTIONS\", details.getEsmCommandlineArgs());\r\n\t\t\tscb.exportVar(\"LUS_JAVA_OPTIONS\", details.getLusCommandlineArgs());\r\n\t\t\tscb.exportVar(\"GSM_JAVA_OPTIONS\", details.getGsmCommandlineArgs());\r\n\t\t\tscb.exportVar(\"GSA_JAVA_OPTIONS\", details.getGsaCommandlineArgs());\r\n\t\t\tscb.exportVar(\"GSC_JAVA_OPTIONS\", details.getGscCommandlineArgs());\r\n\t\t\t\r\n\t\t\tif (details.getRestPort() != null) {\r\n\t\t\t\tscb.exportVar(CloudifyConstants.REST_PORT_ENV_VAR, details.getRestPort().toString());\r\n\t\t\t}\r\n\t\t\tif (details.getRestMaxMemory() != null) {\r\n\t\t\t\tscb.exportVar(CloudifyConstants.REST_MAX_MEMORY_ENVIRONMENT_VAR, details.getRestMaxMemory());\r\n\t\t\t}\r\n\t\t\tif (details.getWebuiPort() != null) {\r\n\t\t\t\tscb.exportVar(CloudifyConstants.WEBUI_PORT_ENV_VAR, details.getWebuiPort().toString());\r\n\t\t\t}\r\n\t\t\tif (details.getWebuiMaxMemory() != null) {\r\n\t\t\t\tscb.exportVar(CloudifyConstants.WEBUI_MAX_MEMORY_ENVIRONMENT_VAR, details.getWebuiMaxMemory());\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (details.getUsername() != null) {\r\n\t\t\tscb.exportVar(\"USERNAME\", details.getUsername());\r\n\t\t}\r\n\t\tif (details.getPassword() != null) {\r\n\t\t\tscb.exportVar(\"PASSWORD\", details.getPassword());\r\n\t\t}\r\n\t\tscb.exportVar(CloudifyConstants.SPRING_SECURITY_CONFIG_FILE_ENV_VAR, details.getRemoteDir() \r\n\t\t\t\t+ \"/\" + CloudifyConstants.SECURITY_FILE_NAME);\r\n\t\tif (StringUtils.isNotBlank(details.getKeystorePassword())) {\r\n\t\t\tscb.exportVar(CloudifyConstants.KEYSTORE_FILE_ENV_VAR, details.getRemoteDir() \r\n\t\t\t\t\t+ \"/\" + CloudifyConstants.KEYSTORE_FILE_NAME);\r\n\t\t\tscb.exportVar(CloudifyConstants.KEYSTORE_PASSWORD_ENV_VAR, details.getKeystorePassword());\r\n\t\t}\r\n\r\n\t\tfinal Set<Entry<String, String>> entries = details.getExtraRemoteEnvironmentVariables().entrySet();\r\n\t\tfor (final Entry<String, String> entry : entries) {\r\n\t\t\tscb.exportVar(entry.getKey(), entry.getValue());\r\n\t\t}\r\n\r\n\t\tscb.chmodExecutable(scriptPath).call(scriptPath);\r\n\r\n\t\tfinal String command = scb.toString();\r\n\r\n\t\tlogger.fine(\"Calling startup script on target: \" + targetHost + \" with LOCATOR=\" + details.getLocator()\r\n\t\t\t\t+ \"\\nThis may take a few minutes. command is: \" + command);\r\n\r\n\t\tswitch (details.getRemoteExecutionMode()) {\r\n\t\tcase SSH:\r\n\t\t\tsshCommand(targetHost, command, details.getUsername(), details.getPassword(), details.getKeyFile(),\r\n\t\t\t\t\tCalcUtils.millisUntil(end), TimeUnit.MILLISECONDS);\r\n\r\n\t\t\tbreak;\r\n\t\tcase WINRM:\r\n\t\t\tpowershellCommand(targetHost, command, details.getUsername(), details.getPassword(), details.getKeyFile(),\r\n\t\t\t\t\tCalcUtils.millisUntil(end), TimeUnit.MILLISECONDS, details.getLocalDir());\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tthrow new UnsupportedOperationException();\r\n\t\t}\r\n\t}","commit_id":"b0fe4c1884dd7ba265c046e9999b96c7dc9de768","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Nullable\n  @Override\n  public FileAnnotation restore(@NotNull VcsAnnotation vcsAnnotation,\n                                @NotNull VcsAbstractHistorySession session,\n                                @NotNull String annotatedContent,\n                                boolean forCurrentRevision,\n                                VcsRevisionNumber revisionNumber) {\n    VirtualFile virtualFile = vcsAnnotation.getFilePath().getVirtualFile();\n    if (virtualFile == null) return null;\n    final VcsLineAnnotationData basicAnnotation = vcsAnnotation.getBasicAnnotation();\n    final int size = basicAnnotation.getNumLines();\n    final Map<VcsRevisionNumber, VcsFileRevision> historyAsMap = session.getHistoryAsMap();\n    final List<LineInfo> lines = new ArrayList<>();\n    for (int i = 0; i < size; i++) {\n      final GitRevisionNumber revision = (GitRevisionNumber)basicAnnotation.getRevision(i);\n      final GitFileRevision vcsFileRevision = (GitFileRevision)historyAsMap.get(revision);\n      if (vcsFileRevision == null) {\n        return null;\n      }\n      lines.add(new LineInfo(vcsFileRevision.getRevisionDate(), revision, vcsFileRevision.getAuthor()));\n    }\n    return new GitFileAnnotation(myProject, virtualFile, revisionNumber, annotatedContent, lines);\n  }","id":75343,"modified_method":"@Nullable\n  @Override\n  public FileAnnotation restore(@NotNull VcsAnnotation vcsAnnotation,\n                                VcsRevisionNumber revisionNumber) {\n    VirtualFile virtualFile = vcsAnnotation.getFilePath().getVirtualFile();\n    if (virtualFile == null) return null;\n    final VcsLineAnnotationData basicAnnotation = vcsAnnotation.getBasicAnnotation();\n    final int size = basicAnnotation.getNumLines();\n\n    final List<? extends VcsRevisionDescription> descriptions = vcsAnnotation.getDescriptions();\n    Map<VcsRevisionNumber, VcsRevisionDescription> map =\n      ContainerUtil.map2Map(descriptions, description -> Pair.create(description.getRevisionNumber(), description));\n    final List<LineInfo> lines = new ArrayList<>();\n    for (int i = 0; i < size; i++) {\n      final GitRevisionNumber revision = (GitRevisionNumber)basicAnnotation.getRevision(i);\n      final VcsRevisionDescription vcsFileRevision = map.get(revision);\n      if (vcsFileRevision == null) {\n        return null;\n      }\n      lines.add(new LineInfo(vcsFileRevision.getRevisionDate(), revision, vcsFileRevision.getAuthor()));\n    }\n    return new GitFileAnnotation(myProject, virtualFile, revisionNumber, lines);\n  }","commit_id":"77f0aa1b884412900d526878f69f8647c5802e36","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public VcsAnnotation createCacheable(FileAnnotation fileAnnotation) {\n    final GitFileAnnotation gitFileAnnotation = (GitFileAnnotation) fileAnnotation;\n    final int size = gitFileAnnotation.getNumLines();\n    final VcsUsualLineAnnotationData basicData = new VcsUsualLineAnnotationData(size);\n    for (int i = 0; i < size; i++) {\n      basicData.put(i,  gitFileAnnotation.getLineRevisionNumber(i));\n    }\n    return new VcsAnnotation(VcsUtil.getFilePath(gitFileAnnotation.getFile()), basicData, null);\n  }","id":75344,"modified_method":"@Override\n  public VcsAnnotation createCacheable(FileAnnotation fileAnnotation) {\n    final GitFileAnnotation gitFileAnnotation = (GitFileAnnotation) fileAnnotation;\n    final int size = gitFileAnnotation.getNumLines();\n    final VcsUsualLineAnnotationData basicData = new VcsUsualLineAnnotationData(size);\n    for (int i = 0; i < size; i++) {\n      basicData.put(i,  gitFileAnnotation.getLineRevisionNumber(i));\n    }\n    return new VcsAnnotation(VcsUtil.getFilePath(gitFileAnnotation.getFile()), basicData, null, gitFileAnnotation.getRevisionDescriptions());\n  }","commit_id":"77f0aa1b884412900d526878f69f8647c5802e36","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private GitFileAnnotation parseAnnotations(@Nullable VcsRevisionNumber revision,\n                                             @NotNull VirtualFile file,\n                                             @NotNull String output) throws VcsException {\n    try {\n      StringBuilder content = new StringBuilder();\n      List<LineInfo> lines = new ArrayList<>();\n      HashMap<String, LineInfo> commits = new HashMap<>();\n      for (StringScanner s = new StringScanner(output); s.hasMoreData(); ) {\n        // parse header line\n        String commitHash = s.spaceToken();\n        if (commitHash.equals(GitRevisionNumber.NOT_COMMITTED_HASH)) {\n          commitHash = null;\n        }\n        s.spaceToken(); // skip revision line number\n        String s1 = s.spaceToken();\n        int lineNum = Integer.parseInt(s1);\n        s.nextLine();\n        // parse commit information\n        LineInfo commit = commits.get(commitHash);\n        if (commit != null || commitHash == null) {\n          while (s.hasMoreData() && !s.startsWith('\\t')) {\n            s.nextLine();\n          }\n        }\n        else {\n          GitRevisionNumber revisionNumber = null;\n          Date committerDate = null;\n          String author = null;\n\n          while (s.hasMoreData() && !s.startsWith('\\t')) {\n            String key = s.spaceToken();\n            String value = s.line();\n            if (AUTHOR_KEY.equals(key)) {\n              author = value;\n            }\n            if (COMMITTER_TIME_KEY.equals(key)) {\n              committerDate = GitUtil.parseTimestamp(value);\n              revisionNumber = new GitRevisionNumber(commitHash, committerDate);\n            }\n          }\n          commit = new LineInfo(committerDate, revisionNumber, author);\n          commits.put(commitHash, commit);\n        }\n        // parse line\n        if (!s.hasMoreData()) {\n          // if the file is empty, the next line will not start with tab and it will be\n          // empty.\n          continue;\n        }\n        s.skipChars(1);\n\n        int expectedLineNum = lines.size() + 1;\n        if (lineNum != expectedLineNum) {\n          throw new VcsException(\"Adding for info for line \" + lineNum + \" but we are expecting it to be for \" + expectedLineNum);\n        }\n\n        content.append(s.line(true));\n        lines.add(commit);\n      }\n      return new GitFileAnnotation(myProject, file, revision, content.toString(), lines);\n    }\n    catch (Exception e) {\n      LOG.error(\"Couldn't parse annotation: \" + e, new Attachment(\"output.txt\", output));\n      throw new VcsException(e);\n    }\n  }","id":75345,"modified_method":"@NotNull\n  private GitFileAnnotation parseAnnotations(@Nullable VcsRevisionNumber revision,\n                                             @NotNull VirtualFile file,\n                                             @NotNull String output) throws VcsException {\n    try {\n      List<LineInfo> lines = new ArrayList<>();\n      HashMap<String, LineInfo> commits = new HashMap<>();\n      for (StringScanner s = new StringScanner(output); s.hasMoreData(); ) {\n        // parse header line\n        String commitHash = s.spaceToken();\n        if (commitHash.equals(GitRevisionNumber.NOT_COMMITTED_HASH)) {\n          commitHash = null;\n        }\n        s.spaceToken(); // skip revision line number\n        String s1 = s.spaceToken();\n        int lineNum = Integer.parseInt(s1);\n        s.nextLine();\n        // parse commit information\n        LineInfo commit = commits.get(commitHash);\n        if (commit != null || commitHash == null) {\n          while (s.hasMoreData() && !s.startsWith('\\t')) {\n            s.nextLine();\n          }\n        }\n        else {\n          GitRevisionNumber revisionNumber = null;\n          Date committerDate = null;\n          String author = null;\n\n          while (s.hasMoreData() && !s.startsWith('\\t')) {\n            String key = s.spaceToken();\n            String value = s.line();\n            if (AUTHOR_KEY.equals(key)) {\n              author = value;\n            }\n            if (COMMITTER_TIME_KEY.equals(key)) {\n              committerDate = GitUtil.parseTimestamp(value);\n              revisionNumber = new GitRevisionNumber(commitHash, committerDate);\n            }\n          }\n          commit = new LineInfo(committerDate, revisionNumber, author);\n          commits.put(commitHash, commit);\n        }\n        // parse line\n        if (!s.hasMoreData()) {\n          // if the file is empty, the next line will not start with tab and it will be\n          // empty.\n          continue;\n        }\n        s.skipChars(1);\n\n        int expectedLineNum = lines.size() + 1;\n        if (lineNum != expectedLineNum) {\n          throw new VcsException(\"Adding for info for line \" + lineNum + \" but we are expecting it to be for \" + expectedLineNum);\n        }\n\n        s.line(true);\n        lines.add(commit);\n      }\n      return new GitFileAnnotation(myProject, file, revision, lines);\n    }\n    catch (Exception e) {\n      LOG.error(\"Couldn't parse annotation: \" + e, new Attachment(\"output.txt\", output));\n      throw new VcsException(e);\n    }\n  }","commit_id":"77f0aa1b884412900d526878f69f8647c5802e36","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public String getAnnotatedContent() {\n    return myAnnotatedContent;\n  }","id":75346,"modified_method":"@NotNull\n  @Override\n  public String getAnnotatedContent() {\n    ContentRevision revision = GitContentRevision.createRevision(myFile, myBaseRevision, myProject);\n    try {\n      return revision.getContent();\n    }\n    catch (VcsException e) {\n      throw new RuntimeException(e);\n    }\n  }","commit_id":"77f0aa1b884412900d526878f69f8647c5802e36","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GitFileAnnotation(@NotNull final Project project,\n                           @NotNull VirtualFile file,\n                           @Nullable final VcsRevisionNumber revision,\n                           @NotNull String annotatedContent,\n                           @NotNull List<LineInfo> lines) {\n    super(project);\n    myProject = project;\n    myFile = file;\n    myVcs = ObjectUtils.assertNotNull(GitVcs.getInstance(myProject));\n    myBaseRevision = revision == null ? (myVcs.getDiffProvider().getCurrentRevision(file)) : revision;\n\n    myAnnotatedContent = annotatedContent;\n    myLines = lines;\n    THashSet<VcsRevisionDescription> descriptions = new THashSet<>(lines, new TObjectHashingStrategy<VcsRevisionDescription>() {\n      @Override\n      public int computeHashCode(VcsRevisionDescription object) {\n        return object.getRevisionNumber().asString().hashCode();\n      }\n\n      @Override\n      public boolean equals(VcsRevisionDescription o1, VcsRevisionDescription o2) {\n        return o1.getRevisionNumber().compareTo(o2.getRevisionNumber()) == 0;\n      }\n    });\n    myRevisions = new ArrayList<>(descriptions);\n    myRevisions.sort((o1, o2) -> o2.getRevisionDate().compareTo(o1.getRevisionDate()));\n  }","id":75347,"modified_method":"public GitFileAnnotation(@NotNull final Project project,\n                           @NotNull VirtualFile file,\n                           @Nullable final VcsRevisionNumber revision,\n                           @NotNull List<LineInfo> lines) {\n    super(project);\n    myProject = project;\n    myFile = file;\n    myVcs = ObjectUtils.assertNotNull(GitVcs.getInstance(myProject));\n    myBaseRevision = revision == null ? (myVcs.getDiffProvider().getCurrentRevision(file)) : revision;\n\n    myLines = lines;\n    THashSet<VcsRevisionDescription> descriptions = new THashSet<>(lines, new TObjectHashingStrategy<VcsRevisionDescription>() {\n      @Override\n      public int computeHashCode(VcsRevisionDescription object) {\n        return object.getRevisionNumber().asString().hashCode();\n      }\n\n      @Override\n      public boolean equals(VcsRevisionDescription o1, VcsRevisionDescription o2) {\n        return o1.getRevisionNumber().compareTo(o2.getRevisionNumber()) == 0;\n      }\n    });\n    myRevisions = new ArrayList<>(descriptions);\n    myRevisions.sort((o1, o2) -> o2.getRevisionDate().compareTo(o1.getRevisionDate()));\n  }","commit_id":"77f0aa1b884412900d526878f69f8647c5802e36","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public VcsAnnotation(FilePath filePath, VcsLineAnnotationData basicAnnotation, VcsRevisionNumber lastRevision) {\n    myBasicAnnotation = basicAnnotation;\n    myLastRevision = lastRevision;\n    myAdditionalAnnotations = new HashMap<>();\n    myCachedOtherRevisions = new HashMap<>();\n    myFilePath = filePath;\n  }","id":75348,"modified_method":"public VcsAnnotation(FilePath filePath, VcsLineAnnotationData basicAnnotation, VcsRevisionNumber lastRevision) {\n    this(filePath, basicAnnotation, lastRevision, null);\n  }","commit_id":"77f0aa1b884412900d526878f69f8647c5802e36","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @param currentRevision - just a hint for optimization\n   */\n  private FileAnnotation annotate(VirtualFile file, final VcsRevisionNumber revisionNumber, final boolean currentRevision,\n                                  final ThrowableComputable<FileAnnotation, VcsException> delegate) throws VcsException {\n    final AnnotationProvider annotationProvider = myAnnotationProvider;\n\n    final FilePath filePath = VcsContextFactory.SERVICE.getInstance().createFilePathOn(file);\n\n    final VcsCacheableAnnotationProvider cacheableAnnotationProvider = (VcsCacheableAnnotationProvider)annotationProvider;\n\n    VcsAnnotation vcsAnnotation = null;\n    if (revisionNumber != null) {\n      vcsAnnotation = myCache.get(VcsContextFactory.SERVICE.getInstance().createFilePathOn(file), myVcs.getKeyInstanceMethod(), revisionNumber);\n    }\n\n    if (vcsAnnotation != null) {\n      final VcsHistoryProvider historyProvider = myVcs.getVcsHistoryProvider();\n      final VcsAbstractHistorySession history = getHistory(revisionNumber, filePath, historyProvider, vcsAnnotation.getFirstRevision());\n      if (history == null) return null;\n      // question is whether we need \"not moved\" path here?\n      final ContentRevision fileContent = myVcs.getDiffProvider().createFileContent(revisionNumber, file);\n      final FileAnnotation restored = cacheableAnnotationProvider.\n        restore(vcsAnnotation, history, fileContent.getContent(), currentRevision,\n                                                                          revisionNumber);\n      if (restored != null) {\n        return restored;\n      }\n    }\n\n    final FileAnnotation fileAnnotation = delegate.compute();\n    vcsAnnotation = cacheableAnnotationProvider.createCacheable(fileAnnotation);\n    if (vcsAnnotation == null) return fileAnnotation;\n\n    if (revisionNumber != null) {\n      myCache.put(filePath, myVcs.getKeyInstanceMethod(), revisionNumber, vcsAnnotation);\n    }\n\n    if (myVcs.getVcsHistoryProvider() instanceof VcsCacheableHistorySessionFactory) {\n      loadHistoryInBackgroundToCache(revisionNumber, filePath, vcsAnnotation);\n    }\n    return fileAnnotation;\n  }","id":75349,"modified_method":"/**\n   * @param currentRevision - just a hint for optimization\n   */\n  private FileAnnotation annotate(VirtualFile file, final VcsRevisionNumber revisionNumber, final boolean currentRevision,\n                                  final ThrowableComputable<FileAnnotation, VcsException> delegate) throws VcsException {\n    final AnnotationProvider annotationProvider = myAnnotationProvider;\n\n    final FilePath filePath = VcsContextFactory.SERVICE.getInstance().createFilePathOn(file);\n\n    final VcsCacheableAnnotationProvider cacheableAnnotationProvider = (VcsCacheableAnnotationProvider)annotationProvider;\n\n    VcsAnnotation vcsAnnotation = null;\n    if (revisionNumber != null) {\n      vcsAnnotation = myCache.get(VcsContextFactory.SERVICE.getInstance().createFilePathOn(file), myVcs.getKeyInstanceMethod(), revisionNumber);\n    }\n\n    if (vcsAnnotation != null) {\n      final VcsHistoryProvider historyProvider = myVcs.getVcsHistoryProvider();\n      // question is whether we need \"not moved\" path here?\n      FileAnnotation restored = cacheableAnnotationProvider.restore(vcsAnnotation, revisionNumber);\n      if (restored != null) {\n        return restored;\n      }\n      final ContentRevision fileContent = myVcs.getDiffProvider().createFileContent(revisionNumber, file);\n      final VcsAbstractHistorySession history = getHistory(revisionNumber, filePath, historyProvider, vcsAnnotation.getFirstRevision());\n      if (history == null) return null;\n      restored = cacheableAnnotationProvider.\n        restore(vcsAnnotation, history, fileContent.getContent(), currentRevision, revisionNumber);\n      if (restored != null) {\n        return restored;\n      }\n    }\n\n    final FileAnnotation fileAnnotation = delegate.compute();\n    vcsAnnotation = cacheableAnnotationProvider.createCacheable(fileAnnotation);\n    if (vcsAnnotation == null) return fileAnnotation;\n\n    if (revisionNumber != null) {\n      myCache.put(filePath, myVcs.getKeyInstanceMethod(), revisionNumber, vcsAnnotation);\n    }\n    return fileAnnotation;\n  }","commit_id":"77f0aa1b884412900d526878f69f8647c5802e36","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public synchronized void paint(Graphics g2d, JComponent c) {\n    Graphics2D g = (Graphics2D)g2d;\n    JCheckBox b = (JCheckBox) c;\n    final ButtonModel model = b.getModel();\n    final Dimension size = c.getSize();\n    final Font font = c.getFont();\n\n    g.setFont(font);\n    FontMetrics fm = SwingUtilities2.getFontMetrics(c, g, font);\n\n    Rectangle viewRect = new Rectangle(size);\n    Rectangle iconRect = new Rectangle();\n    Rectangle textRect = new Rectangle();\n\n    Insets i = c.getInsets();\n    viewRect.x += i.left;\n    viewRect.y += i.top;\n    viewRect.width -= (i.right + viewRect.x);\n    viewRect.height -= (i.bottom + viewRect.y);\n\n    String text = SwingUtilities.layoutCompoundLabel(c, fm, b.getText(), getDefaultIcon(),\n                                                     b.getVerticalAlignment(), b.getHorizontalAlignment(),\n                                                     b.getVerticalTextPosition(), b.getHorizontalTextPosition(),\n                                                     viewRect, iconRect, textRect, b.getIconTextGap());\n\n    //background\n    if (c.isOpaque()) {\n      g.setColor(b.getBackground());\n      g.fillRect(0, 0, size.width, size.height);\n    }\n\n    final int x = iconRect.x + 3;\n    final int y = iconRect.y + 3;\n    final int w = iconRect.width - 6;\n    final int h = iconRect.height - 6;\n\n    g.translate(x, y);\n    final Paint paint = UIUtil.getGradientPaint(w / 2, 0, b.getBackground().brighter(),\n                                                  w / 2, h, b.getBackground());\n    g.setPaint(paint);\n    g.fillRect(1, 1, w - 2, h - 2);\n\n    //setup AA for lines\n    final GraphicsConfig config = new GraphicsConfig(g);\n    g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n    g.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_DEFAULT);\n\n    final boolean armed = b.getModel().isArmed();\n\n    if (c.hasFocus()) {\n      g.setPaint(UIUtil.getGradientPaint(w/2, 1, armed ? Gray._100: Gray._120, w/2, h, armed ? Gray._55 : Gray._75));\n      g.fillRoundRect(0, 0, w - 2, h - 2, 4, 4);\n\n      DarculaUIUtil.paintFocusRing(g, 1, 1, w - 2, h - 2);\n    } else {\n      g.setPaint(UIUtil.getGradientPaint(w / 2, 1, Gray._110, w / 2, h, Gray._95));\n      g.fillRoundRect(0, 0, w , h , 4, 4);\n\n      g.setPaint(UIUtil.getGradientPaint(w / 2, 1, Gray._120.withAlpha(90), w / 2, h, Gray._105.withAlpha(90)));\n      g.drawRoundRect(0, 1, w, h - 1, 4, 4);\n\n      g.setPaint(Gray._40.withAlpha(180));\n      g.drawRoundRect(0, 0, w, h - 1, 4, 4);\n    }\n\n    if (b.getModel().isSelected()) {\n      g.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_PURE);\n      g.setStroke(new BasicStroke(1 *2.0f, BasicStroke.CAP_ROUND,BasicStroke.JOIN_ROUND));\n      g.setPaint(b.isEnabled() ? Gray._30 : Gray._60);\n      g.drawLine(4, 7, 7, 11);\n      g.drawLine(7, 11, w, 2);\n      g.setPaint(b.isEnabled() ? Gray._170 : Gray._120);\n      g.drawLine(4, 5, 7, 9);\n      g.drawLine(7, 9, w, 0);\n    }\n    g.translate(-x, -y);\n    config.restore();\n\n    //text\n    if(text != null) {\n      View view = (View) c.getClientProperty(BasicHTML.propertyKey);\n      if (view != null) {\n        view.paint(g, textRect);\n      } else {\n        g.setColor(model.isEnabled() ? b.getForeground() : getDisabledTextColor());\n        SwingUtilities2.drawStringUnderlineCharAt(c, g, text,\n                                                  b.getDisplayedMnemonicIndex(),\n                                                  textRect.x,\n                                                  textRect.y + fm.getAscent());\n      }\n    }\n  }","id":75350,"modified_method":"@Override\n  public synchronized void paint(Graphics g2d, JComponent c) {\n    Graphics2D g = (Graphics2D)g2d;\n    JCheckBox b = (JCheckBox) c;\n    final ButtonModel model = b.getModel();\n    final Dimension size = c.getSize();\n    final Font font = c.getFont();\n\n    g.setFont(font);\n    FontMetrics fm = SwingUtilities2.getFontMetrics(c, g, font);\n\n    Rectangle viewRect = new Rectangle(size);\n    Rectangle iconRect = new Rectangle();\n    Rectangle textRect = new Rectangle();\n\n    Insets i = c.getInsets();\n    viewRect.x += i.left;\n    viewRect.y += i.top;\n    viewRect.width -= (i.right + viewRect.x);\n    viewRect.height -= (i.bottom + viewRect.y);\n\n    String text = SwingUtilities.layoutCompoundLabel(c, fm, b.getText(), getDefaultIcon(),\n                                                     b.getVerticalAlignment(), b.getHorizontalAlignment(),\n                                                     b.getVerticalTextPosition(), b.getHorizontalTextPosition(),\n                                                     viewRect, iconRect, textRect, b.getIconTextGap());\n\n    //background\n    if (c.isOpaque()) {\n      g.setColor(b.getBackground());\n      g.fillRect(0, 0, size.width, size.height);\n    }\n\n    if (b.isSelected() && b.getSelectedIcon() != null) {\n      b.getSelectedIcon().paintIcon(b, g, iconRect.x + 4, iconRect.y + 2);\n    } else if (!b.isSelected() && b.getIcon() != null) {\n      b.getIcon().paintIcon(b, g, iconRect.x + 4, iconRect.y + 2);\n    } else {\n      final int x = iconRect.x + 3;\n      final int y = iconRect.y + 3;\n      final int w = iconRect.width - 6;\n      final int h = iconRect.height - 6;\n\n      g.translate(x, y);\n      final Paint paint = UIUtil.getGradientPaint(w / 2, 0, b.getBackground().brighter(),\n                                                    w / 2, h, b.getBackground());\n      g.setPaint(paint);\n      g.fillRect(1, 1, w - 2, h - 2);\n\n      //setup AA for lines\n      final GraphicsConfig config = new GraphicsConfig(g);\n      g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n      g.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_DEFAULT);\n\n      final boolean armed = b.getModel().isArmed();\n\n      if (c.hasFocus()) {\n        g.setPaint(UIUtil.getGradientPaint(w/2, 1, armed ? Gray._100: Gray._120, w/2, h, armed ? Gray._55 : Gray._75));\n        g.fillRoundRect(0, 0, w - 2, h - 2, 4, 4);\n\n        DarculaUIUtil.paintFocusRing(g, 1, 1, w - 2, h - 2);\n      } else {\n        g.setPaint(UIUtil.getGradientPaint(w / 2, 1, Gray._110, w / 2, h, Gray._95));\n        g.fillRoundRect(0, 0, w , h , 4, 4);\n\n        g.setPaint(UIUtil.getGradientPaint(w / 2, 1, Gray._120.withAlpha(90), w / 2, h, Gray._105.withAlpha(90)));\n        g.drawRoundRect(0, 1, w, h - 1, 4, 4);\n\n        g.setPaint(Gray._40.withAlpha(180));\n        g.drawRoundRect(0, 0, w, h - 1, 4, 4);\n      }\n\n      if (b.getModel().isSelected()) {\n        g.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_PURE);\n        g.setStroke(new BasicStroke(1 *2.0f, BasicStroke.CAP_ROUND,BasicStroke.JOIN_ROUND));\n        g.setPaint(b.isEnabled() ? Gray._30 : Gray._60);\n        g.drawLine(4, 7, 7, 11);\n        g.drawLine(7, 11, w, 2);\n        g.setPaint(b.isEnabled() ? Gray._170 : Gray._120);\n        g.drawLine(4, 5, 7, 9);\n        g.drawLine(7, 9, w, 0);\n      }\n      g.translate(-x, -y);\n      config.restore();\n    }\n\n    //text\n    if(text != null) {\n      View view = (View) c.getClientProperty(BasicHTML.propertyKey);\n      if (view != null) {\n        view.paint(g, textRect);\n      } else {\n        g.setColor(model.isEnabled() ? b.getForeground() : getDisabledTextColor());\n        SwingUtilities2.drawStringUnderlineCharAt(c, g, text,\n                                                  b.getDisplayedMnemonicIndex(),\n                                                  textRect.x,\n                                                  textRect.y + fm.getAscent());\n      }\n    }\n  }","commit_id":"8627feca667406e19774107d7f701b82572c8bfb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void initialize(IMuleModel model) {\n\t\t// Set the model as the input for the config sets table.\n\t\tgetConfigSetsTable().setInput(model);\n\n\t\t// If available, set the selection to the first config set.\n\t\tif (model != null) {\n\t\t\tIterator it = model.getMuleConfigSets().iterator();\n\t\t\tif (it.hasNext()) {\n\t\t\t\tIMuleConfigSet configSet = (IMuleConfigSet) it.next();\n\t\t\t\tgetConfigSetsTable().setSelection(new StructuredSelection(configSet));\n\t\t\t}\n\t\t}\n\t}","id":75351,"modified_method":"public void initialize(IMuleModel model) {\n\t\tthis.setMuleModel(model);\n\n\t\t// Set the model as the input for the config sets table.\n\t\tgetConfigSetsTable().setInput(model);\n\n\t\t// If available, set the selection to the first config set.\n\t\tif (model != null) {\n\t\t\tIterator it = model.getMuleConfigSets().iterator();\n\t\t\tif (it.hasNext()) {\n\t\t\t\tIMuleConfigSet configSet = (IMuleConfigSet) it.next();\n\t\t\t\tgetConfigSetsTable().setSelection(new StructuredSelection(configSet));\n\t\t\t}\n\t\t}\n\t}","commit_id":"54296dde03be42cf60146f3e84bac2b8b06dce4f","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n\t * Create the area that contains the config sets table and associated buttons.\n\t * \n\t * @param composite the parent composite\n\t */\n\tprotected void createConfigSetsArea(Composite composite) {\n\t\tsetConfigSetsTable(new TableViewer(composite, SWT.SINGLE | SWT.H_SCROLL | SWT.V_SCROLL\n\t\t\t\t| SWT.BORDER));\n\t\tgetConfigSetsTable().setLabelProvider(\n\t\t\t\tMuleModelLabelProvider.getDecoratingMuleModelLabelProvider());\n\t\tgetConfigSetsTable().setContentProvider(new MuleModelContentProvider(false, true));\n\t\tgetConfigSetsTable().setSorter(new MuleModelViewerSorter());\n\t\tgetConfigSetsTable().getTable().setLayoutData(new GridData(GridData.FILL_BOTH));\n\n\t\t// Listen for selection changes in the config set table.\n\t\tgetConfigSetsTable().addPostSelectionChangedListener(new ISelectionChangedListener() {\n\n\t\t\tpublic void selectionChanged(SelectionChangedEvent event) {\n\t\t\t\tconfigSetSelected(getSelectedConfigSet());\n\t\t\t}\n\t\t});\n\n\t\t// Create the config set buttons.\n\t\tComposite csButtons = MuleUIUtils.createButtonPanel(composite);\n\t\tMuleUIUtils.createSideButton(\"Add\", csButtons);\n\t\tMuleUIUtils.createSideButton(\"Edit\", csButtons);\n\t\tMuleUIUtils.createSideButton(\"Delete\", csButtons);\n\t}","id":75352,"modified_method":"/**\n\t * Create the area that contains the config sets table and associated buttons.\n\t * \n\t * @param composite the parent composite\n\t */\n\tprotected void createConfigSetsArea(Composite composite) {\n\t\tsetConfigSetsTable(new TableViewer(composite, SWT.SINGLE | SWT.H_SCROLL | SWT.V_SCROLL\n\t\t\t\t| SWT.BORDER));\n\t\tgetConfigSetsTable().setLabelProvider(\n\t\t\t\tMuleModelLabelProvider.getDecoratingMuleModelLabelProvider());\n\t\tgetConfigSetsTable().setContentProvider(new MuleModelContentProvider(false, true));\n\t\tgetConfigSetsTable().setSorter(new MuleModelViewerSorter());\n\t\tgetConfigSetsTable().getTable().setLayoutData(new GridData(GridData.FILL_BOTH));\n\n\t\t// Listen for selection changes in the config set table.\n\t\tgetConfigSetsTable().addPostSelectionChangedListener(new ISelectionChangedListener() {\n\n\t\t\tpublic void selectionChanged(SelectionChangedEvent event) {\n\t\t\t\tconfigSetSelected(getSelectedConfigSet());\n\t\t\t}\n\t\t});\n\n\t\t// Double clicking a set acts like clicking the edit button.\n\t\tgetConfigSetsTable().addDoubleClickListener(new IDoubleClickListener() {\n\n\t\t\tpublic void doubleClick(DoubleClickEvent event) {\n\t\t\t\teditSetClicked();\n\t\t\t}\n\t\t});\n\n\t\t// Create the config set buttons.\n\t\tComposite csButtons = MuleUIUtils.createButtonPanel(composite);\n\t\tbuttonSetAdd = MuleUIUtils.createSideButton(\"Add\", csButtons);\n\t\tbuttonSetAdd.addMouseListener(new MouseAdapter() {\n\t\t\tpublic void mouseUp(MouseEvent e) {\n\t\t\t\taddSetClicked();\n\t\t\t}\n\t\t});\n\t\tbuttonSetEdit = MuleUIUtils.createSideButton(\"Edit\", csButtons);\n\t\tbuttonSetEdit.addMouseListener(new MouseAdapter() {\n\t\t\tpublic void mouseUp(MouseEvent e) {\n\t\t\t\teditSetClicked();\n\t\t\t}\n\t\t});\n\t\tbuttonSetDelete = MuleUIUtils.createSideButton(\"Delete\", csButtons);\n\t\tbuttonSetDelete.addMouseListener(new MouseAdapter() {\n\t\t\tpublic void mouseUp(MouseEvent e) {\n\t\t\t\tdeleteSetClicked();\n\t\t\t}\n\t\t});\n\t}","commit_id":"54296dde03be42cf60146f3e84bac2b8b06dce4f","url":"https://github.com/mulesoft/mule"},{"original_method":"public Composite createControl(Composite parent) {\n\t\tComposite composite = new Composite(parent, SWT.NULL);\n\t\tGridLayout mainLayout = new GridLayout();\n\t\tmainLayout.numColumns = 2;\n\t\tcomposite.setLayout(mainLayout);\n\t\tcomposite.setLayoutData(new GridData(GridData.FILL_BOTH));\n\n\t\t// Add the viewer that shows the config file list.\n\t\tsetConfigsTable(new TableViewer(composite));\n\t\tgetConfigsTable().setLabelProvider(\n\t\t\t\tMuleModelLabelProvider.getDecoratingMuleModelLabelProvider());\n\t\tgetConfigsTable().setContentProvider(new MuleModelContentProvider(true, false));\n\t\tgetConfigsTable().setSorter(new MuleModelViewerSorter());\n\t\tgetConfigsTable().getTable().setLayoutData(new GridData(GridData.FILL_BOTH));\n\n\t\t// Create buttons and add button handlers.\n\t\tComposite buttons = MuleUIUtils.createButtonPanel(composite);\n\t\taddButton = MuleUIUtils.createSideButton(\"Add\", buttons);\n\t\taddButton.addMouseListener(new MouseAdapter() {\n\t\t\tpublic void mouseUp(MouseEvent e) {\n\t\t\t\taddClicked();\n\t\t\t}\n\t\t});\n\t\teditButton = MuleUIUtils.createSideButton(\"Edit\", buttons);\n\t\teditButton.addMouseListener(new MouseAdapter() {\n\t\t\tpublic void mouseUp(MouseEvent e) {\n\t\t\t\teditClicked();\n\t\t\t}\n\t\t});\n\t\tdeleteButton = MuleUIUtils.createSideButton(\"Delete\", buttons);\n\t\tdeleteButton.addMouseListener(new MouseAdapter() {\n\t\t\tpublic void mouseUp(MouseEvent e) {\n\t\t\t\tdeleteClicked();\n\t\t\t}\n\t\t});\n\n\t\treturn composite;\n\t}","id":75353,"modified_method":"public Composite createControl(Composite parent) {\n\t\tComposite composite = new Composite(parent, SWT.NULL);\n\t\tGridLayout mainLayout = new GridLayout();\n\t\tmainLayout.numColumns = 2;\n\t\tcomposite.setLayout(mainLayout);\n\t\tcomposite.setLayoutData(new GridData(GridData.FILL_BOTH));\n\n\t\t// Add the viewer that shows the config file list.\n\t\tsetConfigsTable(new TableViewer(composite));\n\t\tgetConfigsTable().setLabelProvider(\n\t\t\t\tMuleModelLabelProvider.getDecoratingMuleModelLabelProvider());\n\t\tgetConfigsTable().setContentProvider(new MuleModelContentProvider(true, false));\n\t\tgetConfigsTable().setSorter(new MuleModelViewerSorter());\n\t\tgetConfigsTable().getTable().setLayoutData(new GridData(GridData.FILL_BOTH));\n\n\t\t// Double clicking a config acts like clicking the edit button.\n\t\tgetConfigsTable().addDoubleClickListener(new IDoubleClickListener() {\n\n\t\t\tpublic void doubleClick(DoubleClickEvent event) {\n\t\t\t\teditClicked();\n\t\t\t}\n\t\t});\n\n\t\t// Create buttons and add button handlers.\n\t\tComposite buttons = MuleUIUtils.createButtonPanel(composite);\n\t\taddButton = MuleUIUtils.createSideButton(\"Add\", buttons);\n\t\taddButton.addMouseListener(new MouseAdapter() {\n\t\t\tpublic void mouseUp(MouseEvent e) {\n\t\t\t\taddClicked();\n\t\t\t}\n\t\t});\n\t\teditButton = MuleUIUtils.createSideButton(\"Edit\", buttons);\n\t\teditButton.addMouseListener(new MouseAdapter() {\n\t\t\tpublic void mouseUp(MouseEvent e) {\n\t\t\t\teditClicked();\n\t\t\t}\n\t\t});\n\t\tdeleteButton = MuleUIUtils.createSideButton(\"Delete\", buttons);\n\t\tdeleteButton.addMouseListener(new MouseAdapter() {\n\t\t\tpublic void mouseUp(MouseEvent e) {\n\t\t\t\tdeleteClicked();\n\t\t\t}\n\t\t});\n\n\t\treturn composite;\n\t}","commit_id":"54296dde03be42cf60146f3e84bac2b8b06dce4f","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void registerDescriptors(@NotNull Collection<? extends DeclarationDescriptor> descriptors) {\n        assert !allDescriptorsComputed : \"getAllDescriptors() has been called already\";\n        allDescriptors.addAll(descriptors);\n    }","id":75354,"modified_method":"protected abstract void addExtraDescriptors(@NotNull Collection<DeclarationDescriptor> result);","commit_id":"fd8da79b886427c41ce7bafe313b5976dcb9ab8f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    private ClassDescriptor resolveClassOrObjectDescriptor(@NotNull Name name, boolean object) {\n        Collection<JetClassOrObject> classOrObjectDeclarations = declarationProvider.getClassOrObjectDeclarations(name);\n\n        for (JetClassOrObject classOrObjectDeclaration : classOrObjectDeclarations) {\n            if (object != declaresObjectOrEnumConstant(classOrObjectDeclaration)) continue;\n\n            ClassDescriptor classDescriptor = new LazyClassDescriptor(resolveSession, thisDescriptor, name,\n                                                                      JetClassInfoUtil.createClassLikeInfo(classOrObjectDeclaration));\n\n            if (!object) {\n                registerDescriptor(classDescriptor);\n            }\n\n            return classDescriptor;\n        }\n        return null;\n    }","id":75355,"modified_method":"@Nullable\n    private ClassDescriptor resolveClassOrObjectDescriptor(@NotNull Name name, boolean object) {\n        Collection<JetClassOrObject> classOrObjectDeclarations = declarationProvider.getClassOrObjectDeclarations(name);\n\n        for (JetClassOrObject classOrObjectDeclaration : classOrObjectDeclarations) {\n            if (object != declaresObjectOrEnumConstant(classOrObjectDeclaration)) continue;\n\n            return new LazyClassDescriptor(resolveSession, thisDescriptor, name,\n                                           JetClassInfoUtil.createClassLikeInfo(classOrObjectDeclaration));\n        }\n        return null;\n    }","commit_id":"fd8da79b886427c41ce7bafe313b5976dcb9ab8f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"protected AbstractLazyMemberScope(\n            @NotNull ResolveSession resolveSession,\n            @NotNull DP declarationProvider,\n            @NotNull D thisDescriptor\n    ) {\n        this.resolveSession = resolveSession;\n        this.declarationProvider = declarationProvider;\n        this.thisDescriptor = thisDescriptor;\n\n        StorageManager storageManager = resolveSession.getStorageManager();\n        this.classDescriptors = storageManager.createMemoizedFunctionWithNullableValues(new Function<Name, ClassDescriptor>() {\n            @Override\n            public ClassDescriptor fun(Name name) {\n                return resolveClassOrObjectDescriptor(name, false);\n            }\n        }, STRONG);\n        this.objectDescriptors = storageManager.createMemoizedFunctionWithNullableValues(new Function<Name, ClassDescriptor>() {\n            @Override\n            public ClassDescriptor fun(Name name) {\n                return resolveClassOrObjectDescriptor(name, true);\n            }\n        }, STRONG);\n\n        this.functionDescriptors = storageManager.createMemoizedFunction(new Function<Name, Set<FunctionDescriptor>>() {\n            @Override\n            public Set<FunctionDescriptor> fun(Name name) {\n                return doGetFunctions(name);\n            }\n        }, STRONG);\n        this.propertyDescriptors = storageManager.createMemoizedFunction(new Function<Name, Set<VariableDescriptor>>() {\n            @Override\n            public Set<VariableDescriptor> fun(Name name) {\n                return doGetProperties(name);\n            }\n        }, STRONG);\n\n        this.allDescriptors = storageManager.createConcurrentCollection();\n    }","id":75356,"modified_method":"protected AbstractLazyMemberScope(\n            @NotNull ResolveSession resolveSession,\n            @NotNull DP declarationProvider,\n            @NotNull D thisDescriptor\n    ) {\n        this.resolveSession = resolveSession;\n        this.declarationProvider = declarationProvider;\n        this.thisDescriptor = thisDescriptor;\n\n        StorageManager storageManager = resolveSession.getStorageManager();\n        this.classDescriptors = storageManager.createMemoizedFunctionWithNullableValues(new Function<Name, ClassDescriptor>() {\n            @Override\n            public ClassDescriptor fun(Name name) {\n                return resolveClassOrObjectDescriptor(name, false);\n            }\n        }, STRONG);\n        this.objectDescriptors = storageManager.createMemoizedFunctionWithNullableValues(new Function<Name, ClassDescriptor>() {\n            @Override\n            public ClassDescriptor fun(Name name) {\n                return resolveClassOrObjectDescriptor(name, true);\n            }\n        }, STRONG);\n\n        this.functionDescriptors = storageManager.createMemoizedFunction(new Function<Name, Set<FunctionDescriptor>>() {\n            @Override\n            public Set<FunctionDescriptor> fun(Name name) {\n                return doGetFunctions(name);\n            }\n        }, STRONG);\n        this.propertyDescriptors = storageManager.createMemoizedFunction(new Function<Name, Set<VariableDescriptor>>() {\n            @Override\n            public Set<VariableDescriptor> fun(Name name) {\n                return doGetProperties(name);\n            }\n        }, STRONG);\n\n        this.allDescriptors = storageManager.createLazyValue(new Computable<AllDescriptors>() {\n            @Override\n            public AllDescriptors compute() {\n                return computeAllDescriptors();\n            }\n        });\n    }","commit_id":"fd8da79b886427c41ce7bafe313b5976dcb9ab8f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private Set<FunctionDescriptor> doGetFunctions(@NotNull Name name) {\n        Set<FunctionDescriptor> result = Sets.newLinkedHashSet();\n\n        Collection<JetNamedFunction> declarations = declarationProvider.getFunctionDeclarations(name);\n        for (JetNamedFunction functionDeclaration : declarations) {\n            JetScope resolutionScope = getScopeForMemberDeclarationResolution(functionDeclaration);\n            result.add(resolveSession.getInjector().getDescriptorResolver().resolveFunctionDescriptor(thisDescriptor, resolutionScope,\n                                                                                                      functionDeclaration,\n                                                                                                      resolveSession.getTrace()));\n        }\n\n        getNonDeclaredFunctions(name, result);\n\n        if (!result.isEmpty()) {\n            registerDescriptors(result);\n        }\n        return result;\n    }","id":75357,"modified_method":"@NotNull\n    private Set<FunctionDescriptor> doGetFunctions(@NotNull Name name) {\n        Set<FunctionDescriptor> result = Sets.newLinkedHashSet();\n\n        Collection<JetNamedFunction> declarations = declarationProvider.getFunctionDeclarations(name);\n        for (JetNamedFunction functionDeclaration : declarations) {\n            JetScope resolutionScope = getScopeForMemberDeclarationResolution(functionDeclaration);\n            result.add(resolveSession.getInjector().getDescriptorResolver().resolveFunctionDescriptor(thisDescriptor, resolutionScope,\n                                                                                                      functionDeclaration,\n                                                                                                      resolveSession.getTrace()));\n        }\n\n        getNonDeclaredFunctions(name, result);\n\n        return result;\n    }","commit_id":"fd8da79b886427c41ce7bafe313b5976dcb9ab8f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public Set<VariableDescriptor> doGetProperties(@NotNull Name name) {\n        Set<VariableDescriptor> result = Sets.newLinkedHashSet();\n\n        Collection<JetProperty> declarations = declarationProvider.getPropertyDeclarations(name);\n        for (JetProperty propertyDeclaration : declarations) {\n            JetScope resolutionScope = getScopeForMemberDeclarationResolution(propertyDeclaration);\n            result.add(resolveSession.getInjector().getDescriptorResolver().resolvePropertyDescriptor(thisDescriptor, resolutionScope,\n                                                                                                      propertyDeclaration,\n                                                                                                      resolveSession.getTrace()));\n        }\n\n        // Objects are also properties\n        Collection<JetClassOrObject> classOrObjectDeclarations = declarationProvider.getClassOrObjectDeclarations(name);\n        for (JetClassOrObject classOrObjectDeclaration : classOrObjectDeclarations) {\n            if (declaresObjectOrEnumConstant(classOrObjectDeclaration)) {\n                ClassDescriptor classifier = getObjectDescriptor(name);\n                if (classifier == null) {\n                    throw new IllegalStateException(\"Object declaration \" + name + \" found in the DeclarationProvider \" + declarationProvider + \" but not in the scope \" + this);\n                }\n                VariableDescriptor propertyDescriptor = resolveSession.getInjector().getDescriptorResolver()\n                        .resolveObjectDeclaration(thisDescriptor, classOrObjectDeclaration, classifier, resolveSession.getTrace());\n                result.add(propertyDescriptor);\n            }\n        }\n\n        getNonDeclaredProperties(name, result);\n\n        registerDescriptors(result);\n\n        return result;\n    }","id":75358,"modified_method":"@NotNull\n    public Set<VariableDescriptor> doGetProperties(@NotNull Name name) {\n        Set<VariableDescriptor> result = Sets.newLinkedHashSet();\n\n        Collection<JetProperty> declarations = declarationProvider.getPropertyDeclarations(name);\n        for (JetProperty propertyDeclaration : declarations) {\n            JetScope resolutionScope = getScopeForMemberDeclarationResolution(propertyDeclaration);\n            result.add(resolveSession.getInjector().getDescriptorResolver().resolvePropertyDescriptor(thisDescriptor, resolutionScope,\n                                                                                                      propertyDeclaration,\n                                                                                                      resolveSession.getTrace()));\n        }\n\n        // Objects are also properties\n        Collection<JetClassOrObject> classOrObjectDeclarations = declarationProvider.getClassOrObjectDeclarations(name);\n        for (JetClassOrObject classOrObjectDeclaration : classOrObjectDeclarations) {\n            if (declaresObjectOrEnumConstant(classOrObjectDeclaration)) {\n                ClassDescriptor classifier = getObjectDescriptor(name);\n                if (classifier == null) {\n                    throw new IllegalStateException(\"Object declaration \" + name + \" found in the DeclarationProvider \" + declarationProvider + \" but not in the scope \" + this);\n                }\n                VariableDescriptor propertyDescriptor = resolveSession.getInjector().getDescriptorResolver()\n                        .resolveObjectDeclaration(thisDescriptor, classOrObjectDeclaration, classifier, resolveSession.getTrace());\n                result.add(propertyDescriptor);\n            }\n        }\n\n        getNonDeclaredProperties(name, result);\n\n        return result;\n    }","commit_id":"fd8da79b886427c41ce7bafe313b5976dcb9ab8f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Collection<DeclarationDescriptor> getAllDescriptors() {\n        if (!allDescriptorsComputed) {\n            for (JetDeclaration declaration : declarationProvider.getAllDeclarations()) {\n                if (declaration instanceof JetEnumEntry) {\n                    JetEnumEntry jetEnumEntry = (JetEnumEntry) declaration;\n                    Name name = safeNameForLazyResolve(jetEnumEntry);\n                    if (name != null) {\n                        getProperties(name);\n                        getObjectDescriptor(name);\n                    }\n                }\n                else if (declaration instanceof JetObjectDeclaration) {\n                    JetObjectDeclaration objectDeclaration = (JetObjectDeclaration) declaration;\n                    Name name = safeNameForLazyResolve(objectDeclaration.getNameAsDeclaration());\n                    if (name != null) {\n                        getProperties(name);\n                        getObjectDescriptor(name);\n                    }\n                }\n                else if (declaration instanceof JetClassOrObject) {\n                    JetClassOrObject classOrObject = (JetClassOrObject) declaration;\n                    Name name = safeNameForLazyResolve(classOrObject.getNameAsName());\n                    if (name != null) {\n                        getClassifier(name);\n                    }\n                }\n                else if (declaration instanceof JetFunction) {\n                    JetFunction function = (JetFunction) declaration;\n                    getFunctions(safeNameForLazyResolve(function));\n                }\n                else if (declaration instanceof JetProperty) {\n                    JetProperty property = (JetProperty) declaration;\n                    getProperties(safeNameForLazyResolve(property));\n                }\n                else if (declaration instanceof JetParameter) {\n                    JetParameter parameter = (JetParameter) declaration;\n                    Name name = safeNameForLazyResolve(parameter);\n                    getProperties(name);\n                }\n                else if (declaration instanceof JetTypedef || declaration instanceof JetMultiDeclaration) {\n                    // Do nothing for typedefs as they are not supported.\n                    // MultiDeclarations are not supported on global level too.\n                }\n                else {\n                    throw new IllegalArgumentException(\"Unsupported declaration kind: \" + declaration);\n                }\n            }\n            addExtraDescriptors();\n            allDescriptorsComputed = true;\n        }\n        return allDescriptors;\n    }","id":75359,"modified_method":"@NotNull\n    @Override\n    public Collection<DeclarationDescriptor> getAllDescriptors() {\n        return allDescriptors.get().all;\n    }","commit_id":"fd8da79b886427c41ce7bafe313b5976dcb9ab8f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Collection<ClassDescriptor> getObjectDescriptors() {\n        getAllDescriptors();\n        return objectDescriptors.values();\n    }","id":75360,"modified_method":"@NotNull\n    @Override\n    public Collection<ClassDescriptor> getObjectDescriptors() {\n        return allDescriptors.get().objects;\n    }","commit_id":"fd8da79b886427c41ce7bafe313b5976dcb9ab8f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    protected void addExtraDescriptors() {\n        for (JetType supertype : thisDescriptor.getTypeConstructor().getSupertypes()) {\n            for (DeclarationDescriptor descriptor : supertype.getMemberScope().getAllDescriptors()) {\n                if (descriptor instanceof FunctionDescriptor) {\n                    getFunctions(descriptor.getName());\n                }\n                else if (descriptor instanceof PropertyDescriptor) {\n                    getProperties(descriptor.getName());\n                }\n                // Nothing else is inherited\n            }\n        }\n\n        getFunctions(DescriptorResolver.VALUES_METHOD_NAME);\n        getFunctions(DescriptorResolver.VALUE_OF_METHOD_NAME);\n\n        addDataClassMethods();\n    }","id":75361,"modified_method":"@Override\n    protected void addExtraDescriptors(@NotNull Collection<DeclarationDescriptor> result) {\n        for (JetType supertype : thisDescriptor.getTypeConstructor().getSupertypes()) {\n            for (DeclarationDescriptor descriptor : supertype.getMemberScope().getAllDescriptors()) {\n                if (descriptor instanceof FunctionDescriptor) {\n                    result.addAll(getFunctions(descriptor.getName()));\n                }\n                else if (descriptor instanceof PropertyDescriptor) {\n                    result.addAll(getProperties(descriptor.getName()));\n                }\n                // Nothing else is inherited\n            }\n        }\n\n        result.addAll(getFunctions(DescriptorResolver.VALUES_METHOD_NAME));\n        result.addAll(getFunctions(DescriptorResolver.VALUE_OF_METHOD_NAME));\n\n        addDataClassMethods(result);\n    }","commit_id":"fd8da79b886427c41ce7bafe313b5976dcb9ab8f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    public NamespaceDescriptor createPackageDescriptor(@NotNull Name name) {\n        if (!declarationProvider.isPackageDeclared(name)) return null;\n\n        PackageMemberDeclarationProvider packageMemberDeclarationProvider = resolveSession.getDeclarationProviderFactory().getPackageMemberDeclarationProvider(\n                DescriptorUtils.getFQName(thisDescriptor).child(name).toSafe());\n        assert packageMemberDeclarationProvider != null : \"Package is declared, but declaration provider is not found: \" + name;\n        NamespaceDescriptor namespaceDescriptor = new LazyPackageDescriptor(thisDescriptor, name, resolveSession, packageMemberDeclarationProvider);\n\n        registerDescriptor(namespaceDescriptor);\n\n        return namespaceDescriptor;\n    }","id":75362,"modified_method":"@Nullable\n    public NamespaceDescriptor createPackageDescriptor(@NotNull Name name) {\n        if (!declarationProvider.isPackageDeclared(name)) return null;\n\n        PackageMemberDeclarationProvider packageMemberDeclarationProvider = resolveSession.getDeclarationProviderFactory().getPackageMemberDeclarationProvider(\n                DescriptorUtils.getFQName(thisDescriptor).child(name).toSafe());\n        assert packageMemberDeclarationProvider != null : \"Package is declared, but declaration provider is not found: \" + name;\n\n        return new LazyPackageDescriptor(thisDescriptor, name, resolveSession, packageMemberDeclarationProvider);\n    }","commit_id":"fd8da79b886427c41ce7bafe313b5976dcb9ab8f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    protected void addExtraDescriptors() {\n        for (FqName packageFqName : declarationProvider.getAllDeclaredPackages()) {\n            getNamespace(packageFqName.shortName());\n        }\n    }","id":75363,"modified_method":"@Override\n    protected void addExtraDescriptors(@NotNull Collection<DeclarationDescriptor> result) {\n        for (FqName packageFqName : declarationProvider.getAllDeclaredPackages()) {\n            result.add(getNamespace(packageFqName.shortName()));\n        }\n    }","commit_id":"fd8da79b886427c41ce7bafe313b5976dcb9ab8f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public Quantiles add(Quantiles other) {\n    _gprows += other._gprows;\n    if ( _isEnum ) return this;\n\n    // merge hcnt2 per-bin mins \n    // other must be same length, but use it's length for safety\n    // could add assert on lengths?\n    for (int k = 0; k < other.hcnt2_min.length; k++) {\n      // for now..die on NaNs\n      assert !Double.isNaN(other.hcnt2_min[k]) : \"NaN in other.hcnt2_min merging\";\n      assert !Double.isNaN(other.hcnt2[k]) : \"NaN in hcnt2_min merging\";\n      assert !Double.isNaN(hcnt2_min[k]) : \"NaN in hcnt2_min merging\";\n      assert !Double.isNaN(hcnt2[k]) : \"NaN in hcnt2_min merging\";\n\n      // cover the initial case (relying on initial min = 0 to work is wrong)\n      // Only take the new max if it's hcnt2 is non-zero. like a valid bit\n      // can hcnt2 ever be null here?\n      if (other.hcnt2[k] > 0) {\n        if ( hcnt2[k]==0 || ( other.hcnt2_min[k] < hcnt2_min[k] )) {\n          hcnt2_min[k] = other.hcnt2_min[k];\n        }\n      }\n    }\n\n    // merge hcnt2 per-bin maxs\n    // other must be same length, but use it's length for safety\n    for (int k = 0; k < other.hcnt2_max.length; k++) {\n      // for now..die on NaNs\n      assert !Double.isNaN(other.hcnt2_max[k]) : \"NaN in other.hcnt2_max merging\";\n      assert !Double.isNaN(other.hcnt2[k]) : \"NaN in hcnt2_min merging\";\n      assert !Double.isNaN(hcnt2_max[k]) : \"NaN in hcnt2_max merging\";\n      assert !Double.isNaN(hcnt2[k]) : \"NaN in hcnt2_max merging\";\n\n      // cover the initial case (relying on initial min = 0 to work is wrong)\n      // Only take the new max if it's hcnt2 is non-zero. like a valid bit\n      // can hcnt2 ever be null here?\n      if (other.hcnt2[k] > 0) {\n        if ( hcnt2[k]==0 || ( other.hcnt2_max[k] > hcnt2_max[k] )) {\n          hcnt2_max[k] = other.hcnt2_max[k];\n        }\n      }\n    }\n\n    // can hcnt2 ever be null here?. Inc last, so the zero case is detected above\n    // seems like everything would fail if hcnt2 doesn't exist here\n    assert hcnt2 != null;\n    Utils.add(hcnt2, other.hcnt2);\n    return this;\n  }","id":75364,"modified_method":"public Quantiles add(Quantiles other) {\n    _totalRows += other._totalRows;\n    if ( _isEnum ) return this;\n\n    // merge hcnt2 per-bin mins \n    // other must be same length, but use it's length for safety\n    // could add assert on lengths?\n    for (int k = 0; k < other.hcnt2_min.length; k++) {\n      // for now..die on NaNs\n      assert !Double.isNaN(other.hcnt2_min[k]) : \"NaN in other.hcnt2_min merging\";\n      assert !Double.isNaN(other.hcnt2[k]) : \"NaN in hcnt2_min merging\";\n      assert !Double.isNaN(hcnt2_min[k]) : \"NaN in hcnt2_min merging\";\n      assert !Double.isNaN(hcnt2[k]) : \"NaN in hcnt2_min merging\";\n\n      // cover the initial case (relying on initial min = 0 to work is wrong)\n      // Only take the new max if it's hcnt2 is non-zero. like a valid bit\n      // can hcnt2 ever be null here?\n      if (other.hcnt2[k] > 0) {\n        if ( hcnt2[k]==0 || ( other.hcnt2_min[k] < hcnt2_min[k] )) {\n          hcnt2_min[k] = other.hcnt2_min[k];\n        }\n      }\n    }\n\n    // merge hcnt2 per-bin maxs\n    // other must be same length, but use it's length for safety\n    for (int k = 0; k < other.hcnt2_max.length; k++) {\n      // for now..die on NaNs\n      assert !Double.isNaN(other.hcnt2_max[k]) : \"NaN in other.hcnt2_max merging\";\n      assert !Double.isNaN(other.hcnt2[k]) : \"NaN in hcnt2_min merging\";\n      assert !Double.isNaN(hcnt2_max[k]) : \"NaN in hcnt2_max merging\";\n      assert !Double.isNaN(hcnt2[k]) : \"NaN in hcnt2_max merging\";\n\n      // cover the initial case (relying on initial min = 0 to work is wrong)\n      // Only take the new max if it's hcnt2 is non-zero. like a valid bit\n      // can hcnt2 ever be null here?\n      if (other.hcnt2[k] > 0) {\n        if ( hcnt2[k]==0 || ( other.hcnt2_max[k] > hcnt2_max[k] )) {\n          hcnt2_max[k] = other.hcnt2_max[k];\n        }\n      }\n    }\n\n    // can hcnt2 ever be null here?. Inc last, so the zero case is detected above\n    // seems like everything would fail if hcnt2 doesn't exist here\n    assert hcnt2 != null;\n    Utils.add(hcnt2, other.hcnt2);\n    return this;\n  }","commit_id":"ac99f7ecea71e915e59abbe95a0d42de17118d7a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public void add(double val) {\n    if ( Double.isNaN(val) ) return;\n    _gprows++;\n    if ( _isEnum ) return;\n\n    if ( true ) { // single pass approx\n      long binIdx2;\n      if (hcnt2.length==1) {\n        binIdx2 = 0; // not used\n      }\n      else {\n        // FIX! why is this round not floor? \n        binIdx2 = Math.round(((val - _start2) * 1000000.0) / _binsz2) / 1000000;\n      }\n\n      int binIdx2Int = (int) binIdx2;\n      assert (binIdx2Int >= 0 && binIdx2Int < hcnt2.length) : \n        \"binIdx2Int too big for hcnt2 \"+binIdx2Int+\" \"+hcnt2.length;\n\n      if ( (hcnt2[binIdx2Int] == 0) || (val < hcnt2_min[binIdx2Int]) ) {\n        hcnt2_min[binIdx2Int] = val;\n      }\n      if ( (hcnt2[binIdx2Int] == 0) || (val > hcnt2_max[binIdx2Int]) ) {\n        hcnt2_max[binIdx2Int] = val;\n      }\n      ++hcnt2[binIdx2Int];\n    }\n    else { // multi pass exact. Should be able to do this for both, if the valStart param is correct\n\n      //  Need to count the stuff outside the bin-gathering, \n      //  since threshold compare is based on total row compare\n      double valOffset = val - _valStart;\n      if ( valOffset < 0 ) {\n        ++hcnt2_low;\n      }\n      else if ( val > _valEnd ) {\n        if ( (hcnt2_high==0) || (val < hcnt2_high_min) ) hcnt2_high_min = val;\n        ++hcnt2_high;\n      } \n      else {\n        long binIdx2;\n        if (hcnt2.length==1) {\n          binIdx2 = 0; // not used\n        }\n        else {\n          // FIX! talks about precision loss if I use Math.floor() here. Want floor\n          binIdx2 = Math.round((valOffset * 1000000.0) / _valBinSize) / 1000000;\n        }\n\n        int binIdx2Int = (int) binIdx2;\n        assert (binIdx2Int >= 0 && binIdx2Int < hcnt2.length) : \n          \"binIdx2Int too big for hcnt2 \"+binIdx2Int+\" \"+hcnt2.length;\n\n        //  where are we zeroing in? (start)\n        //  Log.info(valOffset, valBinSize\n        assert (binIdx2Int>=0) && (binIdx2Int<=_valMaxBinCnt) : \"binIdx2Int \"+binIdx2Int+\" out of range\";\n        if ( hcnt2[binIdx2Int]==0 || (val < hcnt2_min[binIdx2Int]) ) hcnt2_min[binIdx2Int] = val;\n        if ( hcnt2[binIdx2Int]==0 || (val > hcnt2_max[binIdx2Int]) ) hcnt2_max[binIdx2Int] = val;\n        ++hcnt2[binIdx2Int];\n      }\n    }\n  }","id":75365,"modified_method":"public void add(double val) {\n    if ( Double.isNaN(val) ) return;\n    _totalRows++;\n    if ( _isEnum ) return;\n\n    long maxBinCnt = _valMaxBinCnt;\n\n    if ( !_multiPass  ) { // single pass approx\n      long binIdx2;\n      if (hcnt2.length==1) {\n        binIdx2 = 0; // not used\n      }\n      else {\n        // FIX! why is this round not floor? \n        // binIdx2 = Math.floor(((val - _start2) * 1000000.0) / _binsz2) / 1000000;\n        // No benefit to mult/div of 1000000. plenty of precision in fp  \n        binIdx2 = (int) Math.floor((val - _start2) / _binsz2);\n      }\n\n      int binIdx2Int = (int) binIdx2;\n      assert (binIdx2Int >= 0 && binIdx2Int < hcnt2.length) : \n        \"binIdx2Int too big for hcnt2 \"+binIdx2Int+\" \"+hcnt2.length;\n\n      if ( (hcnt2[binIdx2Int] == 0) || (val < hcnt2_min[binIdx2Int]) ) {\n        hcnt2_min[binIdx2Int] = val;\n      }\n      if ( (hcnt2[binIdx2Int] == 0) || (val > hcnt2_max[binIdx2Int]) ) {\n        hcnt2_max[binIdx2Int] = val;\n      }\n      ++hcnt2[binIdx2Int];\n    }\n    else { // multi pass exact. Should be able to do this for both, if the valStart param is correct\n\n      //  Need to count the stuff outside the bin-gathering, \n      //  since threshold compare is based on total row compare\n      double valOffset = val - _valStart;\n      if ( valOffset < 0 ) {\n        ++hcnt2_low;\n      }\n      else if ( val > _valEnd ) {\n        if ( (hcnt2_high==0) || (val < hcnt2_high_min) ) hcnt2_high_min = val;\n        ++hcnt2_high;\n      } \n      else {\n        long binIdx2;\n        if (hcnt2.length==1) {\n          binIdx2 = 0; // not used\n        }\n        else {\n          // FIX! talks about precision loss if I use Math.floor() here. Want floor\n          // binIdx2 = Math.floor((valOffset * 1000000.0) / _valBinSize) / 1000000;\n          binIdx2 = (int) Math.floor(valOffset / _valBinSize);\n        }\n\n        int binIdx2Int = (int) binIdx2;\n        assert (binIdx2Int >= 0 && binIdx2Int < hcnt2.length) : \n          \"binIdx2Int too big for hcnt2 \"+binIdx2Int+\" \"+hcnt2.length;\n\n        //  where are we zeroing in? (start)\n        //  Log.info(\"valOffset: \"+valOffset+\" _valBinSize: \"+_valBinSize);\n        assert (binIdx2Int>=0) && (binIdx2Int<=maxBinCnt) : \"binIdx2Int \"+binIdx2Int+\" out of range\";\n        if ( hcnt2[binIdx2Int]==0 || (val < hcnt2_min[binIdx2Int]) ) hcnt2_min[binIdx2Int] = val;\n        if ( hcnt2[binIdx2Int]==0 || (val > hcnt2_max[binIdx2Int]) ) hcnt2_max[binIdx2Int] = val;\n        ++hcnt2[binIdx2Int];\n      }\n    }\n  }","commit_id":"ac99f7ecea71e915e59abbe95a0d42de17118d7a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"private void exactQuantilesMultiPass(double[] qtiles, double[] thres, long desiredBinCnt) {\n    // do we need all of these as output?\n    double newValStart, newValEnd, newValRange, newValBinSize;\n    // FIX! figure out where unitialized can be used\n    newValStart = Double.NaN; \n    newValEnd = Double.NaN;\n    newValRange = Double.NaN;\n    newValBinSize = Double.NaN;\n    long newValLowCnt;\n\n    long maxBinCnt = desiredBinCnt + 1;\n\n    assert !_isEnum;\n    if( hcnt2.length == 0 ) return;\n     // playing with creating relative NUDGE values to make sure bin range\n    // is always inclusive of target.\n    // ratio it down from valBinSize?  It doesn't need to be as big as valBinSize.\n    // can't seem to make it work yet. leave NUDGE=0\n    double NUDGE = 0;\n    //  everything should either be in low, the bins, or high\n    double threshold = thres[0];\n    long totalRows = _gprows;\n    long totalBinnedRows = htot2(hcnt2_low, hcnt2_high);\n    assert totalRows==totalBinnedRows : totalRows+\" \"+totalBinnedRows;\n\n    //  now walk thru and find out what bin to look inside\n    long currentCnt = hcnt2_low;\n    double targetCntFull = threshold * (totalRows-1);  //  zero based indexing\n    long targetCntInt = (long) (Math.floor(threshold * (totalRows-1)));\n    double targetCntFract = targetCntFull  - targetCntInt;\n    assert (targetCntFract>=0) && (targetCntFract<=1);\n    Log.info(\"targetCntInt: \"+targetCntInt+\" targetCntFract: \"+targetCntFract);\n\n    int k = 0;\n    while((currentCnt + hcnt2[k]) <= targetCntInt) {\n      currentCnt += hcnt2[k];\n      ++k;\n      assert k<=maxBinCnt : \"k too large, k:\"+k+\" maxBinCnt: \"+maxBinCnt;\n    }\n\n    assert hcnt2[k]!=1 || hcnt2_min[k]==hcnt2_max[k];\n\n    // FIX!  here, we currently just use mean for interpolation, which is Type 2.\n    // R is Type 7 linear interpolation, so can get difference (worse on small datasets)\n    // We should select between Type 2 and Type 7 here when we interpolate\n    // the linear interpolation for k between row a (vala) and row b (valb) is\n    //    pctDiff = (k-a)/(b-a)\n    //    dDiff = pctDiff * (valb - vala)\n    //    result = vala + dDiff\n\n    boolean done = false;\n    //  some possibily interpolating guesses first, in guess we have to iterate (best guess)\n    // don't really need or want this\n    double guess = (hcnt2_max[k] - hcnt2_min[k]) / 2;\n\n    if ( currentCnt==targetCntInt ) {\n      if ( hcnt2[k]>2 ) {\n        guess = hcnt2_min[k];\n        done = true;\n        Log.info(\"Guess A \"+guess);\n\n      } else if ( hcnt2[k]==2 ) {\n        //  no mattter what size the fraction it would be on this number\n        guess = (hcnt2_max[k] + hcnt2_min[k]) / 2.0;\n        done = true;\n        Log.info(\"Guess B\"+guess);\n\n      } else if ( (hcnt2[k]==1) && (targetCntFract==0) ) {\n        assert hcnt2_min[k]==hcnt2_max[k];\n        guess = hcnt2_min[k];\n        done = true;\n        Log.info(\"k\"+k);\n        Log.info(\"Guess C\"+guess);\n\n      } else if ( hcnt2[k]==1 && targetCntFract!=0 ) {\n        assert hcnt2_min[k]==hcnt2_max[k];\n        Log.info(\"Single value in this bin, but fractional means we need to interpolate to next non-zero\");\n        int nextK;\n        if ( k<maxBinCnt ) nextK = k + 1; //  could put it over maxBinCnt\n        else nextK = k;\n\n        while ( (nextK<maxBinCnt) && (hcnt2[nextK]==0) ) ++nextK;\n\n        //  have the \"extra bin\" for this\n        double nextVal;\n        if ( nextK >= maxBinCnt ) {\n          assert hcnt2_high!=0;\n          Log.info(\"Using hcnt2_high_min for interpolate:\"+hcnt2_high_min);\n          nextVal = hcnt2_high_min;\n        } else {\n          Log.info(\"Using nextK for interpolate:\"+nextK);\n          assert hcnt2[nextK]!=0;\n          nextVal = hcnt2_min[nextK];\n        }\n\n        guess = (hcnt2_max[k] + nextVal) / 2.0;\n        done = true; //  has to be one above us when needed. (or we're at end)\n\n        Log.info(\"k\"+\"hcnt2_max[k]\"+\"nextVal\");\n        Log.info(\"hello3:\"+k+hcnt2_max[k]+nextVal);\n        Log.info(\"\\nInterpolating result using nextK: \"+nextK+ \" nextVal: \"+nextVal);\n      }\n    }\n    if ( !done ) {\n      newValStart = hcnt2_min[k] - NUDGE; //  FIX! should we nudge a little?\n      newValEnd   = hcnt2_max[k] + NUDGE; //  FIX! should we nudge a little?\n      newValRange = newValEnd - newValStart ;\n\n      //  maxBinCnt is always binCount + 1, since we might cover over due to rounding/fp issues?\n      newValBinSize = newValRange / (desiredBinCnt + 0.0);\n      newValLowCnt = currentCnt - 1; // is this right? don't use for anything (debug?)\n      if ( newValBinSize==0 ) {\n        //  assert done or newValBinSize!=0 and live with current guess\n        Log.info(\"Assuming done because newValBinSize is 0.\");\n        Log.info(\"newValRange: \"+newValRange+\n          \" hcnt2[k]: \"+hcnt2[k]+\n          \" hcnt2_min[k]: \"+hcnt2_min[k]+\n          \" hcnt2_max[k]: \"+hcnt2_max[k]);\n        guess = newValStart;\n        Log.info(\"Guess E \"+guess);\n        done = true;\n      }\n      //  if we have to interpolate\n      //  if it falls into this bin, interpolate to this bin means one answer?\n      //  cover the case above with multiple entris in a bin, all the same value\n      //  will be zero on the last pass?\n      //  assert newValBinSize != 0 or done\n      //  need the count up to but not including newValStart\n    }\n\n    // ++iteration;\n\n    // Log.info(\"Ending Pass \"+iteration);\n    Log.info(\"guess: \"+guess+\" done: \"+done+\" hcnt2[k]: \"+hcnt2[k]);\n    Log.info(\"currentCnt: \"+currentCnt+\" targetCntInt: \"+targetCntInt+\" hcnt2_low: \"+hcnt2_low+\"hcnt2_high: \"+hcnt2_high);\n    Log.info(\"was \"+_valStart+\" \"+_valEnd+\" \"+_valRange+\" \"+_valBinSize);\n    Log.info(\"next \"+newValStart+\" \"+newValEnd+\" \"+newValRange+\" \"+newValBinSize);\n\n    qtiles[0] = guess;\n    // might have fp tolerance issues here? but fp numbers should be exactly same?\n    // Log.info(]: hcnt2[k]: \"+hcnt2[k]+\" hcnt2_min[k]: \"+hcnt2_min[k]+\n    //  \" hcnt2_max[k]: \"+hcnt2_max[k]+\" _binsz2: \"+_binsz2+\" guess: \"+guess+\" k: \"+k+\"\\n\");\n\n    // Don't need these any more\n    hcnt2 = null;\n    hcnt2_min = null;\n    hcnt2_max = null;\n\n  }","id":75366,"modified_method":"private boolean exactQuantilesMultiPass(double[] qtiles, double[] thres, long desiredBinCnt) {\n    // do we need all of these as output?\n    double newValStart, newValEnd, newValRange, newValBinSize;\n    // FIX! figure out where unitialized can be used\n    newValStart = Double.NaN; \n    newValEnd = Double.NaN;\n    newValRange = Double.NaN;\n    newValBinSize = Double.NaN;\n    long newValLowCnt;\n    long maxBinCnt = _valMaxBinCnt;\n\n    assert !_isEnum;\n    if( hcnt2.length == 0 ) return false;\n     // playing with creating relative NUDGE values to make sure bin range\n    // is always inclusive of target.\n    // ratio it down from valBinSize?  It doesn't need to be as big as valBinSize.\n    // can't seem to make it work yet. leave NUDGE=0\n    double NUDGE = 0;\n    //  everything should either be in low, the bins, or high\n    double threshold = thres[0];\n    long totalBinnedRows = htot2(hcnt2_low, hcnt2_high);\n    assert _totalRows==totalBinnedRows : _totalRows+\" \"+totalBinnedRows;\n\n    //  now walk thru and find out what bin to look inside\n    long currentCnt = hcnt2_low;\n    double targetCntFull = threshold * (_totalRows-1);  //  zero based indexing\n    long targetCntInt = (long) (Math.floor(threshold * (_totalRows-1)));\n    double targetCntFract = targetCntFull  - targetCntInt;\n    assert (targetCntFract>=0) && (targetCntFract<=1);\n    Log.info(\"targetCntInt: \"+targetCntInt+\" targetCntFract: \"+targetCntFract);\n\n    int k = 0;\n    while((currentCnt + hcnt2[k]) <= targetCntInt) {\n      currentCnt += hcnt2[k];\n      ++k;\n      assert k<=maxBinCnt : \"k too large, k: \"+k+\" maxBinCnt: \"+maxBinCnt;\n    }\n    Log.info(\"Found k (multi): \"+k+\" \"+currentCnt+\" \"+targetCntInt+\" \"+_totalRows+\" \"+hcnt2[k]+\" \"+hcnt2_min[k]+\" \"+hcnt2_max[k]);\n\n\n    assert hcnt2[k]!=1 || hcnt2_min[k]==hcnt2_max[k];\n\n    // FIX!  here, we currently just use mean for interpolation, which is Type 2.\n    // R is Type 7 linear interpolation, so can get difference (worse on small datasets)\n    // We should select between Type 2 and Type 7 here when we interpolate\n    // the linear interpolation for k between row a (vala) and row b (valb) is\n    //    pctDiff = (k-a)/(b-a)\n    //    dDiff = pctDiff * (valb - vala)\n    //    result = vala + dDiff\n\n    boolean done = false;\n    boolean interpolated = false;\n    //  some possibily interpolating guesses first, in guess we have to iterate (best guess)\n    // don't really need or want this\n    double guess = (hcnt2_max[k] - hcnt2_min[k]) / 2;\n\n    if ( currentCnt==targetCntInt ) {\n      if ( hcnt2[k]>2 ) {\n        guess = hcnt2_min[k];\n        done = true;\n        Log.info(\"Guess A \"+guess);\n\n      } else if ( hcnt2[k]==2 ) {\n        //  no mattter what size the fraction it would be on this number\n        guess = (hcnt2_max[k] + hcnt2_min[k]) / 2.0;\n        done = true;\n        Log.info(\"Guess B\"+guess);\n\n      } else if ( (hcnt2[k]==1) && (targetCntFract==0) ) {\n        assert hcnt2_min[k]==hcnt2_max[k];\n        guess = hcnt2_min[k];\n        done = true;\n        Log.info(\"k\"+k);\n        Log.info(\"Guess C\"+guess);\n\n      } else if ( hcnt2[k]==1 && targetCntFract!=0 ) {\n        assert hcnt2_min[k]==hcnt2_max[k];\n        Log.info(\"Single value in this bin, but fractional means we need to interpolate to next non-zero\");\n        int nextK;\n        if ( k<maxBinCnt ) nextK = k + 1; //  could put it over maxBinCnt\n        else nextK = k;\n\n        while ( (nextK<maxBinCnt) && (hcnt2[nextK]==0) ) ++nextK;\n\n        //  have the \"extra bin\" for this\n        double nextVal;\n        if ( nextK >= maxBinCnt ) {\n          assert hcnt2_high!=0;\n          Log.info(\"Using hcnt2_high_min for interpolate: \"+hcnt2_high_min);\n          nextVal = hcnt2_high_min;\n        } else {\n          Log.info(\"Using nextK for interpolate: \"+nextK);\n          assert hcnt2[nextK]!=0;\n          nextVal = hcnt2_min[nextK];\n        }\n\n        guess = (hcnt2_max[k] + nextVal) / 2.0;\n        interpolated = true;\n        done = true; //  has to be one above us when needed. (or we're at end)\n\n        Log.info(\"k\"+\" hcnt2_max[k] \"+\"nextVal\");\n        Log.info(\"hello3: \"+k+hcnt2_max[k]+nextVal);\n        Log.info(\"\\nInterpolating result using nextK: \"+nextK+ \" nextVal: \"+nextVal);\n      }\n    }\n    if ( !done ) {\n      newValStart = hcnt2_min[k] - NUDGE; //  FIX! should we nudge a little?\n      newValEnd   = hcnt2_max[k] + NUDGE; //  FIX! should we nudge a little?\n      newValRange = newValEnd - newValStart ;\n\n      //  maxBinCnt is always binCount + 1, since we might cover over due to rounding/fp issues?\n      newValBinSize = newValRange / (desiredBinCnt + 0.0);\n      newValLowCnt = currentCnt - 1; // is this right? don't use for anything (debug?)\n      if ( newValBinSize==0 ) {\n        //  assert done or newValBinSize!=0 and live with current guess\n        Log.info(\"Assuming done because newValBinSize is 0.\");\n        Log.info(\"newValRange: \"+newValRange+\n          \" hcnt2[k]: \"+hcnt2[k]+\n          \" hcnt2_min[k]: \"+hcnt2_min[k]+\n          \" hcnt2_max[k]: \"+hcnt2_max[k]);\n        guess = newValStart;\n        Log.info(\"Guess E \"+guess);\n        done = true;\n      }\n      //  if we have to interpolate\n      //  if it falls into this bin, interpolate to this bin means one answer?\n      //  cover the case above with multiple entris in a bin, all the same value\n      //  will be zero on the last pass?\n      //  assert newValBinSize != 0 or done\n      //  need the count up to but not including newValStart\n    }\n\n    Log.info(\"guess: \"+guess+\" done: \"+done+\" hcnt2[k]: \"+hcnt2[k]);\n    Log.info(\"currentCnt: \"+currentCnt+\" targetCntInt: \"+targetCntInt+\" hcnt2_low: \"+hcnt2_low+\" hcnt2_high: \"+hcnt2_high);\n    Log.info(\"was \"+_valStart+\" \"+_valEnd+\" \"+_valRange+\" \"+_valBinSize);\n    Log.info(\"next \"+newValStart+\" \"+newValEnd+\" \"+newValRange+\" \"+newValBinSize);\n    \n\n    qtiles[0] = guess;\n    // might have fp tolerance issues here? but fp numbers should be exactly same?\n    // Log.info(]: hcnt2[k]: \"+hcnt2[k]+\" hcnt2_min[k]: \"+hcnt2_min[k]+\n    //  \" hcnt2_max[k]: \"+hcnt2_max[k]+\" _binsz2: \"+_binsz2+\" guess: \"+guess+\" k: \"+k+\"\\n\");\n    // Don't need these any more\n    hcnt2 = null;\n    hcnt2_min = null;\n    hcnt2_max = null;\n    _newValStart = newValStart;\n    _newValEnd = newValEnd;\n    _interpolated = interpolated;\n    return done;\n  }","commit_id":"ac99f7ecea71e915e59abbe95a0d42de17118d7a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"private void approxQuantilesOnePass(double[] qtiles, double[] thres){\n    // not called for enums\n    assert !_isEnum;\n    if( hcnt2.length == 0 ) return;\n\n    int k = 0; long s = 0;\n    double guess = 0;\n    double actualBinWidth = 0;\n    assert _gprows==htot2(0, 0) : \"_gprows: \"+_gprows+\" htot2(): \"+htot2(0, 0);\n\n    // A 'perfect' quantile definition, for comparison. \n    // Given a set of N ordered values {v[1], v[2], ...} and a requirement to \n    // calculate the pth percentile, do the following:\n    // Calculate l = p(N-1) + 1\n    // Split l into integer and decimal components i.e. l = k + d\n    // Compute the required value as V = v[k] + d(v[k+1] - v[k])\n\n    // we do zero-indexed list, so slightly different eqns.\n    // walk up until we're at the bin that starts with the threshold, or right before\n    // only do thres[0]. how do we make a list of thresholds work?\n    // for(int j = 0; j < thres.length; ++j) {\n    for(int j = 0; j <=0; ++j) {\n      // 0 okay for threshold?\n      assert 0 <= thres[j] && thres[j] <= 1;\n      double s1 = Math.floor(thres[j] * (double) _gprows); \n      if ( s1 == 0 ) {\n        s1 = 1; // always need at least one row\n      }\n      // what if _gprows is 0?. just return above?. Is it NAs?\n      // assert _gprows > 0 : _gprows;\n      if( _gprows == 0 ) return;\n      assert 1 <= s1 && s1 <= _gprows : s1+\" \"+_gprows;\n      // how come first bins can be 0? Fixed. problem was _start. Needed _start2. still can get some\n      while( (s+hcnt2[k]) < s1) { // important to be < here. case: 100 rows, getting 50% right.\n        s += hcnt2[k];\n        k++;\n      }\n      // Log.info(\"Found k: \"+k+\" \"+s+\" \"+s1+\" \"+_gprows+\" \"+hcnt2[k]+\" \"+hcnt2_min[k]+\" \"+hcnt2_max[k]);\n\n      // All possible bin boundary issues \n      if ( s==s1 || hcnt2[k]==0 ) {\n        if ( hcnt2[k]!=0 ) {\n          guess = hcnt2_min[k];\n          Log.info(\"Guess A: \"+guess+\" \"+s+\" \"+s1);\n        }\n        else {\n          if ( k==0 ) { \n            assert hcnt2[k+1]!=0 : \"Unexpected state of starting hcnt2 bins\";\n            guess = hcnt2_min[k+1];\n            // Log.info(\"Guess B: \"+guess+\" \"+s+\" \"+s1);\n          }\n          else {\n            if ( hcnt2[k-1]!=0 ) {\n              guess = hcnt2_max[k-1];\n              // Log.info(\"Guess C: \"+guess+\" \"+s+\" \"+s1);\n            }\n            else {\n              assert false : \"Unexpected state of adjacent hcnt2 bins\";\n            }\n          }\n        }\n      }\n      else {\n        // nonzero hcnt2[k] guarantees these are valid\n        actualBinWidth = hcnt2_max[k] - hcnt2_min[k];\n\n        // interpolate within the populated bin, assuming linear distribution\n        // since we have the actual min/max within a bin, we can be more accurate\n        // compared to using the bin boundaries\n        // Note actualBinWidth is 0 when all values are the same in a bin\n        // Interesting how we have a gap that we jump between max of one bin, and min of another.\n        guess = hcnt2_min[k] + actualBinWidth * ((s1 - s) / hcnt2[k]);\n        // Log.info(\"Guess D: \"+guess+\" \"+k+\" \"+hcnt2_min[k]+\" \"+actualBinWidth+\" \"+s+\" \"+s1+\" \"+hcnt2[k]);\n      }\n\n      qtiles[j] = guess;\n\n      // Don't need these any more\n      hcnt2 = null;\n      hcnt2_min = null;\n      hcnt2_max = null;\n\n      // might have fp tolerance issues here? but fp numbers should be exactly same?\n      // Log.info(]: hcnt2[k]: \"+hcnt2[k]+\" hcnt2_min[k]: \"+hcnt2_min[k]+\n      //  \" hcnt2_max[k]: \"+hcnt2_max[k]+\" _binsz2: \"+_binsz2+\" guess: \"+guess+\" k: \"+k+\"\\n\");\n    }\n  }","id":75367,"modified_method":"private boolean approxQuantilesOnePass(double[] qtiles, double[] thres){\n    // not called for enums\n    assert !_isEnum;\n    if( hcnt2.length == 0 ) return false;\n\n    int k = 0; long s = 0;\n    double guess = 0;\n    double actualBinWidth = 0;\n    assert _totalRows==htot2(0, 0) : \"_totalRows: \"+_totalRows+\" htot2(): \"+htot2(0, 0);\n\n    // A 'perfect' quantile definition, for comparison. \n    // Given a set of N ordered values {v[1], v[2], ...} and a requirement to \n    // calculate the pth percentile, do the following:\n    // Calculate l = p(N-1) + 1\n    // Split l into integer and decimal components i.e. l = k + d\n    // Compute the required value as V = v[k] + d(v[k+1] - v[k])\n\n    // we do zero-indexed list, so slightly different eqns.\n    // walk up until we're at the bin that starts with the threshold, or right before\n    // only do thres[0]. how do we make a list of thresholds work?\n    // for(int j = 0; j < thres.length; ++j) {\n    for(int j = 0; j <=0; ++j) {\n      // 0 okay for threshold?\n      assert 0 <= thres[j] && thres[j] <= 1;\n      double s1 = Math.floor(thres[j] * (double) _totalRows); \n      if ( s1 == 0 ) {\n        s1 = 1; // always need at least one row\n      }\n      // what if _totalRows is 0?. just return above?. Is it NAs?\n      // assert _totalRows > 0 : _totalRows;\n      if( _totalRows == 0 ) return false;\n      assert 1 <= s1 && s1 <= _totalRows : s1+\" \"+_totalRows;\n      // how come first bins can be 0? Fixed. problem was _start. Needed _start2. still can get some\n      while( (s+hcnt2[k]) < s1) { // important to be < here. case: 100 rows, getting 50% right.\n        s += hcnt2[k];\n        k++;\n      }\n      Log.info(\"Found k: \"+k+\" \"+s+\" \"+s1+\" \"+_totalRows+\" \"+hcnt2[k]+\" \"+hcnt2_min[k]+\" \"+hcnt2_max[k]);\n\n      // All possible bin boundary issues \n      if ( s==s1 || hcnt2[k]==0 ) {\n        if ( hcnt2[k]!=0 ) {\n          guess = hcnt2_min[k];\n          Log.info(\"Guess A: \"+guess+\" \"+s+\" \"+s1);\n        }\n        else {\n          if ( k==0 ) { \n            assert hcnt2[k+1]!=0 : \"Unexpected state of starting hcnt2 bins\";\n            guess = hcnt2_min[k+1];\n            // Log.info(\"Guess B: \"+guess+\" \"+s+\" \"+s1);\n          }\n          else {\n            if ( hcnt2[k-1]!=0 ) {\n              guess = hcnt2_max[k-1];\n              // Log.info(\"Guess C: \"+guess+\" \"+s+\" \"+s1);\n            }\n            else {\n              assert false : \"Unexpected state of adjacent hcnt2 bins\";\n            }\n          }\n        }\n      }\n      else {\n        // nonzero hcnt2[k] guarantees these are valid\n        actualBinWidth = hcnt2_max[k] - hcnt2_min[k];\n\n        // interpolate within the populated bin, assuming linear distribution\n        // since we have the actual min/max within a bin, we can be more accurate\n        // compared to using the bin boundaries\n        // Note actualBinWidth is 0 when all values are the same in a bin\n        // Interesting how we have a gap that we jump between max of one bin, and min of another.\n        guess = hcnt2_min[k] + actualBinWidth * ((s1 - s) / hcnt2[k]);\n        // Log.info(\"Guess D: \"+guess+\" \"+k+\" \"+hcnt2_min[k]+\" \"+actualBinWidth+\" \"+s+\" \"+s1+\" \"+hcnt2[k]);\n      }\n\n      qtiles[j] = guess;\n\n      // might have fp tolerance issues here? but fp numbers should be exactly same?\n      Log.info(\"hcnt2[k]: \"+hcnt2[k]+\" hcnt2_min[k]: \"+hcnt2_min[k]+\n        \" hcnt2_max[k]: \"+hcnt2_max[k]+\" _binsz2: \"+_binsz2+\" guess: \"+guess+\" k: \"+k+\"\\n\");\n\n      // Don't need these any more\n      hcnt2 = null;\n      hcnt2_min = null;\n      hcnt2_max = null;\n\n    }\n    _interpolated = true;\n    return true;\n  }","commit_id":"ac99f7ecea71e915e59abbe95a0d42de17118d7a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public Quantiles(Vec vec, String name, double quantile, int max_qbins, \n        double valStart, double valEnd, boolean multiPass) {\n\n    colname = name;\n    _isEnum = vec.isEnum();\n    _isInt = vec.isInt();\n    _domain = vec.isEnum() ? vec.domain() : null;\n    _max = vec.max();\n    _min = vec.min();\n    _mean = vec.mean();\n    _sigma = vec.sigma();\n    _naCnt = vec.naCnt();\n\n    _gprows = 0;\n    QUANTILES_TO_DO = new double[1];\n    QUANTILES_TO_DO[0] = quantile;\n\n    _valStart = valStart;\n    _valEnd = valEnd;\n    _valRange = valEnd - valStart;\n\n    int desiredBinCnt = max_qbins;\n    int maxBinCnt = desiredBinCnt + 1;\n    _valBinSize = _valRange / (desiredBinCnt + 0.0);\n    _valMaxBinCnt = maxBinCnt;\n\n    if( vec.isEnum() && _domain.length < MAX_ENUM_SIZE ) {\n      // do we even care here? don't want to think about whether multiPass is disabled\n      _start2 = 0;\n      _binsz2 = 1;\n      hcnt2 = new long[_domain.length];\n      hcnt2_min = new double[_domain.length];\n      hcnt2_max = new double[_domain.length];\n    } \n    else if ( !Double.isNaN(_min) ) {\n      assert max_qbins > 0 && max_qbins <= 1000000 : \"max_qbins must be >0 and <= 1000000\";\n      // only used on single pass\n      _binsz2 = (_max + (vec.isInt()?.5:0) - _min) / max_qbins;\n      _start2 = _binsz2 * Math.floor(_min/_binsz2);\n\n      if ( multiPass ) {\n        assert maxBinCnt > 0;\n        // Log.info(\"Finer histogram has \"+nbin2+\" bins. Visible histogram has \"+nbin);\n        // Log.info(\"Finer histogram starts at \"+_start2+\" Visible histogram starts at \"+_start);\n        // Log.info(\"_min \"+_min+\" _max \"+_max);\n        // can't make any assertion about _start2 vs _start  (either can be smaller due to fp issues)\n        hcnt2 = new long[maxBinCnt];\n        hcnt2_min = new double[maxBinCnt];\n        hcnt2_max = new double[maxBinCnt];\n      }\n      else {\n        // okay if 1 more than max_qbins gets created\n        // _binsz2 = _binsz / (max_qbins / nbin);\n        int nbin2 = (int)(Math.round((_max + (vec.isInt()?.5:0) - _start2)*1000000.0/_binsz2)/1000000L) + 1;\n        assert nbin2 > 0;\n        // Log.info(\"Finer histogram has \"+nbin2+\" bins. Visible histogram has \"+nbin);\n        // Log.info(\"Finer histogram starts at \"+_start2+\" Visible histogram starts at \"+_start);\n        // Log.info(\"_min \"+_min+\" _max \"+_max);\n        // can't make any assertion about _start2 vs _start  (either can be smaller due to fp issues)\n        hcnt2 = new long[nbin2];\n        hcnt2_min = new double[nbin2];\n        hcnt2_max = new double[nbin2];\n      }\n    } \n    else { // vec does not contain finite numbers\n      // do we care here? have to think about whether multiPass is disabled/\n      _start2 = vec.min();\n      _binsz2 = Double.POSITIVE_INFINITY;\n      hcnt2 = new long[1];\n      hcnt2_min = new double[1];\n      hcnt2_max = new double[1];\n    }\n    // these longs are used (see above)\n    // hcnt2_low\n    // hcnt2_high\n    // hcnt2_high_min\n\n    // Implicit on new?\n    //  init to zero for each pass\n    //  for (int i = 0; i < hcnt2.length; i++) hcnt2[i] = 0;\n    //  hcnt2_low = 0;\n    //  hcnt2_high = 0;\n  }","id":75368,"modified_method":"public Quantiles(Vec vec, String name, double quantile, int max_qbins, \n        double valStart, double valEnd, boolean multiPass) {\n\n    colname = name;\n    _isEnum = vec.isEnum();\n    _isInt = vec.isInt();\n    _domain = vec.isEnum() ? vec.domain() : null;\n    _max = vec.max();\n    _min = vec.min();\n    _mean = vec.mean();\n    _sigma = vec.sigma();\n    _naCnt = vec.naCnt();\n\n    _totalRows = 0;\n    QUANTILES_TO_DO = new double[1];\n    QUANTILES_TO_DO[0] = quantile;\n\n    _valStart = valStart;\n    _valEnd = valEnd;\n    _valRange = valEnd - valStart;\n    _multiPass = multiPass;\n\n    int desiredBinCnt = max_qbins;\n    int maxBinCnt = desiredBinCnt + 1;\n    _valBinSize = _valRange / (desiredBinCnt + 0.0);\n    _valMaxBinCnt = maxBinCnt;\n\n    if( vec.isEnum() && _domain.length < MAX_ENUM_SIZE ) {\n      // do we even care here? don't want to think about whether multiPass is disabled\n      _start2 = 0;\n      _binsz2 = 1;\n      hcnt2 = new long[_domain.length];\n      hcnt2_min = new double[_domain.length];\n      hcnt2_max = new double[_domain.length];\n    } \n    else if ( !Double.isNaN(_min) ) {\n      assert max_qbins > 0 && max_qbins <= 1000000 : \"max_qbins must be >0 and <= 1000000\";\n      // only used on single pass\n      _binsz2 = (_max + (vec.isInt()?.5:0) - _min) / max_qbins;\n      _start2 = _binsz2 * Math.floor(_min/_binsz2);\n\n      if ( multiPass ) {\n        assert maxBinCnt > 0;\n        Log.info(\"Multipass histogram starts at \"+_valStart);\n        Log.info(\"_min \"+_min+\" _max \"+_max);\n        // can't make any assertion about _start2 vs _start  (either can be smaller due to fp issues)\n        hcnt2 = new long[maxBinCnt];\n        hcnt2_min = new double[maxBinCnt];\n        hcnt2_max = new double[maxBinCnt];\n      }\n      else {\n        // okay if 1 more than max_qbins gets created\n        // _binsz2 = _binsz / (max_qbins / nbin);\n        int nbin2 = (int)(Math.round((_max + (vec.isInt()?.5:0) - _start2)*1000000.0/_binsz2)/1000000L) + 1;\n        assert nbin2 > 0;\n        Log.info(\"Single pass histogram has \"+nbin2+\" bins\");\n        Log.info(\"Single pass histogram starts at \"+_start2);\n        Log.info(\"_min \"+_min+\" _max \"+_max);\n        // can't make any assertion about _start2 vs _min (either can be slightly smaller: fp)\n        hcnt2 = new long[nbin2];\n        hcnt2_min = new double[nbin2];\n        hcnt2_max = new double[nbin2];\n      }\n    } \n    else { // vec does not contain finite numbers\n      // do we care here? have to think about whether multiPass is disabled/\n      _start2 = vec.min();\n      _binsz2 = Double.POSITIVE_INFINITY;\n      hcnt2 = new long[1];\n      hcnt2_min = new double[1];\n      hcnt2_max = new double[1];\n    }\n    hcnt2_low = 0;\n    hcnt2_high = 0;\n    hcnt2_high_min = 0;\n    // hcnt2 implicitly zeroed on new \n  }","commit_id":"ac99f7ecea71e915e59abbe95a0d42de17118d7a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public void finishUp(Vec vec, long max_qbins) {\n    // below, we force it to ignore length and only do [0]\n    // need to figure out if we need to do a list and how that's returned\n    _pctile = new double[QUANTILES_TO_DO.length];\n\n    if ( _isEnum ) {\n      ;\n    } else {\n      if ( false ) {\n        // FIX! how to pass this corectly\n        long desiredBinCnt = max_qbins + 1;\n        exactQuantilesMultiPass(_pctile, QUANTILES_TO_DO, desiredBinCnt);\n      } else {\n        approxQuantilesOnePass(_pctile, QUANTILES_TO_DO);\n      }\n    }\n  }","id":75369,"modified_method":"public void finishUp(Vec vec, long max_qbins) {\n    // below, we force it to ignore length and only do [0]\n    // need to figure out if we need to do a list and how that's returned\n    _pctile = new double[QUANTILES_TO_DO.length];\n    if ( _isEnum ) {\n      ;\n    } \n    else {\n      if ( !_multiPass ) {\n        _done = approxQuantilesOnePass(_pctile, QUANTILES_TO_DO);\n      } \n      else {\n        // FIX! how to pass this corectly\n        long desiredBinCnt = max_qbins + 1;\n        _done = exactQuantilesMultiPass(_pctile, QUANTILES_TO_DO, desiredBinCnt);\n      }\n    }\n  }","commit_id":"ac99f7ecea71e915e59abbe95a0d42de17118d7a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override protected Response serve() {\n    if( source_key == null ) return RequestServer._http404.serve();\n    if( column == null ) return RequestServer._http404.serve();\n    if (column.isEnum()) {\n      throw new IllegalArgumentException(\"Column is an enum\");\n    }\n    if (! ((interpolation_type == 2) || (interpolation_type == 7))) {\n      throw new IllegalArgumentException(\"Unsupported interpolation type\");\n    }\n\n    Vec[] vecs = new Vec[1];\n    String[] names = new String[1];\n    vecs[0] = column;\n    names[0] = source_key.names()[source_key.find(column)];\n    Frame fr = new Frame(names, vecs);\n\n    Futures fs = new Futures();\n    for( Vec vec : vecs) {\n        vec.rollupStats(fs);\n        // just to see, move to using these rather than the min/max/mean from basicStats\n        double vmax = vec.max();\n        double vmin = vec.min();\n        double vmean = vec.mean();\n        double vsigma = vec.sigma();\n        long vnaCnt = vec.naCnt();\n        boolean visInt = vec.isInt();\n    }\n    fs.blockForPending();\n\n    Quantiles[] qbins;\n    // not used on the single pass approx. will use on multipass iterations\n    double valStart = vecs[0].min();\n    double valEnd = vecs[0].max();\n    boolean multiPass = false;\n    qbins = new Quantiles.BinTask2(quantile, max_qbins, valStart, valEnd, multiPass).doAll(fr)._qbins;\n\n    // Have to get this internal state, and copy this state for the next iteration\n    // in order to multipass\n    // I guess forward as params to next iteration\n    // while ( (iteration <= maxIterations) && !done ) {\n    //  valStart   = newValStart;\n    //  valEnd     = newValEnd;\n\n    // These 3 are available for viewing, but not necessary to iterate\n    //  valRange   = newValRange;\n    //  valBinSize = newValBinSize;\n    //  valLowCnt  = newValLowCnt;\n\n    if (qbins != null) {\n      qbins[0].finishUp(vecs[0], max_qbins);\n      column_name = qbins[0].colname;\n      quantile_requested = qbins[0].QUANTILES_TO_DO[0];\n      interpolation_type_requested = interpolation_type;\n      result = qbins[0]._pctile[0];\n    }\n\n    // just see we can do another iteration with same values\n    // This would normally be up above in a conditional loop\n    int iteration = 0;\n    // if max_qbins is set to 2? hmm. we won't resolve if max_qbins = 1\n    // interesting to see how we resolve (should we disallow < 1000? (accuracy issues) but good for test)\n    int MAX_ITERATIONS = 32; \n    // qbins2 = new Quantiles.BinTask2(quantile, max_qbins, valStart, valEnd, multiPass).doAll(fr)._qbins;\n\n    return Response.done(this);\n  }","id":75370,"modified_method":"@Override protected Response serve() {\n    if( source_key == null ) return RequestServer._http404.serve();\n    if( column == null ) return RequestServer._http404.serve();\n    if (column.isEnum()) {\n      throw new IllegalArgumentException(\"Column is an enum\");\n    }\n    if (! ((interpolation_type == 2) || (interpolation_type == 7))) {\n      throw new IllegalArgumentException(\"Unsupported interpolation type\");\n    }\n\n    Vec[] vecs = new Vec[1];\n    String[] names = new String[1];\n    vecs[0] = column;\n    names[0] = source_key.names()[source_key.find(column)];\n    Frame fr = new Frame(names, vecs);\n\n    Futures fs = new Futures();\n    for( Vec vec : vecs) {\n        vec.rollupStats(fs);\n        // just to see, move to using these rather than the min/max/mean from basicStats\n        double vmax = vec.max();\n        double vmin = vec.min();\n        double vmean = vec.mean();\n        double vsigma = vec.sigma();\n        long vnaCnt = vec.naCnt();\n        boolean visInt = vec.isInt();\n    }\n    fs.blockForPending();\n\n    // not used on the single pass approx. will use on multipass iterations\n    double valStart = vecs[0].min();\n    double valEnd = vecs[0].max();\n    boolean multiPass = false;\n    Quantiles[] qbins;\n    qbins = new Quantiles.BinTask2(quantile, max_qbins, valStart, valEnd, multiPass).doAll(fr)._qbins;\n    // can we just overwrite it with a new one?\n    Log.info(\"for approx. valStart: \"+valStart+\" valEnd: \"+valEnd);\n\n    // Have to get this internal state, and copy this state for the next iteration\n    // in order to multipass\n    // I guess forward as params to next iteration\n    // while ( (iteration <= maxIterations) && !done ) {\n    //  valStart   = newValStart;\n    //  valEnd     = newValEnd;\n\n    // These 3 are available for viewing, but not necessary to iterate\n    //  valRange   = newValRange;\n    //  valBinSize = newValBinSize;\n    //  valLowCnt  = newValLowCnt;\n\n    double approxResult;\n    double exactResult;\n    boolean done;\n    if (qbins != null) { // if it's enum it will be null?\n      qbins[0].finishUp(vecs[0], max_qbins);\n      column_name = qbins[0].colname;\n      quantile_requested = qbins[0].QUANTILES_TO_DO[0];\n      interpolation_type_requested = interpolation_type;\n      done = qbins[0]._done;\n      approxResult = qbins[0]._pctile[0];\n      interpolated = qbins[0]._interpolated;\n    }\n    else {\n      column_name = \"\";\n      quantile_requested = qbins[0].QUANTILES_TO_DO[0];\n      interpolation_type_requested = interpolation_type;\n      iterations = 0;\n      done = false;\n      approxResult = Double.NaN;\n      interpolated = false;\n    }\n\n    result = approxResult;\n\n    // if max_qbins is set to 2? hmm. we won't resolve if max_qbins = 1\n    // interesting to see how we resolve (should we disallow < 1000? (accuracy issues) but good for test)\n    // done with that!\n    qbins = null;\n    \n    final int MAX_ITERATIONS = 16; \n    if ( multiple_pass == 1) {\n      // try a second pass\n      Quantiles[] qbins2;\n      multiPass = true;\n      int iteration;\n      \n      qbins2 = null;\n      for (int b = 0; b < MAX_ITERATIONS; b++) {\n        qbins2 = new Quantiles.BinTask2(quantile, max_qbins, valStart, valEnd, multiPass).doAll(fr)._qbins;\n        iterations = b + 1;\n        if ( qbins2 != null ) {\n          qbins2[0].finishUp(vecs[0], max_qbins);\n          // for printing?\n          double valRange = qbins2[0]._valRange;\n          double valBinSize = qbins2[0]._valBinSize;\n          Log.info(\"\\nmultipass iteration: \"+iterations+\" valStart: \"+valStart+\" valEnd: \"+valEnd);\n          Log.info(\"valBinSize: \"+valBinSize);\n\n          valStart = qbins2[0]._newValStart;\n          valEnd = qbins2[0]._newValEnd;\n          done = qbins2[0]._done;\n          if ( done ) break;\n        }\n      }\n      if (qbins2 != null) { // if it's enum it will be null?\n        column_name = qbins2[0].colname;\n        quantile_requested = qbins2[0].QUANTILES_TO_DO[0];\n        interpolation_type_requested = interpolation_type;\n        done = qbins2[0]._done;\n        exactResult = qbins2[0]._pctile[0];\n        interpolated = qbins2[0]._interpolated;\n      }\n      else {\n        column_name = \"\";\n        quantile_requested = qbins2[0].QUANTILES_TO_DO[0];\n        interpolation_type_requested = interpolation_type;\n        iterations = 0;\n        done = false;\n        exactResult = Double.NaN;\n        interpolated = false;\n      }\n\n      qbins2 = null;\n      result2 = exactResult;\n    }\n    return Response.done(this);\n  }","commit_id":"ac99f7ecea71e915e59abbe95a0d42de17118d7a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public void add(double val) {\n    if ( Double.isNaN(val) ) return;\n    _totalRows++;\n    if ( _isEnum ) return;\n\n    long maxBinCnt = _valMaxBinCnt;\n\n    if ( !_multiPass  ) { // single pass approx\n      long binIdx2;\n      if (hcnt2.length==1) {\n        binIdx2 = 0; // not used\n      }\n      else {\n        binIdx2 = (int) Math.floor((val - _start2) / _binsz2);\n      }\n\n      int binIdx2Int = (int) binIdx2;\n      assert (binIdx2Int >= 0 && binIdx2Int < hcnt2.length) : \n        \"binIdx2Int too big for hcnt2 \"+binIdx2Int+\" \"+hcnt2.length;\n\n      if ( (hcnt2[binIdx2Int] == 0) || (val < hcnt2_min[binIdx2Int]) ) {\n        hcnt2_min[binIdx2Int] = val;\n      }\n      if ( (hcnt2[binIdx2Int] == 0) || (val > hcnt2_max[binIdx2Int]) ) {\n        hcnt2_max[binIdx2Int] = val;\n      }\n      ++hcnt2[binIdx2Int];\n      // don't care about bin edge leaks on the one pass algo\n      // I suppose the hcnt2.length must be big enough?\n    }\n    else { // multi pass exact. Should be able to do this for both, if the valStart param is correct\n      long binIdx2;\n      // Need to count the stuff outside the bin-gathering, \n      // since threshold compare is based on total row compare\n      double valOffset = val - _valStart;\n\n      // FIX! do we really need this special case? Not hurting.\n      if (hcnt2.length==1) {\n        binIdx2 = 0;\n      }\n      else {\n        binIdx2 = (int) Math.floor(valOffset / _valBinSize);\n      }\n      int binIdx2Int = (int) binIdx2;\n\n      // we always need the start condition in the bins?\n      // if ( valOffset < 0 ) {\n      // if ( binIdx2Int < 0 ) { // works 3/10/14\n      // maybe some redundancy in two compares\n      if ( valOffset < 0 || binIdx2Int<0 ) { \n        ++hcnt2_low;\n      }\n      // we always need the end condition in the bins?\n      // else if ( val > _valEnd ) {\n      // else if ( binIdx2Int >= maxBinCnt ) { // works 3/10/14\n      // would using valOffset here be less accurate? maybe some redundancy in two compares\n      // can't use maxBinCnt-1, because the extra bin is used for one value (the bounds)\n      else if ( val > _valEnd || binIdx2>=maxBinCnt ) { \n        if ( (hcnt2_high==0) || (val < hcnt2_high_min) ) hcnt2_high_min = val;\n        ++hcnt2_high;\n      } \n      else {\n        assert (binIdx2Int >= 0 && binIdx2Int < hcnt2.length) : \n          \"binIdx2Int too big for hcnt2 \"+binIdx2Int+\" \"+hcnt2.length;\n        // Log.info(\"Q_ (multi) val: \"+val+\" valOffset: \"+valOffset+\" _valBinSize: \"+_valBinSize);\n        assert (binIdx2Int>=0) && (binIdx2Int<=maxBinCnt) : \"binIdx2Int \"+binIdx2Int+\" out of range\";\n\n        if ( hcnt2[binIdx2Int]==0 || (val < hcnt2_min[binIdx2Int]) ) hcnt2_min[binIdx2Int] = val;\n        if ( hcnt2[binIdx2Int]==0 || (val > hcnt2_max[binIdx2Int]) ) hcnt2_max[binIdx2Int] = val;\n        ++hcnt2[binIdx2Int];\n\n        // For debug/info, can report when it goes into extra bin needed due to fp fuzziness\n        // not an error! should be protected by newValEnd below, and nextK \n        // estimates should go into the extra bin if interpolation is needed\n        if ( false && (binIdx2 == (maxBinCnt-1)) ) {\n            Log.info(\"\\nQ_ FP! val went into the extra maxBinCnt bin:\"+\n              binIdx2+\" \"+hcnt2_high_min+\" \"+valOffset+\" \"+\n              val+\" \"+_valStart+\" \"+hcnt2_high+\" \"+val+\" \"+_valEnd,\"\\n\");\n        }\n      }\n    }\n  }","id":75371,"modified_method":"public void add(double val) {\n    if ( Double.isNaN(val) ) return;\n    // can get infinity due to bad enum parse to real\n    // histogram is sized ok, but the index calc below will be too big\n    // just drop them. not sure if something better to do?\n    if( val==Double.POSITIVE_INFINITY ) return;\n    if( val==Double.NEGATIVE_INFINITY ) return;\n\n    _totalRows++;\n    if ( _isEnum ) return;\n\n    long maxBinCnt = _valMaxBinCnt;\n\n    if ( !_multiPass  ) { // single pass approx\n      long binIdx2;\n      if (hcnt2.length==1) {\n        binIdx2 = 0; // not used\n      }\n      else {\n        binIdx2 = (int) Math.floor((val - _start2) / _binsz2);\n      }\n\n      int binIdx2Int = (int) binIdx2;\n      assert (binIdx2Int >= 0 && binIdx2Int < hcnt2.length) : \n        \"binIdx2Int too big for hcnt2 \"+binIdx2Int+\" \"+hcnt2.length;\n\n      if ( (hcnt2[binIdx2Int] == 0) || (val < hcnt2_min[binIdx2Int]) ) {\n        hcnt2_min[binIdx2Int] = val;\n      }\n      if ( (hcnt2[binIdx2Int] == 0) || (val > hcnt2_max[binIdx2Int]) ) {\n        hcnt2_max[binIdx2Int] = val;\n      }\n      ++hcnt2[binIdx2Int];\n      // don't care about bin edge leaks on the one pass algo\n      // I suppose the hcnt2.length must be big enough?\n    }\n    else { // multi pass exact. Should be able to do this for both, if the valStart param is correct\n      long binIdx2;\n      // Need to count the stuff outside the bin-gathering, \n      // since threshold compare is based on total row compare\n      double valOffset = val - _valStart;\n\n      // FIX! do we really need this special case? Not hurting.\n      if (hcnt2.length==1) {\n        binIdx2 = 0;\n      }\n      else {\n        binIdx2 = (int) Math.floor(valOffset / _valBinSize);\n      }\n      int binIdx2Int = (int) binIdx2;\n\n      // we always need the start condition in the bins?\n      // if ( valOffset < 0 ) {\n      // if ( binIdx2Int < 0 ) { // works 3/10/14\n      // maybe some redundancy in two compares\n      if ( valOffset < 0 || binIdx2Int<0 ) { \n        ++hcnt2_low;\n      }\n      // we always need the end condition in the bins?\n      // else if ( val > _valEnd ) {\n      // else if ( binIdx2Int >= maxBinCnt ) { // works 3/10/14\n      // would using valOffset here be less accurate? maybe some redundancy in two compares\n      // can't use maxBinCnt-1, because the extra bin is used for one value (the bounds)\n      else if ( val > _valEnd || binIdx2>=maxBinCnt ) { \n        if ( (hcnt2_high==0) || (val < hcnt2_high_min) ) hcnt2_high_min = val;\n        ++hcnt2_high;\n      } \n      else {\n        assert (binIdx2Int >= 0 && binIdx2Int < hcnt2.length) : \n          \"binIdx2Int too big for hcnt2 \"+binIdx2Int+\" \"+hcnt2.length;\n        // Log.info(\"Q_ (multi) val: \"+val+\" valOffset: \"+valOffset+\" _valBinSize: \"+_valBinSize);\n        assert (binIdx2Int>=0) && (binIdx2Int<=maxBinCnt) : \"binIdx2Int \"+binIdx2Int+\" out of range\";\n\n        if ( hcnt2[binIdx2Int]==0 || (val < hcnt2_min[binIdx2Int]) ) hcnt2_min[binIdx2Int] = val;\n        if ( hcnt2[binIdx2Int]==0 || (val > hcnt2_max[binIdx2Int]) ) hcnt2_max[binIdx2Int] = val;\n        ++hcnt2[binIdx2Int];\n\n        // For debug/info, can report when it goes into extra bin needed due to fp fuzziness\n        // not an error! should be protected by newValEnd below, and nextK \n        // estimates should go into the extra bin if interpolation is needed\n        if ( false && (binIdx2 == (maxBinCnt-1)) ) {\n            Log.info(\"\\nQ_ FP! val went into the extra maxBinCnt bin:\"+\n              binIdx2+\" \"+hcnt2_high_min+\" \"+valOffset+\" \"+\n              val+\" \"+_valStart+\" \"+hcnt2_high+\" \"+val+\" \"+_valEnd,\"\\n\");\n        }\n      }\n    }\n  }","commit_id":"f3635faa156fcbd46d68ea616d275473923c4cf1","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public Summary2(Vec vec, String name, BasicStat stat0, int max_qbins) {\n    colname = name;\n    _stat0 = stat0;\n    _type = vec.isEnum()?2:vec.isInt()?1:0;\n    _domain = vec.isEnum() ? vec.domain() : null;\n    _gprows = 0;\n    double sigma = Double.isNaN(vec.sigma()) ? 0 : vec.sigma();\n    if ( _type != T_ENUM ) {\n      _mins = MemoryManager.malloc8d((int)Math.min(vec.length(),NMAX));\n      _maxs = MemoryManager.malloc8d((int)Math.min(vec.length(),NMAX));\n      Arrays.fill(_mins, Double.NaN);\n      Arrays.fill(_maxs, Double.NaN);\n    } else {\n      _mins = MemoryManager.malloc8d(Math.min(_domain.length,NMAX));\n      _maxs = MemoryManager.malloc8d(Math.min(_domain.length,NMAX));\n    }\n\n    if( vec.isEnum() && _domain.length < MAX_HIST_SZ ) {\n      _start = 0;\n      _start2 = 0;\n      _binsz = 1;\n      _binsz2 = 1;\n      hcnt = new long[_domain.length];\n      hcnt2 = new long[_domain.length];\n      hcnt2_min = new double[_domain.length];\n      hcnt2_max = new double[_domain.length];\n    } \n    else if (!(Double.isNaN(stat0._min2) || Double.isNaN(stat0._max2))) {\n      // guard against improper parse (date type) or zero c._sigma\n      long N = _stat0._len - stat0._nas - stat0._nans - stat0._pinfs - stat0._ninfs;\n      double b = Math.max(1e-4,3.5 * sigma/ Math.cbrt(N));\n      double d = Math.pow(10, Math.floor(Math.log10(b)));\n      if (b > 20*d/3)\n        d *= 10;\n      else if (b > 5*d/3)\n        d *= 5;\n\n      // tweak for integers\n      if (d < 1. && vec.isInt()) d = 1.;\n\n      // Result from the dynamic bin sizing equations\n      double startSuggest = d * Math.floor(stat0._min2 / d);\n      double binszSuggest = d;\n      int nbinSuggest = (int)(Math.round((stat0._max2 + (vec.isInt() ? .5 : 0) - startSuggest) / d)) + 1;\n      \n      // Protect against massive binning. browser doesn't need\n      int BROWSER_BIN_TARGET = 100;\n\n      //  _binsz/_start is used in the histogramming. \n      // nbin is used in the array declaration. must be big enough. \n      // the resulting nbin, could be really large number. We need to cap it. \n      // should also be obsessive and check that it's not 0 and force to 1.\n      // Since nbin is implied by _binsz, ratio _binsz and recompute nbin\n      int binCase = 0; // keep track in case we assert\n      if ( nbinSuggest > BROWSER_BIN_TARGET ) {\n        // switch to a static equation with a fixed bin count, and recompute binszSuggest\n        // one more bin than necessary for the range (99 exact. causes one extra\n        binszSuggest = (stat0._max2 - stat0._min2) / (BROWSER_BIN_TARGET - 1.0);\n        _start = binszSuggest * Math.floor(stat0._min2 / binszSuggest);\n        binCase = 1;\n      }\n      // minimum 1. Also 1 if there is only one value.\n      else if ( stat0._max2==stat0._min2 || nbinSuggest<1 ) {\n        binszSuggest = 0; // fixed next with other 0 cases.\n        _start = stat0._min2;\n        binCase = 2;\n      }\n      // minimum 2 if min/max different\n      else if ( stat0._max2!=stat0._min2 && nbinSuggest<2 ) {\n        binszSuggest = (stat0._max2 - stat0._min2) / 2.0;\n        _start = stat0._min2;\n        binCase = 3;\n      }\n      else {\n        // align to binszSuggest boundary\n        _start = binszSuggest * Math.floor(stat0._min2 / binszSuggest);\n        binCase = 4;\n      }\n\n      // _binsz = 0 means min/max are equal for reals?. Just make it a little number\n      // this won't show up in browser display, since bins are labelled by start value\n\n      // Now that we know the best bin size that will fit..Floor the _binsz if integer so visible\n      // histogram looks good for integers. This is our final best bin size.\n      double binsz = (binszSuggest!=0) ? binszSuggest : (vec.isInt() ? 1 : 1e-13d); \n      _binsz = vec.isInt() ? Math.floor(binsz) : binsz;\n\n      // This equation creates possibility of some of the first bins being empty\n      // also: _binsz means many _binsz2 could be empty at the start if we resused _start there\n      // FIX! is this okay if the dynamic range is > 2**32\n      // align to bin size?\n      int nbin = (int) Math.ceil((stat0._max2 - _start)/_binsz) + 1;\n      \n\n      double impliedBinEnd = _start + (nbin * _binsz);\n      String assertMsg = _start+\" \"+_stat0._min2+\" \"+_stat0._max2+\n        \" \"+impliedBinEnd+\" \"+_binsz+\" \"+nbin+\" \"+binCase;\n      // Log.info(\"Summary2 bin1. \"+assertMsg);\n      assert _start <= _stat0._min2 : assertMsg;\n      // just in case, make sure it's big enough\n      assert nbin > 0: assertMsg;\n\n      // just for double checking we're okay (nothing outside the bin rang)\n      assert impliedBinEnd>=_stat0._max2 : assertMsg;\n\n\n      // create a 2nd finer grained historam for quantile estimates.\n      // okay if it is approx. 1000 bins (+-1)\n      // update: we allow api to change max_qbins. default 1000. larger = more accuracy\n      assert max_qbins > 0 && max_qbins <= 10000000 : \"max_qbins must be >0 and <= 10000000\";\n\n      // okay if 1 more than max_qbins gets created\n      double d2 = (stat0._max2 - stat0._min2) / max_qbins;\n      // _binsz2 = 0 means min/max are equal for reals?. Just make it a little number\n      // this won't show up in browser display, since bins are labelled by start value\n      _binsz2 = (d2!=0) ? d2 : (vec.isInt() ? 1 : 1e-13d); \n      _start2 = stat0._min2;\n      int nbin2 = (int) Math.ceil((stat0._max2 - _start2)/_binsz2) + 1;\n      double impliedBinEnd2 = _start2 + (nbin2 * _binsz2);\n\n      assertMsg = _start2+\" \"+_stat0._min2+\" \"+_stat0._max2+\n        \" \"+impliedBinEnd2+\" \"+_binsz2+\" \"+nbin2;\n      // Log.info(\"Summary2 bin2. \"+assertMsg);\n      assert _start2 <= stat0._min2 : assertMsg;\n      assert nbin2 > 0 : assertMsg;\n      // can't make any assertion about _start2 vs _start  (either can be smaller due to fp issues)\n      assert impliedBinEnd2>=_stat0._max2 : assertMsg;\n\n      hcnt = new long[nbin];\n      hcnt2 = new long[nbin2];\n      hcnt2_min = new double[nbin2];\n      hcnt2_max = new double[nbin2];\n\n      // Log.info(\"Finer histogram has \"+nbin2+\" bins. Visible histogram has \"+nbin);\n      // Log.info(\"Finer histogram starts at \"+_start2+\" Visible histogram starts at \"+_start);\n      // Log.info(\"stat0._min2 \"+stat0._min2+\" stat0._max2 \"+stat0._max2);\n\n    } else { // vec does not contain finite numbers\n      Log.info(\"Summary2: NaN in stat0._min2: \"+stat0._min2+\" or stat0._max2: \"+stat0._max2);\n      // vec.min() wouldn't be any better here. It could be NaN? 4/13/14\n      // _start = vec.min();\n      // _start2 = vec.min();\n      // _binsz = Double.POSITIVE_INFINITY;\n      // _binsz2 = Double.POSITIVE_INFINITY;\n      _start = Double.NaN;\n      _start2 = Double.NaN;\n      _binsz = Double.NaN;\n      _binsz2 = Double.NaN;\n      hcnt = new long[1];\n      hcnt2 = new long[1];\n      hcnt2_min = new double[1];\n      hcnt2_max = new double[1];\n    }\n  }","id":75372,"modified_method":"public Summary2(Vec vec, String name, BasicStat stat0, int max_qbins) {\n    colname = name;\n    _stat0 = stat0;\n    _type = vec.isEnum()?2:vec.isInt()?1:0;\n    _domain = vec.isEnum() ? vec.domain() : null;\n    _gprows = 0;\n    double sigma = Double.isNaN(vec.sigma()) ? 0 : vec.sigma();\n    if ( _type != T_ENUM ) {\n      _mins = MemoryManager.malloc8d((int)Math.min(vec.length(),NMAX));\n      _maxs = MemoryManager.malloc8d((int)Math.min(vec.length(),NMAX));\n      Arrays.fill(_mins, Double.NaN);\n      Arrays.fill(_maxs, Double.NaN);\n    } else {\n      _mins = MemoryManager.malloc8d(Math.min(_domain.length,NMAX));\n      _maxs = MemoryManager.malloc8d(Math.min(_domain.length,NMAX));\n    }\n\n    if( vec.isEnum() && _domain.length < MAX_HIST_SZ ) {\n      _start = 0;\n      _start2 = 0;\n      _binsz = 1;\n      _binsz2 = 1;\n      hcnt = new long[_domain.length];\n      hcnt2 = new long[_domain.length];\n      hcnt2_min = new double[_domain.length];\n      hcnt2_max = new double[_domain.length];\n    } \n    else if (!(Double.isNaN(stat0._min2) || Double.isNaN(stat0._max2))) {\n      // guard against improper parse (date type) or zero c._sigma\n      long N = _stat0._len - stat0._nas - stat0._nans - stat0._pinfs - stat0._ninfs;\n      double b = Math.max(1e-4,3.5 * sigma/ Math.cbrt(N));\n      double d = Math.pow(10, Math.floor(Math.log10(b)));\n      if (b > 20*d/3)\n        d *= 10;\n      else if (b > 5*d/3)\n        d *= 5;\n\n      // tweak for integers\n      if (d < 1. && vec.isInt()) d = 1.;\n\n      // Result from the dynamic bin sizing equations\n      double startSuggest = d * Math.floor(stat0._min2 / d);\n      double binszSuggest = d;\n      int nbinSuggest = (int) Math.ceil((stat0._max2 - startSuggest)/d) + 1;\n      \n      // Protect against massive binning. browser doesn't need\n      int BROWSER_BIN_TARGET = 100;\n\n      //  _binsz/_start is used in the histogramming. \n      // nbin is used in the array declaration. must be big enough. \n      // the resulting nbin, could be really large number. We need to cap it. \n      // should also be obsessive and check that it's not 0 and force to 1.\n      // Since nbin is implied by _binsz, ratio _binsz and recompute nbin\n      int binCase = 0; // keep track in case we assert\n      if ( stat0._max2==stat0._min2) {\n        binszSuggest = 0; // fixed next with other 0 cases.\n        _start = stat0._min2;\n        binCase = 1;\n      }\n      // minimum 2 if min/max different\n      else if ( stat0._max2!=stat0._min2 && nbinSuggest<2 ) {\n        binszSuggest = (stat0._max2 - stat0._min2) / 2.0;\n        _start = stat0._min2;\n        binCase = 2;\n      }\n      else if (nbinSuggest<1 || nbinSuggest>BROWSER_BIN_TARGET ) {\n        // switch to a static equation with a fixed bin count, and recompute binszSuggest\n        // one more bin than necessary for the range (99 exact. causes one extra\n        binszSuggest = (stat0._max2 - stat0._min2) / (BROWSER_BIN_TARGET - 1.0);\n        _start = binszSuggest * Math.floor(stat0._min2 / binszSuggest);\n        binCase = 3;\n      }\n      else {\n        // align to binszSuggest boundary\n        _start = binszSuggest * Math.floor(stat0._min2 / binszSuggest);\n        binCase = 4;\n      }\n\n      // _binsz = 0 means min/max are equal for reals?. Just make it a little number\n      // this won't show up in browser display, since bins are labelled by start value\n\n      // Now that we know the best bin size that will fit..Floor the _binsz if integer so visible\n      // histogram looks good for integers. This is our final best bin size.\n      double binsz = (binszSuggest!=0) ? binszSuggest : (vec.isInt() ? 1 : 1e-13d); \n      _binsz = vec.isInt() ? Math.floor(binsz) : binsz;\n\n      // This equation creates possibility of some of the first bins being empty\n      // also: _binsz means many _binsz2 could be empty at the start if we resused _start there\n      // FIX! is this okay if the dynamic range is > 2**32\n      // align to bin size?\n      int nbin = (int) Math.ceil((stat0._max2 - _start)/_binsz) + 1;\n      \n\n      double impliedBinEnd = _start + (nbin * _binsz);\n      String assertMsg = _start+\" \"+_stat0._min2+\" \"+_stat0._max2+\n        \" \"+impliedBinEnd+\" \"+_binsz+\" \"+nbin+\" \"+startSuggest+\" \"+nbinSuggest+\" \"+binCase;\n      // Log.info(\"Summary2 bin1. \"+assertMsg);\n      assert _start <= _stat0._min2 : assertMsg;\n      // just in case, make sure it's big enough\n      assert nbin > 0: assertMsg;\n\n      // just for double checking we're okay (nothing outside the bin rang)\n      assert impliedBinEnd>=_stat0._max2 : assertMsg;\n\n\n      // create a 2nd finer grained historam for quantile estimates.\n      // okay if it is approx. 1000 bins (+-1)\n      // update: we allow api to change max_qbins. default 1000. larger = more accuracy\n      assert max_qbins > 0 && max_qbins <= 10000000 : \"max_qbins must be >0 and <= 10000000\";\n\n      // okay if 1 more than max_qbins gets created\n      double d2 = (stat0._max2 - stat0._min2) / max_qbins;\n      // _binsz2 = 0 means min/max are equal for reals?. Just make it a little number\n      // this won't show up in browser display, since bins are labelled by start value\n      _binsz2 = (d2!=0) ? d2 : (vec.isInt() ? 1 : 1e-13d); \n      _start2 = stat0._min2;\n      int nbin2 = (int) Math.ceil((stat0._max2 - _start2)/_binsz2) + 1;\n      double impliedBinEnd2 = _start2 + (nbin2 * _binsz2);\n\n      assertMsg = _start2+\" \"+_stat0._min2+\" \"+_stat0._max2+\n        \" \"+impliedBinEnd2+\" \"+_binsz2+\" \"+nbin2;\n      // Log.info(\"Summary2 bin2. \"+assertMsg);\n      assert _start2 <= stat0._min2 : assertMsg;\n      assert nbin2 > 0 : assertMsg;\n      // can't make any assertion about _start2 vs _start  (either can be smaller due to fp issues)\n      assert impliedBinEnd2>=_stat0._max2 : assertMsg;\n\n      hcnt = new long[nbin];\n      hcnt2 = new long[nbin2];\n      hcnt2_min = new double[nbin2];\n      hcnt2_max = new double[nbin2];\n\n      // Log.info(\"Finer histogram has \"+nbin2+\" bins. Visible histogram has \"+nbin);\n      // Log.info(\"Finer histogram starts at \"+_start2+\" Visible histogram starts at \"+_start);\n      // Log.info(\"stat0._min2 \"+stat0._min2+\" stat0._max2 \"+stat0._max2);\n\n    } else { // vec does not contain finite numbers\n      Log.info(\"Summary2: NaN in stat0._min2: \"+stat0._min2+\" or stat0._max2: \"+stat0._max2);\n      // vec.min() wouldn't be any better here. It could be NaN? 4/13/14\n      // _start = vec.min();\n      // _start2 = vec.min();\n      // _binsz = Double.POSITIVE_INFINITY;\n      // _binsz2 = Double.POSITIVE_INFINITY;\n      _start = Double.NaN;\n      _start2 = Double.NaN;\n      _binsz = Double.NaN;\n      _binsz2 = Double.NaN;\n      hcnt = new long[1];\n      hcnt2 = new long[1];\n      hcnt2_min = new double[1];\n      hcnt2_max = new double[1];\n    }\n  }","commit_id":"f3635faa156fcbd46d68ea616d275473923c4cf1","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public void add(double val) {\n    if( Double.isNaN(val) ) return;\n    _len1++; _gprows++;\n\n    if ( _type != T_ENUM ) {\n      int index;\n      // update min/max\n      if (val < _mins[_mins.length-1] || Double.isNaN(_mins[_mins.length-1])) {\n        index = Arrays.binarySearch(_mins, val);\n        if (index < 0) {\n          index = -(index + 1);\n          for (int j = _mins.length -1; j > index; j--)\n            _mins[j] = _mins[j-1];\n          _mins[index] = val;\n        }\n      }\n      boolean hasNan = Double.isNaN(_maxs[_maxs.length-1]);\n      if (val > _maxs[0] || hasNan) {\n        index = Arrays.binarySearch(_maxs, val);\n        if (index < 0) {\n          index = -(index + 1);\n          if (hasNan) {\n            for (int j = _maxs.length -1; j > index; j--)\n              _maxs[j] = _maxs[j-1];\n            _maxs[index] = val;\n          } else {\n            for (int j = 0; j < index-1; j++)\n              _maxs[j] = _maxs[j+1];\n            _maxs[index-1] = val;\n          }\n        }\n      }\n      // update the finer histogram (used for quantile estimates on numerics)\n      long binIdx2;\n      if (hcnt2.length==1) {\n        binIdx2 = 0; // not used\n      }\n      else {\n        binIdx2 = Math.round(((val - _start2) * 1000000.0) / _binsz2) / 1000000;\n      }\n\n      int binIdx2Int = (int) binIdx2;\n      assert (binIdx2Int >= 0 && binIdx2Int < hcnt2.length) : \n        \"binIdx2Int too big for hcnt2 \"+binIdx2Int+\" \"+hcnt2.length;\n\n      if (hcnt2[binIdx2Int] == 0) {\n        // Log.info(\"New init: \"+val+\" for index \"+binIdx2Int);\n        hcnt2_min[binIdx2Int] = val;\n        hcnt2_max[binIdx2Int] = val;\n      }\n      else {\n        if (val < hcnt2_min[binIdx2Int]) {\n            // Log.info(\"New min: \"+val+\" for index \"+binIdx2Int);\n            hcnt2_min[binIdx2Int] = val;\n        }\n        if (val > hcnt2_max[binIdx2Int]) {\n            // if ( binIdx2Int == 500 ) Log.info(\"New max: \"+val+\" for index \"+binIdx2Int);\n            hcnt2_max[binIdx2Int] = val;\n        }\n      }\n      ++hcnt2[binIdx2Int];\n    }\n\n    // update the histogram the browser/json uses\n    long binIdx;\n    if (hcnt.length == 1) {\n      binIdx = 0;\n    }\n    // interesting. do we really track Infs in the histogram?\n    else if (val == Double.NEGATIVE_INFINITY) {\n      binIdx = 0;\n    }\n    else if (val == Double.POSITIVE_INFINITY) {\n      binIdx = hcnt.length-1;\n    }\n    else {\n      binIdx = Math.round(((val - _start) * 1000000.0) / _binsz) / 1000000;\n    }\n\n    int binIdxInt = (int) binIdx;\n    assert (binIdxInt >= 0 && binIdx < hcnt.length) : \n        \"binIdxInt too big for hcnt2 \"+binIdxInt+\" \"+hcnt.length;\n    ++hcnt[binIdxInt];\n  }","id":75373,"modified_method":"public void add(double val) {\n    if( Double.isNaN(val) ) return;\n    // can get infinity due to bad enum parse to real\n    // histogram is sized ok, but the index calc below will be too big\n    // just drop them. not sure if something better to do?\n    if( val==Double.POSITIVE_INFINITY ) return;\n    if( val==Double.NEGATIVE_INFINITY ) return;\n    _len1++; _gprows++;\n\n    if ( _type != T_ENUM ) {\n      int index;\n      // update min/max\n      if (val < _mins[_mins.length-1] || Double.isNaN(_mins[_mins.length-1])) {\n        index = Arrays.binarySearch(_mins, val);\n        if (index < 0) {\n          index = -(index + 1);\n          for (int j = _mins.length -1; j > index; j--)\n            _mins[j] = _mins[j-1];\n          _mins[index] = val;\n        }\n      }\n      boolean hasNan = Double.isNaN(_maxs[_maxs.length-1]);\n      if (val > _maxs[0] || hasNan) {\n        index = Arrays.binarySearch(_maxs, val);\n        if (index < 0) {\n          index = -(index + 1);\n          if (hasNan) {\n            for (int j = _maxs.length -1; j > index; j--)\n              _maxs[j] = _maxs[j-1];\n            _maxs[index] = val;\n          } else {\n            for (int j = 0; j < index-1; j++)\n              _maxs[j] = _maxs[j+1];\n            _maxs[index-1] = val;\n          }\n        }\n      }\n      // update the finer histogram (used for quantile estimates on numerics)\n      long binIdx2;\n      if (hcnt2.length==1) {\n        binIdx2 = 0; // not used\n      }\n      else {\n        binIdx2 = (int) Math.floor((val - _start2) / _binsz2);\n      }\n\n      int binIdx2Int = (int) binIdx2;\n      assert (binIdx2Int >= 0 && binIdx2Int < hcnt2.length) : \n        \"binIdx2Int too big for hcnt2 \"+binIdx2Int+\" \"+hcnt2.length+\" \"+val+\" \"+_start2+\" \"+_binsz2;\n\n      if (hcnt2[binIdx2Int] == 0) {\n        // Log.info(\"New init: \"+val+\" for index \"+binIdx2Int);\n        hcnt2_min[binIdx2Int] = val;\n        hcnt2_max[binIdx2Int] = val;\n      }\n      else {\n        if (val < hcnt2_min[binIdx2Int]) {\n            // Log.info(\"New min: \"+val+\" for index \"+binIdx2Int);\n            hcnt2_min[binIdx2Int] = val;\n        }\n        if (val > hcnt2_max[binIdx2Int]) {\n            // if ( binIdx2Int == 500 ) Log.info(\"New max: \"+val+\" for index \"+binIdx2Int);\n            hcnt2_max[binIdx2Int] = val;\n        }\n      }\n      ++hcnt2[binIdx2Int];\n    }\n\n    // update the histogram the browser/json uses\n    long binIdx;\n    if (hcnt.length == 1) {\n      binIdx = 0;\n    }\n    // interesting. do we really track Infs in the histogram?\n    else if (val == Double.NEGATIVE_INFINITY) {\n      binIdx = 0;\n    }\n    else if (val == Double.POSITIVE_INFINITY) {\n      binIdx = hcnt.length-1;\n    }\n    else {\n      binIdx = (int) Math.floor((val - _start) / _binsz);\n    }\n\n    int binIdxInt = (int) binIdx;\n    assert (binIdxInt >= 0 && binIdx < hcnt.length) : \n        \"binIdxInt too big for hcnt2 \"+binIdxInt+\" \"+hcnt.length+\" \"+val+\" \"+_start+\" \"+_binsz;\n    ++hcnt[binIdxInt];\n  }","commit_id":"f3635faa156fcbd46d68ea616d275473923c4cf1","url":"https://github.com/h2oai/h2o-2"},{"original_method":"protected AegisType createHolderType(TypeClassInfo info) {\n\n        Type heldType = TypeUtil.getSingleTypeParameter(info.getType());\n        if (heldType == null) {\n            throw new UnsupportedOperationException(\"Invalid holder type \" + info.getType());\n        }\n\n        info.setType(heldType);\n        return createType(heldType);\n    }","id":75374,"modified_method":"protected AegisType createHolderType(TypeClassInfo info) {\n\n        Type heldType = TypeUtil.getSingleTypeParameter(info.getType(), 0);\n        if (heldType == null) {\n            throw new UnsupportedOperationException(\"Invalid holder type \" + info.getType());\n        }\n\n        info.setType(heldType);\n        return createType(heldType);\n    }","commit_id":"ca316e688eee17ce4e4c7d218bfda3eb770c8f66","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Insist that a Type is a parameterized type of one parameter.\n     * This is used to decompose Holders, for example.\n     * @param type the type\n     * @return the parameter, or null if the type is not what we want.\n     */\n    public static Type getSingleTypeParameter(Type type) {\n        if (type instanceof ParameterizedType) {\n            ParameterizedType pType = (ParameterizedType) type;\n            Type[] params = pType.getActualTypeArguments();\n            if (params.length == 1) {\n                return params[0];\n            }\n        }\n        return null;\n    }","id":75375,"modified_method":"/**\n     * Insist that a Type is a parameterized type of one parameter.\n     * This is used to decompose Holders, for example.\n     * @param type the type\n     * @return the parameter, or null if the type is not what we want.\n     */\n    public static Type getSingleTypeParameter(Type type) {\n        return getSingleTypeParameter(type, 0);\n    }","commit_id":"ca316e688eee17ce4e4c7d218bfda3eb770c8f66","url":"https://github.com/apache/cxf"},{"original_method":"protected void readMetadata(TypeClassInfo info, Element mapping, Element parameter) {\n        info.setTypeName(createQName(parameter, DOMUtils.getAttributeValueEmptyNull(parameter, \"typeName\")));\n        info.setMappedName(createQName(parameter, \n                                       DOMUtils.getAttributeValueEmptyNull(parameter, \"mappedName\")));\n        Class<?> relatedClass = TypeUtil.getTypeRelatedClass(info.getType());\n        // we only mess with the generic issues for list and map\n        if (Collection.class.isAssignableFrom(relatedClass)) {\n            Type componentType = getComponentType(mapping, parameter);\n            Type fullType = ParameterizedTypeFactory.createParameterizedType(relatedClass,\n                                                                             new Type[] {componentType});\n            info.setType(fullType);\n        } else if (Map.class.isAssignableFrom(relatedClass)) {\n            Type keyType = getKeyType(mapping, parameter);\n            info.setKeyType(keyType);\n            Type valueType = getValueType(mapping, parameter);\n            info.setValueType(valueType);\n            Type fullType = ParameterizedTypeFactory.createParameterizedType(relatedClass,\n                                                                             new Type[] {keyType, valueType});\n            info.setType(fullType);\n\n        }\n        setType(info, parameter);\n\n        String min = DOMUtils.getAttributeValueEmptyNull(parameter, \"minOccurs\");\n        if (min != null) {\n            info.setMinOccurs(Long.parseLong(min));\n        }\n\n        String max = DOMUtils.getAttributeValueEmptyNull(parameter, \"maxOccurs\");\n        if (max != null) {\n            info.setMaxOccurs(Long.parseLong(max));\n        }\n\n        String flat = DOMUtils.getAttributeValueEmptyNull(parameter, \"flat\");\n        if (flat != null) {\n            info.setFlat(Boolean.valueOf(flat.toLowerCase()).booleanValue());\n        }\n        \n        String nillable = DOMUtils.getAttributeValueEmptyNull(parameter, \"nillable\");\n        if (nillable != null) {\n            info.setNillable(Boolean.valueOf(nillable.toLowerCase()).booleanValue());\n        }\n    }","id":75376,"modified_method":"protected void readMetadata(TypeClassInfo info, Element mapping, Element parameter) {\n        info.setTypeName(createQName(parameter, DOMUtils.getAttributeValueEmptyNull(parameter, \"typeName\")));\n        info.setMappedName(createQName(parameter, \n                                       DOMUtils.getAttributeValueEmptyNull(parameter, \"mappedName\")));\n        Class<?> relatedClass = TypeUtil.getTypeRelatedClass(info.getType());\n        // we only mess with the generic issues for list and map\n        if (Collection.class.isAssignableFrom(relatedClass)) {\n            Type componentType = getComponentType(mapping, parameter);\n            if (componentType != null) { // there is actually XML config.\n                Type fullType = ParameterizedTypeFactory.createParameterizedType(relatedClass,\n                                                                                 new Type[] {componentType});\n                info.setType(fullType);\n            }\n        } else if (Map.class.isAssignableFrom(relatedClass)) {\n            Type keyType = getKeyType(mapping, parameter);\n            if (keyType != null) {\n                info.setKeyType(keyType);\n            }\n            Type valueType = getValueType(mapping, parameter);\n            if (valueType != null) {\n                info.setValueType(valueType);\n            }\n            // if the XML only specifies one, we expect the other to come from a full\n            // parameterized type.\n            if (keyType != null || valueType != null) {\n                if (keyType == null || valueType == null) {\n                    if (keyType == null) {\n                        keyType = TypeUtil.getSingleTypeParameter(info.getType(), 0);\n                    }\n                    if (keyType == null) {\n                        keyType = Object.class;\n                    }\n                    if (valueType == null) {\n                        valueType = TypeUtil.getSingleTypeParameter(info.getType(), 1);\n                    }\n                    if (valueType == null) {\n                        valueType = Object.class;\n                    }\n                }\n                Type fullType \n                    = ParameterizedTypeFactory.createParameterizedType(relatedClass,\n                                                                       new Type[] {keyType, valueType});\n                info.setType(fullType);\n                \n            }\n            \n\n        }\n        setType(info, parameter);\n\n        String min = DOMUtils.getAttributeValueEmptyNull(parameter, \"minOccurs\");\n        if (min != null) {\n            info.setMinOccurs(Long.parseLong(min));\n        }\n\n        String max = DOMUtils.getAttributeValueEmptyNull(parameter, \"maxOccurs\");\n        if (max != null) {\n            info.setMaxOccurs(Long.parseLong(max));\n        }\n\n        String flat = DOMUtils.getAttributeValueEmptyNull(parameter, \"flat\");\n        if (flat != null) {\n            info.setFlat(Boolean.valueOf(flat.toLowerCase()).booleanValue());\n        }\n        \n        String nillable = DOMUtils.getAttributeValueEmptyNull(parameter, \"nillable\");\n        if (nillable != null) {\n            info.setNillable(Boolean.valueOf(nillable.toLowerCase()).booleanValue());\n        }\n    }","commit_id":"ca316e688eee17ce4e4c7d218bfda3eb770c8f66","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testPutAndGetWithModel() throws Exception {\n        if (systemReady) {\n            ProducerTemplate template = context.createProducerTemplate();\n            Endpoint startEndpoint = context.getEndpoint(\"direct:start\");\n            Endpoint startWithModelEndpoint = context.getEndpoint(\"direct:start-with-model\");\n            Exchange putExchange = startEndpoint.createExchange(ExchangePattern.InOut);\n\n            int index = 1;\n            for (int row = 0; row < key.length; row++) {\n                for (int fam = 0; fam < family.length; fam++) {\n                    for (int col = 0; col < column[fam].length; col++) {\n                        putExchange.getIn().setHeader(HbaseAttribute.HBASE_ROW_ID.asHeader(index), key[row]);\n                        putExchange.getIn().setHeader(HbaseAttribute.HBASE_FAMILY.asHeader(index), family[fam]);\n                        putExchange.getIn().setHeader(HbaseAttribute.HBASE_QUALIFIER.asHeader(index), column[fam][col]);\n                        putExchange.getIn().setHeader(HbaseAttribute.HBASE_VALUE.asHeader(index++), body[row][fam][col]);\n                    }\n                }\n            }\n            putExchange.getIn().setHeader(HBaseConstants.OPERATION, HBaseConstants.PUT);\n            template.send(startEndpoint, putExchange);\n\n            Exchange getExchange = startWithModelEndpoint.createExchange(ExchangePattern.InOut);\n            getExchange.getIn().setHeader(HbaseAttribute.HBASE_ROW_ID.asHeader(), key[0]);\n            getExchange.getIn().setHeader(HbaseAttribute.HBASE_FAMILY.asHeader(), family[0]);\n            getExchange.getIn().setHeader(HbaseAttribute.HBASE_QUALIFIER.asHeader(), column[0][0]);\n            getExchange.getIn().setHeader(HBaseConstants.OPERATION, HBaseConstants.GET);\n            Exchange resp = template.send(startWithModelEndpoint, getExchange);\n\n            assertEquals(body[0][0][0], resp.getOut().getHeader(HbaseAttribute.HBASE_VALUE.asHeader()));\n            assertEquals(body[0][1][2], resp.getOut().getHeader(HbaseAttribute.HBASE_VALUE.asHeader(2)));\n        }\n    }","id":75377,"modified_method":"@Test\n    public void testPutAndGetWithModel() throws Exception {\n        if (systemReady) {\n            ProducerTemplate template = context.createProducerTemplate();\n            Endpoint startEndpoint = context.getEndpoint(\"direct:start\");\n            Endpoint startWithModelEndpoint = context.getEndpoint(\"direct:start-with-model\");\n            Exchange putExchange = startEndpoint.createExchange(ExchangePattern.InOut);\n\n            int index = 1;\n            for (int row = 0; row < key.length; row++) {\n                for (int fam = 0; fam < family.length; fam++) {\n                    for (int col = 0; col < column[fam].length; col++) {\n                        putExchange.getIn().setHeader(HbaseAttribute.HBASE_ROW_ID.asHeader(index), key[row]);\n                        putExchange.getIn().setHeader(HbaseAttribute.HBASE_FAMILY.asHeader(index), family[fam]);\n                        putExchange.getIn().setHeader(HbaseAttribute.HBASE_QUALIFIER.asHeader(index), column[fam][col]);\n                        putExchange.getIn().setHeader(HbaseAttribute.HBASE_VALUE.asHeader(index++), body[row][fam][col]);\n                    }\n                }\n            }\n            putExchange.getIn().setHeader(HBaseConstants.OPERATION, HBaseConstants.PUT);\n            template.send(startEndpoint, putExchange);\n\n            Exchange getExchange = startWithModelEndpoint.createExchange(ExchangePattern.InOut);\n            getExchange.getIn().setHeader(HbaseAttribute.HBASE_ROW_ID.asHeader(), key[0]);\n            getExchange.getIn().setHeader(HBaseConstants.OPERATION, HBaseConstants.GET);\n            Exchange resp = template.send(startWithModelEndpoint, getExchange);\n\n            assertEquals(body[0][0][0], resp.getOut().getHeader(HbaseAttribute.HBASE_VALUE.asHeader()));\n            assertEquals(body[0][1][2], resp.getOut().getHeader(HbaseAttribute.HBASE_VALUE.asHeader(2)));\n        }\n    }","commit_id":"91f554f327fc8ed675c522b5f622e6e023415747","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Resolves the cell that the {@link Exchange} refers to.\n     */\n    private HBaseRow resolveRow(Message message, int index) {\n        HBaseRow hRow = new HBaseRow();\n        HBaseCell hCell = new HBaseCell();\n\n        if (message != null) {\n            Object id =  message.getHeader(HbaseAttribute.HBASE_ROW_ID.asHeader(index));\n            String rowClassName = message.getHeader(HbaseAttribute.HBASE_ROW_TYPE.asHeader(index), String.class);\n            Class<?> rowClass = rowClassName == null || rowClassName.isEmpty() ? String.class : message.getExchange().getContext().getClassResolver().resolveClass(rowClassName);\n            String columnFamily = (String) message.getHeader(HbaseAttribute.HBASE_FAMILY.asHeader(index));\n            String columnName = (String) message.getHeader(HbaseAttribute.HBASE_QUALIFIER.asHeader(index));\n            Object value =  message.getHeader(HbaseAttribute.HBASE_VALUE.asHeader(index));\n\n            String valueClassName = message.getHeader(HbaseAttribute.HBASE_VALUE_TYPE.asHeader(index), String.class);\n            Class<?> valueClass = valueClassName == null || valueClassName.isEmpty() ? String.class : message.getExchange().getContext().getClassResolver().resolveClass(valueClassName);\n\n            //Id can be accepted as null when using get, scan etc.\n            if (id == null && columnFamily == null && columnName == null) {\n                return null;\n            }\n\n            hRow.setId(id);\n            hRow.setRowType(rowClass);\n            hCell.setQualifier(columnName);\n            hCell.setFamily(columnFamily);\n            hCell.setValue(value);\n            // String is the default value type\n            hCell.setValueType((valueClass != null) ? valueClass : String.class);\n            hRow.getCells().add(hCell);\n        }\n        return hRow;\n    }","id":75378,"modified_method":"/**\n     * Resolves the cell that the {@link Exchange} refers to.\n     */\n    private HBaseRow resolveRow(Message message, int index) {\n        HBaseRow hRow = new HBaseRow();\n        HBaseCell hCell = new HBaseCell();\n\n        if (message != null) {\n            Object id =  message.getHeader(HbaseAttribute.HBASE_ROW_ID.asHeader(index));\n            String rowClassName = message.getHeader(HbaseAttribute.HBASE_ROW_TYPE.asHeader(index), String.class);\n            Class<?> rowClass = rowClassName == null || rowClassName.isEmpty() ? String.class : message.getExchange().getContext().getClassResolver().resolveClass(rowClassName);\n            String columnFamily = (String) message.getHeader(HbaseAttribute.HBASE_FAMILY.asHeader(index));\n            String columnName = (String) message.getHeader(HbaseAttribute.HBASE_QUALIFIER.asHeader(index));\n            Object value =  message.getHeader(HbaseAttribute.HBASE_VALUE.asHeader(index));\n\n            String valueClassName = message.getHeader(HbaseAttribute.HBASE_VALUE_TYPE.asHeader(index), String.class);\n            Class<?> valueClass = valueClassName == null || valueClassName.isEmpty() ? String.class : message.getExchange().getContext().getClassResolver().resolveClass(valueClassName);\n\n            //Id can be accepted as null when using get, scan etc.\n            if (id == null && columnFamily == null && columnName == null) {\n                return null;\n            }\n\n            hRow.setId(id);\n            hRow.setRowType(rowClass);\n            if (columnFamily != null && columnName != null) {\n                hCell.setQualifier(columnName);\n                hCell.setFamily(columnFamily);\n                hCell.setValue(value);\n                // String is the default value type\n                hCell.setValueType((valueClass != null) ? valueClass : String.class);\n                hRow.getCells().add(hCell);\n            }\n        }\n        return hRow;\n    }","commit_id":"91f554f327fc8ed675c522b5f622e6e023415747","url":"https://github.com/apache/camel"},{"original_method":"/**\n     *\n     * @param exprNode\n     * @param attrs\n     * @return\n     */\n    private static AbstractExpression parseValueExpression(HashMap<Long, Integer> paramsById, VoltXMLElement exprNode) {\n        String type = exprNode.attributes.get(\"type\");\n        String isParam = exprNode.attributes.get(\"isparam\");\n\n        VoltType vt = VoltType.typeFromString(type);\n        int size = VoltType.MAX_VALUE_LENGTH;\n        assert(vt != VoltType.VOLTTABLE);\n\n        if ((vt != VoltType.STRING) && (vt != VoltType.VARBINARY)) {\n            if (vt == VoltType.NULL) size = 0;\n            else size = vt.getLengthInBytesForFixedTypes();\n        }\n        if ((isParam != null) && (isParam.equalsIgnoreCase(\"true\"))) {\n            ParameterValueExpression expr = new ParameterValueExpression();\n            long id = Long.parseLong(exprNode.attributes.get(\"id\"));\n            int paramIndex = paramIndexById(paramsById, id);\n\n            expr.setValueType(vt);\n            expr.setValueSize(size);\n            expr.setParameterIndex(paramIndex);\n\n            return expr;\n        }\n        else {\n            ConstantValueExpression expr = new ConstantValueExpression();\n            expr.setValueType(vt);\n            expr.setValueSize(size);\n            if (vt == VoltType.NULL)\n                expr.setValue(null);\n            else\n                expr.setValue(exprNode.attributes.get(\"value\"));\n            return expr;\n        }\n    }","id":75379,"modified_method":"/**\n     *\n     * @param exprNode\n     * @param attrs\n     * @return\n     */\n    private static AbstractExpression parseValueExpression(HashMap<Long, Integer> paramsById, VoltXMLElement exprNode) {\n        String type = exprNode.attributes.get(\"type\");\n        String isParam = exprNode.attributes.get(\"isparam\");\n        String isPlannerGenerated = exprNode.attributes.get(\"isplannergenerated\");\n\n        VoltType vt = VoltType.typeFromString(type);\n        int size = VoltType.MAX_VALUE_LENGTH;\n        assert(vt != VoltType.VOLTTABLE);\n\n        if ((vt != VoltType.STRING) && (vt != VoltType.VARBINARY)) {\n            if (vt == VoltType.NULL) size = 0;\n            else size = vt.getLengthInBytesForFixedTypes();\n        }\n        // A ParameterValueExpression is needed to represent any user-provided or planner-injected parameter.\n        boolean needParameter = (isParam != null) && (isParam.equalsIgnoreCase(\"true\"));\n\n        // A ConstantValueExpression is needed to represent a constant in the statement,\n        // EVEN if that constant has been \"parameterized\" by the plan caching code.\n        ConstantValueExpression cve = null;\n        boolean needConstant = (needParameter == false) ||\n            ((isPlannerGenerated != null) && (isPlannerGenerated.equalsIgnoreCase(\"true\")));\n\n        if (needConstant) {\n            cve = new ConstantValueExpression();\n            cve.setValueType(vt);\n            cve.setValueSize(size);\n            String valueStr = null;\n            if (vt != VoltType.NULL) {\n                valueStr = exprNode.attributes.get(\"value\");\n            }\n              cve.setValue(valueStr);\n        }\n        if (needParameter) {\n            ParameterValueExpression expr = new ParameterValueExpression();\n            long id = Long.parseLong(exprNode.attributes.get(\"id\"));\n            int paramIndex = paramIndexById(paramsById, id);\n\n            expr.setValueType(vt);\n            expr.setValueSize(size);\n            expr.setParameterIndex(paramIndex);\n            if (needConstant) {\n                expr.setOriginalValue(cve);\n            }\n            return expr;\n        }\n        return cve;\n    }","commit_id":"928a428d3ce6bb6626c9a37d93fe141c31aa18c4","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public Object clone() throws CloneNotSupportedException {\n        ParameterValueExpression clone = (ParameterValueExpression)super.clone();\n        clone.m_paramIndex = m_paramIndex;\n        return clone;\n    }","id":75380,"modified_method":"@Override\n    public Object clone() throws CloneNotSupportedException {\n        ParameterValueExpression clone = (ParameterValueExpression)super.clone();\n        clone.m_paramIndex = m_paramIndex;\n        clone.m_originalValue = m_originalValue;\n        return clone;\n    }","commit_id":"928a428d3ce6bb6626c9a37d93fe141c31aa18c4","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public static ParameterizationInfo parameterize(VoltXMLElement xmlSQL) {\n        assert(xmlSQL != null);\n\n        VoltXMLElement parameterizedXmlSQL = xmlSQL.duplicate();\n\n        // find the parameters xml node\n        VoltXMLElement paramsNode = null;\n        for (VoltXMLElement child : parameterizedXmlSQL.children) {\n            if (child.name.equals(\"parameters\")) {\n                paramsNode = child;\n            }\n        }\n        assert(paramsNode != null);\n\n        // don't optimize plans with params yet\n        if (paramsNode.children.size() > 0) {\n            return null;\n        }\n\n        Map<Long, Integer> idToParamIndexMap = new HashMap<Long, Integer>();\n        List<String> paramValues = new ArrayList<String>();\n\n        parameterizeRecursively(parameterizedXmlSQL, paramsNode,\n                idToParamIndexMap, paramValues);\n\n        ParameterizationInfo info = new ParameterizationInfo(\n                xmlSQL, parameterizedXmlSQL,\n                paramValues.toArray(new String[paramValues.size()]));\n\n        return info;\n    }","id":75381,"modified_method":"public static ParameterizationInfo parameterize(VoltXMLElement xmlSQL) {\n        assert(xmlSQL != null);\n\n        VoltXMLElement parameterizedXmlSQL = xmlSQL.duplicate();\n\n        // find the parameters xml node\n        VoltXMLElement paramsNode = null;\n        for (VoltXMLElement child : parameterizedXmlSQL.children) {\n            if (child.name.equals(\"parameters\")) {\n                paramsNode = child;\n            }\n        }\n        assert(paramsNode != null);\n\n        // don't optimize plans with params yet\n        if (paramsNode.children.size() > 0) {\n            return null;\n        }\n\n        Map<String, Integer> idToParamIndexMap = new HashMap<String, Integer>();\n        List<String> paramValues = new ArrayList<String>();\n\n        parameterizeRecursively(parameterizedXmlSQL, paramsNode,\n                idToParamIndexMap, paramValues);\n\n        ParameterizationInfo info = new ParameterizationInfo(\n                xmlSQL, parameterizedXmlSQL,\n                paramValues.toArray(new String[paramValues.size()]));\n\n        return info;\n    }","commit_id":"928a428d3ce6bb6626c9a37d93fe141c31aa18c4","url":"https://github.com/VoltDB/voltdb"},{"original_method":"static void parameterizeRecursively(VoltXMLElement node,\n                                        VoltXMLElement paramsNode,\n                                        Map<Long, Integer> idToParamIndexMap,\n                                        List<String> paramValues) {\n        if (node.name.equals(\"value\")) {\n            String idStr = node.attributes.get(\"id\");\n            assert(idStr != null);\n            long id = Long.parseLong(idStr);\n\n            String typeStr = node.attributes.get(\"type\");\n            VoltType type = VoltType.typeFromString(typeStr);\n\n            Integer paramIndex = idToParamIndexMap.get(id);\n            if (paramIndex == null) {\n                paramIndex = paramValues.size();\n\n                VoltXMLElement paramIndexNode = new VoltXMLElement(\"parameter\");\n                paramIndexNode.attributes.put(\"index\", String.valueOf(paramIndex));\n                paramIndexNode.attributes.put(\"type\", typeStr);\n                paramIndexNode.attributes.put(\"id\", idStr);\n                paramsNode.children.add(paramIndexNode);\n\n                idToParamIndexMap.put(id, paramIndex);\n\n                String value = node.attributes.get(\"value\");\n                if (type == VoltType.NULL) {\n                    value = null;\n                }\n\n                paramValues.add(value);\n            }\n\n            node.attributes.put(\"isparam\", \"true\");\n            node.attributes.remove(\"value\");\n        }\n\n        for (VoltXMLElement child : node.children) {\n            parameterizeRecursively(child, paramsNode, idToParamIndexMap, paramValues);\n        }\n    }","id":75382,"modified_method":"static void parameterizeRecursively(VoltXMLElement node,\n                                        VoltXMLElement paramsNode,\n                                        Map<String, Integer> idToParamIndexMap,\n                                        List<String> paramValues) {\n        if (node.name.equals(\"value\")) {\n            String idStr = node.attributes.get(\"id\");\n            assert(idStr != null);\n\n            // A value id is currently a \"string-formatted long\", but there's no need to commit\n            // to that format in this early processing -- here, the id just needs to be a unique\n            // string for each parsed value. It allows hsql to replicate a parameter reference\n            // within its parse trees without causing code like this to lose track of its identity.\n            Integer paramIndex = idToParamIndexMap.get(idStr);\n            if (paramIndex == null) {\n                // Use the next param index for each new value with an unfamiliar id,\n                // starting at 0.\n                paramIndex = paramValues.size();\n                // Later references to this value's id will re-use this same param index.\n                idToParamIndexMap.put(idStr, paramIndex);\n\n                VoltXMLElement paramIndexNode = new VoltXMLElement(\"parameter\");\n                paramIndexNode.attributes.put(\"index\", String.valueOf(paramIndex));\n                String typeStr = node.attributes.get(\"type\");\n                paramIndexNode.attributes.put(\"type\", typeStr);\n                paramIndexNode.attributes.put(\"id\", idStr);\n                paramsNode.children.add(paramIndexNode);\n\n                String value = null;\n                if (VoltType.typeFromString(typeStr) != VoltType.NULL) {\n                    value = node.attributes.get(\"value\");\n                }\n                paramValues.add(value);\n            }\n\n            // Assume that all values, whether or not their ids have been seen before, can\n            // be considered planner-generated parameters (proxies for user-provided constants).\n            // This is one simplification that leverages the fact that statements that came with\n            // user-provided parameters were barred from being (further) parameterized.\n            node.attributes.put(\"isparam\", \"true\");\n            node.attributes.put(\"isplannergenerated\", \"true\");\n        }\n\n        for (VoltXMLElement child : node.children) {\n            parameterizeRecursively(child, paramsNode, idToParamIndexMap, paramValues);\n        }\n    }","commit_id":"928a428d3ce6bb6626c9a37d93fe141c31aa18c4","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Get system file descriptor from FileDescriptor object.\n     * @param descriptor - FileDescriptor objec to get fd from\n     * @return file descriptor, -1 or error\n     */\n    public static int getfd(FileDescriptor descriptor)\n    {\n        Field field = FBUtilities.getProtectedField(descriptor.getClass(), \"fd\");\n\n        if (field == null)\n            return -1;\n\n        try\n        {\n            return field.getInt(descriptor);\n        }\n        catch (Exception e)\n        {\n            JVMStabilityInspector.inspectThrowable(e);\n            logger.warn(\"unable to read fd field from FileDescriptor\");\n        }\n\n        return -1;\n    }","id":75383,"modified_method":"/**\n     * Get system file descriptor from FileDescriptor object.\n     * @param descriptor - FileDescriptor objec to get fd from\n     * @return file descriptor, -1 or error\n     */\n    public static int getfd(FileDescriptor descriptor)\n    {\n        Field field = FBUtilities.getProtectedField(descriptor.getClass(), \"fd\");\n\n        if (field == null)\n            return -1;\n\n        try\n        {\n            return field.getInt(descriptor);\n        }\n        catch (Exception e)\n        {\n            JVMStabilityInspector.inspectThrowable(e);\n            logger.warn(\"Unable to read fd field from FileDescriptor\");\n        }\n\n        return -1;\n    }","commit_id":"2b4029a763173af31633274844a4a3de1f73fa99","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Constructs a new segment file.\n     *\n     * @param filePath  if not null, recycles the existing file by renaming it and truncating it to CommitLog.SEGMENT_SIZE.\n     */\n    CommitLogSegment(String filePath)\n    {\n        id = getNextId();\n        descriptor = new CommitLogDescriptor(id);\n        logFile = new File(DatabaseDescriptor.getCommitLogLocation(), descriptor.fileName());\n        boolean isCreating = true;\n\n        try\n        {\n            if (filePath != null)\n            {\n                File oldFile = new File(filePath);\n\n                if (oldFile.exists())\n                {\n                    logger.debug(\"Re-using discarded CommitLog segment for {} from {}\", id, filePath);\n                    if (!oldFile.renameTo(logFile))\n                        throw new IOException(\"Rename from \" + filePath + \" to \" + id + \" failed\");\n                    isCreating = false;\n                }\n            }\n\n            // Open the initial the segment file\n            logFileAccessor = new RandomAccessFile(logFile, \"rw\");\n\n            if (isCreating)\n                logger.debug(\"Creating new commit log segment {}\", logFile.getPath());\n\n            // Map the segment, extending or truncating it to the standard segment size.\n            // (We may have restarted after a segment size configuration change, leaving \"incorrectly\"\n            // sized segments on disk.)\n            logFileAccessor.setLength(DatabaseDescriptor.getCommitLogSegmentSize());\n            fd = CLibrary.getfd(logFileAccessor.getFD());\n\n            buffer = logFileAccessor.getChannel().map(FileChannel.MapMode.READ_WRITE, 0, DatabaseDescriptor.getCommitLogSegmentSize());\n            // write the header\n            CommitLogDescriptor.writeHeader(buffer, descriptor);\n            // mark the initial sync marker as uninitialised\n            buffer.putInt(CommitLogDescriptor.HEADER_SIZE, 0);\n            buffer.putLong(CommitLogDescriptor.HEADER_SIZE + 4, 0);\n            allocatePosition.set(CommitLogDescriptor.HEADER_SIZE + SYNC_MARKER_SIZE);\n            lastSyncedOffset = CommitLogDescriptor.HEADER_SIZE;\n        }\n        catch (IOException e)\n        {\n            throw new FSWriteError(e, logFile);\n        }\n    }","id":75384,"modified_method":"/**\n     * Constructs a new segment file.\n     *\n     * @param filePath  if not null, recycles the existing file by renaming it and truncating it to CommitLog.SEGMENT_SIZE.\n     */\n    CommitLogSegment(String filePath)\n    {\n        id = getNextId();\n        descriptor = new CommitLogDescriptor(id);\n        logFile = new File(DatabaseDescriptor.getCommitLogLocation(), descriptor.fileName());\n\n        try\n        {\n            if (filePath != null)\n            {\n                File oldFile = new File(filePath);\n\n                if (oldFile.exists())\n                {\n                    logger.debug(\"Re-using discarded CommitLog segment for {} from {}\", id, filePath);\n                    if (!oldFile.renameTo(logFile))\n                        throw new IOException(\"Rename from \" + filePath + \" to \" + id + \" failed\");\n                }\n                else\n                {\n                    logger.debug(\"Creating new CommitLog segment: \" + logFile);\n                }\n            }\n\n            // Extend or truncate the file size to the standard segment size as we may have restarted after a segment\n            // size configuration change, leaving \"incorrectly\" sized segments on disk.\n            // NOTE: while we're using RAF to allow extension of file on disk w/out sparse, we need to avoid using RAF\n            // for grabbing the FileChannel due to FILE_SHARE_DELETE flag bug on windows.\n            // See: https://bugs.openjdk.java.net/browse/JDK-6357433 and CASSANDRA-8308\n            if (logFile.length() != DatabaseDescriptor.getCommitLogSegmentSize())\n            {\n                try (RandomAccessFile raf = new RandomAccessFile(logFile, \"rw\"))\n                {\n                    raf.setLength(DatabaseDescriptor.getCommitLogSegmentSize());\n                }\n                catch (IOException e)\n                {\n                    throw new FSWriteError(e, logFile);\n                }\n            }\n\n            channel = FileChannel.open(logFile.toPath(), StandardOpenOption.WRITE, StandardOpenOption.READ);\n\n            fd = CLibrary.getfd(channel);\n            buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, DatabaseDescriptor.getCommitLogSegmentSize());\n\n            CommitLogDescriptor.writeHeader(buffer, descriptor);\n\n            // mark the initial sync marker as uninitialised\n            buffer.putInt(CommitLogDescriptor.HEADER_SIZE, 0);\n            buffer.putLong(CommitLogDescriptor.HEADER_SIZE + 4, 0);\n            allocatePosition.set(CommitLogDescriptor.HEADER_SIZE + SYNC_MARKER_SIZE);\n            lastSyncedOffset = CommitLogDescriptor.HEADER_SIZE;\n        }\n        catch (IOException e)\n        {\n            throw new FSWriteError(e, logFile);\n        }\n    }","commit_id":"2b4029a763173af31633274844a4a3de1f73fa99","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Close the segment file.\n     */\n    void close()\n    {\n        try\n        {\n            if (FileUtils.isCleanerAvailable())\n                FileUtils.clean(buffer);\n            logFileAccessor.close();\n        }\n        catch (IOException e)\n        {\n            throw new FSWriteError(e, getPath());\n        }\n    }","id":75385,"modified_method":"/**\n     * Close the segment file.\n     */\n    void close()\n    {\n        try\n        {\n            if (FileUtils.isCleanerAvailable())\n                FileUtils.clean(buffer);\n            channel.close();\n        }\n        catch (IOException e)\n        {\n            throw new FSWriteError(e, getPath());\n        }\n    }","commit_id":"2b4029a763173af31633274844a4a3de1f73fa99","url":"https://github.com/apache/cassandra"},{"original_method":"public static void cleanupAndLeaveDirs()\n    {\n        mkdirs();\n        cleanup();\n        mkdirs();\n        CommitLog.instance.resetUnsafe(); // cleanup screws w/ CommitLog, this brings it back to safe state\n    }","id":75386,"modified_method":"public static void cleanupAndLeaveDirs()\n    {\n        CommitLog.instance.resetUnsafe(); // unmap CLS before attempting to delete or Windows complains\n        mkdirs();\n        cleanup();\n        mkdirs();\n        CommitLog.instance.resetUnsafe(); // cleanup screws w/ CommitLog, this brings it back to safe state\n    }","commit_id":"2b4029a763173af31633274844a4a3de1f73fa99","url":"https://github.com/apache/cassandra"},{"original_method":"public static void cleanup()\n    {\n        // clean up commitlog\n        String[] directoryNames = { DatabaseDescriptor.getCommitLogLocation(), };\n        for (String dirName : directoryNames)\n        {\n            File dir = new File(dirName);\n            if (!dir.exists())\n                throw new RuntimeException(\"No such directory: \" + dir.getAbsolutePath());\n            FileUtils.deleteRecursive(dir);\n        }\n\n        cleanupSavedCaches();\n\n        // clean up data directory which are stored as data directory/keyspace/data files\n        for (String dirName : DatabaseDescriptor.getAllDataFileLocations())\n        {\n            File dir = new File(dirName);\n            if (!dir.exists())\n                throw new RuntimeException(\"No such directory: \" + dir.getAbsolutePath());\n            FileUtils.deleteRecursive(dir);\n        }\n    }","id":75387,"modified_method":"public static void cleanup()\n    {\n        // clean up commitlog\n        String[] directoryNames = { DatabaseDescriptor.getCommitLogLocation(), };\n        for (String dirName : directoryNames)\n        {\n            File dir = new File(dirName);\n            if (!dir.exists())\n                throw new RuntimeException(\"No such directory: \" + dir.getAbsolutePath());\n\n            // Leave the folder around as Windows will complain about directory deletion w/handles open to children files\n            String[] children = dir.list();\n            for (String child : children)\n                FileUtils.deleteRecursive(new File(dir, child));\n        }\n\n        cleanupSavedCaches();\n\n        // clean up data directory which are stored as data directory/keyspace/data files\n        for (String dirName : DatabaseDescriptor.getAllDataFileLocations())\n        {\n            File dir = new File(dirName);\n            if (!dir.exists())\n                throw new RuntimeException(\"No such directory: \" + dir.getAbsolutePath());\n            String[] children = dir.list();\n            for (String child : children)\n                FileUtils.deleteRecursive(new File(dir, child));\n        }\n    }","commit_id":"2b4029a763173af31633274844a4a3de1f73fa99","url":"https://github.com/apache/cassandra"},{"original_method":"public LRUEntry putToMRU(String fileName, long filePosition, long dataPointer, boolean isDirty) {\n    long hashCode = hashCode(fileName, filePosition);\n    int index = index(hashCode);\n\n    LRUEntry lruEntry = entries[index];\n\n    LRUEntry prevEntry = null;\n    while (lruEntry != null\n        && (lruEntry.hashCode != hashCode || !lruEntry.fileName.equals(fileName) || lruEntry.filePosition != filePosition)) {\n      prevEntry = lruEntry;\n      lruEntry = lruEntry.next;\n    }\n\n    if (lruEntry == null) {\n      lruEntry = new LRUEntry();\n\n      lruEntry.filePosition = filePosition;\n      lruEntry.fileName = fileName;\n      lruEntry.hashCode = hashCode;\n\n      if (prevEntry == null)\n        entries[index] = lruEntry;\n      else\n        prevEntry.next = lruEntry;\n\n      size++;\n    }\n\n    lruEntry.dataPointer = dataPointer;\n    lruEntry.isDirty = isDirty;\n\n    LRUEntry before = lruEntry.before;\n    LRUEntry after = lruEntry.after;\n\n    if (before != null)\n      before.after = after;\n    if (after != null)\n      after.before = before;\n\n    if (head == null) {\n      head = lruEntry;\n      tail = lruEntry;\n    } else {\n      tail.after = lruEntry;\n      lruEntry.before = tail;\n      tail = lruEntry;\n    }\n\n    if (size >= nextThreshold)\n      rehash();\n\n    return lruEntry;\n  }","id":75388,"modified_method":"public LRUEntry putToMRU(String fileName, long filePosition, long dataPointer, boolean isDirty) {\n    long hashCode = hashCode(fileName, filePosition);\n    int index = index(hashCode);\n\n    LRUEntry lruEntry = entries[index];\n\n    LRUEntry prevEntry = null;\n    while (lruEntry != null\n        && (lruEntry.hashCode != hashCode || !lruEntry.fileName.equals(fileName) || lruEntry.pageIndex != filePosition)) {\n      prevEntry = lruEntry;\n      lruEntry = lruEntry.next;\n    }\n\n    if (lruEntry == null) {\n      lruEntry = new LRUEntry();\n\n      lruEntry.pageIndex = filePosition;\n      lruEntry.fileName = fileName;\n      lruEntry.hashCode = hashCode;\n\n      if (prevEntry == null)\n        entries[index] = lruEntry;\n      else\n        prevEntry.next = lruEntry;\n\n      size++;\n    }\n\n    lruEntry.dataPointer = dataPointer;\n    lruEntry.isDirty = isDirty;\n\n    LRUEntry before = lruEntry.before;\n    LRUEntry after = lruEntry.after;\n\n    if (before != null)\n      before.after = after;\n    if (after != null)\n      after.before = before;\n\n    if (head == null) {\n      head = lruEntry;\n      tail = lruEntry;\n    } else {\n      if (tail != lruEntry) {\n        tail.after = lruEntry;\n        lruEntry.before = tail;\n        tail = lruEntry;\n      }\n    }\n\n    if (size >= nextThreshold)\n      rehash();\n\n    return lruEntry;\n  }","commit_id":"09ef6021714336ebca32ecf094043932c24dae2f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public LRUEntry removeLRU() {\n    return remove(head.fileName, head.filePosition);\n  }","id":75389,"modified_method":"public LRUEntry removeLRU() {\n    return remove(head.fileName, head.pageIndex);\n  }","commit_id":"09ef6021714336ebca32ecf094043932c24dae2f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public LRUEntry get(String fileName, long filePosition) {\n    long hashCode = hashCode(fileName, filePosition);\n    int index = index(hashCode);\n\n    LRUEntry lruEntry = entries[index];\n\n    while (lruEntry != null\n        && (lruEntry.hashCode != hashCode || lruEntry.filePosition != filePosition || !lruEntry.fileName.equals(fileName)))\n      lruEntry = lruEntry.next;\n\n    return lruEntry;\n  }","id":75390,"modified_method":"public LRUEntry get(String fileName, long filePosition) {\n    long hashCode = hashCode(fileName, filePosition);\n    int index = index(hashCode);\n\n    LRUEntry lruEntry = entries[index];\n\n    while (lruEntry != null\n        && (lruEntry.hashCode != hashCode || lruEntry.pageIndex != filePosition || !lruEntry.fileName.equals(fileName)))\n      lruEntry = lruEntry.next;\n\n    return lruEntry;\n  }","commit_id":"09ef6021714336ebca32ecf094043932c24dae2f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public LRUEntry remove(String fileName, long filePosition) {\n    long hashCode = hashCode(fileName, filePosition);\n    int index = index(hashCode);\n\n    LRUEntry lruEntry = entries[index];\n\n    LRUEntry prevEntry = null;\n    while (lruEntry != null\n        && (lruEntry.hashCode != hashCode || !lruEntry.fileName.equals(fileName) || lruEntry.filePosition != filePosition)) {\n      prevEntry = lruEntry;\n      lruEntry = lruEntry.next;\n    }\n\n    if (lruEntry == null)\n      return null;\n\n    LRUEntry before = lruEntry.before;\n    LRUEntry after = lruEntry.after;\n\n    if (before != null)\n      before.after = after;\n    if (after != null)\n      after.before = before;\n\n    if (lruEntry == head)\n      head = lruEntry.after;\n    if (lruEntry == tail)\n      tail = lruEntry.before;\n\n    if (prevEntry == null)\n      entries[index] = lruEntry.next;\n    else\n      prevEntry.next = lruEntry.next;\n\n    size--;\n\n    return lruEntry;\n  }","id":75391,"modified_method":"public LRUEntry remove(String fileName, long filePosition) {\n    long hashCode = hashCode(fileName, filePosition);\n    int index = index(hashCode);\n\n    LRUEntry lruEntry = entries[index];\n\n    LRUEntry prevEntry = null;\n    while (lruEntry != null\n        && (lruEntry.hashCode != hashCode || !lruEntry.fileName.equals(fileName) || lruEntry.pageIndex != filePosition)) {\n      prevEntry = lruEntry;\n      lruEntry = lruEntry.next;\n    }\n\n    if (lruEntry == null)\n      return null;\n\n    LRUEntry before = lruEntry.before;\n    LRUEntry after = lruEntry.after;\n\n    if (before != null)\n      before.after = after;\n    if (after != null)\n      after.before = before;\n\n    if (lruEntry == head)\n      head = lruEntry.after;\n    if (lruEntry == tail)\n      tail = lruEntry.before;\n\n    if (prevEntry == null)\n      entries[index] = lruEntry.next;\n    else\n      prevEntry.next = lruEntry.next;\n\n    size--;\n\n    return lruEntry;\n  }","commit_id":"09ef6021714336ebca32ecf094043932c24dae2f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void assertLRUEntry(LRUEntry lruEntry, String fileName, long filePosition, long dataPointer) {\n    Assert.assertEquals(lruEntry.fileName, fileName);\n    Assert.assertEquals(lruEntry.filePosition, filePosition);\n    Assert.assertEquals(lruEntry.dataPointer, dataPointer);\n  }","id":75392,"modified_method":"private void assertLRUEntry(LRUEntry lruEntry, String fileName, long filePosition, long dataPointer) {\n    Assert.assertEquals(lruEntry.fileName, fileName);\n    Assert.assertEquals(lruEntry.pageIndex, filePosition);\n    Assert.assertEquals(lruEntry.dataPointer, dataPointer);\n  }","commit_id":"09ef6021714336ebca32ecf094043932c24dae2f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void openChannel(final int iNewSize) throws IOException {\r\n    OLogManager.instance().debug(this, \"[OFile.openChannel] opening channel for file '%s' of size: \", osFile, osFile.length());\r\n\r\n    for (int i = 0; i < OPEN_RETRY_MAX; ++i)\r\n      try {\r\n        accessFile = new RandomAccessFile(osFile, mode);\r\n        break;\r\n      } catch (FileNotFoundException e) {\r\n        if (i == OPEN_DELAY_RETRY)\r\n          throw e;\r\n\r\n        // TRY TO RE-CREATE THE DIRECTORY (THIS HAPPENS ON WINDOWS AFTER A DELETE IS PENDING, USUALLY WHEN REOPEN THE DB VERY\r\n        // FREQUENTLY)\r\n        osFile.getParentFile().mkdirs();\r\n        try {\r\n          Thread.sleep(OPEN_DELAY_RETRY);\r\n        } catch (InterruptedException e1) {\r\n          Thread.currentThread().interrupt();\r\n        }\r\n      }\r\n\r\n    if (accessFile == null)\r\n      throw new FileNotFoundException(osFile.getAbsolutePath());\r\n\r\n    accessFile.setLength(iNewSize);\r\n    accessFile.seek(0);\r\n    channel = accessFile.getChannel();\r\n\r\n    if (OGlobalConfiguration.FILE_LOCK.getValueAsBoolean())\r\n      lock();\r\n  }","id":75393,"modified_method":"protected void openChannel(final int iNewSize) throws IOException {\r\n    OLogManager.instance().debug(this, \"[OFile.openChannel] opening channel for file '%s' of size: \", osFile, osFile.length());\r\n\r\n    for (int i = 0; i < OPEN_RETRY_MAX; ++i)\r\n      try {\r\n        accessFile = new RandomAccessFile(osFile, mode);\r\n        break;\r\n      } catch (FileNotFoundException e) {\r\n        if (i == OPEN_DELAY_RETRY)\r\n          throw e;\r\n\r\n        // TRY TO RE-CREATE THE DIRECTORY (THIS HAPPENS ON WINDOWS AFTER A DELETE IS PENDING, USUALLY WHEN REOPEN THE DB VERY\r\n        // FREQUENTLY)\r\n        osFile.getParentFile().mkdirs();\r\n        try {\r\n          Thread.sleep(OPEN_DELAY_RETRY);\r\n        } catch (InterruptedException e1) {\r\n          Thread.currentThread().interrupt();\r\n        }\r\n      }\r\n\r\n    if (accessFile == null)\r\n      throw new FileNotFoundException(osFile.getAbsolutePath());\r\n\r\n    if (accessFile.length() != iNewSize)\r\n      accessFile.setLength(iNewSize);\r\n\r\n    accessFile.seek(0);\r\n    channel = accessFile.getChannel();\r\n\r\n    if (OGlobalConfiguration.FILE_LOCK.getValueAsBoolean())\r\n      lock();\r\n  }","commit_id":"09ef6021714336ebca32ecf094043932c24dae2f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  @NotNull\n  public byte[] contentsToByteArray(@NotNull final VirtualFile file, boolean cacheContent) throws IOException {\n    InputStream contentStream = null;\n    boolean reloadFromDelegate;\n    synchronized (myInputLock) {\n      reloadFromDelegate = mustReloadContent(file) || (contentStream = readContent(file)) == null;\n    }\n\n    if (reloadFromDelegate) {\n      final NewVirtualFileSystem delegate = getDelegate(file);\n      final byte[] content = delegate.contentsToByteArray(file);\n      FSRecords.setLength(getFileId(file), content.length);\n\n      ApplicationEx application = (ApplicationEx)ApplicationManager.getApplication();\n      // we should cache every local files content\n      // because the local history feature is currently depends on this cache,\n      // perforce offline mode as well\n      if ((!delegate.isReadOnly() ||\n           // do not cache archive content unless asked\n           (cacheContent && !application.isInternal() && !application.isUnitTestMode())) &&\n          content.length <= PersistentFSConstants.FILE_LENGTH_TO_CACHE_THRESHOLD) {\n        synchronized (myInputLock) {\n          writeContent(file, new ByteSequence(content), delegate.isReadOnly());\n          setFlag(file, MUST_RELOAD_CONTENT, false);\n        }\n      }\n\n      return content;\n    }\n    else {\n      try {\n        final int length = (int)file.getLength();\n        assert length >= 0 : file;\n        return FileUtil.loadBytes(contentStream, length);\n      }\n      catch (IOException e) {\n        throw FSRecords.handleError(e);\n      }\n    }\n  }","id":75394,"modified_method":"@Override\n  @NotNull\n  public byte[] contentsToByteArray(@NotNull final VirtualFile file, boolean cacheContent) throws IOException {\n    InputStream contentStream = null;\n    boolean reloadFromDelegate;\n    boolean outdated;\n    synchronized (myInputLock) {\n      outdated = checkFlag(file, MUST_RELOAD_CONTENT) || FSRecords.getLength(getFileId(file)) == -1L;\n      reloadFromDelegate = outdated || (contentStream = readContent(file)) == null;\n    }\n\n    if (reloadFromDelegate) {\n      final NewVirtualFileSystem delegate = getDelegate(file);\n\n      final byte[] content;\n      if (outdated) {\n        // in this case, file can have out-of-date length. so, update it first (it's needed for correct contentsToByteArray() work)\n        // see IDEA-90813 for possible bugs\n        FSRecords.setLength(getFileId(file), delegate.getLength(file));\n        content = delegate.contentsToByteArray(file);\n      }\n      else {\n        // a bit of optimization\n        content = delegate.contentsToByteArray(file);\n        FSRecords.setLength(getFileId(file), content.length);\n      }\n\n      ApplicationEx application = (ApplicationEx)ApplicationManager.getApplication();\n      // we should cache every local files content\n      // because the local history feature is currently depends on this cache,\n      // perforce offline mode as well\n      if ((!delegate.isReadOnly() ||\n           // do not cache archive content unless asked\n           (cacheContent && !application.isInternal() && !application.isUnitTestMode())) &&\n          content.length <= PersistentFSConstants.FILE_LENGTH_TO_CACHE_THRESHOLD) {\n        synchronized (myInputLock) {\n          writeContent(file, new ByteSequence(content), delegate.isReadOnly());\n          setFlag(file, MUST_RELOAD_CONTENT, false);\n        }\n      }\n\n      return content;\n    }\n    else {\n      try {\n        final int length = (int)file.getLength();\n        assert length >= 0 : file;\n        return FileUtil.loadBytes(contentStream, length);\n      }\n      catch (IOException e) {\n        throw FSRecords.handleError(e);\n      }\n    }\n  }","commit_id":"eefcd97535d4ab8517c5335a8e32b10a2fadd80e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String createLocatorsString() {\r\n\t\tLookupLocator[] locators = this.admin.getLocators();\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tfor (LookupLocator lookupLocator : locators) {\r\n\t\t\tsb.append(lookupLocator.getHost()).append(\":\").append(lookupLocator.getPort()).append(\",\");\r\n\t\t}\r\n\t\tsb.setLength(sb.length() - 1);\r\n\t\treturn sb.toString();\r\n\t}","id":75395,"modified_method":"private String createLocatorsString() {\r\n\t\tLookupLocator[] locators = this.admin.getLocators();\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tfor (LookupLocator lookupLocator : locators) {\r\n\t\t\tsb.append(lookupLocator.getHost()).append(\":\").append(lookupLocator.getPort()).append(\",\");\r\n\t\t}\r\n\t\tif (sb.toString().length() > 0){\r\n\t\t\tsb.setLength(sb.length() - 1);\r\n\t\t}\r\n\t\treturn sb.toString();\r\n\t}","commit_id":"44e5c6e514d6d77f072a75c940f3210d3f826926","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n     * @see org.opencms.db.I_CmsHistoryDriver#deleteEntries(CmsDbContext, I_CmsHistoryResource, int, long)\n     */\n    public int deleteEntries(CmsDbContext dbc, I_CmsHistoryResource resource, int versionsToKeep, long time)\n    throws CmsDataAccessException {\n\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        ResultSet res = null;\n\n        try {\n            conn = m_sqlManager.getConnection(dbc);\n\n            int maxVersion = -1;\n            // get the maximal version number for this resource\n            stmt = m_sqlManager.getPreparedStatement(conn, \"C_STRUCTURE_HISTORY_MAXVER\");\n            stmt.setString(1, resource.getStructureId().toString());\n            res = stmt.executeQuery();\n            if (res.next()) {\n                maxVersion = res.getInt(1);\n                while (res.next()) {\n                    // do nothing only move through all rows because of mssql odbc driver\n                }\n            } else {\n                // make sure the statement and the result is closed\n                m_sqlManager.closeAll(dbc, null, stmt, res);\n                // nothing to delete\n                internalCleanup(dbc, conn, resource);\n                return 0;\n            }\n            m_sqlManager.closeAll(dbc, null, stmt, res);\n\n            if (time >= 0) {\n                int maxVersionByTime = -1;\n                // get the maximal version to keep for this resource based on the time parameter\n                stmt = m_sqlManager.getPreparedStatement(conn, \"C_STRUCTURE_HISTORY_MAXVER_BYTIME\");\n                stmt.setString(1, resource.getStructureId().toString());\n                stmt.setLong(2, time);\n                res = stmt.executeQuery();\n                if (res.next()) {\n                    maxVersionByTime = res.getInt(1);\n                    while (res.next()) {\n                        // do nothing only move through all rows because of mssql odbc driver\n                    }\n                }\n                m_sqlManager.closeAll(dbc, null, stmt, res);\n                if (maxVersionByTime > 0) {\n                    if (versionsToKeep < 0) {\n                        versionsToKeep = (maxVersion - maxVersionByTime);\n                    } else {\n                        versionsToKeep = Math.min(versionsToKeep, (maxVersion - maxVersionByTime));\n                    }\n                }\n            }\n\n            if (maxVersion - versionsToKeep <= 0) {\n                // nothing to delete\n                internalCleanup(dbc, conn, resource);\n                return 0;\n            }\n\n            // get the minimal structure publish tag to keep for this sibling\n            int minStrPublishTagToKeep = -1;\n            stmt = m_sqlManager.getPreparedStatement(conn, \"C_HISTORY_READ_MAXTAG_FOR_VERSION\");\n            stmt.setString(1, resource.getStructureId().toString());\n            stmt.setInt(2, 1 + maxVersion - versionsToKeep);\n            res = stmt.executeQuery();\n            if (res.next()) {\n                minStrPublishTagToKeep = res.getInt(1);\n                while (res.next()) {\n                    // do nothing only move through all rows because of mssql odbc driver\n                }\n            } else {\n                // make sure the statement and the result is closed\n                m_sqlManager.closeAll(dbc, null, stmt, res);\n                // nothing to delete\n                internalCleanup(dbc, conn, resource);\n                return 0;\n            }\n            m_sqlManager.closeAll(dbc, null, stmt, res);\n            if (minStrPublishTagToKeep < 1) {\n                // nothing to delete\n                internalCleanup(dbc, conn, resource);\n                return 0;\n            }\n            minStrPublishTagToKeep++;\n\n            // delete the properties\n            stmt = m_sqlManager.getPreparedStatement(conn, \"C_PROPERTIES_HISTORY_DELETE\");\n            stmt.setString(1, resource.getStructureId().toString());\n            stmt.setInt(2, minStrPublishTagToKeep);\n            stmt.executeUpdate();\n            m_sqlManager.closeAll(dbc, null, stmt, null);\n\n            // delete the structure entries\n            stmt = m_sqlManager.getPreparedStatement(conn, \"C_STRUCTURE_HISTORY_DELETE\");\n            stmt.setString(1, resource.getStructureId().toString());\n            stmt.setInt(2, minStrPublishTagToKeep);\n            int structureVersions = stmt.executeUpdate();\n            m_sqlManager.closeAll(dbc, null, stmt, null);\n\n            // get the minimal resource publish tag to keep, \n            // all entries with publish tag less than this will be deleted\n            int minResPublishTagToKeep = -1;\n            stmt = m_sqlManager.getPreparedStatement(conn, \"C_HISTORY_READ_MIN_USED_TAG\");\n            stmt.setString(1, resource.getResourceId().toString());\n            res = stmt.executeQuery();\n            if (res.next()) {\n                minResPublishTagToKeep = res.getInt(1);\n                while (res.next()) {\n                    // do nothing only move through all rows because of mssql odbc driver\n                }\n            } else {\n                // make sure the statement and the result is closed\n                m_sqlManager.closeAll(dbc, null, stmt, res);\n                // nothing to delete\n                internalCleanup(dbc, conn, resource);\n                return structureVersions;\n            }\n            m_sqlManager.closeAll(dbc, null, stmt, res);\n\n            // delete the resource entries\n            stmt = m_sqlManager.getPreparedStatement(conn, \"C_RESOURCES_HISTORY_DELETE\");\n            stmt.setString(1, resource.getResourceId().toString());\n            stmt.setInt(2, minResPublishTagToKeep);\n            int resourceVersions = stmt.executeUpdate();\n            m_sqlManager.closeAll(dbc, null, stmt, null);\n\n            // delete the content entries\n            stmt = m_sqlManager.getPreparedStatement(conn, \"C_CONTENT_HISTORY_DELETE\");\n            stmt.setString(1, resource.getResourceId().toString());\n            stmt.setInt(2, minResPublishTagToKeep);\n            stmt.executeUpdate();\n\n            // make sure the statement and the result is closed\n            m_sqlManager.closeAll(dbc, null, stmt, res);\n            internalCleanup(dbc, conn, resource);\n            return Math.max(structureVersions, resourceVersions);\n        } catch (SQLException e) {\n            throw new CmsDbSqlException(Messages.get().container(\n                Messages.ERR_GENERIC_SQL_1,\n                CmsDbSqlException.getErrorQuery(stmt)), e);\n        } finally {\n            m_sqlManager.closeAll(dbc, conn, stmt, res);\n        }\n    }","id":75396,"modified_method":"/**\n     * @see org.opencms.db.I_CmsHistoryDriver#deleteEntries(CmsDbContext, I_CmsHistoryResource, int, long)\n     */\n    public int deleteEntries(CmsDbContext dbc, I_CmsHistoryResource resource, int versionsToKeep, long time)\n    throws CmsDataAccessException {\n\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        ResultSet res = null;\n\n        try {\n            conn = m_sqlManager.getConnection(dbc);\n\n            int maxVersion = -1;\n            // get the maximal version number for this resource\n            stmt = m_sqlManager.getPreparedStatement(conn, \"C_STRUCTURE_HISTORY_MAXVER\");\n            stmt.setString(1, resource.getStructureId().toString());\n            res = stmt.executeQuery();\n            if (res.next()) {\n                maxVersion = res.getInt(1);\n                while (res.next()) {\n                    // do nothing only move through all rows because of mssql odbc driver\n                }\n            } else {\n                // make sure the connection is closed\n                m_sqlManager.closeAll(dbc, conn, stmt, res);\n                // nothing to delete\n                internalCleanup(dbc, resource);\n                return 0;\n            }\n            m_sqlManager.closeAll(dbc, conn, stmt, res);\n\n            if (time >= 0) {\n                int maxVersionByTime = -1;\n                conn = m_sqlManager.getConnection(dbc);\n                // get the maximal version to keep for this resource based on the time parameter\n                stmt = m_sqlManager.getPreparedStatement(conn, \"C_STRUCTURE_HISTORY_MAXVER_BYTIME\");\n                stmt.setString(1, resource.getStructureId().toString());\n                stmt.setLong(2, time);\n                res = stmt.executeQuery();\n                if (res.next()) {\n                    maxVersionByTime = res.getInt(1);\n                    while (res.next()) {\n                        // do nothing only move through all rows because of mssql odbc driver\n                    }\n                }\n                m_sqlManager.closeAll(dbc, conn, stmt, res);\n                if (maxVersionByTime > 0) {\n                    if (versionsToKeep < 0) {\n                        versionsToKeep = (maxVersion - maxVersionByTime);\n                    } else {\n                        versionsToKeep = Math.min(versionsToKeep, (maxVersion - maxVersionByTime));\n                    }\n                }\n            }\n\n            if (maxVersion - versionsToKeep <= 0) {\n                // nothing to delete\n                internalCleanup(dbc, resource);\n                return 0;\n            }\n\n            // get the minimal structure publish tag to keep for this sibling\n            int minStrPublishTagToKeep = -1;\n            conn = m_sqlManager.getConnection(dbc);\n            stmt = m_sqlManager.getPreparedStatement(conn, \"C_HISTORY_READ_MAXTAG_FOR_VERSION\");\n            stmt.setString(1, resource.getStructureId().toString());\n            stmt.setInt(2, 1 + maxVersion - versionsToKeep);\n            res = stmt.executeQuery();\n            if (res.next()) {\n                minStrPublishTagToKeep = res.getInt(1);\n                while (res.next()) {\n                    // do nothing only move through all rows because of mssql odbc driver\n                }\n            } else {\n                // make sure the statement and the result is closed\n                m_sqlManager.closeAll(dbc, conn, stmt, res);\n                // nothing to delete\n                internalCleanup(dbc, resource);\n                return 0;\n            }\n            m_sqlManager.closeAll(dbc, conn, stmt, res);\n            if (minStrPublishTagToKeep < 1) {\n                // nothing to delete\n                internalCleanup(dbc, resource);\n                return 0;\n            }\n            minStrPublishTagToKeep++;\n\n            // delete the properties\n            conn = m_sqlManager.getConnection(dbc);\n            stmt = m_sqlManager.getPreparedStatement(conn, \"C_PROPERTIES_HISTORY_DELETE\");\n            stmt.setString(1, resource.getStructureId().toString());\n            stmt.setInt(2, minStrPublishTagToKeep);\n            stmt.executeUpdate();\n            m_sqlManager.closeAll(dbc, null, stmt, null);\n\n            // delete the structure entries\n            stmt = m_sqlManager.getPreparedStatement(conn, \"C_STRUCTURE_HISTORY_DELETE\");\n            stmt.setString(1, resource.getStructureId().toString());\n            stmt.setInt(2, minStrPublishTagToKeep);\n            int structureVersions = stmt.executeUpdate();\n            m_sqlManager.closeAll(dbc, null, stmt, null);\n\n            // get the minimal resource publish tag to keep, \n            // all entries with publish tag less than this will be deleted\n            int minResPublishTagToKeep = -1;\n            stmt = m_sqlManager.getPreparedStatement(conn, \"C_HISTORY_READ_MIN_USED_TAG\");\n            stmt.setString(1, resource.getResourceId().toString());\n            res = stmt.executeQuery();\n            if (res.next()) {\n                minResPublishTagToKeep = res.getInt(1);\n                while (res.next()) {\n                    // do nothing only move through all rows because of mssql odbc driver\n                }\n            } else {\n                // make sure the statement and the result is closed\n                m_sqlManager.closeAll(dbc, conn, stmt, res);\n                // nothing to delete\n                internalCleanup(dbc, resource);\n                return structureVersions;\n            }\n            m_sqlManager.closeAll(dbc, conn, stmt, res);\n\n            // delete the resource entries\n            conn = m_sqlManager.getConnection(dbc);\n            stmt = m_sqlManager.getPreparedStatement(conn, \"C_RESOURCES_HISTORY_DELETE\");\n            stmt.setString(1, resource.getResourceId().toString());\n            stmt.setInt(2, minResPublishTagToKeep);\n            int resourceVersions = stmt.executeUpdate();\n            m_sqlManager.closeAll(dbc, null, stmt, null);\n\n            // delete the content entries\n            stmt = m_sqlManager.getPreparedStatement(conn, \"C_CONTENT_HISTORY_DELETE\");\n            stmt.setString(1, resource.getResourceId().toString());\n            stmt.setInt(2, minResPublishTagToKeep);\n            stmt.executeUpdate();\n\n            // make sure the statement and the result is closed\n            m_sqlManager.closeAll(dbc, conn, stmt, res);\n            internalCleanup(dbc, resource);\n            return Math.max(structureVersions, resourceVersions);\n        } catch (SQLException e) {\n            throw new CmsDbSqlException(Messages.get().container(\n                Messages.ERR_GENERIC_SQL_1,\n                CmsDbSqlException.getErrorQuery(stmt)), e);\n        } finally {\n            m_sqlManager.closeAll(dbc, conn, stmt, res);\n        }\n    }","commit_id":"080f69f7446769e480385362e98b2e7d5421c7cd","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Deletes all historical entries of subresources of a folder without any historical entry left.<p>\n     * \n     * <b>Note: <\/b> This method is <code>private<\/code> because it DOES NOT close the connection. Please\n     * use this method with care.<p>\n     * \n     * @param dbc the current dbc\n     * @param conn the current connection\n     * @param resource the resource to check\n     * \n     * @throws SQLException if something goes wrong\n     * @throws CmsVfsResourceNotFoundException if one of the subresources could not be read\n     * @throws CmsDataAccessException if the deletion of a entry goes wrong\n     */\n    private void internalCleanup(CmsDbContext dbc, Connection conn, I_CmsHistoryResource resource)\n    throws SQLException, CmsVfsResourceNotFoundException, CmsDataAccessException {\n\n        PreparedStatement stmt = null;\n        ResultSet res = null;\n        Map<CmsUUID, Integer> tmpSubResources = new HashMap<CmsUUID, Integer>();\n\n        // if is folder and if no versions left\n        boolean isFolderAndNoVersionLeft = resource.getRootPath().endsWith(\"/\")\n            && (internalReadLastVersion(dbc, conn, resource.getStructureId()) == 0);\n\n        // if the resource is a folder\n        if (isFolderAndNoVersionLeft) {\n            // get all direct subresources                    \n            stmt = m_sqlManager.getPreparedStatement(conn, \"C_STRUCTURE_HISTORY_READ_SUBRESOURCES\");\n            stmt.setString(1, resource.getStructureId().toString());\n            res = stmt.executeQuery();\n            while (res.next()) {\n                CmsUUID structureId = new CmsUUID(res.getString(1));\n                int version = res.getInt(2);\n                tmpSubResources.put(structureId, Integer.valueOf(version));\n            }\n            m_sqlManager.closeAll(dbc, null, stmt, res);\n        }\n        // delete all subresource versions\n        for (Map.Entry<CmsUUID, Integer> entry : tmpSubResources.entrySet()) {\n            I_CmsHistoryResource histResource = internalReadResource(\n                dbc,\n                conn,\n                entry.getKey(),\n                entry.getValue().intValue());\n            internalDeleteEntries(dbc, conn, histResource, 0, -1);\n        }\n    }","id":75397,"modified_method":"/**\n     * Deletes all historical entries of subresources of a folder without any historical netry left.<p>\n     * \n     * @param dbc the current database context\n     * @param resource the resource to check\n     * \n     * @throws CmsDataAccessException if something goes wrong\n     */\n    protected void internalCleanup(CmsDbContext dbc, I_CmsHistoryResource resource) throws CmsDataAccessException {\n\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        ResultSet res = null;\n        Map<CmsUUID, Integer> tmpSubResources = new HashMap<CmsUUID, Integer>();\n\n        // if is folder and if no versions left\n        boolean isFolderAndNoVersionLeft = resource.getRootPath().endsWith(\"/\")\n            && (readLastVersion(dbc, resource.getStructureId()) == 0);\n\n        // if the resource is a folder\n        if (isFolderAndNoVersionLeft) {\n            try {\n                conn = m_sqlManager.getConnection(dbc);\n                // get all direct subresources                    \n                stmt = m_sqlManager.getPreparedStatement(conn, \"C_STRUCTURE_HISTORY_READ_SUBRESOURCES\");\n                stmt.setString(1, resource.getStructureId().toString());\n                res = stmt.executeQuery();\n                while (res.next()) {\n                    CmsUUID structureId = new CmsUUID(res.getString(1));\n                    int version = res.getInt(2);\n                    tmpSubResources.put(structureId, Integer.valueOf(version));\n                }\n            } catch (SQLException e) {\n                throw new CmsDbSqlException(Messages.get().container(\n                    Messages.ERR_GENERIC_SQL_1,\n                    CmsDbSqlException.getErrorQuery(stmt)), e);\n            } finally {\n                m_sqlManager.closeAll(dbc, conn, stmt, res);\n            }\n        }\n        // delete all subresource versions\n        for (Map.Entry<CmsUUID, Integer> entry : tmpSubResources.entrySet()) {\n            I_CmsHistoryResource histResource = readResource(dbc, entry.getKey(), entry.getValue().intValue());\n            deleteEntries(dbc, histResource, 0, -1);\n        }\n    }","commit_id":"080f69f7446769e480385362e98b2e7d5421c7cd","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public static List<GitCommit> history(final Project project, @NotNull VirtualFile root, String... parameters) throws VcsException {\n    final List<GitCommit> commits = new ArrayList<GitCommit>();\n    final Semaphore semaphore = new Semaphore();\n    semaphore.down();\n    historyWithLinks(project, new FilePathImpl(root), null, new AsynchConsumer<GitCommit>() {\n      @Override\n      public void finished() {\n        semaphore.up();\n      }\n\n      @Override\n      public void consume(GitCommit gitCommit) {\n        commits.add(gitCommit);\n      }\n    }, null, null, parameters);\n    semaphore.waitFor();\n    return commits;\n  }","id":75398,"modified_method":"public static List<GitCommit> history(final Project project, @NotNull VirtualFile root, String... parameters) throws VcsException {\n    final List<GitCommit> commits = new ArrayList<GitCommit>();\n    final Semaphore semaphore = new Semaphore();\n    semaphore.down();\n    historyWithLinks(project, new FilePathImpl(root), null, new AsynchConsumer<GitCommit>() {\n      @Override\n      public void finished() {\n        semaphore.up();\n      }\n\n      @Override\n      public void consume(GitCommit gitCommit) {\n        commits.add(gitCommit);\n      }\n    }, null, null, false, parameters);\n    semaphore.waitFor();\n    return commits;\n  }","commit_id":"33f185f69b1787ec57441c234089a69b99410bec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void historyWithLinks(final Project project,\n                                      FilePath path,\n                                      @Nullable final SymbolicRefsI refs,\n                                      @NotNull final AsynchConsumer<GitCommit> gitCommitConsumer,\n                                      @Nullable final Getter<Boolean> isCanceled,\n                                      @Nullable Collection<VirtualFile> paths, final String... parameters) throws VcsException {\n    // adjust path using change manager\n    path = getLastCommitName(project, path);\n    final VirtualFile root = GitUtil.getGitRoot(path);\n    final GitLineHandler h = new GitLineHandler(project, root, GitCommand.LOG);\n    final GitLogParser parser = new GitLogParser(project, GitLogParser.NameStatus.STATUS, SHORT_HASH, HASH, COMMIT_TIME, AUTHOR_NAME, AUTHOR_TIME, AUTHOR_EMAIL,\n                                                 COMMITTER_NAME, COMMITTER_EMAIL, SHORT_PARENTS, REF_NAMES, SUBJECT, BODY, RAW_BODY);\n    h.setNoSSH(true);\n    h.setStdoutSuppressed(true);\n    h.addParameters(parameters);\n    h.addParameters(\"--name-status\", parser.getPretty(), \"--encoding=UTF-8\", \"--full-history\");\n    if (paths != null && ! paths.isEmpty()) {\n      h.endOptions();\n      h.addRelativeFiles(paths);\n    } else {\n      h.addParameters(\"--sparse\");\n      h.endOptions();\n      h.addRelativePaths(path);\n    }\n\n    final VcsException[] exc = new VcsException[1];\n    final Semaphore semaphore = new Semaphore();\n    final StringBuilder sb = new StringBuilder();\n    final Ref<Boolean> skipFirst = new Ref<Boolean>(true);\n    h.addLineListener(new GitLineHandlerAdapter() {\n      @Override\n      public void onLineAvailable(final String line, final Key outputType) {\n        try {\n          if (ProcessOutputTypes.STDOUT.equals(outputType)) {\n            if (isCanceled != null && isCanceled.get()) {\n              h.cancel();\n              return;\n            }\n            //if (line.charAt(line.length() - 1) != '\\u0003') {\n            if ((! line.startsWith(\"\\u0001\")) || skipFirst.get()) {\n              if (sb.length() > 0) {\n                sb.append(\"\\n\");\n              }\n              sb.append(line);\n              skipFirst.set(false);\n              return;\n            }\n            takeLine(project, line, sb, parser, refs, root, exc, h, gitCommitConsumer);\n          }\n        } catch (ProcessCanceledException e) {\n          h.cancel();\n          semaphore.up();\n        }\n      }\n      @Override\n      public void processTerminated(int exitCode) {\n        semaphore.up();\n      }\n      @Override\n      public void startFailed(Throwable exception) {\n        semaphore.up();\n      }\n    });\n    semaphore.down();\n    h.start();\n    semaphore.waitFor();\n    takeLine(project, \"\", sb, parser, refs, root, exc, h, gitCommitConsumer);\n    gitCommitConsumer.finished();\n    if (exc[0] != null) {\n      throw exc[0];\n    }\n  }","id":75399,"modified_method":"public static void historyWithLinks(final Project project,\n                                      FilePath path,\n                                      @Nullable final SymbolicRefsI refs,\n                                      @NotNull final AsynchConsumer<GitCommit> gitCommitConsumer,\n                                      @Nullable final Getter<Boolean> isCanceled,\n                                      @Nullable Collection<VirtualFile> paths,\n                                      boolean fullHistory, final String... parameters) throws VcsException {\n    // adjust path using change manager\n    path = getLastCommitName(project, path);\n    final VirtualFile root = GitUtil.getGitRoot(path);\n    final GitLineHandler h = new GitLineHandler(project, root, GitCommand.LOG);\n    final GitLogParser parser = new GitLogParser(project, GitLogParser.NameStatus.STATUS, SHORT_HASH, HASH, COMMIT_TIME, AUTHOR_NAME, AUTHOR_TIME, AUTHOR_EMAIL,\n                                                 COMMITTER_NAME, COMMITTER_EMAIL, SHORT_PARENTS, REF_NAMES, SUBJECT, BODY, RAW_BODY);\n    h.setNoSSH(true);\n    h.setStdoutSuppressed(true);\n    h.addParameters(parameters);\n    h.addParameters(\"--name-status\", parser.getPretty(), \"--encoding=UTF-8\");\n    if (fullHistory) {\n      h.addParameters(\"--full-history\");\n    }\n    if (paths != null && ! paths.isEmpty()) {\n      h.endOptions();\n      h.addRelativeFiles(paths);\n    } else {\n      if (fullHistory) {\n        h.addParameters(\"--sparse\");\n      }\n      h.endOptions();\n      h.addRelativePaths(path);\n    }\n\n    final VcsException[] exc = new VcsException[1];\n    final Semaphore semaphore = new Semaphore();\n    final StringBuilder sb = new StringBuilder();\n    final Ref<Boolean> skipFirst = new Ref<Boolean>(true);\n    h.addLineListener(new GitLineHandlerAdapter() {\n      @Override\n      public void onLineAvailable(final String line, final Key outputType) {\n        try {\n          if (ProcessOutputTypes.STDOUT.equals(outputType)) {\n            if (isCanceled != null && isCanceled.get()) {\n              h.cancel();\n              return;\n            }\n            //if (line.charAt(line.length() - 1) != '\\u0003') {\n            if ((! line.startsWith(\"\\u0001\")) || skipFirst.get()) {\n              if (sb.length() > 0) {\n                sb.append(\"\\n\");\n              }\n              sb.append(line);\n              skipFirst.set(false);\n              return;\n            }\n            takeLine(project, line, sb, parser, refs, root, exc, h, gitCommitConsumer);\n          }\n        } catch (ProcessCanceledException e) {\n          h.cancel();\n          semaphore.up();\n        }\n      }\n      @Override\n      public void processTerminated(int exitCode) {\n        semaphore.up();\n      }\n      @Override\n      public void startFailed(Throwable exception) {\n        semaphore.up();\n      }\n    });\n    semaphore.down();\n    h.start();\n    semaphore.waitFor();\n    takeLine(project, \"\", sb, parser, refs, root, exc, h, gitCommitConsumer);\n    gitCommitConsumer.finished();\n    if (exc[0] != null) {\n      throw exc[0];\n    }\n  }","commit_id":"33f185f69b1787ec57441c234089a69b99410bec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void loadCommits(final @NotNull Collection<String> startingPoints, @NotNull final Collection<String> endPoints,\n                          @NotNull final Collection<ChangesFilter.Filter> filters,\n                          @NotNull final AsynchConsumer<GitCommit> consumer,\n                          int useMaxCnt,\n                          Getter<Boolean> isCanceled, SymbolicRefsI refs, final boolean topoOrder)\n    throws VcsException {\n\n    final List<String> parameters = new ArrayList<String>();\n    if (useMaxCnt > 0) {\n      parameters.add(\"--max-count=\" + useMaxCnt);\n    }\n\n    final Collection<VirtualFile> paths = new HashSet<VirtualFile>();\n    ChangesFilter.filtersToParameters(filters, parameters, paths);\n\n    if (! startingPoints.isEmpty()) {\n      for (String startingPoint : startingPoints) {\n        parameters.add(startingPoint);\n      }\n    } else {\n      parameters.add(\"--all\");\n    }\n    if (topoOrder) {\n      parameters.add(\"--topo-order\");\n    } else {\n      parameters.add(\"--date-order\");\n    }\n\n    for (String endPoint : endPoints) {\n      parameters.add(\"^\" + endPoint);\n    }\n\n    GitHistoryUtils.historyWithLinks(myProject, new FilePathImpl(myRoot),\n                                     refs, consumer, isCanceled, paths, ArrayUtil.toStringArray(parameters));\n  }","id":75400,"modified_method":"public void loadCommits(final @NotNull Collection<String> startingPoints, @NotNull final Collection<String> endPoints,\n                          @NotNull final Collection<ChangesFilter.Filter> filters,\n                          @NotNull final AsynchConsumer<GitCommit> consumer,\n                          int useMaxCnt,\n                          Getter<Boolean> isCanceled, SymbolicRefsI refs, final boolean topoOrder)\n    throws VcsException {\n\n    final List<String> parameters = new ArrayList<String>();\n    if (useMaxCnt > 0) {\n      parameters.add(\"--max-count=\" + useMaxCnt);\n    }\n\n    final Collection<VirtualFile> paths = new HashSet<VirtualFile>();\n    ChangesFilter.filtersToParameters(filters, parameters, paths);\n\n    if (! startingPoints.isEmpty()) {\n      for (String startingPoint : startingPoints) {\n        parameters.add(startingPoint);\n      }\n    } else {\n      parameters.add(\"--all\");\n    }\n    if (topoOrder) {\n      parameters.add(\"--topo-order\");\n    } else {\n      parameters.add(\"--date-order\");\n    }\n\n    for (String endPoint : endPoints) {\n      parameters.add(\"^\" + endPoint);\n    }\n\n    GitHistoryUtils.historyWithLinks(myProject, new FilePathImpl(myRoot),\n                                     refs, consumer, isCanceled, paths, true, ArrayUtil.toStringArray(parameters));\n  }","commit_id":"33f185f69b1787ec57441c234089a69b99410bec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * A constructor\n     *\n     * @param project\n     * @param panel\n     */\n    GitCheckinOptions(@NotNull final Project project, @NotNull CheckinProjectPanel panel) {\n      myCheckinPanel = panel;\n      myPanel = new JPanel(new GridBagLayout());\n      final Insets insets = new Insets(2, 2, 2, 2);\n      // add authors drop down\n      GridBagConstraints c = new GridBagConstraints();\n      c.gridx = 0;\n      c.gridy = 0;\n      c.anchor = GridBagConstraints.WEST;\n      c.insets = insets;\n      final JLabel authorLabel = new JLabel(GitBundle.message(\"commit.author\"));\n      myPanel.add(authorLabel, c);\n\n      c = new GridBagConstraints();\n      c.anchor = GridBagConstraints.CENTER;\n      c.insets = insets;\n      c.gridx = 1;\n      c.gridy = 0;\n      c.weightx = 1;\n      c.fill = GridBagConstraints.HORIZONTAL;\n      final List<String> usersList = getUsersList(project, myCheckinPanel.getRoots());\n      final Set<String> authors = usersList == null ? new HashSet<String>() : new HashSet<String>(usersList);\n      ContainerUtil.addAll(authors, mySettings.getCommitAuthors());\n      List<String> list = new ArrayList<String>(authors);\n      Collections.sort(list);\n      list = ObjectsConvertor.convert(list, new Convertor<String, String>() {\n        @Override\n        public String convert(String o) {\n          return StringUtil.shortenTextWithEllipsis(o, 30, 0);\n        }\n      });\n      myAuthor = new JComboBox(ArrayUtil.toObjectArray(list));\n      myAuthor.insertItemAt(\"\", 0);\n      myAuthor.setSelectedItem(\"\");\n      myAuthor.setEditable(true);\n      authorLabel.setLabelFor(myAuthor);\n      myAuthor.setToolTipText(GitBundle.getString(\"commit.author.tooltip\"));\n      myPanel.add(myAuthor, c);\n      // add amend checkbox\n      c = new GridBagConstraints();\n      c.gridx = 0;\n      c.gridy = 1;\n      c.gridwidth = 2;\n      c.anchor = GridBagConstraints.CENTER;\n      c.insets = insets;\n      c.weightx = 1;\n      c.fill = GridBagConstraints.HORIZONTAL;\n      myAmend = new NonFocusableCheckBox(GitBundle.getString(\"commit.amend\"));\n      myAmend.setMnemonic('m');\n      myAmend.setSelected(false);\n      myAmend.setToolTipText(GitBundle.getString(\"commit.amend.tooltip\"));\n      myPanel.add(myAmend, c);\n\n      myPreviousMessage = myCheckinPanel.getCommitMessage();\n\n      myAmend.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          if (myAmend.isSelected()) {\n            if (myPreviousMessage.equals(myCheckinPanel.getCommitMessage())) { // if user has already typed something, don't revert it\n              if (myAmendedMessage == null) {\n                loadMessageInModalTask(project);\n              }\n              else { // checkbox is selected not the first time\n                substituteCommitMessage(myAmendedMessage);\n              }\n            }\n          }\n          else {\n            // there was the amended message, but user has changed it => not reverting\n            if (myCheckinPanel.getCommitMessage().equals(myAmendedMessage)) {\n              myCheckinPanel.setCommitMessage(myPreviousMessage);\n            }\n          }\n        }\n      });\n    }","id":75401,"modified_method":"/**\n     * A constructor\n     *\n     * @param project\n     * @param panel\n     */\n    GitCheckinOptions(@NotNull final Project project, @NotNull CheckinProjectPanel panel) {\n      myVcs = GitVcs.getInstance(project);\n      myCheckinPanel = panel;\n      myPanel = new JPanel(new GridBagLayout());\n      final Insets insets = new Insets(2, 2, 2, 2);\n      // add authors drop down\n      GridBagConstraints c = new GridBagConstraints();\n      c.gridx = 0;\n      c.gridy = 0;\n      c.anchor = GridBagConstraints.WEST;\n      c.insets = insets;\n      final JLabel authorLabel = new JLabel(GitBundle.message(\"commit.author\"));\n      myPanel.add(authorLabel, c);\n\n      c = new GridBagConstraints();\n      c.anchor = GridBagConstraints.CENTER;\n      c.insets = insets;\n      c.gridx = 1;\n      c.gridy = 0;\n      c.weightx = 1;\n      c.fill = GridBagConstraints.HORIZONTAL;\n      final List<String> usersList = getUsersList(project, myCheckinPanel.getRoots());\n      final Set<String> authors = usersList == null ? new HashSet<String>() : new HashSet<String>(usersList);\n      ContainerUtil.addAll(authors, mySettings.getCommitAuthors());\n      List<String> list = new ArrayList<String>(authors);\n      Collections.sort(list);\n      list = ObjectsConvertor.convert(list, new Convertor<String, String>() {\n        @Override\n        public String convert(String o) {\n          return StringUtil.shortenTextWithEllipsis(o, 30, 0);\n        }\n      });\n      myAuthor = new JComboBox(ArrayUtil.toObjectArray(list));\n      myAuthor.insertItemAt(\"\", 0);\n      myAuthor.setSelectedItem(\"\");\n      myAuthor.setEditable(true);\n      authorLabel.setLabelFor(myAuthor);\n      myAuthor.setToolTipText(GitBundle.getString(\"commit.author.tooltip\"));\n      myPanel.add(myAuthor, c);\n      // add amend checkbox\n      c = new GridBagConstraints();\n      c.gridx = 0;\n      c.gridy = 1;\n      c.gridwidth = 2;\n      c.anchor = GridBagConstraints.CENTER;\n      c.insets = insets;\n      c.weightx = 1;\n      c.fill = GridBagConstraints.HORIZONTAL;\n      myAmend = new NonFocusableCheckBox(GitBundle.getString(\"commit.amend\"));\n      myAmend.setMnemonic('m');\n      myAmend.setSelected(false);\n      myAmend.setToolTipText(GitBundle.getString(\"commit.amend.tooltip\"));\n      myPanel.add(myAmend, c);\n\n      myPreviousMessage = myCheckinPanel.getCommitMessage();\n\n      myAmend.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          if (myAmend.isSelected()) {\n            if (myPreviousMessage.equals(myCheckinPanel.getCommitMessage())) { // if user has already typed something, don't revert it\n              if (myAmendedMessage == null) {\n                loadMessageInModalTask(project);\n              }\n              else { // checkbox is selected not the first time\n                substituteCommitMessage(myAmendedMessage);\n              }\n            }\n          }\n          else {\n            // there was the amended message, but user has changed it => not reverting\n            if (myCheckinPanel.getCommitMessage().equals(myAmendedMessage)) {\n              myCheckinPanel.setCommitMessage(myPreviousMessage);\n            }\n          }\n        }\n      });\n    }","commit_id":"a6f80fcd9c0bd095f15aa2b40701f308106f8529","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n    private String getLastCommitMessage(@NotNull VirtualFile root) throws VcsException {\n      GitSimpleHandler h = new GitSimpleHandler(myProject, root, GitCommand.LOG);\n      h.addParameters(\"--max-count=1\");\n      // only message: subject + body; \"%-b\" means that preceding line-feeds will be deleted if the body is empty\n      h.addParameters(\"--pretty=%s%n%n%-b\");\n      return h.run();\n    }","id":75402,"modified_method":"@Nullable\n    private String getLastCommitMessage(@NotNull VirtualFile root) throws VcsException {\n      GitSimpleHandler h = new GitSimpleHandler(myProject, root, GitCommand.LOG);\n      h.addParameters(\"--max-count=1\");\n      if (GitVersionSpecialty.STARTED_USING_RAW_BODY_IN_FORMAT.existsIn(myVcs.getVersion())) {\n        h.addParameters(\"--pretty=%B\");\n      }\n      else {\n        // only message: subject + body; \"%-b\" means that preceding line-feeds will be deleted if the body is empty\n        // %s strips newlines from subject; there is no way to work around it before 1.7.2 with %B (unless parsing some fixed format)\n        h.addParameters(\"--pretty=%s%n%n%-b\");\n      }\n      return h.run();\n    }","commit_id":"a6f80fcd9c0bd095f15aa2b40701f308106f8529","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * git checkout -b &lt;reference&gt; [&lt;trackedBranch&gt;]\n   */\n  public static GitCommandResult checkoutNewBranch(@NotNull GitRepository repository, @NotNull String branchName,\n                                                   @Nullable String trackedBranch,\n                                                   @Nullable GitLineHandlerListener listener) {\n    final GitLineHandler h = new GitLineHandler(repository.getProject(), repository.getRoot(), GitCommand.CHECKOUT);\n    h.addParameters(\"-b\");\n    h.addParameters(branchName);\n    if (trackedBranch != null) {\n      h.addParameters(trackedBranch);\n    }\n    if (listener != null) {\n      h.addLineListener(listener);\n    }\n    return run(h);\n  }","id":75403,"modified_method":"/**\n   * {@code git checkout -b &lt;branchName&gt;}\n   */\n  public static GitCommandResult checkoutNewBranch(@NotNull GitRepository repository, @NotNull String branchName,\n                                                   @Nullable GitLineHandlerListener listener) {\n    final GitLineHandler h = new GitLineHandler(repository.getProject(), repository.getRoot(), GitCommand.CHECKOUT);\n    h.addParameters(\"-b\");\n    h.addParameters(branchName);\n    if (listener != null) {\n      h.addLineListener(listener);\n    }\n    return run(h);\n  }","commit_id":"4f5317b282e62be2655d7f567ac6750204d44b90","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * git checkout &lt;reference&gt;\n   */\n  public static GitCommandResult checkout(@NotNull GitRepository repository, @NotNull String reference, GitLineHandlerListener... listeners) {\n    final GitLineHandler h = new GitLineHandler(repository.getProject(), repository.getRoot(), GitCommand.CHECKOUT);\n    h.addParameters(reference);\n    for (GitLineHandlerListener listener : listeners) {\n      h.addLineListener(listener);\n    }\n    return run(h);\n  }","id":75404,"modified_method":"/**\n   * {@code git checkout &lt;reference&gt;} <br/>\n   * {@code git checkout -b &lt;trackedBranch&gt; &lt;reference&gt;}\n   */\n  public static GitCommandResult checkout(@NotNull GitRepository repository,\n                                          @NotNull String reference,\n                                          @Nullable String newTrackingBranch,\n                                          GitLineHandlerListener... listeners) {\n    final GitLineHandler h = new GitLineHandler(repository.getProject(), repository.getRoot(), GitCommand.CHECKOUT);\n    if (newTrackingBranch == null) { // simply checkout\n      h.addParameters(reference);\n    } else { // checkout reference as new branch\n      h.addParameters(\"-b\", newTrackingBranch, reference);\n    }\n    for (GitLineHandlerListener listener : listeners) {\n      h.addLineListener(listener);\n    }\n    return run(h);\n  }","commit_id":"4f5317b282e62be2655d7f567ac6750204d44b90","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * <p>\n   *   Checks out the given reference (a branch, or a reference name, or a commit hash).\n   *   If local changes prevent the checkout, shows the list of them and proposes to make a \"smart checkout\":\n   *   stash-checkout-unstash.\n   * <\/p>\n   * <p>\n   *   Doesn't check the reference for validity.\n   * <\/p>\n   *\n   * @param reference reference to be checked out.\n   */\n  public void checkout(@NotNull final String reference) {\n    new CommonBackgroundTask(myProject, \"Checking out \" + reference) {\n      @Override public void execute(@NotNull ProgressIndicator indicator) {\n        doCheckout(indicator, reference);\n      }\n    }.runInBackground();\n  }","id":75405,"modified_method":"/**\n   * <p>\n   *   Checks out the given reference (a branch, or a reference name, or a commit hash).\n   *   If local changes prevent the checkout, shows the list of them and proposes to make a \"smart checkout\":\n   *   stash-checkout-unstash.\n   * <\/p>\n   * <p>\n   *   Doesn't check the reference for validity.\n   * <\/p>\n   *\n   * @param reference reference to be checked out.\n   */\n  public void checkout(@NotNull final String reference) {\n    commonCheckout(reference, null);\n  }","commit_id":"4f5317b282e62be2655d7f567ac6750204d44b90","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Checks out or shows an error message.\n   */\n  private boolean checkoutOrNotify(String reference) {\n    GitCommandResult checkoutResult = Git.checkout(myRepository, reference);\n    if (checkoutResult.success()) {\n      return true;\n    }\n    else {\n      showErrorMessage(\"Couldn't checkout \" + reference, checkoutResult.getErrorOutput());\n      return false;\n    }\n  }","id":75406,"modified_method":"/**\n   * Checks out or shows an error message.\n   */\n  private boolean checkoutOrNotify(@NotNull String reference, @Nullable String newTrackingBranch) {\n    GitCommandResult checkoutResult = Git.checkout(myRepository, reference, newTrackingBranch);\n    if (checkoutResult.success()) {\n      return true;\n    }\n    else {\n      showErrorMessage(\"Couldn't checkout \" + reference, checkoutResult.getErrorOutput());\n      return false;\n    }\n  }","commit_id":"4f5317b282e62be2655d7f567ac6750204d44b90","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void checkoutNewTrackingBranch(@NotNull String newBranchName, @NotNull String trackedBranchName) {\n    // TODO checkout & track => would be unmerged problem => smart checkout\n  }","id":75407,"modified_method":"/**\n   * Checks out remote branch as a new local branch.\n   * Provides the \"smart checkout\" procedure the same as in {@link #checkout(String)}.\n   *\n   * @param newBranchName     Name of new local branch.\n   * @param trackedBranchName Name of the remote branch being checked out.\n   */\n  public void checkoutNewTrackingBranch(@NotNull String newBranchName, @NotNull String trackedBranchName) {\n    commonCheckout(trackedBranchName, newBranchName);\n  }","commit_id":"4f5317b282e62be2655d7f567ac6750204d44b90","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void smartCheckout(@NotNull final String reference, @NotNull ProgressIndicator indicator) {\n    final GitChangesSaver saver = configureSaver(reference, indicator);\n\n    GitComplexProcess.Operation checkoutOperation = new GitComplexProcess.Operation() {\n      @Override public void run(ContinuationContext context) {\n        if (saveOrNotify(saver)) {\n          try {\n            checkoutOrNotify(reference);\n          } finally {\n            saver.restoreLocalChanges(context);\n          }\n        }\n      }\n    };\n    GitComplexProcess.execute(myProject, \"checkout\", checkoutOperation);\n  }","id":75408,"modified_method":"private void smartCheckout(@NotNull final String reference, @Nullable final String newTrackingBranch, @NotNull ProgressIndicator indicator) {\n    final GitChangesSaver saver = configureSaver(reference, indicator);\n\n    GitComplexProcess.Operation checkoutOperation = new GitComplexProcess.Operation() {\n      @Override public void run(ContinuationContext context) {\n        if (saveOrNotify(saver)) {\n          try {\n            checkoutOrNotify(reference, newTrackingBranch);\n          } finally {\n            saver.restoreLocalChanges(context);\n          }\n        }\n      }\n    };\n    GitComplexProcess.execute(myProject, \"checkout\", checkoutOperation);\n  }","commit_id":"4f5317b282e62be2655d7f567ac6750204d44b90","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doCheckoutNewBranch(@NotNull final String name) {\n    GitUnmergedFilesDetector unmergedDetector = new GitUnmergedFilesDetector();\n    GitCommandResult result = Git.checkoutNewBranch(myRepository, name, null, unmergedDetector);\n    if (result.success()) {\n      updateRepository();\n      notifySuccess(String.format(\"Branch <b><code>%s<\/code><\/b> was created\", name));\n    } else if (unmergedDetector.isUnmergedFilesDetected()) {\n      GitConflictResolver gitConflictResolver = prepareConflictResolverForUnmergedFilesBeforeCheckout();\n      if (gitConflictResolver.merge()) { // try again to checkout\n        doCheckoutNewBranch(name);\n      }\n    } else { // other error\n      showErrorMessage(\"Couldn't create new branch \" + name, result.getErrorOutput());\n    }\n  }","id":75409,"modified_method":"private void doCheckoutNewBranch(@NotNull final String name) {\n    GitUnmergedFilesDetector unmergedDetector = new GitUnmergedFilesDetector();\n    GitCommandResult result = Git.checkoutNewBranch(myRepository, name, unmergedDetector);\n    if (result.success()) {\n      updateRepository();\n      notifySuccess(String.format(\"Branch <b><code>%s<\/code><\/b> was created\", name));\n    } else if (unmergedDetector.isUnmergedFilesDetected()) {\n      GitConflictResolver gitConflictResolver = prepareConflictResolverForUnmergedFilesBeforeCheckout();\n      if (gitConflictResolver.merge()) { // try again to checkout\n        doCheckoutNewBranch(name);\n      }\n    } else { // other error\n      showErrorMessage(\"Couldn't create new branch \" + name, result.getErrorOutput());\n    }\n  }","commit_id":"4f5317b282e62be2655d7f567ac6750204d44b90","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doCheckout(@NotNull ProgressIndicator indicator, @NotNull String reference) {\n    final GitWouldBeOverwrittenByCheckoutDetector checkoutListener = new GitWouldBeOverwrittenByCheckoutDetector();\n    GitUnmergedFilesDetector unmergedDetector = new GitUnmergedFilesDetector();\n\n    GitCommandResult result = Git.checkout(myRepository, reference, checkoutListener, unmergedDetector);\n    if (result.success()) {\n      refreshRoot();\n      updateRepository();\n      notifySuccess(String.format(\"Checked out <b><code>%s<\/code><\/b>\", reference));\n    }\n    else if (unmergedDetector.isUnmergedFilesDetected()) {\n      GitConflictResolver gitConflictResolver = prepareConflictResolverForUnmergedFilesBeforeCheckout();\n      if (gitConflictResolver.merge()) { // try again to checkout\n        doCheckout(indicator, reference);\n      }\n    }\n    else if (checkoutListener.isWouldBeOverwrittenError()) {\n      List<Change> affectedChanges = getChangesAffectedByCheckout(checkoutListener.getAffectedFiles());\n      if (GitWouldBeOverwrittenByCheckoutDialog.showAndGetAnswer(myProject, affectedChanges)) {\n        smartCheckout(reference, indicator);\n      }\n    }\n    else {\n      showErrorMessage(\"Couldn't checkout \" + reference, result.getErrorOutput());\n    }\n  }","id":75410,"modified_method":"private void doCheckout(@NotNull ProgressIndicator indicator, @NotNull String reference, @Nullable String newTrackingBranch) {\n    final GitWouldBeOverwrittenByCheckoutDetector checkoutListener = new GitWouldBeOverwrittenByCheckoutDetector();\n    GitUnmergedFilesDetector unmergedDetector = new GitUnmergedFilesDetector();\n\n    GitCommandResult result = Git.checkout(myRepository, reference, newTrackingBranch, checkoutListener, unmergedDetector);\n    if (result.success()) {\n      refreshRoot();\n      updateRepository();\n      notifySuccess(String.format(\"Checked out <b><code>%s<\/code><\/b>\", reference));\n    }\n    else if (unmergedDetector.isUnmergedFilesDetected()) {\n      GitConflictResolver gitConflictResolver = prepareConflictResolverForUnmergedFilesBeforeCheckout();\n      if (gitConflictResolver.merge()) { // try again to checkout\n        doCheckout(indicator, reference, newTrackingBranch);\n      }\n    }\n    else if (checkoutListener.isWouldBeOverwrittenError()) {\n      List<Change> affectedChanges = getChangesAffectedByCheckout(checkoutListener.getAffectedFiles());\n      if (GitWouldBeOverwrittenByCheckoutDialog.showAndGetAnswer(myProject, affectedChanges)) {\n        smartCheckout(reference, newTrackingBranch, indicator);\n      }\n    }\n    else {\n      showErrorMessage(\"Couldn't checkout \" + reference, result.getErrorOutput());\n    }\n  }","commit_id":"4f5317b282e62be2655d7f567ac6750204d44b90","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n      public void actionPerformed(AnActionEvent e) {\n        // TODO Checkbox to auto-create in future, if the name is available - if not available the input dialog should be shown\n        // TODO when checkbox is set, the action name can transform to \"checkout as <name>\".\n        final String name = Messages.showInputDialog(myProject, \"Enter name of new branch\", \"Checkout remote branch\", Messages.getQuestionIcon(),\n                                               guessBranchName(), GitNewBranchNameValidator.newInstance(myRepository));\n        if (name == null) {\n          return;\n        }\n        new GitBranchOperationsProcessor(myProject, myRepository).checkoutNewTrackingBranch(name, myRemoteBranchName);\n      }","id":75411,"modified_method":"@Override\n      public void actionPerformed(AnActionEvent e) {\n        final String name = Messages.showInputDialog(myProject, \"Enter name of new branch\", \"Checkout remote branch\", Messages.getQuestionIcon(),\n                                               guessBranchName(), GitNewBranchNameValidator.newInstance(myRepository));\n        if (name != null) {\n          new GitBranchOperationsProcessor(myProject, myRepository).checkoutNewTrackingBranch(name, myRemoteBranchName);\n        }\n      }","commit_id":"4f5317b282e62be2655d7f567ac6750204d44b90","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public abstract SModelDescriptor getModelDescriptor(String packageName);","id":75412,"modified_method":"public abstract SModelReference getModelReferenceFor(String packageName);","commit_id":"741d0f3fc056de1dc3fd5090ce89a8aaf47b4ec1","url":"https://github.com/JetBrains/MPS"},{"original_method":"private Classifier getClassifier(String fqName) {\n    String pack = NodeNameUtil.getNamespace(fqName);\n    final String name = NodeNameUtil.getName(fqName);\n    SModelDescriptor modelDescriptor = this.getModelDescriptor(pack);\n    SModel model = (modelDescriptor == this.myModelDescriptor ?\n      this.myModel :\n      modelDescriptor.getSModel()\n    );\n    Classifier result = (Classifier) BaseAdapter.fromNode(model.getNodeById(ASMNodeId.createId(name)));\n    if (result == null) {\n      byte[] code = this.myCpItem.getClass(fqName);\n      if (code == null) {\n        return null;\n      }\n      ClassReader reader = new ClassReader(code);\n      result = this.createClassifierForClass(fqName, model, reader);\n      if (result == null) {\n        return null;\n      }\n      model.addRoot(result.getNode());\n      this.updateClassifier(result, reader);\n    }\n    return result;\n  }","id":75413,"modified_method":"private Classifier getClassifier(String name) {\n    SModel model = this.myModel;\n    Classifier result = (Classifier) BaseAdapter.fromNode(model.getNodeById(ASMNodeId.createId(name)));\n    if (result == null) {\n      String pack = model.getLongName();\n      byte[] code = this.myCpItem.getClass((pack.length() == 0 ?\n        name :\n        pack + \".\" + name\n      ));\n      if (code == null) {\n        return null;\n      }\n      ClassReader reader = new ClassReader(code);\n      result = this.createClassifierForClass(name, model, reader);\n      if (result == null) {\n        return null;\n      }\n      model.addRoot(result.getNode());\n      this.updateClassifier(result, reader);\n    }\n    return result;\n  }","commit_id":"741d0f3fc056de1dc3fd5090ce89a8aaf47b4ec1","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void addAnnotationMethodReference(SNode sourceNode, String role, ASMClassType annotationType, String method) {\n    SModelDescriptor targetModel = this.getModelDescriptor(NodeNameUtil.getNamespace(annotationType.getName()));\n    if (sourceNode.getModel().getModelDescriptor() != targetModel) {\n      SNodeId nodeId = ASMNodeId.createAnnotationMethodId(annotationType.getName(), method);\n      SReference reference = SReference.create(role, sourceNode, targetModel.getSModelReference(), nodeId);\n      sourceNode.addReference(reference);\n    } else {\n      Classifier classifier = this.getClassifier(annotationType.getName());\n      InstanceMethodDeclaration result = null;\n      if (classifier instanceof Annotation) {\n        Annotation annotation = (Annotation) classifier;\n        for (InstanceMethodDeclaration m : annotation.getMethods()) {\n          if (method.equals(m.getName())) {\n            result = m;\n            break;\n          }\n        }\n      }\n      if (sourceNode.getReferent(role) == null) {\n        sourceNode.addReference(SReference.create(role, sourceNode, BaseAdapter.fromAdapter(result)));\n      }\n    }\n  }","id":75414,"modified_method":"private void addAnnotationMethodReference(SNode sourceNode, String role, ASMClassType annotationType, String method) {\n\n    SModelReference targetRef = this.getModelReferenceFor(NodeNameUtil.getNamespace(annotationType.getName()));\n    if (!(sourceNode.getModel().getModelDescriptor().equals(targetRef))) {\n      SNodeId nodeId = ASMNodeId.createAnnotationMethodId(annotationType.getName(), method);\n      SReference reference = SReference.create(role, sourceNode, targetRef, nodeId);\n      sourceNode.addReference(reference);\n    } else {\n      Classifier classifier = this.getClassifier(NameUtil.shortNameFromLongName(annotationType.getName()));\n      InstanceMethodDeclaration result = null;\n      if (classifier instanceof Annotation) {\n        Annotation annotation = (Annotation) classifier;\n        for (InstanceMethodDeclaration m : annotation.getMethods()) {\n          if (method.equals(m.getName())) {\n            result = m;\n            break;\n          }\n        }\n      }\n      if (sourceNode.getReferent(role) == null) {\n        sourceNode.addReference(SReference.create(role, sourceNode, BaseAdapter.fromAdapter(result)));\n      }\n    }\n  }","commit_id":"741d0f3fc056de1dc3fd5090ce89a8aaf47b4ec1","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void addClassifierReference(SNode sourceNode, String role, ASMClassType clsType) {\n    SModelDescriptor targetModel = this.getModelDescriptor(NodeNameUtil.getNamespace(clsType.getName()));\n    if (sourceNode.getModel().getModelDescriptor() != targetModel) {\n      SNodeId nodeId = ASMNodeId.createId(clsType.getName());\n      SReference reference = SReference.create(role, sourceNode, targetModel.getSModelReference(), nodeId);\n      sourceNode.addReference(reference);\n    } else {\n      if (sourceNode.getReferent(role) == null) {\n        Classifier classifier = this.getClassifier(clsType.getName());\n        if (classifier != null) {\n          SNode targetNode = classifier.getNode();\n          SReference reference = SReference.create(role, sourceNode, targetNode);\n          sourceNode.addReference(reference);\n        }\n      }\n    }\n  }","id":75415,"modified_method":"private void addClassifierReference(SNode sourceNode, String role, ASMClassType clsType) {\n    SModelReference targetModelRef = this.getModelReferenceFor(NodeNameUtil.getNamespace(clsType.getName()));\n    if (!(sourceNode.getModel().getModelDescriptor().getSModelReference().equals(targetModelRef))) {\n      SNodeId nodeId = ASMNodeId.createId(clsType.getName());\n      SReference reference = SReference.create(role, sourceNode, targetModelRef, nodeId);\n      sourceNode.addReference(reference);\n    } else {\n      if (sourceNode.getReferent(role) == null) {\n        Classifier classifier = this.getClassifier(NameUtil.shortNameFromLongName(clsType.getName()));\n        if (classifier != null) {\n          SNode targetNode = classifier.getNode();\n          SReference reference = SReference.create(role, sourceNode, targetNode);\n          sourceNode.addReference(reference);\n        }\n      }\n    }\n  }","commit_id":"741d0f3fc056de1dc3fd5090ce89a8aaf47b4ec1","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void updateModel() {\n    try {\n      SModelReference reference = this.myModelDescriptor.getSModelReference();\n      String pack = reference.getLongName();\n      final Set<String> classes = this.getAvailableClasses(pack);\n      for (String name : classes) {\n        this.getClassifier((pack.equals(\"\") ?\n          name :\n          pack + \".\" + name\n        ));\n      }\n    } catch (Exception e) {\n      LOG.error(\"Exception\", e);\n    }\n  }","id":75416,"modified_method":"public void updateModel() {\n    try {\n      SModelReference reference = this.myModelDescriptor.getSModelReference();\n      String pack = reference.getLongName();\n      final Set<String> classes = this.getAvailableClasses(pack);\n      for (String name : classes) {\n        this.getClassifier(name);\n      }\n    } catch (Exception e) {\n      LOG.error(\"Exception\", e);\n    }\n  }","commit_id":"741d0f3fc056de1dc3fd5090ce89a8aaf47b4ec1","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void addEnumConstReference(SNode sourceNode, String role, ASMEnumValue enumValue) {\n    ASMClassType classType = (ASMClassType) enumValue.getType();\n    SModelDescriptor targetModel = this.getModelDescriptor(NodeNameUtil.getNamespace(classType.getName()));\n    if (sourceNode.getModel().getModelDescriptor() != targetModel) {\n      SNodeId nodeId = ASMNodeId.createFieldId(classType.getName(), enumValue.getConstant());\n      SReference reference = SReference.create(role, sourceNode, targetModel.getSModelReference(), nodeId);\n      sourceNode.addReference(reference);\n    } else {\n      if (sourceNode.getReferent(role) == null) {\n        Classifier classifier = this.getClassifier(classType.getName());\n        EnumConstantDeclaration constDcl = null;\n        if (classifier instanceof EnumClass) {\n          EnumClass ec = (EnumClass) classifier;\n          for (EnumConstantDeclaration dcl : ec.getEnumConstants()) {\n            if (enumValue.getConstant().equals(dcl.getName())) {\n              constDcl = dcl;\n              break;\n            }\n          }\n        }\n        sourceNode.addReference(SReference.create(role, sourceNode, BaseAdapter.fromAdapter(constDcl)));\n      }\n    }\n  }","id":75417,"modified_method":"private void addEnumConstReference(SNode sourceNode, String role, ASMEnumValue enumValue) {\n    ASMClassType classType = (ASMClassType) enumValue.getType();\n    SModelReference targetRef = this.getModelReferenceFor(NodeNameUtil.getNamespace(classType.getName()));\n    if (!(sourceNode.getModel().getSModelReference().equals(targetRef))) {\n      SNodeId nodeId = ASMNodeId.createFieldId(classType.getName(), enumValue.getConstant());\n      SReference reference = SReference.create(role, sourceNode, targetRef, nodeId);\n      sourceNode.addReference(reference);\n    } else {\n      if (sourceNode.getReferent(role) == null) {\n        Classifier classifier = this.getClassifier(NameUtil.shortNameFromLongName(classType.getName()));\n        EnumConstantDeclaration constDcl = null;\n        if (classifier instanceof EnumClass) {\n          EnumClass ec = (EnumClass) classifier;\n          for (EnumConstantDeclaration dcl : ec.getEnumConstants()) {\n            if (enumValue.getConstant().equals(dcl.getName())) {\n              constDcl = dcl;\n              break;\n            }\n          }\n        }\n        sourceNode.addReference(SReference.create(role, sourceNode, BaseAdapter.fromAdapter(constDcl)));\n      }\n    }\n  }","commit_id":"741d0f3fc056de1dc3fd5090ce89a8aaf47b4ec1","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void updateModel(final StubLocation location, final ModelInfo modelInfo) {\n    final JavaStubs localThis = JavaStubs.this;\n    IClassPathItem cpItem = JavaStubs.this.createClassPathItem(location);\n    if (cpItem == null) {\n      return;\n    }\n    new ASMModelLoader(cpItem, modelInfo.getModelDescriptor(), modelInfo.getModel()) {\n      public SModelDescriptor getModelDescriptor(String packageName) {\n        SModelReference modelReference = StubHelper.uidForPackageInStubs(packageName);\n        SModelDescriptor result = SModelRepository.getInstance().getModelDescriptor(modelReference);\n        if (result != null) {\n          return result;\n        }\n        result = new DefaultSModelDescriptor(localThis, null, modelReference);\n        SModelRepository.getInstance().registerModelDescriptor(result, modelInfo.getModelDescriptor().getModule());\n        return result;\n      }\n    }.updateModel();\n  }","id":75418,"modified_method":"protected void updateModel(final StubLocation location, final ModelInfo modelInfo) {\n    final JavaStubs localThis = JavaStubs.this;\n    IClassPathItem cpItem = JavaStubs.this.createClassPathItem(location);\n    if (cpItem == null) {\n      return;\n    }\n    new ASMModelLoader(cpItem, modelInfo.getModelDescriptor(), modelInfo.getModel()) {\n      public SModelReference getModelReferenceFor(String packageName) {\n        return StubHelper.uidForPackageInStubs(packageName);\n      }\n    }.updateModel();\n  }","commit_id":"741d0f3fc056de1dc3fd5090ce89a8aaf47b4ec1","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void clearForModel(SModelDescriptor modelDescriptor) {\n    for (SNode root : SetSequence.fromSetWithValues(new HashSet<SNode>(), MapSequence.fromMap(myRootsToComponents).keySet())) {\n      if (SNodeOperations.getModel(root).getModelDescriptor() == modelDescriptor) {\n        MapSequence.fromMap(myRootsToComponents).get(root).dispose();\n        MapSequence.fromMap(myRootsToComponents).removeKey(root);\n      }\n    }\n    for (EditorComponent component : SetSequence.fromSetWithValues(new HashSet<EditorComponent>(), myEditorComponents)) {\n      if (component.getEditedNode().getModel().getModelDescriptor() == modelDescriptor) {\n        component.removeDisposeListener(myDisposeListener);\n        SetSequence.fromSet(myEditorComponents).removeElement(component);\n      }\n    }\n  }","id":75419,"modified_method":"private void clearForModel(SModelReference modelReference) {\n    for (SNode root : SetSequence.fromSetWithValues(new HashSet<SNode>(), MapSequence.fromMap(myRootsToComponents).keySet())) {\n      if (SNodeOperations.getModel(root).getSModelReference().equals(modelReference)) {\n        MapSequence.fromMap(myRootsToComponents).get(root).dispose();\n        MapSequence.fromMap(myRootsToComponents).removeKey(root);\n      }\n    }\n    for (EditorComponent component : SetSequence.fromSetWithValues(new HashSet<EditorComponent>(), myEditorComponents)) {\n      if (component.getEditedNode().getModel().getSModelReference().equals(modelReference)) {\n        component.removeDisposeListener(myDisposeListener);\n        SetSequence.fromSet(myEditorComponents).removeElement(component);\n      }\n    }\n  }","commit_id":"051431383e0df26833051f29215ad5965d94ec87","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Set<EditorMessage> createMessages(SNode node, IOperationContext operationContext, List<SModelEvent> list, boolean wasCheckedOnce, EditorContext editorContext) {\n    EditorComponent editorComponent = editorContext.getNodeEditorComponent();\n    SNode root = node.getContainingRoot();\n    Set<EditorMessage> result = SetSequence.fromSet(new HashSet<EditorMessage>());\n    if (root == null) {\n      LOG.error(\"containing root for node \" + node + \" is null\");\n      return result;\n    }\n    LanguageErrorsComponent errorsComponent = MapSequence.fromMap(myRootsToComponents).get(root);\n\n    if (errorsComponent == null) {\n      errorsComponent = new LanguageErrorsComponent(editorComponent.getEditedNode());\n      MapSequence.fromMap(myRootsToComponents).put(root, errorsComponent);\n    }\n    if (!(editorComponent instanceof InspectorEditorComponent) && !(SetSequence.fromSet(myEditorComponents).contains(editorComponent))) {\n      SetSequence.fromSet(myEditorComponents).addElement(editorComponent);\n      editorComponent.addDisposeListener(myDisposeListener);\n    }\n    SModelDescriptor descriptor = SNodeOperations.getModel(root).getModelDescriptor();\n    addModelListener(descriptor);\n\n    if (!(wasCheckedOnce)) {\n      errorsComponent.clear();\n    }\n    boolean changed = errorsComponent.check(node, myRules, operationContext);\n    myMessagesChanged = changed;\n    for (IErrorReporter errorReporter : errorsComponent.getErrors()) {\n\n      MessageStatus status = errorReporter.getMessageStatus();\n      String errorString = errorReporter.reportError();\n      HighlighterMessage message = HighlightUtil.createHighlighterMessage(errorReporter.getSNode(), NameUtil.capitalize(status.getPresentation()) + \": \" + errorString, errorReporter, LanguageChecker.this, editorContext);\n      SetSequence.fromSet(result).addElement(message);\n    }\n    return result;\n  }","id":75420,"modified_method":"public Set<EditorMessage> createMessages(SNode node, IOperationContext operationContext, List<SModelEvent> list, boolean wasCheckedOnce, EditorContext editorContext) {\n    EditorComponent editorComponent = editorContext.getNodeEditorComponent();\n    SNode root = node.getContainingRoot();\n    Set<EditorMessage> result = SetSequence.fromSet(new HashSet<EditorMessage>());\n    if (root == null) {\n      LOG.error(\"containing root for node \" + node + \" is null\");\n      return result;\n    }\n    SModelDescriptor descriptor = SNodeOperations.getModel(root).getModelDescriptor();\n    if (descriptor == null) {\n      // descriptor is null for a replaced model \n      // after model is replaced but before it is disposed (this can happen asyncronously) \n      return result;\n    }\n    LanguageErrorsComponent errorsComponent = MapSequence.fromMap(myRootsToComponents).get(root);\n\n    if (errorsComponent == null) {\n      errorsComponent = new LanguageErrorsComponent(editorComponent.getEditedNode());\n      MapSequence.fromMap(myRootsToComponents).put(root, errorsComponent);\n    }\n    if (!(editorComponent instanceof InspectorEditorComponent) && !(SetSequence.fromSet(myEditorComponents).contains(editorComponent))) {\n      SetSequence.fromSet(myEditorComponents).addElement(editorComponent);\n      editorComponent.addDisposeListener(myDisposeListener);\n    }\n    addModelListener(descriptor);\n\n    if (!(wasCheckedOnce)) {\n      errorsComponent.clear();\n    }\n    boolean changed = errorsComponent.check(node, myRules, operationContext);\n    myMessagesChanged = changed;\n    for (IErrorReporter errorReporter : errorsComponent.getErrors()) {\n\n      MessageStatus status = errorReporter.getMessageStatus();\n      String errorString = errorReporter.reportError();\n      HighlighterMessage message = HighlightUtil.createHighlighterMessage(errorReporter.getSNode(), NameUtil.capitalize(status.getPresentation()) + \": \" + errorString, errorReporter, LanguageChecker.this, editorContext);\n      SetSequence.fromSet(result).addElement(message);\n    }\n    return result;\n  }","commit_id":"051431383e0df26833051f29215ad5965d94ec87","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void modelDescriptorRemoved(SModelDescriptor modelDescriptor) {\n    this.removeModelListener(modelDescriptor);\n    this.clearForModel(modelDescriptor);\n  }","id":75421,"modified_method":"private void modelDescriptorRemoved(SModelDescriptor modelDescriptor) {\n    this.removeModelListener(modelDescriptor);\n    this.clearForModel(modelDescriptor.getSModelReference());\n  }","commit_id":"051431383e0df26833051f29215ad5965d94ec87","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n\t * If an exception occurs, it is noted, but ignored. Especially IO, as\n\t * generally they are temporary.\n\t */\n\tprivate Package readPackage(File pkgFile) {\n\n\t\tString name = pkgFile.getName();\n\t\tif (!(name.endsWith(\".pkg\") || name.endsWith(\".drl\") || name\n\t\t\t\t.endsWith(\".xls\"))) {\n\t\t\treturn null;\n\t\t}\n\t\t// use reflection to load if its DRL, the provider lives in drools\n\t\t// compiler.\n\t\tif (pkgFile.getName().endsWith(\".drl\")) {\n\t\t\ttry {\n\t\t\t\tFileLoader fl = (FileLoader) Class.forName(\n\t\t\t\t\t\t\"org.drools.compiler.SourcePackageProvider\")\n\t\t\t\t\t\t.newInstance();\n\t\t\t\treturn fl.loadPackage(pkgFile);\n\t\t\t} catch (Exception e) {\n\t\t\t\tthis.listener.exception(e);\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// use reflection to load if its XLS, the provider lives in drools\n\t\t\t// decision tables.\n\t\t} else if (pkgFile.getName().endsWith(\".xls\")) {\n\t\t\ttry {\n\t\t\t\tFileLoader fl = (FileLoader) Class.forName(\n\t\t\t\t\t\t\"org.drools.decisiontable.SourcePackageProvider\")\n\t\t\t\t\t\t.newInstance();\n\t\t\t\treturn fl.loadPackage(pkgFile);\n\t\t\t} catch (Exception e) {\n\t\t\t\tthis.listener.exception(e);\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tPackage p1_ = null;\n\t\t\ttry {\n\n\t\t\t\tFileInputStream fis = new FileInputStream(pkgFile);\n\n\t\t\t\tp1_ = (Package) DroolsStreamUtils.streamIn(fis);\n\n\t\t\t\tfis.close();\n\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tthis.listener.exception(e);\n\t\t\t\tthis.listener.warning(\"Was unable to find the file \"\n\t\t\t\t\t\t+ pkgFile.getPath());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthis.listener.exception(e);\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tthis.listener.exception(e);\n\t\t\t\tthis.listener\n\t\t\t\t\t\t.warning(\"Was unable to load a class when loading a package. Perhaps it is missing from this application.\");\n\t\t\t}\n\t\t\treturn p1_;\n\t\t}\n\t}","id":75422,"modified_method":"/**\n     * If an exception occurs, it is noted, but ignored. Especially IO, as\n     * generally they are temporary.\n     */\n    private Package readPackage(File pkgFile) {\n\n        String name = pkgFile.getName();\n        if ( !(name.endsWith( \".pkg\" ) || name.endsWith( \".drl\" ) || name.endsWith( \".xls\" )) ) {\n            return null;\n        }\n        // use reflection to load if its DRL, the provider lives in drools\n        // compiler.\n        if ( pkgFile.getName().endsWith( \".drl\" ) ) {\n            try {\n                FileLoader fl = (FileLoader) Class.forName( \"org.drools.compiler.SourcePackageProvider\" ).newInstance();\n                return fl.loadPackage( pkgFile );\n            } catch ( Exception e ) {\n                this.listener.exception( e );\n                return null;\n            }\n\n            // use reflection to load if its XLS, the provider lives in drools\n            // decision tables.\n        } else if ( pkgFile.getName().endsWith( \".xls\" ) ) {\n            try {\n                FileLoader fl = (FileLoader) Class.forName( \"org.drools.decisiontable.SourcePackageProvider\" ).newInstance();\n                return fl.loadPackage( pkgFile );\n            } catch ( Exception e ) {\n                this.listener.exception( e );\n                return null;\n            }\n\n        } else {\n\n            Object o = null;\n            try {\n\n                FileInputStream fis = new FileInputStream( pkgFile );\n\n                o = DroolsStreamUtils.streamIn( fis );\n\n                fis.close();\n\n            } catch ( FileNotFoundException e ) {\n                this.listener.exception( e );\n                this.listener.warning( \"Was unable to find the file \" + pkgFile.getPath() );\n            } catch ( IOException e ) {\n                this.listener.exception( e );\n            } catch ( ClassNotFoundException e ) {\n                this.listener.exception( e );\n                this.listener.warning( \"Was unable to load a class when loading a package. Perhaps it is missing from this application.\" );\n            }\n\n            if ( o instanceof KnowledgePackageImp ) {\n                return ((KnowledgePackageImp) o).pkg;\n            } else {\n                return (Package) o;\n            }\n        }\n    }","commit_id":"b3b185b3e31447b1977e07a79b7580781020a189","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public Package fetchPackage(URL url) throws IOException, ClassNotFoundException {\n        URLConnection con = url.openConnection();\n        HttpURLConnection httpCon = (HttpURLConnection) con;\n        try {\n            httpCon.setRequestMethod( \"GET\" );\n\n            return (Package) DroolsStreamUtils.streamIn(httpCon.getInputStream());\n\n        } finally {\n            httpCon.disconnect();\n        }\n    }","id":75423,"modified_method":"public Package fetchPackage(URL url) throws IOException,\n                                        ClassNotFoundException {\n        URLConnection con = url.openConnection();\n        HttpURLConnection httpCon = (HttpURLConnection) con;\n        try {\n            httpCon.setRequestMethod( \"GET\" );\n\n            Object o = DroolsStreamUtils.streamIn( httpCon.getInputStream() );\n\n            if ( o instanceof KnowledgePackageImp ) {\n                return ((KnowledgePackageImp) o).pkg;\n            } else {\n                return (Package) o;\n            }\n        } finally {\n            httpCon.disconnect();\n        }\n    }","commit_id":"b3b185b3e31447b1977e07a79b7580781020a189","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public Long getZoneId() {\n        return zoneId;\n    }","id":75424,"modified_method":"public long getZoneId() {\n        return zoneId;\n    }","commit_id":"f794abfdefe2fd4608061b0e2dd371e25092e3f1","url":"https://github.com/apache/cloudstack"},{"original_method":"public Long getDomainId() {\n        return domainId;\n    }","id":75425,"modified_method":"public long getDomainId() {\n        if (domainId != null) {\n            return domainId;\n        }\n        return UserContext.current().getAccount().getDomainId();\n    }","commit_id":"f794abfdefe2fd4608061b0e2dd371e25092e3f1","url":"https://github.com/apache/cloudstack"},{"original_method":"public String getAccountName() {\n        return accountName;\n    }","id":75426,"modified_method":"public String getAccountName() {\n        if (accountName != null) { \n            return accountName;\n        }\n        return UserContext.current().getAccount().getAccountName();\n    }","commit_id":"f794abfdefe2fd4608061b0e2dd371e25092e3f1","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public boolean disassociate(Network network, Ip ipAddress) throws ResourceUnavailableException {\n        // TODO Auto-generated method stub\n        return false;\n    }","id":75427,"modified_method":"@Override\n    public boolean disassociate(Network network, IpAddress ipAddress) throws ResourceUnavailableException {\n        // TODO Auto-generated method stub\n        return false;\n    }","commit_id":"f794abfdefe2fd4608061b0e2dd371e25092e3f1","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public boolean associate(Network network, Ip ipAddress) throws ResourceUnavailableException {\n        // TODO Auto-generated method stub\n        return false;\n    }","id":75428,"modified_method":"@Override\n    public boolean associate(Network network, IpAddress ipAddress) throws ResourceUnavailableException {\n        // TODO Auto-generated method stub\n        return false;\n    }","commit_id":"f794abfdefe2fd4608061b0e2dd371e25092e3f1","url":"https://github.com/apache/cloudstack"},{"original_method":"protected NetworkDaoImpl() {\n        super();\n        \n        ProfileSearch = createSearchBuilder();\n        ProfileSearch.and(\"trafficType\", ProfileSearch.entity().getTrafficType(), SearchCriteria.Op.EQ);\n        ProfileSearch.and(\"cidr\", ProfileSearch.entity().getCidr(), SearchCriteria.Op.EQ);\n        ProfileSearch.and(\"broadcastType\", ProfileSearch.entity().getBroadcastDomainType(), SearchCriteria.Op.EQ);\n        ProfileSearch.and(\"offering\", ProfileSearch.entity().getNetworkOfferingId(), SearchCriteria.Op.EQ);\n        ProfileSearch.and(\"datacenter\", ProfileSearch.entity().getDataCenterId(), SearchCriteria.Op.EQ);\n        ProfileSearch.done();\n        \n        AccountSearch = createSearchBuilder();\n        AccountSearch.and(\"offering\", AccountSearch.entity().getNetworkOfferingId(), SearchCriteria.Op.EQ);\n        SearchBuilder<NetworkAccountVO> join = _accountsDao.createSearchBuilder();\n        join.and(\"account\", join.entity().getAccountId(), SearchCriteria.Op.EQ);\n        AccountSearch.join(\"accounts\", join, AccountSearch.entity().getId(), join.entity().getNetworkId(), JoinBuilder.JoinType.INNER);\n        AccountSearch.and(\"datacenter\", AccountSearch.entity().getDataCenterId(), SearchCriteria.Op.EQ);\n        AccountSearch.done();\n    \n        OfferingSearch = createSearchBuilder();\n        OfferingSearch.and(\"guesttype\", OfferingSearch.entity().getGuestType(), SearchCriteria.Op.EQ);\n        OfferingSearch.and(\"datacenter\", OfferingSearch.entity().getDataCenterId(), SearchCriteria.Op.EQ);\n        \n        RelatedConfigSearch = createSearchBuilder();\n        RelatedConfigSearch.and(\"offering\", RelatedConfigSearch.entity().getNetworkOfferingId(), SearchCriteria.Op.EQ);\n        RelatedConfigSearch.and(\"datacenter\", RelatedConfigSearch.entity().getDataCenterId(), SearchCriteria.Op.EQ);\n        SearchBuilder<NetworkAccountVO> join2 = _accountsDao.createSearchBuilder();\n        join2.and(\"account\", join2.entity().getAccountId(), SearchCriteria.Op.EQ);\n        RelatedConfigSearch.join(\"account\", join2, join2.entity().getNetworkId(), RelatedConfigSearch.entity().getId(), JoinType.INNER);\n        RelatedConfigSearch.done();\n        \n        RelatedConfigsSearch = createSearchBuilder();\n        RelatedConfigsSearch.and(\"related\", RelatedConfigsSearch.entity().getRelated(), SearchCriteria.Op.EQ);\n        RelatedConfigsSearch.done();\n        \n        \n        AccountNetworkSearch = createSearchBuilder();\n        AccountNetworkSearch.and(\"networkId\", AccountNetworkSearch.entity().getId(), SearchCriteria.Op.EQ);\n        SearchBuilder<NetworkAccountVO> mapJoin = _accountsDao.createSearchBuilder();\n        mapJoin.and(\"accountId\", mapJoin.entity().getAccountId(), SearchCriteria.Op.EQ);\n        AccountNetworkSearch.join(\"networkSearch\", mapJoin, AccountNetworkSearch.entity().getId(), mapJoin.entity().getNetworkId(), JoinBuilder.JoinType.INNER);\n        AccountNetworkSearch.done();\n        \n        _tgMacAddress = _tgs.get(\"macAddress\");\n    }","id":75429,"modified_method":"protected NetworkDaoImpl() {\n        super();\n        \n        AllFieldsSearch = createSearchBuilder();\n        AllFieldsSearch.and(\"trafficType\", AllFieldsSearch.entity().getTrafficType(), Op.EQ);\n        AllFieldsSearch.and(\"cidr\", AllFieldsSearch.entity().getCidr(), Op.EQ);\n        AllFieldsSearch.and(\"broadcastType\", AllFieldsSearch.entity().getBroadcastDomainType(), Op.EQ);\n        AllFieldsSearch.and(\"offering\", AllFieldsSearch.entity().getNetworkOfferingId(), Op.EQ);\n        AllFieldsSearch.and(\"datacenter\", AllFieldsSearch.entity().getDataCenterId(), Op.EQ);\n        AllFieldsSearch.and(\"account\", AllFieldsSearch.entity().getAccountId(), Op.EQ);\n        AllFieldsSearch.and(\"guesttype\", AllFieldsSearch.entity().getGuestType(), Op.EQ);\n        AllFieldsSearch.and(\"related\", AllFieldsSearch.entity().getRelated(), Op.EQ);\n        AllFieldsSearch.done();\n        \n        AccountSearch = createSearchBuilder();\n        AccountSearch.and(\"offering\", AccountSearch.entity().getNetworkOfferingId(), Op.EQ);\n        SearchBuilder<NetworkAccountVO> join = _accountsDao.createSearchBuilder();\n        join.and(\"account\", join.entity().getAccountId(), Op.EQ);\n        AccountSearch.join(\"accounts\", join, AccountSearch.entity().getId(), join.entity().getNetworkId(), JoinBuilder.JoinType.INNER);\n        AccountSearch.and(\"datacenter\", AccountSearch.entity().getDataCenterId(), Op.EQ);\n        AccountSearch.done();\n    \n        RelatedConfigSearch = createSearchBuilder();\n        RelatedConfigSearch.and(\"offering\", RelatedConfigSearch.entity().getNetworkOfferingId(), Op.EQ);\n        RelatedConfigSearch.and(\"datacenter\", RelatedConfigSearch.entity().getDataCenterId(), Op.EQ);\n        SearchBuilder<NetworkAccountVO> join2 = _accountsDao.createSearchBuilder();\n        join2.and(\"account\", join2.entity().getAccountId(), Op.EQ);\n        RelatedConfigSearch.join(\"account\", join2, join2.entity().getNetworkId(), RelatedConfigSearch.entity().getId(), JoinType.INNER);\n        RelatedConfigSearch.done();\n        \n        AccountNetworkSearch = createSearchBuilder();\n        AccountNetworkSearch.and(\"networkId\", AccountNetworkSearch.entity().getId(), Op.EQ);\n        SearchBuilder<NetworkAccountVO> mapJoin = _accountsDao.createSearchBuilder();\n        mapJoin.and(\"accountId\", mapJoin.entity().getAccountId(), Op.EQ);\n        AccountNetworkSearch.join(\"networkSearch\", mapJoin, AccountNetworkSearch.entity().getId(), mapJoin.entity().getNetworkId(), JoinBuilder.JoinType.INNER);\n        AccountNetworkSearch.done();\n        \n        _tgMacAddress = _tgs.get(\"macAddress\");\n    }","commit_id":"f794abfdefe2fd4608061b0e2dd371e25092e3f1","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public void addAccountToNetworkConfiguration(long configurationId, long accountId) {\n        addAccountToNetworkConfiguration(configurationId, accountId, false);\n    }","id":75430,"modified_method":"@Override\n    public void addAccountToNetwork(long configurationId, long accountId) {\n        addAccountToNetworkConfiguration(configurationId, accountId, false);\n    }","commit_id":"f794abfdefe2fd4608061b0e2dd371e25092e3f1","url":"https://github.com/apache/cloudstack"},{"original_method":"public List<NetworkVO> findBy(TrafficType trafficType, Mode mode, BroadcastDomainType broadcastType, long networkOfferingId, long dataCenterId) {\n        SearchCriteria<NetworkVO> sc = ProfileSearch.create();\n        sc.setParameters(\"trafficType\", trafficType);\n        sc.setParameters(\"broadcastType\", broadcastType);\n        sc.setParameters(\"offering\", networkOfferingId);\n        sc.setParameters(\"datacenter\", dataCenterId);\n        \n        return search(sc, null);\n    }","id":75431,"modified_method":"public List<NetworkVO> findBy(TrafficType trafficType, Mode mode, BroadcastDomainType broadcastType, long networkOfferingId, long dataCenterId) {\n        SearchCriteria<NetworkVO> sc = AllFieldsSearch.create();\n        sc.setParameters(\"trafficType\", trafficType);\n        sc.setParameters(\"broadcastType\", broadcastType);\n        sc.setParameters(\"offering\", networkOfferingId);\n        sc.setParameters(\"datacenter\", dataCenterId);\n        \n        return search(sc, null);\n    }","commit_id":"f794abfdefe2fd4608061b0e2dd371e25092e3f1","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public List<NetworkVO> getRelatedNetworkConfigurations(long related) {\n        SearchCriteria<NetworkVO> sc = RelatedConfigsSearch.create();\n        sc.setParameters(\"related\", related);\n        return search(sc, null);\n    }","id":75432,"modified_method":"@Override\n    public List<NetworkVO> getRelatedNetworks(long related) {\n        SearchCriteria<NetworkVO> sc = AllFieldsSearch.create();\n        sc.setParameters(\"related\", related);\n        return search(sc, null);\n    }","commit_id":"f794abfdefe2fd4608061b0e2dd371e25092e3f1","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public List<NetworkVO> getNetworkConfigurationsForOffering(long offeringId, long dataCenterId, long accountId) {\n        SearchCriteria<NetworkVO> sc = RelatedConfigSearch.create();\n        sc.setParameters(\"offering\", offeringId);\n        sc.setParameters(\"dc\", dataCenterId);\n        sc.setJoinParameters(\"account\", \"account\", accountId);\n        return search(sc, null);\n    }","id":75433,"modified_method":"@Override\n    public List<NetworkVO> getNetworksForOffering(long offeringId, long dataCenterId, long accountId) {\n        SearchCriteria<NetworkVO> sc = RelatedConfigSearch.create();\n        sc.setParameters(\"offering\", offeringId);\n        sc.setParameters(\"dc\", dataCenterId);\n        sc.setJoinParameters(\"account\", \"account\", accountId);\n        return search(sc, null);\n    }","commit_id":"f794abfdefe2fd4608061b0e2dd371e25092e3f1","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public List<AccountVO> getAccountsUsingNetworkConfiguration(long configurationId) {\n        SearchCriteria<AccountVO> sc = AccountsUsingNetworkConfigurationSearch.create();\n        sc.setJoinParameters(\"nc\", \"config\", configurationId);\n        return _accountDao.search(sc, null);\n    }","id":75434,"modified_method":"@Override\n    public List<AccountVO> getAccountsUsingNetwork(long networkId) {\n        SearchCriteria<AccountVO> sc = AccountsUsingNetworkSearch.create();\n        sc.setJoinParameters(\"nc\", \"config\", networkId);\n        return _accountDao.search(sc, null);\n    }","commit_id":"f794abfdefe2fd4608061b0e2dd371e25092e3f1","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public List<NetworkVO> setupNetworkConfiguration(Account owner, ServiceOfferingVO offering, DeploymentPlan plan) {\n        NetworkOfferingVO networkOffering = _networkOfferingDao.findByServiceOffering(offering);\n        return setupNetworkConfiguration(owner, networkOffering, plan, null, null, false);\n    }","id":75435,"modified_method":"@Override\n    public List<NetworkVO> setupNetwork(Account owner, ServiceOfferingVO offering, DeploymentPlan plan) {\n        NetworkOfferingVO networkOffering = _networkOfferingDao.findByServiceOffering(offering);\n        return setupNetworkConfiguration(owner, networkOffering, plan, null, null, false);\n    }","commit_id":"f794abfdefe2fd4608061b0e2dd371e25092e3f1","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override @DB\n    public Network createNetwork(CreateNetworkCmd cmd) throws InvalidParameterValueException, PermissionDeniedException{\n        Account ctxAccount = UserContext.current().getAccount();\n        Long userId = UserContext.current().getUserId();\n        Long networkOfferingId = cmd.getNetworkOfferingId();\n        Long zoneId = cmd.getZoneId();\n        String gateway = cmd.getGateway();\n        String startIP = cmd.getStartIp();\n        String endIP = cmd.getEndIp();\n        String vlanNetmask = cmd.getNetmask();\n        String cidr = null;\n        if (gateway != null && vlanNetmask != null) {\n            cidr = NetUtils.ipAndNetMaskToCidr(gateway, vlanNetmask);\n        }\n        String accountName = cmd.getAccountName();\n        Long domainId = cmd.getDomainId();\n        String vlanId = cmd.getVlan();\n        String name = cmd.getNetworkName();\n        String displayText = cmd.getDisplayText();\n        Boolean isShared = cmd.getIsShared();\n        Account owner = null;\n        \n        //Check if network offering exists\n        NetworkOfferingVO networkOffering = _networkOfferingDao.findById(networkOfferingId);\n        if (networkOffering == null || networkOffering.isSystemOnly()) {\n            throw new InvalidParameterValueException(\"Unable to find network offeirng by id \" + networkOfferingId);\n        }\n        \n        //Check if zone exists\n        if (zoneId == null || ((_dcDao.findById(zoneId)) == null)) {\n            throw new InvalidParameterValueException(\"Please specify a valid zone.\");\n        }\n        \n        //Check permissions\n        if (isAdmin(ctxAccount.getType())) {\n            if (domainId != null) {\n                if ((ctxAccount != null) && !_domainDao.isChildDomain(ctxAccount.getDomainId(), domainId)) {\n                    throw new PermissionDeniedException(\"Failed to create a newtwork, invalid domain id (\" + domainId + \") given.\");\n                }\n                if (accountName != null) {\n                    owner = _accountDao.findActiveAccount(accountName, domainId);\n                    if (owner == null) {\n                        throw new InvalidParameterValueException(\"Unable to find account \" + accountName + \" in domain \" + domainId);\n                    }\n                }\n            } else {\n                owner = ctxAccount;\n            }\n        } else {\n            owner = ctxAccount;\n        }\n        \n       //if VlanId is Direct untagged, verify if there is already network of this type in the zone\n        if (networkOffering.getGuestIpType() == GuestIpType.DirectPodBased && vlanId != null && vlanId.equalsIgnoreCase(Vlan.UNTAGGED)) {\n            SearchBuilder<NetworkVO> sb = _networkConfigDao.createSearchBuilder();\n            sb.and(\"broadcastDomainType\", sb.entity().getBroadcastDomainType(), SearchCriteria.Op.EQ);\n            sb.and(\"dataCenterId\", sb.entity().getDataCenterId(), SearchCriteria.Op.EQ);\n            \n            SearchBuilder<NetworkOfferingVO> networkSearch = _networkOfferingDao.createSearchBuilder();\n            networkSearch.and(\"guestIpType\", networkSearch.entity().getGuestIpType(), SearchCriteria.Op.EQ);\n            sb.join(\"networkSearch\", networkSearch, sb.entity().getNetworkOfferingId(), networkSearch.entity().getId(), JoinBuilder.JoinType.INNER);\n         \n            SearchCriteria<NetworkVO> sc = sb.create();\n            sc.setParameters(\"broadcastDomainType\", BroadcastDomainType.Native);\n            sc.setParameters(\"dataCenterId\", zoneId);\n            sc.setJoinParameters(\"networkSearch\", \"guestIpType\", GuestIpType.DirectPodBased);\n\n            List<NetworkVO> networks = _networkConfigDao.search(sc, null);\n            if (networks!= null && !networks.isEmpty()) {\n                throw new InvalidParameterValueException(\"Network with untagged vlan already exists for the zone \" + zoneId);\n            }\n        }\n        \n        //Regular user can create only network of Virtual type\n        if (ctxAccount.getType() == Account.ACCOUNT_TYPE_NORMAL && networkOffering.getGuestIpType() != GuestIpType.Virtual) {\n            throw new InvalidParameterValueException(\"Regular user can create only networ of type \" + GuestIpType.Virtual);\n        }\n        \n       //VlanId can be specified only when network offering supports it\n        if (ctxAccount.getType() == Account.ACCOUNT_TYPE_NORMAL && vlanId != null && !networkOffering.getSpecifyVlan()) {\n            throw new InvalidParameterValueException(\"Can't specify vlan because network offering doesn't support it\");\n        }\n       \n       Transaction txn = Transaction.currentTxn();\n       txn.start();\n       try {\n           //Create network\n           DataCenterDeployment plan = new DataCenterDeployment(zoneId, null, null, null);\n           NetworkVO userNetwork = new NetworkVO();\n           \n           //cidr should be set only when the user is admin\n           if (ctxAccount.getType() == Account.ACCOUNT_TYPE_ADMIN) {\n               if (cidr != null && gateway != null) {\n                   userNetwork.setCidr(cidr);\n                   userNetwork.setGateway(gateway);\n                   if (vlanId != null) {\n                       userNetwork.setBroadcastUri(URI.create(\"vlan://\" + vlanId));\n                       if (!vlanId.equalsIgnoreCase(Vlan.UNTAGGED)) {\n                           userNetwork.setBroadcastDomainType(BroadcastDomainType.Vlan);\n                       } else {\n                           userNetwork.setBroadcastDomainType(BroadcastDomainType.Native);\n                       }\n                   }\n               }\n           }   \n           \n           List<NetworkVO> networks = setupNetworkConfiguration(owner, networkOffering, userNetwork, plan, name, displayText, isShared);\n           Long networkId = null;\n           \n           if (networks == null || networks.isEmpty()) {\n               txn.rollback();\n               throw new CloudRuntimeException(\"Fail to create a network\");\n           } else {\n               networkId = networks.get(0).getId();\n           }\n           \n           //Don't pass owner to create vlan when network offering is of type Direct\n           if (networkOffering.getGuestIpType() == GuestIpType.Direct) {\n               owner = null;\n           }\n           \n           if (ctxAccount.getType() == Account.ACCOUNT_TYPE_ADMIN && networkOffering.getGuestIpType() == GuestIpType.Direct && startIP != null && endIP != null && gateway != null) {\n               //Create vlan ip range\n               Vlan vlan = _configMgr.createVlanAndPublicIpRange(userId, zoneId, null, startIP, endIP, gateway, vlanNetmask, false, vlanId, owner, networkId);\n               if (vlan == null) {\n                   txn.rollback();\n                   throw new CloudRuntimeException(\"Failed to create a vlan\");\n               }\n           }  \n           txn.commit();\n           return networks.get(0);\n       } catch (Exception ex) {\n           s_logger.warn(\"Unexpected exception while creating network \", ex);\n           txn.rollback();\n       } finally {\n           txn.close();\n       }\n       return null;\n    }","id":75436,"modified_method":"@Override @DB\n    public Network createNetwork(CreateNetworkCmd cmd) throws InvalidParameterValueException, PermissionDeniedException{\n        Account ctxAccount = UserContext.current().getAccount();\n        Long userId = UserContext.current().getUserId();\n        Long networkOfferingId = cmd.getNetworkOfferingId();\n        Long zoneId = cmd.getZoneId();\n        String gateway = cmd.getGateway();\n        String startIP = cmd.getStartIp();\n        String endIP = cmd.getEndIp();\n        String vlanNetmask = cmd.getNetmask();\n        String cidr = null;\n        if (gateway != null && vlanNetmask != null) {\n            cidr = NetUtils.ipAndNetMaskToCidr(gateway, vlanNetmask);\n        }\n        String accountName = cmd.getAccountName();\n        Long domainId = cmd.getDomainId();\n        String vlanId = cmd.getVlan();\n        String name = cmd.getNetworkName();\n        String displayText = cmd.getDisplayText();\n        Boolean isShared = cmd.getIsShared();\n        Account owner = null;\n        \n        //Check if network offering exists\n        NetworkOfferingVO networkOffering = _networkOfferingDao.findById(networkOfferingId);\n        if (networkOffering == null || networkOffering.isSystemOnly()) {\n            throw new InvalidParameterValueException(\"Unable to find network offeirng by id \" + networkOfferingId);\n        }\n        \n        //Check if zone exists\n        if (zoneId == null || ((_dcDao.findById(zoneId)) == null)) {\n            throw new InvalidParameterValueException(\"Please specify a valid zone.\");\n        }\n        \n        //Check permissions\n        if (isAdmin(ctxAccount.getType())) {\n            if (domainId != null) {\n                if ((ctxAccount != null) && !_domainDao.isChildDomain(ctxAccount.getDomainId(), domainId)) {\n                    throw new PermissionDeniedException(\"Failed to create a newtwork, invalid domain id (\" + domainId + \") given.\");\n                }\n                if (accountName != null) {\n                    owner = _accountDao.findActiveAccount(accountName, domainId);\n                    if (owner == null) {\n                        throw new InvalidParameterValueException(\"Unable to find account \" + accountName + \" in domain \" + domainId);\n                    }\n                }\n            } else {\n                owner = ctxAccount;\n            }\n        } else {\n            owner = ctxAccount;\n        }\n        \n       //if VlanId is Direct untagged, verify if there is already network of this type in the zone\n        if (networkOffering.getGuestIpType() == GuestIpType.DirectPodBased && vlanId != null && vlanId.equalsIgnoreCase(Vlan.UNTAGGED)) {\n            SearchBuilder<NetworkVO> sb = _networksDao.createSearchBuilder();\n            sb.and(\"broadcastDomainType\", sb.entity().getBroadcastDomainType(), SearchCriteria.Op.EQ);\n            sb.and(\"dataCenterId\", sb.entity().getDataCenterId(), SearchCriteria.Op.EQ);\n            \n            SearchBuilder<NetworkOfferingVO> networkSearch = _networkOfferingDao.createSearchBuilder();\n            networkSearch.and(\"guestIpType\", networkSearch.entity().getGuestIpType(), SearchCriteria.Op.EQ);\n            sb.join(\"networkSearch\", networkSearch, sb.entity().getNetworkOfferingId(), networkSearch.entity().getId(), JoinBuilder.JoinType.INNER);\n         \n            SearchCriteria<NetworkVO> sc = sb.create();\n            sc.setParameters(\"broadcastDomainType\", BroadcastDomainType.Native);\n            sc.setParameters(\"dataCenterId\", zoneId);\n            sc.setJoinParameters(\"networkSearch\", \"guestIpType\", GuestIpType.DirectPodBased);\n\n            List<NetworkVO> networks = _networksDao.search(sc, null);\n            if (networks!= null && !networks.isEmpty()) {\n                throw new InvalidParameterValueException(\"Network with untagged vlan already exists for the zone \" + zoneId);\n            }\n        }\n        \n        //Regular user can create only network of Virtual type\n        if (ctxAccount.getType() == Account.ACCOUNT_TYPE_NORMAL && networkOffering.getGuestIpType() != GuestIpType.Virtual) {\n            throw new InvalidParameterValueException(\"Regular user can create only networ of type \" + GuestIpType.Virtual);\n        }\n        \n       //VlanId can be specified only when network offering supports it\n        if (ctxAccount.getType() == Account.ACCOUNT_TYPE_NORMAL && vlanId != null && !networkOffering.getSpecifyVlan()) {\n            throw new InvalidParameterValueException(\"Can't specify vlan because network offering doesn't support it\");\n        }\n       \n       Transaction txn = Transaction.currentTxn();\n       txn.start();\n       try {\n           //Create network\n           DataCenterDeployment plan = new DataCenterDeployment(zoneId, null, null, null);\n           NetworkVO userNetwork = new NetworkVO();\n           \n           //cidr should be set only when the user is admin\n           if (ctxAccount.getType() == Account.ACCOUNT_TYPE_ADMIN) {\n               if (cidr != null && gateway != null) {\n                   userNetwork.setCidr(cidr);\n                   userNetwork.setGateway(gateway);\n                   if (vlanId != null) {\n                       userNetwork.setBroadcastUri(URI.create(\"vlan://\" + vlanId));\n                       if (!vlanId.equalsIgnoreCase(Vlan.UNTAGGED)) {\n                           userNetwork.setBroadcastDomainType(BroadcastDomainType.Vlan);\n                       } else {\n                           userNetwork.setBroadcastDomainType(BroadcastDomainType.Native);\n                       }\n                   }\n               }\n           }   \n           \n           List<NetworkVO> networks = setupNetwork(owner, networkOffering, userNetwork, plan, name, displayText, isShared);\n           Long networkId = null;\n           \n           if (networks == null || networks.isEmpty()) {\n               txn.rollback();\n               throw new CloudRuntimeException(\"Fail to create a network\");\n           } else {\n               networkId = networks.get(0).getId();\n           }\n           \n           //Don't pass owner to create vlan when network offering is of type Direct\n           if (networkOffering.getGuestIpType() == GuestIpType.Direct) {\n               owner = null;\n           }\n           \n           if (ctxAccount.getType() == Account.ACCOUNT_TYPE_ADMIN && networkOffering.getGuestIpType() == GuestIpType.Direct && startIP != null && endIP != null && gateway != null) {\n               //Create vlan ip range\n               Vlan vlan = _configMgr.createVlanAndPublicIpRange(userId, zoneId, null, startIP, endIP, gateway, vlanNetmask, false, vlanId, owner, networkId);\n               if (vlan == null) {\n                   txn.rollback();\n                   throw new CloudRuntimeException(\"Failed to create a vlan\");\n               }\n           }  \n           txn.commit();\n           return networks.get(0);\n       } catch (Exception ex) {\n           s_logger.warn(\"Unexpected exception while creating network \", ex);\n           txn.rollback();\n       } finally {\n           txn.close();\n       }\n       return null;\n    }","commit_id":"f794abfdefe2fd4608061b0e2dd371e25092e3f1","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public AccountVO getNetworkConfigurationOwner(long configurationId) {\n        SearchCriteria<AccountVO> sc = AccountsUsingNetworkConfigurationSearch.create();\n        sc.setJoinParameters(\"nc\", \"config\", configurationId);\n        sc.setJoinParameters(\"nc\", \"owner\", true);\n        List<AccountVO> accounts = _accountDao.search(sc, null);\n        return accounts.size() != 0 ? accounts.get(0) : null;\n    }","id":75437,"modified_method":"@Override\n    public AccountVO getNetworkOwner(long networkId) {\n        SearchCriteria<AccountVO> sc = AccountsUsingNetworkSearch.create();\n        sc.setJoinParameters(\"nc\", \"config\", networkId);\n        sc.setJoinParameters(\"nc\", \"owner\", true);\n        List<AccountVO> accounts = _accountDao.search(sc, null);\n        return accounts.size() != 0 ? accounts.get(0) : null;\n    }","commit_id":"f794abfdefe2fd4608061b0e2dd371e25092e3f1","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public List<NetworkVO> setupNetworkConfiguration(Account owner, NetworkOfferingVO offering, Network predefined, DeploymentPlan plan, String name, String displayText, boolean isShared) {\n        \n        List<NetworkVO> configs = _networkConfigDao.listBy(owner.getId(), offering.getId(), plan.getDataCenterId());\n        if (predefined == null || (predefined.getBroadcastUri() == null && predefined.getBroadcastDomainType() != BroadcastDomainType.Vlan)) {\n            if (configs.size() > 0) {\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"Found existing network configuration for offering \" + offering + \": \" + configs.get(0));\n                }\n                return configs;\n            }\n        }\n\n        configs = new ArrayList<NetworkVO>();\n\n        long related = -1;\n\n        for (NetworkGuru guru : _networkGurus) {\n            Network config = guru.design(offering, plan, predefined, owner);\n            if (config == null) {\n                continue;\n            }\n\n            if (config.getId() != -1) {\n                if (config instanceof NetworkVO) {\n                    configs.add((NetworkVO)config);\n                } else {\n                    configs.add(_networkConfigDao.findById(config.getId()));\n                }\n                continue;\n            }\n\n            long id = _networkConfigDao.getNextInSequence(Long.class, \"id\");\n            if (related == -1) {\n                related = id;\n            } \n\n            NetworkVO vo = new NetworkVO(id, config, offering.getId(), plan.getDataCenterId(), guru.getName(), owner.getDomainId(), owner.getId(), related, name, displayText, isShared);\n            configs.add(_networkConfigDao.persist(vo));\n        }\n\n        if (configs.size() < 1) {\n            throw new CloudRuntimeException(\"Unable to convert network offering to network profile: \" + offering.getId());\n        }\n\n        return configs;\n    }","id":75438,"modified_method":"@Override\n    public List<NetworkVO> setupNetworkConfiguration(Account owner, NetworkOfferingVO offering, Network predefined, DeploymentPlan plan, String name, String displayText, boolean isShared) {\n        \n        List<NetworkVO> configs = _networkConfigDao.listBy(owner.getId(), offering.getId(), plan.getDataCenterId());\n        if (predefined == null || (predefined.getBroadcastUri() == null && predefined.getBroadcastDomainType() != BroadcastDomainType.Vlan)) {\n            if (configs.size() > 0) {\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"Found existing network configuration for offering \" + offering + \": \" + configs.get(0));\n                }\n                return configs;\n            }\n        }\n\n        configs = new ArrayList<NetworkVO>();\n\n        long related = -1;\n\n        for (NetworkGuru guru : _networkGurus) {\n            Network config = guru.design(offering, plan, predefined, owner);\n            if (config == null) {\n                continue;\n            }\n\n            if (config.getId() != -1) {\n                if (config instanceof NetworkVO) {\n                    configs.add((NetworkVO)config);\n                } else {\n                    configs.add(_networksDao.findById(config.getId()));\n                }\n                continue;\n            }\n\n            long id = _networksDao.getNextInSequence(Long.class, \"id\");\n            if (related == -1) {\n                related = id;\n            } \n\n            NetworkVO vo = new NetworkVO(id, config, offering.getId(), plan.getDataCenterId(), guru.getName(), owner.getDomainId(), owner.getId(), related, name, displayText, isShared);\n            configs.add(_networksDao.persist(vo));\n        }\n\n        if (configs.size() < 1) {\n            throw new CloudRuntimeException(\"Unable to convert network offering to network profile: \" + offering.getId());\n        }\n\n        return configs;\n    }","commit_id":"f794abfdefe2fd4608061b0e2dd371e25092e3f1","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public boolean releasePublicIpAddress(String ipAddress, long ownerId, long userId) {\n        IPAddressVO ip = _ipAddressDao.markAsUnavailable(ipAddress, ownerId);\n        assert (ip != null) : \"Unable to mark the ip address \" + ipAddress + \" owned by \" + ownerId + \" as unavailable.\";\n        if (ip == null) {\n            return true;\n        }\n        \n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Releasing ip \" + ipAddress + \"; sourceNat = \" + ip.isSourceNat());\n        }\n        \n        Ip addr = new Ip(ip.getAddress());\n\n        boolean success = true;\n        try {\n            if (!_rulesMgr.revokeAllRules(addr, userId)) {\n                s_logger.warn(\"Unable to revoke all the port forwarding rules for ip \" + ip);\n                success = false;\n            }\n        } catch (ResourceUnavailableException e) {\n            s_logger.warn(\"Unable to revoke all the port forwarding rules for ip \" + ip, e);\n            success = false;\n        }\n        \n        if (!_lbMgr.removeAllLoadBalanacers(addr)) {\n            s_logger.warn(\"Unable to revoke all the load balancer rules for ip \" + ip);\n            success = false;\n        }\n        \n        for (NetworkElement ne : _networkElements) {\n            try {\n                ne.disassociate(null, new Ip(ipAddress));\n            } catch (ResourceUnavailableException e) {\n                s_logger.warn(\"Unable to release the ip address \" + ip, e);\n                success = false;\n            }\n        }\n        \n        if (success) {\n            _ipAddressDao.unassignIpAddress(ipAddress);\n            s_logger.debug(\"released a public ip: \" + ipAddress);\n        }\n        \n        final EventVO event = new EventVO();\n        event.setUserId(userId);\n        event.setAccountId(ip.getAllocatedToAccountId());\n        event.setType(EventTypes.EVENT_NET_IP_RELEASE);\n        event.setParameters(\"address=\" + ipAddress + \"\\nsourceNat=\"+ip.isSourceNat());\n        event.setDescription(\"released a public ip: \" + ipAddress);\n        _eventDao.persist(event);\n        \n        return success;\n    }","id":75439,"modified_method":"@Override\n    public boolean releasePublicIpAddress(String ipAddress, long ownerId, long userId) {\n        IPAddressVO ip = _ipAddressDao.markAsUnavailable(ipAddress, ownerId);\n        assert (ip != null) : \"Unable to mark the ip address \" + ipAddress + \" owned by \" + ownerId + \" as unavailable.\";\n        if (ip == null) {\n            return true;\n        }\n        \n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Releasing ip \" + ipAddress + \"; sourceNat = \" + ip.isSourceNat());\n        }\n        \n        Ip addr = new Ip(ip.getAddress());\n\n        boolean success = true;\n        try {\n            if (!_rulesMgr.revokeAllRules(addr, userId)) {\n                s_logger.warn(\"Unable to revoke all the port forwarding rules for ip \" + ip);\n                success = false;\n            }\n        } catch (ResourceUnavailableException e) {\n            s_logger.warn(\"Unable to revoke all the port forwarding rules for ip \" + ip, e);\n            success = false;\n        }\n        \n        if (!_lbMgr.removeAllLoadBalanacers(addr)) {\n            s_logger.warn(\"Unable to revoke all the load balancer rules for ip \" + ip);\n            success = false;\n        }\n        \n        for (NetworkElement ne : _networkElements) {\n            try {\n                ne.disassociate(null, ip);\n            } catch (ResourceUnavailableException e) {\n                s_logger.warn(\"Unable to release the ip address \" + ip, e);\n                success = false;\n            }\n        }\n        \n        if (success) {\n            _ipAddressDao.unassignIpAddress(ipAddress);\n            s_logger.debug(\"released a public ip: \" + ipAddress);\n        }\n        \n        final EventVO event = new EventVO();\n        event.setUserId(userId);\n        event.setAccountId(ip.getAllocatedToAccountId());\n        event.setType(EventTypes.EVENT_NET_IP_RELEASE);\n        event.setParameters(\"address=\" + ipAddress + \"\\nsourceNat=\"+ip.isSourceNat());\n        event.setDescription(\"released a public ip: \" + ipAddress);\n        _eventDao.persist(event);\n        \n        return success;\n    }","commit_id":"f794abfdefe2fd4608061b0e2dd371e25092e3f1","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override @DB\n    public IPAddressVO associateIP(AssociateIPAddrCmd cmd) throws ResourceAllocationException, InsufficientAddressCapacityException, ConcurrentOperationException  {\n        String accountName = cmd.getAccountName();\n        Long domainId = cmd.getDomainId();\n        Long zoneId = cmd.getZoneId();\n        Account account = UserContext.current().getAccount();\n        Long userId = UserContext.current().getUserId();\n        Long accountId = null;\n\n        if ((account == null) || isAdmin(account.getType())) {\n            if (domainId != null) {\n                if ((account != null) && !_domainDao.isChildDomain(account.getDomainId(), domainId)) {\n                    throw new PermissionDeniedException(\"Invalid domain id (\" + domainId + \") given, unable to associate IP address, permission denied\");\n                }\n                if (accountName != null) {\n                    Account userAccount = _accountDao.findActiveAccount(accountName, domainId);\n                    if (userAccount != null) {\n                        accountId = userAccount.getId();\n                    } else {\n                        throw new PermissionDeniedException(\"Unable to find account \" + accountName + \" in domain \" + domainId + \", permission denied\");\n                    }\n                }\n            } else if (account != null) {\n                // the admin is acquiring an IP address\n                accountId = account.getId();\n                domainId = account.getDomainId();\n            } else {\n                throw new InvalidParameterValueException(\"Account information is not specified.\");\n            }\n        } else {\n            accountId = account.getId();\n            domainId = account.getDomainId();\n        }\n\n        if (userId == null) {\n            userId = Long.valueOf(1);\n        }\n\n\n        Transaction txn = Transaction.currentTxn();\n        Account accountToLock = null;\n        try {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Associate IP address called for user \" + userId + \" account \" + accountId);\n            }\n            accountToLock = _accountDao.acquireInLockTable(accountId);\n\n            if (accountToLock == null) {\n                s_logger.warn(\"Unable to lock account: \" + accountId);\n                throw new ConcurrentOperationException(\"Unable to acquire account lock\");\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Associate IP address lock acquired\");\n            }\n\n            // Check that the maximum number of public IPs for the given\n            // accountId will not be exceeded\n            if (_accountMgr.resourceLimitExceeded(accountToLock, ResourceType.public_ip)) {\n                ResourceAllocationException rae = new ResourceAllocationException(\"Maximum number of public IP addresses for account: \" + accountToLock.getAccountName()\n                        + \" has been exceeded.\");\n                rae.setResourceType(\"ip\");\n                throw rae;\n            }\n\n            DomainRouterVO router = _routerMgr.getRouter(accountId, zoneId);\n            if (router == null) {\n                throw new InvalidParameterValueException(\"No router found for account: \" + accountToLock.getAccountName() + \". Please create a VM before acquiring an IP\");\n            }\n\n            txn.start();\n\n            String ipAddress = null;\n            Pair<String, VlanVO> ipAndVlan = null;//FIXME d_vlanDao.assignIpAddress(zoneId, accountId, domainId, VlanType.VirtualNetwork, false);\n\n            if (ipAndVlan == null) {\n                throw new InsufficientAddressCapacityException(\"Unable to find available public IP addresses\", DataCenter.class, zoneId);\n            } else {\n                ipAddress = ipAndVlan.first();\n                _accountMgr.incrementResourceCount(accountId, ResourceType.public_ip);\n            }\n\n            boolean success = true;\n            String errorMsg = \"\";\n\n            List<String> ipAddrs = new ArrayList<String>();\n            ipAddrs.add(ipAddress);\n\n            if (router.getState() == State.Running) {\n                success = associateIP(router, ipAddress, true, 0L);\n                if (!success) {\n                    errorMsg = \"Unable to assign public IP address.\";\n                }\n            }\n\n            EventVO event = new EventVO();\n            event.setUserId(userId);\n            event.setAccountId(accountId);\n            event.setType(EventTypes.EVENT_NET_IP_ASSIGN);\n            event.setParameters(\"address=\" + ipAddress + \"\\nsourceNat=\" + false + \"\\ndcId=\" + zoneId);\n\n            if (!success) {\n                _ipAddressDao.unassignIpAddress(ipAddress);\n                ipAddress = null;\n                _accountMgr.decrementResourceCount(accountId, ResourceType.public_ip);\n\n                event.setLevel(EventVO.LEVEL_ERROR);\n                event.setDescription(errorMsg);\n                _eventDao.persist(event);\n                txn.commit();\n\n                throw new CloudRuntimeException(errorMsg);\n            } else {\n                event.setDescription(\"Assigned a public IP address: \" + ipAddress);\n                _eventDao.persist(event);\n            }\n\n            txn.commit();\n            IPAddressVO ip = _ipAddressDao.findById(ipAddress);\n\n            return ip;\n        } catch (ResourceAllocationException rae) {\n            s_logger.error(\"Associate IP threw a ResourceAllocationException.\", rae);\n            throw rae;\n        } catch (InsufficientAddressCapacityException iace) {\n            s_logger.error(\"Associate IP threw an InsufficientAddressCapacityException.\", iace);\n            throw iace;\n        } catch (InvalidParameterValueException ipve) {\n            s_logger.error(\"Associate IP threw an InvalidParameterValueException.\", ipve);\n            throw ipve;\n        } finally {\n            if (account != null) {\n                _accountDao.releaseFromLockTable(accountId);\n                s_logger.debug(\"Associate IP address lock released\");\n            }\n        }\n\n    }","id":75440,"modified_method":"@Override @DB\n    public IpAddress associateIP(AssociateIPAddrCmd cmd) throws ResourceAllocationException, InsufficientAddressCapacityException, ConcurrentOperationException  {\n        String accountName = cmd.getAccountName();\n        long domainId = cmd.getDomainId();\n        Long zoneId = cmd.getZoneId();\n        Account caller = UserContext.current().getAccount();\n        long userId = UserContext.current().getUserId();\n        Long accountId = null;\n\n        Account owner = _accountDao.findActiveAccount(accountName, domainId);\n        if (owner == null) {\n            throw new InvalidParameterValueException(\"Unable to find account \" + accountName + \" in domain \" + domainId + \", permission denied\");\n        }\n        \n        _accountMgr.checkAccess(caller, owner);\n        \n        Long networkId = cmd.getNetworkId();\n        Network network = null;\n        if (networkId != null) {\n            network = _networksDao.findById(networkId);\n            if (network == null) {\n                throw new InvalidParameterValueException(\"Network id is invalid: \" + networkId);\n            }\n        }\n\n        EventVO event = new EventVO();\n        event.setUserId(userId);\n        event.setAccountId(accountId);\n        event.setType(EventTypes.EVENT_NET_IP_ASSIGN);\n\n        PublicIp ip = null;\n        boolean success = false;\n        \n        Transaction txn = Transaction.currentTxn();\n        Account accountToLock = null;\n        try {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Associate IP address called for user \" + userId + \" account \" + accountId);\n            }\n            accountToLock = _accountDao.acquireInLockTable(accountId);\n            if (accountToLock == null) {\n                s_logger.warn(\"Unable to lock account: \" + accountId);\n                throw new ConcurrentOperationException(\"Unable to acquire account lock\");\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Associate IP address lock acquired\");\n            }\n\n            // Check that the maximum number of public IPs for the given\n            // accountId will not be exceeded\n            if (_accountMgr.resourceLimitExceeded(accountToLock, ResourceType.public_ip)) {\n                ResourceAllocationException rae = new ResourceAllocationException(\"Maximum number of public IP addresses for account: \" + accountToLock.getAccountName() + \" has been exceeded.\");\n                rae.setResourceType(\"ip\");\n                throw rae;\n            }\n\n            txn.start();\n\n            ip = fetchNewPublicIp(zoneId, VlanType.VirtualNetwork, owner, false);\n            if (ip == null) {\n                throw new InsufficientAddressCapacityException(\"Unable to find available public IP addresses\", DataCenter.class, zoneId);\n            } \n            _accountMgr.incrementResourceCount(accountId, ResourceType.public_ip);\n\n            String ipAddress = ip.getAddress();\n            \n            event.setParameters(\"address=\" + ipAddress + \"\\nsourceNat=\" + false + \"\\ndcId=\" + zoneId);\n            event.setDescription(\"Assigned a public IP address: \" + ipAddress);\n            _eventDao.persist(event);\n\n            txn.commit();\n            if (network != null) {\n                for (NetworkElement element : _networkElements) {\n                    element.associate(network, ip);\n                }\n            }\n            \n            success = true;\n            \n            return ip;\n        } catch (ResourceUnavailableException e) {\n            s_logger.error(\"Unable to associate ip address due to resource unavailable exception\", e);\n            return null;\n        } finally {\n            if (caller != null) {\n                _accountDao.releaseFromLockTable(accountId);\n                s_logger.debug(\"Associate IP address lock released\");\n            }\n            \n            if (!success) {\n                if (ip != null) {\n                    Transaction.currentTxn();\n                    txn.start();\n                    _ipAddressDao.unassignIpAddress(ip.getAddress());\n                    _accountMgr.decrementResourceCount(accountId, ResourceType.public_ip);\n\n                    event.setLevel(EventVO.LEVEL_ERROR);\n                    event.setDescription(\"\");\n                    _eventDao.persist(event);\n                    txn.commit();\n                }\n            }\n        }\n    }","commit_id":"f794abfdefe2fd4608061b0e2dd371e25092e3f1","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public boolean configure(final String name, final Map<String, Object> params) throws ConfigurationException {\n        _name = name;\n\n        _configs = _configDao.getConfiguration(\"AgentManager\", params);\n        validateRemoteAccessVpnConfiguration();\n        Integer rateMbps = getIntegerConfigValue(Config.NetworkThrottlingRate.key(), null);  \n        Integer multicastRateMbps = getIntegerConfigValue(Config.MulticastThrottlingRate.key(), null);\n\n\n        NetworkOfferingVO publicNetworkOffering = new NetworkOfferingVO(NetworkOfferingVO.SystemVmPublicNetwork, TrafficType.Public, null);\n        publicNetworkOffering = _networkOfferingDao.persistDefaultNetworkOffering(publicNetworkOffering);\n        _systemNetworks.put(NetworkOfferingVO.SystemVmPublicNetwork, publicNetworkOffering);\n        NetworkOfferingVO managementNetworkOffering = new NetworkOfferingVO(NetworkOfferingVO.SystemVmManagementNetwork, TrafficType.Management, null);\n        managementNetworkOffering = _networkOfferingDao.persistDefaultNetworkOffering(managementNetworkOffering);\n        _systemNetworks.put(NetworkOfferingVO.SystemVmManagementNetwork, managementNetworkOffering);\n        NetworkOfferingVO controlNetworkOffering = new NetworkOfferingVO(NetworkOfferingVO.SystemVmControlNetwork, TrafficType.Control, null);\n        controlNetworkOffering = _networkOfferingDao.persistDefaultNetworkOffering(controlNetworkOffering);\n        _systemNetworks.put(NetworkOfferingVO.SystemVmControlNetwork, controlNetworkOffering);\n        //        NetworkOfferingVO guestNetworkOffering = new NetworkOfferingVO(NetworkOfferingVO.SystemVmGuestNetwork, TrafficType.Guest, GuestIpType.Virtualized);\n        //        guestNetworkOffering = _networkOfferingDao.persistSystemNetworkOffering(guestNetworkOffering);\n        //        _systemNetworks.put(NetworkOfferingVO.SystemVmGuestNetwork, guestNetworkOffering);\n        NetworkOfferingVO storageNetworkOffering = new NetworkOfferingVO(NetworkOfferingVO.SystemVmStorageNetwork, TrafficType.Storage, null);\n        storageNetworkOffering = _networkOfferingDao.persistDefaultNetworkOffering(storageNetworkOffering);\n        _systemNetworks.put(NetworkOfferingVO.SystemVmStorageNetwork, storageNetworkOffering);\n\n        NetworkOfferingVO defaultGuestNetworkOffering = new NetworkOfferingVO(NetworkOffering.DefaultVirtualizedNetworkOffering, \"Virtual Vlan\", TrafficType.Guest, GuestIpType.Virtual, false, false, rateMbps, multicastRateMbps, null, true);\n        defaultGuestNetworkOffering = _networkOfferingDao.persistDefaultNetworkOffering(defaultGuestNetworkOffering);\n        NetworkOfferingVO defaultGuestDirectNetworkOffering = new NetworkOfferingVO(NetworkOffering.DefaultDirectNetworkOffering, \"Direct\", TrafficType.Guest, GuestIpType.Direct, false, false, rateMbps, multicastRateMbps, null, true);\n        defaultGuestNetworkOffering = _networkOfferingDao.persistDefaultNetworkOffering(defaultGuestDirectNetworkOffering);\n        NetworkOfferingVO defaultGuestDirectPodBasedNetworkOffering = new NetworkOfferingVO(NetworkOffering.DefaultDirectPodBasedNetworkOffering, \"DirectPodBased\", TrafficType.Guest, GuestIpType.DirectPodBased, true, false, rateMbps, multicastRateMbps, null, true);\n        defaultGuestNetworkOffering = _networkOfferingDao.persistDefaultNetworkOffering(defaultGuestDirectPodBasedNetworkOffering);\n        \n\n        AccountsUsingNetworkConfigurationSearch = _accountDao.createSearchBuilder();\n        SearchBuilder<NetworkAccountVO> networkAccountSearch = _networkConfigDao.createSearchBuilderForAccount();\n        AccountsUsingNetworkConfigurationSearch.join(\"nc\", networkAccountSearch, AccountsUsingNetworkConfigurationSearch.entity().getId(), networkAccountSearch.entity().getAccountId(), JoinType.INNER);\n        networkAccountSearch.and(\"config\", networkAccountSearch.entity().getNetworkId(), SearchCriteria.Op.EQ);\n        networkAccountSearch.and(\"owner\", networkAccountSearch.entity().isOwner(), SearchCriteria.Op.EQ);\n        AccountsUsingNetworkConfigurationSearch.done();\n        \n        AssignIpAddressSearch = _ipAddressDao.createSearchBuilder();\n        SearchBuilder<VlanVO> vlanSearch = _vlanDao.createSearchBuilder();\n        AssignIpAddressSearch.and(\"dc\", AssignIpAddressSearch.entity().getDataCenterId(), Op.EQ);\n        AssignIpAddressSearch.and(\"allocated\", AssignIpAddressSearch.entity().getAllocatedTime(), Op.NULL);\n        AssignIpAddressSearch.join(\"vlan\", vlanSearch, vlanSearch.entity().getId(), AssignIpAddressSearch.entity().getVlanId(), JoinType.INNER);\n        vlanSearch.and(\"type\", vlanSearch.entity().getVlanType(), Op.EQ);\n        AssignIpAddressSearch.done();\n        \n        IpAddressSearch = _ipAddressDao.createSearchBuilder();\n        IpAddressSearch.and(\"accountId\", IpAddressSearch.entity().getAllocatedToAccountId(), Op.EQ);\n        IpAddressSearch.and(\"dataCenterId\", IpAddressSearch.entity().getDataCenterId(), Op.EQ);\n        SearchBuilder<VlanVO> virtualNetworkVlanSB = _vlanDao.createSearchBuilder();\n        virtualNetworkVlanSB.and(\"vlanType\", virtualNetworkVlanSB.entity().getVlanType(), Op.EQ);\n        IpAddressSearch.join(\"virtualNetworkVlanSB\", virtualNetworkVlanSB, IpAddressSearch.entity().getVlanId(), virtualNetworkVlanSB.entity().getId(), JoinBuilder.JoinType.INNER);\n        IpAddressSearch.done();\n\n        s_logger.info(\"Network Manager is configured.\");\n\n        return true;\n    }","id":75441,"modified_method":"@Override\n    public boolean configure(final String name, final Map<String, Object> params) throws ConfigurationException {\n        _name = name;\n\n        _configs = _configDao.getConfiguration(\"AgentManager\", params);\n        validateRemoteAccessVpnConfiguration();\n        Integer rateMbps = getIntegerConfigValue(Config.NetworkThrottlingRate.key(), null);  \n        Integer multicastRateMbps = getIntegerConfigValue(Config.MulticastThrottlingRate.key(), null);\n\n\n        NetworkOfferingVO publicNetworkOffering = new NetworkOfferingVO(NetworkOfferingVO.SystemVmPublicNetwork, TrafficType.Public, null);\n        publicNetworkOffering = _networkOfferingDao.persistDefaultNetworkOffering(publicNetworkOffering);\n        _systemNetworks.put(NetworkOfferingVO.SystemVmPublicNetwork, publicNetworkOffering);\n        NetworkOfferingVO managementNetworkOffering = new NetworkOfferingVO(NetworkOfferingVO.SystemVmManagementNetwork, TrafficType.Management, null);\n        managementNetworkOffering = _networkOfferingDao.persistDefaultNetworkOffering(managementNetworkOffering);\n        _systemNetworks.put(NetworkOfferingVO.SystemVmManagementNetwork, managementNetworkOffering);\n        NetworkOfferingVO controlNetworkOffering = new NetworkOfferingVO(NetworkOfferingVO.SystemVmControlNetwork, TrafficType.Control, null);\n        controlNetworkOffering = _networkOfferingDao.persistDefaultNetworkOffering(controlNetworkOffering);\n        _systemNetworks.put(NetworkOfferingVO.SystemVmControlNetwork, controlNetworkOffering);\n        //        NetworkOfferingVO guestNetworkOffering = new NetworkOfferingVO(NetworkOfferingVO.SystemVmGuestNetwork, TrafficType.Guest, GuestIpType.Virtualized);\n        //        guestNetworkOffering = _networkOfferingDao.persistSystemNetworkOffering(guestNetworkOffering);\n        //        _systemNetworks.put(NetworkOfferingVO.SystemVmGuestNetwork, guestNetworkOffering);\n        NetworkOfferingVO storageNetworkOffering = new NetworkOfferingVO(NetworkOfferingVO.SystemVmStorageNetwork, TrafficType.Storage, null);\n        storageNetworkOffering = _networkOfferingDao.persistDefaultNetworkOffering(storageNetworkOffering);\n        _systemNetworks.put(NetworkOfferingVO.SystemVmStorageNetwork, storageNetworkOffering);\n\n        NetworkOfferingVO defaultGuestNetworkOffering = new NetworkOfferingVO(NetworkOffering.DefaultVirtualizedNetworkOffering, \"Virtual Vlan\", TrafficType.Guest, GuestIpType.Virtual, false, false, rateMbps, multicastRateMbps, null, true);\n        defaultGuestNetworkOffering = _networkOfferingDao.persistDefaultNetworkOffering(defaultGuestNetworkOffering);\n        NetworkOfferingVO defaultGuestDirectNetworkOffering = new NetworkOfferingVO(NetworkOffering.DefaultDirectNetworkOffering, \"Direct\", TrafficType.Guest, GuestIpType.Direct, false, false, rateMbps, multicastRateMbps, null, true);\n        defaultGuestNetworkOffering = _networkOfferingDao.persistDefaultNetworkOffering(defaultGuestDirectNetworkOffering);\n        NetworkOfferingVO defaultGuestDirectPodBasedNetworkOffering = new NetworkOfferingVO(NetworkOffering.DefaultDirectPodBasedNetworkOffering, \"DirectPodBased\", TrafficType.Guest, GuestIpType.DirectPodBased, true, false, rateMbps, multicastRateMbps, null, true);\n        defaultGuestNetworkOffering = _networkOfferingDao.persistDefaultNetworkOffering(defaultGuestDirectPodBasedNetworkOffering);\n        \n\n        AccountsUsingNetworkSearch = _accountDao.createSearchBuilder();\n        SearchBuilder<NetworkAccountVO> networkAccountSearch = _networksDao.createSearchBuilderForAccount();\n        AccountsUsingNetworkSearch.join(\"nc\", networkAccountSearch, AccountsUsingNetworkSearch.entity().getId(), networkAccountSearch.entity().getAccountId(), JoinType.INNER);\n        networkAccountSearch.and(\"config\", networkAccountSearch.entity().getNetworkId(), SearchCriteria.Op.EQ);\n        networkAccountSearch.and(\"owner\", networkAccountSearch.entity().isOwner(), SearchCriteria.Op.EQ);\n        AccountsUsingNetworkSearch.done();\n        \n        AssignIpAddressSearch = _ipAddressDao.createSearchBuilder();\n        SearchBuilder<VlanVO> vlanSearch = _vlanDao.createSearchBuilder();\n        AssignIpAddressSearch.and(\"dc\", AssignIpAddressSearch.entity().getDataCenterId(), Op.EQ);\n        AssignIpAddressSearch.and(\"allocated\", AssignIpAddressSearch.entity().getAllocatedTime(), Op.NULL);\n        AssignIpAddressSearch.join(\"vlan\", vlanSearch, vlanSearch.entity().getId(), AssignIpAddressSearch.entity().getVlanId(), JoinType.INNER);\n        vlanSearch.and(\"type\", vlanSearch.entity().getVlanType(), Op.EQ);\n        AssignIpAddressSearch.done();\n        \n        IpAddressSearch = _ipAddressDao.createSearchBuilder();\n        IpAddressSearch.and(\"accountId\", IpAddressSearch.entity().getAllocatedToAccountId(), Op.EQ);\n        IpAddressSearch.and(\"dataCenterId\", IpAddressSearch.entity().getDataCenterId(), Op.EQ);\n        SearchBuilder<VlanVO> virtualNetworkVlanSB = _vlanDao.createSearchBuilder();\n        virtualNetworkVlanSB.and(\"vlanType\", virtualNetworkVlanSB.entity().getVlanType(), Op.EQ);\n        IpAddressSearch.join(\"virtualNetworkVlanSB\", virtualNetworkVlanSB, IpAddressSearch.entity().getVlanId(), virtualNetworkVlanSB.entity().getId(), JoinBuilder.JoinType.INNER);\n        IpAddressSearch.done();\n\n        s_logger.info(\"Network Manager is configured.\");\n\n        return true;\n    }","commit_id":"f794abfdefe2fd4608061b0e2dd371e25092e3f1","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public void release(VirtualMachineProfile<? extends VMInstanceVO> vmProfile) {\n        List<NicVO> nics = _nicDao.listBy(vmProfile.getId());\n        for (NicVO nic : nics) {\n            NetworkVO config = _networkConfigDao.findById(nic.getNetworkId());\n            if (nic.getReservationStrategy() == ReservationStrategy.Start) {\n                NetworkGuru concierge = _networkGurus.get(config.getGuruName());\n                nic.setState(Resource.State.Releasing);\n                _nicDao.update(nic.getId(), nic);\n                NicProfile profile = new NicProfile(nic, config, null, null);\n                if (!concierge.release(profile, vmProfile, nic.getReservationId())) {\n                    nic.setState(Resource.State.Allocated);\n                    _nicDao.update(nic.getId(), nic);\n                }\n            }\n        }\n    }","id":75442,"modified_method":"@Override\n    public void release(VirtualMachineProfile<? extends VMInstanceVO> vmProfile) {\n        List<NicVO> nics = _nicDao.listBy(vmProfile.getId());\n        for (NicVO nic : nics) {\n            NetworkVO config = _networksDao.findById(nic.getNetworkId());\n            if (nic.getReservationStrategy() == ReservationStrategy.Start) {\n                NetworkGuru concierge = _networkGurus.get(config.getGuruName());\n                nic.setState(Resource.State.Releasing);\n                _nicDao.update(nic.getId(), nic);\n                NicProfile profile = new NicProfile(nic, config, null, null);\n                if (!concierge.release(profile, vmProfile, nic.getReservationId())) {\n                    nic.setState(Resource.State.Allocated);\n                    _nicDao.update(nic.getId(), nic);\n                }\n            }\n        }\n    }","commit_id":"f794abfdefe2fd4608061b0e2dd371e25092e3f1","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override @DB\n    public Network getNetwork(long id) {\n        return _networkConfigDao.findById(id);\n    }","id":75443,"modified_method":"@Override @DB\n    public Network getNetwork(long id) {\n        return _networksDao.findById(id);\n    }","commit_id":"f794abfdefe2fd4608061b0e2dd371e25092e3f1","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public String getNextAvailableMacAddressInNetwork(long networkConfigurationId) throws InsufficientAddressCapacityException {\n        String mac = _networkConfigDao.getNextAvailableMacAddress(networkConfigurationId);\n        if (mac == null) {\n            throw new InsufficientAddressCapacityException(\"Unable to create another mac address\", Network.class, networkConfigurationId);\n        }\n        return mac;\n    }","id":75444,"modified_method":"@Override\n    public String getNextAvailableMacAddressInNetwork(long networkId) throws InsufficientAddressCapacityException {\n        String mac = _networksDao.getNextAvailableMacAddress(networkId);\n        if (mac == null) {\n            throw new InsufficientAddressCapacityException(\"Unable to create another mac address\", Network.class, networkId);\n        }\n        return mac;\n    }","commit_id":"f794abfdefe2fd4608061b0e2dd371e25092e3f1","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public List<NetworkVO> getNetworkConfigurationsforOffering(long offeringId, long dataCenterId, long accountId) {\n        return _networkConfigDao.getNetworkConfigurationsForOffering(offeringId, dataCenterId, accountId);\n    }","id":75445,"modified_method":"@Override\n    public List<NetworkVO> getNetworksforOffering(long offeringId, long dataCenterId, long accountId) {\n        return _networksDao.getNetworksForOffering(offeringId, dataCenterId, accountId);\n    }","commit_id":"f794abfdefe2fd4608061b0e2dd371e25092e3f1","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override @DB\n    public boolean deleteNetwork(DeleteNetworkCmd cmd) throws InvalidParameterValueException, PermissionDeniedException{        \n        Long networkId = cmd.getId();\n        Long userId = UserContext.current().getUserId();\n        Account account = UserContext.current().getAccount();\n\n        //Verify network id\n        NetworkVO network = _networkConfigDao.findById(networkId);\n        if (network == null) {\n            throw new InvalidParameterValueException(\"unable to find network \" + networkId);\n        } \n        \n        //Perform permission check\n        if (account != null) {\n            if (!isAdmin(account.getType())) {\n                if (network.getAccountId() != account.getId()) {\n                    throw new PermissionDeniedException(\"Account \" + account.getAccountName() + \" does not own network id=\" + networkId + \", permission denied\");\n                }\n            } else if (!(account.getType() == Account.ACCOUNT_TYPE_ADMIN) && !_domainDao.isChildDomain(account.getDomainId(), _accountDao.findById(network.getAccountId()).getId())) {\n                throw new PermissionDeniedException(\"Unable to delete network \" + networkId + \", permission denied.\");\n            }\n        }\n        \n        //Don't allow to remove network if there are non-destroyed vms using it\n        List<NicVO> nics = _nicDao.listByNetworkId(networkId);\n        for (NicVO nic : nics) {\n            UserVm vm = _vmDao.findById(nic.getId());\n            if (vm != null && (vm.getState() != State.Destroyed || vm.getState() != State.Expunging || vm.getState() != State.Error)) {\n                throw new CloudRuntimeException(\"Can't delete a network; make sure that all vms using the network are destroyed\");\n            }\n        }\n        \n        //for regular user don't allow to remove network when it's in any other states but allocated\n        if (account.getType() != Account.ACCOUNT_TYPE_ADMIN) {\n            if (network.getState() != Network.State.Allocated) {\n                throw new InvalidParameterValueException(\"Non-admin user can delete network in \" + Network.State.Allocated + \" state only.\");\n            }    \n        } else {\n            if (!(network.getState() == Network.State.Allocated || network.getState() == Network.State.Setup)) {\n                throw new InvalidParameterValueException(\"Can delete network in \" + Network.State.Allocated + \" and \" + Network.State.Setup + \" states only.\");\n            }    \n        }\n        \n        //remove all the vlans associated with the network\n        Transaction txn = Transaction.currentTxn();\n        try {\n            //remove corresponding vlans\n            List<VlanVO> vlans = _vlanDao.listVlansByNetworkId(networkId);\n            for (VlanVO vlan : vlans) {\n                boolean result = _configMgr.deleteVlanAndPublicIpRange(userId, vlan.getId());\n                if (result == false) {\n                    txn.rollback();\n                    throw new CloudRuntimeException(\"Unable to delete a network: failed to delete corresponding vlan with id \" + vlan.getId());\n                }\n            }\n            \n            //remove networks\n            _networkConfigDao.remove(networkId);\n            \n            txn.commit();\n            return true;\n        } catch (Exception ex) {\n            txn.rollback();\n            s_logger.warn(\"Unexpected exception during deleting a network \", ex);\n            return false;\n        } finally {\n            txn.close();\n        }\n        \n    }","id":75446,"modified_method":"@Override @DB\n    public boolean deleteNetwork(DeleteNetworkCmd cmd) throws InvalidParameterValueException, PermissionDeniedException{        \n        Long networkId = cmd.getId();\n        Long userId = UserContext.current().getUserId();\n        Account account = UserContext.current().getAccount();\n\n        //Verify network id\n        NetworkVO network = _networksDao.findById(networkId);\n        if (network == null) {\n            throw new InvalidParameterValueException(\"unable to find network \" + networkId);\n        } \n        \n        //Perform permission check\n        if (account != null) {\n            if (!isAdmin(account.getType())) {\n                if (network.getAccountId() != account.getId()) {\n                    throw new PermissionDeniedException(\"Account \" + account.getAccountName() + \" does not own network id=\" + networkId + \", permission denied\");\n                }\n            } else if (!(account.getType() == Account.ACCOUNT_TYPE_ADMIN) && !_domainDao.isChildDomain(account.getDomainId(), _accountDao.findById(network.getAccountId()).getId())) {\n                throw new PermissionDeniedException(\"Unable to delete network \" + networkId + \", permission denied.\");\n            }\n        }\n        \n        //Don't allow to remove network if there are non-destroyed vms using it\n        List<NicVO> nics = _nicDao.listByNetworkId(networkId);\n        for (NicVO nic : nics) {\n            UserVm vm = _vmDao.findById(nic.getId());\n            if (vm != null && (vm.getState() != State.Destroyed || vm.getState() != State.Expunging || vm.getState() != State.Error)) {\n                throw new CloudRuntimeException(\"Can't delete a network; make sure that all vms using the network are destroyed\");\n            }\n        }\n        \n        //for regular user don't allow to remove network when it's in any other states but allocated\n        if (account.getType() != Account.ACCOUNT_TYPE_ADMIN) {\n            if (network.getState() != Network.State.Allocated) {\n                throw new InvalidParameterValueException(\"Non-admin user can delete network in \" + Network.State.Allocated + \" state only.\");\n            }    \n        } else {\n            if (!(network.getState() == Network.State.Allocated || network.getState() == Network.State.Setup)) {\n                throw new InvalidParameterValueException(\"Can delete network in \" + Network.State.Allocated + \" and \" + Network.State.Setup + \" states only.\");\n            }    \n        }\n        \n        //remove all the vlans associated with the network\n        Transaction txn = Transaction.currentTxn();\n        try {\n            //remove corresponding vlans\n            List<VlanVO> vlans = _vlanDao.listVlansByNetworkId(networkId);\n            for (VlanVO vlan : vlans) {\n                boolean result = _configMgr.deleteVlanAndPublicIpRange(userId, vlan.getId());\n                if (result == false) {\n                    txn.rollback();\n                    throw new CloudRuntimeException(\"Unable to delete a network: failed to delete corresponding vlan with id \" + vlan.getId());\n                }\n            }\n            \n            //remove networks\n            _networksDao.remove(networkId);\n            \n            txn.commit();\n            return true;\n        } catch (Exception ex) {\n            txn.rollback();\n            s_logger.warn(\"Unexpected exception during deleting a network \", ex);\n            return false;\n        } finally {\n            txn.close();\n        }\n        \n    }","commit_id":"f794abfdefe2fd4608061b0e2dd371e25092e3f1","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public List<NetworkVO> setupNetworkConfiguration(Account owner, NetworkOfferingVO offering, DeploymentPlan plan, String name, String displayText, boolean isShared) {\n        return setupNetworkConfiguration(owner, offering, null, plan, name, displayText, isShared);\n    }","id":75447,"modified_method":"@Override\n    public List<NetworkVO> setupNetworkConfiguration(Account owner, NetworkOfferingVO offering, DeploymentPlan plan, String name, String displayText, boolean isShared) {\n        return setupNetwork(owner, offering, null, plan, name, displayText, isShared);\n    }","commit_id":"f794abfdefe2fd4608061b0e2dd371e25092e3f1","url":"https://github.com/apache/cloudstack"},{"original_method":"@DB\n    protected Pair<NetworkGuru, NetworkVO> implementNetworkConfiguration(long configId, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientAddressCapacityException {\n        Transaction.currentTxn();\n        Pair<NetworkGuru, NetworkVO> implemented = new Pair<NetworkGuru, NetworkVO>(null, null);\n\n        NetworkVO config = _networkConfigDao.acquireInLockTable(configId);\n        if (config == null) {\n            throw new ConcurrentOperationException(\"Unable to acquire network configuration: \" + configId);\n        }\n\n        try {\n            NetworkGuru guru = _networkGurus.get(config.getGuruName());\n            Network.State state = config.getState();\n            if (state == Network.State.Implemented || state == Network.State.Setup) {\n                if (state == Network.State.Setup) {\n                    config.setState(Network.State.Implemented);\n                    _networkConfigDao.update(configId, config);\n                }\n                implemented.set(guru, config);\n                return implemented;\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Asking \" + guru + \" to implement \" + config);\n            }\n\n            NetworkOfferingVO offering = _networkOfferingDao.findById(config.getNetworkOfferingId());\n\n            Network result = guru.implement(config, offering, dest, context);\n            config.setCidr(result.getCidr());\n            config.setBroadcastUri(result.getBroadcastUri());\n            config.setGateway(result.getGateway());\n            config.setDns1(result.getDns1());\n            config.setDns2(result.getDns2());\n            config.setMode(result.getMode());\n            config.setState(Network.State.Implemented);\n            _networkConfigDao.update(configId, config);\n\n            for (NetworkElement element : _networkElements) {\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"Asking \" + element.getName() + \" to implmenet \" + config);\n                }\n                try {\n                    element.implement(config, offering, dest, context);\n                } catch (InsufficientCapacityException e) {\n                    throw new ResourceUnavailableException(\"Unable to start domain router for this VM\", e);\n                }\n            }\n\n            implemented.set(guru, config);\n            return implemented;\n        } finally {\n            if (implemented.first() == null) {\n                s_logger.debug(\"Cleaning up because we're unable to implement network \" + config);\n            }\n            _networkConfigDao.releaseFromLockTable(configId);\n        }\n    }","id":75448,"modified_method":"@DB\n    protected Pair<NetworkGuru, NetworkVO> implementNetwork(long networkId, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientAddressCapacityException {\n        Transaction.currentTxn();\n        Pair<NetworkGuru, NetworkVO> implemented = new Pair<NetworkGuru, NetworkVO>(null, null);\n\n        NetworkVO config = _networksDao.acquireInLockTable(networkId);\n        if (config == null) {\n            throw new ConcurrentOperationException(\"Unable to acquire network configuration: \" + networkId);\n        }\n\n        try {\n            NetworkGuru guru = _networkGurus.get(config.getGuruName());\n            Network.State state = config.getState();\n            if (state == Network.State.Implemented || state == Network.State.Setup) {\n                if (state == Network.State.Setup) {\n                    config.setState(Network.State.Implemented);\n                    _networkConfigDao.update(configId, config);\n                }\n                implemented.set(guru, config);\n                return implemented;\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Asking \" + guru + \" to implement \" + config);\n            }\n\n            NetworkOfferingVO offering = _networkOfferingDao.findById(config.getNetworkOfferingId());\n\n            Network result = guru.implement(config, offering, dest, context);\n            config.setCidr(result.getCidr());\n            config.setBroadcastUri(result.getBroadcastUri());\n            config.setGateway(result.getGateway());\n            config.setDns1(result.getDns1());\n            config.setDns2(result.getDns2());\n            config.setMode(result.getMode());\n            config.setState(Network.State.Implemented);\n            _networksDao.update(networkId, config);\n\n            for (NetworkElement element : _networkElements) {\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"Asking \" + element.getName() + \" to implmenet \" + config);\n                }\n                try {\n                    element.implement(config, offering, dest, context);\n                } catch (InsufficientCapacityException e) {\n                    throw new ResourceUnavailableException(\"Unable to start domain router for this VM\", e);\n                }\n            }\n\n            implemented.set(guru, config);\n            return implemented;\n        } finally {\n            if (implemented.first() == null) {\n                s_logger.debug(\"Cleaning up because we're unable to implement network \" + config);\n            }\n            _networksDao.releaseFromLockTable(networkId);\n        }\n    }","commit_id":"f794abfdefe2fd4608061b0e2dd371e25092e3f1","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public boolean applyRules(Ip ip, List<? extends FirewallRule> rules, boolean continueOnError) throws ResourceUnavailableException {\n        if (rules.size() == 0) {\n            s_logger.debug(\"There are no rules to forward to the network elements\");\n            return true;\n        }\n        \n        boolean success = true;\n        Network network = _networkConfigDao.findById(rules.get(0).getNetworkId());\n        for (NetworkElement ne : _networkElements) {\n            try {\n                boolean handled = ne.applyRules(network, rules);\n                s_logger.debug(\"Network Rules for \" + ip + \" were \" + (handled ? \"\" : \" not\") + \" handled by \" + ne.getName());\n            } catch (ResourceUnavailableException e) {\n                if (!continueOnError) {\n                    throw e;\n                }\n                s_logger.warn(\"Problems with \" + ne.getName() + \" but pushing on\", e);\n                success = false;\n            }\n        }\n        \n        return success;\n    }","id":75449,"modified_method":"@Override\n    public boolean applyRules(Ip ip, List<? extends FirewallRule> rules, boolean continueOnError) throws ResourceUnavailableException {\n        if (rules.size() == 0) {\n            s_logger.debug(\"There are no rules to forward to the network elements\");\n            return true;\n        }\n        \n        boolean success = true;\n        Network network = _networksDao.findById(rules.get(0).getNetworkId());\n        for (NetworkElement ne : _networkElements) {\n            try {\n                boolean handled = ne.applyRules(network, rules);\n                s_logger.debug(\"Network Rules for \" + ip + \" were \" + (handled ? \"\" : \" not\") + \" handled by \" + ne.getName());\n            } catch (ResourceUnavailableException e) {\n                if (!continueOnError) {\n                    throw e;\n                }\n                s_logger.warn(\"Problems with \" + ne.getName() + \" but pushing on\", e);\n                success = false;\n            }\n        }\n        \n        return success;\n    }","commit_id":"f794abfdefe2fd4608061b0e2dd371e25092e3f1","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public List<? extends Network> searchForNetworks(ListNetworksCmd cmd) { \n        Object id = cmd.getId(); \n        Object keyword = cmd.getKeyword();\n        Long zoneId= cmd.getZoneId();\n        Account account = UserContext.current().getAccount();\n        Long domainId = cmd.getDomainId();\n        String accountName = cmd.getAccountName();\n        String type = cmd.getType();\n        Boolean isSystem = cmd.getIsSystem();\n        Long accountId = null;\n        \n        if (isSystem == null) {\n            isSystem = false;\n        }\n        \n        if (isAdmin(account.getType())) {\n            if (domainId != null) {\n                if ((account != null) && !_domainDao.isChildDomain(account.getDomainId(), domainId)) {\n                    throw new PermissionDeniedException(\"Invalid domain id (\" + domainId + \") given, unable to list networks\");\n                }\n\n                if (accountName != null) {\n                    account = _accountDao.findActiveAccount(accountName, domainId);\n                    if (account == null) {\n                        throw new InvalidParameterValueException(\"Unable to find account \" + accountName + \" in domain \" + domainId);\n                    }\n                    accountId = account.getId();\n                }\n            } else {\n                accountId = account.getId();\n            }\n        } else {\n            accountId = account.getId();\n        }\n        \n        Filter searchFilter = new Filter(NetworkVO.class, \"id\", false, cmd.getStartIndex(), cmd.getPageSizeVal());\n        SearchBuilder<NetworkVO> sb = _networkConfigDao.createSearchBuilder();\n        \n        //Don't display networks created of system network offerings\n        SearchBuilder<NetworkOfferingVO> networkOfferingSearch  = _networkOfferingDao.createSearchBuilder();\n        networkOfferingSearch.and(\"systemOnly\", networkOfferingSearch.entity().isSystemOnly(), SearchCriteria.Op.EQ);\n        if (isSystem) {\n            networkOfferingSearch.and(\"trafficType\", networkOfferingSearch.entity().getTrafficType(), SearchCriteria.Op.EQ);\n        } \n        sb.join(\"networkOfferingSearch\", networkOfferingSearch, sb.entity().getNetworkOfferingId(), networkOfferingSearch.entity().getId(), JoinBuilder.JoinType.INNER); \n        \n        SearchBuilder<DataCenterVO> zoneSearch  = _dcDao.createSearchBuilder();\n        zoneSearch.and(\"networkType\", zoneSearch.entity().getNetworkType(), SearchCriteria.Op.EQ);\n        sb.join(\"zoneSearch\", zoneSearch, sb.entity().getDataCenterId(), zoneSearch.entity().getId(), JoinBuilder.JoinType.INNER);\n      \n        SearchCriteria<NetworkVO> sc = sb.create();\n        \n        if (!isSystem) {\n            sc.setJoinParameters(\"networkOfferingSearch\", \"systemOnly\", false);\n        } else {\n            sc.setJoinParameters(\"networkOfferingSearch\", \"systemOnly\", true);\n            sc.setJoinParameters(\"networkOfferingSearch\", \"trafficType\", TrafficType.Public);\n            sc.setJoinParameters(\"zoneSearch\", \"networkType\", NetworkType.Advanced.toString());\n        }\n        \n        if (keyword != null) {\n            SearchCriteria<NetworkVO> ssc = _networkConfigDao.createSearchCriteria();\n            ssc.addOr(\"name\", SearchCriteria.Op.LIKE, \"%\" + keyword + \"%\");\n            sc.addAnd(\"name\", SearchCriteria.Op.SC, ssc);\n        } \n\n        if (id != null) {\n            sc.addAnd(\"id\", SearchCriteria.Op.EQ, id);\n        }\n        \n        if (zoneId != null) {\n            sc.addAnd(\"dataCenterId\", SearchCriteria.Op.EQ, zoneId);\n        }\n        \n        if (type != null) {\n            sc.addAnd(\"guestType\", SearchCriteria.Op.EQ, type);\n        }\n        \n        SearchCriteria<NetworkVO> ssc = _networkConfigDao.createSearchCriteria();\n        ssc.addOr(\"accountId\", SearchCriteria.Op.EQ, accountId);\n        if (accountName == null && domainId == null) {\n            ssc.addOr(\"accountId\", SearchCriteria.Op.EQ, 1L);\n        }\n        sc.addAnd(\"accountId\", SearchCriteria.Op.SC, ssc);\n        \n        return _networkConfigDao.search(sc, searchFilter);\n    }","id":75450,"modified_method":"@Override\n    public List<? extends Network> searchForNetworks(ListNetworksCmd cmd) { \n        Object id = cmd.getId(); \n        Object keyword = cmd.getKeyword();\n        Long zoneId= cmd.getZoneId();\n        Account account = UserContext.current().getAccount();\n        Long domainId = cmd.getDomainId();\n        String accountName = cmd.getAccountName();\n        String type = cmd.getType();\n        Boolean isSystem = cmd.getIsSystem();\n        Long accountId = null;\n        \n        if (isSystem == null) {\n            isSystem = false;\n        }\n        \n        if (isAdmin(account.getType())) {\n            if (domainId != null) {\n                if ((account != null) && !_domainDao.isChildDomain(account.getDomainId(), domainId)) {\n                    throw new PermissionDeniedException(\"Invalid domain id (\" + domainId + \") given, unable to list networks\");\n                }\n\n                if (accountName != null) {\n                    account = _accountDao.findActiveAccount(accountName, domainId);\n                    if (account == null) {\n                        throw new InvalidParameterValueException(\"Unable to find account \" + accountName + \" in domain \" + domainId);\n                    }\n                    accountId = account.getId();\n                }\n            } else {\n                accountId = account.getId();\n            }\n        } else {\n            accountId = account.getId();\n        }\n        \n        Filter searchFilter = new Filter(NetworkVO.class, \"id\", false, cmd.getStartIndex(), cmd.getPageSizeVal());\n        SearchBuilder<NetworkVO> sb = _networksDao.createSearchBuilder();\n        \n        //Don't display networks created of system network offerings\n        SearchBuilder<NetworkOfferingVO> networkOfferingSearch  = _networkOfferingDao.createSearchBuilder();\n        networkOfferingSearch.and(\"systemOnly\", networkOfferingSearch.entity().isSystemOnly(), SearchCriteria.Op.EQ);\n        if (isSystem) {\n            networkOfferingSearch.and(\"trafficType\", networkOfferingSearch.entity().getTrafficType(), SearchCriteria.Op.EQ);\n        } \n        sb.join(\"networkOfferingSearch\", networkOfferingSearch, sb.entity().getNetworkOfferingId(), networkOfferingSearch.entity().getId(), JoinBuilder.JoinType.INNER); \n        \n        SearchBuilder<DataCenterVO> zoneSearch  = _dcDao.createSearchBuilder();\n        zoneSearch.and(\"networkType\", zoneSearch.entity().getNetworkType(), SearchCriteria.Op.EQ);\n        sb.join(\"zoneSearch\", zoneSearch, sb.entity().getDataCenterId(), zoneSearch.entity().getId(), JoinBuilder.JoinType.INNER);\n      \n        SearchCriteria<NetworkVO> sc = sb.create();\n        \n        if (!isSystem) {\n            sc.setJoinParameters(\"networkOfferingSearch\", \"systemOnly\", false);\n        } else {\n            sc.setJoinParameters(\"networkOfferingSearch\", \"systemOnly\", true);\n            sc.setJoinParameters(\"networkOfferingSearch\", \"trafficType\", TrafficType.Public);\n            sc.setJoinParameters(\"zoneSearch\", \"networkType\", NetworkType.Advanced.toString());\n        }\n        \n        if (keyword != null) {\n            SearchCriteria<NetworkVO> ssc = _networksDao.createSearchCriteria();\n            ssc.addOr(\"name\", SearchCriteria.Op.LIKE, \"%\" + keyword + \"%\");\n            sc.addAnd(\"name\", SearchCriteria.Op.SC, ssc);\n        } \n\n        if (id != null) {\n            sc.addAnd(\"id\", SearchCriteria.Op.EQ, id);\n        }\n        \n        if (zoneId != null) {\n            sc.addAnd(\"dataCenterId\", SearchCriteria.Op.EQ, zoneId);\n        }\n        \n        if (type != null) {\n            sc.addAnd(\"guestType\", SearchCriteria.Op.EQ, type);\n        }\n        \n        SearchCriteria<NetworkVO> ssc = _networksDao.createSearchCriteria();\n        ssc.addOr(\"accountId\", SearchCriteria.Op.EQ, accountId);\n        if (accountName == null && domainId == null) {\n            ssc.addOr(\"accountId\", SearchCriteria.Op.EQ, 1L);\n        }\n        sc.addAnd(\"accountId\", SearchCriteria.Op.SC, ssc);\n        \n        return _networksDao.search(sc, searchFilter);\n    }","commit_id":"f794abfdefe2fd4608061b0e2dd371e25092e3f1","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public void prepare(VirtualMachineProfile<? extends VMInstanceVO> vmProfile, DeployDestination dest, ReservationContext context) throws InsufficientNetworkCapacityException, ConcurrentOperationException, ResourceUnavailableException {\n        List<NicVO> nics = _nicDao.listBy(vmProfile.getId());\n        for (NicVO nic : nics) {\n            Pair<NetworkGuru, NetworkVO> implemented = implementNetworkConfiguration(nic.getNetworkId(), dest, context);\n            NetworkGuru concierge = implemented.first();\n            NetworkVO config = implemented.second();\n            NicProfile profile = null;\n            if (nic.getReservationStrategy() == ReservationStrategy.Start) {\n                nic.setState(Resource.State.Reserving);\n                _nicDao.update(nic.getId(), nic);\n                URI broadcastUri = nic.getBroadcastUri();\n                if (broadcastUri == null) {\n                    config.getBroadcastUri();\n                }\n\n                URI isolationUri = nic.getIsolationUri();\n\n                profile = new NicProfile(nic, config, broadcastUri, isolationUri);\n                concierge.reserve(profile, config, vmProfile, dest, context);\n                nic.setIp4Address(profile.getIp4Address());\n                nic.setIp6Address(profile.getIp6Address());\n                nic.setMacAddress(profile.getMacAddress());\n                nic.setIsolationUri(profile.getIsolationUri());\n                nic.setBroadcastUri(profile.getBroadCastUri());\n                nic.setReserver(concierge.getName());\n                nic.setState(Resource.State.Reserved);\n                nic.setNetmask(profile.getNetmask());\n                nic.setGateway(profile.getGateway());\n                nic.setAddressFormat(profile.getFormat());\n                _nicDao.update(nic.getId(), nic);\n                for (NetworkElement element : _networkElements) {\n                    if (s_logger.isDebugEnabled()) {\n                        s_logger.debug(\"Asking \" + element.getName() + \" to prepare for \" + nic);\n                    }\n                    element.prepare(config, profile, vmProfile, dest, context);\n                }\n            } else {\n                profile = new NicProfile(nic, config, nic.getBroadcastUri(), nic.getIsolationUri());\n            }\n\n            vmProfile.addNic(profile);\n        }\n    }","id":75451,"modified_method":"@Override\n    public void prepare(VirtualMachineProfile<? extends VMInstanceVO> vmProfile, DeployDestination dest, ReservationContext context) throws InsufficientNetworkCapacityException, ConcurrentOperationException, ResourceUnavailableException {\n        List<NicVO> nics = _nicDao.listBy(vmProfile.getId());\n        for (NicVO nic : nics) {\n            Pair<NetworkGuru, NetworkVO> implemented = implementNetwork(nic.getNetworkId(), dest, context);\n            NetworkGuru concierge = implemented.first();\n            NetworkVO config = implemented.second();\n            NicProfile profile = null;\n            if (nic.getReservationStrategy() == ReservationStrategy.Start) {\n                nic.setState(Resource.State.Reserving);\n                _nicDao.update(nic.getId(), nic);\n                URI broadcastUri = nic.getBroadcastUri();\n                if (broadcastUri == null) {\n                    config.getBroadcastUri();\n                }\n\n                URI isolationUri = nic.getIsolationUri();\n\n                profile = new NicProfile(nic, config, broadcastUri, isolationUri);\n                concierge.reserve(profile, config, vmProfile, dest, context);\n                nic.setIp4Address(profile.getIp4Address());\n                nic.setIp6Address(profile.getIp6Address());\n                nic.setMacAddress(profile.getMacAddress());\n                nic.setIsolationUri(profile.getIsolationUri());\n                nic.setBroadcastUri(profile.getBroadCastUri());\n                nic.setReserver(concierge.getName());\n                nic.setState(Resource.State.Reserved);\n                nic.setNetmask(profile.getNetmask());\n                nic.setGateway(profile.getGateway());\n                nic.setAddressFormat(profile.getFormat());\n                _nicDao.update(nic.getId(), nic);\n                for (NetworkElement element : _networkElements) {\n                    if (s_logger.isDebugEnabled()) {\n                        s_logger.debug(\"Asking \" + element.getName() + \" to prepare for \" + nic);\n                    }\n                    element.prepare(config, profile, vmProfile, dest, context);\n                }\n            } else {\n                profile = new NicProfile(nic, config, nic.getBroadcastUri(), nic.getIsolationUri());\n            }\n\n            vmProfile.addNic(profile);\n        }\n    }","commit_id":"f794abfdefe2fd4608061b0e2dd371e25092e3f1","url":"https://github.com/apache/cloudstack"},{"original_method":"private boolean processClosureClassMembers(@NotNull PsiScopeProcessor processor,\n                                             @NotNull ResolveState state,\n                                             @Nullable PsiElement lastParent,\n                                             @NotNull PsiElement place) {\n    final PsiClass closureClass = GroovyPsiManager.getInstance(getProject()).findClassWithCache(GROOVY_LANG_CLOSURE, getResolveScope());\n    if (closureClass != null) {\n      if (!closureClass.processDeclarations(processor, state, lastParent, place)) return false;\n\n      if (place instanceof GroovyPsiElement) {\n        GrClosureType closureType = GrClosureType.create(this, false /*if it is 'true' need-to-prevent-recursion triggers*/);\n        if (!ResolveUtil.processNonCodeMembers(closureType, processor, place, state)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }","id":75452,"modified_method":"private boolean processClosureClassMembers(@NotNull PsiScopeProcessor processor,\n                                             @NotNull ResolveState state,\n                                             @Nullable PsiElement lastParent,\n                                             @NotNull PsiElement place) {\n    final PsiClass closureClass = GroovyPsiManager.getInstance(getProject()).findClassWithCache(GROOVY_LANG_CLOSURE, getResolveScope());\n    if (closureClass == null) return true;\n\n    return closureClass.processDeclarations(processor, state, lastParent, place);\n  }","commit_id":"9cdbee87e98a880f79f67d8da82e62177de2be5e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static boolean processScopeNonCodeMethods(PsiElement place, PsiElement lastParent, PsiScopeProcessor processor, PsiElement scope) {\n    if (scope instanceof GrTypeDefinition) {\n      if (!processNonCodeMembers(createPsiType((GrTypeDefinition)scope), processor, place, ResolveState.initial())) return false;\n\n      //@Category(CategoryType)\n      //class Scope {...}\n      PsiClassType categoryType = GdkMethodUtil.getCategoryType((PsiClass)scope);\n      if (categoryType != null) {\n        if (!processNonCodeMembers(categoryType, processor, place, ResolveState.initial())) return false;\n      }\n\n    }\n\n    if (scope instanceof GroovyFileBase && ((GroovyFileBase)scope).isScript()) {\n      final PsiClass psiClass = ((GroovyFileBase)scope).getScriptClass();\n      if (psiClass != null) {\n        if (!processNonCodeMembers(createPsiType(psiClass), processor, place, ResolveState.initial())) return false;\n      }\n    }\n\n    if (scope instanceof GrClosableBlock) {\n      PsiClass superClass = getLiteralSuperClass((GrClosableBlock)scope);\n      if (superClass != null && !superClass.processDeclarations(processor, ResolveState.initial(), null, place)) return false;\n\n      if (!GdkMethodUtil.categoryIteration((GrClosableBlock)scope, processor, ResolveState.initial())) return false;\n      if (!processNonCodeMembers(TypesUtil.createType(GroovyCommonClassNames.GROOVY_LANG_CLOSURE, place), processor, place, ResolveState.initial())) return false;\n    }\n\n    if (scope instanceof GrStatementOwner) {\n      if (!GdkMethodUtil.processMixinToMetaclass((GrStatementOwner)scope, processor, ResolveState.initial(), lastParent, place)) return false;\n    }\n\n    return true;\n  }","id":75453,"modified_method":"static boolean processScopeNonCodeMethods(PsiElement place, PsiElement lastParent, PsiScopeProcessor processor, PsiElement scope) {\n    if (scope instanceof GrTypeDefinition) {\n      if (!processNonCodeMembers(createPsiType((GrTypeDefinition)scope), processor, place, ResolveState.initial())) return false;\n\n      //@Category(CategoryType)\n      //class Scope {...}\n      PsiClassType categoryType = GdkMethodUtil.getCategoryType((PsiClass)scope);\n      if (categoryType != null) {\n        if (!processNonCodeMembers(categoryType, processor, place, ResolveState.initial())) return false;\n      }\n\n    }\n\n    if (scope instanceof GroovyFileBase && ((GroovyFileBase)scope).isScript()) {\n      final PsiClass psiClass = ((GroovyFileBase)scope).getScriptClass();\n      if (psiClass != null) {\n        if (!processNonCodeMembers(createPsiType(psiClass), processor, place, ResolveState.initial())) return false;\n      }\n    }\n\n    if (scope instanceof GrClosableBlock) {\n      ResolveState state = ResolveState.initial().put(ResolverProcessor.RESOLVE_CONTEXT, scope);\n\n      PsiClass superClass = getLiteralSuperClass((GrClosableBlock)scope);\n      if (superClass != null && !superClass.processDeclarations(processor, state, null, place)) return false;\n\n      if (!GdkMethodUtil.categoryIteration((GrClosableBlock)scope, processor, state)) return false;\n      if (!processNonCodeMembers(GrClosureType.create(((GrClosableBlock)scope), false), processor, place, state)) return false;\n    }\n\n    if (scope instanceof GrStatementOwner) {\n      if (!GdkMethodUtil.processMixinToMetaclass((GrStatementOwner)scope, processor, ResolveState.initial(), lastParent, place)) return false;\n    }\n\n    return true;\n  }","commit_id":"9cdbee87e98a880f79f67d8da82e62177de2be5e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public abstract boolean processMembers(GrClosableBlock closure, PsiScopeProcessor processor, GrReferenceExpression ref, ResolveState state);","id":75454,"modified_method":"public abstract boolean processMembers(GrClosableBlock closure, PsiScopeProcessor processor, GrReferenceExpression refExpr, ResolveState state);","commit_id":"88f44ba2e50c7b0904bc690391016b06611b6841","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static Object[] getVariantsImpl(GrReferenceExpression refExpr, ResolverProcessor processor) {\n    GrExpression qualifier = refExpr.getQualifierExpression();\n    String[] sameQualifier = getVariantsWithSameQualifier(qualifier, refExpr);\n    if (qualifier == null) {\n      ResolveUtil.treeWalkUp(refExpr, processor, true);\n      qualifier = PsiImplUtil.getRuntimeQualifier(refExpr);\n      if (qualifier != null) {\n        getVariantsFromQualifier(refExpr, processor, qualifier);\n      }\n    }\n    else {\n      if (refExpr.getDotTokenType() != GroovyTokenTypes.mSPREAD_DOT) {\n        getVariantsFromQualifier(refExpr, processor, qualifier);\n\n        if (qualifier instanceof GrReferenceExpression && \"class\".equals(((GrReferenceExpression)qualifier).getReferenceName())) {\n          processIfJavaLangClass(refExpr, processor, qualifier.getType());\n        }\n        else if (qualifier instanceof GrThisReferenceExpression) {\n          processIfJavaLangClass(refExpr, processor, qualifier.getType());\n        }\n      }\n      else {\n        getVariantsFromQualifierForSpreadOperator(refExpr, processor, qualifier);\n      }\n    }\n\n    GroovyResolveResult[] candidates = processor.getCandidates();\n    if (candidates.length == 0 && sameQualifier.length == 0) return PsiNamedElement.EMPTY_ARRAY;\n    candidates = filterStaticsOK(candidates);\n    if (qualifier == null) {\n      List<GroovyResolveResult> nonPackages = ContainerUtil.findAll(candidates, new Condition<GroovyResolveResult>() {\n        public boolean value(final GroovyResolveResult result) {\n          return !(result.getElement() instanceof PsiPackage);\n        }\n      });\n      candidates = nonPackages.toArray(new GroovyResolveResult[nonPackages.size()]);\n    }\n    LookupElement[] propertyLookupElements = addPretendedProperties(candidates);\n    List<Object> variants = GroovyCompletionUtil.getCompletionVariants(candidates);\n    variants.addAll(Arrays.asList(propertyLookupElements));\n    variants.addAll(Arrays.asList(sameQualifier));\n    return variants.toArray(new Object[variants.size()]);\n  }","id":75455,"modified_method":"private static Object[] getVariantsImpl(GrReferenceExpression refExpr, ResolverProcessor processor) {\n    GrExpression qualifier = refExpr.getQualifierExpression();\n    String[] sameQualifier = getVariantsWithSameQualifier(qualifier, refExpr);\n    if (qualifier == null) {\n      ResolveUtil.treeWalkUp(refExpr, processor, true);\n\n      for (PsiElement e = refExpr.getParent(); e != null; e = e.getParent()) {\n        if (e instanceof GrClosableBlock) {\n          ResolveState state = ResolveState.initial().put(ResolverProcessor.RESOLVE_CONTEXT, (GrClosableBlock)e);\n          for (ClosureMissingMethodContributor contributor : ClosureMissingMethodContributor.EP_NAME.getExtensions()) {\n            contributor.processMembers((GrClosableBlock)e, processor, refExpr, state);\n          }\n        }\n      }\n\n      qualifier = PsiImplUtil.getRuntimeQualifier(refExpr);\n      if (qualifier != null) {\n        getVariantsFromQualifier(refExpr, processor, qualifier);\n      }\n    }\n    else {\n      if (refExpr.getDotTokenType() != GroovyTokenTypes.mSPREAD_DOT) {\n        getVariantsFromQualifier(refExpr, processor, qualifier);\n\n        if (qualifier instanceof GrReferenceExpression && \"class\".equals(((GrReferenceExpression)qualifier).getReferenceName())) {\n          processIfJavaLangClass(refExpr, processor, qualifier.getType());\n        }\n        else if (qualifier instanceof GrThisReferenceExpression) {\n          processIfJavaLangClass(refExpr, processor, qualifier.getType());\n        }\n      }\n      else {\n        getVariantsFromQualifierForSpreadOperator(refExpr, processor, qualifier);\n      }\n    }\n\n    GroovyResolveResult[] candidates = processor.getCandidates();\n    if (candidates.length == 0 && sameQualifier.length == 0) return PsiNamedElement.EMPTY_ARRAY;\n    candidates = filterStaticsOK(candidates);\n    if (qualifier == null) {\n      List<GroovyResolveResult> nonPackages = ContainerUtil.findAll(candidates, new Condition<GroovyResolveResult>() {\n        public boolean value(final GroovyResolveResult result) {\n          return !(result.getElement() instanceof PsiPackage);\n        }\n      });\n      candidates = nonPackages.toArray(new GroovyResolveResult[nonPackages.size()]);\n    }\n    LookupElement[] propertyLookupElements = addPretendedProperties(candidates);\n    List<Object> variants = GroovyCompletionUtil.getCompletionVariants(candidates);\n    variants.addAll(Arrays.asList(propertyLookupElements));\n    variants.addAll(Arrays.asList(sameQualifier));\n    return variants.toArray(new Object[variants.size()]);\n  }","commit_id":"88f44ba2e50c7b0904bc690391016b06611b6841","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GroovyResolveResult[] resolve(GrReferenceExpressionImpl refExpr, boolean incompleteCode) {\n      String name = refExpr.getReferenceName();\n      if (name == null) return GroovyResolveResult.EMPTY_ARRAY;\n\n      Kind kind = refExpr.getKind();\n      if (incompleteCode) {\n        ResolverProcessor processor = CompletionProcessor.createRefSameNameProcessor(refExpr, name);\n        refExpr.resolveImpl(processor);\n        GroovyResolveResult[] propertyCandidates = processor.getCandidates();\n        if (propertyCandidates.length > 0) return propertyCandidates;\n      }\n\n      switch (kind) {\n        case METHOD_OR_PROPERTY:\n          return refExpr.resolveMethodOrProperty();\n        case TYPE_OR_PROPERTY:\n          return refExpr.resolveTypeOrProperty();\n        default:\n          return GroovyResolveResult.EMPTY_ARRAY;\n      }\n    }","id":75456,"modified_method":"public GroovyResolveResult[] resolve(GrReferenceExpressionImpl refExpr, boolean incompleteCode) {\n      String name = refExpr.getReferenceName();\n      if (name == null) return GroovyResolveResult.EMPTY_ARRAY;\n\n      if (incompleteCode) {\n        ResolverProcessor processor = CompletionProcessor.createRefSameNameProcessor(refExpr, name);\n        refExpr.resolveImpl(processor);\n        GroovyResolveResult[] propertyCandidates = processor.getCandidates();\n        if (propertyCandidates.length > 0) return propertyCandidates;\n      }\n\n      switch (refExpr.getKind()) {\n        case METHOD_OR_PROPERTY:\n          return refExpr.resolveMethodOrProperty();\n        case TYPE_OR_PROPERTY:\n          return refExpr.resolveTypeOrProperty();\n        default:\n          return GroovyResolveResult.EMPTY_ARRAY;\n      }\n    }","commit_id":"88f44ba2e50c7b0904bc690391016b06611b6841","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * priority: inside class C: local variable, c.method, c.property, c.getter\n   *           in other places: local variable, c.method, c.getter, c.property\n   */\n  private GroovyResolveResult[] resolveMethodOrProperty(boolean allVariants, GrExpression upToArgument) {\n    String name = getReferenceName();\n    if (name == null) return GroovyResolveResult.EMPTY_ARRAY;\n\n    PropertyResolverProcessor propertyResolver = new PropertyResolverProcessor(name, this);\n    resolveImpl(propertyResolver);\n    final GroovyResolveResult[] propertyCandidates = propertyResolver.getCandidates();\n\n    if (!allVariants) { //search for local variables\n      for (GroovyResolveResult candidate : propertyCandidates) {\n        if (candidate.getElement() instanceof GrVariable && !(candidate.getElement() instanceof GrField)) {\n          return propertyResolver.getCandidates();\n        }\n      }\n    }\n\n    //search for methods\n    final PsiType[] argTypes = PsiUtil.getArgumentTypes(this, false, upToArgument);\n    MethodResolverProcessor methodResolver = runMethodResolverProcessor(name, argTypes, allVariants);\n    if (!allVariants && methodResolver.hasApplicableCandidates()) {\n      return methodResolver.getCandidates();\n    }\n\n    //search for fields inside its class\n    if (!allVariants) {\n      for (GroovyResolveResult candidate : propertyCandidates) {\n        final PsiElement element = candidate.getElement();\n        if (element instanceof GrField) {\n          final PsiClass containingClass = ((PsiField)element).getContainingClass();\n          if (containingClass != null && PsiTreeUtil.isAncestor(containingClass, this, true)) return propertyCandidates;\n        }\n      }\n\n      // Search in ClosureMissingMethodContributor\n      if (!isQualified() && getParent() instanceof GrMethodCall) {\n        boolean resolve = false;\n        for (PsiElement e = this.getParent(); !resolve && e != null; e = e.getParent()) {\n          if (e instanceof GrClosableBlock) {\n            for (ClosureMissingMethodContributor contributor : ClosureMissingMethodContributor.EP_NAME.getExtensions()) {\n              if (!contributor.processMembers((GrClosableBlock)e, methodResolver, this, ResolveState.initial())) {\n                resolve = true;\n                break;\n              }\n            }\n          }\n        }\n\n        if (methodResolver.hasApplicableCandidates()) {\n          return methodResolver.getCandidates();\n        }\n      }\n    }\n\n    List<GroovyResolveResult> allCandidates = new ArrayList<GroovyResolveResult>();\n    ContainerUtil.addAll(allCandidates, propertyCandidates);\n    ContainerUtil.addAll(allCandidates, methodResolver.getCandidates());\n\n    //search for getters\n    for (String getterName : GroovyPropertyUtils.suggestGettersName(name)) {\n      AccessorResolverProcessor getterResolver = new AccessorResolverProcessor(getterName, this, true);\n      resolveImpl(getterResolver);\n      final GroovyResolveResult[] candidates = getterResolver.getCandidates(); //can be only one candidate\n      if (!allVariants && candidates.length == 1) {\n        putUserData(IS_RESOLVED_TO_GETTER, true);\n        return candidates;\n      }\n      ContainerUtil.addAll(allCandidates, candidates);\n    }\n\n    if (allCandidates.size() > 0) {\n      return allCandidates.toArray(new GroovyResolveResult[allCandidates.size()]);\n    }\n    return GroovyResolveResult.EMPTY_ARRAY;\n  }","id":75457,"modified_method":"/**\n   * priority: inside class C: local variable, c.method, c.property, c.getter\n   *           in other places: local variable, c.method, c.getter, c.property\n   */\n  private GroovyResolveResult[] resolveMethodOrProperty(boolean allVariants, GrExpression upToArgument) {\n    String name = getReferenceName();\n    if (name == null) return GroovyResolveResult.EMPTY_ARRAY;\n\n    PropertyResolverProcessor propertyResolver = new PropertyResolverProcessor(name, this);\n    resolveImpl(propertyResolver);\n    final GroovyResolveResult[] propertyCandidates = propertyResolver.getCandidates();\n\n    if (!allVariants) { //search for local variables\n      for (GroovyResolveResult candidate : propertyCandidates) {\n        if (candidate.getElement() instanceof GrVariable && !(candidate.getElement() instanceof GrField)) {\n          return propertyResolver.getCandidates();\n        }\n      }\n    }\n\n    //search for methods\n    final PsiType[] argTypes = PsiUtil.getArgumentTypes(this, false, upToArgument);\n    MethodResolverProcessor methodResolver = runMethodResolverProcessor(name, argTypes, allVariants);\n    if (!allVariants && methodResolver.hasApplicableCandidates()) {\n      return methodResolver.getCandidates();\n    }\n\n    // Search in ClosureMissingMethodContributor\n    if (!isQualified() && getParent() instanceof GrMethodCall) {\n      boolean resolve = false;\n      for (PsiElement e = this.getParent(); !resolve && e != null; e = e.getParent()) {\n        if (e instanceof GrClosableBlock) {\n          ResolveState state = ResolveState.initial().put(ResolverProcessor.RESOLVE_CONTEXT, (GrClosableBlock)e);\n          for (ClosureMissingMethodContributor contributor : ClosureMissingMethodContributor.EP_NAME.getExtensions()) {\n            if (!contributor.processMembers((GrClosableBlock)e, methodResolver, this, state)) {\n              resolve = true;\n              break;\n            }\n          }\n        }\n      }\n\n      if (!allVariants && methodResolver.hasApplicableCandidates()) {\n        return methodResolver.getCandidates();\n      }\n    }\n\n    //search for fields inside its class\n    if (!allVariants) {\n      for (GroovyResolveResult candidate : propertyCandidates) {\n        final PsiElement element = candidate.getElement();\n        if (element instanceof GrField) {\n          final PsiClass containingClass = ((PsiField)element).getContainingClass();\n          if (containingClass != null && PsiTreeUtil.isAncestor(containingClass, this, true)) return propertyCandidates;\n        }\n      }\n    }\n\n    List<GroovyResolveResult> allCandidates = new ArrayList<GroovyResolveResult>();\n    ContainerUtil.addAll(allCandidates, propertyCandidates);\n    ContainerUtil.addAll(allCandidates, methodResolver.getCandidates());\n\n    //search for getters\n    for (String getterName : GroovyPropertyUtils.suggestGettersName(name)) {\n      AccessorResolverProcessor getterResolver = new AccessorResolverProcessor(getterName, this, true);\n      resolveImpl(getterResolver);\n      final GroovyResolveResult[] candidates = getterResolver.getCandidates(); //can be only one candidate\n      if (!allVariants && candidates.length == 1) {\n        putUserData(IS_RESOLVED_TO_GETTER, true);\n        return candidates;\n      }\n      ContainerUtil.addAll(allCandidates, candidates);\n    }\n\n    if (allCandidates.size() > 0) {\n      return allCandidates.toArray(new GroovyResolveResult[allCandidates.size()]);\n    }\n    return GroovyResolveResult.EMPTY_ARRAY;\n  }","commit_id":"88f44ba2e50c7b0904bc690391016b06611b6841","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GroovyResolveResult advancedResolve() {\n    ResolveResult[] results = getManager().getResolveCache().resolveWithCaching(this, RESOLVER, false, false);\n    return results.length == 1 ? (GroovyResolveResult) results[0] : GroovyResolveResult.EMPTY_RESULT;\n  }","id":75458,"modified_method":"public GroovyResolveResult advancedResolve() {\n    ResolveResult[] results = getManager().getResolveCache().resolveWithCaching(this, POLY_RESOLVER, false, false);\n    return results.length == 1 ? (GroovyResolveResult) results[0] : GroovyResolveResult.EMPTY_RESULT;\n  }","commit_id":"834a150d25c537a70d42ec98d8580810032c86ad","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MethodResolverProcessor runMethodResolverProcessor(String referenceName, PsiType[] argTypes, final boolean allVariants) {\n    PsiType thisType = getThisType();\n\n    MethodResolverProcessor methodResolver = new MethodResolverProcessor(referenceName, this, false, thisType, argTypes, getTypeArguments(), allVariants);\n    resolveImpl(methodResolver);\n    return methodResolver;\n  }","id":75459,"modified_method":"private MethodResolverProcessor createMethodProcessor(boolean allVariants, String name, final boolean byShape, @Nullable GrExpression upToArgument) {\n    final PsiType[] argTypes = PsiUtil.getArgumentTypes(this, false, upToArgument);\n    if (byShape && argTypes != null) {\n      for (int i = 0; i < argTypes.length; i++) {\n        argTypes[i] = TypeConversionUtil.erasure(argTypes[i]);\n      }\n    }\n    PsiType thisType = getThisType();\n    return new MethodResolverProcessor(name, this, false, thisType, argTypes, getTypeArguments(), allVariants) {\n      @Override\n      protected PsiSubstitutor obtainSubstitutor(PsiSubstitutor substitutor, PsiMethod method, ResolveState state) {\n        return byShape ? substitutor : super.obtainSubstitutor(substitutor, method, state);\n      }\n    };\n  }","commit_id":"834a150d25c537a70d42ec98d8580810032c86ad","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * priority: inside class C: local variable, c.method, c.property, c.getter\n   *           in other places: local variable, c.method, c.getter, c.property\n   */\n  private GroovyResolveResult[] resolveMethodOrProperty(boolean allVariants, @Nullable GrExpression upToArgument) {\n    String name = getReferenceName();\n    if (name == null) return GroovyResolveResult.EMPTY_ARRAY;\n\n    PropertyResolverProcessor propertyResolver = new PropertyResolverProcessor(name, this);\n    resolveImpl(propertyResolver);\n    final GroovyResolveResult[] propertyCandidates = propertyResolver.getCandidates();\n\n    if (!allVariants) { //search for local variables\n      for (GroovyResolveResult candidate : propertyCandidates) {\n        if (candidate.getElement() instanceof GrVariable && !(candidate.getElement() instanceof GrField)) {\n          return propertyResolver.getCandidates();\n        }\n      }\n    }\n\n    //search for methods\n    final PsiType[] argTypes = PsiUtil.getArgumentTypes(this, false, upToArgument);\n    MethodResolverProcessor methodResolver = runMethodResolverProcessor(name, argTypes, allVariants);\n    if (!allVariants && methodResolver.hasApplicableCandidates()) {\n      return methodResolver.getCandidates();\n    }\n\n    // Search in ClosureMissingMethodContributor\n    if (!isQualified() && getContext() instanceof GrMethodCall) {\n      boolean resolve = false;\n      for (PsiElement e = this.getContext(); !resolve && e != null; e = e.getContext()) {\n        if (e instanceof GrClosableBlock) {\n          ResolveState state = ResolveState.initial().put(ResolverProcessor.RESOLVE_CONTEXT, (GrClosableBlock)e);\n          for (ClosureMissingMethodContributor contributor : ClosureMissingMethodContributor.EP_NAME.getExtensions()) {\n            if (!contributor.processMembers((GrClosableBlock)e, methodResolver, this, state)) {\n              resolve = true;\n              break;\n            }\n          }\n        }\n      }\n\n      if (!allVariants && methodResolver.hasApplicableCandidates()) {\n        return methodResolver.getCandidates();\n      }\n    }\n\n    //search for fields inside its class\n    if (!allVariants) {\n      for (GroovyResolveResult candidate : propertyCandidates) {\n        final PsiElement element = candidate.getElement();\n        if (element instanceof GrField) {\n          final PsiClass containingClass = ((PsiField)element).getContainingClass();\n          if (containingClass != null && PsiTreeUtil.isContextAncestor(containingClass, this, true)) return propertyCandidates;\n        }\n      }\n    }\n\n    List<GroovyResolveResult> allCandidates = new ArrayList<GroovyResolveResult>();\n    ContainerUtil.addAll(allCandidates, propertyCandidates);\n    ContainerUtil.addAll(allCandidates, methodResolver.getCandidates());\n\n    //search for getters\n    for (String getterName : GroovyPropertyUtils.suggestGettersName(name)) {\n      AccessorResolverProcessor getterResolver = new AccessorResolverProcessor(getterName, this, true);\n      resolveImpl(getterResolver);\n      final GroovyResolveResult[] candidates = getterResolver.getCandidates(); //can be only one candidate\n      if (!allVariants && candidates.length == 1) {\n        return candidates;\n      }\n      ContainerUtil.addAll(allCandidates, candidates);\n    }\n\n    if (allCandidates.size() > 0) {\n      return allCandidates.toArray(new GroovyResolveResult[allCandidates.size()]);\n    }\n    return GroovyResolveResult.EMPTY_ARRAY;\n  }","id":75460,"modified_method":"/**\n   * priority: inside class C: local variable, c.method, c.property, c.getter\n   *           in other places: local variable, c.method, c.getter, c.property\n   */\n  private GroovyResolveResult[] resolveMethodOrProperty(boolean allVariants, @Nullable GrExpression upToArgument, boolean genericsMatter) {\n    final String name = getReferenceName();\n    if (name == null) return GroovyResolveResult.EMPTY_ARRAY;\n\n    PropertyResolverProcessor propertyResolver = new PropertyResolverProcessor(name, this);\n    resolveImpl(propertyResolver);\n    final GroovyResolveResult[] propertyCandidates = propertyResolver.getCandidates();\n\n    if (!allVariants) { //search for local variables\n      for (GroovyResolveResult candidate : propertyCandidates) {\n        if (candidate.getElement() instanceof GrVariable && !(candidate.getElement() instanceof GrField)) {\n          return propertyResolver.getCandidates();\n        }\n      }\n    }\n\n    final Pair<Boolean, GroovyResolveResult[]> shapeResults = resolveByShape(allVariants, upToArgument);\n    if (!genericsMatter && !allVariants && shapeResults.first) {\n      return shapeResults.second;\n    }\n\n    final MethodResolverProcessor methodResolver = createMethodProcessor(allVariants, name, false, upToArgument);\n\n    for (GroovyResolveResult result : shapeResults.second) {\n      final ResolveState state = ResolveState.initial().\n        put(PsiSubstitutor.KEY, result.getSubstitutor()).\n        put(ResolverProcessor.RESOLVE_CONTEXT, result.getCurrentFileResolveContext());\n      methodResolver.execute(result.getElement(), state);\n    }\n\n    if (!allVariants && methodResolver.hasApplicableCandidates()) {\n      return methodResolver.getCandidates();\n    }\n\n    //search for fields inside its class\n    if (!allVariants) {\n      for (GroovyResolveResult candidate : propertyCandidates) {\n        final PsiElement element = candidate.getElement();\n        if (element instanceof GrField) {\n          final PsiClass containingClass = ((PsiField)element).getContainingClass();\n          if (containingClass != null && PsiTreeUtil.isContextAncestor(containingClass, this, true)) return propertyCandidates;\n        }\n      }\n    }\n\n    List<GroovyResolveResult> allCandidates = new ArrayList<GroovyResolveResult>();\n    ContainerUtil.addAll(allCandidates, propertyCandidates);\n    ContainerUtil.addAll(allCandidates, methodResolver.getCandidates());\n\n    //search for getters\n    for (String getterName : GroovyPropertyUtils.suggestGettersName(name)) {\n      AccessorResolverProcessor getterResolver = new AccessorResolverProcessor(getterName, this, true);\n      resolveImpl(getterResolver);\n      final GroovyResolveResult[] candidates = getterResolver.getCandidates(); //can be only one candidate\n      if (!allVariants && candidates.length == 1) {\n        return candidates;\n      }\n      ContainerUtil.addAll(allCandidates, candidates);\n    }\n\n    if (allCandidates.size() > 0) {\n      return allCandidates.toArray(new GroovyResolveResult[allCandidates.size()]);\n    }\n    return GroovyResolveResult.EMPTY_ARRAY;\n  }","commit_id":"834a150d25c537a70d42ec98d8580810032c86ad","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public GroovyResolveResult[] multiResolve(boolean incomplete) {  //incomplete means we do not take arguments into consideration\n    return (GroovyResolveResult[]) getManager().getResolveCache().resolveWithCaching(this, RESOLVER, false, incomplete);\n  }","id":75461,"modified_method":"@NotNull\n  public GroovyResolveResult[] multiResolve(boolean incomplete) {  //incomplete means we do not take arguments into consideration\n    return (GroovyResolveResult[]) getManager().getResolveCache().resolveWithCaching(this, POLY_RESOLVER, false, incomplete);\n  }","commit_id":"834a150d25c537a70d42ec98d8580810032c86ad","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public GroovyResolveResult[] getSameNameVariants() {\n    return RESOLVER.resolve(this, true);\n  }","id":75462,"modified_method":"@NotNull\n  public GroovyResolveResult[] getSameNameVariants() {\n    return doPolyResolve(true, true);\n  }","commit_id":"834a150d25c537a70d42ec98d8580810032c86ad","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GroovyResolveResult[] getCallVariants(GrExpression upToArgument) {\n    return resolveMethodOrProperty(true, upToArgument);\n  }","id":75463,"modified_method":"public GroovyResolveResult[] getCallVariants(GrExpression upToArgument) {\n    return resolveMethodOrProperty(true, upToArgument, true);\n  }","commit_id":"834a150d25c537a70d42ec98d8580810032c86ad","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public PsiElement resolve() {\n    ResolveResult[] results = getManager().getResolveCache().resolveWithCaching(this, RESOLVER, true, false);\n    return results.length == 1 ? results[0].getElement() : null;\n  }","id":75464,"modified_method":"@Nullable\n  public PsiElement resolve() {\n    return getManager().getResolveCache().resolveWithCaching(this, SIMPLE_RESOLVER, true, false);\n  }","commit_id":"834a150d25c537a70d42ec98d8580810032c86ad","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private PsiSubstitutor obtainSubstitutor(PsiSubstitutor substitutor, PsiMethod method, ResolveState state) {\n    final PsiTypeParameter[] typeParameters = method.getTypeParameters();\n    if (myTypeArguments.length == typeParameters.length) {\n      for (int i = 0; i < typeParameters.length; i++) {\n        PsiTypeParameter typeParameter = typeParameters[i];\n        final PsiType typeArgument = myTypeArguments[i];\n        substitutor = substitutor.put(typeParameter, typeArgument);\n      }\n      return substitutor;\n    }\n\n    if (argumentsSupplied() && method.hasTypeParameters()) {\n      PsiType[] argTypes = myArgumentTypes;\n      final GroovyPsiElement resolveContext = state.get(RESOLVE_CONTEXT);\n      assert argTypes != null;\n      if (method instanceof GrGdkMethod) {\n        //type inference should be performed from static method\n        PsiType[] newArgTypes = new PsiType[argTypes.length + 1];\n        if (ResolveUtil.isInWithContext(resolveContext)) {\n          newArgTypes[0] = ((GrExpression)resolveContext).getType();\n        }\n        else {\n          newArgTypes[0] = myThisType;\n        }\n        System.arraycopy(argTypes, 0, newArgTypes, 1, argTypes.length);\n        argTypes = newArgTypes;\n\n        method = ((GrGdkMethod) method).getStaticMethod();\n        LOG.assertTrue(method.isValid());\n      }\n      else if (ResolveUtil.isInUseScope(resolveContext)) {\n        PsiType[] newArgTypes = new PsiType[argTypes.length + 1];\n        newArgTypes[0] = myThisType;\n        System.arraycopy(argTypes, 0, newArgTypes, 1, argTypes.length);\n        argTypes = newArgTypes;\n      }\n\n      return inferMethodTypeParameters(method, substitutor, typeParameters, argTypes);\n    }\n\n    return substitutor;\n  }","id":75465,"modified_method":"protected PsiSubstitutor obtainSubstitutor(PsiSubstitutor substitutor, PsiMethod method, ResolveState state) {\n    final PsiTypeParameter[] typeParameters = method.getTypeParameters();\n    if (myTypeArguments.length == typeParameters.length) {\n      for (int i = 0; i < typeParameters.length; i++) {\n        PsiTypeParameter typeParameter = typeParameters[i];\n        final PsiType typeArgument = myTypeArguments[i];\n        substitutor = substitutor.put(typeParameter, typeArgument);\n      }\n      return substitutor;\n    }\n\n    if (argumentsSupplied() && method.hasTypeParameters()) {\n      PsiType[] argTypes = myArgumentTypes;\n      final GroovyPsiElement resolveContext = state.get(RESOLVE_CONTEXT);\n      assert argTypes != null;\n      if (method instanceof GrGdkMethod) {\n        //type inference should be performed from static method\n        PsiType[] newArgTypes = new PsiType[argTypes.length + 1];\n        if (ResolveUtil.isInWithContext(resolveContext)) {\n          newArgTypes[0] = ((GrExpression)resolveContext).getType();\n        }\n        else {\n          newArgTypes[0] = myThisType;\n        }\n        System.arraycopy(argTypes, 0, newArgTypes, 1, argTypes.length);\n        argTypes = newArgTypes;\n\n        method = ((GrGdkMethod) method).getStaticMethod();\n        LOG.assertTrue(method.isValid());\n      }\n      else if (ResolveUtil.isInUseScope(resolveContext)) {\n        PsiType[] newArgTypes = new PsiType[argTypes.length + 1];\n        newArgTypes[0] = myThisType;\n        System.arraycopy(argTypes, 0, newArgTypes, 1, argTypes.length);\n        argTypes = newArgTypes;\n      }\n\n      return inferMethodTypeParameters(method, substitutor, typeParameters, argTypes);\n    }\n\n    return substitutor;\n  }","commit_id":"834a150d25c537a70d42ec98d8580810032c86ad","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n\t\tpublic Enumeration<String> getKeys() {\n\t\t\tEnumeration<String> enumeration = Collections.enumeration(\n\t\t\t\t_languageMap.keySet());\n\n\t\t\tif (parent == null) {\n\t\t\t\treturn enumeration;\n\t\t\t}\n\n\t\t\treturn EnumerationUtil.compose(enumeration, parent.getKeys());\n\t\t}","id":75466,"modified_method":"@Override\n\t\tpublic Enumeration<String> getKeys() {\n\t\t\tSet<String> keySet = _languageMap.keySet();\n\n\t\t\tif (parent == null) {\n\t\t\t\treturn Collections.enumeration(keySet);\n\t\t\t}\n\n\t\t\treturn new ResourceBundleEnumeration(keySet, parent.getKeys());\n\t\t}","commit_id":"af85dad58f18df984d004190f69b443babef053a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String[] getKeys() {\n\t\treturn (String[])_velocityContext.getKeys();\n\t}","id":75467,"modified_method":"public String[] getKeys() {\n\t\tObject[] keyObjects = _velocityContext.getKeys();\n\t\tObject[] innerKeyObjects =\n\t\t\t_velocityContext.getChainedContext().getKeys();\n\n\t\tString[] keys = new String[keyObjects.length + innerKeyObjects.length];\n\n\t\tArrayUtil.combine(keyObjects, innerKeyObjects, keys);\n\n\t\treturn keys;\n\t}","commit_id":"014e85d0fc3d320fc204536e1f337b5168a3d919","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic Enumeration<String> getKeys() {\n\t\tEnumeration<String> enumeration = Collections.enumeration(_keys);\n\n\t\treturn EnumerationUtil.compose(enumeration, parent.getKeys());\n\t}","id":75468,"modified_method":"@Override\n\tpublic Enumeration<String> getKeys() {\n\t\tSet<String> keySet = new HashSet<String>();\n\n\t\tfor (String key : _keys) {\n\t\t\tif (parent.containsKey(_buildKey(key))) {\n\t\t\t\tkeySet.add(key);\n\t\t\t}\n\t\t}\n\n\t\treturn new ResourceBundleEnumeration(keySet, parent.getKeys());\n\t}","commit_id":"36063f3f1680f064652864567dbc99c090a97be7","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected Object handleGetObject(String key) {\n\t\tif (key == null) {\n\t\t\tthrow new NullPointerException();\n\t\t}\n\n\t\tif (_keys.contains(key)) {\n\t\t\tkey = key.concat(StringPool.PERIOD).concat(_portletName);\n\n\t\t\tif (parent.containsKey(key)) {\n\t\t\t\ttry {\n\t\t\t\t\treturn parent.getObject(key);\n\t\t\t\t}\n\t\t\t\tcatch (MissingResourceException mre) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}","id":75469,"modified_method":"@Override\n\tprotected Object handleGetObject(String key) {\n\t\tif (key == null) {\n\t\t\tthrow new NullPointerException();\n\t\t}\n\n\t\tif (_keys.contains(key)) {\n\t\t\tkey = _buildKey(key);\n\t\t}\n\n\t\tif (parent.containsKey(key)) {\n\t\t\ttry {\n\t\t\t\treturn parent.getObject(key);\n\t\t\t}\n\t\t\tcatch (MissingResourceException mre) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"36063f3f1680f064652864567dbc99c090a97be7","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic boolean containsKey(String key) {\n\t\tif (_keys.contains(key)) {\n\t\t\tkey = key.concat(StringPool.PERIOD).concat(_portletName);\n\n\t\t\treturn parent.containsKey(key);\n\t\t}\n\n\t\treturn parent.containsKey(key);\n\t}","id":75470,"modified_method":"@Override\n\tpublic boolean containsKey(String key) {\n\t\tif (key == null) {\n\t\t\tthrow new NullPointerException();\n\t\t}\n\n\t\tif (_keys.contains(key)) {\n\t\t\tkey = _buildKey(key);\n\t\t}\n\n\t\treturn parent.containsKey(key);\n\t}","commit_id":"36063f3f1680f064652864567dbc99c090a97be7","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static CompilerConfiguration compilerConfigurationForTests(@NotNull ConfigurationKind configurationKind, boolean mockJdk) {\n        List<File> classpath = new ArrayList<File>();\n        classpath.add(mockJdk ? JetTestUtils.findMockJdkRtJar() : PathUtil.findRtJar());\n        if (configurationKind == ALL) {\n            classpath.add(ForTestCompileRuntime.runtimeJarForTests());\n        }\n\n        File[] annotationsPath = new File[0];\n        if (configurationKind == ALL || configurationKind == JDK_AND_ANNOTATIONS) {\n            annotationsPath = new File[]{ForTestPackJdkAnnotations.jdkAnnotationsForTests()};\n        }\n\n        CompilerConfiguration configuration = new CompilerConfiguration();\n        configuration.putUserData(JVMConfigurationKeys.CLASSPATH_KEY, classpath.toArray(new File[classpath.size()]));\n        configuration.putUserData(JVMConfigurationKeys.ANNOTATIONS_PATH_KEY, annotationsPath);\n        return configuration;\n    }","id":75471,"modified_method":"public static CompilerConfiguration compilerConfigurationForTests(@NotNull ConfigurationKind configurationKind, @NotNull TestJdkKind jdkKind) {\n        List<File> classpath = new ArrayList<File>();\n        classpath.add(jdkKind == TestJdkKind.MOCK_JDK ? JetTestUtils.findMockJdkRtJar() : PathUtil.findRtJar());\n        if (configurationKind == ALL) {\n            classpath.add(ForTestCompileRuntime.runtimeJarForTests());\n        }\n\n        File[] annotationsPath = new File[0];\n        if (configurationKind == ALL || configurationKind == JDK_AND_ANNOTATIONS) {\n            annotationsPath = new File[]{ForTestPackJdkAnnotations.jdkAnnotationsForTests()};\n        }\n\n        CompilerConfiguration configuration = new CompilerConfiguration();\n        configuration.putUserData(JVMConfigurationKeys.CLASSPATH_KEY, classpath.toArray(new File[classpath.size()]));\n        configuration.putUserData(JVMConfigurationKeys.ANNOTATIONS_PATH_KEY, annotationsPath);\n        return configuration;\n    }","commit_id":"207c75b9561c3b9d5932cae9456dd425b29b0ebb","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static JetCoreEnvironment createEnvironmentWithFullJdk(Disposable disposable) {\n        return new JetCoreEnvironment(disposable,\n                CompileCompilerDependenciesTest.compilerConfigurationForTests(ConfigurationKind.ALL, false)\n        );\n    }","id":75472,"modified_method":"public static JetCoreEnvironment createEnvironmentWithFullJdk(Disposable disposable) {\n        return createEnvironmentWithJdkAndNullabilityAnnotationsFromIdea(disposable,\n                                                                         ConfigurationKind.ALL, TestJdkKind.FULL_JDK);\n    }","commit_id":"207c75b9561c3b9d5932cae9456dd425b29b0ebb","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static JetCoreEnvironment createEnvironmentWithMockJdkAndIdeaAnnotations(Disposable disposable, @NotNull ConfigurationKind configurationKind) {\n        JetCoreEnvironment environment = new JetCoreEnvironment(disposable,\n                CompileCompilerDependenciesTest.compilerConfigurationForTests(configurationKind, true)\n        );\n        environment.addToClasspath(getAnnotationsJar());\n        return environment;\n    }","id":75473,"modified_method":"public static JetCoreEnvironment createEnvironmentWithMockJdkAndIdeaAnnotations(Disposable disposable, @NotNull ConfigurationKind configurationKind) {\n        return createEnvironmentWithJdkAndNullabilityAnnotationsFromIdea(disposable, configurationKind, TestJdkKind.MOCK_JDK);\n    }","commit_id":"207c75b9561c3b9d5932cae9456dd425b29b0ebb","url":"https://github.com/JetBrains/kotlin"},{"original_method":"protected JetCoreEnvironment createEnvironmentWithMockJdk(@NotNull ConfigurationKind configurationKind) {\n        return createEnvironmentWithJdk(configurationKind, true);\n    }","id":75474,"modified_method":"protected JetCoreEnvironment createEnvironmentWithMockJdk(@NotNull ConfigurationKind configurationKind) {\n        return createEnvironmentWithJdk(configurationKind, TestJdkKind.MOCK_JDK);\n    }","commit_id":"207c75b9561c3b9d5932cae9456dd425b29b0ebb","url":"https://github.com/JetBrains/kotlin"},{"original_method":"protected JetCoreEnvironment createEnvironmentWithJdk(@NotNull ConfigurationKind configurationKind, boolean mockJdk) {\n        JetCoreEnvironment environment = new JetCoreEnvironment(getTestRootDisposable(),\n                                                                CompileCompilerDependenciesTest\n                                                                        .compilerConfigurationForTests(configurationKind, mockJdk)\n        );\n        environment.addToClasspath(JetTestUtils.getAnnotationsJar());\n        return environment;\n    }","id":75475,"modified_method":"protected JetCoreEnvironment createEnvironmentWithJdk(@NotNull ConfigurationKind configurationKind, @NotNull TestJdkKind jdkKind) {\n        return JetTestUtils.createEnvironmentWithJdkAndNullabilityAnnotationsFromIdea(getTestRootDisposable(), configurationKind, jdkKind);\n    }","commit_id":"207c75b9561c3b9d5932cae9456dd425b29b0ebb","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        stdlibEnvironment = createEnvironmentWithJdk(ConfigurationKind.JDK_AND_ANNOTATIONS, false);\n    }","id":75476,"modified_method":"@Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        stdlibEnvironment = createEnvironmentWithJdk(ConfigurationKind.JDK_AND_ANNOTATIONS, TestJdkKind.FULL_JDK);\n    }","commit_id":"207c75b9561c3b9d5932cae9456dd425b29b0ebb","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void testFile(@NotNull String relativePath) {\n        CompilerConfiguration configuration =\n                CompileCompilerDependenciesTest.compilerConfigurationForTests(ConfigurationKind.JDK_ONLY, false);\n        File[] classpath = configuration.getUserData(JVMConfigurationKeys.CLASSPATH_KEY);\n        assert classpath != null;\n        configuration.putUserData(JVMConfigurationKeys.CLASSPATH_KEY, ArrayUtil.append(classpath, new File(\"out/production/runtime\")));\n        ReplInterpreter repl = new ReplInterpreter(disposable, configuration);\n\n        ReplSessionTestFile file = ReplSessionTestFile.load(new File(\"compiler/testData/repl/\" + relativePath));\n        for (ReplSessionTestFile.OneLine t : file.getLines()) {\n            String code = t.getCode();\n\n            String expected = StringUtil.convertLineSeparators(t.getExpected()).replaceFirst(\"\\n$\", \"\");\n            ReplSessionTestFile.MatchType matchType = t.getMatchType();\n\n            ReplInterpreter.LineResult lineResult = repl.eval(code);\n            Object actual;\n            if (lineResult.getType() == ReplInterpreter.LineResultType.SUCCESS) {\n                actual = lineResult.getValue();\n            }\n            else if (lineResult.getType() == ReplInterpreter.LineResultType.INCOMPLETE) {\n                actual = \"incomplete\";\n            }\n            else {\n                actual = lineResult.getErrorText();\n            }\n            String actualString = StringUtil.convertLineSeparators(actual != null ? actual.toString() : \"null\").replaceFirst(\"\\n$\", \"\");\n\n            if (matchType == ReplSessionTestFile.MatchType.EQUALS) {\n                Assert.assertEquals(\"after evaluation of: \" + code, expected, actualString);\n            }\n            else if (matchType == ReplSessionTestFile.MatchType.SUBSTRING) {\n                Assert.assertTrue(\"must contain substring: \" + expected + \", actual: \" + actualString, actualString.contains(expected));\n            }\n\n        }\n    }","id":75477,"modified_method":"private void testFile(@NotNull String relativePath) {\n        CompilerConfiguration configuration =\n                CompileCompilerDependenciesTest.compilerConfigurationForTests(ConfigurationKind.JDK_ONLY, TestJdkKind.FULL_JDK);\n        File[] classpath = configuration.getUserData(JVMConfigurationKeys.CLASSPATH_KEY);\n        assert classpath != null;\n        configuration.putUserData(JVMConfigurationKeys.CLASSPATH_KEY, ArrayUtil.append(classpath, new File(\"out/production/runtime\")));\n        ReplInterpreter repl = new ReplInterpreter(disposable, configuration);\n\n        ReplSessionTestFile file = ReplSessionTestFile.load(new File(\"compiler/testData/repl/\" + relativePath));\n        for (ReplSessionTestFile.OneLine t : file.getLines()) {\n            String code = t.getCode();\n\n            String expected = StringUtil.convertLineSeparators(t.getExpected()).replaceFirst(\"\\n$\", \"\");\n            ReplSessionTestFile.MatchType matchType = t.getMatchType();\n\n            ReplInterpreter.LineResult lineResult = repl.eval(code);\n            Object actual;\n            if (lineResult.getType() == ReplInterpreter.LineResultType.SUCCESS) {\n                actual = lineResult.getValue();\n            }\n            else if (lineResult.getType() == ReplInterpreter.LineResultType.INCOMPLETE) {\n                actual = \"incomplete\";\n            }\n            else {\n                actual = lineResult.getErrorText();\n            }\n            String actualString = StringUtil.convertLineSeparators(actual != null ? actual.toString() : \"null\").replaceFirst(\"\\n$\", \"\");\n\n            if (matchType == ReplSessionTestFile.MatchType.EQUALS) {\n                Assert.assertEquals(\"after evaluation of: \" + code, expected, actualString);\n            }\n            else if (matchType == ReplSessionTestFile.MatchType.SUBSTRING) {\n                Assert.assertTrue(\"must contain substring: \" + expected + \", actual: \" + actualString, actualString.contains(expected));\n            }\n\n        }\n    }","commit_id":"207c75b9561c3b9d5932cae9456dd425b29b0ebb","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private boolean parseLibraryFileChunk(File jar, String libDescription, ZipInputStream zip, int classesPerChunk) throws IOException {\n        Disposable junk = new Disposable() {\n            @Override\n            public void dispose() { }\n        };\n\n        JetCoreEnvironment jetCoreEnvironment;\n        if (jar != null) {\n            jetCoreEnvironment = JetTestUtils.createEnvironmentWithMockJdkAndIdeaAnnotations(junk, ConfigurationKind.JDK_AND_ANNOTATIONS);\n            jetCoreEnvironment.addToClasspath(jar);\n        }\n        else {\n            CompilerConfiguration configuration =\n                    CompileCompilerDependenciesTest.compilerConfigurationForTests(ConfigurationKind.JDK_AND_ANNOTATIONS, false);\n            jetCoreEnvironment = JetCoreEnvironment.createCoreEnvironmentForJVM(junk, configuration);\n            if (!PathUtil.findRtJar().equals(jar)) {\n                throw new RuntimeException(\"rt.jar mismatch: \" + jar + \", \" + PathUtil.findRtJar());\n            }\n        }\n\n\n        InjectorForJavaSemanticServices injector = new InjectorForJavaSemanticServices(BuiltinsScopeExtensionMode.ALL, jetCoreEnvironment.getProject());\n\n        boolean hasErrors;\n        try {\n\n            hasErrors = false;\n\n            for (int count = 0; count < classesPerChunk; ) {\n                ZipEntry entry = zip.getNextEntry();\n                if (entry == null) {\n                    break;\n                }\n\n                if (count == 0) {\n                    System.err.println(\"chunk from \" + entry.getName());\n                }\n\n                System.err.println(entry.getName());\n\n                String entryName = entry.getName();\n                if (!entryName.endsWith(\".class\")) {\n                    continue;\n                }\n                if (entryName.matches(\"(.*/|)package-info\\\\.class\")) {\n                    continue;\n                }\n                if (entryName.contains(\"$\")) {\n                    continue;\n                }\n                String className = entryName.substring(0, entryName.length() - \".class\".length()).replace(\"/\", \".\");\n\n                try {\n                    ClassDescriptor clazz = injector.getJavaDescriptorResolver().resolveClass(new FqName(className), DescriptorSearchRule.ERROR_IF_FOUND_IN_KOTLIN);\n                    if (clazz == null) {\n                        throw new IllegalStateException(\"class not found by name \" + className + \" in \" + libDescription);\n                    }\n                    clazz.getDefaultType().getMemberScope().getAllDescriptors();\n                }\n                catch (Exception e) {\n                    System.err.println(\"failed to resolve \" + className);\n                    e.printStackTrace();\n                    //throw new RuntimeException(\"failed to resolve \" + className + \": \" + e, e);\n                    hasErrors = true;\n                }\n\n                ++count;\n            }\n        }\n        finally {\n            Disposer.dispose(junk);\n        }\n        return hasErrors;\n    }","id":75478,"modified_method":"private boolean parseLibraryFileChunk(File jar, String libDescription, ZipInputStream zip, int classesPerChunk) throws IOException {\n        Disposable junk = new Disposable() {\n            @Override\n            public void dispose() { }\n        };\n\n        JetCoreEnvironment jetCoreEnvironment;\n        if (jar != null) {\n            jetCoreEnvironment = JetTestUtils.createEnvironmentWithMockJdkAndIdeaAnnotations(junk, ConfigurationKind.JDK_AND_ANNOTATIONS);\n            jetCoreEnvironment.addToClasspath(jar);\n        }\n        else {\n            CompilerConfiguration configuration =\n                    CompileCompilerDependenciesTest.compilerConfigurationForTests(ConfigurationKind.JDK_AND_ANNOTATIONS, TestJdkKind.FULL_JDK);\n            jetCoreEnvironment = JetCoreEnvironment.createCoreEnvironmentForJVM(junk, configuration);\n            if (!PathUtil.findRtJar().equals(jar)) {\n                throw new RuntimeException(\"rt.jar mismatch: \" + jar + \", \" + PathUtil.findRtJar());\n            }\n        }\n\n\n        InjectorForJavaSemanticServices injector = new InjectorForJavaSemanticServices(BuiltinsScopeExtensionMode.ALL, jetCoreEnvironment.getProject());\n\n        boolean hasErrors;\n        try {\n\n            hasErrors = false;\n\n            for (int count = 0; count < classesPerChunk; ) {\n                ZipEntry entry = zip.getNextEntry();\n                if (entry == null) {\n                    break;\n                }\n\n                if (count == 0) {\n                    System.err.println(\"chunk from \" + entry.getName());\n                }\n\n                System.err.println(entry.getName());\n\n                String entryName = entry.getName();\n                if (!entryName.endsWith(\".class\")) {\n                    continue;\n                }\n                if (entryName.matches(\"(.*/|)package-info\\\\.class\")) {\n                    continue;\n                }\n                if (entryName.contains(\"$\")) {\n                    continue;\n                }\n                String className = entryName.substring(0, entryName.length() - \".class\".length()).replace(\"/\", \".\");\n\n                try {\n                    ClassDescriptor clazz = injector.getJavaDescriptorResolver().resolveClass(new FqName(className), DescriptorSearchRule.ERROR_IF_FOUND_IN_KOTLIN);\n                    if (clazz == null) {\n                        throw new IllegalStateException(\"class not found by name \" + className + \" in \" + libDescription);\n                    }\n                    clazz.getDefaultType().getMemberScope().getAllDescriptors();\n                }\n                catch (Exception e) {\n                    System.err.println(\"failed to resolve \" + className);\n                    e.printStackTrace();\n                    //throw new RuntimeException(\"failed to resolve \" + className + \": \" + e, e);\n                    hasErrors = true;\n                }\n\n                ++count;\n            }\n        }\n        finally {\n            Disposer.dispose(junk);\n        }\n        return hasErrors;\n    }","commit_id":"207c75b9561c3b9d5932cae9456dd425b29b0ebb","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        tmpdir = new File(\"tmp/\" + this.getClass().getSimpleName() + \".\" + this.getName());\n        rmrf(tmpdir);\n        mkdirs(tmpdir);\n    }","id":75479,"modified_method":"@Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        tmpdir = new File(\"tmp/\" + this.getClass().getSimpleName() + \".\" + this.getName());\n        JetTestUtils.recreateDirectory(tmpdir);\n    }","commit_id":"8db2617701dc029e87a9e175b5e4f1b1f7c6ab69","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    protected void runTest() throws Throwable {\n        createMockCoreEnvironment();\n\n        LanguageASTFactory.INSTANCE.addExplicitExtension(JavaLanguage.INSTANCE, new JavaASTFactory());\n\n\n        String text = FileUtil.loadFile(ktFile);\n\n        LightVirtualFile virtualFile = new LightVirtualFile(\"Hello.kt\", JetLanguage.INSTANCE, text);\n        virtualFile.setCharset(CharsetToolkit.UTF8_CHARSET);\n        JetFile psiFile = (JetFile) ((PsiFileFactoryImpl) PsiFileFactory.getInstance(jetCoreEnvironment.getProject())).trySetupPsiForFile(virtualFile, JetLanguage.INSTANCE, true, false);\n\n        GenerationState state = new GenerationState(jetCoreEnvironment.getProject(), ClassBuilderFactory.BINARIES);\n        AnalyzingUtils.checkForSyntacticErrors(psiFile);\n        state.compile(psiFile);\n\n        ClassFileFactory classFileFactory = state.getFactory();\n\n        CompileEnvironment.writeToOutputDirectory(classFileFactory, tmpdir.getPath());\n\n        Disposer.dispose(myTestRootDisposable);\n\n        JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();\n\n        StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(null, Locale.ENGLISH, Charset.forName(\"utf-8\"));\n        try {\n            Iterable<? extends JavaFileObject> javaFileObjectsFromFiles = fileManager.getJavaFileObjectsFromFiles(Collections.singleton(javaFile));\n            List<String> options = Arrays.asList(\n                    \"-classpath\", tmpdir.getPath(),\n                    \"-d\", tmpdir.getPath()\n                );\n            JavaCompiler.CompilationTask task = javaCompiler.getTask(null, fileManager, null, options, null, javaFileObjectsFromFiles);\n\n            Assert.assertTrue(task.call());\n        } finally {\n            fileManager.close();\n        }\n    }","id":75480,"modified_method":"@Override\n    protected void runTest() throws Throwable {\n        jetCoreEnvironment = JetTestUtils.createEnvironmentWithMockJdk(myTestRootDisposable);\n\n        LanguageASTFactory.INSTANCE.addExplicitExtension(JavaLanguage.INSTANCE, new JavaASTFactory());\n\n\n        String text = FileUtil.loadFile(ktFile);\n\n        LightVirtualFile virtualFile = new LightVirtualFile(ktFile.getName(), JetLanguage.INSTANCE, text);\n        virtualFile.setCharset(CharsetToolkit.UTF8_CHARSET);\n        JetFile psiFile = (JetFile) ((PsiFileFactoryImpl) PsiFileFactory.getInstance(jetCoreEnvironment.getProject())).trySetupPsiForFile(virtualFile, JetLanguage.INSTANCE, true, false);\n\n        GenerationState state = new GenerationState(jetCoreEnvironment.getProject(), ClassBuilderFactory.BINARIES);\n        AnalyzingUtils.checkForSyntacticErrors(psiFile);\n        state.compile(psiFile);\n\n        ClassFileFactory classFileFactory = state.getFactory();\n\n        CompileEnvironment.writeToOutputDirectory(classFileFactory, tmpdir.getPath());\n\n        Disposer.dispose(myTestRootDisposable);\n\n        JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();\n\n        StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(null, Locale.ENGLISH, Charset.forName(\"utf-8\"));\n        try {\n            Iterable<? extends JavaFileObject> javaFileObjectsFromFiles = fileManager.getJavaFileObjectsFromFiles(Collections.singleton(javaFile));\n            List<String> options = Arrays.asList(\n                    \"-classpath\", tmpdir.getPath(),\n                    \"-d\", tmpdir.getPath()\n                );\n            JavaCompiler.CompilationTask task = javaCompiler.getTask(null, fileManager, null, options, null, javaFileObjectsFromFiles);\n\n            Assert.assertTrue(task.call());\n        } finally {\n            fileManager.close();\n        }\n    }","commit_id":"8db2617701dc029e87a9e175b5e4f1b1f7c6ab69","url":"https://github.com/JetBrains/kotlin"},{"original_method":"protected void createEnvironmentWithMockJdk() {\n        myEnvironment = new JetCoreEnvironment(getTestRootDisposable());\n        final File rtJar = new File(JetTestCaseBuilder.getHomeDirectory(), \"compiler/testData/mockJDK-1.7/jre/lib/rt.jar\");\n        myEnvironment.addToClasspath(rtJar);\n        myEnvironment.addToClasspath(new File(JetTestCaseBuilder.getHomeDirectory(), \"compiler/testData/mockJDK-1.7/jre/lib/annotations.jar\"));\n    }","id":75481,"modified_method":"protected void createEnvironmentWithMockJdk() {\n        myEnvironment = JetTestUtils.createEnvironmentWithMockJdk(getTestRootDisposable());\n    }","commit_id":"8db2617701dc029e87a9e175b5e4f1b1f7c6ab69","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public void runTest() throws Exception {\n        createMockCoreEnvironment();\n\n        LanguageASTFactory.INSTANCE.addExplicitExtension(JavaLanguage.INSTANCE, new JavaASTFactory());\n\n\n        String text = FileUtil.loadFile(testFile);\n\n        LightVirtualFile virtualFile = new LightVirtualFile(\"Hello.kt\", JetLanguage.INSTANCE, text);\n        virtualFile.setCharset(CharsetToolkit.UTF8_CHARSET);\n        JetFile psiFile = (JetFile) ((PsiFileFactoryImpl) PsiFileFactory.getInstance(jetCoreEnvironment.getProject())).trySetupPsiForFile(virtualFile, JetLanguage.INSTANCE, true, false);\n\n        GenerationState state = new GenerationState(jetCoreEnvironment.getProject(), ClassBuilderFactory.BINARIES);\n        AnalyzingUtils.checkForSyntacticErrors(psiFile);\n        BindingContext bindingContext = state.compile(psiFile);\n\n        ClassFileFactory classFileFactory = state.getFactory();\n\n        CompileEnvironment.writeToOutputDirectory(classFileFactory, tmpdir.getPath());\n        \n        NamespaceDescriptor namespaceFromSource = (NamespaceDescriptor) bindingContext.get(BindingContext.DECLARATION_TO_DESCRIPTOR, psiFile.getRootNamespace());\n\n        Assert.assertEquals(\"test\", namespaceFromSource.getName());\n\n        Disposer.dispose(myTestRootDisposable);\n        \n        \n        \n        createMockCoreEnvironment();\n        \n        jetCoreEnvironment.addToClasspath(tmpdir);\n\n        JetSemanticServices jetSemanticServices = JetSemanticServices.createSemanticServices(jetCoreEnvironment.getProject());\n        JavaSemanticServices semanticServices = new JavaSemanticServices(jetCoreEnvironment.getProject(), jetSemanticServices, new BindingTraceContext());\n\n        JavaDescriptorResolver javaDescriptorResolver = semanticServices.getDescriptorResolver();\n        NamespaceDescriptor namespaceFromClass = javaDescriptorResolver.resolveNamespace(\"test\");\n        \n        compareNamespaces(namespaceFromSource, namespaceFromClass);\n    }","id":75482,"modified_method":"@Override\n    public void runTest() throws Exception {\n        jetCoreEnvironment = JetTestUtils.createEnvironmentWithMockJdk(myTestRootDisposable);\n\n        LanguageASTFactory.INSTANCE.addExplicitExtension(JavaLanguage.INSTANCE, new JavaASTFactory());\n\n\n        String text = FileUtil.loadFile(testFile);\n\n        LightVirtualFile virtualFile = new LightVirtualFile(testFile.getName(), JetLanguage.INSTANCE, text);\n        virtualFile.setCharset(CharsetToolkit.UTF8_CHARSET);\n        JetFile psiFile = (JetFile) ((PsiFileFactoryImpl) PsiFileFactory.getInstance(jetCoreEnvironment.getProject())).trySetupPsiForFile(virtualFile, JetLanguage.INSTANCE, true, false);\n\n        GenerationState state = new GenerationState(jetCoreEnvironment.getProject(), ClassBuilderFactory.BINARIES);\n        AnalyzingUtils.checkForSyntacticErrors(psiFile);\n        BindingContext bindingContext = state.compile(psiFile);\n\n        ClassFileFactory classFileFactory = state.getFactory();\n\n        CompileEnvironment.writeToOutputDirectory(classFileFactory, tmpdir.getPath());\n        \n        NamespaceDescriptor namespaceFromSource = (NamespaceDescriptor) bindingContext.get(BindingContext.DECLARATION_TO_DESCRIPTOR, psiFile.getRootNamespace());\n\n        Assert.assertEquals(\"test\", namespaceFromSource.getName());\n\n        Disposer.dispose(myTestRootDisposable);\n\n\n        jetCoreEnvironment = JetTestUtils.createEnvironmentWithMockJdk(myTestRootDisposable);\n\n        jetCoreEnvironment.addToClasspath(tmpdir);\n\n        JetSemanticServices jetSemanticServices = JetSemanticServices.createSemanticServices(jetCoreEnvironment.getProject());\n        JavaSemanticServices semanticServices = new JavaSemanticServices(jetCoreEnvironment.getProject(), jetSemanticServices, new BindingTraceContext());\n\n        JavaDescriptorResolver javaDescriptorResolver = semanticServices.getDescriptorResolver();\n        NamespaceDescriptor namespaceFromClass = javaDescriptorResolver.resolveNamespace(\"test\");\n        \n        compareNamespaces(namespaceFromSource, namespaceFromClass);\n    }","commit_id":"8db2617701dc029e87a9e175b5e4f1b1f7c6ab69","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        tmpdir = new File(\"tmp/\" + this.getClass().getSimpleName() + \".\" + this.getName());\n        rmrf(tmpdir);\n        mkdirs(tmpdir);\n    }","id":75483,"modified_method":"@Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        tmpdir = new File(\"tmp/\" + this.getClass().getSimpleName() + \".\" + this.getName());\n        JetTestUtils.recreateDirectory(tmpdir);\n    }","commit_id":"8db2617701dc029e87a9e175b5e4f1b1f7c6ab69","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    protected void runTest() throws Throwable {\n        createMockCoreEnvironment();\n\n        LanguageASTFactory.INSTANCE.addExplicitExtension(JavaLanguage.INSTANCE, new JavaASTFactory());\n\n\n        String text = FileUtil.loadFile(ktFile);\n\n        LightVirtualFile virtualFile = new LightVirtualFile(\"Hello.kt\", JetLanguage.INSTANCE, text);\n        virtualFile.setCharset(CharsetToolkit.UTF8_CHARSET);\n        JetFile psiFile = (JetFile) ((PsiFileFactoryImpl) PsiFileFactory.getInstance(jetCoreEnvironment.getProject())).trySetupPsiForFile(virtualFile, JetLanguage.INSTANCE, true, false);\n\n        GenerationState state = new GenerationState(jetCoreEnvironment.getProject(), ClassBuilderFactory.BINARIES);\n        AnalyzingUtils.checkForSyntacticErrors(psiFile);\n        state.compile(psiFile);\n\n        ClassFileFactory classFileFactory = state.getFactory();\n\n        CompileEnvironment.writeToOutputDirectory(classFileFactory, tmpdir.getPath());\n\n        Disposer.dispose(myTestRootDisposable);\n\n        JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();\n\n        StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(null, Locale.ENGLISH, Charset.forName(\"utf-8\"));\n        try {\n            Iterable<? extends JavaFileObject> javaFileObjectsFromFiles = fileManager.getJavaFileObjectsFromFiles(Collections.singleton(javaFile));\n            List<String> options = Arrays.asList(\n                    \"-classpath\", tmpdir.getPath(),\n                    \"-d\", tmpdir.getPath()\n                );\n            JavaCompiler.CompilationTask task = javaCompiler.getTask(null, fileManager, null, options, null, javaFileObjectsFromFiles);\n\n            Assert.assertTrue(task.call());\n        } finally {\n            fileManager.close();\n        }\n    }","id":75484,"modified_method":"@Override\n    protected void runTest() throws Throwable {\n        jetCoreEnvironment = JetTestUtils.createEnvironmentWithMockJdk(myTestRootDisposable);\n\n        LanguageASTFactory.INSTANCE.addExplicitExtension(JavaLanguage.INSTANCE, new JavaASTFactory());\n\n\n        String text = FileUtil.loadFile(ktFile);\n\n        LightVirtualFile virtualFile = new LightVirtualFile(ktFile.getName(), JetLanguage.INSTANCE, text);\n        virtualFile.setCharset(CharsetToolkit.UTF8_CHARSET);\n        JetFile psiFile = (JetFile) ((PsiFileFactoryImpl) PsiFileFactory.getInstance(jetCoreEnvironment.getProject())).trySetupPsiForFile(virtualFile, JetLanguage.INSTANCE, true, false);\n\n        GenerationState state = new GenerationState(jetCoreEnvironment.getProject(), ClassBuilderFactory.BINARIES);\n        AnalyzingUtils.checkForSyntacticErrors(psiFile);\n        state.compile(psiFile);\n\n        ClassFileFactory classFileFactory = state.getFactory();\n\n        CompileEnvironment.writeToOutputDirectory(classFileFactory, tmpdir.getPath());\n\n        Disposer.dispose(myTestRootDisposable);\n\n        JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();\n\n        StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(null, Locale.ENGLISH, Charset.forName(\"utf-8\"));\n        try {\n            Iterable<? extends JavaFileObject> javaFileObjectsFromFiles = fileManager.getJavaFileObjectsFromFiles(Collections.singleton(javaFile));\n            List<String> options = Arrays.asList(\n                    \"-classpath\", tmpdir.getPath(),\n                    \"-d\", tmpdir.getPath()\n                );\n            JavaCompiler.CompilationTask task = javaCompiler.getTask(null, fileManager, null, options, null, javaFileObjectsFromFiles);\n\n            Assert.assertTrue(task.call());\n        } finally {\n            fileManager.close();\n        }\n    }","commit_id":"c76463256bfe65104e7a6e31e9f7b8aa8097d20c","url":"https://github.com/JetBrains/kotlin"},{"original_method":"protected void createEnvironmentWithMockJdk() {\n        myEnvironment = new JetCoreEnvironment(getTestRootDisposable());\n        final File rtJar = new File(JetTestCaseBuilder.getHomeDirectory(), \"compiler/testData/mockJDK-1.7/jre/lib/rt.jar\");\n        myEnvironment.addToClasspath(rtJar);\n        myEnvironment.addToClasspath(new File(JetTestCaseBuilder.getHomeDirectory(), \"compiler/testData/mockJDK-1.7/jre/lib/annotations.jar\"));\n    }","id":75485,"modified_method":"protected void createEnvironmentWithMockJdk() {\n        myEnvironment = JetTestUtils.createEnvironmentWithMockJdk(getTestRootDisposable());\n    }","commit_id":"c76463256bfe65104e7a6e31e9f7b8aa8097d20c","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public void runTest() throws Exception {\n        createMockCoreEnvironment();\n\n        LanguageASTFactory.INSTANCE.addExplicitExtension(JavaLanguage.INSTANCE, new JavaASTFactory());\n\n\n        String text = FileUtil.loadFile(testFile);\n\n        LightVirtualFile virtualFile = new LightVirtualFile(\"Hello.kt\", JetLanguage.INSTANCE, text);\n        virtualFile.setCharset(CharsetToolkit.UTF8_CHARSET);\n        JetFile psiFile = (JetFile) ((PsiFileFactoryImpl) PsiFileFactory.getInstance(jetCoreEnvironment.getProject())).trySetupPsiForFile(virtualFile, JetLanguage.INSTANCE, true, false);\n\n        GenerationState state = new GenerationState(jetCoreEnvironment.getProject(), ClassBuilderFactory.BINARIES);\n        AnalyzingUtils.checkForSyntacticErrors(psiFile);\n        BindingContext bindingContext = state.compile(psiFile);\n\n        ClassFileFactory classFileFactory = state.getFactory();\n\n        CompileEnvironment.writeToOutputDirectory(classFileFactory, tmpdir.getPath());\n        \n        NamespaceDescriptor namespaceFromSource = (NamespaceDescriptor) bindingContext.get(BindingContext.DECLARATION_TO_DESCRIPTOR, psiFile.getRootNamespace());\n\n        Assert.assertEquals(\"test\", namespaceFromSource.getName());\n\n        Disposer.dispose(myTestRootDisposable);\n        \n        \n        \n        createMockCoreEnvironment();\n        \n        jetCoreEnvironment.addToClasspath(tmpdir);\n\n        JetSemanticServices jetSemanticServices = JetSemanticServices.createSemanticServices(jetCoreEnvironment.getProject());\n        JavaSemanticServices semanticServices = new JavaSemanticServices(jetCoreEnvironment.getProject(), jetSemanticServices, new BindingTraceContext());\n\n        JavaDescriptorResolver javaDescriptorResolver = semanticServices.getDescriptorResolver();\n        NamespaceDescriptor namespaceFromClass = javaDescriptorResolver.resolveNamespace(\"test\");\n        \n        compareNamespaces(namespaceFromSource, namespaceFromClass);\n    }","id":75486,"modified_method":"@Override\n    public void runTest() throws Exception {\n        jetCoreEnvironment = JetTestUtils.createEnvironmentWithMockJdk(myTestRootDisposable);\n\n        LanguageASTFactory.INSTANCE.addExplicitExtension(JavaLanguage.INSTANCE, new JavaASTFactory());\n\n\n        String text = FileUtil.loadFile(testFile);\n\n        LightVirtualFile virtualFile = new LightVirtualFile(testFile.getName(), JetLanguage.INSTANCE, text);\n        virtualFile.setCharset(CharsetToolkit.UTF8_CHARSET);\n        JetFile psiFile = (JetFile) ((PsiFileFactoryImpl) PsiFileFactory.getInstance(jetCoreEnvironment.getProject())).trySetupPsiForFile(virtualFile, JetLanguage.INSTANCE, true, false);\n\n        GenerationState state = new GenerationState(jetCoreEnvironment.getProject(), ClassBuilderFactory.BINARIES);\n        AnalyzingUtils.checkForSyntacticErrors(psiFile);\n        BindingContext bindingContext = state.compile(psiFile);\n\n        ClassFileFactory classFileFactory = state.getFactory();\n\n        CompileEnvironment.writeToOutputDirectory(classFileFactory, tmpdir.getPath());\n        \n        NamespaceDescriptor namespaceFromSource = (NamespaceDescriptor) bindingContext.get(BindingContext.DECLARATION_TO_DESCRIPTOR, psiFile.getRootNamespace());\n\n        Assert.assertEquals(\"test\", namespaceFromSource.getName());\n\n        Disposer.dispose(myTestRootDisposable);\n\n\n        jetCoreEnvironment = JetTestUtils.createEnvironmentWithMockJdk(myTestRootDisposable);\n\n        jetCoreEnvironment.addToClasspath(tmpdir);\n\n        JetSemanticServices jetSemanticServices = JetSemanticServices.createSemanticServices(jetCoreEnvironment.getProject());\n        JavaSemanticServices semanticServices = new JavaSemanticServices(jetCoreEnvironment.getProject(), jetSemanticServices, new BindingTraceContext());\n\n        JavaDescriptorResolver javaDescriptorResolver = semanticServices.getDescriptorResolver();\n        NamespaceDescriptor namespaceFromClass = javaDescriptorResolver.resolveNamespace(\"test\");\n        \n        compareNamespaces(namespaceFromSource, namespaceFromClass);\n    }","commit_id":"c76463256bfe65104e7a6e31e9f7b8aa8097d20c","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static PsiExpression inlineVariable(PsiVariable variable, PsiExpression initializer, PsiJavaCodeReferenceElement ref)\n    throws IncorrectOperationException {\n    PsiManager manager = initializer.getManager();\n\n    PsiClass thisClass = RefactoringChangeUtil.getThisClass(initializer);\n    PsiClass refParent = RefactoringChangeUtil.getThisClass(ref);\n    final PsiElement parent = ref.getParent();\n    boolean insertCastWhenUnchecked = parent instanceof PsiForeachStatement;\n    final PsiType varType = variable.getType();\n    initializer = RefactoringUtil.convertInitializerToNormalExpression(initializer, varType);\n    if (initializer instanceof PsiPolyadicExpression &&\n        ((PsiPolyadicExpression)initializer).getOperationTokenType() == JavaTokenType.PLUS &&\n        parent instanceof PsiPolyadicExpression &&\n        ((PsiPolyadicExpression)parent).getOperationTokenType() == JavaTokenType.PLUS) {\n      final PsiType type = ((PsiPolyadicExpression)parent).getType();\n      if (type != null && (type.equalsToText(CommonClassNames.JAVA_LANG_STRING) ^ varType.equalsToText(CommonClassNames.JAVA_LANG_STRING))) {\n        final PsiElementFactory factory = JavaPsiFacade.getElementFactory(initializer.getProject());\n        initializer = factory.createExpressionFromText(\"(\" + initializer.getText() + \")\", initializer);\n      }\n    }\n    solveVariableNameConflicts(initializer, ref, initializer);\n\n    ChangeContextUtil.encodeContextInfo(initializer, false);\n    PsiExpression expr = (PsiExpression)replaceDiamondWithInferredTypesIfNeeded(initializer, ref);\n    PsiType exprType = expr.getType();\n    if (exprType != null && (!varType.equals(exprType) && (varType instanceof PsiPrimitiveType || exprType instanceof PsiPrimitiveType)\n                             || !TypeConversionUtil.isAssignable(varType, exprType)\n                             || insertCastWhenUnchecked && JavaGenericsUtil.isRawToGeneric(varType, exprType))) {\n      boolean matchedTypes = false;\n      //try explicit type arguments\n      final PsiElementFactory elementFactory = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory();\n      if (expr instanceof PsiCallExpression && ((PsiCallExpression)expr).getTypeArguments().length == 0) {\n        final JavaResolveResult resolveResult = ((PsiCallExpression)initializer).resolveMethodGenerics();\n        final PsiElement resolved = resolveResult.getElement();\n        if (resolved instanceof PsiMethod) {\n          final PsiTypeParameter[] typeParameters = ((PsiMethod)resolved).getTypeParameters();\n          if (typeParameters.length > 0) {\n            final PsiCallExpression copy = (PsiCallExpression)expr.copy();\n            for (final PsiTypeParameter typeParameter : typeParameters) {\n              final PsiType substituted = resolveResult.getSubstitutor().substitute(typeParameter);\n              if (substituted == null) break;\n              copy.getTypeArgumentList().add(elementFactory.createTypeElement(substituted));\n            }\n            if (varType.equals(copy.getType())) {\n              ((PsiCallExpression)expr).getTypeArgumentList().replace(copy.getTypeArgumentList());\n              if (expr instanceof PsiMethodCallExpression) {\n                final PsiReferenceExpression methodExpression = ((PsiMethodCallExpression)expr).getMethodExpression();\n                final PsiExpression qualifierExpression = methodExpression.getQualifierExpression();\n                if (qualifierExpression == null) {\n                  final PsiMethod method = (PsiMethod)resolved;\n                  final PsiClass containingClass = method.getContainingClass();\n                  LOG.assertTrue(containingClass != null);\n                  if (method.getModifierList().hasModifierProperty(PsiModifier.STATIC)) {\n                    methodExpression.setQualifierExpression(elementFactory.createReferenceExpression(containingClass));\n                  } else {\n                    methodExpression.setQualifierExpression(createThisExpression(manager, thisClass, refParent));\n                  }\n                }\n              }\n              matchedTypes = true;\n            }\n          }\n        }\n      }\n\n      if (!matchedTypes) {\n        if (varType instanceof PsiEllipsisType && ((PsiEllipsisType)varType).getComponentType().equals(exprType)) { //convert vararg to array\n\n          final PsiExpressionList argumentList = PsiTreeUtil.getParentOfType(expr, PsiExpressionList.class);\n          LOG.assertTrue(argumentList != null);\n          final PsiExpression[] arguments = argumentList.getExpressions();\n\n          @NonNls final StringBuilder builder = new StringBuilder(\"new \");\n          builder.append(exprType.getCanonicalText());\n          builder.append(\"[]{\");\n          builder.append(StringUtil.join(Arrays.asList(arguments), new Function<PsiExpression, String>() {\n            @Override\n            public String fun(final PsiExpression expr) {\n              return expr.getText();\n            }\n          }, \",\"));\n          builder.append('}');\n\n          expr.replace(JavaPsiFacade.getInstance(manager.getProject()).getElementFactory().createExpressionFromText(builder.toString(), argumentList));\n\n        } else {\n          //try cast\n          PsiTypeCastExpression cast = (PsiTypeCastExpression)elementFactory.createExpressionFromText(\"(t)a\", null);\n          PsiTypeElement castTypeElement = cast.getCastType();\n          assert castTypeElement != null;\n          castTypeElement.replace(variable.getTypeElement());\n          final PsiExpression operand = cast.getOperand();\n          assert operand != null;\n          operand.replace(expr);\n          PsiExpression exprCopy = (PsiExpression)expr.copy();\n          cast = (PsiTypeCastExpression)expr.replace(cast);\n          if (!RedundantCastUtil.isCastRedundant(cast)) {\n            expr = cast;\n          }\n          else {\n            PsiElement toReplace = cast;\n            while (toReplace.getParent() instanceof PsiParenthesizedExpression) {\n              toReplace = toReplace.getParent();\n            }\n            expr = (PsiExpression)toReplace.replace(exprCopy);\n          }\n        }\n      }\n    } else if (exprType instanceof PsiLambdaExpressionType) {\n      expr = surroundWithCast(variable, expr, ((PsiLambdaExpressionType)exprType).getExpression());\n    } else if (exprType instanceof PsiMethodReferenceType) {\n      expr = surroundWithCast(variable, expr, ((PsiMethodReferenceType)exprType).getExpression());\n    }\n\n    ChangeContextUtil.clearContextInfo(initializer);\n\n    PsiThisExpression thisAccessExpr = createThisExpression(manager, thisClass, refParent);\n\n    return (PsiExpression)ChangeContextUtil.decodeContextInfo(expr, thisClass, thisAccessExpr);\n  }","id":75487,"modified_method":"public static PsiExpression inlineVariable(PsiVariable variable, PsiExpression initializer, PsiJavaCodeReferenceElement ref)\n    throws IncorrectOperationException {\n    PsiManager manager = initializer.getManager();\n\n    PsiClass thisClass = RefactoringChangeUtil.getThisClass(initializer);\n    PsiClass refParent = RefactoringChangeUtil.getThisClass(ref);\n    final PsiElement parent = ref.getParent();\n    boolean insertCastWhenUnchecked = parent instanceof PsiForeachStatement;\n    final PsiType varType = variable.getType();\n    initializer = RefactoringUtil.convertInitializerToNormalExpression(initializer, varType);\n    if (initializer instanceof PsiPolyadicExpression) {\n      final IElementType operationTokenType = ((PsiPolyadicExpression)initializer).getOperationTokenType();\n      if ((operationTokenType == JavaTokenType.PLUS || operationTokenType == JavaTokenType.MINUS) &&\n          parent instanceof PsiPolyadicExpression && ((PsiPolyadicExpression)parent).getOperationTokenType() == JavaTokenType.PLUS) {\n        final PsiType type = ((PsiPolyadicExpression)parent).getType();\n        if (type != null && type.equalsToText(CommonClassNames.JAVA_LANG_STRING)) {\n          final PsiElementFactory factory = JavaPsiFacade.getElementFactory(initializer.getProject());\n          initializer = factory.createExpressionFromText(\"(\" + initializer.getText() + \")\", initializer);\n        }\n      }\n    }\n    solveVariableNameConflicts(initializer, ref, initializer);\n\n    ChangeContextUtil.encodeContextInfo(initializer, false);\n    PsiExpression expr = (PsiExpression)replaceDiamondWithInferredTypesIfNeeded(initializer, ref);\n    PsiType exprType = expr.getType();\n    if (exprType != null && (!varType.equals(exprType) && (varType instanceof PsiPrimitiveType || exprType instanceof PsiPrimitiveType)\n                             || !TypeConversionUtil.isAssignable(varType, exprType)\n                             || insertCastWhenUnchecked && JavaGenericsUtil.isRawToGeneric(varType, exprType))) {\n      boolean matchedTypes = false;\n      //try explicit type arguments\n      final PsiElementFactory elementFactory = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory();\n      if (expr instanceof PsiCallExpression && ((PsiCallExpression)expr).getTypeArguments().length == 0) {\n        final JavaResolveResult resolveResult = ((PsiCallExpression)initializer).resolveMethodGenerics();\n        final PsiElement resolved = resolveResult.getElement();\n        if (resolved instanceof PsiMethod) {\n          final PsiTypeParameter[] typeParameters = ((PsiMethod)resolved).getTypeParameters();\n          if (typeParameters.length > 0) {\n            final PsiCallExpression copy = (PsiCallExpression)expr.copy();\n            for (final PsiTypeParameter typeParameter : typeParameters) {\n              final PsiType substituted = resolveResult.getSubstitutor().substitute(typeParameter);\n              if (substituted == null) break;\n              copy.getTypeArgumentList().add(elementFactory.createTypeElement(substituted));\n            }\n            if (varType.equals(copy.getType())) {\n              ((PsiCallExpression)expr).getTypeArgumentList().replace(copy.getTypeArgumentList());\n              if (expr instanceof PsiMethodCallExpression) {\n                final PsiReferenceExpression methodExpression = ((PsiMethodCallExpression)expr).getMethodExpression();\n                final PsiExpression qualifierExpression = methodExpression.getQualifierExpression();\n                if (qualifierExpression == null) {\n                  final PsiMethod method = (PsiMethod)resolved;\n                  final PsiClass containingClass = method.getContainingClass();\n                  LOG.assertTrue(containingClass != null);\n                  if (method.getModifierList().hasModifierProperty(PsiModifier.STATIC)) {\n                    methodExpression.setQualifierExpression(elementFactory.createReferenceExpression(containingClass));\n                  } else {\n                    methodExpression.setQualifierExpression(createThisExpression(manager, thisClass, refParent));\n                  }\n                }\n              }\n              matchedTypes = true;\n            }\n          }\n        }\n      }\n\n      if (!matchedTypes) {\n        if (varType instanceof PsiEllipsisType && ((PsiEllipsisType)varType).getComponentType().equals(exprType)) { //convert vararg to array\n\n          final PsiExpressionList argumentList = PsiTreeUtil.getParentOfType(expr, PsiExpressionList.class);\n          LOG.assertTrue(argumentList != null);\n          final PsiExpression[] arguments = argumentList.getExpressions();\n\n          @NonNls final StringBuilder builder = new StringBuilder(\"new \");\n          builder.append(exprType.getCanonicalText());\n          builder.append(\"[]{\");\n          builder.append(StringUtil.join(Arrays.asList(arguments), new Function<PsiExpression, String>() {\n            @Override\n            public String fun(final PsiExpression expr) {\n              return expr.getText();\n            }\n          }, \",\"));\n          builder.append('}');\n\n          expr.replace(JavaPsiFacade.getInstance(manager.getProject()).getElementFactory().createExpressionFromText(builder.toString(), argumentList));\n\n        } else {\n          //try cast\n          PsiTypeCastExpression cast = (PsiTypeCastExpression)elementFactory.createExpressionFromText(\"(t)a\", null);\n          PsiTypeElement castTypeElement = cast.getCastType();\n          assert castTypeElement != null;\n          castTypeElement.replace(variable.getTypeElement());\n          final PsiExpression operand = cast.getOperand();\n          assert operand != null;\n          operand.replace(expr);\n          PsiExpression exprCopy = (PsiExpression)expr.copy();\n          cast = (PsiTypeCastExpression)expr.replace(cast);\n          if (!RedundantCastUtil.isCastRedundant(cast)) {\n            expr = cast;\n          }\n          else {\n            PsiElement toReplace = cast;\n            while (toReplace.getParent() instanceof PsiParenthesizedExpression) {\n              toReplace = toReplace.getParent();\n            }\n            expr = (PsiExpression)toReplace.replace(exprCopy);\n          }\n        }\n      }\n    } else if (exprType instanceof PsiLambdaExpressionType) {\n      expr = surroundWithCast(variable, expr, ((PsiLambdaExpressionType)exprType).getExpression());\n    } else if (exprType instanceof PsiMethodReferenceType) {\n      expr = surroundWithCast(variable, expr, ((PsiMethodReferenceType)exprType).getExpression());\n    }\n\n    ChangeContextUtil.clearContextInfo(initializer);\n\n    PsiThisExpression thisAccessExpr = createThisExpression(manager, thisClass, refParent);\n\n    return (PsiExpression)ChangeContextUtil.decodeContextInfo(expr, thisClass, thisAccessExpr);\n  }","commit_id":"5f788d7c13c1e9979bb1882f95d623d27e2a40d7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement getOperationToken() {\n    final PsiElement child = findChildByType(TokenSets.BINARY_OP_SET);\n    return child;\n  }","id":75488,"modified_method":"@Nullable\n  public PsiElement getOperationToken() {\n    return findChildByType(TokenSets.BINARY_OP_SET);\n  }","commit_id":"5b149baa64c5a3e5690c7cd7c4e3239348faf3d7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isDoubleOrFloat(PsiType type) {\n    return type.equalsToText(DOUBLE_FQ_NAME) || type.equalsToText(FLOAT_FQ_NAME);\n  }","id":75489,"modified_method":"private static boolean isDoubleOrFloat(PsiType type) {\n    return type != null && (type.equalsToText(JAVA_LANG_DOUBLE) || type.equalsToText(JAVA_LANG_FLOAT));\n  }","commit_id":"5b149baa64c5a3e5690c7cd7c4e3239348faf3d7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Creates Groovy PSI element by given AST node\n   *\n   * @param node Given node\n   * @return Respective PSI element\n   */\n  public static PsiElement createElement(ASTNode node) {\n    IElementType elem = node.getElementType();\n\n    if (elem instanceof GroovyElementType.PsiCreator) {\n      return ((GroovyElementType.PsiCreator)elem).createPsi(node);\n    }\n\n    if (elem instanceof IGroovyDocElementType) {\n      return GroovyDocPsiCreator.createElement(node);\n    }\n\n    //Identifiers & literal\n    if (elem.equals(LITERAL)) return new GrLiteralImpl(node);\n    if (elem.equals(LABEL)) return new GrLabelImpl(node);\n//    if (elem.equals(IDENTIFIER)) return new GrIdentifierImpl(node);\n    //Lists, maps etc...\n    if (elem.equals(LIST_OR_MAP)) return new GrListOrMapImpl(node);\n\n    if (elem.equals(MODIFIERS)) return new GrModifierListImpl(node);\n    if (elem.equals(ANNOTATION)) return new GrAnnotationImpl(node);\n    if (elem.equals(ANNOTATION_ARGUMENTS)) return new GrAnnotationArgumentListImpl(node);\n    if (elem.equals(ANNOTATION_ARRAY_INITIALIZER)) return new GrAnnotationArrrayInitializerImpl(node);\n    if (elem.equals(ANNOTATION_MEMBER_VALUE_PAIR)) return new GrAnnotationNameValuePairImpl(node);\n    if (elem.equals(ANNOTATION_MEMBER_VALUE_PAIRS)) return new GrAnnotationNameValuePairsImpl(node);\n\n    if (elem.equals(DEFAULT_ANNOTATION_VALUE)) return new GrDefaultAnnotationValueImpl(node);\n\n    //throws\n    if (elem.equals(THROW_CLAUSE)) return new GrThrowsClauseImpl(node);\n\n    // Imports\n    if (elem.equals(IMPORT_STATEMENT)) return new GrImportStatementImpl(node);\n\n    // Packaging\n    if (elem.equals(PACKAGE_DEFINITION)) return new GrPackageDefinitionImpl(node);\n\n    //statements\n    if (elem.equals(LABELED_STATEMENT)) return new GrLabeledStatementImpl(node);\n    if (elem.equals(IF_STATEMENT)) return new GrIfStatementImpl(node);\n    if (elem.equals(FOR_STATEMENT)) return new GrForStatementImpl(node);\n    if (elem.equals(FOR_IN_CLAUSE)) return new GrForInClauseImpl(node);\n    if (elem.equals(FOR_TRADITIONAL_CLAUSE)) return new GrTraditionalForClauseImpl(node);\n    if (elem.equals(WHILE_STATEMENT)) return new GrWhileStatementImpl(node);\n    if (elem.equals(TRY_BLOCK_STATEMENT)) return new GrTryCatchStatementImpl(node);\n    if (elem.equals(CATCH_CLAUSE)) return new GrCatchClauseImpl(node);\n    if (elem.equals(FINALLY_CLAUSE)) return new GrFinallyClauseImpl(node);\n    if (elem.equals(SYNCHRONIZED_STATEMENT)) return new GrSynchronizedStatementImpl(node);\n    if (elem.equals(SWITCH_STATEMENT)) return new GrSwitchStatementImpl(node);\n    if (elem.equals(CASE_LABEL)) return new GrCaseLabelImpl(node);\n    if (elem.equals(CASE_SECTION)) return new GrCaseSectionImpl(node);\n    if (elem.equals(VARIABLE_DEFINITION) || elem.equals(VARIABLE_DEFINITION_ERROR))\n      return new GrVariableDeclarationBase.GrVariables(node);\n    if (elem.equals(MULTIPLE_VARIABLE_DEFINITION))\n      return new GrVariableDeclarationBase.GrMultipleVariables(node);\n    if (elem.equals(TUPLE_DECLARATION) || elem.equals(TUPLE_ERROR)) return new GrTupleDeclarationImpl(node);\n    if (elem.equals(TUPLE_EXPRESSION)) return new GrTupleExpressionImpl(node);\n    if (elem.equals(VARIABLE)) return new GrVariableImpl(node);\n\n    if (elem.equals(FIELD)) return new GrFieldImpl(node);\n    if (elem.equals(CLASS_INITIALIZER)) return new GrClassInitializerImpl(node);\n\n    //type definitions\n    if (elem.equals(CLASS_DEFINITION)) return new GrClassDefinitionImpl(node);\n    if (elem.equals(INTERFACE_DEFINITION))\n      return new GrInterfaceDefinitionImpl(node);\n    if (elem.equals(ENUM_DEFINITION)) return new GrEnumTypeDefinitionImpl(node);\n    if (elem.equals(ANNOTATION_DEFINITION))\n      return new GrAnnotationTypeDefinitionImpl(node);\n    if (elem.equals(ANNOTATION_METHOD)) return new GrAnnotationMethodImpl(node);\n\n    if (elem.equals(REFERENCE_ELEMENT)) return new GrCodeReferenceElementImpl(node);\n    if (elem.equals(CLASS_TYPE_ELEMENT)) return new GrClassTypeElementImpl(node);\n\n    //clauses\n    if (elem.equals(IMPLEMENTS_CLAUSE)) return new GrImplementsClauseImpl(node);\n    if (elem.equals(EXTENDS_CLAUSE)) return new GrExtendsClauseImpl(node);\n\n    //bodies\n    if (elem.equals(CLASS_BODY)) return new GrTypeDefinitionBodyBase.GrClassBody(node);\n    if (elem.equals(ENUM_BODY)) return new GrTypeDefinitionBodyBase.GrEnumBody(node);\n    if (elem.equals(BLOCK_STATEMENT)) return new GrBlockStatementImpl(node);\n    if (elem.equals(EXPLICIT_CONSTRUCTOR)) return new GrConstructorInvocationImpl(node);\n\n    //enum\n    if (elem.equals(ENUM_CONSTANTS)) return new GrEnumConstantListImpl(node);\n    if (elem.equals(ENUM_CONSTANT)) return new GrEnumConstantImpl(node);\n\n    //members\n    if (elem.equals(CONSTRUCTOR_DEFINITION)) return new GrConstructorImpl(node);\n    if (elem.equals(METHOD_DEFINITION)) return new GrMethodImpl(node);\n\n    //parameters\n    if (elem.equals(PARAMETERS_LIST)) return new GrParameterListImpl(node);\n    if (elem.equals(PARAMETER)) return new GrParameterImpl(node);\n\n    //type parameters\n    if (elem.equals(TYPE_ARGUMENT)) return new GrWildcardTypeArgumentImpl(node);\n    if (elem.equals(TYPE_ARGUMENTS)) return new GrTypeArgumentListImpl(node);\n\n\n    if (elem.equals(TYPE_PARAMETER_LIST)) return new GrTypeParameterListImpl(node);\n    if (elem.equals(TYPE_PARAMETER)) return new GrTypeParameterImpl(node);\n    if (elem.equals(TYPE_PARAMETER_EXTENDS_BOUND_LIST)) return new GrTypeParameterParameterExtendsListImpl(node);\n\n    //Branch statements\n    if (elem.equals(RETURN_STATEMENT)) return new GrReturnStatementImpl(node);\n    if (elem.equals(THROW_STATEMENT)) return new GrThrowStatementImpl(node);\n    if (elem.equals(ASSERT_STATEMENT)) return new GrAssertStatementImpl(node);\n    if (elem.equals(BREAK_STATEMENT)) return new GrBreakStatementImpl(node);\n    if (elem.equals(CONTINUE_STATEMENT)) return new GrContinueStatementImpl(node);\n\n    //expressions\n    if (elem.equals(CALL_EXPRESSION)) return new GrApplicationStatementImpl(node);\n    if (elem.equals(COMMAND_ARGUMENTS)) return new GrCommandArgumentListImpl(node);\n    if (elem.equals(CONDITIONAL_EXPRESSION)) return new GrConditionalExprImpl(node);\n    if (elem.equals(ELVIS_EXPRESSION)) return new GrElvisExprImpl(node);\n    if (elem.equals(ASSIGNMENT_EXPRESSION)) return new GrAssignmentExpressionImpl(node);\n    if (elem.equals(LOGICAL_OR_EXPRESSION)) return new GrLogicalOrExpressionImpl(node);\n    if (elem.equals(LOGICAL_AND_EXPRESSION)) return new GrLogicalAndExpressionImpl(node);\n    if (elem.equals(EXCLUSIVE_OR_EXPRESSION)) return new GrExclusiveOrExpressionImpl(node);\n    if (elem.equals(INCLUSIVE_OR_EXPRESSION)) return new GrInclusiveOrExpressionImpl(node);\n    if (elem.equals(AND_EXPRESSION)) return new GrAndExpressionImpl(node);\n    if (elem.equals(REGEX_MATCH_EXPRESSION)) return new GrRegexMatchExpressionImpl(node);\n    if (elem.equals(REGEX_FIND_EXPRESSION)) return new GrRegexFindExpressionImpl(node);\n    if (elem.equals(EQUALITY_EXPRESSION)) return new GrEqualityExpressionImpl(node);\n    if (elem.equals(RELATIONAL_EXPRESSION)) return new GrRelationalExpressionImpl(node);\n    if (elem.equals(SHIFT_EXPRESSION)) return new GrShiftExpressionImpl(node);\n    if (elem.equals(RANGE_EXPRESSION)) return new GrRangeExpressionImpl(node);\n    if (elem.equals(COMPOSITE_SHIFT_SIGN)) return new GrOperationSignImpl(node);\n    if (elem.equals(ADDITIVE_EXPRESSION)) return new GrAdditiveExpressionImpl(node);\n    if (elem.equals(MULTIPLICATIVE_EXPRESSION)) return new GrMultiplicativeExpressionImpl(node);\n    if (elem.equals(POWER_EXPRESSION)) return new GrPowerExpressionImpl(node);\n    if (elem.equals(POWER_EXPRESSION_SIMPLE)) return new GrPowerExpressionImpl(node);\n    if (elem.equals(UNARY_EXPRESSION)) return new GrUnaryExpressionImpl(node);\n    if (elem.equals(POSTFIX_EXPRESSION)) return new GrPostfixExprImpl(node);\n    if (elem.equals(CAST_EXPRESSION)) return new GrTypeCastExpressionImpl(node);\n    if (elem.equals(SAFE_CAST_EXPRESSION)) return new GrSafeCastExpressionImpl(node);\n    if (elem.equals(INSTANCEOF_EXPRESSION)) return new GrInstanceofExpressionImpl(node);\n    if (elem.equals(BUILT_IN_TYPE_EXPRESSION)) return new GrBuiltinTypeClassExpressionImpl(node);\n    if (elem.equals(ARRAY_TYPE)) return new GrArrayTypeElementImpl(node);\n    if (elem.equals(BUILT_IN_TYPE)) return new GrBuiltInTypeElementImpl(node);\n    if (elem.equals(GSTRING)) return new GrStringImpl(node);\n    if (elem.equals(REGEX)) return new GrRegexImpl(node);\n    if (elem.equals(GSTRING_INJECTION)) return new GrStringInjectionImpl(node);\n    if (elem.equals(REFERENCE_EXPRESSION)) return new GrReferenceExpressionImpl(node);\n    if (elem.equals(THIS_REFERENCE_EXPRESSION)) return new GrThisReferenceExpressionImpl(node);\n    if (elem.equals(SUPER_REFERENCE_EXPRESSION)) return new GrSuperReferenceExpressionImpl(node);\n    if (elem.equals(PARENTHESIZED_EXPRESSION)) return new GrParenthesizedExpressionImpl(node);\n    if (elem.equals(NEW_EXPRESSION)) return new GrNewExpressionImpl(node);\n    if (elem.equals(ANONYMOUS_CLASS_DEFINITION)) return new GrAnonymousClassDefinitionImpl(node);\n    if (elem.equals(ARRAY_DECLARATOR)) return new GrArrayDeclarationImpl(node);\n\n    //Paths\n    if (elem.equals(PATH_PROPERTY)) return new GrPropertySelectorImpl(node);\n    if (elem.equals(PATH_PROPERTY_REFERENCE)) return new GrPropertySelectionImpl(node);\n    if (elem.equals(PATH_METHOD_CALL)) return new GrMethodCallExpressionImpl(node);\n    if (elem.equals(PATH_INDEX_PROPERTY)) return new GrIndexPropertyImpl(node);\n\n    // Arguments\n    if (elem.equals(ARGUMENTS)) return new GrArgumentListImpl(node);\n    if (elem.equals(ARGUMENT)) return new GrNamedArgumentImpl(node);\n    if (elem.equals(ARGUMENT_LABEL)) return new GrArgumentLabelImpl(node);\n\n    if (elem.equals(BALANCED_BRACKETS)) return new GroovyPsiElementImpl(node){};\n\n    return new ASTWrapperPsiElement(node);\n  }","id":75490,"modified_method":"/**\n   * Creates Groovy PSI element by given AST node\n   *\n   * @param node Given node\n   * @return Respective PSI element\n   */\n  public static PsiElement createElement(ASTNode node) {\n    IElementType elem = node.getElementType();\n\n    if (elem instanceof GroovyElementType.PsiCreator) {\n      return ((GroovyElementType.PsiCreator)elem).createPsi(node);\n    }\n\n    if (elem instanceof IGroovyDocElementType) {\n      return GroovyDocPsiCreator.createElement(node);\n    }\n\n    //Identifiers & literal\n    if (elem.equals(LITERAL)) return new GrLiteralImpl(node);\n    if (elem.equals(LABEL)) return new GrLabelImpl(node);\n//    if (elem.equals(IDENTIFIER)) return new GrIdentifierImpl(node);\n    //Lists, maps etc...\n    if (elem.equals(LIST_OR_MAP)) return new GrListOrMapImpl(node);\n\n    if (elem.equals(MODIFIERS)) return new GrModifierListImpl(node);\n    if (elem.equals(ANNOTATION)) return new GrAnnotationImpl(node);\n    if (elem.equals(ANNOTATION_ARGUMENTS)) return new GrAnnotationArgumentListImpl(node);\n    if (elem.equals(ANNOTATION_ARRAY_INITIALIZER)) return new GrAnnotationArrrayInitializerImpl(node);\n    if (elem.equals(ANNOTATION_MEMBER_VALUE_PAIR)) return new GrAnnotationNameValuePairImpl(node);\n    if (elem.equals(ANNOTATION_MEMBER_VALUE_PAIRS)) return new GrAnnotationNameValuePairsImpl(node);\n\n    if (elem.equals(DEFAULT_ANNOTATION_VALUE)) return new GrDefaultAnnotationValueImpl(node);\n\n    //throws\n    if (elem.equals(THROW_CLAUSE)) return new GrThrowsClauseImpl(node);\n\n    // Imports\n    if (elem.equals(IMPORT_STATEMENT)) return new GrImportStatementImpl(node);\n\n    // Packaging\n    if (elem.equals(PACKAGE_DEFINITION)) return new GrPackageDefinitionImpl(node);\n\n    //statements\n    if (elem.equals(LABELED_STATEMENT)) return new GrLabeledStatementImpl(node);\n    if (elem.equals(IF_STATEMENT)) return new GrIfStatementImpl(node);\n    if (elem.equals(FOR_STATEMENT)) return new GrForStatementImpl(node);\n    if (elem.equals(FOR_IN_CLAUSE)) return new GrForInClauseImpl(node);\n    if (elem.equals(FOR_TRADITIONAL_CLAUSE)) return new GrTraditionalForClauseImpl(node);\n    if (elem.equals(WHILE_STATEMENT)) return new GrWhileStatementImpl(node);\n    if (elem.equals(TRY_BLOCK_STATEMENT)) return new GrTryCatchStatementImpl(node);\n    if (elem.equals(CATCH_CLAUSE)) return new GrCatchClauseImpl(node);\n    if (elem.equals(FINALLY_CLAUSE)) return new GrFinallyClauseImpl(node);\n    if (elem.equals(SYNCHRONIZED_STATEMENT)) return new GrSynchronizedStatementImpl(node);\n    if (elem.equals(SWITCH_STATEMENT)) return new GrSwitchStatementImpl(node);\n    if (elem.equals(CASE_LABEL)) return new GrCaseLabelImpl(node);\n    if (elem.equals(CASE_SECTION)) return new GrCaseSectionImpl(node);\n    if (elem.equals(VARIABLE_DEFINITION) || elem.equals(VARIABLE_DEFINITION_ERROR))\n      return new GrVariableDeclarationBase.GrVariables(node);\n    if (elem.equals(MULTIPLE_VARIABLE_DEFINITION))\n      return new GrVariableDeclarationBase.GrMultipleVariables(node);\n    if (elem.equals(TUPLE_DECLARATION) || elem.equals(TUPLE_ERROR)) return new GrTupleDeclarationImpl(node);\n    if (elem.equals(TUPLE_EXPRESSION)) return new GrTupleExpressionImpl(node);\n    if (elem.equals(VARIABLE)) return new GrVariableImpl(node);\n\n    if (elem.equals(FIELD)) return new GrFieldImpl(node);\n    if (elem.equals(CLASS_INITIALIZER)) return new GrClassInitializerImpl(node);\n\n    //type definitions\n    if (elem.equals(CLASS_DEFINITION)) return new GrClassDefinitionImpl(node);\n    if (elem.equals(INTERFACE_DEFINITION))\n      return new GrInterfaceDefinitionImpl(node);\n    if (elem.equals(ENUM_DEFINITION)) return new GrEnumTypeDefinitionImpl(node);\n    if (elem.equals(ANNOTATION_DEFINITION))\n      return new GrAnnotationTypeDefinitionImpl(node);\n    if (elem.equals(ANNOTATION_METHOD)) return new GrAnnotationMethodImpl(node);\n\n    if (elem.equals(REFERENCE_ELEMENT)) return new GrCodeReferenceElementImpl(node);\n    if (elem.equals(CLASS_TYPE_ELEMENT)) return new GrClassTypeElementImpl(node);\n\n    //clauses\n    if (elem.equals(IMPLEMENTS_CLAUSE)) return new GrImplementsClauseImpl(node);\n    if (elem.equals(EXTENDS_CLAUSE)) return new GrExtendsClauseImpl(node);\n\n    //bodies\n    if (elem.equals(CLASS_BODY)) return new GrTypeDefinitionBodyBase.GrClassBody(node);\n    if (elem.equals(ENUM_BODY)) return new GrTypeDefinitionBodyBase.GrEnumBody(node);\n    if (elem.equals(BLOCK_STATEMENT)) return new GrBlockStatementImpl(node);\n    if (elem.equals(EXPLICIT_CONSTRUCTOR)) return new GrConstructorInvocationImpl(node);\n\n    //enum\n    if (elem.equals(ENUM_CONSTANTS)) return new GrEnumConstantListImpl(node);\n    if (elem.equals(ENUM_CONSTANT)) return new GrEnumConstantImpl(node);\n\n    //members\n    if (elem.equals(CONSTRUCTOR_DEFINITION)) return new GrConstructorImpl(node);\n    if (elem.equals(METHOD_DEFINITION)) return new GrMethodImpl(node);\n\n    //parameters\n    if (elem.equals(PARAMETERS_LIST)) return new GrParameterListImpl(node);\n    if (elem.equals(PARAMETER)) return new GrParameterImpl(node);\n\n    //type parameters\n    if (elem.equals(TYPE_ARGUMENT)) return new GrWildcardTypeArgumentImpl(node);\n    if (elem.equals(TYPE_ARGUMENTS)) return new GrTypeArgumentListImpl(node);\n\n\n    if (elem.equals(TYPE_PARAMETER_LIST)) return new GrTypeParameterListImpl(node);\n    if (elem.equals(TYPE_PARAMETER)) return new GrTypeParameterImpl(node);\n    if (elem.equals(TYPE_PARAMETER_EXTENDS_BOUND_LIST)) return new GrTypeParameterParameterExtendsListImpl(node);\n\n    //Branch statements\n    if (elem.equals(RETURN_STATEMENT)) return new GrReturnStatementImpl(node);\n    if (elem.equals(THROW_STATEMENT)) return new GrThrowStatementImpl(node);\n    if (elem.equals(ASSERT_STATEMENT)) return new GrAssertStatementImpl(node);\n    if (elem.equals(BREAK_STATEMENT)) return new GrBreakStatementImpl(node);\n    if (elem.equals(CONTINUE_STATEMENT)) return new GrContinueStatementImpl(node);\n\n    //expressions\n    if (elem.equals(CALL_EXPRESSION)) return new GrApplicationStatementImpl(node);\n    if (elem.equals(COMMAND_ARGUMENTS)) return new GrCommandArgumentListImpl(node);\n    if (elem.equals(CONDITIONAL_EXPRESSION)) return new GrConditionalExprImpl(node);\n    if (elem.equals(ELVIS_EXPRESSION)) return new GrElvisExprImpl(node);\n    if (elem.equals(ASSIGNMENT_EXPRESSION)) return new GrAssignmentExpressionImpl(node);\n\n    if (elem.equals(LOGICAL_OR_EXPRESSION)) return new GrLogicalExpressionImpl(node);\n    if (elem.equals(LOGICAL_AND_EXPRESSION)) return new GrLogicalExpressionImpl(node);\n\n    if (elem.equals(EXCLUSIVE_OR_EXPRESSION)) return new GrBitwiseExpressionImpl(node);\n    if (elem.equals(INCLUSIVE_OR_EXPRESSION)) return new GrBitwiseExpressionImpl(node);\n    if (elem.equals(AND_EXPRESSION)) return new GrBitwiseExpressionImpl(node);\n\n    if (elem.equals(REGEX_MATCH_EXPRESSION)) return new GrLogicalExpressionImpl(node);\n    if (elem.equals(REGEX_FIND_EXPRESSION)) return new GrRegexFindExpressionImpl(node);\n    if (elem.equals(EQUALITY_EXPRESSION)) return new GrRelationalExpressionImpl(node);\n    if (elem.equals(RELATIONAL_EXPRESSION)) return new GrRelationalExpressionImpl(node);\n    if (elem.equals(SHIFT_EXPRESSION)) return new GrShiftExpressionImpl(node);\n    if (elem.equals(RANGE_EXPRESSION)) return new GrRangeExpressionImpl(node);\n    if (elem.equals(COMPOSITE_SHIFT_SIGN)) return new GrOperationSignImpl(node);\n    if (elem.equals(ADDITIVE_EXPRESSION)) return new GrAdditiveExpressionImpl(node);\n    if (elem.equals(MULTIPLICATIVE_EXPRESSION)) return new GrMultiplicativeExpressionImpl(node);\n    if (elem.equals(POWER_EXPRESSION)) return new GrPowerExpressionImpl(node);\n    if (elem.equals(POWER_EXPRESSION_SIMPLE)) return new GrPowerExpressionImpl(node);\n    if (elem.equals(UNARY_EXPRESSION)) return new GrUnaryExpressionImpl(node);\n    if (elem.equals(POSTFIX_EXPRESSION)) return new GrPostfixExprImpl(node);\n    if (elem.equals(CAST_EXPRESSION)) return new GrTypeCastExpressionImpl(node);\n    if (elem.equals(SAFE_CAST_EXPRESSION)) return new GrSafeCastExpressionImpl(node);\n    if (elem.equals(INSTANCEOF_EXPRESSION)) return new GrInstanceofExpressionImpl(node);\n    if (elem.equals(BUILT_IN_TYPE_EXPRESSION)) return new GrBuiltinTypeClassExpressionImpl(node);\n    if (elem.equals(ARRAY_TYPE)) return new GrArrayTypeElementImpl(node);\n    if (elem.equals(BUILT_IN_TYPE)) return new GrBuiltInTypeElementImpl(node);\n    if (elem.equals(GSTRING)) return new GrStringImpl(node);\n    if (elem.equals(REGEX)) return new GrRegexImpl(node);\n    if (elem.equals(GSTRING_INJECTION)) return new GrStringInjectionImpl(node);\n    if (elem.equals(REFERENCE_EXPRESSION)) return new GrReferenceExpressionImpl(node);\n    if (elem.equals(THIS_REFERENCE_EXPRESSION)) return new GrThisReferenceExpressionImpl(node);\n    if (elem.equals(SUPER_REFERENCE_EXPRESSION)) return new GrSuperReferenceExpressionImpl(node);\n    if (elem.equals(PARENTHESIZED_EXPRESSION)) return new GrParenthesizedExpressionImpl(node);\n    if (elem.equals(NEW_EXPRESSION)) return new GrNewExpressionImpl(node);\n    if (elem.equals(ANONYMOUS_CLASS_DEFINITION)) return new GrAnonymousClassDefinitionImpl(node);\n    if (elem.equals(ARRAY_DECLARATOR)) return new GrArrayDeclarationImpl(node);\n\n    //Paths\n    if (elem.equals(PATH_PROPERTY)) return new GrPropertySelectorImpl(node);\n    if (elem.equals(PATH_PROPERTY_REFERENCE)) return new GrPropertySelectionImpl(node);\n    if (elem.equals(PATH_METHOD_CALL)) return new GrMethodCallExpressionImpl(node);\n    if (elem.equals(PATH_INDEX_PROPERTY)) return new GrIndexPropertyImpl(node);\n\n    // Arguments\n    if (elem.equals(ARGUMENTS)) return new GrArgumentListImpl(node);\n    if (elem.equals(ARGUMENT)) return new GrNamedArgumentImpl(node);\n    if (elem.equals(ARGUMENT_LABEL)) return new GrArgumentLabelImpl(node);\n\n    if (elem.equals(BALANCED_BRACKETS)) return new GroovyPsiElementImpl(node){};\n\n    return new ASTWrapperPsiElement(node);\n  }","commit_id":"5b149baa64c5a3e5690c7cd7c4e3239348faf3d7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static int getExprPriorityLevel(GrExpression expr) {\n    int priority = 0;\n    //if (expr instanceof GrNewExpression) priority = 1;\n    if (expr instanceof GrPostfixExpression) priority = 5;\n    if (expr instanceof GrUnaryExpression ||\n        expr instanceof GrTypeCastExpression) priority = 6;\n    if (expr instanceof GrPowerExpressionImpl) priority = 7;\n    if (expr instanceof GrMultiplicativeExpressionImpl) priority = 8;\n    if (expr instanceof GrAdditiveExpressionImpl) priority = 9;\n    if (expr instanceof GrShiftExpressionImpl) priority = 10;\n    if (expr instanceof GrRangeExpressionImpl) priority = 11;\n    if (expr instanceof GrRelationalExpression) priority = 12;\n    if (expr instanceof GrEqualityExpressionImpl) priority = 13;\n    if (expr instanceof GrRegexExpressionImpl) priority = 14;\n    if (expr instanceof GrAndExpressionImpl) priority = 15;\n    if (expr instanceof GrExclusiveOrExpressionImpl) priority = 16;\n    if (expr instanceof GrInclusiveOrExpressionImpl) priority = 17;\n    if (expr instanceof GrLogicalAndExpressionImpl) priority = 18;\n    if (expr instanceof GrLogicalOrExpressionImpl) priority = 19;\n    if (expr instanceof GrConditionalExpression) priority = 20;\n    if (expr instanceof GrSafeCastExpression) priority = 21;\n    if (expr instanceof GrAssignmentExpression) priority = 22;\n    if (expr instanceof GrApplicationStatement) priority = 23;\n    return -priority;\n  }","id":75491,"modified_method":"private static int getExprPriorityLevel(GrExpression expr) {\n    int priority = 0;\n    //if (expr instanceof GrNewExpression) priority = 1;\n    if (expr instanceof GrPostfixExpression) priority = 5;\n    else if (expr instanceof GrUnaryExpression ||\n        expr instanceof GrTypeCastExpression) priority = 6;\n\n    else if (expr instanceof GrRangeExpressionImpl) priority = 11;\n\n    else if (expr instanceof GrBinaryExpression) {\n      final IElementType opToken = ((GrBinaryExpression)expr).getOperationTokenType();\n      LOG.assertTrue(opToken != null, expr.getText());\n\n      if (opToken == mSTAR_STAR) priority = 7;\n      else if (opToken == mSTAR || opToken == mDIV) priority = 8;\n      else if (opToken == mPLUS || opToken == mMINUS) priority = 9;\n      else if (opToken == COMPOSITE_SHIFT_SIGN) priority = 10;\n      else if (RELATIONS.contains(opToken)) priority = 12;\n      else if (opToken == mEQUAL || opToken == mNOT_EQUAL || opToken == mCOMPARE_TO) priority = 13;\n      else if (opToken == mREGEX_FIND || opToken == mREGEX_MATCH) priority = 14;\n      else if (opToken == mBAND) priority = 15;\n      else if (opToken == mBXOR) priority = 16;\n      else if (opToken == mBOR) priority = 17;\n      else if (opToken == mLAND) priority = 18;\n      else if (opToken == mLOR) priority = 19;\n    }\n    else if (expr instanceof GrConditionalExpression) priority = 20;\n    else if (expr instanceof GrSafeCastExpression) priority = 21;\n    else if (expr instanceof GrAssignmentExpression) priority = 22;\n    else if (expr instanceof GrApplicationStatement) priority = 23;\n\n    return -priority;\n  }","commit_id":"5b149baa64c5a3e5690c7cd7c4e3239348faf3d7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isNotAssociative(GrBinaryExpression binaryExpression) {\n    if (binaryExpression instanceof GrMultiplicativeExpressionImpl) {\n      return binaryExpression.getOperationTokenType() != mSTAR;\n    }\n    if (binaryExpression instanceof GrAdditiveExpressionImpl) {\n      return binaryExpression.getOperationTokenType() == mMINUS;\n    }\n    return binaryExpression instanceof GrEqualityExpressionImpl\n        || binaryExpression instanceof GrRegexExpressionImpl\n        || binaryExpression instanceof GrShiftExpressionImpl\n        || binaryExpression instanceof GrPowerExpressionImpl;\n  }","id":75492,"modified_method":"private static boolean isNotAssociative(GrBinaryExpression binaryExpression) {\n    final IElementType opToken = binaryExpression.getOperationTokenType();\n    if (binaryExpression instanceof GrMultiplicativeExpressionImpl) {\n      return opToken != mSTAR;\n    }\n    if (binaryExpression instanceof GrAdditiveExpressionImpl) {\n      return opToken == mMINUS;\n    }\n    return RELATIONS.contains(opToken) || opToken == mCOMPARE_TO\n           || opToken == mREGEX_FIND || opToken == mREGEX_MATCH\n           || opToken == COMPOSITE_SHIFT_SIGN\n           || opToken==mSTAR;\n  }","commit_id":"5b149baa64c5a3e5690c7cd7c4e3239348faf3d7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean parse(PsiBuilder builder, GroovyParser parser) {\n\n    PsiBuilder.Marker marker = builder.mark();\n\n    if (ShiftExpression.parse(builder, parser)) {\n      if (ParserUtils.getToken(builder, RELATIONS) || getCompositeSign(builder)) {\n        ParserUtils.getToken(builder, mNLS);\n        ShiftExpression.parse(builder, parser);\n        marker.done(RELATIONAL_EXPRESSION);\n      } else if (kINSTANCEOF.equals(builder.getTokenType())) {\n        advanceLexerAndParseType(builder);\n        marker.done(INSTANCEOF_EXPRESSION);\n      } else if (kAS.equals(builder.getTokenType())) {\n        advanceLexerAndParseType(builder);\n        marker.done(SAFE_CAST_EXPRESSION);\n      } else {\n        marker.drop();\n      }\n      return true;\n    } else {\n      marker.drop();\n      return false;\n    }\n\n  }","id":75493,"modified_method":"public static boolean parse(PsiBuilder builder, GroovyParser parser) {\n\n    PsiBuilder.Marker marker = builder.mark();\n\n    if (ShiftExpression.parse(builder, parser)) {\n      if (ParserUtils.getToken(builder, TokenSets.RELATIONS) || getCompositeSign(builder)) {\n        ParserUtils.getToken(builder, mNLS);\n        ShiftExpression.parse(builder, parser);\n        marker.done(RELATIONAL_EXPRESSION);\n      } else if (kINSTANCEOF.equals(builder.getTokenType())) {\n        advanceLexerAndParseType(builder);\n        marker.done(INSTANCEOF_EXPRESSION);\n      } else if (kAS.equals(builder.getTokenType())) {\n        advanceLexerAndParseType(builder);\n        marker.done(SAFE_CAST_EXPRESSION);\n      } else {\n        marker.drop();\n      }\n      return true;\n    } else {\n      marker.drop();\n      return false;\n    }\n\n  }","commit_id":"5b149baa64c5a3e5690c7cd7c4e3239348faf3d7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PsiType getLeastUpperBoundForNumericType(@NotNull PsiType lType, @NotNull PsiType rType) {\n    String lCanonical = lType.getCanonicalText();\n    String rCanonical = rType.getCanonicalText();\n    if (TYPE_TO_RANK.containsKey(lCanonical) && TYPE_TO_RANK.containsKey(rCanonical)) {\n      return TYPE_TO_RANK.get(lCanonical) > TYPE_TO_RANK.get(rCanonical) ? lType : rType;\n    }\n    return null;\n  }","id":75494,"modified_method":"@Nullable\n  private static PsiType getLeastUpperBoundForNumericType(@NotNull PsiType lType, @NotNull PsiType rType) {\n    String lCanonical = lType.getCanonicalText();\n    String rCanonical = rType.getCanonicalText();\n    if (JAVA_LANG_FLOAT.equals(lCanonical)) lCanonical = JAVA_LANG_DOUBLE;\n    if (JAVA_LANG_FLOAT.equals(rCanonical)) rCanonical = JAVA_LANG_DOUBLE;\n    if (TYPE_TO_RANK.containsKey(lCanonical) && TYPE_TO_RANK.containsKey(rCanonical)) {\n      return TYPE_TO_RANK.get(lCanonical) > TYPE_TO_RANK.get(rCanonical) ? lType : rType;\n    }\n    return null;\n  }","commit_id":"5b149baa64c5a3e5690c7cd7c4e3239348faf3d7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiType getNumericResultType(GrBinaryExpression binaryExpression, PsiType lType) {\n    final GrExpression rop = binaryExpression.getRightOperand();\n    PsiType rType = rop == null ? null : rop.getType();\n    if (lType == null || rType == null) return null;\n    final PsiType result =\n      getLeastUpperBoundForNumericType(lType, rType);\n    if (result != null) return result;\n\n    return getOverloadedOperatorType(lType, binaryExpression.getOperationTokenType(), binaryExpression, new PsiType[]{rType});\n  }","id":75495,"modified_method":"@Nullable\n  public static PsiType getNumericResultType(GrBinaryExpression binaryExpression) {\n    PsiType lType = binaryExpression.getLeftOperand().getType();\n    final GrExpression rop = binaryExpression.getRightOperand();\n    PsiType rType = rop == null ? null : rop.getType();\n    if (lType == null || rType == null) return null;\n    return getLeastUpperBoundForNumericType(lType, rType);\n  }","commit_id":"5b149baa64c5a3e5690c7cd7c4e3239348faf3d7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isOrStatement(PsiElement element) {\n    return element instanceof GrBitwiseExpressionImpl\n           && ((GrBitwiseExpressionImpl)element).getOperationTokenType() == GroovyTokenTypes.mBOR;\n  }","id":75496,"modified_method":"private static boolean isOrStatement(PsiElement element) {\n    if (element instanceof GrBinaryExpression) {\n      IElementType type = ((GrBinaryExpression)element).getOperationTokenType();\n\n      return type == GroovyTokenTypes.mBOR || type == GroovyTokenTypes.mLOR;\n    }\n\n    return false;\n  }","commit_id":"f4bd91746a458f523c033bab7f2010a214718b43","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void splitOr(List<GrExpression> res, GrExpression element) {\n    GrExpression e = element;\n\n    while (true) {\n      if (e instanceof GrBitwiseExpressionImpl) {\n        GrBitwiseExpressionImpl be = (GrBitwiseExpressionImpl)e;\n        if (be.getOperationTokenType() == GroovyTokenTypes.mBOR) {\n          res.add(be.getRightOperand());\n          e = be.getLeftOperand();\n          continue;\n        }\n      }\n\n      res.add(e);\n      break;\n    }\n\n    Collections.reverse(res);\n  }","id":75497,"modified_method":"private static void splitOr(List<GrExpression> res, GrExpression element) {\n    if (isOrStatement(element)) {\n      GrBinaryExpression be = (GrBinaryExpression)element;\n      splitOr(res, be.getLeftOperand());\n      splitOr(res, be.getRightOperand());\n    }\n    else {\n      res.add(element);\n    }\n  }","commit_id":"f4bd91746a458f523c033bab7f2010a214718b43","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public AddSpaceInsertHandler(boolean triggerAutoPopup) {\n    myTriggerAutoPopup = triggerAutoPopup;\n  }","id":75498,"modified_method":"public AddSpaceInsertHandler(boolean triggerAutoPopup) {\n    this(\"\", triggerAutoPopup);\n  }","commit_id":"f9a3625d9bf1429fa8a7c997b8a8571f246985b6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void handleInsert(InsertionContext context, LookupElement item) {\n    Editor editor = context.getEditor();\n    if (context.getCompletionChar() == ' ') return;\n    Project project = editor.getProject();\n    if (project != null) {\n      if (!isCharAtSpace(editor)) {\n        EditorModificationUtil.insertStringAtCaret(editor, \" \");\n        PsiDocumentManager.getInstance(project).commitDocument(editor.getDocument());\n      }\n      else {\n        editor.getCaretModel().moveToOffset(editor.getCaretModel().getOffset() + 1);\n      }\n      if (myTriggerAutoPopup) {\n        AutoPopupController.getInstance(project).autoPopupMemberLookup(editor, null);\n      }\n    }\n  }","id":75499,"modified_method":"public void handleInsert(InsertionContext context, LookupElement item) {\n    Editor editor = context.getEditor();\n    char completionChar = context.getCompletionChar();\n    if (completionChar == ' ' || myIgnoreOnChars.indexOf(completionChar) >= 0) return;\n    Project project = editor.getProject();\n    if (project != null) {\n      if (!isCharAtSpace(editor)) {\n        EditorModificationUtil.insertStringAtCaret(editor, \" \");\n        PsiDocumentManager.getInstance(project).commitDocument(editor.getDocument());\n      }\n      else {\n        editor.getCaretModel().moveToOffset(editor.getCaretModel().getOffset() + 1);\n      }\n      if (myTriggerAutoPopup) {\n        AutoPopupController.getInstance(project).autoPopupMemberLookup(editor, null);\n      }\n    }\n  }","commit_id":"f9a3625d9bf1429fa8a7c997b8a8571f246985b6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addBrackets(InsertionContext context, PsiElement offsetElement) {\n        int offset = context.getSelectionEndOffset();\n        Document document = context.getDocument();\n\n        String documentText = document.getText();\n\n        boolean braces = bracketType == BracketType.BRACES && context.getCompletionChar() != '(';\n        char openingBracket = braces ? '{' : '(';\n        char closingBracket = braces ? '}' : ')';\n\n        int openingBracketIndex = indexOfSkippingSpace(documentText, openingBracket, offset);\n        int inBracketsShift = 0;\n\n        if (openingBracketIndex == -1) {\n            // Insert ()/{} if it's not already exist\n            if (braces) {\n                if (context.getCompletionChar() == ' ') {\n                    context.setAddCompletionChar(false);\n                }\n\n                if (isInsertSpacesInOneLineFunctionEnabled(offsetElement.getProject())) {\n                    document.insertString(offset, \" {  }\");\n                    inBracketsShift = 1;\n                }\n                else {\n                    document.insertString(offset, \" {}\");\n                }\n            }\n            else {\n                document.insertString(offset, \"()\");\n            }\n\n            PsiDocumentManager.getInstance(context.getProject()).commitDocument(document);\n            documentText = document.getText();\n        }\n\n        openingBracketIndex = indexOfSkippingSpace(documentText, openingBracket, offset);\n        assert openingBracketIndex != -1 : \"If there wasn't open bracket it should already have been inserted\";\n\n        // CaretPosition.AFTER_BRACKETS mode cannot work when there are some non-empty chars between open and close bracket\n        int closeBracketIndex = indexOfSkippingSpace(documentText, closingBracket, openingBracketIndex + 1);\n\n        Editor editor = context.getEditor();\n        if (caretPosition == CaretPosition.IN_BRACKETS || closeBracketIndex == -1) {\n            editor.getCaretModel().moveToOffset(openingBracketIndex + 1 + inBracketsShift);\n            AutoPopupController.getInstance(context.getProject()).autoPopupParameterInfo(editor, offsetElement);\n        }\n        else {\n            editor.getCaretModel().moveToOffset(closeBracketIndex + 1);\n        }\n\n        PsiDocumentManager.getInstance(context.getProject()).commitDocument(context.getDocument());\n    }","id":75500,"modified_method":"private void addBrackets(InsertionContext context, PsiElement offsetElement) {\n        int offset = context.getSelectionEndOffset();\n        Document document = context.getDocument();\n\n        String documentText = document.getText();\n\n        char completionChar = context.getCompletionChar();\n\n        boolean braces = bracketType == BracketType.BRACES && completionChar != '(';\n        char openingBracket = braces ? '{' : '(';\n        char closingBracket = braces ? '}' : ')';\n\n        int openingBracketIndex = indexOfSkippingSpace(documentText, openingBracket, offset);\n        int inBracketsShift = 0;\n\n        if (openingBracketIndex == -1) {\n            // Insert ()/{} if it's not already exist\n            if (braces) {\n                if (completionChar == ' ') {\n                    context.setAddCompletionChar(false);\n                }\n\n                if (isInsertSpacesInOneLineFunctionEnabled(offsetElement.getProject())) {\n                    document.insertString(offset, \" {  }\");\n                    inBracketsShift = 1;\n                }\n                else {\n                    document.insertString(offset, \" {}\");\n                }\n            }\n            else {\n                document.insertString(offset, \"()\");\n            }\n\n            PsiDocumentManager.getInstance(context.getProject()).commitDocument(document);\n            documentText = document.getText();\n        }\n\n        openingBracketIndex = indexOfSkippingSpace(documentText, openingBracket, offset);\n        assert openingBracketIndex != -1 : \"If there wasn't open bracket it should already have been inserted\";\n\n        // CaretPosition.AFTER_BRACKETS mode cannot work when there are some non-empty chars between open and close bracket\n        int closeBracketIndex = indexOfSkippingSpace(documentText, closingBracket, openingBracketIndex + 1);\n\n        Editor editor = context.getEditor();\n\n        // Satisfy TypedHandler.handleRParen() algorithm for preventing doubling ')' char if user typed \"()\" manually.\n        boolean forcePlaceCaretIntoParentheses = completionChar == '(';\n\n        if (caretPosition == CaretPosition.IN_BRACKETS || forcePlaceCaretIntoParentheses || closeBracketIndex == -1) {\n            editor.getCaretModel().moveToOffset(openingBracketIndex + 1 + inBracketsShift);\n            AutoPopupController.getInstance(context.getProject()).autoPopupParameterInfo(editor, offsetElement);\n        }\n        else {\n            editor.getCaretModel().moveToOffset(closeBracketIndex + 1);\n        }\n\n        PsiDocumentManager.getInstance(context.getProject()).commitDocument(context.getDocument());\n    }","commit_id":"93b7e9add9c1fdfd9fe48ec571c945ad883f75d0","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public boolean nextTabOnItemSelected(final ExpressionContext context, final LookupElement item) {\n    final List<? extends PsiElement> elements = JavaCompletionUtil.getAllPsiElements(item);\n    if (elements != null) {\n      if (elements.size() != 1) return false;\n      if (elements.get(0) instanceof PsiMethod) {\n        PsiMethod method = (PsiMethod)elements.get(0);\n        if (method.getParameterList().getParametersCount() != 0) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }","id":75501,"modified_method":"public boolean nextTabOnItemSelected(final ExpressionContext context, final LookupElement item) {\n    final List<? extends PsiElement> elements = JavaCompletionUtil.getAllPsiElements(item);\n    if (elements != null) {\n      if (elements.size() != 1) return false;\n      final PsiElement element = elements.get(0);\n      if (element instanceof PsiPackage) {\n        return false;\n      }\n      if (element instanceof PsiMethod) {\n        PsiMethod method = (PsiMethod)element;\n        if (method.getParameterList().getParametersCount() != 0) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }","commit_id":"9f49e76293c6efee5559884a56bfcf2abee1850f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void handleInsert(InsertionContext context, LookupElement item) {\n      super.handleInsert(context, item);\n      context.setAddCompletionChar(false);\n      eatClosingQuote(context.getCompletionChar(), context.getEditor());\n\n    }","id":75502,"modified_method":"public void handleInsert(InsertionContext context, LookupElement item) {\n      final char c = context.getCompletionChar();\n      if (c == '\\'' || c == '\\\"') {\n        context.setAddCompletionChar(false);\n        eatClosingQuote(c, context.getEditor());\n      }\n    }","commit_id":"9f49e76293c6efee5559884a56bfcf2abee1850f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Initializes a toggle button.\n     * \n     * @param action the action to associate with the button\n     * @param styleConstant the style constant\n     * @return the toggle button with the associated action and style constant\n     */\n    private JToggleButton initStyleToggleButton(final Action action,\n        final Object styleConstant)\n    {\n        final JToggleButton button = new JToggleButton();\n        button.setPreferredSize(new Dimension(25, 25));\n        button.setName(styleConstant.toString());\n        button.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                ActionEvent event = new ActionEvent(chatEditorPane,\n                                                    ActionEvent.ACTION_PERFORMED,\n                                                    styleConstant.toString());\n\n                action.actionPerformed(event);\n\n                chatEditorPane.requestFocus();\n            }\n        });\n\n        chatEditorPane.addCaretListener(new CaretListener()\n        {\n            public void caretUpdate(CaretEvent e)\n            {\n                selectButton(styleConstant, button);\n            }\n        });\n\n        chatEditorPane.addKeyListener(new KeyAdapter()\n        {\n            private boolean wasEmpty = false;\n            \n            public void keyTyped(KeyEvent e)\n            {\n                if (chatEditorPane.getText().length() > 0)\n                {\n                    button.setSelected(((HTMLEditorKit) chatEditorPane\n                        .getEditorKit()).getInputAttributes().containsAttribute(\n                            styleConstant, true));\n                }\n            }\n        });\n\n        chatEditorPane.addMouseListener(new MouseAdapter()\n        {\n            public void mouseClicked(MouseEvent e)\n            {\n                selectButton(styleConstant, button);\n            }\n        });\n\n        return button;\n    }","id":75503,"modified_method":"/**\n     * Initializes a toggle button.\n     * \n     * @param action the action to associate with the button\n     * @param styleConstant the style constant\n     * @return the toggle button with the associated action and style constant\n     */\n    private JToggleButton initStyleToggleButton(final Action action,\n        final Object styleConstant)\n    {\n        final JToggleButton button = new JToggleButton();\n        button.setPreferredSize(new Dimension(25, 25));\n        button.setName(styleConstant.toString());\n        button.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                ActionEvent event = new ActionEvent(chatEditorPane,\n                                                    ActionEvent.ACTION_PERFORMED,\n                                                    styleConstant.toString());\n\n                action.actionPerformed(event);\n\n                chatEditorPane.requestFocus();\n            }\n        });\n\n        chatEditorPane.addCaretListener(new CaretListener()\n        {\n            public void caretUpdate(CaretEvent e)\n            {\n                selectButton(styleConstant, button);\n            }\n        });\n\n        chatEditorPane.addKeyListener(new KeyAdapter()\n        {\n            public void keyTyped(KeyEvent e)\n            {\n                if (chatEditorPane.getText().length() > 0)\n                {\n                    button.setSelected(((HTMLEditorKit) chatEditorPane\n                        .getEditorKit()).getInputAttributes().containsAttribute(\n                            styleConstant, true));\n                }\n            }\n        });\n\n        chatEditorPane.addMouseListener(new MouseAdapter()\n        {\n            public void mouseClicked(MouseEvent e)\n            {\n                selectButton(styleConstant, button);\n            }\n        });\n\n        return button;\n    }","commit_id":"a34e5a9153cb330432e251249d391947becd8cab","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Initializes the label that changes font color.\n     */\n    private void initColorLabel()\n    {\n        this.colorLabel = new ColorLabel();\n        colorLabel.setPreferredSize(new Dimension(21, 21));\n\n        colorLabel.setOpaque(true);\n        colorLabel.setBackground(Color.BLACK);\n\n        this.add(colorLabel);\n\n        colorLabel.addMouseListener(new MouseAdapter()\n        {\n            public void mousePressed(MouseEvent event)\n            {\n                Color newColor =\n                    JColorChooser.showDialog(new JColorChooser(),\n                                            \"Choose a colour\",\n                                            colorLabel.getBackground());\n\n                if (newColor != null) {\n                    colorLabel.setBackground(newColor);\n    \n                    ActionEvent evt =\n                        new ActionEvent(chatEditorPane,\n                            ActionEvent.ACTION_PERFORMED, \"\");\n    \n                    Action action =\n                        new HTMLEditorKit.ForegroundAction(new Integer(newColor\n                            .getRGB()).toString(), newColor);\n    \n                    action.actionPerformed(evt);\n                }\n                \n                chatEditorPane.requestFocus();\n            }\n        });\n\n        chatEditorPane.addCaretListener(new CaretListener()\n        {\n            public void caretUpdate(CaretEvent e)\n            {\n                selectColor(StyleConstants.Foreground, colorLabel);\n            }\n        });\n\n        chatEditorPane.addKeyListener(new KeyAdapter()\n        {\n            public void keyTyped(KeyEvent e)\n            {\n                // The editor pane seems to forget the formatting when it is\n                // empty so we use the interface as a reminder for it\n                if (chatEditorPane.getDocument().getLength() == 0)\n                {\n                    Color newColor = colorLabel.getBackground();\n                    \n                    ActionEvent evt =\n                        new ActionEvent(chatEditorPane,\n                            ActionEvent.ACTION_PERFORMED, \"\");\n    \n                    Action action =\n                        new HTMLEditorKit.ForegroundAction(new Integer(newColor\n                            .getRGB()).toString(), newColor);\n    \n                    action.actionPerformed(evt);\n                }\n            }\n        });\n\n        chatEditorPane.addMouseListener(new MouseAdapter()\n        {\n            public void mouseClicked(MouseEvent e)\n            {\n                selectColor(StyleConstants.Foreground, colorLabel);\n            }\n        });\n    }","id":75504,"modified_method":"/**\n     * Initializes the label that changes font color.\n     */\n    private void initColorLabel()\n    {\n        this.colorLabel = new ColorLabel();\n        colorLabel.setPreferredSize(new Dimension(21, 21));\n\n        colorLabel.setOpaque(true);\n        colorLabel.setBackground(Color.BLACK);\n\n        this.add(colorLabel);\n\n        colorLabel.addMouseListener(new MouseAdapter()\n        {\n            public void mousePressed(MouseEvent event)\n            {\n                Color newColor =\n                    JColorChooser.showDialog(new JColorChooser(),\n                                            \"Choose a colour\",\n                                            colorLabel.getBackground());\n\n                if (newColor != null) {\n                    colorLabel.setBackground(newColor);\n    \n                    ActionEvent evt =\n                        new ActionEvent(chatEditorPane,\n                            ActionEvent.ACTION_PERFORMED, \"\");\n    \n                    Action action =\n                        new HTMLEditorKit.ForegroundAction(new Integer(newColor\n                            .getRGB()).toString(), newColor);\n    \n                    action.actionPerformed(evt);\n                }\n                \n                chatEditorPane.requestFocus();\n            }\n        });\n\n        chatEditorPane.addCaretListener(new CaretListener()\n        {\n            public void caretUpdate(CaretEvent e)\n            {\n                selectColor(StyleConstants.Foreground, colorLabel);\n            }\n        });\n\n        chatEditorPane.addKeyListener(new KeyAdapter()\n        {\n            public void keyTyped(KeyEvent e)\n            {\n                if (chatWritePanel.getText().length() > 0)\n                {\n                    Color currentColor\n                        = (Color) ((HTMLEditorKit) chatEditorPane\n                            .getEditorKit()).getInputAttributes().getAttribute(\n                                StyleConstants.Foreground);\n\n                    if (currentColor != null)\n                        colorLabel.setBackground(currentColor);\n                    else\n                        colorLabel.setBackground(Color.BLACK);\n                }\n            }\n        });\n\n        chatEditorPane.addMouseListener(new MouseAdapter()\n        {\n            public void mouseClicked(MouseEvent e)\n            {\n                selectColor(StyleConstants.Foreground, colorLabel);\n            }\n        });\n    }","commit_id":"a34e5a9153cb330432e251249d391947becd8cab","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Selects the color corresponding to the current style attribute.\n     * \n     * @param styleConstant the style constant\n     * @param colorLabel the color label to select the color from\n     */\n    private void selectColor(   final Object styleConstant,\n                                final JLabel colorLabel)\n    {\n        // use the last settings if the pane is empty\n        if (chatEditorPane.getDocument().getLength() == 0) \n        {\n            return;\n        }\n\n        int index = chatEditorPane.getCaretPosition();\n        \n        // if we are at the beginning of the document, use the style of the\n        // first character\n        if (index == 0) {\n            index = 1;\n        }\n        \n        // use the style of the character preceding the carret\n        AttributeSet attributes =\n            ((HTMLDocument) chatEditorPane.getDocument())\n                .getCharacterElement(index - 1).getAttributes();\n\n        if (attributes.getAttribute(styleConstant) != null)\n        {\n            Object selectedAttribute = attributes.getAttribute(styleConstant);\n            colorLabel.setBackground((Color) selectedAttribute);\n        }\n        else \n        {\n            colorLabel.setBackground(Color.BLACK);\n        }\n    }","id":75505,"modified_method":"/**\n     * Selects the color corresponding to the current style attribute.\n     * \n     * @param styleConstant the style constant\n     * @param colorLabel the color label to select the color from\n     */\n    private void selectColor(   final Object styleConstant,\n                                final JLabel colorLabel)\n    {\n        Object selectedAttribute = null;\n\n        if (chatEditorPane.getSelectedText() == null)\n        {\n            int index = chatEditorPane.getCaretPosition();\n            selectedAttribute =\n                ((HTMLDocument) chatEditorPane.getDocument())\n                    .getCharacterElement(index - 1).getAttributes()\n                    .getAttribute(styleConstant);\n        }\n        else\n        {\n            for (int index = chatEditorPane.getSelectionStart();\n                index < chatEditorPane.getSelectionEnd(); index++)\n            {\n                AttributeSet attributes =\n                    ((HTMLDocument) chatEditorPane.getDocument())\n                        .getCharacterElement(index).getAttributes();\n\n                if (attributes.getAttribute(styleConstant) != null)\n                    selectedAttribute = attributes.getAttribute(styleConstant);\n            }\n        }\n\n        if (selectedAttribute != null)\n            colorLabel.setBackground((Color)selectedAttribute);\n        else\n            colorLabel.setBackground(Color.BLACK);\n    }","commit_id":"a34e5a9153cb330432e251249d391947becd8cab","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Selects or deselects the given toggle button depending on the given\n     * <tt>styleConstant<\/tt>.\n     * \n     * @param styleConstant the style constant\n     * @param button the button to select\n     */\n    private void selectButton(  final Object styleConstant,\n                                final JToggleButton button)\n\n    {\n        /*\n        // use the last settings if the pane is empty\n        if (chatEditorPane.getDocument().getLength() == 0) \n        {\n            return;\n        }\n        */\n        \n        boolean selected = false;\n\n        // if nothing is selected\n        if (chatEditorPane.getSelectedText() == null)\n        {\n            int index = chatEditorPane.getCaretPosition();\n            \n            // if we are at the beginning of the document, use the style of the\n            // first character\n            if (index == 0) {\n                index = 1;\n            }\n            \n            // use the style of the character preceding the carret\n            AttributeSet attributes =\n                ((HTMLDocument) chatEditorPane.getDocument())\n                    .getCharacterElement(index - 1).getAttributes();\n            \n            if (attributes.getAttribute(styleConstant) != null)\n            {\n                selected = attributes.containsAttribute(styleConstant, true);\n            }\n        }\n        else\n        {\n            int index = chatEditorPane.getSelectionStart();\n            \n            // initialize selected with the first character attributes\n            if (index < chatEditorPane.getSelectionEnd()) {\n                AttributeSet attributes =\n                    ((HTMLDocument) chatEditorPane.getDocument())\n                        .getCharacterElement(index).getAttributes();\n                \n                if (attributes.getAttribute(styleConstant) != null)\n                {\n                    selected = attributes\n                        .containsAttribute(styleConstant, true);\n                }\n            }\n            \n            // AND all the attributes to determine the global attribute\n            for (index++; index < chatEditorPane.getSelectionEnd(); index++)\n            {\n                AttributeSet attributes =\n                    ((HTMLDocument) chatEditorPane.getDocument())\n                        .getCharacterElement(index).getAttributes();\n\n                if (attributes.getAttribute(styleConstant) != null)\n                {\n                    selected = selected\n                        && attributes.containsAttribute(styleConstant, true);\n                }\n            }\n        }\n\n        button.setSelected(selected);\n    }","id":75506,"modified_method":"/**\n     * Selects or deselects the given toggle button depending on the given\n     * <tt>styleConstant<\/tt>.\n     * \n     * @param styleConstant the style constant\n     * @param button the button to select\n     */\n    private void selectButton(  final Object styleConstant,\n                                final JToggleButton button)\n\n    {\n        boolean selected = false;\n\n        if (chatEditorPane.getSelectedText() == null)\n        {\n            int index = chatEditorPane.getCaretPosition();\n            selected =\n                ((HTMLDocument) chatEditorPane.getDocument())\n                    .getCharacterElement(index - 1).getAttributes()\n                    .containsAttribute(styleConstant, true);\n        }\n        else\n        {\n            for (int index = chatEditorPane.getSelectionStart();\n                index < chatEditorPane.getSelectionEnd(); index++)\n            {\n                AttributeSet attributes =\n                    ((HTMLDocument) chatEditorPane.getDocument())\n                        .getCharacterElement(index).getAttributes();\n\n                selected =\n                    selected\n                        || attributes.containsAttribute(styleConstant, true);\n            }\n        }\n\n        if (chatEditorPane.getText().length() > 0)\n            button.setSelected(selected);\n    }","commit_id":"a34e5a9153cb330432e251249d391947becd8cab","url":"https://github.com/jitsi/jitsi"},{"original_method":"public RTPHdrExtPacketExtension(RTPHdrExtPacketExtension ext)\n    {\n        this();\n        setAttributes(ext.getAttributes());\n        setID(ext.getID());\n        setSenders(ext.getSenders());\n        setURI(ext.getURI());\n    }","id":75507,"modified_method":"public RTPHdrExtPacketExtension(RTPHdrExtPacketExtension ext)\n    {\n        this();\n        String attributes = ext.getAttributes();\n        if (attributes != null)\n            setAttributes(attributes);\n        setID(ext.getID());\n        setSenders(ext.getSenders());\n        setURI(ext.getURI());\n    }","commit_id":"f143f1d5ff535ee7e74c81eeb1f7b43172689a7c","url":"https://github.com/jitsi/jitsi"},{"original_method":"private File getMirrorWithContentHash(File originalFile, FileAttributes originalAttributes) {\n    File mirrorFile = null;\n    String jarDir = getJarsDir();\n\n    try {\n      String path = originalFile.getPath();\n      CacheLibraryInfo info = CacheLibraryInfo.ourCachedLibraryInfo.get(path);\n\n      if (info != null &&\n          originalAttributes.length == info.myFileLength &&\n          Math.abs(originalAttributes.lastModified - info.myModificationTime) <= FS_TIME_RESOLUTION) {\n        mirrorFile = new File(jarDir, info.mySnapshotPath);\n        if (!mirrorDiffers(originalAttributes, FileSystemUtil.getAttributes(mirrorFile), true)) {\n          return mirrorFile;\n        }\n      }\n\n      MessageDigest sha1 = null;\n      File tempJarFile = null;\n\n      try {\n        tempJarFile = FileUtil.createTempFile(new File(jarDir), originalFile.getName(), \"\", true, false);\n\n        DataOutputStream os = new DataOutputStream(new FileOutputStream(tempJarFile));\n        try {\n          FileInputStream is = new FileInputStream(originalFile);\n          try {\n            sha1 = MessageDigest.getInstance(\"SHA1\");\n            sha1.update(String.valueOf(originalAttributes.length).getBytes(Charset.defaultCharset()));\n            sha1.update((byte)0);\n\n            byte[] buffer = new byte[Math.min(1024 * 1024, (int)originalAttributes.length)];\n            long totalBytes = 0;\n            while (true) {\n              int read = is.read(buffer);\n              if (read < 0) break;\n              totalBytes += read;\n              sha1.update(buffer, 0, read);\n              os.write(buffer, 0, read);\n              if (totalBytes == originalAttributes.length) break;\n            }\n          }\n          finally {\n            is.close();\n          }\n        }\n        finally {\n          os.close();\n        }\n      }\n      catch (IOException ex) {\n        File target = mirrorFile != null ? mirrorFile : tempJarFile != null ? tempJarFile : new File(jarDir);\n        reportIOErrorWithJars(originalFile, target, ex);\n        return originalFile;\n      }\n      catch (NoSuchAlgorithmException ex) {\n        LOG.error(ex);\n        return originalFile; // should never happen for sha1\n      }\n\n      String mirrorName = getSnapshotName(originalFile.getName(), sha1.digest());\n      mirrorFile = new File(jarDir, mirrorName);\n\n      if (mirrorDiffers(originalAttributes, FileSystemUtil.getAttributes(mirrorFile), true)) {\n        try {\n          FileUtil.delete(mirrorFile);\n          FileUtil.rename(tempJarFile, mirrorFile);\n          FileUtil.setLastModified(mirrorFile, originalAttributes.lastModified);\n        }\n        catch (IOException ex) {\n          reportIOErrorWithJars(originalFile, mirrorFile, ex);\n          return originalFile;\n        }\n      }\n      else {\n        FileUtil.delete(tempJarFile);\n      }\n\n      info = new CacheLibraryInfo(mirrorFile.getName(), originalAttributes.lastModified, originalAttributes.length);\n      CacheLibraryInfo.ourCachedLibraryInfo.put(path, info);\n      return mirrorFile;\n    }\n    catch (IOException ex) {\n      CacheLibraryInfo.ourCachedLibraryInfo.markCorrupted();\n      reportIOErrorWithJars(originalFile, mirrorFile != null ? mirrorFile : new File(jarDir, originalFile.getName()), ex);\n      return originalFile;\n    }\n  }","id":75508,"modified_method":"private File getMirrorWithContentHash(File originalFile, FileAttributes originalAttributes) {\n    File mirrorFile = null;\n    String jarDir = getJarsDir();\n\n    try {\n      String path = originalFile.getPath();\n      CacheLibraryInfo info = CacheLibraryInfo.ourCachedLibraryInfo.get(path);\n\n      if (info != null &&\n          originalAttributes.length == info.myFileLength &&\n          Math.abs(originalAttributes.lastModified - info.myModificationTime) <= FS_TIME_RESOLUTION) {\n        mirrorFile = new File(jarDir, info.mySnapshotPath);\n        if (!mirrorDiffers(originalAttributes, FileSystemUtil.getAttributes(mirrorFile), true)) {\n          return mirrorFile;\n        }\n      }\n\n      MessageDigest sha1 = null;\n      File tempJarFile = null;\n\n      try {\n        tempJarFile = FileUtil.createTempFile(new File(jarDir), originalFile.getName(), \"\", true, false);\n\n        DataOutputStream os = new DataOutputStream(new FileOutputStream(tempJarFile));\n        try {\n          FileInputStream is = new FileInputStream(originalFile);\n          try {\n            sha1 = MessageDigest.getInstance(\"SHA1\");\n            sha1.update(String.valueOf(originalAttributes.length).getBytes(Charset.defaultCharset()));\n            sha1.update((byte)0);\n\n            byte[] buffer = new byte[Math.min(1024 * 1024, (int)originalAttributes.length)];\n            long totalBytes = 0;\n            while (true) {\n              int read = is.read(buffer);\n              if (read < 0) break;\n              totalBytes += read;\n              sha1.update(buffer, 0, read);\n              os.write(buffer, 0, read);\n              if (totalBytes == originalAttributes.length) break;\n            }\n          }\n          finally {\n            is.close();\n          }\n        }\n        finally {\n          os.close();\n        }\n      }\n      catch (IOException ex) {\n        File target = mirrorFile != null ? mirrorFile : tempJarFile != null ? tempJarFile : new File(jarDir);\n        reportIOErrorWithJars(originalFile, target, ex);\n        return originalFile;\n      }\n      catch (NoSuchAlgorithmException ex) {\n        LOG.error(ex);\n        return originalFile; // should never happen for sha1\n      }\n\n      String mirrorName = getSnapshotName(originalFile.getName(), sha1.digest());\n      mirrorFile = new File(jarDir, mirrorName);\n\n      FileAttributes mirrorFileAttributes = FileSystemUtil.getAttributes(mirrorFile);\n      if (mirrorFileAttributes == null) {\n        try {\n          FileUtil.rename(tempJarFile, mirrorFile);\n          FileUtil.setLastModified(mirrorFile, originalAttributes.lastModified);\n        }\n        catch (IOException ex) {\n          reportIOErrorWithJars(originalFile, mirrorFile, ex);\n          return originalFile;\n        }\n      }\n      else {\n        FileUtil.delete(tempJarFile);\n      }\n\n      info = new CacheLibraryInfo(mirrorFile.getName(),  originalAttributes.lastModified, originalAttributes.length);\n      CacheLibraryInfo.ourCachedLibraryInfo.put(path, info);\n      return mirrorFile;\n    }\n    catch (IOException ex) {\n      CacheLibraryInfo.ourCachedLibraryInfo.markCorrupted();\n      reportIOErrorWithJars(originalFile, mirrorFile != null ? mirrorFile : new File(jarDir, originalFile.getName()), ex);\n      return originalFile;\n    }\n  }","commit_id":"e7fed368e5d4daf96c495cbe502cb5775539759b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public FileAttributes getAttributes(@NotNull final VirtualFile file) {\n    final JarHandler handler = getHandler(file);\n    if (handler == null) return null;\n\n    if (file.getParent() == null) {\n      final LocalFileSystem localFileSystem = LocalFileSystem.getInstance();\n      final VirtualFile originalFile = localFileSystem.findFileByIoFile(handler.getOriginalFile());\n      return originalFile != null ? localFileSystem.getAttributes(originalFile) : null;\n    }\n\n    return handler.getAttributes(file);\n  }","id":75509,"modified_method":"@Override\n  public FileAttributes getAttributes(@NotNull final VirtualFile file) {\n    final JarHandler handler = getHandler(file);\n    if (handler == null) return null;\n\n    if (file.getParent() == null) {\n      final LocalFileSystem localFileSystem = LocalFileSystem.getInstance();\n      final VirtualFile originalFile = localFileSystem.findFileByIoFile(handler.getOriginalFile());\n      if (originalFile == null) return null;\n      final FileAttributes attributes = localFileSystem.getAttributes(originalFile);\n      if (attributes == null) return null;\n      return new FileAttributes(true, false, false, false, attributes.length, attributes.lastModified, attributes.isWritable());\n    }\n\n    return handler.getAttributes(file);\n  }","commit_id":"323ad3e375ea05f61f9518b65b33d3f5f3d63436","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void populateExchangeFromRestletRequest(Request request, Response response, Exchange exchange) throws Exception {\n        Message inMessage = exchange.getIn();\n\n        inMessage.setHeader(RestletConstants.RESTLET_REQUEST, request);\n        inMessage.setHeader(RestletConstants.RESTLET_RESPONSE, response);\n\n        // extract headers from restlet\n        for (Map.Entry<String, Object> entry : request.getAttributes().entrySet()) {\n            if (!headerFilterStrategy.applyFilterToExternalHeaders(entry.getKey(), entry.getValue(), exchange)) {\n                String key = entry.getKey();\n                Object value = entry.getValue();\n                inMessage.setHeader(key, value);\n                LOG.debug(\"Populate exchange from Restlet request header: {} value: {}\", key, value);\n            }\n        }\n\n        // we need to dig a bit to grab the content-type\n        Series<Header> series = (Series<Header>) request.getAttributes().get(HeaderConstants.ATTRIBUTE_HEADERS);\n        if (series != null) {\n            String type = series.getFirstValue(Exchange.CONTENT_TYPE, true);\n            if (type != null) {\n                inMessage.setHeader(Exchange.CONTENT_TYPE, type);\n            }\n        }\n\n        // copy query string to header\n        String query = request.getResourceRef().getQuery();\n        if (query != null) {\n            inMessage.setHeader(Exchange.HTTP_QUERY, query);\n        }\n\n        // copy URI to header\n        inMessage.setHeader(Exchange.HTTP_URI, request.getResourceRef().getIdentifier(true));\n\n        // copy HTTP method to header\n        inMessage.setHeader(Exchange.HTTP_METHOD, request.getMethod().toString());\n\n        if (!request.isEntityAvailable()) {\n            return;\n        }\n\n        // only deal with the form if the content type is \"application/x-www-form-urlencoded\"\n        if (request.getEntity().getMediaType() != null && request.getEntity().getMediaType().equals(MediaType.APPLICATION_WWW_FORM, true)) {\n            Form form = new Form(request.getEntity());\n            for (String paramName : form.getValuesMap().keySet()) {\n                String[] values = form.getValuesArray(paramName);\n                Object value = null;\n                if (values != null && values.length > 0) {\n                    if (values.length == 1) {\n                        value = values[0];\n                    } else {\n                        value = values;\n                    }\n                }\n                if (value == null) {\n                    inMessage.setBody(paramName);\n                    LOG.debug(\"Populate exchange from Restlet request body: {}\", paramName);\n                } else {\n                    if (!headerFilterStrategy.applyFilterToExternalHeaders(paramName, value, exchange)) {\n                        inMessage.setHeader(paramName, value);\n                        LOG.debug(\"Populate exchange from Restlet request user header: {} value: {}\", paramName, value);\n                    }\n                }\n            }\n        } else {\n            InputStream is = request.getEntity().getStream();\n            Object body = RestletHelper.readResponseBodyFromInputStream(is, exchange);\n            inMessage.setBody(body);\n        }\n\n    }","id":75510,"modified_method":"public void populateExchangeFromRestletRequest(Request request, Response response, Exchange exchange) throws Exception {\n        Message inMessage = exchange.getIn();\n\n        inMessage.setHeader(RestletConstants.RESTLET_REQUEST, request);\n        inMessage.setHeader(RestletConstants.RESTLET_RESPONSE, response);\n\n        // extract headers from restlet\n        for (Map.Entry<String, Object> entry : request.getAttributes().entrySet()) {\n            if (!headerFilterStrategy.applyFilterToExternalHeaders(entry.getKey(), entry.getValue(), exchange)) {\n                String key = entry.getKey();\n                Object value = entry.getValue();\n                if(HeaderConstants.ATTRIBUTE_HEADERS.equalsIgnoreCase(key)){\n                \t Series<Header> series = (Series<Header>) value;\n                     for(Header header: series){\n                         if(!header.getName().equalsIgnoreCase(\"Content-length\")) //Don't set the content length\n                        \t inMessage.setHeader(header.getName(), header.getValue());\n                     }\n                }\n                else {\n                \tinMessage.setHeader(key, value);\n                }\n                LOG.debug(\"Populate exchange from Restlet request header: {} value: {}\", key, value);\n            }\n        }\n\n\n        // copy query string to header\n        String query = request.getResourceRef().getQuery();\n        if (query != null) {\n            inMessage.setHeader(Exchange.HTTP_QUERY, query);\n        }\n\n        // copy URI to header\n        inMessage.setHeader(Exchange.HTTP_URI, request.getResourceRef().getIdentifier(true));\n\n        // copy HTTP method to header\n        inMessage.setHeader(Exchange.HTTP_METHOD, request.getMethod().toString());\n\n        if (!request.isEntityAvailable()) {\n            return;\n        }\n\n        // only deal with the form if the content type is \"application/x-www-form-urlencoded\"\n        if (request.getEntity().getMediaType() != null && request.getEntity().getMediaType().equals(MediaType.APPLICATION_WWW_FORM, true)) {\n            Form form = new Form(request.getEntity());\n            for (String paramName : form.getValuesMap().keySet()) {\n                String[] values = form.getValuesArray(paramName);\n                Object value = null;\n                if (values != null && values.length > 0) {\n                    if (values.length == 1) {\n                        value = values[0];\n                    } else {\n                        value = values;\n                    }\n                }\n                if (value == null) {\n                    inMessage.setBody(paramName);\n                    LOG.debug(\"Populate exchange from Restlet request body: {}\", paramName);\n                } else {\n                    if (!headerFilterStrategy.applyFilterToExternalHeaders(paramName, value, exchange)) {\n                        inMessage.setHeader(paramName, value);\n                        LOG.debug(\"Populate exchange from Restlet request user header: {} value: {}\", paramName, value);\n                    }\n                }\n            }\n        } else {\n            InputStream is = request.getEntity().getStream();\n            Object body = RestletHelper.readResponseBodyFromInputStream(is, exchange);\n            inMessage.setBody(body);\n        }\n\n    }","commit_id":"38677d2b58855d5949c5996108410bc3f6b108b6","url":"https://github.com/apache/camel"},{"original_method":"public void populateRestletRequestFromExchange(Request request, Exchange exchange) {\n        request.setReferrerRef(\"camel-restlet\");\n\n        final Method method = request.getMethod();\n\n        MediaType mediaType = exchange.getIn().getHeader(Exchange.CONTENT_TYPE, MediaType.class);\n        if (mediaType == null) {\n            mediaType = MediaType.APPLICATION_WWW_FORM;\n        }\n\n        Form form = null;\n        // Use forms only for PUT, POST and x-www-form-urlencoded\n        if ((Method.PUT == method || Method.POST == method) && MediaType.APPLICATION_WWW_FORM.equals(mediaType, true)) {\n            form = new Form();\n            // must use string based for forms\n            String body = exchange.getIn().getBody(String.class);\n            if (body != null) {\n                form.add(body, null);\n            }\n        }\n\n        // login and password are filtered by header filter strategy\n        String login = exchange.getIn().getHeader(RestletConstants.RESTLET_LOGIN, String.class);\n        String password = exchange.getIn().getHeader(RestletConstants.RESTLET_PASSWORD, String.class);\n\n        if (login != null && password != null) {\n            ChallengeResponse authentication = new ChallengeResponse(ChallengeScheme.HTTP_BASIC, login, password);\n            request.setChallengeResponse(authentication);\n            LOG.debug(\"Basic HTTP Authentication has been applied\");\n        }\n\n        for (Map.Entry<String, Object> entry : exchange.getIn().getHeaders().entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n            if (!headerFilterStrategy.applyFilterToCamelHeaders(key, value, exchange)) {\n                // Use forms only for PUT, POST and x-www-form-urlencoded\n                if (form != null) {\n                    if (key.startsWith(\"org.restlet.\")) {\n                        // put the org.restlet headers in attributes\n                        request.getAttributes().put(key, value);\n                    } else {\n                        // put the user stuff in the form\n                        if (value instanceof Collection) {\n                            for (Object v : (Collection<?>) value) {\n                                form.add(key, v.toString());\n                            }\n                        } else {\n                            form.add(key, value.toString());\n                        }\n                    }\n                } else {\n                    // For non-form post put all the headers in attributes\n                    request.getAttributes().put(key, value);\n                }\n                LOG.debug(\"Populate Restlet request from exchange header: {} value: {}\", key, value);\n            }\n        }\n\n        if (form != null) {\n            request.setEntity(form.getWebRepresentation());\n            LOG.debug(\"Populate Restlet {} request from exchange body as form using media type {}\", method, mediaType);\n        } else {\n            // include body if PUT or POST\n            if (request.getMethod() == Method.PUT || request.getMethod() == Method.POST) {\n                Representation body = createRepresentationFromBody(exchange, mediaType);\n                request.setEntity(body);\n                LOG.debug(\"Populate Restlet {} request from exchange body: {} using media type {}\", method, body, mediaType);\n            } else {\n                // no body\n                LOG.debug(\"Populate Restlet {} request from exchange using media type {}\", method, mediaType);\n                request.setEntity(new EmptyRepresentation());\n            }\n        }\n\n        // accept\n        String accept = exchange.getIn().getHeader(\"Accept\", String.class);\n        if (accept != null) {\n            MediaType acceptedMediaType = exchange.getContext().getTypeConverter().tryConvertTo(MediaType.class, exchange, accept);\n            if (acceptedMediaType != null) {\n                request.getClientInfo().getAcceptedMediaTypes().add(new Preference<MediaType>(acceptedMediaType));\n            }\n        }\n        MediaType acceptedMediaType = exchange.getIn().getHeader(Exchange.ACCEPT_CONTENT_TYPE, MediaType.class);\n        if (acceptedMediaType != null) {\n            request.getClientInfo().getAcceptedMediaTypes().add(new Preference<MediaType>(acceptedMediaType));\n        }\n\n    }","id":75511,"modified_method":"public void populateRestletRequestFromExchange(Request request, Exchange exchange) {\n        request.setReferrerRef(\"camel-restlet\");\n\n        final Method method = request.getMethod();\n\n        MediaType mediaType = exchange.getIn().getHeader(Exchange.CONTENT_TYPE, MediaType.class);\n        if (mediaType == null) {\n            mediaType = MediaType.APPLICATION_WWW_FORM;\n        }\n\n        Form form = null;\n        // Use forms only for PUT, POST and x-www-form-urlencoded\n        if ((Method.PUT == method || Method.POST == method) && MediaType.APPLICATION_WWW_FORM.equals(mediaType, true)) {\n            form = new Form();\n            // must use string based for forms\n            String body = exchange.getIn().getBody(String.class);\n            if (body != null) {\n            \tList<NameValuePair> pairs = URLEncodedUtils.parse(body, Charset.forName(IOHelper.getCharsetName(exchange, true)));\n                for(NameValuePair p : pairs){\n                \tform.add(p.getName(), p.getValue());\n                }\n            }\n        }\n\n        //Get outgoing custom http headers\n        Series<Header> restletHeaders = (Series)request.getAttributes().get(HeaderConstants.ATTRIBUTE_HEADERS);\n    \tif(restletHeaders == null){\n    \t\trestletHeaders = new Series<>(Header.class);\n    \t\trequest.getAttributes().put(HeaderConstants.ATTRIBUTE_HEADERS, restletHeaders);\n    \t}\n\n        // login and password are filtered by header filter strategy\n        String login = exchange.getIn().getHeader(RestletConstants.RESTLET_LOGIN, String.class);\n        String password = exchange.getIn().getHeader(RestletConstants.RESTLET_PASSWORD, String.class);\n\n        if (login != null && password != null) {\n            ChallengeResponse authentication = new ChallengeResponse(ChallengeScheme.HTTP_BASIC, login, password);\n            request.setChallengeResponse(authentication);\n            LOG.debug(\"Basic HTTP Authentication has been applied\");\n        }\n\n        for (Map.Entry<String, Object> entry : exchange.getIn().getHeaders().entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n            if (!headerFilterStrategy.applyFilterToCamelHeaders(key, value, exchange)) {\n                // Use forms only for PUT, POST and x-www-form-urlencoded\n                if (form != null) {\n                    if (key.startsWith(\"org.restlet.\")) {\n                        // put the org.restlet headers in attributes\n                        request.getAttributes().put(key, value);\n                    } else {\n                        // put the user stuff in the form\n                        if (value instanceof Collection) {\n                            for (Object v : (Collection<?>) value) {\n                                form.add(key, v.toString());\n                                restletHeaders.set(key, value.toString());\n                            }\n                        } else {\n                        \t//Add headers to headers and to body\n                            form.add(key, value.toString());\n                            restletHeaders.set(key, value.toString());\n                        }\n                    }\n                } else {\n                    // For non-form post put all the headers in custom headers\n                    restletHeaders.set(key, value.toString());\n                }\n                LOG.debug(\"Populate Restlet request from exchange header: {} value: {}\", key, value);\n            }\n        }\n\n        if (form != null) {\n            request.setEntity(form.getWebRepresentation());\n            LOG.debug(\"Populate Restlet {} request from exchange body as form using media type {}\", method, mediaType);\n        } else {\n            // include body if PUT or POST\n            if (request.getMethod() == Method.PUT || request.getMethod() == Method.POST) {\n                Representation body = createRepresentationFromBody(exchange, mediaType);\n                request.setEntity(body);\n                LOG.debug(\"Populate Restlet {} request from exchange body: {} using media type {}\", method, body, mediaType);\n            } else {\n                // no body\n                LOG.debug(\"Populate Restlet {} request from exchange using media type {}\", method, mediaType);\n                request.setEntity(new EmptyRepresentation());\n            }\n        }\n\n        // accept\n        String accept = exchange.getIn().getHeader(\"Accept\", String.class);\n        if (accept != null) {\n            MediaType acceptedMediaType = exchange.getContext().getTypeConverter().tryConvertTo(MediaType.class, exchange, accept);\n            if (acceptedMediaType != null) {\n                request.getClientInfo().getAcceptedMediaTypes().add(new Preference<MediaType>(acceptedMediaType));\n            }\n        }\n        MediaType acceptedMediaType = exchange.getIn().getHeader(Exchange.ACCEPT_CONTENT_TYPE, MediaType.class);\n        if (acceptedMediaType != null) {\n            request.getClientInfo().getAcceptedMediaTypes().add(new Preference<MediaType>(acceptedMediaType));\n        }\n\n    }","commit_id":"38677d2b58855d5949c5996108410bc3f6b108b6","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testBasicAuth() throws IOException {\n        \n        // START SNIPPET: auth_request\n        final String id = \"89531\";\n\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(RestletConstants.RESTLET_LOGIN, \"admin\");\n        headers.put(RestletConstants.RESTLET_PASSWORD, \"foo\");\n        headers.put(\"id\", id);\n        \n        String response = template.requestBodyAndHeaders(\n            \"direct:start-auth\", \"<order foo='1'/>\", headers, String.class);\n        // END SNIPPET: auth_request\n\n        assertEquals(\"received [<order foo='1'/>] as an order id = \" + id, response);\n    }","id":75512,"modified_method":"@Test\n    public void testBasicAuth() throws IOException {\n        \n        // START SNIPPET: auth_request\n        final String id = \"89531\";\n\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(RestletConstants.RESTLET_LOGIN, \"admin\");\n        headers.put(RestletConstants.RESTLET_PASSWORD, \"foo\");\n        headers.put(Exchange.CONTENT_TYPE, MediaType.APPLICATION_XML);\n        headers.put(\"id\", id);\n        \n        String response = template.requestBodyAndHeaders(\n            \"direct:start-auth\", \"<order foo='1'/>\", headers, String.class);\n        // END SNIPPET: auth_request\n\n        assertEquals(\"received [<order foo='1'/>] as an order id = \" + id, response);\n    }","commit_id":"38677d2b58855d5949c5996108410bc3f6b108b6","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testProducer() throws IOException {\n        String response = template.requestBody(\"direct:start\", \"<order foo='1'/>\", String.class);\n        assertEquals(\"received [<order foo='1'/>] as an order id = \" + ID, response);\n        \n        response = template.requestBodyAndHeader(\n            \"restlet:http://localhost:\" + portNum + \"/orders?restletMethod=post&foo=bar\", \n            \"<order foo='1'/>\", \"id\", \"89531\", String.class);\n        assertEquals(\"received [<order foo='1'/>] as an order id = \" + ID, response);\n    }","id":75513,"modified_method":"@Test\n    public void testProducer() throws IOException {\n    \tMap<String, Object> headers = new HashMap<String, Object>();\n        headers.put(Exchange.CONTENT_TYPE, MediaType.APPLICATION_XML);\n        \n        String response = template.requestBodyAndHeaders(\"direct:start\", \"<order foo='1'/>\", headers, String.class);\n        assertEquals(\"received [<order foo='1'/>] as an order id = \" + ID, response);\n        \n        headers.put(\"id\", \"89531\");\n        \n        response = template.requestBodyAndHeaders(\n            \"restlet:http://localhost:\" + portNum + \"/orders?restletMethod=post&foo=bar\", \n            \"<order foo='1'/>\", headers, String.class);\n        assertEquals(\"received [<order foo='1'/>] as an order id = \" + ID, response);\n    }","commit_id":"38677d2b58855d5949c5996108410bc3f6b108b6","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected RouteBuilder createRouteBuilder() {\n        return new RouteBuilder() {\n            public void configure() {\n                \n                // Restlet producer to use POST method. The RestletMethod=post will be stripped\n                // before request is sent.\n                from(\"direct:start\").setHeader(\"id\", constant(ID))\n                    .to(\"restlet:http://localhost:\" + portNum + \"/orders?restletMethod=post&foo=bar\");\n\n                // Restlet consumer to handler POST method\n                from(\"restlet:http://localhost:\" + portNum + \"/orders?restletMethod=post\").process(new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        exchange.getOut().setBody(\n                            \"received [\" + exchange.getIn().getBody(String.class)\n                            + \"] as an order id = \"\n                            + exchange.getIn().getHeader(\"id\"));\n                    }\n                });\n\n                // Restlet consumer to handler POST method\n                from(\"restlet:http://localhost:\" + portNum + \"/ordersJSON?restletMethod=post\").process(new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        String body = exchange.getIn().getBody(String.class);\n                        if (body.indexOf(\"{\") == -1) {\n                            throw new Exception(\"Inproperly formatted JSON:  \" + body);\n                        }\n                        exchange.getOut().setBody(body);\n                    }\n                });\n\n                // Restlet consumer default to handle GET method\n                from(\"restlet:http://localhost:\" + portNum + \"/orders/{id}/{x}\").process(new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        exchange.getOut().setBody(\n                            \"received GET request with id=\"\n                            + exchange.getIn().getHeader(\"id\")\n                            + \" and x=\"\n                            + exchange.getIn().getHeader(\"x\"));\n                    }\n                });\n            }\n        };\n    }","id":75514,"modified_method":"@Override\n    protected RouteBuilder createRouteBuilder() {\n        return new RouteBuilder() {\n            public void configure() {\n                \n                // Restlet producer to use POST method. The RestletMethod=post will be stripped\n                // before request is sent.\n                from(\"direct:start\").setHeader(\"id\", constant(ID))\n                    .to(\"restlet:http://localhost:\" + portNum + \"/orders?restletMethod=post&foo=bar\");\n\n                // Restlet consumer to handler POST method\n                from(\"restlet:http://localhost:\" + portNum + \"/orders?restletMethod=post\").process(new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        exchange.getOut().setBody(\n                            \"received [\" + exchange.getIn().getBody(String.class)\n                            + \"] as an order id = \"\n                            + exchange.getIn().getHeader(\"id\"));\n                    }\n                });\n\n                // Restlet consumer to handler POST method\n                from(\"restlet:http://localhost:\" + portNum + \"/ordersJSON?restletMethod=post\").process(new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        String body = exchange.getIn().getBody(String.class);\n                        if (body.indexOf(\"{\") == -1) {\n                            throw new Exception(\"Inproperly formatted JSON:  \" + body);\n                        }\n                        exchange.getOut().setBody(body);\n                    }\n                });\n\n                // Restlet consumer default to handle GET method\n                from(\"restlet:http://localhost:\" + portNum + \"/orders/{id}/{x}\").process(new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        exchange.getOut().setBody(\n                            \"received GET request with id=\"\n                            + exchange.getIn().getHeader(\"id\")\n                            + \" and x=\"\n                            + exchange.getIn().getHeader(\"x\"));\n                    }\n                });\n                \n                // Restlet consumer to handler FORM POST method\n                from(\"restlet:http://localhost:\" + portNum + \"/login?restletMethod=post\").process(new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        exchange.getOut().setBody(\n                            \"received user: \"\n                            + exchange.getIn().getHeader(\"user\")\n                            + \"password: \"\n                            + exchange.getIn().getHeader(\"passwd\"));\n                    }\n                });\n            }\n        };\n    }","commit_id":"38677d2b58855d5949c5996108410bc3f6b108b6","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public void configure() throws Exception {\n\n        // get port number dynamically\n        int port = AvailablePortFinder.getNextAvailable();\n\n        // START SNIPPET: consumer_route\n        from(\"restlet:http://localhost:\" + port + \"/securedOrders?restletMethod=post&restletRealm=#realm\").process(new Processor() {\n            public void process(Exchange exchange) throws Exception {\n                exchange.getOut().setBody(\n                        \"received [\" + exchange.getIn().getBody()\n                        + \"] as an order id = \"\n                        + exchange.getIn().getHeader(\"id\"));\n            }\n        });\n        // END SNIPPET: consumer_route\n\n        // START SNIPPET: producer_route\n        // Note: restletMethod and restletRealmRef are stripped \n        // from the query before a request is sent as they are \n        // only processed by Camel.\n        from(\"direct:start-auth\").to(\"restlet:http://localhost:\" + port + \"/securedOrders?restletMethod=post\");\n        // END SNIPPET: producer_route\n      \n    }","id":75515,"modified_method":"@Override\n    public void configure() throws Exception {\n\n        // get port number dynamically\n        int port = AvailablePortFinder.getNextAvailable();\n\n        // START SNIPPET: consumer_route\n        from(\"restlet:http://localhost:\" + port + \"/securedOrders?restletMethod=post&restletRealm=#realm\").process(new Processor() {\n            public void process(Exchange exchange) throws Exception {\n                exchange.getOut().setBody(\n                        \"received [\" + exchange.getIn().getBody(String.class)\n                        + \"] as an order id = \"\n                        + exchange.getIn().getHeader(\"id\"));\n            }\n        });\n        // END SNIPPET: consumer_route\n\n        // START SNIPPET: producer_route\n        // Note: restletMethod and restletRealmRef are stripped \n        // from the query before a request is sent as they are \n        // only processed by Camel.\n        from(\"direct:start-auth\").to(\"restlet:http://localhost:\" + port + \"/securedOrders?restletMethod=post\");\n        // END SNIPPET: producer_route\n      \n    }","commit_id":"38677d2b58855d5949c5996108410bc3f6b108b6","url":"https://github.com/apache/camel"},{"original_method":"public void registerSeverity(@NotNull SeverityBasedTextAttributes info, Color renderColor) {\n    final HighlightSeverity severity = info.getType().getSeverity(null);\n    myMap.put(severity.getName(), info);\n    if (renderColor != null) {\n      myRendererColors.put(severity.getName(), renderColor);\n    }\n    myOrderMap = null;\n\n    Color color = info.getAttributes().getErrorStripeColor();\n    new HighlightDisplayLevel(severity, new HighlightDisplayLevel.TheColorIcon(HighlightDisplayLevel.EMPTY_ICON_DIM, color));\n    severitiesChanged();\n  }","id":75516,"modified_method":"public void registerSeverity(@NotNull SeverityBasedTextAttributes info, Color renderColor) {\n    final HighlightSeverity severity = info.getType().getSeverity(null);\n    myMap.put(severity.getName(), info);\n    if (renderColor != null) {\n      myRendererColors.put(severity.getName(), renderColor);\n    }\n    myOrderMap = null;\n\n    final TextAttributes attributes = info.getAttributes();\n    Color color = attributes.getErrorStripeColor();\n    if (color == null) {\n      color = attributes.getEffectColor();\n    }\n    if (color == null) {\n      color = JBColor.GRAY;\n    }\n    new HighlightDisplayLevel(severity, new HighlightDisplayLevel.TheColorIcon(HighlightDisplayLevel.EMPTY_ICON_DIM, color));\n    severitiesChanged();\n  }","commit_id":"746cbd69d30c13c413edcd89c9a2ca8649efe13b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getAttributeValue(String qname) { //todo ?\n    Map<String, String> map = myAttributeValueMap;\n    while (map == null) {\n      getAttributes();\n      map = myAttributeValueMap;\n    }\n    return map.get(qname);\n  }","id":75517,"modified_method":"public String getAttributeValue(String qname) { //todo ?\n    Map<String, String> map = myAttributeValueMap;\n    while (map == null) {\n      final XmlAttribute[] xmlAttributes = getAttributes();\n      map = myAttributeValueMap;\n\n      if (map == null && xmlAttributes != null) {\n        myAttributes = null;\n      }\n    }\n    return map.get(qname);\n  }","commit_id":"49027fcb1624d3b5325d9b2d3f9c2ad52e2e42d1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Registers a text attribute key with the specified identifier and default attributes.\n   *\n   * @param externalName      the unique identifier of the key.\n   * @param defaultAttributes the default text attributes associated with the key.\n   * @return the new key instance, or an existing instance if the key with the same\n   *         identifier was already registered.\n   */\n  @NotNull\n  public static TextAttributesKey createTextAttributesKey(@NonNls @NotNull String externalName, TextAttributes defaultAttributes) {\n    TextAttributesKey key = TextAttributesKey.find(externalName);\n    if (!ourMap.containsKey(key) || ourMap.get(key) == null) {\n      ourMap.put(key, defaultAttributes);\n    }\n    return key;\n  }","id":75518,"modified_method":"/**\n   * Registers a text attribute key with the specified identifier and default attributes.\n   *\n   * @param externalName      the unique identifier of the key.\n   * @param defaultAttributes the default text attributes associated with the key.\n   * @return the new key instance, or an existing instance if the key with the same\n   *         identifier was already registered.\n   */\n  @NotNull\n  public static TextAttributesKey createTextAttributesKey(@NonNls @NotNull String externalName, TextAttributes defaultAttributes) {\n    TextAttributesKey key = TextAttributesKey.find(externalName);\n    if (!ourMap.containsKey(key) || ourMap.get(key) == NULL_ATTRIBUTES) {\n      ourMap.put(key, defaultAttributes == null ? NULL_ATTRIBUTES : defaultAttributes);\n    }\n    return key;\n  }","commit_id":"87e64ef94292e18105a4bd364f75e7db9b0e9fc5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Returns the default text attributes associated with the key.\n   *\n   * @return the text attributes.\n   * @param key\n   */\n\n  public static TextAttributes getDefaultAttributes(TextAttributesKey key) {\n    if (!ourMap.containsKey(key)) {\n      // E.g. if one text key reuse default attributes of some other predefined key\n      ourMap.put(key, null);\n      EditorColorsManager manager = EditorColorsManager.getInstance();\n\n      if (manager != null) { // Can be null in test mode\n\n        // It is reasonable to fetch attributes from Default color scheme. Otherwise if we launch IDE and then\n        // try switch from custom colors scheme (e.g. with dark background) to default one. Editor will show\n        // incorrect highlighting with \"traces\" of color scheme which was active during IDE startup.\n        final EditorColorsScheme defaultColorScheme = manager.getScheme(EditorColorsScheme.DEFAULT_SCHEME_NAME);\n        ourMap.put(key, defaultColorScheme.getAttributes(key));\n      }\n    }\n\n    if (!ourMap.containsKey(key))\n      return NULL_ATTRIBUTES;\n    return ourMap.get(key);\n  }","id":75519,"modified_method":"/**\n   * Returns the default text attributes associated with the key.\n   *\n   * @return the text attributes.\n   * @param key\n   */\n\n  public static TextAttributes getDefaultAttributes(TextAttributesKey key) {\n    if (!ourMap.containsKey(key)) {\n      // E.g. if one text key reuse default attributes of some other predefined key\n      ourMap.put(key, NULL_ATTRIBUTES);\n      EditorColorsManager manager = EditorColorsManager.getInstance();\n\n      if (manager != null) { // Can be null in test mode\n\n        // It is reasonable to fetch attributes from Default color scheme. Otherwise if we launch IDE and then\n        // try switch from custom colors scheme (e.g. with dark background) to default one. Editor will show\n        // incorrect highlighting with \"traces\" of color scheme which was active during IDE startup.\n        final EditorColorsScheme defaultColorScheme = manager.getScheme(EditorColorsScheme.DEFAULT_SCHEME_NAME);\n        final TextAttributes textAttributes = defaultColorScheme.getAttributes(key);\n        if (textAttributes != null)\n          ourMap.put(key, textAttributes);\n      }\n    }\n\n    return ourMap.get(key);\n  }","commit_id":"87e64ef94292e18105a4bd364f75e7db9b0e9fc5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visit(JavaClass obj) {\n        String superclassName = obj.getSuperclassName();\n        isSynthetic = superclassName.equals(\"java.rmi.server.RemoteStub\");\n        for(Attribute a : obj.getAttributes()) \n            if (a instanceof Synthetic)\n                isSynthetic = true;\n  \n    }","id":75520,"modified_method":"@Override\n    public void visit(JavaClass obj) {\n        String superclassName = obj.getSuperclassName();\n        isSynthetic = superclassName.equals(\"java.rmi.server.RemoteStub\");\n        Attribute[] attributes = obj.getAttributes();\n        if (attributes != null)\n            for(Attribute a : attributes) \n            if (a instanceof Synthetic)\n                isSynthetic = true;\n  \n    }","commit_id":"a862a8efad79427f142f8954e6323fd88b875e0f","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public RowMeta getFields(String searchBase) throws KettleException {\r\n\t\t\t\t\r\n\t\ttry {\r\n\t\t\tsearch(searchBase, null, 0, null);\r\n\t\t\tAttributes attributes = getAttributes();\r\n\t\r\n\t        NamingEnumeration<? extends Attribute> ne = attributes.getAll();\r\n\t        RowMeta fields = new RowMeta();\r\n\r\n\t        Attribute attr = null;\r\n\t        \r\n\t        while (ne.hasMore()) {\r\n\t        \tattr = ne.next();\r\n\t    \t\t// Get fieldname\r\n\t\t\t    ValueMetaInterface value = new ValueMeta(attr.getID());\r\n\t\r\n\t            String attributeValue=attr.getID();\r\n\t            // Try to get the Type\r\n\t            if(IsDate(attributeValue)){\r\n\t            \tvalue.setType(ValueMeta.TYPE_DATE);\r\n\t    \t\t} else if(IsInteger(attributeValue)){\r\n\t    \t\t\tvalue.setType(ValueMeta.TYPE_INTEGER);\r\n\t    \t\t} else if(IsNumber(attributeValue)){\r\n\t    \t\t\tvalue.setType(ValueMeta.TYPE_NUMBER);\r\n\t    \t\t} else {\r\n\t    \t\t\tvalue.setType(ValueMeta.TYPE_STRING);\t\t            \r\n\t            }  \r\n\t            fields.addValueMeta(value);\r\n\t        }\r\n\t        \r\n\t        return fields;\r\n\t\t}catch(Exception e){\r\n\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"LDAPConnection.Error.RetrievingFields\"));\r\n\t\t}\r\n\t}","id":75521,"modified_method":"public RowMeta getFields(String searchBase) throws KettleException {\r\n        RowMeta fields = new RowMeta();\t\r\n        List<String> fieldsl = new ArrayList<String>();\r\n\t\ttry {\r\n\t\t\tsearch(searchBase, null, 0, null);\r\n\t\t\tAttributes attributes =null;\r\n\t\t\tfieldsl = new ArrayList<String>();\r\n\t\t\twhile(( attributes = getAttributes())!=null) {\r\n\t\r\n\t\t        NamingEnumeration<? extends Attribute> ne = attributes.getAll();\r\n\t\t        \r\n\t\t        while (ne.hasMore()) {\r\n\t\t        \tAttribute attr = ne.next();\r\n\t\t        \tString fieldName = attr.getID();\r\n\t\t        \tif(!fieldsl.contains(fieldName)){\r\n\t\t        \t\tfieldsl.add(fieldName);\r\n\t\t        \t\r\n\t\t\t    \t\t// Get fieldname\r\n\t\t\t\t\t    ValueMetaInterface value = new ValueMeta(fieldName);\r\n\t\t\t\r\n\t\t\t            String attributeValue=attr.get().toString();\r\n\t\t\t            // Try to get the Type\r\n\t\t\t            if(IsDate(attributeValue)){\r\n\t\t\t            \tvalue.setType(ValueMeta.TYPE_DATE);\r\n\t\t\t    \t\t} else if(IsInteger(attributeValue)){\r\n\t\t\t    \t\t\tvalue.setType(ValueMeta.TYPE_INTEGER);\r\n\t\t\t    \t\t} else if(IsNumber(attributeValue)){\r\n\t\t\t    \t\t\tvalue.setType(ValueMeta.TYPE_NUMBER);\r\n\t\t\t    \t\t} else {\r\n\t\t\t    \t\t\tvalue.setType(ValueMeta.TYPE_STRING);\t\t            \r\n\t\t\t            }  \r\n\t\t\t            fields.addValueMeta(value);\r\n\t\t        \t}\r\n\t\t        }\r\n\t\t\t}\r\n\t        return fields;\r\n\t\t}catch(Exception e){\r\n\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"LDAPConnection.Error.RetrievingFields\"));\r\n\t\t}finally{\r\n\t\t\tfieldsl=null;\r\n\t\t}\r\n\t}","commit_id":"91c351ad1049abf8ae3fd6565aae59b6d6aa8677","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void get()\r\n\t{\r\n\t\tLDAPConnection connection = null;\r\n        try\r\n        {\r\n\t\t\r\n    \t\tLDAPInputMeta meta = new LDAPInputMeta();\r\n    \t\tgetInfo(meta);\r\n            \r\n            // Clear Fields Grid\r\n            wFields.removeAll();\r\n\r\n            // Defined a LDAP connection\r\n    \t\tconnection = new LDAPConnection(log, transMeta.environmentSubstitute(meta.getHost()), \r\n    \t\t\t\tConst.toInt(transMeta.environmentSubstitute(meta.getPort()), LDAPConnection.DEFAULT_PORT));\r\n    \t\t\r\n    \t\t// connect ...\r\n    \t\tif(meta.UseAuthentication()) {\r\n        \t\tString username=transMeta.environmentSubstitute(meta.getUserName());\r\n        \t\tString password=Encr.decryptPasswordOptionallyEncrypted(transMeta.environmentSubstitute(meta.getPassword()));\r\n    \t\t\tconnection.connect(username, password);\r\n    \t\t}else {\r\n    \t\t\tconnection.connect();\r\n    \t\t}\r\n\r\n    \t\t// return fields\r\n    \t\tRowMeta listattributes=connection.getFields(transMeta.environmentSubstitute(meta.getSearchBase()));\r\n    \t\tString[] fieldsName= new String[listattributes.size()];\r\n    \t\tfor(int i=0; i<listattributes.size(); i++) {\r\n    \t\t\t\r\n    \t\t\tValueMetaInterface v = listattributes.getValueMeta(i);\r\n    \t\t\tfieldsName[i]=v.getName();\r\n\t\t\t\t// Get Column Name\r\n\t            TableItem item = new TableItem(wFields.table, SWT.NONE);\r\n\t            item.setText(1, v.getName());\r\n\t            item.setText(2, v.getName());\r\n\t            \r\n\t            if(LDAPInputField.binaryAttributes.contains(v.getName())) {\r\n\t            \titem.setText(3, BaseMessages.getString(PKG, \"LDAPInputField.FetchAttributeAs.Binary\"));\r\n\t            }else {\r\n\t            \titem.setText(3, BaseMessages.getString(PKG, \"LDAPInputField.FetchAttributeAs.String\"));\r\n\t            }\r\n\t            item.setText(4,  v.getTypeDesc()); \r\n    \t\t}\r\n            colinf[1].setComboValues(fieldsName);\r\n            wFields.removeEmptyRows();\r\n            wFields.setRowNums();\r\n            wFields.optWidth(true); \r\n     \r\n        }\r\n        catch(KettleException e)\r\n        {\r\n            new ErrorDialog(shell, BaseMessages.getString(PKG, \"LDAPInputDialog.ErrorGettingColums.DialogTitle\"), BaseMessages.getString(PKG, \"LDAPInputDialog.ErrorGettingColums.DialogMessage\"), e);\r\n        }\r\n    \tcatch(Exception e)\r\n\t\t{\r\n    \t\t new ErrorDialog(shell, BaseMessages.getString(PKG, \"LDAPInputDialog.ErrorGettingColums.DialogTitle\"), BaseMessages.getString(PKG, \"LDAPInputDialog.ErrorGettingColums.DialogMessage\"), e);\r\n\r\n\t\t}finally {\r\n\t\t\tif(connection!=null) {\r\n\t\t\t\ttry {connection.close();}catch(Exception e){};\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":75522,"modified_method":"private void get()\r\n\t{\r\n\t\tLDAPConnection connection = null;\r\n        try\r\n        {\r\n\t\t\r\n    \t\tLDAPInputMeta meta = new LDAPInputMeta();\r\n    \t\tgetInfo(meta);\r\n            \r\n            // Clear Fields Grid\r\n            wFields.removeAll();\r\n\r\n            // Defined a LDAP connection\r\n    \t\tconnection = new LDAPConnection(log, transMeta.environmentSubstitute(meta.getHost()), \r\n    \t\t\t\tConst.toInt(transMeta.environmentSubstitute(meta.getPort()), LDAPConnection.DEFAULT_PORT));\r\n    \t\t\r\n    \t\t// connect ...\r\n    \t\tif(meta.UseAuthentication()) {\r\n        \t\tString username=transMeta.environmentSubstitute(meta.getUserName());\r\n        \t\tString password=Encr.decryptPasswordOptionallyEncrypted(transMeta.environmentSubstitute(meta.getPassword()));\r\n    \t\t\tconnection.connect(username, password);\r\n    \t\t}else {\r\n    \t\t\tconnection.connect();\r\n    \t\t}\r\n\r\n    \t\t// return fields\r\n    \t\tRowMeta listattributes=connection.getFields(transMeta.environmentSubstitute(meta.getSearchBase()));\r\n    \t\tString[] fieldsName= new String[listattributes.size()];\r\n    \t\tfor(int i=0; i<listattributes.size(); i++) {\r\n    \t\t\t\r\n    \t\t\tValueMetaInterface v = listattributes.getValueMeta(i);\r\n    \t\t\tfieldsName[i]=v.getName();\r\n\t\t\t\t// Get Column Name\r\n\t            TableItem item = new TableItem(wFields.table, SWT.NONE);\r\n\t            item.setText(1, v.getName());\r\n\t            item.setText(2, v.getName());\r\n\t            \r\n\t            if(LDAPInputField.binaryAttributes.contains(v.getName())) {\r\n\t            \titem.setText(3, BaseMessages.getString(PKG, \"LDAPInputField.FetchAttributeAs.Binary\"));\r\n\t            }else {\r\n\t            \titem.setText(3, BaseMessages.getString(PKG, \"LDAPInputField.FetchAttributeAs.String\"));\r\n\t            }\r\n\t            item.setText(4,  BaseMessages.getString(PKG, \"System.Combo.No\"));\r\n\t            item.setText(5,  v.getTypeDesc()); \r\n    \t\t}\r\n            colinf[1].setComboValues(fieldsName);\r\n            wFields.removeEmptyRows();\r\n            wFields.setRowNums();\r\n            wFields.optWidth(true); \r\n     \r\n        }\r\n        catch(KettleException e)\r\n        {\r\n            new ErrorDialog(shell, BaseMessages.getString(PKG, \"LDAPInputDialog.ErrorGettingColums.DialogTitle\"), BaseMessages.getString(PKG, \"LDAPInputDialog.ErrorGettingColums.DialogMessage\"), e);\r\n        }\r\n    \tcatch(Exception e)\r\n\t\t{\r\n    \t\t new ErrorDialog(shell, BaseMessages.getString(PKG, \"LDAPInputDialog.ErrorGettingColums.DialogTitle\"), BaseMessages.getString(PKG, \"LDAPInputDialog.ErrorGettingColums.DialogMessage\"), e);\r\n\r\n\t\t}finally {\r\n\t\t\tif(connection!=null) {\r\n\t\t\t\ttry {connection.close();}catch(Exception e){};\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"91c351ad1049abf8ae3fd6565aae59b6d6aa8677","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/** {@inheritDoc} */\n    @Override public void readPortable(GridPortableReader reader) throws IOException {\n        qryId = reader.readLong(\"queryId\");\n        items = reader.readCollection(\"items\");\n        last = reader.readBoolean(\"last\");\n        nodeId = reader.readUuid(\"nodeId\");\n    }","id":75523,"modified_method":"/** {@inheritDoc} */\n    @Override public void readPortable(GridPortableReader reader) throws GridPortableException {\n        GridPortableRawReader rawReader = reader.rawReader();\n\n        qryId = rawReader.readLong();\n        items = rawReader.readCollection();\n        last = rawReader.readBoolean();\n        nodeId = rawReader.readUuid();\n    }","commit_id":"02078856a709bc636e66a529bbb6c659d044622c","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override public void writePortable(GridPortableWriter writer) throws IOException {\n        writer.writeLong(\"queryId\", qryId);\n        writer.writeCollection(\"items\", items);\n        writer.writeBoolean(\"last\", last);\n        writer.writeUuid(\"nodeId\", nodeId);\n    }","id":75524,"modified_method":"/** {@inheritDoc} */\n    @Override public void writePortable(GridPortableWriter writer) throws GridPortableException {\n        GridPortableRawWriter rawWriter = writer.rawWriter();\n\n        rawWriter.writeLong(qryId);\n        rawWriter.writeCollection(items);\n        rawWriter.writeBoolean(last);\n        rawWriter.writeUuid(nodeId);\n    }","commit_id":"02078856a709bc636e66a529bbb6c659d044622c","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @param queryId Query ID.\n     * @param wrapper Query future wrapper.\n     * @return Rest response.\n     */\n    private static GridRestResponse fetchQueryResults(\n        long queryId,\n        int num, QueryFutureWrapper wrapper,\n        ConcurrentMap<QueryExecutionKey, QueryFutureWrapper> locMap,\n        UUID locNodeId\n    ) throws GridException {\n        if (wrapper == null)\n            throw new GridException(\"Failed to find query future (query has been expired).\");\n\n        GridCacheQueryFuture<?> fut = wrapper.future();\n\n        Collection<Object> col = new ArrayList<>(num);\n\n        int cnt = 0;\n\n        GridCacheRestResponse res = new GridCacheRestResponse();\n\n        GridCacheClientQueryResult qryRes = new GridCacheClientQueryResult();\n\n        while (cnt < num) {\n            Object obj = fut.next();\n\n            if (obj == null) {\n                qryRes.last(true);\n\n                locMap.remove(new QueryExecutionKey(queryId), wrapper);\n\n                break;\n            }\n\n            col.add(obj);\n        }\n\n        qryRes.items(col);\n        qryRes.queryId(queryId);\n        qryRes.nodeId(locNodeId);\n\n        res.setResponse(qryRes);\n\n        return res;\n    }","id":75525,"modified_method":"/**\n     * @param queryId Query ID.\n     * @param wrapper Query future wrapper.\n     * @return Rest response.\n     */\n    private static GridRestResponse fetchQueryResults(\n        long queryId,\n        int pageSize,\n        QueryFutureWrapper wrapper,\n        ConcurrentMap<QueryExecutionKey, QueryFutureWrapper> locMap,\n        UUID locNodeId\n    ) throws GridException {\n        if (wrapper == null)\n            throw new GridException(\"Failed to find query future (query has been expired).\");\n\n        if (pageSize <= 0)\n            pageSize = GridCacheQuery.DFLT_PAGE_SIZE;\n\n        GridCacheQueryFuture<?> fut = wrapper.future();\n\n        Collection<Object> col = new ArrayList<>(pageSize);\n\n        int cnt = 0;\n\n        GridCacheRestResponse res = new GridCacheRestResponse();\n\n        GridCacheClientQueryResult qryRes = new GridCacheClientQueryResult();\n\n        while (cnt < pageSize) {\n            Object obj = fut.next();\n\n            if (obj == null) {\n                qryRes.last(true);\n\n                locMap.remove(new QueryExecutionKey(queryId), wrapper);\n\n                break;\n            }\n\n            col.add(obj);\n        }\n\n        qryRes.items(col);\n        qryRes.queryId(queryId);\n        qryRes.nodeId(locNodeId);\n\n        res.setResponse(qryRes);\n\n        return res;\n    }","commit_id":"02078856a709bc636e66a529bbb6c659d044622c","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n        @SuppressWarnings({\"unchecked\", \"IfMayBeConditional\"})\n        @Override public GridRestResponse call() throws Exception {\n            long qryId = qryIdGen.getAndIncrement();\n\n            GridCacheQueries<Object, Object> queries = g.cache(req.cacheName()).queries();\n\n            GridCacheQuery<?> qry;\n\n            switch (req.type()) {\n                case SQL:\n                    qry = queries.createSqlQuery(Class.forName(req.className()), req.clause());\n\n                    break;\n\n                case SQL_FIELDS:\n                    qry = queries.createSqlFieldsQuery(req.clause());\n\n                    break;\n\n                case FULL_TEXT:\n                    qry = queries.createFullTextQuery(Class.forName(req.className()), req.clause());\n\n                    break;\n\n                case SCAN:\n                    qry = queries.createScanQuery(instance(GridBiPredicate.class, req.className(),\n                        req.classArguments()));\n\n                    break;\n\n                default:\n                    throw new GridException(\"Unsupported query type: \" + req.type());\n            }\n\n            qry = qry.pageSize(req.pageSize()).timeout(req.timeout()).includeBackups(req.includeBackups())\n                .enableDedup(req.enableDedup()).keepAll(false);\n\n            GridCacheQueryFuture<?> fut;\n\n            if (req.remoteReducerClassName() != null) {\n                fut = qry.execute(\n                    instance(GridReducer.class, req.remoteReducerClassName(), req.classArguments()),\n                    req.queryArguments());\n            }\n            else if (req.remoteTransformerClassName() != null) {\n                fut = qry.execute(\n                    instance(GridClosure.class, req.remoteTransformerClassName(), req.classArguments()),\n                    req.queryArguments());\n            }\n            else {\n                fut = qry.execute(req.queryArguments());\n            }\n\n            GridNodeLocalMap<QueryExecutionKey, QueryFutureWrapper> locMap =\n                g.nodeLocalMap();\n\n            QueryFutureWrapper wrapper = new QueryFutureWrapper(fut);\n\n            QueryFutureWrapper old = locMap.putIfAbsent(new QueryExecutionKey(qryId), wrapper);\n\n            assert old == null;\n\n            return fetchQueryResults(qryId, req.pageSize(), wrapper, locMap, g.localNode().id());\n        }","id":75526,"modified_method":"/** {@inheritDoc} */\n        @SuppressWarnings({\"unchecked\", \"IfMayBeConditional\"})\n        @Override public GridRestResponse call() throws Exception {\n            long qryId = qryIdGen.getAndIncrement();\n\n            GridCacheQueries<Object, Object> queries = g.cache(req.cacheName()).queries();\n\n            GridCacheQuery<?> qry;\n\n            switch (req.type()) {\n                case SQL:\n                    qry = queries.createSqlQuery(Class.forName(req.className()), req.clause());\n\n                    break;\n\n                case SQL_FIELDS:\n                    qry = queries.createSqlFieldsQuery(req.clause());\n\n                    break;\n\n                case FULL_TEXT:\n                    qry = queries.createFullTextQuery(Class.forName(req.className()), req.clause());\n\n                    break;\n\n                case SCAN:\n                    qry = queries.createScanQuery(instance(GridBiPredicate.class, req.className(),\n                        req.classArguments()));\n\n                    break;\n\n                default:\n                    throw new GridException(\"Unsupported query type: \" + req.type());\n            }\n\n            if (req.pageSize() > 0)\n                qry = qry.pageSize(req.pageSize());\n\n            if (req.timeout() > 0)\n                qry = qry.timeout(req.timeout());\n\n            qry = qry.includeBackups(req.includeBackups()).enableDedup(req.enableDedup()).keepAll(false);\n\n            GridCacheQueryFuture<?> fut;\n\n            if (req.remoteReducerClassName() != null) {\n                fut = qry.execute(\n                    instance(GridReducer.class, req.remoteReducerClassName(), req.classArguments()),\n                    req.queryArguments());\n            }\n            else if (req.remoteTransformerClassName() != null) {\n                fut = qry.execute(\n                    instance(GridClosure.class, req.remoteTransformerClassName(), req.classArguments()),\n                    req.queryArguments());\n            }\n            else {\n                fut = qry.execute(req.queryArguments());\n            }\n\n            GridNodeLocalMap<QueryExecutionKey, QueryFutureWrapper> locMap =\n                g.nodeLocalMap();\n\n            QueryFutureWrapper wrapper = new QueryFutureWrapper(fut);\n\n            QueryFutureWrapper old = locMap.putIfAbsent(new QueryExecutionKey(qryId), wrapper);\n\n            assert old == null;\n\n            return fetchQueryResults(qryId, req.pageSize(), wrapper, locMap, g.localNode().id());\n        }","commit_id":"02078856a709bc636e66a529bbb6c659d044622c","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override public void readPortable(GridPortableReader reader) throws IOException {\n        super.readPortable(reader);\n\n        qryId = reader.readLong(\"queryId\");\n        op = GridQueryOperation.fromOrdinal(reader.readInt(\"op\"));\n        type = GridQueryType.fromOrdinal(reader.readInt(\"type\"));\n        cacheName = reader.readString(\"cacheName\");\n        clause = reader.readString(\"clause\");\n        pageSize = reader.readInt(\"pageSize\");\n        timeout = reader.readLong(\"timeout\");\n        includeBackups = reader.readBoolean(\"includeBackups\");\n        enableDedup = reader.readBoolean(\"enableDedup\");\n        clsName = reader.readString(\"className\");\n        rmtReducerClsName = reader.readString(\"remoteReducerClassName\");\n        rmtTransformerClsName = reader.readString(\"remoteTransformerClassName\");\n        clsArgs = reader.readObjectArray(\"classArguments\");\n        qryArgs = reader.readObjectArray(\"arguments\");\n    }","id":75527,"modified_method":"/** {@inheritDoc} */\n    @Override public void readPortable(GridPortableReader reader) throws GridPortableException {\n        super.readPortable(reader);\n\n        GridPortableRawReader rawReader = reader.rawReader();\n\n        qryId = rawReader.readLong();\n        op = GridQueryOperation.fromOrdinal(rawReader.readInt());\n        type = GridQueryType.fromOrdinal(rawReader.readInt());\n        cacheName = rawReader.readString();\n        clause = rawReader.readString();\n        pageSize = rawReader.readInt();\n        timeout = rawReader.readLong();\n        includeBackups = rawReader.readBoolean();\n        enableDedup = rawReader.readBoolean();\n        clsName = rawReader.readString();\n        rmtReducerClsName = rawReader.readString();\n        rmtTransformerClsName = rawReader.readString();\n        clsArgs = rawReader.readObjectArray();\n        qryArgs = rawReader.readObjectArray();\n    }","commit_id":"02078856a709bc636e66a529bbb6c659d044622c","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override public void writePortable(GridPortableWriter writer) throws IOException {\n        super.writePortable(writer);\n\n        writer.writeLong(\"queryId\", qryId);\n        writer.writeInt(\"op\", op.ordinal());\n        writer.writeInt(\"type\", type.ordinal());\n        writer.writeString(\"cacheName\", cacheName);\n        writer.writeString(\"clause\", clause);\n        writer.writeInt(\"pageSize\", pageSize);\n        writer.writeLong(\"timeout\", timeout);\n        writer.writeBoolean(\"includeBackups\", includeBackups);\n        writer.writeBoolean(\"enableDedup\", enableDedup);\n        writer.writeString(\"className\", clsName);\n        writer.writeString(\"remoteReducerClassName\", rmtReducerClsName);\n        writer.writeString(\"remoteTransformerClassName\", rmtTransformerClsName);\n        writer.writeObjectArray(\"classArguments\", clsArgs);\n        writer.writeObjectArray(\"arguments\", qryArgs);\n    }","id":75528,"modified_method":"/** {@inheritDoc} */\n    @Override public void writePortable(GridPortableWriter writer) throws GridPortableException {\n        super.writePortable(writer);\n\n        GridPortableRawWriter rawWriter = writer.rawWriter();\n\n        rawWriter.writeLong(qryId);\n        rawWriter.writeInt(op.ordinal());\n        rawWriter.writeInt(type.ordinal());\n        rawWriter.writeString(cacheName);\n        rawWriter.writeString(clause);\n        rawWriter.writeInt(pageSize);\n        rawWriter.writeLong(timeout);\n        rawWriter.writeBoolean(includeBackups);\n        rawWriter.writeBoolean(enableDedup);\n        rawWriter.writeString(clsName);\n        rawWriter.writeString(rmtReducerClsName);\n        rawWriter.writeString(rmtTransformerClsName);\n        rawWriter.writeObjectArray(clsArgs);\n        rawWriter.writeObjectArray(qryArgs);\n    }","commit_id":"02078856a709bc636e66a529bbb6c659d044622c","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @param portableCfg Portable configuration.\n     * @return Portable context.\n     * @throws GridPortableException In case of error.\n     */\n    public void configure(@Nullable GridPortableConfiguration portableCfg)\n        throws GridPortableException {\n        addDescriptor(Byte.class, BYTE);\n        addDescriptor(Short.class, SHORT);\n        addDescriptor(Integer.class, INT);\n        addDescriptor(Long.class, LONG);\n        addDescriptor(Float.class, FLOAT);\n        addDescriptor(Double.class, DOUBLE);\n        addDescriptor(Character.class, CHAR);\n        addDescriptor(Boolean.class, BOOLEAN);\n        addDescriptor(String.class, STRING);\n        addDescriptor(UUID.class, UUID);\n        addDescriptor(Date.class, DATE);\n        addDescriptor(byte[].class, BYTE_ARR);\n        addDescriptor(short[].class, SHORT_ARR);\n        addDescriptor(int[].class, INT_ARR);\n        addDescriptor(long[].class, LONG_ARR);\n        addDescriptor(float[].class, FLOAT_ARR);\n        addDescriptor(double[].class, DOUBLE_ARR);\n        addDescriptor(char[].class, CHAR_ARR);\n        addDescriptor(boolean[].class, BOOLEAN_ARR);\n        addDescriptor(String[].class, STRING_ARR);\n        addDescriptor(UUID[].class, UUID_ARR);\n        addDescriptor(Date[].class, DATE_ARR);\n        addDescriptor(Object[].class, OBJ_ARR);\n\n        addDescriptor(ArrayList.class, COL);\n        addDescriptor(LinkedList.class, COL);\n        addDescriptor(HashSet.class, COL);\n        addDescriptor(LinkedHashSet.class, COL);\n        addDescriptor(TreeSet.class, COL);\n        addDescriptor(ConcurrentSkipListSet.class, COL);\n\n        addDescriptor(HashMap.class, MAP);\n        addDescriptor(LinkedHashMap.class, MAP);\n        addDescriptor(TreeMap.class, MAP);\n        addDescriptor(ConcurrentHashMap.class, MAP);\n\n        addDescriptor(GridPortableObjectImpl.class, PORTABLE);\n\n        colTypes.put(ArrayList.class, ARR_LIST);\n        colTypes.put(LinkedList.class, LINKED_LIST);\n        colTypes.put(HashSet.class, HASH_SET);\n        colTypes.put(LinkedHashSet.class, LINKED_HASH_SET);\n        colTypes.put(TreeSet.class, TREE_SET);\n        colTypes.put(ConcurrentSkipListSet.class, CONC_SKIP_LIST_SET);\n\n        mapTypes.put(HashMap.class, HASH_MAP);\n        mapTypes.put(LinkedHashMap.class, LINKED_HASH_MAP);\n        mapTypes.put(TreeMap.class, TREE_MAP);\n        mapTypes.put(ConcurrentHashMap.class, CONC_HASH_MAP);\n\n        // TODO: Configure from server and client?\n        addDescriptor(GridClientAuthenticationRequest.class, 51);\n        addDescriptor(GridClientTopologyRequest.class, 52);\n        addDescriptor(GridClientTaskRequest.class, 53);\n        addDescriptor(GridClientCacheRequest.class, 54);\n        addDescriptor(GridClientLogRequest.class, 55);\n        addDescriptor(GridClientResponse.class, 56);\n        addDescriptor(GridClientNodeBean.class, 57);\n        addDescriptor(GridClientNodeMetricsBean.class, 58);\n        addDescriptor(GridClientTaskResultBean.class, 59);\n\n        if (portableCfg != null) {\n            GridPortableIdMapper globalIdMapper = portableCfg.getIdMapper();\n            GridPortableSerializer globalSerializer = portableCfg.getSerializer();\n\n            for (GridPortableTypeConfiguration typeCfg : portableCfg.getTypeConfigurations()) {\n                String clsName = typeCfg.getClassName();\n\n                if (clsName == null)\n                    throw new GridPortableException(\"Class name is required for portable type configuration.\");\n\n                Class<?> cls;\n\n                try {\n                    cls = Class.forName(clsName);\n                }\n                catch (ClassNotFoundException e) {\n                    throw new GridPortableException(\"Portable class doesn't exist: \" + clsName, e);\n                }\n\n                GridPortableIdMapper idMapper = globalIdMapper;\n                GridPortableSerializer serializer = globalSerializer;\n\n                if (typeCfg.getIdMapper() != null)\n                    idMapper = typeCfg.getIdMapper();\n\n                if (typeCfg.getSerializer() != null)\n                    serializer = typeCfg.getSerializer();\n\n                addUserTypeDescriptor(cls, idMapper, serializer);\n            }\n        }\n    }","id":75529,"modified_method":"/**\n     * @param portableCfg Portable configuration.\n     * @return Portable context.\n     * @throws GridPortableException In case of error.\n     */\n    public void configure(@Nullable GridPortableConfiguration portableCfg)\n        throws GridPortableException {\n        addDescriptor(Byte.class, BYTE);\n        addDescriptor(Short.class, SHORT);\n        addDescriptor(Integer.class, INT);\n        addDescriptor(Long.class, LONG);\n        addDescriptor(Float.class, FLOAT);\n        addDescriptor(Double.class, DOUBLE);\n        addDescriptor(Character.class, CHAR);\n        addDescriptor(Boolean.class, BOOLEAN);\n        addDescriptor(String.class, STRING);\n        addDescriptor(UUID.class, UUID);\n        addDescriptor(Date.class, DATE);\n        addDescriptor(byte[].class, BYTE_ARR);\n        addDescriptor(short[].class, SHORT_ARR);\n        addDescriptor(int[].class, INT_ARR);\n        addDescriptor(long[].class, LONG_ARR);\n        addDescriptor(float[].class, FLOAT_ARR);\n        addDescriptor(double[].class, DOUBLE_ARR);\n        addDescriptor(char[].class, CHAR_ARR);\n        addDescriptor(boolean[].class, BOOLEAN_ARR);\n        addDescriptor(String[].class, STRING_ARR);\n        addDescriptor(UUID[].class, UUID_ARR);\n        addDescriptor(Date[].class, DATE_ARR);\n        addDescriptor(Object[].class, OBJ_ARR);\n\n        addDescriptor(ArrayList.class, COL);\n        addDescriptor(LinkedList.class, COL);\n        addDescriptor(HashSet.class, COL);\n        addDescriptor(LinkedHashSet.class, COL);\n        addDescriptor(TreeSet.class, COL);\n        addDescriptor(ConcurrentSkipListSet.class, COL);\n\n        addDescriptor(HashMap.class, MAP);\n        addDescriptor(LinkedHashMap.class, MAP);\n        addDescriptor(TreeMap.class, MAP);\n        addDescriptor(ConcurrentHashMap.class, MAP);\n\n        addDescriptor(GridPortableObjectImpl.class, PORTABLE);\n\n        colTypes.put(ArrayList.class, ARR_LIST);\n        colTypes.put(LinkedList.class, LINKED_LIST);\n        colTypes.put(HashSet.class, HASH_SET);\n        colTypes.put(LinkedHashSet.class, LINKED_HASH_SET);\n        colTypes.put(TreeSet.class, TREE_SET);\n        colTypes.put(ConcurrentSkipListSet.class, CONC_SKIP_LIST_SET);\n\n        mapTypes.put(HashMap.class, HASH_MAP);\n        mapTypes.put(LinkedHashMap.class, LINKED_HASH_MAP);\n        mapTypes.put(TreeMap.class, TREE_MAP);\n        mapTypes.put(ConcurrentHashMap.class, CONC_HASH_MAP);\n\n        // TODO: Configure from server and client?\n        addDescriptor(GridClientAuthenticationRequest.class, 51);\n        addDescriptor(GridClientTopologyRequest.class, 52);\n        addDescriptor(GridClientTaskRequest.class, 53);\n        addDescriptor(GridClientCacheRequest.class, 54);\n        addDescriptor(GridClientLogRequest.class, 55);\n        addDescriptor(GridClientResponse.class, 56);\n        addDescriptor(GridClientNodeBean.class, 57);\n        addDescriptor(GridClientNodeMetricsBean.class, 58);\n        addDescriptor(GridClientTaskResultBean.class, 59);\n        addDescriptor(GridClientCacheQueryRequest.class, 60);\n        addDescriptor(GridCacheClientQueryResult.class, 61);\n\n        if (portableCfg != null) {\n            GridPortableIdMapper globalIdMapper = portableCfg.getIdMapper();\n            GridPortableSerializer globalSerializer = portableCfg.getSerializer();\n\n            for (GridPortableTypeConfiguration typeCfg : portableCfg.getTypeConfigurations()) {\n                String clsName = typeCfg.getClassName();\n\n                if (clsName == null)\n                    throw new GridPortableException(\"Class name is required for portable type configuration.\");\n\n                Class<?> cls;\n\n                try {\n                    cls = Class.forName(clsName);\n                }\n                catch (ClassNotFoundException e) {\n                    throw new GridPortableException(\"Portable class doesn't exist: \" + clsName, e);\n                }\n\n                GridPortableIdMapper idMapper = globalIdMapper;\n                GridPortableSerializer serializer = globalSerializer;\n\n                if (typeCfg.getIdMapper() != null)\n                    idMapper = typeCfg.getIdMapper();\n\n                if (typeCfg.getSerializer() != null)\n                    serializer = typeCfg.getSerializer();\n\n                addUserTypeDescriptor(cls, idMapper, serializer);\n            }\n        }\n    }","commit_id":"02078856a709bc636e66a529bbb6c659d044622c","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Creates a REST request object from client TCP binary packet.\n     *\n     * @param ses NIO session.\n     * @param msg Request message.\n     * @return REST request object.\n     */\n    @Nullable private GridRestRequest createRestRequest(GridNioSession ses, GridClientMessage msg) {\n        GridRestRequest restReq = null;\n\n        if (msg instanceof GridClientAuthenticationRequest) {\n            GridClientAuthenticationRequest req = (GridClientAuthenticationRequest)msg;\n\n            restReq = new GridRestTaskRequest();\n\n            restReq.command(NOOP);\n\n            restReq.credentials(req.credentials());\n        }\n        else if (msg instanceof GridClientCacheRequest) {\n            GridClientCacheRequest req = (GridClientCacheRequest)msg;\n\n            GridRestCacheRequest restCacheReq = new GridRestCacheRequest();\n\n            restCacheReq.cacheName(req.cacheName());\n            restCacheReq.cacheFlags(req.cacheFlagsOn());\n\n            restCacheReq.key(req.key());\n            restCacheReq.value(req.value());\n            restCacheReq.value2(req.value2());\n\n            Map vals = req.values();\n            if (vals != null)\n                restCacheReq.values(new HashMap<Object, Object>(vals));\n\n            restCacheReq.command(cacheCmdMap.get(req.operation()));\n\n            restReq = restCacheReq;\n        }\n        else if (msg instanceof GridClientTaskRequest) {\n            GridClientTaskRequest req = (GridClientTaskRequest) msg;\n\n            GridRestTaskRequest restTaskReq = new GridRestTaskRequest();\n\n            restTaskReq.command(EXE);\n\n            restTaskReq.taskName(req.taskName());\n            restTaskReq.params(Arrays.asList(req.argument()));\n\n            restReq = restTaskReq;\n        }\n        else if (msg instanceof GridClientTopologyRequest) {\n            GridClientTopologyRequest req = (GridClientTopologyRequest) msg;\n\n            GridRestTopologyRequest restTopReq = new GridRestTopologyRequest();\n\n            restTopReq.includeMetrics(req.includeMetrics());\n            restTopReq.includeAttributes(req.includeAttributes());\n\n            if (req.nodeId() != null) {\n                restTopReq.command(NODE);\n\n                restTopReq.nodeId(req.nodeId());\n            }\n            else if (req.nodeIp() != null) {\n                restTopReq.command(NODE);\n\n                restTopReq.nodeIp(req.nodeIp());\n            }\n            else\n                restTopReq.command(TOPOLOGY);\n\n            restReq = restTopReq;\n        }\n        else if (msg instanceof GridClientLogRequest) {\n            GridClientLogRequest req = (GridClientLogRequest) msg;\n\n            GridRestLogRequest restLogReq = new GridRestLogRequest();\n\n            restLogReq.command(LOG);\n\n            restLogReq.path(req.path());\n            restLogReq.from(req.from());\n            restLogReq.to(req.to());\n\n            restReq = restLogReq;\n        }\n\n        if (restReq != null) {\n            restReq.destinationId(msg.destinationId());\n            restReq.clientId(msg.clientId());\n            restReq.sessionToken(msg.sessionToken());\n        }\n\n        restReq.address(ses.remoteAddress());\n\n        return restReq;\n    }","id":75530,"modified_method":"/**\n     * Creates a REST request object from client TCP binary packet.\n     *\n     * @param ses NIO session.\n     * @param msg Request message.\n     * @return REST request object.\n     */\n    @Nullable private GridRestRequest createRestRequest(GridNioSession ses, GridClientMessage msg) {\n        GridRestRequest restReq = null;\n\n        if (msg instanceof GridClientAuthenticationRequest) {\n            GridClientAuthenticationRequest req = (GridClientAuthenticationRequest)msg;\n\n            restReq = new GridRestTaskRequest();\n\n            restReq.command(NOOP);\n\n            restReq.credentials(req.credentials());\n        }\n        else if (msg instanceof GridClientCacheRequest) {\n            GridClientCacheRequest req = (GridClientCacheRequest)msg;\n\n            GridRestCacheRequest restCacheReq = new GridRestCacheRequest();\n\n            restCacheReq.cacheName(req.cacheName());\n            restCacheReq.cacheFlags(req.cacheFlagsOn());\n\n            restCacheReq.key(req.key());\n            restCacheReq.value(req.value());\n            restCacheReq.value2(req.value2());\n\n            Map vals = req.values();\n            if (vals != null)\n                restCacheReq.values(new HashMap<Object, Object>(vals));\n\n            restCacheReq.command(cacheCmdMap.get(req.operation()));\n\n            restReq = restCacheReq;\n        }\n        else if (msg instanceof GridClientCacheQueryRequest) {\n            GridClientCacheQueryRequest req = (GridClientCacheQueryRequest) msg;\n\n            restReq = new GridRestCacheQueryRequest(req);\n\n            switch (req.operation()) {\n                case EXECUTE:\n                    restReq.command(CACHE_QUERY_EXECUTE);\n\n                    break;\n\n                case FETCH:\n                    restReq.command(CACHE_QUERY_FETCH);\n                    break;\n\n                case REBUILD_INDEXES:\n                    restReq.command(CACHE_QUERY_REBUILD_INDEXES);\n\n                    break;\n\n                default:\n                    throw new IllegalArgumentException(\"Unknown query operation: \" + req.operation());\n            }\n        }\n        else if (msg instanceof GridClientTaskRequest) {\n            GridClientTaskRequest req = (GridClientTaskRequest) msg;\n\n            GridRestTaskRequest restTaskReq = new GridRestTaskRequest();\n\n            restTaskReq.command(EXE);\n\n            restTaskReq.taskName(req.taskName());\n            restTaskReq.params(Arrays.asList(req.argument()));\n\n            restReq = restTaskReq;\n        }\n        else if (msg instanceof GridClientTopologyRequest) {\n            GridClientTopologyRequest req = (GridClientTopologyRequest) msg;\n\n            GridRestTopologyRequest restTopReq = new GridRestTopologyRequest();\n\n            restTopReq.includeMetrics(req.includeMetrics());\n            restTopReq.includeAttributes(req.includeAttributes());\n\n            if (req.nodeId() != null) {\n                restTopReq.command(NODE);\n\n                restTopReq.nodeId(req.nodeId());\n            }\n            else if (req.nodeIp() != null) {\n                restTopReq.command(NODE);\n\n                restTopReq.nodeIp(req.nodeIp());\n            }\n            else\n                restTopReq.command(TOPOLOGY);\n\n            restReq = restTopReq;\n        }\n        else if (msg instanceof GridClientLogRequest) {\n            GridClientLogRequest req = (GridClientLogRequest) msg;\n\n            GridRestLogRequest restLogReq = new GridRestLogRequest();\n\n            restLogReq.command(LOG);\n\n            restLogReq.path(req.path());\n            restLogReq.from(req.from());\n            restLogReq.to(req.to());\n\n            restReq = restLogReq;\n        }\n\n        if (restReq != null) {\n            restReq.destinationId(msg.destinationId());\n            restReq.clientId(msg.clientId());\n            restReq.sessionToken(msg.sessionToken());\n            restReq.address(ses.remoteAddress());\n        }\n\n        return restReq;\n    }","commit_id":"02078856a709bc636e66a529bbb6c659d044622c","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override public QueryCursor<List<?>> queryFields(SqlFieldsQuery qry) {\n        A.notNull(qry, \"qry\");\n\n        GridCacheProjectionImpl<K, V> prev = gate.enter(prj);\n\n        try {\n            validate(qry);\n\n            CacheQuery<List<?>> q = ((GridCacheQueriesEx<K,V>)delegate.queries()).createSqlFieldsQuery(qry.getSql(), false);\n\n            q.pageSize(qry.getPageSize());\n\n            CacheQueryFuture<List<?>> fut = q.execute(qry.getArgs());\n\n            return new QueryCursorImpl<>(new ClIter<List<?>, List<?>>(fut) {\n                @Override protected List<?> convert(List<?> row) {\n                    return row;\n                }\n            });\n        }\n        catch (Exception e) {\n            if (e instanceof CacheException)\n                throw e;\n\n            throw new CacheException(e);\n        }\n        finally {\n            gate.leave(prev);\n        }\n    }","id":75531,"modified_method":"/** {@inheritDoc} */\n    @Override public QueryCursor<List<?>> queryFields(SqlFieldsQuery qry) {\n        A.notNull(qry, \"qry\");\n\n        GridCacheProjectionImpl<K, V> prev = gate.enter(prj);\n\n        try {\n            validate(qry);\n\n            CacheQuery<List<?>> q = ((GridCacheQueriesEx<K,V>)delegate.queries()).createSqlFieldsQuery(qry.getSql(), false);\n\n            if (qry.getPageSize() > 0)\n                q.pageSize(qry.getPageSize());\n\n            CacheQueryFuture<List<?>> fut = q.execute(qry.getArgs());\n\n            return new QueryCursorImpl<>(new ClIter<List<?>, List<?>>(fut) {\n                @Override protected List<?> convert(List<?> row) {\n                    return row;\n                }\n            });\n        }\n        catch (Exception e) {\n            if (e instanceof CacheException)\n                throw e;\n\n            throw new CacheException(e);\n        }\n        finally {\n            gate.leave(prev);\n        }\n    }","commit_id":"2e834e6bcfa256ecaf988fed343b433976d75def","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @param filter Filter.\n     * @param grp Optional cluster group.\n     * @return Cursor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    private QueryCursor<Entry<K,V>> doQuery(Query filter, @Nullable ClusterGroup grp) {\n        final CacheQuery<Map.Entry<K,V>> qry;\n        final CacheQueryFuture<Map.Entry<K,V>> fut;\n\n        if (filter instanceof ScanQuery) {\n            IgniteBiPredicate<K,V> p = ((ScanQuery)filter).getFilter();\n\n            qry = delegate.queries().createScanQuery(p != null ? p : acceptAll());\n\n            if (grp != null)\n                qry.projection(grp);\n\n            fut = qry.execute();\n        }\n        else if (filter instanceof TextQuery) {\n            TextQuery p = (TextQuery)filter;\n\n            qry = delegate.queries().createFullTextQuery(p.getType(), p.getText());\n\n            if (grp != null)\n                qry.projection(grp);\n\n            fut = qry.execute();\n        }\n        else if (filter instanceof SpiQuery) {\n            qry = ((GridCacheQueriesEx)delegate.queries()).createSpiQuery();\n\n            if (grp != null)\n                qry.projection(grp);\n\n            fut = qry.execute(((SpiQuery)filter).getArgs());\n        }\n        else if (filter instanceof SqlQuery) {\n            SqlQuery q = (SqlQuery)filter;\n\n            qry = ((GridCacheQueriesEx)delegate.queries()).createSqlQuery(q.getType(), q.getSql());\n\n            if (grp != null)\n                qry.projection(grp);\n\n            qry.pageSize(q.getPageSize());\n\n            qry.enableDedup(false);\n            qry.includeBackups(false);\n\n            fut = qry.execute(q.getArgs());\n        }\n        else\n            throw new IgniteException(\"Unsupported query predicate: \" + filter);\n\n        return new QueryCursorImpl<>(new ClIter<Map.Entry<K,V>,Cache.Entry<K,V>>(fut) {\n            @Override protected Cache.Entry<K,V> convert(Map.Entry<K,V> e) {\n                return new CacheEntryImpl<>(e.getKey(), e.getValue());\n            }\n        });\n    }","id":75532,"modified_method":"/**\n     * @param filter Filter.\n     * @param grp Optional cluster group.\n     * @return Cursor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    private QueryCursor<Entry<K,V>> doQuery(Query filter, @Nullable ClusterGroup grp) {\n        final CacheQuery<Map.Entry<K,V>> qry;\n        final CacheQueryFuture<Map.Entry<K,V>> fut;\n\n        if (filter instanceof ScanQuery) {\n            IgniteBiPredicate<K,V> p = ((ScanQuery)filter).getFilter();\n\n            qry = delegate.queries().createScanQuery(p != null ? p : acceptAll());\n\n            if (grp != null)\n                qry.projection(grp);\n\n            fut = qry.execute();\n        }\n        else if (filter instanceof TextQuery) {\n            TextQuery p = (TextQuery)filter;\n\n            qry = delegate.queries().createFullTextQuery(p.getType(), p.getText());\n\n            if (grp != null)\n                qry.projection(grp);\n\n            fut = qry.execute();\n        }\n        else if (filter instanceof SpiQuery) {\n            qry = ((GridCacheQueriesEx)delegate.queries()).createSpiQuery();\n\n            if (grp != null)\n                qry.projection(grp);\n\n            fut = qry.execute(((SpiQuery)filter).getArgs());\n        }\n        else if (filter instanceof SqlQuery) {\n            SqlQuery q = (SqlQuery)filter;\n\n            qry = ((GridCacheQueriesEx)delegate.queries()).createSqlQuery(q.getType(), q.getSql());\n\n            if (grp != null)\n                qry.projection(grp);\n\n            if (q.getPageSize() > 0)\n                qry.pageSize(q.getPageSize());\n\n            qry.enableDedup(false);\n            qry.includeBackups(false);\n\n            fut = qry.execute(q.getArgs());\n        }\n        else\n            throw new IgniteException(\"Unsupported query predicate: \" + filter);\n\n        return new QueryCursorImpl<>(new ClIter<Map.Entry<K,V>,Cache.Entry<K,V>>(fut) {\n            @Override protected Cache.Entry<K,V> convert(Map.Entry<K,V> e) {\n                return new CacheEntryImpl<>(e.getKey(), e.getValue());\n            }\n        });\n    }","commit_id":"2e834e6bcfa256ecaf988fed343b433976d75def","url":"https://github.com/apache/ignite"},{"original_method":"public ExpressionEvaluator build(final TextWithImports text, final PsiElement contextElement) throws EvaluateException {\n    if (contextElement == null) {\n      throw EvaluateExceptionUtil.CANNOT_FIND_SOURCE_CLASS;\n    }\n\n    final Project project = contextElement.getProject();\n\n    PsiCodeFragment codeFragment = DefaultCodeFragmentFactory.getInstance().createCodeFragment(text, contextElement, project);\n    DebuggerUtils.checkSyntax(codeFragment);\n\n    if(codeFragment == null) {\n      throw EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.invalid.expression\", text.getText()));\n    }\n\n    return build(codeFragment);\n  }","id":75533,"modified_method":"public ExpressionEvaluator build(final TextWithImports text, final PsiElement contextElement) throws EvaluateException {\n    if (contextElement == null) {\n      throw EvaluateExceptionUtil.CANNOT_FIND_SOURCE_CLASS;\n    }\n\n    final Project project = contextElement.getProject();\n\n    PsiCodeFragment codeFragment = DefaultCodeFragmentFactory.getInstance().createCodeFragment(text, contextElement, project);\n    if(codeFragment == null) {\n      throw EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.invalid.expression\", text.getText()));\n    }\n    codeFragment.forceResolveScope(GlobalSearchScope.allScope(project));\n    DebuggerUtils.checkSyntax(codeFragment);\n\n    return build(codeFragment);\n  }","commit_id":"89bfb20ccc0a34033cb5e97598f87c287a66cd34","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected PsiCodeFragment getEvaluationCode(final StackFrameContext context) throws EvaluateException {\n    Value value = myParentDescriptor.getValue();\n\n    if(value instanceof ObjectReference) {\n      final String typeName = value.type().name();\n\n      final PsiClass psiClass = DebuggerUtilsEx.findClass(myTypeName, myProject, ((DebugProcessImpl)context.getDebugProcess()).getSession().getSearchScope());\n\n      if (psiClass == null) {\n        throw EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.invalid.type.name\", typeName));\n      }\n\n      return getEffectiveCodeFragmentFactory(psiClass).createCodeFragment(getEvaluationText(), psiClass, myProject);\n    }\n    else {\n      throw EvaluateExceptionUtil.createEvaluateException(\n        DebuggerBundle.message(\"evaluation.error.objref.expected\", myParentDescriptor.getName())\n      );\n    }\n  }","id":75534,"modified_method":"protected PsiCodeFragment getEvaluationCode(final StackFrameContext context) throws EvaluateException {\n    Value value = myParentDescriptor.getValue();\n\n    if(value instanceof ObjectReference) {\n      final String typeName = value.type().name();\n\n      final PsiClass psiClass = DebuggerUtilsEx.findClass(myTypeName, myProject, ((DebugProcessImpl)context.getDebugProcess()).getSession().getSearchScope());\n\n      if (psiClass == null) {\n        throw EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.invalid.type.name\", typeName));\n      }\n\n      final PsiCodeFragment fragment =\n        getEffectiveCodeFragmentFactory(psiClass).createCodeFragment(getEvaluationText(), psiClass, myProject);\n      fragment.forceResolveScope(GlobalSearchScope.allScope(myProject));\n      return fragment;\n    }\n    else {\n      throw EvaluateExceptionUtil.createEvaluateException(\n        DebuggerBundle.message(\"evaluation.error.objref.expected\", myParentDescriptor.getName())\n      );\n    }\n  }","commit_id":"89bfb20ccc0a34033cb5e97598f87c287a66cd34","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected PsiCodeFragment getEvaluationCode(StackFrameContext context) throws EvaluateException {\n    final PsiElement psiContext = PositionUtil.getContextElement(context);\n    return getEffectiveCodeFragmentFactory(psiContext).createCodeFragment(getEvaluationText(), psiContext, myProject);\n  }","id":75535,"modified_method":"protected PsiCodeFragment getEvaluationCode(StackFrameContext context) throws EvaluateException {\n    final PsiElement psiContext = PositionUtil.getContextElement(context);\n    final PsiCodeFragment fragment =\n      getEffectiveCodeFragmentFactory(psiContext).createCodeFragment(getEvaluationText(), psiContext, myProject);\n    fragment.forceResolveScope(GlobalSearchScope.allScope(myProject));\n    return fragment;\n  }","commit_id":"89bfb20ccc0a34033cb5e97598f87c287a66cd34","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected PsiCodeFragment getEvaluationCode(final StackFrameContext context) throws EvaluateException {\n    Pair<PsiClass, PsiType> psiClassAndType = DebuggerUtilsImpl.getPsiClassAndType(myTypeName, myProject);\n    if (psiClassAndType.first == null) {\n      throw EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.invalid.type.name\", myTypeName));\n    }\n    return createCodeFragment(psiClassAndType.first);\n  }","id":75536,"modified_method":"protected PsiCodeFragment getEvaluationCode(final StackFrameContext context) throws EvaluateException {\n    Pair<PsiClass, PsiType> psiClassAndType = DebuggerUtilsImpl.getPsiClassAndType(myTypeName, myProject);\n    if (psiClassAndType.first == null) {\n      throw EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.invalid.type.name\", myTypeName));\n    }\n    PsiCodeFragment fragment = createCodeFragment(psiClassAndType.first);\n    if (fragment instanceof JavaCodeFragment) {\n      ((JavaCodeFragment)fragment).setThisType(psiClassAndType.second);\n    }\n    return fragment;\n  }","commit_id":"fc41bc48619d1585f1d0c53110c03b29a258ccd3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Deployment\n    public static JavaArchive createDeployment() {\n        final JavaArchive archive = ShrinkWrap.create(JavaArchive.class, \"web-osgi-target\");\n        archive.addClasses(Echo.class, TargetBundleActivator.class);\n        archive.setManifest(new Asset() {\n            public InputStream openStream() {\n                OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();\n                builder.addBundleSymbolicName(archive.getName());\n                builder.addBundleManifestVersion(2);\n                builder.addBundleActivator(TargetBundleActivator.class);\n                // [TODO] remove these explicit imports\n                builder.addImportPackages(\"org.jboss.shrinkwrap.impl.base.path\");\n                builder.addImportPackages(BundleActivator.class, Logger.class, HttpServiceCapability.class);\n                return builder.openStream();\n            }\n        });\n        return archive;\n    }","id":75537,"modified_method":"@Deployment\n    public static JavaArchive createDeployment() {\n        final JavaArchive archive = ShrinkWrap.create(JavaArchive.class, \"web-osgi-target\");\n        archive.addClasses(OSGiTestSupport.class, Echo.class, TargetBundleActivator.class);\n        archive.setManifest(new Asset() {\n            public InputStream openStream() {\n                OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();\n                builder.addBundleSymbolicName(archive.getName());\n                builder.addBundleManifestVersion(2);\n                builder.addBundleActivator(TargetBundleActivator.class);\n                builder.addImportPackages(BundleActivator.class, Logger.class);\n                return builder.openStream();\n            }\n        });\n        return archive;\n    }","commit_id":"40a3567b6aba709464a9631bc0745e14e5ac5243","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static WebArchive getTestArchive(String name) {\n        final WebArchive archive = ShrinkWrap.create(WebArchive.class, name);\n        archive.addClass(SimpleClientServlet.class);\n        archive.addAsResource(\"osgi/webapp/webB.xml\", \"WEB-INF/web.xml\");\n        // [SHRINKWRAP-278] WebArchive.setManifest() results in WEB-INF/classes/META-INF/MANIFEST.MF\n        archive.add(new Asset() {\n            public InputStream openStream() {\n                OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();\n                builder.addManifestHeader(\"Dependencies\", \"org.osgi.core,deployment.web-osgi-target:0.0.0\");\n                return builder.openStream();\n            }\n        }, JarFile.MANIFEST_NAME);\n        return archive;\n    }","id":75538,"modified_method":"@Deployment(name = WAR_DEPLOYMENT_NAME, managed = false, testable = false)\n    public static WebArchive getTestArchive() {\n        final WebArchive archive = ShrinkWrap.create(WebArchive.class, WAR_DEPLOYMENT_NAME);\n        archive.addClass(SimpleClientServlet.class);\n        archive.addAsWebInfResource(\"osgi/webapp/webB.xml\", \"web.xml\");\n        // [SHRINKWRAP-278] WebArchive.setManifest() results in WEB-INF/classes/META-INF/MANIFEST.MF\n        archive.add(new Asset() {\n            public InputStream openStream() {\n                ManifestBuilder builder = ManifestBuilder.newInstance();\n                builder.addManifestHeader(\"Dependencies\", \"org.osgi.core,deployment.web-osgi-target:0.0.0\");\n                return builder.openStream();\n            }\n        }, JarFile.MANIFEST_NAME);\n        return archive;\n    }","commit_id":"40a3567b6aba709464a9631bc0745e14e5ac5243","url":"https://github.com/wildfly/wildfly"},{"original_method":"private String getHttpResponse(String message) throws IOException {\n        String reqPath = \"/web-osgi-client/servlet?msg=\" + message;\n        return HttpServiceCapability.getHttpResponse(\"localhost\", 8080, reqPath, 2000);\n    }","id":75539,"modified_method":"private String getHttpResponse(String message) throws IOException {\n        String reqPath = \"/web-osgi-client/servlet?msg=\" + message;\n        return getHttpResponse(\"localhost\", 8080, reqPath, 2000);\n    }","commit_id":"40a3567b6aba709464a9631bc0745e14e5ac5243","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testServiceAccess() throws Exception {\n        Archive<?> webArchive = null; //provider.getClientDeployment(\"web-osgi-client.war\");\n        String webName = deployer.deploy(webArchive);\n        try {\n            assertEquals(\"web-osgi-target\", getHttpResponse(BUNDLE_SYMBOLICNAME));\n            assertEquals(\"foo\", getHttpResponse(\"foo\"));\n        } finally {\n            deployer.undeploy(webName);\n        }\n    }","id":75540,"modified_method":"@Test\n    public void testServiceAccess() throws Exception {\n        deployer.deploy(WAR_DEPLOYMENT_NAME);\n        try {\n            assertEquals(\"web-osgi-target\", getHttpResponse(BUNDLE_SYMBOLICNAME));\n            assertEquals(\"foo\", getHttpResponse(\"foo\"));\n        } finally {\n            deployer.undeploy(WAR_DEPLOYMENT_NAME);\n        }\n    }","commit_id":"40a3567b6aba709464a9631bc0745e14e5ac5243","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Deployment\n    public static WebArchive createdeployment() {\n        final WebArchive archive = ShrinkWrap.create(WebArchive.class, \"example-webapp-negative\");\n        archive.addClasses(EndpointServlet.class);\n        archive.addAsResource(\"osgi/webapp/message.txt\", \"message.txt\");\n        // [SHRINKWRAP-278] WebArchive.setManifest() results in WEB-INF/classes/META-INF/MANIFEST.MF\n        archive.add(new Asset() {\n            public InputStream openStream() {\n                OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();\n                builder.addBundleSymbolicName(archive.getName());\n                builder.addBundleManifestVersion(2);\n                builder.addManifestHeader(Constants.BUNDLE_CLASSPATH, \".,WEB-INF/classes\");\n                builder.addManifestHeader(\"Web-ContextPath\", \"example-webapp\");\n                builder.addImportPackages(HttpServiceCapability.class, LifecycleInterceptorException.class);\n                builder.addImportPackages(HttpServlet.class, Servlet.class);\n                return builder.openStream();\n            }\n        }, JarFile.MANIFEST_NAME);\n        return archive;\n    }","id":75541,"modified_method":"@Deployment\n    @StartLevelAware(startLevel = 4)\n    public static WebArchive createdeployment() {\n        final WebArchive archive = ShrinkWrap.create(WebArchive.class, \"example-webapp-negative\");\n        archive.addClasses(OSGiTestSupport.class, EndpointServlet.class);\n        archive.addAsResource(\"osgi/webapp/message.txt\", \"message.txt\");\n        // [SHRINKWRAP-278] WebArchive.setManifest() results in WEB-INF/classes/META-INF/MANIFEST.MF\n        archive.add(new Asset() {\n            public InputStream openStream() {\n                OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();\n                builder.addBundleSymbolicName(archive.getName());\n                builder.addBundleManifestVersion(2);\n                builder.addManifestHeader(Constants.BUNDLE_CLASSPATH, \".,WEB-INF/classes\");\n                builder.addManifestHeader(\"Web-ContextPath\", \"example-webapp\");\n                builder.addImportPackages(LifecycleInterceptorException.class);\n                builder.addImportPackages(StartLevel.class, HttpServlet.class, Servlet.class);\n                return builder.openStream();\n            }\n        }, JarFile.MANIFEST_NAME);\n        return archive;\n    }","commit_id":"40a3567b6aba709464a9631bc0745e14e5ac5243","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testServletAccess() throws Exception {\n        try {\n            bundle.start();\n            fail(\"BundleException expected\");\n        } catch (BundleException ex) {\n            Throwable cause = ex.getCause();\n            assertTrue(cause instanceof LifecycleInterceptorException);\n        }\n    }","id":75542,"modified_method":"@Test\n    public void testServletAccess() throws Exception {\n        changeStartLevel(context, 4, 10, TimeUnit.SECONDS);\n        try {\n            bundle.start();\n            fail(\"BundleException expected\");\n        } catch (BundleException ex) {\n            Throwable cause = ex.getCause();\n            assertTrue(cause instanceof LifecycleInterceptorException);\n        }\n    }","commit_id":"40a3567b6aba709464a9631bc0745e14e5ac5243","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Deployment\n    public static WebArchive createdeployment() {\n        final WebArchive archive = ShrinkWrap.create(WebArchive.class, \"example-webapp\");\n        archive.addClasses(EndpointServlet.class);\n        archive.addAsResource(\"osgi/webapp/message.txt\", \"message.txt\");\n        archive.addAsResource(\"osgi/webapp/webA.xml\", \"WEB-INF/web.xml\");\n        // [SHRINKWRAP-278] WebArchive.setManifest() results in WEB-INF/classes/META-INF/MANIFEST.MF\n        archive.add(new Asset() {\n            public InputStream openStream() {\n                OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();\n                builder.addBundleSymbolicName(archive.getName());\n                builder.addBundleManifestVersion(2);\n                builder.addManifestHeader(Constants.BUNDLE_CLASSPATH, \".,WEB-INF/classes\");\n                builder.addManifestHeader(\"Web-ContextPath\", \"example-webapp\");\n                builder.addImportPackages(HttpServiceCapability.class);\n                builder.addImportPackages(HttpServlet.class, Servlet.class);\n                return builder.openStream();\n            }\n        }, JarFile.MANIFEST_NAME);\n        return archive;\n    }","id":75543,"modified_method":"@Deployment\n    @StartLevelAware(startLevel = 4)\n    public static WebArchive createdeployment() {\n        final WebArchive archive = ShrinkWrap.create(WebArchive.class, \"example-webapp\");\n        archive.addClasses(OSGiTestSupport.class, EndpointServlet.class);\n        archive.addAsResource(\"osgi/webapp/message.txt\", \"message.txt\");\n        archive.addAsWebInfResource(\"osgi/webapp/webA.xml\", \"web.xml\");\n        // [SHRINKWRAP-278] WebArchive.setManifest() results in WEB-INF/classes/META-INF/MANIFEST.MF\n        archive.add(new Asset() {\n            public InputStream openStream() {\n                OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();\n                builder.addBundleSymbolicName(archive.getName());\n                builder.addBundleManifestVersion(2);\n                builder.addManifestHeader(Constants.BUNDLE_CLASSPATH, \".,WEB-INF/classes\");\n                builder.addManifestHeader(\"Web-ContextPath\", \"example-webapp\");\n                builder.addImportPackages(StartLevel.class, HttpServlet.class, Servlet.class);\n                return builder.openStream();\n            }\n        }, JarFile.MANIFEST_NAME);\n        return archive;\n    }","commit_id":"40a3567b6aba709464a9631bc0745e14e5ac5243","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testServletAccess() throws Exception {\n        bundle.start();\n        String line = getHttpResponse(\"/example-webapp/servlet?test=plain\", 5000);\n        assertEquals(\"Hello from Servlet\", line);\n    }","id":75544,"modified_method":"@Test\n    public void testServletAccess() throws Exception {\n\n        changeStartLevel(context, 4, 10, TimeUnit.SECONDS);\n\n        bundle.start();\n        String line = getHttpResponse(\"/example-webapp/servlet?test=plain\", 5000);\n        assertEquals(\"Hello from Servlet\", line);\n    }","commit_id":"40a3567b6aba709464a9631bc0745e14e5ac5243","url":"https://github.com/wildfly/wildfly"},{"original_method":"private String getHttpResponse(String reqPath, int timeout) throws IOException {\n        return HttpServiceCapability.getHttpResponse(\"localhost\", DEFAULT_HTTP_SERVICE_PORT, reqPath, timeout);\n    }","id":75545,"modified_method":"private String getHttpResponse(String reqPath, int timeout) throws IOException {\n        return getHttpResponse(\"localhost\", DEFAULT_HTTP_SERVICE_PORT, reqPath, timeout);\n    }","commit_id":"40a3567b6aba709464a9631bc0745e14e5ac5243","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testServletAccess() throws Exception {\n        Archive<?> procArchive = null; //provider.getClientDeployment(\"interceptor-processor\");\n        String procName = deployer.deploy(procArchive);\n        try {\n            Archive<?> httpArchive = null; //provider.getClientDeployment(\"interceptor-endpoint\");\n            String httpName = deployer.deploy(httpArchive);\n            try {\n                String line = getHttpResponse(\"/servlet\", 5000);\n                assertEquals(\"Hello from Servlet\", line);\n            }\n            finally {\n                deployer.undeploy(httpName);\n            }\n        }\n        finally {\n            deployer.undeploy(procName);\n        }\n    }","id":75546,"modified_method":"@Test\n    public void testServletAccess() throws Exception {\n\n        changeStartLevel(context, 3, 10, TimeUnit.SECONDS);\n\n        deployer.deploy(PROCESSOR_NAME);\n        try {\n            deployer.deploy(ENDPOINT_NAME);\n            try {\n                String line = getHttpResponse(\"/servlet\", 5000);\n                assertEquals(\"Hello from Servlet\", line);\n            } finally {\n                deployer.undeploy(ENDPOINT_NAME);\n            }\n        } finally {\n            deployer.undeploy(PROCESSOR_NAME);\n        }\n    }","commit_id":"86f1e716b5e21216c1bb2becf5da17aa27ddbc4f","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Deployment\n    public static JavaArchive createdeployment() {\n        final JavaArchive archive = ShrinkWrap.create(JavaArchive.class, \"example-interceptor\");\n        archive.setManifest(new Asset() {\n            public InputStream openStream() {\n                OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();\n                builder.addBundleSymbolicName(archive.getName());\n                builder.addBundleManifestVersion(2);\n                // [TODO] remove these explicit imports\n                builder.addImportPackages(\"org.jboss.shrinkwrap.impl.base.path\");\n                builder.addImportPackages(HttpServiceCapability.class);\n                return builder.openStream();\n            }\n        });\n        return archive;\n    }","id":75547,"modified_method":"@Deployment\n    @StartLevelAware(startLevel = 3)\n    public static JavaArchive createdeployment() {\n        final JavaArchive archive = ShrinkWrap.create(JavaArchive.class, \"example-interceptor\");\n        archive.addClass(OSGiTestSupport.class);\n        archive.setManifest(new Asset() {\n            public InputStream openStream() {\n                OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();\n                builder.addBundleSymbolicName(archive.getName());\n                builder.addBundleManifestVersion(2);\n                builder.addImportPackages(StartLevel.class, HttpServiceCapability.class);\n                return builder.openStream();\n            }\n        });\n        return archive;\n    }","commit_id":"86f1e716b5e21216c1bb2becf5da17aa27ddbc4f","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testBundleDeployment() throws Exception {\n\n        InputStream input = deployer.getDeployment(BUNDLE_DEPLOYMENT);\n        Bundle bundle = context.installBundle(\"test-bundle\", input);\n        try {\n            // Assert that the bundle is in state INSTALLED\n            OSGiTestHelper.assertBundleState(Bundle.INSTALLED, bundle.getState());\n\n            // Start the bundle\n            bundle.start();\n            OSGiTestHelper.assertBundleState(Bundle.ACTIVE, bundle.getState());\n\n            // Stop the bundle\n            bundle.stop();\n            OSGiTestHelper.assertBundleState(Bundle.RESOLVED, bundle.getState());\n        } finally {\n            bundle.uninstall();\n            OSGiTestHelper.assertBundleState(Bundle.UNINSTALLED, bundle.getState());\n        }\n    }","id":75548,"modified_method":"@Test\n    public void testBundleDeployment() throws Exception {\n\n        InputStream input = deployer.getDeployment(BUNDLE_DEPLOYMENT_NAME);\n        Bundle bundle = context.installBundle(\"test-bundle\", input);\n        try {\n            // Assert that the bundle is in state INSTALLED\n            OSGiTestHelper.assertBundleState(Bundle.INSTALLED, bundle.getState());\n\n            // Start the bundle\n            bundle.start();\n            OSGiTestHelper.assertBundleState(Bundle.ACTIVE, bundle.getState());\n\n            // Stop the bundle\n            bundle.stop();\n            OSGiTestHelper.assertBundleState(Bundle.RESOLVED, bundle.getState());\n        } finally {\n            bundle.uninstall();\n            OSGiTestHelper.assertBundleState(Bundle.UNINSTALLED, bundle.getState());\n        }\n    }","commit_id":"64011df1816a6f178554c8397e574c55a36c85ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Deployment(name = BUNDLE_DEPLOYMENT, managed = false, testable = false)\n    public static JavaArchive getTestArchive() {\n        final JavaArchive archive = ShrinkWrap.create(JavaArchive.class, BUNDLE_DEPLOYMENT);\n        archive.addClasses(SimpleActivator.class, SimpleService.class);\n        archive.setManifest(new Asset() {\n            public InputStream openStream() {\n                OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();\n                builder.addBundleSymbolicName(archive.getName());\n                builder.addBundleManifestVersion(2);\n                builder.addBundleActivator(SimpleActivator.class);\n                builder.addImportPackages(BundleActivator.class);\n                return builder.openStream();\n            }\n        });\n        return archive;\n    }","id":75549,"modified_method":"@Deployment(name = BUNDLE_DEPLOYMENT_NAME, managed = false, testable = false)\n    public static JavaArchive getTestArchive() {\n        final JavaArchive archive = ShrinkWrap.create(JavaArchive.class, BUNDLE_DEPLOYMENT_NAME);\n        archive.addClasses(SimpleActivator.class, SimpleService.class);\n        archive.setManifest(new Asset() {\n            public InputStream openStream() {\n                OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();\n                builder.addBundleSymbolicName(archive.getName());\n                builder.addBundleManifestVersion(2);\n                builder.addBundleActivator(SimpleActivator.class);\n                builder.addImportPackages(BundleActivator.class);\n                return builder.openStream();\n            }\n        });\n        return archive;\n    }","commit_id":"64011df1816a6f178554c8397e574c55a36c85ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Deployment(name = BUNDLE_DEPLOYMENT, managed = false, testable = false)\n    public static JavaArchive getTestArchive() {\n        final JavaArchive archive = ShrinkWrap.create(JavaArchive.class, BUNDLE_DEPLOYMENT);\n        archive.addClasses(SimpleActivator.class, SimpleService.class);\n        archive.setManifest(new Asset() {\n            public InputStream openStream() {\n                OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();\n                builder.addBundleSymbolicName(archive.getName());\n                builder.addBundleManifestVersion(2);\n                builder.addBundleActivator(SimpleActivator.class);\n                builder.addImportPackages(BundleActivator.class);\n                return builder.openStream();\n            }\n        });\n        return archive;\n    }","id":75550,"modified_method":"@Deployment(name = BUNDLE_DEPLOYMENT_NAME, managed = false, testable = false)\n    public static JavaArchive getTestArchive() {\n        final JavaArchive archive = ShrinkWrap.create(JavaArchive.class, BUNDLE_DEPLOYMENT_NAME);\n        archive.addClasses(SimpleActivator.class, SimpleService.class);\n        archive.setManifest(new Asset() {\n            public InputStream openStream() {\n                OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();\n                builder.addBundleSymbolicName(archive.getName());\n                builder.addBundleManifestVersion(2);\n                builder.addBundleActivator(SimpleActivator.class);\n                builder.addImportPackages(BundleActivator.class);\n                return builder.openStream();\n            }\n        });\n        return archive;\n    }","commit_id":"64011df1816a6f178554c8397e574c55a36c85ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testBundleDeployment() throws Exception {\n\n        deployer.deploy(BUNDLE_DEPLOYMENT);\n\n        // Find the deployed bundle\n        Bundle bundle = getDeployedBundle(context, BUNDLE_DEPLOYMENT, null);\n\n        // Start the bundle. Note, it may have started already\n        bundle.start();\n        OSGiTestHelper.assertBundleState(Bundle.ACTIVE, bundle.getState());\n\n        // Stop the bundle\n        bundle.stop();\n        OSGiTestHelper.assertBundleState(Bundle.RESOLVED, bundle.getState());\n\n        final CountDownLatch uninstallLatch = new CountDownLatch(1);\n        context.addBundleListener(new BundleListener() {\n            public void bundleChanged(BundleEvent event) {\n                if (event.getType() == BundleEvent.UNINSTALLED)\n                    uninstallLatch.countDown();\n            }\n        });\n\n        deployer.undeploy(BUNDLE_DEPLOYMENT);\n\n        if (uninstallLatch.await(1000, TimeUnit.MILLISECONDS) == false)\n            fail(\"UNINSTALLED event not received\");\n\n        OSGiTestHelper.assertBundleState(Bundle.UNINSTALLED, bundle.getState());\n    }","id":75551,"modified_method":"@Test\n    public void testBundleDeployment() throws Exception {\n\n        deployer.deploy(BUNDLE_DEPLOYMENT_NAME);\n\n        // Find the deployed bundle\n        Bundle bundle = getDeployedBundle(context, BUNDLE_DEPLOYMENT_NAME, null);\n\n        // Start the bundle. Note, it may have started already\n        bundle.start();\n        OSGiTestHelper.assertBundleState(Bundle.ACTIVE, bundle.getState());\n\n        // Stop the bundle\n        bundle.stop();\n        OSGiTestHelper.assertBundleState(Bundle.RESOLVED, bundle.getState());\n\n        final CountDownLatch uninstallLatch = new CountDownLatch(1);\n        context.addBundleListener(new BundleListener() {\n            public void bundleChanged(BundleEvent event) {\n                if (event.getType() == BundleEvent.UNINSTALLED)\n                    uninstallLatch.countDown();\n            }\n        });\n\n        deployer.undeploy(BUNDLE_DEPLOYMENT_NAME);\n\n        if (uninstallLatch.await(1000, TimeUnit.MILLISECONDS) == false)\n            fail(\"UNINSTALLED event not received\");\n\n        OSGiTestHelper.assertBundleState(Bundle.UNINSTALLED, bundle.getState());\n    }","commit_id":"64011df1816a6f178554c8397e574c55a36c85ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testStatelessBean() throws Exception {\n        Archive<?> ejbArchive = null; //provider.getClientDeployment(\"ejb3-osgi.jar\");\n        String ejbName = deployer.deploy(ejbArchive);\n        try {\n            String jndiname = \"java:global/ejb3-osgi/SimpleStatelessSessionBean!org.jboss.as.testsuite.integration.osgi.ejb3.SimpleStatelessSessionBean\";\n            Echo service = (Echo) new InitialContext().lookup(jndiname);\n            assertNotNull(\"StatelessBean not null\", service);\n            assertEquals(\"ejb3-osgi-target\", service.echo(BUNDLE_SYMBOLICNAME));\n            assertEquals(\"foo\", service.echo(\"foo\"));\n        } finally {\n            deployer.undeploy(ejbName);\n        }\n    }","id":75552,"modified_method":"@Test\n    public void testStatelessBean() throws Exception {\n        deployer.deploy(EJB3_DEPLOYMENT_NAME);\n        try {\n            String jndiname = \"java:global/ejb3-osgi/SimpleStatelessSessionBean!org.jboss.as.testsuite.integration.osgi.ejb3.SimpleStatelessSessionBean\";\n            Echo service = (Echo) new InitialContext().lookup(jndiname);\n            assertNotNull(\"StatelessBean not null\", service);\n            assertEquals(\"ejb3-osgi-target\", service.echo(BUNDLE_SYMBOLICNAME));\n            assertEquals(\"foo\", service.echo(\"foo\"));\n        } finally {\n            deployer.undeploy(EJB3_DEPLOYMENT_NAME);\n        }\n    }","commit_id":"64011df1816a6f178554c8397e574c55a36c85ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static JavaArchive getTestArchive(String name) {\n        final JavaArchive archive = ShrinkWrap.create(JavaArchive.class, name);\n        archive.addClass(SimpleStatelessSessionBean.class);\n        archive.setManifest(new Asset() {\n            public InputStream openStream() {\n                OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();\n                builder.addManifestHeader(\"Dependencies\", \"org.osgi.core,deployment.ejb3-osgi-target:0.0.0\");\n                return builder.openStream();\n            }\n        });\n        return archive;\n    }","id":75553,"modified_method":"@Deployment(name = EJB3_DEPLOYMENT_NAME, managed = false, testable = false)\n    public static JavaArchive getTestArchive() {\n        final JavaArchive archive = ShrinkWrap.create(JavaArchive.class, EJB3_DEPLOYMENT_NAME);\n        archive.addClass(SimpleStatelessSessionBean.class);\n        archive.setManifest(new Asset() {\n            public InputStream openStream() {\n                OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();\n                builder.addManifestHeader(\"Dependencies\", \"org.osgi.core,deployment.ejb3-osgi-target:0.0.0\");\n                return builder.openStream();\n            }\n        });\n        return archive;\n    }","commit_id":"64011df1816a6f178554c8397e574c55a36c85ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Deployment\n    public static JavaArchive createDeployment() {\n        final JavaArchive archive = ShrinkWrap.create(JavaArchive.class, \"ejb3-osgi-target\");\n        archive.addClasses(Echo.class, TargetBundleActivator.class);\n        archive.setManifest(new Asset() {\n            public InputStream openStream() {\n                OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();\n                builder.addBundleSymbolicName(archive.getName());\n                builder.addBundleManifestVersion(2);\n                builder.addBundleActivator(TargetBundleActivator.class);\n                // [TODO] remove these explicit imports\n                builder.addImportPackages(\"org.jboss.shrinkwrap.impl.base.path\");\n                builder.addImportPackages(BundleActivator.class, Logger.class);\n                return builder.openStream();\n            }\n        });\n        return archive;\n    }","id":75554,"modified_method":"@Deployment\n    public static JavaArchive createDeployment() {\n        final JavaArchive archive = ShrinkWrap.create(JavaArchive.class, \"ejb3-osgi-target\");\n        archive.addClasses(Echo.class, TargetBundleActivator.class);\n        archive.setManifest(new Asset() {\n            public InputStream openStream() {\n                OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();\n                builder.addBundleSymbolicName(archive.getName());\n                builder.addBundleManifestVersion(2);\n                builder.addBundleActivator(TargetBundleActivator.class);\n                builder.addImportPackages(BundleActivator.class, Logger.class);\n                return builder.openStream();\n            }\n        });\n        return archive;\n    }","commit_id":"64011df1816a6f178554c8397e574c55a36c85ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"private MeasureModel update(Measure measure) {\n    MeasureModel value = model(measure);\n    value.setId(measure.getId());\n\n    SqlSession session = mybatis.openSession();\n    try {\n      MeasureMapper mapper = session.getMapper(MeasureMapper.class);\n\n      mapper.update(value);\n\n      session.commit();\n    } finally {\n      MyBatis.closeQuietly(session);\n    }\n\n    return value;\n  }","id":75555,"modified_method":"private MeasureModel update(Measure measure) {\n    MeasureModel value = model(measure);\n    value.setId(measure.getId());\n\n    SqlSession session = mybatis.openSession();\n    try {\n      MeasureMapper mapper = session.getMapper(MeasureMapper.class);\n\n      mapper.update(value);\n      mapper.deleteData(value);\n      if (value.getMeasureData() != null) {\n        mapper.insertData(value);\n      }\n\n      session.commit();\n    } finally {\n      MyBatis.closeQuietly(session);\n    }\n\n    return value;\n  }","commit_id":"8ff07c056e873426723912c9484cdcb9f411d8d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@VisibleForTesting\n  static boolean isBestValueMeasure(Measure measure, Metric metric) {\n    return measure.getId() == null\n      && metric.isOptimizedBestValue() == Boolean.TRUE\n      && metric.getBestValue() != null\n      && (measure.getValue() == null || NumberUtils.compare(metric.getBestValue(), measure.getValue()) == 0)\n      && measure.getAlertStatus() == null\n      && measure.getDescription() == null\n      && measure.getTendency() == null\n      && measure.getUrl() == null\n      && !measure.hasData()\n      && (measure.getVariation1() == null || NumberUtils.compare(measure.getVariation1().doubleValue(), 0.0) == 0)\n      && (measure.getVariation2() == null || NumberUtils.compare(measure.getVariation2().doubleValue(), 0.0) == 0)\n      && (measure.getVariation3() == null || NumberUtils.compare(measure.getVariation3().doubleValue(), 0.0) == 0)\n      && (measure.getVariation4() == null || NumberUtils.compare(measure.getVariation4().doubleValue(), 0.0) == 0)\n      && (measure.getVariation5() == null || NumberUtils.compare(measure.getVariation5().doubleValue(), 0.0) == 0);\n  }","id":75556,"modified_method":"@VisibleForTesting\n  static boolean isBestValueMeasure(Measure measure, Metric metric) {\n    return measure.getId() == null\n      && metric.isOptimizedBestValue() == Boolean.TRUE\n      && metric.getBestValue() != null\n      && (measure.getValue() == null || NumberUtils.compare(metric.getBestValue(), measure.getValue()) == 0)\n      && measure.getAlertStatus() == null\n      && measure.getDescription() == null\n      && measure.getTendency() == null\n      && measure.getUrl() == null\n      && !measure.hasData()\n      && isZeroVariation(measure.getVariation1())\n      && isZeroVariation(measure.getVariation2())\n      && isZeroVariation(measure.getVariation3())\n      && isZeroVariation(measure.getVariation4())\n      && isZeroVariation(measure.getVariation5());\n  }","commit_id":"8ff07c056e873426723912c9484cdcb9f411d8d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldUpdateMeasure() {\n    setupData(\"data\");\n\n    Measure measure = new Measure(coverage()).setValue(12.5).setId(1L);\n    measurePersister.saveMeasure(project, measure);\n\n    checkTables(\"shouldUpdateMeasure\", \"project_measures\");\n  }","id":75557,"modified_method":"@Test\n  public void should_update_measure() {\n    setupData(\"data\");\n\n    measurePersister.saveMeasure(project, new Measure(coverage()).setValue(12.5).setId(1L));\n    measurePersister.saveMeasure(project, new Measure(coverage()).setData(SHORT).setId(2L));\n    measurePersister.saveMeasure(project, new Measure(coverage()).setData(LONG).setId(3L));\n\n    checkTables(\"shouldUpdateMeasure\", \"project_measures\");\n  }","commit_id":"8ff07c056e873426723912c9484cdcb9f411d8d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldAddDelayedMeasureSeveralTimes() {\n    setupData(\"empty\");\n\n    Measure measure = new Measure(ncloc());\n\n    measure.setValue(200.0);\n    measurePersister.setDelayedMode(true);\n    measurePersister.saveMeasure(project, measure);\n\n    measure.setValue(300.0);\n    measurePersister.saveMeasure(project, measure);\n    measurePersister.dump();\n\n    checkTables(\"shouldAddDelayedMeasureSeveralTimes\", \"project_measures\");\n  }","id":75558,"modified_method":"@Test\n  public void should_add_delayed_measure_several_times() {\n    setupData(\"empty\");\n\n    Measure measure = new Measure(ncloc());\n\n    measurePersister.setDelayedMode(true);\n    measurePersister.saveMeasure(project, measure.setValue(200.0));\n    measurePersister.saveMeasure(project, measure.setValue(300.0));\n    measurePersister.dump();\n\n    checkTables(\"shouldAddDelayedMeasureSeveralTimes\", \"project_measures\");\n  }","commit_id":"8ff07c056e873426723912c9484cdcb9f411d8d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldInsertRuleMeasure() {\n    setupData(\"empty\");\n\n    Rule rule = Rule.create(\"pmd\", \"key\");\n    when(ruleFinder.findByKey(\"pmd\", \"key\")).thenReturn(rule);\n\n    Measure measure = new RuleMeasure(ncloc(), rule, RulePriority.MAJOR, 1).setValue(1234.0);\n    measurePersister.saveMeasure(project, measure);\n\n    checkTables(\"shouldInsertRuleMeasure\", \"project_measures\");\n  }","id":75559,"modified_method":"@Test\n  public void should_insert_rule_measure() {\n    setupData(\"empty\");\n\n    Rule rule = Rule.create(\"pmd\", \"key\");\n    when(ruleFinder.findByKey(\"pmd\", \"key\")).thenReturn(rule);\n\n    Measure measure = new RuleMeasure(ncloc(), rule, RulePriority.MAJOR, 1).setValue(1234.0);\n    measurePersister.saveMeasure(project, measure);\n\n    checkTables(\"shouldInsertRuleMeasure\", \"project_measures\");\n  }","commit_id":"8ff07c056e873426723912c9484cdcb9f411d8d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldNotSaveBestValueMeasuresInDelayedMode() {\n    setupData(\"empty\");\n\n    measurePersister.setDelayedMode(true);\n    measurePersister.saveMeasure(aFile, new Measure(coverage()).setValue(100.0));\n\n    assertEmptyTables(\"project_measures\");\n\n    measurePersister.dump();\n\n    assertEmptyTables(\"project_measures\");\n  }","id":75560,"modified_method":"@Test\n  public void should_not_save_best_value_measures_in_delayed_mode() {\n    setupData(\"empty\");\n\n    measurePersister.setDelayedMode(true);\n    measurePersister.saveMeasure(aFile, new Measure(coverage()).setValue(100.0));\n\n    assertEmptyTables(\"project_measures\");\n\n    measurePersister.dump();\n\n    assertEmptyTables(\"project_measures\");\n  }","commit_id":"8ff07c056e873426723912c9484cdcb9f411d8d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldNotSaveBestValues() {\n    assertThat(MeasurePersister.shouldPersistMeasure(aFile, new Measure(coverage()).setValue(0.0))).isTrue();\n    assertThat(MeasurePersister.shouldPersistMeasure(aFile, new Measure(coverage()).setValue(75.8))).isTrue();\n    assertThat(MeasurePersister.shouldPersistMeasure(aFile, new Measure(coverage()).setValue(100.0))).isFalse();\n  }","id":75561,"modified_method":"@Test\n  public void should_not_save_best_values() {\n    setupData(\"empty\");\n\n    measurePersister.saveMeasure(aFile, new Measure(coverage()).setValue(100.0));\n\n    assertEmptyTables(\"project_measures\");\n  }","commit_id":"8ff07c056e873426723912c9484cdcb9f411d8d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldInsertMeasure() {\n    setupData(\"empty\");\n\n    Measure measure = new Measure(ncloc()).setValue(1234.0);\n    measurePersister.saveMeasure(project, measure);\n\n    checkTables(\"shouldInsertMeasure\", \"project_measures\");\n    verify(memoryOptimizer).evictDataMeasure(eq(measure), any(MeasureModel.class));\n  }","id":75562,"modified_method":"@Test\n  public void should_insert_measure() {\n    setupData(\"empty\");\n\n    Measure measure = new Measure(ncloc()).setValue(1234.0);\n    measurePersister.saveMeasure(project, measure);\n\n    checkTables(\"shouldInsertMeasure\", \"project_measures\");\n    verify(memoryOptimizer).evictDataMeasure(eq(measure), any(MeasureModel.class));\n  }","commit_id":"8ff07c056e873426723912c9484cdcb9f411d8d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Before\n  public void mockResourcePersister() {\n    when(resourcePersister.getSnapshotOrFail(project)).thenReturn(projectSnapshot);\n    when(resourcePersister.getSnapshot(project)).thenReturn(projectSnapshot);\n    when(resourcePersister.getSnapshot(aPackage)).thenReturn(packageSnapshot);\n\n    measurePersister = new MeasurePersister(getMyBatis(), resourcePersister, ruleFinder, memoryOptimizer);\n  }","id":75563,"modified_method":"@Before\n  public void mockResourcePersister() {\n    when(resourcePersister.getSnapshotOrFail(project)).thenReturn(projectSnapshot);\n    when(resourcePersister.getSnapshotOrFail(aPackage)).thenReturn(packageSnapshot);\n    when(resourcePersister.getSnapshot(project)).thenReturn(projectSnapshot);\n    when(resourcePersister.getSnapshot(aPackage)).thenReturn(packageSnapshot);\n\n    measurePersister = new MeasurePersister(getMyBatis(), resourcePersister, ruleFinder, memoryOptimizer);\n  }","commit_id":"8ff07c056e873426723912c9484cdcb9f411d8d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldNotSaveMemoryOnlyMeasures() {\n    Measure measure = new Measure(\"ncloc\").setPersistenceMode(PersistenceMode.MEMORY);\n\n    assertThat(MeasurePersister.shouldPersistMeasure(aPackage, measure)).isFalse();\n  }","id":75564,"modified_method":"@Test\n  public void should_not_save_memory_only_measures() {\n    setupData(\"empty\");\n\n    measurePersister.saveMeasure(aFile, new Measure(\"ncloc\").setPersistenceMode(PersistenceMode.MEMORY));\n\n    assertEmptyTables(\"project_measures\");\n  }","commit_id":"8ff07c056e873426723912c9484cdcb9f411d8d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldInsertMeasureWithTextData() {\n    setupData(\"empty\");\n\n    measurePersister.saveMeasure(project, new Measure(ncloc()).setData(\"SHORT\"));\n    measurePersister.saveMeasure(project, new Measure(ncloc()).setData(StringUtils.repeat(\"0123456789\", 10)));\n\n    checkTables(\"shouldInsertMeasureWithLargeData\", \"project_measures\", \"measure_data\");\n  }","id":75565,"modified_method":"@Test\n  public void should_insert_measure_with_text_data() {\n    setupData(\"empty\");\n\n    measurePersister.saveMeasure(project, new Measure(ncloc()).setData(SHORT));\n    measurePersister.saveMeasure(project, new Measure(ncloc()).setData(LONG));\n\n    checkTables(\"shouldInsertMeasureWithLargeData\", \"project_measures\", \"measure_data\");\n  }","commit_id":"8ff07c056e873426723912c9484cdcb9f411d8d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldDelaySaving() {\n    setupData(\"empty\");\n\n    measurePersister.setDelayedMode(true);\n    measurePersister.saveMeasure(project, new Measure(ncloc()).setValue(1234.0));\n    measurePersister.saveMeasure(aPackage, new Measure(ncloc()).setValue(50.0));\n\n    assertEmptyTables(\"project_measures\");\n\n    measurePersister.dump();\n    checkTables(\"shouldDelaySaving\", \"project_measures\");\n  }","id":75566,"modified_method":"@Test\n  public void should_delay_saving() {\n    setupData(\"empty\");\n\n    measurePersister.setDelayedMode(true);\n    measurePersister.saveMeasure(project, new Measure(ncloc()).setValue(1234.0).setData(SHORT));\n    measurePersister.saveMeasure(aPackage, new Measure(ncloc()).setValue(50.0).setData(LONG));\n\n    assertEmptyTables(\"project_measures\");\n\n    measurePersister.dump();\n    checkTables(\"shouldDelaySaving\", \"project_measures\");\n  }","commit_id":"8ff07c056e873426723912c9484cdcb9f411d8d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldNotDelaySavingWithDatabaseOnlyMeasure() {\n    setupData(\"empty\");\n\n    measurePersister.setDelayedMode(true);\n    measurePersister.saveMeasure(project, new Measure(ncloc()).setValue(1234.0).setPersistenceMode(PersistenceMode.DATABASE));\n    measurePersister.saveMeasure(aPackage, new Measure(ncloc()).setValue(50.0));\n\n    checkTables(\"shouldInsertMeasure\", \"project_measures\");\n  }","id":75567,"modified_method":"@Test\n  public void should_not_delay_saving_with_database_only_measure() {\n    setupData(\"empty\");\n\n    measurePersister.setDelayedMode(true);\n    measurePersister.saveMeasure(project, new Measure(ncloc()).setValue(1234.0).setPersistenceMode(PersistenceMode.DATABASE));\n    measurePersister.saveMeasure(aPackage, new Measure(ncloc()).setValue(50.0));\n\n    checkTables(\"shouldInsertMeasure\", \"project_measures\");\n  }","commit_id":"8ff07c056e873426723912c9484cdcb9f411d8d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void nullValueAndNullVariationsShouldBeConsideredAsBestValue() {\n    Measure measure = new Measure(CoreMetrics.NEW_VIOLATIONS_KEY);\n\n    assertThat(MeasurePersister.isBestValueMeasure(measure, CoreMetrics.NEW_VIOLATIONS)).isTrue();\n  }","id":75568,"modified_method":"@Test\n  public void null_value_and_null_variations_should_be_considered_as_best_value() {\n    assertThat(MeasurePersister.isBestValueMeasure(new Measure(CoreMetrics.NEW_VIOLATIONS_KEY).setVariation1(0.0), CoreMetrics.NEW_VIOLATIONS)).isTrue();\n    assertThat(MeasurePersister.isBestValueMeasure(new Measure(CoreMetrics.NEW_VIOLATIONS_KEY).setVariation1(1.0), CoreMetrics.NEW_VIOLATIONS)).isFalse();\n    assertThat(MeasurePersister.isBestValueMeasure(new Measure(CoreMetrics.NEW_VIOLATIONS_KEY).setVariation2(1.0), CoreMetrics.NEW_VIOLATIONS)).isFalse();\n    assertThat(MeasurePersister.isBestValueMeasure(new Measure(CoreMetrics.NEW_VIOLATIONS_KEY).setVariation3(1.0), CoreMetrics.NEW_VIOLATIONS)).isFalse();\n    assertThat(MeasurePersister.isBestValueMeasure(new Measure(CoreMetrics.NEW_VIOLATIONS_KEY).setVariation4(1.0), CoreMetrics.NEW_VIOLATIONS)).isFalse();\n    assertThat(MeasurePersister.isBestValueMeasure(new Measure(CoreMetrics.NEW_VIOLATIONS_KEY).setVariation5(1.0), CoreMetrics.NEW_VIOLATIONS)).isFalse();\n  }","commit_id":"8ff07c056e873426723912c9484cdcb9f411d8d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override public void readFrom(StreamInput in) throws IOException {\n        super.readFrom(in);\n        minScore = in.readFloat();\n        querySource = new byte[in.readVInt()];\n        in.readFully(querySource);\n        if (in.readBoolean()) {\n            queryParserName = in.readUTF();\n        }\n        int typesSize = in.readVInt();\n        if (typesSize > 0) {\n            types = new String[typesSize];\n            for (int i = 0; i < typesSize; i++) {\n                types[i] = in.readUTF();\n            }\n        }\n    }","id":75569,"modified_method":"@Override public void readFrom(StreamInput in) throws IOException {\n        super.readFrom(in);\n        minScore = in.readFloat();\n        querySourceLength = in.readVInt();\n        querySourceOffset = 0;\n        querySource = new byte[querySourceLength];\n        in.readFully(querySource);\n        if (in.readBoolean()) {\n            queryParserName = in.readUTF();\n        }\n        int typesSize = in.readVInt();\n        if (typesSize > 0) {\n            types = new String[typesSize];\n            for (int i = 0; i < typesSize; i++) {\n                types[i] = in.readUTF();\n            }\n        }\n    }","commit_id":"c7cb35395638b7e33fbc4dd73775ed2c9c17896d","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public void writeTo(StreamOutput out) throws IOException {\n        super.writeTo(out);\n        out.writeFloat(minScore);\n        out.writeVInt(querySource.length);\n        out.writeBytes(querySource);\n        if (queryParserName == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            out.writeUTF(queryParserName);\n        }\n        out.writeVInt(types.length);\n        for (String type : types) {\n            out.writeUTF(type);\n        }\n    }","id":75570,"modified_method":"@Override public void writeTo(StreamOutput out) throws IOException {\n        super.writeTo(out);\n        out.writeFloat(minScore);\n        out.writeVInt(querySourceLength);\n        out.writeBytes(querySource, querySourceOffset, querySourceLength);\n        if (queryParserName == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            out.writeUTF(queryParserName);\n        }\n        out.writeVInt(types.length);\n        for (String type : types) {\n            out.writeUTF(type);\n        }\n    }","commit_id":"c7cb35395638b7e33fbc4dd73775ed2c9c17896d","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public void readFrom(StreamInput in) throws IOException {\n            name = in.readUTF();\n            position = in.readVLong();\n            length = in.readVLong();\n            content = new byte[in.readVInt()];\n            in.readFully(content);\n        }","id":75571,"modified_method":"@Override public void readFrom(StreamInput in) throws IOException {\n            name = in.readUTF();\n            position = in.readVLong();\n            length = in.readVLong();\n            contentLength = in.readVInt();\n            content = new byte[contentLength];\n            in.readFully(content);\n        }","commit_id":"49f8501a5b995e5288f00aae840c872498541016","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public void messageReceived(FileChunk request, TransportChannel channel) throws Exception {\n            if (closed) {\n                throw new IndexShardClosedException(shardId);\n            }\n            IndexOutput indexOutput;\n            if (request.position == 0) {\n                // first request\n                indexOutput = openIndexOutputs.remove(request.name);\n                if (indexOutput != null) {\n                    try {\n                        indexOutput.close();\n                    } catch (IOException e) {\n                        // ignore\n                    }\n                }\n                indexOutput = store.directory().createOutput(request.name);\n                openIndexOutputs.put(request.name, indexOutput);\n            } else {\n                indexOutput = openIndexOutputs.get(request.name);\n            }\n            synchronized (indexOutput) {\n                try {\n                    indexOutput.writeBytes(request.content, request.content.length);\n                    if (indexOutput.getFilePointer() == request.length) {\n                        // we are done\n                        indexOutput.close();\n                        openIndexOutputs.remove(request.name);\n                    }\n                } catch (IOException e) {\n                    openIndexOutputs.remove(request.name);\n                    try {\n                        indexOutput.close();\n                    } catch (IOException e1) {\n                        // ignore\n                    }\n                }\n            }\n            channel.sendResponse(VoidStreamable.INSTANCE);\n        }","id":75572,"modified_method":"@Override public void messageReceived(FileChunk request, TransportChannel channel) throws Exception {\n            if (closed) {\n                throw new IndexShardClosedException(shardId);\n            }\n            IndexOutput indexOutput;\n            if (request.position == 0) {\n                // first request\n                indexOutput = openIndexOutputs.remove(request.name);\n                if (indexOutput != null) {\n                    try {\n                        indexOutput.close();\n                    } catch (IOException e) {\n                        // ignore\n                    }\n                }\n                indexOutput = store.directory().createOutput(request.name);\n                openIndexOutputs.put(request.name, indexOutput);\n            } else {\n                indexOutput = openIndexOutputs.get(request.name);\n            }\n            synchronized (indexOutput) {\n                try {\n                    indexOutput.writeBytes(request.content, request.contentLength);\n                    if (indexOutput.getFilePointer() == request.length) {\n                        // we are done\n                        indexOutput.close();\n                        openIndexOutputs.remove(request.name);\n                    }\n                } catch (IOException e) {\n                    openIndexOutputs.remove(request.name);\n                    try {\n                        indexOutput.close();\n                    } catch (IOException e1) {\n                        // ignore\n                    }\n                }\n            }\n            channel.sendResponse(VoidStreamable.INSTANCE);\n        }","commit_id":"49f8501a5b995e5288f00aae840c872498541016","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public boolean contains(IEntityGroup group, IGroupMember member) \n   throws GroupsException \n   {\n      GroupDefinition groupDef = (GroupDefinition)groupDefinitions.get(group.getLocalKey());\n      if (member.isGroup()) \n      {\n         String key = ((IEntityGroup)member).getLocalKey();\n         return groupDef.hasMember(key);\n      } \n      else \n      {\n         if (member.getEntityType() != IPERSON_CLASS) \n             { return false; }\n         IPerson person = null;\n         try {\n             IPersonAttributeDao pa = PersonDirectory.getPersonAttributeDao();\n             final IPersonAttributes personAttributes = pa.getPerson(member.getKey());\n\n             RestrictedPerson rp = PersonFactory.createRestrictedPerson();\n             rp.setAttributes(personAttributes.getAttributes());\n             \n             person = rp;\n         }\n         catch (Exception ex) { \n             log.error(\"Exception acquiring attributes for member \" + member + \" while checking if group \" + group + \" contains this member.\", ex);\n             return false; \n         }\n         return testRecursively(groupDef, person, member);\n      }\n   }","id":75573,"modified_method":"public boolean contains(IEntityGroup group, IGroupMember member) \n   throws GroupsException \n   {\n      GroupDefinition groupDef = (GroupDefinition)groupDefinitions.get(group.getLocalKey());\n      if (member.isGroup()) \n      {\n         String key = ((IEntityGroup)member).getLocalKey();\n         return groupDef.hasMember(key);\n      } \n      else \n      {\n         if (member.getEntityType() != IPERSON_CLASS) \n             { return false; }\n         IPerson person = null;\n         try {\n             IPersonAttributeDao pa = PersonDirectory.getPersonAttributeDao();\n             final IPersonAttributes personAttributes = pa.getPerson(member.getKey());\n\n             RestrictedPerson rp = PersonFactory.createRestrictedPerson();\n             if (personAttributes != null) {\n                 rp.setAttributes(personAttributes.getAttributes());\n             }\n             \n             person = rp;\n         }\n         catch (Exception ex) { \n             log.error(\"Exception acquiring attributes for member \" + member + \" while checking if group \" + group + \" contains this member.\", ex);\n             return false; \n         }\n         return testRecursively(groupDef, person, member);\n      }\n   }","commit_id":"8639d1a2268cc10901aec8ead2b36822ef4c95b7","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void setAttribute(String key, String value) {\n        m_attributes.put(key, value);\n    }","id":75574,"modified_method":"public void addAttribute(String key, String value) {\n        m_attributes.put(key, value);\n    }","commit_id":"e4b9929a6504d4b59235d1941010f625e71b2f4e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Parameterized.Parameters\n    public static Collection<Object[]> data() throws ParseException {\n        BusinessServiceDTO bs = new BusinessServiceDTO();\n        bs.setId(1L);\n        bs.setName(\"Web Servers\");\n        bs.setAttribute(\"dc\", \"RDU\");\n        bs.setLocation(new ResourceLocation(ApiVersion.Version2, \"business-services\", \"1\"));\n\n        IpServiceDTO ipService = new IpServiceDTO();\n        ipService.setId(\"1\");\n        ipService.setLocation(new ResourceLocation(ApiVersion.Version1, \"ifservices\", \"1\"));\n        bs.addIpService(ipService);\n\n        return Arrays.asList(new Object[][]{{\n            bs,\n            \"<business-service>\" +\n               \"<id>1<\/id>\" +\n               \"<name>Web Servers<\/name>\" +\n               \"<location>/api/v2/business-services/1<\/location>\" +\n               \"<attributes>\" +\n                 \"<attribute>\" +\n                   \"<key>dc<\/key>\" +\n                   \"<value>RDU<\/value>\" +\n                 \"<\/attribute>\" +\n               \"<\/attributes>\" +\n               \"<ip-services>\" +\n                   \"<ip-service>\" +\n                      \"<id>1<\/id>\" +\n                      \"<location>/rest/ifservices/1<\/location>\" +\n                   \"<\/ip-service>\" +\n               \"<\/ip-services>\" +\n            \"<\/business-service>\",\n            null\n        }});\n    }","id":75575,"modified_method":"@Parameterized.Parameters\n    public static Collection<Object[]> data() throws ParseException {\n        BusinessServiceDTO bs = new BusinessServiceDTO();\n        bs.setId(1L);\n        bs.setName(\"Web Servers\");\n        bs.addAttribute(\"dc\", \"RDU\");\n        bs.addReductionKey(\"myReductionKeyA\");\n        bs.addReductionKey(\"myReductionKeyB\");\n        bs.setLocation(new ResourceLocation(ApiVersion.Version2, \"business-services\", \"1\"));\n\n        IpServiceDTO ipService = new IpServiceDTO();\n        ipService.setId(\"1\");\n        ipService.setLocation(new ResourceLocation(ApiVersion.Version1, \"ifservices\", \"1\"));\n        bs.addIpService(ipService);\n\n        return Arrays.asList(new Object[][]{{\n            bs,\n            \"<business-service>\" +\n               \"<id>1<\/id>\" +\n               \"<name>Web Servers<\/name>\" +\n               \"<location>/api/v2/business-services/1<\/location>\" +\n               \"<attributes>\" +\n                 \"<attribute>\" +\n                   \"<key>dc<\/key>\" +\n                   \"<value>RDU<\/value>\" +\n                 \"<\/attribute>\" +\n               \"<\/attributes>\" +\n               \"<ip-services>\" +\n                   \"<ip-service>\" +\n                      \"<id>1<\/id>\" +\n                      \"<location>/rest/ifservices/1<\/location>\" +\n                   \"<\/ip-service>\" +\n               \"<\/ip-services>\" +\n               \"<reductionKeys>\" +\n                    \"<reductionKey>myReductionKeyB<\/reductionKey>\" +\n                    \"<reductionKey>myReductionKeyA<\/reductionKey>\" +\n               \"<\/reductionKeys>\" +\n            \"<\/business-service>\",\n            null\n        }});\n    }","commit_id":"e4b9929a6504d4b59235d1941010f625e71b2f4e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private BusinessService transform(BusinessServiceDTO dto) {\n        BusinessService service = new BusinessService();\n        service.setId(dto.getId());\n        service.setName(dto.getName());\n        service.setAttributes(new HashMap<>(dto.getAttributes()));\n        for (IpServiceDTO eachService : dto.getIpServices()) {\n            OnmsMonitoredService ipService = getIpService(Integer.valueOf(eachService.getId()));\n            service.addIpService(ipService);\n        }\n        return service;\n    }","id":75576,"modified_method":"private BusinessService transform(BusinessServiceDTO dto) {\n        BusinessService service = new BusinessService();\n        service.setId(dto.getId());\n        service.setName(dto.getName());\n        service.setAttributes(new HashMap<>(dto.getAttributes()));\n        service.setReductionKeys(new HashSet<>(dto.getReductionKeys()));\n        for (IpServiceDTO eachService : dto.getIpServices()) {\n            OnmsMonitoredService ipService = getIpService(Integer.valueOf(eachService.getId()));\n            service.addIpService(ipService);\n        }\n        return service;\n    }","commit_id":"e4b9929a6504d4b59235d1941010f625e71b2f4e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private BusinessServiceDTO transform(BusinessService service) {\n        BusinessServiceDTO dto = new BusinessServiceDTO();\n        dto.setId(service.getId());\n        dto.setName(service.getName());\n        dto.setAttributes(new HashMap<>(service.getAttributes()));\n        for (OnmsMonitoredService eachService : service.getIpServices()) {\n            IpServiceDTO ipServiceDTO = transform(eachService);\n            if (ipServiceDTO != null) {\n                dto.addIpService(ipServiceDTO);\n            }\n        }\n        return dto;\n    }","id":75577,"modified_method":"private BusinessServiceDTO transform(BusinessService service) {\n        BusinessServiceDTO dto = new BusinessServiceDTO();\n        dto.setId(service.getId());\n        dto.setName(service.getName());\n        if(service.getAttributes() != null) {\n            dto.setAttributes(new HashMap<>(service.getAttributes()));\n        } else {\n            dto.setAttributes(new HashMap<>());\n        }\n        if(service.getReductionKeys() != null) {\n            dto.setReductionKeys(new HashSet<>(service.getReductionKeys()));\n        } else {\n            dto.setReductionKeys(new HashSet<>());\n        }\n        for (OnmsMonitoredService eachService : service.getIpServices()) {\n            IpServiceDTO ipServiceDTO = transform(eachService);\n            if (ipServiceDTO != null) {\n                dto.addIpService(ipServiceDTO);\n            }\n        }\n        return dto;\n    }","commit_id":"e4b9929a6504d4b59235d1941010f625e71b2f4e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    @JUnitTemporaryDatabase\n    @Transactional\n    @SuppressWarnings(\"unchecked\")\n    public void canRetrieveBusinessServices() throws Exception {\n        // Add business services to the DB\n        BusinessService bs = new BusinessService();\n        bs.setName(\"Application Servers\");\n        Long id = m_businessServiceDao.save(bs);\n        m_businessServiceDao.flush();\n\n        // Retrieve the list of business services\n        String url = \"/business-services\";\n        JAXBContext context = JAXBContext.newInstance(BusinessServiceListDTO.class, BusinessServiceDTO.class);\n        List<BusinessServiceDTO> businessServices = getXmlObject(context, url, 200, JaxbListWrapper.class).getObjects();\n\n        // Verify\n        assertEquals(1, businessServices.size());\n        BusinessServiceDTO bsDTO = new BusinessServiceDTO();\n        bsDTO.setName(bs.getName());\n        bsDTO.setId(id);\n        assertEquals(bsDTO, businessServices.get(0));\n    }","id":75578,"modified_method":"@Test\n    @JUnitTemporaryDatabase\n    @Transactional\n    @SuppressWarnings(\"unchecked\")\n    public void canRetrieveBusinessServices() throws Exception {\n        // Add business services to the DB\n        BusinessService bs = new BusinessService();\n        bs.setName(\"Application Servers\");\n        String reductionKey = \"MyReductionKey\";\n        bs.addReductionKey(reductionKey);\n        Long id = m_businessServiceDao.save(bs);\n        m_businessServiceDao.flush();\n\n        // Retrieve the list of business services\n        String url = \"/business-services\";\n        JAXBContext context = JAXBContext.newInstance(BusinessServiceListDTO.class, BusinessServiceDTO.class);\n        List<BusinessServiceDTO> businessServices = getXmlObject(context, url, 200, JaxbListWrapper.class).getObjects();\n\n        // Verify\n        assertEquals(1, businessServices.size());\n        BusinessServiceDTO bsDTO = new BusinessServiceDTO();\n        bsDTO.setName(bs.getName());\n        bsDTO.setId(id);\n        assertEquals(bsDTO, businessServices.get(0));\n        assertTrue(\"canRetrieveReductionKey\", businessServices.get(0).getReductionKeys().contains(reductionKey));\n    }","commit_id":"e4b9929a6504d4b59235d1941010f625e71b2f4e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    @JUnitTemporaryDatabase\n    @Transactional\n    public void canCreateBusinessService() throws Exception {\n        final String businessServiceJson = \"{\" +\n                \"\\\"name\\\":\\\"some-name\\\",\" +\n                \"\\\"attributes\\\":{\\\"attribute\\\":[{\\\"key\\\":\\\"some-key\\\",\\\"value\\\":\\\"some-value\\\"}]}\" +\n                \"}\";\n        final String businessServiceXml = \"<business-service>\" +\n                \"    <name>some-name2<\/name>\" +\n                \"<\/business-service>\";\n        sendData(POST, MediaType.APPLICATION_JSON, \"/business-services\", businessServiceJson, 201);\n        sendData(POST, MediaType.APPLICATION_XML, \"/business-services\", businessServiceXml, 201);\n        Assert.assertEquals(2, m_businessServiceDao.findAll().size());\n    }","id":75579,"modified_method":"@Test\n    @JUnitTemporaryDatabase\n    @Transactional\n    public void canCreateBusinessService() throws Exception {\n        final String businessServiceJson = \"{\" +\n                \"\\\"name\\\":\\\"some-name\\\",\" +\n                \"\\\"attributes\\\":{\\\"attribute\\\":[{\\\"key\\\":\\\"some-key\\\",\\\"value\\\":\\\"some-value\\\"}]},\" +\n                \"\\\"reductionKeys\\\": [\\n\" +\n                \"        \\\"key1\\\", \\\"key2\\\", \\\"key3\\\"\\n\" +\n                \"      ]\" +\n                \"}\";\n        final String businessServiceXml = \"<business-service>\" +\n                \"    <name>some-name2<\/name>\" +\n                \"    <reductionKeys>\" +\n                \"        <reductionKey>key1<\/reductionKey>\" +\n                \"        <reductionKey>key2<\/reductionKey>\" +\n                \"        <reductionKey>key3<\/reductionKey>\" +\n                \"    <\/reductionKeys>\" +\n                \"<\/business-service>\";\n        sendData(POST, MediaType.APPLICATION_JSON, \"/business-services\", businessServiceJson, 201);\n        sendData(POST, MediaType.APPLICATION_XML, \"/business-services\", businessServiceXml, 201);\n        Assert.assertEquals(2, m_businessServiceDao.findAll().size());\n        assertTrue(\"createBusinessServiceWithReductionKeys\", m_businessServiceDao.findAll().get(0).getReductionKeys().contains(\"key1\"));\n        assertTrue(\"createBusinessServiceWithReductionKeys\", m_businessServiceDao.findAll().get(0).getReductionKeys().contains(\"key2\"));\n        assertTrue(\"createBusinessServiceWithReductionKeys\", m_businessServiceDao.findAll().get(0).getReductionKeys().contains(\"key3\"));\n        assertEquals(\"createBusinessServiceWithReductionKeys\", 3, m_businessServiceDao.findAll().get(1).getReductionKeys().size());\n    }","commit_id":"e4b9929a6504d4b59235d1941010f625e71b2f4e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    @JUnitTemporaryDatabase\n    @Transactional\n    public void canUpdateBusinessService() throws Exception {\n        BusinessService service = new BusinessService();\n        service.setName(\"Dummy Service\");\n        final Long serviceId = m_businessServiceDao.save(service);\n        m_businessServiceDao.flush();\n        final String businessServiceDtoXml = \"<business-service>\" +\n                \"    <id>\" + serviceId + \"<\/id>\" +\n                \"    <name>Dummy Service Updated<\/name>\" +\n                \"<\/business-service>\";\n        sendData(PUT, MediaType.APPLICATION_XML, \"/business-services/\" + serviceId, businessServiceDtoXml, 204);\n    }","id":75580,"modified_method":"@Test\n    @JUnitTemporaryDatabase\n    @Transactional\n    public void canUpdateBusinessService() throws Exception {\n        BusinessService service = new BusinessService();\n        service.setName(\"Dummy Service\");\n        service.addReductionKey(\"key1\");\n        service.addReductionKey(\"key2-deleteMe\");\n        final Long serviceId = m_businessServiceDao.save(service);\n        m_businessServiceDao.flush();\n        final String businessServiceDtoXml = \"<business-service>\" +\n                \"    <id>\" + serviceId + \"<\/id>\" +\n                \"    <name>Dummy Service Updated<\/name>\" +\n                \"    <reductionKeys>\" +\n                \"        <reductionKey>key1updated<\/reductionKey>\" +\n                \"    <\/reductionKeys>\" +\n                \"<\/business-service>\";\n        sendData(PUT, MediaType.APPLICATION_XML, \"/business-services/\" + serviceId, businessServiceDtoXml, 204);\n        assertEquals(1, m_businessServiceDao.findAll().size());\n        assertEquals(\"Dummy Service Updated\", m_businessServiceDao.findAll().get(0).getName());\n        assertEquals(1, m_businessServiceDao.findAll().get(0).getReductionKeys().size());\n        assertTrue(m_businessServiceDao.findAll().get(0).getReductionKeys().contains(\"key1updated\"));\n    }","commit_id":"e4b9929a6504d4b59235d1941010f625e71b2f4e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private OnmsSeverity calculateCurrentSeverity(BusinessService businessService) {\n        OnmsSeverity maxSeverity = DEFAULT_SEVERITY;\n        for (OnmsMonitoredService ipService : businessService.getIpServices()) {\n            for (String reductionKey : ipService.getReductionKeys()) {\n                final OnmsSeverity ipServiceSeverity = m_reductionKeyToSeverity.get(reductionKey);\n                if (ipServiceSeverity != null && ipServiceSeverity.isGreaterThan(maxSeverity)) {\n                    maxSeverity = ipServiceSeverity;\n                }\n            }\n        }\n        return maxSeverity;\n    }","id":75581,"modified_method":"private OnmsSeverity calculateCurrentSeverity(BusinessService businessService) {\n        OnmsSeverity maxSeverity = DEFAULT_SEVERITY;\n        for (String reductionKey : businessService.getAllReductionKeys()) {\n            final OnmsSeverity ipServiceSeverity = m_reductionKeyToSeverity.get(reductionKey);\n            if (ipServiceSeverity != null && ipServiceSeverity.isGreaterThan(maxSeverity)) {\n                maxSeverity = ipServiceSeverity;\n            }\n        }\n        return maxSeverity;\n    }","commit_id":"e4b9929a6504d4b59235d1941010f625e71b2f4e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public void setBusinessServices(List<BusinessService> businessServices) {\n        Objects.requireNonNull(businessServices, \"businessServices cannot be null\");\n\n        m_rwLock.writeLock().lock();\n        try {\n            // Clear previous state\n            m_reductionKeys.clear();\n            m_businessServiceSeverity.clear();\n            m_reductionKeyToSeverity.clear();\n            m_ipServiceIds.clear();\n\n            // Rebuild\n            for (BusinessService businessService : businessServices) {\n                m_businessServiceSeverity.put(businessService, DEFAULT_SEVERITY);\n                for (OnmsMonitoredService ipService : businessService.getIpServices()) {\n                    m_ipServiceIds.add(ipService.getId());\n                    for (String reductionKey : ipService.getReductionKeys()) {\n                        addReductionKey(reductionKey, businessService);\n                    }\n                }\n            }\n        } finally {\n            m_rwLock.writeLock().unlock();\n        }\n    }","id":75582,"modified_method":"@Override\n    public void setBusinessServices(List<BusinessService> businessServices) {\n        Objects.requireNonNull(businessServices, \"businessServices cannot be null\");\n\n        m_rwLock.writeLock().lock();\n        try {\n            // Clear previous state\n            m_reductionKeys.clear();\n            m_businessServiceSeverity.clear();\n            m_reductionKeyToSeverity.clear();\n            m_ipServiceIds.clear();\n\n            // Rebuild\n            for (BusinessService businessService : businessServices) {\n                m_businessServiceSeverity.put(businessService, DEFAULT_SEVERITY);\n                for (String reductionKey : businessService.getAllReductionKeys()) {\n                    addReductionKey(reductionKey, businessService);\n                }\n            }\n        } finally {\n            m_rwLock.writeLock().unlock();\n        }\n    }","commit_id":"e4b9929a6504d4b59235d1941010f625e71b2f4e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\r\n     * Returns an <code>Iterator<\/code> over the <code>Collection<\/code> of\r\n     * <code>IEntityGroups<\/code> that the <code>IGroupMember<\/code> belongs to.\r\n     * @return java.util.Iterator\r\n     * @param gm org.jasig.portal.groups.IEntityGroup\r\n     */\r\n    public Iterator findContainingGroups(IGroupMember gm) throws GroupsException {\r\n    \t\r\n    \tif (!initialized) {\r\n    \t\tinit();\r\n    \t}\r\n\r\n    \tList<IEntityGroup> rslt = new LinkedList<IEntityGroup>();\r\n    \tif (gm.isGroup()) {\t\t// Check the local indeces...\r\n    \t\tIEntityGroup group = (IEntityGroup) gm;\r\n    \t\tList<String> list = parents.get(group.getLocalKey());\r\n    \t\tif (list != null) {\r\n    \t\t\t// should only reach this code if its a SmartLdap managed group...\r\n        \t\tfor (String s : list) {\r\n        \t\t\trslt.add(groups.get(s));\r\n        \t\t}\r\n    \t\t}\r\n    \t} else if (gm.isEntity()) {\t// Ask the individual...\r\n\r\n    \t\t// Build an IPerson...\r\n    \t\tEntityIdentifier ei = gm.getUnderlyingEntityIdentifier();\r\n    \t\tMap<String,List<Object>> seed = new HashMap<String,List<Object>>();\r\n    \t\tList<Object> seedValue = new LinkedList<Object>();\r\n    \t\tseedValue.add(ei.getKey());\r\n    \t\tseed.put(IPerson.USERNAME, seedValue);\r\n    \t\tMap<String,List<Object>> attr = PersonDirectory.getPersonAttributeDao().getMultivaluedUserAttributes(seed);\r\n    \t\tIPerson p = PersonFactory.createPerson();\r\n    \t\tp.setAttributes(attr);\r\n\r\n    \t\t// Analyze its memberships...\r\n    \t\tString attrName = (String) spring_context.getBean(\"memberOfAttributeName\");\r\n    \t\tObject groupKeys = p.getAttributeValues(attrName);\r\n    \t\t// IPerson returns null if no value is defined for this attribute...\r\n    \t\tif (groupKeys != null) {\r\n\r\n        \t\tList<String> list = new LinkedList<String>();\r\n        \t\tif (groupKeys instanceof String) {\r\n        \t\t\tlist.add((String) groupKeys);\r\n        \t\t} else if (groupKeys instanceof Object[]) {\r\n        \t\t\tObject[] objs = (Object[]) groupKeys;\r\n        \t\t\tfor (Object o : objs) {\r\n        \t\t\t\tlist.add((String) o);\r\n        \t\t\t}\r\n        \t\t} else if (groupKeys instanceof List) {\r\n        \t\t\tList<?> objs = (List<?>) groupKeys;\r\n        \t\t\tfor (Object o : objs) {\r\n        \t\t\t\tlist.add((String) o);\r\n        \t\t\t}\r\n        \t\t}\r\n\r\n    \t\t\tfor (String s : list) {\r\n    \t\t\t\tif (groups.containsKey(s)) {\r\n            \t\t\trslt.add(groups.get(s));\r\n    \t\t\t\t}\r\n        \t\t}\r\n    \t\t}\r\n    \t\t\r\n    \t} else {\r\n    \t\t// WTF...\r\n    \t    log.warn(\"The specified IGroupMember is neither a group nor an entity:  \" + gm.getKey());\r\n    \t}\r\n    \t\r\n    \treturn rslt.iterator();\r\n    \t\r\n    }","id":75583,"modified_method":"/**\r\n     * Returns an <code>Iterator<\/code> over the <code>Collection<\/code> of\r\n     * <code>IEntityGroups<\/code> that the <code>IGroupMember<\/code> belongs to.\r\n     * @return java.util.Iterator\r\n     * @param gm org.jasig.portal.groups.IEntityGroup\r\n     */\r\n    public Iterator findContainingGroups(IGroupMember gm) throws GroupsException {\r\n    \t\r\n    \tif (!initialized) {\r\n    \t\tinit();\r\n    \t}\r\n\r\n    \tList<IEntityGroup> rslt = new LinkedList<IEntityGroup>();\r\n    \tif (gm.isGroup()) {\t\t// Check the local indeces...\r\n    \t\tIEntityGroup group = (IEntityGroup) gm;\r\n    \t\tList<String> list = parents.get(group.getLocalKey());\r\n    \t\tif (list != null) {\r\n    \t\t\t// should only reach this code if its a SmartLdap managed group...\r\n        \t\tfor (String s : list) {\r\n        \t\t\trslt.add(groups.get(s));\r\n        \t\t}\r\n    \t\t}\r\n    \t} else if (gm.isEntity()) {\t// Ask the individual...\r\n\r\n    \t\t// Build an IPerson...\r\n    \t\tEntityIdentifier ei = gm.getUnderlyingEntityIdentifier();\r\n    \t\tMap<String,List<Object>> seed = new HashMap<String,List<Object>>();\r\n    \t\tList<Object> seedValue = new LinkedList<Object>();\r\n    \t\tseedValue.add(ei.getKey());\r\n    \t\tseed.put(IPerson.USERNAME, seedValue);\r\n    \t\tMap<String,List<Object>> attr = PersonDirectory.getPersonAttributeDao().getMultivaluedUserAttributes(seed);\r\n            // avoid NPEs and unnecessary IPerson creation\r\n            if (attr != null && !attr.isEmpty()) {\r\n\r\n    \t\tIPerson p = PersonFactory.createPerson();\r\n    \t\tp.setAttributes(attr);\r\n\r\n    \t\t// Analyze its memberships...\r\n    \t\tString attrName = (String) spring_context.getBean(\"memberOfAttributeName\");\r\n    \t\tObject groupKeys = p.getAttributeValues(attrName);\r\n    \t\t// IPerson returns null if no value is defined for this attribute...\r\n    \t\tif (groupKeys != null) {\r\n\r\n        \t\tList<String> list = new LinkedList<String>();\r\n        \t\tif (groupKeys instanceof String) {\r\n        \t\t\tlist.add((String) groupKeys);\r\n        \t\t} else if (groupKeys instanceof Object[]) {\r\n        \t\t\tObject[] objs = (Object[]) groupKeys;\r\n        \t\t\tfor (Object o : objs) {\r\n        \t\t\t\tlist.add((String) o);\r\n        \t\t\t}\r\n        \t\t} else if (groupKeys instanceof List) {\r\n        \t\t\tList<?> objs = (List<?>) groupKeys;\r\n        \t\t\tfor (Object o : objs) {\r\n        \t\t\t\tlist.add((String) o);\r\n        \t\t\t}\r\n        \t\t}\r\n\r\n    \t\t\tfor (String s : list) {\r\n    \t\t\t\tif (groups.containsKey(s)) {\r\n            \t\t\trslt.add(groups.get(s));\r\n    \t\t\t\t}\r\n        \t\t}\r\n    \t\t}\r\n            }\r\n    \t\t\r\n    \t} else {\r\n    \t\t// WTF...\r\n    \t    log.warn(\"The specified IGroupMember is neither a group nor an entity:  \" + gm.getKey());\r\n    \t}\r\n    \t\r\n    \treturn rslt.iterator();\r\n    \t\r\n    }","commit_id":"55819990f065aa966b4b6d1f0fe2f253ecd64cf7","url":"https://github.com/Jasig/uPortal"},{"original_method":"public EntityPersonAttributesGroupStore() {\n        super();\n        ApplicationContext applicationContext = ApplicationContextLocator.getApplicationContext();\n        this.personAttributesGroupDefinitionDao = applicationContext.getBean(\"personAttributesGroupDefinitionDao\", IPersonAttributesGroupDefinitionDao.class);\n        CacheManager cacheManager = applicationContext.getBean(\"cacheManager\", CacheManager.class);\n        this.groupDefCache = cacheManager.getCache(\"org.jasig.portal.groups.pags.dao.EntityPersonAttributesGroupStore\");\n    }","id":75584,"modified_method":"public EntityPersonAttributesGroupStore() {\n        super();\n        ApplicationContext applicationContext = ApplicationContextLocator.getApplicationContext();\n        this.personAttributesGroupDefinitionDao = applicationContext.getBean(\"personAttributesGroupDefinitionDao\", IPersonAttributesGroupDefinitionDao.class);\n        CacheManager cacheManager = applicationContext.getBean(\"cacheManager\", CacheManager.class);\n        this.groupDefCache = cacheManager.getCache(\"org.jasig.portal.groups.pags.dao.EntityPersonAttributesGroupStore\");\n        this.membershipCache = cacheManager.getCache(\"org.jasig.portal.groups.pags.dao.EntityPersonAttributesGroupStore.membership\");\n    }","commit_id":"f133d422a3c406bb75dc24c19fc7b7ce1803e00b","url":"https://github.com/Jasig/uPortal"},{"original_method":"public boolean contains(IEntityGroup group, IGroupMember member) {\n        logger.debug(\"Checking if group {} contains member {}/{}\", group.getName(), member.getKey(), member.getEntityType().getSimpleName());\n        PagsGroup groupDef = convertEntityToGroupDef(group);\n        if (member.isGroup())\n        {\n           String key = ((IEntityGroup)member).getLocalKey();\n           return groupDef.hasMember(key);\n        }\n        else\n        {\n           if (member.getEntityType() != IPERSON_CLASS)\n               { return false; }\n           IPerson person = null;\n           try {\n               IPersonAttributeDao pa = PersonAttributeDaoLocator.getPersonAttributeDao();\n               final IPersonAttributes personAttributes = pa.getPerson(member.getKey());\n\n               RestrictedPerson rp = PersonFactory.createRestrictedPerson();\n               if (personAttributes != null) {\n                   rp.setAttributes(personAttributes.getAttributes());\n               }\n\n               person = rp;\n           }\n           catch (Exception ex) {\n               logger.error(\"Exception acquiring attributes for member \" + member + \" while checking if group \" + group + \" contains this member.\", ex);\n               return false;\n           }\n           return testRecursively(groupDef, person, member);\n        }\n    }","id":75585,"modified_method":"public boolean contains(IEntityGroup group, IGroupMember member) {\n\n        final MembershipCacheKey cacheKey = new MembershipCacheKey(group.getEntityIdentifier(), member.getEntityIdentifier());\n        Element element = membershipCache.get(cacheKey);\n        if (element == null) {\n\n            logger.debug(\"Checking if group {} contains member {}/{}\", group.getName(), member.getKey(), member.getEntityType().getSimpleName());\n\n            boolean answer = false;  // default\n            final PagsGroup groupDef = convertEntityToGroupDef(group);\n            if (member.isGroup()) {\n               final String key = ((IEntityGroup) member).getLocalKey();\n               answer = groupDef.hasMember(key);\n            } else {\n               if (member.getEntityType() != IPERSON_CLASS) {\n                   answer = false;\n               } else {\n                   try {\n                       final IPersonAttributeDao pa = PersonAttributeDaoLocator.getPersonAttributeDao();\n                       final IPersonAttributes personAttributes = pa.getPerson(member.getKey());\n\n                       if (personAttributes != null) {\n                           final RestrictedPerson rp = PersonFactory.createRestrictedPerson();\n                           rp.setAttributes(personAttributes.getAttributes());\n                           answer = testRecursively(groupDef, rp, member);\n                       }\n                   } catch (Exception ex) {\n                       logger.error(\"Exception acquiring attributes for member \" + member + \" while checking if group \" + group + \" contains this member.\", ex);\n                       return false;\n                   }\n               }\n            }\n\n            element = new Element(cacheKey, answer);\n            membershipCache.put(element);\n\n        }\n\n        return (Boolean) element.getObjectValue();\n\n    }","commit_id":"f133d422a3c406bb75dc24c19fc7b7ce1803e00b","url":"https://github.com/Jasig/uPortal"},{"original_method":"private static void showPreviewFrame(@NotNull final Module module, @NotNull final VirtualFile formFile,\n                                       final DataContext dataContext, @Nullable final Locale stringDescriptorLocale) {\n    final String tempPath;\n    try {\n      final File tempDirectory = FileUtil.createTempDirectory(\"FormPreview\", \"\");\n      tempPath = tempDirectory.getAbsolutePath();\n\n      CopyResourcesUtil.copyFormsRuntime(tempPath, true);\n    }\n    catch (IOException e) {\n      Messages.showErrorDialog(\n        module.getProject(),\n        UIDesignerBundle.message(\"error.cannot.preview.form\", formFile.getPath().replace('/', File.separatorChar), e.toString()),\n        CommonBundle.getErrorTitle()\n      );\n      return;\n    }\n\n    final PathsList sources = OrderEnumerator.orderEntries(module).withoutSdk().withoutLibraries().withoutDepModules().getSourcePathsList();\n    final String classPath = OrderEnumerator.orderEntries(module).recursively().getPathsList().getPathsString() + File.pathSeparator +\n      sources.getPathsString() + File.pathSeparator + /* resources bundles */\n      tempPath;\n    final ClassLoader loader = Form2ByteCodeCompiler.createClassLoader(classPath);\n\n    final Document doc = FileDocumentManager.getInstance().getDocument(formFile);\n    final LwRootContainer rootContainer;\n    try {\n      rootContainer = Utils.getRootContainer(doc.getText(), new CompiledClassPropertiesProvider(loader));\n    }\n    catch (Exception e) {\n      Messages.showErrorDialog(\n        module.getProject(),\n        UIDesignerBundle.message(\"error.cannot.read.form\", formFile.getPath().replace('/', File.separatorChar), e.getMessage()),\n        CommonBundle.getErrorTitle()\n      );\n      return;\n    }\n\n    if (rootContainer.getComponentCount() == 0) {\n      Messages.showErrorDialog(\n        module.getProject(),\n        UIDesignerBundle.message(\"error.cannot.preview.empty.form\", formFile.getPath().replace('/', File.separatorChar)),\n        CommonBundle.getErrorTitle()\n      );\n      return;\n    }\n\n    setPreviewBindings(rootContainer, CLASS_TO_BIND_NAME);\n\n    // 2. Copy previewer class and all its superclasses into TEMP directory and instrument it.\n    try {\n      PreviewNestedFormLoader nestedFormLoader = new PreviewNestedFormLoader(module, tempPath, loader);\n\n      final File tempFile = CopyResourcesUtil.copyClass(tempPath, CLASS_TO_BIND_NAME, true);\n      //CopyResourcesUtil.copyClass(tempPath, CLASS_TO_BIND_NAME + \"$1\", true);\n      CopyResourcesUtil.copyClass(tempPath, CLASS_TO_BIND_NAME + \"$MyExitAction\", true);\n      CopyResourcesUtil.copyClass(tempPath, CLASS_TO_BIND_NAME + \"$MyPackAction\", true);\n      CopyResourcesUtil.copyClass(tempPath, CLASS_TO_BIND_NAME + \"$MySetLafAction\", true);\n\n      Locale locale = Locale.getDefault();\n      if (locale.getCountry().length() > 0 && locale.getLanguage().length() > 0) {\n        CopyResourcesUtil.copyProperties(tempPath, RUNTIME_BUNDLE_PREFIX + \"_\" + locale.getLanguage() +\n                                                   \"_\" + locale.getCountry() + PropertiesFileType.DOT_DEFAULT_EXTENSION);\n      }\n      if (locale.getLanguage().length() > 0) {\n        CopyResourcesUtil.copyProperties(tempPath, RUNTIME_BUNDLE_PREFIX + \"_\" + locale.getLanguage() + PropertiesFileType.DOT_DEFAULT_EXTENSION);\n      }\n      CopyResourcesUtil.copyProperties(tempPath, RUNTIME_BUNDLE_PREFIX + \"_\" + locale.getLanguage() + PropertiesFileType.DOT_DEFAULT_EXTENSION);\n      CopyResourcesUtil.copyProperties(tempPath, RUNTIME_BUNDLE_PREFIX + PropertiesFileType.DOT_DEFAULT_EXTENSION);\n\n      final AsmCodeGenerator codeGenerator = new AsmCodeGenerator(rootContainer, loader, nestedFormLoader, true,\n                                                                  new PsiClassWriter(module));\n      codeGenerator.patchFile(tempFile);\n      final FormErrorInfo[] errors = codeGenerator.getErrors();\n      if(errors.length != 0){\n        Messages.showErrorDialog(\n          module.getProject(),\n          UIDesignerBundle.message(\"error.cannot.preview.form\",\n                                   formFile.getPath().replace('/', File.separatorChar),\n                                   errors[0].getErrorMessage()),\n          CommonBundle.getErrorTitle()\n        );\n        return;\n      }\n    }\n    catch (Exception e) {\n      LOG.debug(e);\n      Messages.showErrorDialog(\n        module.getProject(),\n        UIDesignerBundle.message(\"error.cannot.preview.form\", formFile.getPath().replace('/', File.separatorChar),\n                                 e.getMessage() != null ? e.getMessage() : e.toString()),\n        CommonBundle.getErrorTitle()\n      );\n      return;\n    }\n\n    // 2.5. Copy up-to-date properties files to the output directory.\n    final HashSet<String> bundleSet = new HashSet<String>();\n    FormEditingUtil.iterateStringDescriptors(\n      rootContainer,\n      new FormEditingUtil.StringDescriptorVisitor<IComponent>() {\n        public boolean visit(final IComponent component, final StringDescriptor descriptor) {\n          if (descriptor.getBundleName() != null) {\n            bundleSet.add(descriptor.getDottedBundleName());\n          }\n          return true;\n        }\n      });\n\n    if (bundleSet.size() > 0) {\n      HashSet<VirtualFile> virtualFiles = new HashSet<VirtualFile>();\n      HashSet<Module> modules = new HashSet<Module>();\n      PropertiesReferenceManager manager = PropertiesReferenceManager.getInstance(module.getProject());\n      for(String bundleName: bundleSet) {\n        for(PropertiesFile propFile: manager.findPropertiesFiles(module, bundleName)) {\n          virtualFiles.add(propFile.getVirtualFile());\n          modules.add(ModuleUtil.findModuleForFile(propFile.getVirtualFile(), module.getProject()));\n        }\n      }\n      FileSetCompileScope scope = new FileSetCompileScope(virtualFiles, modules.toArray(new Module[]{}));\n\n      CompilerManager.getInstance(module.getProject()).make(scope, new CompileStatusNotification() {\n        public void finished(boolean aborted, int errors, int warnings, final CompileContext compileContext) {\n          if (!aborted && errors == 0) {\n            runPreviewProcess(tempPath, sources, module, formFile, dataContext, stringDescriptorLocale);\n          }\n        }\n      });\n    }\n    else {\n      runPreviewProcess(tempPath, sources, module, formFile, dataContext, stringDescriptorLocale);\n    }\n  }","id":75586,"modified_method":"private static void showPreviewFrame(@NotNull final Module module, @NotNull final VirtualFile formFile,\n                                       @Nullable final Locale stringDescriptorLocale) {\n    final String tempPath;\n    try {\n      final File tempDirectory = FileUtil.createTempDirectory(\"FormPreview\", \"\");\n      tempPath = tempDirectory.getAbsolutePath();\n\n      CopyResourcesUtil.copyFormsRuntime(tempPath, true);\n    }\n    catch (IOException e) {\n      Messages.showErrorDialog(\n        module.getProject(),\n        UIDesignerBundle.message(\"error.cannot.preview.form\", formFile.getPath().replace('/', File.separatorChar), e.toString()),\n        CommonBundle.getErrorTitle()\n      );\n      return;\n    }\n\n    final PathsList sources = OrderEnumerator.orderEntries(module).withoutSdk().withoutLibraries().withoutDepModules().getSourcePathsList();\n    final String classPath = OrderEnumerator.orderEntries(module).recursively().getPathsList().getPathsString() + File.pathSeparator +\n      sources.getPathsString() + File.pathSeparator + /* resources bundles */\n      tempPath;\n    final ClassLoader loader = Form2ByteCodeCompiler.createClassLoader(classPath);\n\n    final Document doc = FileDocumentManager.getInstance().getDocument(formFile);\n    final LwRootContainer rootContainer;\n    try {\n      rootContainer = Utils.getRootContainer(doc.getText(), new CompiledClassPropertiesProvider(loader));\n    }\n    catch (Exception e) {\n      Messages.showErrorDialog(\n        module.getProject(),\n        UIDesignerBundle.message(\"error.cannot.read.form\", formFile.getPath().replace('/', File.separatorChar), e.getMessage()),\n        CommonBundle.getErrorTitle()\n      );\n      return;\n    }\n\n    if (rootContainer.getComponentCount() == 0) {\n      Messages.showErrorDialog(\n        module.getProject(),\n        UIDesignerBundle.message(\"error.cannot.preview.empty.form\", formFile.getPath().replace('/', File.separatorChar)),\n        CommonBundle.getErrorTitle()\n      );\n      return;\n    }\n\n    setPreviewBindings(rootContainer, CLASS_TO_BIND_NAME);\n\n    // 2. Copy previewer class and all its superclasses into TEMP directory and instrument it.\n    try {\n      PreviewNestedFormLoader nestedFormLoader = new PreviewNestedFormLoader(module, tempPath, loader);\n\n      final File tempFile = CopyResourcesUtil.copyClass(tempPath, CLASS_TO_BIND_NAME, true);\n      //CopyResourcesUtil.copyClass(tempPath, CLASS_TO_BIND_NAME + \"$1\", true);\n      CopyResourcesUtil.copyClass(tempPath, CLASS_TO_BIND_NAME + \"$MyExitAction\", true);\n      CopyResourcesUtil.copyClass(tempPath, CLASS_TO_BIND_NAME + \"$MyPackAction\", true);\n      CopyResourcesUtil.copyClass(tempPath, CLASS_TO_BIND_NAME + \"$MySetLafAction\", true);\n\n      Locale locale = Locale.getDefault();\n      if (locale.getCountry().length() > 0 && locale.getLanguage().length() > 0) {\n        CopyResourcesUtil.copyProperties(tempPath, RUNTIME_BUNDLE_PREFIX + \"_\" + locale.getLanguage() +\n                                                   \"_\" + locale.getCountry() + PropertiesFileType.DOT_DEFAULT_EXTENSION);\n      }\n      if (locale.getLanguage().length() > 0) {\n        CopyResourcesUtil.copyProperties(tempPath, RUNTIME_BUNDLE_PREFIX + \"_\" + locale.getLanguage() + PropertiesFileType.DOT_DEFAULT_EXTENSION);\n      }\n      CopyResourcesUtil.copyProperties(tempPath, RUNTIME_BUNDLE_PREFIX + \"_\" + locale.getLanguage() + PropertiesFileType.DOT_DEFAULT_EXTENSION);\n      CopyResourcesUtil.copyProperties(tempPath, RUNTIME_BUNDLE_PREFIX + PropertiesFileType.DOT_DEFAULT_EXTENSION);\n\n      final AsmCodeGenerator codeGenerator = new AsmCodeGenerator(rootContainer, loader, nestedFormLoader, true,\n                                                                  new PsiClassWriter(module));\n      codeGenerator.patchFile(tempFile);\n      final FormErrorInfo[] errors = codeGenerator.getErrors();\n      if(errors.length != 0){\n        Messages.showErrorDialog(\n          module.getProject(),\n          UIDesignerBundle.message(\"error.cannot.preview.form\",\n                                   formFile.getPath().replace('/', File.separatorChar),\n                                   errors[0].getErrorMessage()),\n          CommonBundle.getErrorTitle()\n        );\n        return;\n      }\n    }\n    catch (Exception e) {\n      LOG.debug(e);\n      Messages.showErrorDialog(\n        module.getProject(),\n        UIDesignerBundle.message(\"error.cannot.preview.form\", formFile.getPath().replace('/', File.separatorChar),\n                                 e.getMessage() != null ? e.getMessage() : e.toString()),\n        CommonBundle.getErrorTitle()\n      );\n      return;\n    }\n\n    // 2.5. Copy up-to-date properties files to the output directory.\n    final HashSet<String> bundleSet = new HashSet<String>();\n    FormEditingUtil.iterateStringDescriptors(\n      rootContainer,\n      new FormEditingUtil.StringDescriptorVisitor<IComponent>() {\n        public boolean visit(final IComponent component, final StringDescriptor descriptor) {\n          if (descriptor.getBundleName() != null) {\n            bundleSet.add(descriptor.getDottedBundleName());\n          }\n          return true;\n        }\n      });\n\n    if (bundleSet.size() > 0) {\n      HashSet<VirtualFile> virtualFiles = new HashSet<VirtualFile>();\n      HashSet<Module> modules = new HashSet<Module>();\n      PropertiesReferenceManager manager = PropertiesReferenceManager.getInstance(module.getProject());\n      for(String bundleName: bundleSet) {\n        for(PropertiesFile propFile: manager.findPropertiesFiles(module, bundleName)) {\n          virtualFiles.add(propFile.getVirtualFile());\n          final Module moduleForFile = ModuleUtil.findModuleForFile(propFile.getVirtualFile(), module.getProject());\n          if (moduleForFile != null) {\n            modules.add(moduleForFile);\n          }\n        }\n      }\n      FileSetCompileScope scope = new FileSetCompileScope(virtualFiles, modules.toArray(new Module[modules.size()]));\n\n      CompilerManager.getInstance(module.getProject()).make(scope, new CompileStatusNotification() {\n        public void finished(boolean aborted, int errors, int warnings, final CompileContext compileContext) {\n          if (!aborted && errors == 0) {\n            runPreviewProcess(tempPath, sources, module, formFile, stringDescriptorLocale);\n          }\n        }\n      });\n    }\n    else {\n      runPreviewProcess(tempPath, sources, module, formFile, stringDescriptorLocale);\n    }\n  }","commit_id":"92251729b9ebf6c98d0add5128412339a8054c19","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(final AnActionEvent e) {\n    final GuiEditor editor = FormEditingUtil.getActiveEditor(e.getDataContext());\n    if (editor != null) {\n      showPreviewFrame(editor.getModule(), editor.getFile(), e.getDataContext(), editor.getStringDescriptorLocale());\n    }\n  }","id":75587,"modified_method":"public void actionPerformed(final AnActionEvent e) {\n    final GuiEditor editor = FormEditingUtil.getActiveEditor(e.getDataContext());\n    if (editor != null) {\n      showPreviewFrame(editor.getModule(), editor.getFile(), editor.getStringDescriptorLocale());\n    }\n  }","commit_id":"92251729b9ebf6c98d0add5128412339a8054c19","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void runPreviewProcess(final String tempPath, final PathsList sources, final Module module, final VirtualFile formFile,\n                                        final DataContext dataContext, @Nullable final Locale stringDescriptorLocale) {\n    // 3. Now we are ready to launch Java process\n    final JavaParameters parameters = new JavaParameters();\n    parameters.getClassPath().add(tempPath);\n    parameters.getClassPath().add(PathManager.findFileInLibDirectory(\"jgoodies-forms.jar\").getAbsolutePath());\n    final List<String> paths = sources.getPathList();\n    for (final String path : paths) {\n      parameters.getClassPath().add(path);\n    }\n    try {\n      parameters.configureByModule(module, JavaParameters.JDK_AND_CLASSES);\n    }\n    catch (CantRunException e) {\n      Messages.showErrorDialog(\n        module.getProject(),\n        UIDesignerBundle.message(\"error.cannot.preview.form\", formFile.getPath().replace('/', File.separatorChar), e.getMessage()),\n        CommonBundle.getErrorTitle()\n      );\n      return;\n    }\n    parameters.setMainClass(\"FormPreviewFrame\");\n    parameters.setWorkingDirectory(tempPath);\n    if (stringDescriptorLocale != null && stringDescriptorLocale.getDisplayName().length() > 0) {\n      parameters.getVMParametersList().add(\"-Duser.language=\" + stringDescriptorLocale.getLanguage());\n    }\n\n    try {\n      final RunProfile profile = new MyRunProfile(module, parameters, UIDesignerBundle.message(\"progress.preview.started\", formFile.getPresentableUrl()));\n      ProgramRunner defaultRunner = RunnerRegistry.getInstance().getRunner(DefaultRunExecutor.EXECUTOR_ID, profile);\n      LOG.assertTrue(defaultRunner != null);\n      defaultRunner.execute(DefaultRunExecutor.getRunExecutorInstance(), new ExecutionEnvironment(profile, module.getProject(), null, null,\n                                                                                                  null));\n    }\n    catch (ExecutionException e) {\n      Messages.showErrorDialog(\n        module.getProject(),\n        UIDesignerBundle.message(\"error.cannot.preview.form\", formFile.getPath().replace('/', File.separatorChar), e.getMessage()),\n        CommonBundle.getErrorTitle()\n      );\n    }\n  }","id":75588,"modified_method":"private static void runPreviewProcess(final String tempPath, final PathsList sources, final Module module, final VirtualFile formFile,\n                                        @Nullable final Locale stringDescriptorLocale) {\n    // 3. Now we are ready to launch Java process\n    final JavaParameters parameters = new JavaParameters();\n    parameters.getClassPath().add(tempPath);\n    parameters.getClassPath().add(PathManager.findFileInLibDirectory(\"jgoodies-forms.jar\").getAbsolutePath());\n    final List<String> paths = sources.getPathList();\n    for (final String path : paths) {\n      parameters.getClassPath().add(path);\n    }\n    try {\n      parameters.configureByModule(module, JavaParameters.JDK_AND_CLASSES);\n    }\n    catch (CantRunException e) {\n      Messages.showErrorDialog(\n        module.getProject(),\n        UIDesignerBundle.message(\"error.cannot.preview.form\", formFile.getPath().replace('/', File.separatorChar), e.getMessage()),\n        CommonBundle.getErrorTitle()\n      );\n      return;\n    }\n    parameters.setMainClass(\"FormPreviewFrame\");\n    parameters.setWorkingDirectory(tempPath);\n    if (stringDescriptorLocale != null && stringDescriptorLocale.getDisplayName().length() > 0) {\n      parameters.getVMParametersList().add(\"-Duser.language=\" + stringDescriptorLocale.getLanguage());\n    }\n\n    try {\n      final RunProfile profile = new MyRunProfile(module, parameters, UIDesignerBundle.message(\"progress.preview.started\", formFile.getPresentableUrl()));\n      ProgramRunner defaultRunner = RunnerRegistry.getInstance().getRunner(DefaultRunExecutor.EXECUTOR_ID, profile);\n      LOG.assertTrue(defaultRunner != null);\n      defaultRunner.execute(DefaultRunExecutor.getRunExecutorInstance(), new ExecutionEnvironment(profile, module.getProject(), null, null,\n                                                                                                  null));\n    }\n    catch (ExecutionException e) {\n      Messages.showErrorDialog(\n        module.getProject(),\n        UIDesignerBundle.message(\"error.cannot.preview.form\", formFile.getPath().replace('/', File.separatorChar), e.getMessage()),\n        CommonBundle.getErrorTitle()\n      );\n    }\n  }","commit_id":"92251729b9ebf6c98d0add5128412339a8054c19","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void doOKAction(){\n    final String packageName = myTfPackage.getText();\n    final String className = getClassName();\n\n    final String[] errorString = new String[1];\n    final PsiManager manager = PsiManager.getInstance(myProject);\n    final PsiNameHelper nameHelper = JavaPsiFacade.getInstance(manager.getProject()).getNameHelper();\n    if (packageName.length() > 0 && !nameHelper.isQualifiedName(packageName)) {\n      errorString[0] = RefactoringBundle.message(\"invalid.target.package.name.specified\");\n    } else if (\"\".equals(className)) {\n      errorString[0] = RefactoringBundle.message(\"no.class.name.specified\");\n    } else {\n      if (!nameHelper.isIdentifier(className)) {\n        errorString[0] = RefactoringMessageUtil.getIncorrectIdentifierMessage(className);\n      }\n      else if (!myDoClone) {\n        try {\n          if (myCbMoveToAnotherSourceFolder.isSelected() && myCbMoveToAnotherSourceFolder.isEnabled()) {\n            final PackageWrapper targetPackage = new PackageWrapper(manager, packageName);\n            final VirtualFile sourceRoot = MoveClassesOrPackagesUtil\n              .chooseSourceRoot(targetPackage, ProjectRootManager.getInstance(myProject).getContentSourceRoots(), myDefaultTargetDirectory);\n            if (sourceRoot == null) return;\n            new WriteCommandAction(myProject, CodeInsightBundle.message(\"create.directory.command\")){\n              @Override\n              protected void run(Result objectResult) throws Throwable {\n                myTargetDirectory = RefactoringUtil.createPackageDirectoryInSourceRoot(targetPackage, sourceRoot);\n              }\n            }.execute();\n          } else {\n            myTargetDirectory = PackageUtil.findOrCreateDirectoryForPackage(ModuleUtil.findModuleForFile(myDefaultTargetDirectory.getVirtualFile(), myProject), packageName, myDefaultTargetDirectory, true);\n          }\n          if (myTargetDirectory == null) {\n            errorString[0] = \"\"; // message already reported by PackageUtil\n          } else {\n            CommandProcessor.getInstance().executeCommand(myProject, new Runnable() {\n              public void run() {\n                ApplicationManager.getApplication().runWriteAction(new Runnable() {\n                  public void run() {\n                    errorString[0] = RefactoringMessageUtil.checkCanCreateClass(myTargetDirectory, className);\n                  }\n                });\n              }\n            }, RefactoringBundle.message(\"create.directory\"), null);\n          }\n        }\n        catch (IncorrectOperationException e) {\n          errorString[0] = e.getMessage();\n        }\n      }\n      RecentsManager.getInstance(myProject).registerRecentEntry(RECENTS_KEY, packageName);\n    }\n\n    if (errorString[0] != null) {\n      if (errorString[0].length() > 0) {\n        Messages.showMessageDialog(myProject, errorString[0], RefactoringBundle.message(\"error.title\"), Messages.getErrorIcon());\n      }\n      myNameField.requestFocusInWindow();\n      return;\n    }\n    super.doOKAction();\n  }","id":75589,"modified_method":"protected void doOKAction(){\n    final String packageName = myTfPackage.getText();\n    final String className = getClassName();\n\n    final String[] errorString = new String[1];\n    final PsiManager manager = PsiManager.getInstance(myProject);\n    final PsiNameHelper nameHelper = JavaPsiFacade.getInstance(manager.getProject()).getNameHelper();\n    if (packageName.length() > 0 && !nameHelper.isQualifiedName(packageName)) {\n      errorString[0] = RefactoringBundle.message(\"invalid.target.package.name.specified\");\n    } else if (\"\".equals(className)) {\n      errorString[0] = RefactoringBundle.message(\"no.class.name.specified\");\n    } else {\n      if (!nameHelper.isIdentifier(className)) {\n        errorString[0] = RefactoringMessageUtil.getIncorrectIdentifierMessage(className);\n      }\n      else if (!myDoClone) {\n        try {\n          if (myCbMoveToAnotherSourceFolder.isSelected() && myCbMoveToAnotherSourceFolder.isEnabled()) {\n            final PackageWrapper targetPackage = new PackageWrapper(manager, packageName);\n            final VirtualFile sourceRoot = MoveClassesOrPackagesUtil\n              .chooseSourceRoot(targetPackage, ProjectRootManager.getInstance(myProject).getContentSourceRoots(), myDefaultTargetDirectory);\n            if (sourceRoot == null) return;\n            new WriteCommandAction(myProject, CodeInsightBundle.message(\"create.directory.command\")){\n              @Override\n              protected void run(Result objectResult) throws Throwable {\n                myTargetDirectory = RefactoringUtil.createPackageDirectoryInSourceRoot(targetPackage, sourceRoot);\n              }\n            }.execute();\n          } else {\n            final Module module = ModuleUtil.findModuleForFile(myDefaultTargetDirectory.getVirtualFile(), myProject);\n            if (module != null) {\n              myTargetDirectory = PackageUtil.findOrCreateDirectoryForPackage(module, packageName, myDefaultTargetDirectory, true);\n            } else {\n              errorString[0] = \"No module found for directory \\'\" + myDefaultTargetDirectory.getVirtualFile().getPresentableUrl() + \"\\'\";\n            }\n          }\n          if (myTargetDirectory == null) {\n            if (errorString[0] == null) {\n              errorString[0] = \"\"; // message already reported by PackageUtil\n            }\n          } else {\n            CommandProcessor.getInstance().executeCommand(myProject, new Runnable() {\n              public void run() {\n                ApplicationManager.getApplication().runWriteAction(new Runnable() {\n                  public void run() {\n                    errorString[0] = RefactoringMessageUtil.checkCanCreateClass(myTargetDirectory, className);\n                  }\n                });\n              }\n            }, RefactoringBundle.message(\"create.directory\"), null);\n          }\n        }\n        catch (IncorrectOperationException e) {\n          errorString[0] = e.getMessage();\n        }\n      }\n      RecentsManager.getInstance(myProject).registerRecentEntry(RECENTS_KEY, packageName);\n    }\n\n    if (errorString[0] != null) {\n      if (errorString[0].length() > 0) {\n        Messages.showMessageDialog(myProject, errorString[0], RefactoringBundle.message(\"error.title\"), Messages.getErrorIcon());\n      }\n      myNameField.requestFocusInWindow();\n      return;\n    }\n    super.doOKAction();\n  }","commit_id":"e50d904feddd830f7dc5f4cbcde1fbbd22261bad","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public Collection<AbstractTreeNode> getChildren() {\n    List<VirtualFile> topLevelContentRoots = ProjectViewDirectoryHelper.getInstance(myProject).getTopLevelRoots();\n\n    Set<Module> modules = new LinkedHashSet<Module>(topLevelContentRoots.size());\n\n    for (VirtualFile root : topLevelContentRoots) {\n      modules.add(ModuleUtil.findModuleForFile(root, myProject));\n    }\n\n    ArrayList<AbstractTreeNode> nodes = new ArrayList<AbstractTreeNode>();\n    final PsiManager psiManager = PsiManager.getInstance(getProject());\n\n    /*\n    for (VirtualFile root : reduceRoots(topLevelContentRoots)) {\n      nodes.add(new PsiDirectoryNode(getProject(), psiManager.findDirectory(root), getSettings()));\n    }\n    */\n\n    nodes.addAll(modulesAndGroups(modules.toArray(new Module[modules.size()])));\n\n    final VirtualFile baseDir = getProject().getBaseDir();\n    if (baseDir == null) return nodes;\n\n    final VirtualFile[] files = baseDir.getChildren();\n    for (VirtualFile file : files) {\n      if (ModuleUtil.findModuleForFile(file, getProject()) == null) {\n        if (!file.isDirectory()) {\n          nodes.add(new PsiFileNode(getProject(), psiManager.findFile(file), getSettings()));\n        }\n      }\n    }\n\n    if (getSettings().isShowLibraryContents()) {\n      nodes.add(new ExternalLibrariesNode(getProject(), getSettings()));\n    }\n\n    return nodes;\n  }","id":75590,"modified_method":"@NotNull\n  public Collection<AbstractTreeNode> getChildren() {\n    List<VirtualFile> topLevelContentRoots = ProjectViewDirectoryHelper.getInstance(myProject).getTopLevelRoots();\n\n    Set<Module> modules = new LinkedHashSet<Module>(topLevelContentRoots.size());\n\n    for (VirtualFile root : topLevelContentRoots) {\n      final Module module = ModuleUtil.findModuleForFile(root, myProject);\n      if (module != null) {\n        modules.add(module);\n      }\n      else {\n        LOG.error(\"Cannot find module for file, which is reported as content root. Path: \" + root.getPresentableUrl());\n      }\n    }\n\n    ArrayList<AbstractTreeNode> nodes = new ArrayList<AbstractTreeNode>();\n    final PsiManager psiManager = PsiManager.getInstance(getProject());\n\n    /*\n    for (VirtualFile root : reduceRoots(topLevelContentRoots)) {\n      nodes.add(new PsiDirectoryNode(getProject(), psiManager.findDirectory(root), getSettings()));\n    }\n    */\n\n    nodes.addAll(modulesAndGroups(modules.toArray(new Module[modules.size()])));\n\n    final VirtualFile baseDir = getProject().getBaseDir();\n    if (baseDir == null) return nodes;\n\n    final VirtualFile[] files = baseDir.getChildren();\n    for (VirtualFile file : files) {\n      if (ModuleUtil.findModuleForFile(file, getProject()) == null) {\n        if (!file.isDirectory()) {\n          nodes.add(new PsiFileNode(getProject(), psiManager.findFile(file), getSettings()));\n        }\n      }\n    }\n\n    if (getSettings().isShowLibraryContents()) {\n      nodes.add(new ExternalLibrariesNode(getProject(), getSettings()));\n    }\n\n    return nodes;\n  }","commit_id":"33f568db1a772fc84f1ad296cd380e87fac17c6e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String _toLanguageId(Locale locale) {\n\t\tif (locale == null) {\n\t\t\tlocale = _locale;\n\t\t}\n\n\t\tString languageId = locale.getLanguage();\n\n\t\tif (Validator.isNotNull(locale.getCountry())) {\n\t\t\tlanguageId = languageId.concat(StringPool.UNDERLINE);\n\t\t\tlanguageId = languageId.concat(locale.getCountry());\n\t\t}\n\n\t\tif (Validator.isNotNull(locale.getVariant())) {\n\t\t\tlanguageId = languageId.concat(StringPool.UNDERLINE);\n\t\t\tlanguageId = languageId.concat(locale.getVariant());\n\t\t}\n\n\t\treturn languageId;\n\t}","id":75591,"modified_method":"private String _toLanguageId(Locale locale) {\n\t\tif (locale == null) {\n\t\t\tlocale = _locale;\n\t\t}\n\n\t\tString languageId = locale.getLanguage();\n\t\tString countryId = locale.getCountry();\n\t\tString variantId = locale.getVariant();\n\n\t\tboolean hasCountryId = countryId.length() != 0;\n\t\tboolean hasVariantId = variantId.length() != 0;\n\n\t\tif ((!hasCountryId) && (!hasVariantId)) {\n\t\t\treturn languageId;\n\t\t}\n\n\t\tint length = 3;\n\n\t\tif (hasCountryId && hasVariantId) {\n\t\t\tlength = 5;\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(length);\n\n\t\tsb.append(languageId);\n\n\t\tif (hasCountryId) {\n\t\t\tsb.append(StringPool.UNDERLINE);\n\t\t\tsb.append(countryId);\n\t\t}\n\n\t\tif (hasVariantId) {\n\t\t\tsb.append(StringPool.UNDERLINE);\n\t\t\tsb.append(variantId);\n\t\t}\n\n\t\treturn sb.toString();\n\t}","commit_id":"6c7cfc974d7be743800b01ab2979e7017a024927","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private String makeFullRecord(IndelPrecall normalCall, IndelPrecall tumorCall) {\r\n        StringBuilder fullRecord = new StringBuilder();\r\n        fullRecord.append(tumorCall.makeEventString());\r\n        fullRecord.append('\\t');\r\n        fullRecord.append(normalCall.makeStatsString(\"N_\"));\r\n        fullRecord.append('\\t');\r\n        fullRecord.append(tumorCall.makeStatsString(\"T_\"));\r\n        fullRecord.append('\\t');\r\n        return fullRecord.toString();\r\n    }","id":75592,"modified_method":"private String makeFullRecord(IndelPrecall normalCall, IndelPrecall tumorCall) {\r\n        StringBuilder fullRecord = new StringBuilder();\r\n        if ( tumorCall.getVariant() != null || normalCall.getVariant() == null) {\r\n            fullRecord.append(tumorCall.makeEventString());\r\n        } else {\r\n            fullRecord.append(normalCall.makeEventString());            \r\n        }\r\n        fullRecord.append('\\t');\r\n        fullRecord.append(normalCall.makeStatsString(\"N_\"));\r\n        fullRecord.append('\\t');\r\n        fullRecord.append(tumorCall.makeStatsString(\"T_\"));\r\n        fullRecord.append('\\t');\r\n        return fullRecord.toString();\r\n    }","commit_id":"68ce55148e01821feaa65e31d1f3c504e7b37171","url":"https://github.com/broadgsa/gatk"},{"original_method":"public boolean isCall() {\r\n            boolean ret =  ( consensus_indel_count >= minIndelCount &&\r\n                    (double)consensus_indel_count > minFraction * total_coverage &&\r\n                    (double) consensus_indel_count > minConsensusFraction*all_indel_count );\r\n            if ( DEBUG && ! ret ) System.out.println(\"DEBUG>>  NOT a call: count=\"+consensus_indel_count+\r\n                        \" total_count=\"+all_indel_count+\" cov=\"+total_coverage+\r\n                \" minConsensusF=\"+((double)consensus_indel_count)/all_indel_count+\r\n                    \" minF=\"+((double)consensus_indel_count)/total_coverage);\r\n            return ret;\r\n\r\n        }","id":75593,"modified_method":"public boolean isCall() {\r\n            boolean ret =  ( consensus_indel_count >= minIndelCount &&\r\n                    (double)consensus_indel_count > minFraction * total_coverage &&\r\n                    (double) consensus_indel_count > minConsensusFraction*all_indel_count && total_coverage >= minCoverage);\r\n            if ( DEBUG && ! ret ) System.out.println(\"DEBUG>>  NOT a call: count=\"+consensus_indel_count+\r\n                        \" total_count=\"+all_indel_count+\" cov=\"+total_coverage+\r\n                \" minConsensusF=\"+((double)consensus_indel_count)/all_indel_count+\r\n                    \" minF=\"+((double)consensus_indel_count)/total_coverage);\r\n            return ret;\r\n\r\n        }","commit_id":"68ce55148e01821feaa65e31d1f3c504e7b37171","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\r\n    public void onTraversalDone(Integer result) {\r\n        if ( call_somatic ) emit_somatic(1000000000, true);\r\n        else emit(1000000000,true); // emit everything we might have left\r\n\r\n        if ( metricsWriter != null ) {\r\n            metricsWriter.println(String.format(\"Normal calls made     %d\", normalCallsMade));\r\n            metricsWriter.println(String.format(\"Tumor calls made      %d\", tumorCallsMade));\r\n            metricsWriter.close();\r\n        }\r\n\r\n        try {\r\n            if ( bedWriter != null ) bedWriter.close();\r\n            if ( verboseWriter != null ) verboseWriter.close();\r\n        } catch (IOException e) {\r\n            System.out.println(\"Failed to close output BED file gracefully, data may be lost\");\r\n            e.printStackTrace();\r\n        }\r\n        super.onTraversalDone(result);\r\n    }","id":75594,"modified_method":"@Override\r\n    public void onTraversalDone(Integer result) {\r\n        if ( DEBUG ) {\r\n            System.out.println(\"DEBUG>> Emitting last window at \"+normal_context.getStart()+\"-\"+normal_context.getStop());\r\n        }\r\n        if ( call_somatic ) emit_somatic(1000000000, true);\r\n        else emit(1000000000,true); // emit everything we might have left\r\n\r\n        if ( metricsWriter != null ) {\r\n            metricsWriter.println(String.format(\"Normal calls made     %d\", normalCallsMade));\r\n            metricsWriter.println(String.format(\"Tumor calls made      %d\", tumorCallsMade));\r\n            metricsWriter.close();\r\n        }\r\n\r\n        try {\r\n            if ( bedWriter != null ) bedWriter.close();\r\n            if ( verboseWriter != null ) verboseWriter.close();\r\n        } catch (IOException e) {\r\n            System.out.println(\"Failed to close output BED file gracefully, data may be lost\");\r\n            e.printStackTrace();\r\n        }\r\n        super.onTraversalDone(result);\r\n    }","commit_id":"68ce55148e01821feaa65e31d1f3c504e7b37171","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void printVCFLine(VCFWriter vcf, IndelPrecall nCall, IndelPrecall tCall) {\r\n        int event_length = tCall.getVariant().lengthOnRef();\r\n        if ( event_length < 0 ) event_length = 0;\r\n\r\n        long start = tCall.getPosition()-1;\r\n        long stop = start;\r\n\r\n        Map<String,Object> attrs = nCall.makeStatsAttributes(\"N_\",null);\r\n        attrs = tCall.makeStatsAttributes(\"T_\",attrs);\r\n\r\n        boolean isSomatic = false;\r\n        if ( nCall.getVariant() == null ) {\r\n            isSomatic = true;\r\n            attrs.put(VCFConstants.SOMATIC_KEY,true);\r\n        }\r\n\r\n        List<Allele> alleles = new ArrayList<Allele>(2);\r\n        List<Allele> homRefAlleles = isSomatic ? new ArrayList<Allele>(2) : null ; // we need this only for somatic calls\r\n\r\n        if ( event_length == 0 ) { // insertion\r\n             alleles.add( Allele.create(Allele.NULL_ALLELE_STRING,true) );\r\n             alleles.add( Allele.create(tCall.getVariant().getBases(), false ));\r\n             if ( isSomatic ) {\r\n                 // create alleles of hom-ref genotype for normal sample\r\n                 homRefAlleles.add( Allele.create(Allele.NULL_ALLELE_STRING,true) );\r\n                 homRefAlleles.add( Allele.create(Allele.NULL_ALLELE_STRING,true) );\r\n             }\r\n        } else { //deletion:\r\n             alleles.add( Allele.create(Allele.NULL_ALLELE_STRING,false) );\r\n             alleles.add( Allele.create(tCall.getVariant().getBases(), true ));\r\n             stop += event_length;\r\n            if ( isSomatic ) {\r\n                // create alleles of hom-ref genotype for normal sample\r\n                homRefAlleles.add( Allele.create(tCall.getVariant().getBases(), true ));\r\n                homRefAlleles.add( Allele.create(tCall.getVariant().getBases(), true ));\r\n            }\r\n        }\r\n\r\n\r\n        Map<String,Genotype> genotypes = new HashMap<String,Genotype>();\r\n\r\n        for ( String sample : normalSamples ) {\r\n            genotypes.put(sample,new Genotype(sample, isSomatic ? homRefAlleles : alleles,0));\r\n        }\r\n\r\n        for ( String sample : tumorSamples ) {\r\n            genotypes.put(sample,new Genotype(sample, alleles,0) );\r\n        }\r\n\r\n        VariantContext vc = new VariantContext(\"IGv2_Indel_call\", refName, start, stop, alleles, genotypes,\r\n            -1.0 /* log error */, null /* filters */, attrs);\r\n        vcf.add(vc,refBases[(int)start-1]);\r\n    }","id":75595,"modified_method":"public void printVCFLine(VCFWriter vcf, IndelPrecall nCall, IndelPrecall tCall) {\r\n\r\n        long start = tCall.getPosition()-1;\r\n        long stop = start;\r\n\r\n        // If the beginning of the chromosome is deleted (possible, however unlikely), it's unclear how to proceed.\r\n        // The suggestion is instead of putting the base before the indel, to put the base after the indel.\r\n        // For now, just don't print out that site.\r\n        if ( start == 0 )\r\n            return;\r\n\r\n        Map<String,Object> attrs = nCall.makeStatsAttributes(\"N_\",null);\r\n        attrs = tCall.makeStatsAttributes(\"T_\",attrs);\r\n\r\n        boolean isSomatic = false;\r\n        if ( nCall.getCoverage() >= minNormalCoverage && nCall.getVariant() == null && tCall.getVariant() != null ) {\r\n            isSomatic = true;\r\n            attrs.put(VCFConstants.SOMATIC_KEY,true);\r\n        }\r\n        List<Allele> alleles = new ArrayList<Allele>(2); // all alleles at the site\r\n //       List<Allele> normal_alleles = null; // all alleles at the site\r\n        List<Allele> homRefAlleles = null;\r\n\r\n//        if ( nCall.getVariant() == null || tCall.getVariant() == null ) {\r\n        homRefAlleles = new ArrayList<Allele>(2) ; // we need this for somatic calls (since normal is ref-ref), and also for no-calls\r\n//        }\r\n        boolean homRefT = ( tCall.getVariant() == null );\r\n        boolean homRefN = ( nCall.getVariant() == null );\r\n        if ( tCall.getVariant() == null && nCall.getVariant() == null) {\r\n            // no indel at all  ; create base-representation ref/ref alleles for genotype construction\r\n            alleles.add( Allele.create(refBases[(int)start-1],true) );\r\n        } else {\r\n            // we got indel(s)\r\n            int event_length = 0;\r\n            if ( tCall.getVariant() != null ) {\r\n                // indel in tumor\r\n                event_length = tCall.getVariant().lengthOnRef();\r\n                fillAlleleList(alleles, tCall);\r\n            } else {\r\n                event_length = nCall.getVariant().lengthOnRef();\r\n                fillAlleleList(alleles, nCall);\r\n            }\r\n            if ( event_length > 0 ) stop += event_length;\r\n        }\r\n        homRefAlleles.add( alleles.get(0));\r\n        homRefAlleles.add( alleles.get(0));\r\n\r\n        Map<String,Genotype> genotypes = new HashMap<String,Genotype>();\r\n\r\n        for ( String sample : normalSamples ) {\r\n            genotypes.put(sample,new Genotype(sample, homRefN ? homRefAlleles : alleles,0));\r\n        }\r\n\r\n        for ( String sample : tumorSamples ) {\r\n            genotypes.put(sample,new Genotype(sample, homRefT ? homRefAlleles : alleles,0) );\r\n        }\r\n\r\n        Set<String> filters = null;\r\n        if ( tCall.getVariant() != null && ! tCall.isCall() ) {\r\n            filters = new HashSet<String>();\r\n            filters.add(\"NOCALL\");\r\n        }\r\n        if ( nCall.getCoverage() < minNormalCoverage ) {\r\n            if ( filters == null ) filters = new HashSet<String>();\r\n            filters.add(\"NCOV\");\r\n        }\r\n        if ( tCall.getCoverage() < minCoverage ) {\r\n            if ( filters == null ) filters = new HashSet<String>();\r\n            filters.add(\"TCOV\");\r\n        }\r\n\r\n        VariantContext vc = new VariantContext(\"IGv2_Indel_call\", refName, start, stop, alleles, genotypes,\r\n            -1.0 /* log error */, filters, attrs);\r\n        vcf.add(vc,refBases[(int)start-1]);\r\n    }","commit_id":"68ce55148e01821feaa65e31d1f3c504e7b37171","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void printVCFLine(VCFWriter vcf, IndelPrecall call) {\r\n        int event_length = call.getVariant().lengthOnRef();\r\n        if ( event_length < 0 ) event_length = 0;\r\n\r\n        long start = call.getPosition()-1;\r\n        // If the beginning of the chromosome is deleted (possible, however unlikely), it's unclear how to proceed.\r\n        // The suggestion is instead of putting the base before the indel, to put the base after the indel.\r\n        // For now, just don't print out that site.\r\n        if ( start == 0 )\r\n            return;\r\n\r\n        long stop = start;\r\n\r\n        List<Allele> alleles = new ArrayList<Allele>(2);\r\n\r\n        if ( event_length == 0 ) { // insertion\r\n             alleles.add( Allele.create(Allele.NULL_ALLELE_STRING,true) );\r\n             alleles.add( Allele.create(call.getVariant().getBases(), false ));\r\n        } else { //deletion:\r\n             alleles.add( Allele.create(Allele.NULL_ALLELE_STRING,false) );\r\n             alleles.add( Allele.create(call.getVariant().getBases(), true ));\r\n             stop += event_length;\r\n        }\r\n\r\n        Map<String,Genotype> genotypes = new HashMap<String,Genotype>();\r\n\r\n        for ( String sample : normalSamples ) {\r\n            genotypes.put(sample,new Genotype(sample, alleles));\r\n        }\r\n               \r\n        VariantContext vc = new VariantContext(\"IGv2_Indel_call\", refName, start, stop, alleles, genotypes,\r\n            -1.0 /* log error */, null /* filters */, call.makeStatsAttributes(\"\",null));\r\n        vcf.add(vc,refBases[(int)start-1]);\r\n    }","id":75596,"modified_method":"public void printVCFLine(VCFWriter vcf, IndelPrecall call) {\r\n\r\n        long start = call.getPosition()-1;\r\n        // If the beginning of the chromosome is deleted (possible, however unlikely), it's unclear how to proceed.\r\n        // The suggestion is instead of putting the base before the indel, to put the base after the indel.\r\n        // For now, just don't print out that site.\r\n        if ( start == 0 )\r\n            return;\r\n\r\n        long stop = start;\r\n\r\n        List<Allele> alleles = new ArrayList<Allele>(2); // actual observed (distinct!) alleles at the site\r\n        List<Allele> homref_alleles = null; // when needed, will contain two identical copies of ref allele - needed to generate hom-ref genotype\r\n\r\n\r\n        if ( call.getVariant() == null ) {\r\n            // we will need to cteate genotype with two (hom) ref alleles (below).\r\n            // we can not use 'alleles' list here, since that list is supposed to contain\r\n            // only *distinct* alleles observed at the site or VCFContext will frown upon us...\r\n            alleles.add( Allele.create(refBases[(int)start-1],true) );\r\n            homref_alleles = new ArrayList<Allele>(2);\r\n            homref_alleles.add( alleles.get(0));\r\n            homref_alleles.add( alleles.get(0));\r\n        } else {\r\n            // we always create alt allele when we observe anything but the ref, even if it is not a call!\r\n            // (Genotype will tell us whether it is an actual call or not!)\r\n            int event_length = call.getVariant().lengthOnRef();\r\n            if ( event_length < 0 ) event_length = 0;\r\n            fillAlleleList(alleles,call);\r\n            stop += event_length;\r\n        }\r\n\r\n        Map<String,Genotype> genotypes = new HashMap<String,Genotype>();\r\n\r\n        for ( String sample : normalSamples ) {\r\n            if ( call.isCall() ) // we made a call - put actual het genotype here:\r\n                genotypes.put(sample,new Genotype(sample, alleles));\r\n            else // no call: genotype is ref/ref (but alleles still contain the alt if we observed anything at all) \r\n                genotypes.put(sample,new Genotype(sample, homref_alleles));\r\n\r\n        }\r\n        Set<String> filters = null;\r\n        if ( call.getVariant() != null && ! call.isCall() ) {\r\n            filters = new HashSet<String>();\r\n            filters.add(\"NOCALL\");\r\n        }\r\n        VariantContext vc = new VariantContext(\"IGv2_Indel_call\", refName, start, stop, alleles, genotypes,\r\n            -1.0 /* log error */,  filters, call.makeStatsAttributes(\"\",null));\r\n        vcf.add(vc,refBases[(int)start-1]);\r\n    }","commit_id":"68ce55148e01821feaa65e31d1f3c504e7b37171","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\r\n\tpublic void initialize() {\r\n\r\n\t\tnormal_context = new WindowContext(0,WINDOW_SIZE);\r\n        normalSamples = new HashSet<String>();\r\n\r\n        if ( bedOutput != null && output_file != null ) {\r\n            throw new UserException.DeprecatedArgument(\"-O\", \"-O option is deprecated and -bed option replaces it; you can not use both at the same time\");\r\n        }\r\n\r\n\t\tif ( RefseqFileName != null ) {\r\n            logger.info(\"Using RefSeq annotations from \"+RefseqFileName);\r\n\r\n\t\t\tRMDTrackBuilder builder = new RMDTrackBuilder();\r\n            FeatureSource refseq = builder.createFeatureReader(RefSeqCodec.class,new File(RefseqFileName)).first;\r\n\r\n            try {\r\n                refseqIterator = new SeekableRODIterator(getToolkit().getReferenceDataSource().getReference().getSequenceDictionary(),\r\n                                                         getToolkit().getGenomeLocParser(),\r\n                                                         new FeatureToGATKFeatureIterator(getToolkit().getGenomeLocParser(),refseq.iterator(),\"refseq\"));\r\n            } catch (IOException e) {\r\n                throw new UserException.CouldNotReadInputFile(new File(RefseqFileName), \"Write failed\", e);\r\n            }\r\n\t\t}\r\n\r\n\t\tif ( refseqIterator == null ) logger.info(\"No gene annotations available\");\r\n\r\n\t\tint nSams = getToolkit().getArguments().samFiles.size();\r\n\r\n        if ( call_somatic ) {\r\n            if ( nSams < 2 ) throw new UserException.BadInput(\"At least two bam files (normal and tumor) must be specified in somatic mode\");\r\n            tumor_context = new WindowContext(0,WINDOW_SIZE);\r\n            tumorSamples = new HashSet<String>();\r\n        }\r\n\r\n        int nNorm = 0;\r\n        int nTum = 0;\r\n        for ( SAMReaderID rid : getToolkit().getReadsDataSource().getReaderIDs() ) {\r\n             List<String> tags = rid.getTags() ;\r\n             if ( tags.isEmpty() && call_somatic )\r\n                 throw new UserException.BadInput(\"In somatic mode all input bam files must be tagged as either 'normal' or 'tumor'. Untagged file: \"+\r\n                         getToolkit().getSourceFileForReaderID(rid));\r\n             boolean normal = false;\r\n             boolean tumor = false;\r\n             for ( String s : tags ) { // we allow additional unrelated tags (and we do not use them), but we REQUIRE one of Tumor/Normal to be present if --somatic is on\r\n                 if ( \"NORMAL\".equals(s.toUpperCase()) ) {\r\n                     normal = true;\r\n                     nNorm++;\r\n                 }\r\n                 if ( \"TUMOR\".equals(s.toUpperCase()) ) {\r\n                     tumor = true;\r\n                     nTum++ ;\r\n                 }\r\n             }\r\n             if ( call_somatic && normal && tumor ) throw new UserException.BadInput(\"Input bam file \"+\r\n                     getToolkit().getSourceFileForReaderID(rid)+\" is tagged both as normal and as tumor. Which one is it??\");\r\n             if ( call_somatic && !normal && ! tumor )\r\n                 throw new UserException.BadInput(\"In somatic mode all input bams must be tagged as either normal or tumor. Encountered untagged file: \"+\r\n                    getToolkit().getSourceFileForReaderID(rid));\r\n             if ( ! call_somatic && (normal || tumor) )\r\n                 System.out.println(\"WARNING: input bam file \"+getToolkit().getSourceFileForReaderID(rid)\r\n                         +\" is tagged as Normal and/or Tumor, but somatic mode is not on. Tags will ne IGNORED\");\r\n            if ( call_somatic && tumor ) {\r\n                for ( SAMReadGroupRecord rg : getToolkit().getSAMFileHeader(rid).getReadGroups() ) {\r\n                    tumorSamples.add(rg.getSample());\r\n                }\r\n            } else {\r\n                for ( SAMReadGroupRecord rg : getToolkit().getSAMFileHeader(rid).getReadGroups() ) {\r\n                    normalSamples.add(rg.getSample());\r\n                }\r\n            }\r\n            if ( genotypeIntervalsFile != null ) {\r\n\r\n                traverseIntervals = getToolkit().getIntervals();\r\n\r\n                if ( ! GENOTYPE_NOT_SORTED && IntervalUtils.isIntervalFile(genotypeIntervalsFile)) {\r\n                    // prepare to read intervals one-by-one, as needed (assuming they are sorted).\r\n                    genotypeIntervals = new IntervalFileMergingIterator(getToolkit().getGenomeLocParser(),\r\n                        new java.io.File(genotypeIntervalsFile), IntervalMergingRule.OVERLAPPING_ONLY );\r\n                } else {\r\n                    // read in the whole list of intervals for cleaning\r\n                    GenomeLocSortedSet locs = IntervalUtils.sortAndMergeIntervals(getToolkit().getGenomeLocParser(),\r\n                        IntervalUtils.parseIntervalArguments(getToolkit().getGenomeLocParser(),Arrays.asList(genotypeIntervalsFile),true), IntervalMergingRule.OVERLAPPING_ONLY);\r\n                    genotypeIntervals = locs.iterator();\r\n                }\r\n                currentGenotypeInterval = genotypeIntervals.hasNext() ? genotypeIntervals.next() : null;\r\n            }\r\n\r\n        }\r\n\r\n\t\tlocation = getToolkit().getGenomeLocParser().createGenomeLoc(getToolkit().getSAMFileHeader().getSequence(0).getSequenceName(),1);\r\n\r\n//\t\tList<Set<String>> readGroupSets = getToolkit().getMergedReadGroupsByReaders();\r\n//        List<Set<String>> sampleSets = getToolkit().getSamplesByReaders();\r\n\r\n        normalSamples = getToolkit().getSamplesByReaders().get(0);\r\n\r\n//\t\tif ( call_somatic ) {\r\n//\t\t\tif ( nSams != 2 ) {\r\n//\t\t\t\tSystem.out.println(\"In --somatic mode two input bam files must be specified (normal/tumor)\");\r\n//\t\t\t\tSystem.exit(1);\r\n//\t\t\t}\r\n\r\n//\t\t\tnormalReadGroups = readGroupSets.get(0); // first -I option must specify normal.bam\r\n//                        System.out.println(normalReadGroups.size() + \" normal read groups\");\r\n//                        for ( String rg : normalReadGroups ) System.out.println(\"Normal RG: \"+rg);\r\n\r\n//\t\t\ttumorReadGroups = readGroupSets.get(1); // second -I option must specify tumor.bam\r\n//                        System.out.println(tumorReadGroups.size() + \" tumor read groups\");\r\n//                        for ( String rg : tumorReadGroups ) System.out.println(\"Tumor RG: \"+rg);\r\n\r\n//            tumorSamples = sampleSets.get(1);\r\n//\t\t} else {\r\n//\t\t\tif ( nSams != 1 ) System.out.println(\"WARNING: multiple input files specified. \\n\"+\r\n//\t\t\t\t\t\"WARNING: Without --somatic option they will be merged and processed as a single sample\");\r\n//\t\t}\r\n\r\n        try {\r\n            // we already checked that bedOutput and output_file are not set simultaneously\r\n            if ( bedOutput != null ) bedWriter = new FileWriter(bedOutput);\r\n            if ( output_file != null ) bedWriter = new FileWriter(output_file);\r\n        } catch (java.io.IOException e) {\r\n            throw new UserException.CouldNotReadInputFile(bedOutput, \"Failed to open BED file for writing.\", e);\r\n        }\r\n        try {\r\n            if ( verboseOutput != null ) verboseWriter = new FileWriter(verboseOutput);\r\n        } catch (java.io.IOException e) {\r\n            throw new UserException.CouldNotReadInputFile(verboseOutput, \"Failed to open BED file for writing.\", e);\r\n        }\r\n\r\n        vcf_writer.writeHeader(new VCFHeader(getVCFHeaderInfo(), SampleUtils.getSAMFileSamples(getToolkit().getSAMFileHeader()))) ;\r\n        refData = new ReferenceDataSource(getToolkit().getArguments().referenceFile);\r\n\t}","id":75597,"modified_method":"@Override\r\n\tpublic void initialize() {\r\n\r\n\t\tnormal_context = new WindowContext(0,WINDOW_SIZE);\r\n        normalSamples = new HashSet<String>();\r\n\r\n        if ( bedOutput != null && output_file != null ) {\r\n            throw new UserException.DeprecatedArgument(\"-O\", \"-O option is deprecated and -bed option replaces it; you can not use both at the same time\");\r\n        }\r\n\r\n\t\tif ( RefseqFileName != null ) {\r\n            logger.info(\"Using RefSeq annotations from \"+RefseqFileName);\r\n\r\n\t\t\tRMDTrackBuilder builder = new RMDTrackBuilder();\r\n            FeatureSource refseq = builder.createFeatureReader(RefSeqCodec.class,new File(RefseqFileName)).first;\r\n\r\n            try {\r\n                refseqIterator = new SeekableRODIterator(getToolkit().getReferenceDataSource().getReference().getSequenceDictionary(),\r\n                                                         getToolkit().getGenomeLocParser(),\r\n                                                         new FeatureToGATKFeatureIterator(getToolkit().getGenomeLocParser(),refseq.iterator(),\"refseq\"));\r\n            } catch (IOException e) {\r\n                throw new UserException.CouldNotReadInputFile(new File(RefseqFileName), \"Write failed\", e);\r\n            }\r\n\t\t}\r\n\r\n\t\tif ( refseqIterator == null ) logger.info(\"No gene annotations available\");\r\n\r\n\t\tint nSams = getToolkit().getArguments().samFiles.size();\r\n\r\n        if ( call_somatic ) {\r\n            if ( nSams < 2 ) throw new UserException.BadInput(\"At least two bam files (normal and tumor) must be specified in somatic mode\");\r\n            tumor_context = new WindowContext(0,WINDOW_SIZE);\r\n            tumorSamples = new HashSet<String>();\r\n        }\r\n\r\n        int nNorm = 0;\r\n        int nTum = 0;\r\n        for ( SAMReaderID rid : getToolkit().getReadsDataSource().getReaderIDs() ) {\r\n             List<String> tags = rid.getTags() ;\r\n             if ( tags.isEmpty() && call_somatic )\r\n                 throw new UserException.BadInput(\"In somatic mode all input bam files must be tagged as either 'normal' or 'tumor'. Untagged file: \"+\r\n                         getToolkit().getSourceFileForReaderID(rid));\r\n             boolean normal = false;\r\n             boolean tumor = false;\r\n             for ( String s : tags ) { // we allow additional unrelated tags (and we do not use them), but we REQUIRE one of Tumor/Normal to be present if --somatic is on\r\n                 if ( \"NORMAL\".equals(s.toUpperCase()) ) {\r\n                     normal = true;\r\n                     nNorm++;\r\n                 }\r\n                 if ( \"TUMOR\".equals(s.toUpperCase()) ) {\r\n                     tumor = true;\r\n                     nTum++ ;\r\n                 }\r\n             }\r\n             if ( call_somatic && normal && tumor ) throw new UserException.BadInput(\"Input bam file \"+\r\n                     getToolkit().getSourceFileForReaderID(rid)+\" is tagged both as normal and as tumor. Which one is it??\");\r\n             if ( call_somatic && !normal && ! tumor )\r\n                 throw new UserException.BadInput(\"In somatic mode all input bams must be tagged as either normal or tumor. Encountered untagged file: \"+\r\n                    getToolkit().getSourceFileForReaderID(rid));\r\n             if ( ! call_somatic && (normal || tumor) )\r\n                 System.out.println(\"WARNING: input bam file \"+getToolkit().getSourceFileForReaderID(rid)\r\n                         +\" is tagged as Normal and/or Tumor, but somatic mode is not on. Tags will ne IGNORED\");\r\n            if ( call_somatic && tumor ) {\r\n                for ( SAMReadGroupRecord rg : getToolkit().getSAMFileHeader(rid).getReadGroups() ) {\r\n                    tumorSamples.add(rg.getSample());\r\n                }\r\n            } else {\r\n                for ( SAMReadGroupRecord rg : getToolkit().getSAMFileHeader(rid).getReadGroups() ) {\r\n                    normalSamples.add(rg.getSample());\r\n                }\r\n            }\r\n            if ( genotypeIntervalsFile != null ) {\r\n\r\n                if ( ! GENOTYPE_NOT_SORTED && IntervalUtils.isIntervalFile(genotypeIntervalsFile)) {\r\n                    // prepare to read intervals one-by-one, as needed (assuming they are sorted).\r\n                    genotypeIntervalIterator = new IntervalFileMergingIterator(getToolkit().getGenomeLocParser(),\r\n                        new java.io.File(genotypeIntervalsFile), IntervalMergingRule.OVERLAPPING_ONLY );\r\n                } else {\r\n                    // read in the whole list of intervals for cleaning\r\n                    GenomeLocSortedSet locs = IntervalUtils.sortAndMergeIntervals(getToolkit().getGenomeLocParser(),\r\n                        IntervalUtils.parseIntervalArguments(getToolkit().getGenomeLocParser(),Arrays.asList(genotypeIntervalsFile),true), IntervalMergingRule.OVERLAPPING_ONLY);\r\n                    genotypeIntervalIterator = locs.iterator();\r\n                }\r\n\r\n                // wrap intervals requested for genotyping inside overlapping iterator, so that we actually\r\n                // genotype only on the intersections of the requested intervals with the -L intervals\r\n                genotypeIntervalIterator = new OverlappingIntervalIterator(genotypeIntervalIterator, getToolkit().getIntervals().iterator() );\r\n\r\n                currentGenotypeInterval = genotypeIntervalIterator.hasNext() ? genotypeIntervalIterator.next() : null;\r\n\r\n                if ( DEBUG) System.out.println(\"DEBUG>> first genotyping interval=\"+currentGenotypeInterval);\r\n\r\n                if ( currentGenotypeInterval != null ) lastGenotypedPosition = currentGenotypeInterval.getStart()-1;\r\n            }\r\n\r\n        }\r\n\r\n\t\tlocation = getToolkit().getGenomeLocParser().createGenomeLoc(getToolkit().getSAMFileHeader().getSequence(0).getSequenceName(),1);\r\n\r\n        normalSamples = getToolkit().getSamplesByReaders().get(0);\r\n\r\n        try {\r\n            // we already checked that bedOutput and output_file are not set simultaneously\r\n            if ( bedOutput != null ) bedWriter = new FileWriter(bedOutput);\r\n            if ( output_file != null ) bedWriter = new FileWriter(output_file);\r\n        } catch (java.io.IOException e) {\r\n            throw new UserException.CouldNotReadInputFile(bedOutput, \"Failed to open BED file for writing.\", e);\r\n        }\r\n        try {\r\n            if ( verboseOutput != null ) verboseWriter = new FileWriter(verboseOutput);\r\n        } catch (java.io.IOException e) {\r\n            throw new UserException.CouldNotReadInputFile(verboseOutput, \"Failed to open BED file for writing.\", e);\r\n        }\r\n\r\n        vcf_writer.writeHeader(new VCFHeader(getVCFHeaderInfo(), SampleUtils.getSAMFileSamples(getToolkit().getSAMFileHeader()))) ;\r\n        refData = new ReferenceDataSource(getToolkit().getArguments().referenceFile);\r\n\t}","commit_id":"68ce55148e01821feaa65e31d1f3c504e7b37171","url":"https://github.com/broadgsa/gatk"},{"original_method":"public String makeEventString() {\r\n            int event_length = consensus_indel.lengthOnRef();\r\n            if ( event_length < 0 ) event_length = 0;\r\n            StringBuffer message = new StringBuffer();\r\n            message.append(refName);\r\n            message.append('\\t');\r\n            message.append(pos-1);\r\n            message.append('\\t');\r\n            message.append(pos-1+event_length);\r\n            message.append('\\t');\r\n            message.append((event_length>0?'-':'+'));\r\n            message.append(consensus_indel.getBases());\r\n            return message.toString();\r\n        }","id":75598,"modified_method":"public String makeEventString() {\r\n            int event_length;\r\n            if ( consensus_indel == null ) event_length = 0;\r\n            else {\r\n                event_length = consensus_indel.lengthOnRef();\r\n                if ( event_length < 0 ) event_length = 0;\r\n            }\r\n            StringBuffer message = new StringBuffer();\r\n            message.append(refName);\r\n            message.append('\\t');\r\n            message.append(pos-1);\r\n            message.append('\\t');\r\n            message.append(pos-1+event_length);\r\n            message.append('\\t');\r\n            if ( consensus_indel != null ) {\r\n                message.append((event_length>0?'-':'+'));\r\n                message.append(consensus_indel.getBases());\r\n            } else {\r\n                message.append('.');\r\n            }\r\n            return message.toString();\r\n        }","commit_id":"68ce55148e01821feaa65e31d1f3c504e7b37171","url":"https://github.com/broadgsa/gatk"},{"original_method":"/** Output indel calls up to the specified position and shift the window: after this method is executed, the\r\n    * first element of the window maps onto 'position', if possible, or at worst a few bases to the left of 'position' if we may need more\r\n    * reads to get full NQS-style statistics for an indel in the close proximity of 'position'.\r\n    *\r\n    * @param position\r\n    */\r\n   private void emit(long position, boolean force) {\r\n\r\n            long adjustedPosition = adjustPosition(position);\r\n\r\n            if ( adjustedPosition == -1 ) {\r\n                // failed to find appropriate shift position, the data are probably to messy anyway so we drop them altogether\r\n                normal_context.shift((int)(position-normal_context.getStart()));\r\n                return;\r\n            }\r\n            long move_to = adjustedPosition;\r\n\r\n            for ( int pos = normal_context.getStart() ; pos < Math.min(adjustedPosition,normal_context.getStop()+1) ; pos++ ) {\r\n\r\n                if ( normal_context.indelsAt(pos).size() == 0 ) continue; // no indels\r\n\r\n                IndelPrecall normalCall = new IndelPrecall(normal_context,pos,NQS_WIDTH);\r\n\r\n                if ( normalCall.getCoverage() < minCoverage ) {\r\n                    if ( DEBUG ) {\r\n                        System.out.println(\"DEBUG>> Indel at \"+pos+\"; coverare in normal=\"+normalCall.getCoverage()+\" (SKIPPED)\");\r\n                    }\r\n                    continue; // low coverage\r\n                }\r\n\r\n                if ( DEBUG ) System.out.println(\"DEBUG>> Indel at \"+pos);\r\n\r\n                long left = Math.max( pos-NQS_WIDTH, normal_context.getStart() );\r\n                long right = pos+normalCall.getVariant().lengthOnRef()+NQS_WIDTH-1;\r\n\r\n                if ( right >= adjustedPosition && ! force) {\r\n                    // we are not asked to force-shift, and there is more coverage around the current indel that we still need to collect\r\n\r\n                    // we are not asked to force-shift, and there's still additional coverage to the right of current indel, so its too early to emit it;\r\n                    // instead we shift only up to current indel pos - MISMATCH_WIDTH, so that we could keep collecting that coverage\r\n                    move_to = adjustPosition(left);\r\n                    if ( move_to == -1 ) {\r\n                        // failed to find appropriate shift position, the data are probably to messy anyway so we drop them altogether\r\n                        normal_context.shift((int)(adjustedPosition-normal_context.getStart()));\r\n                        return;\r\n                    }\r\n                    if ( DEBUG ) System.out.println(\"DEBUG>> waiting for coverage; actual shift performed to \"+ move_to);\r\n                    break;\r\n                }\r\n\r\n                // if indel is too close to the end of the window but we need to emit anyway (force-shift), adjust right:\r\n                if ( right > normal_context.getStop() ) right = normal_context.getStop();\r\n\r\n                location = getToolkit().getGenomeLocParser().setStart(location,pos);\r\n                location = getToolkit().getGenomeLocParser().setStop(location,pos); // retrieve annotation data\r\n\r\n                if ( normalCall.isCall() ) {\r\n                    normalCallsMade++;\r\n                    printVCFLine(vcf_writer,normalCall);\r\n                    if ( bedWriter != null ) normalCall.printBedLine(bedWriter);\r\n\r\n                    if ( verboseWriter != null ) {\r\n\r\n                        RODRecordList annotationList = (refseqIterator == null ? null : refseqIterator.seekForward(location));\r\n                        String annotationString = (refseqIterator == null ? \"\" : getAnnotationString(annotationList));\r\n\r\n                        StringBuilder fullRecord = new StringBuilder();\r\n                        fullRecord.append(makeFullRecord(normalCall));\r\n                        fullRecord.append(annotationString);\r\n                        try {\r\n                            verboseWriter.write(fullRecord.toString());\r\n                            verboseWriter.write('\\n');\r\n                        } catch (IOException e) {\r\n                            throw new UserException.CouldNotCreateOutputFile(verboseOutput, \"Write failed\", e);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                normal_context.indelsAt(pos).clear();\r\n                    // we dealt with this indel; don't want to see it again\r\n                    // (we might otherwise in the case when 1) there is another indel that follows\r\n                    // within MISMATCH_WIDTH bases and 2) we'd need to wait for more coverage for that next indel)\r\n\r\n//\t\t\tfor ( IndelVariant var : variants ) {\r\n//\t\t\t\tSystem.out.print(\"\\t\"+var.getType()+\"\\t\"+var.getBases()+\"\\t\"+var.getCount());\r\n//\t\t\t}\r\n            }\r\n\r\n            if ( DEBUG ) System.out.println(\"DEBUG>> Actual shift to \" + move_to + \" (\"+adjustedPosition+\")\");\r\n            normal_context.shift((int)(move_to - normal_context.getStart() ) );\r\n    }","id":75599,"modified_method":"/** Output indel calls up to the specified position and shift the window: after this method is executed, the\r\n    * first element of the window maps onto 'position', if possible, or at worst a few bases to the left of 'position' if we may need more\r\n    * reads to get full NQS-style statistics for an indel in the close proximity of 'position'.\r\n    *\r\n    * @param position\r\n    */\r\n   private void emit(long position, boolean force) {\r\n\r\n            long adjustedPosition = adjustPosition(position);\r\n\r\n            if ( adjustedPosition == -1 ) {\r\n                // failed to find appropriate shift position, the data are probably to messy anyway so we drop them altogether\r\n                normal_context.shift((int)(position-normal_context.getStart()));\r\n                return;\r\n            }\r\n            long move_to = adjustedPosition;\r\n\r\n            for ( int pos = normal_context.getStart() ; pos < Math.min(adjustedPosition,normal_context.getStop()+1) ; pos++ ) {\r\n\r\n                boolean genotype = false;\r\n                // first let's see if we need to genotype current position:\r\n\r\n                final long p = pos - 1; // our internally used positions (pos) are +1 compared to external format spec (e.g. vcf)\r\n\r\n                if ( pos <= lastGenotypedPosition ) continue;\r\n\r\n                while ( currentGenotypeInterval != null ) {\r\n\r\n                    // if we did not even reach next interval yet, no genotyping at current position:\r\n                    if ( location.getContigIndex() < currentGenotypeInterval.getContigIndex() ||\r\n                         location.getContigIndex() == currentGenotypeInterval.getContigIndex() &&\r\n                                 p < currentGenotypeInterval.getStart() ) break;\r\n                    if ( pastInterval(p, currentGenotypeInterval) ) {\r\n                        // we are past current genotyping interval, so we are done with it; let's load next interval:\r\n                        currentGenotypeInterval = genotypeIntervalIterator.hasNext() ? genotypeIntervalIterator.next() : null;\r\n                        continue; // re-enter the loop to check against the interval we just loaded\r\n                    }\r\n\r\n                    // we reach tjis point only if p is inside current genotyping interval; set the flag and bail out:\r\n                    genotype = true;\r\n                    break;\r\n                }\r\n\r\n//                if ( DEBUG ) System.out.println(\"DEBUG>> pos=\"+pos +\"; genotyping interval=\"+currentGenotypeInterval+\"; genotype=\"+genotype);\r\n\r\n                if ( normal_context.indelsAt(pos).size() == 0 && ! genotype ) continue;\r\n\r\n                IndelPrecall normalCall = new IndelPrecall(normal_context,pos,NQS_WIDTH);\r\n\r\n                if ( normalCall.getCoverage() < minCoverage && ! genotype ) {\r\n                    if ( DEBUG ) {\r\n                        System.out.println(\"DEBUG>> Indel at \"+pos+\"; coverare in normal=\"+normalCall.getCoverage()+\" (SKIPPED)\");\r\n                    }\r\n                    continue; // low coverage\r\n                }\r\n\r\n                if ( DEBUG ) System.out.println(\"DEBUG>> \"+(normalCall.getAllVariantCount() == 0?\"No Indel\":\"Indel\")+\" at \"+pos);\r\n\r\n                long left = Math.max( pos-NQS_WIDTH, normal_context.getStart() );\r\n                long right = pos+( normalCall.getVariant() == null ? 0 : normalCall.getVariant().lengthOnRef())+NQS_WIDTH-1;\r\n\r\n                if ( right >= adjustedPosition && ! force) {\r\n                    // we are not asked to force-shift, and there is more coverage around the current indel that we still need to collect\r\n\r\n                    // we are not asked to force-shift, and there's still additional coverage to the right of current indel, so its too early to emit it;\r\n                    // instead we shift only up to current indel pos - MISMATCH_WIDTH, so that we could keep collecting that coverage\r\n                    move_to = adjustPosition(left);\r\n                    if ( move_to == -1 ) {\r\n                        // failed to find appropriate shift position, the data are probably to messy anyway so we drop them altogether\r\n                        normal_context.shift((int)(adjustedPosition-normal_context.getStart()));\r\n                        return;\r\n                    }\r\n                    if ( DEBUG ) System.out.println(\"DEBUG>> waiting for coverage; actual shift performed to \"+ move_to);\r\n                    break;\r\n                }\r\n\r\n                // if indel is too close to the end of the window but we need to emit anyway (force-shift), adjust right:\r\n                if ( right > normal_context.getStop() ) right = normal_context.getStop();\r\n\r\n                location = getToolkit().getGenomeLocParser().setStart(location,pos);\r\n                location = getToolkit().getGenomeLocParser().setStop(location,pos); // retrieve annotation data\r\n\r\n                boolean haveCall = normalCall.isCall(); // cache the value\r\n\r\n                if ( haveCall || genotype) {\r\n                    if ( haveCall ) normalCallsMade++;\r\n                    printVCFLine(vcf_writer,normalCall);\r\n                    if ( bedWriter != null ) normalCall.printBedLine(bedWriter);\r\n                    if ( verboseWriter != null ) printVerboseLine(verboseWriter, normalCall);\r\n                    lastGenotypedPosition = pos;\r\n                }\r\n\r\n                normal_context.indelsAt(pos).clear();\r\n                    // we dealt with this indel; don't want to see it again\r\n                    // (we might otherwise in the case when 1) there is another indel that follows\r\n                    // within MISMATCH_WIDTH bases and 2) we'd need to wait for more coverage for that next indel)\r\n\r\n//\t\t\tfor ( IndelVariant var : variants ) {\r\n//\t\t\t\tSystem.out.print(\"\\t\"+var.getType()+\"\\t\"+var.getBases()+\"\\t\"+var.getCount());\r\n//\t\t\t}\r\n            }\r\n\r\n            if ( DEBUG ) System.out.println(\"DEBUG>> Actual shift to \" + move_to + \" (\"+adjustedPosition+\")\");\r\n            normal_context.shift((int)(move_to - normal_context.getStart() ) );\r\n    }","commit_id":"68ce55148e01821feaa65e31d1f3c504e7b37171","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void printBedLine(Writer bed) {\r\n            int event_length = consensus_indel.lengthOnRef();\r\n            if ( event_length < 0 ) event_length = 0;\r\n\r\n            StringBuffer message = new StringBuffer();\r\n            message.append(refName+\"\\t\"+(pos-1)+\"\\t\");\r\n            message.append((pos-1+event_length)+\"\\t\"+(event_length>0? \"-\":\"+\")+consensus_indel.getBases() +\":\"+all_indel_count+\"/\"+total_coverage);\r\n\r\n           try {\r\n                bed.write(message.toString()+\"\\n\");\r\n           } catch (IOException e) {\r\n               throw new UserException.CouldNotCreateOutputFile(bedOutput, \"Error encountered while writing into output BED file\", e);\r\n           }\r\n        }","id":75600,"modified_method":"public void printBedLine(Writer bed) {\r\n            int event_length;\r\n            if ( consensus_indel == null ) event_length = 0;\r\n            else {\r\n                event_length = consensus_indel.lengthOnRef();\r\n                if ( event_length < 0 ) event_length = 0;\r\n            }\r\n\r\n            StringBuffer message = new StringBuffer();\r\n            message.append(refName+\"\\t\"+(pos-1)+\"\\t\");\r\n            message.append((pos-1+event_length)+\"\\t\");\r\n            if ( consensus_indel != null ) {\r\n                message.append((event_length>0? \"-\":\"+\")+consensus_indel.getBases());\r\n            } else {\r\n                message.append('.');\r\n            }\r\n            message.append(\":\"+all_indel_count+\"/\"+total_coverage);\r\n            try {\r\n                bed.write(message.toString()+\"\\n\");\r\n            } catch (IOException e) {\r\n               throw new UserException.CouldNotCreateOutputFile(bedOutput, \"Error encountered while writing into output BED file\", e);\r\n            }\r\n        }","commit_id":"68ce55148e01821feaa65e31d1f3c504e7b37171","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\r\n\tpublic Integer map(ReferenceContext ref, SAMRecord read, ReadMetaDataTracker metaDataTracker) {\r\n\r\n    //        if ( read.getReadName().equals(\"428EFAAXX090610:2:36:1384:639#0\") ) System.out.println(\"GOT READ\");\r\n\r\n            if ( DEBUG ) {\r\n                //            System.out.println(\"DEBUG>> read at \"+ read.getAlignmentStart()+\"-\"+read.getAlignmentEnd()+\r\n                //                    \"(\"+read.getCigarString()+\")\");\r\n                if ( read.getDuplicateReadFlag() ) System.out.println(\"DEBUG>> Duplicated read (IGNORED)\");\r\n            }\r\n\r\n            if ( AlignmentUtils.isReadUnmapped(read) ||\r\n\t\t\t read.getDuplicateReadFlag() ||\r\n\t\t\t read.getNotPrimaryAlignmentFlag() ||\r\n\t\t\t read.getMappingQuality() == 0 ) {\r\n\t\t\treturn 0; // we do not need those reads!\r\n            }\r\n\r\n            if ( read.getReferenceIndex() != currentContigIndex ) {\r\n                // we just jumped onto a new contig\r\n                if ( DEBUG ) System.out.println(\"DEBUG>>> Moved to contig \"+read.getReferenceName());\r\n                if ( read.getReferenceIndex() < currentContigIndex ) // paranoidal\r\n                    throw new UserException.MissortedBAM(SAMFileHeader.SortOrder.coordinate, read, \"Read \"+read.getReadName()+\": contig is out of order; input BAM file is unsorted\");\r\n\r\n                // print remaining indels from the previous contig (if any);\r\n                if ( call_somatic ) emit_somatic(1000000000, true);\r\n                else emit(1000000000,true);\r\n\r\n                currentContigIndex = read.getReferenceIndex();\r\n                currentPosition = read.getAlignmentStart();\r\n                refName = new String(read.getReferenceName());\r\n\r\n                location = getToolkit().getGenomeLocParser().createGenomeLoc(refName,location.getStart(),location.getStop());\r\n                contigLength = getToolkit().getGenomeLocParser().getContigInfo(refName).getSequenceLength();\r\n                outOfContigUserWarned = false;\r\n\r\n                normal_context.clear(); // reset coverage window; this will also set reference position to 0\r\n                if ( call_somatic) tumor_context.clear();\r\n\r\n                refBases = new String(refData.getReference().getSequence(read.getReferenceName()).getBases()).toUpperCase().getBytes();\r\n            }\r\n\r\n            // we have reset the window to the new contig if it was required and emitted everything we collected\r\n            // on a previous contig. At this point we are guaranteed that we are set up properly for working\r\n            // with the contig of the current read.\r\n\r\n            // NOTE: all the sanity checks and error messages below use normal_context only. We make sure that normal_context and\r\n            // tumor_context are synchronized exactly (windows are always shifted together by emit_somatic), so it's safe\r\n\r\n            if ( read.getAlignmentStart() < currentPosition ) // oops, read out of order?\r\n                throw new UserException.MissortedBAM(SAMFileHeader.SortOrder.coordinate, read, \"Read \"+read.getReadName() +\" out of order on the contig\\n\"+\r\n                        \"Read starts at \"+refName+\":\"+read.getAlignmentStart()+\"; last read seen started at \"+refName+\":\"+currentPosition\r\n                        +\"\\nLast read was: \"+lastRead.getReadName()+\" RG=\"+lastRead.getAttribute(\"RG\")+\" at \"+lastRead.getAlignmentStart()+\"-\"\r\n                        +lastRead.getAlignmentEnd()+\" cigar=\"+lastRead.getCigarString());\r\n\r\n            currentPosition = read.getAlignmentStart();\r\n            lastRead = read;\r\n\r\n            if ( read.getAlignmentEnd() > contigLength  ) {\r\n                if ( ! outOfContigUserWarned ) {\r\n                    System.out.println(\"WARNING: Reads aligned past contig length on \"+ location.getContig()+\"; all such reads will be skipped\");\r\n                    outOfContigUserWarned = true;\r\n                }\r\n                return 0;\r\n            }\r\n\r\n            long alignmentEnd = read.getAlignmentEnd();\r\n            Cigar c = read.getCigar();\r\n            int lastNonClippedElement = 0; // reverse offset to the last unclipped element\r\n            CigarOperator op = null;\r\n            // moving backwards from the end of the cigar, skip trailing S or H cigar elements:\r\n            do {\r\n                lastNonClippedElement++;\r\n                op = c.getCigarElement( c.numCigarElements()-lastNonClippedElement ).getOperator();\r\n            } while ( op == CigarOperator.H || op == CigarOperator.S );\r\n\r\n            // now op is the last non-S/H operator in the cigar.\r\n\r\n            // a little trick here: we want to make sure that current read completely fits into the current\r\n            // window so that we can accumulate indel observations over the whole length of the read.\r\n            // The ::getAlignmentEnd() method returns the last position on the reference where bases from the\r\n            // read actually match (M cigar elements). After our cleaning procedure, we can have reads that end\r\n            // with I element, which is not gonna be counted into alignment length on the reference. On the other hand,\r\n            // in this program we assign insertions, internally, to the first base *after* the insertion position.\r\n            // Hence, we have to make sure that that extra base is already in the window or we will get IndexOutOfBounds.\r\n\r\n            if ( op == CigarOperator.I) alignmentEnd++;\r\n\r\n            if ( alignmentEnd > normal_context.getStop()) {\r\n\r\n                // we don't emit anything until we reach a read that does not fit into the current window.\r\n                // At that point we try shifting the window to the start of that read (or reasonably close) and emit everything prior to\r\n                // that position. This is legitimate, since the reads are sorted and  we are not gonna see any more coverage at positions\r\n                // below the current read's start.\r\n                // Clearly, we assume here that window is large enough to accomodate any single read, so simply shifting\r\n                // the window to around the read's start will ensure that the read fits...\r\n\r\n                if ( DEBUG) System.out.println(\"DEBUG>> Window at \"+normal_context.getStart()+\"-\"+normal_context.getStop()+\", read at \"+\r\n                                read.getAlignmentStart()+\": trying to emit and shift\" );\r\n                if ( call_somatic ) emit_somatic( read.getAlignmentStart(), false );\r\n                else emit( read.getAlignmentStart(), false );\r\n\r\n                // let's double check now that the read fits after the shift\r\n                if ( read.getAlignmentEnd() > normal_context.getStop()) {\r\n                    // ooops, looks like the read does not fit into the window even after the latter was shifted!!\r\n                    throw new UserException.BadArgumentValue(\"window_size\", \"Read \"+read.getReadName()+\": out of coverage window bounds. Probably window is too small, so increase the value of the window_size argument.\\n\"+\r\n                                             \"Read length=\"+read.getReadLength()+\"; cigar=\"+read.getCigarString()+\"; start=\"+\r\n                                             read.getAlignmentStart()+\"; end=\"+read.getAlignmentEnd()+\r\n                                             \"; window start (after trying to accomodate the read)=\"+normal_context.getStart()+\"; window end=\"+normal_context.getStop());\r\n                }\r\n            }\r\n\r\n            if ( call_somatic ) {\r\n\r\n                List<String> tags =  getToolkit().getReaderIDForRead(read).getTags();\r\n                boolean assigned = false;\r\n                for ( String s : tags ) {\r\n                    if ( \"NORMAL\".equals(s.toUpperCase()) ) {\r\n                        normal_context.add(read,ref.getBases());\r\n                        assigned = true;\r\n                        break;\r\n                    }\r\n                    if ( \"TUMOR\".equals(s.toUpperCase()) ) {\r\n                        tumor_context.add(read,ref.getBases());\r\n                        assigned = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if ( ! assigned )\r\n                    throw new StingException(\"Read \"+read.getReadName()+\" from \"+getToolkit().getSourceFileForReaderID(getToolkit().getReaderIDForRead(read))+\r\n                    \"has no Normal/Tumor tag associated with it\");\r\n\r\n//                String rg = (String)read.getAttribute(\"RG\");\r\n//                if ( rg == null )\r\n//                    throw new UserException.MalformedBam(read, \"Read \"+read.getReadName()+\" has no read group in merged stream. RG is required for somatic calls.\");\r\n\r\n//                if ( normalReadGroups.contains(rg) ) {\r\n//                    normal_context.add(read,ref.getBases());\r\n//                } else if ( tumorReadGroups.contains(rg) ) {\r\n//                    tumor_context.add(read,ref.getBases());\r\n//                } else {\r\n//                    throw new UserException.MalformedBam(read, \"Unrecognized read group in merged stream: \"+rg);\r\n//                }\r\n\r\n                if ( tumor_context.getReads().size() > MAX_READ_NUMBER ) {\r\n                    System.out.println(\"WARNING: a count of \"+MAX_READ_NUMBER+\" reads reached in a window \"+\r\n                            refName+':'+tumor_context.getStart()+'-'+tumor_context.getStop()+\" in tumor sample. The whole window will be dropped.\");\r\n                    tumor_context.shift(WINDOW_SIZE);\r\n                    normal_context.shift(WINDOW_SIZE);\r\n                }\r\n                if ( normal_context.getReads().size() > MAX_READ_NUMBER ) {\r\n                    System.out.println(\"WARNING: a count of \"+MAX_READ_NUMBER+\" reads reached in a window \"+\r\n                            refName+':'+normal_context.getStart()+'-'+normal_context.getStop()+\" in normal sample. The whole window will be dropped\");\r\n                    tumor_context.shift(WINDOW_SIZE);\r\n                    normal_context.shift(WINDOW_SIZE);\r\n                }\r\n\r\n\r\n            } else {\r\n                normal_context.add(read, ref.getBases());\r\n                if ( normal_context.getReads().size() > MAX_READ_NUMBER ) {\r\n                    System.out.println(\"WARNING: a count of \"+MAX_READ_NUMBER+\" reads reached in a window \"+\r\n                            refName+':'+normal_context.getStart()+'-'+normal_context.getStop()+\". The whole window will be dropped\");\r\n                    normal_context.shift(WINDOW_SIZE);\r\n                }\r\n            }\r\n\r\n            return 1;\r\n\t}","id":75601,"modified_method":"@Override\r\n\tpublic Integer map(ReferenceContext ref, SAMRecord read, ReadMetaDataTracker metaDataTracker) {\r\n\r\n    //        if ( read.getReadName().equals(\"428EFAAXX090610:2:36:1384:639#0\") ) System.out.println(\"GOT READ\");\r\n\r\n            if ( DEBUG ) {\r\n                //            System.out.println(\"DEBUG>> read at \"+ read.getAlignmentStart()+\"-\"+read.getAlignmentEnd()+\r\n                //                    \"(\"+read.getCigarString()+\")\");\r\n                if ( read.getDuplicateReadFlag() ) System.out.println(\"DEBUG>> Duplicated read (IGNORED)\");\r\n            }\r\n\r\n            if ( AlignmentUtils.isReadUnmapped(read) ||\r\n\t\t\t read.getDuplicateReadFlag() ||\r\n\t\t\t read.getNotPrimaryAlignmentFlag() ||\r\n\t\t\t read.getMappingQuality() == 0 ) {\r\n\t\t\treturn 0; // we do not need those reads!\r\n            }\r\n\r\n            if ( read.getReferenceIndex() != currentContigIndex ) {\r\n                // we just jumped onto a new contig\r\n                if ( DEBUG ) System.out.println(\"DEBUG>>> Moved to contig \"+read.getReferenceName());\r\n                if ( read.getReferenceIndex() < currentContigIndex ) // paranoidal\r\n                    throw new UserException.MissortedBAM(SAMFileHeader.SortOrder.coordinate, read, \"Read \"+read.getReadName()+\": contig is out of order; input BAM file is unsorted\");\r\n\r\n                // print remaining indels from the previous contig (if any);\r\n                if ( call_somatic ) emit_somatic(1000000000, true);\r\n                else emit(1000000000,true);\r\n\r\n                currentContigIndex = read.getReferenceIndex();\r\n                currentPosition = read.getAlignmentStart();\r\n                refName = new String(read.getReferenceName());\r\n\r\n                location = getToolkit().getGenomeLocParser().createGenomeLoc(refName,location.getStart(),location.getStop());\r\n                contigLength = getToolkit().getGenomeLocParser().getContigInfo(refName).getSequenceLength();\r\n                outOfContigUserWarned = false;\r\n\r\n                lastGenotypedPosition = -1;\r\n\r\n                normal_context.clear(); // reset coverage window; this will also set reference position to 0\r\n                if ( call_somatic) tumor_context.clear();\r\n\r\n                refBases = new String(refData.getReference().getSequence(read.getReferenceName()).getBases()).toUpperCase().getBytes();\r\n            }\r\n\r\n            // we have reset the window to the new contig if it was required and emitted everything we collected\r\n            // on a previous contig. At this point we are guaranteed that we are set up properly for working\r\n            // with the contig of the current read.\r\n\r\n            // NOTE: all the sanity checks and error messages below use normal_context only. We make sure that normal_context and\r\n            // tumor_context are synchronized exactly (windows are always shifted together by emit_somatic), so it's safe\r\n\r\n            if ( read.getAlignmentStart() < currentPosition ) // oops, read out of order?\r\n                throw new UserException.MissortedBAM(SAMFileHeader.SortOrder.coordinate, read, \"Read \"+read.getReadName() +\" out of order on the contig\\n\"+\r\n                        \"Read starts at \"+refName+\":\"+read.getAlignmentStart()+\"; last read seen started at \"+refName+\":\"+currentPosition\r\n                        +\"\\nLast read was: \"+lastRead.getReadName()+\" RG=\"+lastRead.getAttribute(\"RG\")+\" at \"+lastRead.getAlignmentStart()+\"-\"\r\n                        +lastRead.getAlignmentEnd()+\" cigar=\"+lastRead.getCigarString());\r\n\r\n            currentPosition = read.getAlignmentStart();\r\n            lastRead = read;\r\n\r\n            if ( read.getAlignmentEnd() > contigLength  ) {\r\n                if ( ! outOfContigUserWarned ) {\r\n                    System.out.println(\"WARNING: Reads aligned past contig length on \"+ location.getContig()+\"; all such reads will be skipped\");\r\n                    outOfContigUserWarned = true;\r\n                }\r\n                return 0;\r\n            }\r\n\r\n            long alignmentEnd = read.getAlignmentEnd();\r\n            Cigar c = read.getCigar();\r\n            int lastNonClippedElement = 0; // reverse offset to the last unclipped element\r\n            CigarOperator op = null;\r\n            // moving backwards from the end of the cigar, skip trailing S or H cigar elements:\r\n            do {\r\n                lastNonClippedElement++;\r\n                op = c.getCigarElement( c.numCigarElements()-lastNonClippedElement ).getOperator();\r\n            } while ( op == CigarOperator.H || op == CigarOperator.S );\r\n\r\n            // now op is the last non-S/H operator in the cigar.\r\n\r\n            // a little trick here: we want to make sure that current read completely fits into the current\r\n            // window so that we can accumulate indel observations over the whole length of the read.\r\n            // The ::getAlignmentEnd() method returns the last position on the reference where bases from the\r\n            // read actually match (M cigar elements). After our cleaning procedure, we can have reads that end\r\n            // with I element, which is not gonna be counted into alignment length on the reference. On the other hand,\r\n            // in this program we assign insertions, internally, to the first base *after* the insertion position.\r\n            // Hence, we have to make sure that that extra base is already in the window or we will get IndexOutOfBounds.\r\n\r\n            if ( op == CigarOperator.I) alignmentEnd++;\r\n\r\n            if ( alignmentEnd > normal_context.getStop()) {\r\n\r\n                // we don't emit anything until we reach a read that does not fit into the current window.\r\n                // At that point we try shifting the window to the start of that read (or reasonably close) and emit everything prior to\r\n                // that position. This is legitimate, since the reads are sorted and  we are not gonna see any more coverage at positions\r\n                // below the current read's start.\r\n                // Clearly, we assume here that window is large enough to accomodate any single read, so simply shifting\r\n                // the window to around the read's start will ensure that the read fits...\r\n\r\n                if ( DEBUG) System.out.println(\"DEBUG>> Window at \"+normal_context.getStart()+\"-\"+normal_context.getStop()+\", read at \"+\r\n                                read.getAlignmentStart()+\": trying to emit and shift\" );\r\n                if ( call_somatic ) emit_somatic( read.getAlignmentStart(), false );\r\n                else emit( read.getAlignmentStart(), false );\r\n\r\n                // let's double check now that the read fits after the shift\r\n                if ( read.getAlignmentEnd() > normal_context.getStop()) {\r\n                    // ooops, looks like the read does not fit into the window even after the latter was shifted!!\r\n                    throw new UserException.BadArgumentValue(\"window_size\", \"Read \"+read.getReadName()+\": out of coverage window bounds. Probably window is too small, so increase the value of the window_size argument.\\n\"+\r\n                                             \"Read length=\"+read.getReadLength()+\"; cigar=\"+read.getCigarString()+\"; start=\"+\r\n                                             read.getAlignmentStart()+\"; end=\"+read.getAlignmentEnd()+\r\n                                             \"; window start (after trying to accomodate the read)=\"+normal_context.getStart()+\"; window end=\"+normal_context.getStop());\r\n                }\r\n            }\r\n\r\n            if ( call_somatic ) {\r\n\r\n                List<String> tags =  getToolkit().getReaderIDForRead(read).getTags();\r\n                boolean assigned = false;\r\n                for ( String s : tags ) {\r\n                    if ( \"NORMAL\".equals(s.toUpperCase()) ) {\r\n                        normal_context.add(read,ref.getBases());\r\n                        assigned = true;\r\n                        break;\r\n                    }\r\n                    if ( \"TUMOR\".equals(s.toUpperCase()) ) {\r\n                        tumor_context.add(read,ref.getBases());\r\n                        assigned = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if ( ! assigned )\r\n                    throw new StingException(\"Read \"+read.getReadName()+\" from \"+getToolkit().getSourceFileForReaderID(getToolkit().getReaderIDForRead(read))+\r\n                    \"has no Normal/Tumor tag associated with it\");\r\n\r\n//                String rg = (String)read.getAttribute(\"RG\");\r\n//                if ( rg == null )\r\n//                    throw new UserException.MalformedBam(read, \"Read \"+read.getReadName()+\" has no read group in merged stream. RG is required for somatic calls.\");\r\n\r\n//                if ( normalReadGroups.contains(rg) ) {\r\n//                    normal_context.add(read,ref.getBases());\r\n//                } else if ( tumorReadGroups.contains(rg) ) {\r\n//                    tumor_context.add(read,ref.getBases());\r\n//                } else {\r\n//                    throw new UserException.MalformedBam(read, \"Unrecognized read group in merged stream: \"+rg);\r\n//                }\r\n\r\n                if ( tumor_context.getReads().size() > MAX_READ_NUMBER ) {\r\n                    System.out.println(\"WARNING: a count of \"+MAX_READ_NUMBER+\" reads reached in a window \"+\r\n                            refName+':'+tumor_context.getStart()+'-'+tumor_context.getStop()+\" in tumor sample. The whole window will be dropped.\");\r\n                    tumor_context.shift(WINDOW_SIZE);\r\n                    normal_context.shift(WINDOW_SIZE);\r\n                }\r\n                if ( normal_context.getReads().size() > MAX_READ_NUMBER ) {\r\n                    System.out.println(\"WARNING: a count of \"+MAX_READ_NUMBER+\" reads reached in a window \"+\r\n                            refName+':'+normal_context.getStart()+'-'+normal_context.getStop()+\" in normal sample. The whole window will be dropped\");\r\n                    tumor_context.shift(WINDOW_SIZE);\r\n                    normal_context.shift(WINDOW_SIZE);\r\n                }\r\n\r\n\r\n            } else {\r\n                normal_context.add(read, ref.getBases());\r\n                if ( normal_context.getReads().size() > MAX_READ_NUMBER ) {\r\n                    System.out.println(\"WARNING: a count of \"+MAX_READ_NUMBER+\" reads reached in a window \"+\r\n                            refName+':'+normal_context.getStart()+'-'+normal_context.getStop()+\". The whole window will be dropped\");\r\n                    normal_context.shift(WINDOW_SIZE);\r\n                }\r\n            }\r\n\r\n            return 1;\r\n\t}","commit_id":"68ce55148e01821feaa65e31d1f3c504e7b37171","url":"https://github.com/broadgsa/gatk"},{"original_method":"/** Output somatic indel calls up to the specified position and shift the coverage array(s): after this method is executed\r\n     * first elements of the coverage arrays map onto 'position', or a few bases prior to the specified position\r\n     * if there is an indel in close proximity to 'position' so that we may get more coverage around it later.\r\n     *\r\n     * @param position\r\n     */\r\n    private void emit_somatic(long position, boolean force) {\r\n\r\n        long adjustedPosition = adjustPosition(position);\r\n        if ( adjustedPosition == -1 ) {\r\n            // failed to find appropriate shift position, the data are probably to messy anyway so we drop them altogether\r\n            normal_context.shift((int)(position-normal_context.getStart()));\r\n            tumor_context.shift((int)(position-tumor_context.getStart()));\r\n            return;\r\n        }\r\n        long move_to = adjustedPosition;\r\n\r\n        if ( DEBUG ) System.out.println(\"DEBUG>> Emitting in somatic mode up to \"+position+\" force shift=\"+force+\" current window=\"+tumor_context.getStart()+\"-\"+tumor_context.getStop());\r\n\r\n        for ( int pos = tumor_context.getStart() ; pos < Math.min(adjustedPosition,tumor_context.getStop()+1) ; pos++ ) {\r\n\r\n            if ( tumor_context.indelsAt(pos).size() == 0 ) continue; // no indels in tumor\r\n\r\n            IndelPrecall tumorCall = new IndelPrecall(tumor_context,pos,NQS_WIDTH);\r\n            IndelPrecall normalCall = new IndelPrecall(normal_context,pos,NQS_WIDTH);\r\n\r\n            if ( tumorCall.getCoverage() < minCoverage ) {\r\n                if ( DEBUG ) {\r\n                    System.out.println(\"DEBUG>> Indel in tumor at \"+pos+\"; coverare in tumor=\"+tumorCall.getCoverage()+\" (SKIPPED)\");\r\n                }\r\n                continue; // low coverage\r\n            }\r\n            if ( normalCall.getCoverage() < minNormalCoverage ) {\r\n                if ( DEBUG ) {\r\n                    System.out.println(\"DEBUG>> Indel in tumor at \"+pos+\"; coverare in normal=\"+normalCall.getCoverage()+\" (SKIPPED)\");\r\n                }\r\n                continue; // low coverage\r\n            }\r\n\r\n            if ( DEBUG ) System.out.println(\"DEBUG>> Indel in tumor at \"+pos);\r\n\r\n            long left = Math.max( pos-NQS_WIDTH, tumor_context.getStart() );\r\n            long right = pos+tumorCall.getVariant().lengthOnRef()+NQS_WIDTH-1;\r\n\r\n            if ( right >= adjustedPosition && ! force) {\r\n                // we are not asked to force-shift, and there is more coverage around the current indel that we still need to collect\r\n\r\n                // we are not asked to force-shift, and there's still additional coverage to the right of current indel, so its too early to emit it;\r\n                // instead we shift only up to current indel pos - MISMATCH_WIDTH, so that we could keep collecting that coverage\r\n                move_to = adjustPosition(left);\r\n                if ( move_to == -1 ) {\r\n                    // failed to find appropriate shift position, the data are probably to messy anyway so we drop them altogether\r\n                    normal_context.shift((int)(adjustedPosition-normal_context.getStart()));\r\n                    tumor_context.shift((int)(adjustedPosition-tumor_context.getStart()));\r\n                    return;\r\n                }\r\n                if ( DEBUG ) System.out.println(\"DEBUG>> waiting for coverage; actual shift performed to \"+ move_to);\r\n                break;\r\n            }\r\n\r\n            if ( right > tumor_context.getStop() ) right = tumor_context.getStop(); // if indel is too close to the end of the window but we need to emit anyway (force-shift), adjust right\r\n\r\n            location = getToolkit().getGenomeLocParser().setStart(location,pos);\r\n            location = getToolkit().getGenomeLocParser().setStop(location,pos); // retrieve annotation data\r\n\r\n            if ( tumorCall.isCall() ) {\r\n                tumorCallsMade++;\r\n\r\n                printVCFLine(vcf_writer,normalCall,tumorCall);\r\n\r\n                if ( bedWriter != null ) tumorCall.printBedLine(bedWriter);\r\n\r\n                if ( verboseWriter != null ) {\r\n                    RODRecordList annotationList = (refseqIterator == null ? null : refseqIterator.seekForward(location));\r\n                    String annotationString = (refseqIterator == null ? \"\" : getAnnotationString(annotationList));\r\n\r\n                    StringBuilder fullRecord = new StringBuilder();\r\n                    fullRecord.append(makeFullRecord(normalCall,tumorCall));\r\n\r\n                    if ( normalCall.getVariant() == null ) {\r\n                        fullRecord.append(\"SOMATIC\");\r\n                    } else {\r\n                        fullRecord.append(\"GERMLINE\");\r\n                    }\r\n                    try {\r\n                        verboseWriter.write(fullRecord + \"\\t\"+ annotationString);\r\n                        verboseWriter.write('\\n');\r\n                    } catch (IOException e) {\r\n                        throw new UserException.CouldNotCreateOutputFile(verboseOutput, \"Write failed\", e);\r\n                    }\r\n                }\r\n            }\r\n            tumor_context.indelsAt(pos).clear();\r\n            normal_context.indelsAt(pos).clear();\r\n                // we dealt with this indel; don't want to see it again\r\n                // (we might otherwise in the case when 1) there is another indel that follows\r\n                // within MISMATCH_WIDTH bases and 2) we'd need to wait for more coverage for that next indel)\r\n\r\n//\t\t\tfor ( IndelVariant var : variants ) {\r\n//\t\t\t\tSystem.out.print(\"\\t\"+var.getType()+\"\\t\"+var.getBases()+\"\\t\"+var.getCount());\r\n//\t\t\t}\r\n        }\r\n\r\n        if ( DEBUG ) System.out.println(\"DEBUG>> Actual shift to \" + move_to + \" (\"+adjustedPosition+\")\");\r\n        tumor_context.shift((int)(move_to - tumor_context.getStart() ) );\r\n        normal_context.shift((int)(move_to - normal_context.getStart() ) );\r\n    }","id":75602,"modified_method":"/** Output somatic indel calls up to the specified position and shift the coverage array(s): after this method is executed\r\n     * first elements of the coverage arrays map onto 'position', or a few bases prior to the specified position\r\n     * if there is an indel in close proximity to 'position' so that we may get more coverage around it later.\r\n     *\r\n     * @param position\r\n     */\r\n    private void emit_somatic(long position, boolean force) {\r\n\r\n        long adjustedPosition = adjustPosition(position);\r\n        if ( adjustedPosition == -1 ) {\r\n            // failed to find appropriate shift position, the data are probably to messy anyway so we drop them altogether\r\n            normal_context.shift((int)(position-normal_context.getStart()));\r\n            tumor_context.shift((int)(position-tumor_context.getStart()));\r\n            return;\r\n        }\r\n        long move_to = adjustedPosition;\r\n\r\n        if ( DEBUG ) System.out.println(\"DEBUG>> Emitting in somatic mode up to \"+position+\" force shift=\"+force+\" current window=\"+tumor_context.getStart()+\"-\"+tumor_context.getStop());\r\n\r\n        for ( int pos = tumor_context.getStart() ; pos < Math.min(adjustedPosition,tumor_context.getStop()+1) ; pos++ ) {\r\n\r\n            boolean genotype = false;\r\n             // first let's see if we need to genotype current position:\r\n\r\n             final long p = pos - 1; // our internally used positions (pos) are +1 compared to external format spec (e.g. vcf)\r\n\r\n             if ( pos <= lastGenotypedPosition ) continue;\r\n\r\n             while ( currentGenotypeInterval != null ) {\r\n\r\n                 // if we did not even reach next interval yet, no genotyping at current position:\r\n                 if ( location.getContigIndex() < currentGenotypeInterval.getContigIndex() ||\r\n                      location.getContigIndex() == currentGenotypeInterval.getContigIndex() &&\r\n                              p < currentGenotypeInterval.getStart() ) break;\r\n                 if ( pastInterval(p, currentGenotypeInterval) ) {\r\n                     // we are past current genotyping interval, so we are done with it; let's load next interval:\r\n                     currentGenotypeInterval = genotypeIntervalIterator.hasNext() ? genotypeIntervalIterator.next() : null;\r\n                     continue; // re-enter the loop to check against the interval we just loaded\r\n                 }\r\n\r\n                 // we reach tjis point only if p is inside current genotyping interval; set the flag and bail out:\r\n                 genotype = true;\r\n                 break;\r\n             }\r\n//            if ( DEBUG) System.out.println(\"DEBUG>> pos=\"+pos +\"; genotyping interval=\"+currentGenotypeInterval+\"; genotype=\"+genotype);\r\n\r\n            if ( tumor_context.indelsAt(pos).size() == 0 && ! genotype ) continue; // no indels in tumor\r\n\r\n            if ( DEBUG && genotype ) System.out.println(\"DEBUG>> Genotyping requested at \"+pos);\r\n\r\n            IndelPrecall tumorCall = new IndelPrecall(tumor_context,pos,NQS_WIDTH);\r\n            IndelPrecall normalCall = new IndelPrecall(normal_context,pos,NQS_WIDTH);\r\n\r\n            if ( tumorCall.getCoverage() < minCoverage && ! genotype ) {\r\n                if ( DEBUG ) {\r\n                    System.out.println(\"DEBUG>> Indel in tumor at \"+pos+\"; coverare in tumor=\"+tumorCall.getCoverage()+\" (SKIPPED)\");\r\n                }\r\n                continue; // low coverage\r\n            }\r\n            if ( normalCall.getCoverage() < minNormalCoverage && ! genotype ) {\r\n                if ( DEBUG ) {\r\n                    System.out.println(\"DEBUG>> Indel in tumor at \"+pos+\"; coverare in normal=\"+normalCall.getCoverage()+\" (SKIPPED)\");\r\n                }\r\n                continue; // low coverage\r\n            }\r\n\r\n            if ( DEBUG ) {\r\n                System.out.print(\"DEBUG>> \"+(tumorCall.getAllVariantCount() == 0?\"No Indel\":\"Indel\")+\" in tumor, \");\r\n                System.out.print(\"DEBUG>> \"+(normalCall.getAllVariantCount() == 0?\"No Indel\":\"Indel\")+\" in normal at \"+pos);\r\n            }\r\n\r\n            long left = Math.max( pos-NQS_WIDTH, tumor_context.getStart() );\r\n            long right = pos+ ( tumorCall.getVariant() == null ? 0 : tumorCall.getVariant().lengthOnRef() )+NQS_WIDTH-1;\r\n\r\n            if ( right >= adjustedPosition && ! force) {\r\n                // we are not asked to force-shift, and there is more coverage around the current indel that we still need to collect\r\n\r\n                // we are not asked to force-shift, and there's still additional coverage to the right of current indel, so its too early to emit it;\r\n                // instead we shift only up to current indel pos - MISMATCH_WIDTH, so that we could keep collecting that coverage\r\n                move_to = adjustPosition(left);\r\n                if ( move_to == -1 ) {\r\n                    // failed to find appropriate shift position, the data are probably to messy anyway so we drop them altogether\r\n                    normal_context.shift((int)(adjustedPosition-normal_context.getStart()));\r\n                    tumor_context.shift((int)(adjustedPosition-tumor_context.getStart()));\r\n                    return;\r\n                }\r\n                if ( DEBUG ) System.out.println(\"DEBUG>> waiting for coverage; actual shift performed to \"+ move_to);\r\n                break;\r\n            }\r\n\r\n            if ( right > tumor_context.getStop() ) right = tumor_context.getStop(); // if indel is too close to the end of the window but we need to emit anyway (force-shift), adjust right\r\n\r\n            location = getToolkit().getGenomeLocParser().setStart(location,pos);\r\n            location = getToolkit().getGenomeLocParser().setStop(location,pos); // retrieve annotation data\r\n\r\n            boolean haveCall = tumorCall.isCall(); // cache the value\r\n\r\n            if ( haveCall || genotype ) {\r\n                if ( haveCall ) tumorCallsMade++;\r\n\r\n                printVCFLine(vcf_writer,normalCall,tumorCall);\r\n\r\n                if ( bedWriter != null ) tumorCall.printBedLine(bedWriter);\r\n\r\n                if ( verboseWriter != null ) printVerboseLine(verboseWriter, normalCall, tumorCall );\r\n                lastGenotypedPosition = pos;\r\n            }\r\n            tumor_context.indelsAt(pos).clear();\r\n            normal_context.indelsAt(pos).clear();\r\n                // we dealt with this indel; don't want to see it again\r\n                // (we might otherwise in the case when 1) there is another indel that follows\r\n                // within MISMATCH_WIDTH bases and 2) we'd need to wait for more coverage for that next indel)\r\n\r\n//\t\t\tfor ( IndelVariant var : variants ) {\r\n//\t\t\t\tSystem.out.print(\"\\t\"+var.getType()+\"\\t\"+var.getBases()+\"\\t\"+var.getCount());\r\n//\t\t\t}\r\n        }\r\n\r\n        if ( DEBUG ) System.out.println(\"DEBUG>> Actual shift to \" + move_to + \" (\"+adjustedPosition+\")\");\r\n        tumor_context.shift((int)(move_to - tumor_context.getStart() ) );\r\n        normal_context.shift((int)(move_to - normal_context.getStart() ) );\r\n    }","commit_id":"68ce55148e01821feaa65e31d1f3c504e7b37171","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected void removeCluster() throws IOException {\n    setDataCommandInfo(\"Remove cluster\");\n\n    checkDatabase();\n\n    final int id = channel.readShort();\n\n    boolean result = connection.database.dropCluster(connection.database.getClusterNameById(id));\n\n    beginResponse();\n    try {\n      sendOk(clientTxId);\n      channel.writeByte((byte) (result ? 1 : 0));\n    } finally {\n      endResponse();\n    }\n  }","id":75603,"modified_method":"protected void removeCluster() throws IOException {\n    setDataCommandInfo(\"Remove cluster\");\n\n    checkDatabase();\n\n    final int id = channel.readShort();\n\n    final String clusterName = connection.database.getClusterNameById(id);\n    if (clusterName == null)\n      throw new IllegalArgumentException(\"Cluster \" + id + \" doesn't exist anymore. Refresh the db structure or just reconnect to the database\");\n\n    boolean result = connection.database.dropCluster(clusterName);\n\n    beginResponse();\n    try {\n      sendOk(clientTxId);\n      channel.writeByte((byte) (result ? 1 : 0));\n    } finally {\n      endResponse();\n    }\n  }","commit_id":"c3264fb838725602a58474b88570ca0644f4f99e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected Set<String> getInvolvedClustersOfIndex(final String iIndexName) {\r\n    final ODatabaseDocumentInternal db = getDatabase();\r\n\r\n    final Set<String> clusters = new HashSet<String>();\r\n\r\n    final OMetadataInternal metadata = (OMetadataInternal) db.getMetadata();\r\n    final OIndex<?> idx = metadata.getIndexManager().getIndex(iIndexName);\r\n    if (idx != null) {\r\n      final String clazz = idx.getDefinition().getClassName();\r\n\r\n      if (clazz != null) {\r\n        final OClass cls = metadata.getImmutableSchemaSnapshot().getClass(clazz);\r\n        if (cls != null)\r\n          for (int clId : cls.getClusterIds()) {\r\n            clusters.add(db.getClusterNameById(clId).toLowerCase());\r\n          }\r\n      }\r\n    }\r\n\r\n    return clusters;\r\n  }","id":75604,"modified_method":"protected Set<String> getInvolvedClustersOfIndex(final String iIndexName) {\r\n    final ODatabaseDocumentInternal db = getDatabase();\r\n\r\n    final Set<String> clusters = new HashSet<String>();\r\n\r\n    final OMetadataInternal metadata = (OMetadataInternal) db.getMetadata();\r\n    final OIndex<?> idx = metadata.getIndexManager().getIndex(iIndexName);\r\n    if (idx != null) {\r\n      final String clazz = idx.getDefinition().getClassName();\r\n\r\n      if (clazz != null) {\r\n        final OClass cls = metadata.getImmutableSchemaSnapshot().getClass(clazz);\r\n        if (cls != null)\r\n          for (int clId : cls.getClusterIds()) {\r\n            final String clName = db.getClusterNameById(clId);\r\n            if (clName != null)\r\n              clusters.add(clName.toLowerCase());\r\n          }\r\n      }\r\n    }\r\n\r\n    return clusters;\r\n  }","commit_id":"7628ea992ff594079e3610d3ec4ec428e5d57da7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected Set<String> getInvolvedClustersOfIndex(final String iIndexName) {\r\n    final ODatabaseDocumentInternal db = getDatabase();\r\n\r\n    final Set<String> clusters = new HashSet<String>();\r\n\r\n    final OMetadataInternal metadata = (OMetadataInternal) db.getMetadata();\r\n    final OIndex<?> idx = metadata.getIndexManager().getIndex(iIndexName);\r\n    if (idx != null) {\r\n      final String clazz = idx.getDefinition().getClassName();\r\n\r\n      if (clazz != null) {\r\n        final OClass cls = metadata.getImmutableSchemaSnapshot().getClass(clazz);\r\n        if (cls != null)\r\n          for (int clId : cls.getClusterIds()) {\r\n            clusters.add(db.getClusterNameById(clId).toLowerCase());\r\n          }\r\n      }\r\n    }\r\n\r\n    return clusters;\r\n  }","id":75605,"modified_method":"protected Set<String> getInvolvedClustersOfIndex(final String iIndexName) {\r\n    final ODatabaseDocumentInternal db = getDatabase();\r\n\r\n    final Set<String> clusters = new HashSet<String>();\r\n\r\n    final OMetadataInternal metadata = (OMetadataInternal) db.getMetadata();\r\n    final OIndex<?> idx = metadata.getIndexManager().getIndex(iIndexName);\r\n    if (idx != null) {\r\n      final String clazz = idx.getDefinition().getClassName();\r\n\r\n      if (clazz != null) {\r\n        final OClass cls = metadata.getImmutableSchemaSnapshot().getClass(clazz);\r\n        if (cls != null)\r\n          for (int clId : cls.getClusterIds()) {\r\n            final String clName = db.getClusterNameById(clId);\r\n            if (clName != null)\r\n              clusters.add(clName.toLowerCase());\r\n          }\r\n      }\r\n    }\r\n\r\n    return clusters;\r\n  }","commit_id":"e3204d710da982c46b43772156c596ce1c1b9bb2","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public void execute(@NotNull Editor originalEditor, char charTyped, @NotNull DataContext dataContext) {\n    final Project project = CommonDataKeys.PROJECT.getData(dataContext);\n    PsiFile file;\n\n    if (project == null\n        || (file = PsiUtilBase.getPsiFileInEditor(originalEditor, project)) == null\n        || !CodeInsightUtilBase.prepareEditorForWrite(originalEditor)\n        || !FileDocumentManager.getInstance().requestWriting(originalEditor.getDocument(), project)) {\n      if (myOriginalHandler != null){\n        myOriginalHandler.execute(originalEditor, charTyped, dataContext);\n      }\n      return;\n    }\n\n    CompletionPhase oldPhase = CompletionServiceImpl.getCompletionPhase();\n    if (oldPhase instanceof CompletionPhase.CommittingDocuments && ((CompletionPhase.CommittingDocuments)oldPhase).isRestartingCompletion()) {\n      assert oldPhase.indicator != null;\n      oldPhase.indicator.scheduleRestart();\n    }\n\n    Editor editor = TypedHandler.injectedEditorIfCharTypedIsSignificant(charTyped, originalEditor, file);\n    if (editor != originalEditor) {\n      file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n    }\n\n    if (originalEditor.isInsertMode() && beforeCharTyped(charTyped, project, originalEditor, editor, file)) {\n      return;\n    }\n\n    if (myOriginalHandler != null) {\n      myOriginalHandler.execute(originalEditor, charTyped, dataContext);\n    }\n  }","id":75606,"modified_method":"@Override\n  public void execute(@NotNull Editor originalEditor, char charTyped, @NotNull DataContext dataContext) {\n    final Project project = CommonDataKeys.PROJECT.getData(dataContext);\n    PsiFile file = project == null ? null : PsiUtilBase.getPsiFileInEditor(originalEditor, project);\n\n    if (file == null) {\n      if (myOriginalHandler != null){\n        myOriginalHandler.execute(originalEditor, charTyped, dataContext);\n      }\n      return;\n    }\n\n    if (!CodeInsightUtilBase.prepareEditorForWrite(originalEditor) || !FileDocumentManager.getInstance().requestWriting(originalEditor.getDocument(), project)) {\n      return;\n    }\n\n    CompletionPhase oldPhase = CompletionServiceImpl.getCompletionPhase();\n    if (oldPhase instanceof CompletionPhase.CommittingDocuments && ((CompletionPhase.CommittingDocuments)oldPhase).isRestartingCompletion()) {\n      assert oldPhase.indicator != null;\n      oldPhase.indicator.scheduleRestart();\n    }\n\n    Editor editor = TypedHandler.injectedEditorIfCharTypedIsSignificant(charTyped, originalEditor, file);\n    if (editor != originalEditor) {\n      file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n    }\n\n    if (originalEditor.isInsertMode() && beforeCharTyped(charTyped, project, originalEditor, editor, file)) {\n      return;\n    }\n\n    if (myOriginalHandler != null) {\n      myOriginalHandler.execute(originalEditor, charTyped, dataContext);\n    }\n  }","commit_id":"ca6951a3bc613094f508483834433d22cc5c8e06","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setText(final String bytecode, PsiElement element) {\n    int offset = 0;\n    PsiFile psiFile = element.getContainingFile();\n    final Document document = PsiDocumentManager.getInstance(element.getProject()).getDocument(psiFile);\n    if (document != null) {\n      int lineNumber = document.getLineNumber(element.getTextOffset());\n      VirtualFile file = psiFile.getVirtualFile();\n      if (file != null) {\n        LineNumbersMapping mapping = file.getUserData(LineNumbersMapping.LINE_NUMBERS_MAPPING_KEY);\n        if (mapping != null) {\n          int mappedLine = mapping.sourceToBytecode(lineNumber);\n          while (mappedLine == -1 && lineNumber < document.getLineCount()) {\n            mappedLine = mapping.sourceToBytecode(++lineNumber);\n          }\n          if (mappedLine > 0) {\n            lineNumber = mappedLine;\n          }\n        }\n      }\n      offset = bytecode.indexOf(\"LINENUMBER \" + lineNumber);\n      while (offset == -1 && lineNumber < document.getLineCount()) {\n        offset = bytecode.indexOf(\"LINENUMBER \" + (lineNumber++));\n      }\n    }\n    setText(bytecode, Math.max(0, offset));\n  }","id":75607,"modified_method":"public void setText(final String bytecode, PsiElement element) {\n    int offset = 0;\n    VirtualFile file = PsiUtilCore.getVirtualFile(element);\n    if (file != null) {\n      final Document document = FileDocumentManager.getInstance().getDocument(file);\n      if (document != null) {\n        int lineNumber = document.getLineNumber(element.getTextOffset());\n        LineNumbersMapping mapping = file.getUserData(LineNumbersMapping.LINE_NUMBERS_MAPPING_KEY);\n        if (mapping != null) {\n          int mappedLine = mapping.sourceToBytecode(lineNumber);\n          while (mappedLine == -1 && lineNumber < document.getLineCount()) {\n            mappedLine = mapping.sourceToBytecode(++lineNumber);\n          }\n          if (mappedLine > 0) {\n            lineNumber = mappedLine;\n          }\n        }\n        offset = bytecode.indexOf(\"LINENUMBER \" + lineNumber);\n        while (offset == -1 && lineNumber < document.getLineCount()) {\n          offset = bytecode.indexOf(\"LINENUMBER \" + (lineNumber++));\n        }\n      }\n    }\n    setText(bytecode, Math.max(0, offset));\n  }","commit_id":"0ace3c53306e11df893878918f38b46ecf8557f7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PsiElement getPsiElement(DataContext dataContext, Project project, Editor editor) {\n    PsiElement psiElement = null;\n    if (editor == null) {\n      psiElement = dataContext.getData(CommonDataKeys.PSI_ELEMENT);\n    } else {\n      final PsiFile file = PsiUtilBase.getPsiFileInEditor(editor, project);\n      final Editor injectedEditor = InjectedLanguageUtil.getEditorForInjectedLanguageNoCommit(editor, file);\n      if (injectedEditor != null) {\n        PsiFile psiFile = PsiUtilBase.getPsiFileInEditor(injectedEditor, project);\n        psiElement = psiFile != null ? psiFile.findElementAt(injectedEditor.getCaretModel().getOffset()) : null;\n      }\n\n      if (file != null && psiElement == null) {\n        psiElement = file.findElementAt(editor.getCaretModel().getOffset());\n      }\n    }\n\n    return psiElement;\n  }","id":75608,"modified_method":"@Nullable\n  private static PsiElement getPsiElement(DataContext dataContext, Project project, Editor editor) {\n    PsiElement psiElement = null;\n    if (editor == null) {\n      psiElement = dataContext.getData(CommonDataKeys.PSI_ELEMENT);\n    } else {\n      final PsiFile file = PsiUtilBase.getPsiFileInEditor(editor, project);\n      final Editor injectedEditor = InjectedLanguageUtil.getEditorForInjectedLanguageNoCommit(editor, file);\n      if (injectedEditor != null) {\n        psiElement = findElementInFile(PsiUtilBase.getPsiFileInEditor(injectedEditor, project), injectedEditor);\n      }\n\n      if (file != null && psiElement == null) {\n        psiElement = findElementInFile(file, editor);\n      }\n    }\n\n    return psiElement;\n  }","commit_id":"0ace3c53306e11df893878918f38b46ecf8557f7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void executeWriteAction(Editor editor, DataContext dataContext) {\n      MacUIUtil.hideCursor();\n      CommandProcessor.getInstance().setCurrentCommandGroupId(EditorActionUtil.DELETE_COMMAND_GROUP);\n      final SelectionModel selectionModel = editor.getSelectionModel();\n      if (selectionModel.hasBlockSelection()) {\n        final LogicalPosition start = selectionModel.getBlockStart();\n        final LogicalPosition end = selectionModel.getBlockEnd();\n        int column = Math.min(start.column, end.column);\n        int startLine = Math.min(start.line, end.line);\n        int endLine = Math.max(start.line, end.line);\n        EditorModificationUtil.deleteBlockSelection(editor);\n        if (column > 0 && start.column == end.column) {\n          for (int i = startLine; i <= endLine; i++) {\n            editor.getCaretModel().moveToLogicalPosition(new LogicalPosition(i, column));\n            doBackSpaceAtCaret(editor);\n          }\n          column--;\n        }\n        final int newColumn = Math.max(column, 0);\n        selectionModel.setBlockSelection(new LogicalPosition(startLine, newColumn), new LogicalPosition(endLine, newColumn));\n        return;\n      }\n\n      doBackSpaceAtCaret(editor);\n    }","id":75609,"modified_method":"@Override\n    public void executeWriteAction(Editor editor, DataContext dataContext) {\n      MacUIUtil.hideCursor();\n      CommandProcessor.getInstance().setCurrentCommandGroupId(EditorActionUtil.DELETE_COMMAND_GROUP);\n      if (editor instanceof EditorWindow) {\n        // manipulate actual document/editor instead of injected\n        // since the latter have trouble finding the right location of caret movement in the case of multi-shred injected fragments\n        editor = ((EditorWindow)editor).getDelegate();\n      }\n      final SelectionModel selectionModel = editor.getSelectionModel();\n      if (selectionModel.hasBlockSelection()) {\n        final LogicalPosition start = selectionModel.getBlockStart();\n        final LogicalPosition end = selectionModel.getBlockEnd();\n        int column = Math.min(start.column, end.column);\n        int startLine = Math.min(start.line, end.line);\n        int endLine = Math.max(start.line, end.line);\n        EditorModificationUtil.deleteBlockSelection(editor);\n        if (column > 0 && start.column == end.column) {\n          for (int i = startLine; i <= endLine; i++) {\n            editor.getCaretModel().moveToLogicalPosition(new LogicalPosition(i, column));\n            doBackSpaceAtCaret(editor);\n          }\n          column--;\n        }\n        final int newColumn = Math.max(column, 0);\n        selectionModel.setBlockSelection(new LogicalPosition(startLine, newColumn), new LogicalPosition(endLine, newColumn));\n        return;\n      }\n\n      doBackSpaceAtCaret(editor);\n    }","commit_id":"bb9dfbfdc5f2ad89e8f14d59f8f873ea42b3c929","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void doBackSpaceAtCaret(Editor editor) {\n    if(editor.getSelectionModel().hasSelection()) {\n      int newOffset = editor.getSelectionModel().getSelectionStart();\n      if (EditorActionUtil.canEditAtOffset(editor, newOffset)) {\n        editor.getCaretModel().moveToOffset(newOffset);\n        editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n        EditorModificationUtil.deleteSelectedText(editor);\n      }\n      return;\n    }\n\n    int lineNumber = editor.getCaretModel().getLogicalPosition().line;\n    int colNumber = editor.getCaretModel().getLogicalPosition().column;\n    Document document = editor.getDocument();\n    int offset = editor.getCaretModel().getOffset();\n    if(colNumber > 0) {\n      if(EditorModificationUtil.calcAfterLineEnd(editor) > 0) {\n        int columnShift = -1;\n        if (EditorActionUtil.canEditAtOffset(editor, offset - 1)) {\n          editor.getCaretModel().moveCaretRelatively(columnShift, 0, false, false, true);\n        }\n      }\n      else {\n\n        editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n        editor.getSelectionModel().removeSelection();\n\n        FoldRegion region = editor.getFoldingModel().getCollapsedRegionAtOffset(offset - 1);\n        if (region != null && region.shouldNeverExpand()) {\n          if (EditorActionUtil.canEditAtOffset(editor, region.getStartOffset())) {\n            document.deleteString(region.getStartOffset(), region.getEndOffset());\n            editor.getCaretModel().moveToOffset(region.getStartOffset());\n          }\n        }\n        else {\n          if (EditorActionUtil.canEditAtOffset(editor, offset - 1)) {\n           document.deleteString(offset - 1, offset);\n           editor.getCaretModel().moveToOffset(offset - 1, true);\n          }\n        }\n      }\n    }\n    else if(lineNumber > 0) {\n      int separatorLength = document.getLineSeparatorLength(lineNumber - 1);\n      int lineEnd = document.getLineEndOffset(lineNumber - 1) + separatorLength;\n      if (EditorActionUtil.canEditAtOffset(editor, lineEnd - separatorLength)) {\n        document.deleteString(lineEnd - separatorLength, lineEnd);\n        editor.getCaretModel().moveToOffset(lineEnd - separatorLength);\n        editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n        editor.getSelectionModel().removeSelection();\n        // Do not group delete newline and other deletions.\n        CommandProcessor commandProcessor = CommandProcessor.getInstance();\n        commandProcessor.setCurrentCommandGroupId(null);\n      }\n    }\n  }","id":75610,"modified_method":"private static void doBackSpaceAtCaret(@NotNull Editor editor) {\n    if(editor.getSelectionModel().hasSelection()) {\n      int newOffset = editor.getSelectionModel().getSelectionStart();\n      if (EditorActionUtil.canEditAtOffset(editor, newOffset)) {\n        editor.getCaretModel().moveToOffset(newOffset);\n        editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n        EditorModificationUtil.deleteSelectedText(editor);\n      }\n      return;\n    }\n\n    int lineNumber = editor.getCaretModel().getLogicalPosition().line;\n    int colNumber = editor.getCaretModel().getLogicalPosition().column;\n    Document document = editor.getDocument();\n    int offset = editor.getCaretModel().getOffset();\n    if(colNumber > 0) {\n      if(EditorModificationUtil.calcAfterLineEnd(editor) > 0) {\n        if (EditorActionUtil.canEditAtOffset(editor, offset - 1)) {\n          int columnShift = -1;\n          editor.getCaretModel().moveCaretRelatively(columnShift, 0, false, false, true);\n        }\n      }\n      else {\n        editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n        editor.getSelectionModel().removeSelection();\n\n        FoldRegion region = editor.getFoldingModel().getCollapsedRegionAtOffset(offset - 1);\n        if (region != null && region.shouldNeverExpand()) {\n          if (EditorActionUtil.canEditAtOffset(editor, region.getStartOffset())) {\n            document.deleteString(region.getStartOffset(), region.getEndOffset());\n            editor.getCaretModel().moveToOffset(region.getStartOffset());\n          }\n        }\n        else {\n          if (EditorActionUtil.canEditAtOffset(editor, offset - 1)) {\n           document.deleteString(offset - 1, offset);\n           editor.getCaretModel().moveToOffset(offset - 1, true);\n          }\n        }\n      }\n    }\n    else if(lineNumber > 0) {\n      int separatorLength = document.getLineSeparatorLength(lineNumber - 1);\n      int lineEnd = document.getLineEndOffset(lineNumber - 1) + separatorLength;\n      if (EditorActionUtil.canEditAtOffset(editor, lineEnd - separatorLength)) {\n        document.deleteString(lineEnd - separatorLength, lineEnd);\n        editor.getCaretModel().moveToOffset(lineEnd - separatorLength);\n        editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n        editor.getSelectionModel().removeSelection();\n        // Do not group delete newline and other deletions.\n        CommandProcessor commandProcessor = CommandProcessor.getInstance();\n        commandProcessor.setCurrentCommandGroupId(null);\n      }\n    }\n  }","commit_id":"bb9dfbfdc5f2ad89e8f14d59f8f873ea42b3c929","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected boolean handleBackspace(Editor editor, DataContext dataContext, boolean toWordStart) {\n    Project project = CommonDataKeys.PROJECT.getData(dataContext);\n    if (project == null) return false;\n\n    PsiFile file = PsiUtilBase.getPsiFileInEditor(editor, project);\n\n    if (file == null) return false;\n\n    if (editor.getSelectionModel().hasSelection()) return false;\n\n    int offset = editor.getCaretModel().getOffset() - 1;\n    if (offset < 0) return false;\n    CharSequence chars = editor.getDocument().getCharsSequence();\n    char c = chars.charAt(offset);\n\n    final Editor injectedEditor = TypedHandler.injectedEditorIfCharTypedIsSignificant(c, editor, file);\n    if (injectedEditor != editor) {\n      int injectedOffset = injectedEditor.getCaretModel().getOffset();\n      if (isOffsetInsideInjected(injectedEditor, injectedOffset)) {\n        file = PsiDocumentManager.getInstance(project).getPsiFile(injectedEditor.getDocument());\n        editor = injectedEditor;\n        offset = injectedOffset - 1;\n      }\n    }\n\n    final BackspaceHandlerDelegate[] delegates = Extensions.getExtensions(BackspaceHandlerDelegate.EP_NAME);\n    if (!toWordStart) {\n      for(BackspaceHandlerDelegate delegate: delegates) {\n        delegate.beforeCharDeleted(c, file, editor);\n      }\n    }\n\n    FileType fileType = file.getFileType();\n    final QuoteHandler quoteHandler = TypedHandler.getQuoteHandler(file, editor);\n\n    HighlighterIterator hiterator = ((EditorEx)editor).getHighlighter().createIterator(offset);\n    boolean wasClosingQuote = quoteHandler != null && quoteHandler.isClosingQuote(hiterator, offset);\n\n    myOriginalHandler.execute(editor, dataContext);\n\n    if (!toWordStart) {\n      for(BackspaceHandlerDelegate delegate: delegates) {\n        if (delegate.charDeleted(c, file, editor)) {\n          return true;\n        }\n      }\n    }\n\n    if (offset >= editor.getDocument().getTextLength()) return true;\n\n    chars = editor.getDocument().getCharsSequence();\n    if (c == '(' || c == '[' || c == '{'){\n      char c1 = chars.charAt(offset);\n      if (c == '(' && c1 != ')') return true;\n      if (c == '[' && c1 != ']') return true;\n      if (c == '{' && c1 != '}') return true;\n\n      HighlighterIterator iterator = ((EditorEx)editor).getHighlighter().createIterator(offset);\n      BraceMatcher braceMatcher = BraceMatchingUtil.getBraceMatcher(fileType, iterator);\n      if (!braceMatcher.isLBraceToken(iterator, chars, fileType) &&\n          !braceMatcher.isRBraceToken(iterator, chars, fileType)\n          ) {\n        return true;\n      }\n\n      int rparenOffset = BraceMatchingUtil.findRightmostRParen(iterator, iterator.getTokenType() ,chars,fileType);\n      if (rparenOffset >= 0){\n        iterator = ((EditorEx)editor).getHighlighter().createIterator(rparenOffset);\n        boolean matched = BraceMatchingUtil.matchBrace(chars, fileType, iterator, false);\n        if (matched) return true;\n      }\n\n      editor.getDocument().deleteString(offset, offset + 1);\n    }\n    else if (c == '\"' || c == '\\'' || c == '`'){\n      char c1 = chars.charAt(offset);\n      if (c1 != c) return true;\n      if (wasClosingQuote) return true;\n\n      HighlighterIterator iterator = ((EditorEx)editor).getHighlighter().createIterator(offset);\n      if (quoteHandler == null || !quoteHandler.isOpeningQuote(iterator,offset)) return true;\n\n      editor.getDocument().deleteString(offset, offset + 1);\n    }\n\n    return true;\n  }","id":75611,"modified_method":"protected boolean handleBackspace(Editor editor, DataContext dataContext, boolean toWordStart) {\n    Project project = CommonDataKeys.PROJECT.getData(dataContext);\n    if (project == null) return false;\n\n    PsiFile file = PsiUtilBase.getPsiFileInEditor(editor, project);\n\n    if (file == null) return false;\n\n    if (editor.getSelectionModel().hasSelection()) return false;\n\n    int offset = editor.getCaretModel().getOffset() - 1;\n    if (offset < 0) return false;\n    CharSequence chars = editor.getDocument().getCharsSequence();\n    char c = chars.charAt(offset);\n\n    final Editor injectedEditor = TypedHandler.injectedEditorIfCharTypedIsSignificant(c, editor, file);\n    final Editor originalEditor = editor;\n    if (injectedEditor != editor) {\n      int injectedOffset = injectedEditor.getCaretModel().getOffset();\n      if (isOffsetInsideInjected(injectedEditor, injectedOffset)) {\n        file = PsiDocumentManager.getInstance(project).getPsiFile(injectedEditor.getDocument());\n        editor = injectedEditor;\n        offset = injectedOffset - 1;\n      }\n    }\n\n    final BackspaceHandlerDelegate[] delegates = Extensions.getExtensions(BackspaceHandlerDelegate.EP_NAME);\n    if (!toWordStart) {\n      for(BackspaceHandlerDelegate delegate: delegates) {\n        delegate.beforeCharDeleted(c, file, editor);\n      }\n    }\n\n    FileType fileType = file.getFileType();\n    final QuoteHandler quoteHandler = TypedHandler.getQuoteHandler(file, editor);\n\n    HighlighterIterator hiterator = ((EditorEx)editor).getHighlighter().createIterator(offset);\n    boolean wasClosingQuote = quoteHandler != null && quoteHandler.isClosingQuote(hiterator, offset);\n\n    myOriginalHandler.execute(originalEditor, dataContext);\n\n    if (!toWordStart) {\n      for(BackspaceHandlerDelegate delegate: delegates) {\n        if (delegate.charDeleted(c, file, editor)) {\n          return true;\n        }\n      }\n    }\n\n    if (offset >= editor.getDocument().getTextLength()) return true;\n\n    chars = editor.getDocument().getCharsSequence();\n    if (c == '(' || c == '[' || c == '{'){\n      char c1 = chars.charAt(offset);\n      if (c == '(' && c1 != ')') return true;\n      if (c == '[' && c1 != ']') return true;\n      if (c == '{' && c1 != '}') return true;\n\n      HighlighterIterator iterator = ((EditorEx)editor).getHighlighter().createIterator(offset);\n      BraceMatcher braceMatcher = BraceMatchingUtil.getBraceMatcher(fileType, iterator);\n      if (!braceMatcher.isLBraceToken(iterator, chars, fileType) &&\n          !braceMatcher.isRBraceToken(iterator, chars, fileType)\n          ) {\n        return true;\n      }\n\n      int rparenOffset = BraceMatchingUtil.findRightmostRParen(iterator, iterator.getTokenType() ,chars,fileType);\n      if (rparenOffset >= 0){\n        iterator = ((EditorEx)editor).getHighlighter().createIterator(rparenOffset);\n        boolean matched = BraceMatchingUtil.matchBrace(chars, fileType, iterator, false);\n        if (matched) return true;\n      }\n\n      editor.getDocument().deleteString(offset, offset + 1);\n    }\n    else if (c == '\"' || c == '\\'' || c == '`'){\n      char c1 = chars.charAt(offset);\n      if (c1 != c) return true;\n      if (wasClosingQuote) return true;\n\n      HighlighterIterator iterator = ((EditorEx)editor).getHighlighter().createIterator(offset);\n      if (quoteHandler == null || !quoteHandler.isOpeningQuote(iterator,offset)) return true;\n\n      editor.getDocument().deleteString(offset, offset + 1);\n    }\n\n    return true;\n  }","commit_id":"bb9dfbfdc5f2ad89e8f14d59f8f873ea42b3c929","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void execute(@NotNull Editor editor, char charTyped, @NotNull DataContext dataContext) {\n    Project project = CommonDataKeys.PROJECT.getData(dataContext);\n    if (project == null || editor.isColumnMode()){\n      if (myOriginalHandler != null){\n        myOriginalHandler.execute(editor, charTyped, dataContext);\n      }\n      return;\n    }\n\n    PsiFile file = PsiUtilBase.getPsiFileInEditor(editor, project);\n\n    if (file == null){\n      if (myOriginalHandler != null){\n        myOriginalHandler.execute(editor, charTyped, dataContext);\n      }\n      return;\n    }\n\n    if (!CodeInsightUtilBase.prepareEditorForWrite(editor)) return;\n    if (!FileDocumentManager.getInstance().requestWriting(editor.getDocument(), project)) {\n       return;\n    }\n\n    Editor injectedEditor = injectedEditorIfCharTypedIsSignificant(charTyped, editor, file);\n    if (injectedEditor != editor) {\n      file = PsiDocumentManager.getInstance(project).getPsiFile(injectedEditor.getDocument());\n      editor = injectedEditor;\n    }\n\n    final TypedHandlerDelegate[] delegates = Extensions.getExtensions(TypedHandlerDelegate.EP_NAME);\n\n    boolean handled = false;\n    for(TypedHandlerDelegate delegate: delegates) {\n      final TypedHandlerDelegate.Result result = delegate.checkAutoPopup(charTyped, project, editor, file);\n      handled = result == TypedHandlerDelegate.Result.STOP;\n      if (result != TypedHandlerDelegate.Result.CONTINUE) {\n        break;\n      }\n    }\n\n    if (!handled) {\n      autoPopupCompletion(editor, charTyped, project, file);\n      autoPopupParameterInfo(editor, charTyped, project, file);\n    }\n\n    if (!editor.isInsertMode()){\n      myOriginalHandler.execute(editor, charTyped, dataContext);\n      return;\n    }\n\n    if (editor.getSelectionModel().hasSelection()){\n      EditorModificationUtil.deleteSelectedText(editor);\n    }\n\n    FileType fileType = getFileType(file, editor);\n\n    for(TypedHandlerDelegate delegate: delegates) {\n      final TypedHandlerDelegate.Result result = delegate.beforeCharTyped(charTyped, project, editor, file, fileType);\n      if (result == TypedHandlerDelegate.Result.STOP) {\n        return;\n      }\n      if (result == TypedHandlerDelegate.Result.DEFAULT) {\n        break;\n      }\n    }\n\n    if (!editor.getSelectionModel().hasBlockSelection()) {\n      if (')' == charTyped || ']' == charTyped || '}' == charTyped) {\n        if (FileTypes.PLAIN_TEXT != fileType) {\n          if (handleRParen(editor, fileType, charTyped)) return;\n        }\n      }\n      else if ('\"' == charTyped || '\\'' == charTyped || '`' == charTyped/* || '/' == charTyped*/) {\n        if (handleQuote(editor, charTyped, dataContext, file)) return;\n      }\n    }\n\n    long modificationStampBeforeTyping = editor.getDocument().getModificationStamp();\n    myOriginalHandler.execute(editor, charTyped, dataContext);\n    AutoHardWrapHandler.getInstance().wrapLineIfNecessary(editor, dataContext, modificationStampBeforeTyping);\n\n    if (('(' == charTyped || '[' == charTyped || '{' == charTyped) &&\n        CodeInsightSettings.getInstance().AUTOINSERT_PAIR_BRACKET &&\n        !editor.getSelectionModel().hasBlockSelection() && fileType != FileTypes.PLAIN_TEXT) {\n      handleAfterLParen(editor, fileType, charTyped);\n    }\n    else if ('}' == charTyped) {\n      indentClosingBrace(project, editor);\n    }\n    else if (')' == charTyped) {\n      indentClosingParenth(project, editor);\n    }\n\n    for(TypedHandlerDelegate delegate: delegates) {\n      final TypedHandlerDelegate.Result result = delegate.charTyped(charTyped, project, editor, file);\n      if (result == TypedHandlerDelegate.Result.STOP) {\n        return;\n      }\n      if (result == TypedHandlerDelegate.Result.DEFAULT) {\n        break;\n      }\n    }\n    if ('{' == charTyped) {\n      indentOpenedBrace(project, editor);\n    }\n    else if ('(' == charTyped) {\n      indentOpenedParenth(project, editor);\n    }\n  }","id":75612,"modified_method":"@Override\n  public void execute(@NotNull Editor editor, char charTyped, @NotNull DataContext dataContext) {\n    Project project = CommonDataKeys.PROJECT.getData(dataContext);\n    PsiFile file;\n\n    if (project == null || editor.isColumnMode() || (file = PsiUtilBase.getPsiFileInEditor(editor, project)) == null) {\n      if (myOriginalHandler != null){\n        myOriginalHandler.execute(editor, charTyped, dataContext);\n      }\n      return;\n    }\n\n    if (!CodeInsightUtilBase.prepareEditorForWrite(editor)) return;\n    if (!FileDocumentManager.getInstance().requestWriting(editor.getDocument(), project)) {\n       return;\n    }\n\n    Editor originalEditor = editor;\n    Editor injectedEditor = injectedEditorIfCharTypedIsSignificant(charTyped, editor, file);\n    if (injectedEditor != editor) {\n      file = PsiDocumentManager.getInstance(project).getPsiFile(injectedEditor.getDocument());\n      editor = injectedEditor;\n    }\n\n    final TypedHandlerDelegate[] delegates = Extensions.getExtensions(TypedHandlerDelegate.EP_NAME);\n\n    boolean handled = false;\n    for(TypedHandlerDelegate delegate: delegates) {\n      final TypedHandlerDelegate.Result result = delegate.checkAutoPopup(charTyped, project, editor, file);\n      handled = result == TypedHandlerDelegate.Result.STOP;\n      if (result != TypedHandlerDelegate.Result.CONTINUE) {\n        break;\n      }\n    }\n\n    if (!handled) {\n      autoPopupCompletion(editor, charTyped, project, file);\n      autoPopupParameterInfo(editor, charTyped, project, file);\n    }\n\n    if (!editor.isInsertMode()){\n      myOriginalHandler.execute(originalEditor, charTyped, dataContext);\n      return;\n    }\n\n    if (editor.getSelectionModel().hasSelection()){\n      EditorModificationUtil.deleteSelectedText(editor);\n    }\n\n    FileType fileType = getFileType(file, editor);\n\n    for(TypedHandlerDelegate delegate: delegates) {\n      final TypedHandlerDelegate.Result result = delegate.beforeCharTyped(charTyped, project, editor, file, fileType);\n      if (result == TypedHandlerDelegate.Result.STOP) {\n        return;\n      }\n      if (result == TypedHandlerDelegate.Result.DEFAULT) {\n        break;\n      }\n    }\n\n    if (!editor.getSelectionModel().hasBlockSelection()) {\n      if (')' == charTyped || ']' == charTyped || '}' == charTyped) {\n        if (FileTypes.PLAIN_TEXT != fileType) {\n          if (handleRParen(editor, fileType, charTyped)) return;\n        }\n      }\n      else if ('\"' == charTyped || '\\'' == charTyped || '`' == charTyped/* || '/' == charTyped*/) {\n        if (handleQuote(editor, charTyped, dataContext, file)) return;\n      }\n    }\n\n    long modificationStampBeforeTyping = editor.getDocument().getModificationStamp();\n    myOriginalHandler.execute(originalEditor, charTyped, dataContext);\n    AutoHardWrapHandler.getInstance().wrapLineIfNecessary(editor, dataContext, modificationStampBeforeTyping);\n\n    if (('(' == charTyped || '[' == charTyped || '{' == charTyped) &&\n        CodeInsightSettings.getInstance().AUTOINSERT_PAIR_BRACKET &&\n        !editor.getSelectionModel().hasBlockSelection() && fileType != FileTypes.PLAIN_TEXT) {\n      handleAfterLParen(editor, fileType, charTyped);\n    }\n    else if ('}' == charTyped) {\n      indentClosingBrace(project, editor);\n    }\n    else if (')' == charTyped) {\n      indentClosingParenth(project, editor);\n    }\n\n    for(TypedHandlerDelegate delegate: delegates) {\n      final TypedHandlerDelegate.Result result = delegate.charTyped(charTyped, project, editor, file);\n      if (result == TypedHandlerDelegate.Result.STOP) {\n        return;\n      }\n      if (result == TypedHandlerDelegate.Result.DEFAULT) {\n        break;\n      }\n    }\n    if ('{' == charTyped) {\n      indentOpenedBrace(project, editor);\n    }\n    else if ('(' == charTyped) {\n      indentOpenedParenth(project, editor);\n    }\n  }","commit_id":"bb9dfbfdc5f2ad89e8f14d59f8f873ea42b3c929","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void updatePresentation() {\n    this.setIcon(IconManager.getIconFor(this.testCase));\n    this.setNodeIdentifier(this.testCase.getId());\n    this.setText(SPropertyOperations.getString(this.testCase, \"name\"));\n    this.setAdditionalText(SNodeOperations.getModel(this.testCase).getLongName());\n  }","id":75613,"modified_method":"public void updatePresentation() {\n    Icon icon = IconManager.getIconFor(this.testCase);\n    if (icon != null) {\n      this.setIcon(icon);\n    }\n    this.setNodeIdentifier(this.testCase.getId());\n    this.setText(SPropertyOperations.getString(this.testCase, \"name\"));\n    this.setAdditionalText(SNodeOperations.getModel(this.testCase).getLongName());\n  }","commit_id":"500883a08d35d0e18c19df337a1b2c2a8bf09eb9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void updatePresentation() {\n    this.setIcon(this.state.getIcon());\n    this.setNodeIdentifier(this.testMethod.getId());\n    this.setText(ITestMethod_Behavior.call_getTestName_1216136419751(this.testMethod));\n  }","id":75614,"modified_method":"public void updatePresentation() {\n    Icon icon = this.state.getIcon();\n    if (icon != null) {\n      this.setIcon(icon);\n    }\n    this.setNodeIdentifier(this.testMethod.getId());\n    this.setText(ITestMethod_Behavior.call_getTestName_1216136419751(this.testMethod));\n  }","commit_id":"500883a08d35d0e18c19df337a1b2c2a8bf09eb9","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    protected void doUpdatePresentation() {\n      List<ModelChange> changes = MapSequence.fromMap(myRootToChange).get(myRootId);\n\n      if (ListSequence.fromList(changes).first() instanceof AddRootChange) {\n        setColor(ChangeType.ADD.getTreeColor());\n      } else if (ListSequence.fromList(changes).first() instanceof DeleteRootChange) {\n        setColor(ChangeType.DELETE.getTreeColor());\n      } else {\n        setColor(ChangeType.CHANGE.getTreeColor());\n      }\n\n      List<String> presentations = ListSequence.fromList(new ArrayList<String>());\n      Icon icon = null;\n      for (SModel model : Sequence.fromIterable(Sequence.fromArray(new SModel[]{myChangeSet.getOldModel(), myChangeSet.getNewModel()}))) {\n        SNode root = model.getNodeById(myRootId);\n        if (root != null) {\n          String presentation = root.getPresentation();\n          if (!(ListSequence.fromList(presentations).contains(presentation))) {\n            ListSequence.fromList(presentations).addElement(presentation);\n          }\n          if (icon == null) {\n            icon = IconManager.getIconFor(root);\n          }\n        }\n      }\n      setText(myPresentations);\n    }","id":75615,"modified_method":"@Override\n    protected void doUpdatePresentation() {\n      List<ModelChange> changes = MapSequence.fromMap(myRootToChange).get(myRootId);\n\n      if (ListSequence.fromList(changes).first() instanceof AddRootChange) {\n        setColor(ChangeType.ADD.getTreeColor());\n      } else if (ListSequence.fromList(changes).first() instanceof DeleteRootChange) {\n        setColor(ChangeType.DELETE.getTreeColor());\n      } else {\n        setColor(ChangeType.CHANGE.getTreeColor());\n      }\n\n      for (SModel model : Sequence.fromIterable(Sequence.fromArray(new SModel[]{myChangeSet.getOldModel(), myChangeSet.getNewModel()}))) {\n        SNode root = model.getNodeById(myRootId);\n        if (root != null) {\n          myPresentation = root.getPresentation();\n          Icon iconFor = IconManager.getIconFor(root);\n          if (iconFor != null) {\n            setIcon(iconFor);\n          }\n        }\n      }\n      setText(myPresentation);\n    }","commit_id":"67dadc89a4587512806be637e181c7fb2110aa3f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void invokeRootDifference(final SNodeId rootId) {\n    final ModelDifferenceDialog.RootTreeNode rootTreeNode = findRootTreeNode(rootId);\n    assert rootTreeNode != null;\n    if (myRootsDialogInvoked) {\n      return;\n    }\n    myRootsDialogInvoked = true;\n    final Wrappers._T<RootDifferenceDialog> rootDialog = new Wrappers._T<RootDifferenceDialog>();\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        rootDialog.value = new RootDifferenceDialog(ModelDifferenceDialog.this, rootId, rootTreeNode.myPresentations);\n      }\n    });\n    rootDialog.value.showDialog();\n    rootDialog.value.toFront();\n  }","id":75616,"modified_method":"public void invokeRootDifference(final SNodeId rootId) {\n    final ModelDifferenceDialog.RootTreeNode rootTreeNode = findRootTreeNode(rootId);\n    assert rootTreeNode != null;\n    if (myRootsDialogInvoked) {\n      return;\n    }\n    myRootsDialogInvoked = true;\n    final Wrappers._T<RootDifferenceDialog> rootDialog = new Wrappers._T<RootDifferenceDialog>();\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        rootDialog.value = new RootDifferenceDialog(ModelDifferenceDialog.this, rootId, rootTreeNode.myPresentation);\n      }\n    });\n    rootDialog.value.showDialog();\n    rootDialog.value.toFront();\n  }","commit_id":"67dadc89a4587512806be637e181c7fb2110aa3f","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected MPSTreeNode rebuild() {\n      final ModelDifferenceDialog.ModelTreeNode modelNode = new ModelDifferenceDialog.ModelTreeNode();\n      SetSequence.fromSet(MapSequence.fromMap(myRootToChange).keySet()).<ModelDifferenceDialog.RootTreeNode>select(new ISelector<SNodeId, ModelDifferenceDialog.RootTreeNode>() {\n        public ModelDifferenceDialog.RootTreeNode select(SNodeId r) {\n          return new ModelDifferenceDialog.RootTreeNode(r);\n        }\n      }).sort(new ISelector<ModelDifferenceDialog.RootTreeNode, Comparable<?>>() {\n        public Comparable<?> select(ModelDifferenceDialog.RootTreeNode rtn) {\n          return rtn.myPresentations;\n        }\n      }, true).visitAll(new IVisitor<ModelDifferenceDialog.RootTreeNode>() {\n        public void visit(ModelDifferenceDialog.RootTreeNode rtn) {\n          modelNode.add(rtn);\n        }\n      });\n      return modelNode;\n    }","id":75617,"modified_method":"protected MPSTreeNode rebuild() {\n      final ModelDifferenceDialog.ModelTreeNode modelNode = new ModelDifferenceDialog.ModelTreeNode();\n      SetSequence.fromSet(MapSequence.fromMap(myRootToChange).keySet()).<ModelDifferenceDialog.RootTreeNode>select(new ISelector<SNodeId, ModelDifferenceDialog.RootTreeNode>() {\n        public ModelDifferenceDialog.RootTreeNode select(SNodeId r) {\n          return new ModelDifferenceDialog.RootTreeNode(r);\n        }\n      }).sort(new ISelector<ModelDifferenceDialog.RootTreeNode, Comparable<?>>() {\n        public Comparable<?> select(ModelDifferenceDialog.RootTreeNode rtn) {\n          return rtn.myPresentation;\n        }\n      }, true).visitAll(new IVisitor<ModelDifferenceDialog.RootTreeNode>() {\n        public void visit(ModelDifferenceDialog.RootTreeNode rtn) {\n          modelNode.add(rtn);\n        }\n      });\n      return modelNode;\n    }","commit_id":"67dadc89a4587512806be637e181c7fb2110aa3f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public RootTreeNode(SNodeId rootId) {\n      super(myOperationContext);\n      myRootId = rootId;\n      setNodeIdentifier(\"\" + myRootId);\n\n      List<String> presentations = ListSequence.fromList(new ArrayList<String>());\n      Icon icon = null;\n      for (SModel model : Sequence.fromIterable(Sequence.fromArray(new SModel[]{myChangeSet.getNewModel(), myChangeSet.getOldModel()}))) {\n        SNode root = model.getNodeById(myRootId);\n        if (root != null) {\n          String presentation = root.getPresentation();\n          if (!(ListSequence.fromList(presentations).contains(presentation))) {\n            ListSequence.fromList(presentations).addElement(presentation);\n          }\n          if (icon == null) {\n            icon = IconManager.getIconFor(root);\n          }\n        }\n      }\n      myPresentations = StringUtils.join(presentations, \" / \");\n      setIcon(icon);\n    }","id":75618,"modified_method":"public RootTreeNode(SNodeId rootId) {\n      super(myOperationContext);\n      myRootId = rootId;\n      setNodeIdentifier(\"\" + myRootId);\n      doUpdatePresentation();\n    }","commit_id":"67dadc89a4587512806be637e181c7fb2110aa3f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Icon getIconFor(ConceptDeclaration conceptDeclaration) {\n    GlobalScope scope = GlobalScope.getInstance();\n    while (conceptDeclaration != null) {\n      Language language = SModelUtil_new.getDeclaringLanguage(conceptDeclaration, scope);\n      if (language != null) {\n        String iconPath = Macros.languageDescriptor().expandPath(conceptDeclaration.getIconPath(), language.getDescriptorFile());\n        if (iconPath != null) {\n          Icon icon = loadIcon(iconPath, true);\n          if (icon != null) {\n            return icon;\n          }\n        }\n      }\n      conceptDeclaration = conceptDeclaration.getExtends();\n    }\n\n    return Icons.DEFAULT_ICON;\n  }","id":75619,"modified_method":"private static Icon getIconFor(ConceptDeclaration conceptDeclaration) {\n    GlobalScope scope = GlobalScope.getInstance();\n    while (conceptDeclaration != null) {\n      Language language = SModelUtil_new.getDeclaringLanguage(conceptDeclaration, scope);\n      if (language != null) {\n        String iconPath = Macros.languageDescriptor().expandPath(conceptDeclaration.getIconPath(), language.getDescriptorFile());\n        if (iconPath != null) {\n          Icon icon = loadIcon(iconPath, true);\n          if (icon != null) {\n            return icon;\n          }\n        }\n      }\n      conceptDeclaration = conceptDeclaration.getExtends();\n    }\n\n    return null;\n  }","commit_id":"c422c79e484e7079470f0c81a6f0229369085dc3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Icon getIconFor(final SNode node) {\n    return ModelAccess.instance().runReadAction(new Computable<Icon>() {\n      public Icon compute() {\n        if (node == null) return Icons.DEFAULT_ICON;\n\n        if (!(node.getConceptDeclarationAdapter() instanceof ConceptDeclaration)) {\n          return Icons.DEFAULT_ICON;\n        }\n\n        ConceptDeclaration conceptDeclaration = (ConceptDeclaration) node.getConceptDeclarationAdapter();\n        try {\n          return getIconFor(conceptDeclaration);\n        } catch (Throwable t) {\n          LOG.error(\"can't find an icon for concept declaration \" + conceptDeclaration, t);\n          return Icons.DEFAULT_ICON;\n        }\n      }\n    });\n  }","id":75620,"modified_method":"public static Icon getIconFor(final SNode node) {\n    return ModelAccess.instance().runReadAction(new Computable<Icon>() {\n      public Icon compute() {\n        Icon result = null;\n        if (node.getConceptDeclarationAdapter() instanceof ConceptDeclaration) {\n          result = IconManager.getIconFor((ConceptDeclaration) node.getConceptDeclarationAdapter());  \n        }\n\n        if (result == null) {\n          if (node.isRoot()) {\n            return Icons.DEFAULT_ROOT_ICON;\n          } else {\n            return Icons.DEFAULT_ICON;\n          }\n        }\n\n        return result;\n      }\n    });\n  }","commit_id":"c422c79e484e7079470f0c81a6f0229369085dc3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Icon getIconForConceptFQName(String conceptFQName) {\n    ConceptDeclaration cd = (ConceptDeclaration) SModelUtil_new.findConceptDeclaration(conceptFQName, GlobalScope.getInstance());\n    return getIconFor(cd);\n  }","id":75621,"modified_method":"public static Icon getIconForConceptFQName(String conceptFQName) {\n    ConceptDeclaration cd = (ConceptDeclaration) SModelUtil_new.findConceptDeclaration(conceptFQName, GlobalScope.getInstance());\n    Icon icon = getIconFor(cd);\n\n    if (icon == null) {\n      if (cd.isRoot()) {\n        return Icons.DEFAULT_ROOT_ICON;\n      } else {\n        return Icons.DEFAULT_ICON;\n      }\n    }\n\n    return icon;\n  }","commit_id":"c422c79e484e7079470f0c81a6f0229369085dc3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Icon getIcon(INodeAdapter nodeAdapter, boolean referent_presentation) {\n    if (nodeAdapter instanceof ConceptDeclaration && !referent_presentation) {\n      return IconManager.getIconFor((ConceptDeclaration) nodeAdapter);\n    }\n    return IconManager.getIconFor(nodeAdapter.getNode());\n  }","id":75622,"modified_method":"public static Icon getIcon(INodeAdapter nodeAdapter, boolean referent_presentation) {\n    if (nodeAdapter instanceof ConceptDeclaration && !referent_presentation) {\n      return IconManager.getIconFor(NameUtil.nodeFQName(nodeAdapter));\n    }\n    return IconManager.getIconFor(nodeAdapter.getNode());\n  }","commit_id":"c422c79e484e7079470f0c81a6f0229369085dc3","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static void registerTransformers_1_2_0(SubsystemRegistration subsystem) {\n\n        TransformersSubRegistration transformers = subsystem.registerModelTransformers(ModelVersion.create(1, 2, 0), new AbstractSubsystemTransformer(SUBSYSTEM_NAME) {\n            @Override\n            protected ModelNode transformModel(TransformationContext context, ModelNode model) {\n                return model;\n            }\n        });\n\n        // ModClusterConfigResourceDefinition\n        RejectExpressionValuesTransformer configRejectExpressionTransformer = new RejectExpressionValuesTransformer(ADVERTISE, AUTO_ENABLE_CONTEXTS, FLUSH_PACKETS, STICKY_SESSION, STICKY_SESSION_REMOVE, STICKY_SESSION_FORCE, PING);\n        TransformersSubRegistration config = transformers.registerSubResource(CONFIGURATION_PATH);\n        config.registerOperationTransformer(ModelDescriptionConstants.ADD, configRejectExpressionTransformer);\n\n        // ModClusterSSLResourceDefinition\n        RejectExpressionValuesTransformer sslRejectExpressionTransformer = new RejectExpressionValuesTransformer(CIPHER_SUITE, KEY_ALIAS, PROTOCOL);\n        TransformersSubRegistration ssl = transformers.registerSubResource(SSL_CONFIGURATION_PATH);\n        ssl.registerOperationTransformer(ADD, sslRejectExpressionTransformer);\n        ssl.registerOperationTransformer(WRITE_ATTRIBUTE_OPERATION, sslRejectExpressionTransformer.getWriteAttributeTransformer());\n\n        // DynamicLoadProviderDefinition\n        RejectExpressionValuesTransformer dynamicProviderRejectExpressionTransformer = new RejectExpressionValuesTransformer(DECAY, HISTORY);\n        TransformersSubRegistration dynamicProvider = transformers.registerSubResource(DYNAMIC_LOAD_PROVIDER_PATH);\n        dynamicProvider.registerOperationTransformer(ADD, dynamicProviderRejectExpressionTransformer);\n        dynamicProvider.registerOperationTransformer(WRITE_ATTRIBUTE_OPERATION, dynamicProviderRejectExpressionTransformer.getWriteAttributeTransformer());\n\n        // CustomLoadMetricDefinition\n        RejectExpressionValuesTransformer customRejectExpressionTransformer = new RejectExpressionValuesTransformer(CLASS);\n        TransformersSubRegistration customMetric = dynamicProvider.registerSubResource(CUSTOM_LOAD_METRIC_PATH);\n        customMetric.registerOperationTransformer(ADD, customRejectExpressionTransformer);\n        customMetric.registerOperationTransformer(WRITE_ATTRIBUTE_OPERATION, customRejectExpressionTransformer.getWriteAttributeTransformer());\n\n        // LoadMetricDefinition\n        RejectExpressionValuesTransformer loadMetricRejectExpressionTransformer = new RejectExpressionValuesTransformer(TYPE, WEIGHT, CAPACITY, PROPERTY);\n        TransformersSubRegistration metric = dynamicProvider.registerSubResource(LOAD_METRIC_PATH);\n        metric.registerOperationTransformer(ADD, loadMetricRejectExpressionTransformer);\n        metric.registerOperationTransformer(WRITE_ATTRIBUTE_OPERATION, loadMetricRejectExpressionTransformer.getWriteAttributeTransformer());\n\n    }","id":75623,"modified_method":"private static void registerTransformers_1_2_0(SubsystemRegistration subsystem) {\n\n        TransformersSubRegistration transformers = subsystem.registerModelTransformers(ModelVersion.create(1, 2, 0), new AbstractSubsystemTransformer(SUBSYSTEM_NAME) {\n            @Override\n            protected ModelNode transformModel(TransformationContext context, ModelNode model) {\n                return model;\n            }\n        });\n\n        // ModClusterConfigResourceDefinition\n        RejectExpressionValuesTransformer configRejectExpressionTransformer = new RejectExpressionValuesTransformer(ADVERTISE, AUTO_ENABLE_CONTEXTS, FLUSH_PACKETS, STICKY_SESSION, STICKY_SESSION_REMOVE, STICKY_SESSION_FORCE, PING);\n        TransformersSubRegistration config = transformers.registerSubResource(CONFIGURATION_PATH, (ResourceTransformer)configRejectExpressionTransformer);\n        config.registerOperationTransformer(ModelDescriptionConstants.ADD, configRejectExpressionTransformer);\n\n\n\n        // ModClusterSSLResourceDefinition\n        RejectExpressionValuesTransformer sslRejectExpressionTransformer = new RejectExpressionValuesTransformer(CIPHER_SUITE, KEY_ALIAS, PROTOCOL);\n        TransformersSubRegistration ssl = transformers.registerSubResource(SSL_CONFIGURATION_PATH, (ResourceTransformer)sslRejectExpressionTransformer);\n        ssl.registerOperationTransformer(ADD, sslRejectExpressionTransformer);\n        ssl.registerOperationTransformer(WRITE_ATTRIBUTE_OPERATION, sslRejectExpressionTransformer.getWriteAttributeTransformer());\n\n        // DynamicLoadProviderDefinition\n        RejectExpressionValuesTransformer dynamicProviderRejectExpressionTransformer = new RejectExpressionValuesTransformer(DECAY, HISTORY);\n        TransformersSubRegistration dynamicProvider = config.registerSubResource(DYNAMIC_LOAD_PROVIDER_PATH, (ResourceTransformer)dynamicProviderRejectExpressionTransformer);\n        dynamicProvider.registerOperationTransformer(ADD, dynamicProviderRejectExpressionTransformer);\n        dynamicProvider.registerOperationTransformer(WRITE_ATTRIBUTE_OPERATION, dynamicProviderRejectExpressionTransformer.getWriteAttributeTransformer());\n\n        // CustomLoadMetricDefinition\n        RejectExpressionValuesTransformer customRejectExpressionTransformer = new RejectExpressionValuesTransformer(CLASS);\n        TransformersSubRegistration customMetric = dynamicProvider.registerSubResource(CUSTOM_LOAD_METRIC_PATH, (ResourceTransformer)customRejectExpressionTransformer);\n        customMetric.registerOperationTransformer(ADD, customRejectExpressionTransformer);\n        customMetric.registerOperationTransformer(WRITE_ATTRIBUTE_OPERATION, customRejectExpressionTransformer.getWriteAttributeTransformer());\n\n        // LoadMetricDefinition\n        RejectExpressionValuesTransformer loadMetricRejectExpressionTransformer = new RejectExpressionValuesTransformer(TYPE, WEIGHT, CAPACITY, PROPERTY);\n        ChainedResourceTransformer loadMetricResourceTransformer = new ChainedResourceTransformer(loadMetricRejectExpressionTransformer.getChainedTransformer(), ConvertCapacityTransformer.INSTANCE);\n        TransformersSubRegistration metric = dynamicProvider.registerSubResource(LOAD_METRIC_PATH, loadMetricResourceTransformer);\n        metric.registerOperationTransformer(ADD, new ChainedOperationTransformer(loadMetricRejectExpressionTransformer, ConvertCapacityTransformer.INSTANCE));\n        metric.registerOperationTransformer(WRITE_ATTRIBUTE_OPERATION,\n                new ChainedOperationTransformer(loadMetricRejectExpressionTransformer.getWriteAttributeTransformer(), ConvertCapacityTransformer.INSTANCE.getWriteAttributeTransformer()));\n\n    }","commit_id":"47cab61913c009b25bfaf52ab15a77cb76e6ea53","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public ModelNode correctWriteAttributeOperation(ModelNode operation) {\n            ModelNode op = operation.clone();\n            if (hasExpressions(op.get(NAME).asString(), op.get(VALUE))) {\n                op.get(VALUE).set(op.get(VALUE).resolve());\n                return op;\n            }\n            return operation;\n        }","id":75624,"modified_method":"@Override\n        public ModelNode correctWriteAttributeOperation(ModelNode operation) {\n            ModelNode op = operation.clone();\n            String name = operation.get(NAME).asString();\n            if (attributes.contains(name) && hasExpressions(name, op.get(VALUE))) {\n                op.get(VALUE).set(op.get(VALUE).resolve());\n                return op;\n            }\n            return operation;\n        }","commit_id":"dea4a5879bb6886e90fda24149641e4a279846fb","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public boolean expectFailedWriteAttributeOperation(ModelNode operation) {\n            return operation.hasDefined(VALUE);\n        }","id":75625,"modified_method":"@Override\n        public boolean expectFailedWriteAttributeOperation(ModelNode operation) {\n            String name = operation.require(NAME).asString();\n            return attributes.contains(name) && operation.hasDefined(VALUE);\n        }","commit_id":"dea4a5879bb6886e90fda24149641e4a279846fb","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Tests rejection of expressions in 1.1.0 model.\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testRejectExpressions_1_1_0() throws Exception {\n        // create builder for current subsystem version.\n        //\n        // AS7 7.1.2.Final does not allow to add an empty messaging subsystem [AS7-5767]\n        // To work around that, we add an empty \"stuff\" hornetq-server to boot the conf with AS7 7.1.2.Final\n        KernelServicesBuilder builder = createKernelServicesBuilder(AdditionalInitialization.MANAGEMENT)\n                .setSubsystemXmlResource(\"empty_subsystem_1_3.xml\");\n\n        // create builder for legacy subsystem version\n        builder.createLegacyKernelServicesBuilder(createAdditionalInitialization(), VERSION_1_1_0)\n                .addMavenResourceURL(\"org.hornetq:hornetq-core:2.2.16.Final\")\n                .addMavenResourceURL(\"org.hornetq:hornetq-jms:2.2.16.Final\")\n                .addMavenResourceURL(\"org.hornetq:hornetq-ra:2.2.16.Final\")\n                .addMavenResourceURL(\"org.jboss.as:jboss-as-messaging:7.1.2.Final\")\n                .addMavenResourceURL(\"org.jboss.as:jboss-as-controller:7.1.2.Final\")\n                .addParentFirstClassPattern(\"org.jboss.as.controller.*\");\n\n        KernelServices mainServices = builder.build();\n        assertTrue(mainServices.isSuccessfulBoot());\n        KernelServices legacyServices = mainServices.getLegacyServices(VERSION_1_1_0);\n        assertNotNull(legacyServices);\n        assertTrue(legacyServices.isSuccessfulBoot());\n\n        //Use the real xml with expressions for testing all the attributes\n        PathAddress subsystemAddress = PathAddress.pathAddress(pathElement(SUBSYSTEM, MessagingExtension.SUBSYSTEM_NAME));\n        List<ModelNode> modelNodes = builder.parseXmlResource(\"subsystem_incompatible_1_3.xml\");\n        // remote the messaging subsystem add operation that fails on AS7 7.1.2.Final\n        modelNodes.remove(0);\n        checkFailedTransformedBootOperations(\n                mainServices,\n                VERSION_1_1_0,\n                modelNodes,\n                new FailedOperationTransformationConfig()\n                        .addFailedAttribute(\n                                subsystemAddress.append(HORNETQ_SERVER_PATH),\n                                new RejectExpressionsConfig(HornetQServerResourceDefinition.REJECTED_EXPRESSION_ATTRIBUTES))\n                        .addFailedAttribute(\n                                subsystemAddress.append(HORNETQ_SERVER_PATH).append(pathElement(ModelDescriptionConstants.PATH)),\n                                new RejectExpressionsConfig(ModelDescriptionConstants.PATH))\n                        .addFailedAttribute(\n                                subsystemAddress.append(HORNETQ_SERVER_PATH).append(pathElement(CommonAttributes.IN_VM_CONNECTOR)),\n                                new RejectExpressionsConfig(InVMTransportDefinition.SERVER_ID))\n                        .addFailedAttribute(\n                                subsystemAddress.append(HORNETQ_SERVER_PATH).append(pathElement(CommonAttributes.CONNECTOR)),\n                                new RejectExpressionsConfig(CommonAttributes.FACTORY_CLASS))\n                        .addFailedAttribute(\n                                subsystemAddress.append(HORNETQ_SERVER_PATH).append(pathElement(CommonAttributes.IN_VM_ACCEPTOR)),\n                                new RejectExpressionsConfig(InVMTransportDefinition.SERVER_ID))\n                        .addFailedAttribute(\n                                subsystemAddress.append(HORNETQ_SERVER_PATH).append(pathElement(CommonAttributes.ACCEPTOR)),\n                                new RejectExpressionsConfig(CommonAttributes.FACTORY_CLASS))\n                        .addFailedAttribute(\n                                subsystemAddress.append(HORNETQ_SERVER_PATH).append(BroadcastGroupDefinition.PATH),\n                                new RejectExpressionsConfig(BroadcastGroupDefinition.BROADCAST_PERIOD) {\n                                    @Override\n                                    public boolean expectFailed(ModelNode operation) {\n                                        if (\"groupT\".equals(operation.get(OP_ADDR).get(2).get(CommonAttributes.BROADCAST_GROUP).asString())) {\n                                            // groupT use JGroups and do not define socket-binding or local address\n                                            return true;\n                                        }\n                                        return super.expectFailed(operation);\n                                    }\n                                })\n                        .addFailedAttribute(\n                                subsystemAddress.append(HORNETQ_SERVER_PATH).append(DiscoveryGroupDefinition.PATH),\n                                new RejectExpressionsConfig(DiscoveryGroupDefinition.REFRESH_TIMEOUT, DiscoveryGroupDefinition.INITIAL_WAIT_TIMEOUT) {\n                                    @Override\n                                    public boolean expectFailed(ModelNode operation) {\n                                        if (\"groupU\".equals(operation.get(OP_ADDR).get(2).get(CommonAttributes.DISCOVERY_GROUP).asString())) {\n                                            // groupU use JGroups and do not define socket-binding or local address\n                                            return true;\n                                        }\n                                        return super.expectFailed(operation);\n                                    }\n                                })\n                        .addFailedAttribute(\n                                subsystemAddress.append(HORNETQ_SERVER_PATH).append(DivertDefinition.PATH),\n                                new RejectExpressionsConfig(DivertDefinition.REJECTED_EXPRESSION_ATTRIBUTES))\n                        .addFailedAttribute(\n                                subsystemAddress.append(HORNETQ_SERVER_PATH).append(QueueDefinition.PATH),\n                                new RejectExpressionsConfig(QueueDefinition.REJECTED_EXPRESSION_ATTRIBUTES))\n                        .addFailedAttribute(\n                                subsystemAddress.append(HORNETQ_SERVER_PATH).append(ClusterConnectionDefinition.PATH),\n                                new RejectExpressionsConfig(ClusterConnectionDefinition.REJECTED_EXPRESSION_ATTRIBUTES))\n                        .addFailedAttribute(\n                                subsystemAddress.append(HORNETQ_SERVER_PATH).append(BridgeDefinition.PATH),\n                                new RejectExpressionsConfig(BridgeDefinition.REJECTED_EXPRESSION_ATTRIBUTES))\n                        .addFailedAttribute(\n                                subsystemAddress.append(HORNETQ_SERVER_PATH).append(GroupingHandlerDefinition.PATH),\n                                new RejectExpressionsConfig(GroupingHandlerDefinition.REJECTED_EXPRESSION_ATTRIBUTES))\n                        .addFailedAttribute(\n                                subsystemAddress.append(HORNETQ_SERVER_PATH).append(AddressSettingDefinition.PATH),\n                                new RejectExpressionsConfig(AddressSettingDefinition.REJECTED_EXPRESSION_ATTRIBUTES))\n                        .addFailedAttribute(\n                                subsystemAddress.append(HORNETQ_SERVER_PATH).append(ConnectorServiceDefinition.PATH),\n                                new RejectExpressionsConfig(CommonAttributes.FACTORY_CLASS))\n                        .addFailedAttribute(\n                                subsystemAddress.append(HORNETQ_SERVER_PATH).append(ConnectorServiceDefinition.PATH).append(ConnectorServiceParamDefinition.PATH),\n                                new RejectExpressionsConfig(ConnectorServiceParamDefinition.VALUE))\n                        .addFailedAttribute(\n                                subsystemAddress.append(HORNETQ_SERVER_PATH).append(ConnectionFactoryDefinition.PATH),\n                                new RejectExpressionsConfig(ConnectionFactoryDefinition.REJECTED_EXPRESSION_ATTRIBUTES)\n                                        .setReadOnly(FACTORY_TYPE))\n                        .addFailedAttribute(\n                                subsystemAddress.append(HORNETQ_SERVER_PATH).append(PooledConnectionFactoryDefinition.PATH),\n                                new ChainedConfig(new HashMap<String, FailedOperationTransformationConfig.PathAddressConfig>() {{\n                                    for (AttributeDefinition attr : PooledConnectionFactoryDefinition.REJECTED_EXPRESSION_ATTRIBUTES) {\n                                            put(attr.getName(), new RejectExpressionsConfig(attr));\n                                    }\n                                    //put(USE_AUTO_RECOVERY.getName(), new NewAttributesConfig(USE_AUTO_RECOVERY));\n                                    //put(INITIAL_CONNECT_ATTEMPTS.getName(), new NewAttributesConfig(INITIAL_CONNECT_ATTEMPTS));\n                                    //put(INITIAL_MESSAGE_PACKET_SIZE.getName(), new NewAttributesConfig(INITIAL_MESSAGE_PACKET_SIZE));\n                                    //put(COMPRESS_LARGE_MESSAGES.getName(), new NewAttributesConfig(COMPRESS_LARGE_MESSAGES));\n                                    //put(CALL_FAILOVER_TIMEOUT.getName(), new NewAttributesConfig(CALL_FAILOVER_TIMEOUT));\n                                }}).setReadOnly(ConnectionFactoryAttributes.Pooled.TRANSACTION))\n                        .addFailedAttribute(\n                                subsystemAddress.append(HORNETQ_SERVER_PATH).append(JMSQueueDefinition.PATH),\n                                new RejectExpressionsConfig(JMSQueueDefinition.REJECTED_EXPRESSION_ATTRIBUTES))\n                        .addFailedAttribute(\n                                subsystemAddress.append(JMSBridgeDefinition.PATH),\n                                new RejectExpressionsConfig(new String[0]) {\n                                    @Override\n                                    public boolean expectFailed(ModelNode operation) {\n                                        // jms-bridge resource was introduced in version 1.2.0\n                                        return true;\n                                    }\n                                })\n        );\n    }","id":75626,"modified_method":"@Test\n    public void testRejectExpressionsAS712() throws Exception {\n        // AS7 7.1.2.Final does not allow to add an empty messaging subsystem [AS7-5767]\n        // To work around that, we add an empty \"stuff\" hornetq-server to boot the conf with AS7 7.1.2.Final\n        KernelServicesBuilder builder = createKernelServicesBuilder(AdditionalInitialization.MANAGEMENT)\n                .setSubsystemXmlResource(\"empty_subsystem_1_3.xml\");\n\n        // create builder for legacy subsystem version\n        builder.createLegacyKernelServicesBuilder(createAdditionalInitialization(), VERSION_1_1_0)\n                .addMavenResourceURL(\"org.hornetq:hornetq-core:2.2.16.Final\")\n                .addMavenResourceURL(\"org.hornetq:hornetq-jms:2.2.16.Final\")\n                .addMavenResourceURL(\"org.hornetq:hornetq-ra:2.2.16.Final\")\n                .addMavenResourceURL(\"org.jboss.as:jboss-as-messaging:7.1.2.Final\")\n                .addMavenResourceURL(\"org.jboss.as:jboss-as-controller:7.1.2.Final\")\n                .addParentFirstClassPattern(\"org.jboss.as.controller.*\");\n\n        doTestRejectExpressions_1_1_0(builder);\n    }","commit_id":"dea4a5879bb6886e90fda24149641e4a279846fb","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testTransformers_1_1_0() throws Exception {\n        //Boot up empty controllers with the resources needed for the ops coming from the xml to work\n        KernelServicesBuilder builder = createKernelServicesBuilder(AdditionalInitialization.MANAGEMENT)\n                .setSubsystemXmlResource(\"subsystem_1_3.xml\");\n        builder.createLegacyKernelServicesBuilder(createAdditionalInitialization(), VERSION_1_1_0)\n                .addMavenResourceURL(\"org.jboss.as:jboss-as-messaging:7.1.2.Final\")\n                .addMavenResourceURL(\"org.hornetq:hornetq-core:2.2.16.Final\")\n                .addMavenResourceURL(\"org.hornetq:hornetq-jms:2.2.16.Final\")\n                .addMavenResourceURL(\"org.hornetq:hornetq-ra:2.2.16.Final\");\n        KernelServices mainServices = builder.build();\n        assertTrue(mainServices.isSuccessfulBoot());\n        assertTrue(mainServices.getLegacyServices(VERSION_1_1_0).isSuccessfulBoot());\n    }","id":75627,"modified_method":"@Test\n    public void testTransformersAS712() throws Exception {\n        //Boot up empty controllers with the resources needed for the ops coming from the xml to work\n        KernelServicesBuilder builder = createKernelServicesBuilder(AdditionalInitialization.MANAGEMENT)\n                .setSubsystemXmlResource(\"subsystem_1_3.xml\");\n        builder.createLegacyKernelServicesBuilder(createAdditionalInitialization(), VERSION_1_1_0)\n                .addMavenResourceURL(\"org.jboss.as:jboss-as-messaging:7.1.2.Final\")\n                .addMavenResourceURL(\"org.hornetq:hornetq-core:2.2.16.Final\")\n                .addMavenResourceURL(\"org.hornetq:hornetq-jms:2.2.16.Final\")\n                .addMavenResourceURL(\"org.hornetq:hornetq-ra:2.2.16.Final\");\n        KernelServices mainServices = builder.build();\n        assertTrue(mainServices.isSuccessfulBoot());\n        assertTrue(mainServices.getLegacyServices(VERSION_1_1_0).isSuccessfulBoot());\n    }","commit_id":"dea4a5879bb6886e90fda24149641e4a279846fb","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void registerTransformers_1_1_0(final SubsystemRegistration subsystem) {\n\n        // attributes added to the pooled cf resources *after* 1.1.0\n        final AttributeDefinition[] addedPooledCFAttributes = { ConnectionFactoryAttributes.Pooled.INITIAL_CONNECT_ATTEMPTS,\n                ConnectionFactoryAttributes.Pooled.INITIAL_MESSAGE_PACKET_SIZE,\n                COMPRESS_LARGE_MESSAGES,\n                USE_AUTO_RECOVERY,\n                CALL_FAILOVER_TIMEOUT };\n\n        final TransformersSubRegistration transformers = subsystem.registerModelTransformers(VERSION_1_1_0, new AbstractSubsystemTransformer(SUBSYSTEM_NAME) {\n\n            @Override\n            public ModelNode transformModel(final TransformationContext context, final ModelNode model) {\n                ModelNode oldModel = model.clone();\n                if (oldModel.hasDefined(HORNETQ_SERVER)) {\n                    for (Property server : oldModel.get(HORNETQ_SERVER).asPropertyList()) {\n                        ModelNode oldServer = oldModel.get(HORNETQ_SERVER, server.getName());\n                        if (!oldServer.hasDefined(CLUSTERED.getName())) {\n                            oldServer.get(CLUSTERED.getName()).set(false);\n                        }\n                        oldServer.remove(CHECK_FOR_LIVE_SERVER.getName());\n                        oldServer.remove(BACKUP_GROUP_NAME.getName());\n                        oldServer.remove(REPLICATION_CLUSTERNAME.getName());\n                        if (server.getValue().hasDefined(CLUSTER_CONNECTION)) {\n                            for (Property clusterConnection : server.getValue().get(CLUSTER_CONNECTION).asPropertyList()) {\n                                oldServer.get(HORNETQ_SERVER, server.getName(), CLUSTER_CONNECTION, clusterConnection.getName()).remove(CALL_FAILOVER_TIMEOUT.getName());\n                            }\n                        }\n                        if (server.getValue().hasDefined(BROADCAST_GROUP)) {\n                            for (Property broadcastGroup : server.getValue().get(BROADCAST_GROUP).asPropertyList()) {\n                                oldServer.get(BROADCAST_GROUP, broadcastGroup.getName()).remove(JGROUPS_STACK.getName());\n                                oldServer.get(BROADCAST_GROUP, broadcastGroup.getName()).remove(JGROUPS_CHANNEL.getName());\n                            }\n                        }\n                        if (server.getValue().hasDefined(DISCOVERY_GROUP)) {\n                            for (Property discoveryGroup : server.getValue().get(DISCOVERY_GROUP).asPropertyList()) {\n                                oldServer.get(DISCOVERY_GROUP, discoveryGroup.getName()).remove(JGROUPS_STACK.getName());\n                                oldServer.get(DISCOVERY_GROUP, discoveryGroup.getName()).remove(JGROUPS_CHANNEL.getName());\n                            }\n                        }\n                        if (server.getValue().hasDefined(POOLED_CONNECTION_FACTORY)) {\n                            for (Property pooledConnectionFactory : server.getValue().get(POOLED_CONNECTION_FACTORY).asPropertyList()) {\n                                for (AttributeDefinition attribute : addedPooledCFAttributes) {\n                                    oldServer.get(POOLED_CONNECTION_FACTORY, pooledConnectionFactory.getName()).remove(attribute.getName());\n                                }\n                            }\n                        }\n                        if (server.getValue().hasDefined(CONNECTION_FACTORY)) {\n                            for (Property connectionFactory : server.getValue().get(CONNECTION_FACTORY).asPropertyList()) {\n                                oldServer.get(CONNECTION_FACTORY, connectionFactory.getName()).remove(CALL_FAILOVER_TIMEOUT.getName());\n                                if (!connectionFactory.getValue().hasDefined(HA.getName())) {\n                                    oldServer.get(CONNECTION_FACTORY, connectionFactory.getName()).get(HA.getName()).set(HA.getDefaultValue());\n                                }\n                                if (connectionFactory.getValue().hasDefined(FACTORY_TYPE.getName()) && (connectionFactory.getValue().get(FACTORY_TYPE.getName()).equals(FACTORY_TYPE.getDefaultValue()))) {\n                                    oldServer.get(CONNECTION_FACTORY, connectionFactory.getName()).get(FACTORY_TYPE.getName()).set(new ModelNode());\n                                }\n                            }\n                        }\n                        //TODO - a nicer way to automagically remove these runtime resources?\n                        if (server.getValue().hasDefined(CORE_ADDRESS)) {\n                            oldServer.remove(CORE_ADDRESS);\n                        }\n                        if (server.getValue().hasDefined(RUNTIME_QUEUE)) {\n                            oldServer.remove(RUNTIME_QUEUE);\n                        }\n                    }\n                }\n                return oldModel;\n            }\n        });\n\n        RejectExpressionValuesTransformer rejectServerExpressionTransformer = new RejectExpressionValuesTransformer(HornetQServerResourceDefinition.REJECTED_EXPRESSION_ATTRIBUTES);\n        MessagingDiscardAttributesTransformer discardNewServerAttributes = new MessagingDiscardAttributesTransformer(CHECK_FOR_LIVE_SERVER, BACKUP_GROUP_NAME, REPLICATION_CLUSTERNAME);\n        TransformersSubRegistration server = transformers.registerSubResource(PathElement.pathElement(HORNETQ_SERVER));\n        server.registerOperationTransformer(ADD, new ChainedOperationTransformer(\n                new OperationTransformers.InsertDefaultValuesOperationTransformer(ID_CACHE_SIZE, CLUSTERED),\n                rejectServerExpressionTransformer,\n                discardNewServerAttributes));\n        server.registerOperationTransformer(WRITE_ATTRIBUTE_OPERATION, rejectServerExpressionTransformer.getWriteAttributeTransformer());\n        server.registerOperationTransformer(UNDEFINE_ATTRIBUTE_OPERATION, discardNewServerAttributes.getUndefineAttributeTransformer());\n\n        rejectExpressions(server, AddressSettingDefinition.PATH, AddressSettingDefinition.REJECTED_EXPRESSION_ATTRIBUTES);\n\n        MessagingDiscardAttributesTransformer discardNewJGroupsAttributes = new MessagingDiscardAttributesTransformer(JGROUPS_CHANNEL, JGROUPS_STACK);\n\n        RejectExpressionValuesTransformer rejectBroadcastGroupExpressions = new RejectExpressionValuesTransformer(BROADCAST_PERIOD);\n        TransformersSubRegistration broadcastGroup = server.registerSubResource(BroadcastGroupDefinition.PATH);\n        broadcastGroup.registerOperationTransformer(ADD, new ChainedOperationTransformer(\n                rejectBroadcastGroupExpressions,\n                discardNewJGroupsAttributes\n        ));\n        broadcastGroup.registerOperationTransformer(WRITE_ATTRIBUTE_OPERATION, new ChainedOperationTransformer(\n                rejectBroadcastGroupExpressions.getWriteAttributeTransformer(),\n                discardNewJGroupsAttributes.getWriteAttributeTransformer()));\n        broadcastGroup.registerOperationTransformer(UNDEFINE_ATTRIBUTE_OPERATION, discardNewJGroupsAttributes.getUndefineAttributeTransformer());\n\n        RejectExpressionValuesTransformer rejectDiscoveryGroupExpressions = new RejectExpressionValuesTransformer(INITIAL_WAIT_TIMEOUT, REFRESH_TIMEOUT);\n        TransformersSubRegistration discoveryGroup = server.registerSubResource(DiscoveryGroupDefinition.PATH);\n        discoveryGroup.registerOperationTransformer(ADD, new ChainedOperationTransformer(\n                rejectDiscoveryGroupExpressions,\n                discardNewJGroupsAttributes\n        ));\n        discoveryGroup.registerOperationTransformer(WRITE_ATTRIBUTE_OPERATION, new ChainedOperationTransformer(\n                rejectDiscoveryGroupExpressions.getWriteAttributeTransformer(),\n                discardNewJGroupsAttributes.getWriteAttributeTransformer()));\n        discoveryGroup.registerOperationTransformer(UNDEFINE_ATTRIBUTE_OPERATION, discardNewJGroupsAttributes.getUndefineAttributeTransformer());\n\n        rejectExpressions(server, DivertDefinition.PATH, DivertDefinition.REJECTED_EXPRESSION_ATTRIBUTES);\n\n        rejectExpressions(server, BridgeDefinition.PATH, BridgeDefinition.REJECTED_EXPRESSION_ATTRIBUTES);\n\n        rejectExpressions(server, QueueDefinition.PATH, QueueDefinition.REJECTED_EXPRESSION_ATTRIBUTES);\n\n        for (String path :  new String[]{ CommonAttributes.ACCEPTOR, CommonAttributes.CONNECTOR }) {\n            TransformersSubRegistration transport = rejectExpressions(server, PathElement.pathElement(path), CommonAttributes.FACTORY_CLASS);\n            rejectExpressions(transport, TransportParamDefinition.PATH, VALUE);\n        }\n\n        for (String path :  new String[]{ CommonAttributes.IN_VM_ACCEPTOR, CommonAttributes.IN_VM_CONNECTOR }) {\n            TransformersSubRegistration transport = rejectExpressions(server, PathElement.pathElement(path), InVMTransportDefinition.SERVER_ID);\n            rejectExpressions(transport, TransportParamDefinition.PATH, VALUE);\n        }\n\n        for (String path :  new String[]{ CommonAttributes.REMOTE_ACCEPTOR, CommonAttributes.REMOTE_CONNECTOR }) {\n            TransformersSubRegistration transport = server.registerSubResource(PathElement.pathElement(path));\n            rejectExpressions(transport, TransportParamDefinition.PATH, VALUE);\n        }\n\n        for (final String path : MessagingPathHandlers.PATHS.keySet()) {\n            rejectExpressions(server, PathElement.pathElement(PATH, path), PATH);\n        }\n\n        RejectExpressionValuesTransformer rejectClusterConnectionExpressions = new RejectExpressionValuesTransformer(ClusterConnectionDefinition.REJECTED_EXPRESSION_ATTRIBUTES);\n        MessagingDiscardAttributesTransformer discardCallFailoverTimeoutAttribute = new MessagingDiscardAttributesTransformer(CALL_FAILOVER_TIMEOUT);\n        TransformersSubRegistration clusterConnection = server.registerSubResource(ClusterConnectionDefinition.PATH, rejectClusterConnectionExpressions, rejectClusterConnectionExpressions);\n        clusterConnection.registerOperationTransformer(ADD, new ChainedOperationTransformer(\n                rejectClusterConnectionExpressions,\n                discardCallFailoverTimeoutAttribute));\n        clusterConnection.registerOperationTransformer(WRITE_ATTRIBUTE_OPERATION, new ChainedOperationTransformer(\n                rejectClusterConnectionExpressions.getWriteAttributeTransformer(),\n                new OperationTransformers.FailUnignoredAttributesOperationTransformer(CALL_FAILOVER_TIMEOUT)));\n        clusterConnection.registerOperationTransformer(UNDEFINE_ATTRIBUTE_OPERATION, discardCallFailoverTimeoutAttribute.getUndefineAttributeTransformer());\n\n        TransformersSubRegistration connectorService = rejectExpressions(server, ConnectorServiceDefinition.PATH, CommonAttributes.FACTORY_CLASS);\n        rejectExpressions(connectorService, ConnectorServiceParamDefinition.PATH, VALUE);\n\n        RejectExpressionValuesTransformer rejectConnectionFactoryExpressions = new RejectExpressionValuesTransformer(ConnectionFactoryDefinition.REJECTED_EXPRESSION_ATTRIBUTES);\n        TransformersSubRegistration connectionFactory = server.registerSubResource(ConnectionFactoryDefinition.PATH, rejectConnectionFactoryExpressions, rejectConnectionFactoryExpressions);\n        connectionFactory.registerOperationTransformer(ADD, new ChainedOperationTransformer(\n                rejectConnectionFactoryExpressions,\n                discardCallFailoverTimeoutAttribute));\n        connectionFactory.registerOperationTransformer(WRITE_ATTRIBUTE_OPERATION, new ChainedOperationTransformer(\n                rejectConnectionFactoryExpressions.getWriteAttributeTransformer(),\n                new OperationTransformers.FailUnignoredAttributesOperationTransformer(CALL_FAILOVER_TIMEOUT)));\n        connectionFactory.registerOperationTransformer(UNDEFINE_ATTRIBUTE_OPERATION, discardCallFailoverTimeoutAttribute.getUndefineAttributeTransformer());\n\n        RejectExpressionValuesTransformer rejectPooledConnectionFactoryExpressions = new RejectExpressionValuesTransformer(PooledConnectionFactoryDefinition.REJECTED_EXPRESSION_ATTRIBUTES);\n        DiscardAttributesTransformer discardNewPooledConnectionFactoryAttributes = new MessagingDiscardAttributesTransformer(addedPooledCFAttributes);\n        ChainedOperationTransformer chainedPooledConnectionFactoryOps = new ChainedOperationTransformer(\n                rejectConnectionFactoryExpressions,\n                discardNewPooledConnectionFactoryAttributes,\n                new OperationTransformers.InsertDefaultValuesOperationTransformer(ConnectionFactoryAttributes.Pooled.RECONNECT_ATTEMPTS));\n        TransformersSubRegistration pooledConnectionFactory = server.registerSubResource(PooledConnectionFactoryDefinition.PATH, rejectPooledConnectionFactoryExpressions, chainedPooledConnectionFactoryOps);\n        pooledConnectionFactory.registerOperationTransformer(ADD, chainedPooledConnectionFactoryOps);\n        pooledConnectionFactory.registerOperationTransformer(WRITE_ATTRIBUTE_OPERATION, new ChainedOperationTransformer(\n                rejectPooledConnectionFactoryExpressions.getWriteAttributeTransformer(),\n                new OperationTransformers.FailUnignoredAttributesOperationTransformer(addedPooledCFAttributes)));\n        pooledConnectionFactory.registerOperationTransformer(UNDEFINE_ATTRIBUTE_OPERATION, new ChainedOperationTransformer(\n                discardNewPooledConnectionFactoryAttributes.getUndefineAttributeTransformer()));\n\n        rejectExpressions(server, GroupingHandlerDefinition.PATH, GroupingHandlerDefinition.REJECTED_EXPRESSION_ATTRIBUTES);\n\n        rejectExpressions(server, JMSQueueDefinition.PATH, JMSQueueDefinition.REJECTED_EXPRESSION_ATTRIBUTES);\n    }","id":75628,"modified_method":"private static void registerTransformers_1_1_0(final SubsystemRegistration subsystem) {\n\n        final TransformersSubRegistration transformers = subsystem.registerModelTransformers(VERSION_1_1_0, new AbstractSubsystemTransformer(SUBSYSTEM_NAME) {\n\n            private void removeAttributes(ModelNode model, AttributeDefinition... removedAttributes) {\n                for(AttributeDefinition attr: removedAttributes) {\n                    model.remove(attr.getName());\n                }\n            }\n\n            @Override\n            public ModelNode transformModel(final TransformationContext context, final ModelNode model) {\n                ModelNode oldModel = model.clone();\n                if (oldModel.hasDefined(HORNETQ_SERVER)) {\n                    for (Property server : oldModel.get(HORNETQ_SERVER).asPropertyList()) {\n                        ModelNode oldServer = oldModel.get(HORNETQ_SERVER, server.getName());\n                        if (!oldServer.hasDefined(CLUSTERED.getName())) {\n                            oldServer.get(CLUSTERED.getName()).set(false);\n                        }\n                        removeAttributes(oldServer, HornetQServerResourceDefinition.NEW_ATTRIBUTES_ADDED_AFTER_1_1_0);\n\n                        if (server.getValue().hasDefined(CLUSTER_CONNECTION)) {\n                            for (Property clusterConnection : server.getValue().get(CLUSTER_CONNECTION).asPropertyList()) {\n                                removeAttributes(oldServer.get(CLUSTER_CONNECTION, clusterConnection.getName()), ClusterConnectionDefinition.NEW_ATTRIBUTES_ADDED_AFTER_1_1_0);\n                            }\n                        }\n                        if (server.getValue().hasDefined(BROADCAST_GROUP)) {\n                            for (Property broadcastGroup : server.getValue().get(BROADCAST_GROUP).asPropertyList()) {\n                                removeAttributes(oldServer.get(BROADCAST_GROUP, broadcastGroup.getName()), BroadcastGroupDefinition.NEW_ATTRIBUTES_ADDED_AFTER_1_1_0);\n                            }\n                        }\n                        if (server.getValue().hasDefined(DISCOVERY_GROUP)) {\n                            for (Property discoveryGroup : server.getValue().get(DISCOVERY_GROUP).asPropertyList()) {\n                                removeAttributes(oldServer.get(DISCOVERY_GROUP, discoveryGroup.getName()), DiscoveryGroupDefinition.NEW_ATTRIBUTES_ADDED_AFTER_1_1_0);\n                            }\n                        }\n                        if (server.getValue().hasDefined(POOLED_CONNECTION_FACTORY)) {\n                            for (Property pooledConnectionFactory : server.getValue().get(POOLED_CONNECTION_FACTORY).asPropertyList()) {\n                                removeAttributes(oldServer.get(POOLED_CONNECTION_FACTORY, pooledConnectionFactory.getName()), PooledConnectionFactoryDefinition.NEW_ATTRIBUTES_ADDED_AFTER_1_1_0);\n                            }\n                        }\n                        if (server.getValue().hasDefined(CONNECTION_FACTORY)) {\n                            for (Property connectionFactory : server.getValue().get(CONNECTION_FACTORY).asPropertyList()) {\n                                removeAttributes(oldServer.get(CONNECTION_FACTORY, connectionFactory.getName()), ConnectionFactoryDefinition.NEW_ATTRIBUTES_ADDED_AFTER_1_1_0);\n                                if (!connectionFactory.getValue().hasDefined(HA.getName())) {\n                                    oldServer.get(CONNECTION_FACTORY, connectionFactory.getName()).get(HA.getName()).set(HA.getDefaultValue());\n                                }\n                                if (connectionFactory.getValue().hasDefined(FACTORY_TYPE.getName()) && (connectionFactory.getValue().get(FACTORY_TYPE.getName()).equals(FACTORY_TYPE.getDefaultValue()))) {\n                                    oldServer.get(CONNECTION_FACTORY, connectionFactory.getName()).get(FACTORY_TYPE.getName()).set(new ModelNode());\n                                }\n                            }\n                        }\n                        //TODO - a nicer way to automagically remove these runtime resources?\n                        if (server.getValue().hasDefined(CORE_ADDRESS)) {\n                            oldServer.remove(CORE_ADDRESS);\n                        }\n                        if (server.getValue().hasDefined(RUNTIME_QUEUE)) {\n                            oldServer.remove(RUNTIME_QUEUE);\n                        }\n                    }\n                }\n                return oldModel;\n            }\n        });\n\n        RejectExpressionValuesTransformer rejectServerExpressionTransformer = new RejectExpressionValuesTransformer(HornetQServerResourceDefinition.ATTRIBUTES_WITH_EXPRESSION_AFTER_1_1_0);\n        DiscardUndefinedAttributesTransformer discardUndefinedServerAttributes = new DiscardUndefinedAttributesTransformer(HornetQServerResourceDefinition.NEW_ATTRIBUTES_ADDED_AFTER_1_1_0);\n        TransformersSubRegistration server = transformers.registerSubResource(PathElement.pathElement(HORNETQ_SERVER));\n        server.registerOperationTransformer(ADD, new ChainedOperationTransformer(\n                new OperationTransformers.InsertDefaultValuesOperationTransformer(ID_CACHE_SIZE, CLUSTERED),\n                rejectServerExpressionTransformer,\n                discardUndefinedServerAttributes));\n        server.registerOperationTransformer(WRITE_ATTRIBUTE_OPERATION, new ChainedOperationTransformer(\n                rejectServerExpressionTransformer.getWriteAttributeTransformer(),\n                discardUndefinedServerAttributes.getWriteAttributeTransformer()));\n        server.registerOperationTransformer(UNDEFINE_ATTRIBUTE_OPERATION, new ChainedOperationTransformer(\n                discardUndefinedServerAttributes.getUndefineAttributeTransformer()));\n\n        rejectExpressions(server, AddressSettingDefinition.PATH, AddressSettingDefinition.REJECTED_EXPRESSION_ATTRIBUTES);\n\n        DiscardUndefinedAttributesTransformer discardBroadcastUndefinedAttributes = new DiscardUndefinedAttributesTransformer(BroadcastGroupDefinition.NEW_ATTRIBUTES_ADDED_AFTER_1_1_0);\n        RejectExpressionValuesTransformer rejectBroadcastGroupExpressions = new RejectExpressionValuesTransformer(BroadcastGroupDefinition.ATTRIBUTES_WITH_EXPRESSION_AFTER_1_1_0);\n        TransformersSubRegistration broadcastGroup = server.registerSubResource(BroadcastGroupDefinition.PATH);\n        broadcastGroup.registerOperationTransformer(ADD, new ChainedOperationTransformer(\n                rejectBroadcastGroupExpressions,\n                discardBroadcastUndefinedAttributes));\n        broadcastGroup.registerOperationTransformer(WRITE_ATTRIBUTE_OPERATION, new ChainedOperationTransformer(\n                rejectBroadcastGroupExpressions.getWriteAttributeTransformer(),\n                discardBroadcastUndefinedAttributes.getWriteAttributeTransformer()));\n        broadcastGroup.registerOperationTransformer(UNDEFINE_ATTRIBUTE_OPERATION, new ChainedOperationTransformer(\n                discardBroadcastUndefinedAttributes.getUndefineAttributeTransformer()));\n\n        DiscardUndefinedAttributesTransformer discardDiscoveryGroupUndefinedAttributes = new DiscardUndefinedAttributesTransformer(DiscoveryGroupDefinition.NEW_ATTRIBUTES_ADDED_AFTER_1_1_0);\n        RejectExpressionValuesTransformer rejectDiscoveryGroupExpressions = new RejectExpressionValuesTransformer(DiscoveryGroupDefinition.ATTRIBUTES_WITH_EXPRESSION_AFTER_1_1_0);\n        TransformersSubRegistration discoveryGroup = server.registerSubResource(DiscoveryGroupDefinition.PATH);\n        discoveryGroup.registerOperationTransformer(ADD, new ChainedOperationTransformer(\n                rejectDiscoveryGroupExpressions,\n                discardDiscoveryGroupUndefinedAttributes));\n        discoveryGroup.registerOperationTransformer(WRITE_ATTRIBUTE_OPERATION, new ChainedOperationTransformer(\n                rejectDiscoveryGroupExpressions.getWriteAttributeTransformer(),\n                discardDiscoveryGroupUndefinedAttributes.getWriteAttributeTransformer()));\n        discoveryGroup.registerOperationTransformer(UNDEFINE_ATTRIBUTE_OPERATION, new ChainedOperationTransformer(\n                discardDiscoveryGroupUndefinedAttributes.getUndefineAttributeTransformer()));\n\n        rejectExpressions(server, DivertDefinition.PATH, DivertDefinition.ATTRIBUTES_WITH_EXPRESSION_AFTER_1_1_0);\n\n        rejectExpressions(server, BridgeDefinition.PATH, BridgeDefinition.ATTRIBUTES_WITH_EXPRESSION_AFTER_1_1_0);\n\n        rejectExpressions(server, QueueDefinition.PATH, QueueDefinition.ATTRIBUTES_WITH_EXPRESSION_AFTER_1_1_0);\n\n        for (String path :  new String[]{ CommonAttributes.ACCEPTOR, CommonAttributes.CONNECTOR }) {\n            TransformersSubRegistration transport = rejectExpressions(server, PathElement.pathElement(path), CommonAttributes.FACTORY_CLASS);\n            rejectExpressions(transport, TransportParamDefinition.PATH, TransportParamDefinition.ATTRIBUTES_WITH_EXPRESSION_AFTER_1_1_0);\n        }\n\n        for (String path :  new String[]{ CommonAttributes.IN_VM_ACCEPTOR, CommonAttributes.IN_VM_CONNECTOR }) {\n            TransformersSubRegistration transport = rejectExpressions(server, PathElement.pathElement(path), InVMTransportDefinition.ATTRIBUTES_WITH_EXPRESSION_AFTER_1_1_0);\n            rejectExpressions(transport, TransportParamDefinition.PATH, TransportParamDefinition.ATTRIBUTES_WITH_EXPRESSION_AFTER_1_1_0);\n        }\n\n        for (String path :  new String[]{ CommonAttributes.REMOTE_ACCEPTOR, CommonAttributes.REMOTE_CONNECTOR }) {\n            TransformersSubRegistration transport = server.registerSubResource(PathElement.pathElement(path));\n            rejectExpressions(transport, TransportParamDefinition.PATH, TransportParamDefinition.ATTRIBUTES_WITH_EXPRESSION_AFTER_1_1_0);\n        }\n\n        for (final String path : MessagingPathHandlers.PATHS.keySet()) {\n            rejectExpressions(server, PathElement.pathElement(PATH, path), PATH);\n        }\n\n        RejectExpressionValuesTransformer rejectClusterConnectionExpressions = new RejectExpressionValuesTransformer(ClusterConnectionDefinition.ATTRIBUTES_WITH_EXPRESSION_AFTER_1_1_0);\n        DiscardUndefinedAttributesTransformer discardClusterConnectionUndefinedAttributes = new DiscardUndefinedAttributesTransformer(ClusterConnectionDefinition.NEW_ATTRIBUTES_ADDED_AFTER_1_1_0);\n        TransformersSubRegistration clusterConnection = server.registerSubResource(ClusterConnectionDefinition.PATH, rejectClusterConnectionExpressions, rejectClusterConnectionExpressions);\n        clusterConnection.registerOperationTransformer(ADD, new ChainedOperationTransformer(\n                rejectClusterConnectionExpressions,\n                discardClusterConnectionUndefinedAttributes));\n        clusterConnection.registerOperationTransformer(WRITE_ATTRIBUTE_OPERATION, new ChainedOperationTransformer(\n                rejectClusterConnectionExpressions.getWriteAttributeTransformer(),\n                discardClusterConnectionUndefinedAttributes.getWriteAttributeTransformer()));\n        clusterConnection.registerOperationTransformer(UNDEFINE_ATTRIBUTE_OPERATION, new ChainedOperationTransformer(\n                discardClusterConnectionUndefinedAttributes.getUndefineAttributeTransformer()));\n\n        TransformersSubRegistration connectorService = rejectExpressions(server, ConnectorServiceDefinition.PATH, CommonAttributes.FACTORY_CLASS);\n        rejectExpressions(connectorService, ConnectorServiceParamDefinition.PATH, VALUE);\n\n        RejectExpressionValuesTransformer rejectConnectionFactoryExpressions = new RejectExpressionValuesTransformer(ConnectionFactoryDefinition.ATTRIBUTES_WITH_EXPRESSION_AFTER_1_1_0);\n        DiscardUndefinedAttributesTransformer discardConnectionFactoryUndefinedAttributes = new DiscardUndefinedAttributesTransformer(ConnectionFactoryDefinition.NEW_ATTRIBUTES_ADDED_AFTER_1_1_0);\n        TransformersSubRegistration connectionFactory = server.registerSubResource(ConnectionFactoryDefinition.PATH, rejectConnectionFactoryExpressions, rejectConnectionFactoryExpressions);\n        connectionFactory.registerOperationTransformer(ADD, new ChainedOperationTransformer(\n                rejectConnectionFactoryExpressions,\n                discardConnectionFactoryUndefinedAttributes));\n        connectionFactory.registerOperationTransformer(WRITE_ATTRIBUTE_OPERATION, new ChainedOperationTransformer(\n                rejectConnectionFactoryExpressions.getWriteAttributeTransformer(),\n                discardConnectionFactoryUndefinedAttributes.getWriteAttributeTransformer()));\n        connectionFactory.registerOperationTransformer(UNDEFINE_ATTRIBUTE_OPERATION, new ChainedOperationTransformer(\n                discardConnectionFactoryUndefinedAttributes.getUndefineAttributeTransformer()));\n\n        RejectExpressionValuesTransformer rejectPooledConnectionFactoryExpressions = new RejectExpressionValuesTransformer(PooledConnectionFactoryDefinition.ATTRIBUTES_WITH_EXPRESSION_AFTER_1_1_0);\n        DiscardUndefinedAttributesTransformer discardUndefinedPooledConnectionFactoryAttributes = new DiscardUndefinedAttributesTransformer(PooledConnectionFactoryDefinition.NEW_ATTRIBUTES_ADDED_AFTER_1_1_0);\n        TransformersSubRegistration pooledConnectionFactory = server.registerSubResource(PooledConnectionFactoryDefinition.PATH);\n        pooledConnectionFactory.registerOperationTransformer(ADD, new ChainedOperationTransformer(\n                new OperationTransformers.InsertDefaultValuesOperationTransformer(ConnectionFactoryAttributes.Pooled.RECONNECT_ATTEMPTS),\n                rejectConnectionFactoryExpressions,\n                discardUndefinedPooledConnectionFactoryAttributes));\n        pooledConnectionFactory.registerOperationTransformer(WRITE_ATTRIBUTE_OPERATION, new ChainedOperationTransformer(\n                rejectPooledConnectionFactoryExpressions.getWriteAttributeTransformer(),\n                discardUndefinedPooledConnectionFactoryAttributes.getWriteAttributeTransformer()));\n        pooledConnectionFactory.registerOperationTransformer(UNDEFINE_ATTRIBUTE_OPERATION, new ChainedOperationTransformer(\n                discardUndefinedPooledConnectionFactoryAttributes.getUndefineAttributeTransformer()));\n\n        rejectExpressions(server, GroupingHandlerDefinition.PATH, GroupingHandlerDefinition.ATTRIBUTES_WITH_EXPRESSION_AFTER_1_1_0);\n\n        rejectExpressions(server, JMSQueueDefinition.PATH, JMSQueueDefinition.ATTRIBUTES_WITH_EXPRESSION_AFTER_1_1_0);\n    }","commit_id":"dea4a5879bb6886e90fda24149641e4a279846fb","url":"https://github.com/wildfly/wildfly"},{"original_method":"public ArjunaObjectStoreEnvironmentService(boolean useHornetqJournalStore, String path, String pathRef) {\n        this.useHornetqJournalStore = useHornetqJournalStore;\n        this.path = path;\n        this.pathRef = pathRef;\n    }","id":75629,"modified_method":"public ArjunaObjectStoreEnvironmentService(final boolean useHornetqJournalStore, final String path, final String pathRef, final boolean useJdbcStore, final String dataSourceJndiName, final JdbcStoreConfig jdbcSoreConfig) {\n        this.useHornetqJournalStore = useHornetqJournalStore;\n        this.path = path;\n        this.pathRef = pathRef;\n        this.useJdbcStore = useJdbcStore;\n        this.dataSourceJndiName = dataSourceJndiName;\n        this.jdbcSoreConfig = jdbcSoreConfig;\n    }","commit_id":"639986f69d2b62c5b732ccbc50df4183e44c2e88","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void start(StartContext context) throws StartException {\n        callbackHandle = pathManagerInjector.getValue().registerCallback(pathRef, PathManager.ReloadServerCallback.create(), PathManager.Event.UPDATED, PathManager.Event.REMOVED);\n        String objectStoreDir = pathManagerInjector.getValue().resolveRelativePathEntry(path, pathRef);\n\n         final ObjectStoreEnvironmentBean defaultActionStoreObjectStoreEnvironmentBean =\n           BeanPopulator.getNamedInstance(ObjectStoreEnvironmentBean.class, \"default\");\n\n        if(useHornetqJournalStore) {\n            HornetqJournalEnvironmentBean hornetqJournalEnvironmentBean = BeanPopulator.getDefaultInstance(\n                    com.arjuna.ats.internal.arjuna.objectstore.hornetq.HornetqJournalEnvironmentBean.class\n            );\n            hornetqJournalEnvironmentBean.setStoreDir(objectStoreDir+\"/HornetqObjectStore\");\n            defaultActionStoreObjectStoreEnvironmentBean.setObjectStoreType(\n                    \"com.arjuna.ats.internal.arjuna.objectstore.hornetq.HornetqObjectStoreAdaptor\"\n            );\n        } else {\n            defaultActionStoreObjectStoreEnvironmentBean.setObjectStoreDir(objectStoreDir);\n        }\n\n        final ObjectStoreEnvironmentBean stateStoreObjectStoreEnvironmentBean =\n            BeanPopulator.getNamedInstance(ObjectStoreEnvironmentBean.class, \"stateStore\");\n        stateStoreObjectStoreEnvironmentBean.setObjectStoreDir(objectStoreDir);\n        final ObjectStoreEnvironmentBean communicationStoreObjectStoreEnvironmentBean =\n            BeanPopulator.getNamedInstance(ObjectStoreEnvironmentBean.class, \"communicationStore\");\n        communicationStoreObjectStoreEnvironmentBean.setObjectStoreDir(objectStoreDir);\n    }","id":75630,"modified_method":"@Override\n    public void start(StartContext context) throws StartException {\n        callbackHandle = pathManagerInjector.getValue().registerCallback(pathRef, PathManager.ReloadServerCallback.create(), PathManager.Event.UPDATED, PathManager.Event.REMOVED);\n        String objectStoreDir = pathManagerInjector.getValue().resolveRelativePathEntry(path, pathRef);\n\n         final ObjectStoreEnvironmentBean defaultActionStoreObjectStoreEnvironmentBean =\n           BeanPopulator.getNamedInstance(ObjectStoreEnvironmentBean.class, \"default\");\n\n\n        if(useHornetqJournalStore) {\n            HornetqJournalEnvironmentBean hornetqJournalEnvironmentBean = BeanPopulator.getDefaultInstance(\n                    com.arjuna.ats.internal.arjuna.objectstore.hornetq.HornetqJournalEnvironmentBean.class\n            );\n            hornetqJournalEnvironmentBean.setStoreDir(objectStoreDir+\"/HornetqObjectStore\");\n            defaultActionStoreObjectStoreEnvironmentBean.setObjectStoreType(\n                    \"com.arjuna.ats.internal.arjuna.objectstore.hornetq.HornetqObjectStoreAdaptor\"\n            );\n        } else {\n            defaultActionStoreObjectStoreEnvironmentBean.setObjectStoreDir(objectStoreDir);\n        }\n\n        final ObjectStoreEnvironmentBean stateStoreObjectStoreEnvironmentBean =\n            BeanPopulator.getNamedInstance(ObjectStoreEnvironmentBean.class, \"stateStore\");\n        stateStoreObjectStoreEnvironmentBean.setObjectStoreDir(objectStoreDir);\n        final ObjectStoreEnvironmentBean communicationStoreObjectStoreEnvironmentBean =\n            BeanPopulator.getNamedInstance(ObjectStoreEnvironmentBean.class, \"communicationStore\");\n        communicationStoreObjectStoreEnvironmentBean.setObjectStoreDir(objectStoreDir);\n\n        if(useJdbcStore) {\n            defaultActionStoreObjectStoreEnvironmentBean.setObjectStoreType(\"com.arjuna.ats.internal.arjuna.objectstore.jdbc.JDBCStore\");\n            stateStoreObjectStoreEnvironmentBean.setObjectStoreType(\"com.arjuna.ats.internal.arjuna.objectstore.jdbc.JDBCStore\");\n            communicationStoreObjectStoreEnvironmentBean.setObjectStoreType(\"com.arjuna.ats.internal.arjuna.objectstore.jdbc.JDBCStore\");\n\n            defaultActionStoreObjectStoreEnvironmentBean.setJdbcAccess(\"com.arjuna.ats.internal.arjuna.objectstore.jdbc.accessors.DataSourceJDBCAccess;datasourceName=\" + dataSourceJndiName);\n            stateStoreObjectStoreEnvironmentBean.setJdbcAccess(\"com.arjuna.ats.internal.arjuna.objectstore.jdbc.accessors.DataSourceJDBCAccess;datasourceName=\" + dataSourceJndiName);\n            communicationStoreObjectStoreEnvironmentBean.setJdbcAccess(\"com.arjuna.ats.internal.arjuna.objectstore.jdbc.accessors.DataSourceJDBCAccess;datasourceName=\" + dataSourceJndiName);\n\n\n            defaultActionStoreObjectStoreEnvironmentBean.setTablePrefix(jdbcSoreConfig.getActionTablePrefix());\n            stateStoreObjectStoreEnvironmentBean.setTablePrefix(jdbcSoreConfig.getStateTablePrefix());\n            communicationStoreObjectStoreEnvironmentBean.setTablePrefix(jdbcSoreConfig.getCommunicationTablePrefix());\n\n\n            defaultActionStoreObjectStoreEnvironmentBean.setDropTable(jdbcSoreConfig.isActionDropTable());\n            stateStoreObjectStoreEnvironmentBean.setDropTable(jdbcSoreConfig.isStateDropTable());\n            communicationStoreObjectStoreEnvironmentBean.setDropTable(jdbcSoreConfig.isCommunicationDropTable());\n\n        }\n\n    }","commit_id":"639986f69d2b62c5b732ccbc50df4183e44c2e88","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Register the transformers for older model versions.\n     *\n     * @param subsystem the subsystems registration\n     */\n    private static void registerTransformers(final SubsystemRegistration subsystem) {\n\n        // Check the resource and operations for expressions\n\n        // Transformations to the 1.1.0 Model:\n        final ModelVersion version110 = ModelVersion.create(1, 1, 0);\n        final RejectExpressionValuesTransformer reject =\n                new RejectExpressionValuesTransformer(TransactionSubsystemRootResourceDefinition.attributes);\n        final TransformersSubRegistration registration = subsystem.registerModelTransformers(version110, new ChainedResourceTransformer(\n                new ChainedResourceTransformerEntry() {\n                    @Override\n                    public void transformResource(ChainedResourceTransformationContext context, PathAddress address, Resource resource)\n                            throws OperationFailedException {\n                        ModelNode model = resource.getModel();\n                        if (!model.hasDefined(TransactionSubsystemRootResourceDefinition.PROCESS_ID_UUID.getName())) {\n                            model.get(TransactionSubsystemRootResourceDefinition.PROCESS_ID_UUID.getName()).set(false);\n                        }\n                        System.out.println(resource.getModel());\n                    }\n                },\n                reject.getChainedTransformer()));\n        registration.registerOperationTransformer(ADD, reject);\n        registration.registerOperationTransformer(WRITE_ATTRIBUTE_OPERATION, reject.getWriteAttributeTransformer());\n\n    }","id":75631,"modified_method":"/**\n     * Register the transformers for older model versions.\n     *\n     * @param subsystem the subsystems registration\n     */\n    private static void registerTransformers(final SubsystemRegistration subsystem) {\n\n        // Check the resource and operations for expressions\n\n        // Transformations to the 1.1.1 Model:\n        final ModelVersion version111 = ModelVersion.create(1, 1, 1);\n        // Check for new attributes\n        final DiscardUndefinedAttributesTransformer discardTransformer =\n                new DiscardUndefinedAttributesTransformer(TransactionSubsystemRootResourceDefinition.attributes_1_2);\n        final TransformersSubRegistration transformers111 = subsystem.registerModelTransformers(version111, discardTransformer);\n        transformers111.registerOperationTransformer(ADD, discardTransformer);\n        transformers111.registerOperationTransformer(WRITE_ATTRIBUTE_OPERATION, discardTransformer.getWriteAttributeTransformer());\n        transformers111.registerOperationTransformer(UNDEFINE_ATTRIBUTE_OPERATION, discardTransformer.getUndefineAttributeTransformer());\n        // Check the resource and operations for expressions\n\n        // Transformations to the 1.1.0 Model:\n        final ModelVersion version110 = ModelVersion.create(1, 1, 0);\n        // Reject expressions, check for new attributes, store UUID in the root resource if undefined\n        final RejectExpressionValuesTransformer reject =\n                new RejectExpressionValuesTransformer(TransactionSubsystemRootResourceDefinition.attributes);\n        final TransformersSubRegistration registration = subsystem.registerModelTransformers(version110, new ChainedResourceTransformer(\n                new ChainedResourceTransformerEntry() {\n                    @Override\n                    public void transformResource(ChainedResourceTransformationContext context, PathAddress address, Resource resource)\n                            throws OperationFailedException {\n                        ModelNode model = resource.getModel();\n                        if (!model.hasDefined(TransactionSubsystemRootResourceDefinition.PROCESS_ID_UUID.getName())) {\n                            model.get(TransactionSubsystemRootResourceDefinition.PROCESS_ID_UUID.getName()).set(false);\n                        }\n                    }\n                },\n                reject.getChainedTransformer(),\n                discardTransformer));\n        registration.registerOperationTransformer(ADD, reject);\n        registration.registerOperationTransformer(WRITE_ATTRIBUTE_OPERATION,\n                new ChainedOperationTransformer(reject.getWriteAttributeTransformer(), discardTransformer.getWriteAttributeTransformer()));\n        registration.registerOperationTransformer(UNDEFINE_ATTRIBUTE_OPERATION, discardTransformer.getUndefineAttributeTransformer());\n    }","commit_id":"639986f69d2b62c5b732ccbc50df4183e44c2e88","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public void initialize(ExtensionContext context) {\n        ROOT_LOGGER.debug(\"Initializing Transactions Extension\");\n        final LogStoreResource resource = new LogStoreResource();\n        final boolean registerRuntimeOnly = context.isRuntimeOnlyRegistrationValid();\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, MANAGEMENT_API_MAJOR_VERSION,\n                MANAGEMENT_API_MINOR_VERSION, MANAGEMENT_API_MICRO_VERSION);\n\n        final TransactionSubsystemRootResourceDefinition rootResourceDefinition = new TransactionSubsystemRootResourceDefinition(registerRuntimeOnly);\n        final ManagementResourceRegistration registration = subsystem.registerSubsystemModel(rootResourceDefinition);\n        registration.registerOperationHandler(GenericSubsystemDescribeHandler.DEFINITION, GenericSubsystemDescribeHandler.INSTANCE);\n\n        // Create the path resolver handlers\n        if (context.getProcessType().isServer()) {\n            // It's less than ideal to create a separate operation here, but this extension contains two relative-to attributes\n            final ResolvePathHandler objectStorePathHandler = ResolvePathHandler.Builder.of(RESOLVE_OBJECT_STORE_PATH, context.getPathManager())\n                   .setPathAttribute(TransactionSubsystemRootResourceDefinition.OBJECT_STORE_PATH)\n                   .setRelativeToAttribute(TransactionSubsystemRootResourceDefinition.OBJECT_STORE_RELATIVE_TO)\n                   .build();\n            registration.registerOperationHandler(objectStorePathHandler.getOperationDefinition(), objectStorePathHandler);\n\n            final ResolvePathHandler resolvePathHandler = ResolvePathHandler.Builder.of(context.getPathManager())\n                    .setPathAttribute(TransactionSubsystemRootResourceDefinition.PATH)\n                    .setRelativeToAttribute(TransactionSubsystemRootResourceDefinition.RELATIVE_TO)\n                    .build();\n            registration.registerOperationHandler(resolvePathHandler.getOperationDefinition(), resolvePathHandler);\n        }\n\n\n        ManagementResourceRegistration logStoreChild = registration.registerSubModel(new LogStoreDefinition(resource));\n        if (registerRuntimeOnly) {\n            ManagementResourceRegistration transactionChild = logStoreChild.registerSubModel(new LogStoreTransactionDefinition(resource));\n            transactionChild.registerSubModel(LogStoreTransactionParticipantDefinition.INSTANCE);\n        }\n\n        subsystem.registerXMLElementWriter(TransactionSubsystem12Parser.INSTANCE);\n\n        if (context.isRegisterTransformers()) {\n            // Register the model transformers\n            registerTransformers(subsystem);\n        }\n    }","id":75632,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public void initialize(ExtensionContext context) {\n        ROOT_LOGGER.debug(\"Initializing Transactions Extension\");\n        final LogStoreResource resource = new LogStoreResource();\n        final boolean registerRuntimeOnly = context.isRuntimeOnlyRegistrationValid();\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, MANAGEMENT_API_MAJOR_VERSION,\n                MANAGEMENT_API_MINOR_VERSION, MANAGEMENT_API_MICRO_VERSION);\n\n        final TransactionSubsystemRootResourceDefinition rootResourceDefinition = new TransactionSubsystemRootResourceDefinition(registerRuntimeOnly);\n        final ManagementResourceRegistration registration = subsystem.registerSubsystemModel(rootResourceDefinition);\n        registration.registerOperationHandler(GenericSubsystemDescribeHandler.DEFINITION, GenericSubsystemDescribeHandler.INSTANCE);\n\n        // Create the path resolver handlers\n        if (context.getProcessType().isServer()) {\n            // It's less than ideal to create a separate operation here, but this extension contains two relative-to attributes\n            final ResolvePathHandler objectStorePathHandler = ResolvePathHandler.Builder.of(RESOLVE_OBJECT_STORE_PATH, context.getPathManager())\n                   .setPathAttribute(TransactionSubsystemRootResourceDefinition.OBJECT_STORE_PATH)\n                   .setRelativeToAttribute(TransactionSubsystemRootResourceDefinition.OBJECT_STORE_RELATIVE_TO)\n                   .build();\n            registration.registerOperationHandler(objectStorePathHandler.getOperationDefinition(), objectStorePathHandler);\n\n            final ResolvePathHandler resolvePathHandler = ResolvePathHandler.Builder.of(context.getPathManager())\n                    .setPathAttribute(TransactionSubsystemRootResourceDefinition.PATH)\n                    .setRelativeToAttribute(TransactionSubsystemRootResourceDefinition.RELATIVE_TO)\n                    .build();\n            registration.registerOperationHandler(resolvePathHandler.getOperationDefinition(), resolvePathHandler);\n        }\n\n\n        ManagementResourceRegistration logStoreChild = registration.registerSubModel(new LogStoreDefinition(resource));\n        if (registerRuntimeOnly) {\n            ManagementResourceRegistration transactionChild = logStoreChild.registerSubModel(new LogStoreTransactionDefinition(resource));\n            transactionChild.registerSubModel(LogStoreTransactionParticipantDefinition.INSTANCE);\n        }\n\n        subsystem.registerXMLElementWriter(TransactionSubsystem13Parser.INSTANCE);\n\n        if (context.isRegisterTransformers()) {\n            // Register the model transformers\n            registerTransformers(subsystem);\n        }\n    }","commit_id":"639986f69d2b62c5b732ccbc50df4183e44c2e88","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public void initializeParsers(ExtensionParsingContext context) {\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.TRANSACTIONS_1_0.getUriString(), TransactionSubsystem10Parser.INSTANCE);\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.TRANSACTIONS_1_1.getUriString(), TransactionSubsystem11Parser.INSTANCE);\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.TRANSACTIONS_1_2.getUriString(), TransactionSubsystem12Parser.INSTANCE);\n    }","id":75633,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public void initializeParsers(ExtensionParsingContext context) {\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.TRANSACTIONS_1_0.getUriString(), TransactionSubsystem10Parser.INSTANCE);\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.TRANSACTIONS_1_1.getUriString(), TransactionSubsystem11Parser.INSTANCE);\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.TRANSACTIONS_1_2.getUriString(), TransactionSubsystem12Parser.INSTANCE);\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.TRANSACTIONS_1_3.getUriString(), TransactionSubsystem13Parser.INSTANCE);\n    }","commit_id":"639986f69d2b62c5b732ccbc50df4183e44c2e88","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void performObjectStoreBoottime(OperationContext context, ModelNode operation, ModelNode recoveryEnvModel,\n                                            ServiceVerificationHandler verificationHandler,\n                                            List<ServiceController<?>> controllers, boolean useHornetqJournalStore) throws OperationFailedException {\n\n        final String objectStorePathRef =TransactionSubsystemRootResourceDefinition.OBJECT_STORE_RELATIVE_TO.resolveModelAttribute(context, recoveryEnvModel).asString();\n        final String objectStorePath = TransactionSubsystemRootResourceDefinition.OBJECT_STORE_PATH.resolveModelAttribute(context, recoveryEnvModel).asString();\n        if (ROOT_LOGGER.isDebugEnabled()) {\n            ROOT_LOGGER.debugf(\"objectStorePathRef=%s, objectStorePath=%s\\n\", objectStorePathRef, objectStorePath);\n        }\n\n        ServiceTarget target = context.getServiceTarget();\n        // Configure the ObjectStoreEnvironmentBeans\n        final ArjunaObjectStoreEnvironmentService objStoreEnvironmentService = new ArjunaObjectStoreEnvironmentService(useHornetqJournalStore, objectStorePath, objectStorePathRef);\n        controllers.add(target.addService(TxnServices.JBOSS_TXN_ARJUNA_OBJECTSTORE_ENVIRONMENT, objStoreEnvironmentService)\n                .addDependency(PathManagerService.SERVICE_NAME, PathManager.class, objStoreEnvironmentService.getPathManagerInjector())\n                .addDependency(TxnServices.JBOSS_TXN_CORE_ENVIRONMENT)\n                .addListener(verificationHandler).setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n        controllers.add(TransactionManagerService.addService(target, verificationHandler));\n        controllers.add(UserTransactionService.addService(target, verificationHandler));\n        controllers.add(target.addService(TxnServices.JBOSS_TXN_USER_TRANSACTION_REGISTRY, new UserTransactionRegistryService())\n                .addListener(verificationHandler).setInitialMode(ServiceController.Mode.ACTIVE).install());\n        controllers.add(TransactionSynchronizationRegistryService.addService(target, verificationHandler));\n\n    }","id":75634,"modified_method":"private void performObjectStoreBoottime(OperationContext context, ModelNode operation, ModelNode model,\n                                            ServiceVerificationHandler verificationHandler,\n                                            List<ServiceController<?>> controllers) throws OperationFailedException {\n        boolean useHornetqJournalStore = model.hasDefined(USEHORNETQSTORE) && model.get(USEHORNETQSTORE).asBoolean();\n        final String objectStorePathRef =TransactionSubsystemRootResourceDefinition.OBJECT_STORE_RELATIVE_TO.resolveModelAttribute(context, model).asString();\n        final String objectStorePath = TransactionSubsystemRootResourceDefinition.OBJECT_STORE_PATH.resolveModelAttribute(context, model).asString();\n\n        final boolean useJdbcStore =  model.hasDefined(USE_JDBC_STORE) && model.get(USE_JDBC_STORE).asBoolean();\n        final String dataSourceJndiName = TransactionSubsystemRootResourceDefinition.JDBC_STORE_DATASOURCE.resolveModelAttribute(context, model).asString();\n\n        ArjunaObjectStoreEnvironmentService.JdbcStoreConfigBulder confiBuilder = new ArjunaObjectStoreEnvironmentService.JdbcStoreConfigBulder();\n        confiBuilder.setActionDropTable(TransactionSubsystemRootResourceDefinition.JDBC_ACTION_STORE_DROP_TABLE.resolveModelAttribute(context, model).asBoolean())\n                .setActionTablePrefix(TransactionSubsystemRootResourceDefinition.JDBC_ACTION_STORE_TABLE_PREFIX.resolveModelAttribute(context, model).asString())\n                .setStateDropTable(TransactionSubsystemRootResourceDefinition.JDBC_STATE_STORE_DROP_TABLE.resolveModelAttribute(context, model).asBoolean())\n                .setStateTablePrefix(TransactionSubsystemRootResourceDefinition.JDBC_STATE_STORE_TABLE_PREFIX.resolveModelAttribute(context, model).asString())\n                .setCommunicationDropTable(TransactionSubsystemRootResourceDefinition.JDBC_COMMUNICATION_STORE_DROP_TABLE.resolveModelAttribute(context, model).asBoolean())\n                .setCommunicationTablePrefix(TransactionSubsystemRootResourceDefinition.JDBC_COMMUNICATION_STORE_TABLE_PREFIX.resolveModelAttribute(context, model).asString());\n\n\n        if (ROOT_LOGGER.isDebugEnabled()) {\n            ROOT_LOGGER.debugf(\"objectStorePathRef=%s, objectStorePath=%s\\n\", objectStorePathRef, objectStorePath);\n        }\n\n        ServiceTarget target = context.getServiceTarget();\n        // Configure the ObjectStoreEnvironmentBeans\n        final ArjunaObjectStoreEnvironmentService objStoreEnvironmentService = new ArjunaObjectStoreEnvironmentService(useHornetqJournalStore, objectStorePath, objectStorePathRef, useJdbcStore, dataSourceJndiName, confiBuilder.build());\n        ServiceBuilder builder = target.addService(TxnServices.JBOSS_TXN_ARJUNA_OBJECTSTORE_ENVIRONMENT, objStoreEnvironmentService)\n                .addDependency(PathManagerService.SERVICE_NAME, PathManager.class, objStoreEnvironmentService.getPathManagerInjector())\n                .addDependency(TxnServices.JBOSS_TXN_CORE_ENVIRONMENT);\n        if (useJdbcStore) {\n            builder.addDependency(ServiceName.JBOSS.append(\"data-source\").append(dataSourceJndiName));\n        }\n        controllers.add(builder.addListener(verificationHandler).setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n        controllers.add(TransactionManagerService.addService(target, verificationHandler));\n        controllers.add(UserTransactionService.addService(target, verificationHandler));\n        controllers.add(target.addService(TxnServices.JBOSS_TXN_USER_TRANSACTION_REGISTRY, new UserTransactionRegistryService())\n                .addListener(verificationHandler).setInitialMode(ServiceController.Mode.ACTIVE).install());\n        controllers.add(TransactionSynchronizationRegistryService.addService(target, verificationHandler));\n\n    }","commit_id":"639986f69d2b62c5b732ccbc50df4183e44c2e88","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performBoottime(OperationContext context, ModelNode operation, ModelNode model,\n                                   ServiceVerificationHandler verificationHandler,\n                                   List<ServiceController<?>> controllers) throws OperationFailedException {\n\n        boolean jts = model.hasDefined(JTS) && model.get(JTS).asBoolean();\n        boolean useHornetqJournalStore = model.hasDefined(USEHORNETQSTORE) && model.get(USEHORNETQSTORE).asBoolean();\n\n        //recovery environment\n        performRecoveryEnvBoottime(context, operation, model, verificationHandler, controllers, jts);\n\n        //core environment\n        performCoreEnvironmentBootTime(context, operation, model, verificationHandler, controllers);\n\n        //coordinator environment\n        performCoordinatorEnvBoottime(context, operation, model, verificationHandler, controllers, jts);\n\n        //object store\n        performObjectStoreBoottime(context, operation, model, verificationHandler, controllers, useHornetqJournalStore);\n\n\n        //always propagate the transaction context\n        //TODO: need a better way to do this, but this value gets cached in a static\n        //so we need to make sure we set it before anything tries to read it\n        jtsPropertyManager.getJTSEnvironmentBean().setAlwaysPropagateContext(true);\n\n        context.addStep(new AbstractDeploymentChainStep() {\n            protected void execute(final DeploymentProcessorTarget processorTarget) {\n                processorTarget.addDeploymentProcessor(TransactionExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_TRANSACTION_ROLLBACK_ACTION, new TransactionLeakRollbackProcessor());\n                processorTarget.addDeploymentProcessor(TransactionExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_TRANSACTION_BINDINGS, new TransactionJndiBindingProcessor());\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        final ServiceTarget target = context.getServiceTarget();\n\n        //bind the TransactionManger and the TSR into JNDI\n        final BinderService tmBinderService = new BinderService(\"TransactionManager\");\n        final ServiceBuilder<ManagedReferenceFactory> tmBuilder = context.getServiceTarget().addService(ContextNames.JBOSS_CONTEXT_SERVICE_NAME.append(\"TransactionManager\"), tmBinderService);\n        tmBuilder.addDependency(ContextNames.JBOSS_CONTEXT_SERVICE_NAME, ServiceBasedNamingStore.class, tmBinderService.getNamingStoreInjector());\n        tmBuilder.addDependency(TransactionManagerService.SERVICE_NAME, javax.transaction.TransactionManager.class, new Injector<javax.transaction.TransactionManager>() {\n            @Override\n            public void inject(final javax.transaction.TransactionManager value) throws InjectionException {\n                tmBinderService.getManagedObjectInjector().inject(new ValueManagedReferenceFactory(new ImmediateValue<Object>(value)));\n            }\n\n            @Override\n            public void uninject() {\n                tmBinderService.getManagedObjectInjector().uninject();\n            }\n        });\n        tmBuilder.addListener(verificationHandler);\n        controllers.add(tmBuilder.install());\n\n        final BinderService tmLegacyBinderService = new BinderService(\"TransactionManager\");\n        final ServiceBuilder<ManagedReferenceFactory> tmLegacyBuilder = context.getServiceTarget().addService(ContextNames.JAVA_CONTEXT_SERVICE_NAME.append(\"TransactionManager\"), tmLegacyBinderService);\n        tmLegacyBuilder.addDependency(ContextNames.JAVA_CONTEXT_SERVICE_NAME, ServiceBasedNamingStore.class, tmLegacyBinderService.getNamingStoreInjector());\n        tmLegacyBuilder.addDependency(TransactionManagerService.SERVICE_NAME, javax.transaction.TransactionManager.class, new Injector<javax.transaction.TransactionManager>() {\n            @Override\n            public void inject(final javax.transaction.TransactionManager value) throws InjectionException {\n                tmLegacyBinderService.getManagedObjectInjector().inject(new ValueManagedReferenceFactory(new ImmediateValue<Object>(value)));\n            }\n\n            @Override\n            public void uninject() {\n                tmLegacyBinderService.getManagedObjectInjector().uninject();\n            }\n        });\n        tmLegacyBuilder.addListener(verificationHandler);\n        controllers.add(tmLegacyBuilder.install());\n\n        final BinderService tsrBinderService = new BinderService(\"TransactionSynchronizationRegistry\");\n        final ServiceBuilder<ManagedReferenceFactory> tsrBuilder = context.getServiceTarget().addService(ContextNames.JBOSS_CONTEXT_SERVICE_NAME.append(\"TransactionSynchronizationRegistry\"), tsrBinderService);\n        tsrBuilder.addDependency(ContextNames.JBOSS_CONTEXT_SERVICE_NAME, ServiceBasedNamingStore.class, tsrBinderService.getNamingStoreInjector());\n        tsrBuilder.addDependency(TransactionSynchronizationRegistryService.SERVICE_NAME, TransactionSynchronizationRegistry.class, new Injector<TransactionSynchronizationRegistry>() {\n            @Override\n            public void inject(final TransactionSynchronizationRegistry value) throws InjectionException {\n                tsrBinderService.getManagedObjectInjector().inject(new ValueManagedReferenceFactory(new ImmediateValue<Object>(value)));\n            }\n\n            @Override\n            public void uninject() {\n                tsrBinderService.getManagedObjectInjector().uninject();\n            }\n        });\n        tsrBuilder.addListener(verificationHandler);\n        controllers.add(tsrBuilder.install());\n\n        // Bind the UserTransaction into JNDI\n        final BinderService utBinderService = new BinderService(\"UserTransaction\");\n        final ServiceBuilder<ManagedReferenceFactory> utBuilder = context.getServiceTarget().addService(ContextNames.JBOSS_CONTEXT_SERVICE_NAME.append(\"UserTransaction\"), utBinderService);\n        utBuilder.addDependency(ContextNames.JBOSS_CONTEXT_SERVICE_NAME, ServiceBasedNamingStore.class, utBinderService.getNamingStoreInjector());\n        utBuilder.addDependency(UserTransactionService.SERVICE_NAME, javax.transaction.UserTransaction.class, new Injector<javax.transaction.UserTransaction>() {\n            @Override\n            public void inject(final javax.transaction.UserTransaction value) throws InjectionException {\n                utBinderService.getManagedObjectInjector().inject(new ValueManagedReferenceFactory(new ImmediateValue<Object>(value)));\n            }\n\n            @Override\n            public void uninject() {\n                utBinderService.getManagedObjectInjector().uninject();\n            }\n        });\n        utBuilder.addListener(verificationHandler);\n        controllers.add(utBuilder.install());\n\n\n    }","id":75635,"modified_method":"@Override\n    protected void performBoottime(OperationContext context, ModelNode operation, ModelNode model,\n                                   ServiceVerificationHandler verificationHandler,\n                                   List<ServiceController<?>> controllers) throws OperationFailedException {\n\n        boolean jts = model.hasDefined(JTS) && model.get(JTS).asBoolean();\n\n        //recovery environment\n        performRecoveryEnvBoottime(context, operation, model, verificationHandler, controllers, jts);\n\n        //core environment\n        performCoreEnvironmentBootTime(context, operation, model, verificationHandler, controllers);\n\n        //coordinator environment\n        performCoordinatorEnvBoottime(context, operation, model, verificationHandler, controllers, jts);\n\n        //object store\n        performObjectStoreBoottime(context, operation, model, verificationHandler, controllers);\n\n\n        //always propagate the transaction context\n        //TODO: need a better way to do this, but this value gets cached in a static\n        //so we need to make sure we set it before anything tries to read it\n        jtsPropertyManager.getJTSEnvironmentBean().setAlwaysPropagateContext(true);\n\n        context.addStep(new AbstractDeploymentChainStep() {\n            protected void execute(final DeploymentProcessorTarget processorTarget) {\n                processorTarget.addDeploymentProcessor(TransactionExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_TRANSACTION_ROLLBACK_ACTION, new TransactionLeakRollbackProcessor());\n                processorTarget.addDeploymentProcessor(TransactionExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_TRANSACTION_BINDINGS, new TransactionJndiBindingProcessor());\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        final ServiceTarget target = context.getServiceTarget();\n\n        //bind the TransactionManger and the TSR into JNDI\n        final BinderService tmBinderService = new BinderService(\"TransactionManager\");\n        final ServiceBuilder<ManagedReferenceFactory> tmBuilder = context.getServiceTarget().addService(ContextNames.JBOSS_CONTEXT_SERVICE_NAME.append(\"TransactionManager\"), tmBinderService);\n        tmBuilder.addDependency(ContextNames.JBOSS_CONTEXT_SERVICE_NAME, ServiceBasedNamingStore.class, tmBinderService.getNamingStoreInjector());\n        tmBuilder.addDependency(TransactionManagerService.SERVICE_NAME, javax.transaction.TransactionManager.class, new Injector<javax.transaction.TransactionManager>() {\n            @Override\n            public void inject(final javax.transaction.TransactionManager value) throws InjectionException {\n                tmBinderService.getManagedObjectInjector().inject(new ValueManagedReferenceFactory(new ImmediateValue<Object>(value)));\n            }\n\n            @Override\n            public void uninject() {\n                tmBinderService.getManagedObjectInjector().uninject();\n            }\n        });\n        tmBuilder.addListener(verificationHandler);\n        controllers.add(tmBuilder.install());\n\n        final BinderService tmLegacyBinderService = new BinderService(\"TransactionManager\");\n        final ServiceBuilder<ManagedReferenceFactory> tmLegacyBuilder = context.getServiceTarget().addService(ContextNames.JAVA_CONTEXT_SERVICE_NAME.append(\"TransactionManager\"), tmLegacyBinderService);\n        tmLegacyBuilder.addDependency(ContextNames.JAVA_CONTEXT_SERVICE_NAME, ServiceBasedNamingStore.class, tmLegacyBinderService.getNamingStoreInjector());\n        tmLegacyBuilder.addDependency(TransactionManagerService.SERVICE_NAME, javax.transaction.TransactionManager.class, new Injector<javax.transaction.TransactionManager>() {\n            @Override\n            public void inject(final javax.transaction.TransactionManager value) throws InjectionException {\n                tmLegacyBinderService.getManagedObjectInjector().inject(new ValueManagedReferenceFactory(new ImmediateValue<Object>(value)));\n            }\n\n            @Override\n            public void uninject() {\n                tmLegacyBinderService.getManagedObjectInjector().uninject();\n            }\n        });\n        tmLegacyBuilder.addListener(verificationHandler);\n        controllers.add(tmLegacyBuilder.install());\n\n        final BinderService tsrBinderService = new BinderService(\"TransactionSynchronizationRegistry\");\n        final ServiceBuilder<ManagedReferenceFactory> tsrBuilder = context.getServiceTarget().addService(ContextNames.JBOSS_CONTEXT_SERVICE_NAME.append(\"TransactionSynchronizationRegistry\"), tsrBinderService);\n        tsrBuilder.addDependency(ContextNames.JBOSS_CONTEXT_SERVICE_NAME, ServiceBasedNamingStore.class, tsrBinderService.getNamingStoreInjector());\n        tsrBuilder.addDependency(TransactionSynchronizationRegistryService.SERVICE_NAME, TransactionSynchronizationRegistry.class, new Injector<TransactionSynchronizationRegistry>() {\n            @Override\n            public void inject(final TransactionSynchronizationRegistry value) throws InjectionException {\n                tsrBinderService.getManagedObjectInjector().inject(new ValueManagedReferenceFactory(new ImmediateValue<Object>(value)));\n            }\n\n            @Override\n            public void uninject() {\n                tsrBinderService.getManagedObjectInjector().uninject();\n            }\n        });\n        tsrBuilder.addListener(verificationHandler);\n        controllers.add(tsrBuilder.install());\n\n        // Bind the UserTransaction into JNDI\n        final BinderService utBinderService = new BinderService(\"UserTransaction\");\n        final ServiceBuilder<ManagedReferenceFactory> utBuilder = context.getServiceTarget().addService(ContextNames.JBOSS_CONTEXT_SERVICE_NAME.append(\"UserTransaction\"), utBinderService);\n        utBuilder.addDependency(ContextNames.JBOSS_CONTEXT_SERVICE_NAME, ServiceBasedNamingStore.class, utBinderService.getNamingStoreInjector());\n        utBuilder.addDependency(UserTransactionService.SERVICE_NAME, javax.transaction.UserTransaction.class, new Injector<javax.transaction.UserTransaction>() {\n            @Override\n            public void inject(final javax.transaction.UserTransaction value) throws InjectionException {\n                utBinderService.getManagedObjectInjector().inject(new ValueManagedReferenceFactory(new ImmediateValue<Object>(value)));\n            }\n\n            @Override\n            public void uninject() {\n                utBinderService.getManagedObjectInjector().uninject();\n            }\n        });\n        utBuilder.addListener(verificationHandler);\n        controllers.add(utBuilder.install());\n\n\n    }","commit_id":"639986f69d2b62c5b732ccbc50df4183e44c2e88","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void registerAttributes(ManagementResourceRegistration resourceRegistration) {\n        // Register all attributes\n        for(final AttributeDefinition def : attributes) {\n            resourceRegistration.registerReadWriteAttribute(def, null, new ReloadRequiredWriteAttributeHandler(def));\n        }\n\n        if (registerRuntimeOnly) {\n            TxStatsHandler.INSTANCE.registerMetrics(resourceRegistration);\n        }\n    }","id":75636,"modified_method":"@Override\n    public void registerAttributes(ManagementResourceRegistration resourceRegistration) {\n        // Register all attributes\n        for(final AttributeDefinition def : attributes) {\n            resourceRegistration.registerReadWriteAttribute(def, null, new ReloadRequiredWriteAttributeHandler(def));\n        }\n        for(final AttributeDefinition def : attributes_1_2) {\n                    resourceRegistration.registerReadWriteAttribute(def, null, new ReloadRequiredWriteAttributeHandler(def));\n                }\n\n        if (registerRuntimeOnly) {\n            TxStatsHandler.INSTANCE.registerMetrics(resourceRegistration);\n        }\n    }","commit_id":"639986f69d2b62c5b732ccbc50df4183e44c2e88","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static Range getLatexRange(DocDisplay docDisplay, Position pos)\n   {\n      if (pos == null)\n         pos = docDisplay.getCursorPosition();\n      \n      // find start of latex block\n      TokenIterator startIt = docDisplay.createTokenIterator();\n      \n      // avoid case where token iterator moves back across lines\n      // to discover a latex block\n      Token startToken = startIt.moveToPosition(pos);\n      if (startToken != null &&\n          startToken.hasAllTypes(\"latex\", \"end\") &&\n          startIt.getCurrentTokenRow() != pos.getRow())\n      {\n         return null;\n      }\n      \n      for (Token token = startIt.moveToPosition(pos);\n           token != null;\n           token = startIt.stepBackward())\n      {\n         if (!token.hasType(\"latex\"))\n            return null;\n         \n         if (token.hasType(\"begin\"))\n            break;\n      }\n      \n      // find end of latex block\n      TokenIterator endIt = docDisplay.createTokenIterator();\n      for (Token token = endIt.moveToPosition(pos);\n           token != null;\n           token = endIt.stepForward())\n      {\n         if (!token.hasType(\"latex\"))\n            return null;\n         \n         if (token.hasType(\"end\"))\n            break;\n      }\n      \n      if (startIt.getCurrentToken() == null || endIt.getCurrentToken() == null)\n         return null;\n      \n      Position startPos = startIt.getCurrentTokenPosition();\n      Position endPos = endIt.getCurrentTokenPosition();\n      endPos.setColumn(endPos.getColumn() + endIt.getCurrentToken().getValue().length());\n      \n      return Range.fromPoints(startPos, endPos);\n   }","id":75637,"modified_method":"public static Range getLatexRange(DocDisplay docDisplay, Position pos)\n   {\n      if (pos == null)\n         pos = docDisplay.getCursorPosition();\n      \n      // find start of latex block\n      TokenIterator startIt = docDisplay.createTokenIterator();\n      \n      // avoid case where token iterator moves back across lines\n      // to discover a latex block\n      Token startToken = startIt.moveToPosition(pos);\n      if (startToken != null &&\n          startToken.hasAllTypes(\"latex\", \"end\") &&\n          startIt.getCurrentTokenRow() != pos.getRow())\n      {\n         return null;\n      }\n      \n      for (Token token = startIt.moveToPosition(pos);\n           token != null;\n           token = startIt.stepBackward())\n      {\n         if (!token.hasType(\"latex\"))\n            return null;\n         \n         if (token.hasType(\"begin\"))\n            break;\n      }\n      \n      // find end of latex block\n      TokenIterator endIt = docDisplay.createTokenIterator();\n      for (Token token = endIt.moveToPosition(pos);\n           token != null;\n           token = endIt.stepForward())\n      {\n         if (!token.hasType(\"latex\"))\n            return null;\n         \n         if (token.hasType(\"end\"))\n            break;\n      }\n      \n      Token lhsToken = startIt.getCurrentToken();\n      if (lhsToken == null || !lhsToken.hasAllTypes(\"latex\", \"begin\"))\n         return null;\n      \n      Token rhsToken = endIt.getCurrentToken();\n      if (rhsToken == null || !rhsToken.hasAllTypes(\"latex\", \"end\"))\n         return null;\n      \n      Position startPos = startIt.getCurrentTokenPosition();\n      Position endPos = endIt.getCurrentTokenPosition();\n      endPos.setColumn(endPos.getColumn() + endIt.getCurrentToken().getValue().length());\n      \n      return Range.fromPoints(startPos, endPos);\n   }","commit_id":"0372e7ce1ecf8d8c10bc64e6e82c0994ecafe713","url":"https://github.com/rstudio/rstudio"},{"original_method":"public String getTokenText() {\n    return getCurrentToken().getTokenText();\n  }","id":75638,"modified_method":"@Nullable\n  public String getTokenText() {\n    final PsiBuilderImpl.Token token = getCurrentToken();\n    return token != null ? token.getTokenText() : null;\n  }","commit_id":"8dc9c88198aadc7ce1915d0bf1cff6eed783d937","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public SNode typeOf(SNode node) {\n    if (node == null) return null;\n    SNode type = NodeTypesComponentsRepository.getInstance()\n            .getNodeTypesComponent(node.getContainingRoot()).getType(node);\n    if (type != null) return type;\n\n    Map<SNode, SNode> typesContext = myTypeChecker.getMainContext();\n    type = typesContext.get(node);\n    if (type == null) {\n      SNode var = createNewRuntimeTypesVariable(false);\n      type = TypeChecker.asType(var);\n      typesContext.put(node, type);\n    }\n    return myTypeChecker.getEquationManager().getRepresentator(type);\n  }","id":75639,"modified_method":"public SNode typeOf(SNode node) {\n    if (node == null) return null;\n    NodeTypesComponent nodeTypesComponent = NodeTypesComponentsRepository.getInstance()\n            .getNodeTypesComponent(node.getContainingRoot());\n    SNode type;\n    if (nodeTypesComponent != null) {\n      type = nodeTypesComponent.getType(node);\n      if (type != null) return type;\n    }\n\n    Map<SNode, SNode> typesContext = myTypeChecker.getMainContext();\n    type = typesContext.get(node);\n    if (type == null) {\n      SNode var = createNewRuntimeTypesVariable(false);\n      type = TypeChecker.asType(var);\n      typesContext.put(node, type);\n    }\n    return myTypeChecker.getEquationManager().getRepresentator(type);\n  }","commit_id":"ad2d64bc641061890099e8a921bdc22032913772","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  public String getTypeErrorDontCheck(SNode node) {\n    if (node == null) return null;\n    return NodeTypesComponentsRepository.getInstance().\n            getNodeTypesComponent(node.getContainingRoot()).getError(node);\n  }","id":75640,"modified_method":"@Nullable\n  public String getTypeErrorDontCheck(SNode node) {\n    if (node == null) return null;\n    NodeTypesComponent nodeTypesComponent = NodeTypesComponentsRepository.getInstance().\n            getNodeTypesComponent(node.getContainingRoot());\n    if (nodeTypesComponent == null) return null;\n    return nodeTypesComponent.getError(node);\n  }","commit_id":"e0a0f762f97b17daca35a9b9649a0568132c063e","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void checkTypes(SNode root) {\n    //clear\n    clear();\n    NodeTypesComponent nodeTypesComponent = NodeTypesComponentsRepository.getInstance().getNodeTypesComponent(root.getContainingRoot());\n    if (nodeTypesComponent != null) {\n      nodeTypesComponent.clear();\n    }\n    if (!loadTypesystemRules(root)) {\n      return;\n    }\n\n    // check types\n    doCheckTypes(root);\n\n    // solve residual inequations\n    myEquationManagersStack.peek().solveInequations();\n\n    // main context\n    Map<SNode, SNode> mainContext = getMainContext();\n\n    // setting types to nodes\n    for (Map.Entry<SNode, SNode> contextEntry : mainContext.entrySet()) {\n      SNode term = contextEntry.getKey();\n      if (term == null) continue;\n      SNode type = expandType(contextEntry.getValue(), myHInterpreter.getRuntimeTypesModel());\n      if (BaseAdapter.isInstance(type, RuntimeErrorType.class)) {\n        reportTypeError(term, ((RuntimeErrorType) BaseAdapter.fromNode(type)).getErrorText());\n      }\n      NodeTypesComponentsRepository.getInstance().\n              getNodeTypesComponent(term.getContainingRoot()).setTypeToNode(term, type);\n    }\n\n    // setting errors\n    for (SNode node : myNodesWithErrors.keySet()) {\n      String errorString = \"HELGINS ERROR: \" + myNodesWithErrors.get(node).reportError();\n      myNodesWithErrorStrings.put(node, errorString);\n      IStatus status = new Status(IStatus.Code.ERROR, errorString);\n      NodeTypesComponentsRepository.getInstance().\n              getNodeTypesComponent(node.getContainingRoot()).setErrorToNode(node, errorString);\n    }\n  }","id":75641,"modified_method":"public void checkTypes(SNode root) {\n    //clear\n    clear();\n    NodeTypesComponent nodeTypesComponent = NodeTypesComponentsRepository.getInstance().getNodeTypesComponent(root.getContainingRoot());\n    if (nodeTypesComponent != null) {\n      nodeTypesComponent.clear();\n    }\n    if (!loadTypesystemRules(root)) {\n      return;\n    }\n\n    // check types\n    doCheckTypes(root);\n\n    // solve residual inequations\n    myEquationManagersStack.peek().solveInequations();\n\n    // main context\n    Map<SNode, SNode> mainContext = getMainContext();\n\n    // setting types to nodes\n    for (Map.Entry<SNode, SNode> contextEntry : mainContext.entrySet()) {\n      SNode term = contextEntry.getKey();\n      if (term == null) continue;\n      SNode type = expandType(contextEntry.getValue(), myHInterpreter.getRuntimeTypesModel());\n      if (BaseAdapter.isInstance(type, RuntimeErrorType.class)) {\n        reportTypeError(term, ((RuntimeErrorType) BaseAdapter.fromNode(type)).getErrorText());\n      }\n      NodeTypesComponentsRepository.getInstance().\n              createNodeTypesComponent(term.getContainingRoot()).setTypeToNode(term, type);\n    }\n\n    // setting errors\n    for (SNode node : myNodesWithErrors.keySet()) {\n      String errorString = \"HELGINS ERROR: \" + myNodesWithErrors.get(node).reportError();\n      myNodesWithErrorStrings.put(node, errorString);\n      NodeTypesComponentsRepository.getInstance().\n              createNodeTypesComponent(node.getContainingRoot()).setErrorToNode(node, errorString);\n    }\n  }","commit_id":"e7056ecdaac66b38627beb2a39b48be9980c35c5","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  public SNode getTypeDontCheck(SNode node) {\n    if (node == null) return null;\n    /* Object typeObject = node.getUserObject(TYPE_OF_TERM);\n   if (typeObject instanceof SNode) return (SNode) typeObject;\n   return null;*/\n    return NodeTypesComponentsRepository.getInstance().\n            getNodeTypesComponent(node.getContainingRoot()).getType(node);\n  }","id":75642,"modified_method":"@Nullable\n  public SNode getTypeDontCheck(SNode node) {\n    if (node == null) return null;\n    NodeTypesComponent nodeTypesComponent = NodeTypesComponentsRepository.getInstance().\n            getNodeTypesComponent(node.getContainingRoot());\n    if (nodeTypesComponent == null) return null;\n    return nodeTypesComponent.getType(node);\n  }","commit_id":"e7056ecdaac66b38627beb2a39b48be9980c35c5","url":"https://github.com/JetBrains/MPS"},{"original_method":"private int convertResponse(final String response) {\n        if (response != null) {\n            String temp = response.toLowerCase(Locale.ENGLISH);\n            if (\"yes\".equals(temp) || \"y\".equals(temp)) {\n                return YES;\n            }\n\n            if (\"no\".equals(temp) || \"n\".equals(temp)) {\n                return NO;\n            }\n        }\n\n        return INVALID;\n    }","id":75643,"modified_method":"private int convertResponse(final String response) {\n        if (response != null) {\n            String temp = response.toLowerCase(); // We now need to match on the current local.\n            if (MESSAGES.yes().equals(temp) || MESSAGES.shortYes().equals(temp)) {\n                return YES;\n            }\n\n            if (MESSAGES.no().equals(temp) || MESSAGES.shortNo().equals(temp)) {\n                return NO;\n            }\n        }\n\n        return INVALID;\n    }","commit_id":"a8b9a99ac6d8a7e9bfbbab42b3ea1b5a37998d80","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public State execute() {\n        if (message != null) {\n            theConsole.printf(message);\n            theConsole.printf(NEW_LINE);\n        }\n\n        theConsole.printf(prompt);\n        String temp = theConsole.readLine(SPACE);\n\n        switch (convertResponse(temp)) {\n            case YES:\n                return yesState;\n            case NO:\n                return noState;\n            default:\n                return new ErrorState(theConsole, MESSAGES.invalidConfirmationResponse(), this);\n        }\n    }","id":75644,"modified_method":"@Override\n    public State execute() {\n        if (message != null) {\n            theConsole.printf(message);\n            theConsole.printf(NEW_LINE);\n        }\n\n        theConsole.printf(prompt);\n        String temp = theConsole.readLine(SPACE);\n\n        switch (convertResponse(temp)) {\n            case YES:\n                return yesState;\n            case NO:\n                return noState;\n            default: {\n                List<String> acceptedValues = new ArrayList<String>(4);\n                acceptedValues.add(MESSAGES.yes());\n                if (MESSAGES.shortYes().length() > 0) {\n                    acceptedValues.add(MESSAGES.shortYes());\n                }\n                acceptedValues.add(MESSAGES.no());\n                if (MESSAGES.shortNo().length() > 0) {\n                    acceptedValues.add(MESSAGES.shortNo());\n                }\n                StringBuilder sb = new StringBuilder(acceptedValues.get(0));\n                for (int i = 1; i < acceptedValues.size() - 1; i++) {\n                    sb.append(\", \");\n                    sb.append(acceptedValues.get(i));\n                }\n\n                return new ErrorState(theConsole, MESSAGES.invalidConfirmationResponse(sb.toString(),\n                        acceptedValues.get(acceptedValues.size() - 1)), this);\n            }\n        }\n    }","commit_id":"a8b9a99ac6d8a7e9bfbbab42b3ea1b5a37998d80","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testWrongAnswer() throws IOException, StartException {\n\n        ErrorState errorState = new ErrorState(consoleMock,null);\n        PromptPasswordState passwordState = new PromptPasswordState(consoleMock,null);\n\n        ConfirmationChoice confirmationChoice = new ConfirmationChoice(consoleMock, USER_DISPLAY_TEXT, PLEASE_ANSWER, passwordState,errorState);\n\n        AssertConsoleBuilder consoleBuilder = new AssertConsoleBuilder().\n                expectedConfirmMessage(USER_DISPLAY_TEXT,PLEASE_ANSWER,\"d\").\n                expectedErrorMessage(MESSAGES.invalidConfirmationResponse());\n\n        consoleMock.setResponses(consoleBuilder);\n        State nextState = confirmationChoice.execute();\n\n        assertTrue(\"Expected the next state to be ErrorState\", nextState instanceof ErrorState);\n        nextState.execute();\n        consoleBuilder.validate();\n    }","id":75645,"modified_method":"@Test\n    public void testWrongAnswer() throws IOException, StartException {\n\n        ErrorState errorState = new ErrorState(consoleMock,null);\n        PromptPasswordState passwordState = new PromptPasswordState(consoleMock,null);\n\n        ConfirmationChoice confirmationChoice = new ConfirmationChoice(consoleMock, USER_DISPLAY_TEXT, PLEASE_ANSWER, passwordState,errorState);\n\n        List<String> acceptedValues = new ArrayList<String>(4);\n        acceptedValues.add(MESSAGES.yes());\n        if (MESSAGES.shortYes().length() > 0) {\n            acceptedValues.add(MESSAGES.shortYes());\n        }\n        acceptedValues.add(MESSAGES.no());\n        if (MESSAGES.shortNo().length() > 0) {\n            acceptedValues.add(MESSAGES.shortNo());\n        }\n        StringBuilder sb = new StringBuilder(acceptedValues.get(0));\n        for (int i = 1; i < acceptedValues.size() - 1; i++) {\n            sb.append(\", \");\n            sb.append(acceptedValues.get(i));\n        }\n\n        AssertConsoleBuilder consoleBuilder = new AssertConsoleBuilder().expectedConfirmMessage(USER_DISPLAY_TEXT,\n                PLEASE_ANSWER, \"d\").expectedErrorMessage(\n                MESSAGES.invalidConfirmationResponse(sb.toString(), acceptedValues.get(acceptedValues.size() - 1)));\n\n        consoleMock.setResponses(consoleBuilder);\n        State nextState = confirmationChoice.execute();\n\n        assertTrue(\"Expected the next state to be ErrorState\", nextState instanceof ErrorState);\n        nextState.execute();\n        consoleBuilder.validate();\n    }","commit_id":"a8b9a99ac6d8a7e9bfbbab42b3ea1b5a37998d80","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public State execute() {\n        final State continuingState;\n        if (stateValues.isExistingUser()) {\n            continuingState = new UpdateUser(theConsole, stateValues);\n        } else {\n            State addState = new AddUser(theConsole, stateValues);\n\n            if (stateValues.isSilentOrNonInteractive()) {\n                continuingState = addState;\n            } else {\n                String message = MESSAGES.aboutToAddUser(stateValues.getUserName(), stateValues.getRealm());\n                String prompt = MESSAGES.isCorrectPrompt();\n\n                continuingState = new ConfirmationChoice(theConsole,message, prompt, addState, new PromptNewUserState(theConsole, stateValues));\n            }\n        }\n\n        return continuingState;\n    }","id":75646,"modified_method":"@Override\n    public State execute() {\n        final State continuingState;\n        if (stateValues.isExistingUser()) {\n            continuingState = new UpdateUser(theConsole, stateValues);\n        } else {\n            State addState = new AddUser(theConsole, stateValues);\n\n            if (stateValues.isSilentOrNonInteractive()) {\n                continuingState = addState;\n            } else {\n                String message = MESSAGES.aboutToAddUser(stateValues.getUserName(), stateValues.getRealm());\n                String prompt = MESSAGES.isCorrectPrompt() + \" \" + MESSAGES.yes() + \"/\" + MESSAGES.no() + \"?\";\n\n                continuingState = new ConfirmationChoice(theConsole,message, prompt, addState, new PromptNewUserState(theConsole, stateValues));\n            }\n        }\n\n        return continuingState;\n    }","commit_id":"a8b9a99ac6d8a7e9bfbbab42b3ea1b5a37998d80","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void newUser() throws IOException {\n        values.setExistingUser(false);\n        values.setRoles(ROLES);\n        DuplicateUserCheckState userCheckState = new DuplicateUserCheckState(consoleMock, values);\n\n        AssertConsoleBuilder consoleBuilder = new AssertConsoleBuilder().\n                expectedDisplayText(MESSAGES.aboutToAddUser(values.getUserName(), values.getRealm())).\n                expectedDisplayText(AddPropertiesUser.NEW_LINE).\n                expectedDisplayText(MESSAGES.isCorrectPrompt()).\n                expectedDisplayText(\" \").\n                expectedInput(\"yes\").\n                expectedDisplayText(MESSAGES.addedUser(values.getUserName(), values.getPropertiesFiles().get(0).getCanonicalPath())).\n                expectedDisplayText(AddPropertiesUser.NEW_LINE).\n                expectedDisplayText(MESSAGES.addedRoles(values.getUserName(), values.getRoles(),values.getRoleFiles().get(0).getCanonicalPath())).\n                expectedDisplayText(AddPropertiesUser.NEW_LINE);\n        consoleMock.setResponses(consoleBuilder);\n\n        State nextState = userCheckState.execute();\n        assertTrue(nextState instanceof ConfirmationChoice);\n        nextState = nextState.execute();\n        assertTrue(nextState instanceof AddUser);\n        nextState.execute();\n        consoleBuilder.validate();\n    }","id":75647,"modified_method":"@Test\n    public void newUser() throws IOException {\n        values.setExistingUser(false);\n        values.setRoles(ROLES);\n        DuplicateUserCheckState userCheckState = new DuplicateUserCheckState(consoleMock, values);\n\n        AssertConsoleBuilder consoleBuilder = new AssertConsoleBuilder().\n                expectedDisplayText(MESSAGES.aboutToAddUser(values.getUserName(), values.getRealm())).\n                expectedDisplayText(AddPropertiesUser.NEW_LINE).\n                expectedDisplayText(MESSAGES.isCorrectPrompt() + \" \" + MESSAGES.yes() + \"/\" + MESSAGES.no() + \"?\").\n                expectedDisplayText(\" \").\n                expectedInput(\"yes\").\n                expectedDisplayText(MESSAGES.addedUser(values.getUserName(), values.getPropertiesFiles().get(0).getCanonicalPath())).\n                expectedDisplayText(AddPropertiesUser.NEW_LINE).\n                expectedDisplayText(MESSAGES.addedRoles(values.getUserName(), values.getRoles(),values.getRoleFiles().get(0).getCanonicalPath())).\n                expectedDisplayText(AddPropertiesUser.NEW_LINE);\n        consoleMock.setResponses(consoleBuilder);\n\n        State nextState = userCheckState.execute();\n        assertTrue(nextState instanceof ConfirmationChoice);\n        nextState = nextState.execute();\n        assertTrue(nextState instanceof AddUser);\n        nextState.execute();\n        consoleBuilder.validate();\n    }","commit_id":"a8b9a99ac6d8a7e9bfbbab42b3ea1b5a37998d80","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public State execute() {\n        State continuingState = new PromptPasswordState(theConsole, stateValues);\n        if (stateValues.isSilentOrNonInteractive() == false) {\n            theConsole.printf(NEW_LINE);\n            theConsole.printf(MESSAGES.enterNewUserDetails());\n            theConsole.printf(NEW_LINE);\n            stateValues.setPassword(null); // If interactive we want to be sure to capture this.\n\n            /*\n            * Prompt for realm.\n            */\n            theConsole.printf(MESSAGES.realmPrompt(stateValues.getRealm()));\n            String temp = theConsole.readLine(\" : \");\n            if (temp == null) {\n                /*\n                * This will return user to the command prompt so add a new line to\n                * ensure the command prompt is on the next line.\n                */\n                theConsole.printf(NEW_LINE);\n                return null;\n            }\n            if (temp.length() > 0) {\n                stateValues.setRealm(temp);\n            }\n\n            /*\n            * Prompt for username.\n            */\n            String existingUsername = stateValues.getUserName();\n            String usernamePrompt = existingUsername == null ? MESSAGES.usernamePrompt() :\n                    MESSAGES.usernamePrompt(existingUsername);\n            theConsole.printf(usernamePrompt);\n            temp = theConsole.readLine(\" : \");\n            if (temp != null && temp.length() > 0) {\n                existingUsername = temp;\n            }\n            // The user could have pressed Ctrl-D, in which case we do not use the default value.\n            if (temp == null || existingUsername == null || existingUsername.length() == 0) {\n                return new ErrorState(theConsole,MESSAGES.noUsernameExiting());\n            }\n            stateValues.setUserName(existingUsername);\n\n            if (stateValues.getKnownUsers().contains(stateValues.getUserName())) {\n                State duplicateContinuing = stateValues.isSilentOrNonInteractive() ? null : new PromptNewUserState(theConsole, stateValues);\n                if (stateValues.isSilentOrNonInteractive()) {\n                    continuingState = new ErrorState(theConsole, MESSAGES.duplicateUser(stateValues.getUserName()), duplicateContinuing, stateValues);\n                } else {\n                    String message = MESSAGES.aboutToUpdateUser(stateValues.getUserName());\n                    String prompt = MESSAGES.isCorrectPrompt();\n\n                    stateValues.setExistingUser(true);\n                    continuingState = new ConfirmationChoice(theConsole,message, prompt, continuingState, duplicateContinuing);\n                }\n            }\n        }\n\n        return continuingState;\n    }","id":75648,"modified_method":"@Override\n    public State execute() {\n        State continuingState = new PromptPasswordState(theConsole, stateValues);\n        if (stateValues.isSilentOrNonInteractive() == false) {\n            theConsole.printf(NEW_LINE);\n            theConsole.printf(MESSAGES.enterNewUserDetails());\n            theConsole.printf(NEW_LINE);\n            stateValues.setPassword(null); // If interactive we want to be sure to capture this.\n\n            /*\n            * Prompt for realm.\n            */\n            theConsole.printf(MESSAGES.realmPrompt(stateValues.getRealm()));\n            String temp = theConsole.readLine(\" : \");\n            if (temp == null) {\n                /*\n                * This will return user to the command prompt so add a new line to\n                * ensure the command prompt is on the next line.\n                */\n                theConsole.printf(NEW_LINE);\n                return null;\n            }\n            if (temp.length() > 0) {\n                stateValues.setRealm(temp);\n            }\n\n            /*\n            * Prompt for username.\n            */\n            String existingUsername = stateValues.getUserName();\n            String usernamePrompt = existingUsername == null ? MESSAGES.usernamePrompt() :\n                    MESSAGES.usernamePrompt(existingUsername);\n            theConsole.printf(usernamePrompt);\n            temp = theConsole.readLine(\" : \");\n            if (temp != null && temp.length() > 0) {\n                existingUsername = temp;\n            }\n            // The user could have pressed Ctrl-D, in which case we do not use the default value.\n            if (temp == null || existingUsername == null || existingUsername.length() == 0) {\n                return new ErrorState(theConsole,MESSAGES.noUsernameExiting());\n            }\n            stateValues.setUserName(existingUsername);\n\n            if (stateValues.getKnownUsers().contains(stateValues.getUserName())) {\n                State duplicateContinuing = stateValues.isSilentOrNonInteractive() ? null : new PromptNewUserState(theConsole, stateValues);\n                if (stateValues.isSilentOrNonInteractive()) {\n                    continuingState = new ErrorState(theConsole, MESSAGES.duplicateUser(stateValues.getUserName()), duplicateContinuing, stateValues);\n                } else {\n                    String message = MESSAGES.aboutToUpdateUser(stateValues.getUserName());\n                    String prompt = MESSAGES.isCorrectPrompt() + \" \" + MESSAGES.yes() + \"/\" + MESSAGES.no() + \"?\";\n\n                    stateValues.setExistingUser(true);\n                    continuingState = new ConfirmationChoice(theConsole,message, prompt, continuingState, duplicateContinuing);\n                }\n            }\n        }\n\n        return continuingState;\n    }","commit_id":"a8b9a99ac6d8a7e9bfbbab42b3ea1b5a37998d80","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected Router newFriendlyURLRouter(String friendlyURLRoutes)\n\t\t\tthrows Exception {\n\n\t\t\tif (Validator.isNull(friendlyURLRoutes)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tRouter router = new RouterImpl();\n\n\t\t\tClassLoader classLoader = getClassLoader();\n\n\t\t\tString xml = StringUtil.read(classLoader, friendlyURLRoutes);\n\n\t\t\tDocument document = UnsecureSAXReaderUtil.read(xml, true);\n\n\t\t\tElement rootElement = document.getRootElement();\n\n\t\t\tfor (Element routeElement : rootElement.elements(\"route\")) {\n\t\t\t\tString pattern = routeElement.elementText(\"pattern\");\n\n\t\t\t\tRoute route = router.addRoute(pattern);\n\n\t\t\t\tfor (Element generatedParameterElement :\n\t\t\t\t\t\trouteElement.elements(\"generated-parameter\")) {\n\n\t\t\t\t\tString name = generatedParameterElement.attributeValue(\n\t\t\t\t\t\t\"name\");\n\t\t\t\t\tString value = generatedParameterElement.getText();\n\n\t\t\t\t\troute.addGeneratedParameter(name, value);\n\t\t\t\t}\n\n\t\t\t\tfor (Element ignoredParameterElement :\n\t\t\t\t\t\trouteElement.elements(\"ignored-parameter\")) {\n\n\t\t\t\t\tString name = ignoredParameterElement.attributeValue(\n\t\t\t\t\t\t\"name\");\n\n\t\t\t\t\troute.addIgnoredParameter(name);\n\t\t\t\t}\n\n\t\t\t\tfor (Element implicitParameterElement :\n\t\t\t\t\t\trouteElement.elements(\"implicit-parameter\")) {\n\n\t\t\t\t\tString name = implicitParameterElement.attributeValue(\n\t\t\t\t\t\t\"name\");\n\t\t\t\t\tString value = implicitParameterElement.getText();\n\n\t\t\t\t\troute.addImplicitParameter(name, value);\n\t\t\t\t}\n\n\t\t\t\tfor (Element overriddenParameterElement :\n\t\t\t\t\t\trouteElement.elements(\"overridden-parameter\")) {\n\n\t\t\t\t\tString name = overriddenParameterElement.attributeValue(\n\t\t\t\t\t\t\"name\");\n\t\t\t\t\tString value = overriddenParameterElement.getText();\n\n\t\t\t\t\troute.addOverriddenParameter(name, value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn router;\n\t\t}","id":75649,"modified_method":"protected Router newFriendlyURLRouter(String xml)\n\t\t\tthrows Exception {\n\n\t\t\tif (Validator.isNull(xml) || Validator.isBlank(xml)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tRouter router = new RouterImpl();\n\n\t\t\tDocument document = UnsecureSAXReaderUtil.read(xml, true);\n\n\t\t\tElement rootElement = document.getRootElement();\n\n\t\t\tfor (Element routeElement : rootElement.elements(\"route\")) {\n\t\t\t\tString pattern = routeElement.elementText(\"pattern\");\n\n\t\t\t\tRoute route = router.addRoute(pattern);\n\n\t\t\t\tfor (Element generatedParameterElement :\n\t\t\t\t\t\trouteElement.elements(\"generated-parameter\")) {\n\n\t\t\t\t\tString name = generatedParameterElement.attributeValue(\n\t\t\t\t\t\t\"name\");\n\t\t\t\t\tString value = generatedParameterElement.getText();\n\n\t\t\t\t\troute.addGeneratedParameter(name, value);\n\t\t\t\t}\n\n\t\t\t\tfor (Element ignoredParameterElement :\n\t\t\t\t\t\trouteElement.elements(\"ignored-parameter\")) {\n\n\t\t\t\t\tString name = ignoredParameterElement.attributeValue(\n\t\t\t\t\t\t\"name\");\n\n\t\t\t\t\troute.addIgnoredParameter(name);\n\t\t\t\t}\n\n\t\t\t\tfor (Element implicitParameterElement :\n\t\t\t\t\t\trouteElement.elements(\"implicit-parameter\")) {\n\n\t\t\t\t\tString name = implicitParameterElement.attributeValue(\n\t\t\t\t\t\t\"name\");\n\t\t\t\t\tString value = implicitParameterElement.getText();\n\n\t\t\t\t\troute.addImplicitParameter(name, value);\n\t\t\t\t}\n\n\t\t\t\tfor (Element overriddenParameterElement :\n\t\t\t\t\t\trouteElement.elements(\"overridden-parameter\")) {\n\n\t\t\t\t\tString name = overriddenParameterElement.attributeValue(\n\t\t\t\t\t\t\"name\");\n\t\t\t\t\tString value = overriddenParameterElement.getText();\n\n\t\t\t\t\troute.addOverriddenParameter(name, value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn router;\n\t\t}","commit_id":"8099d77dc95d3b090bb58c94c895a78b66a9ad79","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\t\tpublic FriendlyURLMapper addingService(\n\t\t\tServiceReference<FriendlyURLMapper> serviceReference) {\n\n\t\t\tRegistry registry = RegistryUtil.getRegistry();\n\n\t\t\tFriendlyURLMapper friendlyURLMapper = registry.getService(\n\t\t\t\tserviceReference);\n\n\t\t\ttry {\n\t\t\t\tif (Validator.isNotNull(_portlet.getFriendlyURLMapping())) {\n\t\t\t\t\tfriendlyURLMapper.setMapping(\n\t\t\t\t\t\t_portlet.getFriendlyURLMapping());\n\t\t\t\t}\n\n\t\t\t\tfriendlyURLMapper.setPortletId(_portlet.getPortletId());\n\t\t\t\tfriendlyURLMapper.setPortletInstanceable(\n\t\t\t\t\t_portlet.isInstanceable());\n\n\t\t\t\tString friendlyURLRoutes = (String)serviceReference.getProperty(\n\t\t\t\t\t\"com.liferay.portlet.friendly-url-routes\");\n\n\t\t\t\tif (Validator.isNotNull(_portlet.getFriendlyURLRoutes())) {\n\t\t\t\t\tfriendlyURLRoutes = _portlet.getFriendlyURLRoutes();\n\t\t\t\t}\n\n\t\t\t\tfriendlyURLMapper.setRouter(\n\t\t\t\t\tnewFriendlyURLRouter(friendlyURLRoutes));\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn friendlyURLMapper;\n\t\t}","id":75650,"modified_method":"@Override\n\t\tpublic FriendlyURLMapper addingService(\n\t\t\tServiceReference<FriendlyURLMapper> serviceReference) {\n\n\t\t\tRegistry registry = RegistryUtil.getRegistry();\n\n\t\t\tFriendlyURLMapper friendlyURLMapper = registry.getService(\n\t\t\t\tserviceReference);\n\n\t\t\ttry {\n\t\t\t\tif (Validator.isNotNull(_portlet.getFriendlyURLMapping())) {\n\t\t\t\t\tfriendlyURLMapper.setMapping(\n\t\t\t\t\t\t_portlet.getFriendlyURLMapping());\n\t\t\t\t}\n\n\t\t\t\tfriendlyURLMapper.setPortletId(_portlet.getPortletId());\n\t\t\t\tfriendlyURLMapper.setPortletInstanceable(\n\t\t\t\t\t_portlet.isInstanceable());\n\n\t\t\t\tString friendlyURLRoutes = (String)serviceReference.getProperty(\n\t\t\t\t\t\"com.liferay.portlet.friendly-url-routes\");\n\n\t\t\t\tif (Validator.isNotNull(_portlet.getFriendlyURLRoutes())) {\n\t\t\t\t\tfriendlyURLRoutes = _portlet.getFriendlyURLRoutes();\n\t\t\t\t}\n\n\t\t\t\tClassLoader classLoader = friendlyURLMapper.getClass().getClassLoader();\n\n\t\t\t\tString xml = StringUtil.read(classLoader, friendlyURLRoutes);\n\t\t\t\t\n\t\t\t\tfriendlyURLMapper.setRouter(\n\t\t\t\t\tnewFriendlyURLRouter(xml));\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn friendlyURLMapper;\n\t\t}","commit_id":"8099d77dc95d3b090bb58c94c895a78b66a9ad79","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getOldCopyright() throws IOException {\n\t\tString copyright = fileUtil.read(\"old-copyright.txt\");\n\n\t\tif (Validator.isNull(copyright)) {\n\t\t\tcopyright = fileUtil.read(\"../old-copyright.txt\");\n\t\t}\n\n\t\tif (Validator.isNull(copyright)) {\n\t\t\tcopyright = fileUtil.read(\"../../old-copyright.txt\");\n\t\t}\n\n\t\treturn copyright;\n\t}","id":75651,"modified_method":"protected String getOldCopyright() throws IOException {\n\t\tif (Validator.isNotNull(_oldCopyright)) {\n\t\t\treturn _oldCopyright;\n\t\t}\n\n\t\t_oldCopyright = fileUtil.read(\"old-copyright.txt\");\n\n\t\tif (Validator.isNull(_oldCopyright)) {\n\t\t\t_oldCopyright = fileUtil.read(\"../old-copyright.txt\");\n\t\t}\n\n\t\tif (Validator.isNull(_oldCopyright)) {\n\t\t\t_oldCopyright = fileUtil.read(\"../../old-copyright.txt\");\n\t\t}\n\n\t\treturn _oldCopyright;\n\t}","commit_id":"68aba665ac89373383bc4b8aaeffe5d16e16f496","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getCopyright() throws IOException {\n\t\tString copyright = fileUtil.read(\"copyright.txt\");\n\n\t\tif (Validator.isNull(copyright)) {\n\t\t\tcopyright = fileUtil.read(\"../copyright.txt\");\n\t\t}\n\n\t\tif (Validator.isNull(copyright)) {\n\t\t\tcopyright = fileUtil.read(\"../../copyright.txt\");\n\t\t}\n\n\t\treturn copyright;\n\t}","id":75652,"modified_method":"protected String getCopyright() throws IOException {\n\t\tif (Validator.isNotNull(_copyright)) {\n\t\t\treturn _copyright;\n\t\t}\n\n\t\t_copyright = fileUtil.read(\"copyright.txt\");\n\n\t\tif (Validator.isNull(_copyright)) {\n\t\t\t_copyright = fileUtil.read(\"../copyright.txt\");\n\t\t}\n\n\t\tif (Validator.isNull(_copyright)) {\n\t\t\t_copyright = fileUtil.read(\"../../copyright.txt\");\n\t\t}\n\n\t\treturn _copyright;\n\t}","commit_id":"68aba665ac89373383bc4b8aaeffe5d16e16f496","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doFormat() throws Exception {\n\t\tString copyright = getCopyright();\n\t\tString oldCopyright = getOldCopyright();\n\n\t\tCollection<String> fileNames = null;\n\n\t\tif (portalSource) {\n\t\t\tfileNames = getPortalJavaFiles();\n\n\t\t\t_checkUnprocessedExceptions = GetterUtil.getBoolean(\n\t\t\t\tSystem.getProperty(\n\t\t\t\t\t\"source.formatter.check.unprocessed.exceptions\"));\n\t\t}\n\t\telse {\n\t\t\tfileNames = getPluginJavaFiles();\n\t\t}\n\n\t\t_javaTermSortExclusions = getExclusionsProperties(\n\t\t\t\"source_formatter_javaterm_sort_exclusions.properties\");\n\t\t_lineLengthExclusions = getExclusionsProperties(\n\t\t\t\"source_formatter_line_length_exclusions.properties\");\n\t\tProperties staticLogVariableExclusions = getExclusionsProperties(\n\t\t\t\"source_formatter_static_log_exclusions.properties\");\n\t\tProperties upgradeServiceUtilExclusions = getExclusionsProperties(\n\t\t\t\"source_formatter_upgrade_service_util_exclusions.properties\");\n\n\t\tfor (String fileName : fileNames) {\n\t\t\tif (fileName.endsWith(\"SourceProcessor.java\")) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tFile file = new File(BASEDIR + fileName);\n\n\t\t\tfileName = StringUtil.replace(\n\t\t\t\tfileName, StringPool.BACK_SLASH, StringPool.SLASH);\n\n\t\t\tString content = fileUtil.read(file);\n\n\t\t\tif (isGenerated(content) &&\n\t\t\t\t!fileName.endsWith(\"JavadocFormatter.java\")) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tString className = file.getName();\n\n\t\t\tclassName = className.substring(0, className.length() - 5);\n\n\t\t\tString packagePath = fileName;\n\n\t\t\tint packagePathX = packagePath.indexOf(\"/src/\");\n\t\t\tint packagePathY = packagePath.lastIndexOf(StringPool.SLASH);\n\n\t\t\tif ((packagePathX + 5) >= packagePathY) {\n\t\t\t\tpackagePath = StringPool.BLANK;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpackagePath = packagePath.substring(\n\t\t\t\t\tpackagePathX + 5, packagePathY);\n\t\t\t}\n\n\t\t\tpackagePath = StringUtil.replace(\n\t\t\t\tpackagePath, StringPool.SLASH, StringPool.PERIOD);\n\n\t\t\tif (packagePath.endsWith(\".model\")) {\n\t\t\t\tif (content.contains(\"extends \" + className + \"Model\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString newContent = content;\n\n\t\t\tif (newContent.contains(\"$\\n */\")) {\n\t\t\t\tprocessErrorMessage(fileName, \"*: \" + fileName);\n\n\t\t\t\tnewContent = StringUtil.replace(\n\t\t\t\t\tnewContent, \"$\\n */\", \"$\\n *\\n */\");\n\t\t\t}\n\n\t\t\tnewContent = fixCopyright(\n\t\t\t\tnewContent, copyright, oldCopyright, file, fileName);\n\n\t\t\tif (newContent.contains(className + \".java.html\")) {\n\t\t\t\tprocessErrorMessage(fileName, \"Java2HTML: \" + fileName);\n\t\t\t}\n\n\t\t\tif (newContent.contains(\" * @author Raymond Aug\") &&\n\t\t\t\t!newContent.contains(\" * @author Raymond Aug\\u00e9\")) {\n\n\t\t\t\tnewContent = newContent.replaceFirst(\n\t\t\t\t\t\"Raymond Aug.++\", \"Raymond Aug\\u00e9\");\n\n\t\t\t\tprocessErrorMessage(fileName, \"UTF-8: \" + fileName);\n\t\t\t}\n\n\t\t\tnewContent = fixDataAccessConnection(className, newContent);\n\t\t\tnewContent = fixSessionKey(fileName, newContent, sessionKeyPattern);\n\n\t\t\tnewContent = StringUtil.replace(\n\t\t\t\tnewContent,\n\t\t\t\tnew String[] {\n\t\t\t\t\t\"com.liferay.portal.PortalException\",\n\t\t\t\t\t\"com.liferay.portal.SystemException\",\n\t\t\t\t\t\"com.liferay.util.LocalizationUtil\",\n\t\t\t\t\t\"private static final Log _log\"\n\t\t\t\t},\n\t\t\t\tnew String[] {\n\t\t\t\t\t\"com.liferay.portal.kernel.exception.PortalException\",\n\t\t\t\t\t\"com.liferay.portal.kernel.exception.SystemException\",\n\t\t\t\t\t\"com.liferay.portal.kernel.util.LocalizationUtil\",\n\t\t\t\t\t\"private static Log _log\"\n\t\t\t\t});\n\n\t\t\tnewContent = fixCompatClassImports(fileName, newContent);\n\n\t\t\tnewContent = stripJavaImports(newContent, packagePath, className);\n\n\t\t\tnewContent = StringUtil.replace(\n\t\t\t\tnewContent,\n\t\t\t\tnew String[] {\n\t\t\t\t\t\";\\n/**\", \"\\t/*\\n\\t *\", \"catch(\", \"else{\", \"if(\", \"for(\",\n\t\t\t\t\t\"while(\", \"List <\", \"){\\n\", \"]{\\n\"\n\t\t\t\t},\n\t\t\t\tnew String[] {\n\t\t\t\t\t\";\\n\\n/**\", \"\\t/**\\n\\t *\", \"catch (\", \"else {\", \"if (\",\n\t\t\t\t\t\"for (\", \"while (\", \"List<\", \") {\\n\", \"] {\\n\"\n\t\t\t\t});\n\n\t\t\tPattern pattern = Pattern.compile(\n\t\t\t\t\"\\t(catch |else |finally |for |if |try |while ).*\\\\{\\n\\n\" +\n\t\t\t\t\t\"\\t+\\\\w\");\n\n\t\t\tfor (;;) {\n\t\t\t\tMatcher matcher = pattern.matcher(newContent);\n\n\t\t\t\tif (!matcher.find()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tString match = matcher.group();\n\n\t\t\t\tString replacement = StringUtil.replaceFirst(\n\t\t\t\t\tmatch, StringPool.NEW_LINE, StringPool.BLANK);\n\n\t\t\t\tnewContent = StringUtil.replaceFirst(\n\t\t\t\t\tnewContent, match, replacement);\n\t\t\t}\n\n\t\t\tpattern = Pattern.compile(\n\t\t\t\t\"Log _log = LogFactoryUtil.getLog\\\\(\\n*\\t*(.+)\\\\.class\\\\)\");\n\n\t\t\tMatcher matcher = pattern.matcher(newContent);\n\n\t\t\tif (matcher.find()) {\n\t\t\t\tString logClassName = matcher.group(1);\n\n\t\t\t\tif (!logClassName.equals(className)) {\n\t\t\t\t\tnewContent = StringUtil.replaceLast(\n\t\t\t\t\t\tnewContent, logClassName + \".class)\",\n\t\t\t\t\t\tclassName + \".class)\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString excluded = null;\n\n\t\t\tif (staticLogVariableExclusions != null) {\n\t\t\t\texcluded = staticLogVariableExclusions.getProperty(fileName);\n\t\t\t}\n\n\t\t\tif (excluded == null) {\n\t\t\t\tnewContent = StringUtil.replace(\n\t\t\t\t\tnewContent, \"private Log _log\", \"private static Log _log\");\n\t\t\t}\n\n\t\t\tif (newContent.contains(\"*/\\npackage \")) {\n\t\t\t\tprocessErrorMessage(fileName, \"package: \" + fileName);\n\t\t\t}\n\n\t\t\tif (!newContent.endsWith(\"\\n\\n}\") && !newContent.endsWith(\"{\\n}\")) {\n\t\t\t\tprocessErrorMessage(fileName, \"}: \" + fileName);\n\t\t\t}\n\n\t\t\tif (portalSource && !className.equals(\"BaseServiceImpl\") &&\n\t\t\t\tclassName.endsWith(\"ServiceImpl\") &&\n\t\t\t\tnewContent.contains(\"ServiceUtil.\")) {\n\n\t\t\t\tprocessErrorMessage(fileName, \"ServiceUtil: \" + fileName);\n\t\t\t}\n\n\t\t\t// LPS-34911\n\n\t\t\texcluded = null;\n\n\t\t\tif (upgradeServiceUtilExclusions != null) {\n\t\t\t\texcluded = upgradeServiceUtilExclusions.getProperty(fileName);\n\t\t\t}\n\n\t\t\tif ((excluded == null) && portalSource &&\n\t\t\t\tfileName.contains(\"/portal/upgrade/\") &&\n\t\t\t\t!fileName.contains(\"/test/\") &&\n\t\t\t\tnewContent.contains(\"ServiceUtil.\")) {\n\n\t\t\t\tprocessErrorMessage(fileName, \"ServiceUtil: \" + fileName);\n\t\t\t}\n\n\t\t\tif (!className.equals(\"DeepNamedValueScanner\") &&\n\t\t\t\t!className.equals(\"ProxyUtil\") &&\n\t\t\t\tnewContent.contains(\"import java.lang.reflect.Proxy;\")) {\n\n\t\t\t\tprocessErrorMessage(fileName, \"Proxy: \" + fileName);\n\t\t\t}\n\n\t\t\tif (newContent.contains(\"import edu.emory.mathcs.backport.java\")) {\n\t\t\t\tprocessErrorMessage(\n\t\t\t\t\tfileName, \"edu.emory.mathcs.backport.java: \" + fileName);\n\t\t\t}\n\n\t\t\t// LPS-28266\n\n\t\t\tfor (int pos1 = -1;;) {\n\t\t\t\tpos1 = newContent.indexOf(StringPool.TAB + \"try {\", pos1 + 1);\n\n\t\t\t\tif (pos1 == -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tint pos2 = newContent.indexOf(\n\t\t\t\t\tStringPool.TAB + \"try {\", pos1 + 1);\n\t\t\t\tint pos3 = newContent.indexOf(\"\\\"select count(\", pos1);\n\n\t\t\t\tif ((pos2 != -1) && (pos3 != -1) && (pos2 < pos3)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint pos4 = newContent.indexOf(\"rs.getLong(1)\", pos1);\n\t\t\t\tint pos5 = newContent.indexOf(\n\t\t\t\t\tStringPool.TAB + \"finally {\", pos1);\n\n\t\t\t\tif ((pos3 == -1) || (pos4 == -1) || (pos5 == -1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ((pos3 < pos4) && (pos4 < pos5)) {\n\t\t\t\t\tprocessErrorMessage(\n\t\t\t\t\t\tfileName, \"Use getInt(1) for count: \" + fileName);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// LPS-33070\n\n\t\t\tif (content.contains(\"implements ProcessCallable\") &&\n\t\t\t\t!content.contains(\n\t\t\t\t\t\"private static final long serialVersionUID\")) {\n\n\t\t\t\tprocessErrorMessage(\n\t\t\t\t\tfileName,\n\t\t\t\t\t\"Assign ProcessCallable implementation a \" +\n\t\t\t\t\t\t\"serialVersionUID: \" + fileName);\n\t\t\t}\n\n\t\t\tcheckLanguageKeys(fileName, newContent, languageKeyPattern);\n\n\t\t\t// LPS-36174\n\n\t\t\tif (_checkUnprocessedExceptions && !fileName.contains(\"/test/\")) {\n\t\t\t\tcheckUnprocessedExceptions(\n\t\t\t\t\tnewContent, file, packagePath, fileName);\n\t\t\t}\n\n\t\t\tString oldContent = newContent;\n\n\t\t\tfor (;;) {\n\t\t\t\tnewContent = formatJava(fileName, oldContent);\n\n\t\t\t\tnewContent = StringUtil.replace(newContent, \"\\n\\n\\n\", \"\\n\\n\");\n\n\t\t\t\tif (oldContent.equals(newContent)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\toldContent = newContent;\n\t\t\t}\n\n\t\t\tif (isAutoFix() && (newContent != null) &&\n\t\t\t\t!content.equals(newContent)) {\n\n\t\t\t\tfileUtil.write(file, newContent);\n\n\t\t\t\tsourceFormatterHelper.printError(fileName, file);\n\t\t\t}\n\t\t}\n\t}","id":75653,"modified_method":"@Override\n\tprotected void doFormat() throws Exception {\n\t\tCollection<String> fileNames = null;\n\n\t\tif (portalSource) {\n\t\t\tfileNames = getPortalJavaFiles();\n\n\t\t\t_checkUnprocessedExceptions = GetterUtil.getBoolean(\n\t\t\t\tSystem.getProperty(\n\t\t\t\t\t\"source.formatter.check.unprocessed.exceptions\"));\n\t\t}\n\t\telse {\n\t\t\tfileNames = getPluginJavaFiles();\n\t\t}\n\n\t\t_javaTermSortExclusions = getExclusionsProperties(\n\t\t\t\"source_formatter_javaterm_sort_exclusions.properties\");\n\t\t_lineLengthExclusions = getExclusionsProperties(\n\t\t\t\"source_formatter_line_length_exclusions.properties\");\n\t\t_staticLogVariableExclusions = getExclusionsProperties(\n\t\t\t\"source_formatter_static_log_exclusions.properties\");\n\t\t_upgradeServiceUtilExclusions = getExclusionsProperties(\n\t\t\t\"source_formatter_upgrade_service_util_exclusions.properties\");\n\n\t\tfor (String fileName : fileNames) {\n\t\t\tdoFormat(fileName);\n\t\t}\n\t}","commit_id":"68aba665ac89373383bc4b8aaeffe5d16e16f496","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * This method is invoked by the EventIpcManager when a new event is\n     * available for processing. Each message is examined for its Universal\n     * Event Identifier and the appropriate action is taking based on each UEI.\n     * \n     * @param event\n     *            The event\n     * \n     */\n    public void onEvent(Event event) {\n        Category log = ThreadCategory.getInstance(getClass());\n\n        String eventUei = event.getUei();\n        if (eventUei == null)\n            return;\n\n        if (log.isDebugEnabled())\n            log.debug(\"Received event: \" + eventUei);\n\n        if (eventUei.equals(EventConstants.NODE_GAINED_INTERFACE_EVENT_UEI)) {\n            // add to known nodes\n            if (Long.toString(event.getNodeid()) != null && event.getInterface() != null) {\n                TrapdIPMgr.setNodeId(event.getInterface(), event.getNodeid());\n            }\n            if (log.isDebugEnabled())\n                log.debug(\"Added \" + event.getInterface() + \" to known node list\");\n        } else if (eventUei.equals(EventConstants.INTERFACE_DELETED_EVENT_UEI)) {\n            // remove from known nodes\n            if (event.getInterface() != null) {\n                TrapdIPMgr.removeNodeId(event.getInterface());\n            }\n            if (log.isDebugEnabled())\n                log.debug(\"Removed \" + event.getInterface() + \" from known node list\");\n        } else if (eventUei.equals(EventConstants.INTERFACE_REPARENTED_EVENT_UEI)) {\n            // add to known nodes\n            if (Long.toString(event.getNodeid()) != null && event.getInterface() != null) {\n                TrapdIPMgr.setNodeId(event.getInterface(), event.getNodeid());\n            }\n            if (log.isDebugEnabled())\n                log.debug(\"Reparented \" + event.getInterface() + \" to known node list\");\n        }\n    }","id":75654,"modified_method":"/**\n     * This method is invoked by the EventIpcManager when a new event is\n     * available for processing. Each message is examined for its Universal\n     * Event Identifier and the appropriate action is taking based on each UEI.\n     * \n     * @param event\n     *            The event\n     * \n     */\n    public void onEvent(Event event) {\n        Category log = ThreadCategory.getInstance(getClass());\n\n        String eventUei = event.getUei();\n        if (eventUei == null) {\n            log.warn(\"Received an unexpected event with a null UEI\");\n            return;\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Received event: \" + eventUei);\n        }\n\n        if (eventUei.equals(EventConstants.NODE_GAINED_INTERFACE_EVENT_UEI)\n            || eventUei.equals(EventConstants.INTERFACE_REPARENTED_EVENT_UEI)) {\n            String action = eventUei.equals(EventConstants.INTERFACE_REPARENTED_EVENT_UEI) ?\n                \"reparent\" : \"add\";\n            if (Long.toString(event.getNodeid()) == null) {\n                log.warn(\"Not \" + action + \"ing interface to known node list: \"\n                    + \"nodeId is null\");\n            } else if (event.getInterface() == null) {\n                log.warn(\"Not \" + action + \"ing interface to known node list: \"\n                    + \"interface is null\");\n            } else {\n                TrapdIPMgr.setNodeId(event.getInterface(), event.getNodeid());\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Successfully \" + action + \"ed \"\n                              + event.getInterface() + \" to known node list\");\n                }\n            }\n        } else if (eventUei.equals(EventConstants.INTERFACE_DELETED_EVENT_UEI)) {\n            if (event.getInterface() != null) {\n                TrapdIPMgr.removeNodeId(event.getInterface());\n            }\n            if (log.isDebugEnabled()) {\n                log.debug(\"Removed \" + event.getInterface()\n                    + \" from known node list\");\n            }\n        } else {\n            log.warn(\"Received an unexpected event with UEI of \\\"\"\n                     + eventUei + \"\\\"\");\n        }\n    }","commit_id":"f1e22e5a3beacd2920d9c145a6e3bf2e80e9260c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Create message selector to set to the subscription\n     */\n    BroadcastEventProcessor() {\n        // Create the selector for the ueis this service is interested in\n        //\n        List ueiList = new ArrayList();\n\n        // nodeGainedInterface\n        ueiList.add(EventConstants.NODE_GAINED_INTERFACE_EVENT_UEI);\n\n        // interfaceDeleted\n        ueiList.add(EventConstants.INTERFACE_DELETED_EVENT_UEI);\n\n        EventIpcManagerFactory.init();\n        EventIpcManagerFactory.getIpcManager().addEventListener(this, ueiList);\n    }","id":75655,"modified_method":"/**\n     * Create message selector to set to the subscription\n     */\n    BroadcastEventProcessor() {\n        // Create the selector for the ueis this service is interested in\n        List ueiList = new ArrayList();\n\n        ueiList.add(EventConstants.NODE_GAINED_INTERFACE_EVENT_UEI);\n        ueiList.add(EventConstants.INTERFACE_DELETED_EVENT_UEI);\n        ueiList.add(EventConstants.INTERFACE_REPARENTED_EVENT_UEI);\n\n        EventIpcManagerFactory.init();\n        EventIpcManagerFactory.getIpcManager().addEventListener(this, ueiList);\n    }","commit_id":"f1e22e5a3beacd2920d9c145a6e3bf2e80e9260c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Given an address, return the coordinates for that address.\n     *\n     * @param address the complete address, in a format a geolocator can understand\n     * @return the coordinates for the given address\n     */\n    private Coordinates getCoordinates(final String address) {\n        Coordinates coordinates = null;\n        try {\n            coordinates = m_geocoderService.getCoordinates(address);\n            if (coordinates == null) {\n                coordinates = new Coordinates(Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY);\n            }\n        } catch (final TemporaryGeocoderException e) {\n            LOG.debug(\"Failed to find coordinates for address '{}' due to a temporary failure.\", address);\n        } catch (final GeocoderException e) {\n            LOG.debug(\"Failed to find coordinates for address '{}'.\", address);\n            coordinates = new Coordinates(Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY);\n        }\n        return coordinates;\n    }","id":75656,"modified_method":"/**\n     * Given an address, return the coordinates for that address.\n     *\n     * @param address the complete address, in a format a geolocator can understand\n     * @return the coordinates for the given address\n     */\n    private Coordinates getCoordinates(final String address) {\n        Coordinates coordinates = null;\n        try {\n            coordinates = getGeocoderService().getCoordinates(address);\n            if (coordinates == null) {\n                coordinates = new Coordinates(Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY);\n            }\n        } catch (final TemporaryGeocoderException e) {\n            LOG.debug(\"Failed to find coordinates for address '{}' due to a temporary failure.\", address);\n        } catch (final GeocoderException e) {\n            LOG.debug(\"Failed to find coordinates for address '{}'.\", address);\n            coordinates = new Coordinates(Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY);\n        }\n        return coordinates;\n    }","commit_id":"4720a9f5dd6b3b00d10e7d9d28c89c1478b03f02","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void init() {\n        refreshNodeData();\n        showNodes(m_activeNodes);\n    }","id":75657,"modified_method":"public void init() {\n        m_executor.scheduleWithFixedDelay(new Runnable() {\n            @Override public void run() {\n                refreshNodeData();\n            }\n        }, 0, 5, TimeUnit.MINUTES);\n    }","commit_id":"4720a9f5dd6b3b00d10e7d9d28c89c1478b03f02","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void refreshNodeData() {\n        if (m_nodeDao == null) {\n            LOG.warn(\"No node DAO!  Can't refresh node data.\");\n            return;\n        }\n\n        LOG.debug(\"getting nodes\");\n\n        final CriteriaBuilder cb = new CriteriaBuilder(OnmsNode.class);\n        cb.alias(\"assetRecord\", \"asset\");\n        cb.orderBy(\"id\").asc();\n\n        final List<OnmsAssetRecord> updatedAssets = new ArrayList<OnmsAssetRecord>();\n        final Map<Integer, NodeEntry> nodes = new HashMap<Integer, NodeEntry>();\n\n        m_transaction.execute(new TransactionCallbackWithoutResult() {\n            @Override\n            protected void doInTransactionWithoutResult(final TransactionStatus status) {\n                for (final OnmsNode node : m_nodeDao.findMatching(cb.toCriteria())) {\n                    LOG.trace(\"processing node {}\", node.getId());\n\n                    // pass 1: get the nodes with asset data\n                    final OnmsAssetRecord assets = node.getAssetRecord();\n                    if (assets != null && assets.getGeolocation() != null) {\n                        final OnmsGeolocation geolocation = assets.getGeolocation();\n                        final String addressString = geolocation.asAddressString();\n\n                        final Float longitude = geolocation.getLongitude();\n                        final Float latitude = geolocation.getLatitude();\n\n                        if (longitude != null && latitude != null) {\n                            if (longitude == Float.NEGATIVE_INFINITY || latitude == Float.NEGATIVE_INFINITY) {\n                                // we've already cached it as bad, skip it\n                                continue;\n                            } else {\n                                // we've already got good coordinates, return the node\n                                nodes.put(node.getId(), new NodeEntry(node));\n                                continue;\n                            }\n                        } else if (addressString == null || \"\".equals(addressString)) {\n                            // no real address info, skip it\n                            continue;\n                        } else {\n                            LOG.debug(\"Node {} has an asset record with address \\\"{}\\\", but no coordinates.\", new Object[]{node.getId(), addressString});\n                            final Coordinates coordinates = getCoordinates(addressString);\n\n                            if (coordinates == null) {\n                                LOG.debug(\"Node {} has an asset record with address, but we were unable to find valid coordinates.\", node.getId());\n                                continue;\n                            }\n\n                            geolocation.setLongitude(coordinates.getLongitude());\n                            geolocation.setLatitude(coordinates.getLatitude());\n                            updatedAssets.add(assets);\n\n                            if (coordinates.getLongitude() == Float.NEGATIVE_INFINITY || coordinates.getLatitude() == Float.NEGATIVE_INFINITY) {\n                                // we got bad coordinates\n                                LOG.debug(\"Node {} has an asset record with address, but we were unable to find valid coordinates.\", node.getId());\n                                continue;\n                            } else {\n                                // valid coordinates, add to the list\n                                nodes.put(node.getId(), new NodeEntry(node));\n                            }\n                        }\n                    } else {\n                        // no asset information\n                    }\n                }\n\n                int lastId = -1;\n                int unackedCount = 0;\n\n                // pass 2: get alarm data for anything that's been grabbed from the DB\n                if (!m_activeNodes.isEmpty()) {\n                    LOG.debug(\"getting alarms for nodes\");\n                    final CriteriaBuilder ab = new CriteriaBuilder(OnmsAlarm.class);\n                    ab.alias(\"node\", \"node\");\n                    ab.ge(\"severity\", OnmsSeverity.WARNING);\n                    ab.in(\"node.id\", m_activeNodes.keySet());\n                    ab.orderBy(\"node.id\").asc();\n                    ab.orderBy(\"severity\").desc();\n\n                    for (final OnmsAlarm alarm : m_alarmDao.findMatching(ab.toCriteria())) {\n                        final int nodeId = alarm.getNodeId();\n                        LOG.debug(\"nodeId = {}, lastId = {}, unackedCount = {}\", new Object[]{nodeId, lastId, unackedCount});\n                        if (nodeId != lastId) {\n                            LOG.debug(\"  setting severity for node {} to {}\", new Object[]{nodeId, alarm.getSeverity().getLabel()});\n                            final NodeEntry nodeEntry = m_activeNodes.get(nodeId);\n                            nodeEntry.setSeverity(alarm.getSeverity());\n                            if (lastId != -1) {\n                                nodeEntry.setUnackedCount(unackedCount);\n                                unackedCount = 0;\n                            }\n                        }\n                        if (alarm.getAckUser() == null) {\n                            unackedCount++;\n                        }\n\n                        lastId = nodeId;\n                    }\n                }\n\n                if (lastId != -1) {\n                    m_activeNodes.get(lastId).setUnackedCount(unackedCount);\n                }\n\n                // pass 3: save any asset updates to the database\n                LOG.debug(\"saving {} updated asset records to the database\", updatedAssets.size());\n                for (final OnmsAssetRecord asset : updatedAssets) {\n                    m_assetDao.saveOrUpdate(asset);\n                }\n            }\n        });\n\n\n        m_activeNodes = nodes;\n    }","id":75658,"modified_method":"private void refreshNodeData() {\n        if (getNodeDao() == null) {\n            LOG.warn(\"No node DAO!  Can't refresh node data.\");\n            return;\n        }\n\n        LOG.debug(\"Refreshing node data.\");\n\n        final CriteriaBuilder cb = new CriteriaBuilder(OnmsNode.class);\n        cb.alias(\"assetRecord\", \"asset\");\n        cb.orderBy(\"id\").asc();\n\n        final List<OnmsAssetRecord> updatedAssets = new ArrayList<OnmsAssetRecord>();\n        final Map<Integer, NodeEntry> nodes = new HashMap<Integer, NodeEntry>();\n\n        m_transaction.execute(new TransactionCallbackWithoutResult() {\n            @Override\n            protected void doInTransactionWithoutResult(final TransactionStatus status) {\n                for (final OnmsNode node : getNodeDao().findMatching(cb.toCriteria())) {\n                    LOG.trace(\"processing node {}\", node.getId());\n\n                    // pass 1: get the nodes with asset data\n                    final OnmsAssetRecord assets = node.getAssetRecord();\n                    if (assets != null && assets.getGeolocation() != null) {\n                        final OnmsGeolocation geolocation = assets.getGeolocation();\n                        final String addressString = geolocation.asAddressString();\n\n                        final Float longitude = geolocation.getLongitude();\n                        final Float latitude = geolocation.getLatitude();\n\n                        if (longitude != null && latitude != null) {\n                            if (longitude == Float.NEGATIVE_INFINITY || latitude == Float.NEGATIVE_INFINITY) {\n                                // we've already cached it as bad, skip it\n                                continue;\n                            } else {\n                                // we've already got good coordinates, return the node\n                                nodes.put(node.getId(), new NodeEntry(node));\n                                continue;\n                            }\n                        } else if (addressString == null || \"\".equals(addressString)) {\n                            // no real address info, skip it\n                            continue;\n                        } else {\n                            LOG.debug(\"Node {} has an asset record with address \\\"{}\\\", but no coordinates.\", new Object[]{node.getId(), addressString});\n                            final Coordinates coordinates = getCoordinates(addressString);\n\n                            if (coordinates == null) {\n                                LOG.debug(\"Node {} has an asset record with address, but we were unable to find valid coordinates.\", node.getId());\n                                continue;\n                            }\n\n                            geolocation.setLongitude(coordinates.getLongitude());\n                            geolocation.setLatitude(coordinates.getLatitude());\n                            updatedAssets.add(assets);\n\n                            if (coordinates.getLongitude() == Float.NEGATIVE_INFINITY || coordinates.getLatitude() == Float.NEGATIVE_INFINITY) {\n                                // we got bad coordinates\n                                LOG.debug(\"Node {} has an asset record with address, but we were unable to find valid coordinates.\", node.getId());\n                                continue;\n                            } else {\n                                // valid coordinates, add to the list\n                                nodes.put(node.getId(), new NodeEntry(node));\n                            }\n                        }\n                    } else {\n                        // no asset information\n                    }\n                }\n\n                int lastId = -1;\n                int unackedCount = 0;\n\n                // pass 2: get alarm data for anything that's been grabbed from the DB\n                if (!m_activeNodes.isEmpty()) {\n                    LOG.debug(\"getting alarms for nodes\");\n                    final CriteriaBuilder ab = new CriteriaBuilder(OnmsAlarm.class);\n                    ab.alias(\"node\", \"node\");\n                    ab.ge(\"severity\", OnmsSeverity.WARNING);\n                    ab.in(\"node.id\", m_activeNodes.keySet());\n                    ab.orderBy(\"node.id\").asc();\n                    ab.orderBy(\"severity\").desc();\n\n                    for (final OnmsAlarm alarm : getAlarmDao().findMatching(ab.toCriteria())) {\n                        final int nodeId = alarm.getNodeId();\n                        LOG.debug(\"nodeId = {}, lastId = {}, unackedCount = {}\", new Object[]{nodeId, lastId, unackedCount});\n                        if (nodeId != lastId) {\n                            LOG.debug(\"  setting severity for node {} to {}\", new Object[]{nodeId, alarm.getSeverity().getLabel()});\n                            final NodeEntry nodeEntry = m_activeNodes.get(nodeId);\n                            nodeEntry.setSeverity(alarm.getSeverity());\n                            if (lastId != -1) {\n                                nodeEntry.setUnackedCount(unackedCount);\n                                unackedCount = 0;\n                            }\n                        }\n                        if (alarm.getAckUser() == null) {\n                            unackedCount++;\n                        }\n\n                        lastId = nodeId;\n                    }\n                }\n\n                if (lastId != -1) {\n                    m_activeNodes.get(lastId).setUnackedCount(unackedCount);\n                }\n\n                // pass 3: save any asset updates to the database\n                LOG.debug(\"saving {} updated asset records to the database\", updatedAssets.size());\n                for (final OnmsAssetRecord asset : updatedAssets) {\n                    getAssetRecordDao().saveOrUpdate(asset);\n                }\n            }\n        });\n\n\n        m_activeNodes = nodes;\n        showNodes(nodes);\n    }","commit_id":"4720a9f5dd6b3b00d10e7d9d28c89c1478b03f02","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public MapNode createNode() {\n            MapNode node = new MapNode();\n            node.setLatitude(m_latitude);\n            node.setLongitude(m_longitude);\n            if (m_nodeId != null) {\n                node.setNodeId(m_nodeId.toString());\n            }\n            node.setNodeLabel(m_nodeLabel);\n            node.setForeignSource(m_foreignSource);\n            node.setForeignId(m_foreignId);\n            node.setIpAddress(m_ipAddress);\n            node.setDescription(m_description);\n            node.setMaintcontract(m_maintcontract);\n\n            node.setSeverityLabel(m_severity.getLabel());\n            node.setSeverity(String.valueOf(m_severity.getId()));\n            node.setUnackedCount(m_unackedCount);\n\n            node.setCategories(m_categories);\n            return node;\n        }","id":75659,"modified_method":"public MapNode createNode() {\n            final MapNode node = new MapNode();\n\n            node.setLatitude(m_latitude);\n            node.setLongitude(m_longitude);\n            node.setNodeId(String.valueOf(m_nodeId));\n            node.setNodeLabel(m_nodeLabel);\n            node.setForeignSource(m_foreignSource);\n            node.setForeignId(m_foreignId);\n            node.setIpAddress(m_ipAddress);\n            node.setDescription(m_description);\n            node.setMaintcontract(m_maintcontract);\n\n            node.setSeverityLabel(m_severity.getLabel());\n            node.setSeverity(String.valueOf(m_severity.getId()));\n            node.setUnackedCount(m_unackedCount);\n\n            node.setCategories(m_categories);\n            return node;\n        }","commit_id":"4720a9f5dd6b3b00d10e7d9d28c89c1478b03f02","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void showNodes(final Map<Integer, NodeEntry> nodeEntries) {\n        final List<MapNode> nodes = new LinkedList<MapNode>();\n        for (final NodeEntry node : nodeEntries.values()) {\n            nodes.add(node.createNode());\n        }\n        getState().nodes = nodes;\n    }","id":75660,"modified_method":"public void showNodes(final Map<Integer, NodeEntry> nodeEntries) {\n        LOG.info(\"Updating map node list: {} entries.\", nodeEntries.size());\n\n        final List<MapNode> nodes = new LinkedList<MapNode>();\n        for (final NodeEntry node : nodeEntries.values()) {\n            nodes.add(node.createNode());\n        }\n        getState().nodes = nodes;\n\n        LOG.info(\"Finished updating map node list.\");\n    }","commit_id":"4720a9f5dd6b3b00d10e7d9d28c89c1478b03f02","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is invoked by the EventIpcManager when a new event is\n     * available for processing. Each message is examined for its Universal\n     * Event Identifier and the appropriate action is taking based on each UEI.\n     * \n     * @param event\n     *            The event\n     * \n     */\n    public void onEvent(Event event) {\n        Category log = ThreadCategory.getInstance(getClass());\n\n        String eventUei = event.getUei();\n        if (eventUei == null)\n            return;\n\n        if (log.isDebugEnabled())\n            log.debug(\"Received event: \" + eventUei);\n\n        if (eventUei.equals(EventConstants.NODE_GAINED_INTERFACE_EVENT_UEI)) {\n            // add to known nodes\n            if (Long.toString(event.getNodeid()) != null && event.getInterface() != null) {\n                TrapdIPMgr.setNodeId(event.getInterface(), event.getNodeid());\n            }\n            if (log.isDebugEnabled())\n                log.debug(\"Added \" + event.getInterface() + \" to known node list\");\n        } else if (eventUei.equals(EventConstants.INTERFACE_DELETED_EVENT_UEI)) {\n            // remove from known nodes\n            if (event.getInterface() != null) {\n                TrapdIPMgr.removeNodeId(event.getInterface());\n            }\n            if (log.isDebugEnabled())\n                log.debug(\"Removed \" + event.getInterface() + \" from known node list\");\n        } else if (eventUei.equals(EventConstants.INTERFACE_REPARENTED_EVENT_UEI)) {\n            // add to known nodes\n            if (Long.toString(event.getNodeid()) != null && event.getInterface() != null) {\n                TrapdIPMgr.setNodeId(event.getInterface(), event.getNodeid());\n            }\n            if (log.isDebugEnabled())\n                log.debug(\"Reparented \" + event.getInterface() + \" to known node list\");\n        }\n    }","id":75661,"modified_method":"/**\n     * This method is invoked by the EventIpcManager when a new event is\n     * available for processing. Each message is examined for its Universal\n     * Event Identifier and the appropriate action is taking based on each UEI.\n     * \n     * @param event\n     *            The event\n     * \n     */\n    public void onEvent(Event event) {\n        Category log = ThreadCategory.getInstance(getClass());\n\n        String eventUei = event.getUei();\n        if (eventUei == null) {\n            log.warn(\"Received an unexpected event with a null UEI\");\n            return;\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Received event: \" + eventUei);\n        }\n\n        if (eventUei.equals(EventConstants.NODE_GAINED_INTERFACE_EVENT_UEI)\n            || eventUei.equals(EventConstants.INTERFACE_REPARENTED_EVENT_UEI)) {\n            String action = eventUei.equals(EventConstants.INTERFACE_REPARENTED_EVENT_UEI) ?\n                \"reparent\" : \"add\";\n            if (Long.toString(event.getNodeid()) == null) {\n                log.warn(\"Not \" + action + \"ing interface to known node list: \"\n                    + \"nodeId is null\");\n            } else if (event.getInterface() == null) {\n                log.warn(\"Not \" + action + \"ing interface to known node list: \"\n                    + \"interface is null\");\n            } else {\n                TrapdIPMgr.setNodeId(event.getInterface(), event.getNodeid());\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Successfully \" + action + \"ed \"\n                              + event.getInterface() + \" to known node list\");\n                }\n            }\n        } else if (eventUei.equals(EventConstants.INTERFACE_DELETED_EVENT_UEI)) {\n            if (event.getInterface() != null) {\n                TrapdIPMgr.removeNodeId(event.getInterface());\n            }\n            if (log.isDebugEnabled()) {\n                log.debug(\"Removed \" + event.getInterface()\n                    + \" from known node list\");\n            }\n        } else {\n            log.warn(\"Received an unexpected event with UEI of \\\"\"\n                     + eventUei + \"\\\"\");\n        }\n    }","commit_id":"01d43a8a3777f32be572dc15e16706e623b0675e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Create message selector to set to the subscription\n     */\n    BroadcastEventProcessor() {\n        // Create the selector for the ueis this service is interested in\n        //\n        List ueiList = new ArrayList();\n\n        // nodeGainedInterface\n        ueiList.add(EventConstants.NODE_GAINED_INTERFACE_EVENT_UEI);\n\n        // interfaceDeleted\n        ueiList.add(EventConstants.INTERFACE_DELETED_EVENT_UEI);\n\n        EventIpcManagerFactory.init();\n        EventIpcManagerFactory.getIpcManager().addEventListener(this, ueiList);\n    }","id":75662,"modified_method":"/**\n     * Create message selector to set to the subscription\n     */\n    BroadcastEventProcessor() {\n        // Create the selector for the ueis this service is interested in\n        List ueiList = new ArrayList();\n\n        ueiList.add(EventConstants.NODE_GAINED_INTERFACE_EVENT_UEI);\n        ueiList.add(EventConstants.INTERFACE_DELETED_EVENT_UEI);\n        ueiList.add(EventConstants.INTERFACE_REPARENTED_EVENT_UEI);\n\n        EventIpcManagerFactory.init();\n        EventIpcManagerFactory.getIpcManager().addEventListener(this, ueiList);\n    }","commit_id":"01d43a8a3777f32be572dc15e16706e623b0675e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public void visit(Way w) {\n        if (!w.isUsable() || w.isClosed() || !w.hasKey(\"highway\")) {\n            return;\n        }\n\n        for (OsmPrimitive p : w.firstNode().getReferrers()) {\n            testForError(w, w.firstNode(), p);\n        }\n        for (OsmPrimitive p : w.lastNode().getReferrers()) {\n            testForError(w, w.lastNode(), p);\n        }\n\n    }","id":75663,"modified_method":"@Override\n    public void visit(Way w) {\n        if (!w.isUsable() || w.isClosed() || !w.hasKey(\"highway\")) {\n            return;\n        }\n\n        boolean hasway = false;\n        List<OsmPrimitive> r = w.firstNode().getReferrers();\n        for (OsmPrimitive p : r) {\n            if(p != w && p.hasKey(\"highway\")) {\n                hasway = true;\n                break;\n            }\n        }\n        if(!hasway)\n        {\n            for (OsmPrimitive p : r) {\n                testForError(w, w.firstNode(), p);\n            }\n        }\n        hasway = false;\n        r = w.lastNode().getReferrers();\n        for (OsmPrimitive p : r) {\n            if(p != w && p.hasKey(\"highway\")) {\n                hasway = true;\n                break;\n            }\n        }\n        if(!hasway) {\n            for (OsmPrimitive p : r) {\n                testForError(w, w.lastNode(), p);\n            }\n        }\n    }","commit_id":"477766fff61b24ed01ec2842be94d949e6d55ae7","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Tries to merge a primitive <code>source<\/code> into an existing primitive with the same id.\n     *\n     * @param source  the source primitive which is to be merged into a target primitive\n     * @return true, if this method was able to merge <code>source<\/code> into a target object; false, otherwise\n     */\n    private boolean mergeById(OsmPrimitive source) {\n        OsmPrimitive target = targetDataSet.getPrimitiveById(source.getId(), source.getType());\n        // merge other into an existing primitive with the same id, if possible\n        //\n        if (target == null)\n            return false;\n        // found a corresponding target, remember it\n        mergedMap.put(source.getUniqueId(), target.getUniqueId());\n\n        if (target.getVersion() > source.getVersion())\n            // target.version > source.version => keep target version\n            return true;\n        if (! target.isVisible() && source.isVisible()) {\n            // should not happen\n            // FIXME: this message does not make sense, source version can not be lower than\n            //        target version at this point\n            logger.warning(tr(\"Target object with id {0} and version {1} is visible although \"\n                    + \"source object with lower version {2} is not visible. \"\n                    + \"Cannot deal with this inconsistency. Keeping target object. \",\n                    Long.toString(target.getId()),Long.toString(target.getVersion()), Long.toString(source.getVersion())\n            ));\n        } else if (target.isVisible() && ! source.isVisible()) {\n            // this is always a conflict because the user has to decide whether\n            // he wants to create a clone of its target primitive or whether he\n            // wants to purge the target from the local dataset. He can't keep it unchanged\n            // because it was deleted on the server.\n            //\n            conflicts.add(target,source);\n        } else if (target.isIncomplete() && !source.isIncomplete()) {\n            // target is incomplete, source completes it\n            // => merge source into target\n            //\n            target.mergeFrom(source);\n            objectsWithChildrenToMerge.add(source.getPrimitiveId());\n        } else if (!target.isIncomplete() && source.isIncomplete()) {\n            // target is complete and source is incomplete\n            // => keep target, it has more information already\n            //\n        } else if (target.isIncomplete() && source.isIncomplete()) {\n            // target and source are incomplete. Doesn't matter which one to\n            // take. We take target.\n            //\n        } else if (target.isDeleted() && ! source.isDeleted() && target.getVersion() == source.getVersion()) {\n            // same version, but target is deleted. Assume target takes precedence\n            // otherwise too many conflicts when refreshing from the server\n            // but, if source has referrers there is a conflict\n            if (!source.getReferrers().isEmpty()) {\n                conflicts.add(target, source);\n            }\n        } else if (target.isDeleted() != source.isDeleted()) {\n            // differences in deleted state have to be resolved manually. This can\n            // happen if one layer is merged onto another layer\n            //\n            conflicts.add(target,source);\n        } else if (! target.isModified() && source.isModified()) {\n            // target not modified. We can assume that source is the most recent version.\n            // clone it into target. But check first, whether source is deleted. if so,\n            // make sure that target is not referenced any more in myDataSet. If it is there\n            // is a conflict\n            if (source.isDeleted()) {\n                if (!target.getReferrers().isEmpty()) {\n                    conflicts.add(target, source);\n                }\n            } else {\n                target.mergeFrom(source);\n                objectsWithChildrenToMerge.add(source.getPrimitiveId());\n            }\n        } else if (! target.isModified() && !source.isModified() && target.getVersion() == source.getVersion()) {\n            // both not modified. Merge nevertheless.\n            // This helps when updating \"empty\" relations, see #4295\n            target.mergeFrom(source);\n            objectsWithChildrenToMerge.add(source.getPrimitiveId());\n        } else if (! target.isModified() && !source.isModified() && target.getVersion() < source.getVersion()) {\n            // my not modified but other is newer. clone other onto mine.\n            //\n            target.mergeFrom(source);\n            objectsWithChildrenToMerge.add(source.getPrimitiveId());\n        } else if (target.isModified() && ! source.isModified() && target.getVersion() == source.getVersion()) {\n            // target is same as source but target is modified\n            // => keep target and reset modified flag if target and source are semantically equal\n            if (target.hasEqualSemanticAttributes(source)) {\n                target.setModified(false);\n            }\n        } else if (! target.hasEqualSemanticAttributes(source)) {\n            // target is modified and is not semantically equal with source. Can't automatically\n            // resolve the differences\n            // =>  create a conflict\n            conflicts.add(target,source);\n        } else {\n            // clone from other, but keep the modified flag. mergeFrom will mainly copy\n            // technical attributes like timestamp or user information. Semantic\n            // attributes should already be equal if we get here.\n            //\n            target.mergeFrom(source);\n            target.setModified(true);\n            objectsWithChildrenToMerge.add(source.getPrimitiveId());\n        }\n        return true;\n    }","id":75664,"modified_method":"/**\n     * Tries to merge a primitive <code>source<\/code> into an existing primitive with the same id.\n     *\n     * @param source  the source primitive which is to be merged into a target primitive\n     * @return true, if this method was able to merge <code>source<\/code> into a target object; false, otherwise\n     */\n    private boolean mergeById(OsmPrimitive source) {\n        OsmPrimitive target = targetDataSet.getPrimitiveById(source.getId(), source.getType());\n        // merge other into an existing primitive with the same id, if possible\n        //\n        if (target == null)\n            return false;\n        // found a corresponding target, remember it\n        mergedMap.put(source.getUniqueId(), target.getUniqueId());\n\n        if (target.getVersion() > source.getVersion())\n            // target.version > source.version => keep target version\n            return true;\n        if (! target.isVisible() && source.isVisible()) {\n            // should not happen\n            // FIXME: this message does not make sense, source version can not be lower than\n            //        target version at this point\n            logger.warning(tr(\"Target object with id {0} and version {1} is visible although \"\n                    + \"source object with lower version {2} is not visible. \"\n                    + \"Cannot deal with this inconsistency. Keeping target object. \",\n                    Long.toString(target.getId()),Long.toString(target.getVersion()), Long.toString(source.getVersion())\n            ));\n        } else if (target.isVisible() && ! source.isVisible()) {\n            // this is always a conflict because the user has to decide whether\n            // he wants to create a clone of its target primitive or whether he\n            // wants to purge the target from the local dataset. He can't keep it unchanged\n            // because it was deleted on the server.\n            //\n            conflicts.add(target,source);\n        } else if (target.isIncomplete() && !source.isIncomplete()) {\n            // target is incomplete, source completes it\n            // => merge source into target\n            //\n            target.mergeFrom(source);\n            objectsWithChildrenToMerge.add(source.getPrimitiveId());\n        } else if (!target.isIncomplete() && source.isIncomplete()) {\n            // target is complete and source is incomplete\n            // => keep target, it has more information already\n            //\n        } else if (target.isIncomplete() && source.isIncomplete()) {\n            // target and source are incomplete. Doesn't matter which one to\n            // take. We take target.\n            //\n        } else if (target.isDeleted() && ! source.isDeleted() && target.getVersion() == source.getVersion()) {\n            // same version, but target is deleted. Assume target takes precedence\n            // otherwise too many conflicts when refreshing from the server\n            // but, if source has a referrer that is not in the target dataset there is a conflict\n            for (OsmPrimitive referrer: source.getReferrers()) {\n                if (targetDataSet.getPrimitiveById(referrer.getPrimitiveId()) == null) {\n                    conflicts.add(target, source);\n                    break;\n                }\n            }\n        } else if (target.isDeleted() != source.isDeleted()) {\n            // differences in deleted state have to be resolved manually. This can\n            // happen if one layer is merged onto another layer\n            //\n            conflicts.add(target,source);\n        } else if (! target.isModified() && source.isModified()) {\n            // target not modified. We can assume that source is the most recent version.\n            // clone it into target. But check first, whether source is deleted. if so,\n            // make sure that target is not referenced any more in myDataSet. If it is there\n            // is a conflict\n            if (source.isDeleted()) {\n                if (!target.getReferrers().isEmpty()) {\n                    conflicts.add(target, source);\n                }\n            } else {\n                target.mergeFrom(source);\n                objectsWithChildrenToMerge.add(source.getPrimitiveId());\n            }\n        } else if (! target.isModified() && !source.isModified() && target.getVersion() == source.getVersion()) {\n            // both not modified. Merge nevertheless.\n            // This helps when updating \"empty\" relations, see #4295\n            target.mergeFrom(source);\n            objectsWithChildrenToMerge.add(source.getPrimitiveId());\n        } else if (! target.isModified() && !source.isModified() && target.getVersion() < source.getVersion()) {\n            // my not modified but other is newer. clone other onto mine.\n            //\n            target.mergeFrom(source);\n            objectsWithChildrenToMerge.add(source.getPrimitiveId());\n        } else if (target.isModified() && ! source.isModified() && target.getVersion() == source.getVersion()) {\n            // target is same as source but target is modified\n            // => keep target and reset modified flag if target and source are semantically equal\n            if (target.hasEqualSemanticAttributes(source)) {\n                target.setModified(false);\n            }\n        } else if (! target.hasEqualSemanticAttributes(source)) {\n            // target is modified and is not semantically equal with source. Can't automatically\n            // resolve the differences\n            // =>  create a conflict\n            conflicts.add(target,source);\n        } else {\n            // clone from other, but keep the modified flag. mergeFrom will mainly copy\n            // technical attributes like timestamp or user information. Semantic\n            // attributes should already be equal if we get here.\n            //\n            target.mergeFrom(source);\n            target.setModified(true);\n            objectsWithChildrenToMerge.add(source.getPrimitiveId());\n        }\n        return true;\n    }","commit_id":"bf145318273b916ea6a604225960c5c51adfadfd","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Performs the navigation change.<p>\n     * \n     * @throws JspException if including a JSP subelement is not successful\n     */\n    public void actionChangeNav() throws JspException {\n        \n        // save initialized instance of this class in request attribute for included sub-elements\n        getJsp().getRequest().setAttribute(C_SESSION_WORKPLACE_CLASS, this);\n        \n        // get request parameters\n        String filename = getParamResource();\n        String newText = getParamNavtext();\n        String selectedPosString = getParamNavpos();\n        \n        try { \n            // lock resource if autolock is enabled\n            checkLock(getParamResource());\n            // save the new NavText if not null\n            if (newText != null) {\n                CmsProperty newNavText = new CmsProperty();\n                newNavText.setName(I_CmsConstants.C_PROPERTY_NAVTEXT);\n                CmsProperty oldNavText = getCms().readPropertyObject(filename, I_CmsConstants.C_PROPERTY_NAVTEXT, false);\n                if (oldNavText.isNullProperty()) {\n                    // property value was not already set\n                    if (OpenCms.getWorkplaceManager().isDefaultPropertiesOnStructure()) {\n                        newNavText.setStructureValue(newText);\n                    } else {\n                        newNavText.setResourceValue(newText);\n                    }                                         \n                } else {\n                    if (oldNavText.getStructureValue() != null) {\n                        newNavText.setStructureValue(newText);\n                        newNavText.setResourceValue(oldNavText.getResourceValue());\n                    } else {\n                        newNavText.setResourceValue(newText);\n                    }\n                }\n                getCms().writePropertyObject(filename, newNavText);\n            }\n            \n            // determine the selected position\n            float selectedPos = -1;\n            try {\n                selectedPos = Float.parseFloat(selectedPosString);\n            } catch (Exception e) {\n                // can usually be ignored\n                if (OpenCms.getLog(this).isInfoEnabled()) {\n                    OpenCms.getLog(this).info(e);\n                }\n            }\n            \n            // only update the position if a change is requested\n            if (selectedPos != -1) {\n                CmsProperty newNavPos = new CmsProperty();\n                newNavPos.setName(I_CmsConstants.C_PROPERTY_NAVPOS);\n                CmsProperty oldNavPos = getCms().readPropertyObject(filename, I_CmsConstants.C_PROPERTY_NAVPOS, false);\n                if (oldNavPos.isNullProperty()) {\n                    // property value was not already set\n                    if (OpenCms.getWorkplaceManager().isDefaultPropertiesOnStructure()) {\n                        newNavPos.setStructureValue(selectedPosString);\n                    } else {\n                        newNavPos.setResourceValue(selectedPosString);\n                    }                                         \n                } else {\n                    if (oldNavPos.getStructureValue() != null) {\n                        newNavPos.setStructureValue(selectedPosString);\n                        newNavPos.setResourceValue(oldNavPos.getResourceValue());\n                    } else {\n                        newNavPos.setResourceValue(selectedPosString);\n                    }\n                }\n                getCms().writePropertyObject(filename, newNavPos);\n            }\n        } catch (CmsException e) {\n            // error during chnav, show error dialog\n            setParamErrorstack(e.getStackTraceAsString());\n            setParamMessage(key(\"error.message.\" + getParamDialogtype()));\n            setParamReasonSuggestion(getErrorSuggestionDefault());\n            getJsp().include(C_FILE_DIALOG_SCREEN_ERROR);\n        \n        }\n        // chnav operation was successful, return to workplace\n        actionCloseDialog();\n    }","id":75665,"modified_method":"/**\n     * Performs the navigation change.<p>\n     * \n     * @throws JspException if including a JSP subelement is not successful\n     */\n    public void actionChangeNav() throws JspException {\n        \n        // save initialized instance of this class in request attribute for included sub-elements\n        getJsp().getRequest().setAttribute(C_SESSION_WORKPLACE_CLASS, this);\n        \n        // get request parameters\n        String filename = getParamResource();\n        String newText = getParamNavtext();\n        String selectedPosString = getParamNavpos();\n        \n        try { \n            // lock resource if autolock is enabled\n            checkLock(getParamResource());\n            // save the new NavText if not null\n            if (newText != null) {\n                CmsProperty newNavText = new CmsProperty();\n                newNavText.setName(I_CmsConstants.C_PROPERTY_NAVTEXT);\n                CmsProperty oldNavText = getCms().readPropertyObject(filename, I_CmsConstants.C_PROPERTY_NAVTEXT, false);\n                if (oldNavText.isNullProperty()) {\n                    // property value was not already set\n                    if (OpenCms.getWorkplaceManager().isDefaultPropertiesOnStructure()) {\n                        newNavText.setStructureValue(newText);\n                    } else {\n                        newNavText.setResourceValue(newText);\n                    }                                         \n                } else {\n                    if (oldNavText.getStructureValue() != null) {\n                        newNavText.setStructureValue(newText);\n                        newNavText.setResourceValue(oldNavText.getResourceValue());\n                    } else {\n                        newNavText.setResourceValue(newText);\n                    }\n                }\n                \n                String oldStructureValue = oldNavText.getStructureValue();\n                String newStructureValue = newNavText.getStructureValue();\n                if (CmsStringUtil.isEmpty(oldStructureValue)) {\n                    oldStructureValue = CmsProperty.C_DELETE_VALUE;\n                }\n                if (CmsStringUtil.isEmpty(newStructureValue)) {\n                    newStructureValue = CmsProperty.C_DELETE_VALUE;\n                }\n\n                String oldResourceValue = oldNavText.getResourceValue();\n                String newResourceValue = newNavText.getResourceValue();\n                if (CmsStringUtil.isEmpty(oldResourceValue)) {\n                    oldResourceValue = CmsProperty.C_DELETE_VALUE;\n                }\n                if (CmsStringUtil.isEmpty(newResourceValue)) {\n                    newResourceValue = CmsProperty.C_DELETE_VALUE;\n                }\n\n                // change nav text only if it has been changed            \n                if (!oldResourceValue.equals(newResourceValue) || !oldStructureValue.equals(newStructureValue)) {\n                    getCms().writePropertyObject(getParamResource(), newNavText);\n                }\n            }\n            \n            // determine the selected position\n            float selectedPos = -1;\n            try {\n                selectedPos = Float.parseFloat(selectedPosString);\n            } catch (Exception e) {\n                // can usually be ignored\n                if (OpenCms.getLog(this).isInfoEnabled()) {\n                    OpenCms.getLog(this).info(e);\n                }\n            }\n            \n            // only update the position if a change is requested\n            if (selectedPos != -1) {\n                CmsProperty newNavPos = new CmsProperty();\n                newNavPos.setName(I_CmsConstants.C_PROPERTY_NAVPOS);\n                CmsProperty oldNavPos = getCms().readPropertyObject(filename, I_CmsConstants.C_PROPERTY_NAVPOS, false);\n                if (oldNavPos.isNullProperty()) {\n                    // property value was not already set\n                    if (OpenCms.getWorkplaceManager().isDefaultPropertiesOnStructure()) {\n                        newNavPos.setStructureValue(selectedPosString);\n                    } else {\n                        newNavPos.setResourceValue(selectedPosString);\n                    }                                         \n                } else {\n                    if (oldNavPos.getStructureValue() != null) {\n                        newNavPos.setStructureValue(selectedPosString);\n                        newNavPos.setResourceValue(oldNavPos.getResourceValue());\n                    } else {\n                        newNavPos.setResourceValue(selectedPosString);\n                    }\n                }\n                getCms().writePropertyObject(filename, newNavPos);\n            }\n        } catch (CmsException e) {\n            // error during chnav, show error dialog\n            setParamErrorstack(e.getStackTraceAsString());\n            setParamMessage(key(\"error.message.\" + getParamDialogtype()));\n            setParamReasonSuggestion(getErrorSuggestionDefault());\n            getJsp().include(C_FILE_DIALOG_SCREEN_ERROR);\n        \n        }\n        // chnav operation was successful, return to workplace\n        actionCloseDialog();\n    }","commit_id":"5248e8432a76242bd1cf189e1a350fb26abb6c2b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Uploads the specified file and transforms it to HTML.<p>\n     * \n     * @throws JspException if inclusion of error dialog fails\n     */\n    public void actionUpload() throws JspException {\n\n        String errorMsgSuffix = \"\";\n        String newResname = \"\";\n\n        try {\n            if (CmsStringUtil.isNotEmpty(getParamCsvContent())) {\n                // csv content is pasted in the textarea\n                newResname = \"csvcontent.html\";\n                setParamNewResourceName(\"\");\n            } else {\n                try {\n                    setParamCsvContent(new String(getFileContentFromUpload(), CHARSET));\n                    newResname = getCms().getRequestContext().getFileTranslator().translateResource(\n                        CmsResource.getName(getParamResource().replace('\\\\', '/')));\n                    newResname = CmsStringUtil.changeFileNameSuffixTo(newResname, \"html\");\n                    setParamNewResourceName(newResname);\n                } catch (UnsupportedEncodingException e) {\n                    // should not happen\n                } catch (CmsException e) {\n                    // file size is larger than maximum allowed file size, throw an error\n                    errorMsgSuffix = \"size\";\n                    throw e;\n                } catch (FileNotFoundException e) {\n                    throw new CmsException(e.getMessage());\n                }\n            }\n\n            setParamResource(newResname);\n            setParamResource(computeFullResourceName());\n            int resTypeId = OpenCms.getResourceManager().getDefaultTypeForName(newResname).getTypeId();\n\n            String xmlContent = \"\";\n            CmsProperty styleProp = CmsProperty.getNullProperty();\n            if (TABULATOR.equals(getParamDelimiter())) {\n                setParamDelimiter(\"\\t\");\n            } else if (BEST_DELIMITER.equals(getParamDelimiter())) {\n                setParamDelimiter(getPreferredDelimiter(getParamCsvContent()));\n            }\n\n            xmlContent = convertCsvToXml(getParamCsvContent(), getParamDelimiter());\n\n            if (CmsStringUtil.isNotEmpty(getParamXsltFile())) {\n\n                xmlContent = applyXslTransformation(getParamXsltFile(), xmlContent);\n                styleProp = getCms().readPropertyObject(getParamXsltFile(), I_CmsConstants.C_PROPERTY_STYLESHEET, true);\n            }\n            byte[] content = xmlContent.getBytes();\n\n            try {\n                // create the resource\n                getCms().createResource(getParamResource(), resTypeId, content, Collections.EMPTY_LIST);\n            } catch (CmsException e) {\n                // resource was present, overwrite it\n                getCms().lockResource(getParamResource());\n                getCms().replaceResource(getParamResource(), resTypeId, content, null);\n            }\n            // copy xslt stylesheet-property to the new resource\n            getCms().writePropertyObject(getParamResource(), styleProp);\n        } catch (Exception e) {\n            // error uploading file, show error dialog\n            setAction(ACTION_SHOWERROR);\n            getJsp().getRequest().setAttribute(C_SESSION_WORKPLACE_CLASS, this);\n            setParamErrorstack(CmsException.getStackTraceAsString(e));\n            setParamMessage(key(\"error.message.upload\"));\n            setParamReasonSuggestion(key(\"error.reason.upload\" + errorMsgSuffix)\n                + \"<br>\\n\"\n                + key(\"error.suggestion.upload\" + errorMsgSuffix)\n                + \"\\n\");\n            getJsp().include(C_FILE_DIALOG_SCREEN_ERROR);\n            if (OpenCms.getLog(this).isErrorEnabled()) {\n                OpenCms.getLog(this).error(e);\n            }\n        }\n    }","id":75666,"modified_method":"/**\n     * Uploads the specified file and transforms it to HTML.<p>\n     * \n     * @throws JspException if inclusion of error dialog fails\n     */\n    public void actionUpload() throws JspException {\n\n        String errorMsgSuffix = \"\";\n        String newResname = \"\";\n\n        try {\n            if (CmsStringUtil.isNotEmpty(getParamCsvContent())) {\n                // csv content is pasted in the textarea\n                newResname = \"csvcontent.html\";\n                setParamNewResourceName(\"\");\n            } else {\n                try {\n                    setParamCsvContent(new String(getFileContentFromUpload(), CHARSET));\n                    newResname = getCms().getRequestContext().getFileTranslator().translateResource(\n                        CmsResource.getName(getParamResource().replace('\\\\', '/')));\n                    newResname = CmsStringUtil.changeFileNameSuffixTo(newResname, \"html\");\n                    setParamNewResourceName(newResname);\n                } catch (UnsupportedEncodingException e) {\n                    // should not happen\n                } catch (CmsException e) {\n                    // file size is larger than maximum allowed file size, throw an error\n                    errorMsgSuffix = \"size\";\n                    throw e;\n                } catch (FileNotFoundException e) {\n                    throw new CmsException(e.getMessage());\n                }\n            }\n\n            setParamResource(newResname);\n            setParamResource(computeFullResourceName());\n            int resTypeId = OpenCms.getResourceManager().getDefaultTypeForName(newResname).getTypeId();\n\n            String xmlContent = \"\";\n            CmsProperty styleProp = CmsProperty.getNullProperty();\n            if (TABULATOR.equals(getParamDelimiter())) {\n                setParamDelimiter(\"\\t\");\n            } else if (BEST_DELIMITER.equals(getParamDelimiter())) {\n                setParamDelimiter(getPreferredDelimiter(getParamCsvContent()));\n            }\n\n            xmlContent = convertCsvToXml(getParamCsvContent(), getParamDelimiter());\n\n            if (CmsStringUtil.isNotEmpty(getParamXsltFile())) {\n\n                xmlContent = applyXslTransformation(getParamXsltFile(), xmlContent);\n                styleProp = getCms().readPropertyObject(getParamXsltFile(), I_CmsConstants.C_PROPERTY_STYLESHEET, true);\n            }\n            byte[] content = xmlContent.getBytes();\n\n            try {\n                // create the resource\n                getCms().createResource(getParamResource(), resTypeId, content, Collections.EMPTY_LIST);\n            } catch (CmsException e) {\n                // resource was present, overwrite it\n                getCms().lockResource(getParamResource());\n                getCms().replaceResource(getParamResource(), resTypeId, content, null);\n            }\n            // copy xslt stylesheet-property to the new resource\n            if (!styleProp.isNullProperty()) { \n                getCms().writePropertyObject(getParamResource(), styleProp);\n            }\n        } catch (Exception e) {\n            // error uploading file, show error dialog\n            setAction(ACTION_SHOWERROR);\n            getJsp().getRequest().setAttribute(C_SESSION_WORKPLACE_CLASS, this);\n            setParamErrorstack(CmsException.getStackTraceAsString(e));\n            setParamMessage(key(\"error.message.upload\"));\n            setParamReasonSuggestion(key(\"error.reason.upload\" + errorMsgSuffix)\n                + \"<br>\\n\"\n                + key(\"error.suggestion.upload\" + errorMsgSuffix)\n                + \"\\n\");\n            getJsp().include(C_FILE_DIALOG_SCREEN_ERROR);\n            if (OpenCms.getLog(this).isErrorEnabled()) {\n                OpenCms.getLog(this).error(e);\n            }\n        }\n    }","commit_id":"743e1150d12f0609c2219d08cb5ae813d0dd5f81","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns a command for safely running as root, using {@code sudo}.\n     * <p/>\n     * Ensuring non-blocking if password not set by using {@code -S} which reads\n     * from stdin routed to {@code /dev/null} and {@code -E} passes the parent\n     * environment in. If already root, simply runs the command, wrapped in brackets in case it is backgrounded.\n     * <p/>\n     * The command is not quoted or escaped in any ways. \n     * If you are doing privileged redirect you may need to pass e.g. \"bash -c 'echo hi > file'\".\n     * <p/>\n     * If null is supplied, it is returned (sometimes used to indicate no command desired).\n     */\n    public static String sudo(String command) {\n        if (command==null) return null;\n        return format(\"(test $UID -eq 0 && ( %s ) || sudo -E -n -s -- %s )\", command, command);\n    }","id":75667,"modified_method":"/**\n     * Returns a command for safely running as root, using {@code sudo}.\n     * <p/>\n     * Ensuring non-blocking if password not set by using {@code -S} which reads\n     * from stdin routed to {@code /dev/null} and {@code -E} passes the parent\n     * environment in. If already root, simply runs the command, wrapped in brackets in case it is backgrounded.\n     * <p/>\n     * The command is not quoted or escaped in any ways. \n     * If you are doing privileged redirect you may need to pass e.g. \"bash -c 'echo hi > file'\".\n     * <p/>\n     * If null is supplied, it is returned (sometimes used to indicate no command desired).\n     */\n    public static String sudo(String command) {\n        if (command==null) return null;\n        return format(\"( if test \\\"$UID\\\" -eq 0; then ( %s ); else sudo -E -n -s -- %s; fi )\", command, command);\n    }","commit_id":"174a9d01c265c9b92fe44a4c3609199a033507cf","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/**\n     * Returns a command for installing the given package.\n     * <p/>\n     * Flags can contain common overrides for deb, apt, yum, rpm and port\n     * as the package names can be different for each of those:\n     * <pre>\n     * installPackage(\"libssl-devel\", yum:\"openssl-devel\", apt:\"openssl libssl-dev zlib1g-dev\")\n     * <\/pre>\n     */\n    public static String installPackage(Map flags, String packageDefaultName) {\n        List<String> commands = new LinkedList<String>();\n        commands.add(exists(\"apt-get\",\n                \"echo apt-get exists, doing update\",\n                \"export DEBIAN_FRONTEND=noninteractive\",\n                sudo(\"apt-get update\"),\n                sudo(formatIfNotNull(\"apt-get install -y --allow-unauthenticated %s\", getFlag(flags, \"apt\", packageDefaultName)))));\n        commands.add(exists(\"yum\", sudo(formatIfNotNull(\"yum -y --nogpgcheck install %s\", getFlag(flags, \"yum\", packageDefaultName)))));\n        commands.add(exists(\"brew\", formatIfNotNull(\"brew install %s\", getFlag(flags, \"brew\", packageDefaultName))));\n        commands.add(exists(\"port\", sudo(formatIfNotNull(\"port install %s\", getFlag(flags, \"port\", packageDefaultName)))));\n        String failure = format(\"(echo \\\"WARNING: no known/successful package manager to install %s, may fail subsequently\\\")\",\n                packageDefaultName!=null ? packageDefaultName : flags.toString());\n        return alternatives(commands, failure);\n    }","id":75668,"modified_method":"/**\n     * Returns a command for installing the given package.\n     * <p/>\n     * Flags can contain common overrides for deb, apt, yum, rpm and port\n     * as the package names can be different for each of those:\n     * <pre>\n     * installPackage(\"libssl-devel\", yum:\"openssl-devel\", apt:\"openssl libssl-dev zlib1g-dev\")\n     * <\/pre>\n     */\n    public static String installPackage(Map flags, String packageDefaultName) {\n        String ifmissing = (String) flags.get(\"onlyifmissing\");\n        \n        String aptInstall = formatIfNotNull(\"apt-get install -y --allow-unauthenticated %s\", getFlag(flags, \"apt\", packageDefaultName));\n        String yumInstall = formatIfNotNull(\"yum -y --nogpgcheck install %s\", getFlag(flags, \"yum\", packageDefaultName));\n        String brewInstall = formatIfNotNull(\"brew install %s\", getFlag(flags, \"brew\", packageDefaultName));\n        String portInstall = formatIfNotNull(\"port install %s\", getFlag(flags, \"port\", packageDefaultName));\n        \n        List<String> commands = new LinkedList<String>();\n        if (ifmissing != null) commands.add(format(\"which %s\", ifmissing));\n        commands.add(exists(\"apt-get\",\n                \"echo apt-get exists, doing update\",\n                \"export DEBIAN_FRONTEND=noninteractive\",\n                sudo(\"apt-get update\"), \n                sudo(aptInstall)));\n        commands.add(exists(\"yum\", sudo(yumInstall)));\n        commands.add(exists(\"brew\", brewInstall));\n        commands.add(exists(\"port\", sudo(portInstall)));\n        \n        String failure = format(\"(echo \\\"WARNING: no known/successful package manager to install %s, may fail subsequently\\\")\",\n                packageDefaultName!=null ? packageDefaultName : flags.toString());\n        return alternatives(commands, failure);\n    }","commit_id":"174a9d01c265c9b92fe44a4c3609199a033507cf","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void install() {\n        newScript(\"disable requiretty\").\n            setFlag(\"allocatePTY\", true).\n            body.append(CommonCommands.dontRequireTtyForSudo()).\n            execute();\n        \n        String nginxUrl = format(\"http://nginx.org/download/nginx-%s.tar.gz\", getVersion());\n        String nginxSaveAs = format(\"nginx-%s.tar.gz\", getVersion());\n        String stickyVersion = entity.getConfig(NginxController.STICKY_VERSION);\n        String stickyModuleUrl = format(\"http://nginx-sticky-module.googlecode.com/files/nginx-sticky-module-%s.tar.gz\", stickyVersion);\n        String stickyModuleSaveAs = format(\"nginx-sticky-module-%s.tar.gz\", stickyVersion);\n        boolean sticky = ((NginxController) entity).isSticky();\n        boolean isMac = getMachine().getOsDetails().isMac();\n        ScriptHelper script = newScript(INSTALLING);\n        script.body.append(CommonCommands.INSTALL_TAR);\n        MutableMap<String, String> installPackageFlags = MutableMap.of(\n                \"yum\", \"gcc make openssl-devel pcre-devel\", \n                \"apt\", \"gcc make libssl-dev zlib1g-dev libpcre3-dev\",\n                \"port\", null);\n        script.body.append(CommonCommands.installPackage(installPackageFlags, \"nginx-prerequisites\"));\n        script.body.append(CommonCommands.downloadUrlAs(nginxUrl, getEntityVersionLabel(\"/\"), nginxSaveAs));\n        if (isMac) {\n            String pcreVersion = entity.getConfig(NginxController.PCRE_VERSION);\n            String pcreUrl = format(\"ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-%s.tar.gz\", pcreVersion);\n            String pcreSaveAs = format(\"pcre-%s.tar.gz\", pcreVersion);\n            script.body.append(CommonCommands.downloadUrlAs(pcreUrl, getEntityVersionLabel(\"/\"), pcreSaveAs));\n            // Install PCRE\n            script.body.append(format(\"mkdir -p %s/pcre-dist\", getInstallDir()));\n            script.body.append(format(\"tar xvzf pcre-%s.tar.gz\", pcreVersion));\n            script.body.append(format(\"cd pcre-%s\", pcreVersion));\n            script.body.append(format(\"./configure --prefix=%s/pcre-dist\", getInstallDir()));\n            script.body.append(\"make\");\n            script.body.append(\"make install\");\n            script.body.append(\"cd ..\");\n        }\n        \n        script.body.append(format(\"tar xvzf %s\", nginxSaveAs));\n        script.body.append(format(\"cd %s/nginx-%s\", getInstallDir(), getVersion()));\n\n        if (sticky) {\n            script.body.append(\"cd src\");\n            script.body.append(CommonCommands.downloadUrlAs(stickyModuleUrl, getEntityVersionLabel(\"/\"), stickyModuleSaveAs));\n            script.body.append(format(\"tar xvzf %s\", stickyModuleSaveAs));\n            script.body.append(\"cd ..\");\n        }\n\n        script.body.append(\n                \"mkdir -p dist\",\n                \"./configure\"+\n                    format(\" --prefix=%s/nginx-%s/dist\", getInstallDir(), getVersion()) +\n                    \" --with-http_ssl_module\" +\n                    (sticky ? format(\" --add-module=%s/nginx-%s/src/nginx-sticky-module-%s \", getInstallDir(), getVersion(), stickyVersion) : \"\") +\n                    (isMac ? format(\" --with-ld-opt=\\\"-L %s/pcre-dist/lib\\\"\", getInstallDir()) : \"\") ,\n                \"make install\");\n\n        script.header.prepend(\"set -x\");\n        script.gatherOutput();\n        script.failOnNonZeroResultCode(false);\n        int result = script.execute();\n        \n        if (result != 0) {\n            String notes = \"likely an error building nginx. consult the brooklyn log ssh output for further details.\\n\"+\n                    \"note that this Brooklyn nginx driver compiles nginx from source. \" +\n                    \"it attempts to install common prerequisites but this does not always succeed.\\n\";\n            OsDetails os = getMachine().getOsDetails();\n            if (os.isMac()) {\n                notes += \"deploying to Mac OS X, you will require Xcode and Xcode command-line tools, and on \" +\n                \t\t\"some versions the pcre library (e.g. using macports, sudo port install pcre).\\n\";\n            }\n            if (os.isWindows()) {\n                notes += \"this nginx driver is not designed for windows, unless cygwin is installed, and you are patient.\\n\";\n            }\n            if (getEntity().getApplication().getClass().getCanonicalName().startsWith(\"brooklyn.demo.\")) {\n                // this is maybe naughty ... but since we use nginx in the first demo example,\n                // and since it's actually pretty complicated, let's give a little extra hand-holding\n                notes +=\n                \t\t\"if debugging this is all a bit much and you just want to run a demo, \" +\n                \t\t\"you have two fairly friendly options.\\n\" +\n                \t\t\"1. you can use a well known cloud, like AWS or Rackspace, where this should run \" +\n                \t\t\"in a tried-and-tested Ubuntu or CentOS environment, without any problems \" +\n                \t\t\"(and if it does let us know and we'll fix it!).\\n\"+\n                \t\t\"2. or you can just use the demo without nginx, instead access the appserver instances directly.\\n\";\n            }\n\n            if (!script.getResultStderr().isEmpty())\n                notes += \"\\n\" + \"STDERR\\n\" + script.getResultStderr()+\"\\n\";\n            if (!script.getResultStdout().isEmpty())\n                notes += \"\\n\" + \"STDOUT\\n\" + script.getResultStdout()+\"\\n\";\n            \n            Tasks.setExtraStatusDetails(notes.trim());\n            \n            throw new IllegalStateException(\"Installation of nginx failed (shell returned non-zero result \"+result+\")\");\n        }\n    }","id":75669,"modified_method":"@Override\n    public void install() {\n        newScript(\"disable requiretty\").\n            setFlag(\"allocatePTY\", true).\n            body.append(CommonCommands.dontRequireTtyForSudo()).\n            execute();\n        \n        String nginxUrl = format(\"http://nginx.org/download/nginx-%s.tar.gz\", getVersion());\n        String nginxSaveAs = format(\"nginx-%s.tar.gz\", getVersion());\n        String stickyVersion = entity.getConfig(NginxController.STICKY_VERSION);\n        String stickyModuleUrl = format(\"http://nginx-sticky-module.googlecode.com/files/nginx-sticky-module-%s.tar.gz\", stickyVersion);\n        String stickyModuleSaveAs = format(\"nginx-sticky-module-%s.tar.gz\", stickyVersion);\n        boolean sticky = ((NginxController) entity).isSticky();\n        boolean isMac = getMachine().getOsDetails().isMac();\n        \n        ScriptHelper script = newScript(INSTALLING);\n        script.body.append(CommonCommands.INSTALL_TAR);\n        MutableMap<String, String> installGccPackageFlags = MutableMap.of(\n                \"onlyifmissing\", \"gcc\",\n                \"yum\", \"gcc\", \n                \"apt\", \"gcc\",\n                \"port\", null);\n        MutableMap<String, String> installMakePackageFlags = MutableMap.of(\n                \"onlyifmissing\", \"make\",\n                \"yum\", \"make\", \n                \"apt\", \"make\",\n                \"port\", null);\n        MutableMap<String, String> installPackageFlags = MutableMap.of(\n                \"yum\", \"openssl-devel pcre-devel\", \n                \"apt\", \"libssl-dev zlib1g-dev libpcre3-dev\",\n                \"port\", null);\n        script.body.append(CommonCommands.installPackage(installGccPackageFlags, \"nginx-prerequisites-gcc\"));\n        script.body.append(CommonCommands.installPackage(installMakePackageFlags, \"nginx-prerequisites-make\"));\n        script.body.append(CommonCommands.installPackage(installPackageFlags, \"nginx-prerequisites\"));\n        script.body.append(CommonCommands.downloadUrlAs(nginxUrl, getEntityVersionLabel(\"/\"), nginxSaveAs));\n        if (isMac) {\n            String pcreVersion = entity.getConfig(NginxController.PCRE_VERSION);\n            String pcreUrl = format(\"ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-%s.tar.gz\", pcreVersion);\n            String pcreSaveAs = format(\"pcre-%s.tar.gz\", pcreVersion);\n            script.body.append(CommonCommands.downloadUrlAs(pcreUrl, getEntityVersionLabel(\"/\"), pcreSaveAs));\n            // Install PCRE\n            script.body.append(format(\"mkdir -p %s/pcre-dist\", getInstallDir()));\n            script.body.append(format(\"tar xvzf pcre-%s.tar.gz\", pcreVersion));\n            script.body.append(format(\"cd pcre-%s\", pcreVersion));\n            script.body.append(format(\"./configure --prefix=%s/pcre-dist\", getInstallDir()));\n            script.body.append(\"make\");\n            script.body.append(\"make install\");\n            script.body.append(\"cd ..\");\n        }\n        \n        script.body.append(format(\"tar xvzf %s\", nginxSaveAs));\n        script.body.append(format(\"cd %s/nginx-%s\", getInstallDir(), getVersion()));\n\n        if (sticky) {\n            script.body.append(\"cd src\");\n            script.body.append(CommonCommands.downloadUrlAs(stickyModuleUrl, getEntityVersionLabel(\"/\"), stickyModuleSaveAs));\n            script.body.append(format(\"tar xvzf %s\", stickyModuleSaveAs));\n            script.body.append(\"cd ..\");\n        }\n\n        script.body.append(\n                \"mkdir -p dist\",\n                \"./configure\"+\n                    format(\" --prefix=%s/nginx-%s/dist\", getInstallDir(), getVersion()) +\n                    \" --with-http_ssl_module\" +\n                    (sticky ? format(\" --add-module=%s/nginx-%s/src/nginx-sticky-module-%s \", getInstallDir(), getVersion(), stickyVersion) : \"\") +\n                    (isMac ? format(\" --with-ld-opt=\\\"-L %s/pcre-dist/lib\\\"\", getInstallDir()) : \"\") ,\n                \"make install\");\n\n        script.header.prepend(\"set -x\");\n        script.gatherOutput();\n        script.failOnNonZeroResultCode(false);\n        int result = script.execute();\n        \n        if (result != 0) {\n            String notes = \"likely an error building nginx. consult the brooklyn log ssh output for further details.\\n\"+\n                    \"note that this Brooklyn nginx driver compiles nginx from source. \" +\n                    \"it attempts to install common prerequisites but this does not always succeed.\\n\";\n            OsDetails os = getMachine().getOsDetails();\n            if (os.isMac()) {\n                notes += \"deploying to Mac OS X, you will require Xcode and Xcode command-line tools, and on \" +\n                \t\t\"some versions the pcre library (e.g. using macports, sudo port install pcre).\\n\";\n            }\n            if (os.isWindows()) {\n                notes += \"this nginx driver is not designed for windows, unless cygwin is installed, and you are patient.\\n\";\n            }\n            if (getEntity().getApplication().getClass().getCanonicalName().startsWith(\"brooklyn.demo.\")) {\n                // this is maybe naughty ... but since we use nginx in the first demo example,\n                // and since it's actually pretty complicated, let's give a little extra hand-holding\n                notes +=\n                \t\t\"if debugging this is all a bit much and you just want to run a demo, \" +\n                \t\t\"you have two fairly friendly options.\\n\" +\n                \t\t\"1. you can use a well known cloud, like AWS or Rackspace, where this should run \" +\n                \t\t\"in a tried-and-tested Ubuntu or CentOS environment, without any problems \" +\n                \t\t\"(and if it does let us know and we'll fix it!).\\n\"+\n                \t\t\"2. or you can just use the demo without nginx, instead access the appserver instances directly.\\n\";\n            }\n\n            if (!script.getResultStderr().isEmpty())\n                notes += \"\\n\" + \"STDERR\\n\" + script.getResultStderr()+\"\\n\";\n            if (!script.getResultStdout().isEmpty())\n                notes += \"\\n\" + \"STDOUT\\n\" + script.getResultStdout()+\"\\n\";\n            \n            Tasks.setExtraStatusDetails(notes.trim());\n            \n            throw new IllegalStateException(\"Installation of nginx failed (shell returned non-zero result \"+result+\")\");\n        }\n    }","commit_id":"174a9d01c265c9b92fe44a4c3609199a033507cf","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\r\n\t{\r\n\t\tmeta=(RegexEvalMeta)smi;\r\n\t\tdata=(RegexEvalData)sdi;\r\n\t\t\r\n\t\tObject[] row = getRow();\r\n\t\t\r\n\t\tif (row==null)  // no more input to be expected...\r\n\t\t{\r\n\t\t\tsetOutputDone();\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\tif (first) // we just got started\r\n\t\t{\r\n\t\t\tfirst=false;\r\n\t\t\t// get the RowMeta\r\n\t\t\tdata.nrIncomingFields=getInputRowMeta().size();\r\n\t\t\tdata.outputRowMeta = getInputRowMeta().clone();\r\n\t\t\tmeta.getFields(data.outputRowMeta, getStepname(), null, null, this);\r\n\t\t\t\r\n\t\t\tdata.nrExtraFields = meta.isAllowCaptureGroupsFlagSet() ? meta.getFieldName().length : 0;\r\n\t\t\r\n\t\t\t// Check if a Field (matcher) is given\r\n\t\t\tif (meta.getMatcher()!=null)\r\n\t\t\t{\r\n\t\t\t\t // Cache the position of the Field\r\n\t\t\t\tif (data.indexOfFieldToEvaluate<0)\r\n\t\t\t\t{\r\n\t\t\t\t\tdata.indexOfFieldToEvaluate = getInputRowMeta().indexOfValue(meta.getMatcher());\r\n\t\r\n\t\t\t\t\tif (data.indexOfFieldToEvaluate<0)\r\n\t\t            {                    \r\n\t\t                // The field is unreachable !\r\n\t\t\t\t\t\tlogError(BaseMessages.getString(PKG, \"RegexEval.Log.ErrorFindingField\")+ \"[\" + meta.getMatcher()+\"]\"); \r\n\t\t\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"RegexEval.Exception.CouldnotFindField\",meta.getMatcher())); \r\n\t\t\t\t\t}\t\t                \r\n\t\t                \r\n\t\t\t\t\t// Let's check that Result Field is given\r\n\t\t\t\t\tif (Const.isEmpty(environmentSubstitute(meta.getResultFieldName()))) {\r\n\t\t\t\t\t\tif(!meta.isAllowCaptureGroupsFlagSet()) {\r\n\t\t\t\t\t\t//\tResult field is missing !\r\n\t\t\t\t\t\t\tlogError(BaseMessages.getString(PKG, \"RegexEval.Log.ErrorResultFieldMissing\")); \r\n\t\t\t\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"RegexEval.Exception.ErrorResultFieldMissing\"));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tdata.addResultField=false;\r\n\t\t\t\t\t}\r\n\t\t                \r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// Matcher is missing !\r\n\t\t\t\tlogError(BaseMessages.getString(PKG, \"RegexEval.Log.ErrorMatcherMissing\"));\r\n\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"RegexEval.Exception.ErrorMatcherMissing\")); \r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Now create objects to do string to data type conversion...\r\n\t\t\tdata.conversionRowMeta = data.outputRowMeta.clone();\r\n\t\t\tfor (ValueMetaInterface valueMeta : data.conversionRowMeta.getValueMetaList()) {\r\n\t\t\t\tvalueMeta.setType(ValueMetaInterface.TYPE_STRING);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\t\r\n\t\t// reserve room\r\n\t\tObject[] outputRow = RowDataUtil.allocateRowData(data.outputRowMeta.size());\r\n\t\t\t\t\r\n\t\tfor (int i = 0; i < data.nrIncomingFields; i++) {\r\n\t\t\toutputRow[i] = row[i];\r\n\t\t}\r\n\r\n\t\ttry{\r\n\t\t\t// Get the Field value\r\n\t\t\tString fieldValue= getInputRowMeta().getString(row,data.indexOfFieldToEvaluate);\r\n\t\t\t\r\n\t\t\tint index=data.nrIncomingFields;\r\n\t\t\tif (fieldValue == null) {\r\n\t\t\t\tif(data.addResultField) {\r\n\t\t\t\t\toutputRow[index] = false;\r\n\t\t\t\t\tindex++;\r\n\t\t\t\t}\r\n                for (int i = 0; i < data.nrExtraFields; i++) {\r\n                    ValueMetaInterface valueMeta = data.outputRowMeta.getValueMeta(index); \r\n                    ValueMetaInterface conversionValueMeta = data.conversionRowMeta.getValueMeta(index);\r\n                    Object convertedValue = valueMeta.convertDataFromString (\r\n                            null,\r\n                            conversionValueMeta,\r\n                            meta.getFieldNullIf()[i],\r\n                            meta.getFieldIfNull()[i],\r\n                            meta.getFieldTrimType()[i]\r\n                    );\r\n    \r\n                    outputRow[index] = convertedValue;\r\n                \tindex++;\r\n                }\r\n\t\t\t} else {\r\n\t\t\t\t// Search engine\r\n\t\t\t\tMatcher m = data.pattern.matcher(fieldValue);\r\n\t\t\t\tboolean firstCheck=false;\r\n\t\t\t\t// Start search\r\n\t\t\t\tboolean isMatch = m.matches();\r\n\r\n\t\t\t\tif(data.addResultField) {\r\n\t\t\t\t\toutputRow[index] = isMatch;\r\n\t\t\t\t\tindex++;\r\n\t\t\t\t}\r\n\t\t\t\tString[] values = new String[data.nrExtraFields];\r\n\r\n\t\t\t\tfor (int i = 0; i < data.nrExtraFields; i++) {\r\n\t\t\t\t\tif (isMatch) {\r\n\t\t\t\t\t\tif(!firstCheck) {\r\n\t\t\t\t\t\t\tfirstCheck=true;\r\n\t\t\t\t\t\t\tif (data.nrExtraFields != m.groupCount()) {\r\n\t\t\t\t\t\t\t\t// Runtime exception case. The number of capture groups in the regex doesn't match the number of fields.\r\n\t\t\t\t\t\t\t\tlogError(BaseMessages.getString(PKG, \"RegexEval.Log.ErrorCaptureGroupFieldsMismatch\", String.valueOf(m.groupCount()), String.valueOf(data.nrExtraFields)));\r\n\t\t\t\t\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"RegexEval.Exception.ErrorCaptureGroupFieldsMismatch\", String.valueOf(m.groupCount()), String.valueOf(data.nrExtraFields))); \r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvalues[i] = m.group(i+1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tValueMetaInterface valueMeta = data.outputRowMeta.getValueMeta(index); \r\n\t\t\t\t\tValueMetaInterface conversionValueMeta = data.conversionRowMeta.getValueMeta(index);\r\n\t\t\t\t\tObject convertedValue = valueMeta.convertDataFromString (\r\n\t\t\t\t\t\t\tvalues[i],\r\n\t\t\t\t\t\t\tconversionValueMeta,\r\n\t\t\t\t\t\t\tmeta.getFieldNullIf()[i],\r\n\t\t\t\t\t\t\tmeta.getFieldIfNull()[i],\r\n\t\t\t\t\t\t\tmeta.getFieldTrimType()[i]\r\n\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\toutputRow[index] = convertedValue;\r\n\t\t\t\t\tindex++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (log.isRowLevel()) logRowlevel(BaseMessages.getString(PKG, \"RegexEval.Log.ReadRow\") + \" \" +  getInputRowMeta().getString(row)); \r\n\t\t\t\r\n\t\t\tputRow(data.outputRowMeta, outputRow);  // copy row to output rowset(s);\r\n\t\t} catch (KettleException e) {\r\n\t\t\tboolean sendToErrorRow=false;\r\n\t\t\tString errorMessage = null;\r\n\t\t\t\r\n\t\t\tif (getStepMeta().isDoingErrorHandling()) {\r\n                sendToErrorRow = true;\r\n                errorMessage = e.toString();\r\n\t        }else  {\r\n\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"RegexEval.Log.ErrorInStep\"), e); //$NON-NLS-1$\r\n\t        }\r\n\t\t\t \r\n\t\t\t if (sendToErrorRow) {\r\n\t\t\t\t // Simply add this row to the error row\r\n\t             putError(getInputRowMeta(), outputRow, 1, errorMessage, null, \"REGEX001\");\r\n\t         }\r\n\t\t}\r\n\t\treturn true;\r\n\t}","id":75670,"modified_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\r\n\t{\r\n\t\tmeta=(RegexEvalMeta)smi;\r\n\t\tdata=(RegexEvalData)sdi;\r\n\t\t\r\n\t\tObject[] row = getRow();\r\n\t\t\r\n\t\tif (row==null)  // no more input to be expected...\r\n\t\t{\r\n\t\t\tsetOutputDone();\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\tif (first) // we just got started\r\n\t\t{\r\n\t\t\tfirst=false;\r\n\r\n\t\t\t// get the RowMeta\r\n\t\t\tdata.outputRowMeta = getInputRowMeta().clone();\r\n\t\t\tint captureIndex = getInputRowMeta().size();\r\n\t\t\tmeta.getFields(data.outputRowMeta, getStepname(), null, null, this);\r\n\t\t\t\r\n\t\t\t// Let's check that Result Field is given\r\n\t\t\tif (Const.isEmpty(environmentSubstitute(meta.getResultFieldName()))) {\r\n\t\t\t\tif(!meta.isAllowCaptureGroupsFlagSet()) {\r\n\t\t\t\t//\tResult field is missing !\r\n\t\t\t\t\tlogError(BaseMessages.getString(PKG, \"RegexEval.Log.ErrorResultFieldMissing\")); \r\n\t\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"RegexEval.Exception.ErrorResultFieldMissing\"));\r\n\t\t\t\t}\r\n\t\t\t\tdata.indexOfResultField = -1;\r\n\t\t\t} else {\r\n\t\t\t\tif ( meta.isReplacefields() ) {\r\n\t\t\t\t\tdata.indexOfResultField = getInputRowMeta().indexOfValue(meta.getResultFieldName());\r\n\t\t\t\t}\r\n\t\t\t\tif ( data.indexOfResultField < 0 ) {\r\n\t\t\t\t\tdata.indexOfResultField = getInputRowMeta().size();\r\n\t\t\t\t\tcaptureIndex++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\r\n\t\t\t// Check if a Field (matcher) is given\r\n\t\t\tif (meta.getMatcher()==null)\r\n\t\t\t{\r\n\t\t\t\t// Matcher is missing !\r\n\t\t\t\tlogError(BaseMessages.getString(PKG, \"RegexEval.Log.ErrorMatcherMissing\"));\r\n\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"RegexEval.Exception.ErrorMatcherMissing\")); \r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n      // Cache the position of the Field\r\n      data.indexOfFieldToEvaluate = getInputRowMeta().indexOfValue(meta.getMatcher());\r\n      if (data.indexOfFieldToEvaluate<0)\r\n            {\r\n                // The field is unreachable !\r\n        logError(BaseMessages.getString(PKG, \"RegexEval.Log.ErrorFindingField\")+ \"[\" + meta.getMatcher()+\"]\");\r\n        throw new KettleStepException(BaseMessages.getString(PKG, \"RegexEval.Exception.CouldnotFindField\",meta.getMatcher()));\r\n      }\r\n\t\t                \r\n\t\t                \r\n\t\t\t// Cache the position of the CaptureGroups\r\n\t\t\tif (meta.isAllowCaptureGroupsFlagSet()) {\r\n\t\t\t\tdata.positions = new int[meta.getFieldName().length];\r\n\t\t\t\tString fieldName[] = meta.getFieldName();\r\n\t\t\t\tfor (int i = 0; i < fieldName.length; i++ ) {\r\n\t            \tif ( fieldName[i] == null || fieldName[i].length() == 0)\r\n\t            \t\tcontinue;\r\n\t\t\t\t\tif (meta.isReplacefields()) {\r\n\t\t\t\t\t\tdata.positions[i] =  data.outputRowMeta.indexOfValue(fieldName[i]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tdata.positions[i] =  captureIndex;\r\n\t\t\t\t\t\tcaptureIndex++;\r\n\t\t\t\t  }\r\n\t\t\t  }\r\n\t\t\t} else {\r\n        data.positions = new int[0];\r\n      }\r\n\t\t\t\r\n\t\t\t// Now create objects to do string to data type conversion...\r\n\t\t\tdata.conversionRowMeta = data.outputRowMeta.clone();\r\n\t\t\tfor (ValueMetaInterface valueMeta : data.conversionRowMeta.getValueMetaList()) {\r\n\t\t\t\tvalueMeta.setType(ValueMetaInterface.TYPE_STRING);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\t\r\n\t\t// reserve room\r\n\t\tObject[] outputRow = RowDataUtil.allocateRowData(data.outputRowMeta.size());\r\n\t\t\t\t\r\n\t\tfor (int i = 0; i < row.length; i++) {\r\n\t\t\toutputRow[i] = row[i];\r\n\t\t}\r\n\r\n\t\ttry{\r\n\t\t\t// Get the Field value\r\n\t\t\tString fieldValue= getInputRowMeta().getString(row,data.indexOfFieldToEvaluate);\r\n\t\t\tif (fieldValue == null) {\r\n\t\t\t\tfieldValue = \"\";\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\t// Start search engine\r\n\t\t\t\tMatcher m = data.pattern.matcher(fieldValue);\r\n\t\t\t\tboolean isMatch = m.matches();\r\n\t\t\t\t\r\n\t\t\t\tif (data.positions.length != m.groupCount()) {\r\n\t\t\t\t\t// Runtime exception case. The number of capture groups in the regex doesn't match the number of fields.\r\n\t\t\t\t\tlogError(BaseMessages.getString(PKG, \"RegexEval.Log.ErrorCaptureGroupFieldsMismatch\", String.valueOf(m.groupCount()), String.valueOf(data.positions.length)));\r\n\t\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"RegexEval.Exception.ErrorCaptureGroupFieldsMismatch\", String.valueOf(m.groupCount()), String.valueOf(data.positions.length))); \r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(data.indexOfResultField >= 0) {\r\n\t\t\t\t\toutputRow[data.indexOfResultField] = isMatch;\r\n\t\t\t\t}\r\n\t\t\t\t\t\r\n        for (int i = 0; i < data.positions.length; i++) {\r\n          int index = data.positions[i];\r\n          String value;\r\n\t\t\t\t\tif (isMatch) {\r\n            value = m.group(i+1);\r\n          } else {\r\n            value = null;\r\n          }\r\n\r\n          // this part (or possibly the whole) of the regex didn't match\r\n          // preserve the incoming data, but allow for \"trim type\", etc.\r\n          if ( value == null ) {\r\n            try {\r\n              value = data.outputRowMeta.getString(outputRow,index);\r\n            } catch (ArrayIndexOutOfBoundsException err) {}\r\n          }\r\n\t\t\t\t\t\r\n\t\t\t\t\tValueMetaInterface valueMeta = data.outputRowMeta.getValueMeta(index); \r\n\t\t\t\t\tValueMetaInterface conversionValueMeta = data.conversionRowMeta.getValueMeta(index);\r\n\t\t\t\t\tObject convertedValue = valueMeta.convertDataFromString (\r\n\t\t\t\t\t\t\tvalue,\r\n\t\t\t\t\t\t\tconversionValueMeta,\r\n\t\t\t\t\t\t\tmeta.getFieldNullIf()[i],\r\n\t\t\t\t\t\t\tmeta.getFieldIfNull()[i],\r\n\t\t\t\t\t\t\tmeta.getFieldTrimType()[i]\r\n\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\toutputRow[index] = convertedValue;\r\n\t\t\t\t}\r\n\t\t\tif (log.isRowLevel()) logRowlevel(BaseMessages.getString(PKG, \"RegexEval.Log.ReadRow\") + \" \" +  getInputRowMeta().getString(row)); \r\n\t\t\t\r\n\t\t\tputRow(data.outputRowMeta, outputRow);  // copy row to output rowset(s);\r\n\t\t} catch (KettleException e) {\r\n\t\t\tboolean sendToErrorRow=false;\r\n\t\t\tString errorMessage = null;\r\n\t\t\t\r\n\t\t\tif (getStepMeta().isDoingErrorHandling()) {\r\n                sendToErrorRow = true;\r\n                errorMessage = e.toString();\r\n\t        }else  {\r\n\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"RegexEval.Log.ErrorInStep\"), e); //$NON-NLS-1$\r\n\t        }\r\n\t\t\t \r\n\t\t\t if (sendToErrorRow) {\r\n\t\t\t\t // Simply add this row to the error row\r\n\t             putError(getInputRowMeta(), outputRow, 1, errorMessage, null, \"REGEX001\");\r\n\t         }\r\n\t\t}\r\n\t\treturn true;\r\n\t}","commit_id":"03b2363e3e64157aa59cd3f782aad57e5cce8dc9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public RegexEvalData()\r\n\t{\r\n\t\tsuper();\r\n\r\n\t\tindexOfFieldToEvaluate = -1;\r\n\t\taddResultField=true;\r\n\t}","id":75671,"modified_method":"public RegexEvalData()\r\n\t{\r\n\t\tsuper();\r\n\r\n\t\tindexOfFieldToEvaluate = -1;\r\n\t\tindexOfResultField = -1;\r\n\t}","commit_id":"03b2363e3e64157aa59cd3f782aad57e5cce8dc9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void setFieldsEnabledStatus()\r\n    {\r\n        wlFields.setEnabled(wAllowCaptureGroups.getSelection());\r\n        wFields.setEnabled(wAllowCaptureGroups.getSelection());\r\n    }","id":75672,"modified_method":"private void setFieldsEnabledStatus()\r\n    {\r\n        wlFields.setEnabled(wAllowCaptureGroups.getSelection());\r\n        wFields.setEnabled(wAllowCaptureGroups.getSelection());\r\n        wlReplaceFields.setEnabled(wAllowCaptureGroups.getSelection());\r\n        wReplaceFields.setEnabled(wAllowCaptureGroups.getSelection());\r\n    }","commit_id":"03b2363e3e64157aa59cd3f782aad57e5cce8dc9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void setRegexOptions(RegexEvalMeta input)\r\n    {\r\n    \tinput.setScript( wScript.getText() );\r\n    \tinput.setResultFieldName(wResultField.getText() );\r\n    \tinput.setMatcher(wfieldevaluate.getText() );\r\n    \tinput.setUseVariableInterpolationFlag(wUseVar.getSelection());\r\n    \tinput.setAllowCaptureGroupsFlag(wAllowCaptureGroups.getSelection());\r\n    \tinput.setCanonicalEqualityFlag(wCanonEq.getSelection());\r\n    \tinput.setCaseInsensitiveFlag(wCaseInsensitive.getSelection());\r\n    \tinput.setCommentFlag(wComment.getSelection());\r\n    \tinput.setDotAllFlag(wDotAll.getSelection());\r\n    \tinput.setMultilineFlag(wMultiline.getSelection());\r\n    \tinput.setUnicodeFlag(wUnicode.getSelection());\r\n    \tinput.setUnixLineEndingsFlag(wUnix.getSelection());\r\n    }","id":75673,"modified_method":"private void setRegexOptions(RegexEvalMeta input)\r\n    {\r\n    \tinput.setScript( wScript.getText() );\r\n    \tinput.setResultFieldName(wResultField.getText() );\r\n    \tinput.setMatcher(wfieldevaluate.getText() );\r\n    \tinput.setUseVariableInterpolationFlag(wUseVar.getSelection());\r\n    \tinput.setAllowCaptureGroupsFlag(wAllowCaptureGroups.getSelection());\r\n    \tinput.setReplacefields(wReplaceFields.getSelection());\r\n    \tinput.setCanonicalEqualityFlag(wCanonEq.getSelection());\r\n    \tinput.setCaseInsensitiveFlag(wCaseInsensitive.getSelection());\r\n    \tinput.setCommentFlag(wComment.getSelection());\r\n    \tinput.setDotAllFlag(wDotAll.getSelection());\r\n    \tinput.setMultilineFlag(wMultiline.getSelection());\r\n    \tinput.setUnicodeFlag(wUnicode.getSelection());\r\n    \tinput.setUnixLineEndingsFlag(wUnix.getSelection());\r\n    }","commit_id":"03b2363e3e64157aa59cd3f782aad57e5cce8dc9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\r\n\t * Copy information from the meta-data input to the dialog fields.\r\n\t */ \r\n\tpublic void getData()\r\n\t{\r\n\t\r\n\t\tif (input.getScript() != null) wScript.setText( input.getScript() );\r\n\t\tif (input.getResultFieldName() != null) wResultField.setText( input.getResultFieldName() );\r\n\t\tif (input.getMatcher() != null) wfieldevaluate.setText( input.getMatcher() );\r\n\r\n\t\twUseVar.setSelection(input.isUseVariableInterpolationFlagSet());\r\n\t\twAllowCaptureGroups.setSelection(input.isAllowCaptureGroupsFlagSet());\r\n\t\twCanonEq.setSelection(input.isCanonicalEqualityFlagSet());\r\n\t\twCaseInsensitive.setSelection(input.isCaseInsensitiveFlagSet());\r\n\t\twComment.setSelection(input.isCommentFlagSet());\r\n\t\twDotAll.setSelection(input.isDotAllFlagSet());\r\n\t\twMultiline.setSelection(input.isMultilineFlagSet());\r\n\t\twUnicode.setSelection(input.isUnicodeFlagSet());\r\n\t\twUnix.setSelection(input.isUnixLineEndingsFlagSet());\r\n\t\tfor (int i = 0; i < input.getFieldName().length; i++)\r\n\t\t{\r\n\t\t\tTableItem ti = wFields.table.getItem(i);\r\n\t\t\tif (input.getFieldName()[i]   != null) ti.setText( 1, input.getFieldName()[i]); \r\n\t              ti.setText(2, ValueMeta.getTypeDesc(input.getFieldType()[i]));\r\n\t              ti.setText(3, input.getFieldLength()[i]>=0 ? \"\"+input.getFieldLength()[i] : \"\");  //$NON-NLS-1$\r\n\t              ti.setText(4, input.getFieldPrecision()[i]>=0 ? (\"\"+input.getFieldPrecision()[i]) : \"\");  //$NON-NLS-1$\r\n\t\t\tif (input.getFieldFormat()[i]  != null) ti.setText(5, input.getFieldFormat()[i]); \r\n\t\t\tif (input.getFieldGroup()[i]   != null) ti.setText(6, input.getFieldGroup()[i]); \r\n\t\t\tif (input.getFieldDecimal()[i] != null) ti.setText(7, input.getFieldDecimal()[i]); \r\n\t\t\tif (input.getFieldCurrency()[i]!= null) ti.setText(8, input.getFieldCurrency()[i]); \r\n            if (input.getFieldNullIf()[i] != null) ti.setText(9, input.getFieldNullIf()[i]);\r\n            if (input.getFieldIfNull()[i] != null) ti.setText(10, input.getFieldIfNull()[i]);\r\n            ti.setText(11, ValueMeta.getTrimTypeDesc(input.getFieldTrimType()[i]));\r\n\t\t}\r\n\t\twFields.setRowNums();\r\n\t\twFields.optWidth(true);\r\n\r\n\t\twStepname.selectAll();\r\n\t}","id":75674,"modified_method":"/**\r\n\t * Copy information from the meta-data input to the dialog fields.\r\n\t */ \r\n\tpublic void getData()\r\n\t{\r\n\t\r\n\t\tif (input.getScript() != null) wScript.setText( input.getScript() );\r\n\t\tif (input.getResultFieldName() != null) wResultField.setText( input.getResultFieldName() );\r\n\t\tif (input.getMatcher() != null) wfieldevaluate.setText( input.getMatcher() );\r\n\r\n\t\twUseVar.setSelection(input.isUseVariableInterpolationFlagSet());\r\n\t\twReplaceFields.setSelection(input.isReplacefields());\r\n\t\twAllowCaptureGroups.setSelection(input.isAllowCaptureGroupsFlagSet());\r\n\t\twCanonEq.setSelection(input.isCanonicalEqualityFlagSet());\r\n\t\twCaseInsensitive.setSelection(input.isCaseInsensitiveFlagSet());\r\n\t\twComment.setSelection(input.isCommentFlagSet());\r\n\t\twDotAll.setSelection(input.isDotAllFlagSet());\r\n\t\twMultiline.setSelection(input.isMultilineFlagSet());\r\n\t\twUnicode.setSelection(input.isUnicodeFlagSet());\r\n\t\twUnix.setSelection(input.isUnixLineEndingsFlagSet());\r\n\t\tfor (int i = 0; i < input.getFieldName().length; i++)\r\n\t\t{\r\n\t\t\tTableItem ti = wFields.table.getItem(i);\r\n\t\t\tif (input.getFieldName()[i]   != null) ti.setText( 1, input.getFieldName()[i]); \r\n\t              ti.setText(2, ValueMeta.getTypeDesc(input.getFieldType()[i]));\r\n\t              ti.setText(3, input.getFieldLength()[i]>=0 ? \"\"+input.getFieldLength()[i] : \"\");  //$NON-NLS-1$\r\n\t              ti.setText(4, input.getFieldPrecision()[i]>=0 ? (\"\"+input.getFieldPrecision()[i]) : \"\");  //$NON-NLS-1$\r\n\t\t\tif (input.getFieldFormat()[i]  != null) ti.setText(5, input.getFieldFormat()[i]); \r\n\t\t\tif (input.getFieldGroup()[i]   != null) ti.setText(6, input.getFieldGroup()[i]); \r\n\t\t\tif (input.getFieldDecimal()[i] != null) ti.setText(7, input.getFieldDecimal()[i]); \r\n\t\t\tif (input.getFieldCurrency()[i]!= null) ti.setText(8, input.getFieldCurrency()[i]); \r\n            if (input.getFieldNullIf()[i] != null) ti.setText(9, input.getFieldNullIf()[i]);\r\n            if (input.getFieldIfNull()[i] != null) ti.setText(10, input.getFieldIfNull()[i]);\r\n            ti.setText(11, ValueMeta.getTrimTypeDesc(input.getFieldTrimType()[i]));\r\n\t\t}\r\n\t\twFields.setRowNums();\r\n\t\twFields.optWidth(true);\r\n\r\n\t\twStepname.selectAll();\r\n\t}","commit_id":"03b2363e3e64157aa59cd3f782aad57e5cce8dc9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String open()\r\n\t{\r\n\t\tShell parent = getParent();\r\n\t\tDisplay display = parent.getDisplay();\r\n\t\t\r\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\r\n \t\tprops.setLook(shell);\r\n        setShellImage(shell, input);\r\n\r\n\t\tModifyListener lsMod = new ModifyListener() \r\n\t\t{\r\n\t\t\tpublic void modifyText(ModifyEvent e) \r\n\t\t\t{\r\n\t\t\t\tinput.setChanged();\r\n\t\t\t}\r\n\t\t};\r\n\t\tSelectionListener lsSel = new SelectionAdapter() \r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t{\r\n\t\t\t\tinput.setChanged();\r\n\t\t\t}\r\n\t\t};\r\n\t\tchanged = input.hasChanged();\r\n\r\n\t\tFormLayout formLayout = new FormLayout ();\r\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\r\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\r\n\r\n\t\tshell.setLayout(formLayout);\r\n\t\tshell.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.Shell.Title\")); //$NON-NLS-1$\r\n\t\t\r\n\t\tint middle = props.getMiddlePct();\r\n\t\tint margin = Const.MARGIN;\r\n\r\n\t\t// Filename line\r\n\t\twlStepname=new Label(shell, SWT.RIGHT);\r\n\t\twlStepname.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.Stepname.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlStepname);\r\n\t\tfdlStepname=new FormData();\r\n\t\tfdlStepname.left = new FormAttachment(0, 0);\r\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\r\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\r\n\t\twlStepname.setLayoutData(fdlStepname);\r\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\twStepname.setText(stepname);\r\n \t\tprops.setLook(wStepname);\r\n\t\twStepname.addModifyListener(lsMod);\r\n\t\tfdStepname=new FormData();\r\n\t\tfdStepname.left = new FormAttachment(middle, 0);\r\n\t\tfdStepname.top  = new FormAttachment(0, margin);\r\n\t\tfdStepname.right= new FormAttachment(100, 0);\r\n\t\twStepname.setLayoutData(fdStepname);\r\n\r\n\t\twSash = new SashForm(shell, SWT.VERTICAL );\r\n \t\t\r\n\t\twTabFolder = new CTabFolder(wSash, SWT.BORDER);\r\n \t\tprops.setLook(wTabFolder, Props.WIDGET_STYLE_TAB);\r\n \t\t\r\n \t\t//////////////////////////\r\n\t\t// START OF GENERAL TAB   ///\r\n\t\t//////////////////////////\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\twGeneralTab=new CTabItem(wTabFolder, SWT.NONE);\r\n\t\twGeneralTab.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.GeneralTab.TabTitle\"));\r\n\t\t\r\n\t\twGeneralComp = new Composite(wTabFolder, SWT.NONE);\r\n \t\tprops.setLook(wGeneralComp);\r\n\r\n\t\tFormLayout generalLayout = new FormLayout();\r\n\t\tgeneralLayout.marginWidth  = 3;\r\n\t\tgeneralLayout.marginHeight = 3;\r\n\t\twGeneralComp.setLayout(generalLayout);\r\n\t\t\r\n\t\t// Step Settings grouping?\r\n\t\t// ////////////////////////\r\n\t\t// START OF Step Settings GROUP\r\n\t\t// \r\n\r\n\t\twStepSettings = new Group(wGeneralComp, SWT.SHADOW_NONE);\r\n\t\tprops.setLook(wStepSettings);\r\n\t\twStepSettings.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.Group.StepSettings.Label\"));\r\n\t\t\r\n\t\tFormLayout groupLayout = new FormLayout();\r\n\t\tgroupLayout.marginWidth = 10;\r\n\t\tgroupLayout.marginHeight = 10;\r\n\t\twStepSettings.setLayout(groupLayout);\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t// fieldevaluate\r\n\t\twlfieldevaluate=new Label(wStepSettings, SWT.RIGHT);\r\n        wlfieldevaluate.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.Matcher.Label\"));\r\n        props.setLook(wlfieldevaluate);\r\n        fdlfieldevaluate=new FormData();\r\n        fdlfieldevaluate.left = new FormAttachment(0, 0);\r\n        fdlfieldevaluate.top  = new FormAttachment(wStepname, margin);\r\n        fdlfieldevaluate.right= new FormAttachment(middle, -margin);\r\n        wlfieldevaluate.setLayoutData(fdlfieldevaluate);\r\n        wfieldevaluate=new CCombo(wStepSettings, SWT.BORDER | SWT.READ_ONLY);\r\n        wfieldevaluate.setEditable(true);\r\n        props.setLook(wfieldevaluate);\r\n        wfieldevaluate.addModifyListener(lsMod);\r\n        fdfieldevaluate=new FormData();\r\n        fdfieldevaluate.left = new FormAttachment(middle, margin);\r\n        fdfieldevaluate.top  = new FormAttachment(wStepname, margin);\r\n        fdfieldevaluate.right= new FormAttachment(100, -margin);\r\n        wfieldevaluate.setLayoutData(fdfieldevaluate);\r\n        wfieldevaluate.addSelectionListener(lsSel);\r\n        wfieldevaluate.addFocusListener(new FocusListener()\r\n            {\r\n                public void focusLost(org.eclipse.swt.events.FocusEvent e)\r\n                {\r\n                }\r\n            \r\n                public void focusGained(org.eclipse.swt.events.FocusEvent e)\r\n                {\r\n                    Cursor busy = new Cursor(shell.getDisplay(), SWT.CURSOR_WAIT);\r\n                    shell.setCursor(busy);\r\n                    getPreviousFields();\r\n                    shell.setCursor(null);\r\n                    busy.dispose();\r\n                }\r\n            }\r\n        );\r\n\r\n\t\t\r\n\t      // Output Fieldame\r\n              \r\n        wResultField = new LabelTextVar(transMeta, wStepSettings, \r\n        \t\tBaseMessages.getString(PKG, \"RegexEvalDialog.ResultField.Label\"), \r\n        \t\tBaseMessages.getString(PKG, \"RegexEvalDialog.ResultField.Tooltip\"));\r\n        \r\n        \r\n        props.setLook(wResultField);\r\n        wResultField .addModifyListener(lsMod);\r\n        fdResultField  = new FormData();\r\n        fdResultField .left = new FormAttachment(0, 0);\r\n        fdResultField .top = new FormAttachment(wfieldevaluate, margin);\r\n        fdResultField .right = new FormAttachment(100, 0);\r\n        wResultField .setLayoutData(fdResultField );\r\n        \r\n        // Allow capture groups?\r\n        wlAllowCaptureGroups=new Label(wStepSettings, SWT.RIGHT);\r\n        wlAllowCaptureGroups.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.AllowCaptureGroups.Label\"));\r\n        props.setLook(wlAllowCaptureGroups);\r\n        fdlAllowCaptureGroups=new FormData();\r\n        fdlAllowCaptureGroups.left  = new FormAttachment(0, 0);\r\n        fdlAllowCaptureGroups.top   = new FormAttachment(wResultField, margin);\r\n        fdlAllowCaptureGroups.right = new FormAttachment(middle, -margin);\r\n        wlAllowCaptureGroups.setLayoutData(fdlAllowCaptureGroups);\r\n        wAllowCaptureGroups=new Button(wStepSettings, SWT.CHECK);\r\n        wAllowCaptureGroups.setToolTipText(BaseMessages.getString(PKG, \"RegexEvalDialog.AllowCaptureGroups.Tooltip\"));\r\n        props.setLook(wAllowCaptureGroups);\r\n        fdAllowCaptureGroups=new FormData();\r\n        fdAllowCaptureGroups.left  = new FormAttachment(middle, margin);\r\n        fdAllowCaptureGroups.top   = new FormAttachment(wResultField, margin);\r\n        fdAllowCaptureGroups.right = new FormAttachment(100,0);\r\n        wAllowCaptureGroups.setLayoutData(fdAllowCaptureGroups);\r\n        \r\n        wAllowCaptureGroups.addSelectionListener(new SelectionAdapter() {\r\n            public void widgetSelected(SelectionEvent e)\r\n            {\r\n                setFieldsEnabledStatus();\r\n                input.setChanged();\r\n            }\r\n        });\r\n    \tfdStepSettings = new FormData();\r\n\t\tfdStepSettings.left = new FormAttachment(0, margin);\r\n\t\tfdStepSettings.top = new FormAttachment(wStepname, margin);\r\n\t\tfdStepSettings.right = new FormAttachment(100, -margin);\r\n\t\twStepSettings.setLayoutData(fdStepSettings);\r\n\t\t\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\t\t// / END OF STEP SETTINGS GROUP\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\t\t\r\n\r\n\t\t\r\n\t\t// Script line\r\n\t\twlScript=new Label(wGeneralComp, SWT.NONE);\r\n\t\twlScript.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.Javascript.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlScript);\r\n\t\tfdlScript=new FormData();\r\n\t\tfdlScript.left = new FormAttachment(0, 0);\r\n\t\tfdlScript.top  = new FormAttachment(wStepSettings, margin);\r\n\t\twlScript.setLayoutData(fdlScript);\r\n\t\t\r\n\t\twbTestRegExScript=new Button(wGeneralComp, SWT.PUSH| SWT.CENTER);\r\n \t\tprops.setLook(wbTestRegExScript);\r\n\t\twbTestRegExScript.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.TestScript.Label\")); \r\n\t\tfdbTestRegExScript=new FormData();\r\n\t\tfdbTestRegExScript.right = new FormAttachment(100, -margin);\r\n\t\tfdbTestRegExScript.top   = new FormAttachment(wStepSettings, margin);\r\n\t\twbTestRegExScript.setLayoutData(fdbTestRegExScript);\r\n\t\t\r\n\t\t\r\n\t\twScript=new StyledTextComp(transMeta, wGeneralComp, SWT.MULTI | SWT.LEFT | SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL, \"\");\r\n\t\twScript.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.Script.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wScript, Props.WIDGET_STYLE_FIXED);\r\n\t\twScript.addModifyListener(lsMod);\r\n\t\tfdScript=new FormData();\r\n\t\tfdScript.left   = new FormAttachment(0, 0);\r\n\t\tfdScript.top    = new FormAttachment(wbTestRegExScript, margin);\r\n\t\tfdScript.right  = new FormAttachment(100, -10);\r\n\t\tfdScript.bottom = new FormAttachment(100, -25);\r\n\t\twScript.setLayoutData(fdScript);\r\n        //SelectionAdapter lsVar = VariableButtonListenerFactory.getSelectionAdapter(shell, wScript);\r\n        //wScript.addKeyListener(TextVar.getControlSpaceKeyListener(wScript, lsVar));\r\n\r\n        \r\n\t\t// Variable substitution?\r\n\t\twlUseVar=new Label(wGeneralComp, SWT.NONE);\r\n\t\twlUseVar.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.UseVar.Label\"));\r\n \t\tprops.setLook(wlUseVar);\r\n\t\tfdlUseVar=new FormData();\r\n\t\tfdlUseVar.left  = new FormAttachment(0, margin);\r\n\t\tfdlUseVar.top   = new FormAttachment(wScript, margin);\r\n\r\n\t\twlUseVar.setLayoutData(fdlUseVar);\r\n\t\twUseVar=new Button(wGeneralComp, SWT.CHECK);\r\n\t\twUseVar.setToolTipText(BaseMessages.getString(PKG, \"RegexEvalDialog.UseVar.Tooltip\"));\r\n \t\tprops.setLook(wUseVar);\r\n\t\tfdUseVar=new FormData();\r\n\t\tfdUseVar.left  = new FormAttachment(wlUseVar, margin);\r\n\t\tfdUseVar.top   = new FormAttachment(wScript, margin);\r\n\t\twUseVar.setLayoutData(fdUseVar);\r\n\t\twUseVar.addSelectionListener(lsSel);\r\n\t\twBottom = new Composite(wSash, SWT.NONE);\r\n \t\tprops.setLook(wBottom);\r\n\r\n \t\tFormLayout bottomLayout  = new FormLayout ();\r\n\t\tbottomLayout.marginWidth  = Const.FORM_MARGIN;\r\n\t\tbottomLayout.marginHeight = Const.FORM_MARGIN;\r\n\t\twBottom.setLayout(bottomLayout);\r\n\t\t\r\n\t\twSeparator = new Label(wBottom, SWT.SEPARATOR | SWT.HORIZONTAL);\r\n\t\tfdSeparator= new FormData();\r\n\t\tfdSeparator.left  = new FormAttachment(0, 0);\r\n\t\tfdSeparator.right = new FormAttachment(100, 0);\r\n\t\tfdSeparator.top   = new FormAttachment(0, -margin+2);\r\n\t\twSeparator.setLayoutData(fdSeparator);\r\n\r\n\t\twlFields=new Label(wBottom, SWT.NONE);\r\n\t\twlFields.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.Fields.Label\")); //$NON-NLS-1$\r\n\t\twlFields.setToolTipText(BaseMessages.getString(PKG, \"RegexEvalDialog.Fields.Tooltip\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlFields);\r\n\t\tfdlFields=new FormData();\r\n\t\tfdlFields.left = new FormAttachment(0, 0);\r\n\t\tfdlFields.top  = new FormAttachment(wSeparator, 0);\r\n\t\twlFields.setLayoutData(fdlFields);\r\n        \r\n\r\n\t\tfinal int fieldsRows=input.getFieldName().length;\r\n\t\t\r\n\t\tColumnInfo[] columnInfo = new ColumnInfo[] {\r\n\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"RegexEvalDialog.ColumnInfo.NewField\"),    ColumnInfo.COLUMN_TYPE_TEXT,   false ), //$NON-NLS-1$\r\n\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"RegexEvalDialog.ColumnInfo.Type\"),        ColumnInfo.COLUMN_TYPE_CCOMBO, ValueMeta.getTypes() ), //$NON-NLS-1$\r\n\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"RegexEvalDialog.ColumnInfo.Length\"),      ColumnInfo.COLUMN_TYPE_TEXT,   false ), //$NON-NLS-1$\r\n\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"RegexEvalDialog.ColumnInfo.Precision\"),   ColumnInfo.COLUMN_TYPE_TEXT,   false ), //$NON-NLS-1$\r\n\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"RegexEvalDialog.ColumnInfo.Format\"),      ColumnInfo.COLUMN_TYPE_TEXT,   false ), //$NON-NLS-1$\r\n\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"RegexEvalDialog.ColumnInfo.Group\"),       ColumnInfo.COLUMN_TYPE_TEXT,   false ), //$NON-NLS-1$\r\n\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"RegexEvalDialog.ColumnInfo.Decimal\"),     ColumnInfo.COLUMN_TYPE_TEXT,   false ), //$NON-NLS-1$\r\n\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"RegexEvalDialog.ColumnInfo.Currency\"),    ColumnInfo.COLUMN_TYPE_TEXT,   false ), //$NON-NLS-1$\r\n\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"RegexEvalDialog.ColumnInfo.Nullif\"),      ColumnInfo.COLUMN_TYPE_TEXT,   false ), //$NON-NLS-1$\r\n\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"RegexEvalDialog.ColumnInfo.IfNull\"),      ColumnInfo.COLUMN_TYPE_TEXT,   false ), //$NON-NLS-1$\r\n\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"RegexEvalDialog.ColumnInfo.TrimType\"),    ColumnInfo.COLUMN_TYPE_CCOMBO, ValueMeta.trimTypeDesc, true), //$NON-NLS-1$\r\n\t\t};\r\n\t\t\r\n\t\twFields=new TableView(transMeta, wBottom, \r\n\t\t\t\t\t\t      SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, \r\n\t\t\t\t\t\t      columnInfo, \r\n\t\t\t\t\t\t      fieldsRows,  \r\n\t\t\t\t\t\t      lsMod,\r\n\t\t\t\t\t\t\t  props\r\n\t\t\t\t\t\t      );\r\n\r\n\t\tfdFields=new FormData();\r\n\t\tfdFields.left = new FormAttachment(0, 0);\r\n\t\tfdFields.top  = new FormAttachment(wlFields, margin);\r\n\t\tfdFields.right  = new FormAttachment(100, 0);\r\n\t\tfdFields.bottom = new FormAttachment(100, 0);\r\n\t\twFields.setLayoutData(fdFields);\r\n\r\n        \r\n\t\tfdGeneralComp=new FormData();\r\n\t\tfdGeneralComp.left  = new FormAttachment(0, 0);\r\n\t\tfdGeneralComp.top   = new FormAttachment(0, 0);\r\n\t\tfdGeneralComp.right = new FormAttachment(100, 0);\r\n\t\tfdGeneralComp.bottom= new FormAttachment(100, 0);\r\n\t\twGeneralComp.setLayoutData(fdGeneralComp);\r\n\t\t\r\n\t\twGeneralComp.layout();\r\n\t\twGeneralTab.setControl(wGeneralComp);\r\n \t\tprops.setLook(wGeneralComp);\r\n \t\t\r\n \t\t\r\n \t\t\r\n\t\t/////////////////////////////////////////////////////////////\r\n\t\t/// END OF GENERAL TAB\r\n\t\t/////////////////////////////////////////////////////////////\r\n \t\t\r\n \t\t//////////////////////////\r\n\t\t// START OF CONTENT TAB///\r\n\t\t///\r\n\t\twContentTab=new CTabItem(wTabFolder, SWT.NONE);\r\n\t\twContentTab.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.ContentTab.TabTitle\"));\r\n\r\n\t\tFormLayout contentLayout = new FormLayout ();\r\n\t\tcontentLayout.marginWidth  = 3;\r\n\t\tcontentLayout.marginHeight = 3;\r\n\t\t\r\n\t\twContentComp = new Composite(wTabFolder, SWT.NONE);\r\n \t\tprops.setLook(wContentComp);\r\n \t\twContentComp.setLayout(contentLayout);\r\n \t\t\r\n\t\t\r\n\t\t// Step RegexSettings grouping?\r\n\t\t// ////////////////////////\r\n\t\t// START OF RegexSettings GROUP\r\n\t\t// \r\n\r\n\t\twRegexSettings = new Group(wContentComp, SWT.SHADOW_NONE);\r\n\t\tprops.setLook(wRegexSettings);\r\n\t\twRegexSettings.setText(\"Regex Settings\");\r\n\t\t\r\n\t\tFormLayout regexLayout = new FormLayout();\r\n\t\tregexLayout.marginWidth = 10;\r\n\t\tregexLayout.marginHeight = 10;\r\n\t\twRegexSettings.setLayout(regexLayout);\r\n\t\t\r\n\t\t\r\n\t\t// Canon_Eq?\r\n\t\twlCanonEq=new Label(wRegexSettings, SWT.RIGHT);\r\n\t\twlCanonEq.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.CanonEq.Label\"));\r\n \t\tprops.setLook(wlCanonEq);\r\n\t\tfdlCanonEq=new FormData();\r\n\t\tfdlCanonEq.left  = new FormAttachment(0, 0);\r\n\t\tfdlCanonEq.top   = new FormAttachment(wStepSettings, margin);\r\n\t\tfdlCanonEq.right = new FormAttachment(middle, -margin);\r\n\t\twlCanonEq.setLayoutData(fdlCanonEq);\r\n\t\twCanonEq=new Button(wRegexSettings, SWT.CHECK);\r\n\t\twCanonEq.setToolTipText(BaseMessages.getString(PKG, \"RegexEvalDialog.CanonEq.Tooltip\"));\r\n \t\tprops.setLook(wCanonEq);\r\n\t\tfdCanonEq=new FormData();\r\n\t\tfdCanonEq.left  = new FormAttachment(middle, 0);\r\n\t\tfdCanonEq.top   = new FormAttachment(wStepSettings, margin);\r\n\t\tfdCanonEq.right = new FormAttachment(100, 0);\r\n\t\twCanonEq.setLayoutData(fdCanonEq);\r\n\t\twCanonEq.addSelectionListener(lsSel);\r\n\t\t\r\n\t\t// CASE_INSENSITIVE?\r\n\t\twlCaseInsensitive=new Label(wRegexSettings, SWT.RIGHT);\r\n\t\twlCaseInsensitive.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.CaseInsensitive.Label\"));\r\n \t\tprops.setLook(wlCaseInsensitive);\r\n\t\tfdlCaseInsensitive=new FormData();\r\n\t\tfdlCaseInsensitive.left  = new FormAttachment(0, 0);\r\n\t\tfdlCaseInsensitive.top   = new FormAttachment(wCanonEq, margin);\r\n\t\tfdlCaseInsensitive.right = new FormAttachment(middle, -margin);\r\n\t\twlCaseInsensitive.setLayoutData(fdlCaseInsensitive);\r\n\t\twCaseInsensitive=new Button(wRegexSettings, SWT.CHECK);\r\n\t\twCaseInsensitive.setToolTipText(BaseMessages.getString(PKG, \"RegexEvalDialog.CaseInsensitive.Tooltip\"));\r\n \t\tprops.setLook(wCaseInsensitive);\r\n\t\tfdCaseInsensitive=new FormData();\r\n\t\tfdCaseInsensitive.left  = new FormAttachment(middle, 0);\r\n\t\tfdCaseInsensitive.top   = new FormAttachment(wCanonEq, margin);\r\n\t\tfdCaseInsensitive.right = new FormAttachment(100, 0);\r\n\t\twCaseInsensitive.setLayoutData(fdCaseInsensitive);\r\n\t\twCaseInsensitive.addSelectionListener(lsSel);\r\n\t\t\r\n\t\t// COMMENT?\r\n\t\twlComment=new Label(wRegexSettings, SWT.RIGHT);\r\n\t\twlComment.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.Comment.Label\"));\r\n \t\tprops.setLook(wlComment);\r\n\t\tfdlComment=new FormData();\r\n\t\tfdlComment.left  = new FormAttachment(0, 0);\r\n\t\tfdlComment.top   = new FormAttachment(wCaseInsensitive, margin);\r\n\t\tfdlComment.right = new FormAttachment(middle, -margin);\r\n\t\twlComment.setLayoutData(fdlComment);\r\n\t\twComment=new Button(wRegexSettings, SWT.CHECK);\r\n\t\twComment.setToolTipText(BaseMessages.getString(PKG, \"RegexEvalDialog.Comment.Tooltip\"));\r\n \t\tprops.setLook(wComment);\r\n\t\tfdComment=new FormData();\r\n\t\tfdComment.left  = new FormAttachment(middle, 0);\r\n\t\tfdComment.top   = new FormAttachment(wCaseInsensitive, margin);\r\n\t\tfdComment.right = new FormAttachment(100, 0);\r\n\t\twComment.setLayoutData(fdComment);\r\n\t\twComment.addSelectionListener(lsSel);\r\n\t\t\r\n\t\t// DOTALL?\r\n\t\twlDotAll=new Label(wRegexSettings, SWT.RIGHT);\r\n\t\twlDotAll.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.DotAll.Label\"));\r\n \t\tprops.setLook(wlDotAll);\r\n\t\tfdlDotAll=new FormData();\r\n\t\tfdlDotAll.left  = new FormAttachment(0, 0);\r\n\t\tfdlDotAll.top   = new FormAttachment(wComment, margin);\r\n\t\tfdlDotAll.right = new FormAttachment(middle, -margin);\r\n\t\twlDotAll.setLayoutData(fdlDotAll);\r\n\t\twDotAll=new Button(wRegexSettings, SWT.CHECK);\r\n\t\twDotAll.setToolTipText(BaseMessages.getString(PKG, \"RegexEvalDialog.DotAll.Tooltip\"));\r\n \t\tprops.setLook(wDotAll);\r\n\t\tfdDotAll=new FormData();\r\n\t\tfdDotAll.left  = new FormAttachment(middle, 0);\r\n\t\tfdDotAll.top   = new FormAttachment(wComment, margin);\r\n\t\tfdDotAll.right = new FormAttachment(100, 0);\r\n\t\twDotAll.setLayoutData(fdDotAll);\r\n\t\twDotAll.addSelectionListener(lsSel);\r\n\t\t\r\n\t\t// MULTILINE?\r\n\t\twlMultiline=new Label(wRegexSettings, SWT.RIGHT);\r\n\t\twlMultiline.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.Multiline.Label\"));\r\n \t\tprops.setLook(wlMultiline);\r\n\t\tfdlMultiline=new FormData();\r\n\t\tfdlMultiline.left  = new FormAttachment(0, 0);\r\n\t\tfdlMultiline.top   = new FormAttachment(wDotAll, margin);\r\n\t\tfdlMultiline.right = new FormAttachment(middle, -margin);\r\n\t\twlMultiline.setLayoutData(fdlMultiline);\r\n\t\twMultiline=new Button(wRegexSettings, SWT.CHECK);\r\n\t\twMultiline.setToolTipText(BaseMessages.getString(PKG, \"RegexEvalDialog.Multiline.Tooltip\"));\r\n \t\tprops.setLook(wMultiline);\r\n\t\tfdMultiline=new FormData();\r\n\t\tfdMultiline.left  = new FormAttachment(middle, 0);\r\n\t\tfdMultiline.top   = new FormAttachment(wDotAll, margin);\r\n\t\tfdMultiline.right = new FormAttachment(100, 0);\r\n\t\twMultiline.setLayoutData(fdMultiline);\r\n\t\twMultiline.addSelectionListener(lsSel);\r\n\t\t\r\n\t\t// UNICODE?\r\n\t\twlUnicode=new Label(wRegexSettings, SWT.RIGHT);\r\n\t\twlUnicode.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.Unicode.Label\"));\r\n \t\tprops.setLook(wlUnicode);\r\n\t\tfdlUnicode=new FormData();\r\n\t\tfdlUnicode.left  = new FormAttachment(0, 0);\r\n\t\tfdlUnicode.top   = new FormAttachment(wMultiline, margin);\r\n\t\tfdlUnicode.right = new FormAttachment(middle, -margin);\r\n\t\twlUnicode.setLayoutData(fdlUnicode);\r\n\t\twUnicode=new Button(wRegexSettings, SWT.CHECK);\r\n\t\twUnicode.setToolTipText(BaseMessages.getString(PKG, \"RegexEvalDialog.Unicode.Tooltip\"));\r\n \t\tprops.setLook(wUnicode);\r\n\t\tfdUnicode=new FormData();\r\n\t\tfdUnicode.left  = new FormAttachment(middle, 0);\r\n\t\tfdUnicode.top   = new FormAttachment(wMultiline, margin);\r\n\t\tfdUnicode.right = new FormAttachment(100, 0);\r\n\t\twUnicode.setLayoutData(fdUnicode);\r\n\t\twUnicode.addSelectionListener(lsSel);\r\n\t\t\r\n\t\t// UNIX?\r\n\t\twlUnix=new Label(wRegexSettings, SWT.RIGHT);\r\n\t\twlUnix.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.Unix.Label\"));\r\n \t\tprops.setLook(wlUnix);\r\n\t\tfdlUnix=new FormData();\r\n\t\tfdlUnix.left  = new FormAttachment(0, 0);\r\n\t\tfdlUnix.top   = new FormAttachment(wUnicode, margin);\r\n\t\tfdlUnix.right = new FormAttachment(middle, -margin);\r\n\t\twlUnix.setLayoutData(fdlUnix);\r\n\t\twUnix=new Button(wRegexSettings, SWT.CHECK);\r\n\t\twUnix.setToolTipText(BaseMessages.getString(PKG, \"RegexEvalDialog.Unix.Tooltip\"));\r\n \t\tprops.setLook(wUnix);\r\n\t\tfdUnix=new FormData();\r\n\t\tfdUnix.left  = new FormAttachment(middle, 0);\r\n\t\tfdUnix.top   = new FormAttachment(wUnicode, margin);\r\n\t\tfdUnix.right = new FormAttachment(100, 0);\r\n\t\twUnix.setLayoutData(fdUnix);\r\n\t\twUnix.addSelectionListener(lsSel);\r\n\r\n\t\t\r\n\t \tfdRegexSettings = new FormData();\r\n\t\tfdRegexSettings.left = new FormAttachment(0, margin);\r\n\t\tfdRegexSettings.top = new FormAttachment(wStepSettings, margin);\r\n\t\tfdRegexSettings.right = new FormAttachment(100, -margin);\r\n\t\twRegexSettings.setLayoutData(fdRegexSettings);\r\n\t\t\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\t\t// / END OF RegexSettings GROUP\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\t\t\r\n \t\t\r\n \t\t\r\n \t\tfdContentComp = new FormData();\r\n \t\tfdContentComp.left  = new FormAttachment(0, 0);\r\n \t\tfdContentComp.top   = new FormAttachment(0, 0);\r\n \t\tfdContentComp.right = new FormAttachment(100, 0);\r\n \t\tfdContentComp.bottom= new FormAttachment(100, 0);\r\n \t\twContentComp.setLayoutData(wContentComp);\r\n\r\n\t\twContentComp.layout();\r\n\t\twContentTab.setControl(wContentComp);\r\n\r\n\r\n\t\t/////////////////////////////////////////////////////////////\r\n\t\t/// END OF CONTENT TAB\r\n\t\t/////////////////////////////////////////////////////////////\r\n\t\t\r\n\t\tfdTabFolder = new FormData();\r\n\t\tfdTabFolder.left  = new FormAttachment(0, 0);\r\n\t\tfdTabFolder.top   = new FormAttachment(wStepname, margin);\r\n\t\tfdTabFolder.right = new FormAttachment(100, 0);\r\n\t\tfdTabFolder.bottom= new FormAttachment(100, -50);\r\n\t\twTabFolder.setLayoutData(fdTabFolder);\r\n\r\n\t\tfdBottom=new FormData();\r\n\t\tfdBottom.left  = new FormAttachment(0, 0);\r\n\t\tfdBottom.top   = new FormAttachment(0, 0);\r\n\t\tfdBottom.right = new FormAttachment(100, 0);\r\n\t\tfdBottom.bottom= new FormAttachment(100, 0);\r\n\t\twBottom.setLayoutData(fdBottom);\r\n\r\n\t\tfdSash = new FormData();\r\n\t\tfdSash.left  = new FormAttachment(0, 0);\r\n\t\tfdSash.top   = new FormAttachment(wStepname, 0);\r\n\t\tfdSash.right = new FormAttachment(100, 0);\r\n\t\tfdSash.bottom= new FormAttachment(100, -50);\r\n\t\twSash.setLayoutData(fdSash);\r\n\t\t\r\n\t\twSash.setWeights(new int[] {60,40});\r\n\r\n\t\twOK=new Button(shell, SWT.PUSH);\r\n\t\twOK.setText(BaseMessages.getString(PKG, \"System.Button.OK\")); //$NON-NLS-1$\r\n\r\n\t\twCancel=new Button(shell, SWT.PUSH);\r\n\t\twCancel.setText(BaseMessages.getString(PKG, \"System.Button.Cancel\")); //$NON-NLS-1$\r\n\r\n\t\tlsbTestRegExScript   = new Listener() { public void handleEvent(Event e) {testRegExScript();  } };\r\n\t\twbTestRegExScript.addListener  (SWT.Selection, lsbTestRegExScript);\r\n\t\t\r\n\t\tsetButtonPositions(new Button[] { wOK, wCancel }, margin, null);\r\n\r\n\r\n\t\t// Add listeners\r\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel();          } };\r\n\t\t\r\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();              } };\r\n\t\t\r\n\t\twCancel.addListener(SWT.Selection, lsCancel);\r\n\r\n\r\n\t\twOK.addListener    (SWT.Selection, lsOK    );\r\n\t\t\r\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\r\n\t\t\r\n\t\twStepname.addSelectionListener( lsDef );\r\n\t\t\t\t\r\n\t\twTabFolder.setSelection(0);\r\n\t\t\r\n\t\t// Set the shell size, based upon previous time...\r\n\t\tsetSize();\r\n\t\t\r\n\t\tgetData();\r\n\t\t\r\n\t\tsetFieldsEnabledStatus();\r\n\t\t\r\n\t\tinput.setChanged(changed);\r\n\t\r\n\t\tshell.open();\r\n\t\twhile (!shell.isDisposed())\r\n\t\t{\r\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\r\n\t\t}\r\n\t\treturn stepname;\r\n\t}","id":75675,"modified_method":"public String open()\r\n\t{\r\n\t\tShell parent = getParent();\r\n\t\tDisplay display = parent.getDisplay();\r\n\t\t\r\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\r\n \t\tprops.setLook(shell);\r\n        setShellImage(shell, input);\r\n\r\n\t\tModifyListener lsMod = new ModifyListener() \r\n\t\t{\r\n\t\t\tpublic void modifyText(ModifyEvent e) \r\n\t\t\t{\r\n\t\t\t\tinput.setChanged();\r\n\t\t\t}\r\n\t\t};\r\n\t\tSelectionListener lsSel = new SelectionAdapter() \r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t{\r\n\t\t\t\tinput.setChanged();\r\n\t\t\t}\r\n\t\t};\r\n\t\tchanged = input.hasChanged();\r\n\r\n\t\tFormLayout formLayout = new FormLayout ();\r\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\r\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\r\n\r\n\t\tshell.setLayout(formLayout);\r\n\t\tshell.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.Shell.Title\")); //$NON-NLS-1$\r\n\t\t\r\n\t\tint middle = props.getMiddlePct();\r\n\t\tint margin = Const.MARGIN;\r\n\r\n\t\t// Filename line\r\n\t\twlStepname=new Label(shell, SWT.RIGHT);\r\n\t\twlStepname.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.Stepname.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlStepname);\r\n\t\tfdlStepname=new FormData();\r\n\t\tfdlStepname.left = new FormAttachment(0, 0);\r\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\r\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\r\n\t\twlStepname.setLayoutData(fdlStepname);\r\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\twStepname.setText(stepname);\r\n \t\tprops.setLook(wStepname);\r\n\t\twStepname.addModifyListener(lsMod);\r\n\t\tfdStepname=new FormData();\r\n\t\tfdStepname.left = new FormAttachment(middle, 0);\r\n\t\tfdStepname.top  = new FormAttachment(0, margin);\r\n\t\tfdStepname.right= new FormAttachment(100, 0);\r\n\t\twStepname.setLayoutData(fdStepname);\r\n\r\n\t\twSash = new SashForm(shell, SWT.VERTICAL );\r\n \t\t\r\n\t\twTabFolder = new CTabFolder(wSash, SWT.BORDER);\r\n \t\tprops.setLook(wTabFolder, Props.WIDGET_STYLE_TAB);\r\n \t\t\r\n \t\t//////////////////////////\r\n\t\t// START OF GENERAL TAB   ///\r\n\t\t//////////////////////////\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\twGeneralTab=new CTabItem(wTabFolder, SWT.NONE);\r\n\t\twGeneralTab.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.GeneralTab.TabTitle\"));\r\n\t\t\r\n\t\twGeneralComp = new Composite(wTabFolder, SWT.NONE);\r\n \t\tprops.setLook(wGeneralComp);\r\n\r\n\t\tFormLayout generalLayout = new FormLayout();\r\n\t\tgeneralLayout.marginWidth  = 3;\r\n\t\tgeneralLayout.marginHeight = 3;\r\n\t\twGeneralComp.setLayout(generalLayout);\r\n\t\t\r\n\t\t// Step Settings grouping?\r\n\t\t// ////////////////////////\r\n\t\t// START OF Step Settings GROUP\r\n\t\t// \r\n\r\n\t\twStepSettings = new Group(wGeneralComp, SWT.SHADOW_NONE);\r\n\t\tprops.setLook(wStepSettings);\r\n\t\twStepSettings.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.Group.StepSettings.Label\"));\r\n\t\t\r\n\t\tFormLayout groupLayout = new FormLayout();\r\n\t\tgroupLayout.marginWidth = 10;\r\n\t\tgroupLayout.marginHeight = 10;\r\n\t\twStepSettings.setLayout(groupLayout);\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t// fieldevaluate\r\n\t\twlfieldevaluate=new Label(wStepSettings, SWT.RIGHT);\r\n        wlfieldevaluate.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.Matcher.Label\"));\r\n        props.setLook(wlfieldevaluate);\r\n        fdlfieldevaluate=new FormData();\r\n        fdlfieldevaluate.left = new FormAttachment(0, 0);\r\n        fdlfieldevaluate.top  = new FormAttachment(wStepname, margin);\r\n        fdlfieldevaluate.right= new FormAttachment(middle, -margin);\r\n        wlfieldevaluate.setLayoutData(fdlfieldevaluate);\r\n        wfieldevaluate=new CCombo(wStepSettings, SWT.BORDER | SWT.READ_ONLY);\r\n        wfieldevaluate.setEditable(true);\r\n        props.setLook(wfieldevaluate);\r\n        wfieldevaluate.addModifyListener(lsMod);\r\n        fdfieldevaluate=new FormData();\r\n        fdfieldevaluate.left = new FormAttachment(middle, margin);\r\n        fdfieldevaluate.top  = new FormAttachment(wStepname, margin);\r\n        fdfieldevaluate.right= new FormAttachment(100, -margin);\r\n        wfieldevaluate.setLayoutData(fdfieldevaluate);\r\n        wfieldevaluate.addSelectionListener(lsSel);\r\n        wfieldevaluate.addFocusListener(new FocusListener()\r\n            {\r\n                public void focusLost(org.eclipse.swt.events.FocusEvent e)\r\n                {\r\n                }\r\n            \r\n                public void focusGained(org.eclipse.swt.events.FocusEvent e)\r\n                {\r\n                    Cursor busy = new Cursor(shell.getDisplay(), SWT.CURSOR_WAIT);\r\n                    shell.setCursor(busy);\r\n                    getPreviousFields();\r\n                    shell.setCursor(null);\r\n                    busy.dispose();\r\n                }\r\n            }\r\n        );\r\n\r\n\t\t\r\n\t      // Output Fieldame\r\n              \r\n        wResultField = new LabelTextVar(transMeta, wStepSettings, \r\n        \t\tBaseMessages.getString(PKG, \"RegexEvalDialog.ResultField.Label\"), \r\n        \t\tBaseMessages.getString(PKG, \"RegexEvalDialog.ResultField.Tooltip\"));\r\n        \r\n        \r\n        props.setLook(wResultField);\r\n        wResultField .addModifyListener(lsMod);\r\n        fdResultField  = new FormData();\r\n        fdResultField .left = new FormAttachment(0, 0);\r\n        fdResultField .top = new FormAttachment(wfieldevaluate, margin);\r\n        fdResultField .right = new FormAttachment(100, 0);\r\n        wResultField .setLayoutData(fdResultField );\r\n        \r\n        // Allow capture groups?\r\n        wlAllowCaptureGroups=new Label(wStepSettings, SWT.RIGHT);\r\n        wlAllowCaptureGroups.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.AllowCaptureGroups.Label\"));\r\n        props.setLook(wlAllowCaptureGroups);\r\n        fdlAllowCaptureGroups=new FormData();\r\n        fdlAllowCaptureGroups.left  = new FormAttachment(0, 0);\r\n        fdlAllowCaptureGroups.top   = new FormAttachment(wResultField, margin);\r\n        fdlAllowCaptureGroups.right = new FormAttachment(middle, -margin);\r\n        wlAllowCaptureGroups.setLayoutData(fdlAllowCaptureGroups);\r\n        wAllowCaptureGroups=new Button(wStepSettings, SWT.CHECK);\r\n        wAllowCaptureGroups.setToolTipText(BaseMessages.getString(PKG, \"RegexEvalDialog.AllowCaptureGroups.Tooltip\"));\r\n        props.setLook(wAllowCaptureGroups);\r\n        fdAllowCaptureGroups=new FormData();\r\n        fdAllowCaptureGroups.left  = new FormAttachment(middle, margin);\r\n        fdAllowCaptureGroups.top   = new FormAttachment(wResultField, margin);\r\n        fdAllowCaptureGroups.right = new FormAttachment(100,0);\r\n        wAllowCaptureGroups.setLayoutData(fdAllowCaptureGroups);\r\n        \r\n        wAllowCaptureGroups.addSelectionListener(new SelectionAdapter() {\r\n            public void widgetSelected(SelectionEvent e)\r\n            {\r\n                setFieldsEnabledStatus();\r\n                input.setChanged();\r\n            }\r\n        });\r\n        \r\n        // Replace fields?\r\n        wlReplaceFields=new Label(wStepSettings, SWT.RIGHT);\r\n        wlReplaceFields.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.ReplaceFields.Label\"));\r\n        props.setLook(wlReplaceFields);\r\n        fdlReplaceFields=new FormData();\r\n        fdlReplaceFields.left  = new FormAttachment(0, 0);\r\n        fdlReplaceFields.top   = new FormAttachment(wAllowCaptureGroups, margin);\r\n        fdlReplaceFields.right = new FormAttachment(middle, -margin);\r\n        wlReplaceFields.setLayoutData(fdlReplaceFields);\r\n        wReplaceFields=new Button(wStepSettings, SWT.CHECK);\r\n        wReplaceFields.setToolTipText(BaseMessages.getString(PKG, \"RegexEvalDialog.ReplaceFields.Tooltip\"));\r\n        props.setLook(wReplaceFields);\r\n        fdReplaceFields=new FormData();\r\n        fdReplaceFields.left  = new FormAttachment(middle, margin);\r\n        fdReplaceFields.top   = new FormAttachment(wAllowCaptureGroups, margin);\r\n        fdReplaceFields.right = new FormAttachment(100,0);\r\n        wReplaceFields.setLayoutData(fdReplaceFields);\r\n        \r\n        wReplaceFields.addSelectionListener(new SelectionAdapter() {\r\n            public void widgetSelected(SelectionEvent e)\r\n            {\r\n                input.setChanged();\r\n            }\r\n        });\r\n        \r\n        //settings layout\r\n    \tfdStepSettings = new FormData();\r\n\t\tfdStepSettings.left = new FormAttachment(0, margin);\r\n\t\tfdStepSettings.top = new FormAttachment(wStepname, margin);\r\n\t\tfdStepSettings.right = new FormAttachment(100, -margin);\r\n\t\twStepSettings.setLayoutData(fdStepSettings);\r\n\t\t\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\t\t// / END OF STEP SETTINGS GROUP\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\t\t\r\n\r\n\t\t\r\n\t\t// Script line\r\n\t\twlScript=new Label(wGeneralComp, SWT.NONE);\r\n\t\twlScript.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.Javascript.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlScript);\r\n\t\tfdlScript=new FormData();\r\n\t\tfdlScript.left = new FormAttachment(0, 0);\r\n\t\tfdlScript.top  = new FormAttachment(wStepSettings, margin);\r\n\t\twlScript.setLayoutData(fdlScript);\r\n\t\t\r\n\t\twbTestRegExScript=new Button(wGeneralComp, SWT.PUSH| SWT.CENTER);\r\n \t\tprops.setLook(wbTestRegExScript);\r\n\t\twbTestRegExScript.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.TestScript.Label\")); \r\n\t\tfdbTestRegExScript=new FormData();\r\n\t\tfdbTestRegExScript.right = new FormAttachment(100, -margin);\r\n\t\tfdbTestRegExScript.top   = new FormAttachment(wStepSettings, margin);\r\n\t\twbTestRegExScript.setLayoutData(fdbTestRegExScript);\r\n\t\t\r\n\t\t\r\n\t\twScript=new StyledTextComp(transMeta, wGeneralComp, SWT.MULTI | SWT.LEFT | SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL, \"\");\r\n\t\twScript.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.Script.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wScript, Props.WIDGET_STYLE_FIXED);\r\n\t\twScript.addModifyListener(lsMod);\r\n\t\tfdScript=new FormData();\r\n\t\tfdScript.left   = new FormAttachment(0, 0);\r\n\t\tfdScript.top    = new FormAttachment(wbTestRegExScript, margin);\r\n\t\tfdScript.right  = new FormAttachment(100, -10);\r\n\t\tfdScript.bottom = new FormAttachment(100, -25);\r\n\t\twScript.setLayoutData(fdScript);\r\n        //SelectionAdapter lsVar = VariableButtonListenerFactory.getSelectionAdapter(shell, wScript);\r\n        //wScript.addKeyListener(TextVar.getControlSpaceKeyListener(wScript, lsVar));\r\n\r\n        \r\n\t\t// Variable substitution?\r\n\t\twlUseVar=new Label(wGeneralComp, SWT.NONE);\r\n\t\twlUseVar.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.UseVar.Label\"));\r\n \t\tprops.setLook(wlUseVar);\r\n\t\tfdlUseVar=new FormData();\r\n\t\tfdlUseVar.left  = new FormAttachment(0, margin);\r\n\t\tfdlUseVar.top   = new FormAttachment(wScript, margin);\r\n\r\n\t\twlUseVar.setLayoutData(fdlUseVar);\r\n\t\twUseVar=new Button(wGeneralComp, SWT.CHECK);\r\n\t\twUseVar.setToolTipText(BaseMessages.getString(PKG, \"RegexEvalDialog.UseVar.Tooltip\"));\r\n \t\tprops.setLook(wUseVar);\r\n\t\tfdUseVar=new FormData();\r\n\t\tfdUseVar.left  = new FormAttachment(wlUseVar, margin);\r\n\t\tfdUseVar.top   = new FormAttachment(wScript, margin);\r\n\t\twUseVar.setLayoutData(fdUseVar);\r\n\t\twUseVar.addSelectionListener(lsSel);\r\n\t\twBottom = new Composite(wSash, SWT.NONE);\r\n \t\tprops.setLook(wBottom);\r\n\r\n \t\tFormLayout bottomLayout  = new FormLayout ();\r\n\t\tbottomLayout.marginWidth  = Const.FORM_MARGIN;\r\n\t\tbottomLayout.marginHeight = Const.FORM_MARGIN;\r\n\t\twBottom.setLayout(bottomLayout);\r\n\t\t\r\n\t\twSeparator = new Label(wBottom, SWT.SEPARATOR | SWT.HORIZONTAL);\r\n\t\tfdSeparator= new FormData();\r\n\t\tfdSeparator.left  = new FormAttachment(0, 0);\r\n\t\tfdSeparator.right = new FormAttachment(100, 0);\r\n\t\tfdSeparator.top   = new FormAttachment(0, -margin+2);\r\n\t\twSeparator.setLayoutData(fdSeparator);\r\n\r\n\t\twlFields=new Label(wBottom, SWT.NONE);\r\n\t\twlFields.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.Fields.Label\")); //$NON-NLS-1$\r\n\t\twlFields.setToolTipText(BaseMessages.getString(PKG, \"RegexEvalDialog.Fields.Tooltip\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlFields);\r\n\t\tfdlFields=new FormData();\r\n\t\tfdlFields.left = new FormAttachment(0, 0);\r\n\t\tfdlFields.top  = new FormAttachment(wSeparator, 0);\r\n\t\twlFields.setLayoutData(fdlFields);\r\n        \r\n\r\n\t\tfinal int fieldsRows=input.getFieldName().length;\r\n\t\t\r\n\t\tColumnInfo[] columnInfo = new ColumnInfo[] {\r\n\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"RegexEvalDialog.ColumnInfo.NewField\"),    ColumnInfo.COLUMN_TYPE_TEXT,   false ), //$NON-NLS-1$\r\n\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"RegexEvalDialog.ColumnInfo.Type\"),        ColumnInfo.COLUMN_TYPE_CCOMBO, ValueMeta.getTypes() ), //$NON-NLS-1$\r\n\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"RegexEvalDialog.ColumnInfo.Length\"),      ColumnInfo.COLUMN_TYPE_TEXT,   false ), //$NON-NLS-1$\r\n\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"RegexEvalDialog.ColumnInfo.Precision\"),   ColumnInfo.COLUMN_TYPE_TEXT,   false ), //$NON-NLS-1$\r\n\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"RegexEvalDialog.ColumnInfo.Format\"),      ColumnInfo.COLUMN_TYPE_TEXT,   false ), //$NON-NLS-1$\r\n\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"RegexEvalDialog.ColumnInfo.Group\"),       ColumnInfo.COLUMN_TYPE_TEXT,   false ), //$NON-NLS-1$\r\n\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"RegexEvalDialog.ColumnInfo.Decimal\"),     ColumnInfo.COLUMN_TYPE_TEXT,   false ), //$NON-NLS-1$\r\n\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"RegexEvalDialog.ColumnInfo.Currency\"),    ColumnInfo.COLUMN_TYPE_TEXT,   false ), //$NON-NLS-1$\r\n\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"RegexEvalDialog.ColumnInfo.Nullif\"),      ColumnInfo.COLUMN_TYPE_TEXT,   false ), //$NON-NLS-1$\r\n\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"RegexEvalDialog.ColumnInfo.IfNull\"),      ColumnInfo.COLUMN_TYPE_TEXT,   false ), //$NON-NLS-1$\r\n\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"RegexEvalDialog.ColumnInfo.TrimType\"),    ColumnInfo.COLUMN_TYPE_CCOMBO, ValueMeta.trimTypeDesc, true), //$NON-NLS-1$\r\n\t\t};\r\n\t\t\r\n\t\twFields=new TableView(transMeta, wBottom, \r\n\t\t\t\t\t\t      SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, \r\n\t\t\t\t\t\t      columnInfo, \r\n\t\t\t\t\t\t      fieldsRows,  \r\n\t\t\t\t\t\t      lsMod,\r\n\t\t\t\t\t\t\t  props\r\n\t\t\t\t\t\t      );\r\n\r\n\t\tfdFields=new FormData();\r\n\t\tfdFields.left = new FormAttachment(0, 0);\r\n\t\tfdFields.top  = new FormAttachment(wlFields, margin);\r\n\t\tfdFields.right  = new FormAttachment(100, 0);\r\n\t\tfdFields.bottom = new FormAttachment(100, 0);\r\n\t\twFields.setLayoutData(fdFields);\r\n\r\n        \r\n\t\tfdGeneralComp=new FormData();\r\n\t\tfdGeneralComp.left  = new FormAttachment(0, 0);\r\n\t\tfdGeneralComp.top   = new FormAttachment(0, 0);\r\n\t\tfdGeneralComp.right = new FormAttachment(100, 0);\r\n\t\tfdGeneralComp.bottom= new FormAttachment(100, 0);\r\n\t\twGeneralComp.setLayoutData(fdGeneralComp);\r\n\t\t\r\n\t\twGeneralComp.layout();\r\n\t\twGeneralTab.setControl(wGeneralComp);\r\n \t\tprops.setLook(wGeneralComp);\r\n \t\t\r\n \t\t\r\n \t\t\r\n\t\t/////////////////////////////////////////////////////////////\r\n\t\t/// END OF GENERAL TAB\r\n\t\t/////////////////////////////////////////////////////////////\r\n \t\t\r\n \t\t//////////////////////////\r\n\t\t// START OF CONTENT TAB///\r\n\t\t///\r\n\t\twContentTab=new CTabItem(wTabFolder, SWT.NONE);\r\n\t\twContentTab.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.ContentTab.TabTitle\"));\r\n\r\n\t\tFormLayout contentLayout = new FormLayout ();\r\n\t\tcontentLayout.marginWidth  = 3;\r\n\t\tcontentLayout.marginHeight = 3;\r\n\t\t\r\n\t\twContentComp = new Composite(wTabFolder, SWT.NONE);\r\n \t\tprops.setLook(wContentComp);\r\n \t\twContentComp.setLayout(contentLayout);\r\n \t\t\r\n\t\t\r\n\t\t// Step RegexSettings grouping?\r\n\t\t// ////////////////////////\r\n\t\t// START OF RegexSettings GROUP\r\n\t\t// \r\n\r\n\t\twRegexSettings = new Group(wContentComp, SWT.SHADOW_NONE);\r\n\t\tprops.setLook(wRegexSettings);\r\n\t\twRegexSettings.setText(\"Regex Settings\");\r\n\t\t\r\n\t\tFormLayout regexLayout = new FormLayout();\r\n\t\tregexLayout.marginWidth = 10;\r\n\t\tregexLayout.marginHeight = 10;\r\n\t\twRegexSettings.setLayout(regexLayout);\r\n\t\t\r\n\t\t\r\n\t\t// Canon_Eq?\r\n\t\twlCanonEq=new Label(wRegexSettings, SWT.RIGHT);\r\n\t\twlCanonEq.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.CanonEq.Label\"));\r\n \t\tprops.setLook(wlCanonEq);\r\n\t\tfdlCanonEq=new FormData();\r\n\t\tfdlCanonEq.left  = new FormAttachment(0, 0);\r\n\t\tfdlCanonEq.top   = new FormAttachment(wStepSettings, margin);\r\n\t\tfdlCanonEq.right = new FormAttachment(middle, -margin);\r\n\t\twlCanonEq.setLayoutData(fdlCanonEq);\r\n\t\twCanonEq=new Button(wRegexSettings, SWT.CHECK);\r\n\t\twCanonEq.setToolTipText(BaseMessages.getString(PKG, \"RegexEvalDialog.CanonEq.Tooltip\"));\r\n \t\tprops.setLook(wCanonEq);\r\n\t\tfdCanonEq=new FormData();\r\n\t\tfdCanonEq.left  = new FormAttachment(middle, 0);\r\n\t\tfdCanonEq.top   = new FormAttachment(wStepSettings, margin);\r\n\t\tfdCanonEq.right = new FormAttachment(100, 0);\r\n\t\twCanonEq.setLayoutData(fdCanonEq);\r\n\t\twCanonEq.addSelectionListener(lsSel);\r\n\t\t\r\n\t\t// CASE_INSENSITIVE?\r\n\t\twlCaseInsensitive=new Label(wRegexSettings, SWT.RIGHT);\r\n\t\twlCaseInsensitive.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.CaseInsensitive.Label\"));\r\n \t\tprops.setLook(wlCaseInsensitive);\r\n\t\tfdlCaseInsensitive=new FormData();\r\n\t\tfdlCaseInsensitive.left  = new FormAttachment(0, 0);\r\n\t\tfdlCaseInsensitive.top   = new FormAttachment(wCanonEq, margin);\r\n\t\tfdlCaseInsensitive.right = new FormAttachment(middle, -margin);\r\n\t\twlCaseInsensitive.setLayoutData(fdlCaseInsensitive);\r\n\t\twCaseInsensitive=new Button(wRegexSettings, SWT.CHECK);\r\n\t\twCaseInsensitive.setToolTipText(BaseMessages.getString(PKG, \"RegexEvalDialog.CaseInsensitive.Tooltip\"));\r\n \t\tprops.setLook(wCaseInsensitive);\r\n\t\tfdCaseInsensitive=new FormData();\r\n\t\tfdCaseInsensitive.left  = new FormAttachment(middle, 0);\r\n\t\tfdCaseInsensitive.top   = new FormAttachment(wCanonEq, margin);\r\n\t\tfdCaseInsensitive.right = new FormAttachment(100, 0);\r\n\t\twCaseInsensitive.setLayoutData(fdCaseInsensitive);\r\n\t\twCaseInsensitive.addSelectionListener(lsSel);\r\n\t\t\r\n\t\t// COMMENT?\r\n\t\twlComment=new Label(wRegexSettings, SWT.RIGHT);\r\n\t\twlComment.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.Comment.Label\"));\r\n \t\tprops.setLook(wlComment);\r\n\t\tfdlComment=new FormData();\r\n\t\tfdlComment.left  = new FormAttachment(0, 0);\r\n\t\tfdlComment.top   = new FormAttachment(wCaseInsensitive, margin);\r\n\t\tfdlComment.right = new FormAttachment(middle, -margin);\r\n\t\twlComment.setLayoutData(fdlComment);\r\n\t\twComment=new Button(wRegexSettings, SWT.CHECK);\r\n\t\twComment.setToolTipText(BaseMessages.getString(PKG, \"RegexEvalDialog.Comment.Tooltip\"));\r\n \t\tprops.setLook(wComment);\r\n\t\tfdComment=new FormData();\r\n\t\tfdComment.left  = new FormAttachment(middle, 0);\r\n\t\tfdComment.top   = new FormAttachment(wCaseInsensitive, margin);\r\n\t\tfdComment.right = new FormAttachment(100, 0);\r\n\t\twComment.setLayoutData(fdComment);\r\n\t\twComment.addSelectionListener(lsSel);\r\n\t\t\r\n\t\t// DOTALL?\r\n\t\twlDotAll=new Label(wRegexSettings, SWT.RIGHT);\r\n\t\twlDotAll.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.DotAll.Label\"));\r\n \t\tprops.setLook(wlDotAll);\r\n\t\tfdlDotAll=new FormData();\r\n\t\tfdlDotAll.left  = new FormAttachment(0, 0);\r\n\t\tfdlDotAll.top   = new FormAttachment(wComment, margin);\r\n\t\tfdlDotAll.right = new FormAttachment(middle, -margin);\r\n\t\twlDotAll.setLayoutData(fdlDotAll);\r\n\t\twDotAll=new Button(wRegexSettings, SWT.CHECK);\r\n\t\twDotAll.setToolTipText(BaseMessages.getString(PKG, \"RegexEvalDialog.DotAll.Tooltip\"));\r\n \t\tprops.setLook(wDotAll);\r\n\t\tfdDotAll=new FormData();\r\n\t\tfdDotAll.left  = new FormAttachment(middle, 0);\r\n\t\tfdDotAll.top   = new FormAttachment(wComment, margin);\r\n\t\tfdDotAll.right = new FormAttachment(100, 0);\r\n\t\twDotAll.setLayoutData(fdDotAll);\r\n\t\twDotAll.addSelectionListener(lsSel);\r\n\t\t\r\n\t\t// MULTILINE?\r\n\t\twlMultiline=new Label(wRegexSettings, SWT.RIGHT);\r\n\t\twlMultiline.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.Multiline.Label\"));\r\n \t\tprops.setLook(wlMultiline);\r\n\t\tfdlMultiline=new FormData();\r\n\t\tfdlMultiline.left  = new FormAttachment(0, 0);\r\n\t\tfdlMultiline.top   = new FormAttachment(wDotAll, margin);\r\n\t\tfdlMultiline.right = new FormAttachment(middle, -margin);\r\n\t\twlMultiline.setLayoutData(fdlMultiline);\r\n\t\twMultiline=new Button(wRegexSettings, SWT.CHECK);\r\n\t\twMultiline.setToolTipText(BaseMessages.getString(PKG, \"RegexEvalDialog.Multiline.Tooltip\"));\r\n \t\tprops.setLook(wMultiline);\r\n\t\tfdMultiline=new FormData();\r\n\t\tfdMultiline.left  = new FormAttachment(middle, 0);\r\n\t\tfdMultiline.top   = new FormAttachment(wDotAll, margin);\r\n\t\tfdMultiline.right = new FormAttachment(100, 0);\r\n\t\twMultiline.setLayoutData(fdMultiline);\r\n\t\twMultiline.addSelectionListener(lsSel);\r\n\t\t\r\n\t\t// UNICODE?\r\n\t\twlUnicode=new Label(wRegexSettings, SWT.RIGHT);\r\n\t\twlUnicode.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.Unicode.Label\"));\r\n \t\tprops.setLook(wlUnicode);\r\n\t\tfdlUnicode=new FormData();\r\n\t\tfdlUnicode.left  = new FormAttachment(0, 0);\r\n\t\tfdlUnicode.top   = new FormAttachment(wMultiline, margin);\r\n\t\tfdlUnicode.right = new FormAttachment(middle, -margin);\r\n\t\twlUnicode.setLayoutData(fdlUnicode);\r\n\t\twUnicode=new Button(wRegexSettings, SWT.CHECK);\r\n\t\twUnicode.setToolTipText(BaseMessages.getString(PKG, \"RegexEvalDialog.Unicode.Tooltip\"));\r\n \t\tprops.setLook(wUnicode);\r\n\t\tfdUnicode=new FormData();\r\n\t\tfdUnicode.left  = new FormAttachment(middle, 0);\r\n\t\tfdUnicode.top   = new FormAttachment(wMultiline, margin);\r\n\t\tfdUnicode.right = new FormAttachment(100, 0);\r\n\t\twUnicode.setLayoutData(fdUnicode);\r\n\t\twUnicode.addSelectionListener(lsSel);\r\n\t\t\r\n\t\t// UNIX?\r\n\t\twlUnix=new Label(wRegexSettings, SWT.RIGHT);\r\n\t\twlUnix.setText(BaseMessages.getString(PKG, \"RegexEvalDialog.Unix.Label\"));\r\n \t\tprops.setLook(wlUnix);\r\n\t\tfdlUnix=new FormData();\r\n\t\tfdlUnix.left  = new FormAttachment(0, 0);\r\n\t\tfdlUnix.top   = new FormAttachment(wUnicode, margin);\r\n\t\tfdlUnix.right = new FormAttachment(middle, -margin);\r\n\t\twlUnix.setLayoutData(fdlUnix);\r\n\t\twUnix=new Button(wRegexSettings, SWT.CHECK);\r\n\t\twUnix.setToolTipText(BaseMessages.getString(PKG, \"RegexEvalDialog.Unix.Tooltip\"));\r\n \t\tprops.setLook(wUnix);\r\n\t\tfdUnix=new FormData();\r\n\t\tfdUnix.left  = new FormAttachment(middle, 0);\r\n\t\tfdUnix.top   = new FormAttachment(wUnicode, margin);\r\n\t\tfdUnix.right = new FormAttachment(100, 0);\r\n\t\twUnix.setLayoutData(fdUnix);\r\n\t\twUnix.addSelectionListener(lsSel);\r\n\r\n\t\t\r\n\t \tfdRegexSettings = new FormData();\r\n\t\tfdRegexSettings.left = new FormAttachment(0, margin);\r\n\t\tfdRegexSettings.top = new FormAttachment(wStepSettings, margin);\r\n\t\tfdRegexSettings.right = new FormAttachment(100, -margin);\r\n\t\twRegexSettings.setLayoutData(fdRegexSettings);\r\n\t\t\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\t\t// / END OF RegexSettings GROUP\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\t\t\r\n \t\t\r\n \t\t\r\n \t\tfdContentComp = new FormData();\r\n \t\tfdContentComp.left  = new FormAttachment(0, 0);\r\n \t\tfdContentComp.top   = new FormAttachment(0, 0);\r\n \t\tfdContentComp.right = new FormAttachment(100, 0);\r\n \t\tfdContentComp.bottom= new FormAttachment(100, 0);\r\n \t\twContentComp.setLayoutData(wContentComp);\r\n\r\n\t\twContentComp.layout();\r\n\t\twContentTab.setControl(wContentComp);\r\n\r\n\r\n\t\t/////////////////////////////////////////////////////////////\r\n\t\t/// END OF CONTENT TAB\r\n\t\t/////////////////////////////////////////////////////////////\r\n\t\t\r\n\t\tfdTabFolder = new FormData();\r\n\t\tfdTabFolder.left  = new FormAttachment(0, 0);\r\n\t\tfdTabFolder.top   = new FormAttachment(wStepname, margin);\r\n\t\tfdTabFolder.right = new FormAttachment(100, 0);\r\n\t\tfdTabFolder.bottom= new FormAttachment(100, -50);\r\n\t\twTabFolder.setLayoutData(fdTabFolder);\r\n\r\n\t\tfdBottom=new FormData();\r\n\t\tfdBottom.left  = new FormAttachment(0, 0);\r\n\t\tfdBottom.top   = new FormAttachment(0, 0);\r\n\t\tfdBottom.right = new FormAttachment(100, 0);\r\n\t\tfdBottom.bottom= new FormAttachment(100, 0);\r\n\t\twBottom.setLayoutData(fdBottom);\r\n\r\n\t\tfdSash = new FormData();\r\n\t\tfdSash.left  = new FormAttachment(0, 0);\r\n\t\tfdSash.top   = new FormAttachment(wStepname, 0);\r\n\t\tfdSash.right = new FormAttachment(100, 0);\r\n\t\tfdSash.bottom= new FormAttachment(100, -50);\r\n\t\twSash.setLayoutData(fdSash);\r\n\t\t\r\n\t\twSash.setWeights(new int[] {60,40});\r\n\r\n\t\twOK=new Button(shell, SWT.PUSH);\r\n\t\twOK.setText(BaseMessages.getString(PKG, \"System.Button.OK\")); //$NON-NLS-1$\r\n\r\n\t\twCancel=new Button(shell, SWT.PUSH);\r\n\t\twCancel.setText(BaseMessages.getString(PKG, \"System.Button.Cancel\")); //$NON-NLS-1$\r\n\r\n\t\tlsbTestRegExScript   = new Listener() { public void handleEvent(Event e) {testRegExScript();  } };\r\n\t\twbTestRegExScript.addListener  (SWT.Selection, lsbTestRegExScript);\r\n\t\t\r\n\t\tsetButtonPositions(new Button[] { wOK, wCancel }, margin, null);\r\n\r\n\r\n\t\t// Add listeners\r\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel();          } };\r\n\t\t\r\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();              } };\r\n\t\t\r\n\t\twCancel.addListener(SWT.Selection, lsCancel);\r\n\r\n\r\n\t\twOK.addListener    (SWT.Selection, lsOK    );\r\n\t\t\r\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\r\n\t\t\r\n\t\twStepname.addSelectionListener( lsDef );\r\n\t\t\t\t\r\n\t\twTabFolder.setSelection(0);\r\n\t\t\r\n\t\t// Set the shell size, based upon previous time...\r\n\t\tsetSize();\r\n\t\t\r\n\t\tgetData();\r\n\t\t\r\n\t\tsetFieldsEnabledStatus();\r\n\t\t\r\n\t\tinput.setChanged(changed);\r\n\t\r\n\t\tshell.open();\r\n\t\twhile (!shell.isDisposed())\r\n\t\t{\r\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\r\n\t\t}\r\n\t\treturn stepname;\r\n\t}","commit_id":"03b2363e3e64157aa59cd3f782aad57e5cce8dc9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getXML()\r\n    {\r\n        StringBuilder retval = new StringBuilder();\r\n\r\n        retval.append(\"    \" + XMLHandler.openTag(\"script\") + XMLHandler.buildCDATA(script) + XMLHandler.closeTag(\"script\")); //$NON-NLS-1$ //$NON-NLS-2$\r\n        retval.append(\"    \" + XMLHandler.addTagValue(\"matcher\", matcher)); //$NON-NLS-1$ //$NON-NLS-2$\r\n        retval.append(\"    \" + XMLHandler.addTagValue(\"resultfieldname\", resultfieldname)); //$NON-NLS-1$ //$NON-NLS-2$\r\n        retval.append(\"    \" + XMLHandler.addTagValue(\"usevar\", usevar));\r\n        retval.append(\"    \" + XMLHandler.addTagValue(\"allowcapturegroups\", allowcapturegroups));\r\n        retval.append(\"    \" + XMLHandler.addTagValue(\"canoneq\", canoneq));\r\n        retval.append(\"    \" + XMLHandler.addTagValue(\"caseinsensitive\", caseinsensitive));\r\n        retval.append(\"    \" + XMLHandler.addTagValue(\"comment\", comment));\r\n        retval.append(\"    \" + XMLHandler.addTagValue(\"dotall\", dotall));\r\n        retval.append(\"    \" + XMLHandler.addTagValue(\"multiline\", multiline));\r\n        retval.append(\"    \" + XMLHandler.addTagValue(\"unicode\", unicode));\r\n        retval.append(\"    \" + XMLHandler.addTagValue(\"unix\", unix));\r\n\r\n        retval.append(\"    <fields>\").append(Const.CR);\r\n        for (int i = 0; i < fieldName.length; i++)\r\n        {\r\n            if (fieldName[i] != null && fieldName[i].length() != 0)\r\n            {\r\n                retval.append(\"      <field>\").append(Const.CR);\r\n                retval.append(\"        \").append(XMLHandler.addTagValue(\"name\", fieldName[i]));\r\n                retval.append(\"        \").append(XMLHandler.addTagValue(\"type\", ValueMeta.getTypeDesc(fieldType[i]))); //$NON-NLS-1$ //$NON-NLS-2$\r\n                retval.append(\"        \").append(XMLHandler.addTagValue(\"format\", fieldFormat[i]));\r\n                retval.append(\"        \").append(XMLHandler.addTagValue(\"group\", fieldGroup[i])); //$NON-NLS-1$ //$NON-NLS-2$\r\n                retval.append(\"        \").append(XMLHandler.addTagValue(\"decimal\", fieldDecimal[i])); //$NON-NLS-1$ //$NON-NLS-2$\r\n                retval.append(\"        \").append(XMLHandler.addTagValue(\"length\", fieldLength[i])); //$NON-NLS-1$ //$NON-NLS-2$\r\n                retval.append(\"        \").append(XMLHandler.addTagValue(\"precision\", fieldPrecision[i])); //$NON-NLS-1$ //$NON-NLS-2$\r\n                retval.append(\"        \").append(XMLHandler.addTagValue(\"nullif\", fieldNullIf[i])); //$NON-NLS-1$ //$NON-NLS-2$\r\n                retval.append(\"        \").append(XMLHandler.addTagValue(\"ifnull\", fieldIfNull[i])); //$NON-NLS-1$ //$NON-NLS-2$\r\n                retval\r\n                        .append(\"        \").append(XMLHandler.addTagValue(\"trimtype\", ValueMeta.getTrimTypeCode(fieldTrimType[i]))); //$NON-NLS-1$ //$NON-NLS-2$\r\n                retval.append(\"      <\/field>\").append(Const.CR);\r\n            }\r\n        }\r\n        retval.append(\"    <\/fields>\").append(Const.CR);\r\n\r\n        return retval.toString();\r\n    }","id":75676,"modified_method":"public String getXML()\r\n    {\r\n        StringBuilder retval = new StringBuilder();\r\n\r\n        retval.append(\"    \" + XMLHandler.openTag(\"script\") + XMLHandler.buildCDATA(script) + XMLHandler.closeTag(\"script\")); //$NON-NLS-1$ //$NON-NLS-2$\r\n        retval.append(\"    \" + XMLHandler.addTagValue(\"matcher\", matcher)); //$NON-NLS-1$ //$NON-NLS-2$\r\n        retval.append(\"    \" + XMLHandler.addTagValue(\"resultfieldname\", resultfieldname)); //$NON-NLS-1$ //$NON-NLS-2$\r\n        retval.append(\"    \" + XMLHandler.addTagValue(\"usevar\", usevar));\r\n        retval.append(\"    \" + XMLHandler.addTagValue(\"allowcapturegroups\", allowcapturegroups));\r\n        retval.append(\"    \" + XMLHandler.addTagValue(\"replacefields\", replacefields));\r\n        retval.append(\"    \" + XMLHandler.addTagValue(\"canoneq\", canoneq));\r\n        retval.append(\"    \" + XMLHandler.addTagValue(\"caseinsensitive\", caseinsensitive));\r\n        retval.append(\"    \" + XMLHandler.addTagValue(\"comment\", comment));\r\n        retval.append(\"    \" + XMLHandler.addTagValue(\"dotall\", dotall));\r\n        retval.append(\"    \" + XMLHandler.addTagValue(\"multiline\", multiline));\r\n        retval.append(\"    \" + XMLHandler.addTagValue(\"unicode\", unicode));\r\n        retval.append(\"    \" + XMLHandler.addTagValue(\"unix\", unix));\r\n\r\n        retval.append(\"    <fields>\").append(Const.CR);\r\n        for (int i = 0; i < fieldName.length; i++)\r\n        {\r\n            if (fieldName[i] != null && fieldName[i].length() != 0)\r\n            {\r\n                retval.append(\"      <field>\").append(Const.CR);\r\n                retval.append(\"        \").append(XMLHandler.addTagValue(\"name\", fieldName[i]));\r\n                retval.append(\"        \").append(XMLHandler.addTagValue(\"type\", ValueMeta.getTypeDesc(fieldType[i]))); //$NON-NLS-1$ //$NON-NLS-2$\r\n                retval.append(\"        \").append(XMLHandler.addTagValue(\"format\", fieldFormat[i]));\r\n                retval.append(\"        \").append(XMLHandler.addTagValue(\"group\", fieldGroup[i])); //$NON-NLS-1$ //$NON-NLS-2$\r\n                retval.append(\"        \").append(XMLHandler.addTagValue(\"decimal\", fieldDecimal[i])); //$NON-NLS-1$ //$NON-NLS-2$\r\n                retval.append(\"        \").append(XMLHandler.addTagValue(\"length\", fieldLength[i])); //$NON-NLS-1$ //$NON-NLS-2$\r\n                retval.append(\"        \").append(XMLHandler.addTagValue(\"precision\", fieldPrecision[i])); //$NON-NLS-1$ //$NON-NLS-2$\r\n                retval.append(\"        \").append(XMLHandler.addTagValue(\"nullif\", fieldNullIf[i])); //$NON-NLS-1$ //$NON-NLS-2$\r\n                retval.append(\"        \").append(XMLHandler.addTagValue(\"ifnull\", fieldIfNull[i])); //$NON-NLS-1$ //$NON-NLS-2$\r\n                retval\r\n                        .append(\"        \").append(XMLHandler.addTagValue(\"trimtype\", ValueMeta.getTrimTypeCode(fieldTrimType[i]))); //$NON-NLS-1$ //$NON-NLS-2$\r\n                retval.append(\"      <\/field>\").append(Const.CR);\r\n            }\r\n        }\r\n        retval.append(\"    <\/fields>\").append(Const.CR);\r\n\r\n        return retval.toString();\r\n    }","commit_id":"03b2363e3e64157aa59cd3f782aad57e5cce8dc9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void readRep(Repository rep, ObjectId id_step, List<DatabaseMeta> databases, Map<String, Counter> counters)\r\n            throws KettleException\r\n\r\n    {\r\n        try\r\n        {\r\n            script = rep.getStepAttributeString(id_step, \"script\"); //$NON-NLS-1$\r\n            matcher = rep.getStepAttributeString(id_step, \"matcher\"); //$NON-NLS-1$\r\n            resultfieldname = rep.getStepAttributeString(id_step, \"resultfieldname\"); //$NON-NLS-1$\r\n            usevar = rep.getStepAttributeBoolean(id_step, \"usevar\");\r\n            allowcapturegroups = rep.getStepAttributeBoolean(id_step, \"allowcapturegroups\");\r\n            canoneq = rep.getStepAttributeBoolean(id_step, \"canoneq\");\r\n            caseinsensitive = rep.getStepAttributeBoolean(id_step, \"caseinsensitive\");\r\n            comment = rep.getStepAttributeBoolean(id_step, \"comment\");\r\n            multiline = rep.getStepAttributeBoolean(id_step, \"multiline\");\r\n            dotall = rep.getStepAttributeBoolean(id_step, \"dotall\");\r\n            unicode = rep.getStepAttributeBoolean(id_step, \"unicode\");\r\n            unix = rep.getStepAttributeBoolean(id_step, \"unix\");\r\n\r\n            int nrfields = rep.countNrStepAttributes(id_step, \"field_name\");\r\n\r\n            allocate(nrfields);\r\n\r\n            for (int i = 0; i < nrfields; i++)\r\n            {\r\n                fieldName[i] = rep.getStepAttributeString(id_step, i, \"field_name\");\r\n                fieldType[i] = ValueMeta.getType(rep.getStepAttributeString(id_step, i, \"field_type\"));\r\n\r\n                fieldFormat[i] = rep.getStepAttributeString(id_step, i, \"field_format\");\r\n                fieldGroup[i] = rep.getStepAttributeString(id_step, i, \"field_group\"); //$NON-NLS-1$\r\n                fieldDecimal[i] = rep.getStepAttributeString(id_step, i, \"field_decimal\"); //$NON-NLS-1$\r\n                fieldLength[i] = (int) rep.getStepAttributeInteger(id_step, i, \"field_length\"); //$NON-NLS-1$\r\n                fieldPrecision[i] = (int) rep.getStepAttributeInteger(id_step, i, \"field_precision\"); //$NON-NLS-1$\r\n                fieldNullIf[i] = rep.getStepAttributeString(id_step, i, \"field_nullif\"); //$NON-NLS-1$\r\n                fieldIfNull[i] = rep.getStepAttributeString(id_step, i, \"field_ifnull\"); //$NON-NLS-1$\r\n                fieldTrimType[i] = ValueMeta.getTrimTypeByCode(rep.getStepAttributeString(id_step, i, \"field_trimtype\"));  //$NON-NLS-1$\r\n            }\r\n        }\r\n        catch (Exception e)\r\n        {\r\n            throw new KettleException(\r\n                    BaseMessages.getString(PKG, \"RegexEvalMeta.Exception.UnexpectedErrorInReadingStepInfo\"), e); //$NON-NLS-1$\r\n        }\r\n    }","id":75677,"modified_method":"public void readRep(Repository rep, ObjectId id_step, List<DatabaseMeta> databases, Map<String, Counter> counters)\r\n            throws KettleException\r\n\r\n    {\r\n        try\r\n        {\r\n            script = rep.getStepAttributeString(id_step, \"script\"); //$NON-NLS-1$\r\n            matcher = rep.getStepAttributeString(id_step, \"matcher\"); //$NON-NLS-1$\r\n            resultfieldname = rep.getStepAttributeString(id_step, \"resultfieldname\"); //$NON-NLS-1$\r\n            usevar = rep.getStepAttributeBoolean(id_step, \"usevar\");\r\n            allowcapturegroups = rep.getStepAttributeBoolean(id_step, \"allowcapturegroups\");\r\n            replacefields = rep.getStepAttributeBoolean(id_step, \"replacefields\");\r\n            canoneq = rep.getStepAttributeBoolean(id_step, \"canoneq\");\r\n            caseinsensitive = rep.getStepAttributeBoolean(id_step, \"caseinsensitive\");\r\n            comment = rep.getStepAttributeBoolean(id_step, \"comment\");\r\n            multiline = rep.getStepAttributeBoolean(id_step, \"multiline\");\r\n            dotall = rep.getStepAttributeBoolean(id_step, \"dotall\");\r\n            unicode = rep.getStepAttributeBoolean(id_step, \"unicode\");\r\n            unix = rep.getStepAttributeBoolean(id_step, \"unix\");\r\n\r\n            int nrfields = rep.countNrStepAttributes(id_step, \"field_name\");\r\n\r\n            allocate(nrfields);\r\n\r\n            for (int i = 0; i < nrfields; i++)\r\n            {\r\n                fieldName[i] = rep.getStepAttributeString(id_step, i, \"field_name\");\r\n                fieldType[i] = ValueMeta.getType(rep.getStepAttributeString(id_step, i, \"field_type\"));\r\n\r\n                fieldFormat[i] = rep.getStepAttributeString(id_step, i, \"field_format\");\r\n                fieldGroup[i] = rep.getStepAttributeString(id_step, i, \"field_group\"); //$NON-NLS-1$\r\n                fieldDecimal[i] = rep.getStepAttributeString(id_step, i, \"field_decimal\"); //$NON-NLS-1$\r\n                fieldLength[i] = (int) rep.getStepAttributeInteger(id_step, i, \"field_length\"); //$NON-NLS-1$\r\n                fieldPrecision[i] = (int) rep.getStepAttributeInteger(id_step, i, \"field_precision\"); //$NON-NLS-1$\r\n                fieldNullIf[i] = rep.getStepAttributeString(id_step, i, \"field_nullif\"); //$NON-NLS-1$\r\n                fieldIfNull[i] = rep.getStepAttributeString(id_step, i, \"field_ifnull\"); //$NON-NLS-1$\r\n                fieldTrimType[i] = ValueMeta.getTrimTypeByCode(rep.getStepAttributeString(id_step, i, \"field_trimtype\"));  //$NON-NLS-1$\r\n            }\r\n        }\r\n        catch (Exception e)\r\n        {\r\n            throw new KettleException(\r\n                    BaseMessages.getString(PKG, \"RegexEvalMeta.Exception.UnexpectedErrorInReadingStepInfo\"), e); //$NON-NLS-1$\r\n        }\r\n    }","commit_id":"03b2363e3e64157aa59cd3f782aad57e5cce8dc9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void saveRep(Repository rep, ObjectId id_transformation, ObjectId id_step) throws KettleException\r\n    {\r\n        try\r\n        {\r\n            rep.saveStepAttribute(id_transformation, id_step, \"script\", script); //$NON-NLS-1$\r\n            for (int i = 0; i < fieldName.length; i++)\r\n            {\r\n                if (fieldName[i] != null && fieldName[i].length() != 0)\r\n                {\r\n                    rep.saveStepAttribute(id_transformation, id_step, i, \"field_name\", fieldName[i]);\r\n                    rep.saveStepAttribute(id_transformation, id_step, i,\r\n                            \"field_type\", ValueMeta.getTypeDesc(fieldType[i])); //$NON-NLS-1$\r\n                    rep.saveStepAttribute(id_transformation, id_step, i, \"field_format\", fieldFormat[i]); //$NON-NLS-1$\r\n                    rep.saveStepAttribute(id_transformation, id_step, i, \"field_group\", fieldGroup[i]); //$NON-NLS-1$\r\n                    rep.saveStepAttribute(id_transformation, id_step, i, \"field_decimal\", fieldDecimal[i]); //$NON-NLS-1$\r\n                    rep.saveStepAttribute(id_transformation, id_step, i, \"field_length\", fieldLength[i]); //$NON-NLS-1$\r\n                    rep.saveStepAttribute(id_transformation, id_step, i, \"field_precision\", fieldPrecision[i]); //$NON-NLS-1$\r\n                    rep.saveStepAttribute(id_transformation, id_step, i, \"field_nullif\", fieldNullIf[i]); //$NON-NLS-1$\r\n                    rep.saveStepAttribute(id_transformation, id_step, i, \"field_ifnull\", fieldIfNull[i]); //$NON-NLS-1$\r\n                    rep.saveStepAttribute(id_transformation, id_step, i,\r\n                            \"field_trimtype\", ValueMeta.getTrimTypeCode(fieldTrimType[i])); //$NON-NLS-1$\r\n                }\r\n            }\r\n\r\n            rep.saveStepAttribute(id_transformation, id_step, \"resultfieldname\", resultfieldname); //$NON-NLS-1$\r\n            rep.saveStepAttribute(id_transformation, id_step, \"usevar\", usevar);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"allowcapturegroups\", allowcapturegroups);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"canoneq\", canoneq);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"caseinsensitive\", caseinsensitive);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"comment\", comment);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"dotall\", dotall);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"multiline\", multiline);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"unicode\", unicode);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"unix\", unix);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"matcher\", matcher);\r\n        }\r\n        catch (Exception e)\r\n        {\r\n            throw new KettleException(\r\n                    BaseMessages.getString(PKG, \"RegexEvalMeta.Exception.UnableToSaveStepInfo\") + id_step, e); //$NON-NLS-1$\r\n        }\r\n    }","id":75678,"modified_method":"public void saveRep(Repository rep, ObjectId id_transformation, ObjectId id_step) throws KettleException\r\n    {\r\n        try\r\n        {\r\n            rep.saveStepAttribute(id_transformation, id_step, \"script\", script); //$NON-NLS-1$\r\n            for (int i = 0; i < fieldName.length; i++)\r\n            {\r\n                if (fieldName[i] != null && fieldName[i].length() != 0)\r\n                {\r\n                    rep.saveStepAttribute(id_transformation, id_step, i, \"field_name\", fieldName[i]);\r\n                    rep.saveStepAttribute(id_transformation, id_step, i,\r\n                            \"field_type\", ValueMeta.getTypeDesc(fieldType[i])); //$NON-NLS-1$\r\n                    rep.saveStepAttribute(id_transformation, id_step, i, \"field_format\", fieldFormat[i]); //$NON-NLS-1$\r\n                    rep.saveStepAttribute(id_transformation, id_step, i, \"field_group\", fieldGroup[i]); //$NON-NLS-1$\r\n                    rep.saveStepAttribute(id_transformation, id_step, i, \"field_decimal\", fieldDecimal[i]); //$NON-NLS-1$\r\n                    rep.saveStepAttribute(id_transformation, id_step, i, \"field_length\", fieldLength[i]); //$NON-NLS-1$\r\n                    rep.saveStepAttribute(id_transformation, id_step, i, \"field_precision\", fieldPrecision[i]); //$NON-NLS-1$\r\n                    rep.saveStepAttribute(id_transformation, id_step, i, \"field_nullif\", fieldNullIf[i]); //$NON-NLS-1$\r\n                    rep.saveStepAttribute(id_transformation, id_step, i, \"field_ifnull\", fieldIfNull[i]); //$NON-NLS-1$\r\n                    rep.saveStepAttribute(id_transformation, id_step, i,\r\n                            \"field_trimtype\", ValueMeta.getTrimTypeCode(fieldTrimType[i])); //$NON-NLS-1$\r\n                }\r\n            }\r\n\r\n            rep.saveStepAttribute(id_transformation, id_step, \"resultfieldname\", resultfieldname); //$NON-NLS-1$\r\n            rep.saveStepAttribute(id_transformation, id_step, \"usevar\", usevar);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"allowcapturegroups\", allowcapturegroups);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"replacefields\", replacefields);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"canoneq\", canoneq);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"caseinsensitive\", caseinsensitive);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"comment\", comment);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"dotall\", dotall);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"multiline\", multiline);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"unicode\", unicode);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"unix\", unix);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"matcher\", matcher);\r\n        }\r\n        catch (Exception e)\r\n        {\r\n            throw new KettleException(\r\n                    BaseMessages.getString(PKG, \"RegexEvalMeta.Exception.UnableToSaveStepInfo\") + id_step, e); //$NON-NLS-1$\r\n        }\r\n    }","commit_id":"03b2363e3e64157aa59cd3f782aad57e5cce8dc9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void setDefault()\r\n    {\r\n        script = \"\"; //$NON-NLS-1$\r\n        matcher = \"\";\r\n        resultfieldname = \"result\";\r\n        usevar = false;\r\n        allowcapturegroups = false;\r\n        canoneq = false;\r\n        caseinsensitive = false;\r\n        comment = false;\r\n        dotall = false;\r\n        multiline = false;\r\n        unicode = false;\r\n        unix = false;\r\n\r\n        allocate(0);\r\n    }","id":75679,"modified_method":"public void setDefault()\r\n    {\r\n        script = \"\"; //$NON-NLS-1$\r\n        matcher = \"\";\r\n        resultfieldname = \"result\";\r\n        usevar = false;\r\n        allowcapturegroups = false;\r\n        replacefields = true;\r\n        canoneq = false;\r\n        caseinsensitive = false;\r\n        comment = false;\r\n        dotall = false;\r\n        multiline = false;\r\n        unicode = false;\r\n        unix = false;\r\n\r\n        allocate(0);\r\n    }","commit_id":"03b2363e3e64157aa59cd3f782aad57e5cce8dc9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void readData(Node stepnode, List<? extends SharedObjectInterface> databases) throws KettleXMLException\r\n    {\r\n        try\r\n        {\r\n            script = XMLHandler.getTagValue(stepnode, \"script\"); //$NON-NLS-1$\r\n            matcher = XMLHandler.getTagValue(stepnode, \"matcher\"); //$NON-NLS-1$\r\n            resultfieldname = XMLHandler.getTagValue(stepnode, \"resultfieldname\"); //$NON-NLS-1$\r\n            usevar = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"usevar\"));\r\n            allowcapturegroups = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"allowcapturegroups\"));\r\n            canoneq = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"canoneq\"));\r\n            caseinsensitive = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"caseinsensitive\"));\r\n            comment = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"comment\"));\r\n            dotall = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"dotall\"));\r\n            multiline = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"multiline\"));\r\n            unicode = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"unicode\"));\r\n            unix = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"unix\"));\r\n\r\n            Node fields = XMLHandler.getSubNode(stepnode, \"fields\"); //$NON-NLS-1$\r\n            int nrfields = XMLHandler.countNodes(fields, \"field\"); //$NON-NLS-1$\r\n\r\n            allocate(nrfields);\r\n\r\n            for (int i = 0; i < nrfields; i++)\r\n            {\r\n                Node fnode = XMLHandler.getSubNodeByNr(fields, \"field\", i); //$NON-NLS-1$\r\n\r\n                fieldName[i] = XMLHandler.getTagValue(fnode, \"name\"); //$NON-NLS-1$\r\n                final String stype = XMLHandler.getTagValue(fnode, \"type\"); //$NON-NLS-1$\r\n                fieldFormat[i] = XMLHandler.getTagValue(fnode, \"format\"); //$NON-NLS-1$\r\n                fieldGroup[i] = XMLHandler.getTagValue(fnode, \"group\"); //$NON-NLS-1$\r\n                fieldDecimal[i] = XMLHandler.getTagValue(fnode, \"decimal\"); //$NON-NLS-1$\r\n                fieldCurrency[i] = XMLHandler.getTagValue(fnode, \"currency\"); //$NON-NLS-1$\r\n                final String slen = XMLHandler.getTagValue(fnode, \"length\"); //$NON-NLS-1$\r\n                final String sprc = XMLHandler.getTagValue(fnode, \"precision\"); //$NON-NLS-1$\r\n                fieldNullIf[i] = XMLHandler.getTagValue(fnode, \"nullif\"); //$NON-NLS-1$\r\n                fieldIfNull[i] = XMLHandler.getTagValue(fnode, \"ifnull\"); //$NON-NLS-1$\r\n                final String trim = XMLHandler.getTagValue(fnode, \"trimtype\"); //$NON-NLS-1$\r\n                fieldType[i] = ValueMeta.getType(stype);\r\n                fieldLength[i] = Const.toInt(slen, -1);\r\n                fieldPrecision[i] = Const.toInt(sprc, -1);\r\n                fieldTrimType[i] = ValueMeta.getTrimTypeByCode(trim);\r\n            }\r\n        }\r\n        catch (Exception e)\r\n        {\r\n            throw new KettleXMLException(\r\n                    BaseMessages.getString(PKG, \"RegexEvalMeta.Exception.UnableToLoadStepInfoFromXML\"), e); //$NON-NLS-1$\r\n        }\r\n    }","id":75680,"modified_method":"private void readData(Node stepnode, List<? extends SharedObjectInterface> databases) throws KettleXMLException\r\n    {\r\n        try\r\n        {\r\n            script = XMLHandler.getTagValue(stepnode, \"script\"); //$NON-NLS-1$\r\n            matcher = XMLHandler.getTagValue(stepnode, \"matcher\"); //$NON-NLS-1$\r\n            resultfieldname = XMLHandler.getTagValue(stepnode, \"resultfieldname\"); //$NON-NLS-1$\r\n            usevar = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"usevar\"));\r\n            allowcapturegroups = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"allowcapturegroups\"));\r\n            replacefields = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"replacefields\"));\r\n            canoneq = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"canoneq\"));\r\n            caseinsensitive = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"caseinsensitive\"));\r\n            comment = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"comment\"));\r\n            dotall = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"dotall\"));\r\n            multiline = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"multiline\"));\r\n            unicode = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"unicode\"));\r\n            unix = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"unix\"));\r\n\r\n            Node fields = XMLHandler.getSubNode(stepnode, \"fields\"); //$NON-NLS-1$\r\n            int nrfields = XMLHandler.countNodes(fields, \"field\"); //$NON-NLS-1$\r\n\r\n            allocate(nrfields);\r\n\r\n            for (int i = 0; i < nrfields; i++)\r\n            {\r\n                Node fnode = XMLHandler.getSubNodeByNr(fields, \"field\", i); //$NON-NLS-1$\r\n\r\n                fieldName[i] = XMLHandler.getTagValue(fnode, \"name\"); //$NON-NLS-1$\r\n                final String stype = XMLHandler.getTagValue(fnode, \"type\"); //$NON-NLS-1$\r\n                fieldFormat[i] = XMLHandler.getTagValue(fnode, \"format\"); //$NON-NLS-1$\r\n                fieldGroup[i] = XMLHandler.getTagValue(fnode, \"group\"); //$NON-NLS-1$\r\n                fieldDecimal[i] = XMLHandler.getTagValue(fnode, \"decimal\"); //$NON-NLS-1$\r\n                fieldCurrency[i] = XMLHandler.getTagValue(fnode, \"currency\"); //$NON-NLS-1$\r\n                final String slen = XMLHandler.getTagValue(fnode, \"length\"); //$NON-NLS-1$\r\n                final String sprc = XMLHandler.getTagValue(fnode, \"precision\"); //$NON-NLS-1$\r\n                fieldNullIf[i] = XMLHandler.getTagValue(fnode, \"nullif\"); //$NON-NLS-1$\r\n                fieldIfNull[i] = XMLHandler.getTagValue(fnode, \"ifnull\"); //$NON-NLS-1$\r\n                final String trim = XMLHandler.getTagValue(fnode, \"trimtype\"); //$NON-NLS-1$\r\n                fieldType[i] = ValueMeta.getType(stype);\r\n                fieldLength[i] = Const.toInt(slen, -1);\r\n                fieldPrecision[i] = Const.toInt(sprc, -1);\r\n                fieldTrimType[i] = ValueMeta.getTrimTypeByCode(trim);\r\n            }\r\n        }\r\n        catch (Exception e)\r\n        {\r\n            throw new KettleXMLException(\r\n                    BaseMessages.getString(PKG, \"RegexEvalMeta.Exception.UnableToLoadStepInfoFromXML\"), e); //$NON-NLS-1$\r\n        }\r\n    }","commit_id":"03b2363e3e64157aa59cd3f782aad57e5cce8dc9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void getFields(RowMetaInterface inputRowMeta, String name, RowMetaInterface info[], StepMeta nextStep,\r\n            VariableSpace space) throws KettleStepException\r\n    {\r\n        if (!Const.isEmpty(resultfieldname))\r\n        {\r\n            ValueMetaInterface v = new ValueMeta(space.environmentSubstitute(resultfieldname), ValueMeta.TYPE_BOOLEAN);\r\n            v.setOrigin(name);\r\n            inputRowMeta.addValueMeta(v);\r\n        }\r\n        \r\n        if (allowcapturegroups == true)\r\n        {\r\n            for (int i = 0; i < fieldName.length; i++)\r\n            {\r\n                if (fieldName[i] != null && fieldName[i].length() != 0)\r\n                {\r\n                    int type = fieldType[i];\r\n                    if (type == ValueMetaInterface.TYPE_NONE) type = ValueMetaInterface.TYPE_STRING;\r\n                    ValueMetaInterface v = new ValueMeta(fieldName[i], type);\r\n                    v.setLength(fieldLength[i]);\r\n                    v.setPrecision(fieldPrecision[i]);\r\n                    v.setOrigin(name);\r\n                    v.setConversionMask(fieldFormat[i]);\r\n                    v.setDecimalSymbol(fieldDecimal[i]);\r\n                    v.setGroupingSymbol(fieldGroup[i]);\r\n                    v.setCurrencySymbol(fieldCurrency[i]);\r\n                    v.setTrimType(fieldTrimType[i]);\r\n                    inputRowMeta.addValueMeta(v);\r\n                }\r\n            }\r\n        }\r\n    }","id":75681,"modified_method":"public void getFields(RowMetaInterface inputRowMeta, String name, RowMetaInterface info[], StepMeta nextStep,\r\n            VariableSpace space) throws KettleStepException\r\n    {\r\n        if (!Const.isEmpty(resultfieldname))\r\n        {\r\n            ValueMetaInterface v = null;\r\n          \r\n        \tif (replacefields){\r\n        \t\tv = inputRowMeta.searchValueMeta(resultfieldname);\r\n        \t}\r\n        \t\r\n        \tif ( v != null ) {\r\n            v.setOrigin(name);\r\n        \t\tv.setType(ValueMeta.TYPE_BOOLEAN);\r\n        \t} else {\r\n            \tv = new ValueMeta(space.environmentSubstitute(resultfieldname), ValueMeta.TYPE_BOOLEAN);\r\n                v.setOrigin(name);\r\n            inputRowMeta.addValueMeta(v);\r\n        }\r\n        }\r\n        \r\n        if (allowcapturegroups == true)\r\n        {\r\n            for (int i = 0; i < fieldName.length; i++)\r\n            {\r\n            \tif ( fieldName[i] == null || fieldName[i].length() == 0)\r\n            \t\tcontinue;\r\n            \t\r\n        \t\tValueMetaInterface v = null;\r\n\r\n            \tif (replacefields){\r\n            \t\tv = inputRowMeta.searchValueMeta(fieldName[i]);\r\n            \t}\r\n        \t\tif ( v != null ){\r\n                   \tsetValueMeta(v, i, name);\r\n        \t\t} else {\r\n                    v = new ValueMeta(fieldName[i]);\r\n                \tsetValueMeta(v, i, name);\r\n                    inputRowMeta.addValueMeta(v);\r\n                }\r\n            }\r\n        }\r\n    }","commit_id":"03b2363e3e64157aa59cd3f782aad57e5cce8dc9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public static Test suite() throws KettleDatabaseException\r\n    {\r\n        createTables();\r\n        \r\n        TestSuite suite = new TestSuite(\"Run performance tests\");\r\n        //$JUnit-BEGIN$\r\n\r\n        suite.addTestSuite(RunTableOutput.class);\r\n        suite.addTestSuite(RunAbort.class);\r\n        suite.addTestSuite(RunAddSequence.class);\r\n        suite.addTestSuite(RunCalculator.class);\r\n        suite.addTestSuite(RunConstant.class);\r\n        suite.addTestSuite(RunFilterRows.class);\r\n        suite.addTestSuite(RunRowGenerator.class);\r\n        suite.addTestSuite(RunSelectValues.class);\r\n        suite.addTestSuite(RunSortRows.class);\r\n        suite.addTestSuite(RunStreamLookup.class);\r\n        suite.addTestSuite(RunSystemData.class);\r\n        suite.addTestSuite(RunTableInput.class);\r\n        suite.addTestSuite(RunTextFileInput.class);\r\n        suite.addTestSuite(RunTextFileOutput.class);\r\n        suite.addTestSuite(RunUniqueRows.class);\r\n        suite.addTestSuite(RunDatabaseLookup.class);\r\n        \r\n        //$JUnit-END$\r\n        return suite;\r\n    }","id":75682,"modified_method":"public static Test suite() throws KettleDatabaseException\r\n    {\r\n        createTables();\r\n        \r\n        TestSuite suite = new TestSuite(\"Run performance tests\");\r\n        //$JUnit-BEGIN$\r\n\r\n        suite.addTestSuite(RunTableOutput.class);\r\n        suite.addTestSuite(RunAbort.class);\r\n        suite.addTestSuite(RunAddSequence.class);\r\n        suite.addTestSuite(RunCalculator.class);\r\n        suite.addTestSuite(RunConstant.class);\r\n        suite.addTestSuite(RunFilterRows.class);\r\n        suite.addTestSuite(RunRowGenerator.class);\r\n        suite.addTestSuite(RunSelectValues.class);\r\n        suite.addTestSuite(RunSortRows.class);\r\n        suite.addTestSuite(RunStreamLookup.class);\r\n        suite.addTestSuite(RunSystemData.class);\r\n        suite.addTestSuite(RunTableInput.class);\r\n        suite.addTestSuite(RunTextFileInput.class);\r\n        suite.addTestSuite(RunTextFileOutput.class);\r\n        suite.addTestSuite(RunUniqueRows.class);\r\n        suite.addTestSuite(RunDatabaseLookup.class);\r\n        suite.addTestSuite(RunDimensionLookup.class);\r\n        \r\n        //$JUnit-END$\r\n        return suite;\r\n    }","commit_id":"c6b90474b254fd4f14153be06dff3f1914a1dd0d","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n     * TODO: Implement it, make it backward compatible.\n     * \n     * @param inputRowMeta\n     * @param outputRowMeta\n     * @param r\n     * @return\n     * @throws KettleValueException\n     */\n    private Object[] calcFields(RowMetaInterface inputRowMeta, Object[] r) throws KettleValueException\n    {\n        // First copy the input data to the new result...\n        Object[] calcData = new Object[data.calcRowMeta.size()];\n        for (int i=0;i<inputRowMeta.size();i++)\n        {\n            calcData[i] = r[i];\n        }\n\n        for (int i=0;i<meta.getCalculation().length;i++)\n        {\n            CalculatorMetaFunction fn = meta.getCalculation()[i];\n            if (!Const.isEmpty(fn.getFieldName()))\n            {\n                // Get the metadata & the data...\n                // ValueMetaInterface metaTarget = data.calcRowMeta.getValueMeta(i);\n                \n                ValueMetaInterface metaA=null;\n                Object dataA=null;\n                \n                if (data.fieldIndexes[i].indexA>=0) \n                {\n                    metaA = data.calcRowMeta.getValueMeta( data.fieldIndexes[i].indexA );\n                    dataA = calcData[ data.fieldIndexes[i].indexA ];\n                }\n\n                ValueMetaInterface metaB=null;\n                Object dataB=null;\n\n                if (data.fieldIndexes[i].indexB>=0) \n                {\n                    metaB = data.calcRowMeta.getValueMeta( data.fieldIndexes[i].indexB );\n                    dataB = calcData[ data.fieldIndexes[i].indexB ];\n                }\n\n                ValueMetaInterface metaC=null;\n                Object dataC=null;\n\n                if (data.fieldIndexes[i].indexC>=0) \n                {\n                    metaC = data.calcRowMeta.getValueMeta( data.fieldIndexes[i].indexC );\n                    dataC = calcData[ data.fieldIndexes[i].indexC ];\n                }\n                \n                // TODO: the data types are those of the first argument field, convert to the target field.\n                // Exceptions: \n                //  - multiply can be string\n                //  - constant is string\n                //  - all date functions except add days/months\n                //  - hex encode / decodes\n                \n                switch(fn.getCalcType())\n                {\n                case CalculatorMetaFunction.CALC_NONE: \n                    break;\n                case CalculatorMetaFunction.CALC_ADD                :  // A + B\n                    {\n                        calcData[inputRowMeta.size()+i] = ValueDataUtil.plus(metaA, dataA, metaB, dataB);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_SUBTRACT           :   // A - B\n                    {\n                        calcData[inputRowMeta.size()+i] = ValueDataUtil.minus(metaA, dataA, metaB, dataB);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_MULTIPLY           :   // A * B\n                    {\n                        calcData[inputRowMeta.size()+i] = ValueDataUtil.multiply(metaA, dataA, metaB, dataB);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_DIVIDE             :   // A / B\n                    {\n                        calcData[inputRowMeta.size()+i] = ValueDataUtil.divide(metaA, dataA, metaB, dataB);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_SQUARE             :   // A * A\n                    {\n                        calcData[inputRowMeta.size()+i] = ValueDataUtil.multiply(metaA, dataA, metaA, dataA);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_SQUARE_ROOT        :   // SQRT( A )\n                    {\n                        calcData[inputRowMeta.size()+i] = ValueDataUtil.sqrt(metaA, dataA);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_PERCENT_1          :   // 100 * A / B \n                    {\n                        calcData[inputRowMeta.size()+i] = ValueDataUtil.percent1(metaA, dataA, metaB, dataB);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_PERCENT_2          :  // A - ( A * B / 100 )\n                    {\n                        calcData[inputRowMeta.size()+i] = ValueDataUtil.percent2(metaA, dataA, metaB, dataB);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_PERCENT_3          :  // A + ( A * B / 100 )\n                    {\n                        calcData[inputRowMeta.size()+i] = ValueDataUtil.percent2(metaA, dataA, metaB, dataB);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_COMBINATION_1      :  // A + B * C\n                    {\n                        calcData[inputRowMeta.size()+i] = ValueDataUtil.combination1(metaA, dataA, metaB, dataB, metaC, dataC);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_COMBINATION_2      :  // SQRT( A*A + B*B )\n                    {\n                        calcData[inputRowMeta.size()+i] = ValueDataUtil.combination2(metaA, dataA, metaB, dataB);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_ROUND_1            :  // ROUND( A )\n                    {\n                        calcData[inputRowMeta.size()+i] = ValueDataUtil.round(metaA, dataA);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_ROUND_2            :  //  ROUND( A , B )\n                    {\n                        calcData[inputRowMeta.size()+i] = ValueDataUtil.round(metaA, dataA, metaB, dataB);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_CONSTANT           : // Set field to constant value...\n                    {\n                        calcData[inputRowMeta.size()+i] = dataA; // A string\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_NVL                : // Replace null values with another value\n                    {\n                        calcData[inputRowMeta.size()+i] = ValueDataUtil.nvl(metaA, dataA, metaB, dataB);\n                    }\n                    break;                    \n                case CalculatorMetaFunction.CALC_ADD_DAYS           : // Add B days to date field A\n                    {\n                        calcData[inputRowMeta.size()+i] = ValueDataUtil.addDays(metaA, dataA, metaB, dataB);\n                    }\n                    break;\n               case CalculatorMetaFunction.CALC_YEAR_OF_DATE           : // What is the year (Integer) of a date?\n                    {\n                        calcData[inputRowMeta.size()+i] = ValueDataUtil.yearOfDate(metaA, dataA);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_MONTH_OF_DATE           : // What is the month (Integer) of a date?\n                    {\n                        calcData[inputRowMeta.size()+i] = ValueDataUtil.monthOfDate(metaA, dataA);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_DAY_OF_YEAR           : // What is the day of year (Integer) of a date?\n                    {\n                        calcData[inputRowMeta.size()+i] = ValueDataUtil.dayOfYear(metaA, dataA);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_DAY_OF_MONTH           : // What is the day of month (Integer) of a date?\n                    {\n                        calcData[inputRowMeta.size()+i] = ValueDataUtil.dayOfMonth(metaA, dataA);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_DAY_OF_WEEK           : // What is the day of week (Integer) of a date?\n                    {\n                        calcData[inputRowMeta.size()+i] = ValueDataUtil.dayOfWeek(metaA, dataA);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_WEEK_OF_YEAR    : // What is the week of year (Integer) of a date?\n                    {\n                        calcData[inputRowMeta.size()+i] = ValueDataUtil.weekOfYear(metaA, dataA);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_WEEK_OF_YEAR_ISO8601   : // What is the week of year (Integer) of a date ISO8601 style?\n                    {\n                        calcData[inputRowMeta.size()+i] = ValueDataUtil.weekOfYearISO8601(metaA, dataA);\n                    }\n                    break;                    \n                case CalculatorMetaFunction.CALC_YEAR_OF_DATE_ISO8601     : // What is the year (Integer) of a date ISO8601 style?\n                    {\n                        calcData[inputRowMeta.size()+i] = ValueDataUtil.yearOfDateISO8601(metaA, dataA);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_BYTE_TO_HEX_ENCODE   : // Byte to Hex encode string field A\n                    {\n                        calcData[inputRowMeta.size()+i] = ValueDataUtil.byteToHexEncode(metaA, dataA);\n                    }\n                    break;\n                }\n                \n                /*\n                case CalculatorMetaFunction.CALC_HEX_TO_BYTE_DECODE   : // Hex to Byte decode string field A\n                    {\n                        value = new Value(fn.getFieldName(), fieldA);\n                        value.hexToByteDecode();\n                    }\n                    break;                    \n                case CalculatorMetaFunction.CALC_CHAR_TO_HEX_ENCODE   : // Char to Hex encode string field A\n                    {\n                        value = new Value(fn.getFieldName(), fieldA);\n                        value.charToHexEncode();\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_HEX_TO_CHAR_DECODE   : // Hex to Char decode string field A\n                    {\n                        value = new Value(fn.getFieldName(), fieldA);\n                        value.hexToCharDecode();\n                    }\n                    break;                    \n                default:\n                    throw new KettleValueException(\"Unknown calculation type #\"+fn.getCalcType());\n                }\n                \n                if (value!=null)\n                {\n                    if (fn.getValueType()!=Value.VALUE_TYPE_NONE) \n                    {\n                        value.setType(fn.getValueType());\n                        value.setLength(fn.getValueLength(), fn.getValuePrecision());\n                    }\n                    r.addValue(value); // add to the row!\n                }\n                */\n                \n                // TODO: convert the data to the correct target data type.\n                // \n            }\n        }\n        \n        // OK, now we should refrain from adding the temporary fields to the result.\n        // So we remove them.\n        // \n        return RowDataUtil.removeItems(calcData, data.tempIndexes);\n    }","id":75683,"modified_method":"/**\n     * TODO: Make it backward compatible.\n     * \n     * @param inputRowMeta\n     * @param outputRowMeta\n     * @param r\n     * @return\n     * @throws KettleValueException\n     */\n    private Object[] calcFields(RowMetaInterface inputRowMeta, Object[] r) throws KettleValueException\n    {\n        // First copy the input data to the new result...\n        Object[] calcData = new Object[data.calcRowMeta.size()];\n        for (int i=0;i<inputRowMeta.size();i++)\n        {\n            calcData[i] = r[i];\n        }\n\n        for (int i=0, index=inputRowMeta.size()+i;i<meta.getCalculation().length;i++, index++)\n        {\n            CalculatorMetaFunction fn = meta.getCalculation()[i];\n            if (!Const.isEmpty(fn.getFieldName()))\n            {\n                ValueMetaInterface targetMeta = data.calcRowMeta.getValueMeta(index);\n\n                // Get the metadata & the data...\n                // ValueMetaInterface metaTarget = data.calcRowMeta.getValueMeta(i);\n                \n                ValueMetaInterface metaA=null;\n                Object dataA=null;\n                \n                if (data.fieldIndexes[i].indexA>=0) \n                {\n                    metaA = data.calcRowMeta.getValueMeta( data.fieldIndexes[i].indexA );\n                    dataA = calcData[ data.fieldIndexes[i].indexA ];\n                }\n\n                ValueMetaInterface metaB=null;\n                Object dataB=null;\n\n                if (data.fieldIndexes[i].indexB>=0) \n                {\n                    metaB = data.calcRowMeta.getValueMeta( data.fieldIndexes[i].indexB );\n                    dataB = calcData[ data.fieldIndexes[i].indexB ];\n                }\n\n                ValueMetaInterface metaC=null;\n                Object dataC=null;\n\n                if (data.fieldIndexes[i].indexC>=0) \n                {\n                    metaC = data.calcRowMeta.getValueMeta( data.fieldIndexes[i].indexC );\n                    dataC = calcData[ data.fieldIndexes[i].indexC ];\n                }\n                \n                //The data types are those of the first argument field, convert to the target field.\n                // Exceptions: \n                //  - multiply can be string\n                //  - constant is string\n                //  - all date functions except add days/months\n                //  - hex encode / decodes\n                \n                int resultType;\n                if (metaA!=null)\n                {\n                    resultType=metaA.getType();\n                }\n                else\n                {\n                    resultType=ValueMetaInterface.TYPE_NONE;\n                }\n                \n                switch(fn.getCalcType())\n                {\n                case CalculatorMetaFunction.CALC_NONE: \n                    break;\n                case CalculatorMetaFunction.CALC_ADD                :  // A + B\n                    {\n                        calcData[index] = ValueDataUtil.plus(metaA, dataA, metaB, dataB);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_SUBTRACT           :   // A - B\n                    {\n                        calcData[index] = ValueDataUtil.minus(metaA, dataA, metaB, dataB);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_MULTIPLY           :   // A * B\n                    {\n                        calcData[index] = ValueDataUtil.multiply(metaA, dataA, metaB, dataB);\n                        if (metaA.isString() || metaB.isString()) resultType=ValueMetaInterface.TYPE_STRING;\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_DIVIDE             :   // A / B\n                    {\n                        calcData[index] = ValueDataUtil.divide(metaA, dataA, metaB, dataB);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_SQUARE             :   // A * A\n                    {\n                        calcData[index] = ValueDataUtil.multiply(metaA, dataA, metaA, dataA);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_SQUARE_ROOT        :   // SQRT( A )\n                    {\n                        calcData[index] = ValueDataUtil.sqrt(metaA, dataA);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_PERCENT_1          :   // 100 * A / B \n                    {\n                        calcData[index] = ValueDataUtil.percent1(metaA, dataA, metaB, dataB);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_PERCENT_2          :  // A - ( A * B / 100 )\n                    {\n                        calcData[index] = ValueDataUtil.percent2(metaA, dataA, metaB, dataB);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_PERCENT_3          :  // A + ( A * B / 100 )\n                    {\n                        calcData[index] = ValueDataUtil.percent2(metaA, dataA, metaB, dataB);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_COMBINATION_1      :  // A + B * C\n                    {\n                        calcData[index] = ValueDataUtil.combination1(metaA, dataA, metaB, dataB, metaC, dataC);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_COMBINATION_2      :  // SQRT( A*A + B*B )\n                    {\n                        calcData[index] = ValueDataUtil.combination2(metaA, dataA, metaB, dataB);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_ROUND_1            :  // ROUND( A )\n                    {\n                        calcData[index] = ValueDataUtil.round(metaA, dataA);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_ROUND_2            :  //  ROUND( A , B )\n                    {\n                        calcData[index] = ValueDataUtil.round(metaA, dataA, metaB, dataB);\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_CONSTANT           : // Set field to constant value...\n                    {\n                        calcData[index] = dataA; // A string\n                        resultType=ValueMetaInterface.TYPE_STRING;\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_NVL                : // Replace null values with another value\n                    {\n                        calcData[index] = ValueDataUtil.nvl(metaA, dataA, metaB, dataB);\n                    }\n                    break;                    \n                case CalculatorMetaFunction.CALC_ADD_DAYS           : // Add B days to date field A\n                    {\n                        calcData[index] = ValueDataUtil.addDays(metaA, dataA, metaB, dataB);\n                    }\n                    break;\n               case CalculatorMetaFunction.CALC_YEAR_OF_DATE           : // What is the year (Integer) of a date?\n                    {\n                        calcData[index] = ValueDataUtil.yearOfDate(metaA, dataA);\n                        resultType=ValueMetaInterface.TYPE_INTEGER;\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_MONTH_OF_DATE           : // What is the month (Integer) of a date?\n                    {\n                        calcData[index] = ValueDataUtil.monthOfDate(metaA, dataA);\n                        resultType=ValueMetaInterface.TYPE_INTEGER;\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_DAY_OF_YEAR           : // What is the day of year (Integer) of a date?\n                    {\n                        calcData[index] = ValueDataUtil.dayOfYear(metaA, dataA);\n                        resultType=ValueMetaInterface.TYPE_INTEGER;\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_DAY_OF_MONTH           : // What is the day of month (Integer) of a date?\n                    {\n                        calcData[index] = ValueDataUtil.dayOfMonth(metaA, dataA);\n                        resultType=ValueMetaInterface.TYPE_INTEGER;\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_DAY_OF_WEEK           : // What is the day of week (Integer) of a date?\n                    {\n                        calcData[index] = ValueDataUtil.dayOfWeek(metaA, dataA);\n                        resultType=ValueMetaInterface.TYPE_INTEGER;\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_WEEK_OF_YEAR    : // What is the week of year (Integer) of a date?\n                    {\n                        calcData[index] = ValueDataUtil.weekOfYear(metaA, dataA);\n                        resultType=ValueMetaInterface.TYPE_INTEGER;\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_WEEK_OF_YEAR_ISO8601   : // What is the week of year (Integer) of a date ISO8601 style?\n                    {\n                        calcData[index] = ValueDataUtil.weekOfYearISO8601(metaA, dataA);\n                        resultType=ValueMetaInterface.TYPE_INTEGER;\n                    }\n                    break;                    \n                case CalculatorMetaFunction.CALC_YEAR_OF_DATE_ISO8601     : // What is the year (Integer) of a date ISO8601 style?\n                    {\n                        calcData[index] = ValueDataUtil.yearOfDateISO8601(metaA, dataA);\n                        resultType=ValueMetaInterface.TYPE_INTEGER;\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_BYTE_TO_HEX_ENCODE   : // Byte to Hex encode string field A\n                    {\n                        calcData[index] = ValueDataUtil.byteToHexEncode(metaA, dataA);\n                        resultType=ValueMetaInterface.TYPE_STRING;\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_HEX_TO_BYTE_DECODE   : // Hex to Byte decode string field A\n                    {\n                        calcData[index] = ValueDataUtil.hexToByteDecode(metaA, dataA);\n                        resultType=ValueMetaInterface.TYPE_STRING;\n                    }\n                    break;\n                \n                case CalculatorMetaFunction.CALC_CHAR_TO_HEX_ENCODE   : // Char to Hex encode string field A\n                    {\n                        calcData[index] = ValueDataUtil.charToHexEncode(metaA, dataA);\n                        resultType=ValueMetaInterface.TYPE_STRING;\n                    }\n                    break;\n                case CalculatorMetaFunction.CALC_HEX_TO_CHAR_DECODE   : // Hex to Char decode string field A\n                    {\n                        calcData[index] = ValueDataUtil.hexToCharDecode(metaA, dataA);\n                        resultType=ValueMetaInterface.TYPE_STRING;\n                    }\n                    break;                    \n                default:\n                    throw new KettleValueException(\"Unknown calculation type #\"+fn.getCalcType());\n                }\n                \n                // If we don't have a target data type, throw an error.\n                // Otherwise the result is non-deterministic.\n                //\n                if (fn.getValueType()==ValueMetaInterface.TYPE_NONE)\n                {\n                    throw new KettleValueException(\"No datatype is specified for calculation #\"+(i+1)+\" : \"+fn.getFieldName()+\" = \"+fn.getCalcTypeDesc()+\" / \"+fn.getCalcTypeLongDesc());\n                }\n                \n                // Convert the data to the correct target data type.\n                // \n                if (calcData[index]!=null)\n                {\n                    if (fn.getValueType()!=resultType) \n                    {\n                        ValueMetaInterface resultMeta = new ValueMeta(\"result\", resultType);  // $NON-NLS-1$\n                        calcData[index] = targetMeta.convertData(resultMeta, calcData[index]);\n                    }\n                }\n            }\n        }\n        \n        // OK, now we should refrain from adding the temporary fields to the result.\n        // So we remove them.\n        // \n        return RowDataUtil.removeItems(calcData, data.tempIndexes);\n    }","commit_id":"c6b90474b254fd4f14153be06dff3f1914a1dd0d","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void getFields(RowMetaInterface row, String name, RowMetaInterface info) throws KettleStepException\n    {\n        for (int i=0;i<calculation.length;i++)\n        {\n            CalculatorMetaFunction fn = calculation[i];\n            if (!fn.isRemovedFromResult())\n            {\n                if (fn.getFieldName()!=null && fn.getFieldName().length()>0) // It's a new field!\n                {\n                    ValueMetaInterface v = new ValueMeta(fn.getFieldName(), fn.getValueType());\n                    v.setLength(fn.getValueLength());\n                    v.setPrecision(fn.getValuePrecision());\n                    v.setOrigin(name);\n                    row.addValueMeta(v);\n                }\n            }\n        }\n    }","id":75684,"modified_method":"public void getFields(RowMetaInterface row, String origin, RowMetaInterface info) throws KettleStepException\n    {\n        for (int i=0;i<calculation.length;i++)\n        {\n            CalculatorMetaFunction fn = calculation[i];\n            if (!fn.isRemovedFromResult())\n            {\n                if (!Const.isEmpty( fn.getFieldName()) ) // It's a new field!\n                {\n                    ValueMetaInterface v = getValueMeta(fn, origin);\n                    row.addValueMeta(v);\n                }\n            }\n        }\n    }","commit_id":"c6b90474b254fd4f14153be06dff3f1914a1dd0d","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public RowMetaInterface getAllFields(RowMetaInterface inputRowMeta)\n    {\n        RowMetaInterface rowMeta = (RowMetaInterface) inputRowMeta.clone();\n        \n        for (int i=0;i<calculation.length;i++)\n        {\n            CalculatorMetaFunction fn = calculation[i];\n            if (!Const.isEmpty(fn.getFieldName())) // It's a new field!\n            {\n                ValueMetaInterface v = new ValueMeta(fn.getFieldName(), fn.getValueType());\n                v.setLength(fn.getValueLength());\n                v.setPrecision(fn.getValuePrecision());\n                rowMeta.addValueMeta(v);\n            }\n        }\n        return rowMeta;\n    }","id":75685,"modified_method":"public RowMetaInterface getAllFields(RowMetaInterface inputRowMeta)\n    {\n        RowMetaInterface rowMeta = (RowMetaInterface) inputRowMeta.clone();\n        \n        for (int i=0;i<calculation.length;i++)\n        {\n            CalculatorMetaFunction fn = calculation[i];\n            if (!Const.isEmpty(fn.getFieldName())) // It's a new field!\n            {\n                ValueMetaInterface v = getValueMeta(fn, null);\n                rowMeta.addValueMeta(v);\n            }\n        }\n        return rowMeta;\n    }","commit_id":"c6b90474b254fd4f14153be06dff3f1914a1dd0d","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public static Object byteToHexEncode(ValueMetaInterface metaA, Object dataA) throws KettleValueException\r\n    {\r\n        if (dataA==null) return null;\r\n\r\n        final char hexDigits[] =\r\n        { '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F' };\r\n        \r\n        String hex = metaA.getString(dataA);\r\n        \r\n        char[] s = hex.toCharArray();\r\n        StringBuffer hexString = new StringBuffer(2 * s.length);\r\n        \r\n        for (int i = 0; i < s.length; i++)\r\n        {\r\n            hexString.append(hexDigits[(s[i] & 0x00F0) >> 4]); // hi nibble\r\n            hexString.append(hexDigits[s[i] & 0x000F]);        // lo nibble\r\n        }\r\n        \r\n        return hexString;\r\n    }","id":75686,"modified_method":"/**\r\n     * Change a string into its hexadecimal representation. E.g. if Value\r\n     * contains string \"a\" afterwards it would contain value \"0061\".\r\n     * \r\n     * Note that transformations happen in groups of 4 hex characters, so\r\n     * the value of a characters is always in the range 0-65535.\r\n     *  \r\n     * @return \r\n     * @throws KettleValueException\r\n     */\r\n    public static String byteToHexEncode(ValueMetaInterface metaA, Object dataA) throws KettleValueException\r\n    {\r\n        if (dataA==null) return null;\r\n\r\n        final char hexDigits[] =\r\n        { '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F' };\r\n        \r\n        String hex = metaA.getString(dataA);\r\n        \r\n        char[] s = hex.toCharArray();\r\n        StringBuffer hexString = new StringBuffer(2 * s.length);\r\n        \r\n        for (int i = 0; i < s.length; i++)\r\n        {\r\n            hexString.append(hexDigits[(s[i] & 0x00F0) >> 4]); // hi nibble\r\n            hexString.append(hexDigits[s[i] & 0x000F]);        // lo nibble\r\n        }\r\n        \r\n        return hexString.toString();\r\n    }","commit_id":"c6b90474b254fd4f14153be06dff3f1914a1dd0d","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@NotNull\n  public TextRange getDeclarationRange(@NotNull final PsiElement container) {\n    PsiClass aClass = (PsiClass)container;\n    if (aClass instanceof PsiAnonymousClass){\n      PsiConstructorCall call = (PsiConstructorCall)aClass.getParent();\n      int startOffset = call.getTextRange().getStartOffset();\n      int endOffset = call.getArgumentList().getTextRange().getEndOffset();\n      return new TextRange(startOffset, endOffset);\n    }\n    else{\n      int startOffset = aClass.getModifierList().getTextRange().getStartOffset();\n      int endOffset = aClass.getImplementsList().getTextRange().getEndOffset();\n      return new TextRange(startOffset, endOffset);\n    }\n  }","id":75687,"modified_method":"@NotNull\n  public TextRange getDeclarationRange(@NotNull final PsiElement container) {\n    PsiClass aClass = (PsiClass)container;\n    if (aClass instanceof PsiAnonymousClass){\n      PsiConstructorCall call = (PsiConstructorCall)aClass.getParent();\n      int startOffset = call.getTextRange().getStartOffset();\n      int endOffset = call.getArgumentList().getTextRange().getEndOffset();\n      return new TextRange(startOffset, endOffset);\n    }\n    else{\n      final PsiModifierList modifierList = aClass.getModifierList();\n      int startOffset = modifierList == null ? aClass.getTextRange().getStartOffset() : modifierList.getTextRange().getStartOffset();\n      final PsiReferenceList implementsList = aClass.getImplementsList();\n      int endOffset = implementsList == null ? aClass.getTextRange().getEndOffset() : implementsList.getTextRange().getEndOffset();\n      return new TextRange(startOffset, endOffset);\n    }\n  }","commit_id":"0e20ecff7e33cba74bf4984ab25735f846bbf12f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitClass(PsiClass aClass) {\n      //note, no call to super, avoiding drilldown\n      if (aClass instanceof PsiAnonymousClass) {\n        return;\n      }\n      if (!InheritanceUtil.isInheritor(aClass,\n                                       CommonClassNames.JAVA_UTIL_COMPARATOR)) {\n        return;\n      }\n      if (SerializationUtils.isSerializable(aClass)) {\n        return;\n      }\n      registerClassError(aClass);\n    }","id":75688,"modified_method":"@Override\n    public void visitClass(PsiClass aClass) {\n      if (aClass instanceof PsiAnonymousClass || !InheritanceUtil.isInheritor(aClass, CommonClassNames.JAVA_UTIL_COMPARATOR) ||\n          SerializationUtils.isSerializable(aClass)) {\n        return;\n      }\n      registerClassError(aClass);\n    }","commit_id":"4cba7123e069f1261dc550694ca0bc4b17d06c9d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void doFix(Project project, ProblemDescriptor descriptor)\n    throws IncorrectOperationException {\n    final PsiElement nameElement = descriptor.getPsiElement();\n    final PsiClass containingClass =\n      ClassUtils.getContainingClass(nameElement);\n    assert containingClass != null;\n    final PsiElementFactory elementFactory =\n      JavaPsiFacade.getElementFactory(project);\n    final GlobalSearchScope scope = GlobalSearchScope.allScope(project);\n    final PsiJavaCodeReferenceElement referenceElement =\n      elementFactory.createReferenceElementByFQClassName(\n        CommonClassNames.JAVA_IO_SERIALIZABLE, scope);\n    final PsiReferenceList implementsList =\n      containingClass.getImplementsList();\n    assert implementsList != null;\n    implementsList.add(referenceElement);\n  }","id":75689,"modified_method":"@Override\n  public void doFix(Project project, ProblemDescriptor descriptor) {\n    final PsiElement nameElement = descriptor.getPsiElement();\n    final PsiClass containingClass = ClassUtils.getContainingClass(nameElement);\n    if (containingClass == null) {\n      return;\n    }\n    final PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(project);\n    final GlobalSearchScope scope = GlobalSearchScope.allScope(project);\n    final PsiJavaCodeReferenceElement referenceElement =\n      elementFactory.createReferenceElementByFQClassName(CommonClassNames.JAVA_IO_SERIALIZABLE, scope);\n    final PsiReferenceList referenceList;\n    if (containingClass.isInterface()) {\n      referenceList = containingClass.getExtendsList();\n    }\n    else {\n      referenceList = containingClass.getImplementsList();\n    }\n    if (referenceList == null) {\n      return;\n    }\n    referenceList.add(referenceElement);\n  }","commit_id":"4cba7123e069f1261dc550694ca0bc4b17d06c9d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private MavenProject build( String pomLocation, Model model, ArtifactRepository localRepository, List externalProfiles )\n        throws ProjectBuildingException, ArtifactResolutionException\n    {\n        Model superModel = getSuperModel();\n\n        LinkedList lineage = new LinkedList();\n\n        List aggregatedRemoteWagonRepositories = ProjectUtils.buildArtifactRepositories( superModel.getRepositories(), artifactRepositoryFactory, container );\n\n        for ( Iterator i = externalProfiles.iterator(); i.hasNext(); )\n        {\n            Profile externalProfile = (Profile) i.next();\n            \n            for ( Iterator repoIterator = externalProfile.getRepositories().iterator(); repoIterator.hasNext(); )\n            {\n                Repository mavenRepo = (Repository) repoIterator.next();\n\n                ArtifactRepository artifactRepo = ProjectUtils.buildArtifactRepository( mavenRepo, artifactRepositoryFactory, container );\n\n                if ( !aggregatedRemoteWagonRepositories.contains( artifactRepo ) )\n                {\n                    aggregatedRemoteWagonRepositories.add( artifactRepo );\n                }\n            }\n        }\n        \n        MavenProject project = assembleLineage( model, lineage, aggregatedRemoteWagonRepositories, localRepository );\n\n        Model previous = superModel;\n\n        for ( Iterator i = lineage.iterator(); i.hasNext(); )\n        {\n            Model current = ( (MavenProject) i.next() ).getModel();\n\n            modelInheritanceAssembler.assembleModelInheritance( current, previous );\n\n            previous = current;\n        }\n\n        try\n        {\n            project = processProjectLogic( pomLocation, project, aggregatedRemoteWagonRepositories, externalProfiles );\n        }\n        catch ( ModelInterpolationException e )\n        {\n            throw new ProjectBuildingException( \"Error building project from \\'\" + pomLocation + \"\\': \" + model.getId(), e );\n        }\n        return project;\n    }","id":75690,"modified_method":"private MavenProject build( String pomLocation, Model model, ArtifactRepository localRepository, List externalProfiles )\n        throws ProjectBuildingException, ArtifactResolutionException\n    {\n        Model superModel = getSuperModel();\n\n        LinkedList lineage = new LinkedList();\n\n        List aggregatedRemoteWagonRepositories = ProjectUtils.buildArtifactRepositories( superModel.getRepositories(), artifactRepositoryFactory, container );\n\n        for ( Iterator i = externalProfiles.iterator(); i.hasNext(); )\n        {\n            Profile externalProfile = (Profile) i.next();\n            \n            for ( Iterator repoIterator = externalProfile.getRepositories().iterator(); repoIterator.hasNext(); )\n            {\n                Repository mavenRepo = (Repository) repoIterator.next();\n\n                ArtifactRepository artifactRepo = ProjectUtils.buildArtifactRepository( mavenRepo, artifactRepositoryFactory, container );\n\n                if ( !aggregatedRemoteWagonRepositories.contains( artifactRepo ) )\n                {\n                    aggregatedRemoteWagonRepositories.add( artifactRepo );\n                }\n            }\n        }\n        \n        MavenProject project = assembleLineage( model, lineage, aggregatedRemoteWagonRepositories, localRepository );\n        \n        // we don't have to force the collision exception for superModel here, it's already been done in getSuperModel()\n        Model previous = superModel;\n        \n        for ( Iterator i = lineage.iterator(); i.hasNext(); )\n        {\n            Model current = ( (MavenProject) i.next() ).getModel();\n\n            forcePluginExecutionIdCollision( current );\n\n            modelInheritanceAssembler.assembleModelInheritance( current, previous );\n\n            previous = current;\n        }\n\n        try\n        {\n            project = processProjectLogic( pomLocation, project, aggregatedRemoteWagonRepositories, externalProfiles );\n        }\n        catch ( ModelInterpolationException e )\n        {\n            throw new ProjectBuildingException( \"Error building project from \\'\" + pomLocation + \"\\': \" + model.getId(), e );\n        }\n        return project;\n    }","commit_id":"7acd75ed8ad36708408783efff075610dc669c06","url":"https://github.com/apache/maven"},{"original_method":"private Model getSuperModel()\n        throws ProjectBuildingException\n    {\n        URL url = DefaultMavenProjectBuilder.class.getResource( \"pom-\" + MAVEN_MODEL_VERSION + \".xml\" );\n\n        return readModel( url );\n    }","id":75691,"modified_method":"private Model getSuperModel()\n        throws ProjectBuildingException\n    {\n        URL url = DefaultMavenProjectBuilder.class.getResource( \"pom-\" + MAVEN_MODEL_VERSION + \".xml\" );\n\n        Model superModel = readModel( url );\n        \n        forcePluginExecutionIdCollision( superModel );\n\n        return superModel;\n    }","commit_id":"7acd75ed8ad36708408783efff075610dc669c06","url":"https://github.com/apache/maven"},{"original_method":"public static SModel readModel(DiffContent content, String path) throws IOException, ReadException {\n    return readModel(content.getBytes(), path);\n  }","id":75692,"modified_method":"public static SModel readModel(DiffContent content, String path) throws IOException, ReadException {\n    SModel sModel = readModel(content.getBytes(), path);\n    if (content instanceof DocumentContent) {\n      SModelRepository repository = SModelRepository.getInstance();\n      SModelDescriptor sModelDescriptor = repository.getModelDescriptor(sModel.getSModelFqName());\n      return sModelDescriptor.getSModel();\n    }\n    return sModel;\n  }","commit_id":"210c8f873aa56ffc0fa4218fcd6165756e36f3b0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void show(final DiffRequest request) {\n    DiffContent[] contents = request.getContents();\n\n    try {\n      final SModel oldModel = readModel(contents[0], getFilePath(request));\n      final SModel newModel = readModel(contents[1], getFilePath(request));\n\n      final ModelDifferenceDialog d = ModelAccess.instance().runReadAction(new Computable<ModelDifferenceDialog>() {\n        public ModelDifferenceDialog compute() {\n          MPSProject project = request.getProject().getComponent(MPSProjectHolder.class).getMPSProject();\n          IOperationContext context = new ModuleContext(oldModel.getModelDescriptor().getModule(), project);\n          return new ModelDifferenceDialog(context, WindowManager.getInstance().getFrame(request.getProject()), oldModel, newModel, request.getWindowTitle(), !request.getHints().contains(DiffTool.HINT_SHOW_FRAME));\n        }\n      });\n      AnAction action = new AnAction(\"View As Text\", \"View As Text\", Icons.TEXT_ICON) {\n        public void actionPerformed(AnActionEvent e) {\n          DiffTool ideaDiffTool = DiffManager.getInstance().getIdeaDiffTool();\n          if (ideaDiffTool.canShow(request)) {\n            d.dispose();\n            ideaDiffTool.show(request);\n          }\n        }\n      };\n      d.addAction(action);\n      d.showDialog();\n\n    } catch (IOException e) {\n      e.printStackTrace();\n    } catch (ReadException e) {\n      // if we cant read model from file\n      // we try to use idea diff tool instead\n      LOG.warning(\"Can't read models. Using text based merge...\", e);\n      DiffTool ideaDiffTool = DiffManager.getInstance().getIdeaDiffTool();\n      if (ideaDiffTool.canShow(request)) {\n        ideaDiffTool.show(request);\n      }\n    }\n  }","id":75693,"modified_method":"public void show(final DiffRequest request) {\n    DiffContent[] contents = request.getContents();\n\n    try {\n      final SModel oldModel = readModel(contents[0], getFilePath(request));\n      final SModel newModel = readModel(contents[1], getFilePath(request));\n\n      final ModelDifferenceDialog d = ModelAccess.instance().runReadAction(new Computable<ModelDifferenceDialog>() {\n        public ModelDifferenceDialog compute() {\n          MPSProject project = request.getProject().getComponent(MPSProjectHolder.class).getMPSProject();\n          IOperationContext context = new ModuleContext(oldModel.getModelDescriptor().getModule(), project);\n          boolean modal = !request.getHints().contains(DiffTool.HINT_SHOW_FRAME);\n          JFrame frame = WindowManager.getInstance().getFrame(request.getProject());\n          return new ModelDifferenceDialog(context, frame, oldModel, newModel, request.getWindowTitle(), modal, request.getContentTitles());\n        }\n      });\n      AnAction action = new AnAction(\"View As Text\", \"View As Text\", Icons.TEXT_ICON) {\n        public void actionPerformed(AnActionEvent e) {\n          DiffTool ideaDiffTool = DiffManager.getInstance().getIdeaDiffTool();\n          if (ideaDiffTool.canShow(request)) {\n            d.dispose();\n            ideaDiffTool.show(request);\n          }\n        }\n      };\n      d.addAction(action);\n      d.showDialog();\n    } catch (IOException e) {\n      e.printStackTrace();\n    } catch (ReadException e) {\n      // if we cant read model from file\n      // we try to use idea diff tool instead\n      LOG.warning(\"Can't read models. Using text based merge...\", e);\n      DiffTool ideaDiffTool = DiffManager.getInstance().getIdeaDiffTool();\n      if (ideaDiffTool.canShow(request)) {\n        ideaDiffTool.show(request);\n      }\n    }\n  }","commit_id":"210c8f873aa56ffc0fa4218fcd6165756e36f3b0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ModelDifferenceDialog(final IOperationContext context, final Frame parent, final SModel oldModel, final SModel newModel, String windowTitle, boolean modal) throws HeadlessException {\n    super(parent, windowTitle);\n    setModal(modal);\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        myDifferenceComponent = new ModelDifferenceComponent(context) {\n          @Override\n          protected void doubleClickOnNode(final SNode node) {\n            final boolean[] isRoot = new boolean[1];\n            ModelAccess.instance().runReadAction(new Runnable() {\n\n              public void run() {\n                isRoot[0] = node.isRoot();\n              }\n            });\n            if (isRoot[0]) {\n              final RootDifferenceDialog dialog = new RootDifferenceDialog(context.getMainFrame(), newModel, oldModel, false);\n              ModelAccess.instance().runReadAction(new Runnable() {\n                public void run() {\n                  dialog.init(context, node, \"new\", \"old\");\n                }\n              });\n\n              dialog.showDialog();\n            }\n          }\n        };\n        myDifferenceComponent.showDifference(oldModel, newModel);\n      }\n    });\n    myFocusTrackback = new FocusTrackback(this, parent, false);\n    WindowAdapter focusListener = new WindowAdapter() {\n      public void windowOpened(WindowEvent e) {\n        if (myDifferenceComponent != null) {\n          myDifferenceComponent.requestFocusInWindow();\n          myFocusTrackback.registerFocusComponent(myDifferenceComponent);\n        }\n      }\n    };\n    addWindowListener(focusListener);\n    myFocusWatcher = new FocusWatcher() {\n      protected void focusLostImpl(final FocusEvent e) {\n        myFocusTrackback.consume();\n      }\n    };\n    myFocusWatcher.install(myDifferenceComponent);\n  }","id":75694,"modified_method":"public ModelDifferenceDialog(final IOperationContext context, final Frame parent, final SModel oldModel, final SModel newModel, String windowTitle, boolean modal, final String[] contentTitles) throws HeadlessException {\n    super(parent, windowTitle);\n    setModal(modal);\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        myDifferenceComponent = new ModelDifferenceComponent(context) {\n          @Override\n          protected void doubleClickOnNode(final SNode node) {\n            final boolean[] isRoot = new boolean[1];\n            ModelAccess.instance().runReadAction(new Runnable() {\n\n              public void run() {\n                isRoot[0] = node.isRoot();\n              }\n            });\n            if (isRoot[0]) {\n              final RootDifferenceDialog dialog = new RootDifferenceDialog(context.getMainFrame(), newModel, oldModel, false);\n              ModelAccess.instance().runReadAction(new Runnable() {\n                public void run() {\n                  dialog.init(context, node, contentTitles[1], contentTitles[0]);\n                }\n              });\n\n              dialog.showDialog();\n            }\n          }\n        };\n        myDifferenceComponent.showDifference(oldModel, newModel);\n      }\n    });\n    myFocusTrackback = new FocusTrackback(this, parent, false);\n    WindowAdapter focusListener = new WindowAdapter() {\n      public void windowOpened(WindowEvent e) {\n        if (myDifferenceComponent != null) {\n          myDifferenceComponent.requestFocusInWindow();\n          myFocusTrackback.registerFocusComponent(myDifferenceComponent);\n        }\n      }\n    };\n    addWindowListener(focusListener);\n    myFocusWatcher = new FocusWatcher() {\n      protected void focusLostImpl(final FocusEvent e) {\n        myFocusTrackback.consume();\n      }\n    };\n    myFocusWatcher.install(myDifferenceComponent);\n  }","commit_id":"210c8f873aa56ffc0fa4218fcd6165756e36f3b0","url":"https://github.com/JetBrains/MPS"},{"original_method":"private Model readParent( Model childModel, ModelBuildingRequest request, List<ModelProblem> problems )\n        throws ModelBuildingException\n    {\n        Model parentModel;\n\n        Parent parent = childModel.getParent();\n\n        if ( parent != null )\n        {\n            parentModel = readParentLocally( childModel, request, problems );\n\n            if ( parentModel == null )\n            {\n                parentModel = readParentExternally( childModel, request, problems );\n            }\n        }\n        else\n        {\n            parentModel = null;\n        }\n\n        return parentModel;\n    }","id":75695,"modified_method":"private ModelData readParent( Model childModel, ModelBuildingRequest request, List<ModelProblem> problems )\n        throws ModelBuildingException\n    {\n        ModelData parentData;\n\n        Parent parent = childModel.getParent();\n\n        if ( parent != null )\n        {\n            parentData = readParentLocally( childModel, request, problems );\n\n            if ( parentData == null )\n            {\n                parentData = readParentExternally( childModel, request, problems );\n            }\n        }\n        else\n        {\n            parentData = null;\n        }\n\n        return parentData;\n    }","commit_id":"7f526ca65dd5ea9d9d9cb5ce6ae94ce2e3d98fef","url":"https://github.com/apache/maven"},{"original_method":"private ModelBuildingResult build( ModelSource modelSource, File pomFile, ModelBuildingRequest request )\n        throws ModelBuildingException\n    {\n        DefaultModelBuildingResult result = new DefaultModelBuildingResult();\n\n        List<ModelProblem> problems = new ArrayList<ModelProblem>();\n\n        ProfileActivationContext profileActivationContext = getProfileActivationContext( request );\n\n        List<Profile> activeExternalProfiles = getActiveExternalProfiles( request, profileActivationContext, problems );\n\n        result.setActiveExternalProfiles( activeExternalProfiles );\n\n        Model model = readModel( modelSource, pomFile, request, problems );\n\n        List<Model> rawModels = new ArrayList<Model>();\n        List<Model> resultModels = new ArrayList<Model>();\n\n        for ( Model current = model; current != null; current = readParent( current, request, problems ) )\n        {\n            Model resultModel = current;\n            resultModels.add( resultModel );\n\n            Model rawModel = ModelUtils.cloneModel( current );\n            rawModels.add( rawModel );\n\n            modelNormalizer.mergeDuplicates( resultModel, request );\n\n            List<Profile> activePomProfiles = getActivePomProfiles( rawModel, profileActivationContext, problems );\n\n            result.setActivePomProfiles( rawModel, activePomProfiles );\n\n            for ( Profile activeProfile : activePomProfiles )\n            {\n                profileInjector.injectProfile( resultModel, activeProfile, request );\n            }\n\n            if ( current == model )\n            {\n                for ( Profile activeProfile : activeExternalProfiles )\n                {\n                    profileInjector.injectProfile( resultModel, activeProfile, request );\n                }\n            }\n\n            configureResolver( request.getModelResolver(), resultModel, problems );\n        }\n\n        Model superModel = getSuperModel();\n        rawModels.add( superModel );\n        resultModels.add( superModel );\n\n        result.setRawModels( rawModels );\n\n        assembleInheritance( resultModels, request );\n\n        Model resultModel = resultModels.get( 0 );\n\n        resultModel = interpolateModel( resultModel, request, problems );\n        resultModels.set( 0, resultModel );\n\n        modelPathTranslator.alignToBaseDirectory( resultModel, resultModel.getProjectDirectory(), request );\n\n        if ( request.isProcessPlugins() )\n        {\n            lifecycleBindingsInjector.injectLifecycleBindings( resultModel );\n        }\n\n        managementInjector.injectManagement( resultModel, request );\n\n        modelNormalizer.injectDefaultValues( resultModel, request );\n\n        if ( request.isProcessPlugins() )\n        {\n            pluginConfigurationExpander.expandPluginConfiguration( resultModel, request );\n        }\n\n        ModelValidationResult validationResult = modelValidator.validateEffectiveModel( resultModel, request );\n        addProblems( resultModel, validationResult, problems );\n\n        if ( !problems.isEmpty() )\n        {\n            throw new ModelBuildingException( problems );\n        }\n\n        result.setEffectiveModel( resultModel );\n\n        return result;\n    }","id":75696,"modified_method":"private ModelBuildingResult build( ModelSource modelSource, File pomFile, ModelBuildingRequest request )\n        throws ModelBuildingException\n    {\n        DefaultModelBuildingResult result = new DefaultModelBuildingResult();\n\n        List<ModelProblem> problems = new ArrayList<ModelProblem>();\n\n        ProfileActivationContext profileActivationContext = getProfileActivationContext( request );\n\n        List<Profile> activeExternalProfiles = getActiveExternalProfiles( request, profileActivationContext, problems );\n\n        Model inputModel = readModel( modelSource, pomFile, request, problems );\n\n        ModelData resultData = new ModelData( inputModel );\n\n        List<ModelData> lineage = new ArrayList<ModelData>();\n\n        for ( ModelData currentData = resultData; currentData != null; )\n        {\n            lineage.add( currentData );\n\n            Model tmpModel = currentData.getModel();\n\n            Model rawModel = ModelUtils.cloneModel( tmpModel );\n            currentData.setRawModel( rawModel );\n\n            modelNormalizer.mergeDuplicates( tmpModel, request );\n\n            List<Profile> activePomProfiles = getActivePomProfiles( rawModel, profileActivationContext, problems );\n            currentData.setActiveProfiles( activePomProfiles );\n\n            for ( Profile activeProfile : activePomProfiles )\n            {\n                profileInjector.injectProfile( tmpModel, activeProfile, request );\n            }\n\n            if ( currentData == resultData )\n            {\n                for ( Profile activeProfile : activeExternalProfiles )\n                {\n                    profileInjector.injectProfile( tmpModel, activeProfile, request );\n                }\n            }\n\n            configureResolver( request.getModelResolver(), tmpModel, problems );\n\n            currentData = readParent( tmpModel, request, problems );\n        }\n\n        ModelData superData = new ModelData( getSuperModel() );\n        superData.setRawModel( superData.getModel() );\n        superData.setActiveProfiles( Collections.<Profile> emptyList() );\n        lineage.add( superData );\n\n        assembleInheritance( lineage, request );\n\n        Model resultModel = resultData.getModel();\n\n        resultModel = interpolateModel( resultModel, request, problems );\n        resultData.setModel( resultModel );\n\n        modelPathTranslator.alignToBaseDirectory( resultModel, resultModel.getProjectDirectory(), request );\n\n        if ( request.isProcessPlugins() )\n        {\n            lifecycleBindingsInjector.injectLifecycleBindings( resultModel );\n        }\n\n        managementInjector.injectManagement( resultModel, request );\n\n        modelNormalizer.injectDefaultValues( resultModel, request );\n\n        if ( request.isProcessPlugins() )\n        {\n            pluginConfigurationExpander.expandPluginConfiguration( resultModel, request );\n        }\n\n        ModelValidationResult validationResult = modelValidator.validateEffectiveModel( resultModel, request );\n        addProblems( resultModel, validationResult, problems );\n\n        if ( !problems.isEmpty() )\n        {\n            throw new ModelBuildingException( problems );\n        }\n\n        resultData.setGroupId( resultModel.getGroupId() );\n        resultData.setArtifactId( resultModel.getArtifactId() );\n        resultData.setVersion( resultModel.getVersion() );\n\n        result.setEffectiveModel( resultModel );\n\n        result.setActiveExternalProfiles( activeExternalProfiles );\n\n        for ( ModelData currentData : lineage )\n        {\n            String modelId = ( currentData != superData ) ? currentData.getId() : \"\";\n\n            result.addModelId( modelId );\n            result.setActivePomProfiles( modelId, currentData.getActiveProfiles() );\n            result.setRawModel( modelId, currentData.getRawModel() );\n        }\n\n        return result;\n    }","commit_id":"7f526ca65dd5ea9d9d9cb5ce6ae94ce2e3d98fef","url":"https://github.com/apache/maven"},{"original_method":"private Model readParentLocally( Model childModel, ModelBuildingRequest request, List<ModelProblem> problems )\n        throws ModelBuildingException\n    {\n        File projectDirectory = childModel.getProjectDirectory();\n        if ( projectDirectory == null )\n        {\n            return null;\n        }\n\n        Parent parent = childModel.getParent();\n\n        File pomFile = new File( new File( projectDirectory, parent.getRelativePath() ).toURI().normalize() );\n        if ( pomFile.isDirectory() )\n        {\n            pomFile = new File( pomFile, \"pom.xml\" );\n        }\n        if ( !pomFile.isFile() )\n        {\n            return null;\n        }\n\n        Model candidateModel = readModel( new FileModelSource( pomFile ), pomFile, request, problems );\n\n        String groupId = candidateModel.getGroupId();\n        if ( groupId == null && candidateModel.getParent() != null )\n        {\n            groupId = candidateModel.getParent().getGroupId();\n        }\n        String artifactId = candidateModel.getArtifactId();\n        String version = candidateModel.getVersion();\n        if ( version == null && candidateModel.getParent() != null )\n        {\n            version = candidateModel.getParent().getVersion();\n        }\n\n        if ( groupId == null || !groupId.equals( parent.getGroupId() ) )\n        {\n            return null;\n        }\n        if ( artifactId == null || !artifactId.equals( parent.getArtifactId() ) )\n        {\n            return null;\n        }\n        if ( version == null || !version.equals( parent.getVersion() ) )\n        {\n            return null;\n        }\n\n        return candidateModel;\n    }","id":75697,"modified_method":"private ModelData readParentLocally( Model childModel, ModelBuildingRequest request, List<ModelProblem> problems )\n        throws ModelBuildingException\n    {\n        File projectDirectory = childModel.getProjectDirectory();\n        if ( projectDirectory == null )\n        {\n            return null;\n        }\n\n        Parent parent = childModel.getParent();\n\n        File pomFile = new File( new File( projectDirectory, parent.getRelativePath() ).toURI().normalize() );\n        if ( pomFile.isDirectory() )\n        {\n            pomFile = new File( pomFile, \"pom.xml\" );\n        }\n        if ( !pomFile.isFile() )\n        {\n            return null;\n        }\n\n        Model candidateModel = readModel( new FileModelSource( pomFile ), pomFile, request, problems );\n\n        String groupId = candidateModel.getGroupId();\n        if ( groupId == null && candidateModel.getParent() != null )\n        {\n            groupId = candidateModel.getParent().getGroupId();\n        }\n        String artifactId = candidateModel.getArtifactId();\n        String version = candidateModel.getVersion();\n        if ( version == null && candidateModel.getParent() != null )\n        {\n            version = candidateModel.getParent().getVersion();\n        }\n\n        if ( groupId == null || !groupId.equals( parent.getGroupId() ) )\n        {\n            return null;\n        }\n        if ( artifactId == null || !artifactId.equals( parent.getArtifactId() ) )\n        {\n            return null;\n        }\n        if ( version == null || !version.equals( parent.getVersion() ) )\n        {\n            return null;\n        }\n\n        ModelData parentData = new ModelData( candidateModel, groupId, artifactId, version );\n\n        return parentData;\n    }","commit_id":"7f526ca65dd5ea9d9d9cb5ce6ae94ce2e3d98fef","url":"https://github.com/apache/maven"},{"original_method":"private Model readParentExternally( Model childModel, ModelBuildingRequest request, List<ModelProblem> problems )\n        throws ModelBuildingException\n    {\n        Parent parent = childModel.getParent();\n\n        ModelResolver modelResolver = request.getModelResolver();\n\n        if ( modelResolver == null )\n        {\n            problems.add( new ModelProblem( \"Non-resolvable parent POM \" + toId( parent ) + \" for POM \"\n                + toSourceHint( childModel ) + \": \" + \"No model resolver provided\", toSourceHint( childModel ) ) );\n            throw new ModelBuildingException( problems );\n        }\n\n        ModelSource modelSource;\n        try\n        {\n            modelSource = modelResolver.resolveModel( parent.getGroupId(), parent.getArtifactId(), parent.getVersion() );\n        }\n        catch ( UnresolvableModelException e )\n        {\n            problems.add( new ModelProblem( \"Non-resolvable parent POM \" + toId( parent ) + \" for POM \"\n                + toSourceHint( childModel ) + \": \" + e.getMessage(), toSourceHint( childModel ), e ) );\n            throw new ModelBuildingException( problems );\n        }\n\n        return readModel( modelSource, null, request, problems );\n    }","id":75698,"modified_method":"private ModelData readParentExternally( Model childModel, ModelBuildingRequest request, List<ModelProblem> problems )\n        throws ModelBuildingException\n    {\n        Parent parent = childModel.getParent();\n\n        ModelResolver modelResolver = request.getModelResolver();\n\n        if ( modelResolver == null )\n        {\n            problems.add( new ModelProblem( \"Non-resolvable parent POM \" + toId( parent ) + \" for POM \"\n                + toSourceHint( childModel ) + \": \" + \"No model resolver provided\", toSourceHint( childModel ) ) );\n            throw new ModelBuildingException( problems );\n        }\n\n        ModelSource modelSource;\n        try\n        {\n            modelSource = modelResolver.resolveModel( parent.getGroupId(), parent.getArtifactId(), parent.getVersion() );\n        }\n        catch ( UnresolvableModelException e )\n        {\n            problems.add( new ModelProblem( \"Non-resolvable parent POM \" + toId( parent ) + \" for POM \"\n                + toSourceHint( childModel ) + \": \" + e.getMessage(), toSourceHint( childModel ), e ) );\n            throw new ModelBuildingException( problems );\n        }\n\n        Model parentModel = readModel( modelSource, null, request, problems );\n\n        ModelData parentData =\n            new ModelData( parentModel, parent.getGroupId(), parent.getArtifactId(), parent.getVersion() );\n\n        return parentData;\n    }","commit_id":"7f526ca65dd5ea9d9d9cb5ce6ae94ce2e3d98fef","url":"https://github.com/apache/maven"},{"original_method":"private void assembleInheritance( List<Model> models, ModelBuildingRequest request )\n    {\n        for ( int i = models.size() - 2; i >= 0; i-- )\n        {\n            Model parent = models.get( i + 1 );\n            Model child = models.get( i );\n            inheritanceAssembler.assembleModelInheritance( child, parent, request );\n        }\n    }","id":75699,"modified_method":"private void assembleInheritance( List<ModelData> lineage, ModelBuildingRequest request )\n    {\n        for ( int i = lineage.size() - 2; i >= 0; i-- )\n        {\n            Model parent = lineage.get( i + 1 ).getModel();\n            Model child = lineage.get( i ).getModel();\n            inheritanceAssembler.assembleModelInheritance( child, parent, request );\n        }\n    }","commit_id":"7f526ca65dd5ea9d9d9cb5ce6ae94ce2e3d98fef","url":"https://github.com/apache/maven"},{"original_method":"public DefaultModelBuildingResult setActivePomProfiles( Model rawModel, List<Profile> activeProfiles )\n    {\n        if ( rawModel == null )\n        {\n            throw new IllegalArgumentException( \"no model specified\" );\n        }\n\n        if ( activeProfiles != null )\n        {\n            this.activePomProfiles.put( rawModel, new ArrayList<Profile>( activeProfiles ) );\n        }\n        else\n        {\n            this.activePomProfiles.remove( rawModel );\n        }\n\n        return this;\n    }","id":75700,"modified_method":"public DefaultModelBuildingResult setActivePomProfiles( String modelId, List<Profile> activeProfiles )\n    {\n        if ( modelId == null )\n        {\n            throw new IllegalArgumentException( \"no model identifier specified\" );\n        }\n\n        if ( activeProfiles != null )\n        {\n            this.activePomProfiles.put( modelId, new ArrayList<Profile>( activeProfiles ) );\n        }\n        else\n        {\n            this.activePomProfiles.remove( modelId );\n        }\n\n        return this;\n    }","commit_id":"7f526ca65dd5ea9d9d9cb5ce6ae94ce2e3d98fef","url":"https://github.com/apache/maven"},{"original_method":"public Model getEffectiveModel()\n    {\n        return model;\n    }","id":75701,"modified_method":"public Model getEffectiveModel()\n    {\n        return effectiveModel;\n    }","commit_id":"7f526ca65dd5ea9d9d9cb5ce6ae94ce2e3d98fef","url":"https://github.com/apache/maven"},{"original_method":"public List<Profile> getActivePomProfiles( Model rawModel )\n    {\n        List<Profile> profiles = this.activePomProfiles.get( rawModel );\n        return ( profiles == null ) ? Collections.<Profile> emptyList() : Collections.unmodifiableList( profiles );\n    }","id":75702,"modified_method":"public List<Profile> getActivePomProfiles( String modelId )\n    {\n        List<Profile> profiles = this.activePomProfiles.get( modelId );\n        return ( profiles != null ) ? Collections.unmodifiableList( profiles ) : null;\n    }","commit_id":"7f526ca65dd5ea9d9d9cb5ce6ae94ce2e3d98fef","url":"https://github.com/apache/maven"},{"original_method":"public DefaultModelBuildingResult()\n    {\n        rawModels = new ArrayList<Model>();\n        activePomProfiles = new HashMap<Model, List<Profile>>();\n        activeExternalProfiles = new ArrayList<Profile>();\n    }","id":75703,"modified_method":"public DefaultModelBuildingResult()\n    {\n        modelIds = new ArrayList<String>();\n        rawModels = new HashMap<String, Model>();\n        activePomProfiles = new HashMap<String, List<Profile>>();\n        activeExternalProfiles = new ArrayList<Profile>();\n    }","commit_id":"7f526ca65dd5ea9d9d9cb5ce6ae94ce2e3d98fef","url":"https://github.com/apache/maven"},{"original_method":"public List<Model> getRawModels()\n    {\n        return Collections.unmodifiableList( rawModels );\n    }","id":75704,"modified_method":"public Model getRawModel( String modelId )\n    {\n        return rawModels.get( modelId );\n    }","commit_id":"7f526ca65dd5ea9d9d9cb5ce6ae94ce2e3d98fef","url":"https://github.com/apache/maven"},{"original_method":"public DefaultModelBuildingResult setEffectiveModel( Model model )\n    {\n        this.model = model;\n\n        return this;\n    }","id":75705,"modified_method":"public DefaultModelBuildingResult setEffectiveModel( Model model )\n    {\n        this.effectiveModel = model;\n\n        return this;\n    }","commit_id":"7f526ca65dd5ea9d9d9cb5ce6ae94ce2e3d98fef","url":"https://github.com/apache/maven"},{"original_method":"public Model getRawModel()\n    {\n        return rawModels.get( 0 );\n    }","id":75706,"modified_method":"public Model getRawModel()\n    {\n        return rawModels.get( modelIds.get( 0 ) );\n    }","commit_id":"7f526ca65dd5ea9d9d9cb5ce6ae94ce2e3d98fef","url":"https://github.com/apache/maven"},{"original_method":"private MavenProject build( File pomFile, boolean localProject, ProjectBuildingRequest configuration )\n        throws ProjectBuildingException\n    {\n        ModelResolver resolver =\n            new RepositoryModelResolver( repositorySystem, resolutionErrorHandler, configuration.getLocalRepository(),\n                                         configuration.getRemoteRepositories() );\n\n        ModelBuildingRequest request = new DefaultModelBuildingRequest();\n        request.setLenientValidation( configuration.istLenientValidation() );\n        request.setProcessPlugins( configuration.isProcessPlugins() );\n        request.setProfiles( configuration.getProfiles() );\n        request.setActiveProfileIds( configuration.getActiveProfileIds() );\n        request.setInactiveProfileIds( configuration.getInactiveProfileIds() );\n        request.setExecutionProperties( configuration.getExecutionProperties() );\n        request.setBuildStartTime( configuration.getBuildStartTime() );\n        request.setModelResolver( resolver );\n\n        ModelBuildingResult result;\n        try\n        {\n            if ( localProject )\n            {\n                result = modelBuilder.build( pomFile, request );\n            }\n            else\n            {\n                result = modelBuilder.build( new FileModelSource( pomFile ), request );\n            }\n        }\n        catch ( ModelBuildingException e )\n        {\n            throw new ProjectBuildingException( \"[unknown]\", \"Failed to build project for \" + pomFile, pomFile, e );\n        }\n        \n        Model model = result.getEffectiveModel();\n\n        MavenProject project = fromModelToMavenProject( model, result.getRawModels().get( 1 ).getPomFile(), configuration, model.getPomFile() );\n\n        project.setOriginalModel( result.getRawModel() );\n     \n        try\n        {\n            if ( configuration.isProcessPlugins() )\n            {\n                lifecycle.populateDefaultConfigurationForPlugins( model.getBuild().getPlugins(), configuration.getLocalRepository(), project.getPluginArtifactRepositories() );\n            }\n        }\n        catch ( LifecycleExecutionException e )\n        {\n            throw new ProjectBuildingException( \"\", e.getMessage(), e );\n        }\n\n        Build build = project.getBuild();\n        // NOTE: setting this script-source root before path translation, because\n        // the plugin tools compose basedir and scriptSourceRoot into a single file.\n        project.addScriptSourceRoot( build.getScriptSourceDirectory() );\n        project.addCompileSourceRoot( build.getSourceDirectory() );\n        project.addTestCompileSourceRoot( build.getTestSourceDirectory() );\n        project.setFile( pomFile );\n\n        List<Profile> activeProfiles = new ArrayList<Profile>();\n        activeProfiles.addAll( result.getActivePomProfiles( result.getRawModel() ) );\n        activeProfiles.addAll( result.getActiveExternalProfiles() );\n        project.setActiveProfiles( activeProfiles );\n                \n        return project;\n    }","id":75707,"modified_method":"private MavenProject build( File pomFile, boolean localProject, ProjectBuildingRequest configuration )\n        throws ProjectBuildingException\n    {\n        ModelResolver resolver =\n            new RepositoryModelResolver( repositorySystem, resolutionErrorHandler, configuration.getLocalRepository(),\n                                         configuration.getRemoteRepositories() );\n\n        ModelBuildingRequest request = new DefaultModelBuildingRequest();\n        request.setLenientValidation( configuration.istLenientValidation() );\n        request.setProcessPlugins( configuration.isProcessPlugins() );\n        request.setProfiles( configuration.getProfiles() );\n        request.setActiveProfileIds( configuration.getActiveProfileIds() );\n        request.setInactiveProfileIds( configuration.getInactiveProfileIds() );\n        request.setExecutionProperties( configuration.getExecutionProperties() );\n        request.setBuildStartTime( configuration.getBuildStartTime() );\n        request.setModelResolver( resolver );\n\n        ModelBuildingResult result;\n        try\n        {\n            if ( localProject )\n            {\n                result = modelBuilder.build( pomFile, request );\n            }\n            else\n            {\n                result = modelBuilder.build( new FileModelSource( pomFile ), request );\n            }\n        }\n        catch ( ModelBuildingException e )\n        {\n            throw new ProjectBuildingException( \"[unknown]\", \"Failed to build project for \" + pomFile, pomFile, e );\n        }\n        \n        Model model = result.getEffectiveModel();\n\n        File parentPomFile = result.getRawModel( result.getModelIds().get( 1 ) ).getPomFile();\n        MavenProject project = fromModelToMavenProject( model, parentPomFile, configuration, model.getPomFile() );\n\n        project.setOriginalModel( result.getRawModel() );\n     \n        try\n        {\n            if ( configuration.isProcessPlugins() )\n            {\n                lifecycle.populateDefaultConfigurationForPlugins( model.getBuild().getPlugins(), configuration.getLocalRepository(), project.getPluginArtifactRepositories() );\n            }\n        }\n        catch ( LifecycleExecutionException e )\n        {\n            throw new ProjectBuildingException( \"\", e.getMessage(), e );\n        }\n\n        Build build = project.getBuild();\n        // NOTE: setting this script-source root before path translation, because\n        // the plugin tools compose basedir and scriptSourceRoot into a single file.\n        project.addScriptSourceRoot( build.getScriptSourceDirectory() );\n        project.addCompileSourceRoot( build.getSourceDirectory() );\n        project.addTestCompileSourceRoot( build.getTestSourceDirectory() );\n        project.setFile( pomFile );\n\n        List<Profile> activeProfiles = new ArrayList<Profile>();\n        activeProfiles.addAll( result.getActivePomProfiles( result.getModelIds().get( 0 ) ) );\n        activeProfiles.addAll( result.getActiveExternalProfiles() );\n        project.setActiveProfiles( activeProfiles );\n                \n        return project;\n    }","commit_id":"7f526ca65dd5ea9d9d9cb5ce6ae94ce2e3d98fef","url":"https://github.com/apache/maven"},{"original_method":"private String _removeSubjectPrefix(String subject) {\n\t\tif (Validator.isNotNull(subject)) {\n\t\t\tString subjectLowerCase = subject.toLowerCase(); \n\t\t\twhile (subjectLowerCase.startsWith(\"re:\") || \n\t\t\t\tsubjectLowerCase.startsWith(\"re>\") || \n\t\t\t\tsubjectLowerCase.startsWith(\"fw:\") || \n\t\t\t\tsubjectLowerCase.startsWith(\"fw>\"))\t{\n\t\n\t\t\t\tsubject = subject.substring(3).trim();\n\t\t\t\tsubjectLowerCase = subject.toLowerCase();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn subject;\n\t}","id":75708,"modified_method":"private String _removeSubjectPrefix(String subject, String prefix) {\n\t\tif (Validator.isNotNull(subject)) {\n\t\t\tString subjectLowerCase = subject.toLowerCase(); \n\n\t\t\twhile (subjectLowerCase.startsWith(prefix + \":\") || \n\t\t\t\tsubjectLowerCase.startsWith(prefix + \">\"))\t{\n\t\n\t\t\t\tsubject = subject.substring(3).trim();\n\t\t\t\tsubjectLowerCase = subject.toLowerCase();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn subject;\n\t}","commit_id":"f6a4edf33b8ef7b47df76781d6d65c7eec785351","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public ActionForward render(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig config,\n\t\t\tRenderRequest req, RenderResponse res)\n\t\tthrows Exception {\n\n\t\tString composeAction = ParamUtil.getString(req, \"composeAction\");\n\t\t\n\t\tif (\"replyAll\".equals(composeAction)) {\n\t\t\t// reply-all logic\n\t\t}\n\t\t\n\t\tif (\"forward\".equals(composeAction) || \"reply\".equals(composeAction)) {\n\t\t\tlong messageId = ParamUtil.getLong(req, \"messageId\");\n\t\t\tString folderId = ParamUtil.getString(req, \"folderId\");\n\t\n\t\t\tRenderRequestImpl reqImpl = (RenderRequestImpl)req;\n\t\t\tHttpServletRequest svltReq = reqImpl.getHttpServletRequest();\n\t\n\t\t\tMailMessage mm = \n\t\t\t\tMailUtil.getMessage(svltReq.getSession(), folderId, messageId);\n\t\n\t\t\tUser user = PortalUtil.getUser(req);\n\t\t\tDateFormat dateFormatter = \n\t\t\t\tDateFormats.getDateTime(user.getLocale(), user.getTimeZone());\n\t\t\treq.setAttribute(\n\t\t\t\tWebKeys.MAIL_MESSAGE, _buildBody(mm, dateFormatter));\n\t\n\t\t\tif (\"reply\".equals(composeAction)) {\n\t\t\t\tString userEmail = PortalUtil.getUser(req).getEmailAddress();\n\t\n\t\t\t\tInternetAddress [] tos = (InternetAddress [])mm.getTo();\n\t\t\t\tInternetAddress [] ccs = (InternetAddress [])mm.getCc();\n\t\t\t\tInternetAddress [] rtos = (InternetAddress [])mm.getReplyTo();\n\t\n\t\t\t\ttos = InternetAddressUtil.removeEntries(tos, userEmail);\n\t\t\t\tccs = InternetAddressUtil.removeEntries(ccs, userEmail);\n\t\t\t\t\n\t\t\t\tString tosStr = InternetAddressUtil.toString(tos);\n\t\t\t\tString rtosStr = InternetAddressUtil.toString(rtos);\n\t\t\t\tString ccsStr = InternetAddressUtil.toString(ccs);\n\t\t\t\t\n\t\t\t\tif (Validator.isNotNull(rtosStr)) {\n\t\t\t\t\ttosStr = \n\t\t\t\t\t\trtosStr + StringPool.COMMA + StringPool.SPACE + tosStr;\n\t\t\t\t}\n\t\n\t\t\t\tString [] recipients = { tosStr, ccsStr };\n\n\t\t\t\treq.setAttribute(WebKeys.MAIL_RECIPIENTS, recipients);\n\t\t\t\treq.setAttribute(WebKeys.MAIL_SUBJECT, \n\t\t\t\t\t\"Re: \" + _removeSubjectPrefix(mm.getSubject()));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treq.setAttribute(WebKeys.MAIL_SUBJECT,\n\t\t\t\t\t\"Fw: \" + _removeSubjectPrefix(mm.getSubject()));\n\t\t\t\treq.setAttribute(WebKeys.MAIL_ATTACHMENTS, \n\t\t\t\t\tmm.getRemoteAttachments());\n\t\t\t}\t\t\n\t\t}\n\n\t\treturn mapping.findForward(\n\t\t\tgetForward(req, \"portlet.mailbox.edit_message\"));\n\t}","id":75709,"modified_method":"public ActionForward render(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig config,\n\t\t\tRenderRequest req, RenderResponse res)\n\t\tthrows Exception {\n\n\t\tString composeAction = ParamUtil.getString(req, \"composeAction\");\n\t\t\n\t\tif (composeAction.equals(\"forward\") || \n\t\t\tcomposeAction.startsWith(\"reply\")) {\n\n\t\t\tlong messageId = ParamUtil.getLong(req, \"messageId\");\n\t\t\tString folderId = ParamUtil.getString(req, \"folderId\");\n\t\n\t\t\tRenderRequestImpl reqImpl = (RenderRequestImpl)req;\n\t\t\tHttpServletRequest svltReq = reqImpl.getHttpServletRequest();\n\t\n\t\t\tMailMessage mm = \n\t\t\t\tMailUtil.getMessage(svltReq.getSession(), folderId, messageId);\n\t\n\t\t\tUser user = PortalUtil.getUser(req);\n\t\t\tDateFormat dateFormatter = \n\t\t\t\tDateFormats.getDateTime(user.getLocale(), user.getTimeZone());\n\t\t\treq.setAttribute(\n\t\t\t\tWebKeys.MAIL_MESSAGE, _buildBody(mm, dateFormatter));\n\t\n\t\t\tif (composeAction.equals(\"forward\")) {\n\t\t\t\treq.setAttribute(WebKeys.MAIL_SUBJECT,\n\t\t\t\t\t\"Fw: \" + _removeSubjectPrefix(mm.getSubject(), \"fw\"));\n\t\t\t\treq.setAttribute(WebKeys.MAIL_ATTACHMENTS, \n\t\t\t\t\tmm.getRemoteAttachments());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString tosStr = StringPool.BLANK;\n\t\t\t\tString ccsStr = StringPool.BLANK;\n\t\t\t\t\n\t\t\t\tif (composeAction.equals(\"replyAll\")) {\n\t\t\t\t\tString userEmail =\n\t\t\t\t\t\tPortalUtil.getUser(req).getEmailAddress();\n\n\t\t\t\t\ttosStr = InternetAddressUtil.toString(\n\t\t\t\t\t\tInternetAddressUtil.removeEntry(mm.getTo(), userEmail));\n\t\t\t\t\tccsStr = InternetAddressUtil.toString(\n\t\t\t\t\t\tInternetAddressUtil.removeEntry(mm.getCc(), userEmail));\n\n\t\t\t\t\tString rtosStr = \n\t\t\t\t\t\tInternetAddressUtil.toString(mm.getReplyTo());\n\n\t\t\t\t\tif (Validator.isNull(rtosStr)) {\n\t\t\t\t\t\trtosStr = \n\t\t\t\t\t\t\t((InternetAddress)mm.getFrom()).toUnicodeString();\n\t\t\t\t\t}\n\n\t\t\t\t\ttosStr = \n\t\t\t\t\t\trtosStr + StringPool.COMMA + StringPool.SPACE + tosStr;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttosStr = InternetAddressUtil.toString(mm.getReplyTo());\n\n\t\t\t\t\tif (Validator.isNull(tosStr)) {\n\t\t\t\t\t\ttosStr = \n\t\t\t\t\t\t\t((InternetAddress)mm.getFrom()).toUnicodeString();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tString [] recipients = { \n\t\t\t\t\tHtml.escape(tosStr, true),\n\t\t\t\t\tHtml.escape(ccsStr, true)\n\t\t\t\t};\n\n\t\t\t\treq.setAttribute(WebKeys.MAIL_RECIPIENTS, recipients);\n\t\t\t\treq.setAttribute(WebKeys.MAIL_SUBJECT, \n\t\t\t\t\t\"Re: \" + _removeSubjectPrefix(mm.getSubject(), \"re\"));\n\t\t\t}\n\t\t}\n\n\t\treturn mapping.findForward(\n\t\t\tgetForward(req, \"portlet.mailbox.edit_message\"));\n\t}","commit_id":"f6a4edf33b8ef7b47df76781d6d65c7eec785351","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String toString(InternetAddress [] ias) {\r\n\t\tStringBuffer sb = new StringBuffer();\r\n\t\t\r\n\t\tif (ias != null) {\r\n\t\t\tfor (int i = 0; i < ias.length; i++) {\r\n\t\t\t\tsb.append(ias[i].toUnicodeString());\r\n\t\t\t\t\r\n\t\t\t\tif (i < ias.length - 1) {\r\n\t\t\t\t\tsb.append(StringPool.COMMA + StringPool.BLANK);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn sb.toString();\r\n\t}","id":75710,"modified_method":"public static String toString(Address [] as) {\r\n\t\tInternetAddress [] ias = (InternetAddress [])as;\r\n\r\n\t\tStringBuffer sb = new StringBuffer();\r\n\t\t\r\n\t\tif (ias != null) {\r\n\t\t\tfor (int i = 0; i < ias.length; i++) {\r\n\t\t\t\tsb.append(ias[i].toUnicodeString());\r\n\t\t\t\t\r\n\t\t\t\tif (i < ias.length - 1) {\r\n\t\t\t\t\tsb.append(StringPool.COMMA + StringPool.BLANK);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn sb.toString();\r\n\t}","commit_id":"f6a4edf33b8ef7b47df76781d6d65c7eec785351","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static InternetAddress [] removeEntries(\r\n\t\tInternetAddress [] ias, String emailAddress) {\r\n\r\n\t\tList list = new ArrayList();\r\n\r\n\t\tif (Validator.isNull(emailAddress) || ias == null) {\r\n\t\t\treturn ias;\r\n\t\t}\r\n\t\t\r\n\t\tfor (int i = 0; i < ias.length; i++) {\r\n\t\t\tif (!emailAddress.equals(ias[i].getAddress())) {\r\n\t\t\t\tlist.add(ias[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn (InternetAddress [])list.toArray(new InternetAddress [] {});\r\n\t}","id":75711,"modified_method":"public static InternetAddress [] removeEntry(\r\n\t\tAddress [] as, String emailAddress) {\r\n\r\n\t\tInternetAddress [] ias = (InternetAddress [])as;\r\n\r\n\t\tList list = new ArrayList();\r\n\r\n\t\tif (Validator.isNull(emailAddress) || ias == null) {\r\n\t\t\treturn ias;\r\n\t\t}\r\n\t\t\r\n\t\tfor (int i = 0; i < ias.length; i++) {\r\n\t\t\tif (!emailAddress.equals(ias[i].getAddress())) {\r\n\t\t\t\tlist.add(ias[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn (InternetAddress [])list.toArray(new InternetAddress [] {});\r\n\t}","commit_id":"f6a4edf33b8ef7b47df76781d6d65c7eec785351","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Creates a MIME message (message with binary content carrying capabilities) from an existing Mail\n     * \n     * @param mail The original Mail object\n     * @param session Mail session\n     * @return The MIME message\n     */\n    private MimeMessage createMimeMessage(Mail mail, Session session, XWikiContext context) throws MessagingException,\n        XWikiException, IOException\n    {\n        // this will also check for email error\n        InternetAddress from = new InternetAddress(mail.getFrom());\n        InternetAddress[] to =\n            toInternetAddresses(mail.getTo() + \",\" + StringUtils.defaultString(mail.getHeader(\"To\")));\n        InternetAddress[] cc =\n            toInternetAddresses(mail.getCc() + \",\" + StringUtils.defaultString(mail.getHeader(\"Cc\")));\n        InternetAddress[] bcc =\n            toInternetAddresses(mail.getBcc() + \",\" + StringUtils.defaultString(mail.getHeader(\"Bcc\")));\n\n        if ((to == null) && (cc == null) && (bcc == null)) {\n            LOG.info(\"No recipient -> skipping this email\");\n            return null;\n        }\n\n        MimeMessage message = new MimeMessage(session);\n        message.setSentDate(new Date());\n        message.setFrom(from);\n\n        if (to != null) {\n            message.setRecipients(javax.mail.Message.RecipientType.TO, to);\n        }\n\n        if (cc != null) {\n            message.setRecipients(javax.mail.Message.RecipientType.CC, cc);\n        }\n\n        if (bcc != null) {\n            message.setRecipients(javax.mail.Message.RecipientType.BCC, bcc);\n        }\n\n        message.setSubject(mail.getSubject(), \"UTF-8\");\n\n        for (Map.Entry<String, String> header : mail.getHeaders().entrySet()) {\n            message.setHeader(header.getKey(), header.getValue());\n        }\n\n        if (mail.getHtmlPart() != null || mail.getAttachments() != null) {\n            Multipart multipart = createMimeMultipart(mail, context);\n            message.setContent(multipart);\n        } else {\n            message.setText(mail.getTextPart());\n        }\n\n        message.setSentDate(new Date());\n        message.saveChanges();\n        return message;\n    }","id":75712,"modified_method":"/**\n     * Creates a MIME message (message with binary content carrying capabilities) from an existing Mail\n     * \n     * @param mail The original Mail object\n     * @param session Mail session\n     * @return The MIME message\n     */\n    private MimeMessage createMimeMessage(Mail mail, Session session, XWikiContext context) throws MessagingException,\n        XWikiException, IOException\n    {\n        // this will also check for email error\n        InternetAddress from = new InternetAddress(mail.getFrom());\n        String recipients = mail.getHeader(\"To\");\n        if (StringUtils.isBlank(recipients)) {\n            recipients = mail.getTo();\n        } else {\n            recipients = mail.getTo() + \",\" + recipients;\n        }\n        InternetAddress[] to = toInternetAddresses(recipients);\n        recipients = mail.getHeader(\"Cc\");\n        if (StringUtils.isBlank(recipients)) {\n            recipients = mail.getCc();\n        } else {\n            recipients = mail.getCc() + \",\" + recipients;\n        }\n        InternetAddress[] cc = toInternetAddresses(recipients);\n        recipients = mail.getHeader(\"Bcc\");\n        if (StringUtils.isBlank(recipients)) {\n            recipients = mail.getBcc();\n        } else {\n            recipients = mail.getBcc() + \",\" + recipients;\n        }\n        InternetAddress[] bcc = toInternetAddresses(recipients);\n\n        if ((to == null) && (cc == null) && (bcc == null)) {\n            LOG.info(\"No recipient -> skipping this email\");\n            return null;\n        }\n\n        MimeMessage message = new MimeMessage(session);\n        message.setSentDate(new Date());\n        message.setFrom(from);\n\n        if (to != null) {\n            message.setRecipients(javax.mail.Message.RecipientType.TO, to);\n        }\n\n        if (cc != null) {\n            message.setRecipients(javax.mail.Message.RecipientType.CC, cc);\n        }\n\n        if (bcc != null) {\n            message.setRecipients(javax.mail.Message.RecipientType.BCC, bcc);\n        }\n\n        message.setSubject(mail.getSubject(), \"UTF-8\");\n\n        for (Map.Entry<String, String> header : mail.getHeaders().entrySet()) {\n            message.setHeader(header.getKey(), header.getValue());\n        }\n\n        if (mail.getHtmlPart() != null || mail.getAttachments() != null) {\n            Multipart multipart = createMimeMultipart(mail, context);\n            message.setContent(multipart);\n        } else {\n            message.setText(mail.getTextPart());\n        }\n\n        message.setSentDate(new Date());\n        message.saveChanges();\n        return message;\n    }","commit_id":"e672d186aaf4e96fd955a70a8eae7fbc902f4113","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Creates a MIME message (message with binary content carrying capabilities) from an existing Mail\n     * \n     * @param mail The original Mail object\n     * @param session Mail session\n     * @return The MIME message\n     */\n    private MimeMessage createMimeMessage(Mail mail, Session session, XWikiContext context) throws MessagingException,\n        XWikiException, IOException\n    {\n        // this will also check for email error\n        InternetAddress from = new InternetAddress(mail.getFrom());\n        InternetAddress[] to = toInternetAddresses(mail.getTo());\n        InternetAddress[] cc = toInternetAddresses(mail.getCc());\n        InternetAddress[] bcc = toInternetAddresses(mail.getBcc());\n\n        if ((to == null) && (cc == null) && (bcc == null)) {\n            LOG.info(\"No recipient -> skipping this email\");\n            return null;\n        }\n\n        MimeMessage message = new MimeMessage(session);\n        message.setSentDate(new Date());\n        message.setFrom(from);\n\n        if (to != null) {\n            message.setRecipients(javax.mail.Message.RecipientType.TO, to);\n        }\n\n        if (cc != null) {\n            message.setRecipients(javax.mail.Message.RecipientType.CC, cc);\n        }\n\n        if (bcc != null) {\n            message.setRecipients(javax.mail.Message.RecipientType.BCC, bcc);\n        }\n\n        message.setSubject(mail.getSubject(), \"UTF-8\");\n\n        for (Map.Entry<String, String> header : mail.getHeaders().entrySet()) {\n            message.setHeader(header.getKey(), header.getValue());\n        }\n\n        if (mail.getHtmlPart() != null || mail.getAttachments() != null) {\n            Multipart multipart = createMimeMultipart(mail, context);\n            message.setContent(multipart);\n        } else {\n            message.setText(mail.getTextPart());\n        }\n\n        message.setSentDate(new Date());\n        message.saveChanges();\n        return message;\n    }","id":75713,"modified_method":"/**\n     * Creates a MIME message (message with binary content carrying capabilities) from an existing Mail\n     * \n     * @param mail The original Mail object\n     * @param session Mail session\n     * @return The MIME message\n     */\n    private MimeMessage createMimeMessage(Mail mail, Session session, XWikiContext context) throws MessagingException,\n        XWikiException, IOException\n    {\n        // this will also check for email error\n        InternetAddress from = new InternetAddress(mail.getFrom());\n        InternetAddress[] to =\n            toInternetAddresses(mail.getTo() + \",\" + StringUtils.defaultString(mail.getHeader(\"To\")));\n        InternetAddress[] cc =\n            toInternetAddresses(mail.getCc() + \",\" + StringUtils.defaultString(mail.getHeader(\"Cc\")));\n        InternetAddress[] bcc =\n            toInternetAddresses(mail.getBcc() + \",\" + StringUtils.defaultString(mail.getHeader(\"Bcc\")));\n\n        if ((to == null) && (cc == null) && (bcc == null)) {\n            LOG.info(\"No recipient -> skipping this email\");\n            return null;\n        }\n\n        MimeMessage message = new MimeMessage(session);\n        message.setSentDate(new Date());\n        message.setFrom(from);\n\n        if (to != null) {\n            message.setRecipients(javax.mail.Message.RecipientType.TO, to);\n        }\n\n        if (cc != null) {\n            message.setRecipients(javax.mail.Message.RecipientType.CC, cc);\n        }\n\n        if (bcc != null) {\n            message.setRecipients(javax.mail.Message.RecipientType.BCC, bcc);\n        }\n\n        message.setSubject(mail.getSubject(), \"UTF-8\");\n\n        for (Map.Entry<String, String> header : mail.getHeaders().entrySet()) {\n            message.setHeader(header.getKey(), header.getValue());\n        }\n\n        if (mail.getHtmlPart() != null || mail.getAttachments() != null) {\n            Multipart multipart = createMimeMultipart(mail, context);\n            message.setContent(multipart);\n        } else {\n            message.setText(mail.getTextPart());\n        }\n\n        message.setSentDate(new Date());\n        message.saveChanges();\n        return message;\n    }","commit_id":"da3ba6960e815114e11fa57171935479009a3df2","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public String getName()\n    {\n        return ID;\n    }","id":75714,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see com.xpn.xwiki.plugin.XWikiPluginInterface#getName()\n     */\n    @Override\n    public String getName()\n    {\n        return ID;\n    }","commit_id":"da3ba6960e815114e11fa57171935479009a3df2","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see XWikiDefaultPlugin#XWikiDefaultPlugin(String,String,com.xpn.xwiki.XWikiContext)\n     */\n    public MailSenderPlugin(String name, String className, XWikiContext context)\n    {\n        super(name, className, context);\n        init(context);\n    }","id":75715,"modified_method":"/**\n     * Default plugin constructor.\n     * \n     * @see XWikiDefaultPlugin#XWikiDefaultPlugin(String,String,com.xpn.xwiki.XWikiContext)\n     */\n    public MailSenderPlugin(String name, String className, XWikiContext context)\n    {\n        super(name, className, context);\n    }","commit_id":"da3ba6960e815114e11fa57171935479009a3df2","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see MailSender#sendMail(Mail, MailConfiguration)\n     */\n    public int sendMail(Mail mail, MailConfiguration mailConfiguration)\n    {\n        int result = 0;\n        try {\n            getProtectedPlugin().sendMail(mail, mailConfiguration, context);\n        } catch (Exception e) {\n            context.put(\"error\", e.getMessage());\n            LOG.error(\"Failed to send email [\" + mail.toString() + \"] using mail configuration [\"\n                + mailConfiguration.toString() + \"]\", e);\n            result = -1;\n        }\n\n        return result;\n    }","id":75716,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see MailSender#sendMail(Mail, MailConfiguration)\n     */\n    public int sendMail(Mail mail, MailConfiguration mailConfiguration)\n    {\n        int result = 0;\n        try {\n            getProtectedPlugin().sendMail(mail, mailConfiguration, this.context);\n        } catch (Exception e) {\n            this.context.put(\"error\", e.getMessage());\n            LOG.error(\"Failed to send email [\" + mail.toString() + \"] using mail configuration [\"\n                + mailConfiguration.toString() + \"]\", e);\n            result = -1;\n        }\n\n        return result;\n    }","commit_id":"da3ba6960e815114e11fa57171935479009a3df2","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see MailSender#sendMail(Mail)\n     */\n    public int sendMail(Mail mail)\n    {\n        int result = 0;\n        try {\n            getProtectedPlugin().sendMail(mail, context);\n        } catch (Exception e) {\n            context.put(\"error\", e.getMessage());\n            LOG.error(\"Failed to send email [\" + mail.toString() + \"]\", e);\n            result = -1;\n        }\n\n        return result;\n    }","id":75717,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see MailSender#sendMail(Mail)\n     */\n    public int sendMail(Mail mail)\n    {\n        int result = 0;\n        try {\n            getProtectedPlugin().sendMail(mail, this.context);\n        } catch (Exception e) {\n            this.context.put(\"error\", e.getMessage());\n            LOG.error(\"Failed to send email [\" + mail.toString() + \"]\", e);\n            result = -1;\n        }\n\n        return result;\n    }","commit_id":"da3ba6960e815114e11fa57171935479009a3df2","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see MailSender#sendMessageFromTemplate(String, String, String, String, String, String, VelocityContext)\n     */\n    public int sendMessageFromTemplate(String from, String to, String cc, String bcc, String language,\n        String documentFullName, VelocityContext vcontext)\n    {\n        try {\n            return getProtectedPlugin().sendMailFromTemplate(documentFullName, from, to, cc, bcc, language, vcontext,\n                context);\n        } catch (Exception e) {\n            context.put(\"error\", e.getMessage());\n            LOG.error(\"sendMessageFromTemplate\", e);\n            return -1;\n        }\n    }","id":75718,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see MailSender#sendMessageFromTemplate(String, String, String, String, String, String, VelocityContext)\n     */\n    public int sendMessageFromTemplate(String from, String to, String cc, String bcc, String language,\n        String documentFullName, VelocityContext vcontext)\n    {\n        try {\n            return getProtectedPlugin().sendMailFromTemplate(documentFullName, from, to, cc, bcc, language, vcontext,\n                this.context);\n        } catch (Exception e) {\n            this.context.put(\"error\", e.getMessage());\n            LOG.error(\"sendMessageFromTemplate\", e);\n            return -1;\n        }\n    }","commit_id":"da3ba6960e815114e11fa57171935479009a3df2","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected void perform(final XValueNodeImpl node, @NotNull final String nodeName, final AnActionEvent e) {\n    XDebugSession session = node.getTree().getSession();\n    XDebugSessionTab sessionTab = ((XDebugSessionImpl)session).getSessionTab();\n    sessionTab.getWatchesView().addWatchExpression(node.getValueContainer().getEvaluationExpression());\n  }","id":75719,"modified_method":"protected void perform(final XValueNodeImpl node, @NotNull final String nodeName, final AnActionEvent e) {\n    XDebugSession session = node.getTree().getSession();\n    XDebugSessionTab sessionTab = ((XDebugSessionImpl)session).getSessionTab();\n    String expression = node.getValueContainer().getEvaluationExpression();\n    if (expression != null) {\n      sessionTab.getWatchesView().addWatchExpression(expression);\n    }\n  }","commit_id":"a0b376397b7540bd74df054673a94304bc911c78","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public abstract String getDisplayText(final XLineBreakpoint<P> breakpoint);","id":75720,"modified_method":"public String getDisplayText(final XLineBreakpoint<P> breakpoint) {\n    return XDebuggerBundle.message(\"xbreakpoint.default.display.text\", breakpoint.getLine() + 1, breakpoint.getPresentableFilePath());\n  }","commit_id":"a0b376397b7540bd74df054673a94304bc911c78","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public XWatchesView(final XDebugSession session, final Disposable parentDisposable, final XDebugSessionData sessionData) {\n    super(session, parentDisposable);\n    myTreePanel = new XDebuggerTreePanel(session, session.getDebugProcess().getEditorsProvider(), null,\n                                         XDebuggerActions.WATCHES_TREE_POPUP_GROUP);\n    myWatchExpressions.addAll(Arrays.asList(sessionData.getWatchExpressions()));\n  }","id":75721,"modified_method":"public XWatchesView(final XDebugSession session, final Disposable parentDisposable, final XDebugSessionData sessionData) {\n    super(session, parentDisposable);\n    myTreePanel = new XDebuggerTreePanel(session, session.getDebugProcess().getEditorsProvider(), null,\n                                         XDebuggerActions.WATCHES_TREE_POPUP_GROUP);\n    ActionManager actionManager = ActionManager.getInstance();\n    CustomShortcutSet insertShortcut = new CustomShortcutSet(KeyStroke.getKeyStroke(KeyEvent.VK_INSERT, 0));\n    actionManager.getAction(XDebuggerActions.XNEW_WATCH).registerCustomShortcutSet(insertShortcut, getMainPanel());\n    CustomShortcutSet deleteShortcut = new CustomShortcutSet(KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0));\n    actionManager.getAction(XDebuggerActions.XREMOVE_WATCH).registerCustomShortcutSet(deleteShortcut, getMainPanel());\n    myWatchExpressions.addAll(Arrays.asList(sessionData.getWatchExpressions()));\n  }","commit_id":"a0b376397b7540bd74df054673a94304bc911c78","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Checks if value has evaluation expression ready, or calculation is pending\n   */\n  public static boolean hasEvaluationExpression(@NotNull XValue value) {\n    Promise<String> promise = value.calculateEvaluationExpression();\n    if (promise.getState() == Promise.State.PENDING) return true;\n    if (promise instanceof Getter) {\n      return ((Getter)promise).get() != null;\n    }\n    return true;\n  }","id":75722,"modified_method":"/**\n   * Checks if value has evaluation expression ready, or calculation is pending\n   */\n  public static boolean hasEvaluationExpression(@NotNull XValue value) {\n    Promise<XExpression> promise = value.calculateEvaluationExpression();\n    if (promise.getState() == Promise.State.PENDING) return true;\n    if (promise instanceof Getter) {\n      return ((Getter)promise).get() != null;\n    }\n    return true;\n  }","commit_id":"f746f1e8aacf43e87ab15d5250bf706dd7ca7bfe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void perform(XValueNodeImpl node, @NotNull String nodeName, AnActionEvent e) {\n    final ConsoleExecuteAction action = getConsoleExecuteAction(e);\n    if (action != null) {\n      node.getValueContainer().calculateEvaluationExpression().done(new Consumer<String>() {\n        @Override\n        public void consume(String expression) {\n          if (expression != null) {\n            action.execute(null, expression, null);\n          }\n        }\n      });\n    }\n  }","id":75723,"modified_method":"@Override\n  protected void perform(XValueNodeImpl node, @NotNull String nodeName, AnActionEvent e) {\n    final ConsoleExecuteAction action = getConsoleExecuteAction(e);\n    if (action != null) {\n      node.getValueContainer().calculateEvaluationExpression().done(new Consumer<XExpression>() {\n        @Override\n        public void consume(XExpression expression) {\n          if (expression != null) {\n            action.execute(null, expression.getExpression(), null);\n          }\n        }\n      });\n    }\n  }","commit_id":"f746f1e8aacf43e87ab15d5250bf706dd7ca7bfe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public Promise<String> calculateEvaluationExpression() {\n    if (evaluationExpression != null) {\n      return Promise.resolve(evaluationExpression);\n    }\n    else {\n      final AsyncPromise<String> res = new AsyncPromise<String>();\n      myEvaluationContext.getManagerThread().schedule(new SuspendContextCommandImpl(myEvaluationContext.getSuspendContext()) {\n        @Override\n        public Priority getPriority() {\n          return Priority.HIGH;\n        }\n\n        @Override\n        public void contextAction() throws Exception {\n          evaluationExpression = ApplicationManager.getApplication().runReadAction(new Computable<String>() {\n            @Override\n            public String compute() {\n              try {\n                PsiExpression psiExpression = getDescriptor().getTreeEvaluation(JavaValue.this, getDebuggerContext());\n                if (psiExpression != null) {\n                  return new TextWithImportsImpl(psiExpression).getText();\n                }\n              }\n              catch (EvaluateException e) {\n                LOG.info(e);\n              }\n              return null;\n            }\n          });\n          res.setResult(evaluationExpression);\n        }\n      });\n      return res;\n    }\n  }","id":75724,"modified_method":"@NotNull\n  @Override\n  public Promise<XExpression> calculateEvaluationExpression() {\n    if (evaluationExpression != null) {\n      return Promise.resolve(evaluationExpression);\n    }\n    else {\n      final AsyncPromise<XExpression> res = new AsyncPromise<XExpression>();\n      myEvaluationContext.getManagerThread().schedule(new SuspendContextCommandImpl(myEvaluationContext.getSuspendContext()) {\n        @Override\n        public Priority getPriority() {\n          return Priority.HIGH;\n        }\n\n        @Override\n        public void contextAction() throws Exception {\n          evaluationExpression = ApplicationManager.getApplication().runReadAction(new Computable<XExpression>() {\n            @Override\n            public XExpression compute() {\n              try {\n                PsiExpression psiExpression = getDescriptor().getTreeEvaluation(JavaValue.this, getDebuggerContext());\n                if (psiExpression != null) {\n                  return TextWithImportsImpl.toXExpression(new TextWithImportsImpl(psiExpression));\n                }\n              }\n              catch (EvaluateException e) {\n                LOG.info(e);\n              }\n              return null;\n            }\n          });\n          res.setResult(evaluationExpression);\n        }\n      });\n      return res;\n    }\n  }","commit_id":"f746f1e8aacf43e87ab15d5250bf706dd7ca7bfe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void perform(final XValueNodeImpl node, @NotNull final String nodeName, final AnActionEvent e) {\n    final XWatchesView watchesView = getWatchesView(e);\n    if (watchesView != null) {\n      node.getValueContainer().calculateEvaluationExpression().done(new Consumer<String>() {\n        @Override\n        public void consume(String expression) {\n          if (!StringUtil.isEmpty(expression)) {\n            watchesView.addWatchExpression(XExpressionImpl.fromText(expression), -1, true);\n          }\n        }\n      });\n    }\n  }","id":75725,"modified_method":"@Override\n  protected void perform(final XValueNodeImpl node, @NotNull final String nodeName, final AnActionEvent e) {\n    final XWatchesView watchesView = getWatchesView(e);\n    if (watchesView != null) {\n      node.getValueContainer().calculateEvaluationExpression().done(new Consumer<XExpression>() {\n        @Override\n        public void consume(XExpression expression) {\n          if (expression != null) {\n            watchesView.addWatchExpression(expression, -1, true);\n          }\n        }\n      });\n    }\n  }","commit_id":"f746f1e8aacf43e87ab15d5250bf706dd7ca7bfe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void perform(@NotNull final XDebugSession session, final DataContext dataContext) {\n    final XDebuggerEditorsProvider editorsProvider = session.getDebugProcess().getEditorsProvider();\n    final XStackFrame stackFrame = session.getCurrentStackFrame();\n    final XDebuggerEvaluator evaluator = session.getDebugProcess().getEvaluator();\n    if (evaluator == null) {\n      return;\n    }\n\n    Editor editor = CommonDataKeys.EDITOR.getData(dataContext);\n\n    EvaluationMode mode = EvaluationMode.EXPRESSION;\n    String selectedText = editor != null ? editor.getSelectionModel().getSelectedText() : null;\n    if (selectedText != null) {\n      selectedText = evaluator.formatTextForEvaluation(selectedText);\n      mode = evaluator.getEvaluationMode(selectedText,\n                                         editor.getSelectionModel().getSelectionStart(),\n                                         editor.getSelectionModel().getSelectionEnd(),\n                                         CommonDataKeys.PSI_FILE.getData(dataContext));\n    }\n    String text = selectedText;\n\n    if (text == null && editor != null) {\n      text = getExpressionText(evaluator, CommonDataKeys.PROJECT.getData(dataContext), editor);\n    }\n\n    final VirtualFile file = CommonDataKeys.VIRTUAL_FILE.getData(dataContext);\n\n    if (text == null) {\n      XValue value = XDebuggerTreeActionBase.getSelectedValue(dataContext);\n      if (value != null) {\n        final EvaluationMode evalMode = mode;\n        value.calculateEvaluationExpression().done(new Consumer<String>() {\n          @Override\n          public void consume(final String text) {\n            AppUIUtil.invokeOnEdt(new Runnable() {\n              @Override\n              public void run() {\n                showDialog(session, file, editorsProvider, stackFrame, evaluator, evalMode, text);\n              }\n            });\n          }\n        });\n        return;\n      }\n    }\n\n    showDialog(session, file, editorsProvider, stackFrame, evaluator, mode, text);\n  }","id":75726,"modified_method":"@Override\n  protected void perform(@NotNull final XDebugSession session, final DataContext dataContext) {\n    final XDebuggerEditorsProvider editorsProvider = session.getDebugProcess().getEditorsProvider();\n    final XStackFrame stackFrame = session.getCurrentStackFrame();\n    final XDebuggerEvaluator evaluator = session.getDebugProcess().getEvaluator();\n    if (evaluator == null) {\n      return;\n    }\n\n    Editor editor = CommonDataKeys.EDITOR.getData(dataContext);\n\n    EvaluationMode mode = EvaluationMode.EXPRESSION;\n    String selectedText = editor != null ? editor.getSelectionModel().getSelectedText() : null;\n    if (selectedText != null) {\n      selectedText = evaluator.formatTextForEvaluation(selectedText);\n      mode = evaluator.getEvaluationMode(selectedText,\n                                         editor.getSelectionModel().getSelectionStart(),\n                                         editor.getSelectionModel().getSelectionEnd(),\n                                         CommonDataKeys.PSI_FILE.getData(dataContext));\n    }\n    String text = selectedText;\n\n    if (text == null && editor != null) {\n      text = getExpressionText(evaluator, CommonDataKeys.PROJECT.getData(dataContext), editor);\n    }\n\n    final VirtualFile file = CommonDataKeys.VIRTUAL_FILE.getData(dataContext);\n\n    if (text == null) {\n      XValue value = XDebuggerTreeActionBase.getSelectedValue(dataContext);\n      if (value != null) {\n        value.calculateEvaluationExpression().done(new Consumer<XExpression>() {\n          @Override\n          public void consume(final XExpression expression) {\n            AppUIUtil.invokeOnEdt(new Runnable() {\n              @Override\n              public void run() {\n                showDialog(session, file, editorsProvider, stackFrame, evaluator, expression);\n              }\n            });\n          }\n        });\n        return;\n      }\n    }\n\n    XExpression expression = XExpressionImpl.fromText(StringUtil.notNullize(text), mode);\n    showDialog(session, file, editorsProvider, stackFrame, evaluator, expression);\n  }","commit_id":"f746f1e8aacf43e87ab15d5250bf706dd7ca7bfe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void showDialog(@NotNull XDebugSession session,\n                                 VirtualFile file,\n                                 XDebuggerEditorsProvider editorsProvider,\n                                 XStackFrame stackFrame, XDebuggerEvaluator evaluator, EvaluationMode mode, String text) {\n    Language language = null;\n    if (stackFrame != null) {\n      XSourcePosition position = stackFrame.getSourcePosition();\n      if (position != null) {\n        language = XDebuggerEditorBase.getFileTypeLanguage(position.getFile().getFileType());\n      }\n    }\n    if (language == null && file != null) {\n      language = XDebuggerEditorBase.getFileTypeLanguage(file.getFileType());\n    }\n    XExpression expression = new XExpressionImpl(StringUtil.notNullize(text), language, null, mode);\n    new XDebuggerEvaluationDialog(session, editorsProvider, evaluator, expression, stackFrame == null ? null : stackFrame.getSourcePosition()).show();\n  }","id":75727,"modified_method":"private static void showDialog(@NotNull XDebugSession session,\n                                 VirtualFile file,\n                                 XDebuggerEditorsProvider editorsProvider,\n                                 XStackFrame stackFrame,\n                                 XDebuggerEvaluator evaluator,\n                                 XExpression expression) {\n    if (expression.getLanguage() == null) {\n      Language language = null;\n      if (stackFrame != null) {\n        XSourcePosition position = stackFrame.getSourcePosition();\n        if (position != null) {\n          language = XDebuggerEditorBase.getFileTypeLanguage(position.getFile().getFileType());\n        }\n      }\n      if (language == null && file != null) {\n        language = XDebuggerEditorBase.getFileTypeLanguage(file.getFileType());\n      }\n      expression = new XExpressionImpl(expression.getExpression(), language, expression.getCustomInfo(), expression.getMode());\n    }\n    new XDebuggerEvaluationDialog(session, editorsProvider, evaluator, expression, stackFrame == null ? null : stackFrame.getSourcePosition()).show();\n  }","commit_id":"f746f1e8aacf43e87ab15d5250bf706dd7ca7bfe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Asynchronously calculates expression which evaluates to the current value\n   */\n  @NotNull\n  public Promise<String> calculateEvaluationExpression() {\n    return Promise.resolve(getEvaluationExpression());\n  }","id":75728,"modified_method":"/**\n   * Asynchronously calculates expression which evaluates to the current value\n   */\n  @NotNull\n  public Promise<XExpression> calculateEvaluationExpression() {\n    String expression = getEvaluationExpression();\n    XExpression res =\n      expression != null ? XDebuggerUtil.getInstance().createExpression(expression, null, null, EvaluationMode.EXPRESSION) : null;\n    return Promise.resolve(res);\n  }","commit_id":"f746f1e8aacf43e87ab15d5250bf706dd7ca7bfe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void drop(DnDEvent aEvent) {\n    Object object = aEvent.getAttachedObject();\n    if (object instanceof XValueNodeImpl[]) {\n      final XValueNodeImpl[] nodes = (XValueNodeImpl[])object;\n      for (XValueNodeImpl node : nodes) {\n        node.getValueContainer().calculateEvaluationExpression().done(new Consumer<String>() {\n          @Override\n          public void consume(String expression) {\n            if (expression != null) {\n              //noinspection ConstantConditions\n              addWatchExpression(XExpressionImpl.fromText(expression), -1, false);\n            }\n          }\n        });\n      }\n    }\n    else if (object instanceof EventInfo) {\n      String text = ((EventInfo)object).getTextForFlavor(DataFlavor.stringFlavor);\n      if (text != null) {\n        //noinspection ConstantConditions\n        addWatchExpression(XExpressionImpl.fromText(text), -1, false);\n      }\n    }\n  }","id":75729,"modified_method":"@Override\n  public void drop(DnDEvent aEvent) {\n    Object object = aEvent.getAttachedObject();\n    if (object instanceof XValueNodeImpl[]) {\n      final XValueNodeImpl[] nodes = (XValueNodeImpl[])object;\n      for (XValueNodeImpl node : nodes) {\n        node.getValueContainer().calculateEvaluationExpression().done(new Consumer<XExpression>() {\n          @Override\n          public void consume(XExpression expression) {\n            if (expression != null) {\n              //noinspection ConstantConditions\n              addWatchExpression(expression, -1, false);\n            }\n          }\n        });\n      }\n    }\n    else if (object instanceof EventInfo) {\n      String text = ((EventInfo)object).getTextForFlavor(DataFlavor.stringFlavor);\n      if (text != null) {\n        //noinspection ConstantConditions\n        addWatchExpression(XExpressionImpl.fromText(text), -1, false);\n      }\n    }\n  }","commit_id":"f746f1e8aacf43e87ab15d5250bf706dd7ca7bfe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void perform(@NotNull final XDebugSession session, final DataContext dataContext) {\n    XDebuggerEditorsProvider editorsProvider = session.getDebugProcess().getEditorsProvider();\n    XStackFrame stackFrame = session.getCurrentStackFrame();\n    final XDebuggerEvaluator evaluator = session.getDebugProcess().getEvaluator();\n    if (evaluator == null) {\n      return;\n    }\n\n    Editor editor = CommonDataKeys.EDITOR.getData(dataContext);\n\n    String selectedText = editor != null ? editor.getSelectionModel().getSelectedText() : null;\n    if (selectedText != null) {\n      selectedText = evaluator.formatTextForEvaluation(selectedText);\n    }\n    String text = selectedText;\n\n    if (text == null && editor != null) {\n      text = getExpressionText(evaluator, CommonDataKeys.PROJECT.getData(dataContext), editor);\n    }\n\n    if (text == null) {\n      XValue value = XDebuggerTreeActionBase.getSelectedValue(dataContext);\n      if (value != null) {\n        text = value.getEvaluationExpression();\n      }\n    }\n\n    Language language = null;\n    if (stackFrame != null) {\n      XSourcePosition position = stackFrame.getSourcePosition();\n      if (position != null) {\n        language = XDebuggerEditorBase.getFileTypeLanguage(position.getFile().getFileType());\n      }\n    }\n    if (language == null) {\n      VirtualFile file = CommonDataKeys.VIRTUAL_FILE.getData(dataContext);\n      if (file != null) {\n        language = XDebuggerEditorBase.getFileTypeLanguage(file.getFileType());\n      }\n    }\n    XExpression expression = new XExpressionImpl(StringUtil.notNullize(text), language, null);\n    new XDebuggerEvaluationDialog(session, editorsProvider, evaluator, expression, stackFrame == null ? null : stackFrame.getSourcePosition()).show();\n  }","id":75730,"modified_method":"@Override\n  protected void perform(@NotNull final XDebugSession session, final DataContext dataContext) {\n    XDebuggerEditorsProvider editorsProvider = session.getDebugProcess().getEditorsProvider();\n    XStackFrame stackFrame = session.getCurrentStackFrame();\n    final XDebuggerEvaluator evaluator = session.getDebugProcess().getEvaluator();\n    if (evaluator == null) {\n      return;\n    }\n\n    Editor editor = CommonDataKeys.EDITOR.getData(dataContext);\n\n    XExpression expression = null;\n    if (editor != null) {\n      expression = evaluator.getEditorExpression(editor, CommonDataKeys.PSI_FILE.getData(dataContext));\n    }\n\n    Language language = calcLanguage(stackFrame, dataContext);\n\n    if (expression != null && !Comparing.equal(language, expression.getLanguage())) { // may need to change language\n      expression = new XExpressionImpl(expression.getExpression(), language, expression.getCustomInfo(), expression.getMode());\n    }\n\n    if (expression == null) {\n      XValue value = XDebuggerTreeActionBase.getSelectedValue(dataContext);\n      if (value != null) {\n        String text = value.getEvaluationExpression();\n        if (!StringUtil.isEmpty(text)) {\n          expression = new XExpressionImpl(text, language, null);\n        }\n      }\n    }\n\n    if (expression == null) {\n      expression = new XExpressionImpl(\"\", language, null);\n    }\n    new XDebuggerEvaluationDialog(session, editorsProvider, evaluator, expression, stackFrame == null ? null : stackFrame.getSourcePosition()).show();\n  }","commit_id":"0371955a2e42e72c95047e21c1d190477e6e8bac","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public XDebuggerEvaluationDialog(@NotNull XDebugSession session,\n                                   @NotNull XDebuggerEditorsProvider editorsProvider,\n                                   @NotNull XDebuggerEvaluator evaluator,\n                                   @NotNull XExpression text,\n                                   @Nullable XSourcePosition sourcePosition) {\n    super(session.getProject(), true);\n    mySession = session;\n    myEditorsProvider = editorsProvider;\n    mySourcePosition = sourcePosition;\n    setModal(false);\n    setOKButtonText(XDebuggerBundle.message(\"xdebugger.button.evaluate\"));\n    setCancelButtonText(XDebuggerBundle.message(\"xdebugger.evaluate.dialog.close\"));\n\n    mySession.addSessionListener(new XDebugSessionAdapter() {\n      @Override\n      public void sessionStopped() {\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          @Override\n          public void run() {\n            close(CANCEL_EXIT_CODE);\n          }\n        });\n      }\n\n      @Override\n      public void stackFrameChanged() {\n        updateSourcePosition();\n      }\n\n      @Override\n      public void sessionPaused() {\n        updateSourcePosition();\n      }\n    }, myDisposable);\n\n    myTreePanel = new XDebuggerTreePanel(session.getProject(), editorsProvider, myDisposable, sourcePosition, XDebuggerActions.EVALUATE_DIALOG_TREE_POPUP_GROUP,\n                                         ((XDebugSessionImpl)session).getValueMarkers());\n    myResultPanel = new JPanel(new BorderLayout());\n    myResultPanel.add(new JLabel(XDebuggerBundle.message(\"xdebugger.evaluate.label.result\")), BorderLayout.NORTH);\n    myResultPanel.add(myTreePanel.getMainPanel(), BorderLayout.CENTER);\n    myMainPanel = new JPanel(new BorderLayout());\n\n    mySwitchModeAction = new SwitchModeAction();\n\n    new AnAction(){\n      @Override\n      public void actionPerformed(AnActionEvent e) {\n        doOKAction();\n      }\n    }.registerCustomShortcutSet(new CustomShortcutSet(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, InputEvent.CTRL_DOWN_MASK)), getRootPane(), myDisposable);\n\n    new AnAction(){\n      @Override\n      public void actionPerformed(AnActionEvent e) {\n        doOKAction();\n        addToWatches();\n      }\n    }.registerCustomShortcutSet(new CustomShortcutSet(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, InputEvent.CTRL_DOWN_MASK | InputEvent.SHIFT_DOWN_MASK)), getRootPane(), myDisposable);\n\n    new AnAction() {\n      @Override\n      public void actionPerformed(AnActionEvent e) {\n        IdeFocusManager.getInstance(mySession.getProject()).requestFocus(myTreePanel.getTree(), true);\n      }\n    }.registerCustomShortcutSet(new CustomShortcutSet(KeyStroke.getKeyStroke(KeyEvent.VK_R, InputEvent.ALT_DOWN_MASK)), getRootPane(),\n                                myDisposable);\n\n    myTreePanel.getTree().expandNodesOnLoad(new Condition<TreeNode>() {\n      @Override\n      public boolean value(TreeNode node) {\n        return node.getParent() instanceof EvaluatingExpressionRootNode;\n      }\n    });\n\n    EvaluationMode mode = XDebuggerSettingsManager.getInstanceImpl().getGeneralSettings().getEvaluationDialogMode();\n    myIsCodeFragmentEvaluationSupported = evaluator.isCodeFragmentEvaluationSupported();\n    if (mode == EvaluationMode.CODE_FRAGMENT && !myIsCodeFragmentEvaluationSupported) {\n      mode = EvaluationMode.EXPRESSION;\n    }\n    switchToMode(mode, text);\n    init();\n  }","id":75731,"modified_method":"public XDebuggerEvaluationDialog(@NotNull XDebugSession session,\n                                   @NotNull XDebuggerEditorsProvider editorsProvider,\n                                   @NotNull XDebuggerEvaluator evaluator,\n                                   @NotNull XExpression text,\n                                   @Nullable XSourcePosition sourcePosition) {\n    super(session.getProject(), true);\n    mySession = session;\n    myEditorsProvider = editorsProvider;\n    mySourcePosition = sourcePosition;\n    setModal(false);\n    setOKButtonText(XDebuggerBundle.message(\"xdebugger.button.evaluate\"));\n    setCancelButtonText(XDebuggerBundle.message(\"xdebugger.evaluate.dialog.close\"));\n\n    mySession.addSessionListener(new XDebugSessionAdapter() {\n      @Override\n      public void sessionStopped() {\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          @Override\n          public void run() {\n            close(CANCEL_EXIT_CODE);\n          }\n        });\n      }\n\n      @Override\n      public void stackFrameChanged() {\n        updateSourcePosition();\n      }\n\n      @Override\n      public void sessionPaused() {\n        updateSourcePosition();\n      }\n    }, myDisposable);\n\n    myTreePanel = new XDebuggerTreePanel(session.getProject(), editorsProvider, myDisposable, sourcePosition, XDebuggerActions.EVALUATE_DIALOG_TREE_POPUP_GROUP,\n                                         ((XDebugSessionImpl)session).getValueMarkers());\n    myResultPanel = new JPanel(new BorderLayout());\n    myResultPanel.add(new JLabel(XDebuggerBundle.message(\"xdebugger.evaluate.label.result\")), BorderLayout.NORTH);\n    myResultPanel.add(myTreePanel.getMainPanel(), BorderLayout.CENTER);\n    myMainPanel = new JPanel(new BorderLayout());\n\n    mySwitchModeAction = new SwitchModeAction();\n\n    new AnAction(){\n      @Override\n      public void actionPerformed(AnActionEvent e) {\n        doOKAction();\n      }\n    }.registerCustomShortcutSet(new CustomShortcutSet(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, InputEvent.CTRL_DOWN_MASK)), getRootPane(), myDisposable);\n\n    new AnAction(){\n      @Override\n      public void actionPerformed(AnActionEvent e) {\n        doOKAction();\n        addToWatches();\n      }\n    }.registerCustomShortcutSet(new CustomShortcutSet(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, InputEvent.CTRL_DOWN_MASK | InputEvent.SHIFT_DOWN_MASK)), getRootPane(), myDisposable);\n\n    new AnAction() {\n      @Override\n      public void actionPerformed(AnActionEvent e) {\n        IdeFocusManager.getInstance(mySession.getProject()).requestFocus(myTreePanel.getTree(), true);\n      }\n    }.registerCustomShortcutSet(new CustomShortcutSet(KeyStroke.getKeyStroke(KeyEvent.VK_R, InputEvent.ALT_DOWN_MASK)), getRootPane(),\n                                myDisposable);\n\n    myTreePanel.getTree().expandNodesOnLoad(new Condition<TreeNode>() {\n      @Override\n      public boolean value(TreeNode node) {\n        return node.getParent() instanceof EvaluatingExpressionRootNode;\n      }\n    });\n\n    EvaluationMode mode = XDebuggerSettingsManager.getInstanceImpl().getGeneralSettings().getEvaluationDialogMode();\n    myIsCodeFragmentEvaluationSupported = evaluator.isCodeFragmentEvaluationSupported();\n    if (mode == EvaluationMode.CODE_FRAGMENT && !myIsCodeFragmentEvaluationSupported) {\n      mode = EvaluationMode.EXPRESSION;\n    }\n    if (mode == EvaluationMode.EXPRESSION && text.getMode() == EvaluationMode.CODE_FRAGMENT && myIsCodeFragmentEvaluationSupported) {\n      mode = EvaluationMode.CODE_FRAGMENT;\n    }\n    switchToMode(mode, text);\n    init();\n  }","commit_id":"0371955a2e42e72c95047e21c1d190477e6e8bac","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void switchToMode(EvaluationMode mode, XExpression text) {\n    if (myMode == mode) return;\n\n    XDebuggerSettingsManager.getInstanceImpl().getGeneralSettings().setEvaluationDialogMode(mode);\n\n    myMode = mode;\n\n    if (mode == EvaluationMode.EXPRESSION) {\n      text = new XExpressionImpl(StringUtil.replace(text.getExpression(), \"\\n\", \" \"), text.getLanguage(), text.getCustomInfo());\n    }\n\n    myInputComponent = createInputComponent(mode, text);\n    myMainPanel.removeAll();\n    myInputComponent.addComponent(myMainPanel, myResultPanel);\n\n    setTitle(myInputComponent.getTitle());\n    mySwitchModeAction.putValue(Action.NAME, getSwitchButtonText(mode));\n    requestFocusInEditor();\n  }","id":75732,"modified_method":"private void switchToMode(EvaluationMode mode, XExpression text) {\n    if (myMode == mode) return;\n\n    myMode = mode;\n\n    if (mode == EvaluationMode.EXPRESSION) {\n      text = new XExpressionImpl(StringUtil.replace(text.getExpression(), \"\\n\", \" \"), text.getLanguage(), text.getCustomInfo());\n    }\n\n    myInputComponent = createInputComponent(mode, text);\n    myMainPanel.removeAll();\n    myInputComponent.addComponent(myMainPanel, myResultPanel);\n\n    setTitle(myInputComponent.getTitle());\n    mySwitchModeAction.putValue(Action.NAME, getSwitchButtonText(mode));\n    requestFocusInEditor();\n  }","commit_id":"0371955a2e42e72c95047e21c1d190477e6e8bac","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void actionPerformed(ActionEvent e) {\n      XExpression text = getInputEditor().getExpression();\n      if (myMode == EvaluationMode.EXPRESSION) {\n        switchToMode(EvaluationMode.CODE_FRAGMENT, text);\n      }\n      else {\n        switchToMode(EvaluationMode.EXPRESSION, text);\n      }\n    }","id":75733,"modified_method":"@Override\n    public void actionPerformed(ActionEvent e) {\n      XExpression text = getInputEditor().getExpression();\n      EvaluationMode newMode = (myMode == EvaluationMode.EXPRESSION) ? EvaluationMode.CODE_FRAGMENT : EvaluationMode.EXPRESSION;\n      // remember only on user selection\n      XDebuggerSettingsManager.getInstanceImpl().getGeneralSettings().setEvaluationDialogMode(newMode);\n      switchToMode(newMode, text);\n    }","commit_id":"0371955a2e42e72c95047e21c1d190477e6e8bac","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public List<MethodMatch> findDuplicates(SNode root) {\n    List<MethodMatch> found = new ArrayList<MethodMatch>();\n    if (ListSequence.fromList(this.myNodesToFind).count() == 1) {\n      for (SNode node : ListSequence.fromList(SNodeOperations.getDescendants(root, \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{}))) {\n        if (ListSequence.fromList(this.myNodesToFind).contains(node)) {\n          continue;\n        }\n        MethodDuplicatesFinder.MethodMatchModifier modifier = new MethodDuplicatesFinder.MethodMatchModifier();\n        modifier.getMatch().putNode(node);\n        if (MatchingUtil.matchNodes(node, ListSequence.fromList(this.myNodesToFind).first(), modifier, true)) {\n          MethodMatch resultMatch = modifier.getMatch();\n          if (resultMatch.checkMapping()) {\n            found.add(resultMatch);\n          }\n        }\n      }\n    }\n    return found;\n  }","id":75734,"modified_method":"public List<MethodMatch> findDuplicates(SNode root) {\n    List<MethodMatch> found = new ArrayList<MethodMatch>();\n    for (SNode node : ListSequence.fromList(SNodeOperations.getDescendants(root, \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{}))) {\n      SNode current = node;\n      MethodDuplicatesFinder.MethodMatchModifier modifier = new MethodDuplicatesFinder.MethodMatchModifier();\n      Iterator<SNode> iterator = ListSequence.fromList(this.myNodesToFind).iterator();\n      boolean hasNoErrors = true;\n      while (iterator.hasNext() && hasNoErrors) {\n        if ((current == null) || SetSequence.fromSet(this.myUsedNodes).contains(current)) {\n          hasNoErrors = false;\n        } else {\n          modifier.getMatch().putNode(current);\n          if (!(MatchingUtil.matchNodes(current, iterator.next(), modifier, true))) {\n            hasNoErrors = false;\n          }\n          current = SNodeOperations.getNextSibling(current);\n        }\n      }\n      MethodMatch resultMatch = modifier.getMatch();\n      if (hasNoErrors && resultMatch.checkMapping()) {\n        for (SNode resultNode : ListSequence.fromList(resultMatch.getNodes())) {\n          SetSequence.fromSet(this.myUsedNodes).addElement(resultNode);\n        }\n        found.add(resultMatch);\n      }\n    }\n    return found;\n  }","commit_id":"3c6742bfe631cd4ea9d05243589ed8da2109f6e9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public MethodDuplicatesFinder(List<SNode> nodesToFind, Map<SNode, SNode> mapping, List<SNode> parametersOrder) {\n    this.myNodesToFind = nodesToFind;\n    this.myMapping = mapping;\n    this.myParameterOrder = parametersOrder;\n  }","id":75735,"modified_method":"public MethodDuplicatesFinder(List<SNode> nodesToFind, Map<SNode, SNode> mapping, List<SNode> parametersOrder) {\n    this.myNodesToFind = nodesToFind;\n    this.myMapping = mapping;\n    this.myParameterOrder = parametersOrder;\n    for (SNode node : ListSequence.fromList(this.myNodesToFind)) {\n      SetSequence.fromSet(this.myUsedNodes).addElement(node);\n    }\n  }","commit_id":"3c6742bfe631cd4ea9d05243589ed8da2109f6e9","url":"https://github.com/JetBrains/MPS"},{"original_method":"private boolean checkParameter(SNode parameter) {\n    List<SNode> nodes = MapSequence.fromMap(this.myParamsToNodes).get(parameter);\n    if (ListSequence.fromList(nodes).count() == 0) {\n      return true;\n    }\n    for (int i = 0; i < ListSequence.fromList(nodes).count() - 1; i++) {\n      if (!(MatchingUtil.matchNodes(ListSequence.fromList(nodes).getElement(i), ListSequence.fromList(nodes).getElement(i + 1)))) {\n        return false;\n      }\n    }\n    if (!(TypeChecker.getInstance().getSubtypingManager().isSubtype(ListSequence.fromList(nodes).getElement(0), SLinkOperations.getTarget(parameter, \"type\", true)))) {\n\n    }\n    return true;\n  }","id":75736,"modified_method":"private boolean checkParameter(SNode parameter) {\n    List<SNode> nodes = MapSequence.fromMap(this.myParamsToNodes).get(parameter);\n    if (ListSequence.fromList(nodes).count() == 0) {\n      return true;\n    }\n    for (int i = 0; i < ListSequence.fromList(nodes).count() - 1; i++) {\n      if (!(MatchingUtil.matchNodes(ListSequence.fromList(nodes).getElement(i), ListSequence.fromList(nodes).getElement(i + 1)))) {\n        return false;\n      }\n    }\n    if (!(TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(ListSequence.fromList(nodes).getElement(0)), SLinkOperations.getTarget(parameter, \"type\", true)))) {\n      return false;\n    }\n    return true;\n  }","commit_id":"3c6742bfe631cd4ea9d05243589ed8da2109f6e9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void addNode(String parentNodePath, String nodeName, Map<String, String> properties) throws Exception {\n        MutableNode modParent = getOrCreateStagedNode(parentNodePath);\n        if (modParent.getChildNodeEntry(nodeName) != null) {\n            throw new Exception(\"there's already a child node with name '\" + nodeName + \"'\");\n        }\n        MutableNode newChild = new MutableNode(store);\n        newChild.getProperties().putAll(properties);\n\n        // id will be computed on commit\n        modParent.add(new ChildNode(nodeName, null));\n        String newPath = PathUtils.concat(parentNodePath, nodeName);\n        staged.put(newPath, newChild);\n        // update change log\n        changeLog.add(new AddNode(parentNodePath, nodeName, properties));\n    }","id":75737,"modified_method":"public void addNode(String parentNodePath, String nodeName, Map<String, String> properties) throws Exception {\n        MutableNode modParent = getOrCreateStagedNode(parentNodePath);\n        if (modParent.getChildNodeEntry(nodeName) != null) {\n            throw new Exception(\"there's already a child node with name '\" + nodeName + \"'\");\n        }\n        String newPath = PathUtils.concat(parentNodePath, nodeName);\n        MutableNode newChild = new MutableNode(store, newPath);\n        newChild.getProperties().putAll(properties);\n\n        // id will be computed on commit\n        modParent.add(new ChildNode(nodeName, null));\n        staged.put(newPath, newChild);\n        // update change log\n        changeLog.add(new AddNode(parentNodePath, nodeName, properties));\n    }","commit_id":"ae9491868ec705ffc58362d21f0918fa2d7a35b7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"void mergeNode(StoredNode baseNode, StoredNode ourNode, StoredNode theirNode, String path) throws Exception {\n        NodeDelta theirChanges = new NodeDelta(\n                store, store.getNodeState(baseNode), store.getNodeState(theirNode));\n        NodeDelta ourChanges = new NodeDelta(\n                store, store.getNodeState(baseNode), store.getNodeState(ourNode));\n\n        // merge non-conflicting changes\n        MutableNode mergedNode = new MutableNode(theirNode, store);\n        staged.put(path, mergedNode);\n\n        mergedNode.getProperties().putAll(ourChanges.getAddedProperties());\n        mergedNode.getProperties().putAll(ourChanges.getChangedProperties());\n        for (String name : ourChanges.getRemovedProperties().keySet()) {\n            mergedNode.getProperties().remove(name);\n        }\n\n        for (Map.Entry<String, Id> entry : ourChanges.getAddedChildNodes ().entrySet()) {\n            mergedNode.add(new ChildNode(entry.getKey(), entry.getValue()));\n        }\n        for (Map.Entry<String, Id> entry : ourChanges.getChangedChildNodes ().entrySet()) {\n            mergedNode.add(new ChildNode(entry.getKey(), entry.getValue()));\n        }\n        for (String name : ourChanges.getRemovedChildNodes().keySet()) {\n            mergedNode.remove(name);\n        }\n\n        List<NodeDelta.Conflict> conflicts = theirChanges.listConflicts(ourChanges);\n        // resolve/report merge conflicts\n        for (NodeDelta.Conflict conflict : conflicts) {\n            String conflictName = conflict.getName();\n            String conflictPath = PathUtils.concat(path, conflictName);\n            switch (conflict.getType()) {\n                case PROPERTY_VALUE_CONFLICT:\n                    throw new Exception(\n                            \"concurrent modification of property \" + conflictPath\n                                    + \" with conflicting values: \\\"\"\n                                    + ourNode.getProperties().get(conflictName)\n                                    + \"\\\", \\\"\"\n                                    + theirNode.getProperties().get(conflictName));\n\n                case NODE_CONTENT_CONFLICT: {\n                    if (ourChanges.getChangedChildNodes().containsKey(conflictName)) {\n                        // modified subtrees\n                        StoredNode baseChild = store.getNode(baseNode.getChildNodeEntry(conflictName).getId());\n                        StoredNode ourChild = store.getNode(ourNode.getChildNodeEntry(conflictName).getId());\n                        StoredNode theirChild = store.getNode(theirNode.getChildNodeEntry(conflictName).getId());\n                        // merge the dirty subtrees recursively\n                        mergeNode(baseChild, ourChild, theirChild, PathUtils.concat(path, conflictName));\n                    } else {\n                        // todo handle/merge colliding node creation\n                        throw new Exception(\"colliding concurrent node creation: \" + conflictPath);\n                    }\n                    break;\n                }\n\n                case REMOVED_DIRTY_PROPERTY_CONFLICT:\n                    mergedNode.getProperties().remove(conflictName);\n                    break;\n\n                case REMOVED_DIRTY_NODE_CONFLICT:\n                    mergedNode.remove(conflictName);\n                    break;\n            }\n\n        }\n    }","id":75738,"modified_method":"void mergeNode(StoredNode baseNode, StoredNode ourNode, StoredNode theirNode, String path) throws Exception {\n        NodeDelta theirChanges = new NodeDelta(\n                store, store.getNodeState(baseNode), store.getNodeState(theirNode));\n        NodeDelta ourChanges = new NodeDelta(\n                store, store.getNodeState(baseNode), store.getNodeState(ourNode));\n\n        // merge non-conflicting changes\n        MutableNode mergedNode = new MutableNode(theirNode, store, path);\n        staged.put(path, mergedNode);\n\n        mergedNode.getProperties().putAll(ourChanges.getAddedProperties());\n        mergedNode.getProperties().putAll(ourChanges.getChangedProperties());\n        for (String name : ourChanges.getRemovedProperties().keySet()) {\n            mergedNode.getProperties().remove(name);\n        }\n\n        for (Map.Entry<String, Id> entry : ourChanges.getAddedChildNodes ().entrySet()) {\n            mergedNode.add(new ChildNode(entry.getKey(), entry.getValue()));\n        }\n        for (Map.Entry<String, Id> entry : ourChanges.getChangedChildNodes ().entrySet()) {\n            mergedNode.add(new ChildNode(entry.getKey(), entry.getValue()));\n        }\n        for (String name : ourChanges.getRemovedChildNodes().keySet()) {\n            mergedNode.remove(name);\n        }\n\n        List<NodeDelta.Conflict> conflicts = theirChanges.listConflicts(ourChanges);\n        // resolve/report merge conflicts\n        for (NodeDelta.Conflict conflict : conflicts) {\n            String conflictName = conflict.getName();\n            String conflictPath = PathUtils.concat(path, conflictName);\n            switch (conflict.getType()) {\n                case PROPERTY_VALUE_CONFLICT:\n                    throw new Exception(\n                            \"concurrent modification of property \" + conflictPath\n                                    + \" with conflicting values: \\\"\"\n                                    + ourNode.getProperties().get(conflictName)\n                                    + \"\\\", \\\"\"\n                                    + theirNode.getProperties().get(conflictName));\n\n                case NODE_CONTENT_CONFLICT: {\n                    if (ourChanges.getChangedChildNodes().containsKey(conflictName)) {\n                        // modified subtrees\n                        StoredNode baseChild = store.getNode(baseNode.getChildNodeEntry(conflictName).getId());\n                        StoredNode ourChild = store.getNode(ourNode.getChildNodeEntry(conflictName).getId());\n                        StoredNode theirChild = store.getNode(theirNode.getChildNodeEntry(conflictName).getId());\n                        // merge the dirty subtrees recursively\n                        mergeNode(baseChild, ourChild, theirChild, PathUtils.concat(path, conflictName));\n                    } else {\n                        // todo handle/merge colliding node creation\n                        throw new Exception(\"colliding concurrent node creation: \" + conflictPath);\n                    }\n                    break;\n                }\n\n                case REMOVED_DIRTY_PROPERTY_CONFLICT:\n                    mergedNode.getProperties().remove(conflictName);\n                    break;\n\n                case REMOVED_DIRTY_NODE_CONFLICT:\n                    mergedNode.remove(conflictName);\n                    break;\n            }\n\n        }\n    }","commit_id":"ae9491868ec705ffc58362d21f0918fa2d7a35b7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"MutableNode getOrCreateStagedNode(String nodePath) throws Exception {\n        MutableNode node = staged.get(nodePath);\n        if (node == null) {\n            MutableNode parent = staged.get(\"/\");\n            if (parent == null) {\n                parent = new MutableNode(store.getRootNode(baseRevId), store);\n                staged.put(\"/\", parent);\n            }\n            node = parent;\n            String names[] = PathUtils.split(nodePath);\n            for (int i = names.length - 1; i >= 0; i--) {\n                String path = PathUtils.getAncestorPath(nodePath, i);\n                node = staged.get(path);\n                if (node == null) {\n                    // not yet staged, resolve id using staged parent\n                    // to allow for staged move operations\n                    ChildNode cne = parent.getChildNodeEntry(names[names.length - i - 1]);\n                    if (cne == null) {\n                        throw new NotFoundException(nodePath);\n                    }\n                    node = new MutableNode(store.getNode(cne.getId()), store);\n                    staged.put(path, node);\n                }\n                parent = node;\n            }\n        }\n        return node;\n    }","id":75739,"modified_method":"MutableNode getOrCreateStagedNode(String nodePath) throws Exception {\n        MutableNode node = staged.get(nodePath);\n        if (node == null) {\n            MutableNode parent = staged.get(\"/\");\n            if (parent == null) {\n                parent = new MutableNode(store.getRootNode(baseRevId), store, \"/\");\n                staged.put(\"/\", parent);\n            }\n            node = parent;\n            String names[] = PathUtils.split(nodePath);\n            for (int i = names.length - 1; i >= 0; i--) {\n                String path = PathUtils.getAncestorPath(nodePath, i);\n                node = staged.get(path);\n                if (node == null) {\n                    // not yet staged, resolve id using staged parent\n                    // to allow for staged move operations\n                    ChildNode cne = parent.getChildNodeEntry(names[names.length - i - 1]);\n                    if (cne == null) {\n                        throw new NotFoundException(nodePath);\n                    }\n                    node = new MutableNode(store.getNode(cne.getId()), store, path);\n                    staged.put(path, node);\n                }\n                parent = node;\n            }\n        }\n        return node;\n    }","commit_id":"ae9491868ec705ffc58362d21f0918fa2d7a35b7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public StoredNode getNode(Id id) throws NotFoundException, Exception {\n        if (running) {\n            return rsTo.getNode(id);\n        }\n        return rsFrom.getNode(id);\n    }","id":75740,"modified_method":"public StoredNode getNode(Id id) throws NotFoundException, Exception {\n        if (runState.get() == STARTED) {\n            try {\n                return rsTo.getNode(id);\n            } catch (NotFoundException e) {\n                /* ignore */\n            }\n        }\n        try {\n            return rsFrom.getNode(id);\n        } catch (NotFoundException e) {\n//            System.out.println(rsFrom + \" --> \" + id + \" failed!\");\n            throw e;\n        }\n    }","commit_id":"ae9491868ec705ffc58362d21f0918fa2d7a35b7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public StoredCommit getHeadCommit() throws Exception {\n        return running ? rsTo.getHeadCommit() : rsFrom.getHeadCommit(); \n    }","id":75741,"modified_method":"public StoredCommit getHeadCommit() throws Exception {\n        return runState.get() == STARTED ? rsTo.getHeadCommit() : rsFrom.getHeadCommit(); \n    }","commit_id":"ae9491868ec705ffc58362d21f0918fa2d7a35b7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void unlockHead() {\n        if (running) {\n            rsTo.unlockHead();\n        } else {\n            rsFrom.unlockHead();\n        }\n    }","id":75742,"modified_method":"public void unlockHead() {\n        if (runState.get() == STARTED) {\n            rsTo.unlockHead();\n        } else {\n            rsFrom.unlockHead();\n        }\n    }","commit_id":"ae9491868ec705ffc58362d21f0918fa2d7a35b7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public Id putCNEMap(ChildNodeEntriesMap map) throws Exception {\n        return running ? rsTo.putCNEMap(map) : rsFrom.putCNEMap(map);\n    }","id":75743,"modified_method":"public Id putCNEMap(ChildNodeEntriesMap map) throws Exception {\n        return runState.get() == STARTED ? rsTo.putCNEMap(map) : rsFrom.putCNEMap(map);\n    }","commit_id":"ae9491868ec705ffc58362d21f0918fa2d7a35b7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public Id putHeadCommit(MutableCommit commit) throws Exception {\n        return running ? rsTo.putHeadCommit(commit) : rsFrom.putHeadCommit(commit);\n    }","id":75744,"modified_method":"public Id putHeadCommit(MutableCommit commit) throws Exception {\n        return runState.get() == STARTED ? rsTo.putHeadCommit(commit) : rsFrom.putHeadCommit(commit);\n    }","commit_id":"ae9491868ec705ffc58362d21f0918fa2d7a35b7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public StoredCommit getCommit(Id id) throws NotFoundException,\n            Exception {\n        \n        if (running) {\n            return rsTo.getCommit(id);\n        }\n        return rsFrom.getCommit(id);\n    }","id":75745,"modified_method":"public StoredCommit getCommit(Id id) throws NotFoundException,\n            Exception {\n        \n        return rsFrom.getCommit(id);\n    }","commit_id":"ae9491868ec705ffc58362d21f0918fa2d7a35b7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void lockHead() {\n        if (running) {\n            rsTo.lockHead();\n        } else {\n            rsFrom.lockHead();\n        }\n    }","id":75746,"modified_method":"public void lockHead() {\n        if (runState.get() == STARTED) {\n            rsTo.lockHead();\n        } else {\n            rsFrom.lockHead();\n        }\n    }","commit_id":"ae9491868ec705ffc58362d21f0918fa2d7a35b7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public ChildNodeEntriesMap getCNEMap(Id id) throws NotFoundException,\n            Exception {\n        \n        if (running) {\n            return rsTo.getCNEMap(id);\n        }\n        return rsFrom.getCNEMap(id);\n    }","id":75747,"modified_method":"public ChildNodeEntriesMap getCNEMap(Id id) throws NotFoundException,\n            Exception {\n        \n        return rsFrom.getCNEMap(id);\n    }","commit_id":"ae9491868ec705ffc58362d21f0918fa2d7a35b7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Copy a node and all its descendants into a target store\n     * @param node source node\n     * @throws Exception if an error occurs\n     */\n    private void copy(StoredNode node) throws Exception {\n        try {\n            rsTo.getNode(node.getId());\n            return;\n        } catch (NotFoundException e) {\n            // ignore, better add a has() method\n        }\n        rsTo.putNode(new MutableNode(node, rsTo));\n\n        Iterator<ChildNode> iter = node.getChildNodeEntries(0, -1);\n        while (iter.hasNext()) {\n            ChildNode c = iter.next();\n            copy(rsFrom.getNode(c.getId()));\n        }\n    }","id":75748,"modified_method":"/**\n     * Copy a node and all its descendants into a target store\n     * @param node source node\n     * @throws Exception if an error occurs\n     */\n    private void copy(StoredNode node) throws Exception {\n        try {\n            rsTo.getNode(node.getId());\n            return;\n        } catch (NotFoundException e) {\n            // ignore, better add a has() method\n        }\n        rsTo.putNode(new MutableNode(node, rsTo, null));\n\n        Iterator<ChildNode> iter = node.getChildNodeEntries(0, -1);\n        while (iter.hasNext()) {\n            ChildNode c = iter.next();\n            copy(rsFrom.getNode(c.getId()));\n        }\n    }","commit_id":"ae9491868ec705ffc58362d21f0918fa2d7a35b7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public StoredNode getRootNode(Id commitId) throws NotFoundException,\n            Exception {\n\n        if (running) {\n            return rsTo.getRootNode(commitId);\n        }\n        return rsFrom.getRootNode(commitId);\n    }","id":75749,"modified_method":"public StoredNode getRootNode(Id commitId) throws NotFoundException,\n            Exception {\n\n        return rsFrom.getRootNode(commitId);\n    }","commit_id":"ae9491868ec705ffc58362d21f0918fa2d7a35b7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public Id putNode(MutableNode node) throws Exception {\n        return running ? rsTo.putNode(node) : rsFrom.putNode(node);\n    }","id":75750,"modified_method":"public Id putNode(MutableNode node) throws Exception {\n        if (runState.get() == STARTED) {\n            Id id = rsTo.putNode(node);\n//            System.out.println(rsTo + \" <-- \" + node.toString() + \"(\" + id + \")\");\n            return id;\n        } else {\n            Id id = rsFrom.putNode(node);\n//            System.out.println(rsFrom + \" <-- \" + node.toString() + \"(\" + id + \")\");\n            return id;\n        }\n    }","commit_id":"ae9491868ec705ffc58362d21f0918fa2d7a35b7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public Id getHeadCommitId() throws Exception {\n        return running ? rsTo.getHeadCommitId() : rsFrom.getHeadCommitId();\n    }","id":75751,"modified_method":"public Id getHeadCommitId() throws Exception {\n        return runState.get() == STARTED ? rsTo.getHeadCommitId() : rsFrom.getHeadCommitId();\n    }","commit_id":"ae9491868ec705ffc58362d21f0918fa2d7a35b7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void initialize(File homeDir) throws Exception {\n        if (initialized) {\n            throw new IllegalStateException(\"already initialized\");\n        }\n\n        cache = Collections.synchronizedMap(SimpleLRUCache.<Id, Object>newInstance(determineInitialCacheSize()));\n\n        pm = new H2Persistence();\n        //pm = new InMemPersistence();\n        //pm = new MongoPersistence();\n        //pm = new BDbPersistence();\n        //pm = new FSPersistence();\n        pm.initialize(homeDir);\n        \n        if (pm instanceof BlobStore) {\n            blobStore = (BlobStore) pm;\n        } else {\n            blobStore = new FileBlobStore(new File(homeDir, \"blobs\").getCanonicalPath());\n            blobStoreNeedsClose = true;\n        }\n\n        // make sure we've got a HEAD commit\n        head = pm.readHead();\n        if (head == null || head.getBytes().length == 0) {\n            // assume virgin repository\n            byte[] rawHead = longToBytes(++headCounter);\n            head = new Id(rawHead);\n            \n            Id rootNodeId = pm.writeNode(new MutableNode(this));\n            MutableCommit initialCommit = new MutableCommit();\n            initialCommit.setCommitTS(System.currentTimeMillis());\n            initialCommit.setRootNodeId(rootNodeId);\n            pm.writeCommit(head, initialCommit);\n            pm.writeHead(head);\n        } else {\n            headCounter = Long.parseLong(head.toString(), 16);\n        }\n\n        initialized = true;\n    }","id":75752,"modified_method":"public void initialize(File homeDir) throws Exception {\n        if (initialized) {\n            throw new IllegalStateException(\"already initialized\");\n        }\n        this.homeDir = homeDir;\n\n        cache = Collections.synchronizedMap(SimpleLRUCache.<Id, Object>newInstance(determineInitialCacheSize()));\n\n        pm = new H2Persistence();\n        //pm = new InMemPersistence();\n        //pm = new MongoPersistence();\n        //pm = new BDbPersistence();\n        //pm = new FSPersistence();\n        pm.initialize(homeDir);\n        \n        if (pm instanceof BlobStore) {\n            blobStore = (BlobStore) pm;\n        } else {\n            blobStore = new FileBlobStore(new File(homeDir, \"blobs\").getCanonicalPath());\n            blobStoreNeedsClose = true;\n        }\n\n        // make sure we've got a HEAD commit\n        head = pm.readHead();\n        if (head == null || head.getBytes().length == 0) {\n            // assume virgin repository\n            byte[] rawHead = longToBytes(++headCounter);\n            head = new Id(rawHead);\n            \n            Id rootNodeId = pm.writeNode(new MutableNode(this, \"/\"));\n            MutableCommit initialCommit = new MutableCommit();\n            initialCommit.setCommitTS(System.currentTimeMillis());\n            initialCommit.setRootNodeId(rootNodeId);\n            pm.writeCommit(head, initialCommit);\n            pm.writeHead(head);\n        } else {\n            headCounter = Long.parseLong(head.toString(), 16);\n        }\n\n        initialized = true;\n    }","commit_id":"ae9491868ec705ffc58362d21f0918fa2d7a35b7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public MutableNode(Node other, RevisionProvider provider) {\n        super(other, provider);\n    }","id":75753,"modified_method":"public MutableNode(Node other, RevisionProvider provider, String path) {\n        super(other, provider);\n\n        this.path = path;\n    }","commit_id":"ae9491868ec705ffc58362d21f0918fa2d7a35b7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public MutableNode(RevisionProvider provider) {\n        super(provider);\n    }","id":75754,"modified_method":"public MutableNode(RevisionProvider provider, String path) {\n        super(provider);\n        \n        this.path = path;\n    }","commit_id":"ae9491868ec705ffc58362d21f0918fa2d7a35b7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"protected JComponent createNorthPanel() {\n    myTypeSelector = myTypeSelectorManager.getTypeSelector();\n    myTypePanel.setLayout(new BorderLayout());\n    myTypePanel.add(myTypeSelector.getComponent(), BorderLayout.CENTER);\n    if (myTypeSelector.getFocusableComponent() != null) {\n      myTypeLabel.setLabelFor(myTypeSelector.getFocusableComponent());\n    }\n\n    myNameField = new NameSuggestionsField(myProject);\n    myNameSuggestionPanel.setLayout(new BorderLayout());\n\n    myNameSuggestionPanel.add(myNameField.getComponent(), BorderLayout.CENTER);\n    myNameSuggestionLabel.setLabelFor(myNameField.getFocusableComponent());\n\n    Set<String> possibleClassNames = new LinkedHashSet<String>();\n    for (final PsiExpression occurrence : myOccurrences) {\n      final PsiClass parentClass = new IntroduceConstantHandler().getParentClass(occurrence);\n      if (parentClass != null && parentClass.getQualifiedName() != null) {\n        possibleClassNames.add(parentClass.getQualifiedName());\n      }\n    }\n    if (possibleClassNames.size() > 1) {\n      ReferenceEditorComboWithBrowseButton targetClassName =\n        new ReferenceEditorComboWithBrowseButton(new ChooseClassAction(), \"\", PsiManager.getInstance(myProject), true, RECENTS_KEY);\n      myTargetClassNamePanel.setLayout(new BorderLayout());\n      myTargetClassNamePanel.add(targetClassName, BorderLayout.CENTER);\n      myTargetClassNameLabel.setLabelFor(targetClassName);\n      targetClassName.setHistory(ArrayUtil.toStringArray(possibleClassNames));\n      myTfTargetClassName = targetClassName;\n      targetClassName.getChildComponent().addDocumentListener(new DocumentAdapter() {\n        public void documentChanged(DocumentEvent e) {\n          targetClassChanged();\n        }\n      });\n    }\n    else {\n      ReferenceEditorWithBrowseButton targetClassName = JavaReferenceEditorUtil\n          .createReferenceEditorWithBrowseButton(new ChooseClassAction(), \"\", PsiManager.getInstance(myProject), true);\n      myTargetClassNamePanel.setLayout(new BorderLayout());\n      myTargetClassNamePanel.add(targetClassName, BorderLayout.CENTER);\n      myTargetClassNameLabel.setLabelFor(targetClassName);\n      myTfTargetClassName = targetClassName;\n      targetClassName.addDocumentListener(new DocumentAdapter() {\n        public void documentChanged(DocumentEvent e) {\n          targetClassChanged();\n        }\n      });\n    }\n    myIntroduceEnumConstantCb.addActionListener(new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        enableEnumDependant(introduceEnumConstant());\n      }\n    });\n    enableEnumDependant(introduceEnumConstant());\n    final JPanel enumPanel = new JPanel(new BorderLayout());\n    enumPanel.add(myIntroduceEnumConstantCb, BorderLayout.EAST);\n    myTargetClassNamePanel.add(enumPanel, BorderLayout.SOUTH);\n\n    final String propertyName;\n    if (myLocalVariable != null) {\n      propertyName = myCodeStyleManager.variableNameToPropertyName(myLocalVariable.getName(), VariableKind.LOCAL_VARIABLE);\n    }\n    else {\n      propertyName = null;\n    }\n    final NameSuggestionsManager nameSuggestionsManager =\n      new NameSuggestionsManager(myTypeSelector, myNameField, new NameSuggestionsGenerator() {\n        public SuggestedNameInfo getSuggestedNameInfo(PsiType type) {\n          final SuggestedNameInfo nameInfo =\n              myCodeStyleManager.suggestVariableName(VariableKind.STATIC_FINAL_FIELD, propertyName, myInitializerExpression, type);\n          final String[] strings = JavaCompletionUtil.completeVariableNameForRefactoring(myCodeStyleManager, type, VariableKind.LOCAL_VARIABLE, nameInfo);\n          return new SuggestedNameInfo.Delegate(strings, nameInfo);\n        }\n\n      });\n\n    nameSuggestionsManager.setLabelsFor(myTypeLabel, myNameSuggestionLabel);\n    //////////\n    if (myOccurrencesCount > 1) {\n      myCbReplaceAll.addItemListener(new ItemListener() {\n        public void itemStateChanged(ItemEvent e) {\n          updateTypeSelector();\n\n          myNameField.requestFocusInWindow();\n        }\n      });\n      myCbReplaceAll.setText(RefactoringBundle.message(\"replace.all.occurences\", myOccurrencesCount));\n    }\n    else {\n      myCbReplaceAll.setVisible(false);\n    }\n\n    if (myLocalVariable != null) {\n      if (myInvokedOnDeclaration) {\n        myCbDeleteVariable.setEnabled(false);\n        myCbDeleteVariable.setSelected(true);\n      }\n      else if (myCbReplaceAll != null) {\n        updateCbDeleteVariable();\n        myCbReplaceAll.addItemListener(\n          new ItemListener() {\n          public void itemStateChanged(ItemEvent e) {\n            updateCbDeleteVariable();\n          }\n        });\n      }\n    }\n    else {\n      myCbDeleteVariable.setVisible(false);\n    }\n\n    final PsiManager psiManager = PsiManager.getInstance(myProject);\n    if (myTypeSelectorManager.isSuggestedType(\"java.lang.String\") &&\n        LanguageLevelProjectExtension.getInstance(psiManager.getProject()).getLanguageLevel().hasEnumKeywordAndAutoboxing() &&\n        JavaPsiFacade.getInstance(psiManager.getProject()).findClass(AnnotationUtil.NON_NLS, myParentClass.getResolveScope()) != null) {\n      final PropertiesComponent component = PropertiesComponent.getInstance(myProject);\n      myCbNonNls.setSelected(component.isTrueValue(NONNLS_SELECTED_PROPERTY));\n      myCbNonNls.addItemListener(new ItemListener() {\n        public void itemStateChanged(ItemEvent e) {\n          component.setValue(NONNLS_SELECTED_PROPERTY, Boolean.toString(myCbNonNls.isSelected()));\n        }\n      });\n    } else {\n      myCbNonNls.setVisible(false);\n    }\n\n    updateTypeSelector();\n\n    ButtonGroup bg = new ButtonGroup();\n    bg.add(myRbPrivate);\n    bg.add(myRbpackageLocal);\n    bg.add(myRbProtected);\n    bg.add(myRbPublic);\n\n    return myPanel;\n  }","id":75755,"modified_method":"protected JComponent createNorthPanel() {\n    myTypeSelector = myTypeSelectorManager.getTypeSelector();\n    myTypePanel.setLayout(new BorderLayout());\n    myTypePanel.add(myTypeSelector.getComponent(), BorderLayout.CENTER);\n    if (myTypeSelector.getFocusableComponent() != null) {\n      myTypeLabel.setLabelFor(myTypeSelector.getFocusableComponent());\n    }\n\n    myNameField = new NameSuggestionsField(myProject);\n    myNameSuggestionPanel.setLayout(new BorderLayout());\n\n    myNameSuggestionPanel.add(myNameField.getComponent(), BorderLayout.CENTER);\n    myNameSuggestionLabel.setLabelFor(myNameField.getFocusableComponent());\n\n    Set<String> possibleClassNames = new LinkedHashSet<String>();\n    for (final PsiExpression occurrence : myOccurrences) {\n      final PsiClass parentClass = new IntroduceConstantHandler().getParentClass(occurrence);\n      if (parentClass != null && parentClass.getQualifiedName() != null) {\n        possibleClassNames.add(parentClass.getQualifiedName());\n      }\n    }\n    myTfTargetClassName =\n      new ReferenceEditorComboWithBrowseButton(new ChooseClassAction(), \"\", PsiManager.getInstance(myProject), true, RECENTS_KEY);\n    myTargetClassNamePanel.setLayout(new BorderLayout());\n    myTargetClassNamePanel.add(myTfTargetClassName, BorderLayout.CENTER);\n    myTargetClassNameLabel.setLabelFor(myTfTargetClassName);\n    for (String possibleClassName : possibleClassNames) {\n      myTfTargetClassName.prependItem(possibleClassName);\n    }\n    myTfTargetClassName.getChildComponent().addDocumentListener(new DocumentAdapter() {\n      public void documentChanged(DocumentEvent e) {\n        targetClassChanged();\n      }\n    });\n    myIntroduceEnumConstantCb.addActionListener(new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        enableEnumDependant(introduceEnumConstant());\n      }\n    });\n    enableEnumDependant(introduceEnumConstant());\n    final JPanel enumPanel = new JPanel(new BorderLayout());\n    enumPanel.add(myIntroduceEnumConstantCb, BorderLayout.EAST);\n    myTargetClassNamePanel.add(enumPanel, BorderLayout.SOUTH);\n\n    final String propertyName;\n    if (myLocalVariable != null) {\n      propertyName = myCodeStyleManager.variableNameToPropertyName(myLocalVariable.getName(), VariableKind.LOCAL_VARIABLE);\n    }\n    else {\n      propertyName = null;\n    }\n    final NameSuggestionsManager nameSuggestionsManager =\n      new NameSuggestionsManager(myTypeSelector, myNameField, new NameSuggestionsGenerator() {\n        public SuggestedNameInfo getSuggestedNameInfo(PsiType type) {\n          final SuggestedNameInfo nameInfo =\n              myCodeStyleManager.suggestVariableName(VariableKind.STATIC_FINAL_FIELD, propertyName, myInitializerExpression, type);\n          final String[] strings = JavaCompletionUtil.completeVariableNameForRefactoring(myCodeStyleManager, type, VariableKind.LOCAL_VARIABLE, nameInfo);\n          return new SuggestedNameInfo.Delegate(strings, nameInfo);\n        }\n\n      });\n\n    nameSuggestionsManager.setLabelsFor(myTypeLabel, myNameSuggestionLabel);\n    //////////\n    if (myOccurrencesCount > 1) {\n      myCbReplaceAll.addItemListener(new ItemListener() {\n        public void itemStateChanged(ItemEvent e) {\n          updateTypeSelector();\n\n          myNameField.requestFocusInWindow();\n        }\n      });\n      myCbReplaceAll.setText(RefactoringBundle.message(\"replace.all.occurences\", myOccurrencesCount));\n    }\n    else {\n      myCbReplaceAll.setVisible(false);\n    }\n\n    if (myLocalVariable != null) {\n      if (myInvokedOnDeclaration) {\n        myCbDeleteVariable.setEnabled(false);\n        myCbDeleteVariable.setSelected(true);\n      }\n      else if (myCbReplaceAll != null) {\n        updateCbDeleteVariable();\n        myCbReplaceAll.addItemListener(\n          new ItemListener() {\n          public void itemStateChanged(ItemEvent e) {\n            updateCbDeleteVariable();\n          }\n        });\n      }\n    }\n    else {\n      myCbDeleteVariable.setVisible(false);\n    }\n\n    final PsiManager psiManager = PsiManager.getInstance(myProject);\n    if (myTypeSelectorManager.isSuggestedType(\"java.lang.String\") &&\n        LanguageLevelProjectExtension.getInstance(psiManager.getProject()).getLanguageLevel().hasEnumKeywordAndAutoboxing() &&\n        JavaPsiFacade.getInstance(psiManager.getProject()).findClass(AnnotationUtil.NON_NLS, myParentClass.getResolveScope()) != null) {\n      final PropertiesComponent component = PropertiesComponent.getInstance(myProject);\n      myCbNonNls.setSelected(component.isTrueValue(NONNLS_SELECTED_PROPERTY));\n      myCbNonNls.addItemListener(new ItemListener() {\n        public void itemStateChanged(ItemEvent e) {\n          component.setValue(NONNLS_SELECTED_PROPERTY, Boolean.toString(myCbNonNls.isSelected()));\n        }\n      });\n    } else {\n      myCbNonNls.setVisible(false);\n    }\n\n    updateTypeSelector();\n\n    ButtonGroup bg = new ButtonGroup();\n    bg.add(myRbPrivate);\n    bg.add(myRbpackageLocal);\n    bg.add(myRbProtected);\n    bg.add(myRbPublic);\n\n    return myPanel;\n  }","commit_id":"8dfabc85522b505db13093765ab3c13dcb7f7fa6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Constructor.<p>\n     * \n     * @param element the DOM element\n     * @param parent the drag parent\n     * @param clientId the client id\n     * @param sitePath the element site-path\n     * @param noEditReason the no edit reason, if empty, editing is allowed\n     * @param hasSettings should be true if the element has settings which can be edited \n     * @param hasViewPermission indicates if the current user has view permissions on the element resource\n     * @param hasWritePermission indicates if the current user has write permissions on the element resource\n     * @param releasedAndNotExpired <code>true<\/code> if the element resource is currently released and not expired\n     * @param disableNewEditor flag to disable the new editor for this element \n     */\n    public CmsContainerPageElementPanel(\n        Element element,\n        I_CmsDropContainer parent,\n        String clientId,\n        String sitePath,\n        String noEditReason,\n        boolean hasSettings,\n        boolean hasViewPermission,\n        boolean hasWritePermission,\n        boolean releasedAndNotExpired,\n        boolean disableNewEditor) {\n\n        super((com.google.gwt.user.client.Element)element);\n        m_clientId = clientId;\n        m_sitePath = sitePath;\n        m_noEditReason = noEditReason;\n        m_hasSettings = hasSettings;\n        m_parent = parent;\n        m_disableNewEditor = disableNewEditor;\n        setViewPermission(hasViewPermission);\n        setWritePermission(hasWritePermission);\n        setReleasedAndNotExpired(releasedAndNotExpired);\n        getElement().addClassName(I_CmsLayoutBundle.INSTANCE.dragdropCss().dragElement());\n    }","id":75756,"modified_method":"/**\n     * Constructor.<p>\n     * \n     * @param element the DOM element\n     * @param parent the drag parent\n     * @param clientId the client id\n     * @param sitePath the element site-path\n     * @param noEditReason the no edit reason, if empty, editing is allowed\n     * @param hasSettings should be true if the element has settings which can be edited \n     * @param hasViewPermission indicates if the current user has view permissions on the element resource\n     * @param hasWritePermission indicates if the current user has write permissions on the element resource\n     * @param releasedAndNotExpired <code>true<\/code> if the element resource is currently released and not expired\n     * @param disableNewEditor flag to disable the new editor for this element \n     */\n    public CmsContainerPageElementPanel(\n        Element element,\n        I_CmsDropContainer parent,\n        String clientId,\n        String sitePath,\n        String noEditReason,\n        boolean hasSettings,\n        boolean hasViewPermission,\n        boolean hasWritePermission,\n        boolean releasedAndNotExpired,\n        boolean disableNewEditor) {\n\n        super(element);\n        m_clientId = clientId;\n        m_sitePath = sitePath;\n        m_noEditReason = noEditReason;\n        m_hasSettings = hasSettings;\n        m_parent = parent;\n        m_disableNewEditor = disableNewEditor;\n        setViewPermission(hasViewPermission);\n        setWritePermission(hasWritePermission);\n        setReleasedAndNotExpired(releasedAndNotExpired);\n        getElement().addClassName(I_CmsLayoutBundle.INSTANCE.dragdropCss().dragElement());\n    }","commit_id":"6e88e42925f1a69cca54d171828af155747ff63c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Sets if the element resource is currently released and not expired.<p>\n     * \n     * @param releasedAndNotExpired <code>true<\/code> if the element resource is currently released and not expired\n     */\n    public void setReleasedAndNotExpired(boolean releasedAndNotExpired) {\n\n        m_releasedAndNotExpired = releasedAndNotExpired;\n        if (m_releasedAndNotExpired) {\n            getElement().removeClassName(I_CmsLayoutBundle.INSTANCE.containerpageCss().expired());\n            if (m_expiredOverlay != null) {\n                m_expiredOverlay.removeFromParent();\n                m_expiredOverlay = null;\n            }\n\n        } else {\n            getElement().addClassName(I_CmsLayoutBundle.INSTANCE.containerpageCss().expired());\n            m_expiredOverlay = DOM.createDiv();\n            m_expiredOverlay.setTitle(\"Expired resource\");\n            m_expiredOverlay.addClassName(I_CmsLayoutBundle.INSTANCE.containerpageCss().expiredListElementOverlay());\n            getElement().appendChild(m_expiredOverlay);\n        }\n    }","id":75757,"modified_method":"/**\n     * Sets if the element resource is currently released and not expired.<p>\n     * \n     * @param releasedAndNotExpired <code>true<\/code> if the element resource is currently released and not expired\n     */\n    public void setReleasedAndNotExpired(boolean releasedAndNotExpired) {\n\n        m_releasedAndNotExpired = releasedAndNotExpired;\n        if (m_releasedAndNotExpired) {\n            removeStyleName(I_CmsLayoutBundle.INSTANCE.containerpageCss().expired());\n            if (m_expiredOverlay != null) {\n                m_expiredOverlay.removeFromParent();\n                m_expiredOverlay = null;\n            }\n\n        } else {\n            addStyleName(I_CmsLayoutBundle.INSTANCE.containerpageCss().expired());\n            m_expiredOverlay = DOM.createDiv();\n            m_expiredOverlay.setTitle(\"Expired resource\");\n            m_expiredOverlay.addClassName(I_CmsLayoutBundle.INSTANCE.containerpageCss().expiredOverlay());\n            getElement().appendChild(m_expiredOverlay);\n        }\n    }","commit_id":"6e88e42925f1a69cca54d171828af155747ff63c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Initializes the editor click handler.<p>\n     * \n     * @param controller the container page controller instance\n     */\n    public void initInlineEditor(final CmsContainerpageController controller) {\n\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(m_noEditReason)\n            && !m_disableNewEditor\n            && CmsContentEditor.setEditable(getElement(), true)) {\n            if (m_editorClickHandlerRegistration != null) {\n                m_editorClickHandlerRegistration.removeHandler();\n            }\n            m_editorClickHandlerRegistration = Event.addNativePreviewHandler(new NativePreviewHandler() {\n\n                public void onPreviewNativeEvent(NativePreviewEvent event) {\n\n                    if (event.getTypeInt() == Event.ONCLICK) {\n                        // if another content is already being edited, don't start another editor\n                        if (controller.isContentEditing()) {\n                            return;\n                        }\n                        Element eventTarget = event.getNativeEvent().getEventTarget().cast();\n                        // check if the event target is a child \n                        if (getElement().isOrHasChild(eventTarget)) {\n                            Element target = event.getNativeEvent().getEventTarget().cast();\n                            while ((target != null)\n                                && !target.getTagName().equalsIgnoreCase(\"a\")\n                                && (target != getElement())) {\n                                if (CmsContentEditor.isEditable(target)) {\n                                    EditorBase.markForInlineFocus((com.google.gwt.user.client.Element)target);\n                                    controller.getHandler().openEditorForElement(\n                                        CmsContainerPageElementPanel.this,\n                                        true);\n                                    removeEditorHandler();\n                                    event.cancel();\n                                    break;\n                                } else {\n                                    target = target.getParentElement();\n                                }\n                            }\n                        }\n                    }\n                }\n            });\n        }\n    }","id":75758,"modified_method":"/**\n     * Initializes the editor click handler.<p>\n     * \n     * @param controller the container page controller instance\n     */\n    public void initInlineEditor(final CmsContainerpageController controller) {\n\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(m_noEditReason)\n            && !m_disableNewEditor\n            && CmsContentEditor.setEditable(getElement(), true)) {\n            if (m_editorClickHandlerRegistration != null) {\n                m_editorClickHandlerRegistration.removeHandler();\n            }\n            m_editorClickHandlerRegistration = Event.addNativePreviewHandler(new NativePreviewHandler() {\n\n                public void onPreviewNativeEvent(NativePreviewEvent event) {\n\n                    if (event.getTypeInt() == Event.ONCLICK) {\n                        // if another content is already being edited, don't start another editor\n                        if (controller.isContentEditing()) {\n                            return;\n                        }\n                        Element eventTarget = event.getNativeEvent().getEventTarget().cast();\n                        // check if the event target is a child \n                        if (getElement().isOrHasChild(eventTarget)) {\n                            Element target = event.getNativeEvent().getEventTarget().cast();\n                            while ((target != null)\n                                && !target.getTagName().equalsIgnoreCase(\"a\")\n                                && (target != getElement())) {\n                                if (CmsContentEditor.isEditable(target)) {\n                                    EditorBase.markForInlineFocus(target);\n                                    controller.getHandler().openEditorForElement(\n                                        CmsContainerPageElementPanel.this,\n                                        true);\n                                    removeEditorHandler();\n                                    event.cancel();\n                                    break;\n                                } else {\n                                    target = target.getParentElement();\n                                }\n                            }\n                        }\n                    }\n                }\n            });\n        }\n    }","commit_id":"6e88e42925f1a69cca54d171828af155747ff63c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Shows list collector direct edit buttons (old direct edit style), if present.<p>\n     */\n    public void showEditableListButtons() {\n\n        m_checkingEditables = true;\n        if (m_editables == null) {\n            m_editables = new HashMap<Element, CmsListCollectorEditor>();\n            List<Element> editables = CmsDomUtil.getElementsByClass(\"cms-editable\", Tag.div, getElement());\n            if ((editables != null) && (editables.size() > 0)) {\n                for (Element editable : editables) {\n                    CmsListCollectorEditor editor = new CmsListCollectorEditor(editable, m_clientId);\n                    add(editor, (com.google.gwt.user.client.Element)editable.getParentElement());\n                    if (CmsDomUtil.hasDimension(editable.getParentElement())) {\n                        editor.setPosition(CmsDomUtil.getEditablePosition(editable), getElement());\n                    } else {\n                        editor.getElement().getStyle().setDisplay(Display.NONE);\n                    }\n                    m_editables.put(editable, editor);\n                }\n\n            }\n        } else {\n\n            Iterator<Entry<Element, CmsListCollectorEditor>> it = m_editables.entrySet().iterator();\n            while (it.hasNext()) {\n                Entry<Element, CmsListCollectorEditor> entry = it.next();\n                if (!entry.getValue().isValid()) {\n                    entry.getValue().removeFromParent();\n                    it.remove();\n                } else if (CmsDomUtil.hasDimension(entry.getValue().getElement().getParentElement())) {\n                    entry.getValue().getElement().getStyle().clearDisplay();\n                    entry.getValue().setPosition(\n                        CmsDomUtil.getEditablePosition(entry.getValue().getMarkerTag()),\n                        getElement());\n                }\n            }\n            List<Element> editables = CmsDomUtil.getElementsByClass(\"cms-editable\", Tag.div, getElement());\n            if (editables.size() > m_editables.size()) {\n                for (Element editable : editables) {\n                    if (!m_editables.containsKey(editable)) {\n                        CmsListCollectorEditor editor = new CmsListCollectorEditor(editable, m_clientId);\n                        add(editor, (com.google.gwt.user.client.Element)editable.getParentElement());\n                        if (CmsDomUtil.hasDimension(editable.getParentElement())) {\n                            editor.setPosition(CmsDomUtil.getEditablePosition(editable), getElement());\n                        } else {\n                            editor.getElement().getStyle().setDisplay(Display.NONE);\n                        }\n                        m_editables.put(editable, editor);\n\n                    }\n                }\n            }\n\n        }\n        m_checkingEditables = false;\n        resetNodeInsertedHandler();\n    }","id":75759,"modified_method":"/**\n     * Shows list collector direct edit buttons (old direct edit style), if present.<p>\n     */\n    public void showEditableListButtons() {\n\n        m_checkingEditables = true;\n        if (m_editables == null) {\n            m_editables = new HashMap<Element, CmsListCollectorEditor>();\n            List<Element> editables = CmsDomUtil.getElementsByClass(\"cms-editable\", Tag.div, getElement());\n            if ((editables != null) && (editables.size() > 0)) {\n                for (Element editable : editables) {\n                    CmsListCollectorEditor editor = new CmsListCollectorEditor(editable, m_clientId);\n                    add(editor, editable.getParentElement());\n                    if (CmsDomUtil.hasDimension(editable.getParentElement())) {\n                        editor.setPosition(CmsDomUtil.getEditablePosition(editable), getElement());\n                    } else {\n                        editor.getElement().getStyle().setDisplay(Display.NONE);\n                    }\n                    m_editables.put(editable, editor);\n                }\n\n            }\n        } else {\n\n            Iterator<Entry<Element, CmsListCollectorEditor>> it = m_editables.entrySet().iterator();\n            while (it.hasNext()) {\n                Entry<Element, CmsListCollectorEditor> entry = it.next();\n                if (!entry.getValue().isValid()) {\n                    entry.getValue().removeFromParent();\n                    it.remove();\n                } else if (CmsDomUtil.hasDimension(entry.getValue().getElement().getParentElement())) {\n                    entry.getValue().getElement().getStyle().clearDisplay();\n                    entry.getValue().setPosition(\n                        CmsDomUtil.getEditablePosition(entry.getValue().getMarkerTag()),\n                        getElement());\n                }\n            }\n            List<Element> editables = CmsDomUtil.getElementsByClass(\"cms-editable\", Tag.div, getElement());\n            if (editables.size() > m_editables.size()) {\n                for (Element editable : editables) {\n                    if (!m_editables.containsKey(editable)) {\n                        CmsListCollectorEditor editor = new CmsListCollectorEditor(editable, m_clientId);\n                        add(editor, editable.getParentElement());\n                        if (CmsDomUtil.hasDimension(editable.getParentElement())) {\n                            editor.setPosition(CmsDomUtil.getEditablePosition(editable), getElement());\n                        } else {\n                            editor.getElement().getStyle().setDisplay(Display.NONE);\n                        }\n                        m_editables.put(editable, editor);\n\n                    }\n                }\n            }\n\n        }\n        m_checkingEditables = false;\n        resetNodeInsertedHandler();\n    }","commit_id":"6e88e42925f1a69cca54d171828af155747ff63c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Opens the XML content editor.<p>\n     * \n     * @param element the container element widget\n     * @param inline <code>true<\/code> to open the in-line editor for the given element if available\n     */\n    public void openDialog(\n\n    final CmsContainerPageElementPanel element, final boolean inline) {\n\n        m_handler.disableToolbarButtons();\n        m_handler.deactivateCurrentButton();\n        m_currentElementId = element.getId();\n        String serverId = CmsContainerpageController.getServerId(getCurrentElementId());\n        if (m_handler.m_controller.getData().isUseClassicEditor() || element.isNewEditorDisabled()) {\n            CmsEditableData editableData = new CmsEditableData();\n            editableData.setElementLanguage(CmsCoreProvider.get().getLocale());\n            editableData.setStructureId(new CmsUUID(serverId));\n            editableData.setSitePath(element.getSitePath());\n            CmsContentEditorDialog.get().openEditDialog(editableData, false, CmsContentEditorHandler.this);\n        } else {\n            String editorLocale = CmsCoreProvider.get().getLocale();\n\n            Command onClose = new Command() {\n\n                public void execute() {\n\n                    addClosedEditorHistoryItem();\n                    onClose(element.getSitePath(), false);\n                }\n            };\n            if (inline && CmsContentEditor.hasEditable(element.getElement())) {\n                addEditingHistoryItem(true);\n                CmsEditorContext context = getEditorContext();\n                context.setHtmlContextInfo(getContextInfo(element));\n                CmsContentEditor.getInstance().openInlineEditor(\n                    context,\n                    new CmsUUID(serverId),\n                    editorLocale,\n                    element,\n                    onClose);\n            } else {\n                addEditingHistoryItem(false);\n                CmsContentEditor.getInstance().openFormEditor(\n                    getEditorContext(),\n                    editorLocale,\n                    serverId,\n                    null,\n                    null,\n                    onClose);\n            }\n        }\n    }","id":75760,"modified_method":"/**\n     * Opens the XML content editor.<p>\n     * \n     * @param element the container element widget\n     * @param inline <code>true<\/code> to open the in-line editor for the given element if available\n     */\n    public void openDialog(\n\n    final CmsContainerPageElementPanel element, final boolean inline) {\n\n        m_handler.disableToolbarButtons();\n        m_handler.deactivateCurrentButton();\n        m_currentElementId = element.getId();\n        String serverId = CmsContainerpageController.getServerId(getCurrentElementId());\n        if (m_handler.m_controller.getData().isUseClassicEditor() || element.isNewEditorDisabled()) {\n            CmsEditableData editableData = new CmsEditableData();\n            editableData.setElementLanguage(CmsCoreProvider.get().getLocale());\n            editableData.setStructureId(new CmsUUID(serverId));\n            editableData.setSitePath(element.getSitePath());\n            CmsContentEditorDialog.get().openEditDialog(editableData, false, CmsContentEditorHandler.this);\n        } else {\n            String editorLocale = CmsCoreProvider.get().getLocale();\n\n            Command onClose = new Command() {\n\n                public void execute() {\n\n                    addClosedEditorHistoryItem();\n                    onClose(element.getSitePath(), false);\n                }\n            };\n            if (inline && CmsContentEditor.hasEditable(element.getElement())) {\n                addEditingHistoryItem(true);\n                CmsEditorContext context = getEditorContext();\n                context.setHtmlContextInfo(getContextInfo(element));\n                // remove expired style before initializing the editor\n                element.setReleasedAndNotExpired(true);\n                CmsContentEditor.getInstance().openInlineEditor(\n                    context,\n                    new CmsUUID(serverId),\n                    editorLocale,\n                    element,\n                    onClose);\n            } else {\n                addEditingHistoryItem(false);\n                CmsContentEditor.getInstance().openFormEditor(\n                    getEditorContext(),\n                    editorLocale,\n                    serverId,\n                    null,\n                    null,\n                    onClose);\n            }\n        }\n    }","commit_id":"6e88e42925f1a69cca54d171828af155747ff63c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Shows list collector direct edit buttons (old direct edit style), if present.<p>\n     */\n    public void showEditableListButtons() {\n\n        m_checkingEditables = true;\n        if (m_editables == null) {\n            m_editables = new HashMap<Element, CmsListCollectorEditor>();\n            List<Element> editables = CmsDomUtil.getElementsByClass(\"cms-editable\", Tag.div, getElement());\n            if ((editables != null) && (editables.size() > 0)) {\n                for (Element editable : editables) {\n                    CmsListCollectorEditor editor = new CmsListCollectorEditor(editable, m_clientId);\n                    add(editor, (com.google.gwt.user.client.Element)editable.getParentElement());\n                    if (CmsDomUtil.hasDimension(editable.getParentElement())) {\n                        editor.setPosition(CmsDomUtil.getEditablePosition(editable), getElement());\n                    } else {\n                        editor.getElement().getStyle().setDisplay(Display.NONE);\n                    }\n                    m_editables.put(editable, editor);\n                }\n\n            }\n        } else {\n\n            Iterator<Entry<Element, CmsListCollectorEditor>> it = m_editables.entrySet().iterator();\n            while (it.hasNext()) {\n                Entry<Element, CmsListCollectorEditor> entry = it.next();\n                if (!entry.getValue().isValid()) {\n                    entry.getValue().removeFromParent();\n                    it.remove();\n                } else if (CmsDomUtil.hasDimension(entry.getValue().getElement().getParentElement())) {\n                    entry.getValue().getElement().getStyle().clearDisplay();\n                    entry.getValue().setPosition(\n                        CmsDomUtil.getEditablePosition(entry.getValue().getMarkerTag()),\n                        getElement());\n                }\n            }\n            List<Element> editables = CmsDomUtil.getElementsByClass(\"cms-editable\", Tag.div, getElement());\n            if (editables.size() > m_editables.size()) {\n                for (Element editable : editables) {\n                    if (!m_editables.containsKey(editable)) {\n                        CmsListCollectorEditor editor = new CmsListCollectorEditor(editable, m_clientId);\n                        add(editor, (com.google.gwt.user.client.Element)editable.getParentElement());\n                        if (CmsDomUtil.hasDimension(editable.getParentElement())) {\n                            editor.setPosition(CmsDomUtil.getEditablePosition(editable), getElement());\n                        } else {\n                            editor.getElement().getStyle().setDisplay(Display.NONE);\n                        }\n                        m_editables.put(editable, editor);\n\n                    }\n                }\n            }\n\n        }\n        m_checkingEditables = false;\n        resetNodeInsertedHandler();\n    }","id":75761,"modified_method":"/**\n     * Shows list collector direct edit buttons (old direct edit style), if present.<p>\n     */\n    public void showEditableListButtons() {\n\n        m_checkingEditables = true;\n        if (m_editables == null) {\n            m_editables = new HashMap<Element, CmsListCollectorEditor>();\n            List<Element> editables = CmsDomUtil.getElementsByClass(\"cms-editable\", Tag.div, getElement());\n            if ((editables != null) && (editables.size() > 0)) {\n                for (Element editable : editables) {\n                    CmsListCollectorEditor editor = new CmsListCollectorEditor(editable, m_clientId);\n                    add(editor, editable.getParentElement());\n                    if (CmsDomUtil.hasDimension(editable.getParentElement())) {\n                        editor.setPosition(CmsDomUtil.getEditablePosition(editable), getElement());\n                    } else {\n                        editor.getElement().getStyle().setDisplay(Display.NONE);\n                    }\n                    m_editables.put(editable, editor);\n                }\n\n            }\n        } else {\n\n            Iterator<Entry<Element, CmsListCollectorEditor>> it = m_editables.entrySet().iterator();\n            while (it.hasNext()) {\n                Entry<Element, CmsListCollectorEditor> entry = it.next();\n                if (!entry.getValue().isValid()) {\n                    entry.getValue().removeFromParent();\n                    it.remove();\n                } else if (CmsDomUtil.hasDimension(entry.getValue().getElement().getParentElement())) {\n                    entry.getValue().getElement().getStyle().clearDisplay();\n                    entry.getValue().setPosition(\n                        CmsDomUtil.getEditablePosition(entry.getValue().getMarkerTag()),\n                        getElement());\n                }\n            }\n            List<Element> editables = CmsDomUtil.getElementsByClass(\"cms-editable\", Tag.div, getElement());\n            if (editables.size() > m_editables.size()) {\n                for (Element editable : editables) {\n                    if (!m_editables.containsKey(editable)) {\n                        CmsListCollectorEditor editor = new CmsListCollectorEditor(editable, m_clientId);\n                        add(editor, editable.getParentElement());\n                        if (CmsDomUtil.hasDimension(editable.getParentElement())) {\n                            editor.setPosition(CmsDomUtil.getEditablePosition(editable), getElement());\n                        } else {\n                            editor.getElement().getStyle().setDisplay(Display.NONE);\n                        }\n                        m_editables.put(editable, editor);\n\n                    }\n                }\n            }\n\n        }\n        m_checkingEditables = false;\n        resetNodeInsertedHandler();\n    }","commit_id":"eec2702e7ec0d3489f142ef833422b848328a217","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Sets if the element resource is currently released and not expired.<p>\n     * \n     * @param releasedAndNotExpired <code>true<\/code> if the element resource is currently released and not expired\n     */\n    public void setReleasedAndNotExpired(boolean releasedAndNotExpired) {\n\n        m_releasedAndNotExpired = releasedAndNotExpired;\n        if (m_releasedAndNotExpired) {\n            getElement().removeClassName(I_CmsLayoutBundle.INSTANCE.containerpageCss().expired());\n            if (m_expiredOverlay != null) {\n                m_expiredOverlay.removeFromParent();\n                m_expiredOverlay = null;\n            }\n\n        } else {\n            getElement().addClassName(I_CmsLayoutBundle.INSTANCE.containerpageCss().expired());\n            m_expiredOverlay = DOM.createDiv();\n            m_expiredOverlay.setTitle(\"Expired resource\");\n            m_expiredOverlay.addClassName(I_CmsLayoutBundle.INSTANCE.containerpageCss().expiredListElementOverlay());\n            getElement().appendChild(m_expiredOverlay);\n        }\n    }","id":75762,"modified_method":"/**\n     * Sets if the element resource is currently released and not expired.<p>\n     * \n     * @param releasedAndNotExpired <code>true<\/code> if the element resource is currently released and not expired\n     */\n    public void setReleasedAndNotExpired(boolean releasedAndNotExpired) {\n\n        m_releasedAndNotExpired = releasedAndNotExpired;\n        if (m_releasedAndNotExpired) {\n            removeStyleName(I_CmsLayoutBundle.INSTANCE.containerpageCss().expired());\n            if (m_expiredOverlay != null) {\n                m_expiredOverlay.removeFromParent();\n                m_expiredOverlay = null;\n            }\n\n        } else {\n            addStyleName(I_CmsLayoutBundle.INSTANCE.containerpageCss().expired());\n            m_expiredOverlay = DOM.createDiv();\n            m_expiredOverlay.setTitle(\"Expired resource\");\n            m_expiredOverlay.addClassName(I_CmsLayoutBundle.INSTANCE.containerpageCss().expiredOverlay());\n            getElement().appendChild(m_expiredOverlay);\n        }\n    }","commit_id":"eec2702e7ec0d3489f142ef833422b848328a217","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Initializes the editor click handler.<p>\n     * \n     * @param controller the container page controller instance\n     */\n    public void initInlineEditor(final CmsContainerpageController controller) {\n\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(m_noEditReason)\n            && !m_disableNewEditor\n            && CmsContentEditor.setEditable(getElement(), true)) {\n            if (m_editorClickHandlerRegistration != null) {\n                m_editorClickHandlerRegistration.removeHandler();\n            }\n            m_editorClickHandlerRegistration = Event.addNativePreviewHandler(new NativePreviewHandler() {\n\n                public void onPreviewNativeEvent(NativePreviewEvent event) {\n\n                    if (event.getTypeInt() == Event.ONCLICK) {\n                        // if another content is already being edited, don't start another editor\n                        if (controller.isContentEditing()) {\n                            return;\n                        }\n                        Element eventTarget = event.getNativeEvent().getEventTarget().cast();\n                        // check if the event target is a child \n                        if (getElement().isOrHasChild(eventTarget)) {\n                            Element target = event.getNativeEvent().getEventTarget().cast();\n                            while ((target != null)\n                                && !target.getTagName().equalsIgnoreCase(\"a\")\n                                && (target != getElement())) {\n                                if (CmsContentEditor.isEditable(target)) {\n                                    EditorBase.markForInlineFocus((com.google.gwt.user.client.Element)target);\n                                    controller.getHandler().openEditorForElement(\n                                        CmsContainerPageElementPanel.this,\n                                        true);\n                                    removeEditorHandler();\n                                    event.cancel();\n                                    break;\n                                } else {\n                                    target = target.getParentElement();\n                                }\n                            }\n                        }\n                    }\n                }\n            });\n        }\n    }","id":75763,"modified_method":"/**\n     * Initializes the editor click handler.<p>\n     * \n     * @param controller the container page controller instance\n     */\n    public void initInlineEditor(final CmsContainerpageController controller) {\n\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(m_noEditReason)\n            && !m_disableNewEditor\n            && CmsContentEditor.setEditable(getElement(), true)) {\n            if (m_editorClickHandlerRegistration != null) {\n                m_editorClickHandlerRegistration.removeHandler();\n            }\n            m_editorClickHandlerRegistration = Event.addNativePreviewHandler(new NativePreviewHandler() {\n\n                public void onPreviewNativeEvent(NativePreviewEvent event) {\n\n                    if (event.getTypeInt() == Event.ONCLICK) {\n                        // if another content is already being edited, don't start another editor\n                        if (controller.isContentEditing()) {\n                            return;\n                        }\n                        Element eventTarget = event.getNativeEvent().getEventTarget().cast();\n                        // check if the event target is a child \n                        if (getElement().isOrHasChild(eventTarget)) {\n                            Element target = event.getNativeEvent().getEventTarget().cast();\n                            while ((target != null)\n                                && !target.getTagName().equalsIgnoreCase(\"a\")\n                                && (target != getElement())) {\n                                if (CmsContentEditor.isEditable(target)) {\n                                    EditorBase.markForInlineFocus(target);\n                                    controller.getHandler().openEditorForElement(\n                                        CmsContainerPageElementPanel.this,\n                                        true);\n                                    removeEditorHandler();\n                                    event.cancel();\n                                    break;\n                                } else {\n                                    target = target.getParentElement();\n                                }\n                            }\n                        }\n                    }\n                }\n            });\n        }\n    }","commit_id":"eec2702e7ec0d3489f142ef833422b848328a217","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Constructor.<p>\n     * \n     * @param element the DOM element\n     * @param parent the drag parent\n     * @param clientId the client id\n     * @param sitePath the element site-path\n     * @param noEditReason the no edit reason, if empty, editing is allowed\n     * @param hasSettings should be true if the element has settings which can be edited \n     * @param hasViewPermission indicates if the current user has view permissions on the element resource\n     * @param hasWritePermission indicates if the current user has write permissions on the element resource\n     * @param releasedAndNotExpired <code>true<\/code> if the element resource is currently released and not expired\n     * @param disableNewEditor flag to disable the new editor for this element \n     */\n    public CmsContainerPageElementPanel(\n        Element element,\n        I_CmsDropContainer parent,\n        String clientId,\n        String sitePath,\n        String noEditReason,\n        boolean hasSettings,\n        boolean hasViewPermission,\n        boolean hasWritePermission,\n        boolean releasedAndNotExpired,\n        boolean disableNewEditor) {\n\n        super((com.google.gwt.user.client.Element)element);\n        m_clientId = clientId;\n        m_sitePath = sitePath;\n        m_noEditReason = noEditReason;\n        m_hasSettings = hasSettings;\n        m_parent = parent;\n        m_disableNewEditor = disableNewEditor;\n        setViewPermission(hasViewPermission);\n        setWritePermission(hasWritePermission);\n        setReleasedAndNotExpired(releasedAndNotExpired);\n        getElement().addClassName(I_CmsLayoutBundle.INSTANCE.dragdropCss().dragElement());\n    }","id":75764,"modified_method":"/**\n     * Constructor.<p>\n     * \n     * @param element the DOM element\n     * @param parent the drag parent\n     * @param clientId the client id\n     * @param sitePath the element site-path\n     * @param noEditReason the no edit reason, if empty, editing is allowed\n     * @param hasSettings should be true if the element has settings which can be edited \n     * @param hasViewPermission indicates if the current user has view permissions on the element resource\n     * @param hasWritePermission indicates if the current user has write permissions on the element resource\n     * @param releasedAndNotExpired <code>true<\/code> if the element resource is currently released and not expired\n     * @param disableNewEditor flag to disable the new editor for this element \n     */\n    public CmsContainerPageElementPanel(\n        Element element,\n        I_CmsDropContainer parent,\n        String clientId,\n        String sitePath,\n        String noEditReason,\n        boolean hasSettings,\n        boolean hasViewPermission,\n        boolean hasWritePermission,\n        boolean releasedAndNotExpired,\n        boolean disableNewEditor) {\n\n        super(element);\n        m_clientId = clientId;\n        m_sitePath = sitePath;\n        m_noEditReason = noEditReason;\n        m_hasSettings = hasSettings;\n        m_parent = parent;\n        m_disableNewEditor = disableNewEditor;\n        setViewPermission(hasViewPermission);\n        setWritePermission(hasWritePermission);\n        setReleasedAndNotExpired(releasedAndNotExpired);\n        getElement().addClassName(I_CmsLayoutBundle.INSTANCE.dragdropCss().dragElement());\n    }","commit_id":"eec2702e7ec0d3489f142ef833422b848328a217","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Opens the XML content editor.<p>\n     * \n     * @param element the container element widget\n     * @param inline <code>true<\/code> to open the in-line editor for the given element if available\n     */\n    public void openDialog(\n\n    final CmsContainerPageElementPanel element, final boolean inline) {\n\n        m_handler.disableToolbarButtons();\n        m_handler.deactivateCurrentButton();\n        m_currentElementId = element.getId();\n        String serverId = CmsContainerpageController.getServerId(getCurrentElementId());\n        if (m_handler.m_controller.getData().isUseClassicEditor() || element.isNewEditorDisabled()) {\n            CmsEditableData editableData = new CmsEditableData();\n            editableData.setElementLanguage(CmsCoreProvider.get().getLocale());\n            editableData.setStructureId(new CmsUUID(serverId));\n            editableData.setSitePath(element.getSitePath());\n            CmsContentEditorDialog.get().openEditDialog(editableData, false, CmsContentEditorHandler.this);\n        } else {\n            String editorLocale = CmsCoreProvider.get().getLocale();\n\n            Command onClose = new Command() {\n\n                public void execute() {\n\n                    addClosedEditorHistoryItem();\n                    onClose(element.getSitePath(), false);\n                }\n            };\n            if (inline && CmsContentEditor.hasEditable(element.getElement())) {\n                addEditingHistoryItem(true);\n                CmsEditorContext context = getEditorContext();\n                context.setHtmlContextInfo(getContextInfo(element));\n                CmsContentEditor.getInstance().openInlineEditor(\n                    context,\n                    new CmsUUID(serverId),\n                    editorLocale,\n                    element,\n                    onClose);\n            } else {\n                addEditingHistoryItem(false);\n                CmsContentEditor.getInstance().openFormEditor(\n                    getEditorContext(),\n                    editorLocale,\n                    serverId,\n                    null,\n                    null,\n                    onClose);\n            }\n        }\n    }","id":75765,"modified_method":"/**\n     * Opens the XML content editor.<p>\n     * \n     * @param element the container element widget\n     * @param inline <code>true<\/code> to open the in-line editor for the given element if available\n     */\n    public void openDialog(\n\n    final CmsContainerPageElementPanel element, final boolean inline) {\n\n        m_handler.disableToolbarButtons();\n        m_handler.deactivateCurrentButton();\n        m_currentElementId = element.getId();\n        String serverId = CmsContainerpageController.getServerId(getCurrentElementId());\n        if (m_handler.m_controller.getData().isUseClassicEditor() || element.isNewEditorDisabled()) {\n            CmsEditableData editableData = new CmsEditableData();\n            editableData.setElementLanguage(CmsCoreProvider.get().getLocale());\n            editableData.setStructureId(new CmsUUID(serverId));\n            editableData.setSitePath(element.getSitePath());\n            CmsContentEditorDialog.get().openEditDialog(editableData, false, CmsContentEditorHandler.this);\n        } else {\n            String editorLocale = CmsCoreProvider.get().getLocale();\n\n            Command onClose = new Command() {\n\n                public void execute() {\n\n                    addClosedEditorHistoryItem();\n                    onClose(element.getSitePath(), false);\n                }\n            };\n            if (inline && CmsContentEditor.hasEditable(element.getElement())) {\n                addEditingHistoryItem(true);\n                CmsEditorContext context = getEditorContext();\n                context.setHtmlContextInfo(getContextInfo(element));\n                // remove expired style before initializing the editor\n                element.setReleasedAndNotExpired(true);\n                CmsContentEditor.getInstance().openInlineEditor(\n                    context,\n                    new CmsUUID(serverId),\n                    editorLocale,\n                    element,\n                    onClose);\n            } else {\n                addEditingHistoryItem(false);\n                CmsContentEditor.getInstance().openFormEditor(\n                    getEditorContext(),\n                    editorLocale,\n                    serverId,\n                    null,\n                    null,\n                    onClose);\n            }\n        }\n    }","commit_id":"eec2702e7ec0d3489f142ef833422b848328a217","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public EditorCell createEditorCell(EditorContext context) {\n    EditorCell result = createCell_internal(myEditorContext);\n    // do not override role/link-declaration if they are already set\n    if (result.getUserObject(EditorCell.ROLE) == null &&\n      result.getUserObject(EditorCell.METAINFO_LINK_DECLARATION) == null) {\n      result.putUserObject(EditorCell.ROLE, myGenuineRole);\n      result.putUserObject(EditorCell.METAINFO_LINK_DECLARATION, myGenuineLinkDeclaration.getNode());\n    }\n    return result;\n  }","id":75766,"modified_method":"public EditorCell createEditorCell(EditorContext context) {\n    EditorCell result = createCell_internal(myEditorContext);\n    // do not override role/link-declaration if they are already set\n    if (result.getUserObject(EditorCell.ROLE) == null &&\n      result.getUserObject(EditorCell.METAINFO_LINK_DECLARATION) == null) {\n      result.putUserObject(EditorCell.ROLE, myGenuineRole);\n      if (myGenuineLinkDeclaration != null) {\n        result.putUserObject(EditorCell.METAINFO_LINK_DECLARATION, myGenuineLinkDeclaration.getNode());\n      } else {\n        LOG.error(\"Can't find link declaration \" + myGenuineRole);\n      }\n    }\n    return result;\n  }","commit_id":"77445d998858515e30759f84a03e1f9b266f86c2","url":"https://github.com/JetBrains/MPS"},{"original_method":"private Object readUserObject(ModelInputStream is, SModel model) throws IOException {\n      int id = is.readInt();\n      switch (id) {\n        case NodesAndUserObjectsWriter.NODE_POINTER:\n          return is.readNodePointer();\n        case NodesAndUserObjectsWriter.NODE_ID:\n          return is.readNodeId();\n        case NodesAndUserObjectsWriter.MODEL_ID:\n          return is.readModelID();\n        case NodesAndUserObjectsWriter.MODEL_REFERENCE:\n          return is.readModelReference();\n        case NodesAndUserObjectsWriter.NODE:\n          SModel tmodel = null;\n          SModelReference modelRef = is.readModelReference();\n          SNodeId nodeId = is.readNodeId();\n          if (LOCAL.equals(modelRef)) {\n            tmodel = model;\n          } else {\n            SModelDescriptor mdesc = SModelRepository.getInstance().getModelDescriptor(modelRef);\n            if (mdesc != null) {\n              tmodel = mdesc.getSModel();\n            }\n          }\n          if (tmodel != null) {\n            return tmodel.getNodeById(nodeId);\n          } else {\n            throw new IOException(\"couldn't load user object\");\n          }\n        case NodesAndUserObjectsWriter.SERIALIZABLE:\n          ObjectInputStream stream = new ObjectInputStream(is);\n          try {\n            return stream.readObject();\n          } catch (ClassNotFoundException e) {\n            throw new IOException(e);\n          }\n      }\n      throw new IOException(\"Could not read user object\");\n    }","id":75767,"modified_method":"private Object readUserObject(ModelInputStream is, SModel model) throws IOException {\n      int id = is.readInt();\n      switch (id) {\n        case NodesAndUserObjectsWriter.NODE_POINTER:\n          return is.readNodePointer();\n        case NodesAndUserObjectsWriter.NODE_ID:\n          return is.readNodeId();\n        case NodesAndUserObjectsWriter.MODEL_ID:\n          return is.readModelID();\n        case NodesAndUserObjectsWriter.MODEL_REFERENCE:\n          return is.readModelReference();\n        case NodesAndUserObjectsWriter.NODE:\n          SModel tmodel = null;\n          SModelReference modelRef = is.readModelReference();\n          SNodeId nodeId = is.readNodeId();\n          if (LOCAL.equals(modelRef)) {\n            tmodel = model;\n          } else {\n            SModelDescriptor mdesc = SModelRepository.getInstance().getModelDescriptor(modelRef);\n            if (mdesc != null) {\n              tmodel = mdesc.getSModel();\n            }\n          }\n          if (tmodel != null) {\n            return tmodel.getNodeById(nodeId);\n          } else {\n            throw new IOException(\"couldn't load user object\");\n          }\n        case NodesAndUserObjectsWriter.SERIALIZABLE:\n          ObjectInputStream stream = new ObjectInputStream(is);\n          try {\n            return stream.readObject();\n          } catch (ClassNotFoundException ignore) {\n            // class could be loaded by the other classloader\n            return null;\n          }\n      }\n      throw new IOException(\"Could not read user object\");\n    }","commit_id":"aa42c9ccd26b5b072f3e0db5fb3d665a1f343a63","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    protected void readChildren(SModel model, ModelInputStream is, SNode node) throws IOException {\n      // first read user objects\n      int userObjectCount = is.readInt();\n      for (int i = 0; i < userObjectCount; i += 2) {\n        Object key = readUserObject(is, model);\n        Object value = readUserObject(is, model);\n        node.putUserObject(key, value);\n      }\n\n      super.readChildren(model, is, node);\n    }","id":75768,"modified_method":"@Override\n    protected void readChildren(SModel model, ModelInputStream is, SNode node) throws IOException {\n      // first read user objects\n      int userObjectCount = is.readInt();\n      for (int i = 0; i < userObjectCount; i += 2) {\n        Object key = readUserObject(is, model);\n        Object value = readUserObject(is, model);\n        if (key != null && value != null) {\n          node.putUserObject(key, value);\n        }\n      }\n\n      super.readChildren(model, is, node);\n    }","commit_id":"aa42c9ccd26b5b072f3e0db5fb3d665a1f343a63","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static void populateTextGenCompatibilityObjects(TextGenBuffer buffer, SNode node) {\n    // BL-specific object, BL shall manage itself\n    buffer.putUserObject(PACKAGE_NAME, NameUtil.getModelLongName(node.getModel()));\n    // shall get replaced with TextUnit#getStartNode()\n    buffer.putUserObject(ROOT_NODE, node);\n    buffer.putUserObject(COMPATIBILITY_USE_ATTRIBUTES, ourEnabledNodeAttributes);\n  }","id":75769,"modified_method":"private static void populateTextGenCompatibilityObjects(TextGenBuffer buffer, SNode node) {\n    // BL-specific object, BL shall manage itself\n    if (node.getModel() != null) {\n      buffer.putUserObject(PACKAGE_NAME, NameUtil.getModelLongName(node.getModel()));\n    }\n    // shall get replaced with TextUnit#getStartNode()\n    buffer.putUserObject(ROOT_NODE, node);\n    buffer.putUserObject(COMPATIBILITY_USE_ATTRIBUTES, ourEnabledNodeAttributes);\n  }","commit_id":"f92db99d12342a951246fc68f1d0650a768f206f","url":"https://github.com/JetBrains/MPS"},{"original_method":"private PageTable getPageTable(boolean create)\n\t{\n\t\tPageTable pageTable = (PageTable)pageManagerContext.getSessionAttribute(PAGE_TABLE_KEY);\n\t\tif (pageTable == null && create)\n\t\t{\n\t\t\tpageTable = new PageTable();\n\t\t\tpageManagerContext.setSessionAttribute(PAGE_TABLE_KEY, pageTable);\n\t\t}\n\n\t\treturn pageTable;\n\t}","id":75770,"modified_method":"private PageTable getPageTable(boolean create)\n\t{\n\t\tPageTable pageTable = null;\n\t\tif (Session.exists())\n\t\t{\n\t\t\tpageTable = (PageTable)pageManagerContext.getSessionAttribute(PAGE_TABLE_KEY);\n\t\t\tif (pageTable == null && create)\n\t\t\t{\n\t\t\t\tpageTable = new PageTable();\n\t\t\t\tpageManagerContext.setSessionAttribute(PAGE_TABLE_KEY, pageTable);\n\t\t\t}\n\t\t}\n\t\treturn pageTable;\n\t}","commit_id":"a06d47fd58f625df0b17c220da7d313118a9435b","url":"https://github.com/apache/wicket"},{"original_method":"public void storeData(String sessionId, int pageId, byte[] pageAsBytes)\n\t{\n\t\tPageTable pageTable = getPageTable(true);\n\t\tpageTable.storePage(pageId, pageAsBytes);\n\n\t\tevictionStrategy.evict(pageTable);\n\t}","id":75771,"modified_method":"public void storeData(String sessionId, int pageId, byte[] pageAsBytes)\n\t{\n\t\tPageTable pageTable = getPageTable(true);\n\t\tif (pageTable != null)\n\t\t{\n\t\t\tpageTable.storePage(pageId, pageAsBytes);\n\t\t\tevictionStrategy.evict(pageTable);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog.error(\"Cannot store the data for page with id '{}' in session with id '{}'\",\n\t\t\t\tpageId, sessionId);\n\t\t}\n\t}","commit_id":"a06d47fd58f625df0b17c220da7d313118a9435b","url":"https://github.com/apache/wicket"},{"original_method":"public Serializable prepareForSerialization(final String sessionId, final Object object)\n\t{\n\t\tif (pageDataStore.isReplicated())\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tSerializedPage result = null;\n\n\t\tif (object instanceof IManageablePage)\n\t\t{\n\t\t\tIManageablePage page = (IManageablePage)object;\n\t\t\tresult = serializedPagesCache.getPage(sessionId, page.getPageId());\n\t\t\tif (result == null)\n\t\t\t{\n\t\t\t\tresult = serializePage(sessionId, page);\n\t\t\t\tserializedPagesCache.storePage(result);\n\t\t\t}\n\t\t}\n\t\telse if (object instanceof SerializedPage)\n\t\t{\n\t\t\tSerializedPage page = (SerializedPage)object;\n\t\t\tif (page.getData() == null)\n\t\t\t{\n\t\t\t\tresult = restoreStrippedSerializedPage(page);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = page;\n\t\t\t}\n\t\t}\n\n\t\tif (result != null)\n\t\t{\n\t\t\treturn result;\n\t\t}\n\t\treturn (Serializable)object;\n\t}","id":75772,"modified_method":"public Serializable prepareForSerialization(final String sessionId, final Object object)\n\t{\n\t\tif (pageDataStore.isReplicated())\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tSerializedPage result = null;\n\n\t\tif (object instanceof IManageablePage)\n\t\t{\n\t\t\tIManageablePage page = (IManageablePage)object;\n\t\t\tresult = serializedPagesCache.getPage(sessionId, page.getPageId());\n\t\t\tif (result == null)\n\t\t\t{\n\t\t\t\tresult = serializePage(sessionId, page);\n\t\t\t\tif (result != null)\n\t\t\t\t{\n\t\t\t\t\tserializedPagesCache.storePage(result);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (object instanceof SerializedPage)\n\t\t{\n\t\t\tSerializedPage page = (SerializedPage)object;\n\t\t\tif (page.getData() == null)\n\t\t\t{\n\t\t\t\tresult = restoreStrippedSerializedPage(page);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = page;\n\t\t\t}\n\t\t}\n\n\t\tif (result != null)\n\t\t{\n\t\t\treturn result;\n\t\t}\n\t\treturn (Serializable)object;\n\t}","commit_id":"a25af5ac9ddcbe4f1792c90c56c54b9e71eefb68","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * \n\t * @param sessionId\n\t * @param page\n\t * @return the serialized page information\n\t */\n\tprotected SerializedPage serializePage(final String sessionId, final IManageablePage page)\n\t{\n\t\tArgs.notNull(sessionId, \"sessionId\");\n\t\tArgs.notNull(page, \"page\");\n\n\t\tbyte[] data = pageSerializer.serialize(page);\n\t\treturn new SerializedPage(sessionId, page.getPageId(), data);\n\t}","id":75773,"modified_method":"/**\n\t * \n\t * @param sessionId\n\t * @param page\n\t * @return the serialized page information\n\t */\n\tprotected SerializedPage serializePage(final String sessionId, final IManageablePage page)\n\t{\n\t\tArgs.notNull(sessionId, \"sessionId\");\n\t\tArgs.notNull(page, \"page\");\n\n\t\tSerializedPage serializedPage = null;\n\n\t\tbyte[] data = pageSerializer.serialize(page);\n\n\t\tif (data != null)\n\t\t{\n\t\t\tserializedPage = new SerializedPage(sessionId, page.getPageId(), data);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tLOG.warn(\"Page {} cannot be serialized. See previous logs for possible reasons.\", page);\n\t\t}\n\t\treturn serializedPage;\n\t}","commit_id":"a25af5ac9ddcbe4f1792c90c56c54b9e71eefb68","url":"https://github.com/apache/wicket"},{"original_method":"public void storePage(final String sessionId, final IManageablePage page)\n\t{\n\t\tSerializedPage serialized = serializePage(sessionId, page);\n\t\tserializedPagesCache.storePage(serialized);\n\t\tstorePageData(sessionId, serialized.getPageId(), serialized.getData());\n\t}","id":75774,"modified_method":"public void storePage(final String sessionId, final IManageablePage page)\n\t{\n\t\tSerializedPage serialized = serializePage(sessionId, page);\n\t\tif (serialized != null)\n\t\t{\n\t\t\tserializedPagesCache.storePage(serialized);\n\t\t\tstorePageData(sessionId, serialized.getPageId(), serialized.getData());\n\t\t}\n\t}","commit_id":"a25af5ac9ddcbe4f1792c90c56c54b9e71eefb68","url":"https://github.com/apache/wicket"},{"original_method":"public Object deserialize(final byte[] data)\n\t{\n\t\tThreadContext old = ThreadContext.get(false);\n\t\tfinal ByteArrayInputStream in = new ByteArrayInputStream(data);\n\t\tObjectInputStream ois = null;\n\t\ttry\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tois = newObjectInputStream(in);\n\t\t\t\tString applicationName = (String)ois.readObject();\n\t\t\t\tif (applicationName != null && !Application.exists())\n\t\t\t\t{\n\t\t\t\t\tApplication app = Application.get(applicationName);\n\t\t\t\t\tif (app != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tThreadContext.setApplication(app);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn ois.readObject();\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tIOUtils.close(ois);\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tin.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (ClassNotFoundException e)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Could not deserialize object using: \" + ois.getClass(), e);\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Could not deserialize object using: \" + ois.getClass(), e);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tThreadContext.restore(old);\n\t\t}\n\t}","id":75775,"modified_method":"public Object deserialize(final byte[] data)\n\t{\n\t\tThreadContext old = ThreadContext.get(false);\n\t\tfinal ByteArrayInputStream in = new ByteArrayInputStream(data);\n\t\tObjectInputStream ois = null;\n\t\ttry\n\t\t{\n\t\t\tApplication oldApplication = ThreadContext.getApplication();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tois = newObjectInputStream(in);\n\t\t\t\tString applicationName = (String)ois.readObject();\n\t\t\t\tif (applicationName != null)\n\t\t\t\t{\n\t\t\t\t\tApplication app = Application.get(applicationName);\n\t\t\t\t\tif (app != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tThreadContext.setApplication(app);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn ois.readObject();\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tThreadContext.setApplication(oldApplication);\n\t\t\t\t\tIOUtils.close(ois);\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tin.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (ClassNotFoundException e)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Could not deserialize object using: \" + ois.getClass(), e);\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Could not deserialize object using: \" + ois.getClass(), e);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tThreadContext.restore(old);\n\t\t}\n\t}","commit_id":"a25af5ac9ddcbe4f1792c90c56c54b9e71eefb68","url":"https://github.com/apache/wicket"},{"original_method":"protected String getLeftMostValue(String headerValue)\n    {\n        if (headerValue == null)\n            return null;\n\n        int commaIndex = headerValue.indexOf(',');\n\n        if (commaIndex == -1)\n        {\n            // Single value\n            return headerValue;\n        }\n\n        // The left-most value is the farthest downstream client\n        return headerValue.substring(0,commaIndex);\n    }","id":75776,"modified_method":"protected String getLeftMostFieldValue(HttpFields fields, String header)\n    {\n        if (header == null)\n            return null;\n\n        String headerValue = fields.getStringField(header);\n\n        if (headerValue == null)\n            return null;\n\n        int commaIndex = headerValue.indexOf(',');\n\n        if (commaIndex == -1)\n        {\n            // Single value\n            return headerValue;\n        }\n\n        // The left-most value is the farthest downstream client\n        return headerValue.substring(0,commaIndex);\n    }","commit_id":"6a2ecc493e010ff33c4280a1d7aa5dfe7ae78283","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected void checkForwardedHeaders(EndPoint endpoint, Request request) throws IOException\n    {\n        HttpFields httpFields = request.getConnection().getRequestFields();\n\n        // Retrieving headers from the request\n        String forwardedHost = getLeftMostValue(httpFields.getStringField(getForwardedHostHeader()));\n        String forwardedServer = getLeftMostValue(httpFields.getStringField(getForwardedServerHeader()));\n        String forwardedFor = getLeftMostValue(httpFields.getStringField(getForwardedForHeader()));\n        String forwardedProto = getLeftMostValue(httpFields.getStringField(getForwardedProtoHeader()));\n\n        if (_hostHeader != null)\n        {\n            // Update host header\n            httpFields.put(HttpHeaders.HOST_BUFFER,_hostHeader);\n            request.setServerName(null);\n            request.setServerPort(-1);\n            request.getServerName();\n        }\n        else if (forwardedHost != null)\n        {\n            // Update host header\n            httpFields.put(HttpHeaders.HOST_BUFFER,forwardedHost);\n            request.setServerName(null);\n            request.setServerPort(-1);\n            request.getServerName();\n        }\n        else if (forwardedServer != null)\n        {\n            // Use provided server name\n            request.setServerName(forwardedServer);\n        }\n\n        if (forwardedFor != null)\n        {\n            request.setRemoteAddr(forwardedFor);\n            InetAddress inetAddress = null;\n\n            if (_useDNS)\n            {\n                try\n                {\n                    inetAddress = InetAddress.getByName(forwardedFor);\n                }\n                catch (UnknownHostException e)\n                {\n                    Log.ignore(e);\n                }\n            }\n\n            request.setRemoteHost(inetAddress == null?forwardedFor:inetAddress.getHostName());\n        }\n        \n        if (forwardedProto != null)\n        {\n            request.setScheme(forwardedProto);\n        }\n    }","id":75777,"modified_method":"protected void checkForwardedHeaders(EndPoint endpoint, Request request) throws IOException\n    {\n        HttpFields httpFields = request.getConnection().getRequestFields();\n\n        // Do SSL first\n        if (getForwardedCipherSuiteHeader()!=null)\n        {\n            String cipher_suite=httpFields.getStringField(getForwardedCipherSuiteHeader());\n            if (cipher_suite!=null)\n                request.setAttribute(\"javax.servlet.request.cipher_suite\",cipher_suite);\n        }\n        if (getForwardedSslSessionIdHeader()!=null)\n        {\n            String ssl_session_id=httpFields.getStringField(getForwardedSslSessionIdHeader());\n            if(ssl_session_id!=null)\n            {\n                request.setAttribute(\"javax.servlet.request.ssl_session_id\", ssl_session_id);\n                request.setScheme(HttpSchemes.HTTPS);\n            }\n        }\n        \n        // Retrieving headers from the request\n        String forwardedHost = getLeftMostFieldValue(httpFields,getForwardedHostHeader());\n        String forwardedServer = getLeftMostFieldValue(httpFields,getForwardedServerHeader());\n        String forwardedFor = getLeftMostFieldValue(httpFields,getForwardedForHeader());\n        String forwardedProto = getLeftMostFieldValue(httpFields,getForwardedProtoHeader());\n        \n        if (_hostHeader != null)\n        {\n            // Update host header\n            httpFields.put(HttpHeaders.HOST_BUFFER,_hostHeader);\n            request.setServerName(null);\n            request.setServerPort(-1);\n            request.getServerName();\n        }\n        else if (forwardedHost != null)\n        {\n            // Update host header\n            httpFields.put(HttpHeaders.HOST_BUFFER,forwardedHost);\n            request.setServerName(null);\n            request.setServerPort(-1);\n            request.getServerName();\n        }\n        else if (forwardedServer != null)\n        {\n            // Use provided server name\n            request.setServerName(forwardedServer);\n        }\n\n        if (forwardedFor != null)\n        {\n            request.setRemoteAddr(forwardedFor);\n            InetAddress inetAddress = null;\n\n            if (_useDNS)\n            {\n                try\n                {\n                    inetAddress = InetAddress.getByName(forwardedFor);\n                }\n                catch (UnknownHostException e)\n                {\n                    Log.ignore(e);\n                }\n            }\n\n            request.setRemoteHost(inetAddress == null?forwardedFor:inetAddress.getHostName());\n        }\n        \n        if (forwardedProto != null)\n        {\n            request.setScheme(forwardedProto);\n        }\n    }","commit_id":"6a2ecc493e010ff33c4280a1d7aa5dfe7ae78283","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected NestedConnection(final NestedConnector connector, final NestedEndPoint endp, final HttpServletRequest outerRequest, HttpServletResponse outerResponse,String nestedIn)\n        throws IOException\n    {\n        super(connector,\n              endp,\n              connector.getServer(),\n              new NestedParser(),\n              new NestedGenerator(connector.getResponseBuffers(),endp,outerResponse,nestedIn),\n              new NestedRequest(outerRequest));\n\n        ((NestedRequest)_request).setConnection(this);\n        \n        // Set the request line\n        _request.setDispatcherType(DispatcherType.REQUEST);\n        _request.setScheme(outerRequest.getScheme());\n        _request.setMethod(outerRequest.getMethod());\n        String uri=outerRequest.getQueryString()==null?outerRequest.getRequestURI():(outerRequest.getRequestURI()+\"?\"+outerRequest.getQueryString());\n        _request.setUri(new HttpURI(uri));\n        _request.setPathInfo(outerRequest.getRequestURI());\n        _request.setQueryString(outerRequest.getQueryString());\n        _request.setProtocol(outerRequest.getProtocol());\n        \n        // Set the headers\n        HttpFields fields = getRequestFields();\n        for (Enumeration<String> e=outerRequest.getHeaderNames();e.hasMoreElements();)\n        {\n            String header=e.nextElement();\n            String value=outerRequest.getHeader(header);\n            fields.add(header,value);\n        }\n        \n        // Slight hack for cloud foundry\n        if (!fields.containsKey(\"x-forwarded-for\") && outerRequest.getHeader(\"x-forwarded_for\")!=null)\n            fields.add(\"x-forwarded-for\",outerRequest.getHeader(\"x-forwarded_for\"));\n        \n        // Let outer parse the cookies\n        _request.setCookies(outerRequest.getCookies());\n        \n        // copy request attributes\n        for (Enumeration<String> e=outerRequest.getAttributeNames();e.hasMoreElements();)\n        {\n            String attr=e.nextElement();\n            _request.setAttribute(attr,outerRequest.getAttribute(attr));\n        }\n        \n        // customize the request\n        connector.customize(endp,_request);\n        \n        // System.err.println(_request.getMethod()+\" \"+_request.getUri()+\" \"+_request.getProtocol());\n        // System.err.println(fields.toString());\n    }","id":75778,"modified_method":"protected NestedConnection(final NestedConnector connector, final NestedEndPoint endp, final HttpServletRequest outerRequest, HttpServletResponse outerResponse,String nestedIn)\n        throws IOException\n    {\n        super(connector,\n              endp,\n              connector.getServer(),\n              new NestedParser(),\n              new NestedGenerator(connector.getResponseBuffers(),endp,outerResponse,nestedIn),\n              new NestedRequest(outerRequest));\n\n        ((NestedRequest)_request).setConnection(this);\n        \n        // Set the request line\n        _request.setDispatcherType(DispatcherType.REQUEST);\n        _request.setScheme(outerRequest.getScheme());\n        _request.setMethod(outerRequest.getMethod());\n        String uri=outerRequest.getQueryString()==null?outerRequest.getRequestURI():(outerRequest.getRequestURI()+\"?\"+outerRequest.getQueryString());\n        _request.setUri(new HttpURI(uri));\n        _request.setPathInfo(outerRequest.getRequestURI());\n        _request.setQueryString(outerRequest.getQueryString());\n        _request.setProtocol(outerRequest.getProtocol());\n        \n        // Set the headers\n        HttpFields fields = getRequestFields();\n        for (Enumeration<String> e=outerRequest.getHeaderNames();e.hasMoreElements();)\n        {\n            String header=e.nextElement();\n            String value=outerRequest.getHeader(header);\n            fields.add(header,value);\n        }\n        \n        // Let outer parse the cookies\n        _request.setCookies(outerRequest.getCookies());\n        \n        // copy request attributes\n        for (Enumeration<String> e=outerRequest.getAttributeNames();e.hasMoreElements();)\n        {\n            String attr=e.nextElement();\n            _request.setAttribute(attr,outerRequest.getAttribute(attr));\n        }\n        \n        // customize the request\n        connector.customize(endp,_request);\n        \n        // System.err.println(_request.getMethod()+\" \"+_request.getUri()+\" \"+_request.getProtocol());\n        // System.err.println(fields.toString());\n    }","commit_id":"6a2ecc493e010ff33c4280a1d7aa5dfe7ae78283","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public boolean isSecure()\n    {\n        return _outer.isSecure();\n    }","id":75779,"modified_method":"public boolean isSecure()\n    {\n        return _outer.isSecure() || HttpSchemes.HTTPS.equals(getScheme());\n    }","commit_id":"6a2ecc493e010ff33c4280a1d7aa5dfe7ae78283","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void map(final FileBasedIndex.FileContent inputData, final IndexDataConsumer<TodoIndexEntry, Integer> consumer) {\n      final CharSequence chars = inputData.content;\n      if (IdCacheUtil.getIndexPatternCount() > 0) {\n        final TodoOccurrenceConsumer occurrenceConsumer = new TodoOccurrenceConsumer();\n        final EditorHighlighter highlighter = HighlighterFactory.createHighlighter(null, myFile);\n        highlighter.setText(chars);\n        final HighlighterIterator iterator = highlighter.createIterator(0);\n        while (!iterator.atEnd()) {\n          final IElementType token = iterator.getTokenType();\n          if (IdCacheUtil.isInComments(token) || myCommentTokens.contains(token)) {\n            BaseFilterLexer.advanceTodoItemsCount(chars.subSequence(iterator.getStart(), iterator.getEnd()), occurrenceConsumer);\n          }\n          iterator.advance();\n        }\n        for (IndexPattern pattern : IdCacheUtil.getIndexPatterns()) {\n          consumer.consume(new TodoIndexEntry(pattern.getPatternString(), pattern.isCaseSensitive()), occurrenceConsumer.getOccurrenceCount(pattern));\n        }\n      }\n    }","id":75780,"modified_method":"public Map<TodoIndexEntry,Integer> map(final FileBasedIndex.FileContent inputData) {\n      final CharSequence chars = inputData.content;\n      if (IdCacheUtil.getIndexPatternCount() > 0) {\n        final TodoOccurrenceConsumer occurrenceConsumer = new TodoOccurrenceConsumer();\n        final EditorHighlighter highlighter = HighlighterFactory.createHighlighter(null, myFile);\n        highlighter.setText(chars);\n        final HighlighterIterator iterator = highlighter.createIterator(0);\n        while (!iterator.atEnd()) {\n          final IElementType token = iterator.getTokenType();\n          if (IdCacheUtil.isInComments(token) || myCommentTokens.contains(token)) {\n            BaseFilterLexer.advanceTodoItemsCount(chars.subSequence(iterator.getStart(), iterator.getEnd()), occurrenceConsumer);\n          }\n          iterator.advance();\n        }\n        final Map<TodoIndexEntry,Integer> map = new HashMap<TodoIndexEntry, Integer>();\n        for (IndexPattern pattern : IdCacheUtil.getIndexPatterns()) {\n          final int count = occurrenceConsumer.getOccurrenceCount(pattern);\n          if (count > 0) {\n            map.put(new TodoIndexEntry(pattern.getPatternString(), pattern.isCaseSensitive()), count);\n          }\n        }\n        return map;\n      }\n      return Collections.emptyMap();\n    }","commit_id":"7fff9a82b504f8b16ecf9e9e086dd2131baeaa8d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void map(final FileBasedIndex.FileContent inputData, final IndexDataConsumer<TodoIndexEntry, Integer> consumer) {\n      final CharSequence chars = inputData.content;\n\n\n      final IndexPattern[] indexPatterns = IdCacheUtil.getIndexPatterns();\n      final TodoOccurrenceConsumer occurrenceConsumer = new TodoOccurrenceConsumer();\n      for (IndexPattern indexPattern : indexPatterns) {\n        Pattern pattern = indexPattern.getPattern();\n        if (pattern != null) {\n          Matcher matcher = pattern.matcher(chars);\n          while (matcher.find()) {\n            if (matcher.start() != matcher.end()) {\n              occurrenceConsumer.incTodoOccurrence(indexPattern);\n            }\n          }\n        }\n      }\n      for (IndexPattern indexPattern : indexPatterns) {\n        consumer.consume(new TodoIndexEntry(indexPattern.getPatternString(), indexPattern.isCaseSensitive()), occurrenceConsumer.getOccurrenceCount(indexPattern));\n      }\n    }","id":75781,"modified_method":"public Map<TodoIndexEntry, Integer> map(final FileBasedIndex.FileContent inputData) {\n      final CharSequence chars = inputData.content;\n\n\n      final IndexPattern[] indexPatterns = IdCacheUtil.getIndexPatterns();\n      if (indexPatterns.length > 0) {\n        final TodoOccurrenceConsumer occurrenceConsumer = new TodoOccurrenceConsumer();\n        for (IndexPattern indexPattern : indexPatterns) {\n          Pattern pattern = indexPattern.getPattern();\n          if (pattern != null) {\n            Matcher matcher = pattern.matcher(chars);\n            while (matcher.find()) {\n              if (matcher.start() != matcher.end()) {\n                occurrenceConsumer.incTodoOccurrence(indexPattern);\n              }\n            }\n          }\n        }\n        Map<TodoIndexEntry, Integer> map = new HashMap<TodoIndexEntry, Integer>();\n        for (IndexPattern indexPattern : indexPatterns) {\n          final int count = occurrenceConsumer.getOccurrenceCount(indexPattern);\n          if (count > 0) {\n            map.put(new TodoIndexEntry(indexPattern.getPatternString(), indexPattern.isCaseSensitive()), count);\n          }\n        }\n        return map;\n      }\n      return Collections.emptyMap();\n    }","commit_id":"7fff9a82b504f8b16ecf9e9e086dd2131baeaa8d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void map(final FileBasedIndex.FileContent inputData, final IndexDataConsumer<IdIndexEntry, Integer> consumer) {\n      final CharSequence chars = inputData.content;\n      scanWords(new ScanWordProcessor(){\n        public void run(final CharSequence chars11, final int start, final int end, char[] charsArray) {\n          if (charsArray != null) {\n            addOccurrence(consumer, charsArray, start, end, (int)UsageSearchContext.IN_PLAIN_TEXT);\n          } else {\n            addOccurrence(consumer, chars11, start, end, (int)UsageSearchContext.IN_PLAIN_TEXT);\n          }\n        }\n      }, chars, 0, chars.length());\n    }","id":75782,"modified_method":"public Map<IdIndexEntry, Integer> map(final FileBasedIndex.FileContent inputData) {\n      final IdDataConsumer consumer = new IdDataConsumer();\n      final CharSequence chars = inputData.content;\n      scanWords(new ScanWordProcessor(){\n        public void run(final CharSequence chars11, final int start, final int end, char[] charsArray) {\n          if (charsArray != null) {\n            consumer.addOccurrence(charsArray, start, end, (int)UsageSearchContext.IN_PLAIN_TEXT);\n          } else {\n            consumer.addOccurrence(chars11, start, end, (int)UsageSearchContext.IN_PLAIN_TEXT);\n          }\n        }\n      }, chars, 0, chars.length());\n      return consumer.getResult();\n    }","commit_id":"7fff9a82b504f8b16ecf9e9e086dd2131baeaa8d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void map(final FileBasedIndex.FileContent inputData, final IndexDataConsumer<IdIndexEntry, Integer> consumer) {\n      final CharSequence chars = inputData.content;\n      final char[] charsArray = CharArrayUtil.fromSequenceWithoutCopying(chars);\n\n      myScanner.processWords(chars, new Processor<WordOccurrence>() {\n        public boolean process(final WordOccurrence t) {\n          if(charsArray != null && t.getBaseText() == chars) {\n            addOccurrence(consumer, charsArray, t.getStart(),t.getEnd(),convertToMask(t.getKind()));\n          } \n          else {\n            addOccurrence(consumer, t.getBaseText(), t.getStart(),t.getEnd(),convertToMask(t.getKind()));\n          }\n          return true;\n        }\n\n        private int convertToMask(final WordOccurrence.Kind kind) {\n          if (kind == null) return UsageSearchContext.ANY;\n          if (kind == WordOccurrence.Kind.CODE) return UsageSearchContext.IN_CODE;\n          if (kind == WordOccurrence.Kind.COMMENTS) return UsageSearchContext.IN_COMMENTS;\n          if (kind == WordOccurrence.Kind.LITERALS) return UsageSearchContext.IN_STRINGS;\n          if (kind == WordOccurrence.Kind.FOREIGN_LANGUAGE) return UsageSearchContext.IN_FOREIGN_LANGUAGES;\n          return 0;\n        }\n      });\n    }","id":75783,"modified_method":"public Map<IdIndexEntry, Integer> map(final FileBasedIndex.FileContent inputData) {\n      final CharSequence chars = inputData.content;\n      final char[] charsArray = CharArrayUtil.fromSequenceWithoutCopying(chars);\n      final IdDataConsumer consumer = new IdDataConsumer();\n      myScanner.processWords(chars, new Processor<WordOccurrence>() {\n        public boolean process(final WordOccurrence t) {\n          if(charsArray != null && t.getBaseText() == chars) {\n            consumer.addOccurrence(charsArray, t.getStart(),t.getEnd(),convertToMask(t.getKind()));\n          } \n          else {\n            consumer.addOccurrence(t.getBaseText(), t.getStart(),t.getEnd(),convertToMask(t.getKind()));\n          }\n          return true;\n        }\n\n        private int convertToMask(final WordOccurrence.Kind kind) {\n          if (kind == null) return UsageSearchContext.ANY;\n          if (kind == WordOccurrence.Kind.CODE) return UsageSearchContext.IN_CODE;\n          if (kind == WordOccurrence.Kind.COMMENTS) return UsageSearchContext.IN_COMMENTS;\n          if (kind == WordOccurrence.Kind.LITERALS) return UsageSearchContext.IN_STRINGS;\n          if (kind == WordOccurrence.Kind.FOREIGN_LANGUAGE) return UsageSearchContext.IN_FOREIGN_LANGUAGES;\n          return 0;\n        }\n      });\n      return consumer.getResult();\n    }","commit_id":"7fff9a82b504f8b16ecf9e9e086dd2131baeaa8d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final void map(final FileBasedIndex.FileContent inputData, final IndexDataConsumer<IdIndexEntry, Integer> consumer) {\n    final Lexer lexer = createLexer(consumer);\n    final CharSequence chars = inputData.content;\n    lexer.start(chars, 0, chars.length(),0);\n    while (lexer.getTokenType() != null) {\n      lexer.advance();\n    }\n  }","id":75784,"modified_method":"public final Map<IdIndexEntry,Integer> map(final FileBasedIndex.FileContent inputData) {\n    final IdDataConsumer consumer = new IdDataConsumer();\n    final Lexer lexer = createLexer(new OccurrenceToIdDataConsumerAdapter(consumer));\n    final CharSequence chars = inputData.content;\n    lexer.start(chars, 0, chars.length(),0);\n    while (lexer.getTokenType() != null) {\n      lexer.advance();\n    }\n    return consumer.getResult();\n  }","commit_id":"7fff9a82b504f8b16ecf9e9e086dd2131baeaa8d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void map(final FileBasedIndex.FileContent inputData, final IndexDataConsumer<TodoIndexEntry, Integer> consumer) {\n    \n    final TodoOccurrenceConsumer todoOccurrenceConsumer = new TodoOccurrenceConsumer();\n    final Lexer filterLexer = createLexer(todoOccurrenceConsumer);\n    final CharSequence chars = inputData.content;\n    filterLexer.start(chars, 0, chars.length(),0);\n    while (filterLexer.getTokenType() != null) {\n      filterLexer.advance();\n    }\n\n    for (IndexPattern indexPattern : IdCacheUtil.getIndexPatterns()) {\n      consumer.consume(new TodoIndexEntry(indexPattern.getPatternString(), indexPattern.isCaseSensitive()), todoOccurrenceConsumer.getOccurrenceCount(indexPattern));\n    }\n  }","id":75785,"modified_method":"public Map<TodoIndexEntry,Integer> map(final FileBasedIndex.FileContent inputData) {\n    \n    final TodoOccurrenceConsumer todoOccurrenceConsumer = new TodoOccurrenceConsumer();\n    final Lexer filterLexer = createLexer(todoOccurrenceConsumer);\n    final CharSequence chars = inputData.content;\n    filterLexer.start(chars, 0, chars.length(),0);\n    while (filterLexer.getTokenType() != null) {\n      filterLexer.advance();\n    }\n    final Map<TodoIndexEntry,Integer> map = new HashMap<TodoIndexEntry, Integer>();\n    for (IndexPattern indexPattern : IdCacheUtil.getIndexPatterns()) {\n      final int count = todoOccurrenceConsumer.getOccurrenceCount(indexPattern);\n      if (count > 0) {\n        map.put(new TodoIndexEntry(indexPattern.getPatternString(), indexPattern.isCaseSensitive()), count);\n      }\n    }\n    return map;\n  }","commit_id":"7fff9a82b504f8b16ecf9e9e086dd2131baeaa8d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void update(int inputId, @Nullable Input content, @Nullable Input oldContent) throws StorageException {\n    final Map<Key, Set<Value>> oldData = oldContent != null? processInput(oldContent) : Collections.<Key, Set<Value>>emptyMap();\n    final Map<Key, Set<Value>> data    = content != null? processInput(content) : Collections.<Key, Set<Value>>emptyMap();\n\n    final Set<Key> allKeys = new HashSet<Key>(oldData.size() + data.size());\n    allKeys.addAll(oldData.keySet());\n    allKeys.addAll(data.keySet());\n\n    if (allKeys.size() > 0) {\n      for (Key key : allKeys) {\n        // remove outdated values\n        final Set<Value> oldValues = oldData.get(key);\n        final Lock writeLock = getWriteLock();\n        if (oldValues != null && oldValues.size() > 0) {\n          writeLock.lock();\n          try {\n            for (Value oldValue : oldValues) {\n              myStorage.removeValue(key, inputId, oldValue);\n            }\n          }\n          finally {\n            writeLock.unlock();\n          }\n        }\n        // add new values\n        final Set<Value> newValues = data.get(key);\n        if (newValues != null) {\n          writeLock.lock();\n          try {\n            for (Value value : newValues) {\n              myStorage.addValue(key, inputId, value);\n            }\n          }\n          finally {\n            writeLock.unlock();\n          }\n        }\n      }\n      scheduleFlush();\n    }\n  }","id":75786,"modified_method":"public void update(int inputId, @Nullable Input content, @Nullable Input oldContent) throws StorageException {\n    final Map<Key, Value> oldData = oldContent != null? myIndexer.map(oldContent) : Collections.<Key, Value>emptyMap();\n    final Map<Key, Value> data    = content != null? myIndexer.map(content) : Collections.<Key, Value>emptyMap();\n\n    final Set<Key> allKeys = new HashSet<Key>(oldData.size() + data.size());\n    allKeys.addAll(oldData.keySet());\n    allKeys.addAll(data.keySet());\n\n    if (allKeys.size() > 0) {\n      for (Key key : allKeys) {\n        // remove outdated values\n        final Value oldValue = oldData.get(key);\n        final Lock writeLock = getWriteLock();\n        if (oldValue != null) {\n          writeLock.lock();\n          try {\n            myStorage.removeValue(key, inputId, oldValue);\n          }\n          finally {\n            writeLock.unlock();\n          }\n        }\n        // add new values\n        final Value newValue = data.get(key);\n        if (newValue != null) {\n          writeLock.lock();\n          try {\n            myStorage.addValue(key, inputId, newValue);\n          }\n          finally {\n            writeLock.unlock();\n          }\n        }\n      }\n      scheduleFlush();\n    }\n  }","commit_id":"7fff9a82b504f8b16ecf9e9e086dd2131baeaa8d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void decompose() {\n\t\tString r = routingKey == null ? \"none\" : HexUtil.bytesToHex(routingKey);\n\t\tString k = cryptoKey == null ? \"none\" : HexUtil.bytesToHex(cryptoKey);\n\t\tString e = extra == null ? \"none\" : HexUtil.bytesToHex(extra);\n\t\tSystem.out.println(\"\" + this);\n\t\tSystem.out.println(\"Key type   : \" + keyType);\n\t\tSystem.out.println(\"Routing key: \" + r);\n\t\tSystem.out.println(\"Crypto key : \" + k);\n\t\tSystem.out.println(\"Extra      : \" + e);\n\t\tSystem.out.println(\n\t\t        \"Doc name   : \" + (docName == null ? \"none\" : docName));\n\t\tSystem.out.print(\"Meta strings: \");\n\t\tif (metaStr == null) {\n\t\t\tSystem.err.println(\"none\");\n\t\t} else\n\t\t\tfor (int i = 0; i < metaStr.length; i++) {\n\t\t\t\tSystem.err.print(metaStr[i]);\n\t\t\t\tif (i == metaStr.length - 1) {\n\t\t\t\t\tSystem.err.println();\n\t\t\t\t} else {\n\t\t\t\t\tSystem.err.print(\", \");\n\t\t\t\t}\n\t\t\t}\n\t}","id":75787,"modified_method":"public void decompose() {\n\t\tString r = routingKey == null ? \"none\" : HexUtil.bytesToHex(routingKey);\n\t\tString k = cryptoKey == null ? \"none\" : HexUtil.bytesToHex(cryptoKey);\n\t\tString e = extra == null ? \"none\" : HexUtil.bytesToHex(extra);\n\t\tSystem.out.println(\"FreenetURI\" + this);\n\t\tSystem.out.println(\"Key type   : \" + keyType);\n\t\tSystem.out.println(\"Routing key: \" + r);\n\t\tSystem.out.println(\"Crypto key : \" + k);\n\t\tSystem.out.println(\"Extra      : \" + e);\n\t\tSystem.out.println(\n\t\t        \"Doc name   : \" + (docName == null ? \"none\" : docName));\n\t\tSystem.out.print(\"Meta strings: \");\n\t\tif (metaStr == null) {\n\t\t\tSystem.err.println(\"none\");\n\t\t} else\n\t\t\tfor (int i = 0; i < metaStr.length; i++) {\n\t\t\t\tSystem.err.print(metaStr[i]);\n\t\t\t\tif (i == metaStr.length - 1) {\n\t\t\t\t\tSystem.err.println();\n\t\t\t\t} else {\n\t\t\t\t\tSystem.err.print(\", \");\n\t\t\t\t}\n\t\t\t}\n\t}","commit_id":"7339ad9205e6f0fc9da137d073878c6b54833b33","url":"https://github.com/freenet/fred"},{"original_method":"public static NodeUpdater maybeCreate(Node node, Config config) throws NodeInitException {\n        SubConfig updaterConfig = new SubConfig(\"node.updater\", config);\n         \n        updaterConfig.register(\"enabled\", false, 1, false, \"Enable Node's updater?\",\n        \t\t\"Whether to enable the node's updater. It won't auto-update unless node.updater.autoupdate is true, it will just warn\",\n        \t\tnew UpdaterEnabledCallback(node));\n        \n        boolean enabled = updaterConfig.getBoolean(\"enabled\");\n\n        if(enabled) {\n        \t// is the auto-update allowed ?\n        \tupdaterConfig.register(\"autoupdate\", false, 2, false, \"Is the node allowed to auto-update?\", \"Is the node allowed to auto-update?\",\n        \t\t\tnew AutoUpdateAllowedCallback(node));\n        \tboolean autoUpdateAllowed = updaterConfig.getBoolean(\"autoupdate\");\n        \t\n        \tupdaterConfig.register(\"URI\",\n        \t\t\t\"freenet:USK@XC-ntr3FcUblbYWjLkV9ci6BwnXqvIuKKWcWQHDjlFw,YcCSs5lraAMOKx5VMbrvL-28Waf4elHpz~lvVL~hEDk,AQABAAE/update/\"+Version.buildNumber()+\"/\",\n        \t\t\t3, true, \"Where should the node look for updates?\",\n        \t\t\t\"Where should the node look for updates?\",\n        \t\t\tnew UpdateURICallback(node));\n        \t\n        \tString URI = updaterConfig.getString(\"URI\");\n        \t\n        \tupdaterConfig.finishedInitialization();\n        \ttry{\n        \t\treturn new NodeUpdater(node , autoUpdateAllowed, new FreenetURI(URI));\n        \t}catch(Exception e){\n        \t\tLogger.error(node, \"Error starting the NodeUpdater: \"+e);\n        \t\tthrow new NodeInitException(node.EXIT_COULD_NOT_START_UPDATER,\"Unable to start the NodeUpdater up\");\n        \t}\n        } else {\n        \tupdaterConfig.finishedInitialization();\n        \treturn null;\n        }\n\t}","id":75788,"modified_method":"public static NodeUpdater maybeCreate(Node node, Config config) throws NodeInitException {\n        SubConfig updaterConfig = new SubConfig(\"node.updater\", config);\n         \n        updaterConfig.register(\"enabled\", false, 1, false, \"Enable Node's updater?\",\n        \t\t\"Whether to enable the node's updater. It won't auto-update unless node.updater.autoupdate is true, it will just warn\",\n        \t\tnew UpdaterEnabledCallback(node));\n        \n        boolean enabled = updaterConfig.getBoolean(\"enabled\");\n\n        if(enabled) {\n        \t// is the auto-update allowed ?\n        \tupdaterConfig.register(\"autoupdate\", false, 2, false, \"Is the node allowed to auto-update?\", \"Is the node allowed to auto-update?\",\n        \t\t\tnew AutoUpdateAllowedCallback(node));\n        \tboolean autoUpdateAllowed = updaterConfig.getBoolean(\"autoupdate\");\n        \t\n        \tupdaterConfig.register(\"URI\",\n        \t\t\t\"freenet:USK@SIDKS6l-eOU8IQqDo03d~3qqBd-69WG60aDgg4nWqss,CPFqYi95Is3GwzAdAKtAuFMCXDZFFWC3~uPoidCD67s,AQABAAE/update/\"+Version.buildNumber()+\"/\",\n        \t\t\t3, true, \"Where should the node look for updates?\",\n        \t\t\t\"Where should the node look for updates?\",\n        \t\t\tnew UpdateURICallback(node));\n        \t\n        \tString URI = updaterConfig.getString(\"URI\");\n        \t\n        \t\n        \tupdaterConfig.register(\"revocationURI\",\n        \t\t\t\"freenet:SSK@VOfCZVTYPaatJ~eB~4lu2cPrWEmGyt4bfbB1v15Z6qQ,B6EynLhm7QE0se~rMgWWhl7wh3rFWjxJsEUcyohAm8A,AQABAAE/revoked/\",\n        \t\t\t3, true, \"Where should the node look for revocation ?\",\n        \t\t\t\"Where should the node look for revocation ?\",\n        \t\t\tnew UpdaterevocationURICallback(node));\n        \t\n        \tString revURI = updaterConfig.getString(\"revocationURI\");\n        \t\n        \t\n        \tupdaterConfig.finishedInitialization();\n        \ttry{\n        \t\treturn new NodeUpdater(node , autoUpdateAllowed, new FreenetURI(URI), new FreenetURI(revURI));\n        \t}catch(Exception e){\n        \t\tLogger.error(node, \"Error starting the NodeUpdater: \"+e);\n        \t\tthrow new NodeInitException(Node.EXIT_COULD_NOT_START_UPDATER,\"Unable to start the NodeUpdater up\");\n        \t}\n        } else {\n        \tupdaterConfig.finishedInitialization();\n        \treturn null;\n        }\n\t}","commit_id":"7339ad9205e6f0fc9da137d073878c6b54833b33","url":"https://github.com/freenet/fred"},{"original_method":"public void onSuccess(FetchResult result, ClientGetter state) {\n\t}","id":75789,"modified_method":"public synchronized void onSuccess(FetchResult result, ClientGetter state) {\n\t\tthis.cg = state;\n\t\tthis.result = result;\n\t\tUpdate();\n\t}","commit_id":"7339ad9205e6f0fc9da137d073878c6b54833b33","url":"https://github.com/freenet/fred"},{"original_method":"public void onFailure(FetchException e, ClientGetter state) {\n\t}","id":75790,"modified_method":"public synchronized void onFailure(FetchException e, ClientGetter state) {\n\t\tthis.cg = state;\n\t\t\n\t\tcg.cancel();\n\t\tmaybeUpdate();\n\t}","commit_id":"7339ad9205e6f0fc9da137d073878c6b54833b33","url":"https://github.com/freenet/fred"},{"original_method":"public synchronized void onFoundEdition(long l, USK key){\n\t\t// FIXME : Check if it has been blown\n\t\tint found = (int)key.suggestedEdition;\n\t\t\n\t\tif(found > availableVersion){\n\t\t\tthis.availableVersion = found;\n\n\t\t\tLogger.normal(this, \"Found a new version!, setting up a new UpdatedVersionAviableUserAlert\");\n\t\t\talert.set(availableVersion);\n\t\t\talert.isValid(true);\n\n\t\t\tmaybeUpdate();\n\t\t}\n\t}","id":75791,"modified_method":"public synchronized void onFoundEdition(long l, USK key){\n\t\t// FIXME : Check if it has been blown\n\t\tint found = (int)key.suggestedEdition;\n\t\t\n\t\tif(found > availableVersion){\n\t\t\tthis.availableVersion = found;\n\t\t\ttry{\n\t\t\t\tmaybeUpdate();\n\t\t\t}catch (Exception e){\n\t\t\t\t\n\t\t\t}\n\t\t\tSystem.out.println(\"Found \"+availableVersion);\n\t\t\tLogger.normal(this, \"Found a new version!, setting up a new UpdatedVersionAviableUserAlert\");\n\t\t\talert.set(availableVersion);\n\t\t\talert.isValid(true);\t\t\n\t\t\tthis.isRunning=true;\n\t\t}\n\t}","commit_id":"7339ad9205e6f0fc9da137d073878c6b54833b33","url":"https://github.com/freenet/fred"},{"original_method":"public synchronized void maybeUpdate(){\n\t\ttry{\n\t\t\tif(isRunning || !isUpdatable()) return;\n\t\t}catch (PrivkeyHasBeenBlownException e){\n\t\t\t// how to handle it ? a new UserAlert or an imediate exit?\n\t\t\tLogger.error(this, \"Private key has been blown!\");\n\t\t\tnode.exit();\n\t\t}\n\t\t\n\t\t//TODO maybe a UpdateInProgress alert ?\n\t\t\n\t\tif(isAutoUpdateAllowed){\n\t\t\tLogger.normal(this,\"Starting the update process\");\n\t\t}else{\n\t\t\tLogger.normal(this,\"Not starting the update process as it's not allowed\");\n\t\t}\n\t}","id":75792,"modified_method":"public synchronized void maybeUpdate(){\n\t\ttry{\n\t\t\tif(isFetching || !isRunning || !isUpdatable()) return;\n\t\t}catch (PrivkeyHasBeenBlownException e){\n\t\t\t// how to handle it ? a new UserAlert or an imediate exit?\n\t\t\tLogger.error(this, \"The auto-updating Private key has been blown!\");\n\t\t\tnode.exit();\n\t\t}\n\t\t\n\t\tisRunning=false;\n\t\t\n\t\t//TODO maybe a UpdateInProgress alert ?\n\t\tif(isAutoUpdateAllowed){\n\t\t\tLogger.normal(this,\"Starting the update process\");\n//\t\t\tWe fetch it\n\t\t\ttry{\n\t\t\t\tif(cg==null||cg.isCancelled()){\n\t\t\t\t\tcg = new ClientGetter(this, node.chkFetchScheduler, node.sskFetchScheduler, \n\t\t\t\t\t\t\tURI.setSuggestedEdition(availableVersion), ctx, RequestStarter.BULK_SPLITFILE_PRIORITY_CLASS, \n\t\t\t\t\t\t\tthis, new ArrayBucket());\n\t\t\t\t}\n\t\t\t\tcg.start();\n\t\t\t\tisFetching = true;\n\t\t\t}catch (Exception e) {\n\t\t\t\tLogger.error(this, \"Error while starting the fetching\");\n\t\t\t}\n\t\t}else{\n\t\t\tLogger.normal(this,\"Not starting the update process as it's not allowed\");\n\t\t}\n\t}","commit_id":"7339ad9205e6f0fc9da137d073878c6b54833b33","url":"https://github.com/freenet/fred"},{"original_method":"public NodeUpdater(Node n, boolean isAutoUpdateAllowed, FreenetURI URI) {\n\t\tsuper();\n\t\tthis.URI = URI;\n\t\tthis.node = n;\n\t\tthis.currentVersion = Version.buildNumber();\n\t\tthis.availableVersion = currentVersion;\n\t\tthis.hasBeenBlown = false;\n\t\tthis.isRunning = true;\n\t\tthis.isAutoUpdateAllowed = isAutoUpdateAllowed;\n\t\t\n\t\tthis.alert= new UpdatedVersionAvailableUserAlert(currentVersion);\n\t\talert.isValid(false);\n\t\tnode.alerts.register(alert);\n\t\t\n\t\tFetcherContext ctx = n.makeClient((short)0).getFetcherContext();\t\t\n\t\tctx.allowSplitfiles = true;\n\t\tctx.dontEnterImplicitArchives = false;\n\t\tctx.maxArchiveRestarts = 0;\n\t\tctx.maxMetadataSize = 256;\n\t\tctx.maxNonSplitfileRetries = 10;\n\t\tctx.maxOutputLength = 4096;\n\t\tctx.maxRecursionLevel = 2;\n\t\tctx.maxTempLength = 4096;\n\t\tthis.ctx = ctx;\n\t\t\n\t\ttry{\t\t\n\t\t\tUSK myUsk=USK.create(URI);\n\t\t\tctx.uskManager.subscribe(myUsk, this,\ttrue);\n\t\t\tctx.uskManager.startTemporaryBackgroundFetcher(myUsk);\n\t\t}catch(MalformedURLException e){\n\t\t\tLogger.error(this,\"The auto-update URI isn't valid and can't be used\");\n\t\t\tthis.hasBeenBlown=true;\n\t\t\tthis.revocationMessage = new String(\"The auto-update URI isn't valid and can't be used\");\n\t\t}\n\t}","id":75793,"modified_method":"public NodeUpdater(Node n, boolean isAutoUpdateAllowed, FreenetURI URI, FreenetURI revocationURI) {\n\t\tsuper();\n\t\tthis.URI = URI;\n\t\tthis.revocationURI = revocationURI;\n\t\tthis.node = n;\n\t\tthis.currentVersion = Version.buildNumber();\n\t\tthis.availableVersion = currentVersion;\n\t\tthis.hasBeenBlown = false;\n\t\tthis.isRunning = true;\n\t\tthis.isAutoUpdateAllowed = isAutoUpdateAllowed;\n\t\tthis.cg = null;\n\t\tthis.isFetching = false;\n\t\t\n\t\tthis.alert= new UpdatedVersionAvailableUserAlert(currentVersion);\n\t\talert.isValid(false);\n\t\tnode.alerts.register(alert);\n\t\t\n\t\tFetcherContext ctx = n.makeClient((short)0).getFetcherContext();\t\t\n\t\tctx.allowSplitfiles = true;\n\t\tctx.dontEnterImplicitArchives = false;\n\t\tthis.ctx = ctx;\n\t\t\n\t\ttry{\t\t\n\t\t\tUSK myUsk=USK.create(URI);\n\t\t\tctx.uskManager.subscribe(myUsk, this,\ttrue);\n\t\t\tctx.uskManager.startTemporaryBackgroundFetcher(myUsk);\n\t\t}catch(MalformedURLException e){\n\t\t\tLogger.error(this,\"The auto-update URI isn't valid and can't be used\");\n\t\t\tthis.hasBeenBlown=true;\n\t\t\tthis.revocationMessage = new String(\"The auto-update URI isn't valid and can't be used\");\n\t\t}\n\t}","commit_id":"7339ad9205e6f0fc9da137d073878c6b54833b33","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * Process a single command.\n     * @throws IOException If we could not write the data to stdout.\n     */\n    private boolean processLine(BufferedReader reader, OutputStream out) throws IOException {\n        String line;\n        StringBuffer outsb = new StringBuffer();\n        try {\n            line = reader.readLine();\n        } catch (IOException e) {\n            outsb.append(\"Bye... (\"+e+\")\");\n            System.err.println(\"Bye... (\"+e+\")\");\n            return true;\n        }\n        boolean getCHKOnly = false;\n        if(line == null) return true;\n        String uline = line.toUpperCase();\n        Logger.minor(this, \"Command: \"+line);\n        if(uline.startsWith(\"GET:\")) {\n            // Should have a key next\n            String key = line.substring(\"GET:\".length());\n            while(key.length() > 0 && key.charAt(0) == ' ')\n                key = key.substring(1);\n            while(key.length() > 0 && key.charAt(key.length()-1) == ' ')\n                key = key.substring(0, key.length()-2);\n            Logger.normal(this, \"Key: \"+key);\n            FreenetURI uri;\n            try {\n                uri = new FreenetURI(key);\n                Logger.normal(this, \"Key: \"+uri);\n            } catch (MalformedURLException e2) {\n                outsb.append(\"Malformed URI: \"+key+\" : \"+e2);\n                return false;\n            }\n            try {\n\t\t\t\tFetchResult result = client.fetch(uri);\n\t\t\t\tClientMetadata cm = result.getMetadata();\n\t\t\t\toutsb.append(\"Content MIME type: \"+cm.getMIMEType());\n\t\t\t\tBucket data = result.asBucket();\n\t\t\t\t// FIXME limit it above\n\t\t\t\tif(data.size() > 32*1024) {\n\t\t\t\t\tSystem.err.println(\"Data is more than 32K: \"+data.size());\n\t\t\t\t\toutsb.append(\"Data is more than 32K: \"+data.size());\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tbyte[] dataBytes = BucketTools.toByteArray(data);\n\t\t\t\tboolean evil = false;\n\t\t\t\tfor(int i=0;i<dataBytes.length;i++) {\n\t\t\t\t\t// Look for escape codes\n\t\t\t\t\tif(dataBytes[i] == '\\n') continue;\n\t\t\t\t\tif(dataBytes[i] == '\\r') continue;\n\t\t\t\t\tif(dataBytes[i] < 32) evil = true;\n\t\t\t\t}\n\t\t\t\tif(evil) {\n\t\t\t\t\tSystem.err.println(\"Data may contain escape codes which could cause the terminal to run arbitrary commands! Save it to a file if you must with GETFILE:\");\n\t\t\t\t\toutsb.append(\"Data may contain escape codes which could cause the terminal to run arbitrary commands! Save it to a file if you must with GETFILE:\");\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\toutsb.append(\"Data:\\r\\n\");\n\t\t\t\toutsb.append(new String(dataBytes));\n\t\t\t} catch (FetchException e) {\n\t\t\t\toutsb.append(\"Error: \"+e.getMessage()+\"\\r\\n\");\n            \tif(e.getMode() == e.SPLITFILE_ERROR && e.errorCodes != null) {\n            \t\toutsb.append(e.errorCodes.toVerboseString());\n            \t}\n            \tif(e.newURI != null)\n            \t\toutsb.append(\"Permanent redirect: \"+e.newURI+\"\\r\\n\");\n\t\t\t}\n        } else if(uline.startsWith(\"GETFILE:\")) {\n            // Should have a key next\n            String key = line.substring(\"GETFILE:\".length());\n            while(key.length() > 0 && key.charAt(0) == ' ')\n                key = key.substring(1);\n            while(key.length() > 0 && key.charAt(key.length()-1) == ' ')\n                key = key.substring(0, key.length()-2);\n            Logger.normal(this, \"Key: \"+key);\n            FreenetURI uri;\n            try {\n                uri = new FreenetURI(key);\n            } catch (MalformedURLException e2) {\n                outsb.append(\"Malformed URI: \"+key+\" : \"+e2);\n                return false;\n            }\n            try {\n            \tlong startTime = System.currentTimeMillis();\n\t\t\t\tFetchResult result = client.fetch(uri);\n\t\t\t\tClientMetadata cm = result.getMetadata();\n\t\t\t\toutsb.append(\"Content MIME type: \"+cm.getMIMEType());\n\t\t\t\tBucket data = result.asBucket();\n                // Now calculate filename\n                String fnam = uri.getDocName();\n                fnam = sanitize(fnam);\n                if(fnam.length() == 0) {\n                    fnam = \"freenet-download-\"+HexUtil.bytesToHex(BucketTools.hash(data), 0, 10);\n                    String ext = DefaultMIMETypes.getExtension(cm.getMIMEType());\n                    if(ext != null && !ext.equals(\"\"))\n                    \tfnam += \".\" + ext;\n                }\n                File f = new File(downloadsDir, fnam);\n                if(f.exists()) {\n                    outsb.append(\"File exists already: \"+fnam);\n                    fnam = \"freenet-\"+System.currentTimeMillis()+\"-\"+fnam;\n                }\n                FileOutputStream fos = null;\n                try {\n                    fos = new FileOutputStream(f);\n                    BucketTools.copyTo(data, fos, Long.MAX_VALUE);\n                    fos.close();\n                    outsb.append(\"Written to \"+fnam);\n                } catch (IOException e) {\n                    outsb.append(\"Could not write file: caught \"+e);\n                    e.printStackTrace();\n                } finally {\n                    if(fos != null) try {\n                        fos.close();\n                    } catch (IOException e1) {\n                        // Ignore\n                    }\n                }\n                long endTime = System.currentTimeMillis();\n                long sz = data.size();\n                double rate = 1000.0 * sz / (endTime-startTime);\n                outsb.append(\"Download rate: \"+rate+\" bytes / second\");\n\t\t\t} catch (FetchException e) {\n\t\t\t\toutsb.append(\"Error: \"+e.getMessage());\n            \tif(e.getMode() == e.SPLITFILE_ERROR && e.errorCodes != null) {\n            \t\toutsb.append(e.errorCodes.toVerboseString());\n            \t}\n            \tif(e.newURI != null)\n            \t\toutsb.append(\"Permanent redirect: \"+e.newURI+\"\\r\\n\");\n\t\t\t}\n\t} else if(uline.startsWith(\"SHUTDOWN\")) {\n\t\tStringBuffer sb = new StringBuffer();\n\t\tsb.append(\"Shutting node down.\\r\\n\");\n\t\tout.write(sb.toString().getBytes());\n\t\tout.flush();\n\t\tn.exit();\n\t} else if(uline.startsWith(\"RESTART\")) {\n\t\tStringBuffer sb = new StringBuffer();\n\t\tsb.append(\"Restarting the node.\\r\\n\");\n\t\tout.write(sb.toString().getBytes());\n\t\tout.flush();\n\t\tn.getNodeStarter().restart();\n\t} else if(uline.startsWith(\"QUIT\") && n.directTMCI == this) {\n\t\tStringBuffer sb = new StringBuffer();\n\t\tsb.append(\"QUIT command not available in console mode.\\r\\n\");\n\t\tout.write(sb.toString().getBytes());\n\t\tout.flush();\n\t\treturn false;\n        } else if(uline.startsWith(\"QUIT\")) {\n\t\tStringBuffer sb = new StringBuffer();\n\t\tsb.append(\"Closing connection.\\r\\n\");\n\t\tout.write(sb.toString().getBytes());\n\t\tout.flush();\n\t\treturn true;\n\t} else if(uline.startsWith(\"HELP\")) {\n\t\tprintHeader(out);\n\t\treturn false;\n        } else if(uline.startsWith(\"PUT:\") || (getCHKOnly = uline.startsWith(\"GETCHK:\"))) {\n            // Just insert to local store\n        \tif(getCHKOnly)\n        \t\tline = line.substring((\"GETCHK:\").length());\n        \telse\n        \t\tline = line.substring(\"PUT:\".length());\n            while(line.length() > 0 && line.charAt(0) == ' ')\n                line = line.substring(1);\n            while(line.length() > 0 && line.charAt(line.length()-1) == ' ')\n                line = line.substring(0, line.length()-2);\n            String content;\n            if(line.length() > 0) {\n                // Single line insert\n                content = line;\n            } else {\n                // Multiple line insert\n                content = readLines(reader, false);\n            }\n            // Insert\n            byte[] data = content.getBytes();\n            \n            InsertBlock block = new InsertBlock(new ArrayBucket(data), null, FreenetURI.EMPTY_CHK_URI);\n\n            FreenetURI uri;\n            try {\n            \turi = client.insert(block, getCHKOnly);\n            } catch (InserterException e) {\n            \toutsb.append(\"Error: \"+e.getMessage());\n            \tif(e.uri != null)\n            \t\toutsb.append(\"URI would have been: \"+e.uri);\n            \tint mode = e.getMode();\n            \tif(mode == InserterException.FATAL_ERRORS_IN_BLOCKS || mode == InserterException.TOO_MANY_RETRIES_IN_BLOCKS) {\n            \t\toutsb.append(\"Splitfile-specific error:\\n\"+e.errorCodes.toVerboseString());\n            \t}\n            \treturn false;\n            }\n            \n            outsb.append(\"URI: \"+uri);\n            ////////////////////////////////////////////////////////////////////////////////\n        } else if(uline.startsWith(\"PUTDIR:\") || (uline.startsWith(\"PUTSSKDIR\")) || (getCHKOnly = uline.startsWith(\"GETCHKDIR:\"))) {\n        \t// TODO: Check for errors?\n        \tboolean ssk = false;\n        \tif(uline.startsWith(\"PUTDIR:\"))\n        \t\tline = line.substring(\"PUTDIR:\".length());\n        \telse if(uline.startsWith(\"PUTSSKDIR:\")) {\n        \t\tline = line.substring(\"PUTSSKDIR:\".length());\n        \t\tssk = true;\n        \t} else if(uline.startsWith(\"GETCHKDIR:\"))\n        \t\tline = line.substring((\"GETCHKDIR:\").length());\n        \telse {\n        \t\tSystem.err.println(\"Impossible\");\n        \t\toutsb.append(\"Impossible\");\n        \t}\n        \t\n        \tline = line.trim();\n        \t\n        \tif(line.length() < 1) {\n        \t\tprintHeader(out);\n        \t\treturn false;\n        \t}\n        \t\n        \tString defaultFile = null;\n        \t\n        \tFreenetURI insertURI = FreenetURI.EMPTY_CHK_URI;\n        \t\n        \t// set default file?\n        \tif (line.matches(\"^.*#.*$\")) {\n        \t\tString[] split = line.split(\"#\");\n        \t\tif(ssk) {\n        \t\t\tinsertURI = new FreenetURI(split[0]);\n        \t\t\tline = split[1];\n        \t\t\tif(split.length > 2)\n        \t\t\t\tdefaultFile = split[2];\n        \t\t} else {\n        \t\t\tdefaultFile = split[1];\n        \t\t\tline = split[0];\n        \t\t}\n        \t}\n        \t\n        \tHashMap bucketsByName =\n        \t\tmakeBucketsByName(line);\n        \t\n        \tif(defaultFile == null) {\n        \t\tString[] defaultFiles = \n        \t\t\tnew String[] { \"index.html\", \"index.htm\", \"default.html\", \"default.htm\" };\n        \t\tfor(int i=0;i<defaultFiles.length;i++) {\n        \t\t\tif(bucketsByName.containsKey(defaultFiles[i])) {\n        \t\t\t\tdefaultFile = defaultFiles[i];\n        \t\t\t\tbreak;\n        \t\t\t}        \t\t\t\t\n        \t\t}\n        \t}\n        \t\n        \tFreenetURI uri;\n\t\t\ttry {\n\t\t\t\turi = client.insertManifest(insertURI, bucketsByName, defaultFile);\n\t\t\t\turi = uri.addMetaStrings(new String[] { \"\" });\n\t        \toutsb.append(\"=======================================================\");\n\t            outsb.append(\"URI: \"+uri);\n\t        \toutsb.append(\"=======================================================\");\n\t\t\t} catch (InserterException e) {\n            \toutsb.append(\"Finished insert but: \"+e.getMessage());\n            \tif(e.uri != null) {\n            \t\turi = e.uri;\n    \t\t\t\turi = uri.addMetaStrings(new String[] { \"\" });\n            \t\toutsb.append(\"URI would have been: \"+uri);\n            \t}\n            \tif(e.errorCodes != null) {\n            \t\toutsb.append(\"Splitfile errors breakdown:\");\n            \t\toutsb.append(e.errorCodes.toVerboseString());\n            \t}\n            \tLogger.error(this, \"Caught \"+e, e);\n\t\t\t}\n            \n        } else if(uline.startsWith(\"PUTFILE:\") || (getCHKOnly = uline.startsWith(\"GETCHKFILE:\"))) {\n            // Just insert to local store\n        \tif(getCHKOnly) {\n        \t\tline = line.substring((\"GETCHKFILE:\").length());\n        \t} else {\n        \t\tline = line.substring(\"PUTFILE:\".length());\n        \t}\n            while(line.length() > 0 && line.charAt(0) == ' ')\n                line = line.substring(1);\n            while(line.length() > 0 && line.charAt(line.length()-1) == ' ')\n                line = line.substring(0, line.length()-2);\n            String mimeType = DefaultMIMETypes.guessMIMEType(line);\n            if (line.indexOf('#') > -1) {\n            \tString[] splittedLine = line.split(\"#\");\n            \tline = splittedLine[0];\n            \tmimeType = splittedLine[1];\n            }\n            File f = new File(line);\n            outsb.append(\"Attempting to read file \"+line);\n            long startTime = System.currentTimeMillis();\n            try {\n            \tif(!(f.exists() && f.canRead())) {\n            \t\tthrow new FileNotFoundException();\n            \t}\n            \t\n            \t// Guess MIME type\n            \toutsb.append(\"Using MIME type: \"+mimeType + \"\\r\\n\");\n            \tif(mimeType.equals(DefaultMIMETypes.DEFAULT_MIME_TYPE))\n            \t\tmimeType = \"\"; // don't need to override it\n            \t\n            \tFileBucket fb = new FileBucket(f, true, false, false, false);\n            \tInsertBlock block = new InsertBlock(fb, new ClientMetadata(mimeType), FreenetURI.EMPTY_CHK_URI);\n\n            \tstartTime = System.currentTimeMillis();\n            \tFreenetURI uri = client.insert(block, getCHKOnly);\n            \t\n            \t// FIXME depends on CHK's still being renamable\n                //uri = uri.setDocName(f.getName());\n            \t\n                outsb.append(\"URI: \"+uri+\"\\r\\n\");\n            \tlong endTime = System.currentTimeMillis();\n                long sz = f.length();\n                double rate = 1000.0 * sz / (endTime-startTime);\n                outsb.append(\"Upload rate: \"+rate+\" bytes / second\\r\\n\");\n            } catch (FileNotFoundException e1) {\n                outsb.append(\"File not found\");\n            } catch (InserterException e) {\n            \toutsb.append(\"Finished insert but: \"+e.getMessage());\n            \tif(e.uri != null) {\n            \t\toutsb.append(\"URI would have been: \"+e.uri);\n                \tlong endTime = System.currentTimeMillis();\n                    long sz = f.length();\n                    double rate = 1000.0 * sz / (endTime-startTime);\n                    outsb.append(\"Upload rate: \"+rate+\" bytes / second\");\n            \t}\n            \tif(e.errorCodes != null) {\n            \t\toutsb.append(\"Splitfile errors breakdown:\");\n            \t\toutsb.append(e.errorCodes.toVerboseString());\n            \t}\n            } catch (Throwable t) {\n                outsb.append(\"Insert threw: \"+t);\n                t.printStackTrace();\n            }\n        } else if(uline.startsWith(\"MAKESSK\")) {\n        \tInsertableClientSSK key = InsertableClientSSK.createRandom(r, \"\");\n        \toutsb.append(\"Insert URI: \"+key.getInsertURI().toString(false)+\"\\r\\n\");\n        \toutsb.append(\"Request URI: \"+key.getURI().toString(false)+\"\\r\\n\");\n        \tFreenetURI insertURI = key.getInsertURI().setDocName(\"testsite\");\n        \tString fixedInsertURI = insertURI.toString(false);\n        \toutsb.append(\"Note that you MUST add a filename to the end of the above URLs e.g.:\\r\\n\"+fixedInsertURI+\"\\r\\n\");\n        \toutsb.append(\"Normally you will then do PUTSSKDIR:<insert URI>#<directory to upload>, for example:\\r\\nPUTSSKDIR:\"+fixedInsertURI+\"#directoryToUpload/\"+\"\\r\\n\");\n        \toutsb.append(\"This will then produce a manifest site containing all the files, the default document can be accessed at\\r\\n\"+key.getURI().toString(false)+\"testsite/\");\n        } else if(uline.startsWith(\"PUTSSK:\")) {\n        \tString cmd = line.substring(\"PUTSSK:\".length());\n        \tcmd = cmd.trim();\n        \tif(cmd.indexOf(';') <= 0) {\n        \t\toutsb.append(\"No target URI provided.\");\n        \t\toutsb.append(\"PUTSSK:<insert uri>;<url to redirect to>\");\n        \t\treturn false;\n        \t}\n        \tString[] split = cmd.split(\";\");\n        \tString insertURI = split[0];\n        \tString targetURI = split[1];\n        \toutsb.append(\"Insert URI: \"+insertURI);\n        \toutsb.append(\"Target URI: \"+targetURI);\n        \tFreenetURI insert = new FreenetURI(insertURI);\n        \tFreenetURI target = new FreenetURI(targetURI);\n        \ttry {\n\t\t\t\tFreenetURI result = client.insertRedirect(insert, target);\n\t\t\t\toutsb.append(\"Successfully inserted to fetch URI: \"+result);\n\t\t\t} catch (InserterException e) {\n            \toutsb.append(\"Finished insert but: \"+e.getMessage());\n            \tLogger.normal(this, \"Error: \"+e, e);\n            \tif(e.uri != null) {\n            \t\toutsb.append(\"URI would have been: \"+e.uri);\n            \t}\n\t\t\t}\n        \t\n        } else if(uline.startsWith(\"STATUS\")) {\n            SimpleFieldSet fs = n.exportPublicFieldSet();\n            outsb.append(fs.toString());\n            outsb.append(n.getStatus());\n\t    if(Version.buildNumber()<Version.highestSeenBuild){\n\t            outsb.append(\"The latest version is : \"+Version.highestSeenBuild);\n\t    }\n        } else if(uline.startsWith(\"CONNECT:\")) {\n            String key = line.substring(\"CONNECT:\".length());\n            while(key.length() > 0 && key.charAt(0) == ' ')\n                key = key.substring(1);\n            while(key.length() > 0 && key.charAt(key.length()-1) == ' ')\n                key = key.substring(0, key.length()-2);\n            \n            String content = null;\n            if(key.length() > 0) {\n                // Filename\n            \tBufferedReader in;\n                outsb.append(\"Trying to connect to noderef in \"+key);\n                File f = new File(key);\n                if (f.isFile()) {\n                \toutsb.append(\"Given string seems to be a file, loading...\");\n                \tin = new BufferedReader(new FileReader(f));\n                } else {\n                \toutsb.append(\"Given string seems to be an URL, loading...\");\n                    URL url = new URL(key);\n                    URLConnection uc = url.openConnection();\n                \tin = new BufferedReader(\n                \t\t\tnew InputStreamReader(uc.getInputStream()));\n                }\n                content = readLines(in, true);\n                in.close();\n            } else {\n                content = readLines(reader, true);\n            }\n            if(content == null) return false;\n            if(content.equals(\"\")) return false;\n            connect(content);\n        \n        } else if(uline.startsWith(\"NAME:\")) {\n            outsb.append(\"Node name currently: \"+n.myName);\n            String key = line.substring(\"NAME:\".length());\n            while(key.length() > 0 && key.charAt(0) == ' ')\n                key = key.substring(1);\n            while(key.length() > 0 && key.charAt(key.length()-1) == ' ')\n                key = key.substring(0, key.length()-2);\n            outsb.append(\"New name: \"+key);\n            \n            try{\n            \tn.config.get(\"node\").getOption(\"name\").setValue(key);\n            \tLogger.minor(this, \"Setting node.name to \"+key);\n\t\t\t}catch(Exception e){\n\t\t\t\tLogger.error(this, \"Error setting node's name\");\n    \t\t}\n    \t\tn.config.store();\n        } else if(uline.startsWith(\"DISCONNECT:\")) {\n        \tString ipAndPort = line.substring(\"DISCONNECT:\".length());\n        \tdisconnect(ipAndPort.trim());\n        \t\n        } else if(uline.startsWith(\"PLUGLOAD:\")) {\n        \tif (line.substring(\"PLUGLOAD:\".length()).trim().equals(\"?\")) {\n        \t\toutsb.append(\"  PLUGLOAD: pkg.Class                  - Load plugin from current classpath\");        \t\t\n        \t\toutsb.append(\"  PLUGLOAD: pkg.Class@file:<filename>  - Load plugin from file\");\n        \t\toutsb.append(\"  PLUGLOAD: pkg.Class@http://...       - Load plugin from online file\");\n        \t\toutsb.append(\"  PLUGLOAD:         *@...              - Load plugin from manifest in given jarfile\");\n        \t\toutsb.append(\"\");\n        \t\toutsb.append(\"If the filename/url ends with \\\".url\\\", it\" +\n        \t\t\t\t\" is treated as a link, meaning that the first line is\" +\n        \t\t\t\t\" the accual URL. Else it is loaded as classpath and\" +\n        \t\t\t\t\" the class it loaded from it (meaning the file could\" +\n        \t\t\t\t\" be either a jar-file or a class-file).\");\n        \t\toutsb.append(\"\");\n        \t\toutsb.append(\"  PLUGLOAD: pkg.Class*  - Load newest version of plugin from http://downloads.freenetproject.org/alpha/plugins/\");        \t\t\n        \t\toutsb.append(\"\");\n        \t\t\n        \t} else\n        \t\tn.pluginManager.startPlugin(line.substring(\"PLUGLOAD:\".length()).trim());\n            //outsb.append(\"PLUGLOAD: <pkg.classname>[(@<URI to jarfile.jar>|<<URI to file containing real URI>|* (will load from freenets pluginpool))] - Load plugin.\");\n        } else if(uline.startsWith(\"PLUGLIST\")) {\n        \toutsb.append(n.pluginManager.dumpPlugins());\n        } else if(uline.startsWith(\"PLUGKILL:\")) {\n        \tn.pluginManager.killPlugin(line.substring(\"PLUGKILL:\".length()).trim());\n        } else {\n        \tif(uline.length() > 0)\n        \t\tprintHeader(out);\n        }\n        outsb.append(\"\\r\\n\");\n        out.write(outsb.toString().getBytes());\n        out.flush();\n        return false;\n    }","id":75794,"modified_method":"/**\n     * Process a single command.\n     * @throws IOException If we could not write the data to stdout.\n     */\n    private boolean processLine(BufferedReader reader, OutputStream out) throws IOException {\n        String line;\n        StringBuffer outsb = new StringBuffer();\n        try {\n            line = reader.readLine();\n        } catch (IOException e) {\n            outsb.append(\"Bye... (\"+e+\")\");\n            System.err.println(\"Bye... (\"+e+\")\");\n            return true;\n        }\n        boolean getCHKOnly = false;\n        if(line == null) return true;\n        String uline = line.toUpperCase();\n        Logger.minor(this, \"Command: \"+line);\n        if(uline.startsWith(\"GET:\")) {\n            // Should have a key next\n            String key = line.substring(\"GET:\".length());\n            while(key.length() > 0 && key.charAt(0) == ' ')\n                key = key.substring(1);\n            while(key.length() > 0 && key.charAt(key.length()-1) == ' ')\n                key = key.substring(0, key.length()-2);\n            Logger.normal(this, \"Key: \"+key);\n            FreenetURI uri;\n            try {\n                uri = new FreenetURI(key);\n                Logger.normal(this, \"Key: \"+uri);\n            } catch (MalformedURLException e2) {\n                outsb.append(\"Malformed URI: \"+key+\" : \"+e2);\n                return false;\n            }\n            try {\n\t\t\t\tFetchResult result = client.fetch(uri);\n\t\t\t\tClientMetadata cm = result.getMetadata();\n\t\t\t\toutsb.append(\"Content MIME type: \"+cm.getMIMEType());\n\t\t\t\tBucket data = result.asBucket();\n\t\t\t\t// FIXME limit it above\n\t\t\t\tif(data.size() > 32*1024) {\n\t\t\t\t\tSystem.err.println(\"Data is more than 32K: \"+data.size());\n\t\t\t\t\toutsb.append(\"Data is more than 32K: \"+data.size());\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tbyte[] dataBytes = BucketTools.toByteArray(data);\n\t\t\t\tboolean evil = false;\n\t\t\t\tfor(int i=0;i<dataBytes.length;i++) {\n\t\t\t\t\t// Look for escape codes\n\t\t\t\t\tif(dataBytes[i] == '\\n') continue;\n\t\t\t\t\tif(dataBytes[i] == '\\r') continue;\n\t\t\t\t\tif(dataBytes[i] < 32) evil = true;\n\t\t\t\t}\n\t\t\t\tif(evil) {\n\t\t\t\t\tSystem.err.println(\"Data may contain escape codes which could cause the terminal to run arbitrary commands! Save it to a file if you must with GETFILE:\");\n\t\t\t\t\toutsb.append(\"Data may contain escape codes which could cause the terminal to run arbitrary commands! Save it to a file if you must with GETFILE:\");\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\toutsb.append(\"Data:\\r\\n\");\n\t\t\t\toutsb.append(new String(dataBytes));\n\t\t\t} catch (FetchException e) {\n\t\t\t\toutsb.append(\"Error: \"+e.getMessage()+\"\\r\\n\");\n            \tif(e.getMode() == e.SPLITFILE_ERROR && e.errorCodes != null) {\n            \t\toutsb.append(e.errorCodes.toVerboseString());\n            \t}\n            \tif(e.newURI != null)\n            \t\toutsb.append(\"Permanent redirect: \"+e.newURI+\"\\r\\n\");\n\t\t\t}\n        } else if(uline.startsWith(\"GETFILE:\")) {\n            // Should have a key next\n            String key = line.substring(\"GETFILE:\".length());\n            while(key.length() > 0 && key.charAt(0) == ' ')\n                key = key.substring(1);\n            while(key.length() > 0 && key.charAt(key.length()-1) == ' ')\n                key = key.substring(0, key.length()-2);\n            Logger.normal(this, \"Key: \"+key);\n            FreenetURI uri;\n            try {\n                uri = new FreenetURI(key);\n            } catch (MalformedURLException e2) {\n                outsb.append(\"Malformed URI: \"+key+\" : \"+e2);\n                return false;\n            }\n            try {\n            \tlong startTime = System.currentTimeMillis();\n\t\t\t\tFetchResult result = client.fetch(uri);\n\t\t\t\tClientMetadata cm = result.getMetadata();\n\t\t\t\toutsb.append(\"Content MIME type: \"+cm.getMIMEType());\n\t\t\t\tBucket data = result.asBucket();\n                // Now calculate filename\n                String fnam = uri.getDocName();\n                fnam = sanitize(fnam);\n                if(fnam.length() == 0) {\n                    fnam = \"freenet-download-\"+HexUtil.bytesToHex(BucketTools.hash(data), 0, 10);\n                    String ext = DefaultMIMETypes.getExtension(cm.getMIMEType());\n                    if(ext != null && !ext.equals(\"\"))\n                    \tfnam += \".\" + ext;\n                }\n                File f = new File(downloadsDir, fnam);\n                if(f.exists()) {\n                    outsb.append(\"File exists already: \"+fnam);\n                    fnam = \"freenet-\"+System.currentTimeMillis()+\"-\"+fnam;\n                }\n                FileOutputStream fos = null;\n                try {\n                    fos = new FileOutputStream(f);\n                    BucketTools.copyTo(data, fos, Long.MAX_VALUE);\n                    fos.close();\n                    outsb.append(\"Written to \"+fnam);\n                } catch (IOException e) {\n                    outsb.append(\"Could not write file: caught \"+e);\n                    e.printStackTrace();\n                } finally {\n                    if(fos != null) try {\n                        fos.close();\n                    } catch (IOException e1) {\n                        // Ignore\n                    }\n                }\n                long endTime = System.currentTimeMillis();\n                long sz = data.size();\n                double rate = 1000.0 * sz / (endTime-startTime);\n                outsb.append(\"Download rate: \"+rate+\" bytes / second\");\n\t\t\t} catch (FetchException e) {\n\t\t\t\toutsb.append(\"Error: \"+e.getMessage());\n            \tif(e.getMode() == e.SPLITFILE_ERROR && e.errorCodes != null) {\n            \t\toutsb.append(e.errorCodes.toVerboseString());\n            \t}\n            \tif(e.newURI != null)\n            \t\toutsb.append(\"Permanent redirect: \"+e.newURI+\"\\r\\n\");\n\t\t\t}\n    } else if(uline.startsWith(\"UPDATE\")) {\n    \t\tn.getNodeUpdater().Update();\n    \t\treturn false;\n\t} else if(uline.startsWith(\"SHUTDOWN\")) {\n\t\tStringBuffer sb = new StringBuffer();\n\t\tsb.append(\"Shutting node down.\\r\\n\");\n\t\tout.write(sb.toString().getBytes());\n\t\tout.flush();\n\t\tn.exit();\n\t} else if(uline.startsWith(\"RESTART\")) {\n\t\tStringBuffer sb = new StringBuffer();\n\t\tsb.append(\"Restarting the node.\\r\\n\");\n\t\tout.write(sb.toString().getBytes());\n\t\tout.flush();\n\t\tn.getNodeStarter().restart();\n\t} else if(uline.startsWith(\"QUIT\") && n.directTMCI == this) {\n\t\tStringBuffer sb = new StringBuffer();\n\t\tsb.append(\"QUIT command not available in console mode.\\r\\n\");\n\t\tout.write(sb.toString().getBytes());\n\t\tout.flush();\n\t\treturn false;\n        } else if(uline.startsWith(\"QUIT\")) {\n\t\tStringBuffer sb = new StringBuffer();\n\t\tsb.append(\"Closing connection.\\r\\n\");\n\t\tout.write(sb.toString().getBytes());\n\t\tout.flush();\n\t\treturn true;\n\t} else if(uline.startsWith(\"HELP\")) {\n\t\tprintHeader(out);\n\t\treturn false;\n        } else if(uline.startsWith(\"PUT:\") || (getCHKOnly = uline.startsWith(\"GETCHK:\"))) {\n            // Just insert to local store\n        \tif(getCHKOnly)\n        \t\tline = line.substring((\"GETCHK:\").length());\n        \telse\n        \t\tline = line.substring(\"PUT:\".length());\n            while(line.length() > 0 && line.charAt(0) == ' ')\n                line = line.substring(1);\n            while(line.length() > 0 && line.charAt(line.length()-1) == ' ')\n                line = line.substring(0, line.length()-2);\n            String content;\n            if(line.length() > 0) {\n                // Single line insert\n                content = line;\n            } else {\n                // Multiple line insert\n                content = readLines(reader, false);\n            }\n            // Insert\n            byte[] data = content.getBytes();\n            \n            InsertBlock block = new InsertBlock(new ArrayBucket(data), null, FreenetURI.EMPTY_CHK_URI);\n\n            FreenetURI uri;\n            try {\n            \turi = client.insert(block, getCHKOnly);\n            } catch (InserterException e) {\n            \toutsb.append(\"Error: \"+e.getMessage());\n            \tif(e.uri != null)\n            \t\toutsb.append(\"URI would have been: \"+e.uri);\n            \tint mode = e.getMode();\n            \tif(mode == InserterException.FATAL_ERRORS_IN_BLOCKS || mode == InserterException.TOO_MANY_RETRIES_IN_BLOCKS) {\n            \t\toutsb.append(\"Splitfile-specific error:\\n\"+e.errorCodes.toVerboseString());\n            \t}\n            \treturn false;\n            }\n            \n            outsb.append(\"URI: \"+uri);\n            ////////////////////////////////////////////////////////////////////////////////\n        } else if(uline.startsWith(\"PUTDIR:\") || (uline.startsWith(\"PUTSSKDIR\")) || (getCHKOnly = uline.startsWith(\"GETCHKDIR:\"))) {\n        \t// TODO: Check for errors?\n        \tboolean ssk = false;\n        \tif(uline.startsWith(\"PUTDIR:\"))\n        \t\tline = line.substring(\"PUTDIR:\".length());\n        \telse if(uline.startsWith(\"PUTSSKDIR:\")) {\n        \t\tline = line.substring(\"PUTSSKDIR:\".length());\n        \t\tssk = true;\n        \t} else if(uline.startsWith(\"GETCHKDIR:\"))\n        \t\tline = line.substring((\"GETCHKDIR:\").length());\n        \telse {\n        \t\tSystem.err.println(\"Impossible\");\n        \t\toutsb.append(\"Impossible\");\n        \t}\n        \t\n        \tline = line.trim();\n        \t\n        \tif(line.length() < 1) {\n        \t\tprintHeader(out);\n        \t\treturn false;\n        \t}\n        \t\n        \tString defaultFile = null;\n        \t\n        \tFreenetURI insertURI = FreenetURI.EMPTY_CHK_URI;\n        \t\n        \t// set default file?\n        \tif (line.matches(\"^.*#.*$\")) {\n        \t\tString[] split = line.split(\"#\");\n        \t\tif(ssk) {\n        \t\t\tinsertURI = new FreenetURI(split[0]);\n        \t\t\tline = split[1];\n        \t\t\tif(split.length > 2)\n        \t\t\t\tdefaultFile = split[2];\n        \t\t} else {\n        \t\t\tdefaultFile = split[1];\n        \t\t\tline = split[0];\n        \t\t}\n        \t}\n        \t\n        \tHashMap bucketsByName =\n        \t\tmakeBucketsByName(line);\n        \t\n        \tif(defaultFile == null) {\n        \t\tString[] defaultFiles = \n        \t\t\tnew String[] { \"index.html\", \"index.htm\", \"default.html\", \"default.htm\" };\n        \t\tfor(int i=0;i<defaultFiles.length;i++) {\n        \t\t\tif(bucketsByName.containsKey(defaultFiles[i])) {\n        \t\t\t\tdefaultFile = defaultFiles[i];\n        \t\t\t\tbreak;\n        \t\t\t}        \t\t\t\t\n        \t\t}\n        \t}\n        \t\n        \tFreenetURI uri;\n\t\t\ttry {\n\t\t\t\turi = client.insertManifest(insertURI, bucketsByName, defaultFile);\n\t\t\t\turi = uri.addMetaStrings(new String[] { \"\" });\n\t        \toutsb.append(\"=======================================================\");\n\t            outsb.append(\"URI: \"+uri);\n\t        \toutsb.append(\"=======================================================\");\n\t\t\t} catch (InserterException e) {\n            \toutsb.append(\"Finished insert but: \"+e.getMessage());\n            \tif(e.uri != null) {\n            \t\turi = e.uri;\n    \t\t\t\turi = uri.addMetaStrings(new String[] { \"\" });\n            \t\toutsb.append(\"URI would have been: \"+uri);\n            \t}\n            \tif(e.errorCodes != null) {\n            \t\toutsb.append(\"Splitfile errors breakdown:\");\n            \t\toutsb.append(e.errorCodes.toVerboseString());\n            \t}\n            \tLogger.error(this, \"Caught \"+e, e);\n\t\t\t}\n            \n        } else if(uline.startsWith(\"PUTFILE:\") || (getCHKOnly = uline.startsWith(\"GETCHKFILE:\"))) {\n            // Just insert to local store\n        \tif(getCHKOnly) {\n        \t\tline = line.substring((\"GETCHKFILE:\").length());\n        \t} else {\n        \t\tline = line.substring(\"PUTFILE:\".length());\n        \t}\n            while(line.length() > 0 && line.charAt(0) == ' ')\n                line = line.substring(1);\n            while(line.length() > 0 && line.charAt(line.length()-1) == ' ')\n                line = line.substring(0, line.length()-2);\n            String mimeType = DefaultMIMETypes.guessMIMEType(line);\n            if (line.indexOf('#') > -1) {\n            \tString[] splittedLine = line.split(\"#\");\n            \tline = splittedLine[0];\n            \tmimeType = splittedLine[1];\n            }\n            File f = new File(line);\n            outsb.append(\"Attempting to read file \"+line);\n            long startTime = System.currentTimeMillis();\n            try {\n            \tif(!(f.exists() && f.canRead())) {\n            \t\tthrow new FileNotFoundException();\n            \t}\n            \t\n            \t// Guess MIME type\n            \toutsb.append(\"Using MIME type: \"+mimeType + \"\\r\\n\");\n            \tif(mimeType.equals(DefaultMIMETypes.DEFAULT_MIME_TYPE))\n            \t\tmimeType = \"\"; // don't need to override it\n            \t\n            \tFileBucket fb = new FileBucket(f, true, false, false, false);\n            \tInsertBlock block = new InsertBlock(fb, new ClientMetadata(mimeType), FreenetURI.EMPTY_CHK_URI);\n\n            \tstartTime = System.currentTimeMillis();\n            \tFreenetURI uri = client.insert(block, getCHKOnly);\n            \t\n            \t// FIXME depends on CHK's still being renamable\n                //uri = uri.setDocName(f.getName());\n            \t\n                outsb.append(\"URI: \"+uri+\"\\r\\n\");\n            \tlong endTime = System.currentTimeMillis();\n                long sz = f.length();\n                double rate = 1000.0 * sz / (endTime-startTime);\n                outsb.append(\"Upload rate: \"+rate+\" bytes / second\\r\\n\");\n            } catch (FileNotFoundException e1) {\n                outsb.append(\"File not found\");\n            } catch (InserterException e) {\n            \toutsb.append(\"Finished insert but: \"+e.getMessage());\n            \tif(e.uri != null) {\n            \t\toutsb.append(\"URI would have been: \"+e.uri);\n                \tlong endTime = System.currentTimeMillis();\n                    long sz = f.length();\n                    double rate = 1000.0 * sz / (endTime-startTime);\n                    outsb.append(\"Upload rate: \"+rate+\" bytes / second\");\n            \t}\n            \tif(e.errorCodes != null) {\n            \t\toutsb.append(\"Splitfile errors breakdown:\");\n            \t\toutsb.append(e.errorCodes.toVerboseString());\n            \t}\n            } catch (Throwable t) {\n                outsb.append(\"Insert threw: \"+t);\n                t.printStackTrace();\n            }\n        } else if(uline.startsWith(\"MAKESSK\")) {\n        \tInsertableClientSSK key = InsertableClientSSK.createRandom(r, \"\");\n        \toutsb.append(\"Insert URI: \"+key.getInsertURI().toString(false)+\"\\r\\n\");\n        \toutsb.append(\"Request URI: \"+key.getURI().toString(false)+\"\\r\\n\");\n        \tFreenetURI insertURI = key.getInsertURI().setDocName(\"testsite\");\n        \tString fixedInsertURI = insertURI.toString(false);\n        \toutsb.append(\"Note that you MUST add a filename to the end of the above URLs e.g.:\\r\\n\"+fixedInsertURI+\"\\r\\n\");\n        \toutsb.append(\"Normally you will then do PUTSSKDIR:<insert URI>#<directory to upload>, for example:\\r\\nPUTSSKDIR:\"+fixedInsertURI+\"#directoryToUpload/\"+\"\\r\\n\");\n        \toutsb.append(\"This will then produce a manifest site containing all the files, the default document can be accessed at\\r\\n\"+key.getURI().toString(false)+\"testsite/\");\n        } else if(uline.startsWith(\"PUTSSK:\")) {\n        \tString cmd = line.substring(\"PUTSSK:\".length());\n        \tcmd = cmd.trim();\n        \tif(cmd.indexOf(';') <= 0) {\n        \t\toutsb.append(\"No target URI provided.\");\n        \t\toutsb.append(\"PUTSSK:<insert uri>;<url to redirect to>\");\n        \t\treturn false;\n        \t}\n        \tString[] split = cmd.split(\";\");\n        \tString insertURI = split[0];\n        \tString targetURI = split[1];\n        \toutsb.append(\"Insert URI: \"+insertURI);\n        \toutsb.append(\"Target URI: \"+targetURI);\n        \tFreenetURI insert = new FreenetURI(insertURI);\n        \tFreenetURI target = new FreenetURI(targetURI);\n        \ttry {\n\t\t\t\tFreenetURI result = client.insertRedirect(insert, target);\n\t\t\t\toutsb.append(\"Successfully inserted to fetch URI: \"+result);\n\t\t\t} catch (InserterException e) {\n            \toutsb.append(\"Finished insert but: \"+e.getMessage());\n            \tLogger.normal(this, \"Error: \"+e, e);\n            \tif(e.uri != null) {\n            \t\toutsb.append(\"URI would have been: \"+e.uri);\n            \t}\n\t\t\t}\n        \t\n        } else if(uline.startsWith(\"STATUS\")) {\n            SimpleFieldSet fs = n.exportPublicFieldSet();\n            outsb.append(fs.toString());\n            outsb.append(n.getStatus());\n\t    if(Version.buildNumber()<Version.highestSeenBuild){\n\t            outsb.append(\"The latest version is : \"+Version.highestSeenBuild);\n\t    }\n        } else if(uline.startsWith(\"CONNECT:\")) {\n            String key = line.substring(\"CONNECT:\".length());\n            while(key.length() > 0 && key.charAt(0) == ' ')\n                key = key.substring(1);\n            while(key.length() > 0 && key.charAt(key.length()-1) == ' ')\n                key = key.substring(0, key.length()-2);\n            \n            String content = null;\n            if(key.length() > 0) {\n                // Filename\n            \tBufferedReader in;\n                outsb.append(\"Trying to connect to noderef in \"+key);\n                File f = new File(key);\n                if (f.isFile()) {\n                \toutsb.append(\"Given string seems to be a file, loading...\");\n                \tin = new BufferedReader(new FileReader(f));\n                } else {\n                \toutsb.append(\"Given string seems to be an URL, loading...\");\n                    URL url = new URL(key);\n                    URLConnection uc = url.openConnection();\n                \tin = new BufferedReader(\n                \t\t\tnew InputStreamReader(uc.getInputStream()));\n                }\n                content = readLines(in, true);\n                in.close();\n            } else {\n                content = readLines(reader, true);\n            }\n            if(content == null) return false;\n            if(content.equals(\"\")) return false;\n            connect(content);\n        \n        } else if(uline.startsWith(\"NAME:\")) {\n            outsb.append(\"Node name currently: \"+n.myName);\n            String key = line.substring(\"NAME:\".length());\n            while(key.length() > 0 && key.charAt(0) == ' ')\n                key = key.substring(1);\n            while(key.length() > 0 && key.charAt(key.length()-1) == ' ')\n                key = key.substring(0, key.length()-2);\n            outsb.append(\"New name: \"+key);\n            \n            try{\n            \tn.config.get(\"node\").getOption(\"name\").setValue(key);\n            \tLogger.minor(this, \"Setting node.name to \"+key);\n\t\t\t}catch(Exception e){\n\t\t\t\tLogger.error(this, \"Error setting node's name\");\n    \t\t}\n    \t\tn.config.store();\n        } else if(uline.startsWith(\"DISCONNECT:\")) {\n        \tString ipAndPort = line.substring(\"DISCONNECT:\".length());\n        \tdisconnect(ipAndPort.trim());\n        \t\n        } else if(uline.startsWith(\"PLUGLOAD:\")) {\n        \tif (line.substring(\"PLUGLOAD:\".length()).trim().equals(\"?\")) {\n        \t\toutsb.append(\"  PLUGLOAD: pkg.Class                  - Load plugin from current classpath\");        \t\t\n        \t\toutsb.append(\"  PLUGLOAD: pkg.Class@file:<filename>  - Load plugin from file\");\n        \t\toutsb.append(\"  PLUGLOAD: pkg.Class@http://...       - Load plugin from online file\");\n        \t\toutsb.append(\"  PLUGLOAD:         *@...              - Load plugin from manifest in given jarfile\");\n        \t\toutsb.append(\"\");\n        \t\toutsb.append(\"If the filename/url ends with \\\".url\\\", it\" +\n        \t\t\t\t\" is treated as a link, meaning that the first line is\" +\n        \t\t\t\t\" the accual URL. Else it is loaded as classpath and\" +\n        \t\t\t\t\" the class it loaded from it (meaning the file could\" +\n        \t\t\t\t\" be either a jar-file or a class-file).\");\n        \t\toutsb.append(\"\");\n        \t\toutsb.append(\"  PLUGLOAD: pkg.Class*  - Load newest version of plugin from http://downloads.freenetproject.org/alpha/plugins/\");        \t\t\n        \t\toutsb.append(\"\");\n        \t\t\n        \t} else\n        \t\tn.pluginManager.startPlugin(line.substring(\"PLUGLOAD:\".length()).trim());\n            //outsb.append(\"PLUGLOAD: <pkg.classname>[(@<URI to jarfile.jar>|<<URI to file containing real URI>|* (will load from freenets pluginpool))] - Load plugin.\");\n        } else if(uline.startsWith(\"PLUGLIST\")) {\n        \toutsb.append(n.pluginManager.dumpPlugins());\n        } else if(uline.startsWith(\"PLUGKILL:\")) {\n        \tn.pluginManager.killPlugin(line.substring(\"PLUGKILL:\".length()).trim());\n        } else {\n        \tif(uline.length() > 0)\n        \t\tprintHeader(out);\n        }\n        outsb.append(\"\\r\\n\");\n        out.write(outsb.toString().getBytes());\n        out.flush();\n        return false;\n    }","commit_id":"7339ad9205e6f0fc9da137d073878c6b54833b33","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Send an auth packet.\n\t */\n\tprivate void sendAuthPacket(int version, int negType, int phase, byte[] data, PeerNode pn, Peer replyTo) {\n\t\tbyte[] output = new byte[data.length+3];\n\t\toutput[0] = (byte) version;\n\t\toutput[1] = (byte) negType;\n\t\toutput[2] = (byte) phase;\n\t\tSystem.arraycopy(data, 0, output, 3, data.length);\n\t\tif(logMINOR) {\n\t\t\tlong now = System.currentTimeMillis();\n\t\t\tString delta = \"never\";\n\t\t\tlong last = pn.lastSentPacketTime();\n\t\t\tdelta = TimeUtil.formatTime(now - last, 2, true) + \" ago\";\n\t\t\tLogger.minor(this, \"Sending auth packet for \"+ String.valueOf(pn.getPeer())+\" (phase=\"+phase+\", ver=\"+version+\", nt=\"+negType+\") (last packet sent \"+delta+\") to \"+replyTo+\" data.length=\"+data.length+\" to \"+replyTo);\n\t\t}\n\t\tsendAuthPacket(output, pn.outgoingSetupCipher, pn, replyTo, false);\n\t}","id":75795,"modified_method":"/**\n\t * Send an auth packet.\n\t */\n\tprivate void sendAuthPacket(int version, int negType, int phase, byte[] data, PeerNode pn, Peer replyTo) {\n\t\tif(pn == null) throw new IllegalArgumentException(\"pn shouldn't be null here!\");\n\t\tbyte[] output = new byte[data.length+3];\n\t\toutput[0] = (byte) version;\n\t\toutput[1] = (byte) negType;\n\t\toutput[2] = (byte) phase;\n\t\tSystem.arraycopy(data, 0, output, 3, data.length);\n\t\tif(logMINOR) {\n\t\t\tlong now = System.currentTimeMillis();\n\t\t\tString delta = \"never\";\n\t\t\tlong last = pn.lastSentPacketTime();\n\t\t\tdelta = TimeUtil.formatTime(now - last, 2, true) + \" ago\";\n\t\t\tLogger.minor(this, \"Sending auth packet for \"+ String.valueOf(pn.getPeer())+\" (phase=\"+phase+\", ver=\"+version+\", nt=\"+negType+\") (last packet sent \"+delta+\") to \"+replyTo+\" data.length=\"+data.length+\" to \"+replyTo);\n\t\t}\n\t\tsendAuthPacket(output, pn.outgoingSetupCipher, pn, replyTo, false);\n\t}","commit_id":"b6562a91eadf6af5b930382e9db69ecb532fbec5","url":"https://github.com/freenet/fred"},{"original_method":"private void processJFKMessage3(byte[] payload, int inputOffset, PeerNode pn,Peer replyTo, boolean oldOpennetPeer, boolean unknownInitiator, int setupType)\n\t{\n\t\tfinal long t1 = System.currentTimeMillis();\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(3) message, processing it - \"+pn);\n\t\t\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) {}\n\t\t\n\t\tfinal int expectedLength =\t\n\t\t\tNONCE_SIZE*2 + // Ni, Nr\n\t\t\tDiffieHellman.modulusLengthInBytes()*2 + // g^i, g^r\n\t\t\tHASH_LENGTH + // authenticator\n\t\t\tHASH_LENGTH + // HMAC of the cyphertext\n\t\t\t(c.getBlockSize() >> 3) + // IV\n\t\t\tHASH_LENGTH + // it's at least a signature\n\t\t\t8 +\t      // a bootid\n\t\t\t1;\t      // znoderefI* is at least 1 byte long\n\t\t\n\t\tif(payload.length < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn+\": \"+payload.length+\" after decryption in JFK(3), should be \"+(expectedLength + 3));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Ni\n\t\tbyte[] nonceInitiator = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceInitiator, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\t// Nr\n\t\tbyte[] nonceResponder = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceResponder, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\t// g^i\n\t\tbyte[] initiatorExponential = new byte[DiffieHellman.modulusLengthInBytes()];\n\t\tSystem.arraycopy(payload, inputOffset, initiatorExponential, 0, DiffieHellman.modulusLengthInBytes());\n\t\tinputOffset += DiffieHellman.modulusLengthInBytes();\n\t\t// g^r\n\t\tbyte[] responderExponential = new byte[DiffieHellman.modulusLengthInBytes()];\n\t\tSystem.arraycopy(payload, inputOffset, responderExponential, 0, DiffieHellman.modulusLengthInBytes());\n\t\tinputOffset += DiffieHellman.modulusLengthInBytes();\n\t\t\n\t\tbyte[] authenticator = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, authenticator, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\n\t\t// We *WANT* to check the hmac before we do the lookup on the hashmap\n\t\t// @see https://bugs.freenetproject.org/view.php?id=1604\n\t\tif(!HMAC.verifyWithSHA256(getTransientKey(), assembleJFKAuthenticator(responderExponential, initiatorExponential, nonceResponder, nonceInitiator, replyTo.getAddress().getAddress()) , authenticator)) {\n\t\t\tif(shouldLogErrorInHandshake(t1))\n\t\t\t\tLogger.normal(this, \"The HMAC doesn't match; let's discard the packet (either we rekeyed or we are victim of forgery) - JFK3 - \"+pn);\n\t\t\treturn;\n\t\t}\n\t\t// Check try to find the authenticator in the cache.\n\t\t// If authenticator is already present, indicates duplicate/replayed message3\n\t\t// Now simply transmit the corresponding message4\n\t\tObject message4 = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tmessage4 = authenticatorCache.get(new ByteArrayWrapper(authenticator));\n\t\t}\n\t\tif(message4 != null) {\n\t\t\tLogger.normal(this, \"We replayed a message from the cache (shouldn't happen often) - \"+pn);\n\t\t\t// We are replaying a JFK(4).\n\t\t\t// Therefore if it is anon-initiator it is encrypted with our setup key.\n\t\t\tif(unknownInitiator)\n\t\t\t\tsendAnonAuthPacket(1,2,3,setupType, (byte[]) message4, null, replyTo, crypto.anonSetupCipher);\n\t\t\telse\n\t\t\t\tsendAuthPacket(1, 2, 3, (byte[]) message4, pn, replyTo);\n\t\t\treturn;\n\t\t} else {\n\t\t\tif(logDEBUG) Logger.debug(this, \"No message4 found for \"+HexUtil.bytesToHex(authenticator)+\" responderExponential \"+Fields.hashCode(responderExponential)+\" initiatorExponential \"+Fields.hashCode(initiatorExponential)+\" nonceResponder \"+Fields.hashCode(nonceResponder)+\" nonceInitiator \"+Fields.hashCode(nonceInitiator)+\" address \"+HexUtil.bytesToHex(replyTo.getAddress().getAddress()));\n\t\t}\n\t\t\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1, initiatorExponential);\n\t\tNativeBigInteger _ourExponential = new NativeBigInteger(1, responderExponential);\n\t\t\n\t\tbyte[] hmac = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, hmac, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\t\t\n\t\tDiffieHellmanLightContext ctx = findContextByExponential(_ourExponential);\n\t\tif(ctx == null) {\n\t\t\tLogger.error(this, \"WTF? the HMAC verified but we don't know about that exponential! SHOULDN'T HAPPEN! - JFK3 - \"+pn);\n\t\t\treturn;\n\t\t}\n\t\tBigInteger computedExponential = ctx.getHMACKey(_hisExponential, Global.DHgroupA);\n\t\tbyte[] Ks = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"0\");\n\t\tbyte[] Ke = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"1\");\n\t\tbyte[] Ka = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"2\");\n\t\tc.initialize(Ke);\n\t\tfinal PCFBMode pk = PCFBMode.create(c);\n\t\tint ivLength = pk.lengthIV();\n\t\tint decypheredPayloadOffset = 0;\n\t\t// We compute the HMAC of (\"I\"+cyphertext) : the cyphertext includes the IV!\n\t\tbyte[] decypheredPayload = new byte[JFK_PREFIX_INITIATOR.length + payload.length - inputOffset];\n\t\tSystem.arraycopy(JFK_PREFIX_INITIATOR, 0, decypheredPayload, decypheredPayloadOffset, JFK_PREFIX_INITIATOR.length);\n\t\tdecypheredPayloadOffset += JFK_PREFIX_INITIATOR.length;\n\t\tSystem.arraycopy(payload, inputOffset, decypheredPayload, decypheredPayloadOffset, decypheredPayload.length-decypheredPayloadOffset);\n\t\tif(!HMAC.verifyWithSHA256(Ka, decypheredPayload, hmac)) {\n\t\t\tLogger.error(this, \"The inner-HMAC doesn't match; let's discard the packet JFK(3) - \"+pn);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Get the IV\n\t\tpk.reset(decypheredPayload, decypheredPayloadOffset);\n\t\tdecypheredPayloadOffset += ivLength;\n\t\t// Decrypt the payload\n\t\tpk.blockDecipher(decypheredPayload, decypheredPayloadOffset, decypheredPayload.length-decypheredPayloadOffset);\n\t\t/*\n\t\t * DecipheredData Format:\n\t\t * Signature-r,s\n\t\t * Node Data (starting with BootID)\n\t\t */\n\t\tbyte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] data = new byte[decypheredPayload.length - decypheredPayloadOffset];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, data, 0, decypheredPayload.length - decypheredPayloadOffset);\n\t\tlong bootID = Fields.bytesToLong(data);\n\t\tbyte[] hisRef = new byte[data.length - 8];\n\t\tSystem.arraycopy(data, 8, hisRef, 0, hisRef.length);\n\t\t\n\t\t// construct the peernode\n\t\tif(unknownInitiator) {\n\t\t\tpn = getPeerNodeFromUnknownInitiator(hisRef, setupType, pn);\n\t\t\tif(pn == null) {\n\t\t\t\t// Reject\n\t\t\t\tLogger.normal(this, \"Rejecting... unable to construct PeerNode\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// verify the signature\n\t\tDSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s)); \n\t\tif(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, SHA256.digest(assembleDHParams(nonceInitiator, nonceResponder, _hisExponential, _ourExponential, crypto.myIdentity, data))), false)) {\n\t\t\tLogger.error(this, \"The signature verification has failed!! JFK(3) - \"+pn.getPeer());\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// At this point we know it's from the peer, so we can report a packet received.\n\t\tpn.receivedPacket(true);\n\t\t\n\t\t// Send reply\n\t\tsendJFKMessage4(1, 2, 3, nonceInitiator, nonceResponder,initiatorExponential, responderExponential, \n\t\t\t\tc, Ke, Ka, authenticator, hisRef, pn, replyTo, unknownInitiator, setupType);\n\t\t\n\t\tc.initialize(Ks);\n\t\t\n\t\t// Promote if necessary\n\t\tboolean dontWant = false;\n\t\tif(oldOpennetPeer) {\n\t\t\tOpennetManager opennet = node.getOpennet();\n\t\t\tif(opennet == null) {\n\t\t\t\tLogger.normal(this, \"Dumping incoming old-opennet peer as opennet just turned off: \"+pn+\".\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(!opennet.wantPeer(pn, true)) {\n\t\t\t\tLogger.normal(this, \"No longer want peer \"+pn+\" - dumping it after connecting\");\n\t\t\t\tdontWant = true;\n\t\t\t}\n\t\t\t// wantPeer will call node.peers.addPeer(), we don't have to.\n\t\t}\n\t\t\n\t\tif(pn.completedHandshake(bootID, hisRef, 0, hisRef.length, c, Ks, replyTo, true)) {\n\t\t\tif(dontWant)\n\t\t\t\tnode.peers.disconnect(pn, true, false);\n\t\t\telse\n\t\t\t\tpn.maybeSendInitialMessages();\n\t\t} else {\n\t\t\tLogger.error(this, \"Handshake failure! with \"+pn.getPeer());\n\t\t}\n\t\t\n\t\tfinal long t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message3 Processing packet for\"+pn.getPeer()+\" took \"+TimeUtil.formatTime(t2-t1, 3, true));\n\t}","id":75796,"modified_method":"private void processJFKMessage3(byte[] payload, int inputOffset, PeerNode pn,Peer replyTo, boolean oldOpennetPeer, boolean unknownInitiator, int setupType)\n\t{\n\t\tfinal long t1 = System.currentTimeMillis();\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(3) message, processing it - \"+pn);\n\t\t\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) {}\n\t\t\n\t\tfinal int expectedLength =\t\n\t\t\tNONCE_SIZE*2 + // Ni, Nr\n\t\t\tDiffieHellman.modulusLengthInBytes()*2 + // g^i, g^r\n\t\t\tHASH_LENGTH + // authenticator\n\t\t\tHASH_LENGTH + // HMAC of the cyphertext\n\t\t\t(c.getBlockSize() >> 3) + // IV\n\t\t\tHASH_LENGTH + // it's at least a signature\n\t\t\t8 +\t      // a bootid\n\t\t\t1;\t      // znoderefI* is at least 1 byte long\n\t\t\n\t\tif(payload.length < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn+\": \"+payload.length+\" after decryption in JFK(3), should be \"+(expectedLength + 3));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Ni\n\t\tbyte[] nonceInitiator = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceInitiator, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\t// Nr\n\t\tbyte[] nonceResponder = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceResponder, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\t// g^i\n\t\tbyte[] initiatorExponential = new byte[DiffieHellman.modulusLengthInBytes()];\n\t\tSystem.arraycopy(payload, inputOffset, initiatorExponential, 0, DiffieHellman.modulusLengthInBytes());\n\t\tinputOffset += DiffieHellman.modulusLengthInBytes();\n\t\t// g^r\n\t\tbyte[] responderExponential = new byte[DiffieHellman.modulusLengthInBytes()];\n\t\tSystem.arraycopy(payload, inputOffset, responderExponential, 0, DiffieHellman.modulusLengthInBytes());\n\t\tinputOffset += DiffieHellman.modulusLengthInBytes();\n\t\t\n\t\tbyte[] authenticator = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, authenticator, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\n\t\t// We *WANT* to check the hmac before we do the lookup on the hashmap\n\t\t// @see https://bugs.freenetproject.org/view.php?id=1604\n\t\tif(!HMAC.verifyWithSHA256(getTransientKey(), assembleJFKAuthenticator(responderExponential, initiatorExponential, nonceResponder, nonceInitiator, replyTo.getAddress().getAddress()) , authenticator)) {\n\t\t\tif(shouldLogErrorInHandshake(t1))\n\t\t\t\tLogger.normal(this, \"The HMAC doesn't match; let's discard the packet (either we rekeyed or we are victim of forgery) - JFK3 - \"+pn);\n\t\t\treturn;\n\t\t}\n\t\t// Check try to find the authenticator in the cache.\n\t\t// If authenticator is already present, indicates duplicate/replayed message3\n\t\t// Now simply transmit the corresponding message4\n\t\tObject message4 = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tmessage4 = authenticatorCache.get(new ByteArrayWrapper(authenticator));\n\t\t}\n\t\tif(message4 != null) {\n\t\t\tLogger.normal(this, \"We replayed a message from the cache (shouldn't happen often) - \"+pn);\n\t\t\t// We are replaying a JFK(4).\n\t\t\t// Therefore if it is anon-initiator it is encrypted with our setup key.\n\t\t\tif(unknownInitiator)\n\t\t\t\tsendAnonAuthPacket(1,2,3,setupType, (byte[]) message4, null, replyTo, crypto.anonSetupCipher);\n\t\t\telse\n\t\t\t\tsendAuthPacket(1, 2, 3, (byte[]) message4, pn, replyTo);\n\t\t\treturn;\n\t\t} else {\n\t\t\tif(logDEBUG) Logger.debug(this, \"No message4 found for \"+HexUtil.bytesToHex(authenticator)+\" responderExponential \"+Fields.hashCode(responderExponential)+\" initiatorExponential \"+Fields.hashCode(initiatorExponential)+\" nonceResponder \"+Fields.hashCode(nonceResponder)+\" nonceInitiator \"+Fields.hashCode(nonceInitiator)+\" address \"+HexUtil.bytesToHex(replyTo.getAddress().getAddress()));\n\t\t}\n\t\t\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1, initiatorExponential);\n\t\tNativeBigInteger _ourExponential = new NativeBigInteger(1, responderExponential);\n\t\t\n\t\tbyte[] hmac = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, hmac, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\t\t\n\t\tDiffieHellmanLightContext ctx = findContextByExponential(_ourExponential);\n\t\tif(ctx == null) {\n\t\t\tLogger.error(this, \"WTF? the HMAC verified but we don't know about that exponential! SHOULDN'T HAPPEN! - JFK3 - \"+pn);\n\t\t\treturn;\n\t\t}\n\t\tBigInteger computedExponential = ctx.getHMACKey(_hisExponential, Global.DHgroupA);\n\t\tbyte[] Ks = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"0\");\n\t\tbyte[] Ke = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"1\");\n\t\tbyte[] Ka = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"2\");\n\t\tc.initialize(Ke);\n\t\tfinal PCFBMode pk = PCFBMode.create(c);\n\t\tint ivLength = pk.lengthIV();\n\t\tint decypheredPayloadOffset = 0;\n\t\t// We compute the HMAC of (\"I\"+cyphertext) : the cyphertext includes the IV!\n\t\tbyte[] decypheredPayload = new byte[JFK_PREFIX_INITIATOR.length + payload.length - inputOffset];\n\t\tSystem.arraycopy(JFK_PREFIX_INITIATOR, 0, decypheredPayload, decypheredPayloadOffset, JFK_PREFIX_INITIATOR.length);\n\t\tdecypheredPayloadOffset += JFK_PREFIX_INITIATOR.length;\n\t\tSystem.arraycopy(payload, inputOffset, decypheredPayload, decypheredPayloadOffset, decypheredPayload.length-decypheredPayloadOffset);\n\t\tif(!HMAC.verifyWithSHA256(Ka, decypheredPayload, hmac)) {\n\t\t\tLogger.error(this, \"The inner-HMAC doesn't match; let's discard the packet JFK(3) - \"+pn);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Get the IV\n\t\tpk.reset(decypheredPayload, decypheredPayloadOffset);\n\t\tdecypheredPayloadOffset += ivLength;\n\t\t// Decrypt the payload\n\t\tpk.blockDecipher(decypheredPayload, decypheredPayloadOffset, decypheredPayload.length-decypheredPayloadOffset);\n\t\t/*\n\t\t * DecipheredData Format:\n\t\t * Signature-r,s\n\t\t * Node Data (starting with BootID)\n\t\t */\n\t\tbyte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] data = new byte[decypheredPayload.length - decypheredPayloadOffset];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, data, 0, decypheredPayload.length - decypheredPayloadOffset);\n\t\tlong bootID = Fields.bytesToLong(data);\n\t\tbyte[] hisRef = new byte[data.length - 8];\n\t\tSystem.arraycopy(data, 8, hisRef, 0, hisRef.length);\n\t\t\n\t\t// construct the peernode\n\t\tif(unknownInitiator) {\n\t\t\tpn = getPeerNodeFromUnknownInitiator(hisRef, setupType, pn);\n\t\t}\n\t\tif(pn == null) {\n\t\t\tif(unknownInitiator)\n\t\t\t\t// Reject\n\t\t\t\tLogger.normal(this, \"Rejecting... unable to construct PeerNode\");\n\t\t\telse\n\t\t\t\tLogger.error(this, \"PeerNode is null and unknownInitiator is false!\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// verify the signature\n\t\tDSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s)); \n\t\tif(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, SHA256.digest(assembleDHParams(nonceInitiator, nonceResponder, _hisExponential, _ourExponential, crypto.myIdentity, data))), false)) {\n\t\t\tLogger.error(this, \"The signature verification has failed!! JFK(3) - \"+pn.getPeer());\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// At this point we know it's from the peer, so we can report a packet received.\n\t\tpn.receivedPacket(true);\n\t\t\n\t\t// Send reply\n\t\tsendJFKMessage4(1, 2, 3, nonceInitiator, nonceResponder,initiatorExponential, responderExponential, \n\t\t\t\tc, Ke, Ka, authenticator, hisRef, pn, replyTo, unknownInitiator, setupType);\n\t\t\n\t\tc.initialize(Ks);\n\t\t\n\t\t// Promote if necessary\n\t\tboolean dontWant = false;\n\t\tif(oldOpennetPeer) {\n\t\t\tOpennetManager opennet = node.getOpennet();\n\t\t\tif(opennet == null) {\n\t\t\t\tLogger.normal(this, \"Dumping incoming old-opennet peer as opennet just turned off: \"+pn+\".\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(!opennet.wantPeer(pn, true)) {\n\t\t\t\tLogger.normal(this, \"No longer want peer \"+pn+\" - dumping it after connecting\");\n\t\t\t\tdontWant = true;\n\t\t\t}\n\t\t\t// wantPeer will call node.peers.addPeer(), we don't have to.\n\t\t}\n\t\t\n\t\tif(pn.completedHandshake(bootID, hisRef, 0, hisRef.length, c, Ks, replyTo, true)) {\n\t\t\tif(dontWant)\n\t\t\t\tnode.peers.disconnect(pn, true, false);\n\t\t\telse\n\t\t\t\tpn.maybeSendInitialMessages();\n\t\t} else {\n\t\t\tLogger.error(this, \"Handshake failure! with \"+pn.getPeer());\n\t\t}\n\t\t\n\t\tfinal long t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message3 Processing packet for\"+pn.getPeer()+\" took \"+TimeUtil.formatTime(t2-t1, 3, true));\n\t}","commit_id":"b6562a91eadf6af5b930382e9db69ecb532fbec5","url":"https://github.com/freenet/fred"},{"original_method":"private void processJFKMessage2(byte[] payload,int inputOffset,PeerNode pn,Peer replyTo, boolean unknownInitiator, int setupType)\n\t{\n\t\tlong t1=System.currentTimeMillis();\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(2) message, processing it - \"+pn);\n\t\t// FIXME: follow the spec and send IDr' ?\n\t\tint expectedLength = NONCE_SIZE*2 + DiffieHellman.modulusLengthInBytes() + HASH_LENGTH*2;\n\t\tif(payload.length < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn+\": \"+payload.length+\" after decryption in JFK(2), should be \"+(expectedLength + 3));\n\t\t\treturn;\n\t\t}\n\n\t\tbyte[] nonceInitiator = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceInitiator, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\tbyte[] nonceResponder = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceResponder, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\n\t\tbyte[] hisExponential = new byte[DiffieHellman.modulusLengthInBytes()];\n\t\tSystem.arraycopy(payload, inputOffset, hisExponential, 0, DiffieHellman.modulusLengthInBytes());\n\t\tinputOffset += DiffieHellman.modulusLengthInBytes();\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\n\t\tbyte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tinputOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tinputOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\n\t\tbyte[] authenticator = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, authenticator, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\t\t\n\t\t// Check try to find the authenticator in the cache.\n\t\t// If authenticator is already present, indicates duplicate/replayed message2\n\t\t// Now simply transmit the corresponding message3\n\t\tObject message3 = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tmessage3 = authenticatorCache.get(authenticator);\n\t\t}\n\t\tif(message3 != null) {\n\t\t\tLogger.normal(this, \"We replayed a message from the cache (shouldn't happen often) -\"+pn);\n\t\t\tsendAuthPacket(1, 2, 3, (byte[]) message3, pn, replyTo);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// sanity check\n\t\tbyte[] myNi = null;\n\t\tsynchronized (pn) {\n\t\t\tmyNi = (byte[]) pn.jfkNoncesSent.get(replyTo);\n\t\t}\n\t\t// We don't except such a message;\n\t\tif(myNi == null) {\n\t\t\tLogger.normal(this, \"We received an unexpected JFK(2) message from \"+pn);\n\t\t\treturn;\n\t\t} else if(!Arrays.equals(myNi, nonceInitiator)){\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Ignoring old JFK(2) (different nonce to the one we sent - either a timing artefact or an attempt to change the nonce)\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(!DiffieHellman.checkDHExponentialValidity(this.getClass(), _hisExponential)) {\n\t\t\tLogger.error(this, \"We can't accept the exponential \"+pn+\" sent us!! REDFLAG: IT CAN'T HAPPEN UNLESS AGAINST AN ACTIVE ATTACKER!!\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Verify the DSA signature\n\t\tDSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t\t// At that point we don't know if it's \"him\"; let's check it out\n\t\tbyte[] locallyExpectedExponentials = assembleDHParams(_hisExponential, pn.peerCryptoGroup);\n\n\t\tif(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, SHA256.digest(locallyExpectedExponentials)), false)) {\n\t\t\tLogger.error(this, \"The signature verification has failed in JFK(2)!! \"+pn);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// At this point we know it's from the peer, so we can report a packet received.\n\t\tpn.receivedPacket(true);\n\t\t\n\t\tsendJFKMessage3(1, 2, 3, nonceInitiator, nonceResponder, hisExponential, authenticator, pn, replyTo, unknownInitiator, setupType);\n\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message1 timeout error:Sending packet for\"+pn.getPeer());\n\t}","id":75797,"modified_method":"private void processJFKMessage2(byte[] payload,int inputOffset,PeerNode pn,Peer replyTo, boolean unknownInitiator, int setupType)\n\t{\n\t\tlong t1=System.currentTimeMillis();\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(2) message, processing it - \"+pn.getPeer());\n\t\t// FIXME: follow the spec and send IDr' ?\n\t\tint expectedLength = NONCE_SIZE*2 + DiffieHellman.modulusLengthInBytes() + HASH_LENGTH*2;\n\t\tif(payload.length < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn.getPeer()+\": \"+payload.length+\" after decryption in JFK(2), should be \"+(expectedLength + 3));\n\t\t\treturn;\n\t\t}\n\n\t\tbyte[] nonceInitiator = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceInitiator, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\tbyte[] nonceResponder = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceResponder, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\n\t\tbyte[] hisExponential = new byte[DiffieHellman.modulusLengthInBytes()];\n\t\tSystem.arraycopy(payload, inputOffset, hisExponential, 0, DiffieHellman.modulusLengthInBytes());\n\t\tinputOffset += DiffieHellman.modulusLengthInBytes();\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\n\t\tbyte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tinputOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tinputOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\n\t\tbyte[] authenticator = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, authenticator, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\t\t\n\t\t// Check try to find the authenticator in the cache.\n\t\t// If authenticator is already present, indicates duplicate/replayed message2\n\t\t// Now simply transmit the corresponding message3\n\t\tObject message3 = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tmessage3 = authenticatorCache.get(authenticator);\n\t\t}\n\t\tif(message3 != null) {\n\t\t\tLogger.normal(this, \"We replayed a message from the cache (shouldn't happen often) - \"+pn.getPeer());\n\t\t\tsendAuthPacket(1, 2, 3, (byte[]) message3, pn, replyTo);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// sanity check\n\t\tbyte[] myNi = null;\n\t\tsynchronized (pn) {\n\t\t\tmyNi = (byte[]) pn.jfkNoncesSent.get(replyTo);\n\t\t}\n\t\t// We don't except such a message;\n\t\tif(myNi == null) {\n\t\t\tif(shouldLogErrorInHandshake(t1))\n\t\t\t\tLogger.normal(this, \"We received an unexpected JFK(2) message from \"+pn.getPeer());\n\t\t\treturn;\n\t\t} else if(!Arrays.equals(myNi, nonceInitiator)){\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Ignoring old JFK(2) (different nonce to the one we sent - either a timing artefact or an attempt to change the nonce)\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(!DiffieHellman.checkDHExponentialValidity(this.getClass(), _hisExponential)) {\n\t\t\tLogger.error(this, \"We can't accept the exponential \"+pn.getPeer()+\" sent us!! REDFLAG: IT CAN'T HAPPEN UNLESS AGAINST AN ACTIVE ATTACKER!!\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Verify the DSA signature\n\t\tDSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t\t// At that point we don't know if it's \"him\"; let's check it out\n\t\tbyte[] locallyExpectedExponentials = assembleDHParams(_hisExponential, pn.peerCryptoGroup);\n\n\t\tif(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, SHA256.digest(locallyExpectedExponentials)), false)) {\n\t\t\tLogger.error(this, \"The signature verification has failed in JFK(2)!! \"+pn.getPeer());\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// At this point we know it's from the peer, so we can report a packet received.\n\t\tpn.receivedPacket(true);\n\t\t\n\t\tsendJFKMessage3(1, 2, 3, nonceInitiator, nonceResponder, hisExponential, authenticator, pn, replyTo, unknownInitiator, setupType);\n\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message2 timeout error:Processing packet for\"+pn.getPeer());\n\t}","commit_id":"0f83d0f20db8853feaedae197c7765fff0937db8","url":"https://github.com/freenet/fred"},{"original_method":"private void sendJFKMessage4(int version,int negType,int phase,byte[] nonceInitiator,byte[] nonceResponder,byte[] initiatorExponential,byte[] responderExponential, BlockCipher c, byte[] Ke, byte[] Ka, byte[] authenticator, byte[] hisRef, PeerNode pn, Peer replyTo, boolean unknownInitiator, int setupType)\n\t{\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Sending a JFK(4) message to \"+pn);\n\t\tNativeBigInteger _responderExponential = new NativeBigInteger(1,responderExponential);\n\t\tNativeBigInteger _initiatorExponential = new NativeBigInteger(1,initiatorExponential);\n\t\t\n\t\tbyte[] myRef = crypto.myCompressedSetupRef();\n\t\tbyte[] data = new byte[8 + myRef.length + hisRef.length];\n\t\tSystem.arraycopy(Fields.longToBytes(node.bootID), 0, data, 0, 8);\n\t\tSystem.arraycopy(myRef, 0, data, 8, myRef.length);\n\t\tSystem.arraycopy(hisRef, 0, data, 8 + myRef.length, hisRef.length);\n\t\t\n\t\tDSASignature localSignature = crypto.sign(SHA256.digest(assembleDHParams(nonceInitiator, nonceResponder, _initiatorExponential, _responderExponential, pn.identity, data)));\n\t\tbyte[] r = localSignature.getRBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tbyte[] s = localSignature.getSBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\t\n\t\tPCFBMode pk=PCFBMode.create(c);\n\t\tint ivLength = pk.lengthIV();\n\t\tbyte[] iv=new byte[ivLength];\n\t\tnode.random.nextBytes(iv);\n\t\tpk.reset(iv);\n\t\tbyte[] prefix = null;\n\t\ttry { prefix = \"R\".getBytes(\"UTF-8\"); } catch (UnsupportedEncodingException e) {}\n\n\t\tbyte[] cyphertext = new byte[prefix.length + ivLength + Node.SIGNATURE_PARAMETER_LENGTH * 2 + data.length];\n\t\tint cleartextOffset = 0;\n\t\tSystem.arraycopy(prefix, 0, cyphertext, cleartextOffset, prefix.length);\n\t\tcleartextOffset += prefix.length;\n\t\tSystem.arraycopy(iv, 0, cyphertext, cleartextOffset, ivLength);\n\t\tcleartextOffset += ivLength;\n\t\tSystem.arraycopy(r, 0, cyphertext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(s, 0, cyphertext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(data, 0, cyphertext, cleartextOffset, data.length);\n\t\tcleartextOffset += data.length;\n\t\t// Now encrypt the cleartext[Signature]\n\t\tint cleartextToEncypherOffset = prefix.length + ivLength;\n\t\tpk.blockEncipher(cyphertext, cleartextToEncypherOffset, cyphertext.length - cleartextToEncypherOffset);\n\t\t\n\t\t// We compute the HMAC of (prefix + iv + signature)\n\t\tHMAC mac = new HMAC(SHA256.getInstance());\n\t\tbyte[] hmac = mac.mac(Ka, cyphertext, HASH_LENGTH);\n\t\t\n\t\t// Message4 = hmac + IV + encryptedSignature\n\t\tbyte[] message4 = new byte[HASH_LENGTH + ivLength + (cyphertext.length - cleartextToEncypherOffset)]; \n\t\tint offset = 0;\n\t\tSystem.arraycopy(hmac, 0, message4, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\tSystem.arraycopy(iv, 0, message4, offset, ivLength);\n\t\toffset += ivLength;\n\t\tSystem.arraycopy(cyphertext, cleartextToEncypherOffset, message4, offset, cyphertext.length - cleartextToEncypherOffset);\n\t\t\n\t\t// cache the message\n\t\tsynchronized (authenticatorCache) {\n\t\t\tif(!maybeResetTransientKey())\n\t\t\t\tauthenticatorCache.put(authenticator, message4);\n\t\t}\n\t\t\n\t\tif(unknownInitiator)\n\t\t\tsendAnonAuthPacket(1, 2, 3, setupType, message4, pn, replyTo, crypto.anonSetupCipher);\n\t\telse\n\t\t\tsendAuthPacket(1, 2, 3, message4, pn, replyTo);\n\t}","id":75798,"modified_method":"private void sendJFKMessage4(int version,int negType,int phase,byte[] nonceInitiator,byte[] nonceResponder,byte[] initiatorExponential,byte[] responderExponential, BlockCipher c, byte[] Ke, byte[] Ka, byte[] authenticator, byte[] hisRef, PeerNode pn, Peer replyTo, boolean unknownInitiator, int setupType)\n\t{\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Sending a JFK(4) message to \"+pn.getPeer());\n\t\tlong t1=System.currentTimeMillis();\n\t\tNativeBigInteger _responderExponential = new NativeBigInteger(1,responderExponential);\n\t\tNativeBigInteger _initiatorExponential = new NativeBigInteger(1,initiatorExponential);\n\t\t\n\t\tbyte[] myRef = crypto.myCompressedSetupRef();\n\t\tbyte[] data = new byte[8 + myRef.length + hisRef.length];\n\t\tSystem.arraycopy(Fields.longToBytes(node.bootID), 0, data, 0, 8);\n\t\tSystem.arraycopy(myRef, 0, data, 8, myRef.length);\n\t\tSystem.arraycopy(hisRef, 0, data, 8 + myRef.length, hisRef.length);\n\t\t\n\t\tDSASignature localSignature = crypto.sign(SHA256.digest(assembleDHParams(nonceInitiator, nonceResponder, _initiatorExponential, _responderExponential, pn.identity, data)));\n\t\tbyte[] r = localSignature.getRBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tbyte[] s = localSignature.getSBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\t\n\t\tPCFBMode pk=PCFBMode.create(c);\n\t\tint ivLength = pk.lengthIV();\n\t\tbyte[] iv=new byte[ivLength];\n\t\tnode.random.nextBytes(iv);\n\t\tpk.reset(iv);\n\t\tbyte[] cyphertext = new byte[JFK_PREFIX_RESPONDER.length + ivLength + Node.SIGNATURE_PARAMETER_LENGTH * 2 + data.length];\n\t\tint cleartextOffset = 0;\n\t\tSystem.arraycopy(JFK_PREFIX_RESPONDER, 0, cyphertext, cleartextOffset, JFK_PREFIX_RESPONDER.length);\n\t\tcleartextOffset += JFK_PREFIX_RESPONDER.length;\n\t\tSystem.arraycopy(iv, 0, cyphertext, cleartextOffset, ivLength);\n\t\tcleartextOffset += ivLength;\n\t\tSystem.arraycopy(r, 0, cyphertext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(s, 0, cyphertext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(data, 0, cyphertext, cleartextOffset, data.length);\n\t\tcleartextOffset += data.length;\n\t\t// Now encrypt the cleartext[Signature]\n\t\tint cleartextToEncypherOffset = JFK_PREFIX_RESPONDER.length + ivLength;\n\t\tpk.blockEncipher(cyphertext, cleartextToEncypherOffset, cyphertext.length - cleartextToEncypherOffset);\n\t\t\n\t\t// We compute the HMAC of (prefix + iv + signature)\n\t\tHMAC mac = new HMAC(SHA256.getInstance());\n\t\tbyte[] hmac = mac.mac(Ka, cyphertext, HASH_LENGTH);\n\t\t\n\t\t// Message4 = hmac + IV + encryptedSignature\n\t\tbyte[] message4 = new byte[HASH_LENGTH + ivLength + (cyphertext.length - cleartextToEncypherOffset)]; \n\t\tint offset = 0;\n\t\tSystem.arraycopy(hmac, 0, message4, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\tSystem.arraycopy(iv, 0, message4, offset, ivLength);\n\t\toffset += ivLength;\n\t\tSystem.arraycopy(cyphertext, cleartextToEncypherOffset, message4, offset, cyphertext.length - cleartextToEncypherOffset);\n\t\t\n\t\t// cache the message\n\t\tsynchronized (authenticatorCache) {\n\t\t\tif(!maybeResetTransientKey())\n\t\t\t\tauthenticatorCache.put(authenticator, message4);\n\t\t}\n\t\t\n\t\tif(unknownInitiator)\n\t\t\tsendAnonAuthPacket(1, 2, 3, setupType, message4, pn, replyTo, crypto.anonSetupCipher);\n\t\telse\n\t\t\tsendAuthPacket(1, 2, 3, message4, pn, replyTo);\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message4 timeout error:Sending packet for\"+pn.getPeer());\n\t}","commit_id":"0f83d0f20db8853feaedae197c7765fff0937db8","url":"https://github.com/freenet/fred"},{"original_method":"private void processJFKMessage1(byte[] payload,int offset,PeerNode pn,Peer replyTo, boolean unknownInitiator, int setupType)\n\t{\n\t\tlong t1=System.currentTimeMillis();\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(1) message, processing it - \"+pn);\n\t\t// FIXME: follow the spec and send IDr' ?\n\t\tif(payload.length < NONCE_SIZE + DiffieHellman.modulusLengthInBytes() + 3 + (unknownInitiator ? NodeCrypto.IDENTITY_LENGTH : 0)) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn+\": \"+payload.length+\" after decryption in JFK(1), should be \"+(NONCE_SIZE + DiffieHellman.modulusLengthInBytes()));\n\t\t\treturn;\n\t\t}\n\t\t// get Ni\n\t\tbyte[] nonceInitiator = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, offset, nonceInitiator, 0, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\n\t\t// get g^i\n\t\tint modulusLength = DiffieHellman.modulusLengthInBytes();\n\t\tbyte[] hisExponential = new byte[modulusLength];\n\t\tSystem.arraycopy(payload, offset, hisExponential, 0, modulusLength);\n\t\tif(unknownInitiator) {\n\t\t\t// Check IDr'\n\t\t\toffset += DiffieHellman.modulusLengthInBytes();\n\t\t\tbyte[] expectedIdentityHash = new byte[NodeCrypto.IDENTITY_LENGTH];\n\t\t\tSystem.arraycopy(payload, offset, expectedIdentityHash, 0, expectedIdentityHash.length);\n\t\t\tif(!Arrays.equals(expectedIdentityHash, crypto.identityHash)) {\n\t\t\t\tLogger.error(this, \"Invalid unknown-initiator JFK(1), IDr' is \"+HexUtil.bytesToHex(expectedIdentityHash)+\" should be \"+HexUtil.bytesToHex(crypto.identityHash));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\t\tif(DiffieHellman.checkDHExponentialValidity(this.getClass(), _hisExponential)) {\n\t\t\tsendJFKMessage2(nonceInitiator, hisExponential, pn, replyTo, unknownInitiator, setupType);\n\t\t}else\n\t\t\tLogger.error(this, \"We can't accept the exponential \"+pn+\" sent us!! REDFLAG: IT CAN'T HAPPEN UNLESS AGAINST AN ACTIVE ATTACKER!!\");\n\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message1 timeout error:Sending packet for\"+pn.getPeer());\n\t}","id":75799,"modified_method":"private void processJFKMessage1(byte[] payload,int offset,PeerNode pn,Peer replyTo, boolean unknownInitiator, int setupType)\n\t{\n\t\tlong t1=System.currentTimeMillis();\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(1) message, processing it - \"+pn.getPeer());\n\t\t// FIXME: follow the spec and send IDr' ?\n\t\tif(payload.length < NONCE_SIZE + DiffieHellman.modulusLengthInBytes() + 3 + (unknownInitiator ? NodeCrypto.IDENTITY_LENGTH : 0)) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn+\": \"+payload.length+\" after decryption in JFK(1), should be \"+(NONCE_SIZE + DiffieHellman.modulusLengthInBytes()));\n\t\t\treturn;\n\t\t}\n\t\t// get Ni\n\t\tbyte[] nonceInitiator = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, offset, nonceInitiator, 0, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\n\t\t// get g^i\n\t\tint modulusLength = DiffieHellman.modulusLengthInBytes();\n\t\tbyte[] hisExponential = new byte[modulusLength];\n\t\tSystem.arraycopy(payload, offset, hisExponential, 0, modulusLength);\n\t\tif(unknownInitiator) {\n\t\t\t// Check IDr'\n\t\t\toffset += DiffieHellman.modulusLengthInBytes();\n\t\t\tbyte[] expectedIdentityHash = new byte[NodeCrypto.IDENTITY_LENGTH];\n\t\t\tSystem.arraycopy(payload, offset, expectedIdentityHash, 0, expectedIdentityHash.length);\n\t\t\tif(!Arrays.equals(expectedIdentityHash, crypto.identityHash)) {\n\t\t\t\tLogger.error(this, \"Invalid unknown-initiator JFK(1), IDr' is \"+HexUtil.bytesToHex(expectedIdentityHash)+\" should be \"+HexUtil.bytesToHex(crypto.identityHash));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\t\tif(DiffieHellman.checkDHExponentialValidity(this.getClass(), _hisExponential)) {\n\t\t\tsendJFKMessage2(nonceInitiator, hisExponential, pn, replyTo, unknownInitiator, setupType);\n\t\t}else\n\t\t\tLogger.error(this, \"We can't accept the exponential \"+pn+\" sent us!! REDFLAG: IT CAN'T HAPPEN UNLESS AGAINST AN ACTIVE ATTACKER!!\");\n\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message1 timeout error:Processing packet for\"+pn.getPeer());\n\t}","commit_id":"0f83d0f20db8853feaedae197c7765fff0937db8","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Send an auth packet (we have constructed the payload, now hash it, pad it, encrypt it).\n\t */\n\tprivate void sendAuthPacket(byte[] output, BlockCipher cipher, PeerNode pn, Peer replyTo) {\n\t\tint length = output.length;\n\t\t// FIXME shorten seednode phase 3/4 so it's within the limit\n//\t\tif(length > sock.getMaxPacketSize()) {\n//\t\t\tthrow new IllegalStateException(\"Cannot send auth packet: too long: \"+length);\n//\t\t}\n\t\tPCFBMode pcfb = PCFBMode.create(cipher);\n\t\tint paddingLength = node.fastWeakRandom.nextInt(100);\n\t\tbyte[] iv = new byte[pcfb.lengthIV()];\n\t\tnode.random.nextBytes(iv);\n\t\tbyte[] hash = SHA256.digest(output);\n\t\tif(logMINOR) Logger.minor(this, \"Data hash: \"+HexUtil.bytesToHex(hash));\n\t\tbyte[] data = new byte[iv.length + hash.length + 2 /* length */ + output.length + paddingLength];\n\t\tpcfb.reset(iv);\n\t\tSystem.arraycopy(iv, 0, data, 0, iv.length);\n\t\tpcfb.blockEncipher(hash, 0, hash.length);\n\t\tSystem.arraycopy(hash, 0, data, iv.length, hash.length);\n\t\tif(logMINOR) Logger.minor(this, \"Payload length: \"+length);\n\t\tdata[hash.length+iv.length] = (byte) pcfb.encipher((byte)(length>>8));\n\t\tdata[hash.length+iv.length+1] = (byte) pcfb.encipher((byte)length);\n\t\tpcfb.blockEncipher(output, 0, output.length);\n\t\tSystem.arraycopy(output, 0, data, hash.length+iv.length+2, output.length);\n\t\tbyte[] random = new byte[paddingLength];\n\t\tnode.fastWeakRandom.nextBytes(random);\n\t\tSystem.arraycopy(random, 0, data, hash.length+iv.length+2+output.length, random.length);\n\t\ttry {\n\t\t\tsendPacket(data, replyTo, pn, 0);\n\t\t} catch (LocalAddressException e) {\n\t\t\tLogger.error(this, \"Tried to send auth packet to local address: \"+replyTo+\" for \"+pn+\" - maybe you should set allowLocalAddresses for this peer??\");\n\t\t}\n\t}","id":75800,"modified_method":"/**\n\t * Send an auth packet (we have constructed the payload, now hash it, pad it, encrypt it).\n\t */\n\tprivate void sendAuthPacket(byte[] output, BlockCipher cipher, PeerNode pn, Peer replyTo) {\n\t\tint length = output.length;\n\t\t// FIXME shorten seednode phase 3/4 so it's within the limit\n//\t\tif(length > sock.getMaxPacketSize()) {\n//\t\t\tthrow new IllegalStateException(\"Cannot send auth packet: too long: \"+length);\n//\t\t}\n\t\tPCFBMode pcfb = PCFBMode.create(cipher);\n\t\tbyte[] iv = new byte[pcfb.lengthIV()];\n\t\tnode.random.nextBytes(iv);\n\t\tbyte[] hash = SHA256.digest(output);\n\t\tif(logMINOR) Logger.minor(this, \"Data hash: \"+HexUtil.bytesToHex(hash));\n\t\tint prePaddingLength = iv.length + hash.length + 2 /* length */ + output.length;\n\t\tint paddingLength = node.fastWeakRandom.nextInt(Math.min(100, sock.getMaxPacketSize() - HEADERS_LENGTH_MINIMUM - prePaddingLength));\n\t\tbyte[] data = new byte[prePaddingLength + paddingLength];\n\t\tpcfb.reset(iv);\n\t\tSystem.arraycopy(iv, 0, data, 0, iv.length);\n\t\tpcfb.blockEncipher(hash, 0, hash.length);\n\t\tSystem.arraycopy(hash, 0, data, iv.length, hash.length);\n\t\tif(logMINOR) Logger.minor(this, \"Payload length: \"+length);\n\t\tdata[hash.length+iv.length] = (byte) pcfb.encipher((byte)(length>>8));\n\t\tdata[hash.length+iv.length+1] = (byte) pcfb.encipher((byte)length);\n\t\tpcfb.blockEncipher(output, 0, output.length);\n\t\tSystem.arraycopy(output, 0, data, hash.length+iv.length+2, output.length);\n\t\tbyte[] random = new byte[paddingLength];\n\t\tnode.fastWeakRandom.nextBytes(random);\n\t\tSystem.arraycopy(random, 0, data, hash.length+iv.length+2+output.length, random.length);\n\t\ttry {\n\t\t\tsendPacket(data, replyTo, pn, 0);\n\t\t} catch (LocalAddressException e) {\n\t\t\tLogger.error(this, \"Tried to send auth packet to local address: \"+replyTo+\" for \"+pn+\" - maybe you should set allowLocalAddresses for this peer??\");\n\t\t}\n\t}","commit_id":"0f83d0f20db8853feaedae197c7765fff0937db8","url":"https://github.com/freenet/fred"},{"original_method":"private void sendJFKMessage3(int version,int negType,int phase,byte[] nonceInitiator,byte[] nonceResponder,byte[] hisExponential, byte[] authenticator, final PeerNode pn, final Peer replyTo, final boolean unknownInitiator, final int setupType)\n\t{\n\t\tif(logMINOR) Logger.minor(this, \"Sending a JFK(3) message to \"+pn);\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) {}\n\t\tDiffieHellmanLightContext ctx = (DiffieHellmanLightContext) pn.getKeyAgreementSchemeContext();\n\t\tif(ctx == null) return;\n\t\tbyte[] ourExponential = stripBigIntegerToNetworkFormat(ctx.myExponential);\n\t\tpn.jfkMyRef = unknownInitiator ? crypto.myCompressedFullRef() : crypto.myCompressedSetupRef();\n\t\tbyte[] data = new byte[8 + pn.jfkMyRef.length];\n\t\tSystem.arraycopy(Fields.longToBytes(node.bootID), 0, data, 0, 8);\n\t\tSystem.arraycopy(pn.jfkMyRef, 0, data, 8, pn.jfkMyRef.length);\n\t\tfinal byte[] message3 = new byte[NONCE_SIZE*2 + // nI, nR\n\t\t                           DiffieHellman.modulusLengthInBytes()*2 + // g^i, g^r\n\t\t                           HASH_LENGTH + // authenticator\n\t\t                           HASH_LENGTH + // HMAC(cyphertext)\n\t\t                           (c.getBlockSize() >> 3) + // IV\n\t\t                           Node.SIGNATURE_PARAMETER_LENGTH * 2 + // Signature (R,S)\n\t\t                           data.length]; // The bootid+noderef\n\t\tint offset = 0;\n\t\t// Ni\n\t\tSystem.arraycopy(nonceInitiator, 0, message3, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\t// Nr\n\t\tSystem.arraycopy(nonceResponder, 0, message3, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\t// g^i\n\t\tSystem.arraycopy(ourExponential, 0,message3, offset, ourExponential.length);\n\t\toffset += ourExponential.length;\n\t\t// g^r\n\t\tSystem.arraycopy(hisExponential, 0,message3, offset, hisExponential.length);\n\t\toffset += hisExponential.length;\n\n\t\t// Authenticator\n\t\tSystem.arraycopy(authenticator, 0, message3, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\t/*\n\t\t * Digital Signature of the message with the private key belonging to the initiator/responder\n\t\t * It is assumed to be non-message recovering\n\t\t */\n\t\tNativeBigInteger _ourExponential = new NativeBigInteger(1,ourExponential);\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\t\t// save parameters so that we can verify message4\n\t\tbyte[] toSign = assembleDHParams(nonceInitiator, nonceResponder, _ourExponential, _hisExponential, pn.identity, data);\n\t\tpn.setJFKBuffer(toSign);\n\t\tDSASignature localSignature = crypto.sign(SHA256.digest(toSign));\n\t\tbyte[] r = localSignature.getRBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tbyte[] s = localSignature.getSBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\t\n\t\tBigInteger computedExponential = ctx.getHMACKey(_hisExponential, Global.DHgroupA);\n\t\tpn.jfkKs = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"0\");\n\t\tpn.jfkKe = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"1\");\n\t\tpn.jfkKa = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"2\");\n\t\tc.initialize(pn.jfkKe);\n\t\tPCFBMode pcfb = PCFBMode.create(c);\n\t\tint ivLength = pcfb.lengthIV();\n\t\tbyte[] iv = new byte[ivLength];\n\t\tnode.random.nextBytes(iv);\n\t\tpcfb.reset(iv);\n\t\tint cleartextOffset = 0;\n\t\tbyte[] prefix = null;\n\t\ttry { prefix = \"I\".getBytes(\"UTF-8\"); } catch (UnsupportedEncodingException e) {}\n\t\t\n\t\tbyte[] cleartext = new byte[prefix.length + ivLength + Node.SIGNATURE_PARAMETER_LENGTH * 2 + data.length];\n\t\tSystem.arraycopy(prefix, 0, cleartext, cleartextOffset, prefix.length);\n\t\tcleartextOffset += prefix.length;\n\t\tSystem.arraycopy(iv, 0, cleartext, cleartextOffset, ivLength);\n\t\tcleartextOffset += ivLength;\n\t\tSystem.arraycopy(r, 0, cleartext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(s, 0, cleartext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(data, 0, cleartext, cleartextOffset, data.length);\n\t\tcleartextOffset += data.length;\n\t\t\n\t\tint cleartextToEncypherOffset = prefix.length + ivLength;\n\t\tpcfb.blockEncipher(cleartext, cleartextToEncypherOffset, cleartext.length-cleartextToEncypherOffset);\n\t\t\n\t\t// We compute the HMAC of (prefix + cyphertext) Includes the IV!\n\t\tHMAC mac = new HMAC(SHA256.getInstance());\n\t\tbyte[] hmac = mac.mac(pn.jfkKa, cleartext, HASH_LENGTH);\n\t\t\n\t\t// copy stuffs back to the message\n\t\tSystem.arraycopy(hmac, 0, message3, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\tSystem.arraycopy(iv, 0, message3, offset, ivLength);\n\t\toffset += ivLength;\n\t\tSystem.arraycopy(cleartext, cleartextToEncypherOffset, message3, offset, cleartext.length-cleartextToEncypherOffset);\n\t\t\n\t\t// cache the message\n\t\tsynchronized (authenticatorCache) {\n\t\t\tif(!maybeResetTransientKey())\n\t\t\t\tauthenticatorCache.put(authenticator,message3);\n\t\t}\n\t\tif(unknownInitiator)\n\t\t\tsendAnonAuthPacket(1, 2, 2, setupType, message3, pn, replyTo, pn.anonymousInitiatorSetupCipher);\n\t\telse\n\t\t\tsendAuthPacket(1, 2, 2, message3, pn, replyTo);\n\t\t\n\t\t/* Re-send the packet after 5sec if we don't get any reply */\n\t\tnode.getTicker().queueTimedJob(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tif(pn.timeLastConnected() >= pn.lastReceivedPacketTime()) {\n\t\t\t\t\tif(unknownInitiator)\n\t\t\t\t\t\tsendAnonAuthPacket(1, 2, 2, setupType, message3, pn, replyTo, pn.anonymousInitiatorSetupCipher);\n\t\t\t\t\telse\n\t\t\t\t\t\tsendAuthPacket(1, 2, 2, message3, pn, replyTo);\n\t\t\t\t}\n\t\t\t}\n\t\t}, 5*1000);\n\t}","id":75801,"modified_method":"private void sendJFKMessage3(int version,int negType,int phase,byte[] nonceInitiator,byte[] nonceResponder,byte[] hisExponential, byte[] authenticator, final PeerNode pn, final Peer replyTo, final boolean unknownInitiator, final int setupType)\n\t{\n\t\tif(logMINOR) Logger.minor(this, \"Sending a JFK(3) message to \"+pn.getPeer());\n\t\tlong t1=System.currentTimeMillis();\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) {}\n\t\tDiffieHellmanLightContext ctx = (DiffieHellmanLightContext) pn.getKeyAgreementSchemeContext();\n\t\tif(ctx == null) return;\n\t\tbyte[] ourExponential = stripBigIntegerToNetworkFormat(ctx.myExponential);\n\t\tpn.jfkMyRef = unknownInitiator ? crypto.myCompressedFullRef() : crypto.myCompressedSetupRef();\n\t\tbyte[] data = new byte[8 + pn.jfkMyRef.length];\n\t\tSystem.arraycopy(Fields.longToBytes(node.bootID), 0, data, 0, 8);\n\t\tSystem.arraycopy(pn.jfkMyRef, 0, data, 8, pn.jfkMyRef.length);\n\t\tfinal byte[] message3 = new byte[NONCE_SIZE*2 + // nI, nR\n\t\t                           DiffieHellman.modulusLengthInBytes()*2 + // g^i, g^r\n\t\t                           HASH_LENGTH + // authenticator\n\t\t                           HASH_LENGTH + // HMAC(cyphertext)\n\t\t                           (c.getBlockSize() >> 3) + // IV\n\t\t                           Node.SIGNATURE_PARAMETER_LENGTH * 2 + // Signature (R,S)\n\t\t                           data.length]; // The bootid+noderef\n\t\tint offset = 0;\n\t\t// Ni\n\t\tSystem.arraycopy(nonceInitiator, 0, message3, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\t// Nr\n\t\tSystem.arraycopy(nonceResponder, 0, message3, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\t// g^i\n\t\tSystem.arraycopy(ourExponential, 0,message3, offset, ourExponential.length);\n\t\toffset += ourExponential.length;\n\t\t// g^r\n\t\tSystem.arraycopy(hisExponential, 0,message3, offset, hisExponential.length);\n\t\toffset += hisExponential.length;\n\n\t\t// Authenticator\n\t\tSystem.arraycopy(authenticator, 0, message3, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\t/*\n\t\t * Digital Signature of the message with the private key belonging to the initiator/responder\n\t\t * It is assumed to be non-message recovering\n\t\t */\n\t\tNativeBigInteger _ourExponential = new NativeBigInteger(1,ourExponential);\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\t\t// save parameters so that we can verify message4\n\t\tbyte[] toSign = assembleDHParams(nonceInitiator, nonceResponder, _ourExponential, _hisExponential, pn.identity, data);\n\t\tpn.setJFKBuffer(toSign);\n\t\tDSASignature localSignature = crypto.sign(SHA256.digest(toSign));\n\t\tbyte[] r = localSignature.getRBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tbyte[] s = localSignature.getSBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\t\n\t\tBigInteger computedExponential = ctx.getHMACKey(_hisExponential, Global.DHgroupA);\n\t\tpn.jfkKs = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"0\");\n\t\tpn.jfkKe = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"1\");\n\t\tpn.jfkKa = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"2\");\n\t\tc.initialize(pn.jfkKe);\n\t\tPCFBMode pcfb = PCFBMode.create(c);\n\t\tint ivLength = pcfb.lengthIV();\n\t\tbyte[] iv = new byte[ivLength];\n\t\tnode.random.nextBytes(iv);\n\t\tpcfb.reset(iv);\n\t\tint cleartextOffset = 0;\n\t\tbyte[] cleartext = new byte[JFK_PREFIX_INITIATOR.length + ivLength + Node.SIGNATURE_PARAMETER_LENGTH * 2 + data.length];\n\t\tSystem.arraycopy(JFK_PREFIX_INITIATOR, 0, cleartext, cleartextOffset, JFK_PREFIX_INITIATOR.length);\n\t\tcleartextOffset += JFK_PREFIX_INITIATOR.length;\n\t\tSystem.arraycopy(iv, 0, cleartext, cleartextOffset, ivLength);\n\t\tcleartextOffset += ivLength;\n\t\tSystem.arraycopy(r, 0, cleartext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(s, 0, cleartext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(data, 0, cleartext, cleartextOffset, data.length);\n\t\tcleartextOffset += data.length;\n\t\t\n\t\tint cleartextToEncypherOffset = JFK_PREFIX_INITIATOR.length + ivLength;\n\t\tpcfb.blockEncipher(cleartext, cleartextToEncypherOffset, cleartext.length-cleartextToEncypherOffset);\n\t\t\n\t\t// We compute the HMAC of (prefix + cyphertext) Includes the IV!\n\t\tHMAC mac = new HMAC(SHA256.getInstance());\n\t\tbyte[] hmac = mac.mac(pn.jfkKa, cleartext, HASH_LENGTH);\n\t\t\n\t\t// copy stuffs back to the message\n\t\tSystem.arraycopy(hmac, 0, message3, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\tSystem.arraycopy(iv, 0, message3, offset, ivLength);\n\t\toffset += ivLength;\n\t\tSystem.arraycopy(cleartext, cleartextToEncypherOffset, message3, offset, cleartext.length-cleartextToEncypherOffset);\n\t\t\n\t\t// cache the message\n\t\tsynchronized (authenticatorCache) {\n\t\t\tif(!maybeResetTransientKey())\n\t\t\t\tauthenticatorCache.put(authenticator,message3);\n\t\t}\n\t\tif(unknownInitiator)\n\t\t\tsendAnonAuthPacket(1, 2, 2, setupType, message3, pn, replyTo, pn.anonymousInitiatorSetupCipher);\n\t\telse\n\t\t\tsendAuthPacket(1, 2, 2, message3, pn, replyTo);\n\t\t\n\t\t/* Re-send the packet after 5sec if we don't get any reply */\n\t\tnode.getTicker().queueTimedJob(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tif(pn.timeLastConnected() >= pn.lastReceivedPacketTime()) {\n\t\t\t\t\tif(unknownInitiator)\n\t\t\t\t\t\tsendAnonAuthPacket(1, 2, 2, setupType, message3, pn, replyTo, pn.anonymousInitiatorSetupCipher);\n\t\t\t\t\telse\n\t\t\t\t\t\tsendAuthPacket(1, 2, 2, message3, pn, replyTo);\n\t\t\t\t}\n\t\t\t}\n\t\t}, 5*1000);\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message3 timeout error:Sending packet for\"+pn.getPeer());\n\t}","commit_id":"0f83d0f20db8853feaedae197c7765fff0937db8","url":"https://github.com/freenet/fred"},{"original_method":"private void processJFKMessage4(byte[] payload, int inputOffset, PeerNode pn, Peer replyTo, boolean oldOpennetPeer, boolean unknownInitiator, int setupType)\n\t{\n\t\tfinal long t1 = System.currentTimeMillis();\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(4) message, processing it - \"+pn);\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) {}\n\t\t\n\t\tfinal int expectedLength =\tHASH_LENGTH + // HMAC of the cyphertext\n\t\t\t\t\t\t\t\t\t(c.getBlockSize() >> 3) + // IV\n\t\t\t\t\t\t\t\t\tHASH_LENGTH + // the signature\n\t\t\t\t\t\t\t\t\tpn.jfkMyRef.length\t\t\t  // the bootid + mynoderef\n\t\t\t\t\t\t\t\t\t;\n\t\tif(payload.length < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn+\": \"+payload.length+\" after decryption in JFK(4), should be \"+(expectedLength + 3));\n\t\t\treturn;\n\t\t}\n\t\tbyte[] jfkBuffer = pn.getJFKBuffer();\n\t\tif(jfkBuffer == null) {\n\t\t\tLogger.normal(this, \"We have already handled this message... might be a replay or a bug - \"+pn);\n\t\t\treturn;\n\t\t}\n\n\t\tbyte[] hmac = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, hmac, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\t\t\n\t\tc.initialize(pn.jfkKe);\n\t\tfinal PCFBMode pk = PCFBMode.create(c);\n\t\tint ivLength = pk.lengthIV();\n\t\tint decypheredPayloadOffset = 0;\n\t\t// We compute the HMAC of (\"R\"+cyphertext) : the cyphertext includes the IV!\n\t\tbyte[] decypheredPayload = new byte[JFK_PREFIX_RESPONDER.length + (payload.length-inputOffset)];\n\t\tSystem.arraycopy(JFK_PREFIX_RESPONDER, 0, decypheredPayload, decypheredPayloadOffset, JFK_PREFIX_RESPONDER.length);\n\t\tdecypheredPayloadOffset += JFK_PREFIX_RESPONDER.length;\n\t\tSystem.arraycopy(payload, inputOffset, decypheredPayload, decypheredPayloadOffset, payload.length-inputOffset);\n\t\tHMAC mac = new HMAC(SHA256.getInstance());\n\t\tif(!mac.verify(pn.jfkKa, decypheredPayload, hmac)) {\n\t\t\tLogger.error(this, \"The digest-HMAC doesn't match; let's discard the packet\");\n\t\t\treturn;\n\t\t}\n\t\t// Get the IV\n\t\tpk.reset(decypheredPayload, decypheredPayloadOffset);\n\t\tdecypheredPayloadOffset += ivLength;\n\t\t// Decrypt the payload\n\t\tpk.blockDecipher(decypheredPayload, decypheredPayloadOffset, decypheredPayload.length - decypheredPayloadOffset);\n\t\t/*\n\t\t * DecipheredData Format:\n\t\t * Signature-r,s\n\t\t * bootID, znoderef\n\t\t */\n\t\tbyte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] data = new byte[decypheredPayload.length - decypheredPayloadOffset];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, data, 0, decypheredPayload.length - decypheredPayloadOffset);\n\t\tlong bootID = Fields.bytesToLong(data);\n\t\tbyte[] hisRef = new byte[data.length - pn.jfkMyRef.length - 8];\n\t\tSystem.arraycopy(data, 8, hisRef, 0, hisRef.length);\n\t\t\n\t\t// verify the signature\n\t\tDSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t\tbyte[] locallyGeneratedText = new byte[NONCE_SIZE * 2 + DiffieHellman.modulusLengthInBytes() * 2 + crypto.myIdentity.length + 8 /*bootID*/ + hisRef.length + pn.jfkMyRef.length];\n\t\tint bufferOffset = NONCE_SIZE * 2 + DiffieHellman.modulusLengthInBytes()*2;\n\t\tSystem.arraycopy(jfkBuffer, 0, locallyGeneratedText, 0, bufferOffset);\n\t\tSystem.arraycopy(crypto.myIdentity, 0, locallyGeneratedText, bufferOffset, crypto.myIdentity.length);\n\t\tbufferOffset += crypto.myIdentity.length;\n\t\t// bootID\n\t\tSystem.arraycopy(data, 0, locallyGeneratedText, bufferOffset, data.length - pn.jfkMyRef.length);\n\t\tbufferOffset += data.length - pn.jfkMyRef.length;\n\t\tSystem.arraycopy(pn.jfkMyRef, 0, locallyGeneratedText, bufferOffset, pn.jfkMyRef.length);\n\t\tif(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, SHA256.digest(locallyGeneratedText)), false)) {\n\t\t\tLogger.error(this, \"The signature verification has failed!! JFK(4) -\"+pn);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Promote if necessary\n\t\tboolean dontWant = false;\n\t\tif(oldOpennetPeer) {\n\t\t\tOpennetManager opennet = node.getOpennet();\n\t\t\tif(opennet == null) {\n\t\t\t\tLogger.normal(this, \"Dumping incoming old-opennet peer as opennet just turned off: \"+pn+\".\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(!opennet.wantPeer(pn, true)) {\n\t\t\t\tLogger.normal(this, \"No longer want peer \"+pn+\" - dumping it after connecting\");\n\t\t\t\tdontWant = true;\n\t\t\t}\n\t\t\t// wantPeer will call node.peers.addPeer(), we don't have to.\n\t\t}\n\t\t\n\t\t// We change the key\n\t\tc.initialize(pn.jfkKs);\n\t\tif(pn.completedHandshake(bootID, data, 8, data.length - 8, c, pn.jfkKs, replyTo, false)) {\n\t\t\tif(dontWant)\n\t\t\t\tnode.peers.disconnect(pn, true, false);\n\t\t\telse\n\t\t\t\tpn.maybeSendInitialMessages();\n\t\t} else {\n\t\t\tLogger.error(this, \"Handshake failed!\");\n\t\t}\n\t\t\n\t\t// cleanup\n                // FIXME: maybe we should copy zeros/garbage into it before leaving it to the GC\n\t\tpn.setJFKBuffer(null);\n\t\tpn.jfkKa = null;\n\t\tpn.jfkKe = null;\n\t\tpn.jfkKs = null;\n\t\t// We want to clear it here so that new handshake requests\n\t\t// will be sent with a different DH pair\n\t\tpn.setKeyAgreementSchemeContext(null);\n\t\tsynchronized (pn) {\n\t\t\t// FIXME TRUE MULTI-HOMING: winner-takes-all, kill all other connection attempts since we can't deal with multiple active connections\n\t\t\t// Also avoids leaking\n\t\t\tpn.jfkNoncesSent.clear();\n\t\t}\n\t\t\n\t\tfinal long t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message3 timeout error:Sending packet for\"+pn.getPeer());\n\t}","id":75802,"modified_method":"private void processJFKMessage4(byte[] payload, int inputOffset, PeerNode pn, Peer replyTo, boolean oldOpennetPeer, boolean unknownInitiator, int setupType)\n\t{\n\t\tfinal long t1 = System.currentTimeMillis();\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(4) message, processing it - \"+pn.getPeer());\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) {}\n\t\t\n\t\tfinal int expectedLength =\tHASH_LENGTH + // HMAC of the cyphertext\n\t\t\t\t\t\t\t\t\t(c.getBlockSize() >> 3) + // IV\n\t\t\t\t\t\t\t\t\tHASH_LENGTH + // the signature\n\t\t\t\t\t\t\t\t\tpn.jfkMyRef.length\t\t\t  // the bootid + mynoderef\n\t\t\t\t\t\t\t\t\t;\n\t\tif(payload.length < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn.getPeer()+\": \"+payload.length+\" after decryption in JFK(4), should be \"+(expectedLength + 3));\n\t\t\treturn;\n\t\t}\n\t\tbyte[] jfkBuffer = pn.getJFKBuffer();\n\t\tif(jfkBuffer == null) {\n\t\t\tLogger.normal(this, \"We have already handled this message... might be a replay or a bug - \"+pn);\n\t\t\treturn;\n\t\t}\n\n\t\tbyte[] hmac = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, hmac, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\t\t\n\t\tc.initialize(pn.jfkKe);\n\t\tfinal PCFBMode pk = PCFBMode.create(c);\n\t\tint ivLength = pk.lengthIV();\n\t\tint decypheredPayloadOffset = 0;\n\t\t// We compute the HMAC of (\"R\"+cyphertext) : the cyphertext includes the IV!\n\t\tbyte[] decypheredPayload = new byte[JFK_PREFIX_RESPONDER.length + (payload.length-inputOffset)];\n\t\tSystem.arraycopy(JFK_PREFIX_RESPONDER, 0, decypheredPayload, decypheredPayloadOffset, JFK_PREFIX_RESPONDER.length);\n\t\tdecypheredPayloadOffset += JFK_PREFIX_RESPONDER.length;\n\t\tSystem.arraycopy(payload, inputOffset, decypheredPayload, decypheredPayloadOffset, payload.length-inputOffset);\n\t\tHMAC mac = new HMAC(SHA256.getInstance());\n\t\tif(!mac.verify(pn.jfkKa, decypheredPayload, hmac)) {\n\t\t\tLogger.normal(this, \"The digest-HMAC doesn't match; let's discard the packet - \"+pn.getPeer());\n\t\t\treturn;\n\t\t}\n\t\t// Get the IV\n\t\tpk.reset(decypheredPayload, decypheredPayloadOffset);\n\t\tdecypheredPayloadOffset += ivLength;\n\t\t// Decrypt the payload\n\t\tpk.blockDecipher(decypheredPayload, decypheredPayloadOffset, decypheredPayload.length - decypheredPayloadOffset);\n\t\t/*\n\t\t * DecipheredData Format:\n\t\t * Signature-r,s\n\t\t * bootID, znoderef\n\t\t */\n\t\tbyte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] data = new byte[decypheredPayload.length - decypheredPayloadOffset];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, data, 0, decypheredPayload.length - decypheredPayloadOffset);\n\t\tlong bootID = Fields.bytesToLong(data);\n\t\tbyte[] hisRef = new byte[data.length - pn.jfkMyRef.length - 8];\n\t\tSystem.arraycopy(data, 8, hisRef, 0, hisRef.length);\n\t\t\n\t\t// verify the signature\n\t\tDSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t\tbyte[] locallyGeneratedText = new byte[NONCE_SIZE * 2 + DiffieHellman.modulusLengthInBytes() * 2 + crypto.myIdentity.length + 8 /*bootID*/ + hisRef.length + pn.jfkMyRef.length];\n\t\tint bufferOffset = NONCE_SIZE * 2 + DiffieHellman.modulusLengthInBytes()*2;\n\t\tSystem.arraycopy(jfkBuffer, 0, locallyGeneratedText, 0, bufferOffset);\n\t\tSystem.arraycopy(crypto.myIdentity, 0, locallyGeneratedText, bufferOffset, crypto.myIdentity.length);\n\t\tbufferOffset += crypto.myIdentity.length;\n\t\t// bootID\n\t\tSystem.arraycopy(data, 0, locallyGeneratedText, bufferOffset, data.length - pn.jfkMyRef.length);\n\t\tbufferOffset += data.length - pn.jfkMyRef.length;\n\t\tSystem.arraycopy(pn.jfkMyRef, 0, locallyGeneratedText, bufferOffset, pn.jfkMyRef.length);\n\t\tif(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, SHA256.digest(locallyGeneratedText)), false)) {\n\t\t\tLogger.error(this, \"The signature verification has failed!! JFK(4) -\"+pn.getPeer());\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Promote if necessary\n\t\tboolean dontWant = false;\n\t\tif(oldOpennetPeer) {\n\t\t\tOpennetManager opennet = node.getOpennet();\n\t\t\tif(opennet == null) {\n\t\t\t\tLogger.normal(this, \"Dumping incoming old-opennet peer as opennet just turned off: \"+pn+\".\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(!opennet.wantPeer(pn, true)) {\n\t\t\t\tLogger.normal(this, \"No longer want peer \"+pn+\" - dumping it after connecting\");\n\t\t\t\tdontWant = true;\n\t\t\t}\n\t\t\t// wantPeer will call node.peers.addPeer(), we don't have to.\n\t\t}\n\t\t\n\t\t// We change the key\n\t\tc.initialize(pn.jfkKs);\n\t\tif(pn.completedHandshake(bootID, data, 8, data.length - 8, c, pn.jfkKs, replyTo, false)) {\n\t\t\tif(dontWant)\n\t\t\t\tnode.peers.disconnect(pn, true, false);\n\t\t\telse\n\t\t\t\tpn.maybeSendInitialMessages();\n\t\t} else {\n\t\t\tLogger.error(this, \"Handshake failed!\");\n\t\t}\n\t\t\n\t\t// cleanup\n                // FIXME: maybe we should copy zeros/garbage into it before leaving it to the GC\n\t\tpn.setJFKBuffer(null);\n\t\tpn.jfkKa = null;\n\t\tpn.jfkKe = null;\n\t\tpn.jfkKs = null;\n\t\t// We want to clear it here so that new handshake requests\n\t\t// will be sent with a different DH pair\n\t\tpn.setKeyAgreementSchemeContext(null);\n\t\tsynchronized (pn) {\n\t\t\t// FIXME TRUE MULTI-HOMING: winner-takes-all, kill all other connection attempts since we can't deal with multiple active connections\n\t\t\t// Also avoids leaking\n\t\t\tpn.jfkNoncesSent.clear();\n\t\t}\n\t\t\n\t\tfinal long t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message4 timeout error:Processing packet from \"+pn.getPeer());\n\t}","commit_id":"0f83d0f20db8853feaedae197c7765fff0937db8","url":"https://github.com/freenet/fred"},{"original_method":"private void processJFKMessage3(byte[] payload, int inputOffset, PeerNode pn,Peer replyTo, boolean oldOpennetPeer, boolean unknownInitiator, int setupType)\n\t{\n\t\tfinal long t1 = System.currentTimeMillis();\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(3) message, processing it - \"+pn);\n\t\t\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) {}\n\t\t\n\t\tfinal int expectedLength =\tNONCE_SIZE*2 + DiffieHellman.modulusLengthInBytes()*2 +\n\t\t\t\t\t\t\t\t\tHASH_LENGTH + // authenticator\n\t\t\t\t\t\t\t\t\tHASH_LENGTH + // HMAC of the cyphertext\n\t\t\t\t\t\t\t\t\t(c.getBlockSize() >> 3) + // IV\n\t\t\t\t\t\t\t\t\tHASH_LENGTH + // it's at least a signature\n\t\t\t\t\t\t\t\t\t8;\t\t\t  // a bootid\n\t\tif(payload.length < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn+\": \"+payload.length+\" after decryption in JFK(3), should be \"+(expectedLength + 3));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Ni\n\t\tbyte[] nonceInitiator = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceInitiator, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\t// Nr\n\t\tbyte[] nonceResponder = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceResponder, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\t// g^i\n\t\tbyte[] initiatorExponential = new byte[DiffieHellman.modulusLengthInBytes()];\n\t\tSystem.arraycopy(payload, inputOffset, initiatorExponential, 0, DiffieHellman.modulusLengthInBytes());\n\t\tinputOffset += DiffieHellman.modulusLengthInBytes();\n\t\t// g^r\n\t\tbyte[] responderExponential = new byte[DiffieHellman.modulusLengthInBytes()];\n\t\tSystem.arraycopy(payload, inputOffset, responderExponential, 0, DiffieHellman.modulusLengthInBytes());\n\t\tinputOffset += DiffieHellman.modulusLengthInBytes();\n\t\t\n\t\tbyte[] authenticator = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, authenticator, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\n\t\t// FIXME: check the cache before or after the hmac verification ?\n\t\t// is it cheaper to wait for the lock on authenticatorCache or to verify the hmac ?\n\t\tHMAC mac = new HMAC(SHA256.getInstance());\n\t\tif(!mac.verify(getTransientKey(), assembleJFKAuthenticator(responderExponential, initiatorExponential, nonceResponder, nonceInitiator, replyTo.getAddress().getAddress()) , authenticator)) {\n\t\t\tLogger.error(this, \"The HMAC doesn't match; let's discard the packet (either we rekeyed or we are victim of forgery) - JFK3\");\n\t\t\treturn;\n\t\t}\n\t\t// Check try to find the authenticator in the cache.\n\t\t// If authenticator is already present, indicates duplicate/replayed message3\n\t\t// Now simply transmit the corresponding message4\n\t\tObject message4 = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tmessage4 = authenticatorCache.get(authenticator);\n\t\t}\n\t\tif(message4 != null) {\n\t\t\tLogger.normal(this, \"We replayed a message from the cache (shouldn't happen often) - \"+pn);\n\t\t\tsendAuthPacket(1, 2, 3, (byte[]) message4, pn, replyTo);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1, initiatorExponential);\n\t\tNativeBigInteger _ourExponential = new NativeBigInteger(1, responderExponential);\n\t\t\n\t\tbyte[] hmac = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, hmac, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\t\t\n\t\tDiffieHellmanLightContext ctx = findContextByExponential(_ourExponential);\n\t\tif(ctx == null) {\n\t\t\tLogger.error(this, \"WTF? the HMAC verified but we don't know about that exponential! SHOULDN'T HAPPEN! - JFK4\");\n\t\t\treturn;\n\t\t}\n\t\tBigInteger computedExponential = ctx.getHMACKey(_hisExponential, Global.DHgroupA);\n\t\tbyte[] Ks = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"0\");\n\t\tbyte[] Ke = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"1\");\n\t\tbyte[] Ka = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"2\");\n\t\tc.initialize(Ke);\n\t\tfinal PCFBMode pk = PCFBMode.create(c);\n\t\tint ivLength = pk.lengthIV();\n\t\tint decypheredPayloadOffset = 0;\n\t\t// We compute the HMAC of (\"I\"+cyphertext) : the cyphertext includes the IV!\n\t\tbyte[] decypheredPayload = new byte[JFK_PREFIX_INITIATOR.length + payload.length - inputOffset];\n\t\tSystem.arraycopy(JFK_PREFIX_INITIATOR, 0, decypheredPayload, decypheredPayloadOffset, JFK_PREFIX_INITIATOR.length);\n\t\tdecypheredPayloadOffset += JFK_PREFIX_INITIATOR.length;\n\t\tSystem.arraycopy(payload, inputOffset, decypheredPayload, decypheredPayloadOffset, decypheredPayload.length-decypheredPayloadOffset);\n\t\tif(!mac.verify(Ka, decypheredPayload, hmac)) {\n\t\t\tLogger.error(this, \"The digest-HMAC doesn't match; let's discard the packet JFK(3) - \"+pn);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Get the IV\n\t\tpk.reset(decypheredPayload, decypheredPayloadOffset);\n\t\tdecypheredPayloadOffset += ivLength;\n\t\t// Decrypt the payload\n\t\tpk.blockDecipher(decypheredPayload, decypheredPayloadOffset, decypheredPayload.length-decypheredPayloadOffset);\n\t\t/*\n\t\t * DecipheredData Format:\n\t\t * Signature-r,s\n\t\t * Node Data (starting with BootID)\n\t\t */\n\t\tbyte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] data = new byte[decypheredPayload.length - decypheredPayloadOffset];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, data, 0, decypheredPayload.length - decypheredPayloadOffset);\n\t\tlong bootID = Fields.bytesToLong(data);\n\t\tbyte[] hisRef = new byte[data.length -8];\n\t\tSystem.arraycopy(data, 8, hisRef, 0, hisRef.length);\n\t\t\n\t\t// construct the peernode\n\t\tif(unknownInitiator) {\n\t\t\tpn = getPeerNodeFromUnknownInitiator(hisRef, setupType, pn);\n\t\t}\n\t\t\n\t\tif(pn == null) {\n\t\t\t// Reject\n\t\t\tLogger.normal(this, \"Rejecting...\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// verify the signature\n\t\tDSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s)); \n\t\tif(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, SHA256.digest(assembleDHParams(nonceInitiator, nonceResponder, _hisExponential, _ourExponential, crypto.myIdentity, data))), false)) {\n\t\t\tLogger.error(this, \"The signature verification has failed!! JFK(3) - \"+pn);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// At this point we know it's from the peer, so we can report a packet received.\n\t\tpn.receivedPacket(true);\n\t\t\n\t\t// Send reply\n\t\tsendJFKMessage4(1, 2, 3, nonceInitiator, nonceResponder,initiatorExponential, responderExponential, c, Ke, Ka, authenticator, hisRef, pn, replyTo, unknownInitiator, setupType);\n\t\tc.initialize(Ks);\n\t\t\n\t\t// Promote if necessary\n\t\tboolean dontWant = false;\n\t\tif(oldOpennetPeer) {\n\t\t\tOpennetManager opennet = node.getOpennet();\n\t\t\tif(opennet == null) {\n\t\t\t\tLogger.normal(this, \"Dumping incoming old-opennet peer as opennet just turned off: \"+pn+\".\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(!opennet.wantPeer(pn, true)) {\n\t\t\t\tLogger.normal(this, \"No longer want peer \"+pn+\" - dumping it after connecting\");\n\t\t\t\tdontWant = true;\n\t\t\t}\n\t\t\t// wantPeer will call node.peers.addPeer(), we don't have to.\n\t\t}\n\t\t\n\t\tif(pn.completedHandshake(bootID, hisRef, 0, hisRef.length, c, Ks, replyTo, true)) {\n\t\t\tif(dontWant)\n\t\t\t\tnode.peers.disconnect(pn, true, false);\n\t\t\telse\n\t\t\t\tpn.maybeSendInitialMessages();\n\t\t} else {\n\t\t\tLogger.error(this, \"Handshake failure! with \"+pn);\n\t\t}\n\t\t\n\t\tfinal long t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message3 Sending packet for\"+pn.getPeer()+\" took \"+TimeUtil.formatTime(t2-t1, 3, true));\n\t}","id":75803,"modified_method":"private void processJFKMessage3(byte[] payload, int inputOffset, PeerNode pn,Peer replyTo, boolean oldOpennetPeer, boolean unknownInitiator, int setupType)\n\t{\n\t\tfinal long t1 = System.currentTimeMillis();\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(3) message, processing it - \"+pn.getPeer());\n\t\t\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) {}\n\t\t\n\t\tfinal int expectedLength =\tNONCE_SIZE*2 + DiffieHellman.modulusLengthInBytes()*2 +\n\t\t\t\t\t\t\t\t\tHASH_LENGTH + // authenticator\n\t\t\t\t\t\t\t\t\tHASH_LENGTH + // HMAC of the cyphertext\n\t\t\t\t\t\t\t\t\t(c.getBlockSize() >> 3) + // IV\n\t\t\t\t\t\t\t\t\tHASH_LENGTH + // it's at least a signature\n\t\t\t\t\t\t\t\t\t8;\t\t\t  // a bootid\n\t\tif(payload.length < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn.getPeer()+\": \"+payload.length+\" after decryption in JFK(3), should be \"+(expectedLength + 3));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Ni\n\t\tbyte[] nonceInitiator = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceInitiator, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\t// Nr\n\t\tbyte[] nonceResponder = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceResponder, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\t// g^i\n\t\tbyte[] initiatorExponential = new byte[DiffieHellman.modulusLengthInBytes()];\n\t\tSystem.arraycopy(payload, inputOffset, initiatorExponential, 0, DiffieHellman.modulusLengthInBytes());\n\t\tinputOffset += DiffieHellman.modulusLengthInBytes();\n\t\t// g^r\n\t\tbyte[] responderExponential = new byte[DiffieHellman.modulusLengthInBytes()];\n\t\tSystem.arraycopy(payload, inputOffset, responderExponential, 0, DiffieHellman.modulusLengthInBytes());\n\t\tinputOffset += DiffieHellman.modulusLengthInBytes();\n\t\t\n\t\tbyte[] authenticator = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, authenticator, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\n\t\t// FIXME: check the cache before or after the hmac verification ?\n\t\t// is it cheaper to wait for the lock on authenticatorCache or to verify the hmac ?\n\t\tHMAC mac = new HMAC(SHA256.getInstance());\n\t\tif(!mac.verify(getTransientKey(), assembleJFKAuthenticator(responderExponential, initiatorExponential, nonceResponder, nonceInitiator, replyTo.getAddress().getAddress()) , authenticator)) {\n\t\t\tif(shouldLogErrorInHandshake(t1))\n\t\t\t\tLogger.normal(this, \"The HMAC doesn't match; let's discard the packet (either we rekeyed or we are victim of forgery) - JFK3 - \"+pn.getPeer());\n\t\t\treturn;\n\t\t}\n\t\t// Check try to find the authenticator in the cache.\n\t\t// If authenticator is already present, indicates duplicate/replayed message3\n\t\t// Now simply transmit the corresponding message4\n\t\tObject message4 = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tmessage4 = authenticatorCache.get(authenticator);\n\t\t}\n\t\tif(message4 != null) {\n\t\t\tLogger.normal(this, \"We replayed a message from the cache (shouldn't happen often) - \"+pn.getPeer());\n\t\t\tsendAuthPacket(1, 2, 3, (byte[]) message4, pn, replyTo);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1, initiatorExponential);\n\t\tNativeBigInteger _ourExponential = new NativeBigInteger(1, responderExponential);\n\t\t\n\t\tbyte[] hmac = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, hmac, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\t\t\n\t\tDiffieHellmanLightContext ctx = findContextByExponential(_ourExponential);\n\t\tif(ctx == null) {\n\t\t\tLogger.error(this, \"WTF? the HMAC verified but we don't know about that exponential! SHOULDN'T HAPPEN! - JFK3 - \"+pn.getPeer());\n\t\t\treturn;\n\t\t}\n\t\tBigInteger computedExponential = ctx.getHMACKey(_hisExponential, Global.DHgroupA);\n\t\tbyte[] Ks = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"0\");\n\t\tbyte[] Ke = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"1\");\n\t\tbyte[] Ka = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"2\");\n\t\tc.initialize(Ke);\n\t\tfinal PCFBMode pk = PCFBMode.create(c);\n\t\tint ivLength = pk.lengthIV();\n\t\tint decypheredPayloadOffset = 0;\n\t\t// We compute the HMAC of (\"I\"+cyphertext) : the cyphertext includes the IV!\n\t\tbyte[] decypheredPayload = new byte[JFK_PREFIX_INITIATOR.length + payload.length - inputOffset];\n\t\tSystem.arraycopy(JFK_PREFIX_INITIATOR, 0, decypheredPayload, decypheredPayloadOffset, JFK_PREFIX_INITIATOR.length);\n\t\tdecypheredPayloadOffset += JFK_PREFIX_INITIATOR.length;\n\t\tSystem.arraycopy(payload, inputOffset, decypheredPayload, decypheredPayloadOffset, decypheredPayload.length-decypheredPayloadOffset);\n\t\tif(!mac.verify(Ka, decypheredPayload, hmac)) {\n\t\t\tLogger.error(this, \"The inner-HMAC doesn't match; let's discard the packet JFK(3) - \"+pn.getPeer());\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Get the IV\n\t\tpk.reset(decypheredPayload, decypheredPayloadOffset);\n\t\tdecypheredPayloadOffset += ivLength;\n\t\t// Decrypt the payload\n\t\tpk.blockDecipher(decypheredPayload, decypheredPayloadOffset, decypheredPayload.length-decypheredPayloadOffset);\n\t\t/*\n\t\t * DecipheredData Format:\n\t\t * Signature-r,s\n\t\t * Node Data (starting with BootID)\n\t\t */\n\t\tbyte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] data = new byte[decypheredPayload.length - decypheredPayloadOffset];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, data, 0, decypheredPayload.length - decypheredPayloadOffset);\n\t\tlong bootID = Fields.bytesToLong(data);\n\t\tbyte[] hisRef = new byte[data.length -8];\n\t\tSystem.arraycopy(data, 8, hisRef, 0, hisRef.length);\n\t\t\n\t\t// construct the peernode\n\t\tif(unknownInitiator) {\n\t\t\tpn = getPeerNodeFromUnknownInitiator(hisRef, setupType, pn);\n\t\t}\n\t\t\n\t\tif(pn == null) {\n\t\t\t// Reject\n\t\t\tLogger.normal(this, \"Rejecting...\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// verify the signature\n\t\tDSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s)); \n\t\tif(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, SHA256.digest(assembleDHParams(nonceInitiator, nonceResponder, _hisExponential, _ourExponential, crypto.myIdentity, data))), false)) {\n\t\t\tLogger.error(this, \"The signature verification has failed!! JFK(3) - \"+pn.getPeer());\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// At this point we know it's from the peer, so we can report a packet received.\n\t\tpn.receivedPacket(true);\n\t\t\n\t\t// Send reply\n\t\tsendJFKMessage4(1, 2, 3, nonceInitiator, nonceResponder,initiatorExponential, responderExponential, c, Ke, Ka, authenticator, hisRef, pn, replyTo, unknownInitiator, setupType);\n\t\tc.initialize(Ks);\n\t\t\n\t\t// Promote if necessary\n\t\tboolean dontWant = false;\n\t\tif(oldOpennetPeer) {\n\t\t\tOpennetManager opennet = node.getOpennet();\n\t\t\tif(opennet == null) {\n\t\t\t\tLogger.normal(this, \"Dumping incoming old-opennet peer as opennet just turned off: \"+pn+\".\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(!opennet.wantPeer(pn, true)) {\n\t\t\t\tLogger.normal(this, \"No longer want peer \"+pn+\" - dumping it after connecting\");\n\t\t\t\tdontWant = true;\n\t\t\t}\n\t\t\t// wantPeer will call node.peers.addPeer(), we don't have to.\n\t\t}\n\t\t\n\t\tif(pn.completedHandshake(bootID, hisRef, 0, hisRef.length, c, Ks, replyTo, true)) {\n\t\t\tif(dontWant)\n\t\t\t\tnode.peers.disconnect(pn, true, false);\n\t\t\telse\n\t\t\t\tpn.maybeSendInitialMessages();\n\t\t} else {\n\t\t\tLogger.error(this, \"Handshake failure! with \"+pn.getPeer());\n\t\t}\n\t\t\n\t\tfinal long t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message3 Processing packet for\"+pn.getPeer()+\" took \"+TimeUtil.formatTime(t2-t1, 3, true));\n\t}","commit_id":"0f83d0f20db8853feaedae197c7765fff0937db8","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Try to process an incoming packet with a given PeerNode.\n\t * We need to know where the packet has come from in order to\n\t * decrypt and authenticate it.\n\t */\n\tprivate boolean tryProcess(byte[] buf, int offset, int length, KeyTracker tracker, long now) {\n\t\t// Need to be able to call with tracker == null to simplify code above\n\t\tif(tracker == null) {\n\t\t\tif(Logger.shouldLog(Logger.DEBUG, this)) Logger.debug(this, \"Tracker == null\");\n\t\t\treturn false;\n\t\t}\n\t\tif(logMINOR) Logger.minor(this,\"Entering tryProcess: \"+Fields.hashCode(buf)+ ',' +offset+ ',' +length+ ',' +tracker);\n\t\t/**\n\t\t * E_pcbc_session(H(seq+random+data)) E_pcfb_session(seq+random+data)\n\t\t * \n\t\t * So first two blocks are the hash, PCBC encoded (meaning the\n\t\t * first one is ECB, and the second one is ECB XORed with the \n\t\t * ciphertext and plaintext of the first block).\n\t\t */\n\t\tBlockCipher sessionCipher = tracker.sessionCipher;\n\t\tif(sessionCipher == null) {\n\t\t\tif(logMINOR) Logger.minor(this, \"No cipher\");\n\t\t\treturn false;\n\t\t}\n\t\tif(logMINOR) Logger.minor(this, \"Decrypting with \"+HexUtil.bytesToHex(tracker.sessionKey));\n\t\tint blockSize = sessionCipher.getBlockSize() >> 3;\n\t\tif(sessionCipher.getKeySize() != sessionCipher.getBlockSize())\n\t\t\tthrow new IllegalStateException(\"Block size must be equal to key size\");\n\n\t\tif(HASH_LENGTH != blockSize)\n\t\t\tthrow new IllegalStateException(\"Block size must be digest length!\");\n\n\t\tbyte[] packetHash = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(buf, offset, packetHash, 0, HASH_LENGTH);\n\n\t\t// Decrypt the sequence number and see if it's plausible\n\t\t// Verify the hash later\n\n\t\tPCFBMode pcfb;\n\t\tpcfb = PCFBMode.create(sessionCipher);\n\t\t// Set IV to the hash, after it is encrypted\n\t\tpcfb.reset(packetHash);\n\t\t//Logger.minor(this,\"IV:\\n\"+HexUtil.bytesToHex(packetHash));\n\n\t\tbyte[] seqBuf = new byte[4];\n\t\tSystem.arraycopy(buf, offset+HASH_LENGTH, seqBuf, 0, 4);\n\t\t//Logger.minor(this, \"Encypted sequence number: \"+HexUtil.bytesToHex(seqBuf));\n\t\tpcfb.blockDecipher(seqBuf, 0, 4);\n\t\t//Logger.minor(this, \"Decrypted sequence number: \"+HexUtil.bytesToHex(seqBuf));\n\n\t\tint seqNumber = ((((((seqBuf[0] & 0xff) << 8)\n\t\t\t\t+ (seqBuf[1] & 0xff)) << 8) + \n\t\t\t\t(seqBuf[2] & 0xff)) << 8) +\n\t\t\t\t(seqBuf[3] & 0xff);\n\n\t\tint targetSeqNumber = tracker.highestReceivedIncomingSeqNumber();\n\t\tif(logMINOR) Logger.minor(this, \"Seqno: \"+seqNumber+\" (highest seen \"+targetSeqNumber+\") receiving packet from \"+tracker.pn.getPeer());\n\n\t\tif(seqNumber == -1) {\n\t\t\t// Ack/resendreq-only packet\n\t\t} else {\n\t\t\t// Now is it credible?\n\t\t\t// As long as it's within +/- 256, this is valid.\n\t\t\tif((targetSeqNumber != -1) && (Math.abs(targetSeqNumber - seqNumber) > MAX_PACKETS_IN_FLIGHT))\n\t\t\t\treturn false;\n\t\t}\n\t\tif(logMINOR) Logger.minor(this, \"Sequence number received: \"+seqNumber);\n\n\t\t// Plausible, so lets decrypt the rest of the data\n\n\t\tbyte[] plaintext = new byte[length-(4+HASH_LENGTH)];\n\t\tSystem.arraycopy(buf, offset+HASH_LENGTH+4, plaintext, 0, length-(HASH_LENGTH+4));\n\n\t\tpcfb.blockDecipher(plaintext, 0, length-(HASH_LENGTH+4));\n\n\t\t//Logger.minor(this, \"Plaintext:\\n\"+HexUtil.bytesToHex(plaintext));\n\n\t\tMessageDigest md = SHA256.getMessageDigest();\n\t\tmd.update(seqBuf);\n\t\tmd.update(plaintext);\n\t\tbyte[] realHash = md.digest();\n\t\tSHA256.returnMessageDigest(md); md = null;\n\n\t\t// Now decrypt the original hash\n\n\t\tbyte[] temp = new byte[blockSize];\n\t\tSystem.arraycopy(buf, offset, temp, 0, blockSize);\n\t\tsessionCipher.decipher(temp, temp);\n\t\tSystem.arraycopy(temp, 0, packetHash, 0, blockSize);\n\n\t\t// Check the hash\n\t\tif(!Arrays.equals(packetHash, realHash)) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Packet possibly from \"+tracker+\" hash does not match:\\npacketHash=\"+\n\t\t\t\t\tHexUtil.bytesToHex(packetHash)+\"\\n  realHash=\"+HexUtil.bytesToHex(realHash)+\" (\"+(length-HASH_LENGTH)+\" bytes payload)\");\n\t\t\treturn false;\n\t\t}\n\n\t\t// Verify\n\t\ttracker.pn.verified(tracker);\n\n\t\tfor(int i=0;i<HASH_LENGTH;i++) {\n\t\t\tpacketHash[i] ^= buf[offset+i];\n\t\t}\n\t\tif(logMINOR) Logger.minor(this, \"Contributing entropy\");\n\t\tnode.random.acceptEntropyBytes(myPacketDataSource, packetHash, 0, HASH_LENGTH, 0.5);\n\t\tif(logMINOR) Logger.minor(this, \"Contributed entropy\");\n\n\t\t// Lots more to do yet!\n\t\tprocessDecryptedData(plaintext, seqNumber, tracker, length - plaintext.length);\n\t\ttracker.pn.reportIncomingPacket(buf, offset, length, now);\n\t\treturn true;\n\t}","id":75804,"modified_method":"/**\n\t * Should we log an error for an event that could easily be\n\t * caused by a handshake across a restart boundary?\n\t */\t\n\tprivate boolean shouldLogErrorInHandshake(long now) {\n\t\tif(now - node.startupTime < Node.HANDSHAKE_TIMEOUT*2)\n\t\t\treturn false;\n\t\treturn true;\n\t}","commit_id":"0f83d0f20db8853feaedae197c7765fff0937db8","url":"https://github.com/freenet/fred"},{"original_method":"private void sendJFKMessage1(PeerNode pn, Peer replyTo, boolean unknownInitiator, int setupType) {\n\t\tif(logMINOR) Logger.minor(this, \"Sending a JFK(1) message to \"+replyTo+\" for \"+pn);\n\t\tfinal long now = System.currentTimeMillis();\n\t\tDiffieHellmanLightContext ctx = (DiffieHellmanLightContext) pn.getKeyAgreementSchemeContext();\n\t\tif((ctx == null) || ((pn.jfkContextLifetime + DH_GENERATION_INTERVAL*DH_CONTEXT_BUFFER_SIZE) < now)) {\n\t\t\tpn.jfkContextLifetime = now;\n\t\t\tpn.setKeyAgreementSchemeContext(ctx = getLightDiffieHellmanContext());\n\t\t}\n\t\tint offset = 0;\n\t\tbyte[] myExponential = stripBigIntegerToNetworkFormat(ctx.myExponential);\n\t\tbyte[] nonce = new byte[NONCE_SIZE];\n\t\tnode.random.nextBytes(nonce);\n\t\t\n\t\tsynchronized (pn) {\n\t\t\tpn.jfkNoncesSent.put(replyTo, nonce);\n\t\t}\n\t\t\n\t\tint modulusLength = DiffieHellman.modulusLengthInBytes();\n\t\tbyte[] message1 = new byte[NONCE_SIZE+modulusLength+(unknownInitiator ? NodeCrypto.IDENTITY_LENGTH : 0)];\n\n\t\tSystem.arraycopy(nonce, 0, message1, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\tSystem.arraycopy(myExponential, 0, message1, offset, modulusLength);\n\t\t\n\t\tif(unknownInitiator) {\n\t\t\toffset += modulusLength;\n\t\t\tSystem.arraycopy(pn.identityHash, 0, message1, offset, pn.identityHash.length);\n\t\t\tsendAnonAuthPacket(1,2,0,setupType,message1,pn,replyTo,pn.anonymousInitiatorSetupCipher);\n\t\t} else {\n\t\t\tsendAuthPacket(1,2,0,message1,pn,replyTo);\n\t\t}\n\t}","id":75805,"modified_method":"private void sendJFKMessage1(PeerNode pn, Peer replyTo, boolean unknownInitiator, int setupType) {\n\t\tif(logMINOR) Logger.minor(this, \"Sending a JFK(1) message to \"+replyTo+\" for \"+pn.getPeer());\n\t\tfinal long now = System.currentTimeMillis();\n\t\tDiffieHellmanLightContext ctx = (DiffieHellmanLightContext) pn.getKeyAgreementSchemeContext();\n\t\tif((ctx == null) || ((pn.jfkContextLifetime + DH_GENERATION_INTERVAL*DH_CONTEXT_BUFFER_SIZE) < now)) {\n\t\t\tpn.jfkContextLifetime = now;\n\t\t\tpn.setKeyAgreementSchemeContext(ctx = getLightDiffieHellmanContext());\n\t\t}\n\t\tint offset = 0;\n\t\tbyte[] myExponential = stripBigIntegerToNetworkFormat(ctx.myExponential);\n\t\tbyte[] nonce = new byte[NONCE_SIZE];\n\t\tnode.random.nextBytes(nonce);\n\t\t\n\t\tsynchronized (pn) {\n\t\t\tpn.jfkNoncesSent.put(replyTo, nonce);\n\t\t}\n\t\t\n\t\tint modulusLength = DiffieHellman.modulusLengthInBytes();\n\t\tbyte[] message1 = new byte[NONCE_SIZE+modulusLength+(unknownInitiator ? NodeCrypto.IDENTITY_LENGTH : 0)];\n\n\t\tSystem.arraycopy(nonce, 0, message1, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\tSystem.arraycopy(myExponential, 0, message1, offset, modulusLength);\n\t\t\n\t\tif(unknownInitiator) {\n\t\t\toffset += modulusLength;\n\t\t\tSystem.arraycopy(pn.identityHash, 0, message1, offset, pn.identityHash.length);\n\t\t\tsendAnonAuthPacket(1,2,0,setupType,message1,pn,replyTo,pn.anonymousInitiatorSetupCipher);\n\t\t} else {\n\t\t\tsendAuthPacket(1,2,0,message1,pn,replyTo);\n\t\t}\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-now)>500)\n\t\t\tLogger.error(this,\"Message1 timeout error:Sending packet for\"+pn.getPeer());\n\t}","commit_id":"0f83d0f20db8853feaedae197c7765fff0937db8","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n    public void initialize(NodeBuilder builder) {\n        builder.setProperty(JCR_PRIMARYTYPE, NT_REP_ROOT, Type.NAME);\n\n        if (!builder.hasChildNode(JCR_SYSTEM)) {\n            NodeBuilder system = builder.child(JCR_SYSTEM);\n            system.setProperty(JCR_PRIMARYTYPE, NT_REP_SYSTEM, Type.NAME);\n\n            system.child(JCR_VERSIONSTORAGE)\n                    .setProperty(JCR_PRIMARYTYPE, VersionConstants.REP_VERSIONSTORAGE, Type.NAME);\n            system.child(JCR_NODE_TYPES)\n                    .setProperty(JCR_PRIMARYTYPE, NT_REP_NODE_TYPES, Type.NAME);\n            system.child(VersionConstants.JCR_ACTIVITIES)\n                    .setProperty(JCR_PRIMARYTYPE, VersionConstants.REP_ACTIVITIES, Type.NAME);\n        }\n\n        if (!builder.hasChildNode(IndexConstants.INDEX_DEFINITIONS_NAME)) {\n            NodeBuilder index = IndexUtils.getOrCreateOakIndex(builder);\n\n            IndexUtils.createIndexDefinition(index, \"uuid\", true, true,\n                    ImmutableList.<String>of(JCR_UUID), null);\n            NodeBuilder nt = \n                    IndexUtils.createIndexDefinition(index, \"nodetype\", true, false,\n                    ImmutableList.of(JCR_PRIMARYTYPE, JCR_MIXINTYPES), null);\n            // the cost of using the property index for \"@primaryType is not null\" is very high\n            nt.setProperty(IndexConstants.ENTRY_COUNT_PROPERTY_NAME, Long.valueOf(Long.MAX_VALUE));\n        }\n\n        NodeState base = builder.getNodeState();\n        NodeStore store = new MemoryNodeStore(base);\n        BuiltInNodeTypes.register(new SystemRoot(\n                store, new EditorHook(new RegistrationEditorProvider())));\n        NodeState target = store.getRoot();\n        target.compareAgainstBaseState(base, new ApplyDiff(builder));\n    }","id":75806,"modified_method":"@Override\n    public void initialize(NodeBuilder builder) {\n        builder.setProperty(JCR_PRIMARYTYPE, NT_REP_ROOT, Type.NAME);\n\n        if (!builder.hasChildNode(JCR_SYSTEM)) {\n            NodeBuilder system = builder.child(JCR_SYSTEM);\n            system.setProperty(JCR_PRIMARYTYPE, NT_REP_SYSTEM, Type.NAME);\n\n            system.child(JCR_VERSIONSTORAGE)\n                    .setProperty(JCR_PRIMARYTYPE, VersionConstants.REP_VERSIONSTORAGE, Type.NAME);\n            system.child(JCR_NODE_TYPES)\n                    .setProperty(JCR_PRIMARYTYPE, NT_REP_NODE_TYPES, Type.NAME);\n            system.child(VersionConstants.JCR_ACTIVITIES)\n                    .setProperty(JCR_PRIMARYTYPE, VersionConstants.REP_ACTIVITIES, Type.NAME);\n\n            Namespaces.setupNamespaces(system);\n        }\n\n        if (!builder.hasChildNode(IndexConstants.INDEX_DEFINITIONS_NAME)) {\n            NodeBuilder index = IndexUtils.getOrCreateOakIndex(builder);\n\n            IndexUtils.createIndexDefinition(index, \"uuid\", true, true,\n                    ImmutableList.<String>of(JCR_UUID), null);\n            NodeBuilder nt = \n                    IndexUtils.createIndexDefinition(index, \"nodetype\", true, false,\n                    ImmutableList.of(JCR_PRIMARYTYPE, JCR_MIXINTYPES), null);\n            // the cost of using the property index for \"@primaryType is not null\" is very high\n            nt.setProperty(IndexConstants.ENTRY_COUNT_PROPERTY_NAME, Long.valueOf(Long.MAX_VALUE));\n        }\n\n        NodeState base = builder.getNodeState();\n        NodeStore store = new MemoryNodeStore(base);\n        BuiltInNodeTypes.register(new SystemRoot(store, new EditorHook(\n                new CompositeEditorProvider(new NamespaceValidatorProvider(),\n                        new RegistrationEditorProvider()))));\n        NodeState target = store.getRoot();\n        target.compareAgainstBaseState(base, new ApplyDiff(builder));\n    }","commit_id":"d7878aa320b34550511fb2c25da58e5b154711ea","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"protected void checkValidName(String name) throws CommitFailedException {\n        int colon = name.indexOf(':');\n        if (colon > 0) {\n            String prefix = name.substring(0, colon);\n            if (prefix.isEmpty() || !prefixes.contains(prefix)) {\n                throw new CommitFailedException(\n                        CommitFailedException.NAME, 1, \"Invalid namespace prefix: \" + name);\n            }\n        }\n\n        String local = name.substring(colon + 1);\n\n        int n = local.length();\n        if (n > 3 && local.charAt(n - 1) == ']') {\n            int i = n - 2;\n            while (i > 1 && Character.isDigit(local.charAt(i))) {\n                i--;\n            }\n            if (local.charAt(i) != '[') {\n                throw new CommitFailedException(\n                        CommitFailedException.NAME, 2, \"Invalid name index \" + name);\n            } else {\n                local = local.substring(0, i);\n            }\n        }\n\n        if (!Namespaces.isValidLocalName(local)) {\n            throw new CommitFailedException(\n                    CommitFailedException.NAME, 3, \"Invalid name: \" + name);\n        }\n    }","id":75807,"modified_method":"protected void checkValidName(String name) throws CommitFailedException {\n        int colon = name.indexOf(':');\n        if (colon > 0) {\n            String prefix = name.substring(0, colon);\n            if (prefix.isEmpty() || !prefixes.contains(prefix)) {\n                throw new CommitFailedException(\n                        CommitFailedException.NAME, 1, \"Invalid namespace prefix(\"+prefixes+\"): \" + prefix);\n            }\n        }\n\n        String local = name.substring(colon + 1);\n\n        int n = local.length();\n        if (n > 3 && local.charAt(n - 1) == ']') {\n            int i = n - 2;\n            while (i > 1 && Character.isDigit(local.charAt(i))) {\n                i--;\n            }\n            if (local.charAt(i) != '[') {\n                throw new CommitFailedException(\n                        CommitFailedException.NAME, 2, \"Invalid name index \" + name);\n            } else {\n                local = local.substring(0, i);\n            }\n        }\n\n        if (!Namespaces.isValidLocalName(local)) {\n            throw new CommitFailedException(\n                    CommitFailedException.NAME, 3, \"Invalid name: \" + name);\n        }\n    }","commit_id":"d7878aa320b34550511fb2c25da58e5b154711ea","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public NameValidator(Set<String> prefixes) {\n        this.prefixes = prefixes;\n    }","id":75808,"modified_method":"NameValidator(Set<String> prefixes) {\n        this.prefixes = prefixes;\n    }","commit_id":"d7878aa320b34550511fb2c25da58e5b154711ea","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Validator getRootValidator(NodeState before, NodeState after) {\n        return new NameValidator(\n                Namespaces.getNamespaceMap(new ImmutableTree(after)).keySet());\n    }","id":75809,"modified_method":"@Override\n    public Validator getRootValidator(NodeState before, NodeState after) {\n        return new NameValidator(after);\n    }","commit_id":"d7878aa320b34550511fb2c25da58e5b154711ea","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void propertyAdded(PropertyState after)\n            throws CommitFailedException {\n        String prefix = after.getName();\n        // ignore jcr:primaryType\n        if (prefix.equals(\"jcr:primaryType\")) {\n            return;\n        }\n        if (map.containsKey(prefix)) {\n            throw new CommitFailedException(\n                    CommitFailedException.NAMESPACE, 1,\n                    \"Namespace mapping already registered: \" + prefix);\n        } else if (Namespaces.isValidPrefix(prefix)) {\n            if (after.isArray() || !STRING.equals(after.getType())) {\n                throw new CommitFailedException(\n                        CommitFailedException.NAMESPACE, 2,\n                        \"Invalid namespace mapping: \" + prefix);\n            } else if (prefix.toLowerCase(Locale.ENGLISH).startsWith(\"xml\")) {\n                throw new CommitFailedException(\n                        CommitFailedException.NAMESPACE, 3,\n                        \"XML prefixes are reserved: \" + prefix);\n            } else if (map.containsValue(after.getValue(STRING))) {\n                throw modificationNotAllowed(prefix);\n            }\n        } else {\n            throw new CommitFailedException(\n                    CommitFailedException.NAMESPACE, 4,\n                    \"Not a valid namespace prefix: \" + prefix);\n        }\n    }","id":75810,"modified_method":"@Override\n    public void propertyAdded(PropertyState after) throws CommitFailedException {\n        String prefix = after.getName();\n        // ignore jcr:primaryType\n        if (JCR_PRIMARYTYPE.equals(prefix)) {\n            return;\n        }\n\n        if (namespaces.hasProperty(prefix)) {\n            throw new CommitFailedException(CommitFailedException.NAMESPACE, 1,\n                    \"Namespace mapping already registered: \" + prefix);\n        } else if (isValidPrefix(prefix)) {\n            if (after.isArray() || !STRING.equals(after.getType())) {\n                throw new CommitFailedException(\n                        CommitFailedException.NAMESPACE, 2,\n                        \"Invalid namespace mapping: \" + prefix);\n            } else if (prefix.toLowerCase(Locale.ENGLISH).startsWith(\"xml\")) {\n                throw new CommitFailedException(\n                        CommitFailedException.NAMESPACE, 3,\n                        \"XML prefixes are reserved: \" + prefix);\n            } else if (containsValue(namespaces, after.getValue(STRING))) {\n                throw modificationNotAllowed(prefix);\n            }\n        } else {\n            throw new CommitFailedException(CommitFailedException.NAMESPACE, 4,\n                    \"Not a valid namespace prefix: \" + prefix);\n        }\n        modified = true;\n    }","commit_id":"d7878aa320b34550511fb2c25da58e5b154711ea","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void propertyDeleted(PropertyState before)\n            throws CommitFailedException {\n        if (map.containsKey(before.getName())) {\n            // TODO: Check whether this namespace is still used in content\n        }\n    }","id":75811,"modified_method":"@Override\n    public void propertyDeleted(PropertyState before)\n            throws CommitFailedException {\n\n        // FIXME Desired Behavior: if we enable it, there are a few generic\n        // #unregister tests that fail\n        // TODO allow changes if there is no content referencing the mappings\n        // throw modificationNotAllowed(before.getName());\n\n        // FIXME Best effort backwards compatible:\n        if (jcrSystemNS.contains(before.getName())) {\n            throw modificationNotAllowed(before.getName());\n        }\n        modified = true;\n    }","commit_id":"d7878aa320b34550511fb2c25da58e5b154711ea","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void propertyChanged(PropertyState before, PropertyState after)\n            throws CommitFailedException {\n        if (map.containsKey(after.getName())) {\n            throw modificationNotAllowed(after.getName());\n        }\n    }","id":75812,"modified_method":"@Override\n    public void propertyChanged(PropertyState before, PropertyState after)\n            throws CommitFailedException {\n        // TODO allow changes if there is no content referencing the mappings\n        throw modificationNotAllowed(after.getName());\n    }","commit_id":"d7878aa320b34550511fb2c25da58e5b154711ea","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Validator getRootValidator(NodeState before, NodeState after) {\n        Validator validator = new NamespaceValidator(\n                Namespaces.getNamespaceMap(new ImmutableTree(before)));\n        return new SubtreeValidator(validator, JCR_SYSTEM, REP_NAMESPACES);\n    }","id":75813,"modified_method":"@Override\n    public Editor getRootEditor(NodeState before, NodeState after,\n            NodeBuilder builder) throws CommitFailedException {\n        return new SubtreeEditor(new NamespaceValidator(before, builder), JCR_SYSTEM, REP_NAMESPACES);\n    }","commit_id":"d7878aa320b34550511fb2c25da58e5b154711ea","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public static boolean isValidPrefix(String prefix) {\n        // TODO: Other prefix rules?\n        return !prefix.isEmpty() && prefix.indexOf(':') == -1;\n    }","id":75814,"modified_method":"public static boolean isValidPrefix(String prefix) {\n        // TODO: Other prefix rules?\n        return prefix.indexOf(':') == -1;\n    }","commit_id":"d7878aa320b34550511fb2c25da58e5b154711ea","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public static Map<String, String> getNamespaceMap(Tree root) {\n        Map<String, String> map = new HashMap<String, String>(DEFAULTS);\n\n        Tree namespaces = root.getChild(JcrConstants.JCR_SYSTEM).getChild(REP_NAMESPACES);\n        for (PropertyState property : namespaces.getProperties()) {\n            String prefix = property.getName();\n            if (!property.isArray() && isValidPrefix(prefix)) {\n                String value = property.getValue(STRING);\n                if (STRING.equals(property.getType())) {\n                    map.put(prefix, value);\n                }\n            }\n        }\n\n        return map;\n    }","id":75815,"modified_method":"public static Map<String, String> getNamespaceMap(Tree root) {\n        Map<String, String> map = new HashMap<String, String>();\n\n        Tree namespaces = getNamespaceTree(root);\n        for (PropertyState property : namespaces.getProperties()) {\n            String prefix = property.getName();\n            if (STRING.equals(property.getType()) && isValidPrefix(prefix)) {\n                map.put(unescapePropertyKey(prefix), property.getValue(STRING));\n            }\n        }\n\n        return map;\n    }","commit_id":"d7878aa320b34550511fb2c25da58e5b154711ea","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    @Nonnull\n    public String getURI(String prefix) throws RepositoryException {\n        try {\n            Tree root = getReadTree();\n            Map<String, String> map = Namespaces.getNamespaceMap(root);\n            String uri = map.get(prefix);\n            if (uri == null) {\n                throw new NamespaceException(\n                        \"No namespace registered for prefix \" + prefix);\n            }\n            return uri;\n        } catch (RuntimeException e) {\n            throw new RepositoryException(\n                    \"Failed to retrieve the namespace URI for prefix \"\n                    + prefix, e);\n        }\n    }","id":75816,"modified_method":"@Override\n    @Nonnull\n    public String getURI(String prefix) throws RepositoryException {\n        try {\n            String uri = Namespaces.getNamespaceURI(getReadTree(), prefix);\n            if (uri == null) {\n                throw new NamespaceException(\n                        \"No namespace registered for prefix \" + prefix);\n            }\n            return uri;\n        } catch (RuntimeException e) {\n            throw new RepositoryException(\n                    \"Failed to retrieve the namespace URI for prefix \"\n                    + prefix, e);\n        }\n    }","commit_id":"d7878aa320b34550511fb2c25da58e5b154711ea","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    @Nonnull\n    public String[] getURIs() throws RepositoryException {\n        try {\n            Tree root = getReadTree();\n            Map<String, String> map = Namespaces.getNamespaceMap(root);\n            String[] uris = map.values().toArray(new String[map.size()]);\n            return uris;\n        } catch (RuntimeException e) {\n            throw new RepositoryException(\n                    \"Failed to retrieve registered namespace URIs\", e);\n        }\n    }","id":75817,"modified_method":"@Override\n    @Nonnull\n    public String[] getURIs() throws RepositoryException {\n        try {\n            return Namespaces.getNamespaceURIs(getReadTree());\n        } catch (RuntimeException e) {\n            throw new RepositoryException(\n                    \"Failed to retrieve registered namespace URIs\", e);\n        }\n    }","commit_id":"d7878aa320b34550511fb2c25da58e5b154711ea","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    @Nonnull\n    public String getPrefix(String uri) throws RepositoryException {\n        try {\n            Tree root = getReadTree();\n            Map<String, String> map = Namespaces.getNamespaceMap(root);\n            for (Map.Entry<String, String> entry : map.entrySet()) {\n                if (entry.getValue().equals(uri)) {\n                    return entry.getKey();\n                }\n            }\n            throw new NamespaceException(\n                        \"No namespace prefix registered for URI \" + uri);\n        } catch (RuntimeException e) {\n            throw new RepositoryException(\n                    \"Failed to retrieve the namespace prefix for URI \"\n                    + uri, e);\n        }\n    }","id":75818,"modified_method":"@Override\n    @Nonnull\n    public String getPrefix(String uri) throws RepositoryException {\n        try {\n            String prefix = Namespaces.getNamespacePrefix(getReadTree(), uri);\n            if (prefix == null) {\n                throw new NamespaceException(\n                        \"No namespace prefix registered for URI \" + uri);\n            }\n            return prefix;\n        } catch (RuntimeException e) {\n            throw new RepositoryException(\n                    \"Failed to retrieve the namespace prefix for URI \"\n                    + uri, e);\n        }\n    }","commit_id":"d7878aa320b34550511fb2c25da58e5b154711ea","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    @Nonnull\n    public String[] getPrefixes() throws RepositoryException {\n        try {\n            Tree root = getReadTree();\n            Map<String, String> map = Namespaces.getNamespaceMap(root);\n            String[] prefixes = map.keySet().toArray(new String[map.size()]);\n            Arrays.sort(prefixes);\n            return prefixes;\n        } catch (RuntimeException e) {\n            throw new RepositoryException(\n                    \"Failed to retrieve registered namespace prefixes\", e);\n        }\n    }","id":75819,"modified_method":"@Override\n    @Nonnull\n    public String[] getPrefixes() throws RepositoryException {\n        try {\n            return Namespaces.getNamespacePrefixes(getReadTree());\n        } catch (RuntimeException e) {\n            throw new RepositoryException(\n                    \"Failed to retrieve registered namespace prefixes\", e);\n        }\n    }","commit_id":"d7878aa320b34550511fb2c25da58e5b154711ea","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void registerNamespace(String prefix, String uri)\n            throws RepositoryException {\n        Map<String, String> map = Namespaces.getNamespaceMap(getReadTree());\n        if (uri.equals(map.get(prefix))) {\n            return; // Namespace already registered, so we do nothing\n        }\n\n        try {\n            Root root = getWriteRoot();\n            Tree namespaces =\n                    getOrCreate(root, JcrConstants.JCR_SYSTEM, REP_NAMESPACES);\n            if (!namespaces.hasProperty(JcrConstants.JCR_PRIMARYTYPE)) {\n                namespaces.setProperty(JcrConstants.JCR_PRIMARYTYPE,\n                        JcrConstants.NT_UNSTRUCTURED, NAME);\n            }\n            // remove existing mapping to given uri\n            for (PropertyState p : namespaces.getProperties()) {\n                if (!p.isArray() && p.getValue(STRING).equals(uri)) {\n                    namespaces.removeProperty(p.getName());\n                }\n            }\n            namespaces.setProperty(prefix, uri);\n            root.commit();\n            refresh();\n        } catch (CommitFailedException e) {\n            String message =\n                    \"Failed to register namespace mapping from \"\n                            + prefix + \" to \" + uri;\n            throw e.asRepositoryException(message);\n        }\n    }","id":75820,"modified_method":"@Override\n    public void registerNamespace(String prefix, String uri)\n            throws RepositoryException {\n        if (uri.equals(getNamespaceURI(getReadTree(), prefix))) {\n            return; // Namespace already registered, so we do nothing\n        }\n        try {\n            Root root = getWriteRoot();\n            Tree namespaces = root.getTree(NAMESPACES_PATH);\n\n            // remove existing mapping to given uri\n            String ns = Namespaces.getNamespacePrefix(namespaces, uri);\n            if (ns != null) {\n                namespaces.removeProperty(ns);\n            }\n            namespaces.setProperty(prefix, uri);\n            root.commit();\n            refresh();\n        } catch (CommitFailedException e) {\n            String message =\n                    \"Failed to register namespace mapping from \"\n                            + prefix + \" to \" + uri;\n            throw e.asRepositoryException(message);\n        }\n    }","commit_id":"d7878aa320b34550511fb2c25da58e5b154711ea","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"protected void registerWidgets() {\n        //\n        // non-widget support classes\n        //\n        registerFactory(\"action\", new ActionFactory());\n        registerFactory(\"actions\", new CollectionFactory());\n        registerBeanFactory(\"buttonGroup\", ButtonGroup.class);\n        registerFactory(\"map\", new MapFactory());\n\n        // ulimate pass through types\n        registerFactory(\"widget\", new WidgetFactory()); //TODO prohibit child content somehow\n        registerFactory(\"container\", new WidgetFactory());\n        \n        //\n        // standalone window classes\n        //\n        registerFactory(\"dialog\", new DialogFactory());\n        registerBeanFactory(\"fileChooser\", JFileChooser.class);\n        registerFactory(\"frame\", new FrameFactory());\n        registerBeanFactory(\"optionPane\", JOptionPane.class);\n        registerFactory(\"window\", new WindowFactory());\n        \n        //\n        // widgets\n        //\n        registerFactory(\"button\", new ButtonFactory());\n        registerFactory(\"checkBox\", new CheckBoxFactory());\n        registerFactory(\"checkBoxMenuItem\", new CheckBoxMenuItemFactory());\n        registerBeanFactory(\"colorChooser\", JColorChooser.class);\n        registerFactory(\"comboBox\", new ComboBoxFactory());\n        registerBeanFactory(\"desktopPane\", JDesktopPane.class);\n        registerFactory(\"editorPane\", new EditorPaneFactory());\n        registerFactory(\"formattedTextField\", new FormattedTextFactory());\n        registerBeanFactory(\"internalFrame\", JInternalFrame.class);\n        registerFactory(\"label\", new LabelFactory());\n        registerBeanFactory(\"layeredPane\", JLayeredPane.class);\n        registerBeanFactory(\"list\", JList.class);\n        registerBeanFactory(\"menu\", JMenu.class);\n        registerBeanFactory(\"menuBar\", JMenuBar.class);\n        registerFactory(\"menuItem\", new MenuItemFactory());\n        registerBeanFactory(\"panel\", JPanel.class);\n        registerFactory(\"passwordField\", new PasswordFieldFactory());\n        registerBeanFactory(\"popupMenu\", JPopupMenu.class);\n        registerBeanFactory(\"progressBar\", JProgressBar.class);\n        registerFactory(\"radioButton\", new RadioButtonFactory());\n        registerFactory(\"radioButtonMenuItem\", new RadioButtonMenuItemFactory());\n        registerBeanFactory(\"scrollBar\", JScrollBar.class);\n        registerBeanFactory(\"scrollPane\", JScrollPane.class);\n        registerFactory(\"separator\", new SeparatorFactory());\n        registerBeanFactory(\"slider\", JSlider.class);\n        registerBeanFactory(\"spinner\", JSpinner.class);\n        registerFactory(\"splitPane\", new SplitPaneFactory());\n        registerBeanFactory(\"tabbedPane\", JTabbedPane.class);\n        registerBeanFactory(\"table\", JTable.class);\n        registerBeanFactory(\"tableColumn\", TableColumn.class);\n        registerFactory(\"textArea\", new TextAreaFactory());\n        registerFactory(\"textPane\", new TextPaneFactory());\n        registerFactory(\"textField\", new TextFieldFactory());\n        registerFactory(\"toggleButton\", new ToggleButtonFactory());\n        registerBeanFactory(\"toolBar\", JToolBar.class);\n        //registerBeanFactory(\"tooltip\", JToolTip.class); // doesn't work, use toolTipText property\n        registerBeanFactory(\"tree\", JTree.class);\n        registerBeanFactory(\"viewport\", JViewport.class); // sub class?\n        \n        //\n        // MVC models\n        //\n        registerBeanFactory(\"boundedRangeModel\", DefaultBoundedRangeModel.class);\n        \n        // spinner models\n        registerBeanFactory(\"spinnerDateModel\", SpinnerDateModel.class);\n        registerBeanFactory(\"spinnerListModel\", SpinnerListModel.class);\n        registerBeanFactory(\"spinnerNumberModel\", SpinnerNumberModel.class);\n        \n        // table models\n        registerFactory(\"tableModel\", new TableModelFactory());\n        registerFactory(\"propertyColumn\", new TableModelFactory.PropertyColumnFactory());\n        registerFactory(\"closureColumn\", new TableModelFactory.ClosureColumnFactory());\n        \n        //\n        // Layouts\n        //\n        registerBeanFactory(\"borderLayout\", BorderLayout.class);\n        registerBeanFactory(\"cardLayout\", CardLayout.class);\n        registerBeanFactory(\"flowLayout\", FlowLayout.class);\n        registerBeanFactory(\"gridBagLayout\", GridBagLayout.class);\n        registerBeanFactory(\"gridLayout\", GridLayout.class);\n        registerBeanFactory(\"overlayLayout\", OverlayLayout.class);\n        registerBeanFactory(\"springLayout\", SpringLayout.class);\n        registerBeanFactory(\"gridBagConstraints\", GridBagConstraints.class);\n        registerBeanFactory(\"gbc\", GridBagConstraints.class); // shortcut name\n\n        // Box layout and friends\n        registerFactory(\"boxLayout\", new BoxLayoutFactory());\n        registerFactory(\"box\", new BoxFactory());\n        registerFactory(\"hbox\", new BoxFactory.HBoxFactory());\n        registerFactory(\"hglue\", new BoxFactory.HGlueFactory());\n        registerFactory(\"hstrut\", new BoxFactory.HStrutFactory());\n        registerFactory(\"vbox\", new BoxFactory.VBoxFactory());\n        registerFactory(\"vglue\", new BoxFactory.VGlueFactory());\n        registerFactory(\"vstrut\", new BoxFactory.VStrutFactory());\n        registerFactory(\"glue\", new BoxFactory.GlueFactory());\n        registerFactory(\"rigidArea\", new BoxFactory.RigidAreaFactory());\n        \n        // table layout\n        registerFactory(\"tableLayout\", new TableLayoutFactory());\n        registerFactory(\"tr\", new TableLayoutFactory.TRFactory());\n        registerFactory(\"td\", new TableLayoutFactory.TDFactory());\n        \n    }","id":75821,"modified_method":"protected void registerWidgets() {\n        //\n        // non-widget support classes\n        //\n        registerFactory(\"action\", new ActionFactory());\n        registerFactory(\"actions\", new CollectionFactory());\n        registerBeanFactory(\"buttonGroup\", ButtonGroup.class);\n        registerFactory(\"map\", new MapFactory());\n\n        // ulimate pass through types\n        registerFactory(\"widget\", new WidgetFactory()); //TODO prohibit child content somehow\n        registerFactory(\"container\", new WidgetFactory());\n        \n        //\n        // standalone window classes\n        //\n        registerFactory(\"dialog\", new DialogFactory());\n        registerBeanFactory(\"fileChooser\", JFileChooser.class);\n        registerFactory(\"frame\", new FrameFactory());\n        registerBeanFactory(\"optionPane\", JOptionPane.class);\n        registerFactory(\"window\", new WindowFactory());\n        \n        //\n        // widgets\n        //\n        registerFactory(\"button\", new RichActionWidgetFactory(JButton.class));\n        registerFactory(\"checkBox\", new RichActionWidgetFactory(JCheckBox.class));\n        registerFactory(\"checkBoxMenuItem\", new RichActionWidgetFactory(JCheckBoxMenuItem.class));\n        registerFactory(\"menuItem\", new RichActionWidgetFactory(JMenuItem.class));\n        registerFactory(\"radioButton\", new RichActionWidgetFactory(JRadioButton.class));\n        registerFactory(\"radioButtonMenuItem\", new RichActionWidgetFactory(JRadioButtonMenuItem.class));\n        registerFactory(\"toggleButton\", new RichActionWidgetFactory(JToggleButton.class));\n\n        registerFactory(\"editorPane\", new TextArgWidgetFactory(JEditorPane.class));\n        registerFactory(\"label\", new TextArgWidgetFactory(JLabel.class));\n        registerFactory(\"passwordField\", new TextArgWidgetFactory(JPasswordField.class));\n        registerFactory(\"textArea\", new TextArgWidgetFactory(JTextArea.class));\n        registerFactory(\"textField\", new TextArgWidgetFactory(JTextField.class));\n        registerFactory(\"textPane\", new TextArgWidgetFactory(JTextPane.class));\n\n        registerBeanFactory(\"colorChooser\", JColorChooser.class);\n        registerFactory(\"comboBox\", new ComboBoxFactory());\n        registerBeanFactory(\"desktopPane\", JDesktopPane.class);\n        registerFactory(\"formattedTextField\", new FormattedTextFactory());\n        registerBeanFactory(\"internalFrame\", JInternalFrame.class);\n        registerBeanFactory(\"layeredPane\", JLayeredPane.class);\n        registerBeanFactory(\"list\", JList.class);\n        registerBeanFactory(\"menu\", JMenu.class);\n        registerBeanFactory(\"menuBar\", JMenuBar.class);\n        registerBeanFactory(\"panel\", JPanel.class);\n        registerBeanFactory(\"popupMenu\", JPopupMenu.class);\n        registerBeanFactory(\"progressBar\", JProgressBar.class);\n        registerBeanFactory(\"scrollBar\", JScrollBar.class);\n        registerBeanFactory(\"scrollPane\", JScrollPane.class);\n        registerFactory(\"separator\", new SeparatorFactory());\n        registerBeanFactory(\"slider\", JSlider.class);\n        registerBeanFactory(\"spinner\", JSpinner.class);\n        registerFactory(\"splitPane\", new SplitPaneFactory());\n        registerBeanFactory(\"tabbedPane\", JTabbedPane.class);\n        registerBeanFactory(\"table\", JTable.class);\n        registerBeanFactory(\"tableColumn\", TableColumn.class);\n        registerBeanFactory(\"toolBar\", JToolBar.class);\n        //registerBeanFactory(\"tooltip\", JToolTip.class); // doesn't work, use toolTipText property\n        registerBeanFactory(\"tree\", JTree.class);\n        registerBeanFactory(\"viewport\", JViewport.class); // sub class?\n        \n        //\n        // MVC models\n        //\n        registerBeanFactory(\"boundedRangeModel\", DefaultBoundedRangeModel.class);\n        \n        // spinner models\n        registerBeanFactory(\"spinnerDateModel\", SpinnerDateModel.class);\n        registerBeanFactory(\"spinnerListModel\", SpinnerListModel.class);\n        registerBeanFactory(\"spinnerNumberModel\", SpinnerNumberModel.class);\n        \n        // table models\n        registerFactory(\"tableModel\", new TableModelFactory());\n        registerFactory(\"propertyColumn\", new TableModelFactory.PropertyColumnFactory());\n        registerFactory(\"closureColumn\", new TableModelFactory.ClosureColumnFactory());\n        \n        //\n        // Layouts\n        //\n        registerBeanFactory(\"borderLayout\", BorderLayout.class);\n        registerBeanFactory(\"cardLayout\", CardLayout.class);\n        registerBeanFactory(\"flowLayout\", FlowLayout.class);\n        registerBeanFactory(\"gridBagLayout\", GridBagLayout.class);\n        registerBeanFactory(\"gridLayout\", GridLayout.class);\n        registerBeanFactory(\"overlayLayout\", OverlayLayout.class);\n        registerBeanFactory(\"springLayout\", SpringLayout.class);\n        registerBeanFactory(\"gridBagConstraints\", GridBagConstraints.class);\n        registerBeanFactory(\"gbc\", GridBagConstraints.class); // shortcut name\n\n        // Box layout and friends\n        registerFactory(\"boxLayout\", new BoxLayoutFactory());\n        registerFactory(\"box\", new BoxFactory());\n        registerFactory(\"hbox\", new BoxFactory.HBoxFactory());\n        registerFactory(\"hglue\", new BoxFactory.HGlueFactory());\n        registerFactory(\"hstrut\", new BoxFactory.HStrutFactory());\n        registerFactory(\"vbox\", new BoxFactory.VBoxFactory());\n        registerFactory(\"vglue\", new BoxFactory.VGlueFactory());\n        registerFactory(\"vstrut\", new BoxFactory.VStrutFactory());\n        registerFactory(\"glue\", new BoxFactory.GlueFactory());\n        registerFactory(\"rigidArea\", new BoxFactory.RigidAreaFactory());\n        \n        // table layout\n        registerFactory(\"tableLayout\", new TableLayoutFactory());\n        registerFactory(\"tr\", new TableLayoutFactory.TRFactory());\n        registerFactory(\"td\", new TableLayoutFactory.TDFactory());\n        \n    }","commit_id":"fed72b624817e9010f44a5557d10cc5005e1180d","url":"https://github.com/apache/groovy"},{"original_method":"public ViewDescriptor handle(HttpServletRequest request,\n\t\t\tHttpServletResponse response) throws Exception {\n\t\tfinal boolean[] created = new boolean[1];\n\t\tcreated[0] = false;\n\t\tViewDescriptor viewDescriptor = super.handle(request, response, new FlowExecutionListener() {\n\t\t\tpublic void created(FlowExecutionContext context) {\n\t\t\t\tcreated[0] = true;\n\t\t\t}\n\t\t\tpublic void sessionStarted(RequestContext context) {\n\t\t\t}\n\t\t\tpublic void resumed(RequestContext context) {\n\t\t\t}\n\t\t\tpublic void sessionEnded(RequestContext context, FlowSession endedSession) {\n\t\t\t}\n\t\t\tpublic void stateEntered(RequestContext context, State previousState, State state) {\n\t\t\t}\n\t\t\tpublic void eventSignaled(RequestContext context) {\n\t\t\t}\n\t\t\tpublic void requestProcessed(RequestContext context) {\n\t\t\t}\n\t\t\tpublic void loaded(FlowExecutionContext context, Serializable id) {\n\t\t\t}\n\t\t\tpublic void paused(RequestContext context) {\n\t\t\t}\n\t\t\tpublic void removed(FlowExecutionContext context, Serializable id) {\n\t\t\t}\n\t\t\tpublic void requestSubmitted(RequestContext context) {\n\t\t\t}\n\t\t\tpublic void saved(FlowExecutionContext context, Serializable id) {\n\t\t\t}\n\t\t\tpublic void sessionStarting(RequestContext context, State startState, Map input) throws EnterStateVetoException {\n\t\t\t}\n\t\t\tpublic void stateEntering(RequestContext context, State nextState) throws EnterStateVetoException {\n\t\t\t}\n\t\t});\n\t\t\n\t\tif (created[0]) {\n\t\t\tCookie flowExecutionIdCookie = new Cookie(FLOW_EXECUTION_ID_COOKIE_NAME, (String)viewDescriptor.getAttribute(FLOW_EXECUTION_ID_ATTRIBUTE));\n\t\t\tresponse.addCookie(flowExecutionIdCookie);\n\t\t}\n\t\t\n\t\treturn viewDescriptor;\n\t}","id":75822,"modified_method":"public ViewDescriptor handle(HttpServletRequest request,\n\t\t\tHttpServletResponse response) throws Exception {\n\t\tfinal boolean[] created = new boolean[1];\n\t\tcreated[0] = false;\n\t\tViewDescriptor viewDescriptor = super.handle(request, response, new FlowExecutionListener() {\n\t\t\tpublic void created(FlowExecutionContext context) {\n\t\t\t\tcreated[0] = true;\n\t\t\t}\n\t\t\tpublic void sessionStarted(RequestContext context) {\n\t\t\t}\n\t\t\tpublic void resumed(RequestContext context) {\n\t\t\t}\n\t\t\tpublic void sessionEnded(RequestContext context, FlowSession endedSession) {\n\t\t\t}\n\t\t\tpublic void stateEntered(RequestContext context, State previousState, State state) {\n\t\t\t}\n\t\t\tpublic void eventSignaled(RequestContext context) {\n\t\t\t}\n\t\t\tpublic void requestProcessed(RequestContext context) {\n\t\t\t}\n\t\t\tpublic void loaded(FlowExecutionContext context, Serializable id) {\n\t\t\t}\n\t\t\tpublic void paused(RequestContext context) {\n\t\t\t}\n\t\t\tpublic void removed(FlowExecutionContext context, Serializable id) {\n\t\t\t}\n\t\t\tpublic void requestSubmitted(RequestContext context) {\n\t\t\t}\n\t\t\tpublic void saved(FlowExecutionContext context, Serializable id) {\n\t\t\t}\n\t\t\tpublic void sessionStarting(RequestContext context, State startState, Map input) throws EnterStateVetoException {\n\t\t\t}\n\t\t\tpublic void stateEntering(RequestContext context, State nextState) throws EnterStateVetoException {\n\t\t\t}\n\t\t});\n\t\t\n\t\tCookie flowExecutionIdCookie = null;\n\t\tif (request.getAttribute(RESET_PARAMETER) != null && request.getAttribute(RESET_PARAMETER).equals(TRUE)) {\n\t\t\tflowExecutionIdCookie = new Cookie(FLOW_EXECUTION_ID_COOKIE_NAME, \"\");\n\t\t} else if (created[0]) {\n\t\t\tflowExecutionIdCookie = new Cookie(FLOW_EXECUTION_ID_COOKIE_NAME, (String)viewDescriptor.getAttribute(FLOW_EXECUTION_ID_ATTRIBUTE));\n\t\t}\n\t\tif (flowExecutionIdCookie != null) {\n\t\t\tresponse.addCookie(flowExecutionIdCookie);\n\t\t}\n\n\t\treturn viewDescriptor;\n\t}","commit_id":"330fd545119883d586fcad802670a4b7781faa25","url":"https://github.com/grails/grails-core"},{"original_method":"protected String getFlowExecutionId(Event event) {\n\t\tif (event instanceof ServletEvent) {\t\t\t\n\t\t\tString flowExecutionId = super.getFlowExecutionId(event);\n\t\t\tif (StringUtils.isBlank(flowExecutionId)) {\n\t\t\t\tString resetValue = (String)event.getParameter(RESET_PARAMETER);\n\t\t\t\tif (StringUtils.isNotBlank(resetValue) && TRUE.equals(resetValue)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tCookie[] cookies = ((ServletEvent)event).getRequest().getCookies();\n\t\t\t\tfor (int i = 0; cookies != null && i < cookies.length; i++) {\n\t\t\t\t\tif (FLOW_EXECUTION_ID_COOKIE_NAME.equals(cookies[i].getName())) {\n\t\t\t\t\t\tif (StringUtils.isNotBlank(cookies[i].getValue())) {\n\t\t\t\t\t\t\treturn cookies[i].getValue();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\treturn flowExecutionId;\n\t\t\t}\n\t\t} else {\n\t\t\treturn super.getFlowExecutionId(event);\n\t\t}\n\t}","id":75823,"modified_method":"protected String getFlowExecutionId(Event event) {\n\t\tif (event instanceof ServletEvent) {\t\t\t\n\t\t\tString flowExecutionId = super.getFlowExecutionId(event);\n\t\t\tif (StringUtils.isBlank(flowExecutionId)) {\n\t\t\t\tString resetValue = (String)event.getParameter(RESET_PARAMETER);\n\t\t\t\tif (StringUtils.isNotBlank(resetValue) && TRUE.equals(resetValue)) {\n\t\t\t\t\t((ServletEvent)event).getRequest().setAttribute(RESET_PARAMETER, TRUE);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tCookie[] cookies = ((ServletEvent)event).getRequest().getCookies();\n\t\t\t\tfor (int i = 0; cookies != null && i < cookies.length; i++) {\n\t\t\t\t\tif (FLOW_EXECUTION_ID_COOKIE_NAME.equals(cookies[i].getName())) {\n\t\t\t\t\t\tif (StringUtils.isNotBlank(cookies[i].getValue())) {\n\t\t\t\t\t\t\treturn cookies[i].getValue();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\treturn flowExecutionId;\n\t\t\t}\n\t\t} else {\n\t\t\treturn super.getFlowExecutionId(event);\n\t\t}\n\t}","commit_id":"330fd545119883d586fcad802670a4b7781faa25","url":"https://github.com/grails/grails-core"},{"original_method":"public static void login(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tString login, String password, boolean rememberMe, String authType)\n\t\tthrows Exception {\n\n\t\tCookieKeys.validateSupportCookie(request);\n\n\t\tHttpSession session = request.getSession();\n\n\t\tCompany company = PortalUtil.getCompany(request);\n\n\t\tlong userId = getAuthenticatedUserId(\n\t\t\trequest, login, password, authType);\n\n\t\tif (!PropsValues.AUTH_SIMULTANEOUS_LOGINS) {\n\t\t\tMap<String, UserTracker> sessionUsers = LiveUsers.getSessionUsers(\n\t\t\t\tcompany.getCompanyId());\n\n\t\t\tList<UserTracker> userTrackers = new ArrayList<UserTracker>(\n\t\t\t\tsessionUsers.values());\n\n\t\t\tfor (UserTracker userTracker : userTrackers) {\n\t\t\t\tif (userId != userTracker.getUserId()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\t\tjsonObject.put(\"command\", \"signOut\");\n\n\t\t\t\tlong companyId = CompanyLocalServiceUtil.getCompanyIdByUserId(\n\t\t\t\t\tuserId);\n\n\t\t\t\tjsonObject.put(\"companyId\", companyId);\n\n\t\t\t\tjsonObject.put(\"userId\", userId);\n\t\t\t\tjsonObject.put(\"sessionId\", userTracker.getSessionId());\n\n\t\t\t\tMessageBusUtil.sendMessage(\n\t\t\t\t\tDestinationNames.LIVE_USERS, jsonObject.toString());\n\t\t\t}\n\t\t}\n\n\t\tif (PropsValues.SESSION_ENABLE_PHISHING_PROTECTION) {\n\n\t\t\t// Invalidate the previous session to prevent phishing\n\n\t\t\tString[] protectedAttributeNames =\n\t\t\t\tPropsValues.SESSION_PHISHING_PROTECTED_ATTRIBUTES;\n\n\t\t\tMap<String, Object> protectedAttributes =\n\t\t\t\tnew HashMap<String, Object>();\n\n\t\t\tfor (String protectedAttributeName : protectedAttributeNames) {\n\t\t\t\tObject protectedAttributeValue = session.getAttribute(\n\t\t\t\t\tprotectedAttributeName);\n\n\t\t\t\tif (protectedAttributeValue == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tprotectedAttributes.put(\n\t\t\t\t\tprotectedAttributeName, protectedAttributeValue);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tsession.invalidate();\n\t\t\t}\n\t\t\tcatch (IllegalStateException ise) {\n\n\t\t\t\t// This only happens in Geronimo\n\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(ise.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsession = request.getSession(true);\n\n\t\t\tfor (String protectedAttributeName : protectedAttributeNames) {\n\t\t\t\tObject protectedAttributeValue = protectedAttributes.get(\n\t\t\t\t\tprotectedAttributeName);\n\n\t\t\t\tif (protectedAttributeValue == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tsession.setAttribute(\n\t\t\t\t\tprotectedAttributeName, protectedAttributeValue);\n\t\t\t}\n\t\t}\n\n\t\t// Set cookies\n\n\t\tString domain = CookieKeys.getDomain(request);\n\n\t\tUser user = UserLocalServiceUtil.getUserById(userId);\n\n\t\tString userIdString = String.valueOf(userId);\n\n\t\tsession.setAttribute(\"j_username\", userIdString);\n\t\tsession.setAttribute(\"j_password\", user.getPassword());\n\t\tsession.setAttribute(\"j_remoteuser\", userIdString);\n\n\t\tif (PropsValues.SESSION_STORE_PASSWORD) {\n\t\t\tsession.setAttribute(WebKeys.USER_PASSWORD, password);\n\t\t}\n\n\t\tCookie companyIdCookie = new Cookie(\n\t\t\tCookieKeys.COMPANY_ID, String.valueOf(company.getCompanyId()));\n\n\t\tif (Validator.isNotNull(domain)) {\n\t\t\tcompanyIdCookie.setDomain(domain);\n\t\t}\n\n\t\tcompanyIdCookie.setPath(StringPool.SLASH);\n\n\t\tCookie idCookie = new Cookie(\n\t\t\tCookieKeys.ID,\n\t\t\tEncryptor.encrypt(company.getKeyObj(), userIdString));\n\n\t\tif (Validator.isNotNull(domain)) {\n\t\t\tidCookie.setDomain(domain);\n\t\t}\n\n\t\tidCookie.setPath(StringPool.SLASH);\n\n\t\tCookie passwordCookie = new Cookie(\n\t\t\tCookieKeys.PASSWORD,\n\t\t\tEncryptor.encrypt(company.getKeyObj(), password));\n\n\t\tif (Validator.isNotNull(domain)) {\n\t\t\tpasswordCookie.setDomain(domain);\n\t\t}\n\n\t\tpasswordCookie.setPath(StringPool.SLASH);\n\n\t\tCookie rememberMeCookie = new Cookie(\n\t\t\tCookieKeys.REMEMBER_ME, Boolean.TRUE.toString());\n\n\t\tif (Validator.isNotNull(domain)) {\n\t\t\trememberMeCookie.setDomain(domain);\n\t\t}\n\n\t\trememberMeCookie.setPath(StringPool.SLASH);\n\n\t\tint loginMaxAge = PropsValues.COMPANY_SECURITY_AUTO_LOGIN_MAX_AGE;\n\n\t\tif (PropsValues.SESSION_DISABLED) {\n\t\t\trememberMe = true;\n\t\t}\n\n\t\tif (rememberMe) {\n\t\t\tcompanyIdCookie.setMaxAge(loginMaxAge);\n\t\t\tidCookie.setMaxAge(loginMaxAge);\n\t\t\tpasswordCookie.setMaxAge(loginMaxAge);\n\t\t\trememberMeCookie.setMaxAge(loginMaxAge);\n\t\t}\n\t\telse {\n\n\t\t\t// This was explicitly changed from 0 to -1 so that the cookie lasts\n\t\t\t// as long as the browser. This allows an external servlet wrapped\n\t\t\t// in AutoLoginFilter to work throughout the client connection. The\n\t\t\t// cookies ARE removed on an actual logout, so there is no security\n\t\t\t// issue. See LEP-4678 and LEP-5177.\n\n\t\t\tcompanyIdCookie.setMaxAge(-1);\n\t\t\tidCookie.setMaxAge(-1);\n\t\t\tpasswordCookie.setMaxAge(-1);\n\t\t\trememberMeCookie.setMaxAge(0);\n\t\t}\n\n\t\tCookie loginCookie = new Cookie(CookieKeys.LOGIN, login);\n\n\t\tif (Validator.isNotNull(domain)) {\n\t\t\tloginCookie.setDomain(domain);\n\t\t}\n\n\t\tloginCookie.setMaxAge(loginMaxAge);\n\t\tloginCookie.setPath(StringPool.SLASH);\n\n\t\tCookie screenNameCookie = new Cookie(\n\t\t\tCookieKeys.SCREEN_NAME,\n\t\t\tEncryptor.encrypt(company.getKeyObj(), user.getScreenName()));\n\n\t\tif (Validator.isNotNull(domain)) {\n\t\t\tscreenNameCookie.setDomain(domain);\n\t\t}\n\n\t\tscreenNameCookie.setMaxAge(loginMaxAge);\n\t\tscreenNameCookie.setPath(StringPool.SLASH);\n\n\t\tboolean secure = request.isSecure();\n\n\t\tif (secure) {\n\t\t\tBoolean httpsInitial = (Boolean)session.getAttribute(\n\t\t\t\tWebKeys.HTTPS_INITIAL);\n\n\t\t\tif ((httpsInitial == null) || !httpsInitial.booleanValue()) {\n\t\t\t\tsecure = false;\n\t\t\t}\n\t\t}\n\n\t\tCookieKeys.addCookie(request, response, companyIdCookie, secure);\n\t\tCookieKeys.addCookie(request, response, idCookie, secure);\n\n\t\tif (rememberMe) {\n\t\t\tCookieKeys.addCookie(request, response, passwordCookie, secure);\n\t\t\tCookieKeys.addCookie(request, response, rememberMeCookie, secure);\n\t\t\tCookieKeys.addCookie(request, response, loginCookie, secure);\n\t\t\tCookieKeys.addCookie(request, response, screenNameCookie, secure);\n\t\t}\n\t}","id":75824,"modified_method":"public static void login(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tString login, String password, boolean rememberMe, String authType)\n\t\tthrows Exception {\n\n\t\tCookieKeys.validateSupportCookie(request);\n\n\t\tHttpSession session = request.getSession();\n\n\t\tCompany company = PortalUtil.getCompany(request);\n\n\t\tlong userId = getAuthenticatedUserId(\n\t\t\trequest, login, password, authType);\n\n\t\tif (!PropsValues.AUTH_SIMULTANEOUS_LOGINS) {\n\t\t\tMap<String, UserTracker> sessionUsers = LiveUsers.getSessionUsers(\n\t\t\t\tcompany.getCompanyId());\n\n\t\t\tList<UserTracker> userTrackers = new ArrayList<UserTracker>(\n\t\t\t\tsessionUsers.values());\n\n\t\t\tfor (UserTracker userTracker : userTrackers) {\n\t\t\t\tif (userId != userTracker.getUserId()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\t\tjsonObject.put(\"command\", \"signOut\");\n\n\t\t\t\tlong companyId = CompanyLocalServiceUtil.getCompanyIdByUserId(\n\t\t\t\t\tuserId);\n\n\t\t\t\tjsonObject.put(\"companyId\", companyId);\n\n\t\t\t\tjsonObject.put(\"userId\", userId);\n\t\t\t\tjsonObject.put(\"sessionId\", userTracker.getSessionId());\n\n\t\t\t\tMessageBusUtil.sendMessage(\n\t\t\t\t\tDestinationNames.LIVE_USERS, jsonObject.toString());\n\t\t\t}\n\t\t}\n\n\t\tif (PropsValues.SESSION_ENABLE_PHISHING_PROTECTION) {\n\n\t\t\t// Invalidate the previous session to prevent phishing\n\n\t\t\tString[] protectedAttributeNames =\n\t\t\t\tPropsValues.SESSION_PHISHING_PROTECTED_ATTRIBUTES;\n\n\t\t\tMap<String, Object> protectedAttributes =\n\t\t\t\tnew HashMap<String, Object>();\n\n\t\t\tfor (String protectedAttributeName : protectedAttributeNames) {\n\t\t\t\tObject protectedAttributeValue = session.getAttribute(\n\t\t\t\t\tprotectedAttributeName);\n\n\t\t\t\tif (protectedAttributeValue == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tprotectedAttributes.put(\n\t\t\t\t\tprotectedAttributeName, protectedAttributeValue);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tsession.invalidate();\n\t\t\t}\n\t\t\tcatch (IllegalStateException ise) {\n\n\t\t\t\t// This only happens in Geronimo\n\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(ise.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsession = request.getSession(true);\n\n\t\t\tfor (String protectedAttributeName : protectedAttributeNames) {\n\t\t\t\tObject protectedAttributeValue = protectedAttributes.get(\n\t\t\t\t\tprotectedAttributeName);\n\n\t\t\t\tif (protectedAttributeValue == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tsession.setAttribute(\n\t\t\t\t\tprotectedAttributeName, protectedAttributeValue);\n\t\t\t}\n\t\t}\n\n\t\t// Set cookies\n\n\t\tString domain = CookieKeys.getDomain(request);\n\n\t\tUser user = UserLocalServiceUtil.getUserById(userId);\n\n\t\tString userIdString = String.valueOf(userId);\n\n\t\tsession.setAttribute(\"j_username\", userIdString);\n\t\tsession.setAttribute(\"j_password\", user.getPassword());\n\t\tsession.setAttribute(\"j_remoteuser\", userIdString);\n\n\t\tif (PropsValues.SESSION_STORE_PASSWORD) {\n\t\t\tsession.setAttribute(WebKeys.USER_PASSWORD, password);\n\t\t}\n\n\t\tCookie companyIdCookie = new Cookie(\n\t\t\tCookieKeys.COMPANY_ID, String.valueOf(company.getCompanyId()));\n\n\t\tif (Validator.isNotNull(domain)) {\n\t\t\tcompanyIdCookie.setDomain(domain);\n\t\t}\n\n\t\tcompanyIdCookie.setPath(StringPool.SLASH);\n\n\t\tCookie idCookie = new Cookie(\n\t\t\tCookieKeys.ID,\n\t\t\tEncryptor.encrypt(company.getKeyObj(), userIdString));\n\n\t\tif (Validator.isNotNull(domain)) {\n\t\t\tidCookie.setDomain(domain);\n\t\t}\n\n\t\tidCookie.setPath(StringPool.SLASH);\n\n\t\tCookie passwordCookie = new Cookie(\n\t\t\tCookieKeys.PASSWORD,\n\t\t\tEncryptor.encrypt(company.getKeyObj(), password));\n\n\t\tif (Validator.isNotNull(domain)) {\n\t\t\tpasswordCookie.setDomain(domain);\n\t\t}\n\n\t\tpasswordCookie.setPath(StringPool.SLASH);\n\n\t\tCookie rememberMeCookie = new Cookie(\n\t\t\tCookieKeys.REMEMBER_ME, Boolean.TRUE.toString());\n\n\t\tif (Validator.isNotNull(domain)) {\n\t\t\trememberMeCookie.setDomain(domain);\n\t\t}\n\n\t\trememberMeCookie.setPath(StringPool.SLASH);\n\n\t\tint loginMaxAge = PropsValues.COMPANY_SECURITY_AUTO_LOGIN_MAX_AGE;\n\n\t\tString userUUID = userIdString.concat(StringPool.PERIOD).concat(\n\t\t\tString.valueOf(System.nanoTime()));\n\n\t\tCookie userUUIDCookie = new Cookie(\n\t\t\tCookieKeys.USER_UUID,\n\t\t\tEncryptor.encrypt(company.getKeyObj(), userUUID));\n\n\t\tuserUUIDCookie.setPath(StringPool.SLASH);\n\n\t\tsession.setAttribute(\"USER_UUID\", userUUID);\n\n\t\tif (PropsValues.SESSION_DISABLED) {\n\t\t\trememberMe = true;\n\t\t}\n\n\t\tif (rememberMe) {\n\t\t\tcompanyIdCookie.setMaxAge(loginMaxAge);\n\t\t\tidCookie.setMaxAge(loginMaxAge);\n\t\t\tpasswordCookie.setMaxAge(loginMaxAge);\n\t\t\trememberMeCookie.setMaxAge(loginMaxAge);\n\t\t\tuserUUIDCookie.setMaxAge(loginMaxAge);\n\t\t}\n\t\telse {\n\n\t\t\t// This was explicitly changed from 0 to -1 so that the cookie lasts\n\t\t\t// as long as the browser. This allows an external servlet wrapped\n\t\t\t// in AutoLoginFilter to work throughout the client connection. The\n\t\t\t// cookies ARE removed on an actual logout, so there is no security\n\t\t\t// issue. See LEP-4678 and LEP-5177.\n\n\t\t\tcompanyIdCookie.setMaxAge(-1);\n\t\t\tidCookie.setMaxAge(-1);\n\t\t\tpasswordCookie.setMaxAge(-1);\n\t\t\trememberMeCookie.setMaxAge(0);\n\t\t\tuserUUIDCookie.setMaxAge(-1);\n\t\t}\n\n\t\tCookie loginCookie = new Cookie(CookieKeys.LOGIN, login);\n\n\t\tif (Validator.isNotNull(domain)) {\n\t\t\tloginCookie.setDomain(domain);\n\t\t}\n\n\t\tloginCookie.setMaxAge(loginMaxAge);\n\t\tloginCookie.setPath(StringPool.SLASH);\n\n\t\tCookie screenNameCookie = new Cookie(\n\t\t\tCookieKeys.SCREEN_NAME,\n\t\t\tEncryptor.encrypt(company.getKeyObj(), user.getScreenName()));\n\n\t\tif (Validator.isNotNull(domain)) {\n\t\t\tscreenNameCookie.setDomain(domain);\n\t\t}\n\n\t\tscreenNameCookie.setMaxAge(loginMaxAge);\n\t\tscreenNameCookie.setPath(StringPool.SLASH);\n\n\t\tboolean secure = request.isSecure();\n\n\t\tif (secure) {\n\t\t\tBoolean httpsInitial = (Boolean)session.getAttribute(\n\t\t\t\tWebKeys.HTTPS_INITIAL);\n\n\t\t\tif ((httpsInitial == null) || !httpsInitial.booleanValue()) {\n\t\t\t\tsecure = false;\n\t\t\t}\n\t\t}\n\n\t\tCookieKeys.addCookie(request, response, companyIdCookie, secure);\n\t\tCookieKeys.addCookie(request, response, idCookie, secure);\n\t\tCookieKeys.addCookie(request, response, userUUIDCookie, secure);\n\n\t\tif (rememberMe) {\n\t\t\tCookieKeys.addCookie(request, response, loginCookie, secure);\n\t\t\tCookieKeys.addCookie(request, response, passwordCookie, secure);\n\t\t\tCookieKeys.addCookie(request, response, rememberMeCookie, secure);\n\t\t\tCookieKeys.addCookie(request, response, screenNameCookie, secure);\n\t\t}\n\n\t\tAuthenticatedUserUUIDStoreUtil.register(userUUID);\n\t}","commit_id":"b802816bf2a297f5195c66f438f757718909c2da","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doPortalInit() {\n\t\tif (PropsValues.SESSION_DISABLED) {\n\t\t\treturn;\n\t\t}\n\n\t\tHttpSession session = _httpSessionEvent.getSession();\n\n\t\tPortalSessionContext.remove(session.getId());\n\n\t\ttry {\n\t\t\tLong userIdObj = (Long)session.getAttribute(WebKeys.USER_ID);\n\n\t\t\tif (userIdObj == null) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\"User id is not in the session\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (userIdObj == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Language\n\n\t\t\tsession.removeAttribute(Globals.LOCALE_KEY);\n\n\t\t\t// Live users\n\n\t\t\tif (PropsValues.LIVE_USERS_ENABLED) {\n\t\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\t\tjsonObject.put(\"command\", \"signOut\");\n\n\t\t\t\tlong userId = userIdObj.longValue();\n\n\t\t\t\tlong companyId = CompanyLocalServiceUtil.getCompanyIdByUserId(\n\t\t\t\t\tuserId);\n\n\t\t\t\tjsonObject.put(\"companyId\", companyId);\n\t\t\t\tjsonObject.put(\"userId\", userId);\n\t\t\t\tjsonObject.put(\"sessionId\", session.getId());\n\n\t\t\t\tMessageBusUtil.sendMessage(\n\t\t\t\t\tDestinationNames.LIVE_USERS, jsonObject.toString());\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalStateException ise) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Please upgrade to a Servlet 2.4 compliant container\");\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\ttry {\n\t\t\tPortletSessionTracker portletSessionTracker =\n\t\t\t\t(PortletSessionTracker)session.getAttribute(\n\t\t\t\t\tWebKeys.PORTLET_SESSION_TRACKER);\n\n\t\t\tif (portletSessionTracker != null) {\n\t\t\t\tPortletSessionTracker.invalidate(session);\n\n\t\t\t\tsession.removeAttribute(WebKeys.PORTLET_SESSION_TRACKER);\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalStateException ise) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(ise, ise);\n\t\t\t}\n\t\t}\n\n\t\t// Process session destroyed events\n\n\t\ttry {\n\t\t\tEventsProcessorUtil.process(\n\t\t\t\tPropsKeys.SERVLET_SESSION_DESTROY_EVENTS,\n\t\t\t\tPropsValues.SERVLET_SESSION_DESTROY_EVENTS, session);\n\t\t}\n\t\tcatch (ActionException ae) {\n\t\t\t_log.error(ae, ae);\n\t\t}\n\t}","id":75825,"modified_method":"@Override\n\tprotected void doPortalInit() {\n\t\tif (PropsValues.SESSION_DISABLED) {\n\t\t\treturn;\n\t\t}\n\n\t\tHttpSession session = _httpSessionEvent.getSession();\n\n\t\tPortalSessionContext.remove(session.getId());\n\n\t\ttry {\n\t\t\tLong userIdObj = (Long)session.getAttribute(WebKeys.USER_ID);\n\n\t\t\tif (userIdObj == null) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\"User id is not in the session\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (userIdObj == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Language\n\n\t\t\tsession.removeAttribute(Globals.LOCALE_KEY);\n\n\t\t\t// Live users\n\n\t\t\tif (PropsValues.LIVE_USERS_ENABLED) {\n\t\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\t\tjsonObject.put(\"command\", \"signOut\");\n\n\t\t\t\tlong userId = userIdObj.longValue();\n\n\t\t\t\tlong companyId = CompanyLocalServiceUtil.getCompanyIdByUserId(\n\t\t\t\t\tuserId);\n\n\t\t\t\tjsonObject.put(\"companyId\", companyId);\n\t\t\t\tjsonObject.put(\"userId\", userId);\n\t\t\t\tjsonObject.put(\"sessionId\", session.getId());\n\n\t\t\t\tMessageBusUtil.sendMessage(\n\t\t\t\t\tDestinationNames.LIVE_USERS, jsonObject.toString());\n\t\t\t}\n\n\t\t\tString userUUID = (String)session.getAttribute(\"USER_UUID\");\n\n\t\t\tif (Validator.isNotNull(userUUID)) {\n\t\t\t\tAuthenticatedUserUUIDStoreUtil.unregister(userUUID);\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalStateException ise) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Please upgrade to a Servlet 2.4 compliant container\");\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\ttry {\n\t\t\tPortletSessionTracker portletSessionTracker =\n\t\t\t\t(PortletSessionTracker)session.getAttribute(\n\t\t\t\t\tWebKeys.PORTLET_SESSION_TRACKER);\n\n\t\t\tif (portletSessionTracker != null) {\n\t\t\t\tPortletSessionTracker.invalidate(session);\n\n\t\t\t\tsession.removeAttribute(WebKeys.PORTLET_SESSION_TRACKER);\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalStateException ise) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(ise, ise);\n\t\t\t}\n\t\t}\n\n\t\t// Process session destroyed events\n\n\t\ttry {\n\t\t\tEventsProcessorUtil.process(\n\t\t\t\tPropsKeys.SERVLET_SESSION_DESTROY_EVENTS,\n\t\t\t\tPropsValues.SERVLET_SESSION_DESTROY_EVENTS, session);\n\t\t}\n\t\tcatch (ActionException ae) {\n\t\t\t_log.error(ae, ae);\n\t\t}\n\t}","commit_id":"b802816bf2a297f5195c66f438f757718909c2da","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n        if (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);       \n            context.getProfiler().message(this, Profiler.DEPENDENCIES, \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT SEQUENCE\", contextSequence);\n            if (contextItem != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT ITEM\", contextItem.toSequence());\n        }\n        \n\t\tResponseModule myModule = (ResponseModule)context.getModule(ResponseModule.NAMESPACE_URI);\n\n\t\t// response object is read from global variable $response\n\t\tVariable var = myModule.resolveVariable(ResponseModule.RESPONSE_VAR);\n\t\tif(var == null || var.getValue() == null)\n\t\t\tthrow new XPathException(\"Response not set\");\n\t\tif(var.getValue().getItemType() != Type.JAVA_OBJECT)\n\t\t\tthrow new XPathException(\"Variable $response is not bound to a Java object.\");\n\t\tJavaObjectValue response = (JavaObjectValue)var.getValue().itemAt(0);\n\t\t\n\t\t//get parameters\n\t\tString name = getArgument(0).eval(contextSequence, contextItem).getStringValue();\n\t\tString value = getArgument(1).eval(contextSequence, contextItem).getStringValue();\n\t\tSequence ageSeq = getArgument(2).eval(contextSequence, contextItem);\n\t\t//set response header\n\t\tif(response.getObject() instanceof ResponseWrapper) {\n\t\t    if (ageSeq.isEmpty()) {\n\t\t\t((ResponseWrapper) response.getObject()).addCookie(name, value);\n\t\t    } else {\n\t\t\tDuration duration = ((DurationValue) ageSeq.itemAt(0)).getCanonicalDuration();\n\t\t\tint maxAge = (int) (duration.getTimeInMillis(new Date(System.currentTimeMillis())) / 1000L);\n\t\t\t((ResponseWrapper) response.getObject()).addCookie(name, value, maxAge);\n\t\t    }\n\t\t} else {\n\t\t    throw new XPathException(\"Type error: variable $response is not bound to a response object\");\n\t\t}\n\t\treturn Sequence.EMPTY_SEQUENCE;\n\t}","id":75826,"modified_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n\t\tif (context.getProfiler().isEnabled()) {\n\t\t\tcontext.getProfiler().start(this);       \n\t\t\tcontext.getProfiler().message(this, Profiler.DEPENDENCIES, \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n\t\t\tif (contextSequence != null) {\n\t\t\t\tcontext.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT SEQUENCE\", contextSequence);\n\t\t\t}\n\t\t\tif (contextItem != null) {\n\t\t\t\tcontext.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT ITEM\", contextItem.toSequence());\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tResponseModule myModule = (ResponseModule)context.getModule(ResponseModule.NAMESPACE_URI);\n\t\t\n\t\t// response object is read from global variable $response\n\t\tVariable var = myModule.resolveVariable(ResponseModule.RESPONSE_VAR);\n\t\tif(var == null || var.getValue() == null) {\n\t\t\tthrow new XPathException(\"Response not set\");\n\t\t}\n\t\tif(var.getValue().getItemType() != Type.JAVA_OBJECT) {\n\t\t\tthrow new XPathException(\"Variable $response is not bound to a Java object.\");\n\t\t}\n\t\tJavaObjectValue response = (JavaObjectValue)var.getValue().itemAt(0);\n\t\t\n\t\t//get parameters\n\t\tString name = getArgument(0).eval(contextSequence, contextItem).getStringValue();\n\t\tString value = getArgument(1).eval(contextSequence, contextItem).getStringValue();\n\t\tSequence ageSeq = getArgument(2).eval(contextSequence, contextItem);\n\t\t//set response header\n\t\tif(response.getObject() instanceof ResponseWrapper) {\n\t\t\tif (ageSeq.isEmpty()) {\n\t\t\t\t((ResponseWrapper) response.getObject()).addCookie(name, value);\n\t\t\t} else {\n\t\t\t\tDuration duration = ((DurationValue) ageSeq.itemAt(0)).getCanonicalDuration();\n\t\t\t\tint maxAge = (int) (duration.getTimeInMillis(new Date(System.currentTimeMillis())) / 1000L);\n\t\t\t\t\n\t\t\t\tSequence secureSeq = getArgument(3).eval(contextSequence, contextItem);\n\t\t\t\t\n\t\t\t\tif (secureSeq.isEmpty()) {\n\t\t\t\t\t((ResponseWrapper) response.getObject()).addCookie(name, value, maxAge);\n\t\t\t\t} else {\n\t\t\t\t\t((ResponseWrapper) response.getObject()).addCookie(name, value, maxAge, ((BooleanValue)secureSeq.itemAt(0)).effectiveBooleanValue() );\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new XPathException(\"Type error: variable $response is not bound to a response object\");\n\t\t}\n\t\treturn Sequence.EMPTY_SEQUENCE;\n\t}","commit_id":"e4da3332900384300e291b7ac366a91c8b20ca3d","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n  protected JComponent createCenterPanel() {\n    JPanel panel = new JPanel(new BorderLayout());\n    JBSplitter splitter = new JBSplitter(true, .5F, .2F, .8F);\n    splitter.setFirstComponent(new JBScrollPane(myRequestsTable, ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED, ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER));\n\n    final JComponent consoleComponent = new JPanel(new BorderLayout());\n    consoleComponent.add(consoleView.getComponent(), BorderLayout.CENTER);\n    consoleView.print(ExceptionUtil.getThrowableText(myRequests.get(myRequestsTable.getSelectedRow()).trace), ConsoleViewContentType.NORMAL_OUTPUT);\n\n    splitter.setSecondComponent(\n      new JBScrollPane(consoleComponent, ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED, ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER));\n    panel.add(splitter, BorderLayout.CENTER);\n    return panel;\n  }","id":75827,"modified_method":"@Override\n  protected JComponent createCenterPanel() {\n    JPanel panel = new JPanel(new BorderLayout());\n    JBSplitter splitter = new JBSplitter(true, .5F, .2F, .8F);\n    splitter.setFirstComponent(new JBScrollPane(myRequestsTable, ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED, ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER));\n\n    JComponent consoleComponent = new JPanel(new BorderLayout());\n    consoleComponent.add(consoleView.getComponent(), BorderLayout.CENTER);\n    int row = myRequestsTable.getSelectedRow();\n    if (row >= 0) {\n      consoleView.print(ExceptionUtil.getThrowableText(myRequests.get(row).trace), ConsoleViewContentType.NORMAL_OUTPUT);\n    }\n\n    splitter.setSecondComponent(\n      new JBScrollPane(consoleComponent, ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED, ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER));\n    panel.add(splitter, BorderLayout.CENTER);\n    return panel;\n  }","commit_id":"daa1d55185931673410b5fa389375e9f6c7e080c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addActions() {\n    // show on enter\n    myBreakpointsTable.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0), COMMAND_SHOW_NODE);\n    myBreakpointsTable.getActionMap().put(COMMAND_SHOW_NODE, new AbstractAction() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        AbstractMPSBreakpoint breakpoint = getSelectedBreakpoint();\n        if (breakpoint == null) return;\n        openNode(breakpoint, false, true);\n      }\n    });\n\n    // open on f4\n    myBreakpointsTable.registerKeyboardAction(new AbstractAction() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        AbstractMPSBreakpoint breakpoint = getSelectedBreakpoint();\n        if (breakpoint == null) return;\n        dispose();\n        openNode(breakpoint, true, true);\n      }\n    }, KeyStroke.getKeyStroke(\"F4\"), JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\n\n    // delete on del\n    myBreakpointsTable.registerKeyboardAction(new AbstractAction() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        MyAbstractTableModel model = (MyAbstractTableModel) myBreakpointsTable.getModel();\n        model.getBreakpointAt(myBreakpointsTable.getSelectedRow());\n        final AbstractMPSBreakpoint breakpoint = model.getBreakpointAt(myBreakpointsTable.getSelectedRow());\n        if (breakpoint == null) return;\n        ModelAccess.instance().runReadAction(new Runnable() {\n          @Override\n          public void run() {\n            myBreakpointsManager.removeBreakpoint(breakpoint);\n          }\n        });\n        myBreakpointsTableModel.reloadBreakpoints();\n      }\n    }, KeyStroke.getKeyStroke(\"DELETE\"), JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\n\n    // open on double click\n    myBreakpointsTable.addMouseListener(new MouseAdapter() {\n      @Override\n      public void mouseClicked(MouseEvent e) {\n        if (e.getClickCount() == 2) {\n          AbstractMPSBreakpoint breakpoint = getSelectedBreakpoint();\n          if (breakpoint == null) return;\n          dispose();\n          openNode(breakpoint, true, true);\n        }\n      }\n    });\n  }","id":75828,"modified_method":"private void addActions() {\n    // show on enter\n    myBreakpointsTable.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0), COMMAND_SHOW_NODE);\n    myBreakpointsTable.getActionMap().put(COMMAND_SHOW_NODE, new AbstractAction() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        AbstractMPSBreakpoint breakpoint = getSelectedBreakpoint();\n        if (breakpoint == null) return;\n        openNode(breakpoint, false, true);\n      }\n    });\n\n    // open on f4\n    myBreakpointsTable.registerKeyboardAction(new AbstractAction() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        AbstractMPSBreakpoint breakpoint = getSelectedBreakpoint();\n        if (breakpoint == null) return;\n        dispose();\n        openNode(breakpoint, true, true);\n      }\n    }, KeyStroke.getKeyStroke(\"F4\"), JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\n\n    // delete on del\n    myBreakpointsTable.registerKeyboardAction(new AbstractAction() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        int selectedRow = myBreakpointsTable.getSelectedRow();\n        final AbstractMPSBreakpoint breakpoint = getSelectedBreakpoint();\n        if (breakpoint == null) return;\n        ModelAccess.instance().runReadAction(new Runnable() {\n          @Override\n          public void run() {\n            myBreakpointsManager.removeBreakpoint(breakpoint);\n          }\n        });\n        myBreakpointsTableModel.breakpointDeleted(selectedRow);\n      }\n    }, KeyStroke.getKeyStroke(\"DELETE\"), JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\n\n    // open on double click\n    myBreakpointsTable.addMouseListener(new MouseAdapter() {\n      @Override\n      public void mouseClicked(MouseEvent e) {\n        if (e.getClickCount() == 2) {\n          AbstractMPSBreakpoint breakpoint = getSelectedBreakpoint();\n          if (breakpoint == null) return;\n          dispose();\n          openNode(breakpoint, true, true);\n        }\n      }\n    });\n  }","commit_id":"8a3e33412d2fe19933c65f682d4a645a64e0ad48","url":"https://github.com/JetBrains/MPS"},{"original_method":"private AbstractMPSBreakpoint getSelectedBreakpoint() {\n    MyAbstractTableModel model = (MyAbstractTableModel) myBreakpointsTable.getModel();\n    model.getBreakpointAt(myBreakpointsTable.getSelectedRow());\n    AbstractMPSBreakpoint breakpoint = model.getBreakpointAt(myBreakpointsTable.getSelectedRow());\n    return breakpoint;\n  }","id":75829,"modified_method":"private AbstractMPSBreakpoint getSelectedBreakpoint() {\n    MyAbstractTableModel model = (MyAbstractTableModel) myBreakpointsTable.getModel();\n    int selectedRow = myBreakpointsTable.getSelectedRow();\n    if (selectedRow < 0 || selectedRow >= model.getRowCount()) {\n      return null;\n    }\n    model.getBreakpointAt(selectedRow);\n    AbstractMPSBreakpoint breakpoint = model.getBreakpointAt(myBreakpointsTable.getSelectedRow());\n    return breakpoint;\n  }","commit_id":"8a3e33412d2fe19933c65f682d4a645a64e0ad48","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static PsiType getLeastContainingTypeArgument(PsiType type1,\n                                                        PsiType type2,\n                                                        Set<Pair<PsiType, PsiType>> compared,\n                                                        PsiManager manager) {\n    Pair<PsiType, PsiType> types = new Pair<PsiType, PsiType>(type1, type2);\n    if (compared.contains(types)) return PsiWildcardType.createUnbounded(manager);\n    compared.add(types);\n\n    try {\n      if (type1 instanceof PsiWildcardType) {\n        PsiWildcardType wild1 = (PsiWildcardType)type1;\n        if (type2 instanceof PsiWildcardType) {\n          PsiWildcardType wild2 = (PsiWildcardType)type2;\n          if (wild1.isExtends() == wild2.isExtends()) {\n            return wild1.isExtends() ? PsiWildcardType.createExtends(manager,\n                                                                     getLeastUpperBound(wild1.getBound(), wild2.getBound(), compared,\n                                                                                        manager)) :\n                                                                                                  wild1.isSuper() ? PsiWildcardType.createSuper(manager, getGreatestLowerBound(wild1.getBound(), wild2.getBound())) :\n                                                                                                  wild1;\n          }\n          else {\n            return wild1.getBound().equals(wild2.getBound()) ? wild1.getBound() : PsiWildcardType.createUnbounded(manager);\n          }\n        }\n        else {\n          return wild1.isExtends() ? PsiWildcardType.createExtends(manager, getLeastUpperBound(wild1.getBound(), type2, compared, manager)) :\n                 wild1.isSuper() ? PsiWildcardType.createSuper(manager, getGreatestLowerBound(wild1.getBound(), type2)) :\n                 wild1;\n        }\n      }\n      else if (type2 instanceof PsiWildcardType) {\n        return getLeastContainingTypeArgument(type2, type1, compared, manager);\n      }\n      //Done with wildcards\n\n      if (type1.equals(type2)) return type1;\n      return PsiWildcardType.createExtends(manager, getLeastUpperBound(type1, type2, compared, manager));\n    }\n    finally {\n      compared.remove(types);\n    }\n  }","id":75830,"modified_method":"private static PsiType getLeastContainingTypeArgument(PsiType type1,\n                                                        PsiType type2,\n                                                        Set<Pair<PsiType, PsiType>> compared,\n                                                        PsiManager manager) {\n    Pair<PsiType, PsiType> types = new Pair<PsiType, PsiType>(type1, type2);\n    if (compared.contains(types)) return PsiWildcardType.createUnbounded(manager);\n    compared.add(types);\n\n    try {\n      if (type1 instanceof PsiWildcardType) {\n        PsiWildcardType wild1 = (PsiWildcardType)type1;\n        final PsiType bound1 = wild1.getBound();\n        if (bound1 == null) return type2;\n        if (type2 instanceof PsiWildcardType) {\n          PsiWildcardType wild2 = (PsiWildcardType)type2;\n          final PsiType bound2 = wild2.getBound();\n          if (bound2 == null) return wild1;\n          if (wild1.isExtends() == wild2.isExtends()) {\n            return wild1.isExtends() ? PsiWildcardType.createExtends(manager,\n                                                                     getLeastUpperBound(bound1, bound2, compared,\n                                                                                        manager)) :\n                                                                                                  wild1.isSuper() ? PsiWildcardType.createSuper(manager, getGreatestLowerBound(bound1, bound2)) :\n                                                                                                  wild1;\n          }\n          else {\n            return bound1.equals(bound2) ? bound1 : PsiWildcardType.createUnbounded(manager);\n          }\n        }\n        else {\n          return wild1.isExtends() ? PsiWildcardType.createExtends(manager, getLeastUpperBound(bound1, type2, compared, manager)) :\n                 wild1.isSuper() ? PsiWildcardType.createSuper(manager, getGreatestLowerBound(bound1, type2)) :\n                 wild1;\n        }\n      }\n      else if (type2 instanceof PsiWildcardType) {\n        return getLeastContainingTypeArgument(type2, type1, compared, manager);\n      }\n      //Done with wildcards\n\n      if (type1.equals(type2)) return type1;\n      return PsiWildcardType.createExtends(manager, getLeastUpperBound(type1, type2, compared, manager));\n    }\n    finally {\n      compared.remove(types);\n    }\n  }","commit_id":"7be867908f3a5ae37f872e10f9d6e23a8e3f73f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiType inferTypeForMethodTypeParameter(final PsiTypeParameter typeParameter,\n                                                 final PsiParameter[] parameters,\n                                                 PsiExpression[] arguments,\n                                                 PsiSubstitutor partialSubstitutor,\n                                                 PsiElement parent,\n                                                 final boolean forCompletion) {\n    PsiType substitution = PsiType.NULL;\n    if (parameters.length > 0) {\n      for (int j = 0; j < arguments.length; j++) {\n        PsiExpression argument = arguments[j];\n        final PsiParameter parameter = parameters[Math.min(j, parameters.length - 1)];\n        if (j >= parameters.length && !parameter.isVarArgs()) break;\n        PsiType parameterType = parameter.getType();\n        PsiType argumentType = argument.getType();\n        if (argumentType == null) continue;\n\n        if (parameterType instanceof PsiEllipsisType) {\n          parameterType = ((PsiEllipsisType)parameterType).getComponentType();\n          if (arguments.length == parameters.length && argumentType instanceof PsiArrayType && !(((PsiArrayType)argumentType).getComponentType() instanceof PsiPrimitiveType)) {\n            argumentType = ((PsiArrayType)argumentType).getComponentType();\n          }\n        }\n        final PsiType currentSubstitution = getSubstitutionForTypeParameter(typeParameter, parameterType,\n                                                                            argumentType, true);\n        if (currentSubstitution == null) {\n          substitution = null;\n          break;\n        } else if (currentSubstitution instanceof PsiCapturedWildcardType) {\n          if (substitution instanceof PsiCapturedWildcardType) return PsiType.NULL;\n        } else if (currentSubstitution == PsiType.NULL) continue;\n\n        if (substitution == PsiType.NULL) {\n          substitution = currentSubstitution;\n          continue;\n        }\n        if (!substitution.equals(currentSubstitution) && !substitution.isAssignableFrom(currentSubstitution)) {\n          if (!currentSubstitution.isAssignableFrom(substitution)) {\n            substitution = GenericsUtil.getLeastUpperBound(substitution, currentSubstitution, typeParameter.getManager());\n            if (substitution == null) {\n              break;\n            }\n          }\n          else {\n            substitution = currentSubstitution;\n          }\n        }\n      }\n    }\n\n    if (substitution == PsiType.NULL) {\n      substitution = inferMethodTypeParameterFromParent(typeParameter, partialSubstitutor, parent, forCompletion);\n    }\n    return substitution;\n  }","id":75831,"modified_method":"public PsiType inferTypeForMethodTypeParameter(final PsiTypeParameter typeParameter,\n                                                 final PsiParameter[] parameters,\n                                                 PsiExpression[] arguments,\n                                                 PsiSubstitutor partialSubstitutor,\n                                                 PsiElement parent,\n                                                 final boolean forCompletion) {\n    PsiType substitution = PsiType.NULL;\n    if (parameters.length > 0) {\n      for (int j = 0; j < arguments.length; j++) {\n        PsiExpression argument = arguments[j];\n        final PsiParameter parameter = parameters[Math.min(j, parameters.length - 1)];\n        if (j >= parameters.length && !parameter.isVarArgs()) break;\n        PsiType parameterType = parameter.getType();\n        PsiType argumentType = argument.getType();\n        if (argumentType == null) continue;\n\n        if (parameterType instanceof PsiEllipsisType) {\n          parameterType = ((PsiEllipsisType)parameterType).getComponentType();\n          if (arguments.length == parameters.length && argumentType instanceof PsiArrayType && !(((PsiArrayType)argumentType).getComponentType() instanceof PsiPrimitiveType)) {\n            argumentType = ((PsiArrayType)argumentType).getComponentType();\n          }\n        }\n        final PsiType currentSubstitution = getSubstitutionForTypeParameter(typeParameter, parameterType,\n                                                                            argumentType, true);\n        if (currentSubstitution == null) {\n          substitution = null;\n          break;\n        } else if (currentSubstitution instanceof PsiCapturedWildcardType) {\n          if (substitution instanceof PsiCapturedWildcardType) return PsiType.NULL;\n        } else if (currentSubstitution == PsiType.NULL) continue;\n\n        if (substitution == PsiType.NULL) {\n          substitution = currentSubstitution;\n          continue;\n        }\n        if (!substitution.equals(currentSubstitution)) {\n          substitution = GenericsUtil.getLeastUpperBound(substitution, currentSubstitution, typeParameter.getManager());\n          if (substitution == null) break;\n        }\n      }\n    }\n\n    if (substitution == PsiType.NULL) {\n      substitution = inferMethodTypeParameterFromParent(typeParameter, partialSubstitutor, parent, forCompletion);\n    }\n    return substitution;\n  }","commit_id":"7be867908f3a5ae37f872e10f9d6e23a8e3f73f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean typesAgree(PsiType typeLeft, PsiType typeRight) {\n    if (typeLeft instanceof PsiWildcardType) {\n      final PsiWildcardType leftWildcard = (PsiWildcardType)typeLeft;\n      if (leftWildcard.getBound() == null) return true;\n      if (typeRight instanceof PsiWildcardType) {\n        final PsiWildcardType rightWildcard = ((PsiWildcardType)typeRight);\n        if (leftWildcard.isExtends()) {\n          return rightWildcard.isExtends() && isAssignable(leftWildcard.getBound(), rightWildcard.getBound(), false);\n        }\n        else { //isSuper\n          return rightWildcard.isSuper() && isAssignable(rightWildcard.getBound(), leftWildcard.getBound(), false);\n        }\n      }\n      else {\n        if (leftWildcard.isExtends()) {\n          return isAssignable(leftWildcard.getBound(), typeRight, false);\n        }\n        else { // isSuper\n          return isAssignable(typeRight, leftWildcard.getBound(), false);\n        }\n      }\n    }\n    else {\n      return typeLeft.equals(typeRight);\n    }\n  }","id":75832,"modified_method":"private static boolean typesAgree(PsiType typeLeft, PsiType typeRight) {\n    if (typeLeft instanceof PsiWildcardType) {\n      final PsiWildcardType leftWildcard = (PsiWildcardType)typeLeft;\n      final PsiType leftBound = leftWildcard.getBound();\n      if (leftBound == null || leftBound.equalsToText(\"java.lang.Object\")) return true;\n      if (typeRight instanceof PsiWildcardType) {\n        final PsiWildcardType rightWildcard = ((PsiWildcardType)typeRight);\n        if (leftWildcard.isExtends()) {\n          return rightWildcard.isExtends() && isAssignable(leftBound, rightWildcard.getBound(), false);\n        }\n        else { //isSuper\n          return rightWildcard.isSuper() && isAssignable(rightWildcard.getBound(), leftBound, false);\n        }\n      }\n      else {\n        if (leftWildcard.isExtends()) {\n          return isAssignable(leftBound, typeRight, false);\n        }\n        else { // isSuper\n          return isAssignable(typeRight, leftBound, false);\n        }\n      }\n    }\n    else {\n      return typeLeft.equals(typeRight);\n    }\n  }","commit_id":"3cd17253e0322d2a4652acb0611472a2dff68164","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tgetSupportActionBar().setTitle(R.string.av_settings);\n\t\tPreferenceScreen grp = getPreferenceScreen();\n\t\tAudioVideoNotesPlugin p = OsmandPlugin.getEnabledPlugin(AudioVideoNotesPlugin.class);\n\t\tif (p != null) {\n\t\t\tString[] entries;\n\t\t\tInteger[] intValues;\n\n\t\t\tentries = new String[] { getString(R.string.av_def_action_choose), getString(R.string.av_def_action_audio),\n\t\t\t\t\tgetString(R.string.av_def_action_video), getString(R.string.av_def_action_picture) };\n\t\t\tintValues = new Integer[] { AV_DEFAULT_ACTION_CHOOSE, AV_DEFAULT_ACTION_AUDIO, AV_DEFAULT_ACTION_VIDEO,\n\t\t\t\t\tAV_DEFAULT_ACTION_TAKEPICTURE };\n\t\t\tListPreference defAct = createListPreference(p.AV_DEFAULT_ACTION, entries, intValues, R.string.av_widget_action,\n\t\t\t\t\tR.string.av_widget_action_descr);\n\t\t\tgrp.addPreference(defAct);\n\t\t\t\n\t\t\t// camera type settings:\n\t\t\tgrp.addPreference(createCheckBoxPreference(p.AV_EXTERNAL_PHOTO_CAM, R.string.av_use_external_camera,\n\t\t\t\t\tR.string.av_use_external_camera_descr));\n\t\t\t// focus mode settings:\n\t\t\t// show in menu only suppoted modes:\n\t\t\tfinal Camera cam = openCamera();\n\t\t\tParameters parameters = cam.getParameters();\n\t\t\tList<String> sfm=parameters.getSupportedFocusModes ();\n\t\t\tList<String> items=new ArrayList <String>();\n\t\t\tList<Integer> itemsValues=new ArrayList <Integer>();\n\t\t\t// filtering known types for translate and set index:\n\t\t\tfor(int index=0;index<sfm.size();index++)\n\t\t\t{\n\t\t\t\tif(sfm.get(index).equals(\"auto\"))\n\t\t\t\t{\n\t\t\t\t\titems.add(getString(R.string.av_camera_focus_auto));\n\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_AUTO);\n\t\t\t\t}\n\t\t\t\telse if(sfm.get(index).equals(\"fixed\"))\n\t\t\t\t{\n\t\t\t\t\titems.add(getString(R.string.av_camera_focus_hiperfocal));\n\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_HIPERFOCAL);\n\t\t\t\t}\n\t\t\t\telse if(sfm.get(index).equals(\"edof\"))\n\t\t\t\t{\n\t\t\t\t\titems.add(getString(R.string.av_camera_focus_edof));\n\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_EDOF);\n\t\t\t\t}\n\t\t\t\telse if(sfm.get(index).equals(\"infinity\"))\n\t\t\t\t{\n\t\t\t\t\titems.add(getString(R.string.av_camera_focus_infinity));\n\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_INFINITY);\n\t\t\t\t}\n\t\t\t\telse if(sfm.get(index).equals(\"macro\"))\n\t\t\t\t{\n\t\t\t\t\titems.add(getString(R.string.av_camera_focus_macro));\n\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_MACRO);\n\t\t\t\t}\n\t\t\t\telse if(sfm.get(index).equals(\"continuous-picture\"))\n\t\t\t\t{\n\t\t\t\t\titems.add(getString(R.string.av_camera_focus_continuous));\n\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_CONTINUOUS);\n\t\t\t\t}\n\t\t\t}\n\t\t\tentries=items.toArray(entries);\n\t\t\tintValues=itemsValues.toArray(intValues);\n\t\t\tListPreference camFocus = createListPreference(p.AV_CAMERA_FOCUS_TYPE, entries, intValues, R.string.av_camera_focus,\n\t\t\t\t\tR.string.av_camera_focus_descr);\n\t\t\tgrp.addPreference(camFocus);\n\t\t\t// play sound on success photo:\n\t\t\tgrp.addPreference(createCheckBoxPreference(p.AV_PHOTO_PLAY_SOUND, R.string.av_photo_play_sound,\n\t\t\t\t\tR.string.av_photo_play_sound_descr));\n\t\t\tcam.release();\n\n\n\t\t\t// video settings:\n\t\t\tgrp.addPreference(createCheckBoxPreference(p.AV_EXTERNAL_RECORDER, R.string.av_use_external_recorder,\n\t\t\t\t\tR.string.av_use_external_recorder_descr));\n\t\t\t\n\t\t\tentries = new String[] { \"3GP\", \"MP4\" };\n\t\t\tintValues = new Integer[] { VIDEO_OUTPUT_3GP, VIDEO_OUTPUT_MP4 };\n\t\t\tListPreference lp = createListPreference(p.AV_VIDEO_FORMAT, entries, intValues, R.string.av_video_format,\n\t\t\t\t\tR.string.av_video_format_descr);\n\t\t\tgrp.addPreference(lp);\n\t\t}\n\t}","id":75833,"modified_method":"@Override\n    public void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tgetSupportActionBar().setTitle(R.string.av_settings);\n\t\tPreferenceScreen grp = getPreferenceScreen();\n\t\tAudioVideoNotesPlugin p = OsmandPlugin.getEnabledPlugin(AudioVideoNotesPlugin.class);\n\t\tif (p != null) {\n\t\t\tString[] entries;\n\t\t\tInteger[] intValues;\n\n\t\t\tentries = new String[] { getString(R.string.av_def_action_choose), getString(R.string.av_def_action_audio),\n\t\t\t\t\tgetString(R.string.av_def_action_video), getString(R.string.av_def_action_picture) };\n\t\t\tintValues = new Integer[] { AV_DEFAULT_ACTION_CHOOSE, AV_DEFAULT_ACTION_AUDIO, AV_DEFAULT_ACTION_VIDEO,\n\t\t\t\t\tAV_DEFAULT_ACTION_TAKEPICTURE };\n\t\t\tListPreference defAct = createListPreference(p.AV_DEFAULT_ACTION, entries, intValues, R.string.av_widget_action,\n\t\t\t\t\tR.string.av_widget_action_descr);\n\t\t\tgrp.addPreference(defAct);\n\t\t\t\n\t\t\t// camera type settings:\n\t\t\tgrp.addPreference(createCheckBoxPreference(p.AV_EXTERNAL_PHOTO_CAM, R.string.av_use_external_camera,\n\t\t\t\t\tR.string.av_use_external_camera_descr));\n\t\t\t// focus mode settings:\n\t\t\t// show in menu only suppoted modes:\n\t\t\tfinal Camera cam = openCamera();\n\t\t\tParameters parameters = cam.getParameters();\n\t\t\tList<String> sfm = parameters.getSupportedFocusModes();\n\t\t\tList<String> items = new ArrayList<String>();\n\t\t\tList<Integer> itemsValues = new ArrayList<Integer>();\n\t\t\t// filtering known types for translate and set index:\n\t\t\tfor (int index = 0; index < sfm.size(); index++) {\n\t\t\t\tif (sfm.get(index).equals(\"auto\")) {\n\t\t\t\t\titems.add(getString(R.string.av_camera_focus_auto));\n\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_AUTO);\n\t\t\t\t} else if (sfm.get(index).equals(\"fixed\")) {\n\t\t\t\t\titems.add(getString(R.string.av_camera_focus_hiperfocal));\n\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_HIPERFOCAL);\n\t\t\t\t} else if (sfm.get(index).equals(\"edof\")) {\n\t\t\t\t\titems.add(getString(R.string.av_camera_focus_edof));\n\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_EDOF);\n\t\t\t\t} else if (sfm.get(index).equals(\"infinity\")) {\n\t\t\t\t\titems.add(getString(R.string.av_camera_focus_infinity));\n\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_INFINITY);\n\t\t\t\t} else if (sfm.get(index).equals(\"macro\")) {\n\t\t\t\t\titems.add(getString(R.string.av_camera_focus_macro));\n\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_MACRO);\n\t\t\t\t} else if (sfm.get(index).equals(\"continuous-picture\")) {\n\t\t\t\t\titems.add(getString(R.string.av_camera_focus_continuous));\n\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_CONTINUOUS);\n\t\t\t\t}\n\t\t\t}\n\t\t\tentries = items.toArray(entries);\n\t\t\tintValues = itemsValues.toArray(intValues);\n\t\t\tif (entries.length > 0) {\n\t\t\t\tListPreference camFocus = createListPreference(p.AV_CAMERA_FOCUS_TYPE, entries, intValues, R.string.av_camera_focus,\n\t\t\t\t\t\tR.string.av_camera_focus_descr);\n\t\t\t\tgrp.addPreference(camFocus);\n\t\t\t}\n\t\t\t// play sound on success photo:\n\t\t\tgrp.addPreference(createCheckBoxPreference(p.AV_PHOTO_PLAY_SOUND, R.string.av_photo_play_sound,\n\t\t\t\t\tR.string.av_photo_play_sound_descr));\n\t\t\tcam.release();\n\n\n\t\t\t// video settings:\n\t\t\tgrp.addPreference(createCheckBoxPreference(p.AV_EXTERNAL_RECORDER, R.string.av_use_external_recorder,\n\t\t\t\t\tR.string.av_use_external_recorder_descr));\n\t\t\t\n\t\t\tentries = new String[] { \"3GP\", \"MP4\" };\n\t\t\tintValues = new Integer[] { VIDEO_OUTPUT_3GP, VIDEO_OUTPUT_MP4 };\n\t\t\tListPreference lp = createListPreference(p.AV_VIDEO_FORMAT, entries, intValues, R.string.av_video_format,\n\t\t\t\t\tR.string.av_video_format_descr);\n\t\t\tgrp.addPreference(lp);\n\t\t}\n\t}","commit_id":"2f2c79ea5a4bacb30ab55a8abd27c6d470e9f6a2","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void settingsActivityCreate(final SettingsActivity activity, final PreferenceScreen screen) {\n\t\tPreferenceScreen grp = screen.getPreferenceManager().createPreferenceScreen(activity);\n\t\tgrp.setTitle(R.string.accessibility_preferences);\n\t\tgrp.setSummary(R.string.accessibility_preferences_descr);\n\t\tgrp.setKey(\"accessibility_preferences\");\n\t\tscreen.addPreference(grp);\n\n\t\tString[] entries = new String[AccessibilityMode.values().length];\n\t\tfor (int i = 0; i < entries.length; i++) {\n\t\t\tentries[i] = AccessibilityMode.values()[i].toHumanString((ClientContext) activity.getApplication());\n\t\t}\n\t\taccessibilityModePreference = activity.createListPreference(settings.ACCESSIBILITY_MODE, entries, AccessibilityMode.values(),\n\t\t\t\tR.string.accessibility_mode, R.string.accessibility_mode_descr);\n\t\taccessibilityModePreference.setOnPreferenceChangeListener(new OnPreferenceChangeListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onPreferenceChange(Preference preference, Object newValue) {\n\t\t\t\tPreferenceCategory accessibilityOptions = ((PreferenceCategory)(screen.findPreference(\"accessibility_options\")));\n\t\t\t\tif (accessibilityOptions != null)\n\t\t\t\t\taccessibilityOptions.setEnabled(app.getInternalAPI().accessibilityEnabled());\n\t\t\t\taccessibilityModePreference.setSummary(app.getString(R.string.accessibility_mode_descr) + \"  [\" + settings.ACCESSIBILITY_MODE.get().toHumanString(app) + \"]\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\t\n\t\tgrp.addPreference(accessibilityModePreference);\n\t\tPreferenceCategory cat = new PreferenceCategory(activity);\n\t\tcat.setKey(\"accessibility_options\");\n\t\tgrp.addPreference(cat);\n\n\t\tentries = new String[RelativeDirectionStyle.values().length];\n\t\tfor (int i = 0; i < entries.length; i++) {\n\t\t\tentries[i] = RelativeDirectionStyle.values()[i].toHumanString((ClientContext) activity.getApplication());\n\t\t}\n\t\tdirectionStylePreference = activity.createListPreference(settings.DIRECTION_STYLE, entries, RelativeDirectionStyle.values(),\n\t\t\t\tR.string.settings_direction_style, R.string.settings_direction_style_descr);\n\t\tdirectionStylePreference.setOnPreferenceChangeListener(new OnPreferenceChangeListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onPreferenceChange(Preference preference, Object newValue) {\n\t\t\t\tdirectionStylePreference.setSummary(app.getString(R.string.settings_direction_style_descr) + \"  [\" + settings.DIRECTION_STYLE.get().toHumanString(app) + \"]\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\tcat.addPreference(directionStylePreference);\n\n\t\tcat.addPreference(activity.createCheckBoxPreference(settings.ZOOM_BY_TRACKBALL, R.string.zoom_by_trackball,\n\t\t\t\tR.string.zoom_by_trackball_descr));\n\t\tcat.addPreference(activity.createCheckBoxPreference(settings.SCROLL_MAP_BY_GESTURES, R.string.scroll_map_by_gestures,\n\t\t\t\tR.string.scroll_map_by_gestures_descr));\n\t\tcat.addPreference(activity.createCheckBoxPreference(settings.USE_SHORT_OBJECT_NAMES, R.string.use_short_object_names,\n\t\t\t\tR.string.use_short_object_names_descr));\n\t\tcat.addPreference(activity.createCheckBoxPreference(settings.ACCESSIBILITY_EXTENSIONS, R.string.accessibility_extensions,\n\t\t\t\tR.string.accessibility_extensions));\n\t}","id":75834,"modified_method":"@Override\n\tpublic void settingsActivityCreate(final SettingsActivity activity, final PreferenceScreen screen) {\n\t\tPreferenceScreen grp = screen.getPreferenceManager().createPreferenceScreen(activity);\n\t\tgrp.setTitle(R.string.accessibility_preferences);\n\t\tgrp.setSummary(R.string.accessibility_preferences_descr);\n\t\tgrp.setKey(\"accessibility_preferences\");\n\t\tscreen.addPreference(grp);\n\n\t\tString[] entries = new String[AccessibilityMode.values().length];\n\t\tfor (int i = 0; i < entries.length; i++) {\n\t\t\tentries[i] = AccessibilityMode.values()[i].toHumanString((ClientContext) activity.getApplication());\n\t\t}\n\t\taccessibilityModePreference = activity.createListPreference(settings.ACCESSIBILITY_MODE, entries, AccessibilityMode.values(),\n\t\t\t\tR.string.accessibility_mode, R.string.accessibility_mode_descr);\n\t\taccessibilityModePreference.setOnPreferenceChangeListener(new OnPreferenceChangeListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onPreferenceChange(Preference preference, Object newValue) {\n\t\t\t\tPreferenceCategory accessibilityOptions = ((PreferenceCategory)(screen.findPreference(\"accessibility_options\")));\n\t\t\t\tif (accessibilityOptions != null)\n\t\t\t\t\taccessibilityOptions.setEnabled(app.getInternalAPI().accessibilityEnabled());\n\t\t\t\taccessibilityModePreference.setSummary(app.getString(R.string.accessibility_mode_descr) + \"  [\" + settings.ACCESSIBILITY_MODE.get().toHumanString(app) + \"]\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\t\n\t\tgrp.addPreference(accessibilityModePreference);\n\t\tPreferenceCategory cat = new PreferenceCategory(activity);\n\t\tcat.setKey(\"accessibility_options\");\n\t\tgrp.addPreference(cat);\n\n\t\tentries = new String[RelativeDirectionStyle.values().length];\n\t\tfor (int i = 0; i < entries.length; i++) {\n\t\t\tentries[i] = RelativeDirectionStyle.values()[i].toHumanString((ClientContext) activity.getApplication());\n\t\t}\n\t\tdirectionStylePreference = activity.createListPreference(settings.DIRECTION_STYLE, entries, RelativeDirectionStyle.values(),\n\t\t\t\tR.string.settings_direction_style, R.string.settings_direction_style_descr);\n\t\tdirectionStylePreference.setOnPreferenceChangeListener(new OnPreferenceChangeListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onPreferenceChange(Preference preference, Object newValue) {\n\t\t\t\tdirectionStylePreference.setSummary(app.getString(R.string.settings_direction_style_descr) + \"  [\" + settings.DIRECTION_STYLE.get().toHumanString(app) + \"]\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\tcat.addPreference(directionStylePreference);\n\n\t\tcat.addPreference(activity.createCheckBoxPreference(settings.ZOOM_BY_TRACKBALL, R.string.zoom_by_trackball,\n\t\t\t\tR.string.zoom_by_trackball_descr));\n\t\tcat.addPreference(activity.createCheckBoxPreference(settings.SCROLL_MAP_BY_GESTURES, R.string.scroll_map_by_gestures,\n\t\t\t\tR.string.scroll_map_by_gestures_descr));\n\t\tcat.addPreference(activity.createCheckBoxPreference(settings.USE_SHORT_OBJECT_NAMES, R.string.use_short_object_names,\n\t\t\t\tR.string.use_short_object_names_descr));\n\t\tif (Build.VERSION.SDK_INT < 14) // Build.VERSION_CODES.ICE_CREAM_SANDWICH\n\t\t\tcat.addPreference(activity.createCheckBoxPreference(settings.ACCESSIBILITY_EXTENSIONS, R.string.accessibility_extensions,\n\t\t\t\t\tR.string.accessibility_extensions));\n\t}","commit_id":"b3e12061e0a66666cad1869e2086f1374adc46dd","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n    public Builder setMessage(int msgid) {\n        if (((OsmandApplication) context.getApplicationContext()).getSettings().ACCESSIBILITY_EXTENSIONS.get())\n            return setView(TextMessage.makeView(context, msgid, R.layout.alert));\n        return super.setMessage(msgid);\n    }","id":75835,"modified_method":"@Override\n    public Builder setMessage(int msgid) {\n        if (((OsmandApplication) context.getApplicationContext()).getInternalAPI().accessibilityExtensions())\n            return setView(TextMessage.makeView(context, msgid, R.layout.alert));\n        return super.setMessage(msgid);\n    }","commit_id":"b3e12061e0a66666cad1869e2086f1374adc46dd","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n    public Builder setMessage(CharSequence msg) {\n        if (((OsmandApplication) context.getApplicationContext()).getSettings().ACCESSIBILITY_EXTENSIONS.get())\n            return setView(TextMessage.makeView(context, msg, R.layout.alert));\n        return super.setMessage(msg);\n    }","id":75836,"modified_method":"@Override\n    public Builder setMessage(CharSequence msg) {\n        if (((OsmandApplication) context.getApplicationContext()).getInternalAPI().accessibilityExtensions())\n            return setView(TextMessage.makeView(context, msg, R.layout.alert));\n        return super.setMessage(msg);\n    }","commit_id":"b3e12061e0a66666cad1869e2086f1374adc46dd","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public boolean dispatchTouchEvent(MotionEvent event, Callback callback) {\n        if (((OsmandApplication) ctx.getApplicationContext()).getSettings().ACCESSIBILITY_EXTENSIONS.get()) {\n            int action = event.getAction();\n            View newTouch;\n            switch (action) {\n            case MotionEvent.ACTION_MOVE:\n                newTouch = findTouch(event);\n                if ((newTouch != null) && (newTouch != nowTouched)) {\n                    float x = event.getX();\n                    float y = event.getY();\n                    float pressure = event.getPressure();\n                    float size = event.getSize();\n                    int metaState = event.getMetaState();\n                    float xPrecision = event.getXPrecision();\n                    float yPrecision = event.getYPrecision();\n                    int deviceId = event.getDeviceId();\n                    int edgeFlags = event.getEdgeFlags();\n                    event.setAction(MotionEvent.ACTION_CANCEL);\n                    callback.dispatchNativeTouchEvent(event);\n                    newTouch.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_FOCUSED);\n                    long now = SystemClock.uptimeMillis();\n                    event.recycle();\n                    event = MotionEvent.obtain(now, now, MotionEvent.ACTION_DOWN, x, y, pressure, size,\n                                               metaState, xPrecision, yPrecision, deviceId, edgeFlags);\n                }\n                nowTouched = newTouch;\n                break;\n            case MotionEvent.ACTION_DOWN:\n                nowTouched = findTouch(event);\n                if (nowTouched != null)\n                    nowTouched.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_FOCUSED);\n                break;\n            default:\n                nowTouched = null;\n                break;\n            }\n        }\n        return callback.dispatchNativeTouchEvent(event);\n    }","id":75837,"modified_method":"public boolean dispatchTouchEvent(MotionEvent event, Callback callback) {\n        if (((OsmandApplication) ctx.getApplicationContext()).getInternalAPI().accessibilityExtensions()) {\n            int action = event.getAction();\n            View newTouch;\n            switch (action) {\n            case MotionEvent.ACTION_MOVE:\n                newTouch = findTouch(event);\n                if ((newTouch != null) && (newTouch != nowTouched)) {\n                    float x = event.getX();\n                    float y = event.getY();\n                    float pressure = event.getPressure();\n                    float size = event.getSize();\n                    int metaState = event.getMetaState();\n                    float xPrecision = event.getXPrecision();\n                    float yPrecision = event.getYPrecision();\n                    int deviceId = event.getDeviceId();\n                    int edgeFlags = event.getEdgeFlags();\n                    event.setAction(MotionEvent.ACTION_CANCEL);\n                    callback.dispatchNativeTouchEvent(event);\n                    newTouch.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_FOCUSED);\n                    long now = SystemClock.uptimeMillis();\n                    event.recycle();\n                    event = MotionEvent.obtain(now, now, MotionEvent.ACTION_DOWN, x, y, pressure, size,\n                                               metaState, xPrecision, yPrecision, deviceId, edgeFlags);\n                }\n                nowTouched = newTouch;\n                break;\n            case MotionEvent.ACTION_DOWN:\n                nowTouched = findTouch(event);\n                if (nowTouched != null)\n                    nowTouched.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_FOCUSED);\n                break;\n            default:\n                nowTouched = null;\n                break;\n            }\n        }\n        return callback.dispatchNativeTouchEvent(event);\n    }","commit_id":"b3e12061e0a66666cad1869e2086f1374adc46dd","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        if (!getSettings().ACCESSIBILITY_EXTENSIONS.get())\n            return super.dispatchPopulateAccessibilityEvent(event);\n        cursorTrackingEnabled = false;\n        boolean result = super.dispatchPopulateAccessibilityEvent(event);\n        if (event.getEventType() == AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED) {\n            if (isFocused()) {\n                event.getText().clear();\n                event.getText().add(getText().subSequence(selectionStart, selectionStart + selectionLength));\n            }\n            event.setAddedCount(selectionLength);\n            event.setRemovedCount(0);\n            event.setFromIndex(0);\n            event.setBeforeText(null);\n            result = true;\n        }\n        cursorTrackingEnabled =true;\n        return result;\n    }","id":75838,"modified_method":"@Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        if (!accessibilityExtensions())\n            return super.dispatchPopulateAccessibilityEvent(event);\n        cursorTrackingEnabled = false;\n        boolean result = super.dispatchPopulateAccessibilityEvent(event);\n        if (event.getEventType() == AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED) {\n            if (isFocused()) {\n                event.getText().clear();\n                event.getText().add(getText().subSequence(selectionStart, selectionStart + selectionLength));\n            }\n            event.setAddedCount(selectionLength);\n            event.setRemovedCount(0);\n            event.setFromIndex(0);\n            event.setBeforeText(null);\n            result = true;\n        }\n        cursorTrackingEnabled =true;\n        return result;\n    }","commit_id":"b3e12061e0a66666cad1869e2086f1374adc46dd","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n    protected MovementMethod getDefaultMovementMethod() {\n        if (getSettings().ACCESSIBILITY_EXTENSIONS.get())\n            return ArrowKeyMovementMethod.getInstance();\n        return super.getDefaultMovementMethod();\n    }","id":75839,"modified_method":"@Override\n    protected MovementMethod getDefaultMovementMethod() {\n        if (accessibilityExtensions())\n            return ArrowKeyMovementMethod.getInstance();\n        return super.getDefaultMovementMethod();\n    }","commit_id":"b3e12061e0a66666cad1869e2086f1374adc46dd","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n    protected void onSelectionChanged(int start, int end) {\n        super.onSelectionChanged(start, end);\n        if (getSettings().ACCESSIBILITY_EXTENSIONS.get() && cursorTrackingEnabled && isFocused()) {\n            if (end >= getText().length()) {\n                cursor = getText().length();\n            } else if (cursor != end) {\n                if (Math.abs(cursor - end) > 1) {\n                    final Layout layout = getLayout();\n                    final int line = layout.getLineForOffset(end);\n                    selectionStart = layout.getLineStart(line);\n                    selectionLength = Math.min(layout.getLineEnd(line) - selectionStart, AccessibilityEvent.MAX_TEXT_LENGTH);\n                } else {\n                    selectionStart = end;\n                    selectionLength = 1;\n                }\n                sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED);\n                cursor = end;\n            }\n        }\n    }","id":75840,"modified_method":"@Override\n    protected void onSelectionChanged(int start, int end) {\n        super.onSelectionChanged(start, end);\n        if (accessibilityExtensions() && cursorTrackingEnabled && isFocused()) {\n            if (end >= getText().length()) {\n                cursor = getText().length();\n            } else if (cursor != end) {\n                if (Math.abs(cursor - end) > 1) {\n                    final Layout layout = getLayout();\n                    final int line = layout.getLineForOffset(end);\n                    selectionStart = layout.getLineStart(line);\n                    selectionLength = Math.min(layout.getLineEnd(line) - selectionStart, AccessibilityEvent.MAX_TEXT_LENGTH);\n                } else {\n                    selectionStart = end;\n                    selectionLength = 1;\n                }\n                sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED);\n                cursor = end;\n            }\n        }\n    }","commit_id":"b3e12061e0a66666cad1869e2086f1374adc46dd","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n    protected void onTextChanged(CharSequence text, int start, int before, int after) {\n        super.onTextChanged(text, start, before, after);\n        if (getSettings().ACCESSIBILITY_EXTENSIONS.get() && !isFocused()) {\n            selectionLength = Math.min(text.length(), AccessibilityEvent.MAX_TEXT_LENGTH);\n            sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED);\n        }\n    }","id":75841,"modified_method":"@Override\n    protected void onTextChanged(CharSequence text, int start, int before, int after) {\n        super.onTextChanged(text, start, before, after);\n        if (accessibilityExtensions() && !isFocused()) {\n            selectionLength = Math.min(text.length(), AccessibilityEvent.MAX_TEXT_LENGTH);\n            sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED);\n        }\n    }","commit_id":"b3e12061e0a66666cad1869e2086f1374adc46dd","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public boolean accessibilityExtensions() {\n\t\treturn app.getSettings().ACCESSIBILITY_EXTENSIONS.get();\n\t}","id":75842,"modified_method":"public boolean accessibilityExtensions() {\n\t\treturn (Build.VERSION.SDK_INT < 14) ? app.getSettings().ACCESSIBILITY_EXTENSIONS.get() : false;\n\t}","commit_id":"b3e12061e0a66666cad1869e2086f1374adc46dd","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public Dialog getDialogToShowTips(boolean showFirst, boolean random){\n\t\t\n\t\tfinal Dialog dlg = new Dialog(ctx);\n\t\tdlg.setContentView(R.layout.tips_and_tricks);\n\t\tdlg.getWindow().setLayout(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT);\n\t\tfinal TextView tipDescription = (TextView) dlg.findViewById(R.id.TipDescription);\n\t\tif (!((OsmandApplication)ctx.getApplicationContext()).getSettings().ACCESSIBILITY_EXTENSIONS.get())\n\t\t\ttipDescription.setMovementMethod(ScrollingMovementMethod.getInstance());\n\t\tint nextInd = 0;\n\t\tfinal TIntArrayList toShow = new TIntArrayList();\n\t\tfinal int[] historyInd = new int[1];\n\t\tif(showFirst){\n\t\t\tdlg.setTitle(R.string.tip_initial);\n\t\t\ttipDescription.setText(R.string.tip_initial_t);\n\t\t\thistoryInd[0] = -1;\n\t\t} else if(!random){\n\t\t\tnextInd = 0;\n\t\t\tdlg.setTitle(getTipName(nextInd));\n\t\t\ttipDescription.setText(getTipDescription(nextInd));\n\t\t\ttoShow.add(nextInd);\n\t\t\thistoryInd[0] = 0;\n\t\t} else {\n\t\t\tnextInd = getNextRandomTipToShow();\n\t\t\tdlg.setTitle(getTipName(nextInd));\n\t\t\ttipDescription.setText(getTipDescription(nextInd));\n\t\t\ttoShow.add(nextInd);\n\t\t\thistoryInd[0] = 0;\n\t\t}\n\t\t\n\t\tfinal Button nextButton = ((Button)dlg.findViewById(R.id.NextButton));\n\t\tfinal Button prevButton = (Button)dlg.findViewById(R.id.PreviousButton);\n\t\t\n\t\tprevButton.setEnabled(historyInd[0] > 0);\n\t\tnextButton.setEnabled(historyInd[0] < getNumberOfTips() - 1);\n\t\t\n\t\tnextButton.setOnClickListener(new View.OnClickListener() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tif(historyInd[0] == toShow.size() - 1){\n\t\t\t\t\tint suggest = 0;\n\t\t\t\t\tif(historyInd[0] >= 0) {\n\t\t\t\t\t\tsuggest = toShow.get(historyInd[0]) + 1;\n\t\t\t\t\t}\n\t\t\t\t\ttoShow.add(getNextTipToShow(suggest));\n\t\t\t\t}\n\t\t\t\thistoryInd[0] ++;\n\t\t\t\tdlg.setTitle(getTipName(toShow.get(historyInd[0])));\n\t\t\t\ttipDescription.setText(getTipDescription(toShow.get(historyInd[0])));\n\t\t\t\ttipDescription.scrollTo(0, 0);\n\t\t\t\t\n\t\t\t\tprevButton.setEnabled(historyInd[0] >  0);\n\t\t\t\tnextButton.setEnabled(historyInd[0] < getNumberOfTips() - 1);\n\t\t\t}\n\t\t});\n\t\t\n\t\tprevButton.setOnClickListener(new View.OnClickListener() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tif(historyInd[0] > 0){\n\t\t\t\t\thistoryInd[0] --;\n\t\t\t\t\tdlg.setTitle(getTipName(toShow.get(historyInd[0])));\n\t\t\t\t\ttipDescription.setText(getTipDescription(toShow.get(historyInd[0])));\n\t\t\t\t\ttipDescription.scrollTo(0, 0);\n\t\t\t\t}\n\t\t\t\tprevButton.setEnabled(historyInd[0] > 0);\n\t\t\t\tnextButton.setEnabled(historyInd[0] < getNumberOfTips() - 1);\n\t\t\t}\n\t\t});\n\t\t\n\t\t((Button)dlg.findViewById(R.id.CloseButton)).setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tdlg.dismiss();\n\t\t\t}\n\t\t});\n\t\treturn dlg;\n\t}","id":75843,"modified_method":"public Dialog getDialogToShowTips(boolean showFirst, boolean random){\n\t\t\n\t\tfinal Dialog dlg = new Dialog(ctx);\n\t\tdlg.setContentView(R.layout.tips_and_tricks);\n\t\tdlg.getWindow().setLayout(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT);\n\t\tfinal TextView tipDescription = (TextView) dlg.findViewById(R.id.TipDescription);\n\t\tif (!((OsmandApplication)ctx.getApplicationContext()).getInternalAPI().accessibilityExtensions())\n\t\t\ttipDescription.setMovementMethod(ScrollingMovementMethod.getInstance());\n\t\tint nextInd = 0;\n\t\tfinal TIntArrayList toShow = new TIntArrayList();\n\t\tfinal int[] historyInd = new int[1];\n\t\tif(showFirst){\n\t\t\tdlg.setTitle(R.string.tip_initial);\n\t\t\ttipDescription.setText(R.string.tip_initial_t);\n\t\t\thistoryInd[0] = -1;\n\t\t} else if(!random){\n\t\t\tnextInd = 0;\n\t\t\tdlg.setTitle(getTipName(nextInd));\n\t\t\ttipDescription.setText(getTipDescription(nextInd));\n\t\t\ttoShow.add(nextInd);\n\t\t\thistoryInd[0] = 0;\n\t\t} else {\n\t\t\tnextInd = getNextRandomTipToShow();\n\t\t\tdlg.setTitle(getTipName(nextInd));\n\t\t\ttipDescription.setText(getTipDescription(nextInd));\n\t\t\ttoShow.add(nextInd);\n\t\t\thistoryInd[0] = 0;\n\t\t}\n\t\t\n\t\tfinal Button nextButton = ((Button)dlg.findViewById(R.id.NextButton));\n\t\tfinal Button prevButton = (Button)dlg.findViewById(R.id.PreviousButton);\n\t\t\n\t\tprevButton.setEnabled(historyInd[0] > 0);\n\t\tnextButton.setEnabled(historyInd[0] < getNumberOfTips() - 1);\n\t\t\n\t\tnextButton.setOnClickListener(new View.OnClickListener() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tif(historyInd[0] == toShow.size() - 1){\n\t\t\t\t\tint suggest = 0;\n\t\t\t\t\tif(historyInd[0] >= 0) {\n\t\t\t\t\t\tsuggest = toShow.get(historyInd[0]) + 1;\n\t\t\t\t\t}\n\t\t\t\t\ttoShow.add(getNextTipToShow(suggest));\n\t\t\t\t}\n\t\t\t\thistoryInd[0] ++;\n\t\t\t\tdlg.setTitle(getTipName(toShow.get(historyInd[0])));\n\t\t\t\ttipDescription.setText(getTipDescription(toShow.get(historyInd[0])));\n\t\t\t\ttipDescription.scrollTo(0, 0);\n\t\t\t\t\n\t\t\t\tprevButton.setEnabled(historyInd[0] >  0);\n\t\t\t\tnextButton.setEnabled(historyInd[0] < getNumberOfTips() - 1);\n\t\t\t}\n\t\t});\n\t\t\n\t\tprevButton.setOnClickListener(new View.OnClickListener() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tif(historyInd[0] > 0){\n\t\t\t\t\thistoryInd[0] --;\n\t\t\t\t\tdlg.setTitle(getTipName(toShow.get(historyInd[0])));\n\t\t\t\t\ttipDescription.setText(getTipDescription(toShow.get(historyInd[0])));\n\t\t\t\t\ttipDescription.scrollTo(0, 0);\n\t\t\t\t}\n\t\t\t\tprevButton.setEnabled(historyInd[0] > 0);\n\t\t\t\tnextButton.setEnabled(historyInd[0] < getNumberOfTips() - 1);\n\t\t\t}\n\t\t});\n\t\t\n\t\t((Button)dlg.findViewById(R.id.CloseButton)).setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tdlg.dismiss();\n\t\t\t}\n\t\t});\n\t\treturn dlg;\n\t}","commit_id":"b3e12061e0a66666cad1869e2086f1374adc46dd","url":"https://github.com/osmandapp/Osmand"},{"original_method":"protected void parseCategoryFromXml(XmlPullParser parser, String poiParentCategory, String poiParentPrefix) {\n\t\tString tag = parser.getAttributeValue(\"\",\"poi_tag\");\n\t\tif (tag != null) {\n\t\t\tAmenityRuleType rtype = new AmenityRuleType();\n\t\t\trtype.poiCategory = AmenityType.valueOf(poiParentCategory.toUpperCase());\n\t\t\trtype.poiSpecified = true;\n\t\t\trtype.relation = Boolean.parseBoolean(parser.getAttributeValue(\"\", \"relation\"));\n\t\t\trtype.poiPrefix = poiParentPrefix;\n\t\t\trtype.tag = tag;\n\t\t\tregisterAmenityType(tag, null, rtype);\n\t\t}\n\t}","id":75844,"modified_method":"protected void parseCategoryFromXml(XmlPullParser parser, String poiParentCategory, String poiParentPrefix) {\n\t\tString tag = parser.getAttributeValue(\"\",\"poi_tag\");\n\t\tif (tag != null) {\n\t\t\tAmenityRuleType rtype = new AmenityRuleType();\n\t\t\trtype.poiCategory = AmenityType.fromString(poiParentCategory);\n\t\t\trtype.poiSpecified = true;\n\t\t\trtype.relation = Boolean.parseBoolean(parser.getAttributeValue(\"\", \"relation\"));\n\t\t\trtype.poiPrefix = poiParentPrefix;\n\t\t\trtype.tag = tag;\n\t\t\tregisterAmenityType(tag, null, rtype);\n\t\t}\n\t}","commit_id":"f89cd246f062d2e2f3f83cdd2ee80c586365459e","url":"https://github.com/osmandapp/Osmand"},{"original_method":"protected void parseTypeFromXML(XmlPullParser parser, String poiParentCategory, String poiParentPrefix) {\n\t\tAmenityRuleType rtype = new AmenityRuleType();\n\t\trtype.tag = parser.getAttributeValue(\"\", \"tag\"); //$NON-NLS-1$\n\t\trtype.value = parser.getAttributeValue(\"\", \"value\"); //$NON-NLS-1$\n\t\tif (rtype.value != null && rtype.value.length() == 0) { //$NON-NLS-1$\n\t\t\trtype.value = null;\n\t\t}\n\t\tif (poiParentCategory != null) {\n\t\t\trtype.poiCategory = AmenityType.valueOf(poiParentCategory.toUpperCase());\n\t\t\trtype.poiSpecified = true;\n\t\t}\n\t\tif (poiParentPrefix != null) {\n\t\t\trtype.poiPrefix = poiParentPrefix;\n\t\t}\n\n\t\tString poiCategory = parser.getAttributeValue(\"\", \"poi_category\");\n\t\tif (poiCategory != null) {\n\t\t\trtype.poiSpecified = true;\n\t\t\tif (poiCategory.length() == 0) {\n\t\t\t\trtype.poiCategory = null;\n\t\t\t} else {\n\t\t\t\trtype.poiCategory = null;\n\t\t\t\tfor(AmenityType t : AmenityType.values()) {\n\t\t\t\t\tif(AmenityType.valueToString(t).equals(poiCategory)) {\n\t\t\t\t\t\trtype.poiCategory = t;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tString poiPrefix = parser.getAttributeValue(\"\", \"poi_prefix\");\n\t\tif (poiPrefix != null) {\n\t\t\trtype.poiPrefix = poiPrefix;\n\t\t}\n\t\trtype.relation = Boolean.parseBoolean(parser.getAttributeValue(\"\", \"relation\"));\n\t\tif (rtype.poiSpecified) {\n\t\t\tregisterAmenityType(rtype.tag, rtype.value, rtype);\n\t\t\tString targetTag = parser.getAttributeValue(\"\", \"target_tag\");\n\t\t\tString targetValue = parser.getAttributeValue(\"\", \"target_value\");\n\t\t\tif (targetTag != null || targetValue != null) {\n\t\t\t\tif (targetTag == null) {\n\t\t\t\t\ttargetTag = rtype.tag;\n\t\t\t\t}\n\t\t\t\tif (targetValue == null) {\n\t\t\t\t\ttargetValue = rtype.value;\n\t\t\t\t}\n\t\t\t\trtype.targetTagValue = amenityTypes.get(constructRuleKey(targetTag, targetValue));\n\t\t\t}\n\t\t}\n\t}","id":75845,"modified_method":"protected void parseTypeFromXML(XmlPullParser parser, String poiParentCategory, String poiParentPrefix) {\n\t\tAmenityRuleType rtype = new AmenityRuleType();\n\t\trtype.tag = parser.getAttributeValue(\"\", \"tag\"); //$NON-NLS-1$\n\t\trtype.value = parser.getAttributeValue(\"\", \"value\"); //$NON-NLS-1$\n\t\tif (rtype.value != null && rtype.value.length() == 0) { //$NON-NLS-1$\n\t\t\trtype.value = null;\n\t\t}\n\t\tif (poiParentCategory != null) {\n\t\t\trtype.poiCategory = AmenityType.fromString(poiParentCategory);\n\t\t\trtype.poiSpecified = true;\n\t\t}\n\t\tif (poiParentPrefix != null) {\n\t\t\trtype.poiPrefix = poiParentPrefix;\n\t\t}\n\n\t\tString poiCategory = parser.getAttributeValue(\"\", \"poi_category\");\n\t\tif (poiCategory != null) {\n\t\t\trtype.poiSpecified = true;\n\t\t\tif (poiCategory.length() == 0) {\n\t\t\t\trtype.poiCategory = null;\n\t\t\t} else {\n\t\t\t\trtype.poiCategory = null;\n\t\t\t\tfor(AmenityType t : AmenityType.values()) {\n\t\t\t\t\tif(AmenityType.valueToString(t).equals(poiCategory)) {\n\t\t\t\t\t\trtype.poiCategory = t;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tString poiPrefix = parser.getAttributeValue(\"\", \"poi_prefix\");\n\t\tif (poiPrefix != null) {\n\t\t\trtype.poiPrefix = poiPrefix;\n\t\t}\n\t\trtype.relation = Boolean.parseBoolean(parser.getAttributeValue(\"\", \"relation\"));\n\t\tif (rtype.poiSpecified) {\n\t\t\tregisterAmenityType(rtype.tag, rtype.value, rtype);\n\t\t\tString targetTag = parser.getAttributeValue(\"\", \"target_tag\");\n\t\t\tString targetValue = parser.getAttributeValue(\"\", \"target_value\");\n\t\t\tif (targetTag != null || targetValue != null) {\n\t\t\t\tif (targetTag == null) {\n\t\t\t\t\ttargetTag = rtype.tag;\n\t\t\t\t}\n\t\t\t\tif (targetValue == null) {\n\t\t\t\t\ttargetValue = rtype.value;\n\t\t\t\t}\n\t\t\t\trtype.targetTagValue = amenityTypes.get(constructRuleKey(targetTag, targetValue));\n\t\t\t}\n\t\t}\n\t}","commit_id":"f89cd246f062d2e2f3f83cdd2ee80c586365459e","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void updateSearchPoiTextButton(boolean taskAlreadyFinished) {\n\t\tboolean enabled = false;\n\t\tint title = R.string.search_POI_level_btn;\n\n\t\tif (location == null) {\n\t\t\ttitle = R.string.search_poi_location;\n\t\t\tenabled = false;\n\t\t} else if (!isNameFinderFilter() && !isSearchByNameFilter()) {\n\t\t\ttitle = R.string.search_POI_level_btn;\n\t\t\tenabled = (taskAlreadyFinished || currentSearchTask.getStatus() != Status.RUNNING) && filter.isSearchFurtherAvailable();\n\t\t} else if (filter != null) {\n\t\t\ttitle = R.string.search_button;\n\t\t\tenabled = (taskAlreadyFinished || currentSearchTask.getStatus() != Status.RUNNING) && filter.isSearchFurtherAvailable();\n\t\t}\n\t\tif (searchPOILevel != null) {\n\t\t\tsearchPOILevel.setEnabled(enabled);\n\t\t\tsearchPOILevel.setTitle(title);\n\t\t}\n\t\tif(ResourcesCompat.getResources_getBoolean(this, R.bool.abs__split_action_bar_is_narrow)) {\n\t\t\tsearchFooterButton.setVisibility(View.GONE);\n\t\t} else {\n\t\t\tsearchFooterButton.setVisibility(View.VISIBLE);\n\t\t\tsearchFooterButton.setEnabled(enabled);\n\t\t\tsearchFooterButton.setText(title);\n\t\t}\n\t}","id":75846,"modified_method":"private void updateSearchPoiTextButton(boolean taskAlreadyFinished) {\n\t\tboolean enabled = false;\n\t\tint title = R.string.search_POI_level_btn;\n\n\t\tif (location == null) {\n\t\t\ttitle = R.string.search_poi_location;\n\t\t\tenabled = false;\n\t\t} else if (filter != null && !isNameFinderFilter() && !isSearchByNameFilter()) {\n\t\t\ttitle = R.string.search_POI_level_btn;\n\t\t\tenabled = (taskAlreadyFinished || currentSearchTask.getStatus() != Status.RUNNING) && filter.isSearchFurtherAvailable();\n\t\t} else if (filter != null) {\n\t\t\ttitle = R.string.search_button;\n\t\t\tenabled = (taskAlreadyFinished || currentSearchTask.getStatus() != Status.RUNNING) && filter.isSearchFurtherAvailable();\n\t\t}\n\t\tif (searchPOILevel != null) {\n\t\t\tsearchPOILevel.setEnabled(enabled);\n\t\t\tsearchPOILevel.setTitle(title);\n\t\t}\n\t\tif(ResourcesCompat.getResources_getBoolean(this, R.bool.abs__split_action_bar_is_narrow)) {\n\t\t\tsearchFooterButton.setVisibility(View.GONE);\n\t\t} else {\n\t\t\tsearchFooterButton.setVisibility(View.VISIBLE);\n\t\t\tsearchFooterButton.setEnabled(enabled);\n\t\t\tsearchFooterButton.setText(title);\n\t\t}\n\t}","commit_id":"f89cd246f062d2e2f3f83cdd2ee80c586365459e","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n    public void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tgetSupportActionBar().setTitle(R.string.av_settings);\n\t\tPreferenceScreen grp = getPreferenceScreen();\n\t\tAudioVideoNotesPlugin p = OsmandPlugin.getEnabledPlugin(AudioVideoNotesPlugin.class);\n\t\tif (p != null) {\n\t\t\tString[] entries;\n\t\t\tInteger[] intValues;\n\n\t\t\tentries = new String[] { getString(R.string.av_def_action_choose), getString(R.string.av_def_action_audio),\n\t\t\t\t\tgetString(R.string.av_def_action_video), getString(R.string.av_def_action_picture) };\n\t\t\tintValues = new Integer[] { AV_DEFAULT_ACTION_CHOOSE, AV_DEFAULT_ACTION_AUDIO, AV_DEFAULT_ACTION_VIDEO,\n\t\t\t\t\tAV_DEFAULT_ACTION_TAKEPICTURE };\n\t\t\tListPreference defAct = createListPreference(p.AV_DEFAULT_ACTION, entries, intValues, R.string.av_widget_action,\n\t\t\t\t\tR.string.av_widget_action_descr);\n\t\t\tgrp.addPreference(defAct);\n\t\t\t\n\t\t\t// camera type settings:\n\t\t\tgrp.addPreference(createCheckBoxPreference(p.AV_EXTERNAL_PHOTO_CAM, R.string.av_use_external_camera,\n\t\t\t\t\tR.string.av_use_external_camera_descr));\n\t\t\t// focus mode settings:\n\t\t\t// show in menu only suppoted modes:\n\t\t\tfinal Camera cam = openCamera();\n\t\t\tParameters parameters = cam.getParameters();\n\t\t\tList<String> sfm = parameters.getSupportedFocusModes();\n\t\t\tList<String> items = new ArrayList<String>();\n\t\t\tList<Integer> itemsValues = new ArrayList<Integer>();\n\t\t\t// filtering known types for translate and set index:\n\t\t\tfor (int index = 0; index < sfm.size(); index++) {\n\t\t\t\tif (sfm.get(index).equals(\"auto\")) {\n\t\t\t\t\titems.add(getString(R.string.av_camera_focus_auto));\n\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_AUTO);\n\t\t\t\t} else if (sfm.get(index).equals(\"fixed\")) {\n\t\t\t\t\titems.add(getString(R.string.av_camera_focus_hiperfocal));\n\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_HIPERFOCAL);\n\t\t\t\t} else if (sfm.get(index).equals(\"edof\")) {\n\t\t\t\t\titems.add(getString(R.string.av_camera_focus_edof));\n\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_EDOF);\n\t\t\t\t} else if (sfm.get(index).equals(\"infinity\")) {\n\t\t\t\t\titems.add(getString(R.string.av_camera_focus_infinity));\n\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_INFINITY);\n\t\t\t\t} else if (sfm.get(index).equals(\"macro\")) {\n\t\t\t\t\titems.add(getString(R.string.av_camera_focus_macro));\n\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_MACRO);\n\t\t\t\t} else if (sfm.get(index).equals(\"continuous-picture\")) {\n\t\t\t\t\titems.add(getString(R.string.av_camera_focus_continuous));\n\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_CONTINUOUS);\n\t\t\t\t}\n\t\t\t}\n\t\t\tentries = items.toArray(entries);\n\t\t\tintValues = itemsValues.toArray(intValues);\n\t\t\tif (entries.length > 0) {\n\t\t\t\tListPreference camFocus = createListPreference(p.AV_CAMERA_FOCUS_TYPE, entries, intValues, R.string.av_camera_focus,\n\t\t\t\t\t\tR.string.av_camera_focus_descr);\n\t\t\t\tgrp.addPreference(camFocus);\n\t\t\t}\n\t\t\t// play sound on success photo:\n\t\t\tgrp.addPreference(createCheckBoxPreference(p.AV_PHOTO_PLAY_SOUND, R.string.av_photo_play_sound,\n\t\t\t\t\tR.string.av_photo_play_sound_descr));\n\t\t\tcam.release();\n\n\n\t\t\t// video settings:\n\t\t\tgrp.addPreference(createCheckBoxPreference(p.AV_EXTERNAL_RECORDER, R.string.av_use_external_recorder,\n\t\t\t\t\tR.string.av_use_external_recorder_descr));\n\t\t\t\n\t\t\tentries = new String[] { \"3GP\", \"MP4\" };\n\t\t\tintValues = new Integer[] { VIDEO_OUTPUT_3GP, VIDEO_OUTPUT_MP4 };\n\t\t\tListPreference lp = createListPreference(p.AV_VIDEO_FORMAT, entries, intValues, R.string.av_video_format,\n\t\t\t\t\tR.string.av_video_format_descr);\n\t\t\tgrp.addPreference(lp);\n\t\t}\n\t}","id":75847,"modified_method":"@Override\n    public void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tgetSupportActionBar().setTitle(R.string.av_settings);\n\t\tPreferenceScreen grp = getPreferenceScreen();\n\t\tAudioVideoNotesPlugin p = OsmandPlugin.getEnabledPlugin(AudioVideoNotesPlugin.class);\n\t\tif (p != null) {\n\t\t\tString[] entries;\n\t\t\tInteger[] intValues;\n\n\t\t\tentries = new String[] { getString(R.string.av_def_action_choose), getString(R.string.av_def_action_audio),\n\t\t\t\t\tgetString(R.string.av_def_action_video), getString(R.string.av_def_action_picture) };\n\t\t\tintValues = new Integer[] { AV_DEFAULT_ACTION_CHOOSE, AV_DEFAULT_ACTION_AUDIO, AV_DEFAULT_ACTION_VIDEO,\n\t\t\t\t\tAV_DEFAULT_ACTION_TAKEPICTURE };\n\t\t\tListPreference defAct = createListPreference(p.AV_DEFAULT_ACTION, entries, intValues, R.string.av_widget_action,\n\t\t\t\t\tR.string.av_widget_action_descr);\n\t\t\tgrp.addPreference(defAct);\n\t\t\tfinal Camera cam = openCamera();\n\t\t\tif (cam != null) {\n\t\t\t\t// camera type settings:\n\t\t\t\tgrp.addPreference(createCheckBoxPreference(p.AV_EXTERNAL_PHOTO_CAM, R.string.av_use_external_camera,\n\t\t\t\t\t\tR.string.av_use_external_camera_descr));\n\t\t\t\t// focus mode settings:\n\t\t\t\t// show in menu only suppoted modes:\n\n\t\t\t\tParameters parameters = cam.getParameters();\n\t\t\t\tList<String> sfm = parameters.getSupportedFocusModes();\n\t\t\t\tList<String> items = new ArrayList<String>();\n\t\t\t\tList<Integer> itemsValues = new ArrayList<Integer>();\n\t\t\t\t// filtering known types for translate and set index:\n\t\t\t\tfor (int index = 0; index < sfm.size(); index++) {\n\t\t\t\t\tif (sfm.get(index).equals(\"auto\")) {\n\t\t\t\t\t\titems.add(getString(R.string.av_camera_focus_auto));\n\t\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_AUTO);\n\t\t\t\t\t} else if (sfm.get(index).equals(\"fixed\")) {\n\t\t\t\t\t\titems.add(getString(R.string.av_camera_focus_hiperfocal));\n\t\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_HIPERFOCAL);\n\t\t\t\t\t} else if (sfm.get(index).equals(\"edof\")) {\n\t\t\t\t\t\titems.add(getString(R.string.av_camera_focus_edof));\n\t\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_EDOF);\n\t\t\t\t\t} else if (sfm.get(index).equals(\"infinity\")) {\n\t\t\t\t\t\titems.add(getString(R.string.av_camera_focus_infinity));\n\t\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_INFINITY);\n\t\t\t\t\t} else if (sfm.get(index).equals(\"macro\")) {\n\t\t\t\t\t\titems.add(getString(R.string.av_camera_focus_macro));\n\t\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_MACRO);\n\t\t\t\t\t} else if (sfm.get(index).equals(\"continuous-picture\")) {\n\t\t\t\t\t\titems.add(getString(R.string.av_camera_focus_continuous));\n\t\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_CONTINUOUS);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tentries = items.toArray(entries);\n\t\t\t\tintValues = itemsValues.toArray(intValues);\n\t\t\t\tif (entries.length > 0) {\n\t\t\t\t\tListPreference camFocus = createListPreference(p.AV_CAMERA_FOCUS_TYPE, entries, intValues, R.string.av_camera_focus,\n\t\t\t\t\t\t\tR.string.av_camera_focus_descr);\n\t\t\t\t\tgrp.addPreference(camFocus);\n\t\t\t\t}\n\t\t\t\t// play sound on success photo:\n\t\t\t\tgrp.addPreference(createCheckBoxPreference(p.AV_PHOTO_PLAY_SOUND, R.string.av_photo_play_sound,\n\t\t\t\t\t\tR.string.av_photo_play_sound_descr));\n\t\t\t\tcam.release();\n\t\t\t}\n\t\t\t// video settings:\n\t\t\tgrp.addPreference(createCheckBoxPreference(p.AV_EXTERNAL_RECORDER, R.string.av_use_external_recorder,\n\t\t\t\t\tR.string.av_use_external_recorder_descr));\n\t\t\t\n\t\t\tentries = new String[] { \"3GP\", \"MP4\" };\n\t\t\tintValues = new Integer[] { VIDEO_OUTPUT_3GP, VIDEO_OUTPUT_MP4 };\n\t\t\tListPreference lp = createListPreference(p.AV_VIDEO_FORMAT, entries, intValues, R.string.av_video_format,\n\t\t\t\t\tR.string.av_video_format_descr);\n\t\t\tgrp.addPreference(lp);\n\t\t}\n\t}","commit_id":"f89cd246f062d2e2f3f83cdd2ee80c586365459e","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private static void displayHelp(String message) {\n        SysOut.println(\"Usage:\");\n        SysOut.println(\"    -u, --url     [plugin location]   : Set exact URL to download the plugin from\");\n        SysOut.println(\"    -i, --install [plugin name]       : Downloads and installs listed plugins [*]\");\n        SysOut.println(\"    -t, --timeout [duration]          : Timeout setting: 30s, 1m, 1h... (infinite by default)\");\n        SysOut.println(\"    -r, --remove  [plugin name]       : Removes listed plugins\");\n        SysOut.println(\"    -l, --list                        : List installed plugins\");\n        SysOut.println(\"    -v, --verbose                     : Prints verbose messages\");\n        SysOut.println(\"    -s, --silent                      : Run in silent mode\");\n        SysOut.println(\"    -h, --help                        : Prints this help message\");\n        SysOut.newline();\n        SysOut.println(\" [*] Plugin name could be:\");\n        SysOut.println(\"     elasticsearch/plugin/version for official elasticsearch plugins (download from download.elasticsearch.org)\");\n        SysOut.println(\"     groupId/artifactId/version   for community plugins (download from maven central or oss sonatype)\");\n        SysOut.println(\"     username/repository          for site plugins (download from github master)\");\n\n        if (message != null) {\n            SysOut.newline();\n            SysOut.println(\"Message:\");\n            SysOut.println(\"   \" + message);\n        }\n    }","id":75848,"modified_method":"private static void displayHelp(String message) {\n        SysOut.println(\"Usage:\");\n        SysOut.println(\"    -u, --url     [plugin location]   : Set exact URL to download the plugin from\");\n        SysOut.println(\"    -i, --install [plugin name]       : Downloads and installs listed plugins [*]\");\n        SysOut.println(\"    -t, --timeout [duration]          : Timeout setting: 30s, 1m, 1h... (infinite by default)\");\n        SysOut.println(\"    -r, --remove  [plugin name]       : Removes listed plugins\");\n        SysOut.println(\"    -l, --list                        : List installed plugins\");\n        SysOut.println(\"    -v, --verbose                     : Prints verbose messages\");\n        SysOut.println(\"    -s, --silent                      : Run in silent mode\");\n        SysOut.println(\"    -h, --help                        : Prints this help message\");\n        SysOut.newline();\n        SysOut.println(\" [*] Plugin name could be:\");\n        SysOut.println(\"     elasticsearch-plugin-name    for Elasticsearch 2.0 Core plugin (download from download.elastic.co)\");\n        SysOut.println(\"     elasticsearch/plugin/version for elasticsearch commercial plugins (download from download.elastic.co)\");\n        SysOut.println(\"     groupId/artifactId/version   for community plugins (download from maven central or oss sonatype)\");\n        SysOut.println(\"     username/repository          for site plugins (download from github master)\");\n        SysOut.newline();\n        SysOut.println(\"Elasticsearch Core plugins:\");\n        for (String o : OFFICIAL_PLUGINS) {\n            SysOut.println(\" - \" + o);\n        }\n\n        if (message != null) {\n            SysOut.newline();\n            SysOut.println(\"Message:\");\n            SysOut.println(\"   \" + message);\n        }\n    }","commit_id":"d57de591586faf05fef81286527539a9a51e01c2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"static PluginHandle parse(String name) {\n            String[] elements = name.split(\"/\");\n            // We first consider the simplest form: pluginname\n            String repo = elements[0];\n            String user = null;\n            String version = null;\n\n            // We consider the form: username/pluginname\n            if (elements.length > 1) {\n                user = elements[0];\n                repo = elements[1];\n\n                // We consider the form: username/pluginname/version\n                if (elements.length > 2) {\n                    version = elements[2];\n                }\n            }\n\n            if (repo.startsWith(\"elasticsearch-\")) {\n                // remove elasticsearch- prefix\n                String endname = repo.substring(\"elasticsearch-\".length());\n                return new PluginHandle(endname, version, user, repo);\n            }\n\n            if (name.startsWith(\"es-\")) {\n                // remove es- prefix\n                String endname = repo.substring(\"es-\".length());\n                return new PluginHandle(endname, version, user, repo);\n            }\n\n            return new PluginHandle(repo, version, user, repo);\n        }","id":75849,"modified_method":"static PluginHandle parse(String name) {\n            String[] elements = name.split(\"/\");\n            // We first consider the simplest form: pluginname\n            String repo = elements[0];\n            String user = null;\n            String version = null;\n\n            // We consider the form: username/pluginname\n            if (elements.length > 1) {\n                user = elements[0];\n                repo = elements[1];\n\n                // We consider the form: username/pluginname/version\n                if (elements.length > 2) {\n                    version = elements[2];\n                }\n            }\n\n            if (isOfficialPlugin(repo, user, version)) {\n                return new PluginHandle(repo, Version.CURRENT.number(), null, repo);\n            }\n\n            if (repo.startsWith(\"elasticsearch-\")) {\n                // remove elasticsearch- prefix\n                String endname = repo.substring(\"elasticsearch-\".length());\n                return new PluginHandle(endname, version, user, repo);\n            }\n\n            if (name.startsWith(\"es-\")) {\n                // remove es- prefix\n                String endname = repo.substring(\"es-\".length());\n                return new PluginHandle(endname, version, user, repo);\n            }\n\n            return new PluginHandle(repo, version, user, repo);\n        }","commit_id":"d57de591586faf05fef81286527539a9a51e01c2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"List<URL> urls() {\n            List<URL> urls = new ArrayList<>();\n            if (version != null) {\n                // Elasticsearch download service\n                addUrl(urls, \"http://download.elasticsearch.org/\" + user + \"/\" + repo + \"/\" + repo + \"-\" + version + \".zip\");\n                // Maven central repository\n                addUrl(urls, \"http://search.maven.org/remotecontent?filepath=\" + user.replace('.', '/') + \"/\" + repo + \"/\" + version + \"/\" + repo + \"-\" + version + \".zip\");\n                // Sonatype repository\n                addUrl(urls, \"https://oss.sonatype.org/service/local/repositories/releases/content/\" + user.replace('.', '/') + \"/\" + repo + \"/\" + version + \"/\" + repo + \"-\" + version + \".zip\");\n                // Github repository\n                addUrl(urls, \"https://github.com/\" + user + \"/\" + repo + \"/archive/\" + version + \".zip\");\n            }\n            // Github repository for master branch (assume site)\n            addUrl(urls, \"https://github.com/\" + user + \"/\" + repo + \"/archive/master.zip\");\n            return urls;\n        }","id":75850,"modified_method":"List<URL> urls() {\n            List<URL> urls = new ArrayList<>();\n            if (version != null) {\n                // Elasticsearch new download service uses groupId org.elasticsearch.plugins from 2.0.0\n                if (user == null) {\n                    // TODO Update to https\n                    addUrl(urls, String.format(Locale.ROOT, \"http://download.elastic.co/org.elasticsearch.plugins/%1$s/%1$s-%2$s.zip\", repo, version));\n                } else {\n                    // Elasticsearch old download service\n                    // TODO Update to https\n                    addUrl(urls, String.format(Locale.ROOT, \"http://download.elastic.co/%1$s/%2$s/%2$s-%3$s.zip\", user, repo, version));\n                    // Maven central repository\n                    addUrl(urls, String.format(Locale.ROOT, \"http://search.maven.org/remotecontent?filepath=%1$s/%2$s/%3$s/%2$s-%3$s.zip\", user.replace('.', '/'), repo, version));\n                    // Sonatype repository\n                    addUrl(urls, String.format(Locale.ROOT, \"https://oss.sonatype.org/service/local/repositories/releases/content/%1$s/%2$s/%3$s/%2$s-%3$s.zip\", user.replace('.', '/'), repo, version));\n                    // Github repository\n                    addUrl(urls, String.format(Locale.ROOT, \"https://github.com/%1$s/%2$s/archive/%3$s.zip\", user, repo, version));\n                }\n            }\n            if (user != null) {\n                // Github repository for master branch (assume site)\n                addUrl(urls, String.format(Locale.ROOT, \"https://github.com/%1$s/%2$s/archive/master.zip\", user, repo));\n            }\n            return urls;\n        }","commit_id":"d57de591586faf05fef81286527539a9a51e01c2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void downloadAndExtract(String name) throws IOException {\n        if (name == null) {\n            throw new IllegalArgumentException(\"plugin name must be supplied with --install [name].\");\n        }\n        HttpDownloadHelper downloadHelper = new HttpDownloadHelper();\n        boolean downloaded = false;\n        HttpDownloadHelper.DownloadProgress progress;\n        if (outputMode == OutputMode.SILENT) {\n            progress = new HttpDownloadHelper.NullProgress();\n        } else {\n            progress = new HttpDownloadHelper.VerboseProgress(SysOut.getOut());\n        }\n\n        if (!Files.isWritable(environment.pluginsFile())) {\n            throw new IOException(\"plugin directory \" + environment.pluginsFile() + \" is read only\");\n        }\n\n        PluginHandle pluginHandle = PluginHandle.parse(name);\n        checkForForbiddenName(pluginHandle.name);\n\n        Path pluginFile = pluginHandle.distroFile(environment);\n        // extract the plugin\n        final Path extractLocation = pluginHandle.extractedDir(environment);\n        if (Files.exists(extractLocation)) {\n            throw new IOException(\"plugin directory \" + extractLocation.toAbsolutePath() + \" already exists. To update the plugin, uninstall it first using --remove \" + name + \" command\");\n        }\n\n        // first, try directly from the URL provided\n        if (url != null) {\n            URL pluginUrl = new URL(url);\n            log(\"Trying \" + pluginUrl.toExternalForm() + \"...\");\n            try {\n                downloadHelper.download(pluginUrl, pluginFile, progress, this.timeout);\n                downloaded = true;\n            } catch (ElasticsearchTimeoutException e) {\n                throw e;\n            } catch (Exception e) {\n                // ignore\n                log(\"Failed: \" + ExceptionsHelper.detailedMessage(e));\n            }\n        }\n\n        if (!downloaded) {\n            // We try all possible locations\n            for (URL url : pluginHandle.urls()) {\n                log(\"Trying \" + url.toExternalForm() + \"...\");\n                try {\n                    downloadHelper.download(url, pluginFile, progress, this.timeout);\n                    downloaded = true;\n                    break;\n                } catch (ElasticsearchTimeoutException e) {\n                    throw e;\n                } catch (Exception e) {\n                    debug(\"Failed: \" + ExceptionsHelper.detailedMessage(e));\n                }\n            }\n        }\n\n        if (!downloaded) {\n            throw new IOException(\"failed to download out of all possible locations..., use --verbose to get detailed information\");\n        }\n\n        // unzip plugin to a temp dir\n        Path tmp = unzipToTemporary(pluginFile);\n\n        // create list of current jars in classpath\n        final List<URL> jars = new ArrayList<>();\n        ClassLoader loader = PluginManager.class.getClassLoader();\n        if (loader instanceof URLClassLoader) {\n            for (URL url : ((URLClassLoader) loader).getURLs()) {\n                jars.add(url);\n            }\n        }\n\n        // add any jars we find in the plugin to the list\n        Files.walkFileTree(tmp, new SimpleFileVisitor<Path>() {\n            @Override\n            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n                if (file.toString().endsWith(\".jar\")) {\n                    jars.add(file.toUri().toURL());\n                }\n                return FileVisitResult.CONTINUE;\n            }\n        });\n\n        // check combined (current classpath + new jars to-be-added)\n        try {\n            JarHell.checkJarHell(jars.toArray(new URL[0]));\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n\n        // cleanup\n        IOUtils.rm(tmp);\n\n        // TODO: we have a tmpdir made above, so avoid zipfilesystem\n        try (FileSystem zipFile = FileSystems.newFileSystem(pluginFile, null)) {\n            for (final Path root : zipFile.getRootDirectories() ) {\n                final Path[] topLevelFiles = FileSystemUtils.files(root);\n                //we check whether we need to remove the top-level folder while extracting\n                //sometimes (e.g. github) the downloaded archive contains a top-level folder which needs to be removed\n                final boolean stripTopLevelDirectory;\n                if (topLevelFiles.length == 1 && Files.isDirectory(topLevelFiles[0])) {\n                    // valid names if the zip has only one top level directory\n                    switch (topLevelFiles[0].getFileName().toString()) {\n                        case  \"_site/\":\n                        case  \"bin/\":\n                        case  \"config/\":\n                        case  \"_dict/\":\n                          stripTopLevelDirectory = false;\n                          break;\n                        default:\n                          stripTopLevelDirectory = true;\n                    }\n                } else {\n                    stripTopLevelDirectory = false;\n                }\n                Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n                    @Override\n                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n                        Path target =  FileSystemUtils.append(extractLocation, file, stripTopLevelDirectory ? 1 : 0);\n                        Files.createDirectories(target);\n                        Files.copy(file, target, StandardCopyOption.REPLACE_EXISTING);\n                        return FileVisitResult.CONTINUE;\n                    }\n\n                });\n            }\n            log(\"Installed \" + name + \" into \" + extractLocation.toAbsolutePath());\n        } catch (Exception e) {\n            log(\"failed to extract plugin [\" + pluginFile + \"]: \" + ExceptionsHelper.detailedMessage(e));\n            return;\n        } finally {\n            try {\n                Files.delete(pluginFile);\n            } catch (Exception ex) {\n                log(\"Failed to delete plugin file\" + pluginFile + \" \" + ex);\n            }\n        }\n\n        if (FileSystemUtils.hasExtensions(extractLocation, \".java\")) {\n            debug(\"Plugin installation assumed to be site plugin, but contains source code, aborting installation...\");\n            try {\n                IOUtils.rm(extractLocation);\n            } catch(Exception ex) {\n                debug(\"Failed to remove site plugin from path \" + extractLocation + \" - \" + ex.getMessage());\n            }\n            throw new IllegalArgumentException(\"Plugin installation assumed to be site plugin, but contains source code, aborting installation.\");\n        }\n\n        // It could potentially be a non explicit _site plugin\n        boolean potentialSitePlugin = true;\n        Path binFile = extractLocation.resolve(\"bin\");\n        if (Files.isDirectory(binFile)) {\n            Path toLocation = pluginHandle.binDir(environment);\n            debug(\"Found bin, moving to \" + toLocation.toAbsolutePath());\n            if (Files.exists(toLocation)) {\n                IOUtils.rm(toLocation);\n            }\n            try {\n                FileSystemUtils.move(binFile, toLocation);\n            } catch (IOException e) {\n                throw new IOException(\"Could not move [\" + binFile + \"] to [\" + toLocation + \"]\", e);\n            }\n            if (Files.getFileStore(toLocation).supportsFileAttributeView(PosixFileAttributeView.class)) {\n                final Set<PosixFilePermission> perms = new HashSet<>();\n                perms.add(PosixFilePermission.OWNER_EXECUTE);\n                perms.add(PosixFilePermission.GROUP_EXECUTE);\n                perms.add(PosixFilePermission.OTHERS_EXECUTE);\n                Files.walkFileTree(toLocation, new SimpleFileVisitor<Path>() {\n                    @Override\n                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n                        if (attrs.isRegularFile()) {\n                            Files.setPosixFilePermissions(file, perms);\n                        }\n                        return FileVisitResult.CONTINUE;\n                    }\n                });\n            } else {\n                debug(\"Skipping posix permissions - filestore doesn't support posix permission\");\n            }\n            debug(\"Installed \" + name + \" into \" + toLocation.toAbsolutePath());\n            potentialSitePlugin = false;\n        }\n\n        Path configFile = extractLocation.resolve(\"config\");\n        if (Files.isDirectory(configFile)) {\n            Path configDestLocation = pluginHandle.configDir(environment);\n            debug(\"Found config, moving to \" + configDestLocation.toAbsolutePath());\n            moveFilesWithoutOverwriting(configFile, configDestLocation, \".new\");\n            debug(\"Installed \" + name + \" into \" + configDestLocation.toAbsolutePath());\n            potentialSitePlugin = false;\n        }\n\n        // try and identify the plugin type, see if it has no .class or .jar files in it\n        // so its probably a _site, and it it does not have a _site in it, move everything to _site\n        if (!Files.exists(extractLocation.resolve(\"_site\"))) {\n            if (potentialSitePlugin && !FileSystemUtils.hasExtensions(extractLocation, \".class\", \".jar\")) {\n                log(\"Identified as a _site plugin, moving to _site structure ...\");\n                Path site = extractLocation.resolve(\"_site\");\n                Path tmpLocation = environment.pluginsFile().resolve(extractLocation.getFileName() + \".tmp\");\n                Files.move(extractLocation, tmpLocation);\n                Files.createDirectories(extractLocation);\n                Files.move(tmpLocation, site);\n                debug(\"Installed \" + name + \" into \" + site.toAbsolutePath());\n            }\n        }\n    }","id":75851,"modified_method":"public void downloadAndExtract(String name) throws IOException {\n        if (name == null) {\n            throw new IllegalArgumentException(\"plugin name must be supplied with --install [name].\");\n        }\n        HttpDownloadHelper downloadHelper = new HttpDownloadHelper();\n        boolean downloaded = false;\n        HttpDownloadHelper.DownloadProgress progress;\n        if (outputMode == OutputMode.SILENT) {\n            progress = new HttpDownloadHelper.NullProgress();\n        } else {\n            progress = new HttpDownloadHelper.VerboseProgress(SysOut.getOut());\n        }\n\n        if (!Files.isWritable(environment.pluginsFile())) {\n            throw new IOException(\"plugin directory \" + environment.pluginsFile() + \" is read only\");\n        }\n\n        PluginHandle pluginHandle = PluginHandle.parse(name);\n        checkForForbiddenName(pluginHandle.name);\n\n        Path pluginFile = pluginHandle.distroFile(environment);\n        // extract the plugin\n        final Path extractLocation = pluginHandle.extractedDir(environment);\n        if (Files.exists(extractLocation)) {\n            throw new IOException(\"plugin directory \" + extractLocation.toAbsolutePath() + \" already exists. To update the plugin, uninstall it first using --remove \" + name + \" command\");\n        }\n\n        // first, try directly from the URL provided\n        if (url != null) {\n            URL pluginUrl = new URL(url);\n            log(\"Trying \" + pluginUrl.toExternalForm() + \"...\");\n            try {\n                downloadHelper.download(pluginUrl, pluginFile, progress, this.timeout);\n                downloaded = true;\n            } catch (ElasticsearchTimeoutException e) {\n                throw e;\n            } catch (Exception e) {\n                // ignore\n                log(\"Failed: \" + ExceptionsHelper.detailedMessage(e));\n            }\n        } else {\n            if (PluginHandle.isOfficialPlugin(pluginHandle.repo, pluginHandle.user, pluginHandle.version)) {\n                checkForOfficialPlugins(pluginHandle.name);\n            }\n        }\n\n        if (!downloaded) {\n            // We try all possible locations\n            for (URL url : pluginHandle.urls()) {\n                log(\"Trying \" + url.toExternalForm() + \"...\");\n                try {\n                    downloadHelper.download(url, pluginFile, progress, this.timeout);\n                    downloaded = true;\n                    break;\n                } catch (ElasticsearchTimeoutException e) {\n                    throw e;\n                } catch (Exception e) {\n                    debug(\"Failed: \" + ExceptionsHelper.detailedMessage(e));\n                }\n            }\n        }\n\n        if (!downloaded) {\n            throw new IOException(\"failed to download out of all possible locations..., use --verbose to get detailed information\");\n        }\n\n        // unzip plugin to a temp dir\n        Path tmp = unzipToTemporary(pluginFile);\n\n        // create list of current jars in classpath\n        final List<URL> jars = new ArrayList<>();\n        ClassLoader loader = PluginManager.class.getClassLoader();\n        if (loader instanceof URLClassLoader) {\n            for (URL url : ((URLClassLoader) loader).getURLs()) {\n                jars.add(url);\n            }\n        }\n\n        // add any jars we find in the plugin to the list\n        Files.walkFileTree(tmp, new SimpleFileVisitor<Path>() {\n            @Override\n            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n                if (file.toString().endsWith(\".jar\")) {\n                    jars.add(file.toUri().toURL());\n                }\n                return FileVisitResult.CONTINUE;\n            }\n        });\n\n        // check combined (current classpath + new jars to-be-added)\n        try {\n            JarHell.checkJarHell(jars.toArray(new URL[0]));\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n\n        // cleanup\n        IOUtils.rm(tmp);\n\n        // TODO: we have a tmpdir made above, so avoid zipfilesystem\n        try (FileSystem zipFile = FileSystems.newFileSystem(pluginFile, null)) {\n            for (final Path root : zipFile.getRootDirectories() ) {\n                final Path[] topLevelFiles = FileSystemUtils.files(root);\n                //we check whether we need to remove the top-level folder while extracting\n                //sometimes (e.g. github) the downloaded archive contains a top-level folder which needs to be removed\n                final boolean stripTopLevelDirectory;\n                if (topLevelFiles.length == 1 && Files.isDirectory(topLevelFiles[0])) {\n                    // valid names if the zip has only one top level directory\n                    switch (topLevelFiles[0].getFileName().toString()) {\n                        case  \"_site/\":\n                        case  \"bin/\":\n                        case  \"config/\":\n                        case  \"_dict/\":\n                          stripTopLevelDirectory = false;\n                          break;\n                        default:\n                          stripTopLevelDirectory = true;\n                    }\n                } else {\n                    stripTopLevelDirectory = false;\n                }\n                Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n                    @Override\n                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n                        Path target =  FileSystemUtils.append(extractLocation, file, stripTopLevelDirectory ? 1 : 0);\n                        Files.createDirectories(target);\n                        Files.copy(file, target, StandardCopyOption.REPLACE_EXISTING);\n                        return FileVisitResult.CONTINUE;\n                    }\n\n                });\n            }\n            log(\"Installed \" + name + \" into \" + extractLocation.toAbsolutePath());\n        } catch (Exception e) {\n            log(\"failed to extract plugin [\" + pluginFile + \"]: \" + ExceptionsHelper.detailedMessage(e));\n            return;\n        } finally {\n            try {\n                Files.delete(pluginFile);\n            } catch (Exception ex) {\n                log(\"Failed to delete plugin file\" + pluginFile + \" \" + ex);\n            }\n        }\n\n        if (FileSystemUtils.hasExtensions(extractLocation, \".java\")) {\n            debug(\"Plugin installation assumed to be site plugin, but contains source code, aborting installation...\");\n            try {\n                IOUtils.rm(extractLocation);\n            } catch(Exception ex) {\n                debug(\"Failed to remove site plugin from path \" + extractLocation + \" - \" + ex.getMessage());\n            }\n            throw new IllegalArgumentException(\"Plugin installation assumed to be site plugin, but contains source code, aborting installation.\");\n        }\n\n        // It could potentially be a non explicit _site plugin\n        boolean potentialSitePlugin = true;\n        Path binFile = extractLocation.resolve(\"bin\");\n        if (Files.isDirectory(binFile)) {\n            Path toLocation = pluginHandle.binDir(environment);\n            debug(\"Found bin, moving to \" + toLocation.toAbsolutePath());\n            if (Files.exists(toLocation)) {\n                IOUtils.rm(toLocation);\n            }\n            try {\n                FileSystemUtils.move(binFile, toLocation);\n            } catch (IOException e) {\n                throw new IOException(\"Could not move [\" + binFile + \"] to [\" + toLocation + \"]\", e);\n            }\n            if (Files.getFileStore(toLocation).supportsFileAttributeView(PosixFileAttributeView.class)) {\n                final Set<PosixFilePermission> perms = new HashSet<>();\n                perms.add(PosixFilePermission.OWNER_EXECUTE);\n                perms.add(PosixFilePermission.GROUP_EXECUTE);\n                perms.add(PosixFilePermission.OTHERS_EXECUTE);\n                Files.walkFileTree(toLocation, new SimpleFileVisitor<Path>() {\n                    @Override\n                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n                        if (attrs.isRegularFile()) {\n                            Files.setPosixFilePermissions(file, perms);\n                        }\n                        return FileVisitResult.CONTINUE;\n                    }\n                });\n            } else {\n                debug(\"Skipping posix permissions - filestore doesn't support posix permission\");\n            }\n            debug(\"Installed \" + name + \" into \" + toLocation.toAbsolutePath());\n            potentialSitePlugin = false;\n        }\n\n        Path configFile = extractLocation.resolve(\"config\");\n        if (Files.isDirectory(configFile)) {\n            Path configDestLocation = pluginHandle.configDir(environment);\n            debug(\"Found config, moving to \" + configDestLocation.toAbsolutePath());\n            moveFilesWithoutOverwriting(configFile, configDestLocation, \".new\");\n            debug(\"Installed \" + name + \" into \" + configDestLocation.toAbsolutePath());\n            potentialSitePlugin = false;\n        }\n\n        // try and identify the plugin type, see if it has no .class or .jar files in it\n        // so its probably a _site, and it it does not have a _site in it, move everything to _site\n        if (!Files.exists(extractLocation.resolve(\"_site\"))) {\n            if (potentialSitePlugin && !FileSystemUtils.hasExtensions(extractLocation, \".class\", \".jar\")) {\n                log(\"Identified as a _site plugin, moving to _site structure ...\");\n                Path site = extractLocation.resolve(\"_site\");\n                Path tmpLocation = environment.pluginsFile().resolve(extractLocation.getFileName() + \".tmp\");\n                Files.move(extractLocation, tmpLocation);\n                Files.createDirectories(extractLocation);\n                Files.move(tmpLocation, site);\n                debug(\"Installed \" + name + \" into \" + site.toAbsolutePath());\n            }\n        }\n    }","commit_id":"d57de591586faf05fef81286527539a9a51e01c2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void downloadDocumentation() {\n    for (String url : getDocUrls()) {\n      String offlineDocUrl = myProvider.getOfflineDocUrl(url); \n      if (offlineDocUrl != null) {\n        String targetFile = myProvider.downloadOfflineDoc(myProject, offlineDocUrl, getRootPane());\n        myDocUrlListModel.addUrl(targetFile);\n        return;\n      }\n    }\n  }","id":75852,"modified_method":"private void downloadDocumentation() {\n    for (String url : getDocUrls()) {\n      String offlineDocUrl = myProvider.getOfflineDocUrl(url); \n      if (offlineDocUrl != null) {\n        VirtualFile targetFile = myProvider.downloadOfflineDoc(myProject, offlineDocUrl, getRootPane());\n        if (targetFile != null) {\n          myDocUrlListModel.addUrl(targetFile.getUrl());\n        }\n        return;\n      }\n    }\n  }","commit_id":"0aecbab9035fa58ee72e89340df2a5f617299aa9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public abstract String downloadOfflineDoc(Project project, String offlineDocUrl, JComponent parent);","id":75853,"modified_method":"@Nullable\n  public abstract VirtualFile downloadOfflineDoc(Project project, String offlineDocUrl, JComponent parent);","commit_id":"0aecbab9035fa58ee72e89340df2a5f617299aa9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static WikiNode getFirstVisibleNode(PortletRequest portletRequest)\n\t\tthrows PortalException, SystemException {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tWikiNode node = null;\n\n\t\tint nodesCount = WikiNodeLocalServiceUtil.getNodesCount(\n\t\t\tthemeDisplay.getScopeGroupId());\n\n\t\tif (nodesCount == 0) {\n\t\t\tString nodeName = PropsUtil.get(PropsKeys.WIKI_INITIAL_NODE_NAME);\n\n\t\t\tLayout layout = themeDisplay.getLayout();\n\n\t\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\t\tWikiNode.class.getName(), portletRequest);\n\n\t\t\tserviceContext.setAddCommunityPermissions(true);\n\n\t\t\tif (layout.isPublicLayout()) {\n\t\t\t\tserviceContext.setAddGuestPermissions(true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tserviceContext.setAddGuestPermissions(false);\n\t\t\t}\n\n\t\t\tnode = WikiNodeLocalServiceUtil.addNode(\n\t\t\t\tthemeDisplay.getUserId(), nodeName, StringPool.BLANK,\n\t\t\t\tserviceContext);\n\t\t}\n\t\telse {\n\t\t\tList<WikiNode> nodes = WikiUtil.getNodes(portletRequest);\n\n\t\t\tif (nodes.size() == 0) {\n\t\t\t\tthrow new PrincipalException();\n\t\t\t}\n\n\t\t\tnode = nodes.get(0);\n\t\t}\n\n\t\tportletRequest.setAttribute(WebKeys.WIKI_NODE, node);\n\n\t\treturn node;\n\t}","id":75854,"modified_method":"public static WikiNode getFirstVisibleNode(PortletRequest portletRequest)\n\t\tthrows PortalException, SystemException {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tWikiNode node = null;\n\n\t\tint nodesCount = WikiNodeLocalServiceUtil.getNodesCount(\n\t\t\tthemeDisplay.getScopeGroupId());\n\n\t\tif (nodesCount == 0) {\n\t\t\tString nodeName = PropsUtil.get(PropsKeys.WIKI_INITIAL_NODE_NAME);\n\n\t\t\tLayout layout = themeDisplay.getLayout();\n\n\t\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\t\tWikiNode.class.getName(), portletRequest);\n\n\t\t\tserviceContext.setAddCommunityPermissions(true);\n\n\t\t\tif (layout.isPublicLayout()) {\n\t\t\t\tserviceContext.setAddGuestPermissions(true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tserviceContext.setAddGuestPermissions(false);\n\t\t\t}\n\n\t\t\tnode = WikiNodeLocalServiceUtil.addNode(\n\t\t\t\tthemeDisplay.getUserId(), nodeName, StringPool.BLANK,\n\t\t\t\tserviceContext);\n\t\t}\n\t\telse {\n\t\t\tnode = WikiUtil.getFirstNode(portletRequest);\n\t\t\tif (node == null) {\n\t\t\t\tthrow new PrincipalException();\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\n\t\tportletRequest.setAttribute(WebKeys.WIKI_NODE, node);\n\n\t\treturn node;\n\t}","commit_id":"bfeb36d6255384309a6ddfa0cdad9810d95180fc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static List<WikiNode> getNodes(\n\t\t\tlong groupId, String[] visibleNodes, String[] hiddenNodes,\n\t\t\tPermissionChecker permissionChecker)\n\t\tthrows SystemException {\n\n\t\tList<WikiNode> nodes = WikiNodeLocalServiceUtil.getNodes(groupId);\n\n\t\tnodes = ListUtil.copy(nodes);\n\t\tnodes = _orderNodes(nodes, visibleNodes);\n\n\t\tIterator<WikiNode> itr = nodes.iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tWikiNode node = itr.next();\n\n\t\t\tif (ArrayUtil.contains(hiddenNodes, node.getName()) ||\n\t\t\t\t!WikiNodePermission.contains(\n\t\t\t\t\tpermissionChecker, node, ActionKeys.VIEW)) {\n\n\t\t\t\titr.remove();\n\t\t\t}\n\t\t}\n\n\t\treturn nodes;\n\t}","id":75855,"modified_method":"public static List<WikiNode> getNodes(\n\t\t\tList<WikiNode> nodes, String[] hiddenNodes,\n\t\t\tPermissionChecker permissionChecker)\n\t\tthrows SystemException {\n\n\t\tList<WikiNode> resultNodes = new ArrayList<WikiNode>(nodes.size());\n\n\t\tArrays.sort(hiddenNodes);\n\t\tfor(WikiNode node : nodes) {\n\t\t\tif ((Arrays.binarySearch(hiddenNodes, node.getName()) < 0) &&\n\t\t\t\t(WikiNodePermission.contains(permissionChecker, node,\n\t\t\t\t\tActionKeys.VIEW))) {\n\t\t\t\tresultNodes.add(node);\n\t\t\t}\n\t\t}\n\n\t\treturn resultNodes;\n\t}","commit_id":"bfeb36d6255384309a6ddfa0cdad9810d95180fc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static List<WikiNode> getNodes(PortletRequest portletRequest)\n\t\tthrows SystemException {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong groupId = themeDisplay.getScopeGroupId();\n\n\t\tString allNodes = ListUtil.toString(\n\t\t\tWikiNodeLocalServiceUtil.getNodes(groupId), \"name\");\n\n\t\tPortletPreferences preferences = portletRequest.getPreferences();\n\n\t\tString[] visibleNodes = StringUtil.split(\n\t\t\tpreferences.getValue(\"visible-nodes\", allNodes));\n\t\tString[] hiddenNodes = StringUtil.split(\n\t\t\tpreferences.getValue(\"hidden-nodes\", StringPool.BLANK));\n\n\t\treturn getNodes(\n\t\t\tgroupId, visibleNodes, hiddenNodes,\n\t\t\tthemeDisplay.getPermissionChecker());\n\t}","id":75856,"modified_method":"public static WikiNode getFirstNode(PortletRequest portletRequest)\n\t\tthrows SystemException {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\t\tlong groupId = themeDisplay.getScopeGroupId();\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tList<WikiNode> nodes = WikiNodeLocalServiceUtil.getNodes(groupId);\n\n\t\tPortletPreferences preferences = portletRequest.getPreferences();\n\t\tString[] visibleNodesNames =\n\t\t\tStringUtil.split(preferences.getValue(\"visible-nodes\", null));\n\t\tnodes = orderNodes(nodes, visibleNodesNames);\n\n\t\tString[] hiddenNodes = StringUtil.split(\n\t\t\tpreferences.getValue(\"hidden-nodes\", StringPool.BLANK));\n\t\tArrays.sort(hiddenNodes);\n\n\t\tfor(WikiNode node : nodes) {\n\t\t\tif ((Arrays.binarySearch(hiddenNodes, node.getName()) < 0) &&\n\t\t\t\t(WikiNodePermission.contains(permissionChecker, node,\n\t\t\t\t\tActionKeys.VIEW))) {\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","commit_id":"bfeb36d6255384309a6ddfa0cdad9810d95180fc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static List<WikiNode> _orderNodes(\n\t\tList<WikiNode> nodes, String[] nodeNames) {\n\n\t\tList<WikiNode> orderedNodes = new ArrayList<WikiNode>();\n\n\t\tfor (String nodeName : nodeNames) {\n\t\t\tfor (WikiNode node : nodes) {\n\t\t\t\tif (node.getName().equals(nodeName)) {\n\t\t\t\t\torderedNodes.add(node);\n\n\t\t\t\t\tnodes.remove(node);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\torderedNodes.addAll(nodes);\n\n\t\treturn orderedNodes;\n\t}","id":75857,"modified_method":"public static List<WikiNode> orderNodes(\n\t\tList<WikiNode> nodes, String[] visibleNodesNames) {\n\n\t\tif ((visibleNodesNames == null) || (visibleNodesNames.length == 0)) {\n\t\t\treturn nodes;\n\t\t}\n\n\t\tList<WikiNode> orderedNodes = new ArrayList<WikiNode>(nodes.size());\n\n\t\tList<WikiNode> tailNodes = new ArrayList<WikiNode>(nodes);\n\n\t\tfor (String nodeName : visibleNodesNames) {\n\t\t\tIterator<WikiNode> tailNodesIterator = tailNodes.iterator();\n\t\t\twhile (tailNodesIterator.hasNext()) {\n\t\t\t\tWikiNode node = tailNodesIterator.next();\n\t\t\t\tif (node.getName().equals(nodeName)) {\n\t\t\t\t\torderedNodes.add(node);\n\t\t\t\t\ttailNodesIterator.remove();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\torderedNodes.addAll(tailNodes);\n\n\t\treturn orderedNodes;\n\t}","commit_id":"bfeb36d6255384309a6ddfa0cdad9810d95180fc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Returns true if the specified <code>String<\/code> matches any\n     * IANA-defined country code top-level domain. Leading dots are\n     * ignored if present. The search is case-sensitive.\n     * @param ccTld the parameter to check for country code TLD status\n     * @return true if the parameter is a country code TLD\n     */\n    public boolean isValidCountryCodeTld(String ccTld) {\n        return COUNTRY_CODE_TLD_LIST.contains(chompLeadingDot(ccTld.toLowerCase()));\n    }","id":75858,"modified_method":"/**\n     * Returns true if the specified <code>String<\/code> matches any\n     * IANA-defined country code top-level domain. Leading dots are\n     * ignored if present. The search is case-sensitive.\n     * @param ccTld the parameter to check for country code TLD status\n     * @return true if the parameter is a country code TLD\n     */\n    public boolean isValidCountryCodeTld(String ccTld) {\n        return Arrays.binarySearch(COUNTRY_CODE_TLDS, chompLeadingDot(ccTld.toLowerCase())) >= 0;\n    }","commit_id":"63211939e92d0abef75c776654c7c936935f0a56","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Returns true if the specified <code>String<\/code> matches any\n     * IANA-defined generic top-level domain. Leading dots are ignored\n     * if present. The search is case-sensitive.\n     * @param gTld the parameter to check for generic TLD status\n     * @return true if the parameter is a generic TLD\n     */\n    public boolean isValidGenericTld(String gTld) {\n        return GENERIC_TLD_LIST.contains(chompLeadingDot(gTld.toLowerCase()));\n    }","id":75859,"modified_method":"/**\n     * Returns true if the specified <code>String<\/code> matches any\n     * IANA-defined generic top-level domain. Leading dots are ignored\n     * if present. The search is case-sensitive.\n     * @param gTld the parameter to check for generic TLD status\n     * @return true if the parameter is a generic TLD\n     */\n    public boolean isValidGenericTld(String gTld) {\n        return Arrays.binarySearch(GENERIC_TLDS, chompLeadingDot(gTld.toLowerCase())) >= 0;\n    }","commit_id":"63211939e92d0abef75c776654c7c936935f0a56","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Returns true if the specified <code>String<\/code> matches any\n     * IANA-defined infrastructure top-level domain. Leading dots are\n     * ignored if present. The search is case-sensitive.\n     * @param iTld the parameter to check for infrastructure TLD status\n     * @return true if the parameter is an infrastructure TLD\n     */\n    public boolean isValidInfrastructureTld(String iTld) {\n        return INFRASTRUCTURE_TLD_LIST.contains(chompLeadingDot(iTld.toLowerCase()));\n    }","id":75860,"modified_method":"/**\n     * Returns true if the specified <code>String<\/code> matches any\n     * IANA-defined infrastructure top-level domain. Leading dots are\n     * ignored if present. The search is case-sensitive.\n     * @param iTld the parameter to check for infrastructure TLD status\n     * @return true if the parameter is an infrastructure TLD\n     */\n    public boolean isValidInfrastructureTld(String iTld) {\n        return Arrays.binarySearch(INFRASTRUCTURE_TLDS, (chompLeadingDot(iTld.toLowerCase()))) >= 0;\n    }","commit_id":"63211939e92d0abef75c776654c7c936935f0a56","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Returns true if the specified <code>String<\/code> matches any\n     * widely used \"local\" domains (localhost or localdomain). Leading dots are\n     *  ignored if present. The search is case-sensitive.\n     * @param iTld the parameter to check for local TLD status\n     * @return true if the parameter is an local TLD\n     */\n    public boolean isValidLocalTld(String iTld) {\n        return LOCAL_TLD_LIST.contains(chompLeadingDot(iTld.toLowerCase()));\n    }","id":75861,"modified_method":"/**\n     * Returns true if the specified <code>String<\/code> matches any\n     * widely used \"local\" domains (localhost or localdomain). Leading dots are\n     *  ignored if present. The search is case-sensitive.\n     * @param iTld the parameter to check for local TLD status\n     * @return true if the parameter is an local TLD\n     */\n    public boolean isValidLocalTld(String iTld) {\n        return Arrays.binarySearch(LOCAL_TLDS, chompLeadingDot(iTld.toLowerCase())) >= 0;\n    }","commit_id":"63211939e92d0abef75c776654c7c936935f0a56","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Returns true if the domain component of an email address is valid.\n     *\n     * @param domain being validated.\n     * @return true if the email address's domain is valid.\n     */\n    protected boolean isValidDomain(String domain) {\n        // see if domain is an IP address in brackets\n        Matcher ipDomainMatcher = IP_DOMAIN_PATTERN.matcher(domain);\n\n        if (ipDomainMatcher.matches()) {\n            InetAddressValidator inetAddressValidator =\n                    InetAddressValidator.getInstance();\n            return inetAddressValidator.isValid(ipDomainMatcher.group(1));\n        } else {\n            // Domain is symbolic name\n            DomainValidator domainValidator =\n                    DomainValidator.getInstance(allowLocal);\n            return domainValidator.isValid(domain);\n        }\n    }","id":75862,"modified_method":"/**\n     * Returns true if the domain component of an email address is valid.\n     *\n     * @param domain being validated.\n     * @return true if the email address's domain is valid.\n     */\n    protected boolean isValidDomain(String domain) {\n        // see if domain is an IP address in brackets\n        Matcher ipDomainMatcher = IP_DOMAIN_PATTERN.matcher(domain);\n\n        if (ipDomainMatcher.matches()) {\n            InetAddressValidator inetAddressValidator =\n                    InetAddressValidator.getInstance();\n            return inetAddressValidator.isValid(ipDomainMatcher.group(1));\n        } else {\n            // Domain is symbolic name\n            DomainValidator domainValidator =\n                    DomainValidator.getInstance(allowLocal);\n            return domainValidator.isValid(domain) ||\n                    domainValidator.isValidTld(domain);\n        }\n    }","commit_id":"63211939e92d0abef75c776654c7c936935f0a56","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Card card = game.getCard(getTargetPointer().getFirst(game, source));\r\n        Permanent permanent = game.getPermanent(source.getSourceId());\r\n        if (card == null || permanent == null) {\r\n            discard();\r\n            return false;\r\n        }\r\n        if (IdOfCopiedCard == null || !IdOfCopiedCard.equals(card.getId())) {\r\n            IdOfCopiedCard = card.getId();\r\n            cardToCopy = card.copy();\r\n            cardToCopy.assignNewId();\r\n        }\r\n        permanent.getPower().setValue(cardToCopy.getPower().getValue());\r\n        permanent.getToughness().setValue(cardToCopy.getToughness().getValue());\r\n        permanent.getColor().setColor(cardToCopy.getColor());\r\n        permanent.getManaCost().clear();\r\n        permanent.getManaCost().add(cardToCopy.getManaCost());\r\n        permanent.getCardType().clear();\r\n        for (CardType type : cardToCopy.getCardType()) {\r\n            if (!permanent.getCardType().contains(type)) {\r\n                permanent.getCardType().add(type);\r\n            }\r\n        }\r\n        permanent.getSubtype().clear();\r\n        for (String type : cardToCopy.getSubtype()) {\r\n            if (!permanent.getSubtype().contains(type)) {\r\n                permanent.getSubtype().add(type);\r\n            }\r\n        }\r\n        permanent.getSupertype().clear();\r\n        permanent.getSupertype().add(\"Legendary\");\r\n        for (String type : cardToCopy.getSupertype()) {\r\n            if (!permanent.getSupertype().contains(type)) {\r\n                permanent.getSupertype().add(type);\r\n            }\r\n        }\r\n        permanent.removeAllAbilities(source.getSourceId(), game);\r\n        permanent.addAbility(HexproofAbility.getInstance(), source.getSourceId(), game);\r\n        permanent.addAbility(new PutCardIntoGraveFromAnywhereAllTriggeredAbility(\r\n                new LazavDimirEffect(), true,\r\n                new FilterCreatureCard(\"a creature card\"),\r\n                TargetController.OPPONENT, SetTargetPointer.CARD), source.getSourceId(), game);\r\n\r\n        for (Ability ability : cardToCopy.getAbilities()) {\r\n            if (!permanent.getAbilities().contains(ability)) {\r\n                permanent.addAbility(ability, source.getSourceId(), game);\r\n            }\r\n        }\r\n        return true;\r\n    }","id":75863,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Card card = game.getCard(((FixedTarget)getTargetPointer()).getTarget());\r\n        Permanent permanent = game.getPermanent(source.getSourceId());\r\n        if (card == null || permanent == null) {\r\n            discard();\r\n            return false;\r\n        }\r\n        if (IdOfCopiedCard == null || !IdOfCopiedCard.equals(card.getId())) {\r\n            IdOfCopiedCard = card.getId();\r\n            cardToCopy = card.copy();\r\n            cardToCopy.assignNewId();\r\n        }\r\n        permanent.getPower().setValue(cardToCopy.getPower().getValue());\r\n        permanent.getToughness().setValue(cardToCopy.getToughness().getValue());\r\n        permanent.getColor().setColor(cardToCopy.getColor());\r\n        permanent.getManaCost().clear();\r\n        permanent.getManaCost().add(cardToCopy.getManaCost());\r\n        permanent.getCardType().clear();\r\n        for (CardType type : cardToCopy.getCardType()) {\r\n            if (!permanent.getCardType().contains(type)) {\r\n                permanent.getCardType().add(type);\r\n            }\r\n        }\r\n        permanent.getSubtype().clear();\r\n        for (String type : cardToCopy.getSubtype()) {\r\n            if (!permanent.getSubtype().contains(type)) {\r\n                permanent.getSubtype().add(type);\r\n            }\r\n        }\r\n        permanent.getSupertype().clear();\r\n        permanent.getSupertype().add(\"Legendary\");\r\n        for (String type : cardToCopy.getSupertype()) {\r\n            if (!permanent.getSupertype().contains(type)) {\r\n                permanent.getSupertype().add(type);\r\n            }\r\n        }\r\n        permanent.removeAllAbilities(source.getSourceId(), game);\r\n        permanent.addAbility(HexproofAbility.getInstance(), source.getSourceId(), game);\r\n        permanent.addAbility(new PutCardIntoGraveFromAnywhereAllTriggeredAbility(\r\n                new LazavDimirEffect(), true,\r\n                new FilterCreatureCard(\"a creature card\"),\r\n                TargetController.OPPONENT, SetTargetPointer.CARD), source.getSourceId(), game);\r\n\r\n        for (Ability ability : cardToCopy.getAbilities()) {\r\n            if (!permanent.getAbilities().contains(ability)) {\r\n                permanent.addAbility(ability, source.getSourceId(), game);\r\n            }\r\n        }\r\n        return true;\r\n    }","commit_id":"7648ca4b4f75d78f4cb35c78e950c4673dfdbfdd","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        for (Target target: source.getTargets()) {\r\n            if (target instanceof TargetCardInOpponentsGraveyard) {\r\n                Card targetCard = game.getCard(target.getFirstTarget());\r\n                if (controller != null && targetCard != null) {\r\n                    if (controller.chooseUse(outcome, \"Cast \" + targetCard.getName() +\"?\", game)) {\r\n                        controller.cast(targetCard.getSpellAbility(), game, true);\r\n                        ContinuousEffect effect = new DiluvianPrimordialReplacementEffect();\r\n                        effect.setTargetPointer(new FixedTarget(targetCard.getId()));\r\n                        game.addEffect(effect, source);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }","id":75864,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            for (Target target: source.getTargets()) {\r\n                if (target instanceof TargetCardInOpponentsGraveyard) {\r\n                    Card targetCard = game.getCard(target.getFirstTarget());\r\n                    if (targetCard != null) {\r\n                        if (controller.chooseUse(outcome, \"Cast \" + targetCard.getLogName() +\"?\", game)) {\r\n                            // TODO: Handle the case if the cast is not possible, so the replacement effect shouldn't be active\r\n                            ContinuousEffect effect = new DiluvianPrimordialReplacementEffect();\r\n                            effect.setTargetPointer(new FixedTarget(targetCard.getId()));\r\n                            game.addEffect(effect, source);\r\n                            \r\n                            controller.cast(targetCard.getSpellAbility(), game, true);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"e82ee26136018f6da2be4d98b1dd43bb9f281370","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean applies(GameEvent event, Ability source, Game game) {\r\n        ZoneChangeEvent zEvent = (ZoneChangeEvent) event;\r\n        if (zEvent.getToZone() == Zone.GRAVEYARD\r\n                && ((ZoneChangeEvent) event).getTargetId().equals(getTargetPointer().getFirst(game, source))) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":75865,"modified_method":"@Override\r\n    public boolean applies(GameEvent event, Ability source, Game game) {\r\n        ZoneChangeEvent zEvent = (ZoneChangeEvent) event;\r\n        return zEvent.getToZone() == Zone.GRAVEYARD\r\n                && ((ZoneChangeEvent) event).getTargetId().equals(getTargetPointer().getFirst(game, source));\r\n    }","commit_id":"e82ee26136018f6da2be4d98b1dd43bb9f281370","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean replaceEvent(GameEvent event, Ability source, Game game) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            Card card = game.getCard(getTargetPointer().getFirst(game, source));\r\n            if (card != null) {\r\n                controller.moveCardToExileWithInfo(card, null, \"\", source.getSourceId(), game, Zone.STACK, true);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","id":75866,"modified_method":"@Override\r\n    public boolean replaceEvent(GameEvent event, Ability source, Game game) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            Card card = game.getCard(((FixedTarget)getTargetPointer()).getTarget());\r\n            if (card != null) {\r\n                controller.moveCards(card, Zone.STACK, Zone.EXILED, source, game);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"e82ee26136018f6da2be4d98b1dd43bb9f281370","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player player = game.getPlayer(source.getControllerId());\r\n        for (Target target: source.getTargets()) {\r\n            if (target instanceof TargetCardInOpponentsGraveyard) {\r\n                Card targetCard = game.getCard(target.getFirstTarget());\r\n                if (player != null && targetCard != null) {\r\n                    targetCard.putOntoBattlefield(game, Zone.GRAVEYARD, source.getSourceId(), source.getControllerId());\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }","id":75867,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {        \r\n            for (Target target: source.getTargets()) {\r\n                if (target instanceof TargetCardInOpponentsGraveyard) {\r\n                    Card targetCard = game.getCard(target.getFirstTarget());\r\n                    if (targetCard != null) {\r\n                        targetCard.putOntoBattlefield(game, Zone.GRAVEYARD, source.getSourceId(), source.getControllerId());\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"e82ee26136018f6da2be4d98b1dd43bb9f281370","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean applies(UUID sourceId, Ability source, UUID affectedControllerId, Game game) {\r\n        if (sourceId.equals(cardId)) {\r\n            ExileZone exileZone = game.getState().getExile().getExileZone(exileId);\r\n            return exileZone != null && exileZone.contains(cardId);\r\n        }\r\n        return false;\r\n    }","id":75868,"modified_method":"@Override\r\n    public boolean applies(UUID sourceId, Ability source, UUID affectedControllerId, Game game) {\r\n        if (sourceId.equals(cardId) && source.getControllerId().equals(affectedControllerId)) {\r\n            ExileZone exileZone = game.getState().getExile().getExileZone(exileId);\r\n            return exileZone != null && exileZone.contains(cardId);\r\n        }\r\n        return false;\r\n    }","commit_id":"ee304e773e00e226b2deb282f6bde8f76ec08871","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean applies(UUID sourceId, Ability source, UUID affectedControllerId, Game game) {\r\n        return sourceId.equals(getTargetPointer().getFirst(game, source));\r\n    }","id":75869,"modified_method":"@Override\r\n    public boolean applies(UUID objectId, Ability source, UUID affectedControllerId, Game game) {\r\n        return source.getControllerId().equals(affectedControllerId)\r\n                && objectId == ((FixedTarget) getTargetPointer()).getTarget()\r\n                && ((FixedTarget) getTargetPointer()).getZoneChangeCounter() + 1 == game.getState().getZoneChangeCounter(objectId)\r\n                && game.getState().getZone(objectId).equals(Zone.STACK);\r\n    }","commit_id":"ee304e773e00e226b2deb282f6bde8f76ec08871","url":"https://github.com/magefree/mage"},{"original_method":"/**\n   * Test our hard-coded sizing of native java objects\n   */\n  @Test\n  public void testNativeSizes() throws IOException {\n    Class<?> cl;\n    long expected;\n    long actual;\n\n    // ArrayList\n    cl = ArrayList.class;\n    expected = ClassSize.estimateBase(cl, false);\n    actual = ClassSize.ARRAYLIST;\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // ByteBuffer\n    cl = ByteBuffer.class;\n    expected = ClassSize.estimateBase(cl, false);\n    actual = ClassSize.BYTE_BUFFER;\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // Integer\n    cl = Integer.class;\n    expected = ClassSize.estimateBase(cl, false);\n    actual = ClassSize.INTEGER;\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // Map.Entry\n    // Interface is public, all others are not.  Hard to size via ClassSize\n//    cl = Map.Entry.class;\n//    expected = ClassSize.estimateBase(cl, false);\n//    actual = ClassSize.MAP_ENTRY;\n//    if(expected != actual) {\n//      ClassSize.estimateBase(cl, true);\n//      assertEquals(expected, actual);\n//    }\n\n    // Object\n    cl = Object.class;\n    expected = ClassSize.estimateBase(cl, false);\n    actual = ClassSize.OBJECT;\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // TreeMap\n    cl = TreeMap.class;\n    expected = ClassSize.estimateBase(cl, false);\n    actual = ClassSize.TREEMAP;\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // String\n    cl = String.class;\n    expected = ClassSize.estimateBase(cl, false);\n    actual = ClassSize.STRING;\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // ConcurrentHashMap\n    cl = ConcurrentHashMap.class;\n    expected = ClassSize.estimateBase(cl, false);\n    actual = ClassSize.CONCURRENT_HASHMAP;\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // ConcurrentSkipListMap\n    cl = ConcurrentSkipListMap.class;\n    expected = ClassSize.estimateBase(cl, false);\n    actual = ClassSize.CONCURRENT_SKIPLISTMAP;\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // ReentrantReadWriteLock\n    cl = ReentrantReadWriteLock.class;\n    expected = ClassSize.estimateBase(cl, false);\n    actual = ClassSize.REENTRANT_LOCK;\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // AtomicLong\n    cl = AtomicLong.class;\n    expected = ClassSize.estimateBase(cl, false);\n    actual = ClassSize.ATOMIC_LONG;\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // AtomicInteger\n    cl = AtomicInteger.class;\n    expected = ClassSize.estimateBase(cl, false);\n    actual = ClassSize.ATOMIC_INTEGER;\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // AtomicBoolean\n    cl = AtomicBoolean.class;\n    expected = ClassSize.estimateBase(cl, false);\n    actual = ClassSize.ATOMIC_BOOLEAN;\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // CopyOnWriteArraySet\n    cl = CopyOnWriteArraySet.class;\n    expected = ClassSize.estimateBase(cl, false);\n    actual = ClassSize.COPYONWRITE_ARRAYSET;\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // CopyOnWriteArrayList\n    cl = CopyOnWriteArrayList.class;\n    expected = ClassSize.estimateBase(cl, false);\n    actual = ClassSize.COPYONWRITE_ARRAYLIST;\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n\n  }","id":75870,"modified_method":"/**\n   * Test our hard-coded sizing of native java objects\n   */\n  @Test\n  public void testNativeSizes() throws IOException {\n    Class<?> cl;\n    long expected;\n    long actual;\n\n    // ArrayList\n    cl = ArrayList.class;\n    expected = ClassSize.estimateBase(cl, false);\n    actual = ClassSize.ARRAYLIST;\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // ByteBuffer\n    cl = ByteBuffer.class;\n    expected = ClassSize.estimateBase(cl, false);\n    actual = ClassSize.BYTE_BUFFER;\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // Integer\n    cl = Integer.class;\n    expected = ClassSize.estimateBase(cl, false);\n    actual = ClassSize.INTEGER;\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // Map.Entry\n    // Interface is public, all others are not.  Hard to size via ClassSize\n//    cl = Map.Entry.class;\n//    expected = ClassSize.estimateBase(cl, false);\n//    actual = ClassSize.MAP_ENTRY;\n//    if(expected != actual) {\n//      ClassSize.estimateBase(cl, true);\n//      assertEquals(expected, actual);\n//    }\n\n    // Object\n    cl = Object.class;\n    expected = ClassSize.estimateBase(cl, false);\n    actual = ClassSize.OBJECT;\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // TreeMap\n    cl = TreeMap.class;\n    expected = ClassSize.estimateBase(cl, false);\n    actual = ClassSize.TREEMAP;\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // String\n    cl = String.class;\n    expected = ClassSize.estimateBase(cl, false);\n    actual = ClassSize.STRING;\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // ConcurrentHashMap\n    cl = ConcurrentHashMap.class;\n    expected = ClassSize.estimateBase(cl, false);\n    actual = ClassSize.CONCURRENT_HASHMAP;\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // ConcurrentSkipListMap\n    cl = ConcurrentSkipListMap.class;\n    expected = ClassSize.estimateBase(cl, false);\n    actual = ClassSize.CONCURRENT_SKIPLISTMAP;\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // ReentrantReadWriteLock\n    cl = ReentrantReadWriteLock.class;\n    expected = ClassSize.estimateBase(cl, false);\n    actual = ClassSize.REENTRANT_LOCK;\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // AtomicLong\n    cl = AtomicLong.class;\n    expected = ClassSize.estimateBase(cl, false);\n    actual = ClassSize.ATOMIC_LONG;\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // AtomicInteger\n    cl = AtomicInteger.class;\n    expected = ClassSize.estimateBase(cl, false);\n    actual = ClassSize.ATOMIC_INTEGER;\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // AtomicBoolean\n    cl = AtomicBoolean.class;\n    expected = ClassSize.estimateBase(cl, false);\n    actual = ClassSize.ATOMIC_BOOLEAN;\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // CopyOnWriteArraySet\n    cl = CopyOnWriteArraySet.class;\n    expected = ClassSize.estimateBase(cl, false);\n    actual = ClassSize.COPYONWRITE_ARRAYSET;\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // CopyOnWriteArrayList\n    cl = CopyOnWriteArrayList.class;\n    expected = ClassSize.estimateBase(cl, false);\n    actual = ClassSize.COPYONWRITE_ARRAYLIST;\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // TimeRangeTracker\n    cl = TimeRangeTracker.class;\n    expected = ClassSize.estimateBase(cl, false);\n    actual = ClassSize.TIMERANGE_TRACKER;\n    if (expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // KeyValueSkipListSet\n    cl = KeyValueSkipListSet.class;\n    expected = ClassSize.estimateBase(cl, false);\n    actual = ClassSize.KEYVALUE_SKIPLIST_SET;\n    if (expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n  }","commit_id":"0541a8da5cdbdfb6049a3dbc8eb07f726aab2960","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Testing the classes that implements HeapSize and are a part of 0.20.\n   * Some are not tested here for example BlockIndex which is tested in\n   * TestHFile since it is a non public class\n   * @throws IOException\n   */\n  @Test\n  public void testSizes() throws IOException {\n    Class<?> cl;\n    long expected;\n    long actual;\n\n    //KeyValue\n    cl = KeyValue.class;\n    expected = ClassSize.estimateBase(cl, false);\n    KeyValue kv = new KeyValue();\n    actual = kv.heapSize();\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    //LruBlockCache Overhead\n    cl = LruBlockCache.class;\n    actual = LruBlockCache.CACHE_FIXED_OVERHEAD;\n    expected = ClassSize.estimateBase(cl, false);\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // CachedBlock Fixed Overhead\n    // We really need \"deep\" sizing but ClassSize does not do this.\n    // Perhaps we should do all these more in this style....\n    cl = CachedBlock.class;\n    actual = CachedBlock.PER_BLOCK_OVERHEAD;\n    expected = ClassSize.estimateBase(cl, false);\n    expected += ClassSize.estimateBase(String.class, false);\n    expected += ClassSize.estimateBase(ByteBuffer.class, false);\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      ClassSize.estimateBase(String.class, true);\n      ClassSize.estimateBase(ByteBuffer.class, true);\n      assertEquals(expected, actual);\n    }\n\n    // MemStore Overhead\n    cl = MemStore.class;\n    actual = MemStore.FIXED_OVERHEAD;\n    expected = ClassSize.estimateBase(cl, false);\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // MemStore Deep Overhead\n    actual = MemStore.DEEP_OVERHEAD;\n    expected = ClassSize.estimateBase(cl, false);\n    expected += ClassSize.estimateBase(ReentrantReadWriteLock.class, false);\n    expected += ClassSize.estimateBase(AtomicLong.class, false);\n    expected += ClassSize.estimateBase(ConcurrentSkipListMap.class, false);\n    expected += ClassSize.estimateBase(ConcurrentSkipListMap.class, false);\n    expected += ClassSize.estimateBase(CopyOnWriteArraySet.class, false);\n    expected += ClassSize.estimateBase(CopyOnWriteArrayList.class, false);\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      ClassSize.estimateBase(ReentrantReadWriteLock.class, true);\n      ClassSize.estimateBase(AtomicLong.class, true);\n      ClassSize.estimateBase(ConcurrentSkipListMap.class, true);\n      ClassSize.estimateBase(CopyOnWriteArraySet.class, true);\n      ClassSize.estimateBase(CopyOnWriteArrayList.class, true);\n      assertEquals(expected, actual);\n    }\n\n    // Store Overhead\n    cl = HStore.class;\n    actual = HStore.FIXED_OVERHEAD;\n    expected = ClassSize.estimateBase(cl, false);\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // Region Overhead\n    cl = HRegion.class;\n    actual = HRegion.FIXED_OVERHEAD;\n    expected = ClassSize.estimateBase(cl, false);\n    if (expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // Block cache key overhead\n    cl = BlockCacheKey.class;\n    // Passing zero length file name, because estimateBase does not handle\n    // deep overhead.\n    actual = new BlockCacheKey(\"\", 0).heapSize();\n    expected  = ClassSize.estimateBase(cl, false);\n    if (expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // Currently NOT testing Deep Overheads of many of these classes.\n    // Deep overheads cover a vast majority of stuff, but will not be 100%\n    // accurate because it's unclear when we're referencing stuff that's already\n    // accounted for.  But we have satisfied our two core requirements.\n    // Sizing is quite accurate now, and our tests will throw errors if\n    // any of these classes are modified without updating overhead sizes.\n  }","id":75871,"modified_method":"/**\n   * Testing the classes that implements HeapSize and are a part of 0.20.\n   * Some are not tested here for example BlockIndex which is tested in\n   * TestHFile since it is a non public class\n   * @throws IOException\n   */\n  @Test\n  public void testSizes() throws IOException {\n    Class<?> cl;\n    long expected;\n    long actual;\n\n    //KeyValue\n    cl = KeyValue.class;\n    expected = ClassSize.estimateBase(cl, false);\n    KeyValue kv = new KeyValue();\n    actual = kv.heapSize();\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    //LruBlockCache Overhead\n    cl = LruBlockCache.class;\n    actual = LruBlockCache.CACHE_FIXED_OVERHEAD;\n    expected = ClassSize.estimateBase(cl, false);\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // CachedBlock Fixed Overhead\n    // We really need \"deep\" sizing but ClassSize does not do this.\n    // Perhaps we should do all these more in this style....\n    cl = CachedBlock.class;\n    actual = CachedBlock.PER_BLOCK_OVERHEAD;\n    expected = ClassSize.estimateBase(cl, false);\n    expected += ClassSize.estimateBase(String.class, false);\n    expected += ClassSize.estimateBase(ByteBuffer.class, false);\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      ClassSize.estimateBase(String.class, true);\n      ClassSize.estimateBase(ByteBuffer.class, true);\n      assertEquals(expected, actual);\n    }\n\n    // MemStore Overhead\n    cl = MemStore.class;\n    actual = MemStore.FIXED_OVERHEAD;\n    expected = ClassSize.estimateBase(cl, false);\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // MemStore Deep Overhead\n    actual = MemStore.DEEP_OVERHEAD;\n    expected = ClassSize.estimateBase(cl, false);\n    expected += ClassSize.estimateBase(ReentrantReadWriteLock.class, false);\n    expected += ClassSize.estimateBase(AtomicLong.class, false);\n    expected += (2 * ClassSize.estimateBase(KeyValueSkipListSet.class, false));\n    expected += (2 * ClassSize.estimateBase(ConcurrentSkipListMap.class, false));\n    expected += (2 * ClassSize.estimateBase(TimeRangeTracker.class, false));\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      ClassSize.estimateBase(ReentrantReadWriteLock.class, true);\n      ClassSize.estimateBase(AtomicLong.class, true);\n      ClassSize.estimateBase(KeyValueSkipListSet.class, true);\n      ClassSize.estimateBase(KeyValueSkipListSet.class, true);\n      ClassSize.estimateBase(ConcurrentSkipListMap.class, true);\n      ClassSize.estimateBase(ConcurrentSkipListMap.class, true);\n      ClassSize.estimateBase(TimeRangeTracker.class, true);\n      ClassSize.estimateBase(TimeRangeTracker.class, true);\n      assertEquals(expected, actual);\n    }\n\n    // Store Overhead\n    cl = HStore.class;\n    actual = HStore.FIXED_OVERHEAD;\n    expected = ClassSize.estimateBase(cl, false);\n    if(expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // Region Overhead\n    cl = HRegion.class;\n    actual = HRegion.FIXED_OVERHEAD;\n    expected = ClassSize.estimateBase(cl, false);\n    if (expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // Block cache key overhead\n    cl = BlockCacheKey.class;\n    // Passing zero length file name, because estimateBase does not handle\n    // deep overhead.\n    actual = new BlockCacheKey(\"\", 0).heapSize();\n    expected  = ClassSize.estimateBase(cl, false);\n    if (expected != actual) {\n      ClassSize.estimateBase(cl, true);\n      assertEquals(expected, actual);\n    }\n\n    // Currently NOT testing Deep Overheads of many of these classes.\n    // Deep overheads cover a vast majority of stuff, but will not be 100%\n    // accurate because it's unclear when we're referencing stuff that's already\n    // accounted for.  But we have satisfied our two core requirements.\n    // Sizing is quite accurate now, and our tests will throw errors if\n    // any of these classes are modified without updating overhead sizes.\n  }","commit_id":"0541a8da5cdbdfb6049a3dbc8eb07f726aab2960","url":"https://github.com/apache/hbase"},{"original_method":"/**\n\t * @see wicket.request.target.coding.IRequestTargetUrlCodingStrategy#decode(wicket.request.RequestParameters)\n\t */\n\tpublic IRequestTarget decode(RequestParameters requestParameters)\n\t{\n\t\tfinal String parametersFragment = requestParameters.getPath().substring(\n\t\t\t\tgetMountPath().length());\n\t\tfinal PageParameters parameters = new PageParameters(decodeParameters(parametersFragment,\n\t\t\t\trequestParameters.getParameters()));\n\t\tfinal String pageMapName = (String)parameters.remove(WebRequestCodingStrategy.PAGEMAP);\n\t\trequestParameters.setPageMapName(pageMapName);\n\n\t\tfinal BookmarkablePageRequestTarget target = new BookmarkablePageRequestTarget(pageMapName,\n\t\t\t\tbookmarkablePageClass, parameters);\n\t\treturn target;\n\t}","id":75872,"modified_method":"/**\n\t * @see wicket.request.target.coding.IRequestTargetUrlCodingStrategy#decode(wicket.request.RequestParameters)\n\t */\n\tpublic IRequestTarget decode(RequestParameters requestParameters)\n\t{\n\t\tfinal String parametersFragment = requestParameters.getPath().substring(\n\t\t\t\tgetMountPath().length());\n\t\tfinal PageParameters parameters = new PageParameters(decodeParameters(parametersFragment,\n\t\t\t\trequestParameters.getParameters()));\n\t\tString pageMapName = (String)parameters.remove(WebRequestCodingStrategy.PAGEMAP);\n\t\tif(requestParameters.getPageMapName() == null)\n\t\t{\n\t\t\trequestParameters.setPageMapName(pageMapName);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpageMapName = requestParameters.getPageMapName();\n\t\t}\n\n\t\tfinal BookmarkablePageRequestTarget target = new BookmarkablePageRequestTarget(pageMapName,\n\t\t\t\tbookmarkablePageClass, parameters);\n\t\treturn target;\n\t}","commit_id":"cdc59849cc0c9b9eb5d999657d0bb7604faa7464","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.request.IRequestCodingStrategy#decode(wicket.Request)\n\t */\n\tpublic final RequestParameters decode(final Request request)\n\t{\n\t\tfinal RequestParameters parameters = new RequestParameters();\n\t\tfinal String pathInfo = getRequestPath(request);\n\t\tparameters.setPath(pathInfo);\n\t\taddInterfaceParameters(request, parameters);\n\t\taddBookmarkablePageParameters(request, parameters);\n\t\taddResourceParameters(request, parameters);\n\t\tparameters.setBehaviorId(request.getParameter(BEHAVIOR_ID_PARAMETER_NAME));\n\t\tif (request.getParameter(IGNORE_IF_NOT_ACTIVE_PARAMETER_NAME) != null)\n\t\t{\n\t\t\tparameters.setOnlyProcessIfPathActive(true);\n\t\t}\n\n\t\tMap map = request.getParameterMap();\n\t\tIterator iterator = map.keySet().iterator();\n\t\twhile (iterator.hasNext())\n\t\t{\n\t\t\tString key = (String)iterator.next();\n\t\t\tif (key.startsWith(NAME_SPACE))\n\t\t\t{\n\t\t\t\titerator.remove();\n\t\t\t}\n\t\t}\n\t\tparameters.setParameters(map);\n\t\treturn parameters;\n\t}","id":75873,"modified_method":"/**\n\t * @see wicket.request.IRequestCodingStrategy#decode(wicket.Request)\n\t */\n\tpublic final RequestParameters decode(final Request request)\n\t{\n\t\tfinal RequestParameters parameters = new RequestParameters();\n\t\tfinal String pathInfo = getRequestPath(request);\n\t\tparameters.setPath(pathInfo);\n\t\tparameters.setPageMapName(request.getParameter(PAGEMAP));\n\t\taddInterfaceParameters(request, parameters);\n\t\taddBookmarkablePageParameters(request, parameters);\n\t\taddResourceParameters(request, parameters);\n\t\tparameters.setBehaviorId(request.getParameter(BEHAVIOR_ID_PARAMETER_NAME));\n\t\tif (request.getParameter(IGNORE_IF_NOT_ACTIVE_PARAMETER_NAME) != null)\n\t\t{\n\t\t\tparameters.setOnlyProcessIfPathActive(true);\n\t\t}\n\n\t\tMap map = request.getParameterMap();\n\t\tIterator iterator = map.keySet().iterator();\n\t\twhile (iterator.hasNext())\n\t\t{\n\t\t\tString key = (String)iterator.next();\n\t\t\tif (key.startsWith(NAME_SPACE))\n\t\t\t{\n\t\t\t\titerator.remove();\n\t\t\t}\n\t\t}\n\t\tparameters.setParameters(map);\n\t\treturn parameters;\n\t}","commit_id":"cdc59849cc0c9b9eb5d999657d0bb7604faa7464","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see org.apache.wicket.markup.html.link.ILinkListener#onLinkClicked()\n\t */\n\tpublic final void onLinkClicked()\n\t{\n\t\tRequestCycle.get().getRequest().getRequestParameters().setPageMapName(pageMapName);\n\n\t\tsetResponsePage(pageLink.getPage());\n\t}","id":75874,"modified_method":"/**\n\t * @see org.apache.wicket.markup.html.link.ILinkListener#onLinkClicked()\n\t */\n\tpublic final void onLinkClicked()\n\t{\n\t\tRequestParameters parameters = RequestCycle.get().getRequest().getRequestParameters();\n\t\tString oldPageMapName = parameters.getPageMapName();\n\t\ttry\n\t\t{\n\t\t\tif (pageMapName != null)\n\t\t\t{\n\t\t\t\tRequestCycle.get().getRequest().getRequestParameters().setPageMapName(pageMapName);\n\t\t\t}\n\t\t\tsetResponsePage(pageLink.getPage());\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tRequestCycle.get().getRequest().getRequestParameters().setPageMapName(oldPageMapName);\n\t\t}\n\t}","commit_id":"0c2f7a7ccfe4b39cfb26a055b8f4b1297c464c66","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * This constructor is ideal if a Page object was passed in from a previous\n\t * Page. Construct an inline frame containing the given Page.\n\t * \n\t * @param id\n\t *            See component\n\t * @param pageMap\n\t *            the pagemap where the page of the inline frame must be in\n\t * @param page\n\t *            The page\n\t */\n\tpublic InlineFrame(final String id, final IPageMap pageMap, final Page page)\n\t{\n\t\tthis(id, pageMap, new IPageLink()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic Page getPage()\n\t\t\t{\n\t\t\t\t// use given page\n\t\t\t\treturn page;\n\t\t\t}\n\n\t\t\tpublic Class getPageIdentity()\n\t\t\t{\n\t\t\t\treturn page.getClass();\n\t\t\t}\n\t\t});\n\t}","id":75875,"modified_method":"/**\n\t * This constructor is ideal if a Page object was passed in from a previous\n\t * Page. Construct an inline frame containing the given Page.\n\t * \n\t * @param id\n\t *            See component\n\t * @param pageMap\n\t *            the pagemap where the page of the inline frame must be in\n\t * @param page\n\t *            The page\n\t */\n\tpublic InlineFrame(final String id, final Page page)\n\t{\n\t\tthis(id, null, new IPageLink()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic Page getPage()\n\t\t\t{\n\t\t\t\t// use given page\n\t\t\t\treturn page;\n\t\t\t}\n\n\t\t\tpublic Class getPageIdentity()\n\t\t\t{\n\t\t\t\treturn page.getClass();\n\t\t\t}\n\t\t});\n\t}","commit_id":"0c2f7a7ccfe4b39cfb26a055b8f4b1297c464c66","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructs an inline frame that instantiates the given Page class when\n\t * the content of the inline frame is requested. The instantiated Page is\n\t * used to render a response to the user.\n\t * \n\t * @param id\n\t *            See Component\n\t * @param pageMap\n\t *            the pagemap where the page of the inline frame must be in\n\t * @param c\n\t *            Page class\n\t */\n\tpublic InlineFrame(final String id, final IPageMap pageMap, final Class c)\n\t{\n\t\tthis(id, pageMap, new IPageLink()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tpublic Page getPage()\n\t\t\t{\n\t\t\t\t// Create page using page factory\n\t\t\t\treturn Session.get().getPageFactory().newPage(c);\n\t\t\t}\n\n\t\t\tpublic Class getPageIdentity()\n\t\t\t{\n\t\t\t\treturn c;\n\t\t\t}\n\t\t});\n\n\t\t// Ensure that c is a subclass of Page\n\t\tif (!Page.class.isAssignableFrom(c))\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"Class \" + c + \" is not a subclass of Page\");\n\t\t}\n\t}","id":75876,"modified_method":"/**\n\t * Constructs an inline frame that instantiates the given Page class when\n\t * the content of the inline frame is requested. The instantiated Page is\n\t * used to render a response to the user.\n\t * \n\t * @param id\n\t *            See Component\n\t * @param pageMap\n\t *            the pagemap where the page of the inline frame must be in\n\t * @param c\n\t *            Page class\n\t */\n\tpublic InlineFrame(final String id, final IPageMap pageMap, final Class c)\n\t{\n\t\tthis(id, pageMap, c, null);\n\t}","commit_id":"0c2f7a7ccfe4b39cfb26a055b8f4b1297c464c66","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.request.target.coding.IRequestTargetUrlCodingStrategy#decode(wicket.request.RequestParameters)\n\t */\n\tpublic IRequestTarget decode(RequestParameters requestParameters)\n\t{\n\n\t\tfinal String parametersFragment = requestParameters.getPath().substring(\n\t\t\t\tgetMountPath().length());\n\t\tfinal PageParameters parameters = new PageParameters(decodeParameters(parametersFragment,\n\t\t\t\trequestParameters.getParameters()));\n\t\tfinal String pageMapName = (String)parameters.remove(WebRequestCodingStrategy.PAGEMAP);\n\t\trequestParameters.setPageMapName(pageMapName);\n\t\t\n\t\tfinal BookmarkablePageRequestTarget target;\n\t\t\n\t\tfinal String bookmarkableInterfaceListener = (String) parameters.remove(\n\t\t\t\tWebRequestCodingStrategy.INTERFACE_PARAMETER_NAME);\n\t\t\n\t\t// Do the parameters contain component path and listener interface?\n\t\tif (bookmarkableInterfaceListener != null) {\n\t\t\t// try to parse component path and listener interface \n\t\t\tfinal String[] pathComponents = Strings.split(bookmarkableInterfaceListener, Component.PATH_SEPARATOR);\n\t\t\t// There must be at least 4 path components\n\t\t\tif (pathComponents.length < 4)\n\t\t\t{\n\t\t\t\tthrow new WicketRuntimeException(\"Internal error parsing \"\n\t\t\t\t\t\t+ WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME + \" = \" + bookmarkableInterfaceListener);\n\t\t\t}\n\t\t\tfinal String interfaceName = pathComponents[pathComponents.length - 1];\n\t\t\tfinal String componentPath = bookmarkableInterfaceListener.substring(1, \n\t\t\t\t\tbookmarkableInterfaceListener.length() - interfaceName.length() - 2);\n\t\t\t\n\t\t\ttarget = new BookmarkableListenerInterfaceRequestTarget(pageMapName, bookmarkablePageClass, parameters,\n\t\t\t\t\tcomponentPath, interfaceName);\n\t\t}\t\t\t\t\t\t\t\t\t\t\n\t\telse \n\t\t{\n\t\t\ttarget = new BookmarkablePageRequestTarget(pageMapName,\n\t\t\t\t\tbookmarkablePageClass, parameters);\t\n\t\t}\n\t\t \n\t\treturn target;\n\t}","id":75877,"modified_method":"/**\n\t * @see wicket.request.target.coding.IRequestTargetUrlCodingStrategy#decode(wicket.request.RequestParameters)\n\t */\n\tpublic IRequestTarget decode(RequestParameters requestParameters)\n\t{\n\n\t\tfinal String parametersFragment = requestParameters.getPath().substring(\n\t\t\t\tgetMountPath().length());\n\t\tfinal PageParameters parameters = new PageParameters(decodeParameters(parametersFragment,\n\t\t\t\trequestParameters.getParameters()));\n\t\tString pageMapName = (String)parameters.remove(WebRequestCodingStrategy.PAGEMAP);\n\t\tif(requestParameters.getPageMapName() == null)\n\t\t{\n\t\t\trequestParameters.setPageMapName(pageMapName);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpageMapName = requestParameters.getPageMapName();\n\t\t}\n\t\t\n\t\tfinal BookmarkablePageRequestTarget target;\n\t\t\n\t\tfinal String bookmarkableInterfaceListener = (String) parameters.remove(\n\t\t\t\tWebRequestCodingStrategy.INTERFACE_PARAMETER_NAME);\n\t\t\n\t\t// Do the parameters contain component path and listener interface?\n\t\tif (bookmarkableInterfaceListener != null) {\n\t\t\t// try to parse component path and listener interface \n\t\t\tfinal String[] pathComponents = Strings.split(bookmarkableInterfaceListener, Component.PATH_SEPARATOR);\n\t\t\t// There must be at least 4 path components\n\t\t\tif (pathComponents.length < 4)\n\t\t\t{\n\t\t\t\tthrow new WicketRuntimeException(\"Internal error parsing \"\n\t\t\t\t\t\t+ WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME + \" = \" + bookmarkableInterfaceListener);\n\t\t\t}\n\t\t\tfinal String interfaceName = pathComponents[pathComponents.length - 1];\n\t\t\tfinal String componentPath = bookmarkableInterfaceListener.substring(1, \n\t\t\t\t\tbookmarkableInterfaceListener.length() - interfaceName.length() - 2);\n\t\t\t\n\t\t\ttarget = new BookmarkableListenerInterfaceRequestTarget(pageMapName, bookmarkablePageClass, parameters,\n\t\t\t\t\tcomponentPath, interfaceName);\n\t\t}\t\t\t\t\t\t\t\t\t\t\n\t\telse \n\t\t{\n\t\t\ttarget = new BookmarkablePageRequestTarget(pageMapName,\n\t\t\t\t\tbookmarkablePageClass, parameters);\t\n\t\t}\n\t\t \n\t\treturn target;\n\t}","commit_id":"7f394cea249ab0615963bc7ac26a31608a46a7c4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.request.IRequestCodingStrategy#decode(wicket.Request)\n\t */\n\tpublic final RequestParameters decode(final Request request)\n\t{\n\t\tfinal RequestParameters parameters = new RequestParameters();\n\t\tfinal String pathInfo = getRequestPath(request);\n\t\tparameters.setPath(pathInfo);\n\t\taddInterfaceParameters(request, parameters);\n\t\taddBookmarkablePageParameters(request, parameters);\n\t\taddResourceParameters(request, parameters);\n\n\t\tparameters.setBehaviorId(request.getParameter(BEHAVIOR_ID_PARAMETER_NAME));\n\n\t\tMap<String, ? extends Object> map = request.getParameterMap();\n\t\tIterator<String> iterator = map.keySet().iterator();\n\t\twhile (iterator.hasNext())\n\t\t{\n\t\t\tString key = iterator.next();\n\t\t\tif (key.startsWith(NAME_SPACE))\n\t\t\t{\n\t\t\t\titerator.remove();\n\t\t\t}\n\t\t}\n\t\tparameters.setParameters(map);\n\t\treturn parameters;\n\t}","id":75878,"modified_method":"/**\n\t * @see wicket.request.IRequestCodingStrategy#decode(wicket.Request)\n\t */\n\tpublic final RequestParameters decode(final Request request)\n\t{\n\t\tfinal RequestParameters parameters = new RequestParameters();\n\t\tfinal String pathInfo = getRequestPath(request);\n\t\tparameters.setPath(pathInfo);\n\t\tparameters.setPageMapName(request.getParameter(PAGEMAP));\n\t\taddInterfaceParameters(request, parameters);\n\t\taddBookmarkablePageParameters(request, parameters);\n\t\taddResourceParameters(request, parameters);\n\n\t\tparameters.setBehaviorId(request.getParameter(BEHAVIOR_ID_PARAMETER_NAME));\n\n\t\tMap<String, ? extends Object> map = request.getParameterMap();\n\t\tIterator<String> iterator = map.keySet().iterator();\n\t\twhile (iterator.hasNext())\n\t\t{\n\t\t\tString key = iterator.next();\n\t\t\tif (key.startsWith(NAME_SPACE))\n\t\t\t{\n\t\t\t\titerator.remove();\n\t\t\t}\n\t\t}\n\t\tparameters.setParameters(map);\n\t\treturn parameters;\n\t}","commit_id":"7f394cea249ab0615963bc7ac26a31608a46a7c4","url":"https://github.com/apache/wicket"},{"original_method":"@Override\n  public void store(Measure measure) {\n    org.sonar.api.measures.Metric<?> m = metricFinder.findByKey(measure.metric().key());\n    if (m == null) {\n      throw new IllegalStateException(\"Unknow metric with key: \" + measure.metric().key());\n    }\n    org.sonar.api.measures.Measure measureToSave = new org.sonar.api.measures.Measure(m);\n    setValueAccordingToMetricType(measure, m, measureToSave);\n    if (measure.inputFile() != null) {\n      Formula formula = measure.metric() instanceof org.sonar.api.measures.Metric ?\n        ((org.sonar.api.measures.Metric) measure.metric()).getFormula() : null;\n      if (formula instanceof SumChildDistributionFormula\n        && !Scopes.isHigherThanOrEquals(Scopes.FILE, ((SumChildDistributionFormula) formula).getMinimumScopeToPersist())) {\n        measureToSave.setPersistenceMode(PersistenceMode.MEMORY);\n      }\n      sensorContext.saveMeasure(measure.inputFile(), measureToSave);\n    } else {\n      sensorContext.saveMeasure(measureToSave);\n    }\n  }","id":75879,"modified_method":"@Override\n  public void store(Measure measure) {\n    org.sonar.api.measures.Metric m = findMetricOrFail(measure.metric().key());\n    org.sonar.api.measures.Measure measureToSave = new org.sonar.api.measures.Measure(m);\n    setValueAccordingToMetricType(measure, m, measureToSave);\n    if (measure.inputFile() != null) {\n      Formula formula = measure.metric() instanceof org.sonar.api.measures.Metric ?\n        ((org.sonar.api.measures.Metric) measure.metric()).getFormula() : null;\n      if (formula instanceof SumChildDistributionFormula\n        && !Scopes.isHigherThanOrEquals(Scopes.FILE, ((SumChildDistributionFormula) formula).getMinimumScopeToPersist())) {\n        measureToSave.setPersistenceMode(PersistenceMode.MEMORY);\n      }\n      sensorContext.saveMeasure(measure.inputFile(), measureToSave);\n    } else {\n      sensorContext.saveMeasure(measureToSave);\n    }\n  }","commit_id":"a7d09f73566971ae7301963907336be8cae943a9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void setValueAccordingToMetricType(Measure<?> measure, org.sonar.api.measures.Metric<?> m, org.sonar.api.measures.Measure measureToSave) {\n    switch (m.getType()) {\n      case BOOL:\n        measureToSave.setValue(Boolean.TRUE.equals(measure.value()) ? 1.0 : 0.0);\n        break;\n      case INT:\n      case MILLISEC:\n        measureToSave.setValue(Double.valueOf((Integer) measure.value()));\n        break;\n      case FLOAT:\n      case PERCENT:\n      case RATING:\n        measureToSave.setValue((Double) measure.value());\n        break;\n      case STRING:\n      case LEVEL:\n      case DATA:\n      case DISTRIB:\n        measureToSave.setData((String) measure.value());\n        break;\n      case WORK_DUR:\n        measureToSave.setValue(Double.valueOf((Long) measure.value()));\n        break;\n      default:\n        if (m.isNumericType()) {\n          measureToSave.setValue((Double) measure.value());\n        } else if (m.isDataType()) {\n          measureToSave.setData((String) measure.value());\n        } else {\n          throw new UnsupportedOperationException(\"Unsupported type :\" + m.getType());\n        }\n    }\n  }","id":75880,"modified_method":"private void setValueAccordingToMetricType(Measure<?> measure, org.sonar.api.measures.Metric<?> m, org.sonar.api.measures.Measure measureToSave) {\n    switch (m.getType()) {\n      case BOOL:\n        measureToSave.setValue(Boolean.TRUE.equals(measure.value()) ? 1.0 : 0.0);\n        break;\n      case INT:\n      case MILLISEC:\n        measureToSave.setValue(Double.valueOf((Integer) measure.value()));\n        break;\n      case FLOAT:\n      case PERCENT:\n      case RATING:\n        measureToSave.setValue((Double) measure.value());\n        break;\n      case STRING:\n      case LEVEL:\n      case DATA:\n      case DISTRIB:\n        measureToSave.setData((String) measure.value());\n        break;\n      case WORK_DUR:\n        measureToSave.setValue(Double.valueOf((Long) measure.value()));\n        break;\n      default:\n        throw new UnsupportedOperationException(\"Unsupported type :\" + m.getType());\n    }\n  }","commit_id":"a7d09f73566971ae7301963907336be8cae943a9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public TestCase getTestCase(InputFile testFile, String testCaseName) {\n    File testRes = getTestResource(testFile);\n    MutableTestPlan testPlan = perspectives.as(MutableTestPlan.class, testRes);\n    Iterable<MutableTestCase> testCases = testPlan.testCasesByName(testCaseName);\n    if (testCases.iterator().hasNext()) {\n      MutableTestCase testCase = testCases.iterator().next();\n      return new DefaultTestCase(testFile, testCaseName, testCase.durationInMs(), TestCase.Status.of(testCase.status().name()), testCase.message(), TestCase.Type.valueOf(testCase\n        .type()), testCase.stackTrace());\n    }\n    return null;\n  }","id":75881,"modified_method":"@Override\n  public TestCase getTestCase(InputFile testFile, String testCaseName) {\n    File testRes = getTestResource(testFile);\n    MutableTestPlan testPlan = perspectives.as(MutableTestPlan.class, testRes);\n    if (testPlan != null) {\n      Iterable<MutableTestCase> testCases = testPlan.testCasesByName(testCaseName);\n      if (testCases.iterator().hasNext()) {\n        MutableTestCase testCase = testCases.iterator().next();\n        return new DefaultTestCase(testFile, testCaseName, testCase.durationInMs(), TestCase.Status.of(testCase.status().name()), testCase.message(),\n          TestCase.Type.valueOf(testCase\n            .type()), testCase.stackTrace());\n      }\n    }\n    return null;\n  }","commit_id":"a7d09f73566971ae7301963907336be8cae943a9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private Metric findMetricOrFail(String metricKey) {\n    Metric<?> m = metricFinder.findByKey(metricKey);\n    if (m == null) {\n      throw new IllegalStateException(\"Unknow metric with key: \" + metricKey);\n    }\n    return m;\n  }","id":75882,"modified_method":"private org.sonar.api.measures.Metric findMetricOrFail(String metricKey) {\n    org.sonar.api.measures.Metric m = metricFinder.findByKey(metricKey);\n    if (m == null) {\n      throw new IllegalStateException(\"Unknow metric with key: \" + metricKey);\n    }\n    return m;\n  }","commit_id":"a7d09f73566971ae7301963907336be8cae943a9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void addTestCase(TestCase testCase) {\n    File testRes = getTestResource(((DefaultTestCase) testCase).testFile());\n    MutableTestPlan testPlan = perspectives.as(MutableTestPlan.class, testRes);\n    testPlan\n      .addTestCase(testCase.name())\n      .setDurationInMs(testCase.durationInMs())\n      .setType(testCase.type().name())\n      .setStatus(org.sonar.api.test.TestCase.Status.valueOf(testCase.status().name()))\n      .setMessage(testCase.message())\n      .setStackTrace(testCase.stackTrace());\n  }","id":75883,"modified_method":"@Override\n  public void addTestCase(TestCase testCase) {\n    File testRes = getTestResource(((DefaultTestCase) testCase).testFile());\n    MutableTestPlan testPlan = perspectives.as(MutableTestPlan.class, testRes);\n    if (testPlan != null) {\n      testPlan\n        .addTestCase(testCase.name())\n        .setDurationInMs(testCase.durationInMs())\n        .setType(testCase.type().name())\n        .setStatus(org.sonar.api.test.TestCase.Status.valueOf(testCase.status().name()))\n        .setMessage(testCase.message())\n        .setStackTrace(testCase.stackTrace());\n    }\n  }","commit_id":"a7d09f73566971ae7301963907336be8cae943a9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void setStackTrace(Fault fault, Message msg) {\n        Map<String, String> ns = new HashMap<String, String>();\n        XPathUtils xu = new XPathUtils(ns);\n        ns.put(\"s\", Fault.STACKTRACE_NAMESPACE);\n        String ss = (String) xu.getValue(\"//s:\" + Fault.STACKTRACE + \"/text()\", fault.getDetail(),\n                XPathConstants.STRING);\n        List<StackTraceElement> stackTraceList = new ArrayList<StackTraceElement>();\n        if (!StringUtils.isEmpty(ss)) {\n            StringTokenizer st = new StringTokenizer(ss, \"\\n\");\n            while (st.hasMoreTokens()) {\n                String oneLine = st.nextToken();\n                if (oneLine.startsWith(\"Caused by:\")) {\n                    // need to skip this part of message,\n                    // as we can't create the cause exception instance directly. \n                    break;\n                }\n                StringTokenizer stInner = new StringTokenizer(oneLine, \"!\");\n                StackTraceElement ste = new StackTraceElement(stInner.nextToken(), stInner.nextToken(),\n                        stInner.nextToken(), Integer.parseInt(stInner.nextToken()));\n                stackTraceList.add(ste);\n            }\n            if (stackTraceList.size() > 0) {\n                StackTraceElement[] stackTraceElement = new StackTraceElement[stackTraceList.size()];\n                Exception e = msg.getContent(Exception.class);\n                e.setStackTrace(stackTraceList.toArray(stackTraceElement));\n            }\n        }\n\n    }","id":75884,"modified_method":"private void setStackTrace(Fault fault, Message msg) {\n        Throwable cause = null;\n        Map<String, String> ns = new HashMap<String, String>();\n        XPathUtils xu = new XPathUtils(ns);\n        ns.put(\"s\", Fault.STACKTRACE_NAMESPACE);\n        String ss = (String) xu.getValue(\"//s:\" + Fault.STACKTRACE + \"/text()\", fault.getDetail(),\n                XPathConstants.STRING);\n        List<StackTraceElement> stackTraceList = new ArrayList<StackTraceElement>();\n        if (!StringUtils.isEmpty(ss)) {\n            StringTokenizer st = new StringTokenizer(ss, \"\\n\");\n            while (st.hasMoreTokens()) {\n                String oneLine = st.nextToken();\n                if (oneLine.startsWith(\"Caused by:\")) {\n                    cause = getCause(st, oneLine);\n                    break;\n                }\n                stackTraceList.add(parseStackTrackLine(oneLine));\n            }\n            if (stackTraceList.size() > 0 || cause != null) {\n                Exception e = msg.getContent(Exception.class);\n                if (!stackTraceList.isEmpty()) {\n                    StackTraceElement[] stackTraceElement = new StackTraceElement[stackTraceList.size()];\n                    e.setStackTrace(stackTraceList.toArray(stackTraceElement));\n                }\n                if (cause != null) {\n                    e.initCause(cause);\n                }\n            }\n        }\n\n    }","commit_id":"82da7a300db3050694fdc6a25df8a1df80b07e66","url":"https://github.com/apache/cxf"},{"original_method":"public ExceptionPlaceholder(Throwable throwable) throws IOException {\r\n            ByteArrayOutputStream outstr = new ByteArrayOutputStream();\r\n            ObjectOutputStream oos = new ObjectOutputStream(outstr);\r\n            try {\r\n                oos.writeObject(throwable);\r\n                oos.close();\r\n                serializedException = outstr.toByteArray();\r\n            } catch (NotSerializableException e) {\r\n                // Ignore\r\n            }\r\n\r\n            type = throwable.getClass().getName();\r\n            message = throwable.getMessage();\r\n            if (throwable.getCause() != null) {\r\n                cause = new ExceptionPlaceholder(throwable.getCause());\r\n            }\r\n            stackTrace = throwable.getStackTrace();\r\n        }","id":75885,"modified_method":"public ExceptionPlaceholder(final Throwable throwable) throws IOException {\r\n            ByteArrayOutputStream outstr = new ByteArrayOutputStream();\r\n            ObjectOutputStream oos = new ExceptionReplacingObjectOutputStream(outstr) {\r\n                @Override\r\n                protected Object replaceObject(Object obj) throws IOException {\r\n                    if (obj == throwable) {\r\n                        return throwable;\r\n                    }\r\n                    // Don't serialize the cause - we'll serialize it separately later \r\n                    if (obj == throwable.getCause()) {\r\n                        return new CausePlaceholder();\r\n                    }\r\n                    return super.replaceObject(obj);\r\n                }\r\n            };\r\n            try {\r\n                oos.writeObject(throwable);\r\n                oos.close();\r\n                serializedException = outstr.toByteArray();\r\n            } catch (NotSerializableException e) {\r\n                // Ignore\r\n            }\r\n\r\n            type = throwable.getClass().getName();\r\n            message = throwable.getMessage();\r\n            if (throwable.getCause() != null) {\r\n                cause = new ExceptionPlaceholder(throwable.getCause());\r\n            }\r\n            stackTrace = throwable.getStackTrace();\r\n        }","commit_id":"1687bb52caa27eac1acec04ef468f3c0701f10aa","url":"https://github.com/gradle/gradle"},{"original_method":"public Throwable read(ClassLoader classLoader) throws IOException {\r\n            if (serializedException != null) {\r\n                try {\r\n                    return (Throwable) new ClassLoaderObjectInputStream(new ByteArrayInputStream(serializedException),\r\n                            classLoader).readObject();\r\n                } catch (ClassNotFoundException e) {\r\n                    // Ignore\r\n                } catch (InvalidClassException e) {\r\n                    try {\r\n                        Constructor<?> constructor = classLoader.loadClass(type).getConstructor(String.class);\r\n                        Throwable throwable = (Throwable) constructor.newInstance(message);\r\n                        throwable.initCause(getCause(classLoader));\r\n                        throwable.setStackTrace(stackTrace);\r\n                        return throwable;\r\n                    } catch (ClassNotFoundException e1) {\r\n                        // Ignore\r\n                    } catch (NoSuchMethodException e1) {\r\n                        // Ignore\r\n                    } catch (Throwable t) {\r\n                        throw UncheckedException.asUncheckedException(t);\r\n                    }\r\n                }\r\n            }\r\n\r\n            PlaceholderException exception = new PlaceholderException(String.format(\"%s: %s\", type, message), getCause(\r\n                    classLoader));\r\n            exception.setStackTrace(stackTrace);\r\n            return exception;\r\n        }","id":75886,"modified_method":"public Throwable read(ClassLoader classLoader) throws IOException {\r\n            final Throwable causeThrowable = getCause(classLoader);\r\n            Throwable throwable = null;\r\n            if (serializedException != null) {\r\n                try {\r\n                    final ExceptionReplacingObjectInputStream ois = new ExceptionReplacingObjectInputStream(new ByteArrayInputStream(serializedException), classLoader) {\r\n                        @Override\r\n                        protected Object resolveObject(Object obj) throws IOException {\r\n                            if (obj instanceof CausePlaceholder) {\r\n                                return causeThrowable;\r\n                            }\r\n                            return super.resolveObject(obj);\r\n                        }\r\n                    };\r\n                    throwable = (Throwable) ois.readObject();\r\n                } catch (ClassNotFoundException e) {\r\n                    // Ignore\r\n                } catch (InvalidClassException e) {\r\n                    try {\r\n                        Constructor<?> constructor = classLoader.loadClass(type).getConstructor(String.class);\r\n                        throwable = (Throwable) constructor.newInstance(message);\r\n                        throwable.initCause(causeThrowable);\r\n                        throwable.setStackTrace(stackTrace);\r\n                    } catch (ClassNotFoundException e1) {\r\n                        // Ignore\r\n                    } catch (NoSuchMethodException e1) {\r\n                        // Ignore\r\n                    } catch (Throwable t) {\r\n                        throw UncheckedException.asUncheckedException(t);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (throwable == null) {\r\n                throwable = new PlaceholderException(String.format(\"%s: %s\", type, message), causeThrowable);\r\n                throwable.setStackTrace(stackTrace);\r\n            }\r\n\r\n            return throwable;\r\n        }","commit_id":"1687bb52caa27eac1acec04ef468f3c0701f10aa","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Object invoke(MethodInvocation invocation) throws Throwable {\n\t\tClass<?>[] groups = determineValidationGroups(invocation);\n\t\tif (forExecutablesMethod != null) {\n\t\t\tObject executableValidator = ReflectionUtils.invokeMethod(forExecutablesMethod, this.validator);\n\t\t\tSet<ConstraintViolation<?>> result = (Set<ConstraintViolation<?>>)\n\t\t\t\t\tReflectionUtils.invokeMethod(validateParametersMethod, executableValidator,\n\t\t\t\t\t\t\tinvocation.getThis(), invocation.getMethod(), invocation.getArguments(), groups);\n\t\t\tif (!result.isEmpty()) {\n\t\t\t\tthrow new ConstraintViolationException(result);\n\t\t\t}\n\t\t\tObject returnValue = invocation.proceed();\n\t\t\tresult = (Set<ConstraintViolation<?>>)\n\t\t\t\t\tReflectionUtils.invokeMethod(validateReturnValueMethod, executableValidator,\n\t\t\t\t\t\t\tinvocation.getThis(), invocation.getMethod(), returnValue, groups);\n\t\t\tif (!result.isEmpty()) {\n\t\t\t\tthrow new ConstraintViolationException(result);\n\t\t\t}\n\t\t\treturn returnValue;\n\t\t}\n\t\telse {\n\t\t\treturn HibernateValidatorDelegate.invokeWithinValidation(invocation, this.validator, groups);\n\t\t}\n\t}","id":75887,"modified_method":"@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Object invoke(MethodInvocation invocation) throws Throwable {\n\t\tClass<?>[] groups = determineValidationGroups(invocation);\n\n\t\tif (forExecutablesMethod != null) {\n\t\t\t// Standard Bean Validation 1.1 API\n\t\t\tObject execVal = ReflectionUtils.invokeMethod(forExecutablesMethod, this.validator);\n\t\t\tMethod methodToValidate = invocation.getMethod();\n\t\t\tSet<ConstraintViolation<?>> result;\n\n\t\t\ttry {\n\t\t\t\tresult = (Set<ConstraintViolation<?>>) ReflectionUtils.invokeMethod(validateParametersMethod,\n\t\t\t\t\t\texecVal, invocation.getThis(), methodToValidate, invocation.getArguments(), groups);\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t// Probably a generic type mismatch between interface and impl as reported in SPR-12237 / HV-1011\n\t\t\t\t// Let's try to find the bridged method on the implementation class...\n\t\t\t\tmethodToValidate = BridgeMethodResolver.findBridgedMethod(\n\t\t\t\t\t\tClassUtils.getMostSpecificMethod(invocation.getMethod(), invocation.getThis().getClass()));\n\t\t\t\tresult = (Set<ConstraintViolation<?>>) ReflectionUtils.invokeMethod(validateParametersMethod,\n\t\t\t\t\t\texecVal, invocation.getThis(), methodToValidate, invocation.getArguments(), groups);\n\t\t\t}\n\t\t\tif (!result.isEmpty()) {\n\t\t\t\tthrow new ConstraintViolationException(result);\n\t\t\t}\n\n\t\t\tObject returnValue = invocation.proceed();\n\n\t\t\tresult = (Set<ConstraintViolation<?>>) ReflectionUtils.invokeMethod(validateReturnValueMethod,\n\t\t\t\t\texecVal, invocation.getThis(), methodToValidate, returnValue, groups);\n\t\t\tif (!result.isEmpty()) {\n\t\t\t\tthrow new ConstraintViolationException(result);\n\t\t\t}\n\n\t\t\treturn returnValue;\n\t\t}\n\n\t\telse {\n\t\t\t// Hibernate Validator 4.3's native API\n\t\t\treturn HibernateValidatorDelegate.invokeWithinValidation(invocation, this.validator, groups);\n\t\t}\n\t}","commit_id":"7118fcff0de2993d8654a2c72597aaa629e67e9b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private void doTestProxyValidation(MyValidInterface proxy) {\n\t\tassertNotNull(proxy.myValidMethod(\"value\", 5));\n\t\ttry {\n\t\t\tassertNotNull(proxy.myValidMethod(\"value\", 15));\n\t\t\tfail(\"Should have thrown MethodConstraintViolationException\");\n\t\t}\n\t\tcatch (javax.validation.ValidationException ex) {\n\t\t\t// expected\n\t\t}\n\t\ttry {\n\t\t\tassertNotNull(proxy.myValidMethod(null, 5));\n\t\t\tfail(\"Should have thrown MethodConstraintViolationException\");\n\t\t}\n\t\tcatch (javax.validation.ValidationException ex) {\n\t\t\t// expected\n\t\t}\n\t\ttry {\n\t\t\tassertNotNull(proxy.myValidMethod(\"value\", 0));\n\t\t\tfail(\"Should have thrown MethodConstraintViolationException\");\n\t\t}\n\t\tcatch (javax.validation.ValidationException ex) {\n\t\t\t// expected\n\t\t}\n\n\t\tproxy.myValidAsyncMethod(\"value\", 5);\n\t\ttry {\n\t\t\tproxy.myValidAsyncMethod(\"value\", 15);\n\t\t\tfail(\"Should have thrown MethodConstraintViolationException\");\n\t\t}\n\t\tcatch (javax.validation.ValidationException ex) {\n\t\t\t// expected\n\t\t}\n\t\ttry {\n\t\t\tproxy.myValidAsyncMethod(null, 5);\n\t\t\tfail(\"Should have thrown MethodConstraintViolationException\");\n\t\t}\n\t\tcatch (javax.validation.ValidationException ex) {\n\t\t\t// expected\n\t\t}\n\t}","id":75888,"modified_method":"private void doTestProxyValidation(MyValidInterface proxy) {\n\t\tassertNotNull(proxy.myValidMethod(\"value\", 5));\n\t\ttry {\n\t\t\tassertNotNull(proxy.myValidMethod(\"value\", 15));\n\t\t\tfail(\"Should have thrown ValidationException\");\n\t\t}\n\t\tcatch (javax.validation.ValidationException ex) {\n\t\t\t// expected\n\t\t}\n\t\ttry {\n\t\t\tassertNotNull(proxy.myValidMethod(null, 5));\n\t\t\tfail(\"Should have thrown ValidationException\");\n\t\t}\n\t\tcatch (javax.validation.ValidationException ex) {\n\t\t\t// expected\n\t\t}\n\t\ttry {\n\t\t\tassertNotNull(proxy.myValidMethod(\"value\", 0));\n\t\t\tfail(\"Should have thrown ValidationException\");\n\t\t}\n\t\tcatch (javax.validation.ValidationException ex) {\n\t\t\t// expected\n\t\t}\n\n\t\tproxy.myValidAsyncMethod(\"value\", 5);\n\t\ttry {\n\t\t\tproxy.myValidAsyncMethod(\"value\", 15);\n\t\t\tfail(\"Should have thrown ValidationException\");\n\t\t}\n\t\tcatch (javax.validation.ValidationException ex) {\n\t\t\t// expected\n\t\t}\n\t\ttry {\n\t\t\tproxy.myValidAsyncMethod(null, 5);\n\t\t\tfail(\"Should have thrown ValidationException\");\n\t\t}\n\t\tcatch (javax.validation.ValidationException ex) {\n\t\t\t// expected\n\t\t}\n\n\t\tassertEquals(\"myValue\", proxy.myGenericMethod(\"myValue\"));\n\t\ttry {\n\t\t\tproxy.myGenericMethod(null);\n\t\t\tfail(\"Should have thrown ValidationException\");\n\t\t}\n\t\tcatch (javax.validation.ValidationException ex) {\n\t\t\t// expected\n\t\t}\n\t}","commit_id":"7118fcff0de2993d8654a2c72597aaa629e67e9b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void testMethodValidationPostProcessor() {\n\t\tStaticApplicationContext ac = new StaticApplicationContext();\n\t\tac.registerSingleton(\"mvpp\", MethodValidationPostProcessor.class);\n\t\tMutablePropertyValues pvs = new MutablePropertyValues();\n\t\tpvs.add(\"beforeExistingAdvisors\", false);\n\t\tac.registerSingleton(\"aapp\", AsyncAnnotationBeanPostProcessor.class, pvs);\n\t\tac.registerSingleton(\"bean\", MyValidBean.class);\n\t\tac.refresh();\n\t\tdoTestProxyValidation(ac.getBean(\"bean\", MyValidInterface.class));\n\t}","id":75889,"modified_method":"@Test\n\tpublic void testMethodValidationPostProcessor() {\n\t\tStaticApplicationContext ac = new StaticApplicationContext();\n\t\tac.registerSingleton(\"mvpp\", MethodValidationPostProcessor.class);\n\t\tMutablePropertyValues pvs = new MutablePropertyValues();\n\t\tpvs.add(\"beforeExistingAdvisors\", false);\n\t\tac.registerSingleton(\"aapp\", AsyncAnnotationBeanPostProcessor.class, pvs);\n\t\tac.registerSingleton(\"bean\", MyValidBean.class);\n\t\tac.refresh();\n\t\tdoTestProxyValidation(ac.getBean(\"bean\", MyValidInterface.class));\n\t\tac.close();\n\t}","commit_id":"7118fcff0de2993d8654a2c72597aaa629e67e9b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private void doTestProxyValidation(MyValidInterface proxy) {\n\t\tassertNotNull(proxy.myValidMethod(\"value\", 5));\n\t\ttry {\n\t\t\tassertNotNull(proxy.myValidMethod(\"value\", 15));\n\t\t\tfail(\"Should have thrown MethodConstraintViolationException\");\n\t\t}\n\t\tcatch (javax.validation.ValidationException ex) {\n\t\t\t// expected\n\t\t}\n\t\ttry {\n\t\t\tassertNotNull(proxy.myValidMethod(null, 5));\n\t\t\tfail(\"Should have thrown MethodConstraintViolationException\");\n\t\t}\n\t\tcatch (javax.validation.ValidationException ex) {\n\t\t\t// expected\n\t\t}\n\t\ttry {\n\t\t\tassertNotNull(proxy.myValidMethod(\"value\", 0));\n\t\t\tfail(\"Should have thrown MethodConstraintViolationException\");\n\t\t}\n\t\tcatch (javax.validation.ValidationException ex) {\n\t\t\t// expected\n\t\t}\n\n\t\tproxy.myValidAsyncMethod(\"value\", 5);\n\t\ttry {\n\t\t\tproxy.myValidAsyncMethod(\"value\", 15);\n\t\t\tfail(\"Should have thrown MethodConstraintViolationException\");\n\t\t}\n\t\tcatch (javax.validation.ValidationException ex) {\n\t\t\t// expected\n\t\t}\n\t\ttry {\n\t\t\tproxy.myValidAsyncMethod(null, 5);\n\t\t\tfail(\"Should have thrown MethodConstraintViolationException\");\n\t\t}\n\t\tcatch (javax.validation.ValidationException ex) {\n\t\t\t// expected\n\t\t}\n\t}","id":75890,"modified_method":"private void doTestProxyValidation(MyValidInterface proxy) {\n\t\tassertNotNull(proxy.myValidMethod(\"value\", 5));\n\t\ttry {\n\t\t\tassertNotNull(proxy.myValidMethod(\"value\", 15));\n\t\t\tfail(\"Should have thrown ValidationException\");\n\t\t}\n\t\tcatch (javax.validation.ValidationException ex) {\n\t\t\t// expected\n\t\t}\n\t\ttry {\n\t\t\tassertNotNull(proxy.myValidMethod(null, 5));\n\t\t\tfail(\"Should have thrown ValidationException\");\n\t\t}\n\t\tcatch (javax.validation.ValidationException ex) {\n\t\t\t// expected\n\t\t}\n\t\ttry {\n\t\t\tassertNotNull(proxy.myValidMethod(\"value\", 0));\n\t\t\tfail(\"Should have thrown ValidationException\");\n\t\t}\n\t\tcatch (javax.validation.ValidationException ex) {\n\t\t\t// expected\n\t\t}\n\n\t\tproxy.myValidAsyncMethod(\"value\", 5);\n\t\ttry {\n\t\t\tproxy.myValidAsyncMethod(\"value\", 15);\n\t\t\tfail(\"Should have thrown ValidationException\");\n\t\t}\n\t\tcatch (javax.validation.ValidationException ex) {\n\t\t\t// expected\n\t\t}\n\t\ttry {\n\t\t\tproxy.myValidAsyncMethod(null, 5);\n\t\t\tfail(\"Should have thrown ValidationException\");\n\t\t}\n\t\tcatch (javax.validation.ValidationException ex) {\n\t\t\t// expected\n\t\t}\n\n\t\tassertEquals(\"myValue\", proxy.myGenericMethod(\"myValue\"));\n\t\ttry {\n\t\t\tproxy.myGenericMethod(null);\n\t\t\tfail(\"Should have thrown ValidationException\");\n\t\t}\n\t\tcatch (javax.validation.ValidationException ex) {\n\t\t\t// expected\n\t\t}\n\t}","commit_id":"7118fcff0de2993d8654a2c72597aaa629e67e9b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic void accept(\n\t\t\tMethodInvocation methodInvocation,\n\t\t\tAccessControlled accessControlled)\n\t\tthrows SecurityException {\n\n\t\tObject[] arguments = methodInvocation.getArguments();\n\t\tMethod targetMethod = methodInvocation.getMethod();\n\n\t\tboolean remoteAccess = AccessControlThreadLocal.isRemoteAccess();\n\n\t\tif (remoteAccess) {\n\t\t\tfor (AccessControlPolicy policy : _policies) {\n\t\t\t\tpolicy.onServiceRemoteAccess(\n\t\t\t\t\ttargetMethod, arguments, accessControlled);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (AccessControlPolicy policy : _policies) {\n\t\t\t\tpolicy.onServiceAccess(\n\t\t\t\t\ttargetMethod, arguments, accessControlled);\n\t\t\t}\n\t\t}\n\t}","id":75891,"modified_method":"@Override\n\tpublic void accept(\n\t\t\tMethodInvocation methodInvocation,\n\t\t\tAccessControlled accessControlled)\n\t\tthrows SecurityException {\n\n\t\tif (AccessControlThreadLocal.isRemoteAccess()) {\n\t\t\tfor (AccessControlPolicy policy : _policies) {\n\t\t\t\tpolicy.onServiceRemoteAccess(\n\t\t\t\t\tmethodInvocation.getMethod(),\n\t\t\t\t\tmethodInvocation.getArguments(), accessControlled);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (AccessControlPolicy policy : _policies) {\n\t\t\t\tpolicy.onServiceAccess(\n\t\t\t\t\tmethodInvocation.getMethod(),\n\t\t\t\t\tmethodInvocation.getArguments(), accessControlled);\n\t\t\t}\n\t\t}\n\t}","commit_id":"133de76dc19cdf79bb5a7f532353009172344dcc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int namespaceNode(QName qn) {\n\t\tint lastNode = doc.getLastNode();\n\t\tint nodeNr = doc.addNamespace(lastNode, qn);\n\t\treturn nodeNr;\n\t}","id":75892,"modified_method":"public int namespaceNode(QName qn) {\n\t\tint lastNode = doc.getLastNode();\n        QName elemQN = (QName) doc.namePool.get(doc.nodeName[lastNode]);\n        String elemPrefix = elemQN.getPrefix() == null ? \"\" : elemQN.getPrefix();\n        if (elemPrefix.equals(qn.getLocalName()) && elemQN.getNamespaceURI() != null &&\n            !elemQN.getNamespaceURI().equals(qn.getNamespaceURI()))\n            return -1;\n\t\treturn doc.addNamespace(lastNode, qn);\n\t}","commit_id":"1cd9ae0cabb257c72d81e68575ac91414d84aba6","url":"https://github.com/eXist-db/exist"},{"original_method":"@Before\n    @Override\n    public void setUp() throws Exception\n    {\n        super.setUp();\n\n        this.repositoryUtil = new RepositoryUtil(getClass().getSimpleName(), getConfigurationSource());\n        this.repositoryUtil.setup();\n\n        // lookup\n\n        this.taskManager = getComponentManager().lookup(TaskManager.class);\n        this.localExtensionRepository = getComponentManager().lookup(LocalExtensionRepository.class);\n    }","id":75893,"modified_method":"@Before\n    @Override\n    public void setUp() throws Exception\n    {\n        super.setUp();\n\n        this.repositoryUtil =\n            new RepositoryUtil(getClass().getSimpleName(), getConfigurationSource(), getComponentManager());\n        this.repositoryUtil.setup();\n\n        // lookup\n\n        this.taskManager = getComponentManager().lookup(TaskManager.class);\n        this.localExtensionRepository = getComponentManager().lookup(LocalExtensionRepository.class);\n    }","commit_id":"1e888a78c35abfb3deb01ba16c20432271818654","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public boolean addNamespace(String namespace)\n    {\n        return this.namespaces.add(namespace);\n    }","id":75894,"modified_method":"public boolean addNamespace(String namespace)\n    {\n        if (this.namespaces == null) {\n            this.namespaces = new ArrayList<String>();\n        }\n\n        return this.namespaces.add(namespace);\n    }","commit_id":"1e888a78c35abfb3deb01ba16c20432271818654","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Before\n    public void setUp() throws Exception\n    {\n        super.setUp();\n\n        this.repositoryUtil = new RepositoryUtil(getClass().getSimpleName(), getConfigurationSource());\n        this.repositoryUtil.setup();\n\n        this.rubyArtifactId = new ExtensionId(\"org.xwiki.platform:xwiki-core-rendering-macro-ruby\", \"2.4\");\n\n        // lookup\n\n        this.repositoryManager = getComponentManager().lookup(ExtensionRepositoryManager.class);\n\n        this.repositoryManager.addRepository(new ExtensionRepositoryId(\"central\", \"maven\", new URI(\n            \"http://repo1.maven.org/maven2/\")));\n        this.repositoryManager.addRepository(new ExtensionRepositoryId(\"xwiki-releases\", \"maven\", new URI(\n            \"http://maven.xwiki.org/releases/\")));\n\n    }","id":75895,"modified_method":"@Before\n    public void setUp() throws Exception\n    {\n        super.setUp();\n\n        this.repositoryUtil =\n            new RepositoryUtil(getClass().getSimpleName(), getConfigurationSource(), getComponentManager());\n        this.repositoryUtil.setup();\n\n        this.rubyArtifactId = new ExtensionId(\"org.xwiki.platform:xwiki-core-rendering-macro-ruby\", \"2.4\");\n\n        // lookup\n\n        this.repositoryManager = getComponentManager().lookup(ExtensionRepositoryManager.class);\n\n        this.repositoryManager.addRepository(new ExtensionRepositoryId(\"central\", \"maven\", new URI(\n            \"http://repo1.maven.org/maven2/\")));\n        this.repositoryManager.addRepository(new ExtensionRepositoryId(\"xwiki-releases\", \"maven\", new URI(\n            \"http://maven.xwiki.org/releases/\")));\n\n    }","commit_id":"1e888a78c35abfb3deb01ba16c20432271818654","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String getType()\n    {\n        return this.extensionType;\n    }","id":75896,"modified_method":"public String getType()\n    {\n        return this.mavenModel.getPackaging();\n    }","commit_id":"1e888a78c35abfb3deb01ba16c20432271818654","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public AetherExtension(ExtensionId id, ArtifactDescriptorResult artifactDescriptorResult,\n        AetherExtensionRepository repository, PlexusComponentManager mavenComponentManager)\n        throws ComponentLookupException\n    {\n        this.plexusComponentManager = mavenComponentManager;\n\n        this.repository = repository;\n\n        this.id = id;\n        this.artifactDescriptorResult = artifactDescriptorResult;\n        this.extensionType = artifactDescriptorResult.getArtifact().getExtension();\n\n        this.repositorySystem = this.plexusComponentManager.getPlexus().lookup(RepositorySystem.class);\n    }","id":75897,"modified_method":"public AetherExtension(ExtensionId id, Model mavenModel, AetherExtensionRepository repository,\n        PlexusComponentManager mavenComponentManager) throws ComponentLookupException\n    {\n        this.plexusComponentManager = mavenComponentManager;\n\n        this.repository = repository;\n\n        this.id = id;\n        this.mavenModel = mavenModel;\n\n        this.repositorySystem = this.plexusComponentManager.getPlexus().lookup(RepositorySystem.class);\n    }","commit_id":"1e888a78c35abfb3deb01ba16c20432271818654","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String getWebSite()\n    {\n        return null;// return this.project.getUrl();\n    }","id":75898,"modified_method":"public String getWebSite()\n    {\n        return this.mavenModel.getUrl();\n    }","commit_id":"1e888a78c35abfb3deb01ba16c20432271818654","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void download(File file) throws ExtensionException\n    {\n        ArtifactRequest artifactRequest = new ArtifactRequest();\n        artifactRequest.addRepository(this.repository.getRemoteRepository());\n        artifactRequest.setArtifact(this.artifactDescriptorResult.getArtifact());\n\n        ArtifactResult artifactResult;\n        try {\n            artifactResult = this.repositorySystem.resolveArtifact(this.repository.getSession(), artifactRequest);\n        } catch (ArtifactResolutionException e) {\n            throw new ExtensionException(\"Failed to resolve artifact\", e);\n        }\n\n        File aetherFile = artifactResult.getArtifact().getFile();\n\n        try {\n            FileUtils.copyFile(aetherFile, file);\n        } catch (IOException e) {\n            new ExtensionException(\"Failed to copy file\", e);\n        }\n    }","id":75899,"modified_method":"public void download(File file) throws ExtensionException\n    {\n        ArtifactRequest artifactRequest = new ArtifactRequest();\n        artifactRequest.addRepository(this.repository.getRemoteRepository());\n        artifactRequest.setArtifact(new DefaultArtifact(this.mavenModel.getGroupId(), this.mavenModel.getArtifactId(),\n            getType(), this.mavenModel.getVersion()));\n\n        ArtifactResult artifactResult;\n        try {\n            artifactResult = this.repositorySystem.resolveArtifact(this.repository.getSession(), artifactRequest);\n        } catch (ArtifactResolutionException e) {\n            throw new ExtensionException(\"Failed to resolve artifact\", e);\n        }\n\n        File aetherFile = artifactResult.getArtifact().getFile();\n\n        try {\n            FileUtils.copyFile(aetherFile, file);\n        } catch (IOException e) {\n            new ExtensionException(\"Failed to copy file\", e);\n        }\n    }","commit_id":"1e888a78c35abfb3deb01ba16c20432271818654","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public List<ExtensionId> getSuggestedExtensions()\n    {\n        if (this.suggested == null) {\n            this.suggested = new ArrayList<ExtensionId>();\n\n            for (Dependency mavenDependency : this.artifactDescriptorResult.getDependencies()) {\n                if (mavenDependency.isOptional()) {\n                    this.suggested.add(new ExtensionId(mavenDependency.getArtifact().getGroupId() + \":\"\n                        + mavenDependency.getArtifact().getArtifactId(), mavenDependency.getArtifact().getVersion()));\n                }\n            }\n        }\n\n        return this.suggested;\n    }","id":75900,"modified_method":"public List<ExtensionId> getSuggestedExtensions()\n    {\n        if (this.suggested == null) {\n            this.suggested = new ArrayList<ExtensionId>();\n\n            for (Dependency mavenDependency : this.mavenModel.getDependencies()) {\n                if (mavenDependency.isOptional()) {\n                    this.suggested.add(new ExtensionId(mavenDependency.getGroupId() + \":\"\n                        + mavenDependency.getArtifactId(), mavenDependency.getVersion()));\n                }\n            }\n        }\n\n        return this.suggested;\n    }","commit_id":"1e888a78c35abfb3deb01ba16c20432271818654","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public List<ExtensionDependency> getDependencies()\n    {\n        if (this.dependencies == null) {\n            this.dependencies = new ArrayList<ExtensionDependency>();\n\n            for (Dependency aetherDependency : this.artifactDescriptorResult.getDependencies()) {\n                // XXX: not sure what to do about \"provided\"\n                if (!aetherDependency.isOptional()\n                    && (aetherDependency.getScope().equals(\"compile\") || aetherDependency.getScope().equals(\"runtime\"))) {\n                    this.dependencies.add(new AetherExtensionDependency(new ExtensionId(aetherDependency.getArtifact()\n                        .getGroupId() + \":\" + aetherDependency.getArtifact().getArtifactId(), aetherDependency\n                        .getArtifact().getVersion())));\n                }\n            }\n        }\n\n        return this.dependencies;\n    }","id":75901,"modified_method":"public List<ExtensionDependency> getDependencies()\n    {\n        if (this.dependencies == null) {\n            this.dependencies = new ArrayList<ExtensionDependency>();\n\n            for (Dependency mavenDependency : this.mavenModel.getDependencies()) {\n                // XXX: not sure what to do about \"provided\"\n                if (!mavenDependency.isOptional()\n                    && (mavenDependency.getScope().equals(\"compile\") || mavenDependency.getScope().equals(\"runtime\") || mavenDependency\n                        .getScope().equals(\"provided\"))) {\n                    this.dependencies.add(new AetherExtensionDependency(new ExtensionId(mavenDependency.getGroupId()\n                        + \":\" + mavenDependency.getArtifactId(), mavenDependency.getVersion())));\n                }\n            }\n        }\n\n        return this.dependencies;\n    }","commit_id":"1e888a78c35abfb3deb01ba16c20432271818654","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String getDescription()\n    {\n        return null;// return this.project.getDescription();\n    }","id":75902,"modified_method":"public String getDescription()\n    {\n        return this.mavenModel.getDescription();\n    }","commit_id":"1e888a78c35abfb3deb01ba16c20432271818654","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public Extension resolve(ExtensionId extensionId) throws ResolveException\n    {\n        Artifact artifact = new DefaultArtifact(extensionId.getId() + ':' + extensionId.getVersion());\n\n        Artifact pomArtifact = new SubArtifact(artifact, \"\", \"pom\");\n        LocalArtifactRequest localArtifactRequest = new LocalArtifactRequest();\n        localArtifactRequest.setArtifact(pomArtifact);\n        LocalArtifactResult localArtifactResult =\n            this.session.getLocalRepositoryManager().find(this.session, localArtifactRequest);\n        if (localArtifactResult.getFile() != null) {\n            localArtifactResult.getFile().delete();\n        }\n\n        ArtifactDescriptorRequest artifactDescriptorRequest = new ArtifactDescriptorRequest();\n        artifactDescriptorRequest.setArtifact(artifact);\n        artifactDescriptorRequest.addRepository(this.remoteRepository);\n\n        ArtifactDescriptorResult result = resolveArtifact(extensionId);\n\n        if (result.getRepository() instanceof LocalRepository) {\n            result.getArtifact().getFile().delete();\n            result = resolveArtifact(extensionId);\n        }\n\n        List<Exception> extensions = result.getExceptions();\n\n        if (!extensions.isEmpty()) {\n            throw new ResolveException(\"Failed to resolve extension [\" + extensionId + \"]\", extensions.get(0));\n        }\n\n        // TODO: get details from the pom.xml file directly using Maven API (use ModelBuilder and ModelResolver)\n\n        try {\n            return new AetherExtension(extensionId, result, this, this.plexusComponentManager);\n        } catch (ComponentLookupException e) {\n            throw new ResolveException(\"Failed to resolve extension [\" + extensionId + \"]\", e);\n        }\n    }","id":75903,"modified_method":"public Extension resolve(ExtensionId extensionId) throws ResolveException\n    {\n        Model model;\n        try {\n            model = loadPom(this.session, extensionId);\n        } catch (Exception e) {\n            throw new ResolveException(\"Failed to resolve extension [\" + extensionId + \"] descriptor\", e);\n        }\n\n        try {\n            return new AetherExtension(extensionId, model, this, this.plexusComponentManager);\n        } catch (ComponentLookupException e) {\n            throw new ResolveException(\"Failed to resolve extension [\" + extensionId + \"]\", e);\n        }\n    }","commit_id":"1e888a78c35abfb3deb01ba16c20432271818654","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public AetherExtensionRepository(ExtensionRepositoryId repositoryId, RepositorySystemSession session,\n        PlexusComponentManager mavenComponentManager) throws ComponentLookupException\n    {\n        this.repositoryId = repositoryId;\n\n        this.plexusComponentManager = mavenComponentManager;\n\n        this.session = session;\n        this.repositorySystem = this.plexusComponentManager.getPlexus().lookup(RepositorySystem.class);\n\n        this.remoteRepository = new RemoteRepository(repositoryId.getId(), \"default\", repositoryId.getURI().toString());\n    }","id":75904,"modified_method":"public AetherExtensionRepository(ExtensionRepositoryId repositoryId, RepositorySystemSession session,\n        PlexusComponentManager mavenComponentManager) throws Exception\n    {\n        this.repositoryId = repositoryId;\n\n        this.plexusComponentManager = mavenComponentManager;\n\n        this.session = session;\n\n        this.artifactDescriptorReader = this.plexusComponentManager.getPlexus().lookup(ArtifactDescriptorReader.class);\n\n        this.remoteRepository = new RemoteRepository(repositoryId.getId(), \"default\", repositoryId.getURI().toString());\n\n        // FIXME: not very nice\n        this.loadPomMethod =\n            this.artifactDescriptorReader.getClass().getDeclaredMethod(\"loadPom\", RepositorySystemSession.class,\n                ArtifactDescriptorRequest.class, ArtifactDescriptorResult.class);\n        this.loadPomMethod.setAccessible(true);\n    }","commit_id":"1e888a78c35abfb3deb01ba16c20432271818654","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private LocalExtension loadDescriptor(File descriptor) throws ParserConfigurationException, SAXException,\n        IOException\n    {\n        DocumentBuilder documentBuilder = this.documentBuilderFactory.newDocumentBuilder();\n        Document document = documentBuilder.parse(descriptor);\n\n        Element extensionElement = document.getDocumentElement();\n\n        // Mandatory fields\n\n        Node idNode = extensionElement.getElementsByTagName(\"id\").item(0);\n        Node versionNode = extensionElement.getElementsByTagName(\"version\").item(0);\n        Node typeNode = extensionElement.getElementsByTagName(\"type\").item(0);\n\n        DefaultLocalExtension localExtension =\n            new DefaultLocalExtension(this, new ExtensionId(idNode.getTextContent(), versionNode.getTextContent()),\n                typeNode.getTextContent());\n\n        localExtension.setFile(getFile(localExtension.getId(), localExtension.getType()));\n\n        // Optional fields\n\n        Node dependencyNode = getNode(extensionElement, \"dependency\");\n        if (dependencyNode != null) {\n            localExtension.setDependency(Boolean.valueOf(dependencyNode.getTextContent()));\n        }\n        Node enabledNode = getNode(extensionElement, \"installed\");\n        if (enabledNode != null) {\n            localExtension.setInstalled(Boolean.valueOf(enabledNode.getTextContent()));\n        }\n        Node descriptionNode = getNode(extensionElement, \"description\");\n        if (descriptionNode != null) {\n            localExtension.setDescription(descriptionNode.getTextContent());\n        }\n        Node authorNode = getNode(extensionElement, \"author\");\n        if (authorNode != null) {\n            localExtension.setAuthor(authorNode.getTextContent());\n        }\n        Node websiteNode = getNode(extensionElement, \"website\");\n        if (websiteNode != null) {\n            localExtension.setWebsite(websiteNode.getTextContent());\n        }\n\n        // Dependencies\n\n        NodeList dependenciesNodes = extensionElement.getElementsByTagName(\"dependencies\");\n        if (dependenciesNodes.getLength() > 0) {\n            NodeList dependenciesNodeList = dependenciesNodes.item(0).getChildNodes();\n            for (int i = 0; i < dependenciesNodeList.getLength(); ++i) {\n                Node dependency = dependenciesNodeList.item(i);\n\n                if (dependency.getNodeName().equals(\"dependency\")) {\n                    Node dependencyIdNode = getNode(dependency, \"id\");\n                    Node dependencyVersionNode = getNode(dependency, \"version\");\n\n                    localExtension.addDependency(new LocalExtensionDependency(dependencyIdNode.getTextContent(),\n                        dependencyVersionNode.getTextContent()));\n                }\n            }\n        }\n\n        // Namespaces\n        NodeList namespacesNodes = extensionElement.getElementsByTagName(\"namespaces\");\n        if (namespacesNodes.getLength() > 0) {\n            NodeList namespaces = namespacesNodes.item(0).getChildNodes();\n            for (int i = 0; i < namespaces.getLength(); ++i) {\n                Node namespaceNode = namespaces.item(i);\n\n                localExtension.addNamespace(namespaceNode.getTextContent());\n            }\n        }\n\n        return localExtension;\n    }","id":75905,"modified_method":"private LocalExtension loadDescriptor(File descriptor) throws ParserConfigurationException, SAXException,\n        IOException\n    {\n        FileInputStream fis = new FileInputStream(descriptor);\n\n        try {\n            DefaultLocalExtension localExtension = this.extensionSerializer.loadDescriptor(fis);\n\n            localExtension.setFile(getExtensionFile(localExtension.getId(), localExtension.getType()));\n\n            return localExtension;\n        } finally {\n            fis.close();\n        }\n    }","commit_id":"1e888a78c35abfb3deb01ba16c20432271818654","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void saveDescriptor(LocalExtension extension) throws ParserConfigurationException, TransformerException,\n        IOException\n    {\n        DocumentBuilder documentBuilder = this.documentBuilderFactory.newDocumentBuilder();\n        Document document = documentBuilder.newDocument();\n\n        Element extensionElement = document.createElement(\"extension\");\n        document.appendChild(extensionElement);\n\n        addElement(document, extensionElement, \"id\", extension.getId().getId());\n        addElement(document, extensionElement, \"version\", extension.getId().getVersion());\n        addElement(document, extensionElement, \"type\", extension.getType());\n\n        addElement(document, extensionElement, \"dependency\", String.valueOf(extension.isDependency()));\n        addElement(document, extensionElement, \"installed\", String.valueOf(extension.isInstalled()));\n        addElement(document, extensionElement, \"description\", extension.getDescription());\n        addElement(document, extensionElement, \"author\", extension.getAuthor());\n        addElement(document, extensionElement, \"website\", extension.getWebSite());\n\n        addDependencies(document, extensionElement, extension);\n        addNamespaces(document, extensionElement, extension);\n\n        TransformerFactory transfac = TransformerFactory.newInstance();\n        Transformer trans = transfac.newTransformer();\n        trans.setOutputProperty(OutputKeys.INDENT, \"yes\");\n\n        DOMSource source = new DOMSource(document);\n        File file = getDescriptorFile(extension.getId());\n        FileOutputStream fos = new FileOutputStream(file);\n        try {\n            Result result = new StreamResult(fos);\n            trans.transform(source, result);\n        } finally {\n            fos.close();\n        }\n    }","id":75906,"modified_method":"private void saveDescriptor(LocalExtension extension) throws ParserConfigurationException, TransformerException,\n        IOException\n    {\n        File file = getDescriptorFile(extension.getId());\n        FileOutputStream fos = new FileOutputStream(file);\n\n        try {\n            this.extensionSerializer.saveDescriptor(extension, fos);\n        } finally {\n            fos.close();\n        }\n    }","commit_id":"1e888a78c35abfb3deb01ba16c20432271818654","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private LocalExtension createExtension(Extension extension, boolean dependency)\n    {\n        DefaultLocalExtension localExtension = new DefaultLocalExtension(this, extension);\n\n        localExtension.setDependency(dependency);\n\n        localExtension.setFile(getFile(localExtension.getId(), localExtension.getType()));\n\n        return localExtension;\n    }","id":75907,"modified_method":"private LocalExtension createExtension(Extension extension, boolean dependency)\n    {\n        DefaultLocalExtension localExtension = new DefaultLocalExtension(this, extension);\n\n        localExtension.setDependency(dependency);\n\n        localExtension.setFile(getExtensionFile(localExtension.getId(), localExtension.getType()));\n\n        return localExtension;\n    }","commit_id":"1e888a78c35abfb3deb01ba16c20432271818654","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private File getFile(ExtensionId id, String type)\n    {\n        return new File(getRootFolder(), id.getId() + \"-\" + id.getVersion() + \".\" + type);\n    }","id":75908,"modified_method":"private File getExtensionFile(ExtensionId id, String type)\n    {\n        return new File(getRootFolder(), getFileName(id, type));\n    }","commit_id":"1e888a78c35abfb3deb01ba16c20432271818654","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private File getDescriptorFile(ExtensionId id)\n    {\n        return new File(getRootFolder(), id.getId() + \"-\" + id.getVersion() + \".xed\");\n    }","id":75909,"modified_method":"private File getDescriptorFile(ExtensionId id)\n    {\n        return new File(getRootFolder(), getFileName(id, \"xed\"));\n    }","commit_id":"1e888a78c35abfb3deb01ba16c20432271818654","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void initialize() throws InitializationException\n    {\n        this.rootFolder = this.configuration.getLocalRepository();\n\n        this.repositoryId = new ExtensionRepositoryId(\"local\", \"xwiki\", this.rootFolder.toURI());\n\n        loadExtensions();\n    }","id":75910,"modified_method":"public void initialize() throws InitializationException\n    {\n        this.rootFolder = this.configuration.getLocalRepository();\n\n        this.repositoryId = new ExtensionRepositoryId(\"local\", \"xwiki\", this.rootFolder.toURI());\n\n        this.extensionSerializer = new DefaultLocalExtensionSerializer(this);\n\n        loadExtensions();\n    }","commit_id":"1e888a78c35abfb3deb01ba16c20432271818654","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Before\n    public void setUp() throws Exception\n    {\n        super.setUp();\n\n        this.repositoryUtil = new RepositoryUtil(getClass().getSimpleName(), getConfigurationSource());\n        this.repositoryUtil.setup();\n\n        // lookup\n\n        this.localExtensionRepository =\n            (DefaultLocalExtensionRepository) getComponentManager().lookup(LocalExtensionRepository.class);\n    }","id":75911,"modified_method":"@Before\n    public void setUp() throws Exception\n    {\n        super.setUp();\n\n        this.repositoryUtil =\n            new RepositoryUtil(getClass().getSimpleName(), getConfigurationSource(), getComponentManager());\n        this.repositoryUtil.setup();\n\n        // lookup\n\n        this.localExtensionRepository =\n            (DefaultLocalExtensionRepository) getComponentManager().lookup(LocalExtensionRepository.class);\n    }","commit_id":"1e888a78c35abfb3deb01ba16c20432271818654","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public Task uninstall(String id, String wiki)\n    {\n        if (!this.documentAccessBridge.hasProgrammingRights()) {\n            return null;\n        }\n\n        setError(null);\n\n        UninstallRequest uninstallRequest = new UninstallRequest();\n        uninstallRequest.addExtension(new ExtensionId(id, null));\n        uninstallRequest.addNamespace(wiki);\n\n        Task task;\n        try {\n            task = this.taskManager.uninstall(uninstallRequest);\n        } catch (TaskException e) {\n            setError(e);\n\n            task = null;\n        }\n\n        return task;\n    }","id":75912,"modified_method":"public Task uninstall(String id, String wiki)\n    {\n        if (!this.documentAccessBridge.hasProgrammingRights()) {\n            return null;\n        }\n\n        setError(null);\n\n        UninstallRequest uninstallRequest = new UninstallRequest();\n        uninstallRequest.addExtension(new ExtensionId(id, null));\n        if (wiki != null) {\n            uninstallRequest.addNamespace(wiki);\n        }\n\n        Task task;\n        try {\n            task = this.taskManager.uninstall(uninstallRequest);\n        } catch (TaskException e) {\n            setError(e);\n\n            task = null;\n        }\n\n        return task;\n    }","commit_id":"1e888a78c35abfb3deb01ba16c20432271818654","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public Task install(String id, String version, String wiki)\n    {\n        if (!this.documentAccessBridge.hasProgrammingRights()) {\n            return null;\n        }\n\n        setError(null);\n\n        InstallRequest installRequest = new InstallRequest();\n        installRequest.addExtension(new ExtensionId(id, null));\n        installRequest.addNamespace(wiki);\n\n        Task task;\n        try {\n            task = this.taskManager.install(installRequest);\n        } catch (TaskException e) {\n            setError(e);\n\n            task = null;\n        }\n\n        return task;\n    }","id":75913,"modified_method":"public Task install(String id, String version, String wiki)\n    {\n        if (!this.documentAccessBridge.hasProgrammingRights()) {\n            return null;\n        }\n\n        setError(null);\n\n        InstallRequest installRequest = new InstallRequest();\n        installRequest.addExtension(new ExtensionId(id, version));\n        if (wiki != null) {\n            installRequest.addNamespace(wiki);\n        }\n\n        Task task;\n        try {\n            task = this.taskManager.install(installRequest);\n        } catch (TaskException e) {\n            setError(e);\n\n            task = null;\n        }\n\n        return task;\n    }","commit_id":"1e888a78c35abfb3deb01ba16c20432271818654","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void testInstallAndUninstallExtension() throws Exception\n    {\n        // way too big for a unit test so lets skip it\n        this.coreExtensionRepository.addExtensions(\"org.jruby:jruby\", \"1.5\");\n        // the following extension should be found in the classpath but maven seems to have some bug around it (it's\n        // working well inside Eclipse)\n        // this.coreExtensionRepository.addExtensions(\"org.xwiki.platform:xwiki-core-classloader\",\n        // this.rubyArtifactId.getVersion());\n        // this.coreExtensionRepository.addExtensions(\"org.xwiki.platform:xwiki-core-rendering-api\",\n        // this.rubyArtifactId.getVersion());\n\n        // emulate environment\n        registerMockComponent(DocumentAccessBridge.class);\n        registerMockComponent(AttachmentReferenceResolver.class, \"current\");\n\n        // actual test\n        LocalExtension localExtension = install(this.rubyArtifactId);\n\n        Assert.assertNotNull(localExtension);\n        Assert.assertNotNull(localExtension.getFile());\n        Assert.assertTrue(localExtension.getFile().exists());\n\n        Macro< ? > rubyMacro = getComponentManager().lookup(Macro.class, \"ruby\");\n\n        Assert.assertNotNull(rubyMacro);\n\n        try {\n            install(this.rubyArtifactId);\n            Assert.fail(\"installExtension should have failed\");\n        } catch (InstallException expected) {\n            // expected\n        }\n\n        uninstall(this.rubyArtifactId);\n\n        Assert.assertNull(this.localExtensionRepository.getInstalledExtension(this.rubyArtifactId.getId(), null));\n\n        try {\n            getComponentManager().lookup(Macro.class, \"ruby\");\n            Assert.fail(\"the extension has not been uninstalled\");\n        } catch (ComponentLookupException expected) {\n            // expected\n        }\n    }","id":75914,"modified_method":"@Test\n    public void testInstallAndUninstallExtension() throws Exception\n    {\n        // actual test\n        LocalExtension localExtension = install(this.testArtifactId);\n\n        Assert.assertNotNull(localExtension);\n        Assert.assertNotNull(localExtension.getFile());\n        Assert.assertTrue(localExtension.getFile().exists());\n\n        getComponentManager().lookup(TestComponent.class);\n\n        try {\n            install(this.testArtifactId);\n            Assert.fail(\"installExtension should have failed\");\n        } catch (InstallException expected) {\n            // expected\n        }\n\n        uninstall(this.testArtifactId);\n\n        Assert.assertNull(this.localExtensionRepository.getInstalledExtension(this.testArtifactId.getId(), null));\n\n        try {\n            getComponentManager().lookup(TestComponent.class);\n            Assert.fail(\"the extension has not been uninstalled\");\n        } catch (ComponentLookupException expected) {\n            // expected\n        }\n    }","commit_id":"1e888a78c35abfb3deb01ba16c20432271818654","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Before\n    @Override\n    public void setUp() throws Exception\n    {\n        super.setUp();\n\n        // lookup\n\n        this.repositoryManager = getComponentManager().lookup(ExtensionRepositoryManager.class);\n\n        this.repositoryManager.addRepository(new ExtensionRepositoryId(\"xwiki-releases\", \"maven\", new URI(\n            \"http://maven.xwiki.org/releases/\")));\n        this.repositoryManager.addRepository(new ExtensionRepositoryId(\"central\", \"maven\", new URI(\n            \"http://repo1.maven.org/maven2/\")));\n\n        this.coreExtensionRepository =\n            (ConfigurableDefaultCoreExtensionRepository) getComponentManager().lookup(CoreExtensionRepository.class);\n        this.localExtensionRepository = getComponentManager().lookup(LocalExtensionRepository.class);\n\n        this.rubyArtifactId = new ExtensionId(\"org.xwiki.platform:xwiki-core-rendering-macro-ruby\", \"2.7\");\n    }","id":75915,"modified_method":"@Before\n    @Override\n    public void setUp() throws Exception\n    {\n        super.setUp();\n\n        // lookup\n\n        this.localExtensionRepository = getComponentManager().lookup(LocalExtensionRepository.class);\n\n        this.testArtifactId = new ExtensionId(\"org.xwiki.test:test-extension\", \"test\");\n    }","commit_id":"1e888a78c35abfb3deb01ba16c20432271818654","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public RepositoryUtil(String name, MockConfigurationSource configurationSource)\n    {\n        this.name = name;\n        this.configurationSource = configurationSource;\n\n        this.workingDirectory = new File(\"target/\" + this.name + \"/\");\n        this.repositoriesDirectory = new File(this.workingDirectory, \"repository/\");\n        this.localRepository = new File(this.repositoriesDirectory, \"local/\");\n        this.aetherRepository = new File(this.repositoriesDirectory, \"aether/\");\n    }","id":75916,"modified_method":"public RepositoryUtil(String name, MockConfigurationSource configurationSource, ComponentManager componentManager)\n    {\n        this.name = name;\n        this.configurationSource = configurationSource;\n        this.componentManager = componentManager;\n\n        this.workingDirectory = new File(\"target/\" + this.name + \"/\");\n        this.repositoriesDirectory = new File(this.workingDirectory, \"repository/\");\n        this.localRepository = new File(this.repositoriesDirectory, \"local/\");\n        this.aetherRepository = new File(this.repositoriesDirectory, \"aether/\");\n    }","commit_id":"1e888a78c35abfb3deb01ba16c20432271818654","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void setup() throws IOException\n    {\n        clean();\n\n        // copy\n\n        File localRepository = getLocalRepository();\n\n        copyResourceFolder(localRepository, \"repository.local\");\n\n        // configuration\n\n        this.configurationSource.setProperty(\"extension.localRepository\", getLocalRepository().getAbsolutePath());\n        this.configurationSource.setProperty(\"extension.aether.localRepository\", getAetherRepository()\n            .getAbsolutePath());\n    }","id":75917,"modified_method":"public void setup() throws IOException, ComponentLookupException\n    {\n        clean();\n\n        // copy\n\n        File localRepository = getLocalRepository();\n\n        copyResourceFolder(localRepository, \"repository.local\");\n\n        // configuration\n\n        this.configurationSource.setProperty(\"extension.localRepository\", getLocalRepository().getAbsolutePath());\n        this.configurationSource.setProperty(\"extension.aether.localRepository\", getAetherRepository()\n            .getAbsolutePath());\n\n        // repositories\n\n        ExtensionRepositoryManager repositoryManager = this.componentManager.lookup(ExtensionRepositoryManager.class);\n\n        ResourceExtensionRepository resourceExtensionrepository =\n            new ResourceExtensionRepository(getClass().getClassLoader(), \"repository/remote/\");\n        repositoryManager.addRepository(resourceExtensionrepository);\n    }","commit_id":"1e888a78c35abfb3deb01ba16c20432271818654","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Before\n    public void setUp() throws Exception\n    {\n        super.setUp();\n\n        this.repositoryUtil = new RepositoryUtil(getClass().getSimpleName(), getConfigurationSource());\n        this.repositoryUtil.setup();\n\n        // mock\n\n        this.mockXWiki = getMockery().mock(XWiki.class);\n        getContext().setWiki(this.mockXWiki);\n        getContext().setDatabase(\"xwiki\");\n\n        this.localXarExtensiontId = new ExtensionId(\"test\", \"1.0\");\n        this.localXarExtension = new DefaultLocalExtension(null, this.localXarExtensiontId, \"xar\");\n        this.localXarExtension.setFile(new File(this.repositoryUtil.getLocalRepository(), \"test-1.0.xar\"));\n\n        this.localXarExtensiontId2 = new ExtensionId(\"test\", \"2.0\");\n        this.localXarExtension2 = new DefaultLocalExtension(null, this.localXarExtensiontId2, \"xar\");\n        this.localXarExtension2.setFile(new File(this.repositoryUtil.getLocalRepository(), \"test-2.0.xar\"));\n\n        // checking\n\n        getMockery().checking(new Expectations()\n        {\n            {\n                allowing(mockXWiki).getDocument(with(any(DocumentReference.class)), with(any(XWikiContext.class)));\n                will(new CustomAction(\"getDocument\")\n                {\n                    public Object invoke(org.jmock.api.Invocation invocation) throws Throwable\n                    {\n                        Map<String, XWikiDocument> documentLanguages = documents.get(invocation.getParameter(0));\n\n                        if (documentLanguages == null) {\n                            documentLanguages = new HashMap<String, XWikiDocument>();\n                            documents.put((DocumentReference) invocation.getParameter(0), documentLanguages);\n                        }\n\n                        XWikiDocument document = documentLanguages.get(\"en\");\n\n                        if (document == null) {\n                            document = new XWikiDocument((DocumentReference) invocation.getParameter(0));\n                        }\n\n                        return document;\n                    }\n                });\n\n                allowing(mockXWiki).saveDocument(with(any(XWikiDocument.class)), with(any(String.class)),\n                    with(any(XWikiContext.class)));\n                will(new CustomAction(\"saveDocument\")\n                {\n                    public Object invoke(org.jmock.api.Invocation invocation) throws Throwable\n                    {\n                        XWikiDocument document = (XWikiDocument) invocation.getParameter(0);\n\n                        document.incrementVersion();\n                        document.setNew(false);\n\n                        Map<String, XWikiDocument> documentLanguages = documents.get(document.getDocumentReference());\n\n                        if (documentLanguages == null) {\n                            documentLanguages = new HashMap<String, XWikiDocument>();\n                            documents.put(document.getDocumentReference(), documentLanguages);\n                        }\n\n                        documentLanguages.put(document.getRealLanguage(), document);\n\n                        return null;\n                    }\n                });\n\n                allowing(mockXWiki).deleteDocument(with(any(XWikiDocument.class)), with(any(XWikiContext.class)));\n                will(new CustomAction(\"deleteDocument\")\n                {\n                    public Object invoke(org.jmock.api.Invocation invocation) throws Throwable\n                    {\n                        XWikiDocument document = (XWikiDocument) invocation.getParameter(0);\n\n                        Map<String, XWikiDocument> documentLanguages = documents.get(document.getDocumentReference());\n\n                        if (documentLanguages != null) {\n                            documentLanguages.remove(document.getRealLanguage());\n                        }\n\n                        return null;\n                    }\n                });\n            }\n        });\n\n        // lookup\n\n        this.handler = (XarExtensionHandler) getComponentManager().lookup(ExtensionHandler.class, \"xar\");\n        this.observationManager = (ObservationManager) getComponentManager().lookup(ObservationManager.class);\n    }","id":75918,"modified_method":"@Before\n    public void setUp() throws Exception\n    {\n        super.setUp();\n\n        this.repositoryUtil =\n            new RepositoryUtil(getClass().getSimpleName(), getConfigurationSource(), getComponentManager());\n        this.repositoryUtil.setup();\n\n        // mock\n\n        this.mockXWiki = getMockery().mock(XWiki.class);\n        getContext().setWiki(this.mockXWiki);\n        getContext().setDatabase(\"xwiki\");\n\n        this.localXarExtensiontId = new ExtensionId(\"test\", \"1.0\");\n        this.localXarExtension = new DefaultLocalExtension(null, this.localXarExtensiontId, \"xar\");\n        this.localXarExtension.setFile(new File(this.repositoryUtil.getLocalRepository(), \"test-1.0.xar\"));\n\n        this.localXarExtensiontId2 = new ExtensionId(\"test\", \"2.0\");\n        this.localXarExtension2 = new DefaultLocalExtension(null, this.localXarExtensiontId2, \"xar\");\n        this.localXarExtension2.setFile(new File(this.repositoryUtil.getLocalRepository(), \"test-2.0.xar\"));\n\n        // checking\n\n        getMockery().checking(new Expectations()\n        {\n            {\n                allowing(mockXWiki).getDocument(with(any(DocumentReference.class)), with(any(XWikiContext.class)));\n                will(new CustomAction(\"getDocument\")\n                {\n                    public Object invoke(org.jmock.api.Invocation invocation) throws Throwable\n                    {\n                        Map<String, XWikiDocument> documentLanguages = documents.get(invocation.getParameter(0));\n\n                        if (documentLanguages == null) {\n                            documentLanguages = new HashMap<String, XWikiDocument>();\n                            documents.put((DocumentReference) invocation.getParameter(0), documentLanguages);\n                        }\n\n                        XWikiDocument document = documentLanguages.get(\"en\");\n\n                        if (document == null) {\n                            document = new XWikiDocument((DocumentReference) invocation.getParameter(0));\n                        }\n\n                        return document;\n                    }\n                });\n\n                allowing(mockXWiki).saveDocument(with(any(XWikiDocument.class)), with(any(String.class)),\n                    with(any(XWikiContext.class)));\n                will(new CustomAction(\"saveDocument\")\n                {\n                    public Object invoke(org.jmock.api.Invocation invocation) throws Throwable\n                    {\n                        XWikiDocument document = (XWikiDocument) invocation.getParameter(0);\n\n                        document.incrementVersion();\n                        document.setNew(false);\n\n                        Map<String, XWikiDocument> documentLanguages = documents.get(document.getDocumentReference());\n\n                        if (documentLanguages == null) {\n                            documentLanguages = new HashMap<String, XWikiDocument>();\n                            documents.put(document.getDocumentReference(), documentLanguages);\n                        }\n\n                        documentLanguages.put(document.getRealLanguage(), document);\n\n                        return null;\n                    }\n                });\n\n                allowing(mockXWiki).deleteDocument(with(any(XWikiDocument.class)), with(any(XWikiContext.class)));\n                will(new CustomAction(\"deleteDocument\")\n                {\n                    public Object invoke(org.jmock.api.Invocation invocation) throws Throwable\n                    {\n                        XWikiDocument document = (XWikiDocument) invocation.getParameter(0);\n\n                        Map<String, XWikiDocument> documentLanguages = documents.get(document.getDocumentReference());\n\n                        if (documentLanguages != null) {\n                            documentLanguages.remove(document.getRealLanguage());\n                        }\n\n                        return null;\n                    }\n                });\n            }\n        });\n\n        // lookup\n\n        this.handler = (XarExtensionHandler) getComponentManager().lookup(ExtensionHandler.class, \"xar\");\n        this.observationManager = (ObservationManager) getComponentManager().lookup(ObservationManager.class);\n    }","commit_id":"1e888a78c35abfb3deb01ba16c20432271818654","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public int namespaceNode(QName qn) {\n\t\tint lastNode = doc.getLastNode();\n\t\tint nodeNr = doc.addNamespace(lastNode, qn);\n\t\treturn nodeNr;\n\t}","id":75919,"modified_method":"public int namespaceNode(QName qn) {\n\t\tint lastNode = doc.getLastNode();\n        QName elemQN = (QName) doc.namePool.get(doc.nodeName[lastNode]);\n        String elemPrefix = elemQN.getPrefix() == null ? \"\" : elemQN.getPrefix();\n        if (elemPrefix.equals(qn.getLocalName()) && elemQN.getNamespaceURI() != null &&\n            !elemQN.getNamespaceURI().equals(qn.getNamespaceURI()))\n            return -1;\n\t\treturn doc.addNamespace(lastNode, qn);\n\t}","commit_id":"a85a81ad21c3e3ebe46066d936fd101a23c9a39e","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n   * List of all {@link org.sonar.server.computation.step.ComputationStep},\n   * ordered by execution sequence.\n   */\n  public List<Class<? extends ComputationStep>> orderedStepClasses() {\n    return Arrays.asList(\n      // Builds Component tree\n      BuildComponentTreeStep.class,\n\n      PopulateComponentsUuidAndKeyStep.class,\n      ValidateProjectStep.class,\n\n      // Read report\n      ParseReportStep.class,\n\n      // data computation\n      QualityProfileEventsStep.class,\n\n      // Persist data\n      PersistComponentsStep.class,\n      PersistNumberOfDaysSinceLastCommitStep.class,\n      PersistMeasuresStep.class,\n      PersistIssuesStep.class,\n      PersistProjectLinksStep.class,\n      PersistEventsStep.class,\n      PersistDuplicationsStep.class,\n      PersistFileSourcesStep.class,\n      PersistTestsStep.class,\n\n      // Switch snapshot and purge\n      SwitchSnapshotStep.class,\n      IndexComponentsStep.class,\n      PurgeDatastoresStep.class,\n\n      // ES indexing is done after all db changes\n      ApplyPermissionsStep.class,\n      IndexIssuesStep.class,\n      IndexSourceLinesStep.class,\n      IndexTestsStep.class,\n\n      // notifications are sent at the end, so that webapp displays up-to-date information\n      SendIssueNotificationsStep.class);\n  }","id":75920,"modified_method":"/**\n   * List of all {@link org.sonar.server.computation.step.ComputationStep},\n   * ordered by execution sequence.\n   */\n  public List<Class<? extends ComputationStep>> orderedStepClasses() {\n    return Arrays.asList(\n      // extract report to a temp directory\n      ReportExtractionStep.class,\n\n      // Builds Component tree\n      BuildComponentTreeStep.class,\n\n      PopulateComponentsUuidAndKeyStep.class,\n      ValidateProjectStep.class,\n\n      // Read report\n      ParseReportStep.class,\n\n      // data computation\n      QualityProfileEventsStep.class,\n\n      // Persist data\n      PersistComponentsStep.class,\n      PersistNumberOfDaysSinceLastCommitStep.class,\n      PersistMeasuresStep.class,\n      PersistIssuesStep.class,\n      PersistProjectLinksStep.class,\n      PersistEventsStep.class,\n      PersistDuplicationsStep.class,\n      PersistFileSourcesStep.class,\n      PersistTestsStep.class,\n\n      // Switch snapshot and purge\n      SwitchSnapshotStep.class,\n      IndexComponentsStep.class,\n      PurgeDatastoresStep.class,\n\n      // ES indexing is done after all db changes\n      ApplyPermissionsStep.class,\n      IndexIssuesStep.class,\n      IndexSourceLinesStep.class,\n      IndexTestsStep.class,\n\n      // notifications are sent at the end, so that webapp displays up-to-date information\n      SendIssueNotificationsStep.class);\n  }","commit_id":"1321df4c9bb0af4d43d697cac5c930e7e2711226","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * List of all objects to be injected in the picocontainer dedicated to computation stack.\n   * Does not contain the steps declared in {@link org.sonar.server.computation.step.ComputationSteps#orderedStepClasses()}.\n   */\n  private static List componentClasses() {\n    return Arrays.asList(\n      ActivityManager.class,\n      ReportExtractor.class,\n      BatchReportReaderImpl.class,\n\n      TreeRootHolderImpl.class,\n\n      // repositories\n      PlatformLanguageRepository.class,\n      MeasureRepositoryImpl.class,\n      EventRepositoryImpl.class,\n      ProjectSettingsRepository.class,\n\n      // component caches\n      DbComponentsRefCache.class,\n\n      // issues\n      ScmAccountCacheLoader.class,\n      ScmAccountCache.class,\n      SourceLinesCache.class,\n      IssueComputation.class,\n      RuleCache.class,\n      RuleCacheLoader.class,\n      IssueCache.class,\n      MetricCache.class,\n      UpdateConflictResolver.class,\n\n      // views\n      ViewIndex.class,\n\n      // ComputationService\n      ComputationService.class\n      );\n  }","id":75921,"modified_method":"/**\n   * List of all objects to be injected in the picocontainer dedicated to computation stack.\n   * Does not contain the steps declared in {@link org.sonar.server.computation.step.ComputationSteps#orderedStepClasses()}.\n   */\n  private static List componentClasses() {\n    return Arrays.asList(\n      ActivityManager.class,\n\n      TreeRootHolderImpl.class,\n\n      BatchReportReaderImpl.class,\n\n      BatchReportDirectoryHolderImpl.class,\n\n      // repositories\n      PlatformLanguageRepository.class,\n      MeasureRepositoryImpl.class,\n      EventRepositoryImpl.class,\n      ProjectSettingsRepository.class,\n\n      // component caches\n      DbComponentsRefCache.class,\n\n      // issues\n      ScmAccountCacheLoader.class,\n      ScmAccountCache.class,\n      SourceLinesCache.class,\n      IssueComputation.class,\n      RuleCache.class,\n      RuleCacheLoader.class,\n      IssueCache.class,\n      MetricCache.class,\n      UpdateConflictResolver.class,\n\n      // views\n      ViewIndex.class,\n\n      // ComputationService\n      ComputationService.class\n      );\n  }","commit_id":"1321df4c9bb0af4d43d697cac5c930e7e2711226","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void compute_keys_and_uuids_on_project_having_module_and_directory() throws Exception {\n    reportReader.setMetadata(BatchReport.Metadata.newBuilder()\n      .setRootComponentRef(1)\n      .build());\n\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(PROJECT_KEY)\n      .addChildRef(2)\n      .addChildRef(5)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(2)\n      .setType(Constants.ComponentType.MODULE)\n      .setKey(\"MODULE_KEY\")\n      .addChildRef(3)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(3)\n      .setType(Constants.ComponentType.DIRECTORY)\n      .setPath(\"src/main/java/dir\")\n      .addChildRef(4)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(4)\n      .setType(Constants.ComponentType.FILE)\n      .setPath(\"src/main/java/dir/Foo.java\")\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(5)\n      .setType(Constants.ComponentType.DIRECTORY)\n      .setPath(\"/\")\n      .addChildRef(6)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(6)\n      .setType(Constants.ComponentType.FILE)\n      .setPath(\"pom.xml\")\n      .build());\n\n    treeRootHolder.setRoot(ComponentTreeBuilders.from(reportReader).build());\n    sut.execute();\n\n    Map<Integer, Component> componentsByRef = getComponentsByRef(treeRootHolder.getRoot());\n\n    assertThat(componentsByRef.get(1).getKey()).isEqualTo(PROJECT_KEY);\n    assertThat(componentsByRef.get(1).getUuid()).isNotNull();\n\n    assertThat(componentsByRef.get(2).getKey()).isEqualTo(\"MODULE_KEY\");\n    assertThat(componentsByRef.get(2).getUuid()).isNotNull();\n\n    assertThat(componentsByRef.get(3).getKey()).isEqualTo(\"MODULE_KEY:src/main/java/dir\");\n    assertThat(componentsByRef.get(3).getUuid()).isNotNull();\n\n    assertThat(componentsByRef.get(4).getKey()).isEqualTo(\"MODULE_KEY:src/main/java/dir/Foo.java\");\n    assertThat(componentsByRef.get(4).getUuid()).isNotNull();\n\n    assertThat(componentsByRef.get(5).getKey()).isEqualTo(PROJECT_KEY + \":/\");\n    assertThat(componentsByRef.get(5).getUuid()).isNotNull();\n\n    assertThat(componentsByRef.get(6).getKey()).isEqualTo(PROJECT_KEY + \":pom.xml\");\n    assertThat(componentsByRef.get(6).getUuid()).isNotNull();\n  }","id":75922,"modified_method":"@Test\n  public void compute_keys_and_uuids_on_project_having_module_and_directory() throws Exception {\n    reportReader.setMetadata(BatchReport.Metadata.newBuilder()\n      .setRootComponentRef(1)\n      .build());\n\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(PROJECT_KEY)\n      .addChildRef(2)\n      .addChildRef(5)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(2)\n      .setType(Constants.ComponentType.MODULE)\n      .setKey(\"MODULE_KEY\")\n      .addChildRef(3)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(3)\n      .setType(Constants.ComponentType.DIRECTORY)\n      .setPath(\"src/main/java/dir\")\n      .addChildRef(4)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(4)\n      .setType(Constants.ComponentType.FILE)\n      .setPath(\"src/main/java/dir/Foo.java\")\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(5)\n      .setType(Constants.ComponentType.DIRECTORY)\n      .setPath(\"/\")\n      .addChildRef(6)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(6)\n      .setType(Constants.ComponentType.FILE)\n      .setPath(\"pom.xml\")\n      .build());\n\n    treeRootHolder.setRoot(ComponentTreeBuilder.from(reportReader));\n    sut.execute();\n\n    Map<Integer, Component> componentsByRef = getComponentsByRef(treeRootHolder.getRoot());\n\n    assertThat(componentsByRef.get(1).getKey()).isEqualTo(PROJECT_KEY);\n    assertThat(componentsByRef.get(1).getUuid()).isNotNull();\n\n    assertThat(componentsByRef.get(2).getKey()).isEqualTo(\"MODULE_KEY\");\n    assertThat(componentsByRef.get(2).getUuid()).isNotNull();\n\n    assertThat(componentsByRef.get(3).getKey()).isEqualTo(\"MODULE_KEY:src/main/java/dir\");\n    assertThat(componentsByRef.get(3).getUuid()).isNotNull();\n\n    assertThat(componentsByRef.get(4).getKey()).isEqualTo(\"MODULE_KEY:src/main/java/dir/Foo.java\");\n    assertThat(componentsByRef.get(4).getUuid()).isNotNull();\n\n    assertThat(componentsByRef.get(5).getKey()).isEqualTo(PROJECT_KEY + \":/\");\n    assertThat(componentsByRef.get(5).getUuid()).isNotNull();\n\n    assertThat(componentsByRef.get(6).getKey()).isEqualTo(PROJECT_KEY + \":pom.xml\");\n    assertThat(componentsByRef.get(6).getUuid()).isNotNull();\n  }","commit_id":"1321df4c9bb0af4d43d697cac5c930e7e2711226","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void compute_keys_and_uuids_on_multi_modules() throws Exception {\n    reportReader.setMetadata(BatchReport.Metadata.newBuilder()\n      .setRootComponentRef(1)\n      .build());\n\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(PROJECT_KEY)\n      .addChildRef(2)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(2)\n      .setType(Constants.ComponentType.MODULE)\n      .setKey(\"MODULE_KEY\")\n      .addChildRef(3)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(3)\n      .setType(Constants.ComponentType.MODULE)\n      .setKey(\"SUB_MODULE_KEY\")\n      .addChildRef(4)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(4)\n      .setType(Constants.ComponentType.DIRECTORY)\n      .setPath(\"src/main/java/dir\")\n      .addChildRef(5)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(5)\n      .setType(Constants.ComponentType.FILE)\n      .setPath(\"src/main/java/dir/Foo.java\")\n      .build());\n\n    treeRootHolder.setRoot(ComponentTreeBuilders.from(reportReader).build());\n    sut.execute();\n\n    Map<Integer, Component> componentsByRef = getComponentsByRef(treeRootHolder.getRoot());\n\n    assertThat(componentsByRef.get(1).getKey()).isEqualTo(PROJECT_KEY);\n    assertThat(componentsByRef.get(1).getUuid()).isNotNull();\n\n    assertThat(componentsByRef.get(2).getKey()).isEqualTo(\"MODULE_KEY\");\n    assertThat(componentsByRef.get(2).getUuid()).isNotNull();\n\n    assertThat(componentsByRef.get(3).getKey()).isEqualTo(\"SUB_MODULE_KEY\");\n    assertThat(componentsByRef.get(3).getUuid()).isNotNull();\n\n    assertThat(componentsByRef.get(4).getKey()).isEqualTo(\"SUB_MODULE_KEY:src/main/java/dir\");\n    assertThat(componentsByRef.get(4).getUuid()).isNotNull();\n\n    assertThat(componentsByRef.get(5).getKey()).isEqualTo(\"SUB_MODULE_KEY:src/main/java/dir/Foo.java\");\n    assertThat(componentsByRef.get(5).getUuid()).isNotNull();\n  }","id":75923,"modified_method":"@Test\n  public void compute_keys_and_uuids_on_multi_modules() throws Exception {\n    reportReader.setMetadata(BatchReport.Metadata.newBuilder()\n      .setRootComponentRef(1)\n      .build());\n\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(PROJECT_KEY)\n      .addChildRef(2)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(2)\n      .setType(Constants.ComponentType.MODULE)\n      .setKey(\"MODULE_KEY\")\n      .addChildRef(3)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(3)\n      .setType(Constants.ComponentType.MODULE)\n      .setKey(\"SUB_MODULE_KEY\")\n      .addChildRef(4)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(4)\n      .setType(Constants.ComponentType.DIRECTORY)\n      .setPath(\"src/main/java/dir\")\n      .addChildRef(5)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(5)\n      .setType(Constants.ComponentType.FILE)\n      .setPath(\"src/main/java/dir/Foo.java\")\n      .build());\n\n    treeRootHolder.setRoot(ComponentTreeBuilder.from(reportReader));\n    sut.execute();\n\n    Map<Integer, Component> componentsByRef = getComponentsByRef(treeRootHolder.getRoot());\n\n    assertThat(componentsByRef.get(1).getKey()).isEqualTo(PROJECT_KEY);\n    assertThat(componentsByRef.get(1).getUuid()).isNotNull();\n\n    assertThat(componentsByRef.get(2).getKey()).isEqualTo(\"MODULE_KEY\");\n    assertThat(componentsByRef.get(2).getUuid()).isNotNull();\n\n    assertThat(componentsByRef.get(3).getKey()).isEqualTo(\"SUB_MODULE_KEY\");\n    assertThat(componentsByRef.get(3).getUuid()).isNotNull();\n\n    assertThat(componentsByRef.get(4).getKey()).isEqualTo(\"SUB_MODULE_KEY:src/main/java/dir\");\n    assertThat(componentsByRef.get(4).getUuid()).isNotNull();\n\n    assertThat(componentsByRef.get(5).getKey()).isEqualTo(\"SUB_MODULE_KEY:src/main/java/dir/Foo.java\");\n    assertThat(componentsByRef.get(5).getUuid()).isNotNull();\n  }","commit_id":"1321df4c9bb0af4d43d697cac5c930e7e2711226","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void return_existing_uuids() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto(\"ABCD\").setKey(PROJECT_KEY);\n    dbClient.componentDao().insert(session, project);\n    ComponentDto module = ComponentTesting.newModuleDto(\"BCDE\", project).setKey(\"MODULE_KEY\");\n    dbClient.componentDao().insert(session, module);\n    ComponentDto directory = ComponentTesting.newDirectory(module, \"CDEF\", \"src/main/java/dir\").setKey(\"MODULE_KEY:src/main/java/dir\");\n    ComponentDto file = ComponentTesting.newFileDto(module, \"DEFG\").setKey(\"MODULE_KEY:src/main/java/dir/Foo.java\");\n    dbClient.componentDao().insert(session, directory, file);\n    session.commit();\n\n    reportReader.setMetadata(BatchReport.Metadata.newBuilder()\n      .setRootComponentRef(1)\n      .build());\n\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(PROJECT_KEY)\n      .addChildRef(2)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(2)\n      .setType(Constants.ComponentType.MODULE)\n      .setKey(\"MODULE_KEY\")\n      .addChildRef(3)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(3)\n      .setType(Constants.ComponentType.DIRECTORY)\n      .setPath(\"src/main/java/dir\")\n      .addChildRef(4)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(4)\n      .setType(Constants.ComponentType.FILE)\n      .setPath(\"src/main/java/dir/Foo.java\")\n      .build());\n\n\n    treeRootHolder.setRoot(ComponentTreeBuilders.from(reportReader).build());\n    sut.execute();\n\n    Map<Integer, Component> componentsByRef = getComponentsByRef(treeRootHolder.getRoot());\n\n    assertThat(componentsByRef.get(1).getKey()).isEqualTo(PROJECT_KEY);\n    assertThat(componentsByRef.get(1).getUuid()).isEqualTo(\"ABCD\");\n\n    assertThat(componentsByRef.get(2).getKey()).isEqualTo(\"MODULE_KEY\");\n    assertThat(componentsByRef.get(2).getUuid()).isEqualTo(\"BCDE\");\n\n    assertThat(componentsByRef.get(3).getKey()).isEqualTo(\"MODULE_KEY:src/main/java/dir\");\n    assertThat(componentsByRef.get(3).getUuid()).isEqualTo(\"CDEF\");\n\n    assertThat(componentsByRef.get(4).getKey()).isEqualTo(\"MODULE_KEY:src/main/java/dir/Foo.java\");\n    assertThat(componentsByRef.get(4).getUuid()).isEqualTo(\"DEFG\");\n  }","id":75924,"modified_method":"@Test\n  public void return_existing_uuids() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto(\"ABCD\").setKey(PROJECT_KEY);\n    dbClient.componentDao().insert(session, project);\n    ComponentDto module = ComponentTesting.newModuleDto(\"BCDE\", project).setKey(\"MODULE_KEY\");\n    dbClient.componentDao().insert(session, module);\n    ComponentDto directory = ComponentTesting.newDirectory(module, \"CDEF\", \"src/main/java/dir\").setKey(\"MODULE_KEY:src/main/java/dir\");\n    ComponentDto file = ComponentTesting.newFileDto(module, \"DEFG\").setKey(\"MODULE_KEY:src/main/java/dir/Foo.java\");\n    dbClient.componentDao().insert(session, directory, file);\n    session.commit();\n\n    reportReader.setMetadata(BatchReport.Metadata.newBuilder()\n      .setRootComponentRef(1)\n      .build());\n\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(PROJECT_KEY)\n      .addChildRef(2)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(2)\n      .setType(Constants.ComponentType.MODULE)\n      .setKey(\"MODULE_KEY\")\n      .addChildRef(3)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(3)\n      .setType(Constants.ComponentType.DIRECTORY)\n      .setPath(\"src/main/java/dir\")\n      .addChildRef(4)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(4)\n      .setType(Constants.ComponentType.FILE)\n      .setPath(\"src/main/java/dir/Foo.java\")\n      .build());\n\n\n    treeRootHolder.setRoot(ComponentTreeBuilder.from(reportReader));\n    sut.execute();\n\n    Map<Integer, Component> componentsByRef = getComponentsByRef(treeRootHolder.getRoot());\n\n    assertThat(componentsByRef.get(1).getKey()).isEqualTo(PROJECT_KEY);\n    assertThat(componentsByRef.get(1).getUuid()).isEqualTo(\"ABCD\");\n\n    assertThat(componentsByRef.get(2).getKey()).isEqualTo(\"MODULE_KEY\");\n    assertThat(componentsByRef.get(2).getUuid()).isEqualTo(\"BCDE\");\n\n    assertThat(componentsByRef.get(3).getKey()).isEqualTo(\"MODULE_KEY:src/main/java/dir\");\n    assertThat(componentsByRef.get(3).getUuid()).isEqualTo(\"CDEF\");\n\n    assertThat(componentsByRef.get(4).getKey()).isEqualTo(\"MODULE_KEY:src/main/java/dir/Foo.java\");\n    assertThat(componentsByRef.get(4).getUuid()).isEqualTo(\"DEFG\");\n  }","commit_id":"1321df4c9bb0af4d43d697cac5c930e7e2711226","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public ValidateProjectStep(DbClient dbClient, Settings settings, BatchReportReader reportReader) {\n    this.dbClient = dbClient;\n    this.settings = settings;\n    this.reportReader = reportReader;\n  }","id":75925,"modified_method":"public ValidateProjectStep(DbClient dbClient, Settings settings, BatchReportReader reportReader, TreeRootHolder treeRootHolder) {\n    this.dbClient = dbClient;\n    this.settings = settings;\n    this.reportReader = reportReader;\n    this.treeRootHolder = treeRootHolder;\n  }","commit_id":"1321df4c9bb0af4d43d697cac5c930e7e2711226","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_if_provisioning_enforced_and_project_does_not_exists() throws Exception {\n    thrown.expect(IllegalArgumentException.class);\n    thrown.expectMessage(\"Unable to scan non-existing project '\" + PROJECT_KEY + \"'\");\n\n    reportReader.setMetadata(BatchReport.Metadata.newBuilder().build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(PROJECT_KEY)\n      .build());\n\n    settings.appendProperty(CoreProperties.CORE_PREVENT_AUTOMATIC_PROJECT_CREATION, \"true\");\n\n    sut.execute(new ComputationContext(ComponentTreeBuilders.from(new DumbComponent(Component.Type.PROJECT, 1, \"ABCD\", PROJECT_KEY))));\n  }","id":75926,"modified_method":"@Test\n  public void fail_if_provisioning_enforced_and_project_does_not_exists() throws Exception {\n    thrown.expect(IllegalArgumentException.class);\n    thrown.expectMessage(\"Unable to scan non-existing project '\" + PROJECT_KEY + \"'\");\n\n    reportReader.setMetadata(BatchReport.Metadata.newBuilder().build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(PROJECT_KEY)\n      .build());\n\n    settings.appendProperty(CoreProperties.CORE_PREVENT_AUTOMATIC_PROJECT_CREATION, \"true\");\n    treeRootHolder.setRoot(new DumbComponent(Component.Type.PROJECT, 1, \"ABCD\", PROJECT_KEY));\n\n    sut.execute();\n  }","commit_id":"1321df4c9bb0af4d43d697cac5c930e7e2711226","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_if_module_key_already_exists_in_another_project() throws Exception {\n    String anotherProjectKey = \"ANOTHER_PROJECT_KEY\";\n    thrown.expect(IllegalArgumentException.class);\n    thrown.expectMessage(\"Validation of project failed:\\n\" +\n      \"  o Module \\\"\" + MODULE_KEY + \"\\\" is already part of project \\\"\" + anotherProjectKey + \"\\\"\");\n\n    reportReader.setMetadata(BatchReport.Metadata.newBuilder().build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(PROJECT_KEY)\n      .addChildRef(2)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(2)\n      .setType(Constants.ComponentType.MODULE)\n      .setKey(MODULE_KEY)\n      .build());\n\n    ComponentDto project = ComponentTesting.newProjectDto(\"ABCD\").setKey(PROJECT_KEY);\n    ComponentDto anotherProject = ComponentTesting.newProjectDto().setKey(anotherProjectKey);\n    dbClient.componentDao().insert(dbSession, project, anotherProject);\n    ComponentDto module = ComponentTesting.newModuleDto(\"BCDE\", anotherProject).setKey(MODULE_KEY);\n    dbClient.componentDao().insert(dbSession, module);\n    dbSession.commit();\n\n    DumbComponent root = new DumbComponent(Component.Type.PROJECT, 1, \"ABCD\", PROJECT_KEY,\n      new DumbComponent(Component.Type.MODULE, 2, \"BCDE\", MODULE_KEY));\n    sut.execute(new ComputationContext(\n      ComponentTreeBuilders.from(root)));\n  }","id":75927,"modified_method":"@Test\n  public void fail_if_module_key_already_exists_in_another_project() throws Exception {\n    String anotherProjectKey = \"ANOTHER_PROJECT_KEY\";\n    thrown.expect(IllegalArgumentException.class);\n    thrown.expectMessage(\"Validation of project failed:\\n\" +\n      \"  o Module \\\"\" + MODULE_KEY + \"\\\" is already part of project \\\"\" + anotherProjectKey + \"\\\"\");\n\n    reportReader.setMetadata(BatchReport.Metadata.newBuilder().build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(PROJECT_KEY)\n      .addChildRef(2)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(2)\n      .setType(Constants.ComponentType.MODULE)\n      .setKey(MODULE_KEY)\n      .build());\n\n    ComponentDto project = ComponentTesting.newProjectDto(\"ABCD\").setKey(PROJECT_KEY);\n    ComponentDto anotherProject = ComponentTesting.newProjectDto().setKey(anotherProjectKey);\n    dbClient.componentDao().insert(dbSession, project, anotherProject);\n    ComponentDto module = ComponentTesting.newModuleDto(\"BCDE\", anotherProject).setKey(MODULE_KEY);\n    dbClient.componentDao().insert(dbSession, module);\n    dbSession.commit();\n\n    treeRootHolder.setRoot(new DumbComponent(Component.Type.PROJECT, 1, \"ABCD\", PROJECT_KEY,\n      new DumbComponent(Component.Type.MODULE, 2, \"BCDE\", MODULE_KEY)));\n\n    sut.execute();\n  }","commit_id":"1321df4c9bb0af4d43d697cac5c930e7e2711226","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_on_invalid_branch() throws Exception {\n    thrown.expect(IllegalArgumentException.class);\n    thrown.expectMessage(\"Validation of project failed:\\n\" +\n      \"  o \\\"bran#ch\\\" is not a valid branch name. Allowed characters are alphanumeric, '-', '_', '.' and '/'.\");\n\n    reportReader.setMetadata(BatchReport.Metadata.newBuilder()\n      .setBranch(\"bran#ch\")\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(PROJECT_KEY)\n      .build());\n\n    sut.execute(new ComputationContext(\n      ComponentTreeBuilders.from(new DumbComponent(Component.Type.PROJECT, 1, \"ABCD\", PROJECT_KEY + \":bran#ch\"))));\n  }","id":75928,"modified_method":"@Test\n  public void fail_on_invalid_branch() throws Exception {\n    thrown.expect(IllegalArgumentException.class);\n    thrown.expectMessage(\"Validation of project failed:\\n\" +\n      \"  o \\\"bran#ch\\\" is not a valid branch name. Allowed characters are alphanumeric, '-', '_', '.' and '/'.\");\n\n    reportReader.setMetadata(BatchReport.Metadata.newBuilder()\n      .setBranch(\"bran#ch\")\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(PROJECT_KEY)\n      .build());\n    treeRootHolder.setRoot(new DumbComponent(Component.Type.PROJECT, 1, \"ABCD\", PROJECT_KEY + \":bran#ch\"));\n\n    sut.execute();\n  }","commit_id":"1321df4c9bb0af4d43d697cac5c930e7e2711226","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_if_module_key_is_already_used_as_project_key() throws Exception {\n    thrown.expect(IllegalArgumentException.class);\n    thrown.expectMessage(\"Validation of project failed:\\n\" +\n      \"  o The project \\\"\" + MODULE_KEY + \"\\\" is already defined in SonarQube but not as a module of project \\\"\" + PROJECT_KEY + \"\\\". \" +\n      \"If you really want to stop directly analysing project \\\"\" + MODULE_KEY + \"\\\", please first delete it from SonarQube and then relaunch the analysis of project \\\"\"\n      + PROJECT_KEY + \"\\\".\");\n\n    reportReader.setMetadata(BatchReport.Metadata.newBuilder().build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(PROJECT_KEY)\n      .addChildRef(2)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(2)\n      .setType(Constants.ComponentType.MODULE)\n      .setKey(MODULE_KEY)\n      .build());\n\n    ComponentDto project = ComponentTesting.newProjectDto(\"ABCD\").setKey(MODULE_KEY);\n    dbClient.componentDao().insert(dbSession, project);\n    dbSession.commit();\n\n    DumbComponent root = new DumbComponent(Component.Type.PROJECT, 1, \"ABCD\", PROJECT_KEY,\n      new DumbComponent(Component.Type.MODULE, 2, \"BCDE\", MODULE_KEY));\n    sut.execute(new ComputationContext(\n      ComponentTreeBuilders.from(root)));\n  }","id":75929,"modified_method":"@Test\n  public void fail_if_module_key_is_already_used_as_project_key() throws Exception {\n    thrown.expect(IllegalArgumentException.class);\n    thrown.expectMessage(\"Validation of project failed:\\n\" +\n      \"  o The project \\\"\" + MODULE_KEY + \"\\\" is already defined in SonarQube but not as a module of project \\\"\" + PROJECT_KEY + \"\\\". \" +\n      \"If you really want to stop directly analysing project \\\"\" + MODULE_KEY + \"\\\", please first delete it from SonarQube and then relaunch the analysis of project \\\"\"\n      + PROJECT_KEY + \"\\\".\");\n\n    reportReader.setMetadata(BatchReport.Metadata.newBuilder().build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(PROJECT_KEY)\n      .addChildRef(2)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(2)\n      .setType(Constants.ComponentType.MODULE)\n      .setKey(MODULE_KEY)\n      .build());\n\n    ComponentDto project = ComponentTesting.newProjectDto(\"ABCD\").setKey(MODULE_KEY);\n    dbClient.componentDao().insert(dbSession, project);\n    dbSession.commit();\n\n    treeRootHolder.setRoot(new DumbComponent(Component.Type.PROJECT, 1, \"ABCD\", PROJECT_KEY,\n      new DumbComponent(Component.Type.MODULE, 2, \"BCDE\", MODULE_KEY)));\n\n    sut.execute();\n  }","commit_id":"1321df4c9bb0af4d43d697cac5c930e7e2711226","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void not_fail_if_provisioning_enforced_and_project_exists() throws Exception {\n    reportReader.setMetadata(BatchReport.Metadata.newBuilder().build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(PROJECT_KEY)\n      .build());\n\n    settings.appendProperty(CoreProperties.CORE_PREVENT_AUTOMATIC_PROJECT_CREATION, \"true\");\n    dbClient.componentDao().insert(dbSession, ComponentTesting.newProjectDto(\"ABCD\").setKey(PROJECT_KEY));\n    dbSession.commit();\n\n    sut.execute(new ComputationContext(ComponentTreeBuilders.from(new DumbComponent(Component.Type.PROJECT, 1, \"ABCD\", PROJECT_KEY))));\n  }","id":75930,"modified_method":"@Test\n  public void not_fail_if_provisioning_enforced_and_project_exists() throws Exception {\n    reportReader.setMetadata(BatchReport.Metadata.newBuilder().build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(PROJECT_KEY)\n      .build());\n\n    settings.appendProperty(CoreProperties.CORE_PREVENT_AUTOMATIC_PROJECT_CREATION, \"true\");\n    dbClient.componentDao().insert(dbSession, ComponentTesting.newProjectDto(\"ABCD\").setKey(PROJECT_KEY));\n    dbSession.commit();\n    treeRootHolder.setRoot(new DumbComponent(Component.Type.PROJECT, 1, \"ABCD\", PROJECT_KEY));\n\n    sut.execute();\n  }","commit_id":"1321df4c9bb0af4d43d697cac5c930e7e2711226","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_if_project_key_already_exists_as_module() throws Exception {\n    String anotherProjectKey = \"ANOTHER_PROJECT_KEY\";\n    thrown.expect(IllegalArgumentException.class);\n    thrown.expectMessage(\"Validation of project failed:\\n\" +\n      \"  o The project \\\"\" + PROJECT_KEY + \"\\\" is already defined in SonarQube but as a module of project \\\"\" + anotherProjectKey + \"\\\". \" +\n      \"If you really want to stop directly analysing project \\\"\" + anotherProjectKey + \"\\\", please first delete it from SonarQube and then relaunch the analysis of project \\\"\"\n      + PROJECT_KEY + \"\\\".\");\n\n    reportReader.setMetadata(BatchReport.Metadata.newBuilder().build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(PROJECT_KEY)\n      .addChildRef(2)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(2)\n      .setType(Constants.ComponentType.MODULE)\n      .setKey(MODULE_KEY)\n      .build());\n\n    ComponentDto anotherProject = ComponentTesting.newProjectDto().setKey(anotherProjectKey);\n    dbClient.componentDao().insert(dbSession, anotherProject);\n    ComponentDto module = ComponentTesting.newModuleDto(\"ABCD\", anotherProject).setKey(PROJECT_KEY);\n    dbClient.componentDao().insert(dbSession, module);\n    dbSession.commit();\n\n    DumbComponent root = new DumbComponent(Component.Type.PROJECT, 1, \"ABCD\", PROJECT_KEY,\n      new DumbComponent(Component.Type.MODULE, 2, \"BCDE\", MODULE_KEY));\n    sut.execute(new ComputationContext(\n      ComponentTreeBuilders.from(root)));\n  }","id":75931,"modified_method":"@Test\n  public void fail_if_project_key_already_exists_as_module() throws Exception {\n    String anotherProjectKey = \"ANOTHER_PROJECT_KEY\";\n    thrown.expect(IllegalArgumentException.class);\n    thrown.expectMessage(\"Validation of project failed:\\n\" +\n      \"  o The project \\\"\" + PROJECT_KEY + \"\\\" is already defined in SonarQube but as a module of project \\\"\" + anotherProjectKey + \"\\\". \" +\n      \"If you really want to stop directly analysing project \\\"\" + anotherProjectKey + \"\\\", please first delete it from SonarQube and then relaunch the analysis of project \\\"\"\n      + PROJECT_KEY + \"\\\".\");\n\n    reportReader.setMetadata(BatchReport.Metadata.newBuilder().build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(PROJECT_KEY)\n      .addChildRef(2)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(2)\n      .setType(Constants.ComponentType.MODULE)\n      .setKey(MODULE_KEY)\n      .build());\n\n    ComponentDto anotherProject = ComponentTesting.newProjectDto().setKey(anotherProjectKey);\n    dbClient.componentDao().insert(dbSession, anotherProject);\n    ComponentDto module = ComponentTesting.newModuleDto(\"ABCD\", anotherProject).setKey(PROJECT_KEY);\n    dbClient.componentDao().insert(dbSession, module);\n    dbSession.commit();\n\n    treeRootHolder.setRoot(new DumbComponent(Component.Type.PROJECT, 1, \"ABCD\", PROJECT_KEY,\n      new DumbComponent(Component.Type.MODULE, 2, \"BCDE\", MODULE_KEY)));\n    \n    sut.execute();\n  }","commit_id":"1321df4c9bb0af4d43d697cac5c930e7e2711226","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_on_invalid_key() throws Exception {\n    String invalidProjectKey = \"Project\\\\Key\";\n\n    thrown.expect(IllegalArgumentException.class);\n    thrown.expectMessage(\"Validation of project failed:\\n\" +\n      \"  o \\\"Project\\\\Key\\\" is not a valid project or module key. Allowed characters are alphanumeric, '-', '_', '.' and ':', with at least one non-digit.\\n\" +\n      \"  o \\\"Module$Key\\\" is not a valid project or module key. Allowed characters are alphanumeric, '-', '_', '.' and ':', with at least one non-digit\");\n\n    reportReader.setMetadata(BatchReport.Metadata.newBuilder().build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(invalidProjectKey)\n      .addChildRef(2)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(2)\n      .setType(Constants.ComponentType.MODULE)\n      .setKey(\"Module$Key\")\n      .build());\n\n    DumbComponent root = new DumbComponent(Component.Type.PROJECT, 1, \"ABCD\", invalidProjectKey,\n      new DumbComponent(Component.Type.MODULE, 2, \"BCDE\", \"Module$Key\"));\n    sut.execute(new ComputationContext(ComponentTreeBuilders.from(root)));\n  }","id":75932,"modified_method":"@Test\n  public void fail_on_invalid_key() throws Exception {\n    String invalidProjectKey = \"Project\\\\Key\";\n\n    thrown.expect(IllegalArgumentException.class);\n    thrown.expectMessage(\"Validation of project failed:\\n\" +\n      \"  o \\\"Project\\\\Key\\\" is not a valid project or module key. Allowed characters are alphanumeric, '-', '_', '.' and ':', with at least one non-digit.\\n\" +\n      \"  o \\\"Module$Key\\\" is not a valid project or module key. Allowed characters are alphanumeric, '-', '_', '.' and ':', with at least one non-digit\");\n\n    reportReader.setMetadata(BatchReport.Metadata.newBuilder().build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(invalidProjectKey)\n      .addChildRef(2)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(2)\n      .setType(Constants.ComponentType.MODULE)\n      .setKey(\"Module$Key\")\n      .build());\n    treeRootHolder.setRoot(new DumbComponent(Component.Type.PROJECT, 1, \"ABCD\", invalidProjectKey,\n      new DumbComponent(Component.Type.MODULE, 2, \"BCDE\", \"Module$Key\")));\n\n    sut.execute();\n  }","commit_id":"1321df4c9bb0af4d43d697cac5c930e7e2711226","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_if_provisioning_not_enforced_and_project_does_not_exists() throws Exception {\n    reportReader.setMetadata(BatchReport.Metadata.newBuilder().build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(PROJECT_KEY)\n      .build());\n\n    settings.appendProperty(CoreProperties.CORE_PREVENT_AUTOMATIC_PROJECT_CREATION, \"false\");\n\n    sut.execute(new ComputationContext(ComponentTreeBuilders.from(new DumbComponent(Component.Type.PROJECT, 1, \"ABCD\", PROJECT_KEY))));\n  }","id":75933,"modified_method":"@Test\n  public void fail_if_provisioning_not_enforced_and_project_does_not_exists() throws Exception {\n    reportReader.setMetadata(BatchReport.Metadata.newBuilder().build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(PROJECT_KEY)\n      .build());\n\n    settings.appendProperty(CoreProperties.CORE_PREVENT_AUTOMATIC_PROJECT_CREATION, \"false\");\n    treeRootHolder.setRoot(new DumbComponent(Component.Type.PROJECT, 1, \"ABCD\", PROJECT_KEY));\n\n    sut.execute();\n  }","commit_id":"1321df4c9bb0af4d43d697cac5c930e7e2711226","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Before\n  public void setUp() throws Exception {\n    dbTester.truncateTables();\n    dbClient = new DbClient(dbTester.database(), dbTester.myBatis(), new ComponentDao());\n    dbSession = dbClient.openSession(false);\n    settings = new Settings();\n\n    sut = new ValidateProjectStep(dbClient, settings, reportReader);\n  }","id":75934,"modified_method":"@Before\n  public void setUp() throws Exception {\n    dbTester.truncateTables();\n    dbClient = new DbClient(dbTester.database(), dbTester.myBatis(), new ComponentDao());\n    dbSession = dbClient.openSession(false);\n    settings = new Settings();\n\n    sut = new ValidateProjectStep(dbClient, settings, reportReader, treeRootHolder);\n  }","commit_id":"1321df4c9bb0af4d43d697cac5c930e7e2711226","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void not_fail_on_valid_branch() throws Exception {\n    reportReader.setMetadata(BatchReport.Metadata.newBuilder()\n      .setBranch(\"origin/master\")\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(PROJECT_KEY)\n      .build());\n\n    sut.execute(new ComputationContext(\n      ComponentTreeBuilders.from(new DumbComponent(Component.Type.PROJECT, 1, \"ABCD\", PROJECT_KEY + \":origin/master\"))));\n  }","id":75935,"modified_method":"@Test\n  public void not_fail_on_valid_branch() throws Exception {\n    reportReader.setMetadata(BatchReport.Metadata.newBuilder()\n      .setBranch(\"origin/master\")\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(PROJECT_KEY)\n      .build());\n    treeRootHolder.setRoot(new DumbComponent(Component.Type.PROJECT, 1, \"ABCD\", PROJECT_KEY + \":origin/master\"));\n\n    sut.execute();\n  }","commit_id":"1321df4c9bb0af4d43d697cac5c930e7e2711226","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static Type convertType(Constants.ComponentType type) {\n    switch (type) {\n      case PROJECT:\n        return Type.PROJECT;\n      case MODULE:\n        return Type.MODULE;\n      case DIRECTORY:\n        return Type.DIRECTORY;\n      case FILE:\n        return Type.FILE;\n      default:\n        throw new IllegalArgumentException(\"Unsupported Constants.ComponentType value \" + type);\n    }\n  }","id":75936,"modified_method":"public static Type convertType(Constants.ComponentType type) {\n    switch (type) {\n      case PROJECT:\n        return Type.PROJECT;\n      case MODULE:\n        return Type.MODULE;\n      case DIRECTORY:\n        return Type.DIRECTORY;\n      case FILE:\n        return Type.FILE;\n      default:\n        throw new IllegalArgumentException(\"Unsupported Constants.ComponentType value \" + type);\n    }\n  }","commit_id":"6327a718ef8197caec2ea8ced400cd9dae79c2d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void compute_keys_and_uuids() throws Exception {\n    reportReader.setMetadata(BatchReport.Metadata.newBuilder()\n      .setRootComponentRef(1)\n      .build());\n\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(PROJECT_KEY)\n      .addChildRef(2)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(2)\n      .setType(Constants.ComponentType.MODULE)\n      .setKey(\"MODULE_KEY\")\n      .addChildRef(3)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(3)\n      .setType(Constants.ComponentType.DIRECTORY)\n      .setPath(\"src/main/java/dir\")\n      .addChildRef(4)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(4)\n      .setType(Constants.ComponentType.FILE)\n      .setPath(\"src/main/java/dir/Foo.java\")\n      .build());\n\n    treeRootHolder.setRoot(ComponentTreeBuilders.from(reportReader).build());\n    sut.execute();\n\n    Map<Integer, Component> componentsByRef = getComponentsByRef(treeRootHolder.getRoot());\n\n    assertThat(componentsByRef.get(1).getKey()).isEqualTo(PROJECT_KEY);\n    assertThat(componentsByRef.get(1).getUuid()).isNotNull();\n\n    assertThat(componentsByRef.get(2).getKey()).isEqualTo(\"MODULE_KEY\");\n    assertThat(componentsByRef.get(2).getUuid()).isNotNull();\n\n    assertThat(componentsByRef.get(3).getKey()).isEqualTo(\"MODULE_KEY:src/main/java/dir\");\n    assertThat(componentsByRef.get(3).getUuid()).isNotNull();\n\n    assertThat(componentsByRef.get(4).getKey()).isEqualTo(\"MODULE_KEY:src/main/java/dir/Foo.java\");\n    assertThat(componentsByRef.get(4).getUuid()).isNotNull();\n  }","id":75937,"modified_method":"@Test\n  public void compute_keys_and_uuids() throws Exception {\n    reportReader.setMetadata(BatchReport.Metadata.newBuilder()\n      .setRootComponentRef(1)\n      .build());\n\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(PROJECT_KEY)\n      .addChildRef(2)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(2)\n      .setType(Constants.ComponentType.MODULE)\n      .setKey(\"MODULE_KEY\")\n      .addChildRef(3)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(3)\n      .setType(Constants.ComponentType.DIRECTORY)\n      .setPath(\"src/main/java/dir\")\n      .addChildRef(4)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(4)\n      .setType(Constants.ComponentType.FILE)\n      .setPath(\"src/main/java/dir/Foo.java\")\n      .build());\n\n    treeRootHolder.setRoot(ComponentTreeBuilder.from(reportReader));\n    sut.execute();\n\n    Map<Integer, Component> componentsByRef = getComponentsByRef(treeRootHolder.getRoot());\n\n    assertThat(componentsByRef.get(1).getKey()).isEqualTo(PROJECT_KEY);\n    assertThat(componentsByRef.get(1).getUuid()).isNotNull();\n\n    assertThat(componentsByRef.get(2).getKey()).isEqualTo(\"MODULE_KEY\");\n    assertThat(componentsByRef.get(2).getUuid()).isNotNull();\n\n    assertThat(componentsByRef.get(3).getKey()).isEqualTo(\"MODULE_KEY:src/main/java/dir\");\n    assertThat(componentsByRef.get(3).getUuid()).isNotNull();\n\n    assertThat(componentsByRef.get(4).getKey()).isEqualTo(\"MODULE_KEY:src/main/java/dir/Foo.java\");\n    assertThat(componentsByRef.get(4).getUuid()).isNotNull();\n  }","commit_id":"6327a718ef8197caec2ea8ced400cd9dae79c2d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void use_latest_module_for_files_key() throws Exception {\n    reportReader.setMetadata(BatchReport.Metadata.newBuilder()\n      .setRootComponentRef(1)\n      .build());\n\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(PROJECT_KEY)\n      .setName(\"Project\")\n      .addChildRef(2)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(2)\n      .setType(Constants.ComponentType.MODULE)\n      .setKey(\"MODULE_KEY\")\n      .setName(\"Module\")\n      .addChildRef(3)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(3)\n      .setType(Constants.ComponentType.MODULE)\n      .setKey(\"SUB_MODULE_KEY\")\n      .setName(\"Sub Module\")\n      .addChildRef(4)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(4)\n      .setType(Constants.ComponentType.DIRECTORY)\n      .setPath(\"src/main/java/dir\")\n      .addChildRef(5)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(5)\n      .setType(Constants.ComponentType.FILE)\n      .setPath(\"src/main/java/dir/Foo.java\")\n      .build());\n\n    treeRootHolder.setRoot(ComponentTreeBuilders.from(reportReader).build());\n    sut.execute();\n\n    Map<Integer, Component> componentsByRef = getComponentsByRef(treeRootHolder.getRoot());\n\n    assertThat(componentsByRef.get(4).getKey()).isEqualTo(\"SUB_MODULE_KEY:src/main/java/dir\");\n    assertThat(componentsByRef.get(5).getKey()).isEqualTo(\"SUB_MODULE_KEY:src/main/java/dir/Foo.java\");\n  }","id":75938,"modified_method":"@Test\n  public void use_latest_module_for_files_key() throws Exception {\n    reportReader.setMetadata(BatchReport.Metadata.newBuilder()\n      .setRootComponentRef(1)\n      .build());\n\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(PROJECT_KEY)\n      .setName(\"Project\")\n      .addChildRef(2)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(2)\n      .setType(Constants.ComponentType.MODULE)\n      .setKey(\"MODULE_KEY\")\n      .setName(\"Module\")\n      .addChildRef(3)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(3)\n      .setType(Constants.ComponentType.MODULE)\n      .setKey(\"SUB_MODULE_KEY\")\n      .setName(\"Sub Module\")\n      .addChildRef(4)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(4)\n      .setType(Constants.ComponentType.DIRECTORY)\n      .setPath(\"src/main/java/dir\")\n      .addChildRef(5)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(5)\n      .setType(Constants.ComponentType.FILE)\n      .setPath(\"src/main/java/dir/Foo.java\")\n      .build());\n\n    treeRootHolder.setRoot(ComponentTreeBuilder.from(reportReader));\n    sut.execute();\n\n    Map<Integer, Component> componentsByRef = getComponentsByRef(treeRootHolder.getRoot());\n\n    assertThat(componentsByRef.get(4).getKey()).isEqualTo(\"SUB_MODULE_KEY:src/main/java/dir\");\n    assertThat(componentsByRef.get(5).getKey()).isEqualTo(\"SUB_MODULE_KEY:src/main/java/dir/Foo.java\");\n  }","commit_id":"6327a718ef8197caec2ea8ced400cd9dae79c2d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void use_branch_to_generate_keys() throws Exception {\n    reportReader.setMetadata(BatchReport.Metadata.newBuilder()\n      .setRootComponentRef(1)\n      .setBranch(\"origin/master\")\n      .setProjectKey(\"\")\n      .build());\n\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(PROJECT_KEY)\n      .setName(\"Project\")\n      .addChildRef(2)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(2)\n      .setType(Constants.ComponentType.MODULE)\n      .setKey(\"MODULE_KEY\")\n      .setName(\"Module\")\n      .addChildRef(3)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(3)\n      .setType(Constants.ComponentType.DIRECTORY)\n      .setPath(\"src/main/java/dir\")\n      .addChildRef(4)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(4)\n      .setType(Constants.ComponentType.FILE)\n      .setPath(\"src/main/java/dir/Foo.java\")\n      .build());\n\n    treeRootHolder.setRoot(ComponentTreeBuilders.from(reportReader).build());\n    sut.execute();\n\n    Map<Integer, Component> componentsByRef = getComponentsByRef(treeRootHolder.getRoot());\n\n    assertThat(componentsByRef.get(1).getKey()).isEqualTo(\"PROJECT_KEY:origin/master\");\n    assertThat(componentsByRef.get(2).getKey()).isEqualTo(\"MODULE_KEY:origin/master\");\n    assertThat(componentsByRef.get(3).getKey()).isEqualTo(\"MODULE_KEY:origin/master:src/main/java/dir\");\n    assertThat(componentsByRef.get(4).getKey()).isEqualTo(\"MODULE_KEY:origin/master:src/main/java/dir/Foo.java\");\n  }","id":75939,"modified_method":"@Test\n  public void use_branch_to_generate_keys() throws Exception {\n    reportReader.setMetadata(BatchReport.Metadata.newBuilder()\n      .setRootComponentRef(1)\n      .setBranch(\"origin/master\")\n      .setProjectKey(\"\")\n      .build());\n\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(1)\n      .setType(Constants.ComponentType.PROJECT)\n      .setKey(PROJECT_KEY)\n      .setName(\"Project\")\n      .addChildRef(2)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(2)\n      .setType(Constants.ComponentType.MODULE)\n      .setKey(\"MODULE_KEY\")\n      .setName(\"Module\")\n      .addChildRef(3)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(3)\n      .setType(Constants.ComponentType.DIRECTORY)\n      .setPath(\"src/main/java/dir\")\n      .addChildRef(4)\n      .build());\n    reportReader.putComponent(BatchReport.Component.newBuilder()\n      .setRef(4)\n      .setType(Constants.ComponentType.FILE)\n      .setPath(\"src/main/java/dir/Foo.java\")\n      .build());\n\n    treeRootHolder.setRoot(ComponentTreeBuilder.from(reportReader));\n    sut.execute();\n\n    Map<Integer, Component> componentsByRef = getComponentsByRef(treeRootHolder.getRoot());\n\n    assertThat(componentsByRef.get(1).getKey()).isEqualTo(\"PROJECT_KEY:origin/master\");\n    assertThat(componentsByRef.get(2).getKey()).isEqualTo(\"MODULE_KEY:origin/master\");\n    assertThat(componentsByRef.get(3).getKey()).isEqualTo(\"MODULE_KEY:origin/master:src/main/java/dir\");\n    assertThat(componentsByRef.get(4).getKey()).isEqualTo(\"MODULE_KEY:origin/master:src/main/java/dir/Foo.java\");\n  }","commit_id":"6327a718ef8197caec2ea8ced400cd9dae79c2d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * Returns the result set of the query as iterable vertices.\n   */\n  @Override\n  public Iterable<Vertex> vertices() {\n    if (limit == 0)\n      return Collections.emptyList();\n\n    if (((OrientBaseGraph) graph).getRawGraph().getTransaction().isActive())\n      // INSIDE TRANSACTION QUERY DOESN'T SEE IN MEMORY CHANGES, UNTIL\n      // SUPPORTED USED THE BASIC IMPL\n      return new OrientGraphQueryIterable<Vertex>(true, labels);\n\n    final StringBuilder text = new StringBuilder(512);\n\n    // GO DIRECTLY AGAINST E CLASS AND SUB-CLASSES\n    text.append(QUERY_SELECT_FROM);\n\n    if (((OrientBaseGraph) graph).isUseClassForVertexLabel() && labels != null && labels.length > 0) {\n      // FILTER PER CLASS SAVING CHECKING OF LABEL PROPERTY\n      if (labels.length == 1)\n        // USE THE CLASS NAME\n        text.append(OrientBaseGraph.encodeClassName(labels[0]));\n      else {\n        // MULTIPLE CLASSES NOT SUPPORTED DIRECTLY: CREATE A SUB-QUERY\n        return new OrientGraphQueryIterable<Vertex>(true, labels);\n      }\n    } else\n      text.append(OrientVertexType.CLASS_NAME);\n\n    // APPEND ALWAYS WHERE\n    text.append(QUERY_WHERE);\n    manageFilters(text);\n    if (!((OrientBaseGraph) graph).isUseClassForVertexLabel())\n      manageLabels(text);\n\n    if (orderBy.length() > 1) {\n      text.append(ORDERBY);\n      text.append(orderBy);\n      text.append(\" \" + orderByDir + \" \");\n    }\n    if (skip > 0 && skip < Long.MAX_VALUE) {\n      text.append(SKIP);\n      text.append(skip);\n    }\n\n    if (limit > 0 && limit < Long.MAX_VALUE) {\n      text.append(LIMIT);\n      text.append(limit);\n    }\n\n    final OSQLSynchQuery<OIdentifiable> query = new OSQLSynchQuery<OIdentifiable>(text.toString());\n\n    if (fetchPlan != null)\n      query.setFetchPlan(fetchPlan);\n\n    return new OrientElementIterable<Vertex>(((OrientBaseGraph) graph), ((OrientBaseGraph) graph).getRawGraph().query(query));\n  }","id":75940,"modified_method":"/**\n   * Returns the result set of the query as iterable vertices.\n   */\n  @Override\n  public Iterable<Vertex> vertices() {\n    if (limit == 0)\n      return Collections.emptyList();\n\n    if (((OrientBaseGraph) graph).getRawGraph().getTransaction().isActive())\n      // INSIDE TRANSACTION QUERY DOESN'T SEE IN MEMORY CHANGES, UNTIL\n      // SUPPORTED USED THE BASIC IMPL\n      return new OrientGraphQueryIterable<Vertex>(true, labels);\n\n    final StringBuilder text = new StringBuilder(512);\n\n    // GO DIRECTLY AGAINST E CLASS AND SUB-CLASSES\n    text.append(QUERY_SELECT_FROM);\n\n    if (((OrientBaseGraph) graph).isUseClassForVertexLabel() && labels != null && labels.length > 0) {\n      // FILTER PER CLASS SAVING CHECKING OF LABEL PROPERTY\n      if (labels.length == 1)\n        // USE THE CLASS NAME\n        text.append(OrientBaseGraph.encodeClassName(labels[0]));\n      else {\n        // MULTIPLE CLASSES NOT SUPPORTED DIRECTLY: CREATE A SUB-QUERY\n        return new OrientGraphQueryIterable<Vertex>(true, labels);\n      }\n    } else\n      text.append(OrientVertexType.CLASS_NAME);\n\n    final boolean usedWhere = manageFilters(text);\n    if (!((OrientBaseGraph) graph).isUseClassForVertexLabel())\n      manageLabels(usedWhere, text);\n\n    if (orderBy.length() > 1) {\n      text.append(ORDERBY);\n      text.append(orderBy);\n      text.append(\" \" + orderByDir + \" \");\n    }\n    if (skip > 0 && skip < Long.MAX_VALUE) {\n      text.append(SKIP);\n      text.append(skip);\n    }\n\n    if (limit > 0 && limit < Long.MAX_VALUE) {\n      text.append(LIMIT);\n      text.append(limit);\n    }\n\n    final OSQLSynchQuery<OIdentifiable> query = new OSQLSynchQuery<OIdentifiable>(text.toString());\n\n    if (fetchPlan != null)\n      query.setFetchPlan(fetchPlan);\n\n    return new OrientElementIterable<Vertex>(((OrientBaseGraph) graph), ((OrientBaseGraph) graph).getRawGraph().query(query));\n  }","commit_id":"8fe1b073e8dc74e5e3822be123c063163f021f22","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n   * \n   * Returns the result set of the query as iterable edges.\n   */\n  @Override\n  public Iterable<Edge> edges() {\n    if (limit == 0)\n      return Collections.emptyList();\n\n    if (((OrientBaseGraph) graph).getRawGraph().getTransaction().isActive())\n      // INSIDE TRANSACTION QUERY DOESN'T SEE IN MEMORY CHANGES, UNTIL\n      // SUPPORTED USED THE BASIC IMPL\n      return new OrientGraphQueryIterable<Edge>(false, labels);\n\n    if (((OrientBaseGraph) graph).isUseLightweightEdges())\n      return new OrientGraphQueryIterable<Edge>(false, labels);\n\n    final StringBuilder text = new StringBuilder(512);\n\n    // GO DIRECTLY AGAINST E CLASS AND SUB-CLASSES\n    text.append(QUERY_SELECT_FROM);\n\n    if (((OrientBaseGraph) graph).isUseClassForEdgeLabel() && labels != null && labels.length > 0) {\n      // FILTER PER CLASS SAVING CHECKING OF LABEL PROPERTY\n      if (labels.length == 1)\n        // USE THE CLASS NAME\n        text.append(OrientBaseGraph.encodeClassName(labels[0]));\n      else {\n        // MULTIPLE CLASSES NOT SUPPORTED DIRECTLY: CREATE A SUB-QUERY\n        return new OrientGraphQueryIterable<Edge>(false, labels);\n      }\n    } else\n      text.append(OrientEdgeType.CLASS_NAME);\n\n    // APPEND ALWAYS WHERE 1=1 TO MAKE CONCATENATING EASIER\n    text.append(QUERY_WHERE);\n\n    manageFilters(text);\n    if (!((OrientBaseGraph) graph).isUseClassForEdgeLabel())\n      manageLabels(text);\n\n    final OSQLSynchQuery<OIdentifiable> query = new OSQLSynchQuery<OIdentifiable>(text.toString());\n\n    if (fetchPlan != null)\n      query.setFetchPlan(fetchPlan);\n\n    if (limit > 0 && limit < Long.MAX_VALUE)\n      query.setLimit((int) limit);\n\n    return new OrientElementIterable<Edge>(((OrientBaseGraph) graph), ((OrientBaseGraph) graph).getRawGraph().query(query));\n  }","id":75941,"modified_method":"/**\n   * \n   * Returns the result set of the query as iterable edges.\n   */\n  @Override\n  public Iterable<Edge> edges() {\n    if (limit == 0)\n      return Collections.emptyList();\n\n    if (((OrientBaseGraph) graph).getRawGraph().getTransaction().isActive())\n      // INSIDE TRANSACTION QUERY DOESN'T SEE IN MEMORY CHANGES, UNTIL\n      // SUPPORTED USED THE BASIC IMPL\n      return new OrientGraphQueryIterable<Edge>(false, labels);\n\n    if (((OrientBaseGraph) graph).isUseLightweightEdges())\n      return new OrientGraphQueryIterable<Edge>(false, labels);\n\n    final StringBuilder text = new StringBuilder(512);\n\n    // GO DIRECTLY AGAINST E CLASS AND SUB-CLASSES\n    text.append(QUERY_SELECT_FROM);\n\n    if (((OrientBaseGraph) graph).isUseClassForEdgeLabel() && labels != null && labels.length > 0) {\n      // FILTER PER CLASS SAVING CHECKING OF LABEL PROPERTY\n      if (labels.length == 1)\n        // USE THE CLASS NAME\n        text.append(OrientBaseGraph.encodeClassName(labels[0]));\n      else {\n        // MULTIPLE CLASSES NOT SUPPORTED DIRECTLY: CREATE A SUB-QUERY\n        return new OrientGraphQueryIterable<Edge>(false, labels);\n      }\n    } else\n      text.append(OrientEdgeType.CLASS_NAME);\n\n    final boolean usedWhere = manageFilters(text);\n    if (!((OrientBaseGraph) graph).isUseClassForEdgeLabel())\n      manageLabels(usedWhere, text);\n\n    final OSQLSynchQuery<OIdentifiable> query = new OSQLSynchQuery<OIdentifiable>(text.toString());\n\n    if (fetchPlan != null)\n      query.setFetchPlan(fetchPlan);\n\n    if (limit > 0 && limit < Long.MAX_VALUE)\n      query.setLimit((int) limit);\n\n    return new OrientElementIterable<Edge>(((OrientBaseGraph) graph), ((OrientBaseGraph) graph).getRawGraph().query(query));\n  }","commit_id":"8fe1b073e8dc74e5e3822be123c063163f021f22","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void manageLabels(final StringBuilder text) {\n    if (labels != null && labels.length > 0) {\n      // APPEND LABELS\n      text.append(QUERY_LABEL_BEGIN);\n      for (int i = 0; i < labels.length; ++i) {\n        if (i > 0)\n          text.append(QUERY_SEPARATOR);\n        text.append(QUERY_STRING);\n        text.append(labels[i]);\n        text.append(QUERY_STRING);\n      }\n      text.append(QUERY_LABEL_END);\n    }\n  }","id":75942,"modified_method":"protected void manageLabels(final boolean usedWhere, final StringBuilder text) {\n    if (labels != null && labels.length > 0) {\n\n      if( !usedWhere ){\n        // APPEND WHERE\n        text.append(QUERY_WHERE);\n      } else\n        text.append(QUERY_FILTER_AND);\n\n      text.append(QUERY_LABEL_BEGIN);\n      for (int i = 0; i < labels.length; ++i) {\n        if (i > 0)\n          text.append(QUERY_SEPARATOR);\n        text.append(QUERY_STRING);\n        text.append(labels[i]);\n        text.append(QUERY_STRING);\n      }\n      text.append(QUERY_LABEL_END);\n    }\n  }","commit_id":"8fe1b073e8dc74e5e3822be123c063163f021f22","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\n  protected void manageFilters(final StringBuilder text) {\n    boolean firstPredicate = true;\n    for (HasContainer has : hasContainers) {\n      if (!firstPredicate)\n        text.append(QUERY_FILTER_AND);\n      else\n        firstPredicate = false;\n\n      if (has.predicate instanceof Contains) {\n        // IN AND NOT_IN\n        if (has.predicate == Contains.NOT_IN) {\n          text.append(OPERATOR_NOT);\n          text.append(PARENTHESIS_BEGIN);\n        }\n        text.append(has.key);\n\n        if (has.value instanceof String) {\n          text.append(OPERATOR_LIKE);\n          generateFilterValue(text, has.value);\n        } else {\n          text.append(OPERATOR_IN);\n          text.append(COLLECTION_BEGIN);\n\n          boolean firstItem = true;\n          for (Object o : (Collection<Object>) has.value) {\n            if (!firstItem)\n              text.append(QUERY_SEPARATOR);\n            else\n              firstItem = false;\n            generateFilterValue(text, o);\n          }\n\n          text.append(COLLECTION_END);\n        }\n\n        if (has.predicate == Contains.NOT_IN)\n          text.append(PARENTHESIS_END);\n      } else {\n        // ANY OTHER OPERATORS\n        text.append(has.key);\n        text.append(SPACE);\n\n        if (has.predicate instanceof com.tinkerpop.blueprints.Compare) {\n          final com.tinkerpop.blueprints.Compare compare = (com.tinkerpop.blueprints.Compare) has.predicate;\n          switch (compare) {\n          case EQUAL:\n            if (has.value == null)\n              // IS\n              text.append(OPERATOR_IS);\n            else\n              // EQUALS\n              text.append(OPERATOR_EQUALS);\n            break;\n          case GREATER_THAN:\n            text.append(OPERATOR_GT);\n            break;\n          case GREATER_THAN_EQUAL:\n            text.append(OPERATOR_GTE);\n            break;\n          case LESS_THAN:\n            text.append(OPERATOR_LT);\n            break;\n          case LESS_THAN_EQUAL:\n            text.append(OPERATOR_LET);\n            break;\n          case NOT_EQUAL:\n            if (has.value == null)\n              text.append(OPERATOR_IS_NOT);\n            else\n              text.append(OPERATOR_DIFFERENT);\n            break;\n          }\n          text.append(SPACE);\n          generateFilterValue(text, has.value);\n        }\n\n        if (has.value instanceof Collection<?>)\n          text.append(PARENTHESIS_END);\n      }\n    }\n  }","id":75943,"modified_method":"@SuppressWarnings(\"unchecked\")\n  protected boolean manageFilters(final StringBuilder text) {\n    boolean firstPredicate = true;\n    for (HasContainer has : hasContainers) {\n      if (!firstPredicate)\n        text.append(QUERY_FILTER_AND);\n      else {\n        text.append(QUERY_WHERE);\n        firstPredicate = false;\n      }\n\n      if (has.predicate instanceof Contains) {\n        // IN AND NOT_IN\n        if (has.predicate == Contains.NOT_IN) {\n          text.append(OPERATOR_NOT);\n          text.append(PARENTHESIS_BEGIN);\n        }\n        text.append(has.key);\n\n        if (has.value instanceof String) {\n          text.append(OPERATOR_LIKE);\n          generateFilterValue(text, has.value);\n        } else {\n          text.append(OPERATOR_IN);\n          text.append(COLLECTION_BEGIN);\n\n          boolean firstItem = true;\n          for (Object o : (Collection<Object>) has.value) {\n            if (!firstItem)\n              text.append(QUERY_SEPARATOR);\n            else\n              firstItem = false;\n            generateFilterValue(text, o);\n          }\n\n          text.append(COLLECTION_END);\n        }\n\n        if (has.predicate == Contains.NOT_IN)\n          text.append(PARENTHESIS_END);\n      } else {\n        // ANY OTHER OPERATORS\n        text.append(has.key);\n        text.append(SPACE);\n\n        if (has.predicate instanceof com.tinkerpop.blueprints.Compare) {\n          final com.tinkerpop.blueprints.Compare compare = (com.tinkerpop.blueprints.Compare) has.predicate;\n          switch (compare) {\n          case EQUAL:\n            if (has.value == null)\n              // IS\n              text.append(OPERATOR_IS);\n            else\n              // EQUALS\n              text.append(OPERATOR_EQUALS);\n            break;\n          case GREATER_THAN:\n            text.append(OPERATOR_GT);\n            break;\n          case GREATER_THAN_EQUAL:\n            text.append(OPERATOR_GTE);\n            break;\n          case LESS_THAN:\n            text.append(OPERATOR_LT);\n            break;\n          case LESS_THAN_EQUAL:\n            text.append(OPERATOR_LET);\n            break;\n          case NOT_EQUAL:\n            if (has.value == null)\n              text.append(OPERATOR_IS_NOT);\n            else\n              text.append(OPERATOR_DIFFERENT);\n            break;\n          }\n          text.append(SPACE);\n          generateFilterValue(text, has.value);\n        }\n\n        if (has.value instanceof Collection<?>)\n          text.append(PARENTHESIS_END);\n      }\n    }\n    return !firstPredicate;\n  }","commit_id":"8fe1b073e8dc74e5e3822be123c063163f021f22","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n   * \n   * Returns the result set of the query as iterable edges.\n   */\n  @Override\n  public Iterable<Edge> edges() {\n    if (limit == 0)\n      return Collections.emptyList();\n\n    if (((OrientBaseGraph) graph).getRawGraph().getTransaction().isActive())\n      // INSIDE TRANSACTION QUERY DOESN'T SEE IN MEMORY CHANGES, UNTIL\n      // SUPPORTED USED THE BASIC IMPL\n      return new OrientGraphQueryIterable<Edge>(false, labels);\n\n    if (((OrientBaseGraph) graph).isUseLightweightEdges())\n      return new OrientGraphQueryIterable<Edge>(false, labels);\n\n    final StringBuilder text = new StringBuilder();\n\n    // GO DIRECTLY AGAINST E CLASS AND SUB-CLASSES\n    text.append(QUERY_SELECT_FROM);\n\n    if (((OrientBaseGraph) graph).isUseClassForEdgeLabel() && labels != null && labels.length > 0) {\n      // FILTER PER CLASS SAVING CHECKING OF LABEL PROPERTY\n      if (labels.length == 1)\n        // USE THE CLASS NAME\n        text.append(OrientBaseGraph.encodeClassName(labels[0]));\n      else {\n        // MULTIPLE CLASSES NOT SUPPORTED DIRECTLY: CREATE A SUB-QUERY\n        return new OrientGraphQueryIterable<Edge>(false, labels);\n      }\n    } else\n      text.append(OrientEdgeType.CLASS_NAME);\n\n    // APPEND ALWAYS WHERE 1=1 TO MAKE CONCATENATING EASIER\n    text.append(QUERY_WHERE);\n\n    manageFilters(text);\n    if (!((OrientBaseGraph) graph).isUseClassForEdgeLabel())\n      manageLabels(text);\n\n    final OSQLSynchQuery<OIdentifiable> query = new OSQLSynchQuery<OIdentifiable>(text.toString());\n\n    if (fetchPlan != null)\n      query.setFetchPlan(fetchPlan);\n\n    if (limit > 0 && limit < Long.MAX_VALUE)\n      query.setLimit((int) limit);\n\n    return new OrientElementIterable<Edge>(((OrientBaseGraph) graph), ((OrientBaseGraph) graph).getRawGraph().query(query));\n  }","id":75944,"modified_method":"/**\n   * \n   * Returns the result set of the query as iterable edges.\n   */\n  @Override\n  public Iterable<Edge> edges() {\n    if (limit == 0)\n      return Collections.emptyList();\n\n    if (((OrientBaseGraph) graph).getRawGraph().getTransaction().isActive())\n      // INSIDE TRANSACTION QUERY DOESN'T SEE IN MEMORY CHANGES, UNTIL\n      // SUPPORTED USED THE BASIC IMPL\n      return new OrientGraphQueryIterable<Edge>(false, labels);\n\n    if (((OrientBaseGraph) graph).isUseLightweightEdges())\n      return new OrientGraphQueryIterable<Edge>(false, labels);\n\n    final StringBuilder text = new StringBuilder();\n\n    // GO DIRECTLY AGAINST E CLASS AND SUB-CLASSES\n    text.append(QUERY_SELECT_FROM);\n\n    if (((OrientBaseGraph) graph).isUseClassForEdgeLabel() && labels != null && labels.length > 0) {\n      // FILTER PER CLASS SAVING CHECKING OF LABEL PROPERTY\n      if (labels.length == 1)\n        // USE THE CLASS NAME\n        text.append(OrientBaseGraph.encodeClassName(labels[0]));\n      else {\n        // MULTIPLE CLASSES NOT SUPPORTED DIRECTLY: CREATE A SUB-QUERY\n        return new OrientGraphQueryIterable<Edge>(false, labels);\n      }\n    } else\n      text.append(OrientEdgeType.CLASS_NAME);\n\n    final boolean usedWhere = manageFilters(text);\n    if (!((OrientBaseGraph) graph).isUseClassForEdgeLabel())\n      manageLabels(usedWhere, text);\n\n    final OSQLSynchQuery<OIdentifiable> query = new OSQLSynchQuery<OIdentifiable>(text.toString());\n\n    if (fetchPlan != null)\n      query.setFetchPlan(fetchPlan);\n\n    if (limit > 0 && limit < Long.MAX_VALUE)\n      query.setLimit((int) limit);\n\n    return new OrientElementIterable<Edge>(((OrientBaseGraph) graph), ((OrientBaseGraph) graph).getRawGraph().query(query));\n  }","commit_id":"235e5a136c52c6e40531d4da3fb9bac35f8ea2b1","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\n  protected void manageFilters(final StringBuilder text) {\n    boolean firstPredicate = true;\n    for (HasContainer has : hasContainers) {\n      if (!firstPredicate)\n        text.append(QUERY_FILTER_AND);\n      else\n        firstPredicate = false;\n\n      if (has.predicate instanceof Contains) {\n        // IN AND NOT_IN\n        if (has.predicate == Contains.NOT_IN) {\n          text.append(OPERATOR_NOT);\n          text.append(PARENTHESIS_BEGIN);\n        }\n        text.append(has.key);\n\n        if (has.value instanceof String) {\n          text.append(OPERATOR_LIKE);\n          generateFilterValue(text, has.value);\n        } else {\n          text.append(OPERATOR_IN);\n          text.append(COLLECTION_BEGIN);\n\n          boolean firstItem = true;\n          for (Object o : (Collection<Object>) has.value) {\n            if (!firstItem)\n              text.append(QUERY_SEPARATOR);\n            else\n              firstItem = false;\n            generateFilterValue(text, o);\n          }\n\n          text.append(COLLECTION_END);\n        }\n\n        if (has.predicate == Contains.NOT_IN)\n          text.append(PARENTHESIS_END);\n      } else {\n        // ANY OTHER OPERATORS\n        text.append(has.key);\n        text.append(SPACE);\n\n        if (has.predicate instanceof com.tinkerpop.blueprints.Compare) {\n          final com.tinkerpop.blueprints.Compare compare = (com.tinkerpop.blueprints.Compare) has.predicate;\n          switch (compare) {\n          case EQUAL:\n            if (has.value == null)\n              // IS\n              text.append(OPERATOR_IS);\n            else\n              // EQUALS\n              text.append(OPERATOR_EQUALS);\n            break;\n          case GREATER_THAN:\n            text.append(OPERATOR_GT);\n            break;\n          case GREATER_THAN_EQUAL:\n            text.append(OPERATOR_GTE);\n            break;\n          case LESS_THAN:\n            text.append(OPERATOR_LT);\n            break;\n          case LESS_THAN_EQUAL:\n            text.append(OPERATOR_LET);\n            break;\n          case NOT_EQUAL:\n            if (has.value == null)\n              text.append(OPERATOR_IS_NOT);\n            else\n              text.append(OPERATOR_DIFFERENT);\n            break;\n          }\n          text.append(SPACE);\n          generateFilterValue(text, has.value);\n        }\n\n        if (has.value instanceof Collection<?>)\n          text.append(PARENTHESIS_END);\n      }\n    }\n  }","id":75945,"modified_method":"@SuppressWarnings(\"unchecked\")\n  protected boolean manageFilters(final StringBuilder text) {\n    boolean firstPredicate = true;\n    for (HasContainer has : hasContainers) {\n      if (!firstPredicate)\n        text.append(QUERY_FILTER_AND);\n      else {\n        text.append(QUERY_WHERE);\n        firstPredicate = false;\n      }\n\n      if (has.predicate instanceof Contains) {\n        // IN AND NOT_IN\n        if (has.predicate == Contains.NOT_IN) {\n          text.append(OPERATOR_NOT);\n          text.append(PARENTHESIS_BEGIN);\n        }\n        text.append(has.key);\n\n        if (has.value instanceof String) {\n          text.append(OPERATOR_LIKE);\n          generateFilterValue(text, has.value);\n        } else {\n          text.append(OPERATOR_IN);\n          text.append(COLLECTION_BEGIN);\n\n          boolean firstItem = true;\n          for (Object o : (Collection<Object>) has.value) {\n            if (!firstItem)\n              text.append(QUERY_SEPARATOR);\n            else\n              firstItem = false;\n            generateFilterValue(text, o);\n          }\n\n          text.append(COLLECTION_END);\n        }\n\n        if (has.predicate == Contains.NOT_IN)\n          text.append(PARENTHESIS_END);\n      } else {\n        // ANY OTHER OPERATORS\n        text.append(has.key);\n        text.append(SPACE);\n\n        if (has.predicate instanceof com.tinkerpop.blueprints.Compare) {\n          final com.tinkerpop.blueprints.Compare compare = (com.tinkerpop.blueprints.Compare) has.predicate;\n          switch (compare) {\n          case EQUAL:\n            if (has.value == null)\n              // IS\n              text.append(OPERATOR_IS);\n            else\n              // EQUALS\n              text.append(OPERATOR_EQUALS);\n            break;\n          case GREATER_THAN:\n            text.append(OPERATOR_GT);\n            break;\n          case GREATER_THAN_EQUAL:\n            text.append(OPERATOR_GTE);\n            break;\n          case LESS_THAN:\n            text.append(OPERATOR_LT);\n            break;\n          case LESS_THAN_EQUAL:\n            text.append(OPERATOR_LET);\n            break;\n          case NOT_EQUAL:\n            if (has.value == null)\n              text.append(OPERATOR_IS_NOT);\n            else\n              text.append(OPERATOR_DIFFERENT);\n            break;\n          }\n          text.append(SPACE);\n          generateFilterValue(text, has.value);\n        }\n\n        if (has.value instanceof Collection<?>)\n          text.append(PARENTHESIS_END);\n      }\n    }\n    return !firstPredicate;\n  }","commit_id":"235e5a136c52c6e40531d4da3fb9bac35f8ea2b1","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n   * Returns the result set of the query as iterable vertices.\n   */\n  @Override\n  public Iterable<Vertex> vertices() {\n    if (limit == 0)\n      return Collections.emptyList();\n\n    if (((OrientBaseGraph) graph).getRawGraph().getTransaction().isActive())\n      // INSIDE TRANSACTION QUERY DOESN'T SEE IN MEMORY CHANGES, UNTIL\n      // SUPPORTED USED THE BASIC IMPL\n      return new OrientGraphQueryIterable<Vertex>(true, labels);\n\n    final StringBuilder text = new StringBuilder();\n\n    // GO DIRECTLY AGAINST E CLASS AND SUB-CLASSES\n    text.append(QUERY_SELECT_FROM);\n\n    if (((OrientBaseGraph) graph).isUseClassForVertexLabel() && labels != null && labels.length > 0) {\n      // FILTER PER CLASS SAVING CHECKING OF LABEL PROPERTY\n      if (labels.length == 1)\n        // USE THE CLASS NAME\n        text.append(OrientBaseGraph.encodeClassName(labels[0]));\n      else {\n        // MULTIPLE CLASSES NOT SUPPORTED DIRECTLY: CREATE A SUB-QUERY\n        return new OrientGraphQueryIterable<Vertex>(true, labels);\n      }\n    } else\n      text.append(OrientVertexType.CLASS_NAME);\n\n    // APPEND ALWAYS WHERE\n    text.append(QUERY_WHERE);\n    manageFilters(text);\n    if (!((OrientBaseGraph) graph).isUseClassForVertexLabel())\n      manageLabels(text);\n\n    if (orderBy.length() > 1) {\n      text.append(ORDERBY);\n      text.append(orderBy);\n      text.append(\" \" + orderByDir + \" \");\n    }\n    if (skip > 0 && skip < Long.MAX_VALUE) {\n      text.append(SKIP);\n      text.append(skip);\n    }\n\n    if (limit > 0 && limit < Long.MAX_VALUE) {\n      text.append(LIMIT);\n      text.append(limit);\n    }\n\n    final OSQLSynchQuery<OIdentifiable> query = new OSQLSynchQuery<OIdentifiable>(text.toString());\n\n    if (fetchPlan != null)\n      query.setFetchPlan(fetchPlan);\n\n    return new OrientElementIterable<Vertex>(((OrientBaseGraph) graph), ((OrientBaseGraph) graph).getRawGraph().query(query));\n  }","id":75946,"modified_method":"/**\n   * Returns the result set of the query as iterable vertices.\n   */\n  @Override\n  public Iterable<Vertex> vertices() {\n    if (limit == 0)\n      return Collections.emptyList();\n\n    if (((OrientBaseGraph) graph).getRawGraph().getTransaction().isActive())\n      // INSIDE TRANSACTION QUERY DOESN'T SEE IN MEMORY CHANGES, UNTIL\n      // SUPPORTED USED THE BASIC IMPL\n      return new OrientGraphQueryIterable<Vertex>(true, labels);\n\n    final StringBuilder text = new StringBuilder();\n\n    // GO DIRECTLY AGAINST E CLASS AND SUB-CLASSES\n    text.append(QUERY_SELECT_FROM);\n\n    if (((OrientBaseGraph) graph).isUseClassForVertexLabel() && labels != null && labels.length > 0) {\n      // FILTER PER CLASS SAVING CHECKING OF LABEL PROPERTY\n      if (labels.length == 1)\n        // USE THE CLASS NAME\n        text.append(OrientBaseGraph.encodeClassName(labels[0]));\n      else {\n        // MULTIPLE CLASSES NOT SUPPORTED DIRECTLY: CREATE A SUB-QUERY\n        return new OrientGraphQueryIterable<Vertex>(true, labels);\n      }\n    } else\n      text.append(OrientVertexType.CLASS_NAME);\n\n    final boolean usedWhere = manageFilters(text);\n    if (!((OrientBaseGraph) graph).isUseClassForVertexLabel())\n      manageLabels(usedWhere, text);\n\n    if (orderBy.length() > 1) {\n      text.append(ORDERBY);\n      text.append(orderBy);\n      text.append(\" \" + orderByDir + \" \");\n    }\n    if (skip > 0 && skip < Long.MAX_VALUE) {\n      text.append(SKIP);\n      text.append(skip);\n    }\n\n    if (limit > 0 && limit < Long.MAX_VALUE) {\n      text.append(LIMIT);\n      text.append(limit);\n    }\n\n    final OSQLSynchQuery<OIdentifiable> query = new OSQLSynchQuery<OIdentifiable>(text.toString());\n\n    if (fetchPlan != null)\n      query.setFetchPlan(fetchPlan);\n\n    return new OrientElementIterable<Vertex>(((OrientBaseGraph) graph), ((OrientBaseGraph) graph).getRawGraph().query(query));\n  }","commit_id":"235e5a136c52c6e40531d4da3fb9bac35f8ea2b1","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void manageLabels(final StringBuilder text) {\n    if (labels != null && labels.length > 0) {\n      // APPEND LABELS\n      text.append(QUERY_LABEL_BEGIN);\n      for (int i = 0; i < labels.length; ++i) {\n        if (i > 0)\n          text.append(QUERY_SEPARATOR);\n        text.append(QUERY_STRING);\n        text.append(labels[i]);\n        text.append(QUERY_STRING);\n      }\n      text.append(QUERY_LABEL_END);\n    }\n  }","id":75947,"modified_method":"protected void manageLabels(final boolean usedWhere, final StringBuilder text) {\n    if (labels != null && labels.length > 0) {\n\n      if( !usedWhere ){\n        // APPEND WHERE\n        text.append(QUERY_WHERE);\n      } else\n        text.append(QUERY_FILTER_AND);\n\n      text.append(QUERY_LABEL_BEGIN);\n      for (int i = 0; i < labels.length; ++i) {\n        if (i > 0)\n          text.append(QUERY_SEPARATOR);\n        text.append(QUERY_STRING);\n        text.append(labels[i]);\n        text.append(QUERY_STRING);\n      }\n      text.append(QUERY_LABEL_END);\n    }\n  }","commit_id":"235e5a136c52c6e40531d4da3fb9bac35f8ea2b1","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void registerUncommittedGauge(MetricRegistry metricRegistry, String name) {\n        try {\n            metricRegistry.register(name,\n                                    new Gauge<Long>() {\n                                        @Override\n                                        public Long getValue() {\n                                            return Math.max(0, getLogEndOffset() - 1 - committedOffset.get());\n                                        }\n                                    });\n        } catch (IllegalArgumentException ignored) {\n            // already registered, we'll ignore that.\n        }\n    }","id":75948,"modified_method":"private void registerUncommittedGauge(MetricRegistry metricRegistry, String name) {\n        try {\n            metricRegistry.register(name,\n                    (Gauge<Long>) () -> Math.max(0, getLogEndOffset() - 1 - committedOffset.get()));\n        } catch (IllegalArgumentException ignored) {\n            // already registered, we'll ignore that.\n        }\n    }","commit_id":"8162ade3bf1f294a7999bdacf77745030627420d","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n        public void run() {\n            // Do not write the file if committedOffset has never been updated.\n            if (committedOffset.get() == DEFAULT_COMMITTED_OFFSET) {\n                return;\n            }\n            try (final FileOutputStream fos = new FileOutputStream(committedReadOffsetFile)) {\n                fos.write(String.valueOf(committedOffset.get()).getBytes(Charsets.UTF_8));\n                // flush stream\n                fos.flush();\n                // actually sync to disk\n                fos.getFD().sync();\n            } catch (SyncFailedException e) {\n                LOG.error(\"Cannot sync \" + committedReadOffsetFile.getAbsolutePath() + \" to disk. Continuing anyway,\" +\n                        \" but there is no guarantee that the file has been written.\", e);\n            } catch (IOException e) {\n                LOG.error(\"Cannot write \" + committedReadOffsetFile.getAbsolutePath() + \" to disk.\", e);\n            }\n        }","id":75949,"modified_method":"@Override\n        public void run() {\n            // Do not write the file if committedOffset has never been updated.\n            if (committedOffset.get() == DEFAULT_COMMITTED_OFFSET) {\n                return;\n            }\n            try (final FileOutputStream fos = new FileOutputStream(committedReadOffsetFile)) {\n                fos.write(String.valueOf(committedOffset.get()).getBytes(StandardCharsets.UTF_8));\n                // flush stream\n                fos.flush();\n                // actually sync to disk\n                fos.getFD().sync();\n            } catch (SyncFailedException e) {\n                LOG.error(\"Cannot sync \" + committedReadOffsetFile.getAbsolutePath() + \" to disk. Continuing anyway,\" +\n                        \" but there is no guarantee that the file has been written.\", e);\n            } catch (IOException e) {\n                LOG.error(\"Cannot write \" + committedReadOffsetFile.getAbsolutePath() + \" to disk.\", e);\n            }\n        }","commit_id":"8162ade3bf1f294a7999bdacf77745030627420d","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public List<JournalReadEntry> read(long readOffset, long requestedMaximumCount) {\n        // Always read at least one!\n        final long maximumCount = Math.max(1, requestedMaximumCount);\n        long maxOffset = readOffset + maximumCount;\n        final List<JournalReadEntry> messages = Lists.newArrayListWithCapacity((int) (maximumCount));\n\n        if (shuttingDown) {\n            return messages;\n        }\n        try (Timer.Context ignored = readTime.time()) {\n            final long logStartOffset = getLogStartOffset();\n\n            if (readOffset < logStartOffset) {\n                LOG.error(\n                        \"Read offset {} before start of log at {}, starting to read from the beginning of the journal.\",\n                        readOffset,\n                        logStartOffset);\n                readOffset = logStartOffset;\n                maxOffset = readOffset + maximumCount;\n            }\n            LOG.debug(\"Requesting to read a maximum of {} messages (or 5MB) from the journal, offset interval [{}, {})\",\n                    maximumCount, readOffset, maxOffset);\n\n            // TODO benchmark and make read-ahead strategy configurable for performance tuning\n            final MessageSet messageSet = kafkaLog.read(readOffset,\n                    5 * 1024 * 1024,\n                    Option.<Object>apply(maxOffset)).messageSet();\n\n            final Iterator<MessageAndOffset> iterator = messageSet.iterator();\n            long firstOffset = Long.MIN_VALUE;\n            long lastOffset = Long.MIN_VALUE;\n            long totalBytes = 0;\n            while (iterator.hasNext()) {\n                final MessageAndOffset messageAndOffset = iterator.next();\n\n                if (firstOffset == Long.MIN_VALUE) firstOffset = messageAndOffset.offset();\n                // always remember the last seen offset for debug purposes below\n                lastOffset = messageAndOffset.offset();\n\n                final byte[] payloadBytes = Utils.readBytes(messageAndOffset.message().payload());\n                if (LOG.isTraceEnabled()) {\n                    final byte[] keyBytes = Utils.readBytes(messageAndOffset.message().key());\n                    LOG.trace(\"Read message {} contains {}\", bytesToHex(keyBytes), bytesToHex(payloadBytes));\n                }\n                totalBytes += payloadBytes.length;\n                messages.add(new JournalReadEntry(payloadBytes, messageAndOffset.offset()));\n                // remember where to read from\n                nextReadOffset = messageAndOffset.nextOffset();\n            }\n            if (messages.isEmpty()) {\n                LOG.debug(\"No messages available to read for offset interval [{}, {}).\", readOffset, maxOffset);\n            } else {\n                LOG.debug(\n                        \"Read {} messages, total payload size {}, from journal, offset interval [{}, {}], requested read at {}\",\n                        messages.size(),\n                        totalBytes,\n                        firstOffset,\n                        lastOffset,\n                        readOffset);\n            }\n\n        } catch (OffsetOutOfRangeException e) {\n            // This is fine, the reader tries to read faster than the writer commited data. Next read will get the data.\n            LOG.debug(\"Offset out of range, no messages available starting at offset {}\", readOffset);\n        } catch (Exception e) {\n            // the scala code does not declare the IOException in kafkaLog.read() so we can't catch it here\n            // sigh.\n            if (shuttingDown) {\n                LOG.debug(\"Caught exception during shutdown, ignoring it because we might have been blocked on a read.\");\n                return Lists.newArrayList();\n            }\n            //noinspection ConstantConditions\n            if (e instanceof ClosedByInterruptException) {\n                LOG.debug(\"Interrupted while reading from journal, during shutdown this is harmless and ignored.\", e);\n            } else {\n                throw e;\n            }\n\n        }\n        readMessages.mark(messages.size());\n        return messages;\n    }","id":75950,"modified_method":"public List<JournalReadEntry> read(long readOffset, long requestedMaximumCount) {\n        // Always read at least one!\n        final long maximumCount = Math.max(1, requestedMaximumCount);\n        long maxOffset = readOffset + maximumCount;\n\n        if (shuttingDown) {\n            return Collections.emptyList();\n        }\n        final List<JournalReadEntry> messages = new ArrayList<>(Ints.saturatedCast(maximumCount));\n        try (Timer.Context ignored = readTime.time()) {\n            final long logStartOffset = getLogStartOffset();\n\n            if (readOffset < logStartOffset) {\n                LOG.error(\n                        \"Read offset {} before start of log at {}, starting to read from the beginning of the journal.\",\n                        readOffset,\n                        logStartOffset);\n                readOffset = logStartOffset;\n                maxOffset = readOffset + maximumCount;\n            }\n            LOG.debug(\"Requesting to read a maximum of {} messages (or 5MB) from the journal, offset interval [{}, {})\",\n                    maximumCount, readOffset, maxOffset);\n\n            // TODO benchmark and make read-ahead strategy configurable for performance tuning\n            final MessageSet messageSet = kafkaLog.read(readOffset,\n                    5 * 1024 * 1024,\n                    Option.<Object>apply(maxOffset)).messageSet();\n\n            final Iterator<MessageAndOffset> iterator = messageSet.iterator();\n            long firstOffset = Long.MIN_VALUE;\n            long lastOffset = Long.MIN_VALUE;\n            long totalBytes = 0;\n            while (iterator.hasNext()) {\n                final MessageAndOffset messageAndOffset = iterator.next();\n\n                if (firstOffset == Long.MIN_VALUE) firstOffset = messageAndOffset.offset();\n                // always remember the last seen offset for debug purposes below\n                lastOffset = messageAndOffset.offset();\n\n                final byte[] payloadBytes = ByteBufferUtils.readBytes(messageAndOffset.message().payload());\n                if (LOG.isTraceEnabled()) {\n                    final byte[] keyBytes = ByteBufferUtils.readBytes(messageAndOffset.message().key());\n                    LOG.trace(\"Read message {} contains {}\", bytesToHex(keyBytes), bytesToHex(payloadBytes));\n                }\n                totalBytes += payloadBytes.length;\n                messages.add(new JournalReadEntry(payloadBytes, messageAndOffset.offset()));\n                // remember where to read from\n                nextReadOffset = messageAndOffset.nextOffset();\n            }\n            if (messages.isEmpty()) {\n                LOG.debug(\"No messages available to read for offset interval [{}, {}).\", readOffset, maxOffset);\n            } else {\n                LOG.debug(\n                        \"Read {} messages, total payload size {}, from journal, offset interval [{}, {}], requested read at {}\",\n                        messages.size(),\n                        totalBytes,\n                        firstOffset,\n                        lastOffset,\n                        readOffset);\n            }\n\n        } catch (OffsetOutOfRangeException e) {\n            // This is fine, the reader tries to read faster than the writer committed data. Next read will get the data.\n            LOG.debug(\"Offset out of range, no messages available starting at offset {}\", readOffset);\n        } catch (Exception e) {\n            // the scala code does not declare the IOException in kafkaLog.read() so we can't catch it here\n            // sigh.\n            if (shuttingDown) {\n                LOG.debug(\"Caught exception during shutdown, ignoring it because we might have been blocked on a read.\");\n                return Collections.emptyList();\n            }\n            //noinspection ConstantConditions\n            if (e instanceof ClosedByInterruptException) {\n                LOG.debug(\"Interrupted while reading from journal, during shutdown this is harmless and ignored.\", e);\n            } else {\n                throw e;\n            }\n\n        }\n        readMessages.mark(messages.size());\n        return messages;\n    }","commit_id":"8162ade3bf1f294a7999bdacf77745030627420d","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"/**\n     * Writes the list of entries to the journal.\n     *\n     * @param entries journal entries to be written\n     * @return the last position written to in the journal\n     */\n    @Override\n    public long write(List<Entry> entries) {\n        try (Timer.Context ignored = writeTime.time()) {\n            long payloadSize = 0L;\n\n            final List<Message> messages = Lists.newArrayListWithCapacity(entries.size());\n            for (final Entry entry : entries) {\n                final byte[] messageBytes = entry.getMessageBytes();\n                final byte[] idBytes = entry.getIdBytes();\n\n                payloadSize += messageBytes.length;\n                messages.add(new Message(messageBytes, idBytes));\n\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"Message {} contains bytes {}\", bytesToHex(idBytes), bytesToHex(messageBytes));\n                }\n            }\n\n            final ByteBufferMessageSet messageSet = new ByteBufferMessageSet(JavaConversions.asScalaBuffer(messages));\n\n            final Log.LogAppendInfo appendInfo = kafkaLog.append(messageSet, true);\n            long lastWriteOffset = appendInfo.lastOffset();\n            LOG.debug(\"Wrote {} messages to journal: {} bytes, log position {} to {}\",\n                    entries.size(), payloadSize, appendInfo.firstOffset(), lastWriteOffset);\n            writtenMessages.mark(entries.size());\n            return lastWriteOffset;\n        }\n    }","id":75951,"modified_method":"/**\n     * Writes the list of entries to the journal.\n     *\n     * @param entries journal entries to be written\n     * @return the last position written to in the journal\n     */\n    @Override\n    public long write(List<Entry> entries) {\n        try (Timer.Context ignored = writeTime.time()) {\n            long payloadSize = 0L;\n\n            final List<Message> messages = new ArrayList<>(entries.size());\n            for (final Entry entry : entries) {\n                final byte[] messageBytes = entry.getMessageBytes();\n                final byte[] idBytes = entry.getIdBytes();\n\n                payloadSize += messageBytes.length;\n                messages.add(new Message(messageBytes, idBytes));\n\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"Message {} contains bytes {}\", bytesToHex(idBytes), bytesToHex(messageBytes));\n                }\n            }\n\n            final ByteBufferMessageSet messageSet = new ByteBufferMessageSet(JavaConversions.asScalaBuffer(messages).toSeq());\n\n            final LogAppendInfo appendInfo = kafkaLog.append(messageSet, true);\n            long lastWriteOffset = appendInfo.lastOffset();\n            LOG.debug(\"Wrote {} messages to journal: {} bytes, log position {} to {}\",\n                    entries.size(), payloadSize, appendInfo.firstOffset(), lastWriteOffset);\n            writtenMessages.mark(entries.size());\n            return lastWriteOffset;\n        }\n    }","commit_id":"8162ade3bf1f294a7999bdacf77745030627420d","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private Timer registerHdrTimer(MetricRegistry metricRegistry, final String metricName) {\n        Timer timer;\n        try {\n            timer = metricRegistry.register(metricName, new HdrTimer(1, TimeUnit.MINUTES, 1));\n        } catch (IllegalArgumentException e) {\n            final SortedMap<String, Timer> timers = metricRegistry.getTimers(new MetricFilter() {\n                @Override\n                public boolean matches(String name, Metric metric) {\n                    return metricName.equals(name);\n                }\n            });\n            timer = Iterables.getOnlyElement(timers.values());\n        }\n        return timer;\n    }","id":75952,"modified_method":"private Timer registerHdrTimer(MetricRegistry metricRegistry, final String metricName) {\n        Timer timer;\n        try {\n            timer = metricRegistry.register(metricName, new HdrTimer(1, TimeUnit.MINUTES, 1));\n        } catch (IllegalArgumentException e) {\n            final SortedMap<String, Timer> timers = metricRegistry.getTimers((name, metric) -> metricName.equals(name));\n            timer = Iterables.getOnlyElement(timers.values());\n        }\n        return timer;\n    }","commit_id":"8162ade3bf1f294a7999bdacf77745030627420d","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private void setupKafkaLogMetrics(final MetricRegistry metricRegistry) {\n        metricRegistry.register(name(KafkaJournal.class, \"size\"), new Gauge<Long>() {\n            @Override\n            public Long getValue() {\n                return kafkaLog.size();\n            }\n        });\n        metricRegistry.register(name(KafkaJournal.class, \"logEndOffset\"), new Gauge<Long>() {\n            @Override\n            public Long getValue() {\n                return kafkaLog.logEndOffset();\n            }\n        });\n        metricRegistry.register(name(KafkaJournal.class, \"numberOfSegments\"), new Gauge<Integer>() {\n            @Override\n            public Integer getValue() {\n                return kafkaLog.numberOfSegments();\n            }\n        });\n        metricRegistry.register(name(KafkaJournal.class, \"unflushedMessages\"), new Gauge<Long>() {\n            @Override\n            public Long getValue() {\n                return kafkaLog.unflushedMessages();\n            }\n        });\n        metricRegistry.register(name(KafkaJournal.class, \"recoveryPoint\"), new Gauge<Long>() {\n            @Override\n            public Long getValue() {\n                return kafkaLog.recoveryPoint();\n            }\n        });\n        metricRegistry.register(name(KafkaJournal.class, \"lastFlushTime\"), new Gauge<Long>() {\n            @Override\n            public Long getValue() {\n                return kafkaLog.lastFlushTime();\n            }\n        });\n        metricRegistry.register(GlobalMetricNames.JOURNAL_OLDEST_SEGMENT, new Gauge<Date>() {\n            @Override\n            public Date getValue() {\n                long oldestSegment = Long.MAX_VALUE;\n                for (final LogSegment segment : getSegments()) {\n                    oldestSegment = Math.min(oldestSegment, segment.created());\n                }\n\n                return new Date(oldestSegment);\n            }\n        });\n    }","id":75953,"modified_method":"private void setupKafkaLogMetrics(final MetricRegistry metricRegistry) {\n        metricRegistry.register(name(KafkaJournal.class, \"size\"), (Gauge<Long>) kafkaLog::size);\n        metricRegistry.register(name(KafkaJournal.class, \"logEndOffset\"), (Gauge<Long>) kafkaLog::logEndOffset);\n        metricRegistry.register(name(KafkaJournal.class, \"numberOfSegments\"), (Gauge<Integer>) kafkaLog::numberOfSegments);\n        metricRegistry.register(name(KafkaJournal.class, \"unflushedMessages\"), (Gauge<Long>) kafkaLog::unflushedMessages);\n        metricRegistry.register(name(KafkaJournal.class, \"recoveryPoint\"), (Gauge<Long>) kafkaLog::recoveryPoint);\n        metricRegistry.register(name(KafkaJournal.class, \"lastFlushTime\"), (Gauge<Long>) kafkaLog::lastFlushTime);\n        // must not be a lambda, because the serialization cannot determine the proper Metric type :(\n        metricRegistry.register(GlobalMetricNames.JOURNAL_OLDEST_SEGMENT, (Gauge<Date>) new Gauge<Date>() {\n            @Override\n            public Date getValue() {\n                long oldestSegment = Long.MAX_VALUE;\n                for (final LogSegment segment : KafkaJournal.this.getSegments()) {\n                    oldestSegment = Math.min(oldestSegment, segment.created());\n                }\n\n                return new Date(oldestSegment);\n            }\n        });\n    }","commit_id":"8162ade3bf1f294a7999bdacf77745030627420d","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Test(expected = RuntimeException.class)\n    public void lockedJournalDir() throws Exception {\n        // Grab the lock before starting the KafkaJournal.\n        final File file = new File(journalDirectory, \".lock\");\n        assumeTrue(file.createNewFile());\n        final FileLock fileLock = new FileLock(file);\n        assumeTrue(fileLock.tryLock());\n\n        new KafkaJournal(journalDirectory,\n                scheduler,\n                Size.megabytes(100L),\n                Duration.standardHours(1),\n                Size.megabytes(5L),\n                Duration.standardHours(1),\n                1_000_000,\n                Duration.standardMinutes(1),\n                new MetricRegistry());\n    }","id":75954,"modified_method":"@Test\n    public void lockedJournalDir() throws Exception {\n        // Grab the lock before starting the KafkaJournal.\n        final File file = new File(journalDirectory, \".lock\");\n        assumeTrue(file.createNewFile());\n        final FileLock fileLock = new FileLock(file);\n        assumeTrue(fileLock.tryLock());\n\n        try {\n            new KafkaJournal(journalDirectory,\n                scheduler,\n                Size.megabytes(100L),\n                Duration.standardHours(1),\n                Size.megabytes(5L),\n                Duration.standardHours(1),\n                1_000_000,\n                Duration.standardMinutes(1),\n                new MetricRegistry());\n            fail(\"Expected exception\");\n        } catch (Exception e) {\n            assertThat(e)\n                .isExactlyInstanceOf(RuntimeException.class)\n                .hasMessageStartingWith(\"kafka.common.KafkaException: Failed to acquire lock on file .lock in\")\n                .hasCauseExactlyInstanceOf(KafkaException.class);\n        }\n    }","commit_id":"8162ade3bf1f294a7999bdacf77745030627420d","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Test\n    public void writeAndRead() throws IOException {\n        final Journal journal = new KafkaJournal(journalDirectory,\n                scheduler,\n                Size.megabytes(100L),\n                Duration.standardHours(1),\n                Size.megabytes(5L),\n                Duration.standardHours(1),\n                1_000_000,\n                Duration.standardMinutes(1),\n                new MetricRegistry());\n\n        final byte[] idBytes = \"id\".getBytes(UTF_8);\n        final byte[] messageBytes = \"message\".getBytes(UTF_8);\n\n        final long position = journal.write(idBytes, messageBytes);\n        final List<Journal.JournalReadEntry> messages = journal.read(1);\n\n        final Journal.JournalReadEntry firstMessage = Iterators.getOnlyElement(messages.iterator());\n\n        assertEquals(new String(firstMessage.getPayload(), UTF_8), \"message\");\n    }","id":75955,"modified_method":"@Test\n    public void writeAndRead() throws IOException {\n        final Journal journal = new KafkaJournal(journalDirectory,\n                scheduler,\n                Size.megabytes(100L),\n                Duration.standardHours(1),\n                Size.megabytes(5L),\n                Duration.standardHours(1),\n                1_000_000,\n                Duration.standardMinutes(1),\n                new MetricRegistry());\n\n        final byte[] idBytes = \"id\".getBytes(UTF_8);\n        final byte[] messageBytes = \"message\".getBytes(UTF_8);\n\n        final long position = journal.write(idBytes, messageBytes);\n        final List<Journal.JournalReadEntry> messages = journal.read(1);\n\n        final Journal.JournalReadEntry firstMessage = Iterators.getOnlyElement(messages.iterator());\n\n        assertEquals(\"message\", new String(firstMessage.getPayload(), UTF_8));\n    }","commit_id":"8162ade3bf1f294a7999bdacf77745030627420d","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Test\n    public void readAtLeastOne() throws Exception {\n        final Journal journal = new KafkaJournal(journalDirectory,\n                scheduler,\n                Size.megabytes(100L),\n                Duration.standardHours(1),\n                Size.megabytes(5L),\n                Duration.standardHours(1),\n                1_000_000,\n                Duration.standardMinutes(1),\n                new MetricRegistry());\n\n        final byte[] idBytes = \"id\".getBytes(UTF_8);\n        final byte[] messageBytes = \"message1\".getBytes(UTF_8);\n\n        final long position = journal.write(idBytes, messageBytes);\n\n        // Trying to read 0 should always read at least 1 entry.\n        final List<Journal.JournalReadEntry> messages = journal.read(0);\n\n        final Journal.JournalReadEntry firstMessage = Iterators.getOnlyElement(messages.iterator());\n\n        assertEquals(new String(firstMessage.getPayload(), UTF_8), \"message1\");\n    }","id":75956,"modified_method":"@Test\n    public void readAtLeastOne() throws Exception {\n        final Journal journal = new KafkaJournal(journalDirectory,\n                scheduler,\n                Size.megabytes(100L),\n                Duration.standardHours(1),\n                Size.megabytes(5L),\n                Duration.standardHours(1),\n                1_000_000,\n                Duration.standardMinutes(1),\n                new MetricRegistry());\n\n        final byte[] idBytes = \"id\".getBytes(UTF_8);\n        final byte[] messageBytes = \"message1\".getBytes(UTF_8);\n\n        final long position = journal.write(idBytes, messageBytes);\n\n        // Trying to read 0 should always read at least 1 entry.\n        final List<Journal.JournalReadEntry> messages = journal.read(0);\n\n        final Journal.JournalReadEntry firstMessage = Iterators.getOnlyElement(messages.iterator());\n\n        assertEquals(\"message1\", new String(firstMessage.getPayload(), UTF_8));\n    }","commit_id":"8162ade3bf1f294a7999bdacf77745030627420d","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public AddFriend(String id, final ModalWindow window, final FriendAction friendActionModel, final String userX, final String userY){\n        super(id);\n\n        //get API's\n        sakaiProxy = ProfileApplication.get().getSakaiProxy();\n        profile = ProfileApplication.get().getProfile();\n        \n        //get friendName\n        final String friendName = sakaiProxy.getUserDisplayName(userY);\n        \n        //window setup\n\t\twindow.setTitle(new StringResourceModel(\"title.friend.add\", null, new Object[]{ friendName } )); \n\t\twindow.setInitialHeight(150);\n\t\twindow.setInitialWidth(500);\n\t\twindow.setResizable(false);\n\t\t\n\t\t//is this user allowed to view this person's profile image?\n\t\tboolean isProfileImageAllowed = profile.isUserXProfileImageVisibleByUserY(userY, userX, false);\n\t\t\n\t\t//image\n\t\tadd(new ProfileImageRenderer(\"image\", userY, isProfileImageAllowed, ProfileImageManager.PROFILE_IMAGE_THUMBNAIL, true));\n\t\t\n        //text\n\t\tfinal Label text = new Label(\"text\", new StringResourceModel(\"text.friend.add\", null, new Object[]{ friendName } ));\n        text.setEscapeModelStrings(false);\n        text.setOutputMarkupId(true);\n        add(text);\n                   \n        //setup form\t\t\n\t\tForm form = new Form(\"form\");\n\t\tform.setOutputMarkupId(true);\n\t\t\t\t\n\t\t//submit button\n\t\tAjaxFallbackButton submitButton = new AjaxFallbackButton(\"submit\", new ResourceModel(\"button.friend.add\"), form) {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tprotected void onSubmit(AjaxRequestTarget target, Form form) {\n\t\t\t\t\n\t\t\t\t/* double checking */\n\t\t\t\t\n\t\t\t\t//friend?\n\t\t\t\tif(profile.isUserXFriendOfUserY(userX, userY)) {\n\t\t\t\t\ttext.setModel(new StringResourceModel(\"error.friend.already.confirmed\", null, new Object[]{ friendName } ));\n\t\t\t\t\tthis.setEnabled(false);\n\t\t\t\t\tthis.add(new AttributeModifier(\"class\", true, new Model(\"disabled\")));\n\t\t\t\t\ttarget.addComponent(text);\n\t\t\t\t\ttarget.addComponent(this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//has a friend request already been made to this person?\n\t\t\t\tif(profile.isFriendRequestPending(userX, userY)) {\n\t\t\t\t\ttext.setModel(new StringResourceModel(\"error.friend.already.pending\", null, new Object[]{ friendName } ));\n\t\t\t\t\tthis.setEnabled(false);\n\t\t\t\t\tthis.add(new AttributeModifier(\"class\", true, new Model(\"disabled\")));\n\t\t\t\t\ttarget.addComponent(text);\n\t\t\t\t\ttarget.addComponent(this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//has a friend request been made from this person to the current user?\n\t\t\t\tif(profile.isFriendRequestPending(userY, userX)) {\n\t\t\t\t\ttext.setModel(new StringResourceModel(\"error.friend.already.pending\", null, new Object[]{ friendName } ));\n\t\t\t\t\tthis.setEnabled(false);\n\t\t\t\t\tthis.add(new AttributeModifier(\"class\", true, new Model(\"disabled\")));\n\t\t\t\t\ttarget.addComponent(text);\n\t\t\t\t\ttarget.addComponent(this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//if ok, request friend\n\t\t\t\tif(profile.requestFriend(userX, userY)) {\n\t\t\t\t\tfriendActionModel.setRequested(true);\n\t\t\t\t\t\n\t\t\t\t\t//post event\n\t\t\t\t\tsakaiProxy.postEvent(ProfileUtilityManager.EVENT_FRIEND_REQUEST, \"/profile/\"+userY, true);\n\t\t\t\t\t\n\t\t\t\t\t//if email is enabled for this message type, send email\n\t\t\t\t\tif(profile.isEmailEnabledForThisMessageType(userY, ProfilePreferencesManager.EMAIL_NOTIFICATION_REQUEST)) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t//get some info\n\t\t\t\t        final String currentUserName = sakaiProxy.getUserDisplayName(userX);\n\t\t\t\t        final String serviceName = sakaiProxy.getServiceName();\n\t\t\t\t        final String portalUrl = sakaiProxy.getPortalUrl();\n\t\n\t\t\t\t\t\t//url needs to go to userY's (ie other user) myworkspace and wicket takes them to their MyFriends page\n\t\t\t\t        final String url = sakaiProxy.getDirectUrlToUserProfile(userY, urlFor(MyFriends.class, null).toString());\n\t\n\t\t\t\t        //tinyUrl\n\t\t\t\t        final String tinyUrl = profile.generateTinyUrl(url);\n\t\t\t\t        \n\t\t\t\t\t\t//subject\n\t\t\t\t\t\tfinal String subject = new StringResourceModel(\"email.friend.request.subject\", null, new Object[]{ currentUserName, serviceName } ).getObject().toString();\n\t\t\t\t\t\t\n\t\t\t\t\t\t//email newline\n\t\t\t\t\t\tfinal String newline = ProfileUtilityManager.EMAIL_NEWLINE;\n\t\t\t\t\t\t\n\t\t\t\t\t\t//message\n\t\t\t\t\t\tStringBuilder message = new StringBuilder();\n\t\t\t\t\t\tmessage.append(new StringResourceModel(\"email.friend.request.message\", null, new Object[]{ currentUserName, serviceName }).getObject().toString());\n\t\t\t\t\t\tmessage.append(newline);\n\t\t\t\t\t\tmessage.append(newline);\n\t\t\t\t\t\tmessage.append(new StringResourceModel(\"email.friend.request.link\", null, new Object[]{ currentUserName }).getObject().toString());\n\t\t\t\t\t\tmessage.append(newline);\n\t\t\t\t\t\tmessage.append(new StringResourceModel(\"email.friend.request.link.href\", null, new Object[]{ tinyUrl }).getObject().toString());\n\t\t\t\t\t\tmessage.append(newline);\n\t\t\t\t\t\tmessage.append(newline);\n\t\t\t\t\t\tmessage.append(new StringResourceModel(\"email.footer.1\", this, null).getString());\n\t\t\t\t\t\tmessage.append(newline);\n\t\t\t\t\t\tmessage.append(new StringResourceModel(\"email.footer.2\", null, new Object[]{ serviceName, portalUrl } ).getObject().toString());\n\t\t\t\t\t\tmessage.append(newline);\n\t\t\t\t\t\tmessage.append(new StringResourceModel(\"email.footer.3\", this, null).getString());\n\t\n\t\t\t\t\t\t//send email (this method will format it properly, then send it)\n\t\t\t\t\t\tsakaiProxy.sendEmail(userY, subject, message.toString());\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\twindow.close(target);\n\t\t\t\t} else {\n\t\t\t\t\ttext.setModel(new StringResourceModel(\"error.friend.add.failed\", null, new Object[]{ friendName } ));\n\t\t\t\t\tthis.setEnabled(false);\n\t\t\t\t\tthis.add(new AttributeModifier(\"class\", true, new Model(\"disabled\")));\n\t\t\t\t\ttarget.addComponent(text);\n\t\t\t\t\ttarget.addComponent(this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n            }\n\t\t};\n\t\tsubmitButton.add(new FocusOnLoadBehaviour());\n\t\tform.add(submitButton);\n\t\t\n        \n\t\t//cancel button\n\t\tAjaxFallbackButton cancelButton = new AjaxFallbackButton(\"cancel\", new ResourceModel(\"button.cancel\"), form) {\n            private static final long serialVersionUID = 1L;\n\n\t\t\tprotected void onSubmit(AjaxRequestTarget target, Form form) {\n\t\t\t\tfriendActionModel.setRequested(false);\n            \twindow.close(target);\n            }\n        };\n        cancelButton.setDefaultFormProcessing(false);\n        form.add(cancelButton);\n        \n        //add form\n        add(form);\n        \n        \n       \n        \n\n    }","id":75957,"modified_method":"public AddFriend(String id, final ModalWindow window, final FriendAction friendActionModel, final String userX, final String userY){\n        super(id);\n\n        //get API's\n        sakaiProxy = ProfileApplication.get().getSakaiProxy();\n        profile = ProfileApplication.get().getProfile();\n        \n        //get friendName\n        final String friendName = FormattedText.processFormattedText(sakaiProxy.getUserDisplayName(userY), new StringBuilder());\n        \n        //window setup\n\t\twindow.setTitle(new StringResourceModel(\"title.friend.add\", null, new Object[]{ friendName } )); \n\t\twindow.setInitialHeight(150);\n\t\twindow.setInitialWidth(500);\n\t\twindow.setResizable(false);\n\t\t\n\t\t//is this user allowed to view this person's profile image?\n\t\tboolean isProfileImageAllowed = profile.isUserXProfileImageVisibleByUserY(userY, userX, false);\n\t\t\n\t\t//image\n\t\tadd(new ProfileImageRenderer(\"image\", userY, isProfileImageAllowed, ProfileImageManager.PROFILE_IMAGE_THUMBNAIL, true));\n\t\t\n        //text\n\t\tfinal Label text = new Label(\"text\", new StringResourceModel(\"text.friend.add\", null, new Object[]{ friendName } ));\n        text.setEscapeModelStrings(false);\n        text.setOutputMarkupId(true);\n        add(text);\n                   \n        //setup form\t\t\n\t\tForm form = new Form(\"form\");\n\t\tform.setOutputMarkupId(true);\n\t\t\t\t\n\t\t//submit button\n\t\tAjaxFallbackButton submitButton = new AjaxFallbackButton(\"submit\", new ResourceModel(\"button.friend.add\"), form) {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tprotected void onSubmit(AjaxRequestTarget target, Form form) {\n\t\t\t\t\n\t\t\t\t/* double checking */\n\t\t\t\t\n\t\t\t\t//friend?\n\t\t\t\tif(profile.isUserXFriendOfUserY(userX, userY)) {\n\t\t\t\t\ttext.setModel(new StringResourceModel(\"error.friend.already.confirmed\", null, new Object[]{ friendName } ));\n\t\t\t\t\tthis.setEnabled(false);\n\t\t\t\t\tthis.add(new AttributeModifier(\"class\", true, new Model(\"disabled\")));\n\t\t\t\t\ttarget.addComponent(text);\n\t\t\t\t\ttarget.addComponent(this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//has a friend request already been made to this person?\n\t\t\t\tif(profile.isFriendRequestPending(userX, userY)) {\n\t\t\t\t\ttext.setModel(new StringResourceModel(\"error.friend.already.pending\", null, new Object[]{ friendName } ));\n\t\t\t\t\tthis.setEnabled(false);\n\t\t\t\t\tthis.add(new AttributeModifier(\"class\", true, new Model(\"disabled\")));\n\t\t\t\t\ttarget.addComponent(text);\n\t\t\t\t\ttarget.addComponent(this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//has a friend request been made from this person to the current user?\n\t\t\t\tif(profile.isFriendRequestPending(userY, userX)) {\n\t\t\t\t\ttext.setModel(new StringResourceModel(\"error.friend.already.pending\", null, new Object[]{ friendName } ));\n\t\t\t\t\tthis.setEnabled(false);\n\t\t\t\t\tthis.add(new AttributeModifier(\"class\", true, new Model(\"disabled\")));\n\t\t\t\t\ttarget.addComponent(text);\n\t\t\t\t\ttarget.addComponent(this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//if ok, request friend\n\t\t\t\tif(profile.requestFriend(userX, userY)) {\n\t\t\t\t\tfriendActionModel.setRequested(true);\n\t\t\t\t\t\n\t\t\t\t\t//post event\n\t\t\t\t\tsakaiProxy.postEvent(ProfileUtilityManager.EVENT_FRIEND_REQUEST, \"/profile/\"+userY, true);\n\t\t\t\t\t\n\t\t\t\t\t//if email is enabled for this message type, send email\n\t\t\t\t\tif(profile.isEmailEnabledForThisMessageType(userY, ProfilePreferencesManager.EMAIL_NOTIFICATION_REQUEST)) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t//get some info\n\t\t\t\t        final String currentUserName = sakaiProxy.getUserDisplayName(userX);\n\t\t\t\t        final String serviceName = sakaiProxy.getServiceName();\n\t\t\t\t        final String portalUrl = sakaiProxy.getPortalUrl();\n\t\n\t\t\t\t\t\t//url needs to go to userY's (ie other user) myworkspace and wicket takes them to their MyFriends page\n\t\t\t\t        final String url = sakaiProxy.getDirectUrlToUserProfile(userY, urlFor(MyFriends.class, null).toString());\n\t\n\t\t\t\t        //tinyUrl\n\t\t\t\t        final String tinyUrl = profile.generateTinyUrl(url);\n\t\t\t\t        \n\t\t\t\t\t\t//subject\n\t\t\t\t\t\tfinal String subject = new StringResourceModel(\"email.friend.request.subject\", null, new Object[]{ currentUserName, serviceName } ).getObject().toString();\n\t\t\t\t\t\t\n\t\t\t\t\t\t//email newline\n\t\t\t\t\t\tfinal String newline = ProfileUtilityManager.EMAIL_NEWLINE;\n\t\t\t\t\t\t\n\t\t\t\t\t\t//message\n\t\t\t\t\t\tStringBuilder message = new StringBuilder();\n\t\t\t\t\t\tmessage.append(new StringResourceModel(\"email.friend.request.message\", null, new Object[]{ currentUserName, serviceName }).getObject().toString());\n\t\t\t\t\t\tmessage.append(newline);\n\t\t\t\t\t\tmessage.append(newline);\n\t\t\t\t\t\tmessage.append(new StringResourceModel(\"email.friend.request.link\", null, new Object[]{ currentUserName }).getObject().toString());\n\t\t\t\t\t\tmessage.append(newline);\n\t\t\t\t\t\tmessage.append(new StringResourceModel(\"email.friend.request.link.href\", null, new Object[]{ tinyUrl }).getObject().toString());\n\t\t\t\t\t\tmessage.append(newline);\n\t\t\t\t\t\tmessage.append(newline);\n\t\t\t\t\t\tmessage.append(new StringResourceModel(\"email.footer.1\", this, null).getString());\n\t\t\t\t\t\tmessage.append(newline);\n\t\t\t\t\t\tmessage.append(new StringResourceModel(\"email.footer.2\", null, new Object[]{ serviceName, portalUrl } ).getObject().toString());\n\t\t\t\t\t\tmessage.append(newline);\n\t\t\t\t\t\tmessage.append(new StringResourceModel(\"email.footer.3\", this, null).getString());\n\t\n\t\t\t\t\t\t//send email (this method will format it properly, then send it)\n\t\t\t\t\t\tsakaiProxy.sendEmail(userY, subject, message.toString());\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\twindow.close(target);\n\t\t\t\t} else {\n\t\t\t\t\ttext.setModel(new StringResourceModel(\"error.friend.add.failed\", null, new Object[]{ friendName } ));\n\t\t\t\t\tthis.setEnabled(false);\n\t\t\t\t\tthis.add(new AttributeModifier(\"class\", true, new Model(\"disabled\")));\n\t\t\t\t\ttarget.addComponent(text);\n\t\t\t\t\ttarget.addComponent(this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n            }\n\t\t};\n\t\tsubmitButton.add(new FocusOnLoadBehaviour());\n\t\tform.add(submitButton);\n\t\t\n        \n\t\t//cancel button\n\t\tAjaxFallbackButton cancelButton = new AjaxFallbackButton(\"cancel\", new ResourceModel(\"button.cancel\"), form) {\n            private static final long serialVersionUID = 1L;\n\n\t\t\tprotected void onSubmit(AjaxRequestTarget target, Form form) {\n\t\t\t\tfriendActionModel.setRequested(false);\n            \twindow.close(target);\n            }\n        };\n        cancelButton.setDefaultFormProcessing(false);\n        form.add(cancelButton);\n        \n        //add form\n        add(form);\n        \n        \n       \n        \n\n    }","commit_id":"bb4a2fcfe0fa63be3b4ad9c3ab7e69efc0146495","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public ConfirmFriend(String id, final ModalWindow window, final FriendAction friendActionModel, final String userX, final String userY){\n        super(id);\n\n        //get API's\n        sakaiProxy = ProfileApplication.get().getSakaiProxy();\n        profile = ProfileApplication.get().getProfile();\n        \n        //get friendName\n        final String friendName = sakaiProxy.getUserDisplayName(userY);\n                \n        //window setup\n\t\twindow.setTitle(new StringResourceModel(\"title.friend.confirm\", null, new Object[]{ friendName } )); \n\t\twindow.setInitialHeight(150);\n\t\twindow.setInitialWidth(500);\n\t\twindow.setResizable(false);\n\t\t\n\t\t//is this user allowed to view this person's profile image?\n\t\tboolean isProfileImageAllowed = profile.isUserXProfileImageVisibleByUserY(userY, userX, false);\n\t\t\n\t\t//image\n\t\tadd(new ProfileImageRenderer(\"image\", userY, isProfileImageAllowed, ProfileImageManager.PROFILE_IMAGE_THUMBNAIL, true));\n\t\t\n\t\t\n        //text\n\t\tfinal Label text = new Label(\"text\", new StringResourceModel(\"text.friend.confirm\", null, new Object[]{ friendName } ));\n        text.setEscapeModelStrings(false);\n        text.setOutputMarkupId(true);\n        add(text);\n                   \n        //setup form\t\t\n\t\tForm form = new Form(\"form\");\n\t\tform.setOutputMarkupId(true);\n\t\t\n\t\t//submit button\n\t\tAjaxFallbackButton submitButton = new AjaxFallbackButton(\"submit\", new ResourceModel(\"button.friend.confirm\"), form) {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tprotected void onSubmit(AjaxRequestTarget target, Form form) {\n\t\t\t\t\n\t\t\t\t/* double checking */\n\t\t\t\t\n\t\t\t\t//must exist a pending friend request FROM userY to userX in order to confirm it\n\t\t\t\tboolean friendRequestFromThisPerson = profile.isFriendRequestPending(userY, userX);\n\t\t\t\t\n\t\t\t\tif(!friendRequestFromThisPerson) {\n\t\t\t\t\ttext.setModel(new StringResourceModel(\"error.friend.not.pending.confirm\", null, new Object[]{ friendName } ));\n\t\t\t\t\tthis.setEnabled(false);\n\t\t\t\t\tthis.add(new AttributeModifier(\"class\", true, new Model(\"disabled\")));\n\t\t\t\t\ttarget.addComponent(text);\n\t\t\t\t\ttarget.addComponent(this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//if ok, request friend\n\t\t\t\tif(profile.confirmFriendRequest(userY, userX)) {\n\t\t\t\t\tfriendActionModel.setConfirmed(true);\n\t\t\t\t\t\n\t\t\t\t\t//post event\n\t\t\t\t\tsakaiProxy.postEvent(ProfileUtilityManager.EVENT_FRIEND_CONFIRM, \"/profile/\"+userY, true);\n\t\t\t\t\t\n\t\t\t\t\t//if email is enabled for this message type, send email\n\t\t\t\t\tif(profile.isEmailEnabledForThisMessageType(userY, ProfilePreferencesManager.EMAIL_NOTIFICATION_CONFIRM)) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t       \n\t\t\t\t\t\tfinal String currentUserName = sakaiProxy.getUserDisplayName(userX);\n\t\t\t\t        final String serviceName = sakaiProxy.getServiceName();\n\t\t\t\t        final String portalUrl = sakaiProxy.getPortalUrl();\n\t\t\t\t        \n\t\t\t\t\t\t//subject\n\t\t\t\t\t\tfinal String subject = new StringResourceModel(\"email.friend.confirm.subject\", null, new Object[]{ currentUserName, serviceName } ).getObject().toString();\n\t\t\t\t\t\t\n\t\t\t\t\t\t//email newline\n\t\t\t\t\t\tfinal String newline = ProfileUtilityManager.EMAIL_NEWLINE;\n\t\t\t\t\t\t\n\t\t\t\t\t\t//message\n\t\t\t\t\t\tStringBuilder message = new StringBuilder();\n\t\t\t\t\t\tmessage.append(new StringResourceModel(\"email.friend.confirm.message\", null, new Object[]{ currentUserName, serviceName }).getObject().toString());\n\t\t\t\t\t\t\n\t\t\t\t\t\t//url needs to go to userY's (ie other user) myworkspace and then Wicket takes them to their ViewProfile page for userX\n\t\t\t\t        String url = sakaiProxy.getDirectUrlToUserProfile(userY, urlFor(ViewProfile.class, new PageParameters(\"id=\" + userX)).toString());\n\t\t\t\t        //tinyurl\n\t\t\t\t        final String tinyUrl = profile.generateTinyUrl(url);\n\t\t\t\t        message.append(newline);\n\t\t\t\t\t\tmessage.append(newline);\n\t\t\t\t        message.append(new StringResourceModel(\"email.friend.confirm.link\", null, new Object[]{ currentUserName} ).getObject().toString());\n\t\t\t\t        message.append(newline);\n\t\t\t\t\t\tmessage.append(new StringResourceModel(\"email.friend.confirm.link.href\", null, new Object[]{ tinyUrl }).getObject().toString());\n\t\t\t\t\t\t\n\t\t\t\t\t\t//standard footer\n\t\t\t\t\t\tmessage.append(newline);\n\t\t\t\t\t\tmessage.append(newline);\n\t\t\t\t\t\tmessage.append(new StringResourceModel(\"email.footer.1\", this, null).getString());\n\t\t\t\t\t\tmessage.append(newline);\n\t\t\t\t\t\tmessage.append(new StringResourceModel(\"email.footer.2\", null, new Object[]{ serviceName, portalUrl } ).getObject().toString());\n\t\t\t\t\t\tmessage.append(newline);\n\t\t\t\t\t\tmessage.append(new StringResourceModel(\"email.footer.3\", this, null).getString());\n\t\t\t\t\t\t\n\t\t\t\t\t\t//send email\n\t\t\t\t\t\tsakaiProxy.sendEmail(userY, subject, message.toString());\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\twindow.close(target);\n\t\t\t\t} else {\n\t\t\t\t\ttext.setModel(new StringResourceModel(\"error.friend.confirm.failed\", null, new Object[]{ friendName } ));\n\t\t\t\t\tthis.setEnabled(false);\n\t\t\t\t\tthis.add(new AttributeModifier(\"class\", true, new Model(\"disabled\")));\n\t\t\t\t\ttarget.addComponent(text);\n\t\t\t\t\ttarget.addComponent(this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n            }\n\t\t};\n\t\tsubmitButton.add(new FocusOnLoadBehaviour());\n\t\tform.add(submitButton);\n\t\t\n        \n\t\t//cancel button\n\t\tAjaxFallbackButton cancelButton = new AjaxFallbackButton(\"cancel\", new ResourceModel(\"button.cancel\"), form) {\n            private static final long serialVersionUID = 1L;\n\n\t\t\tprotected void onSubmit(AjaxRequestTarget target, Form form) {\n\t\t\t\tfriendActionModel.setConfirmed(false);\n            \twindow.close(target);\n            }\n        };\n        cancelButton.setDefaultFormProcessing(false);\n        form.add(cancelButton);\n        \n        //add form\n        add(form);\n        \n        \n       \n        \n\n    }","id":75958,"modified_method":"public ConfirmFriend(String id, final ModalWindow window, final FriendAction friendActionModel, final String userX, final String userY){\n        super(id);\n\n        //get API's\n        sakaiProxy = ProfileApplication.get().getSakaiProxy();\n        profile = ProfileApplication.get().getProfile();\n        \n        //get friendName\n        final String friendName = FormattedText.processFormattedText(sakaiProxy.getUserDisplayName(userY), new StringBuilder());\n                \n        //window setup\n\t\twindow.setTitle(new StringResourceModel(\"title.friend.confirm\", null, new Object[]{ friendName } )); \n\t\twindow.setInitialHeight(150);\n\t\twindow.setInitialWidth(500);\n\t\twindow.setResizable(false);\n\t\t\n\t\t//is this user allowed to view this person's profile image?\n\t\tboolean isProfileImageAllowed = profile.isUserXProfileImageVisibleByUserY(userY, userX, false);\n\t\t\n\t\t//image\n\t\tadd(new ProfileImageRenderer(\"image\", userY, isProfileImageAllowed, ProfileImageManager.PROFILE_IMAGE_THUMBNAIL, true));\n\t\t\n\t\t\n        //text\n\t\tfinal Label text = new Label(\"text\", new StringResourceModel(\"text.friend.confirm\", null, new Object[]{ friendName } ));\n        text.setEscapeModelStrings(false);\n        text.setOutputMarkupId(true);\n        add(text);\n                   \n        //setup form\t\t\n\t\tForm form = new Form(\"form\");\n\t\tform.setOutputMarkupId(true);\n\t\t\n\t\t//submit button\n\t\tAjaxFallbackButton submitButton = new AjaxFallbackButton(\"submit\", new ResourceModel(\"button.friend.confirm\"), form) {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tprotected void onSubmit(AjaxRequestTarget target, Form form) {\n\t\t\t\t\n\t\t\t\t/* double checking */\n\t\t\t\t\n\t\t\t\t//must exist a pending friend request FROM userY to userX in order to confirm it\n\t\t\t\tboolean friendRequestFromThisPerson = profile.isFriendRequestPending(userY, userX);\n\t\t\t\t\n\t\t\t\tif(!friendRequestFromThisPerson) {\n\t\t\t\t\ttext.setModel(new StringResourceModel(\"error.friend.not.pending.confirm\", null, new Object[]{ friendName } ));\n\t\t\t\t\tthis.setEnabled(false);\n\t\t\t\t\tthis.add(new AttributeModifier(\"class\", true, new Model(\"disabled\")));\n\t\t\t\t\ttarget.addComponent(text);\n\t\t\t\t\ttarget.addComponent(this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//if ok, request friend\n\t\t\t\tif(profile.confirmFriendRequest(userY, userX)) {\n\t\t\t\t\tfriendActionModel.setConfirmed(true);\n\t\t\t\t\t\n\t\t\t\t\t//post event\n\t\t\t\t\tsakaiProxy.postEvent(ProfileUtilityManager.EVENT_FRIEND_CONFIRM, \"/profile/\"+userY, true);\n\t\t\t\t\t\n\t\t\t\t\t//if email is enabled for this message type, send email\n\t\t\t\t\tif(profile.isEmailEnabledForThisMessageType(userY, ProfilePreferencesManager.EMAIL_NOTIFICATION_CONFIRM)) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t       \n\t\t\t\t\t\tfinal String currentUserName = sakaiProxy.getUserDisplayName(userX);\n\t\t\t\t        final String serviceName = sakaiProxy.getServiceName();\n\t\t\t\t        final String portalUrl = sakaiProxy.getPortalUrl();\n\t\t\t\t        \n\t\t\t\t\t\t//subject\n\t\t\t\t\t\tfinal String subject = new StringResourceModel(\"email.friend.confirm.subject\", null, new Object[]{ currentUserName, serviceName } ).getObject().toString();\n\t\t\t\t\t\t\n\t\t\t\t\t\t//email newline\n\t\t\t\t\t\tfinal String newline = ProfileUtilityManager.EMAIL_NEWLINE;\n\t\t\t\t\t\t\n\t\t\t\t\t\t//message\n\t\t\t\t\t\tStringBuilder message = new StringBuilder();\n\t\t\t\t\t\tmessage.append(new StringResourceModel(\"email.friend.confirm.message\", null, new Object[]{ currentUserName, serviceName }).getObject().toString());\n\t\t\t\t\t\t\n\t\t\t\t\t\t//url needs to go to userY's (ie other user) myworkspace and then Wicket takes them to their ViewProfile page for userX\n\t\t\t\t        String url = sakaiProxy.getDirectUrlToUserProfile(userY, urlFor(ViewProfile.class, new PageParameters(\"id=\" + userX)).toString());\n\t\t\t\t        //tinyurl\n\t\t\t\t        final String tinyUrl = profile.generateTinyUrl(url);\n\t\t\t\t        message.append(newline);\n\t\t\t\t\t\tmessage.append(newline);\n\t\t\t\t        message.append(new StringResourceModel(\"email.friend.confirm.link\", null, new Object[]{ currentUserName} ).getObject().toString());\n\t\t\t\t        message.append(newline);\n\t\t\t\t\t\tmessage.append(new StringResourceModel(\"email.friend.confirm.link.href\", null, new Object[]{ tinyUrl }).getObject().toString());\n\t\t\t\t\t\t\n\t\t\t\t\t\t//standard footer\n\t\t\t\t\t\tmessage.append(newline);\n\t\t\t\t\t\tmessage.append(newline);\n\t\t\t\t\t\tmessage.append(new StringResourceModel(\"email.footer.1\", this, null).getString());\n\t\t\t\t\t\tmessage.append(newline);\n\t\t\t\t\t\tmessage.append(new StringResourceModel(\"email.footer.2\", null, new Object[]{ serviceName, portalUrl } ).getObject().toString());\n\t\t\t\t\t\tmessage.append(newline);\n\t\t\t\t\t\tmessage.append(new StringResourceModel(\"email.footer.3\", this, null).getString());\n\t\t\t\t\t\t\n\t\t\t\t\t\t//send email\n\t\t\t\t\t\tsakaiProxy.sendEmail(userY, subject, message.toString());\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\twindow.close(target);\n\t\t\t\t} else {\n\t\t\t\t\ttext.setModel(new StringResourceModel(\"error.friend.confirm.failed\", null, new Object[]{ friendName } ));\n\t\t\t\t\tthis.setEnabled(false);\n\t\t\t\t\tthis.add(new AttributeModifier(\"class\", true, new Model(\"disabled\")));\n\t\t\t\t\ttarget.addComponent(text);\n\t\t\t\t\ttarget.addComponent(this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n            }\n\t\t};\n\t\tsubmitButton.add(new FocusOnLoadBehaviour());\n\t\tform.add(submitButton);\n\t\t\n        \n\t\t//cancel button\n\t\tAjaxFallbackButton cancelButton = new AjaxFallbackButton(\"cancel\", new ResourceModel(\"button.cancel\"), form) {\n            private static final long serialVersionUID = 1L;\n\n\t\t\tprotected void onSubmit(AjaxRequestTarget target, Form form) {\n\t\t\t\tfriendActionModel.setConfirmed(false);\n            \twindow.close(target);\n            }\n        };\n        cancelButton.setDefaultFormProcessing(false);\n        form.add(cancelButton);\n        \n        //add form\n        add(form);\n        \n        \n       \n        \n\n    }","commit_id":"bb4a2fcfe0fa63be3b4ad9c3ab7e69efc0146495","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public IgnoreFriend(String id, final ModalWindow window, final FriendAction friendActionModel, final String userX, final String userY){\n        super(id);\n\n        //get API's\n        sakaiProxy = ProfileApplication.get().getSakaiProxy();\n        profile = ProfileApplication.get().getProfile();\n        \n        //get friendName\n        final String friendName = sakaiProxy.getUserDisplayName(userY);\n                \n        //window setup\n\t\twindow.setTitle(new ResourceModel(\"title.friend.ignore\")); \n\t\twindow.setInitialHeight(150);\n\t\twindow.setInitialWidth(500);\n\t\twindow.setResizable(false);\n\t\t\n\t\t//is this user allowed to view this person's profile image?\n\t\tboolean isProfileImageAllowed = profile.isUserXProfileImageVisibleByUserY(userY, userX, false);\n\t\t\n\t\t//image\n\t\tadd(new ProfileImageRenderer(\"image\", userY, isProfileImageAllowed, ProfileImageManager.PROFILE_IMAGE_THUMBNAIL, true));\n\t\t\n        //text\n\t\tfinal Label text = new Label(\"text\", new StringResourceModel(\"text.friend.ignore\", null, new Object[]{ friendName } ));\n        text.setEscapeModelStrings(false);\n        text.setOutputMarkupId(true);\n        add(text);\n                   \n        //setup form\t\t\n\t\tForm form = new Form(\"form\");\n\t\tform.setOutputMarkupId(true);\n\t\t\n\t\t//submit button\n\t\tAjaxFallbackButton submitButton = new AjaxFallbackButton(\"submit\", new ResourceModel(\"button.friend.ignore\"), form) {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tprotected void onSubmit(AjaxRequestTarget target, Form form) {\n\t\t\t\t\n\t\t\t\t/* double checking */\n\t\t\t\t\n\t\t\t\t//must exist a pending friend request FROM userY to userX in order to ignore it\n\t\t\t\tboolean friendRequestFromThisPerson = profile.isFriendRequestPending(userY, userX);\n\t\t\t\t\n\t\t\t\tif(!friendRequestFromThisPerson) {\n\t\t\t\t\ttext.setModel(new StringResourceModel(\"error.friend.not.pending.ignore\", null, new Object[]{ friendName } ));\n\t\t\t\t\tthis.setEnabled(false);\n\t\t\t\t\tthis.add(new AttributeModifier(\"class\", true, new Model(\"disabled\")));\n\t\t\t\t\ttarget.addComponent(text);\n\t\t\t\t\ttarget.addComponent(this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t//if ok, ignore friend request\n\t\t\t\tif(profile.ignoreFriendRequest(userY, userX)) {\n\t\t\t\t\tfriendActionModel.setIgnored(true);\n\t\t\t\t\t\n\t\t\t\t\t//post event\n\t\t\t\t\tsakaiProxy.postEvent(ProfileUtilityManager.EVENT_FRIEND_IGNORE, \"/profile/\"+userY, true);\n\t\t\t\t\t\n\t\t\t\t\twindow.close(target);\n\t\t\t\t} else {\n\t\t\t\t\ttext.setModel(new StringResourceModel(\"error.friend.ignore.failed\", null, new Object[]{ friendName } ));\n\t\t\t\t\tthis.setEnabled(false);\n\t\t\t\t\tthis.add(new AttributeModifier(\"class\", true, new Model(\"disabled\")));\n\t\t\t\t\ttarget.addComponent(text);\n\t\t\t\t\ttarget.addComponent(this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n            }\n\t\t};\n\t\tsubmitButton.add(new FocusOnLoadBehaviour());\n\t\tform.add(submitButton);\n\t\t\n        \n\t\t//cancel button\n\t\tAjaxFallbackButton cancelButton = new AjaxFallbackButton(\"cancel\", new ResourceModel(\"button.cancel\"), form) {\n            private static final long serialVersionUID = 1L;\n\n\t\t\tprotected void onSubmit(AjaxRequestTarget target, Form form) {\n\t\t\t\tfriendActionModel.setIgnored(false);\n            \twindow.close(target);\n            }\n        };\n        cancelButton.setDefaultFormProcessing(false);\n        form.add(cancelButton);\n        \n        //add form\n        add(form);\n        \n        \n       \n        \n\n    }","id":75959,"modified_method":"public IgnoreFriend(String id, final ModalWindow window, final FriendAction friendActionModel, final String userX, final String userY){\n        super(id);\n\n        //get API's\n        sakaiProxy = ProfileApplication.get().getSakaiProxy();\n        profile = ProfileApplication.get().getProfile();\n        \n        //get friendName\n        final String friendName = FormattedText.processFormattedText(sakaiProxy.getUserDisplayName(userY), new StringBuilder());\n                \n        //window setup\n\t\twindow.setTitle(new ResourceModel(\"title.friend.ignore\")); \n\t\twindow.setInitialHeight(150);\n\t\twindow.setInitialWidth(500);\n\t\twindow.setResizable(false);\n\t\t\n\t\t//is this user allowed to view this person's profile image?\n\t\tboolean isProfileImageAllowed = profile.isUserXProfileImageVisibleByUserY(userY, userX, false);\n\t\t\n\t\t//image\n\t\tadd(new ProfileImageRenderer(\"image\", userY, isProfileImageAllowed, ProfileImageManager.PROFILE_IMAGE_THUMBNAIL, true));\n\t\t\n        //text\n\t\tfinal Label text = new Label(\"text\", new StringResourceModel(\"text.friend.ignore\", null, new Object[]{ friendName } ));\n        text.setEscapeModelStrings(false);\n        text.setOutputMarkupId(true);\n        add(text);\n                   \n        //setup form\t\t\n\t\tForm form = new Form(\"form\");\n\t\tform.setOutputMarkupId(true);\n\t\t\n\t\t//submit button\n\t\tAjaxFallbackButton submitButton = new AjaxFallbackButton(\"submit\", new ResourceModel(\"button.friend.ignore\"), form) {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tprotected void onSubmit(AjaxRequestTarget target, Form form) {\n\t\t\t\t\n\t\t\t\t/* double checking */\n\t\t\t\t\n\t\t\t\t//must exist a pending friend request FROM userY to userX in order to ignore it\n\t\t\t\tboolean friendRequestFromThisPerson = profile.isFriendRequestPending(userY, userX);\n\t\t\t\t\n\t\t\t\tif(!friendRequestFromThisPerson) {\n\t\t\t\t\ttext.setModel(new StringResourceModel(\"error.friend.not.pending.ignore\", null, new Object[]{ friendName } ));\n\t\t\t\t\tthis.setEnabled(false);\n\t\t\t\t\tthis.add(new AttributeModifier(\"class\", true, new Model(\"disabled\")));\n\t\t\t\t\ttarget.addComponent(text);\n\t\t\t\t\ttarget.addComponent(this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t//if ok, ignore friend request\n\t\t\t\tif(profile.ignoreFriendRequest(userY, userX)) {\n\t\t\t\t\tfriendActionModel.setIgnored(true);\n\t\t\t\t\t\n\t\t\t\t\t//post event\n\t\t\t\t\tsakaiProxy.postEvent(ProfileUtilityManager.EVENT_FRIEND_IGNORE, \"/profile/\"+userY, true);\n\t\t\t\t\t\n\t\t\t\t\twindow.close(target);\n\t\t\t\t} else {\n\t\t\t\t\ttext.setModel(new StringResourceModel(\"error.friend.ignore.failed\", null, new Object[]{ friendName } ));\n\t\t\t\t\tthis.setEnabled(false);\n\t\t\t\t\tthis.add(new AttributeModifier(\"class\", true, new Model(\"disabled\")));\n\t\t\t\t\ttarget.addComponent(text);\n\t\t\t\t\ttarget.addComponent(this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n            }\n\t\t};\n\t\tsubmitButton.add(new FocusOnLoadBehaviour());\n\t\tform.add(submitButton);\n\t\t\n        \n\t\t//cancel button\n\t\tAjaxFallbackButton cancelButton = new AjaxFallbackButton(\"cancel\", new ResourceModel(\"button.cancel\"), form) {\n            private static final long serialVersionUID = 1L;\n\n\t\t\tprotected void onSubmit(AjaxRequestTarget target, Form form) {\n\t\t\t\tfriendActionModel.setIgnored(false);\n            \twindow.close(target);\n            }\n        };\n        cancelButton.setDefaultFormProcessing(false);\n        form.add(cancelButton);\n        \n        //add form\n        add(form);\n        \n        \n       \n        \n\n    }","commit_id":"bb4a2fcfe0fa63be3b4ad9c3ab7e69efc0146495","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public RemoveFriend(String id, final ModalWindow window, final FriendAction friendActionModel, final String userX, final String userY){\n        super(id);\n\n        //get API's\n        sakaiProxy = ProfileApplication.get().getSakaiProxy();\n        profile = ProfileApplication.get().getProfile();\n        \n        //get friendName\n        final String friendName = sakaiProxy.getUserDisplayName(userY);\n                \n        //window setup\n\t\twindow.setTitle(new ResourceModel(\"title.friend.remove\")); \n\t\twindow.setInitialHeight(150);\n\t\twindow.setInitialWidth(500);\n\t\twindow.setResizable(false);\n\t\t\n\t\t//is this user allowed to view this person's profile image?\n\t\tboolean isProfileImageAllowed = profile.isUserXProfileImageVisibleByUserY(userY, userX, true);\n\t\t\n\t\t//image\n\t\tadd(new ProfileImageRenderer(\"image\", userY, isProfileImageAllowed, ProfileImageManager.PROFILE_IMAGE_THUMBNAIL, true));\n\t\t\n        //text\n\t\tfinal Label text = new Label(\"text\", new StringResourceModel(\"text.friend.remove\", null, new Object[]{ friendName } ));\n        text.setEscapeModelStrings(false);\n        text.setOutputMarkupId(true);\n        add(text);\n                   \n        //setup form\t\t\n\t\tForm form = new Form(\"form\");\n\t\tform.setOutputMarkupId(true);\n\t\t\n\t\t//submit button\n\t\tAjaxFallbackButton submitButton = new AjaxFallbackButton(\"submit\", new ResourceModel(\"button.friend.remove\"), form) {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tprotected void onSubmit(AjaxRequestTarget target, Form form) {\n\t\t\t\t\n\t\t\t\t/* double checking */\n\t\t\t\t\n\t\t\t\t//must be friend in order to remove them\n\t\t\t\tboolean friend = profile.isUserXFriendOfUserY(userX, userY);\n\t\t\t\t\n\t\t\t\tif(!friend) {\n\t\t\t\t\ttext.setModel(new StringResourceModel(\"error.friend.not.friend\", null, new Object[]{ friendName } ));\n\t\t\t\t\tthis.setEnabled(false);\n\t\t\t\t\tthis.add(new AttributeModifier(\"class\", true, new Model(\"disabled\")));\n\t\t\t\t\ttarget.addComponent(text);\n\t\t\t\t\ttarget.addComponent(this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t//if ok, remove friend\n\t\t\t\tif(profile.removeFriend(userX, userY)) {\n\t\t\t\t\tfriendActionModel.setRemoved(true);\n\t\t\t\t\t\n\t\t\t\t\t//post event\n\t\t\t\t\tsakaiProxy.postEvent(ProfileUtilityManager.EVENT_FRIEND_REMOVE, \"/profile/\"+userY, true);\n\t\t\t\t\t\n\t\t\t\t\twindow.close(target);\n\t\t\t\t} else {\n\t\t\t\t\ttext.setModel(new StringResourceModel(\"error.friend.remove.failed\", null, new Object[]{ friendName } ));\n\t\t\t\t\tthis.setEnabled(false);\n\t\t\t\t\tthis.add(new AttributeModifier(\"class\", true, new Model(\"disabled\")));\n\t\t\t\t\ttarget.addComponent(text);\n\t\t\t\t\ttarget.addComponent(this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n            }\n\t\t};\n\t\tsubmitButton.add(new FocusOnLoadBehaviour());\n\t\tform.add(submitButton);\n\t\t\n        \n\t\t//cancel button\n\t\tAjaxFallbackButton cancelButton = new AjaxFallbackButton(\"cancel\", new ResourceModel(\"button.cancel\"), form) {\n            private static final long serialVersionUID = 1L;\n\n\t\t\tprotected void onSubmit(AjaxRequestTarget target, Form form) {\n\t\t\t\tfriendActionModel.setRemoved(false);\n            \twindow.close(target);\n            }\n        };\n        cancelButton.setDefaultFormProcessing(false);\n        form.add(cancelButton);\n        \n        //add form\n        add(form);\n        \n        \n       \n        \n\n    }","id":75960,"modified_method":"public RemoveFriend(String id, final ModalWindow window, final FriendAction friendActionModel, final String userX, final String userY){\n        super(id);\n\n        //get API's\n        sakaiProxy = ProfileApplication.get().getSakaiProxy();\n        profile = ProfileApplication.get().getProfile();\n        \n        //get friendName\n        final String friendName = FormattedText.processFormattedText(sakaiProxy.getUserDisplayName(userY), new StringBuilder());\n                \n        //window setup\n\t\twindow.setTitle(new ResourceModel(\"title.friend.remove\")); \n\t\twindow.setInitialHeight(150);\n\t\twindow.setInitialWidth(500);\n\t\twindow.setResizable(false);\n\t\t\n\t\t//is this user allowed to view this person's profile image?\n\t\tboolean isProfileImageAllowed = profile.isUserXProfileImageVisibleByUserY(userY, userX, true);\n\t\t\n\t\t//image\n\t\tadd(new ProfileImageRenderer(\"image\", userY, isProfileImageAllowed, ProfileImageManager.PROFILE_IMAGE_THUMBNAIL, true));\n\t\t\n        //text\n\t\tfinal Label text = new Label(\"text\", new StringResourceModel(\"text.friend.remove\", null, new Object[]{ friendName } ));\n        text.setEscapeModelStrings(false);\n        text.setOutputMarkupId(true);\n        add(text);\n                   \n        //setup form\t\t\n\t\tForm form = new Form(\"form\");\n\t\tform.setOutputMarkupId(true);\n\t\t\n\t\t//submit button\n\t\tAjaxFallbackButton submitButton = new AjaxFallbackButton(\"submit\", new ResourceModel(\"button.friend.remove\"), form) {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tprotected void onSubmit(AjaxRequestTarget target, Form form) {\n\t\t\t\t\n\t\t\t\t/* double checking */\n\t\t\t\t\n\t\t\t\t//must be friend in order to remove them\n\t\t\t\tboolean friend = profile.isUserXFriendOfUserY(userX, userY);\n\t\t\t\t\n\t\t\t\tif(!friend) {\n\t\t\t\t\ttext.setModel(new StringResourceModel(\"error.friend.not.friend\", null, new Object[]{ friendName } ));\n\t\t\t\t\tthis.setEnabled(false);\n\t\t\t\t\tthis.add(new AttributeModifier(\"class\", true, new Model(\"disabled\")));\n\t\t\t\t\ttarget.addComponent(text);\n\t\t\t\t\ttarget.addComponent(this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t//if ok, remove friend\n\t\t\t\tif(profile.removeFriend(userX, userY)) {\n\t\t\t\t\tfriendActionModel.setRemoved(true);\n\t\t\t\t\t\n\t\t\t\t\t//post event\n\t\t\t\t\tsakaiProxy.postEvent(ProfileUtilityManager.EVENT_FRIEND_REMOVE, \"/profile/\"+userY, true);\n\t\t\t\t\t\n\t\t\t\t\twindow.close(target);\n\t\t\t\t} else {\n\t\t\t\t\ttext.setModel(new StringResourceModel(\"error.friend.remove.failed\", null, new Object[]{ friendName } ));\n\t\t\t\t\tthis.setEnabled(false);\n\t\t\t\t\tthis.add(new AttributeModifier(\"class\", true, new Model(\"disabled\")));\n\t\t\t\t\ttarget.addComponent(text);\n\t\t\t\t\ttarget.addComponent(this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n            }\n\t\t};\n\t\tsubmitButton.add(new FocusOnLoadBehaviour());\n\t\tform.add(submitButton);\n\t\t\n        \n\t\t//cancel button\n\t\tAjaxFallbackButton cancelButton = new AjaxFallbackButton(\"cancel\", new ResourceModel(\"button.cancel\"), form) {\n            private static final long serialVersionUID = 1L;\n\n\t\t\tprotected void onSubmit(AjaxRequestTarget target, Form form) {\n\t\t\t\tfriendActionModel.setRemoved(false);\n            \twindow.close(target);\n            }\n        };\n        cancelButton.setDefaultFormProcessing(false);\n        form.add(cancelButton);\n        \n        //add form\n        add(form);\n        \n        \n       \n        \n\n    }","commit_id":"bb4a2fcfe0fa63be3b4ad9c3ab7e69efc0146495","url":"https://github.com/sakaiproject/sakai"},{"original_method":"private Map<String, Object> loadSourceIfNeeded() {\n        if (source != null) {\n            return source;\n        }\n        XContentParser parser = null;\n        try {\n            Document doc = reader.document(docId, SourceFieldSelector.INSTANCE);\n            Fieldable sourceField = doc.getFieldable(SourceFieldMapper.NAME);\n            byte[] source = sourceField.getBinaryValue();\n            this.source = sourceAsMap(source, 0, source.length);\n        } catch (Exception e) {\n            throw new ElasticSearchParseException(\"failed to parse / load source\", e);\n        } finally {\n            if (parser != null) {\n                parser.close();\n            }\n        }\n        return this.source;\n    }","id":75961,"modified_method":"private Map<String, Object> loadSourceIfNeeded() {\n        if (source != null) {\n            return source;\n        }\n        XContentParser parser = null;\n        try {\n            Document doc = reader.document(docId, SourceFieldSelector.INSTANCE);\n            Fieldable sourceField = doc.getFieldable(SourceFieldMapper.NAME);\n            if (sourceField == null) {\n                source = ImmutableMap.of();\n            } else {\n                this.source = sourceAsMap(sourceField.getBinaryValue(), sourceField.getBinaryOffset(), sourceField.getBinaryLength());\n            }\n        } catch (Exception e) {\n            throw new ElasticSearchParseException(\"failed to parse / load source\", e);\n        } finally {\n            if (parser != null) {\n                parser.close();\n            }\n        }\n        return this.source;\n    }","commit_id":"f9d0e823898c445b2777738f57a8a1e22dcb1649","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void execute(SearchContext context) {\n        ResetFieldSelector fieldSelector;\n        List<String> extractFieldNames = null;\n        boolean sourceRequested = false;\n        if (!context.hasFieldNames()) {\n            if (context.hasPartialFields()) {\n                // partial fields need the source, so fetch it, but don't return it\n                fieldSelector = new UidAndSourceFieldSelector();\n                sourceRequested = false;\n            } else if (context.hasScriptFields()) {\n                // we ask for script fields, and no field names, don't load the source\n                fieldSelector = UidFieldSelector.INSTANCE;\n                sourceRequested = false;\n            } else {\n                fieldSelector = new UidAndSourceFieldSelector();\n                sourceRequested = true;\n            }\n        } else if (context.fieldNames().isEmpty()) {\n            fieldSelector = UidFieldSelector.INSTANCE;\n            sourceRequested = false;\n        } else {\n            boolean loadAllStored = false;\n            FieldMappersFieldSelector fieldSelectorMapper = null;\n            for (String fieldName : context.fieldNames()) {\n                if (fieldName.equals(\"*\")) {\n                    loadAllStored = true;\n                    continue;\n                }\n                if (fieldName.equals(SourceFieldMapper.NAME)) {\n                    sourceRequested = true;\n                    continue;\n                }\n                FieldMappers x = context.smartNameFieldMappers(fieldName);\n                if (x != null && x.mapper().stored()) {\n                    if (fieldSelectorMapper == null) {\n                        fieldSelectorMapper = new FieldMappersFieldSelector();\n                    }\n                    fieldSelectorMapper.add(x);\n                } else {\n                    if (extractFieldNames == null) {\n                        extractFieldNames = Lists.newArrayList();\n                    }\n                    extractFieldNames.add(fieldName);\n                }\n            }\n\n            if (loadAllStored) {\n                if (sourceRequested || extractFieldNames != null) {\n                    fieldSelector = null; // load everything, including _source\n                } else {\n                    fieldSelector = AllButSourceFieldSelector.INSTANCE;\n                }\n            } else if (fieldSelectorMapper != null) {\n                // we are asking specific stored fields, just add the UID and be done\n                fieldSelectorMapper.add(UidFieldMapper.NAME);\n                if (extractFieldNames != null || sourceRequested) {\n                    fieldSelectorMapper.add(SourceFieldMapper.NAME);\n                }\n                fieldSelector = fieldSelectorMapper;\n            } else if (extractFieldNames != null || sourceRequested) {\n                fieldSelector = new UidAndSourceFieldSelector();\n            } else {\n                fieldSelector = UidFieldSelector.INSTANCE;\n            }\n        }\n\n        InternalSearchHit[] hits = new InternalSearchHit[context.docIdsToLoadSize()];\n        for (int index = 0; index < context.docIdsToLoadSize(); index++) {\n            int docId = context.docIdsToLoad()[context.docIdsToLoadFrom() + index];\n            Document doc = loadDocument(context, fieldSelector, docId);\n            Uid uid = extractUid(context, doc, fieldSelector);\n\n            DocumentMapper documentMapper = context.mapperService().documentMapper(uid.type());\n\n            if (documentMapper == null) {\n                throw new TypeMissingException(new Index(context.shardTarget().index()), uid.type(), \"failed to find type loaded for doc [\" + uid.id() + \"]\");\n            }\n\n            byte[] source = extractSource(doc, documentMapper);\n\n            // get the version\n\n            InternalSearchHit searchHit = new InternalSearchHit(docId, uid.id(), uid.type(), sourceRequested ? source : null, null);\n            hits[index] = searchHit;\n\n            for (Object oField : doc.getFields()) {\n                Fieldable field = (Fieldable) oField;\n                String name = field.name();\n\n                // ignore UID, we handled it above\n                if (name.equals(UidFieldMapper.NAME)) {\n                    continue;\n                }\n\n                // ignore source, we handled it above\n                if (name.equals(SourceFieldMapper.NAME)) {\n                    continue;\n                }\n\n                Object value = null;\n                FieldMappers fieldMappers = documentMapper.mappers().indexName(field.name());\n                if (fieldMappers != null) {\n                    FieldMapper mapper = fieldMappers.mapper();\n                    if (mapper != null) {\n                        name = mapper.names().fullName();\n                        value = mapper.valueForSearch(field);\n                    }\n                }\n                if (value == null) {\n                    if (field.isBinary()) {\n                        value = field.getBinaryValue();\n                    } else {\n                        value = field.stringValue();\n                    }\n                }\n\n                if (searchHit.fieldsOrNull() == null) {\n                    searchHit.fields(new HashMap<String, SearchHitField>(2));\n                }\n\n                SearchHitField hitField = searchHit.fields().get(name);\n                if (hitField == null) {\n                    hitField = new InternalSearchHitField(name, new ArrayList<Object>(2));\n                    searchHit.fields().put(name, hitField);\n                }\n                hitField.values().add(value);\n            }\n\n            int readerIndex = context.searcher().readerIndex(docId);\n            IndexReader subReader = context.searcher().subReaders()[readerIndex];\n            int subDoc = docId - context.searcher().docStarts()[readerIndex];\n\n            // go over and extract fields that are not mapped / stored\n            context.lookup().setNextReader(subReader);\n            context.lookup().setNextDocId(subDoc);\n            if (source != null) {\n                context.lookup().source().setNextSource(new BytesArray(source));\n            }\n            if (extractFieldNames != null) {\n                for (String extractFieldName : extractFieldNames) {\n                    Object value = context.lookup().source().extractValue(extractFieldName);\n                    if (value != null) {\n                        if (searchHit.fieldsOrNull() == null) {\n                            searchHit.fields(new HashMap<String, SearchHitField>(2));\n                        }\n\n                        SearchHitField hitField = searchHit.fields().get(extractFieldName);\n                        if (hitField == null) {\n                            hitField = new InternalSearchHitField(extractFieldName, new ArrayList<Object>(2));\n                            searchHit.fields().put(extractFieldName, hitField);\n                        }\n                        hitField.values().add(value);\n                    }\n                }\n            }\n\n            for (FetchSubPhase fetchSubPhase : fetchSubPhases) {\n                FetchSubPhase.HitContext hitContext = new FetchSubPhase.HitContext();\n                if (fetchSubPhase.hitExecutionNeeded(context)) {\n                    hitContext.reset(searchHit, subReader, subDoc, context.searcher().getIndexReader(), docId, doc);\n                    fetchSubPhase.hitExecute(context, hitContext);\n                }\n            }\n        }\n\n        for (FetchSubPhase fetchSubPhase : fetchSubPhases) {\n            if (fetchSubPhase.hitsExecutionNeeded(context)) {\n                fetchSubPhase.hitsExecute(context, hits);\n            }\n        }\n\n        context.fetchResult().hits(new InternalSearchHits(hits, context.queryResult().topDocs().totalHits, context.queryResult().topDocs().getMaxScore()));\n    }","id":75962,"modified_method":"public void execute(SearchContext context) {\n        ResetFieldSelector fieldSelector;\n        List<String> extractFieldNames = null;\n        boolean sourceRequested = false;\n        if (!context.hasFieldNames()) {\n            if (context.hasPartialFields()) {\n                // partial fields need the source, so fetch it, but don't return it\n                fieldSelector = new UidAndSourceFieldSelector();\n                sourceRequested = false;\n            } else if (context.hasScriptFields()) {\n                // we ask for script fields, and no field names, don't load the source\n                fieldSelector = UidFieldSelector.INSTANCE;\n                sourceRequested = false;\n            } else {\n                fieldSelector = new UidAndSourceFieldSelector();\n                sourceRequested = true;\n            }\n        } else if (context.fieldNames().isEmpty()) {\n            fieldSelector = UidFieldSelector.INSTANCE;\n            sourceRequested = false;\n        } else {\n            boolean loadAllStored = false;\n            FieldMappersFieldSelector fieldSelectorMapper = null;\n            for (String fieldName : context.fieldNames()) {\n                if (fieldName.equals(\"*\")) {\n                    loadAllStored = true;\n                    continue;\n                }\n                if (fieldName.equals(SourceFieldMapper.NAME)) {\n                    sourceRequested = true;\n                    continue;\n                }\n                FieldMappers x = context.smartNameFieldMappers(fieldName);\n                if (x != null && x.mapper().stored()) {\n                    if (fieldSelectorMapper == null) {\n                        fieldSelectorMapper = new FieldMappersFieldSelector();\n                    }\n                    fieldSelectorMapper.add(x);\n                } else {\n                    if (extractFieldNames == null) {\n                        extractFieldNames = Lists.newArrayList();\n                    }\n                    extractFieldNames.add(fieldName);\n                }\n            }\n\n            if (loadAllStored) {\n                if (sourceRequested || extractFieldNames != null) {\n                    fieldSelector = null; // load everything, including _source\n                } else {\n                    fieldSelector = AllButSourceFieldSelector.INSTANCE;\n                }\n            } else if (fieldSelectorMapper != null) {\n                // we are asking specific stored fields, just add the UID and be done\n                fieldSelectorMapper.add(UidFieldMapper.NAME);\n                if (extractFieldNames != null || sourceRequested) {\n                    fieldSelectorMapper.add(SourceFieldMapper.NAME);\n                }\n                fieldSelector = fieldSelectorMapper;\n            } else if (extractFieldNames != null || sourceRequested) {\n                fieldSelector = new UidAndSourceFieldSelector();\n            } else {\n                fieldSelector = UidFieldSelector.INSTANCE;\n            }\n        }\n\n        InternalSearchHit[] hits = new InternalSearchHit[context.docIdsToLoadSize()];\n        for (int index = 0; index < context.docIdsToLoadSize(); index++) {\n            int docId = context.docIdsToLoad()[context.docIdsToLoadFrom() + index];\n            Document doc = loadDocument(context, fieldSelector, docId);\n            Uid uid = extractUid(context, doc, fieldSelector);\n\n            DocumentMapper documentMapper = context.mapperService().documentMapper(uid.type());\n\n            if (documentMapper == null) {\n                throw new TypeMissingException(new Index(context.shardTarget().index()), uid.type(), \"failed to find type loaded for doc [\" + uid.id() + \"]\");\n            }\n\n            byte[] source = extractSource(doc, documentMapper);\n\n            // get the version\n\n            InternalSearchHit searchHit = new InternalSearchHit(docId, uid.id(), uid.type(), sourceRequested ? source : null, null);\n            hits[index] = searchHit;\n\n            for (Object oField : doc.getFields()) {\n                Fieldable field = (Fieldable) oField;\n                String name = field.name();\n\n                // ignore UID, we handled it above\n                if (name.equals(UidFieldMapper.NAME)) {\n                    continue;\n                }\n\n                // ignore source, we handled it above\n                if (name.equals(SourceFieldMapper.NAME)) {\n                    continue;\n                }\n\n                Object value = null;\n                FieldMappers fieldMappers = documentMapper.mappers().indexName(field.name());\n                if (fieldMappers != null) {\n                    FieldMapper mapper = fieldMappers.mapper();\n                    if (mapper != null) {\n                        name = mapper.names().fullName();\n                        value = mapper.valueForSearch(field);\n                    }\n                }\n                if (value == null) {\n                    if (field.isBinary()) {\n                        value = new BytesArray(field.getBinaryValue(), field.getBinaryOffset(), field.getBinaryLength());\n                    } else {\n                        value = field.stringValue();\n                    }\n                }\n\n                if (searchHit.fieldsOrNull() == null) {\n                    searchHit.fields(new HashMap<String, SearchHitField>(2));\n                }\n\n                SearchHitField hitField = searchHit.fields().get(name);\n                if (hitField == null) {\n                    hitField = new InternalSearchHitField(name, new ArrayList<Object>(2));\n                    searchHit.fields().put(name, hitField);\n                }\n                hitField.values().add(value);\n            }\n\n            int readerIndex = context.searcher().readerIndex(docId);\n            IndexReader subReader = context.searcher().subReaders()[readerIndex];\n            int subDoc = docId - context.searcher().docStarts()[readerIndex];\n\n            // go over and extract fields that are not mapped / stored\n            context.lookup().setNextReader(subReader);\n            context.lookup().setNextDocId(subDoc);\n            if (source != null) {\n                context.lookup().source().setNextSource(new BytesArray(source));\n            }\n            if (extractFieldNames != null) {\n                for (String extractFieldName : extractFieldNames) {\n                    Object value = context.lookup().source().extractValue(extractFieldName);\n                    if (value != null) {\n                        if (searchHit.fieldsOrNull() == null) {\n                            searchHit.fields(new HashMap<String, SearchHitField>(2));\n                        }\n\n                        SearchHitField hitField = searchHit.fields().get(extractFieldName);\n                        if (hitField == null) {\n                            hitField = new InternalSearchHitField(extractFieldName, new ArrayList<Object>(2));\n                            searchHit.fields().put(extractFieldName, hitField);\n                        }\n                        hitField.values().add(value);\n                    }\n                }\n            }\n\n            for (FetchSubPhase fetchSubPhase : fetchSubPhases) {\n                FetchSubPhase.HitContext hitContext = new FetchSubPhase.HitContext();\n                if (fetchSubPhase.hitExecutionNeeded(context)) {\n                    hitContext.reset(searchHit, subReader, subDoc, context.searcher().getIndexReader(), docId, doc);\n                    fetchSubPhase.hitExecute(context, hitContext);\n                }\n            }\n        }\n\n        for (FetchSubPhase fetchSubPhase : fetchSubPhases) {\n            if (fetchSubPhase.hitsExecutionNeeded(context)) {\n                fetchSubPhase.hitsExecute(context, hits);\n            }\n        }\n\n        context.fetchResult().hits(new InternalSearchHits(hits, context.queryResult().topDocs().totalHits, context.queryResult().topDocs().getMaxScore()));\n    }","commit_id":"1a085d9bfa9e29c43e9a2c3b25393a574ae2fa53","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public GetResult innerGet(String type, String id, String[] gFields, boolean realtime) throws ElasticSearchException {\n        boolean loadSource = gFields == null || gFields.length > 0;\n        Engine.GetResult get = null;\n        if (type == null || type.equals(\"_all\")) {\n            for (String typeX : mapperService.types()) {\n                get = indexShard.get(new Engine.Get(realtime, UidFieldMapper.TERM_FACTORY.createTerm(Uid.createUid(typeX, id))).loadSource(loadSource));\n                if (get.exists()) {\n                    type = typeX;\n                    break;\n                } else {\n                    get.release();\n                }\n            }\n            if (get == null) {\n                return new GetResult(shardId.index().name(), type, id, -1, false, null, null);\n            }\n            if (!get.exists()) {\n                // no need to release here as well..., we release in the for loop for non exists\n                return new GetResult(shardId.index().name(), type, id, -1, false, null, null);\n            }\n        } else {\n            get = indexShard.get(new Engine.Get(realtime, UidFieldMapper.TERM_FACTORY.createTerm(Uid.createUid(type, id))).loadSource(loadSource));\n            if (!get.exists()) {\n                get.release();\n                return new GetResult(shardId.index().name(), type, id, -1, false, null, null);\n            }\n        }\n\n        DocumentMapper docMapper = mapperService.documentMapper(type);\n        if (docMapper == null) {\n            get.release();\n            return new GetResult(shardId.index().name(), type, id, -1, false, null, null);\n        }\n\n        try {\n            // break between having loaded it from translog (so we only have _source), and having a document to load\n            if (get.docIdAndVersion() != null) {\n                Map<String, GetField> fields = null;\n                byte[] source = null;\n                UidField.DocIdAndVersion docIdAndVersion = get.docIdAndVersion();\n                ResetFieldSelector fieldSelector = buildFieldSelectors(docMapper, gFields);\n                if (fieldSelector != null) {\n                    fieldSelector.reset();\n                    Document doc;\n                    try {\n                        doc = docIdAndVersion.reader.document(docIdAndVersion.docId, fieldSelector);\n                    } catch (IOException e) {\n                        throw new ElasticSearchException(\"Failed to get type [\" + type + \"] and id [\" + id + \"]\", e);\n                    }\n                    source = extractSource(doc, docMapper);\n\n                    for (Object oField : doc.getFields()) {\n                        Fieldable field = (Fieldable) oField;\n                        String name = field.name();\n                        Object value = null;\n                        FieldMappers fieldMappers = docMapper.mappers().indexName(field.name());\n                        if (fieldMappers != null) {\n                            FieldMapper mapper = fieldMappers.mapper();\n                            if (mapper != null) {\n                                name = mapper.names().fullName();\n                                value = mapper.valueForSearch(field);\n                            }\n                        }\n                        if (value == null) {\n                            if (field.isBinary()) {\n                                value = field.getBinaryValue();\n                            } else {\n                                value = field.stringValue();\n                            }\n                        }\n\n                        if (fields == null) {\n                            fields = newHashMapWithExpectedSize(2);\n                        }\n\n                        GetField getField = fields.get(name);\n                        if (getField == null) {\n                            getField = new GetField(name, new ArrayList<Object>(2));\n                            fields.put(name, getField);\n                        }\n                        getField.values().add(value);\n                    }\n                }\n\n                // now, go and do the script thingy if needed\n                if (gFields != null && gFields.length > 0) {\n                    SearchLookup searchLookup = null;\n                    for (String field : gFields) {\n                        Object value = null;\n                        if (field.contains(\"_source.\") || field.contains(\"doc[\")) {\n                            if (searchLookup == null) {\n                                searchLookup = new SearchLookup(mapperService, indexCache.fieldData(), new String[]{type});\n                            }\n                            SearchScript searchScript = scriptService.search(searchLookup, \"mvel\", field, null);\n                            searchScript.setNextReader(docIdAndVersion.reader);\n                            searchScript.setNextDocId(docIdAndVersion.docId);\n\n                            try {\n                                value = searchScript.run();\n                            } catch (RuntimeException e) {\n                                if (logger.isTraceEnabled()) {\n                                    logger.trace(\"failed to execute get request script field [{}]\", e, field);\n                                }\n                                // ignore\n                            }\n                        } else {\n                            FieldMappers x = docMapper.mappers().smartName(field);\n                            if (x == null || !x.mapper().stored()) {\n                                if (searchLookup == null) {\n                                    searchLookup = new SearchLookup(mapperService, indexCache.fieldData(), new String[]{type});\n                                    searchLookup.setNextReader(docIdAndVersion.reader);\n                                    searchLookup.setNextDocId(docIdAndVersion.docId);\n                                }\n                                value = searchLookup.source().extractValue(field);\n                            }\n                        }\n\n                        if (value != null) {\n                            if (fields == null) {\n                                fields = newHashMapWithExpectedSize(2);\n                            }\n                            GetField getField = fields.get(field);\n                            if (getField == null) {\n                                getField = new GetField(field, new ArrayList<Object>(2));\n                                fields.put(field, getField);\n                            }\n                            getField.values().add(value);\n                        }\n                    }\n                }\n\n                return new GetResult(shardId.index().name(), type, id, get.version(), get.exists(), source == null ? null : new BytesArray(source), fields);\n            } else {\n                Translog.Source source = get.source();\n\n                Map<String, GetField> fields = null;\n                boolean sourceRequested = false;\n\n                // we can only load scripts that can run against the source\n                if (gFields == null) {\n                    sourceRequested = true;\n                } else if (gFields.length == 0) {\n                    // no fields, and no source\n                    sourceRequested = false;\n                } else {\n                    Map<String, Object> sourceAsMap = null;\n                    SearchLookup searchLookup = null;\n                    for (String field : gFields) {\n                        if (field.equals(\"_source\")) {\n                            sourceRequested = true;\n                            continue;\n                        }\n                        Object value = null;\n                        if (field.equals(RoutingFieldMapper.NAME) && docMapper.routingFieldMapper().stored()) {\n                            value = source.routing;\n                        } else if (field.equals(ParentFieldMapper.NAME) && docMapper.parentFieldMapper() != null && docMapper.parentFieldMapper().stored()) {\n                            value = source.parent;\n                        } else if (field.equals(TimestampFieldMapper.NAME) && docMapper.timestampFieldMapper().stored()) {\n                            value = source.timestamp;\n                        } else if (field.equals(TTLFieldMapper.NAME) && docMapper.TTLFieldMapper().stored()) {\n                            // Call value for search with timestamp + ttl here to display the live remaining ttl value and be consistent with the search result display\n                            if (source.ttl > 0) {\n                                value = docMapper.TTLFieldMapper().valueForSearch(source.timestamp + source.ttl);\n                            }\n                        } else if (field.equals(SizeFieldMapper.NAME) && docMapper.rootMapper(SizeFieldMapper.class).stored()) {\n                            value = source.source.length();\n                        } else {\n                            if (field.contains(\"_source.\")) {\n                                if (searchLookup == null) {\n                                    searchLookup = new SearchLookup(mapperService, indexCache.fieldData(), new String[]{type});\n                                }\n                                if (sourceAsMap == null) {\n                                    sourceAsMap = SourceLookup.sourceAsMap(source.source);\n                                }\n                                SearchScript searchScript = scriptService.search(searchLookup, \"mvel\", field, null);\n                                // we can't do this, only allow to run scripts against the source\n                                //searchScript.setNextReader(docIdAndVersion.reader);\n                                //searchScript.setNextDocId(docIdAndVersion.docId);\n\n                                // but, we need to inject the parsed source into the script, so it will be used...\n                                searchScript.setNextSource(sourceAsMap);\n\n                                try {\n                                    value = searchScript.run();\n                                } catch (RuntimeException e) {\n                                    if (logger.isTraceEnabled()) {\n                                        logger.trace(\"failed to execute get request script field [{}]\", e, field);\n                                    }\n                                    // ignore\n                                }\n                            } else {\n                                if (searchLookup == null) {\n                                    searchLookup = new SearchLookup(mapperService, indexCache.fieldData(), new String[]{type});\n                                    searchLookup.source().setNextSource(source.source);\n                                }\n\n                                FieldMapper<?> x = docMapper.mappers().smartNameFieldMapper(field);\n                                // only if the field is stored or source is enabled we should add it..\n                                if (docMapper.sourceMapper().enabled() || x == null || x.stored()) {\n                                    value = searchLookup.source().extractValue(field);\n                                    if (x != null && value instanceof String) {\n                                        value = x.valueFromString((String) value);\n                                    }\n                                }\n                            }\n                        }\n                        if (value != null) {\n                            if (fields == null) {\n                                fields = newHashMapWithExpectedSize(2);\n                            }\n                            GetField getField = fields.get(field);\n                            if (getField == null) {\n                                getField = new GetField(field, new ArrayList<Object>(2));\n                                fields.put(field, getField);\n                            }\n                            getField.values().add(value);\n                        }\n                    }\n                }\n\n                // if source is not enabled, don't return it even though we have it from the translog\n                if (sourceRequested && !docMapper.sourceMapper().enabled()) {\n                    sourceRequested = false;\n                }\n\n                return new GetResult(shardId.index().name(), type, id, get.version(), get.exists(), sourceRequested ? source.source : null, fields);\n            }\n        } finally {\n            get.release();\n        }\n    }","id":75963,"modified_method":"public GetResult innerGet(String type, String id, String[] gFields, boolean realtime) throws ElasticSearchException {\n        boolean loadSource = gFields == null || gFields.length > 0;\n        Engine.GetResult get = null;\n        if (type == null || type.equals(\"_all\")) {\n            for (String typeX : mapperService.types()) {\n                get = indexShard.get(new Engine.Get(realtime, UidFieldMapper.TERM_FACTORY.createTerm(Uid.createUid(typeX, id))).loadSource(loadSource));\n                if (get.exists()) {\n                    type = typeX;\n                    break;\n                } else {\n                    get.release();\n                }\n            }\n            if (get == null) {\n                return new GetResult(shardId.index().name(), type, id, -1, false, null, null);\n            }\n            if (!get.exists()) {\n                // no need to release here as well..., we release in the for loop for non exists\n                return new GetResult(shardId.index().name(), type, id, -1, false, null, null);\n            }\n        } else {\n            get = indexShard.get(new Engine.Get(realtime, UidFieldMapper.TERM_FACTORY.createTerm(Uid.createUid(type, id))).loadSource(loadSource));\n            if (!get.exists()) {\n                get.release();\n                return new GetResult(shardId.index().name(), type, id, -1, false, null, null);\n            }\n        }\n\n        DocumentMapper docMapper = mapperService.documentMapper(type);\n        if (docMapper == null) {\n            get.release();\n            return new GetResult(shardId.index().name(), type, id, -1, false, null, null);\n        }\n\n        try {\n            // break between having loaded it from translog (so we only have _source), and having a document to load\n            if (get.docIdAndVersion() != null) {\n                Map<String, GetField> fields = null;\n                byte[] source = null;\n                UidField.DocIdAndVersion docIdAndVersion = get.docIdAndVersion();\n                ResetFieldSelector fieldSelector = buildFieldSelectors(docMapper, gFields);\n                if (fieldSelector != null) {\n                    fieldSelector.reset();\n                    Document doc;\n                    try {\n                        doc = docIdAndVersion.reader.document(docIdAndVersion.docId, fieldSelector);\n                    } catch (IOException e) {\n                        throw new ElasticSearchException(\"Failed to get type [\" + type + \"] and id [\" + id + \"]\", e);\n                    }\n                    source = extractSource(doc, docMapper);\n\n                    for (Object oField : doc.getFields()) {\n                        Fieldable field = (Fieldable) oField;\n                        String name = field.name();\n                        Object value = null;\n                        FieldMappers fieldMappers = docMapper.mappers().indexName(field.name());\n                        if (fieldMappers != null) {\n                            FieldMapper mapper = fieldMappers.mapper();\n                            if (mapper != null) {\n                                name = mapper.names().fullName();\n                                value = mapper.valueForSearch(field);\n                            }\n                        }\n                        if (value == null) {\n                            if (field.isBinary()) {\n                                value = new BytesArray(field.getBinaryValue(), field.getBinaryOffset(), field.getBinaryLength());\n                            } else {\n                                value = field.stringValue();\n                            }\n                        }\n\n                        if (fields == null) {\n                            fields = newHashMapWithExpectedSize(2);\n                        }\n\n                        GetField getField = fields.get(name);\n                        if (getField == null) {\n                            getField = new GetField(name, new ArrayList<Object>(2));\n                            fields.put(name, getField);\n                        }\n                        getField.values().add(value);\n                    }\n                }\n\n                // now, go and do the script thingy if needed\n                if (gFields != null && gFields.length > 0) {\n                    SearchLookup searchLookup = null;\n                    for (String field : gFields) {\n                        Object value = null;\n                        if (field.contains(\"_source.\") || field.contains(\"doc[\")) {\n                            if (searchLookup == null) {\n                                searchLookup = new SearchLookup(mapperService, indexCache.fieldData(), new String[]{type});\n                            }\n                            SearchScript searchScript = scriptService.search(searchLookup, \"mvel\", field, null);\n                            searchScript.setNextReader(docIdAndVersion.reader);\n                            searchScript.setNextDocId(docIdAndVersion.docId);\n\n                            try {\n                                value = searchScript.run();\n                            } catch (RuntimeException e) {\n                                if (logger.isTraceEnabled()) {\n                                    logger.trace(\"failed to execute get request script field [{}]\", e, field);\n                                }\n                                // ignore\n                            }\n                        } else {\n                            FieldMappers x = docMapper.mappers().smartName(field);\n                            if (x == null || !x.mapper().stored()) {\n                                if (searchLookup == null) {\n                                    searchLookup = new SearchLookup(mapperService, indexCache.fieldData(), new String[]{type});\n                                    searchLookup.setNextReader(docIdAndVersion.reader);\n                                    searchLookup.setNextDocId(docIdAndVersion.docId);\n                                }\n                                value = searchLookup.source().extractValue(field);\n                            }\n                        }\n\n                        if (value != null) {\n                            if (fields == null) {\n                                fields = newHashMapWithExpectedSize(2);\n                            }\n                            GetField getField = fields.get(field);\n                            if (getField == null) {\n                                getField = new GetField(field, new ArrayList<Object>(2));\n                                fields.put(field, getField);\n                            }\n                            getField.values().add(value);\n                        }\n                    }\n                }\n\n                return new GetResult(shardId.index().name(), type, id, get.version(), get.exists(), source == null ? null : new BytesArray(source), fields);\n            } else {\n                Translog.Source source = get.source();\n\n                Map<String, GetField> fields = null;\n                boolean sourceRequested = false;\n\n                // we can only load scripts that can run against the source\n                if (gFields == null) {\n                    sourceRequested = true;\n                } else if (gFields.length == 0) {\n                    // no fields, and no source\n                    sourceRequested = false;\n                } else {\n                    Map<String, Object> sourceAsMap = null;\n                    SearchLookup searchLookup = null;\n                    for (String field : gFields) {\n                        if (field.equals(\"_source\")) {\n                            sourceRequested = true;\n                            continue;\n                        }\n                        Object value = null;\n                        if (field.equals(RoutingFieldMapper.NAME) && docMapper.routingFieldMapper().stored()) {\n                            value = source.routing;\n                        } else if (field.equals(ParentFieldMapper.NAME) && docMapper.parentFieldMapper() != null && docMapper.parentFieldMapper().stored()) {\n                            value = source.parent;\n                        } else if (field.equals(TimestampFieldMapper.NAME) && docMapper.timestampFieldMapper().stored()) {\n                            value = source.timestamp;\n                        } else if (field.equals(TTLFieldMapper.NAME) && docMapper.TTLFieldMapper().stored()) {\n                            // Call value for search with timestamp + ttl here to display the live remaining ttl value and be consistent with the search result display\n                            if (source.ttl > 0) {\n                                value = docMapper.TTLFieldMapper().valueForSearch(source.timestamp + source.ttl);\n                            }\n                        } else if (field.equals(SizeFieldMapper.NAME) && docMapper.rootMapper(SizeFieldMapper.class).stored()) {\n                            value = source.source.length();\n                        } else {\n                            if (field.contains(\"_source.\")) {\n                                if (searchLookup == null) {\n                                    searchLookup = new SearchLookup(mapperService, indexCache.fieldData(), new String[]{type});\n                                }\n                                if (sourceAsMap == null) {\n                                    sourceAsMap = SourceLookup.sourceAsMap(source.source);\n                                }\n                                SearchScript searchScript = scriptService.search(searchLookup, \"mvel\", field, null);\n                                // we can't do this, only allow to run scripts against the source\n                                //searchScript.setNextReader(docIdAndVersion.reader);\n                                //searchScript.setNextDocId(docIdAndVersion.docId);\n\n                                // but, we need to inject the parsed source into the script, so it will be used...\n                                searchScript.setNextSource(sourceAsMap);\n\n                                try {\n                                    value = searchScript.run();\n                                } catch (RuntimeException e) {\n                                    if (logger.isTraceEnabled()) {\n                                        logger.trace(\"failed to execute get request script field [{}]\", e, field);\n                                    }\n                                    // ignore\n                                }\n                            } else {\n                                if (searchLookup == null) {\n                                    searchLookup = new SearchLookup(mapperService, indexCache.fieldData(), new String[]{type});\n                                    searchLookup.source().setNextSource(source.source);\n                                }\n\n                                FieldMapper<?> x = docMapper.mappers().smartNameFieldMapper(field);\n                                // only if the field is stored or source is enabled we should add it..\n                                if (docMapper.sourceMapper().enabled() || x == null || x.stored()) {\n                                    value = searchLookup.source().extractValue(field);\n                                    if (x != null && value instanceof String) {\n                                        value = x.valueFromString((String) value);\n                                    }\n                                }\n                            }\n                        }\n                        if (value != null) {\n                            if (fields == null) {\n                                fields = newHashMapWithExpectedSize(2);\n                            }\n                            GetField getField = fields.get(field);\n                            if (getField == null) {\n                                getField = new GetField(field, new ArrayList<Object>(2));\n                                fields.put(field, getField);\n                            }\n                            getField.values().add(value);\n                        }\n                    }\n                }\n\n                // if source is not enabled, don't return it even though we have it from the translog\n                if (sourceRequested && !docMapper.sourceMapper().enabled()) {\n                    sourceRequested = false;\n                }\n\n                return new GetResult(shardId.index().name(), type, id, get.version(), get.exists(), sourceRequested ? source.source : null, fields);\n            }\n        } finally {\n            get.release();\n        }\n    }","commit_id":"1a085d9bfa9e29c43e9a2c3b25393a574ae2fa53","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n   * (Blueprints Extension) Sets multiple properties in one shot against Vertices and Edges. This improves performance avoiding to\n   * save the graph element at every property set. Example:\n   * \n   * <code>\n   * vertex.setProperties( \"name\", \"Jill\", \"age\", 33, \"city\", \"Rome\", \"born\", \"Victoria, TX\" );\n   * <\/code> You can also pass a Map of values as first argument. In this case all the map entries will be set as element\n   * properties:\n   * \n   * <code>\n   * Map<String,Object> props = new HashMap<String,Object>();\n   * props.put(\"name\", \"Jill\");\n   * props.put(\"age\", 33);\n   * props.put(\"city\", \"Rome\");\n   * props.put(\"born\", \"Victoria, TX\");\n   * vertex.setProperties(props);\n   * <\/code>\n   * \n   * @param fields\n   *          Odd number of fields to set as repeating pairs of key, value, or if one parameter is received and it's a Map, the Map\n   *          entries are used as field key/value pairs.\n   * @param <T>\n   * @return\n   */\n  public <T extends OrientElement> T setProperties(final Object... fields) {\n    if (fields != null && fields.length > 0 && fields[0] != null) {\n      if (!isDetached())\n        graph.autoStartTransaction();\n\n      if (fields.length == 1) {\n        Object f = fields[0];\n        if (f instanceof Map<?, ?>) {\n          for (Map.Entry<Object, Object> entry : ((Map<Object, Object>) f).entrySet())\n            setPropertyInternal(this, (ODocument) rawElement.getRecord(), entry.getKey().toString(), entry.getValue());\n\n        } else\n          throw new IllegalArgumentException(\n              \"Invalid fields: expecting a pairs of fields as String,Object or a single Map<String,Object>, but found: \" + f);\n      } else\n        // SET THE FIELDS\n        for (int i = 0; i < fields.length; i += 2)\n          setPropertyInternal(this, (ODocument) rawElement.getRecord(), fields[i].toString(), fields[i + 1]);\n    }\n    return (T) this;\n  }","id":75964,"modified_method":"/**\n   * (Blueprints Extension) Sets multiple properties in one shot against Vertices and Edges. This improves performance avoiding to\n   * save the graph element at every property set. Example:\n   * \n   * <code>\n   * vertex.setProperties( \"name\", \"Jill\", \"age\", 33, \"city\", \"Rome\", \"born\", \"Victoria, TX\" );\n   * <\/code> You can also pass a Map of values as first argument. In this case all the map entries will be set as element\n   * properties:\n   * \n   * <code>\n   * Map<String,Object> props = new HashMap<String,Object>();\n   * props.put(\"name\", \"Jill\");\n   * props.put(\"age\", 33);\n   * props.put(\"city\", \"Rome\");\n   * props.put(\"born\", \"Victoria, TX\");\n   * vertex.setProperties(props);\n   * <\/code>\n   * \n   * @param fields\n   *          Odd number of fields to set as repeating pairs of key, value, or if one parameter is received and it's a Map, the Map\n   *          entries are used as field key/value pairs.\n   * @param <T>\n   * @return\n   */\n  public <T extends OrientElement> T setProperties(final Object... fields) {\n    if (fields != null && fields.length > 0 && fields[0] != null) {\n      if (!isDetached())\n        graph.autoStartTransaction();\n\n      if (fields.length == 1) {\n        Object f = fields[0];\n        if (f instanceof Map<?, ?>) {\n          for (Map.Entry<Object, Object> entry : ((Map<Object, Object>) f).entrySet())\n            setPropertyInternal(this, (ODocument) rawElement.getRecord(), entry.getKey().toString(), entry.getValue());\n\n        } else\n          throw new IllegalArgumentException(\n              \"Invalid fields: expecting a pairs of fields as String,Object or a single Map<String,Object>, but found: \" + f);\n      } else {\n        if (fields.length % 2 != 0)\n          throw new IllegalArgumentException(\n              \"Invalid fields: expecting a pairs of fields as String,Object or a single Map<String,Object>, but found: \"\n                  + Arrays.toString(fields));\n\n        // SET THE FIELDS\n        for (int i = 0; i < fields.length; i += 2)\n          setPropertyInternal(this, (ODocument) rawElement.getRecord(), fields[i].toString(), fields[i + 1]);\n      }\n    }\n    return (T) this;\n  }","commit_id":"1721dbd9a25b28a2d0313b642c834397bfde950a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n   * Creates an edge between current Vertex and a target Vertex setting label as Edge's label. The fields parameter is an Array of\n   * fields to set on Edge upon creation. Fields must be a odd pairs of key/value or a single object as Map containing entries as\n   * key/value pairs. iClusterName is the name of the cluster where to store the new Edge.\n   * \n   * @param label\n   *          Edge's label or class\n   * @param inVertex\n   *          Outgoing target vertex\n   * @param fields\n   *          Fields must be a odd pairs of key/value or a single object as Map containing entries as key/value pairs\n   * @param iClassName\n   *          Edge's class name\n   * @param iClusterName\n   *          The cluster name where to store the edge record\n   * @return The new Edge created\n   */\n  public OrientEdge addEdge(String label, final OrientVertex inVertex, final String iClassName, final String iClusterName,\n      final Object... fields) {\n    if (inVertex == null)\n      throw new IllegalArgumentException(\"destination vertex is null\");\n\n    if (graph != null) {\n      setCurrentGraphInThreadLocal();\n      graph.autoStartTransaction();\n    }\n\n    // TEMPORARY STATIC LOCK TO AVOID MT PROBLEMS AGAINST OMVRBTreeRID\n    final ODocument outDocument = getRecord();\n    final ODocument inDocument = inVertex.getRecord();\n\n    final OrientEdge edge;\n    OIdentifiable to;\n    OIdentifiable from;\n\n    label = OrientBaseGraph.encodeClassName(label);\n    if (label == null && iClassName != null)\n      // RETRO-COMPATIBILITY WITH THE SYNTAX CLASS:<CLASS-NAME>\n      label = OrientBaseGraph.encodeClassName(iClassName);\n\n    final String outFieldName = getConnectionFieldName(Direction.OUT, label, settings.useVertexFieldsForEdgeLabels);\n    final String inFieldName = getConnectionFieldName(Direction.IN, label, settings.useVertexFieldsForEdgeLabels);\n\n    // since the label for the edge can potentially get re-assigned\n    // before being pushed into the OrientEdge, the\n    // null check has to go here.\n    if (label == null)\n      throw ExceptionFactory.edgeLabelCanNotBeNull();\n\n    if (canCreateDynamicEdge(outDocument, inDocument, outFieldName, inFieldName, fields, label)) {\n      // CREATE A LIGHTWEIGHT DYNAMIC EDGE\n      from = rawElement;\n      to = inDocument;\n      if (settings.keepInMemoryReferences)\n        edge = new OrientEdge(graph, from.getIdentity(), to.getIdentity(), label);\n      else\n        edge = new OrientEdge(graph, from, to, label);\n    } else {\n      // CREATE THE EDGE DOCUMENT TO STORE FIELDS TOO\n      edge = new OrientEdge(graph, label, fields);\n\n      if (settings.keepInMemoryReferences)\n        edge.getRecord().fields(OrientBaseGraph.CONNECTION_OUT, rawElement.getIdentity(), OrientBaseGraph.CONNECTION_IN,\n            inDocument.getIdentity());\n      else\n        edge.getRecord().fields(OrientBaseGraph.CONNECTION_OUT, rawElement, OrientBaseGraph.CONNECTION_IN, inDocument);\n\n      from = (OIdentifiable) edge.getRecord();\n      to = (OIdentifiable) edge.getRecord();\n    }\n\n    if (settings.keepInMemoryReferences) {\n      // USES REFERENCES INSTEAD OF DOCUMENTS\n      from = from.getIdentity();\n      to = to.getIdentity();\n    }\n\n    // OUT-VERTEX ---> IN-VERTEX/EDGE\n    createLink(graph, outDocument, to, outFieldName);\n\n    // IN-VERTEX ---> OUT-VERTEX/EDGE\n    createLink(graph, inDocument, from, inFieldName);\n\n    if (graph != null) {\n      edge.save(iClusterName);\n      inDocument.save();\n      outDocument.save();\n    }\n    return edge;\n\n  }","id":75965,"modified_method":"/**\n   * Creates an edge between current Vertex and a target Vertex setting label as Edge's label. The fields parameter is an Array of\n   * fields to set on Edge upon creation. Fields must be a odd pairs of key/value or a single object as Map containing entries as\n   * key/value pairs. iClusterName is the name of the cluster where to store the new Edge.\n   * \n   * @param label\n   *          Edge's label or class\n   * @param inVertex\n   *          Outgoing target vertex\n   * @param fields\n   *          Fields must be a odd pairs of key/value or a single object as Map containing entries as key/value pairs\n   * @param iClassName\n   *          Edge's class name\n   * @param iClusterName\n   *          The cluster name where to store the edge record\n   * @return The new Edge created\n   */\n  public OrientEdge addEdge(String label, final OrientVertex inVertex, final String iClassName, final String iClusterName,\n      final Object... fields) {\n    if (inVertex == null)\n      throw new IllegalArgumentException(\"destination vertex is null\");\n\n    if (graph != null) {\n      setCurrentGraphInThreadLocal();\n      graph.autoStartTransaction();\n    }\n\n    // TEMPORARY STATIC LOCK TO AVOID MT PROBLEMS AGAINST OMVRBTreeRID\n    final ODocument outDocument = getRecord();\n    if (outDocument == null)\n      throw new IllegalArgumentException(\"source vertex is invalid (rid=\" + getIdentity() + \")\");\n\n    final ODocument inDocument = inVertex.getRecord();\n    if (inDocument == null)\n      throw new IllegalArgumentException(\"destination vertex is invalid (rid=\" + inVertex.getIdentity() + \")\");\n\n    final OrientEdge edge;\n    OIdentifiable to;\n    OIdentifiable from;\n\n    label = OrientBaseGraph.encodeClassName(label);\n    if (label == null && iClassName != null)\n      // RETRO-COMPATIBILITY WITH THE SYNTAX CLASS:<CLASS-NAME>\n      label = OrientBaseGraph.encodeClassName(iClassName);\n\n    final String outFieldName = getConnectionFieldName(Direction.OUT, label, settings.useVertexFieldsForEdgeLabels);\n    final String inFieldName = getConnectionFieldName(Direction.IN, label, settings.useVertexFieldsForEdgeLabels);\n\n    // since the label for the edge can potentially get re-assigned\n    // before being pushed into the OrientEdge, the\n    // null check has to go here.\n    if (label == null)\n      throw ExceptionFactory.edgeLabelCanNotBeNull();\n\n    if (canCreateDynamicEdge(outDocument, inDocument, outFieldName, inFieldName, fields, label)) {\n      // CREATE A LIGHTWEIGHT DYNAMIC EDGE\n      from = rawElement;\n      to = inDocument;\n      if (settings.keepInMemoryReferences)\n        edge = new OrientEdge(graph, from.getIdentity(), to.getIdentity(), label);\n      else\n        edge = new OrientEdge(graph, from, to, label);\n    } else {\n      // CREATE THE EDGE DOCUMENT TO STORE FIELDS TOO\n      edge = new OrientEdge(graph, label, fields);\n\n      if (settings.keepInMemoryReferences)\n        edge.getRecord().fields(OrientBaseGraph.CONNECTION_OUT, rawElement.getIdentity(), OrientBaseGraph.CONNECTION_IN,\n            inDocument.getIdentity());\n      else\n        edge.getRecord().fields(OrientBaseGraph.CONNECTION_OUT, rawElement, OrientBaseGraph.CONNECTION_IN, inDocument);\n\n      from = (OIdentifiable) edge.getRecord();\n      to = (OIdentifiable) edge.getRecord();\n    }\n\n    if (settings.keepInMemoryReferences) {\n      // USES REFERENCES INSTEAD OF DOCUMENTS\n      from = from.getIdentity();\n      to = to.getIdentity();\n    }\n\n    // OUT-VERTEX ---> IN-VERTEX/EDGE\n    createLink(graph, outDocument, to, outFieldName);\n\n    // IN-VERTEX ---> OUT-VERTEX/EDGE\n    createLink(graph, inDocument, from, inFieldName);\n\n    if (graph != null) {\n      edge.save(iClusterName);\n      inDocument.save();\n      outDocument.save();\n    }\n    return edge;\n\n  }","commit_id":"1721dbd9a25b28a2d0313b642c834397bfde950a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n   * Returns a string representation of the vertex.\n   */\n  public String toString() {\n    if (graph != null)\n      graph.setCurrentGraphInThreadLocal();\n\n    final String clsName = getRecord().getClassName();\n\n    if (OrientVertexType.CLASS_NAME.equals(clsName))\n      return StringFactory.vertexString(this);\n\n    return StringFactory.V + \"(\" + clsName + \")\" + StringFactory.L_BRACKET + getId() + StringFactory.R_BRACKET;\n  }","id":75966,"modified_method":"/**\n   * Returns a string representation of the vertex.\n   */\n  public String toString() {\n    if (graph != null)\n      graph.setCurrentGraphInThreadLocal();\n\n    final ODocument record = getRecord();\n    if (record == null)\n      return \"<invalid record \" + rawElement.getIdentity() + \">\";\n\n    final String clsName = record.getClassName();\n\n    if (OrientVertexType.CLASS_NAME.equals(clsName))\n      return StringFactory.vertexString(this);\n\n    return StringFactory.V + \"(\" + clsName + \")\" + StringFactory.L_BRACKET + getId() + StringFactory.R_BRACKET;\n  }","commit_id":"1721dbd9a25b28a2d0313b642c834397bfde950a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected Object evaluate(OIdentifiable iCurrentRecord, final ODocument iCurrentResult, final Object iValue,\r\n      final OCommandContext iContext) {\r\n    if (iValue == null)\r\n      return null;\r\n\r\n    if (iCurrentRecord != null && iCurrentRecord.getRecord().getInternalStatus() == ORecordElement.STATUS.NOT_LOADED) {\r\n      try {\r\n        iCurrentRecord = iCurrentRecord.getRecord().load();\r\n      } catch (ORecordNotFoundException e) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    if (iValue instanceof OSQLFilterItem) {\r\n      return ((OSQLFilterItem) iValue).getValue(iCurrentRecord, iCurrentResult, iContext);\r\n    }\r\n\r\n    if (iValue instanceof OSQLFilterCondition) {\r\n      // NESTED CONDITION: EVALUATE IT RECURSIVELY\r\n      return ((OSQLFilterCondition) iValue).evaluate(iCurrentRecord, iCurrentResult, iContext);\r\n    }\r\n\r\n    if (iValue instanceof OSQLFunctionRuntime) {\r\n      // STATELESS FUNCTION: EXECUTE IT\r\n      final OSQLFunctionRuntime f = (OSQLFunctionRuntime) iValue;\r\n      return f.execute(iCurrentRecord, iCurrentRecord, iCurrentResult, iContext);\r\n    }\r\n\r\n    if (OMultiValue.isMultiValue(iValue)) {\r\n      final Iterable<?> multiValue = OMultiValue.getMultiValueIterable(iValue);\r\n\r\n      // MULTI VALUE: RETURN A COPY\r\n      final ArrayList<Object> result = new ArrayList<Object>(OMultiValue.getSize(iValue));\r\n\r\n      for (final Object value : multiValue) {\r\n        if (value instanceof OSQLFilterItem) {\r\n          result.add(((OSQLFilterItem) value).getValue(iCurrentRecord, iCurrentResult, iContext));\r\n        } else {\r\n          result.add(value);\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    // SIMPLE VALUE: JUST RETURN IT\r\n    return iValue;\r\n  }","id":75967,"modified_method":"protected Object evaluate(OIdentifiable iCurrentRecord, final ODocument iCurrentResult, final Object iValue,\r\n      final OCommandContext iContext) {\r\n    if (iValue == null)\r\n      return null;\r\n\r\n    if (iCurrentRecord != null) {\r\n      iCurrentRecord = iCurrentRecord.getRecord();\r\n      if (iCurrentRecord!=null && ((ODocument)iCurrentRecord).getInternalStatus() == ORecordElement.STATUS.NOT_LOADED) {\r\n        try {\r\n          iCurrentRecord = iCurrentRecord.getRecord().load();\r\n        } catch (ORecordNotFoundException e) {\r\n          return null;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (iValue instanceof OSQLFilterItem) {\r\n      return ((OSQLFilterItem) iValue).getValue(iCurrentRecord, iCurrentResult, iContext);\r\n    }\r\n\r\n    if (iValue instanceof OSQLFilterCondition) {\r\n      // NESTED CONDITION: EVALUATE IT RECURSIVELY\r\n      return ((OSQLFilterCondition) iValue).evaluate(iCurrentRecord, iCurrentResult, iContext);\r\n    }\r\n\r\n    if (iValue instanceof OSQLFunctionRuntime) {\r\n      // STATELESS FUNCTION: EXECUTE IT\r\n      final OSQLFunctionRuntime f = (OSQLFunctionRuntime) iValue;\r\n      return f.execute(iCurrentRecord, iCurrentRecord, iCurrentResult, iContext);\r\n    }\r\n\r\n    if (OMultiValue.isMultiValue(iValue)) {\r\n      final Iterable<?> multiValue = OMultiValue.getMultiValueIterable(iValue);\r\n\r\n      // MULTI VALUE: RETURN A COPY\r\n      final ArrayList<Object> result = new ArrayList<Object>(OMultiValue.getSize(iValue));\r\n\r\n      for (final Object value : multiValue) {\r\n        if (value instanceof OSQLFilterItem) {\r\n          result.add(((OSQLFilterItem) value).getValue(iCurrentRecord, iCurrentResult, iContext));\r\n        } else {\r\n          result.add(value);\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    // SIMPLE VALUE: JUST RETURN IT\r\n    return iValue;\r\n  }","commit_id":"e8a50f5feaa01b99a4fbf4f558dd0b6c8f16d3b6","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public void convertLinks2Records() {\n    doDeserialization();\n\n    for (int i = 0; i < entriesLength; i++) {\n      final Object entry = entries[i];\n\n      if (entry instanceof OIdentifiable) {\n        final OIdentifiable identifiable = (OIdentifiable) entry;\n        entries[i] = identifiable.getRecord();\n      }\n    }\n  }","id":75968,"modified_method":"@Override\n  public void convertLinks2Records() {\n    doDeserialization();\n\n    for (int i = 0; i < entriesLength; i++) {\n      final Object entry = entries[i];\n\n      if (entry instanceof OIdentifiable) {\n        final OIdentifiable identifiable = (OIdentifiable) entry;\n        ORecord record = identifiable.getRecord();\n        if (record != null)\n          entries[i] = record;\n      }\n    }\n  }","commit_id":"7c9d4d91a69eca277d224362c45aac48ee64553f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public static ODocument applyRecord(final ODocument iValue, final Map<String, Object> iProjections,\r\n      final OCommandContext iContext, final OIdentifiable iRecord) {\r\n    // APPLY PROJECTIONS\r\n    final ODocument inputDocument = (ODocument) (iRecord != null ? iRecord.getRecord() : null);\r\n\r\n    if (iProjections.isEmpty())\r\n      // SELECT * CASE\r\n      inputDocument.copyTo(iValue);\r\n    else {\r\n\r\n      for (Entry<String, Object> projection : iProjections.entrySet()) {\r\n        final Object v = projection.getValue();\r\n\r\n        if (v == null)\r\n          continue;\r\n\r\n        final Object projectionValue;\r\n        if (v.equals(\"*\")) {\r\n          // COPY ALL\r\n          inputDocument.copyTo(iValue);\r\n          projectionValue = null;\r\n        } else if (v instanceof OSQLFilterItemVariable) {\r\n          // RETURN A VARIABLE FROM THE CONTEXT\r\n          projectionValue = ((OSQLFilterItemVariable) v).getValue(inputDocument, iValue, iContext);\r\n        } else if (v instanceof OSQLFilterItemField)\r\n          projectionValue = ((OSQLFilterItemField) v).getValue(inputDocument, iValue, iContext);\r\n        else if (v instanceof OSQLFunctionRuntime) {\r\n          final OSQLFunctionRuntime f = (OSQLFunctionRuntime) v;\r\n          projectionValue = f.execute(inputDocument, inputDocument, iValue, iContext);\r\n        } else\r\n          projectionValue = v;\r\n\r\n        if (projectionValue != null)\r\n          if (projectionValue instanceof ORidBag)\r\n            iValue.field(projection.getKey(), new ORidBag((ORidBag) projectionValue));\r\n          else if (projectionValue instanceof OIdentifiable && !(projectionValue instanceof ORID)\r\n              && !(projectionValue instanceof ORecord))\r\n            iValue.field(projection.getKey(), ((OIdentifiable) projectionValue).getRecord());\r\n          else if (projectionValue instanceof Iterator) {\r\n            // make temporary value typical case graph database elemenet's iterator edges\r\n            if (projectionValue instanceof OResettable)\r\n              ((OResettable) projectionValue).reset();\r\n\r\n            final List<Object> iteratorValues = new ArrayList<Object>();\r\n            final Iterator projectionValueIterator = (Iterator) projectionValue;\r\n            while (projectionValueIterator.hasNext()) {\r\n              final Object value = projectionValueIterator.next();\r\n              if (value instanceof OIdentifiable && !(value instanceof ORID) && !(value instanceof ORecord))\r\n                iteratorValues.add(((OIdentifiable) value).getRecord());\r\n              else\r\n                iteratorValues.add(value);\r\n            }\r\n\r\n            iValue.field(projection.getKey(), iteratorValues);\r\n          } else\r\n            iValue.field(projection.getKey(), projectionValue);\r\n\r\n      }\r\n    }\r\n\r\n    return iValue;\r\n  }","id":75969,"modified_method":"public static ODocument applyRecord(final ODocument iValue, final Map<String, Object> iProjections,\r\n      final OCommandContext iContext, final OIdentifiable iRecord) {\r\n    // APPLY PROJECTIONS\r\n    final ODocument inputDocument = (ODocument) (iRecord != null ? iRecord.getRecord() : null);\r\n\r\n    if (iProjections.isEmpty())\r\n      // SELECT * CASE\r\n      inputDocument.copyTo(iValue);\r\n    else {\r\n\r\n      for (Entry<String, Object> projection : iProjections.entrySet()) {\r\n        final Object v = projection.getValue();\r\n\r\n        if (v == null)\r\n          continue;\r\n\r\n        final Object projectionValue;\r\n        if (v.equals(\"*\")) {\r\n          // COPY ALL\r\n          inputDocument.copyTo(iValue);\r\n          projectionValue = null;\r\n        } else if (v instanceof OSQLFilterItemVariable) {\r\n          // RETURN A VARIABLE FROM THE CONTEXT\r\n          projectionValue = ((OSQLFilterItemVariable) v).getValue(inputDocument, iValue, iContext);\r\n        } else if (v instanceof OSQLFilterItemField)\r\n          projectionValue = ((OSQLFilterItemField) v).getValue(inputDocument, iValue, iContext);\r\n        else if (v instanceof OSQLFunctionRuntime) {\r\n          final OSQLFunctionRuntime f = (OSQLFunctionRuntime) v;\r\n          projectionValue = f.execute(inputDocument, inputDocument, iValue, iContext);\r\n        } else\r\n          projectionValue = v;\r\n\r\n        if (projectionValue != null)\r\n          if (projectionValue instanceof ORidBag)\r\n            iValue.field(projection.getKey(), new ORidBag((ORidBag) projectionValue));\r\n          else if (projectionValue instanceof OIdentifiable && !(projectionValue instanceof ORID)\r\n              && !(projectionValue instanceof ORecord))\r\n            iValue.field(projection.getKey(), ((OIdentifiable) projectionValue).getRecord());\r\n          else if (projectionValue instanceof Iterator) {\r\n            // make temporary value typical case graph database elemenet's iterator edges\r\n            if (projectionValue instanceof OResettable)\r\n              ((OResettable) projectionValue).reset();\r\n\r\n            final List<Object> iteratorValues = new ArrayList<Object>();\r\n            final Iterator projectionValueIterator = (Iterator) projectionValue;\r\n            while (projectionValueIterator.hasNext()) {\r\n              Object value = projectionValueIterator.next();\r\n              if (value instanceof OIdentifiable)\r\n                value = ((OIdentifiable) value).getRecord();\r\n\r\n              if (value != null)\r\n                iteratorValues.add(value);\r\n            }\r\n\r\n            iValue.field(projection.getKey(), iteratorValues);\r\n          } else\r\n            iValue.field(projection.getKey(), projectionValue);\r\n\r\n      }\r\n    }\r\n\r\n    return iValue;\r\n  }","commit_id":"c5329d03ed220602c41212d26b9b4a2aafa40fcc","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public boolean result(final Object iRecord) {\r\n    result.add((T) iRecord);\r\n    return true;\r\n  }","id":75970,"modified_method":"public boolean result(final Object iRecord) {\r\n    if (iRecord != null)\r\n      result.add((T) iRecord);\r\n    return true;\r\n  }","commit_id":"c5329d03ed220602c41212d26b9b4a2aafa40fcc","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n    public void run()\n            throws Exception {\n        final int partitionId = getPartitionId();\n        final InternalPartitionService partitionService = getNodeEngine().getPartitionService();\n\n        Set<Data> filteredKeys = new HashSet<Data>();\n        if (keys != null) {\n            for (Data k : keys) {\n                if (partitionService.getPartitionId(k) == partitionId) {\n                    filteredKeys.add(k);\n                }\n            }\n        }\n\n        if (filteredKeys.isEmpty()) {\n            return;\n        }\n\n        try {\n            final CacheService service = getService();\n            cache = service.getOrCreateRecordStore(name, partitionId);\n            final Set<Data> keysLoaded = cache.loadAll(filteredKeys, replaceExistingValues);\n            shouldBackup = !keysLoaded.isEmpty();\n            if (shouldBackup) {\n                backupRecords = new HashMap<Data, CacheRecord>();\n                for (Data key : keysLoaded) {\n                    backupRecords.put(key, cache.getRecord(key));\n                }\n            }\n        } catch (CacheException e) {\n            response = new CacheClearResponse(e);\n        }\n    }","id":75971,"modified_method":"@Override\n    public void run()\n            throws Exception {\n        final int partitionId = getPartitionId();\n        final InternalPartitionService partitionService = getNodeEngine().getPartitionService();\n\n        Set<Data> filteredKeys = new HashSet<Data>();\n        if (keys != null) {\n            for (Data k : keys) {\n                if (partitionService.getPartitionId(k) == partitionId) {\n                    filteredKeys.add(k);\n                }\n            }\n        }\n\n        if (filteredKeys.isEmpty()) {\n            return;\n        }\n\n        try {\n            final CacheService service = getService();\n            cache = service.getOrCreateRecordStore(name, partitionId);\n            final Set<Data> keysLoaded = cache.loadAll(filteredKeys, replaceExistingValues);\n            shouldBackup = !keysLoaded.isEmpty();\n            if (shouldBackup) {\n                backupRecords = new HashMap<Data, CacheRecord>(keysLoaded.size());\n                for (Data key : keysLoaded) {\n                    CacheRecord record = cache.getRecord(key);\n                    // Loaded keys may have been evicted, then record will be null.\n                    // So if the loaded key is evicted, don't send it to backup.\n                    if (record != null) {\n                        backupRecords.put(key, record);\n                    }\n                }\n            }\n        } catch (CacheException e) {\n            response = new CacheClearResponse(e);\n        }\n    }","commit_id":"8d811dda1eefbe42286c607ffb03daf1e1d4d88c","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private static boolean isReadObjectNoDataMethod(PsiMethod method) {\n    if (!method.getName().equals(\"readObjectNoData\")) return false;\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 0) return false;\n    PsiType returnType = method.getReturnType();\n    if (!TypeConversionUtil.isVoidType(returnType)) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    PsiClass aClass = method.getContainingClass();\n    return aClass == null || HighlightUtil.isSerializable(aClass);\n  }","id":75972,"modified_method":"private static boolean isReadObjectNoDataMethod(PsiMethod method) {\n    if (!\"readObjectNoData\".equals(method.getName())) return false;\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 0) return false;\n    PsiType returnType = method.getReturnType();\n    if (!TypeConversionUtil.isVoidType(returnType)) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    PsiClass aClass = method.getContainingClass();\n    return aClass == null || HighlightUtil.isSerializable(aClass);\n  }","commit_id":"cc672bb6b38f712bd14df0316deb8832bbf13b26","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private HighlightInfo processMethod(PsiMethod method, final List<IntentionAction> options) {\n    if (method.hasModifierProperty(PsiModifier.PRIVATE)) {\n      int count = myRefCountHolder.getRefCount(method);\n      if (count == 0) {\n        if (isWriteObjectMethod(method) ||\n            isWriteReplaceMethod(method) ||\n            isReadObjectMethod(method) ||\n            isReadObjectNoDataMethod(method) ||\n            isReadResolveMethod(method) ||\n            isIntentionalPrivateConstructor(method)\n        ) {\n          return null;\n        }\n        String pattern = method.isConstructor() ? PRIVATE_CONSTRUCTOR_IS_NOT_USED : PRIVATE_METHOD_IS_NOT_USED;\n        String symbolName = HighlightMessageUtil.getSymbolName(method, PsiSubstitutor.EMPTY);\n        String message = MessageFormat.format(pattern, new Object[]{symbolName});\n        PsiIdentifier identifier = method.getNameIdentifier();\n        HighlightInfo highlightInfo = createUnusedSymbolInfo(identifier, message);\n        QuickFixAction.registerQuickFixAction(highlightInfo, new SafeDeleteFix(method), options);\n        return highlightInfo;\n      }\n    }\n    return null;\n  }","id":75973,"modified_method":"private HighlightInfo processMethod(PsiMethod method, final List<IntentionAction> options) {\n    if (method.hasModifierProperty(PsiModifier.PRIVATE)) {\n      if (!myRefCountHolder.isReferenced(method)) {\n        if (isWriteObjectMethod(method) ||\n            isWriteReplaceMethod(method) ||\n            isReadObjectMethod(method) ||\n            isReadObjectNoDataMethod(method) ||\n            isReadResolveMethod(method) ||\n            isIntentionalPrivateConstructor(method)\n        ) {\n          return null;\n        }\n        String pattern = method.isConstructor() ? PRIVATE_CONSTRUCTOR_IS_NOT_USED : PRIVATE_METHOD_IS_NOT_USED;\n        String symbolName = HighlightMessageUtil.getSymbolName(method, PsiSubstitutor.EMPTY);\n        String message = MessageFormat.format(pattern, new Object[]{symbolName});\n        PsiIdentifier identifier = method.getNameIdentifier();\n        HighlightInfo highlightInfo = createUnusedSymbolInfo(identifier, message);\n        QuickFixAction.registerQuickFixAction(highlightInfo, new SafeDeleteFix(method), options);\n        return highlightInfo;\n      }\n    }\n    return null;\n  }","commit_id":"cc672bb6b38f712bd14df0316deb8832bbf13b26","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private HighlightInfo processClass(PsiClass aClass, final List<IntentionAction> options) {\n    if (aClass.getContainingClass() != null && aClass.hasModifierProperty(PsiModifier.PRIVATE)) {\n      int count = myRefCountHolder.getRefCount(aClass);\n      if (count == 0) {\n        String pattern = aClass.isInterface()\n                         ? PRIVATE_INNER_INTERFACE_IS_NOT_USED\n                         : PRIVATE_INNER_CLASS_IS_NOT_USED;\n        return formatUnusedSymbolHighlightInfo(aClass, pattern, options);\n      }\n    }\n    else if (aClass.getParent() instanceof PsiDeclarationStatement) { // local class\n      int count = myRefCountHolder.getRefCount(aClass);\n      if (count == 0) {\n        return formatUnusedSymbolHighlightInfo(aClass, LOCAL_CLASS_IS_NOT_USED, options);\n      }\n    }\n    else if (aClass instanceof PsiTypeParameter) {\n      int count = myRefCountHolder.getRefCount(aClass);\n      if (count == 0) {\n        return formatUnusedSymbolHighlightInfo(aClass, TYPE_PARAMETER_IS_NOT_USED, options);\n      }\n    }\n    return null;\n  }","id":75974,"modified_method":"private HighlightInfo processClass(PsiClass aClass, final List<IntentionAction> options) {\n    if (aClass.getContainingClass() != null && aClass.hasModifierProperty(PsiModifier.PRIVATE)) {\n      if (!myRefCountHolder.isReferenced(aClass)) {\n        String pattern = aClass.isInterface()\n                         ? PRIVATE_INNER_INTERFACE_IS_NOT_USED\n                         : PRIVATE_INNER_CLASS_IS_NOT_USED;\n        return formatUnusedSymbolHighlightInfo(aClass, pattern, options);\n      }\n    }\n    else if (aClass.getParent() instanceof PsiDeclarationStatement) { // local class\n      if (!myRefCountHolder.isReferenced(aClass)) {\n        return formatUnusedSymbolHighlightInfo(aClass, LOCAL_CLASS_IS_NOT_USED, options);\n      }\n    }\n    else if (aClass instanceof PsiTypeParameter) {\n      if (!myRefCountHolder.isReferenced(aClass)) {\n        return formatUnusedSymbolHighlightInfo(aClass, TYPE_PARAMETER_IS_NOT_USED, options);\n      }\n    }\n    return null;\n  }","commit_id":"cc672bb6b38f712bd14df0316deb8832bbf13b26","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isReadResolveMethod(PsiMethod method) {\n    if (!method.getName().equals(\"readResolve\")) return false;\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 0) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    PsiType returnType = method.getReturnType();\n    if (returnType == null || !returnType.equalsToText(\"java.lang.Object\")) return false;\n    PsiClass aClass = method.getContainingClass();\n    return aClass == null || HighlightUtil.isSerializable(aClass);\n  }","id":75975,"modified_method":"private static boolean isReadResolveMethod(PsiMethod method) {\n    if (!\"readResolve\".equals(method.getName())) return false;\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 0) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    PsiType returnType = method.getReturnType();\n    if (returnType == null || !returnType.equalsToText(\"java.lang.Object\")) return false;\n    PsiClass aClass = method.getContainingClass();\n    return aClass == null || HighlightUtil.isSerializable(aClass);\n  }","commit_id":"cc672bb6b38f712bd14df0316deb8832bbf13b26","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isReadObjectMethod(PsiMethod method) {\n    if (!method.getName().equals(\"readObject\")) return false;\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 1) return false;\n\n    if (!parameters[0].getType().equalsToText(\"java.io.ObjectInputStream\")) return false;\n\n    PsiType returnType = method.getReturnType();\n    if (!TypeConversionUtil.isVoidType(returnType)) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    PsiClass aClass = method.getContainingClass();\n    return aClass == null || HighlightUtil.isSerializable(aClass);\n  }","id":75976,"modified_method":"private static boolean isReadObjectMethod(PsiMethod method) {\n    if (!\"readObject\".equals(method.getName())) return false;\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 1) return false;\n\n    if (!parameters[0].getType().equalsToText(\"java.io.ObjectInputStream\")) return false;\n\n    PsiType returnType = method.getReturnType();\n    if (!TypeConversionUtil.isVoidType(returnType)) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    PsiClass aClass = method.getContainingClass();\n    return aClass == null || HighlightUtil.isSerializable(aClass);\n  }","commit_id":"cc672bb6b38f712bd14df0316deb8832bbf13b26","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private HighlightInfo processField(PsiField field, final List<IntentionAction> options) {\n    final PsiIdentifier identifier = field.getNameIdentifier();\n    final PsiFile boundForm = getFormFile(field);\n    final boolean isBoundToForm = boundForm != null;\n\n    if (isBoundToForm) { // bound to form\n      LOG.assertTrue(boundForm instanceof PsiPlainTextFile);\n      final PsiType guiComponentType = ReferenceUtil.getGUIComponentType((PsiPlainTextFile)boundForm, field.getName());\n      if (guiComponentType != null) {\n        final PsiType fieldType = field.getType();\n        if (!fieldType.isAssignableFrom(guiComponentType)) {\n          String message = MessageFormat.format(BOUND_FIELD_TYPE_MISMATCH, new Object[]{guiComponentType.getCanonicalText(), fieldType.getCanonicalText()});\n          final HighlightInfo highlightInfo = HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, field.getTypeElement(), message);\n          QuickFixAction.registerQuickFixAction(highlightInfo, new ChangeFormComponentTypeFix((PsiPlainTextFile)boundForm, field.getName(), field.getType()), options);\n          QuickFixAction.registerQuickFixAction(highlightInfo, new ChangeBoundFieldTypeFix(field, guiComponentType), options);\n          return highlightInfo;\n        }\n      }\n\n      if (field.hasInitializer()) {\n        String message = MessageFormat.format(FIELD_IS_OVERWRITTEN, new Object[]{identifier.getText()});\n        final HighlightInfo highlightInfo = HighlightInfo.createHighlightInfo(HighlightInfoType.WARNING, field.getInitializer(), message);\n        QuickFixAction.registerQuickFixAction(highlightInfo, new EmptyIntentionAction(HighlightDisplayKey.getDisplayNameByKey(HighlightDisplayKey.UNUSED_SYMBOL), options), options);\n        return highlightInfo;\n      }\n    }\n\n    if (field.hasModifierProperty(PsiModifier.PRIVATE)) {\n      final int refCount = myRefCountHolder.getRefCount(field);\n      if (refCount == 0) {\n        if (HighlightUtil.isSerializationImplicitlyUsedField(field)) {\n          return null;\n        }\n        String message = MessageFormat.format(PRIVATE_FIELD_IS_NOT_USED, new Object[]{identifier.getText()});\n        HighlightInfo highlightInfo = createUnusedSymbolInfo(identifier, message);\n        QuickFixAction.registerQuickFixAction(highlightInfo, new RemoveUnusedVariableFix(field), options);\n        QuickFixAction.registerQuickFixAction(highlightInfo, new CreateGetterOrSetterAction(true, false, field), options);\n        QuickFixAction.registerQuickFixAction(highlightInfo, new CreateGetterOrSetterAction(false, true, field), options);\n        QuickFixAction.registerQuickFixAction(highlightInfo, new CreateGetterOrSetterAction(true, true, field), options);\n        return highlightInfo;\n      }\n\n      final int readRefCount = myRefCountHolder.getReadRefCount(field);\n      if (readRefCount == 0) {\n        String message = MessageFormat.format(PRIVATE_FIELD_IS_NOT_USED_FOR_READING, new Object[]{identifier.getText()});\n        HighlightInfo highlightInfo = createUnusedSymbolInfo(identifier, message);\n        QuickFixAction.registerQuickFixAction(highlightInfo, new RemoveUnusedVariableFix(field), options);\n        QuickFixAction.registerQuickFixAction(highlightInfo, new CreateGetterOrSetterAction(true, false, field), options);\n        return highlightInfo;\n      }\n\n      if (!field.hasInitializer()) {\n        final int writeRefCount = myRefCountHolder.getWriteRefCount(field);\n        if (writeRefCount == 0 && !isBoundToForm) {\n          String message = MessageFormat.format(PRIVATE_FIELD_IS_NOT_ASSIGNED, new Object[]{identifier.getText()});\n          HighlightInfo info = createUnusedSymbolInfo(identifier, message);\n          QuickFixAction.registerQuickFixAction(info, new CreateGetterOrSetterAction(false, true, field), options);\n          return info;\n        }\n      }\n    }\n\n    return null;\n  }","id":75977,"modified_method":"private HighlightInfo processField(PsiField field, final List<IntentionAction> options) {\n    final PsiIdentifier identifier = field.getNameIdentifier();\n    final PsiFile boundForm = getFormFile(field);\n    final boolean isBoundToForm = boundForm != null;\n\n    if (isBoundToForm) { // bound to form\n      LOG.assertTrue(boundForm instanceof PsiPlainTextFile);\n      final PsiType guiComponentType = ReferenceUtil.getGUIComponentType((PsiPlainTextFile)boundForm, field.getName());\n      if (guiComponentType != null) {\n        final PsiType fieldType = field.getType();\n        if (!fieldType.isAssignableFrom(guiComponentType)) {\n          String message = MessageFormat.format(BOUND_FIELD_TYPE_MISMATCH, new Object[]{guiComponentType.getCanonicalText(), fieldType.getCanonicalText()});\n          final HighlightInfo highlightInfo = HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, field.getTypeElement(), message);\n          QuickFixAction.registerQuickFixAction(highlightInfo, new ChangeFormComponentTypeFix((PsiPlainTextFile)boundForm, field.getName(), field.getType()), options);\n          QuickFixAction.registerQuickFixAction(highlightInfo, new ChangeBoundFieldTypeFix(field, guiComponentType), options);\n          return highlightInfo;\n        }\n      }\n\n      if (field.hasInitializer()) {\n        String message = MessageFormat.format(FIELD_IS_OVERWRITTEN, new Object[]{identifier.getText()});\n        final HighlightInfo highlightInfo = HighlightInfo.createHighlightInfo(HighlightInfoType.WARNING, field.getInitializer(), message);\n        QuickFixAction.registerQuickFixAction(highlightInfo, new EmptyIntentionAction(HighlightDisplayKey.getDisplayNameByKey(HighlightDisplayKey.UNUSED_SYMBOL), options), options);\n        return highlightInfo;\n      }\n    }\n\n    if (field.hasModifierProperty(PsiModifier.PRIVATE)) {\n      if (!myRefCountHolder.isReferenced(field)) {\n        if (HighlightUtil.isSerializationImplicitlyUsedField(field)) {\n          return null;\n        }\n        String message = MessageFormat.format(PRIVATE_FIELD_IS_NOT_USED, new Object[]{identifier.getText()});\n        HighlightInfo highlightInfo = createUnusedSymbolInfo(identifier, message);\n        QuickFixAction.registerQuickFixAction(highlightInfo, new RemoveUnusedVariableFix(field), options);\n        QuickFixAction.registerQuickFixAction(highlightInfo, new CreateGetterOrSetterAction(true, false, field), options);\n        QuickFixAction.registerQuickFixAction(highlightInfo, new CreateGetterOrSetterAction(false, true, field), options);\n        QuickFixAction.registerQuickFixAction(highlightInfo, new CreateGetterOrSetterAction(true, true, field), options);\n        return highlightInfo;\n      }\n\n      final int readRefCount = myRefCountHolder.getReadRefCount(field);\n      if (readRefCount == 0) {\n        String message = MessageFormat.format(PRIVATE_FIELD_IS_NOT_USED_FOR_READING, new Object[]{identifier.getText()});\n        HighlightInfo highlightInfo = createUnusedSymbolInfo(identifier, message);\n        QuickFixAction.registerQuickFixAction(highlightInfo, new RemoveUnusedVariableFix(field), options);\n        QuickFixAction.registerQuickFixAction(highlightInfo, new CreateGetterOrSetterAction(true, false, field), options);\n        return highlightInfo;\n      }\n\n      if (!field.hasInitializer()) {\n        final int writeRefCount = myRefCountHolder.getWriteRefCount(field);\n        if (writeRefCount == 0 && !isBoundToForm) {\n          String message = MessageFormat.format(PRIVATE_FIELD_IS_NOT_ASSIGNED, new Object[]{identifier.getText()});\n          HighlightInfo info = createUnusedSymbolInfo(identifier, message);\n          QuickFixAction.registerQuickFixAction(info, new CreateGetterOrSetterAction(false, true, field), options);\n          return info;\n        }\n      }\n    }\n\n    return null;\n  }","commit_id":"cc672bb6b38f712bd14df0316deb8832bbf13b26","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isWriteReplaceMethod(PsiMethod method) {\n    if (!method.getName().equals(\"writeReplace\")) return false;\n    PsiType returnType = method.getReturnType();\n    if (returnType == null || !returnType.equalsToText(\"java.lang.Object\")) return false;\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 0) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    PsiClass aClass = method.getContainingClass();\n    return aClass == null || HighlightUtil.isSerializable(aClass);\n  }","id":75978,"modified_method":"private static boolean isWriteReplaceMethod(PsiMethod method) {\n    if (!\"writeReplace\".equals(method.getName())) return false;\n    PsiType returnType = method.getReturnType();\n    if (returnType == null || !returnType.equalsToText(\"java.lang.Object\")) return false;\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 0) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    PsiClass aClass = method.getContainingClass();\n    return aClass == null || HighlightUtil.isSerializable(aClass);\n  }","commit_id":"cc672bb6b38f712bd14df0316deb8832bbf13b26","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isWriteObjectMethod(PsiMethod method) {\n    if (!method.getName().equals(\"writeObject\")) return false;\n    PsiType returnType = method.getReturnType();\n    if (!TypeConversionUtil.isVoidType(returnType)) return false;\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 1) return false;\n    if (!parameters[0].getType().equalsToText(\"java.io.ObjectOutputStream\")) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    PsiClass aClass = method.getContainingClass();\n    return aClass == null || HighlightUtil.isSerializable(aClass);\n  }","id":75979,"modified_method":"private static boolean isWriteObjectMethod(PsiMethod method) {\n    if (!\"writeObject\".equals(method.getName())) return false;\n    PsiType returnType = method.getReturnType();\n    if (!TypeConversionUtil.isVoidType(returnType)) return false;\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 1) return false;\n    if (!parameters[0].getType().equalsToText(\"java.io.ObjectOutputStream\")) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    PsiClass aClass = method.getContainingClass();\n    return aClass == null || HighlightUtil.isSerializable(aClass);\n  }","commit_id":"cc672bb6b38f712bd14df0316deb8832bbf13b26","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private HighlightInfo processLocalVariable(PsiLocalVariable variable, final List<IntentionAction> options) {\n    PsiIdentifier identifier = variable.getNameIdentifier();\n\n    int count = myRefCountHolder.getRefCount(variable);\n    if (count == 0) {\n      String message = MessageFormat.format(LOCAL_VARIABLE_IS_NOT_USED, new Object[]{identifier.getText()});\n      HighlightInfo highlightInfo = createUnusedSymbolInfo(identifier, message);\n      QuickFixAction.registerQuickFixAction(highlightInfo, new RemoveUnusedVariableFix(variable), options);\n      return highlightInfo;\n    }\n\n    count = myRefCountHolder.getReadRefCount(variable);\n    if (count == 0) {\n      String message = MessageFormat.format(LOCAL_VARIABLE_IS_NOT_USED_FOR_READING, new Object[]{identifier.getText()});\n      HighlightInfo highlightInfo = createUnusedSymbolInfo(identifier, message);\n      QuickFixAction.registerQuickFixAction(highlightInfo, new RemoveUnusedVariableFix(variable), options);\n      return highlightInfo;\n    }\n\n    if (!variable.hasInitializer()) {\n      count = myRefCountHolder.getWriteRefCount(variable);\n      if (count == 0) {\n        String message = MessageFormat.format(LOCAL_VARIABLE_IS_NOT_ASSIGNED, new Object[]{identifier.getText()});\n        final HighlightInfo unusedSymbolInfo = createUnusedSymbolInfo(identifier, message);\n        QuickFixAction.registerQuickFixAction(unusedSymbolInfo, new EmptyIntentionAction(HighlightDisplayKey.getDisplayNameByKey(HighlightDisplayKey.UNUSED_SYMBOL), options), options);\n        return unusedSymbolInfo;\n      }\n    }\n\n    return null;\n  }","id":75980,"modified_method":"private HighlightInfo processLocalVariable(PsiLocalVariable variable, final List<IntentionAction> options) {\n    PsiIdentifier identifier = variable.getNameIdentifier();\n\n    if (!myRefCountHolder.isReferenced(variable)) {\n      String message = MessageFormat.format(LOCAL_VARIABLE_IS_NOT_USED, new Object[]{identifier.getText()});\n      HighlightInfo highlightInfo = createUnusedSymbolInfo(identifier, message);\n      QuickFixAction.registerQuickFixAction(highlightInfo, new RemoveUnusedVariableFix(variable), options);\n      return highlightInfo;\n    }\n\n    int count = myRefCountHolder.getReadRefCount(variable);\n    if (count == 0) {\n      String message = MessageFormat.format(LOCAL_VARIABLE_IS_NOT_USED_FOR_READING, new Object[]{identifier.getText()});\n      HighlightInfo highlightInfo = createUnusedSymbolInfo(identifier, message);\n      QuickFixAction.registerQuickFixAction(highlightInfo, new RemoveUnusedVariableFix(variable), options);\n      return highlightInfo;\n    }\n\n    if (!variable.hasInitializer()) {\n      count = myRefCountHolder.getWriteRefCount(variable);\n      if (count == 0) {\n        String message = MessageFormat.format(LOCAL_VARIABLE_IS_NOT_ASSIGNED, new Object[]{identifier.getText()});\n        final HighlightInfo unusedSymbolInfo = createUnusedSymbolInfo(identifier, message);\n        QuickFixAction.registerQuickFixAction(unusedSymbolInfo, new EmptyIntentionAction(HighlightDisplayKey.getDisplayNameByKey(HighlightDisplayKey.UNUSED_SYMBOL), options), options);\n        return unusedSymbolInfo;\n      }\n    }\n\n    return null;\n  }","commit_id":"cc672bb6b38f712bd14df0316deb8832bbf13b26","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private HighlightInfo processParameter(PsiParameter parameter, final List<IntentionAction> options) {\n    PsiElement declarationScope = parameter.getDeclarationScope();\n    if (declarationScope instanceof PsiMethod) {\n      PsiMethod method = (PsiMethod)declarationScope;\n      if (PsiUtil.hasErrorElementChild(method)) return null;\n      if ((method.isConstructor() || method.hasModifierProperty(PsiModifier.PRIVATE) ||\n           method.hasModifierProperty(PsiModifier.STATIC))\n          && !method.hasModifierProperty(PsiModifier.NATIVE)\n      ) {\n        if (isMainMethod(method)) return null;\n        int count = myRefCountHolder.getRefCount(parameter);\n        if (count == 0) {\n          PsiIdentifier identifier = parameter.getNameIdentifier();\n          String message = MessageFormat.format(PARAMETER_IS_NOT_USED, new Object[]{identifier.getText()});\n          HighlightInfo highlightInfo = createUnusedSymbolInfo(identifier, message);\n          QuickFixAction.registerQuickFixAction(highlightInfo, new RemoveUnusedParameterFix(parameter), options);\n          return highlightInfo;\n        }\n      }\n    }\n    else if (declarationScope instanceof PsiForeachStatement) {\n      if (myRefCountHolder.getRefCount(parameter) == 0) {\n        PsiIdentifier identifier = parameter.getNameIdentifier();\n        String message = MessageFormat.format(PARAMETER_IS_NOT_USED, new Object[]{identifier.getText()});\n        final HighlightInfo unusedSymbolInfo = createUnusedSymbolInfo(identifier, message);\n        QuickFixAction.registerQuickFixAction(unusedSymbolInfo, new EmptyIntentionAction(HighlightDisplayKey.getDisplayNameByKey(HighlightDisplayKey.UNUSED_SYMBOL), options), options);\n        return unusedSymbolInfo;\n      }\n    }\n\n    return null;\n  }","id":75981,"modified_method":"private HighlightInfo processParameter(PsiParameter parameter, final List<IntentionAction> options) {\n    PsiElement declarationScope = parameter.getDeclarationScope();\n    if (declarationScope instanceof PsiMethod) {\n      PsiMethod method = (PsiMethod)declarationScope;\n      if (PsiUtil.hasErrorElementChild(method)) return null;\n      if ((method.isConstructor() || method.hasModifierProperty(PsiModifier.PRIVATE) ||\n           method.hasModifierProperty(PsiModifier.STATIC))\n          && !method.hasModifierProperty(PsiModifier.NATIVE)\n      ) {\n        if (isMainMethod(method)) return null;\n        if (!myRefCountHolder.isReferenced(parameter)) {\n          PsiIdentifier identifier = parameter.getNameIdentifier();\n          String message = MessageFormat.format(PARAMETER_IS_NOT_USED, new Object[]{identifier.getText()});\n          HighlightInfo highlightInfo = createUnusedSymbolInfo(identifier, message);\n          QuickFixAction.registerQuickFixAction(highlightInfo, new RemoveUnusedParameterFix(parameter), options);\n          return highlightInfo;\n        }\n      }\n    }\n    else if (declarationScope instanceof PsiForeachStatement) {\n      if (!myRefCountHolder.isReferenced(parameter)) {\n        PsiIdentifier identifier = parameter.getNameIdentifier();\n        String message = MessageFormat.format(PARAMETER_IS_NOT_USED, new Object[]{identifier.getText()});\n        final HighlightInfo unusedSymbolInfo = createUnusedSymbolInfo(identifier, message);\n        QuickFixAction.registerQuickFixAction(unusedSymbolInfo, new EmptyIntentionAction(HighlightDisplayKey.getDisplayNameByKey(HighlightDisplayKey.UNUSED_SYMBOL), options), options);\n        return unusedSymbolInfo;\n      }\n    }\n\n    return null;\n  }","commit_id":"cc672bb6b38f712bd14df0316deb8832bbf13b26","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getRefCount(PsiElement element) {\n    List<PsiReference> array = myLocalRefsMap.getKeysByValue(element);\n    if(array != null) return array.size();\n\n    Boolean usedStatus = myDclsUsedMap.get(element);\n    if (usedStatus == Boolean.TRUE) return 1;\n\n    return 0;\n  }","id":75982,"modified_method":"public boolean isReferenced(PsiElement element) {\n    List<PsiReference> array = myLocalRefsMap.getKeysByValue(element);\n    if(array != null && !isParameterUsedRecursively(element, array)) return true;\n\n    Boolean usedStatus = myDclsUsedMap.get(element);\n    return usedStatus == Boolean.TRUE;\n  }","commit_id":"cc672bb6b38f712bd14df0316deb8832bbf13b26","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MapPaintAction(StyleSource style) {\n            super(style.getDisplayString(), ImageProvider.getIfAvailable(style.icon),\n                    tr(\"Select the map painting styles\"), null, true, \"mappaint/\" + style.getDisplayString(), true);\n            this.button = new StayOpenCheckBoxMenuItem(this);\n            this.style = style;\n            updateButton();\n        }","id":75983,"modified_method":"public MapPaintAction(StyleSource style) {\n            super(style.getDisplayString(), style.icon == null ? null : ImageProvider.getIfAvailable(style.icon),\n                    tr(\"Select the map painting styles\"), null, true, \"mappaint/\" + style.getDisplayString(), true);\n            this.button = new StayOpenCheckBoxMenuItem(this);\n            this.style = style;\n            updateButton();\n        }","commit_id":"fa619dd43ebc44753283a94a573acfa32e4969ad","url":"https://github.com/openstreetmap/josm"},{"original_method":"public Marker(LatLon ll, TemplateEngineDataProvider dataProvider, String iconName, MarkerLayer parentLayer, double time, double offset) {\n        setCoor(ll);\n\n        this.offset = offset;\n        this.time = time;\n        // /* ICON(markers/) */\"Bridge\"\n        // /* ICON(markers/) */\"Crossing\"\n        this.symbol = ImageProvider.getIfAvailable(\"markers\",iconName);\n        this.parentLayer = parentLayer;\n\n        this.dataProvider = dataProvider;\n        this.text = null;\n    }","id":75984,"modified_method":"public Marker(LatLon ll, TemplateEngineDataProvider dataProvider, String iconName, MarkerLayer parentLayer, double time, double offset) {\n        setCoor(ll);\n\n        this.offset = offset;\n        this.time = time;\n        // /* ICON(markers/) */\"Bridge\"\n        // /* ICON(markers/) */\"Crossing\"\n        this.symbol = iconName != null ? ImageProvider.getIfAvailable(\"markers\",iconName) : null;\n        this.parentLayer = parentLayer;\n\n        this.dataProvider = dataProvider;\n        this.text = null;\n    }","commit_id":"4ddb0cde58170bcbec3d7bc91ae02c42e67bab00","url":"https://github.com/openstreetmap/josm"},{"original_method":"public Marker(LatLon ll, String text, String iconName, MarkerLayer parentLayer, double time, double offset) {\n        setCoor(ll);\n\n        this.offset = offset;\n        this.time = time;\n        // /* ICON(markers/) */\"Bridge\"\n        // /* ICON(markers/) */\"Crossing\"\n        this.symbol = ImageProvider.getIfAvailable(\"markers\",iconName);\n        this.parentLayer = parentLayer;\n\n        this.dataProvider = null;\n        this.text = text;\n    }","id":75985,"modified_method":"public Marker(LatLon ll, String text, String iconName, MarkerLayer parentLayer, double time, double offset) {\n        setCoor(ll);\n\n        this.offset = offset;\n        this.time = time;\n        // /* ICON(markers/) */\"Bridge\"\n        // /* ICON(markers/) */\"Crossing\"\n        this.symbol = iconName != null ? ImageProvider.getIfAvailable(\"markers\",iconName) : null;\n        this.parentLayer = parentLayer;\n\n        this.dataProvider = null;\n        this.text = text;\n    }","commit_id":"4ddb0cde58170bcbec3d7bc91ae02c42e67bab00","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Cover method to set the current localizer\n     * to the localizer for that language.\n     * <p>\n     * Also updates languages list with the new single language. \n     * \n     * @param language to set the current localizer for.\n     * @see #language\n     * @see #setLanguages\n     */\n    public void setLanguage(String language) {\n        ERXLocalizer newLocalizer = ERXLocalizer.localizerForLanguage(language);\n        if (! newLocalizer.equals(_localizer)) {\n            if (_localizer == null  &&  ! WOApplication.application().isCachingEnabled()) \n                observer().registerForLocalizationDidResetNotification();\n\n            _localizer = newLocalizer;\n            ERXLocalizer.setCurrentLocalizer(_localizer);\n            _messageEncoding = new ERXMessageEncoding(_localizer.language());\n\n            NSMutableArray languageList = new NSMutableArray(_localizer.language());\n            if (! languageList.containsObject(\"Nonlocalized\")) \n                languageList.addObject(\"Nonlocalized\");\n            setLanguages(languageList);\n        }\n    }","id":75986,"modified_method":"/**\n     * Cover method to set the current localizer\n     * to the localizer for that language.\n     * <p>\n     * Also updates languages list with the new single language. \n     * \n     * @param language to set the current localizer for.\n     * @see #language\n     * @see #setLanguages\n     */\n    public void setLanguage(String language) {\n        ERXLocalizer newLocalizer = ERXLocalizer.localizerForLanguage(language);\n        if (! newLocalizer.equals(_localizer)) {\n            if (_localizer == null  &&  ! WOApplication.application().isCachingEnabled()) \n                observer().registerForLocalizationDidResetNotification();\n\n            _localizer = newLocalizer;\n            ERXLocalizer.setCurrentLocalizer(_localizer);\n            _messageEncoding = browser().messageEncodingForLanguage(_localizer.language());\n\n            NSMutableArray languageList = new NSMutableArray(_localizer.language());\n            if (! languageList.containsObject(\"Nonlocalized\")) \n                languageList.addObject(\"Nonlocalized\");\n            setLanguages(languageList);\n        }\n    }","commit_id":"bdd236c9d175bb3d5717f4b44948ccbdc08bd7c2","url":"https://github.com/wocommunity/wonder"},{"original_method":"/** \n     * Sets the languages list for which the session is localized. \n     * The ordering of language strings in the array determines \n     * the order in which the application will search .lproj \n     * directories for localized strings, images, and component \n     * definitions.\n     * <p>\n     * Also updates localizer and messageEncodings. \n     * \n     * @param languageList  the array of languages for the session\n     * @see #language\n     * @see #setLanguage\n     */ \n    public void setLanguages(NSArray languageList) {\n        super.setLanguages(languageList);\n        ERXLocalizer newLocalizer = ERXLocalizer.localizerForLanguages(languageList);\n        if (! newLocalizer.equals(_localizer)) {\n            if (_localizer == null  &&  ! WOApplication.application().isCachingEnabled()) \n                observer().registerForLocalizationDidResetNotification();\n\n            _localizer = newLocalizer;\n            ERXLocalizer.setCurrentLocalizer(_localizer);\n            _messageEncoding = new ERXMessageEncoding(_localizer.language());\n        }\n    }","id":75987,"modified_method":"/** \n     * Sets the languages list for which the session is localized. \n     * The ordering of language strings in the array determines \n     * the order in which the application will search .lproj \n     * directories for localized strings, images, and component \n     * definitions.\n     * <p>\n     * Also updates localizer and messageEncodings. \n     * \n     * @param languageList  the array of languages for the session\n     * @see #language\n     * @see #setLanguage\n     */ \n    public void setLanguages(NSArray languageList) {\n        super.setLanguages(languageList);\n        ERXLocalizer newLocalizer = ERXLocalizer.localizerForLanguages(languageList);\n        if (! newLocalizer.equals(_localizer)) {\n            if (_localizer == null  &&  ! WOApplication.application().isCachingEnabled()) \n                observer().registerForLocalizationDidResetNotification();\n\n            _localizer = newLocalizer;\n            ERXLocalizer.setCurrentLocalizer(_localizer);\n            _messageEncoding = browser().messageEncodingForLanguage(_localizer.language());\n        }\n    }","commit_id":"bdd236c9d175bb3d5717f4b44948ccbdc08bd7c2","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Returns the browser object representing the web \n     * browser's \"user-agent\" string. You can obtain \n     * browser name, version, platform and Mozilla version, etc. \n     * through this object. <br>\n     * Good for WOConditional's condition binding to deal \n     * with different browser versions. \n     * @return browser object\n     */\n    public ERXBrowser browser() { \n        if (_browser == null  &&  context() != null) {\n            WORequest request = context().request();\n            if (request != null) {\n                ERXBrowserFactory browserFactory = ERXBrowserFactory.factory();\n                _browser = browserFactory.browserMatchingRequest(request);\n                browserFactory.retainBrowser(_browser);\n            }\n        }\n        return _browser; \n    }","id":75988,"modified_method":"/**\n     * Returns the browser object representing the web \n     * browser's \"user-agent\" string. You can obtain \n     * browser name, version, platform and Mozilla version, etc. \n     * through this object. <br>\n     * Good for WOConditional's condition binding to deal \n     * with different browser versions. \n     * @return browser object\n     */\n    public ERXBrowser browser() { \n        if (_browser == null  &&  context() != null) {\n            WORequest request = context().request();\n            if (request != null) {\n                ERXBrowserFactory browserFactory = ERXBrowserFactory.factory();\n                if (request instanceof ERXRequest) {\n                    _browser = ((ERXRequest)request).browser();\n                } else {\n                    _browser = browserFactory.browserMatchingRequest(request);                    \n                }\n                browserFactory.retainBrowser(_browser);\n            }\n        }\n        return _browser; \n    }","commit_id":"a0de5ef012c10160e2ab341706e6a2e5e1e63292","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Returns the message encoding of the current session. \n     * If it's not already set up but no current <code>language()<\/code> \n     * available for the session, it creates one with \n     * the defailt encoding. \n     * @return message encoding object\n     */\n    public ERXMessageEncoding messageEncoding() { \n        if (_messageEncoding == null) \n            _messageEncoding = new ERXMessageEncoding(language());\n        return _messageEncoding; \n    }","id":75989,"modified_method":"/**\n     * Returns the message encoding of the current session. \n     * If it's not already set up but no current <code>language()<\/code> \n     * available for the session, it creates one with \n     * the defailt encoding. \n     * @return message encoding object\n     */\n    public ERXMessageEncoding messageEncoding() {\n        if (_messageEncoding == null) {\n            //_messageEncoding = new ERXMessageEncoding(language());\n            _messageEncoding = browser().messageEncodingForLanguage(language());\n        }\n        return _messageEncoding; \n    }","commit_id":"a0de5ef012c10160e2ab341706e6a2e5e1e63292","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Test\n    public void deployBundleOnServer() throws CoreException, InterruptedException, BackingStoreException, IOException,\n            OsgiClientException {\n\n        wstServer.waitForServerToStart();\n\n        // create faceted project\n        IProject bundleProject = projectRule.getProject();\n\n        ProjectAdapter project = new ProjectAdapter(bundleProject);\n        project.addNatures(JavaCore.NATURE_ID, \"org.eclipse.wst.common.project.facet.core.nature\");\n\n        // configure java project with dependencies\n        MavenDependency slingApiDep = new MavenDependency().groupId(\"org.apache.sling\")\n                .artifactId(\"org.apache.sling.api\").version(\"2.2.0\");\n        MavenDependency servletApiDep = new MavenDependency().groupId(\"javax.servlet\").artifactId(\"servlet-api\")\n                .version(\"2.4\");\n        project.configureAsJavaProject(slingApiDep, servletApiDep);\n\n        // create DS component class\n        InputStream simpleServlet = null;\n        try {\n            simpleServlet = getClass().getResourceAsStream(\"SimpleServlet.java.v1.txt\");\n            project.createOrUpdateFile(Path.fromPortableString(\"src/example/SimpleServlet.java\"), simpleServlet);\n        } finally {\n            IOUtils.closeQuietly(simpleServlet);\n        }\n        \n        // create DS component descriptor\n        InputStream servletDescriptor = null;\n        try {\n            servletDescriptor = getClass().getResourceAsStream(\"SimpleServlet.xml\");\n            project.createOrUpdateFile(Path.fromPortableString(\"src/OSGI-INF/SimpleServlet.xml\"), servletDescriptor);\n        } finally {\n            IOUtils.closeQuietly(servletDescriptor);\n        }\n\n        // create manifest\n        OsgiBundleManifest manifest = OsgiBundleManifest.symbolicName(\"test.bundle001\").version(\"1.0.0.SNAPSHOT\")\n                .name(\"Test bundle\").serviceComponent(\"OSGI-INF/SimpleServlet.xml\")\n                .importPackage(\"javax.servlet,org.apache.sling.api,org.apache.sling.api.servlets\");\n        project.createOsgiBundleManifest(manifest);\n\n        // install bundle facet\n        project.installFacet(\"sling.bundle\", \"1.0\");\n\n        ServerAdapter server = new ServerAdapter(wstServer.getServer());\n        server.installModule(bundleProject);\n\n        final RepositoryAccessor repo = new RepositoryAccessor(config);\n        Poller poller = new Poller();\n        poller.pollUntil(new Callable<Void>() {\n            @Override\n            public Void call() throws HttpException, IOException {\n                repo.assertGetIsSuccessful(\"simple-servlet\", \"Version 1\");\n                return null;\n            }\n        }, nullValue(Void.class));\n\n        // update DS component class\n        InputStream simpleServlet2 = null;\n        try {\n            simpleServlet2 = getClass().getResourceAsStream(\"SimpleServlet.java.v2.txt\");\n            project.createOrUpdateFile(Path.fromPortableString(\"src/example/SimpleServlet.java\"), simpleServlet2);\n        } finally {\n            IOUtils.closeQuietly(simpleServlet2);\n        }\n\n        poller.pollUntil(new Callable<Void>() {\n            @Override\n            public Void call() throws HttpException, IOException {\n                repo.assertGetIsSuccessful(\"simple-servlet\", \"Version 2\");\n                return null;\n            }\n        }, nullValue(Void.class));\n    }","id":75990,"modified_method":"@Test\n    public void deployBundleOnServer() throws CoreException, InterruptedException, BackingStoreException, IOException,\n            OsgiClientException {\n\n        wstServer.waitForServerToStart();\n\n        // create faceted project\n        IProject bundleProject = projectRule.getProject();\n\n        ProjectAdapter project = new ProjectAdapter(bundleProject);\n        project.addNatures(JavaCore.NATURE_ID, \"org.eclipse.wst.common.project.facet.core.nature\");\n\n        // configure java project with dependencies\n        MavenDependency slingApiDep = new MavenDependency().groupId(\"org.apache.sling\")\n                .artifactId(\"org.apache.sling.api\").version(\"2.2.0\");\n        MavenDependency servletApiDep = new MavenDependency().groupId(\"javax.servlet\").artifactId(\"servlet-api\")\n                .version(\"2.4\");\n        project.configureAsJavaProject(slingApiDep, servletApiDep);\n\n        // create DS component class\n        InputStream simpleServlet = getClass().getResourceAsStream(\"SimpleServlet.java.v1.txt\");\n        project.createOrUpdateFile(Path.fromPortableString(\"src/example/SimpleServlet.java\"), simpleServlet);\n        \n        // create DS component descriptor\n        InputStream servletDescriptor = getClass().getResourceAsStream(\"SimpleServlet.xml\");\n        project.createOrUpdateFile(Path.fromPortableString(\"src/OSGI-INF/SimpleServlet.xml\"), servletDescriptor);\n\n        // create manifest\n        OsgiBundleManifest manifest = OsgiBundleManifest.symbolicName(\"test.bundle001\").version(\"1.0.0.SNAPSHOT\")\n                .name(\"Test bundle\").serviceComponent(\"OSGI-INF/SimpleServlet.xml\")\n                .importPackage(\"javax.servlet,org.apache.sling.api,org.apache.sling.api.servlets\");\n        project.createOsgiBundleManifest(manifest);\n\n        // install bundle facet\n        project.installFacet(\"sling.bundle\", \"1.0\");\n\n        ServerAdapter server = new ServerAdapter(wstServer.getServer());\n        server.installModule(bundleProject);\n\n        final RepositoryAccessor repo = new RepositoryAccessor(config);\n        Poller poller = new Poller();\n        poller.pollUntil(new Callable<Void>() {\n            @Override\n            public Void call() throws HttpException, IOException {\n                repo.assertGetIsSuccessful(\"simple-servlet\", \"Version 1\");\n                return null;\n            }\n        }, nullValue(Void.class));\n\n        // update DS component class\n        InputStream simpleServlet2 = getClass().getResourceAsStream(\"SimpleServlet.java.v2.txt\");\n        project.createOrUpdateFile(Path.fromPortableString(\"src/example/SimpleServlet.java\"), simpleServlet2);\n\n        poller.pollUntil(new Callable<Void>() {\n            @Override\n            public Void call() throws HttpException, IOException {\n                repo.assertGetIsSuccessful(\"simple-servlet\", \"Version 2\");\n                return null;\n            }\n        }, nullValue(Void.class));\n    }","commit_id":"10d463154f54e2641e7c76665435e06adfc43609","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void deployFileWithAttachedMetadata() throws Exception {\n\n        wstServer.waitForServerToStart();\n\n        // create faceted project\n        IProject contentProject = projectRule.getProject();\n\n        ProjectAdapter project = new ProjectAdapter(contentProject);\n        project.addNatures(JavaCore.NATURE_ID, \"org.eclipse.wst.common.project.facet.core.nature\");\n\n        project.createOrUpdateFile(Path.fromPortableString(\"jcr_root/test/hello.esp\"), new ByteArrayInputStream(\n                \"// not really javascript\".getBytes()));\n\n        // install bundle facet\n        project.installFacet(\"sling.content\", \"1.0\");\n\n        ServerAdapter server = new ServerAdapter(wstServer.getServer());\n        server.installModule(contentProject);\n\n        // verify that file is created\n        final RepositoryAccessor repo = new RepositoryAccessor(config);\n        Poller poller = new Poller();\n        assertThatNode(repo, poller, \"/test/hello.esp\", hasPrimaryType(\"nt:file\"));\n\n        InputStream contentXml = getClass().getResourceAsStream(\"file-custom-mimetype.xml\");\n        try {\n            project.createOrUpdateFile(Path.fromPortableString(\"jcr_root/test/hello.esp.dir/.content.xml\"), contentXml);\n        } finally {\n            IOUtils.closeQuietly(contentXml);\n        }\n\n        assertThatNode(repo, poller, \"/test/hello.esp/jcr:content\", hasPropertyValue(\"jcr:mimeType\", \"text/javascript\"));\n    }","id":75991,"modified_method":"@Test\n    public void deployFileWithAttachedMetadata() throws Exception {\n\n        wstServer.waitForServerToStart();\n\n        // create faceted project\n        IProject contentProject = projectRule.getProject();\n\n        ProjectAdapter project = new ProjectAdapter(contentProject);\n        project.addNatures(JavaCore.NATURE_ID, \"org.eclipse.wst.common.project.facet.core.nature\");\n\n        project.createOrUpdateFile(Path.fromPortableString(\"jcr_root/test/hello.esp\"), new ByteArrayInputStream(\n                \"// not really javascript\".getBytes()));\n\n        // install bundle facet\n        project.installFacet(\"sling.content\", \"1.0\");\n\n        ServerAdapter server = new ServerAdapter(wstServer.getServer());\n        server.installModule(contentProject);\n\n        // verify that file is created\n        final RepositoryAccessor repo = new RepositoryAccessor(config);\n        Poller poller = new Poller();\n        assertThatNode(repo, poller, \"/test/hello.esp\", hasPrimaryType(\"nt:file\"));\n\n        InputStream contentXml = getClass().getResourceAsStream(\"file-custom-mimetype.xml\");\n        project.createOrUpdateFile(Path.fromPortableString(\"jcr_root/test/hello.esp.dir/.content.xml\"), contentXml);\n\n        assertThatNode(repo, poller, \"/test/hello.esp/jcr:content\", hasPropertyValue(\"jcr:mimeType\", \"text/javascript\"));\n    }","commit_id":"10d463154f54e2641e7c76665435e06adfc43609","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void changeNodePrimaryType() throws Exception {\n\n        wstServer.waitForServerToStart();\n\n        // create faceted project\n        IProject contentProject = projectRule.getProject();\n\n        ProjectAdapter project = new ProjectAdapter(contentProject);\n        project.addNatures(\"org.eclipse.wst.common.project.facet.core.nature\");\n\n        project.createOrUpdateFile(Path.fromPortableString(\"jcr_root/test/hello.txt\"),\n                new ByteArrayInputStream(\"hello, world\".getBytes()));\n\n        // install bundle facet\n        project.installFacet(\"sling.content\", \"1.0\");\n\n        ServerAdapter server = new ServerAdapter(wstServer.getServer());\n        server.installModule(contentProject);\n\n        // verifications\n        final RepositoryAccessor repo = new RepositoryAccessor(config);\n        Poller poller = new Poller();\n        assertThatNode(repo, poller, \"/test\", allOf(hasPath(\"/test\"), hasPrimaryType(\"nt:folder\"), hasChildrenCount(1)));\n\n        // change node type to sling:Folder\n        InputStream contentXml = getClass().getResourceAsStream(\"sling-folder-nodetype.xml\");\n        try {\n            project.createOrUpdateFile(Path.fromPortableString(\"jcr_root/test/.content.xml\"), contentXml);\n        } finally {\n            IOUtils.closeQuietly(contentXml);\n        }\n\n        // verifications (2)\n        assertThatNode(repo, poller, \"/test\",\n                allOf(hasPath(\"/test\"), hasPrimaryType(\"sling:Folder\"), hasChildrenCount(1)));\n    }","id":75992,"modified_method":"@Test\n    public void changeNodePrimaryType() throws Exception {\n\n        wstServer.waitForServerToStart();\n\n        // create faceted project\n        IProject contentProject = projectRule.getProject();\n\n        ProjectAdapter project = new ProjectAdapter(contentProject);\n        project.addNatures(\"org.eclipse.wst.common.project.facet.core.nature\");\n\n        project.createOrUpdateFile(Path.fromPortableString(\"jcr_root/test/hello.txt\"),\n                new ByteArrayInputStream(\"hello, world\".getBytes()));\n\n        // install bundle facet\n        project.installFacet(\"sling.content\", \"1.0\");\n\n        ServerAdapter server = new ServerAdapter(wstServer.getServer());\n        server.installModule(contentProject);\n\n        // verifications\n        final RepositoryAccessor repo = new RepositoryAccessor(config);\n        Poller poller = new Poller();\n        assertThatNode(repo, poller, \"/test\", allOf(hasPath(\"/test\"), hasPrimaryType(\"nt:folder\"), hasChildrenCount(1)));\n\n        // change node type to sling:Folder\n        InputStream contentXml = getClass().getResourceAsStream(\"sling-folder-nodetype.xml\");\n        project.createOrUpdateFile(Path.fromPortableString(\"jcr_root/test/.content.xml\"), contentXml);\n\n        // verifications (2)\n        assertThatNode(repo, poller, \"/test\",\n                allOf(hasPath(\"/test\"), hasPrimaryType(\"sling:Folder\"), hasChildrenCount(1)));\n    }","commit_id":"10d463154f54e2641e7c76665435e06adfc43609","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void deployNestedFullCoverageAggregate() throws Exception {\n\n        wstServer.waitForServerToStart();\n\n        // create faceted project\n        IProject contentProject = projectRule.getProject();\n\n        ProjectAdapter project = new ProjectAdapter(contentProject);\n        project.addNatures(\"org.eclipse.wst.common.project.facet.core.nature\");\n\n        // create .content.xml structure\n        InputStream contentXml = getClass().getResourceAsStream(\"content-nested-structure.xml\");\n        try {\n            project.createOrUpdateFile(Path.fromPortableString(\"jcr_root/content/test-root/en.xml\"),\n                    contentXml);\n        } finally {\n            IOUtils.closeQuietly(contentXml);\n        }\n\n        // install content facet\n        project.installFacet(\"sling.content\", \"1.0\");\n\n        ServerAdapter server = new ServerAdapter(wstServer.getServer());\n        server.installModule(contentProject);\n\n        Matcher<Node> postConditions = allOf(hasPath(\"/content/test-root/en\"), hasPrimaryType(\"sling:Folder\"),\n                hasMixinTypes(\"mix:language\"), hasChildrenCount(3));\n\n        final RepositoryAccessor repo = new RepositoryAccessor(config);\n        Poller poller = new Poller();\n        poller.pollUntil(new Callable<Node>() {\n            @Override\n            public Node call() throws RepositoryException {\n                return repo.getNode(\"/content/test-root/en\");\n\n            }\n        }, postConditions);\n    }","id":75993,"modified_method":"@Test\n    public void deployNestedFullCoverageAggregate() throws Exception {\n\n        wstServer.waitForServerToStart();\n\n        // create faceted project\n        IProject contentProject = projectRule.getProject();\n\n        ProjectAdapter project = new ProjectAdapter(contentProject);\n        project.addNatures(\"org.eclipse.wst.common.project.facet.core.nature\");\n\n        // create .content.xml structure\n        InputStream contentXml = getClass().getResourceAsStream(\"content-nested-structure.xml\");\n        project.createOrUpdateFile(Path.fromPortableString(\"jcr_root/content/test-root/en.xml\"), contentXml);\n\n        // install content facet\n        project.installFacet(\"sling.content\", \"1.0\");\n\n        ServerAdapter server = new ServerAdapter(wstServer.getServer());\n        server.installModule(contentProject);\n\n        Matcher<Node> postConditions = allOf(hasPath(\"/content/test-root/en\"), hasPrimaryType(\"sling:Folder\"),\n                hasMixinTypes(\"mix:language\"), hasChildrenCount(3));\n\n        final RepositoryAccessor repo = new RepositoryAccessor(config);\n        Poller poller = new Poller();\n        poller.pollUntil(new Callable<Node>() {\n            @Override\n            public Node call() throws RepositoryException {\n                return repo.getNode(\"/content/test-root/en\");\n\n            }\n        }, postConditions);\n    }","commit_id":"10d463154f54e2641e7c76665435e06adfc43609","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void deployNestedFullCoverageAggregateAtFilterRoot() throws Exception {\n\n        wstServer.waitForServerToStart();\n\n        // create faceted project\n        IProject contentProject = projectRule.getProject();\n\n        ProjectAdapter project = new ProjectAdapter(contentProject);\n        project.addNatures(\"org.eclipse.wst.common.project.facet.core.nature\");\n\n        // create filter.xml\n        InputStream filterXml = getClass().getResourceAsStream(\"filter-only-content-test-root-en.xml\");\n        try {\n            project.createOrUpdateFile(Path.fromPortableString(\"META-INF/vault/filter.xml\"), filterXml);\n        } finally {\n            IOUtils.closeQuietly(filterXml);\n        }\n\n        // create .content.xml structure\n        InputStream contentXml = getClass().getResourceAsStream(\"content-nested-structure.xml\");\n        try {\n            project.createOrUpdateFile(Path.fromPortableString(\"jcr_root/content/test-root/en.xml\"), contentXml);\n        } finally {\n            IOUtils.closeQuietly(contentXml);\n        }\n\n        // install content facet\n        project.installFacet(\"sling.content\", \"1.0\");\n\n        // create prerequisite data\n        final RepositoryAccessor repo = new RepositoryAccessor(config);\n        repo.createNode(\"/content\", \"sling:Folder\");\n        repo.createNode(\"/content/test-root\", \"sling:Folder\");\n\n        ServerAdapter server = new ServerAdapter(wstServer.getServer());\n        server.installModule(contentProject);\n\n        Matcher<Node> postConditions = allOf(hasPath(\"/content/test-root/en\"), hasPrimaryType(\"sling:Folder\"),\n                hasMixinTypes(\"mix:language\"), hasChildrenCount(3));\n\n        Poller poller = new Poller();\n        poller.pollUntil(new Callable<Node>() {\n            @Override\n            public Node call() throws RepositoryException {\n                return repo.getNode(\"/content/test-root/en\");\n\n            }\n        }, postConditions);\n    }","id":75994,"modified_method":"@Test\n    public void deployNestedFullCoverageAggregateAtFilterRoot() throws Exception {\n\n        wstServer.waitForServerToStart();\n\n        // create faceted project\n        IProject contentProject = projectRule.getProject();\n\n        ProjectAdapter project = new ProjectAdapter(contentProject);\n        project.addNatures(\"org.eclipse.wst.common.project.facet.core.nature\");\n\n        // create filter.xml\n        InputStream filterXml = getClass().getResourceAsStream(\"filter-only-content-test-root-en.xml\");\n        project.createOrUpdateFile(Path.fromPortableString(\"META-INF/vault/filter.xml\"), filterXml);\n\n        // create .content.xml structure\n        InputStream contentXml = getClass().getResourceAsStream(\"content-nested-structure.xml\");\n        project.createOrUpdateFile(Path.fromPortableString(\"jcr_root/content/test-root/en.xml\"), contentXml);\n\n        // install content facet\n        project.installFacet(\"sling.content\", \"1.0\");\n\n        // create prerequisite data\n        final RepositoryAccessor repo = new RepositoryAccessor(config);\n        repo.createNode(\"/content\", \"sling:Folder\");\n        repo.createNode(\"/content/test-root\", \"sling:Folder\");\n\n        ServerAdapter server = new ServerAdapter(wstServer.getServer());\n        server.installModule(contentProject);\n\n        Matcher<Node> postConditions = allOf(hasPath(\"/content/test-root/en\"), hasPrimaryType(\"sling:Folder\"),\n                hasMixinTypes(\"mix:language\"), hasChildrenCount(3));\n\n        Poller poller = new Poller();\n        poller.pollUntil(new Callable<Node>() {\n            @Override\n            public Node call() throws RepositoryException {\n                return repo.getNode(\"/content/test-root/en\");\n\n            }\n        }, postConditions);\n    }","commit_id":"10d463154f54e2641e7c76665435e06adfc43609","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void reorderNodesFromNestedFullCoverageAggregate() throws Exception {\n\n        wstServer.waitForServerToStart();\n\n        // create faceted project\n        IProject contentProject = projectRule.getProject();\n\n        ProjectAdapter project = new ProjectAdapter(contentProject);\n        project.addNatures(\"org.eclipse.wst.common.project.facet.core.nature\");\n\n        // create .content.xml structure\n        InputStream contentXml = getClass().getResourceAsStream(\"content-nested-structure.xml\");\n        try {\n            project.createOrUpdateFile(Path.fromPortableString(\"jcr_root/content/test-root/en.xml\"), contentXml);\n        } finally {\n            IOUtils.closeQuietly(contentXml);\n        }\n\n        // install content facet\n        project.installFacet(\"sling.content\", \"1.0\");\n\n        ServerAdapter server = new ServerAdapter(wstServer.getServer());\n        server.installModule(contentProject);\n\n        Matcher<Node> postConditions = allOf(hasPath(\"/content/test-root/en\"), hasPrimaryType(\"sling:Folder\"),\n                hasMixinTypes(\"mix:language\"), hasChildrenNames(\"message\", \"error\", \"warning\"));\n\n        final RepositoryAccessor repo = new RepositoryAccessor(config);\n        Poller poller = new Poller();\n        poller.pollUntil(new Callable<Node>() {\n            @Override\n            public Node call() throws RepositoryException {\n                return repo.getNode(\"/content/test-root/en\");\n\n            }\n        }, postConditions);\n\n        // update .content.xml structure\n        InputStream updatedContentXml = getClass().getResourceAsStream(\"content-nested-structure-reordered-nodes.xml\");\n        try {\n            project.createOrUpdateFile(Path.fromPortableString(\"jcr_root/content/test-root/en.xml\"), updatedContentXml);\n        } finally {\n            IOUtils.closeQuietly(updatedContentXml);\n        }\n\n        // poll until we have the child nodes reordered\n        postConditions = allOf(hasPath(\"/content/test-root/en\"), hasPrimaryType(\"sling:OrderedFolder\"),\n                hasMixinTypes(\"mix:language\"), hasChildrenNames(\"message\", \"warning\", \"error\"));\n\n        poller.pollUntil(new Callable<Node>() {\n            @Override\n            public Node call() throws RepositoryException {\n                return repo.getNode(\"/content/test-root/en\");\n\n            }\n        }, postConditions);\n\n    }","id":75995,"modified_method":"@Test\n    public void reorderNodesFromNestedFullCoverageAggregate() throws Exception {\n\n        wstServer.waitForServerToStart();\n\n        // create faceted project\n        IProject contentProject = projectRule.getProject();\n\n        ProjectAdapter project = new ProjectAdapter(contentProject);\n        project.addNatures(\"org.eclipse.wst.common.project.facet.core.nature\");\n\n        // create .content.xml structure\n        InputStream contentXml = getClass().getResourceAsStream(\"content-nested-structure.xml\");\n        project.createOrUpdateFile(Path.fromPortableString(\"jcr_root/content/test-root/en.xml\"), contentXml);\n\n        // install content facet\n        project.installFacet(\"sling.content\", \"1.0\");\n\n        ServerAdapter server = new ServerAdapter(wstServer.getServer());\n        server.installModule(contentProject);\n\n        Matcher<Node> postConditions = allOf(hasPath(\"/content/test-root/en\"), hasPrimaryType(\"sling:Folder\"),\n                hasMixinTypes(\"mix:language\"), hasChildrenNames(\"message\", \"error\", \"warning\"));\n\n        final RepositoryAccessor repo = new RepositoryAccessor(config);\n        Poller poller = new Poller();\n        poller.pollUntil(new Callable<Node>() {\n            @Override\n            public Node call() throws RepositoryException {\n                return repo.getNode(\"/content/test-root/en\");\n\n            }\n        }, postConditions);\n\n        // update .content.xml structure\n        InputStream updatedContentXml = getClass().getResourceAsStream(\"content-nested-structure-reordered-nodes.xml\");\n        project.createOrUpdateFile(Path.fromPortableString(\"jcr_root/content/test-root/en.xml\"), updatedContentXml);\n\n        // poll until we have the child nodes reordered\n        postConditions = allOf(hasPath(\"/content/test-root/en\"), hasPrimaryType(\"sling:OrderedFolder\"),\n                hasMixinTypes(\"mix:language\"), hasChildrenNames(\"message\", \"warning\", \"error\"));\n\n        poller.pollUntil(new Callable<Node>() {\n            @Override\n            public Node call() throws RepositoryException {\n                return repo.getNode(\"/content/test-root/en\");\n\n            }\n        }, postConditions);\n\n    }","commit_id":"10d463154f54e2641e7c76665435e06adfc43609","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void deleteNodeFromNestedFullCoverageAggreate() throws Exception {\n\n        wstServer.waitForServerToStart();\n\n        // create faceted project\n        IProject contentProject = projectRule.getProject();\n\n        ProjectAdapter project = new ProjectAdapter(contentProject);\n        project.addNatures(\"org.eclipse.wst.common.project.facet.core.nature\");\n\n        // create .content.xml structure\n        InputStream contentXml = getClass().getResourceAsStream(\"content-nested-structure.xml\");\n        try {\n            project.createOrUpdateFile(Path.fromPortableString(\"jcr_root/content/test-root/en.xml\"), contentXml);\n        } finally {\n            IOUtils.closeQuietly(contentXml);\n        }\n\n        // install content facet\n        project.installFacet(\"sling.content\", \"1.0\");\n\n        ServerAdapter server = new ServerAdapter(wstServer.getServer());\n        server.installModule(contentProject);\n\n        Matcher<Node> postConditions = allOf(hasPath(\"/content/test-root/en\"), hasPrimaryType(\"sling:Folder\"),\n                hasMixinTypes(\"mix:language\"), hasChildrenCount(3));\n\n        final RepositoryAccessor repo = new RepositoryAccessor(config);\n        Poller poller = new Poller();\n        poller.pollUntil(new Callable<Node>() {\n            @Override\n            public Node call() throws RepositoryException {\n                return repo.getNode(\"/content/test-root/en\");\n\n            }\n        }, postConditions);\n\n        // update .content.xml structure\n        InputStream updatedContentXml = getClass().getResourceAsStream(\"content-nested-structure-deleted-node.xml\");\n        try {\n            project.createOrUpdateFile(Path.fromPortableString(\"jcr_root/content/test-root/en.xml\"), updatedContentXml);\n        } finally {\n            IOUtils.closeQuietly(updatedContentXml);\n        }\n\n        // poll until we only have 2 child nodes left\n        postConditions = allOf(hasPath(\"/content/test-root/en\"), hasPrimaryType(\"sling:Folder\"),\n                hasMixinTypes(\"mix:language\"), hasChildrenCount(2));\n        poller.pollUntil(new Callable<Node>() {\n            @Override\n            public Node call() throws RepositoryException {\n                return repo.getNode(\"/content/test-root/en\");\n\n            }\n        }, postConditions);\n    }","id":75996,"modified_method":"@Test\n    public void deleteNodeFromNestedFullCoverageAggreate() throws Exception {\n\n        wstServer.waitForServerToStart();\n\n        // create faceted project\n        IProject contentProject = projectRule.getProject();\n\n        ProjectAdapter project = new ProjectAdapter(contentProject);\n        project.addNatures(\"org.eclipse.wst.common.project.facet.core.nature\");\n\n        // create .content.xml structure\n        InputStream contentXml = getClass().getResourceAsStream(\"content-nested-structure.xml\");\n        project.createOrUpdateFile(Path.fromPortableString(\"jcr_root/content/test-root/en.xml\"), contentXml);\n\n        // install content facet\n        project.installFacet(\"sling.content\", \"1.0\");\n\n        ServerAdapter server = new ServerAdapter(wstServer.getServer());\n        server.installModule(contentProject);\n\n        Matcher<Node> postConditions = allOf(hasPath(\"/content/test-root/en\"), hasPrimaryType(\"sling:Folder\"),\n                hasMixinTypes(\"mix:language\"), hasChildrenCount(3));\n\n        final RepositoryAccessor repo = new RepositoryAccessor(config);\n        Poller poller = new Poller();\n        poller.pollUntil(new Callable<Node>() {\n            @Override\n            public Node call() throws RepositoryException {\n                return repo.getNode(\"/content/test-root/en\");\n\n            }\n        }, postConditions);\n\n        // update .content.xml structure\n        InputStream updatedContentXml = getClass().getResourceAsStream(\"content-nested-structure-deleted-node.xml\");\n        project.createOrUpdateFile(Path.fromPortableString(\"jcr_root/content/test-root/en.xml\"), updatedContentXml);\n\n        // poll until we only have 2 child nodes left\n        postConditions = allOf(hasPath(\"/content/test-root/en\"), hasPrimaryType(\"sling:Folder\"),\n                hasMixinTypes(\"mix:language\"), hasChildrenCount(2));\n        poller.pollUntil(new Callable<Node>() {\n            @Override\n            public Node call() throws RepositoryException {\n                return repo.getNode(\"/content/test-root/en\");\n\n            }\n        }, postConditions);\n    }","commit_id":"10d463154f54e2641e7c76665435e06adfc43609","url":"https://github.com/apache/sling"},{"original_method":"public void createOrUpdateFile(IPath fromPortableString, InputStream resourceAsStream) throws CoreException {\n\n        if (resourceAsStream == null) {\n            throw new IllegalArgumentException(\"resourceAsStream may not be null\");\n        }\n\n        IContainer current = project;\n\n        for (int i = 0; i < fromPortableString.segmentCount() - 1; i++) {\n\n            String currentSegment = fromPortableString.segment(i);\n            IResource container = current.findMember(currentSegment);\n\n            if (container != null) {\n                if (container.getType() != IContainer.FOLDER) {\n                    throw new IllegalArgumentException(\"Resource \" + container\n                            + \" exists and is not a folder; unable to create file at path \" + fromPortableString);\n                }\n\n                current = (IContainer) container;\n            } else {\n\n                IFolder newFolder = ((IContainer) current).getFolder(Path.fromPortableString(currentSegment));\n                newFolder.create(true, true, new NullProgressMonitor());\n                current = newFolder;\n            }\n        }\n\n        IFile file = current.getFile(Path.fromPortableString(fromPortableString.segments()[fromPortableString\n                .segmentCount() - 1]));\n        if (file.exists()) {\n            file.setContents(resourceAsStream, true, true, new NullProgressMonitor());\n        } else {\n            file.create(resourceAsStream, true, new NullProgressMonitor());\n        }\n\n    }","id":75997,"modified_method":"/**\n     * Creates or updates an existing file\n     * \n     * @param fileLocation the path where the resource will be created or updated\n     * @param contents the contents to write to the file. This stream will be closed after being used\n     * @throws CoreException\n     */\n    public void createOrUpdateFile(IPath fileLocation, InputStream contents) throws CoreException {\n\n        if (contents == null) {\n            throw new IllegalArgumentException(\"resourceAsStream may not be null\");\n        }\n\n        IContainer current = project;\n\n        try {\n            for (int i = 0; i < fileLocation.segmentCount() - 1; i++) {\n\n                String currentSegment = fileLocation.segment(i);\n                IResource container = current.findMember(currentSegment);\n\n                if (container != null) {\n                    if (container.getType() != IContainer.FOLDER) {\n                        throw new IllegalArgumentException(\"Resource \" + container\n                                + \" exists and is not a folder; unable to create file at path \" + fileLocation);\n                    }\n\n                    current = (IContainer) container;\n                } else {\n\n                    IFolder newFolder = ((IContainer) current).getFolder(Path.fromPortableString(currentSegment));\n                    newFolder.create(true, true, new NullProgressMonitor());\n                    current = newFolder;\n                }\n            }\n\n            IFile file = current.getFile(Path.fromPortableString(fileLocation.segments()[fileLocation\n                    .segmentCount() - 1]));\n            if (file.exists()) {\n                file.setContents(contents, true, true, new NullProgressMonitor());\n            } else {\n                file.create(contents, true, new NullProgressMonitor());\n            }\n        } finally {\n            IOUtils.closeQuietly(contents);\n        }\n\n    }","commit_id":"10d463154f54e2641e7c76665435e06adfc43609","url":"https://github.com/apache/sling"},{"original_method":"@Override\n\t\tpublic void visitINVOKEINTERFACE(INVOKEINTERFACE obj) {\n\t\t\thandleInstanceMethod(obj);\n\t\t}","id":75998,"modified_method":"@Override\n\t\tpublic void visitINVOKEINTERFACE(INVOKEINTERFACE obj) {\n\t\t\tif (returnsString(obj))\n\t\t\t\thandleInstanceMethod(obj);\n\t\t\telse super.visitINVOKEINTERFACE(obj);\n\n\t\t}","commit_id":"908d9f33f6c4347292af37b8f66b03a912e0177c","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n\t\tpublic void visitINVOKEVIRTUAL(INVOKEVIRTUAL obj) {\n\t\t\thandleInstanceMethod(obj);\n\t\t}","id":75999,"modified_method":"@Override\n\t\tpublic void visitINVOKEVIRTUAL(INVOKEVIRTUAL obj) {\n\t\t\tif (returnsString(obj))\n\t\t\t\thandleInstanceMethod(obj);\n\t\t\telse super.visitINVOKEVIRTUAL(obj);\n\t\t}","commit_id":"908d9f33f6c4347292af37b8f66b03a912e0177c","url":"https://github.com/findbugsproject/findbugs"}]