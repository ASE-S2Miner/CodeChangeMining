[{"original_method":"public MapReduceMetricsWriter(Job jobConf, BasicMapReduceContext context) {\n    this.jobConf = jobConf;\n    this.context = context;\n    this.previousMapStats = HashBasedTable.create();\n    this.previousReduceStats = HashBasedTable.create();\n  }","id":6000,"modified_method":"public MapReduceMetricsWriter(Job jobConf, BasicMapReduceContext context) {\n    this.jobConf = jobConf;\n    this.context = context;\n    this.previousMapStats = HashBasedTable.create();\n    this.previousReduceStats = HashBasedTable.create();\n    this.previousSystemStats = HashBasedTable.create();\n  }","commit_id":"6e532337da452d88ca9d817b727ff17a687b82c0","url":"https://github.com/caskdata/cdap"},{"original_method":"@Nullable\n  public <P extends PsiElement> StubElement<P> findChildStubByType(final IStubElementType<?, P> elementType) {\n    for (StubElement childStub : getChildrenStubs()) {\n      if (childStub.getStubType() == elementType) {\n        return childStub;\n      }\n    }\n    return null;\n  }","id":6001,"modified_method":"@Nullable\n  public <P extends PsiElement> StubElement<P> findChildStubByType(final IStubElementType<?, P> elementType) {\n    final List<StubElement> childrenStubs = getChildrenStubs();\n    final int size = childrenStubs.size();\n\n    for (int i = 0; i < size; ++i) {\n      final StubElement childStub = childrenStubs.get(i);\n      if (childStub.getStubType() == elementType) {\n        return childStub;\n      }\n    }\n    return null;\n  }","commit_id":"f1476a509cc12f4a8fe51be3c5f9d91091ada6b1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isSuperMethod(PsiMethod method, PsiMethod superMethod) {\n    HierarchicalMethodSignature signature = method.getHierarchicalMethodSignature();\n    for (HierarchicalMethodSignature supsig : signature.getSuperSignatures()) {\n      PsiMethod supsigme = supsig.getMethod();\n      if (superMethod.equals(supsigme) || isSuperMethod(supsigme, superMethod)) return true;\n    }\n\n    return false;\n  }","id":6002,"modified_method":"public static boolean isSuperMethod(PsiMethod method, PsiMethod superMethod) {\n    HierarchicalMethodSignature signature = method.getHierarchicalMethodSignature();\n    List<HierarchicalMethodSignature> superSignatures = signature.getSuperSignatures();\n    for (int i = 0, superSignaturesSize = superSignatures.size(); i < superSignaturesSize; i++) {\n      HierarchicalMethodSignature supsig = superSignatures.get(i);\n      PsiMethod supsigme = supsig.getMethod();\n      if (superMethod.equals(supsigme) || isSuperMethod(supsigme, superMethod)) return true;\n    }\n\n    return false;\n  }","commit_id":"37460687f41fb7d4ff1896192bdddd860f2ac428","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private int countChildren(final IElementType elementType) {\n    int count = 0;\n    for (StubElement childStub : getChildrenStubs()) {\n      if (childStub.getStubType() == elementType) count++;\n    }\n\n    return count;\n  }","id":6003,"modified_method":"private int countChildren(final IElementType elementType) {\n    int count = 0;\n    List<StubElement> childrenStubs = getChildrenStubs();\n    for (int i = 0, childrenStubsSize = childrenStubs.size(); i < childrenStubsSize; i++) {\n      StubElement childStub = childrenStubs.get(i);\n      if (childStub.getStubType() == elementType) count++;\n    }\n\n    return count;\n  }","commit_id":"37460687f41fb7d4ff1896192bdddd860f2ac428","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private int countChildren(final TokenSet types) {\n    int count = 0;\n    for (StubElement childStub : getChildrenStubs()) {\n      if (types.contains(childStub.getStubType())) count++;\n    }\n\n    return count;\n  }","id":6004,"modified_method":"private int countChildren(final TokenSet types) {\n    int count = 0;\n    List<StubElement> childrenStubs = getChildrenStubs();\n    for (int i = 0, childrenStubsSize = childrenStubs.size(); i < childrenStubsSize; i++) {\n      StubElement childStub = childrenStubs.get(i);\n      if (types.contains(childStub.getStubType())) count++;\n    }\n\n    return count;\n  }","commit_id":"37460687f41fb7d4ff1896192bdddd860f2ac428","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n    * put your documentation comment here\n    * @param sessionData\n    */\n   public void execute (CGroupsManagerSessionData sessionData) {\n      ChannelStaticData staticData = sessionData.staticData;\n      ChannelRuntimeData runtimeData= sessionData.runtimeData;\n      Document model = getXmlDoc(sessionData);\n      Utility.logMessage(\"DEBUG\", \"AddMembers::execute(): Start\");\n      String parentAddElemId = getCommandArg(runtimeData);\n      try{\n         IGroupMember pg = GroupsManagerXML.retrieveGroupMemberForElementId(model, parentAddElemId);\n         sessionData.rootViewGroupID = Utility.translateKeytoID(GroupService.getRootGroup(pg.getLeafType()).getKey(),getXmlDoc(sessionData));\n         // Parent was locked so no other thread or process could have changed it, but\n         // child members could have changed.\n         Element parentElem = GroupsManagerXML.getElementById(model, parentAddElemId);\n         GroupsManagerXML.refreshAllNodesRecursivelyIfRequired(model, parentElem);\n      }\n      catch(Exception e){\n         LogService.instance().log(LogService.ERROR,e);\n      }\n      sessionData.mode=SELECT_MODE;\n      sessionData.highlightedGroupID = sessionData.rootViewGroupID;\n      Utility.logMessage(\"DEBUG\", \"AddMembers::execute(): Uid of parent element = \" +\n            parentAddElemId);\n      staticData.setParameter(\"groupParentId\", parentAddElemId);\n   }","id":6005,"modified_method":"/**\n    * put your documentation comment here\n    * @throws Exception\n    * @param sessionData\n    */\n   public void execute (CGroupsManagerSessionData sessionData) throws Exception{\n      ChannelStaticData staticData = sessionData.staticData;\n      ChannelRuntimeData runtimeData= sessionData.runtimeData;\n      Document model = getXmlDoc(sessionData);\n      Utility.logMessage(\"DEBUG\", \"AddMembers::execute(): Start\");\n      String parentAddElemId = getCommandArg(runtimeData);\n\n      IGroupMember pg = GroupsManagerXML.retrieveGroupMemberForElementId(model, parentAddElemId);\n      sessionData.rootViewGroupID = Utility.translateKeytoID(GroupService.getRootGroup(pg.getLeafType()).getKey(),getXmlDoc(sessionData));\n      // Parent was locked so no other thread or process could have changed it, but\n      // child members could have changed.\n      Element parentElem = GroupsManagerXML.getElementById(model, parentAddElemId);\n      GroupsManagerXML.refreshAllNodesRecursivelyIfRequired(model, parentElem);\n\n      sessionData.mode=SELECT_MODE;\n      sessionData.highlightedGroupID = sessionData.rootViewGroupID;\n      Utility.logMessage(\"DEBUG\", \"AddMembers::execute(): Uid of parent element = \" +\n            parentAddElemId);\n      staticData.setParameter(\"groupParentId\", parentAddElemId);\n   }","commit_id":"96cda17d1df681a885e0f5383409673be6598fd6","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void execute(CGroupsManagerSessionData sessionData) {\n         try {\n            ChannelRuntimeData slaveRD = sessionData.runtimeData;\n            String[] tgts = new String[1];\n            tgts[0] = this.getCommandArg(sessionData.runtimeData);\n            sessionData.servantChannel = CPermissionsManagerServantFactory.getPermissionsServant((IPermissible)Class.forName(OWNER).newInstance(),\n                  sessionData.staticData, null, null, tgts);\n            slaveRD = (ChannelRuntimeData)sessionData.runtimeData.clone();\n            Enumeration srd = slaveRD.keys();\n            while (srd.hasMoreElements()) {\n               slaveRD.remove(srd.nextElement());\n            }\n            sessionData.runtimeData = slaveRD;\n         } catch (Exception e) {\n            LogService.instance().log(LogService.ERROR, e);\n            sessionData.feedback=\"Error tring to assign permissions: \"+e.getMessage();\n         }\n   }","id":6006,"modified_method":"/**\n    * put your documentation comment here\n    * @throws Exception\n    * @param sessionData\n    */\n   public void execute(CGroupsManagerSessionData sessionData) throws Exception{\n      ChannelRuntimeData slaveRD = sessionData.runtimeData;\n      String[] tgts = new String[1];\n      tgts[0] = this.getCommandArg(sessionData.runtimeData);\n      sessionData.servantChannel = CPermissionsManagerServantFactory.getPermissionsServant((IPermissible)Class.forName(OWNER).newInstance(),\n            sessionData.staticData, null, null, tgts);\n      slaveRD = (ChannelRuntimeData)sessionData.runtimeData.clone();\n      Enumeration srd = slaveRD.keys();\n      while (srd.hasMoreElements()) {\n         slaveRD.remove(srd.nextElement());\n      }\n      sessionData.runtimeData = slaveRD;\n   }","commit_id":"96cda17d1df681a885e0f5383409673be6598fd6","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n    * Returns an array of objects representing the result set.\n    * Note that these are IGroupMembers !!\n    * @return Object[]\n    */\n   public Object[] getResults () {\n      CGroupsManagerSessionData sessionData = ((CGroupsManager) channel).getSessionData(uid);\n      ChannelStaticData staticData = sessionData.staticData;\n      ChannelRuntimeData runtimeData = sessionData.runtimeData;\n      Object[] results = null;\n      IGroupsManagerCommand cmd = GroupsManagerCommandFactory.instance().get(\"Done\");\n      cmd.execute(sessionData);\n      results = (Object[])staticData.get(\"princResults\");\n      Utility.logMessage(\"DEBUG\", \"CGroupsManagerservant.getResults()\");\n      return  results;\n   }","id":6007,"modified_method":"/**\n    * Returns an array of objects representing the result set.\n    * Note that these are IGroupMembers !!\n    * @return Object[]\n    */\n   public Object[] getResults () {\n      CGroupsManagerSessionData sessionData = ((CGroupsManager) channel).getSessionData(uid);\n      ChannelStaticData staticData = sessionData.staticData;\n      ChannelRuntimeData runtimeData = sessionData.runtimeData;\n      Object[] results = null;\n      IGroupsManagerCommand cmd = GroupsManagerCommandFactory.instance().get(\"Done\");\n      try{\n         cmd.execute(sessionData);\n      }\n      catch(Exception e){\n         LogService.instance().log(LogService.ERROR,e);\n         sessionData.feedback = \"Error executing command Done: \"+e.getMessage();\n      }\n      results = (Object[])staticData.get(\"princResults\");\n      Utility.logMessage(\"DEBUG\", \"CGroupsManagerservant.getResults()\");\n      return  results;\n   }","commit_id":"96cda17d1df681a885e0f5383409673be6598fd6","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n    * put your documentation comment here\n    * @param sessionData\n    */\n   public void execute (CGroupsManagerSessionData sessionData) {\n      ChannelStaticData staticData = sessionData.staticData;\n      ChannelRuntimeData runtimeData= sessionData.runtimeData;\n\n      Document model = getXmlDoc(sessionData);\n      /** @todo move to GroupManagerCommand.cleanUp */\n      Utility.logMessage(\"DEBUG\", \"CancelSelection::execute(): Start\");\n      clearSelected(sessionData);\n      String parentId = getParentId(staticData);\n      if (parentId != null) {\n         // came from the edit screen, so go back\n         sessionData.mode = EDIT_MODE;\n         sessionData.highlightedGroupID = parentId;\n         sessionData.rootViewGroupID=\"0\";\n         staticData.remove(\"groupParentId\");\n         // Parent was locked so no other thread or process could have changed it, but\n         // child members could have changed.\n         Element parentElem = GroupsManagerXML.getElementById(model, parentId);\n         GroupsManagerXML.refreshAllNodesRecursivelyIfRequired(model, parentElem);\n      }\n      else {\n         staticData.setParameter(\"groupManagerFinished\", \"true\");\n      }\n   }","id":6008,"modified_method":"/**\n    * put your documentation comment here\n    * @throws Exception\n    * @param sessionData\n    */\n   public void execute (CGroupsManagerSessionData sessionData) throws Exception{\n      ChannelStaticData staticData = sessionData.staticData;\n      ChannelRuntimeData runtimeData= sessionData.runtimeData;\n\n      Document model = getXmlDoc(sessionData);\n      /** @todo move to GroupManagerCommand.cleanUp */\n      Utility.logMessage(\"DEBUG\", \"CancelSelection::execute(): Start\");\n      clearSelected(sessionData);\n      String parentId = getParentId(staticData);\n      if (parentId != null) {\n         // came from the edit screen, so go back\n         sessionData.mode = EDIT_MODE;\n         sessionData.highlightedGroupID = parentId;\n         sessionData.rootViewGroupID=\"0\";\n         staticData.remove(\"groupParentId\");\n         // Parent was locked so no other thread or process could have changed it, but\n         // child members could have changed.\n         Element parentElem = GroupsManagerXML.getElementById(model, parentId);\n         GroupsManagerXML.refreshAllNodesRecursivelyIfRequired(model, parentElem);\n      }\n      else {\n         staticData.setParameter(\"groupManagerFinished\", \"true\");\n      }\n   }","commit_id":"96cda17d1df681a885e0f5383409673be6598fd6","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n    * put your documentation comment here\n    * @param sessionData\n    */\n   public void execute (CGroupsManagerSessionData sessionData) {\n      ChannelStaticData staticData = sessionData.staticData;\n      ChannelRuntimeData runtimeData= sessionData.runtimeData;\n\n      Utility.logMessage(\"DEBUG\", \"CollapseGroup::execute(): Start\");\n      Document model = getXmlDoc(sessionData);\n      Element collapseElem = GroupsManagerXML.getElementByTagNameAndId(model, GROUP_TAGNAME,\n            getCommandArg(runtimeData));\n      Utility.logMessage(\"DEBUG\", \"CollapseGroup::execute(): collapseElem was found: \"\n            + collapseElem);\n      if (collapseElem != null) {\n         Utility.logMessage(\"DEBUG\", \"CollapseGroup::execute(): Element to be expanded: \\n\"\n               + collapseElem);\n         GroupsManagerXML.refreshAllNodesIfRequired(model, collapseElem);\n         collapseElem.setAttribute(\"expanded\", \"false\");\n         GroupsManagerXML.refreshAllNodesIfRequired(model, collapseElem);\n      }\n      return;\n   }","id":6009,"modified_method":"/**\n    * put your documentation comment here\n    * @throws Exception\n    * @param sessionData\n    */\n   public void execute (CGroupsManagerSessionData sessionData) throws Exception{\n      ChannelStaticData staticData = sessionData.staticData;\n      ChannelRuntimeData runtimeData= sessionData.runtimeData;\n\n      Utility.logMessage(\"DEBUG\", \"CollapseGroup::execute(): Start\");\n      Document model = getXmlDoc(sessionData);\n      Element collapseElem = GroupsManagerXML.getElementByTagNameAndId(model, GROUP_TAGNAME,\n            getCommandArg(runtimeData));\n      Utility.logMessage(\"DEBUG\", \"CollapseGroup::execute(): collapseElem was found: \"\n            + collapseElem);\n      if (collapseElem != null) {\n         Utility.logMessage(\"DEBUG\", \"CollapseGroup::execute(): Element to be expanded: \\n\"\n               + collapseElem);\n         GroupsManagerXML.refreshAllNodesIfRequired(model, collapseElem);\n         collapseElem.setAttribute(\"expanded\", \"false\");\n         GroupsManagerXML.refreshAllNodesIfRequired(model, collapseElem);\n      }\n      return;\n   }","commit_id":"96cda17d1df681a885e0f5383409673be6598fd6","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n    * The execute() method is the main method for the CreateMember command.\n    * @param sessionData\n    */\n   public void execute (CGroupsManagerSessionData sessionData) {\n      ChannelStaticData staticData = sessionData.staticData;\n      ChannelRuntimeData runtimeData= sessionData.runtimeData;\n\n      Utility.logMessage(\"DEBUG\", \"CreateGroup::execute(): Start\");\n      Document model = getXmlDoc(sessionData);\n      String theCommand = runtimeData.getParameter(\"grpCommand\");\n      String parentID = getCommandArg(runtimeData);\n      boolean parentIsInitialGroupContext = parentIsInitialGroupContext(parentID);\n      String newGrpName = runtimeData.getParameter(\"grpNewName\");\n      Utility.logMessage(\"DEBUG\", \"CreateGroup::execute(): New grp: \" + newGrpName +\n            \" will be added to parent element = \" + parentID);\n      IEntityGroup parentGroup = null;\n      Class parentEntityType;\n      Element parentElem = GroupsManagerXML.getElementByTagNameAndId(model, GROUP_TAGNAME, parentID);\n      String parentKey = parentElem.getAttribute(\"key\");\n      String retMsg;\n      Iterator parentNodes;\n      if (parentElem == null) {\n         retMsg = \"Unable to find Parent element!\";\n         sessionData.feedback = retMsg;\n         Utility.logMessage(\"ERROR\", \"CreateGroup::execute(): \" + retMsg);\n         return;\n      }\n      Utility.logMessage(\"DEBUG\", \"CreateGroup::execute(): Parent element was found!\");\n      try {\n         // The parent could be an IGroupMember or an IInitialGroupContext.\n         if (!parentIsInitialGroupContext) {\n            parentGroup = GroupsManagerXML.retrieveGroup(parentKey);\n            if (parentGroup == null) {\n               retMsg = \"Unable to retrieve Parent Entity Group!\";\n               sessionData.feedback = retMsg;\n               return;\n            }\n            else {\n               parentEntityType = parentGroup.getLeafType();\n            }\n         }\n         else {\n            /** @todo A list will be presented to the user who will select the type\n             *  of group to create */\n            parentEntityType = Class.forName((String) GroupsManagerXML.getEntityTypes().get(\"IPerson\"));\n         }\n         Utility.logMessage(\"DEBUG\", \"CreateGroup::execute(): About to create new group: \"\n               + newGrpName);\n         // Next line creates a group that will hold iEntities\n         String userID = getUserID(sessionData);\n         IEntityGroup childEntGrp = GroupService.newGroup(parentEntityType);\n         childEntGrp.setName(newGrpName);\n         childEntGrp.setCreatorID(userID);\n         childEntGrp.update();\n         Utility.logMessage(\"DEBUG\", \"CreateGroup::execute(): About to add new group: \"\n               + newGrpName);\n         if (parentIsInitialGroupContext) {\n            IInitialGroupContext igc = Utility.createInitialGroupContext(userID, \"p\",\n                  childEntGrp.getKey(), 1, false, null);\n            igc.update();\n            Node parentNode = (Node)parentElem;\n            Element childElem = GroupsManagerXML.getGroupMemberXml((IGroupMember)childEntGrp,\n                  false, null, model);\n            parentNode.appendChild((Node)childElem);\n         }\n         else {\n            parentGroup.addMember((IGroupMember)childEntGrp);\n            parentGroup.updateMembers();\n            parentNodes = GroupsManagerXML.getNodesByTagNameAndKey(model, GROUP_TAGNAME, parentKey);\n            // add new group to all parent group xml nodes\n            while (parentNodes.hasNext()) {\n               Element parentNode = (Element)parentNodes.next();\n               GroupsManagerXML.getGroupMemberXml((IGroupMember)parentGroup, true, parentNode,\n                     model);\n               ((Element)parentNode).setAttribute(\"hasMembers\", \"true\");\n            }\n         }\n\n         /** Grant all permissions for the new group to the creator */\n         /** @todo need to catch following exceptions for next block of code\n          *  org.jasig.portal.AuthorizationException\n          *  java.lang.IllegalAccessException\n          *  java.lang.InstantiationException */\n         ArrayList perms = new ArrayList();\n         IUpdatingPermissionManager upm = AuthorizationService.instance().newUpdatingPermissionManager(OWNER);\n         IAuthorizationPrincipal ap = staticData.getAuthorizationPrincipal();\n         Utility.logMessage(\"DEBUG\", \"CreateGroup::execute(): The IAuthorizationPrincipal: \" + ap);\n         String[] activities = ((IPermissible)Class.forName(OWNER).newInstance()).getActivityTokens();\n         IPermission prm;\n         for (int a = 0; a < activities.length; a++) {\n            prm = upm.newPermission(ap);\n            prm.setActivity(activities[a]);\n            prm.setTarget(childEntGrp.getKey());\n            prm.setType(\"GRANT\");\n            perms.add(prm);\n         }\n         upm.addPermissions((IPermission[])perms.toArray(new IPermission[perms.size()]));\n\n         // create permission elements\n         /** @todo should make sure there is one and only one principal element */\n         NodeList principals = model.getDocumentElement().getElementsByTagName(\"principal\");\n         Element princElem = (Element)principals.item(0);\n         for (int p = 0; p < perms.size(); p++) {\n            prm = (IPermission)perms.get(p);\n            Element permElem = GroupsManagerXML.getPermissionXml(model, prm.getPrincipal(), prm.getActivity(), prm.getType(), prm.getTarget());\n            /** @todo should we check if element already exists??? */\n            princElem.appendChild(permElem);\n         }\n         // Parent was locked so no other thread or process could have changed it, but\n         // child members could have changed.\n         GroupsManagerXML.refreshAllNodesRecursivelyIfRequired(model, parentElem);\n      } catch (GroupsException ge) {\n         retMsg = \"Unable to create new group\\n\" + ge;\n         sessionData.feedback = retMsg;\n         Utility.logMessage(\"ERROR\", \"CreateGroup::execute(): \" + retMsg + \"\\n\" + ge);\n      } catch (ClassNotFoundException cnfe) {\n         retMsg = \"Unable to instantiate class \" + GROUP_CLASSNAME;\n         sessionData.feedback = retMsg;\n         Utility.logMessage(\"ERROR\", \"CreateGroup::execute(): \" + retMsg + \"\\n\" + cnfe);\n      } catch (Exception e) {\n         retMsg = \"Unable to create group\";\n         sessionData.feedback = retMsg;\n         Utility.logMessage(\"ERROR\", \"CreateGroup::execute(): \" + retMsg + \".\\n\" + e);\n      }\n      Utility.logMessage(\"DEBUG\", \"CreateGroup::execute(): Finished\");\n   }","id":6010,"modified_method":"/**\n    * The execute() method is the main method for the CreateMember command.\n    * @throws Exception\n    * @param sessionData\n    */\n   public void execute (CGroupsManagerSessionData sessionData) throws Exception{\n      ChannelStaticData staticData = sessionData.staticData;\n      ChannelRuntimeData runtimeData= sessionData.runtimeData;\n\n      Utility.logMessage(\"DEBUG\", \"CreateGroup::execute(): Start\");\n      Document model = getXmlDoc(sessionData);\n      String theCommand = runtimeData.getParameter(\"grpCommand\");\n      String parentID = getCommandArg(runtimeData);\n      boolean parentIsInitialGroupContext = parentIsInitialGroupContext(parentID);\n      String newGrpName = runtimeData.getParameter(\"grpNewName\");\n      Utility.logMessage(\"DEBUG\", \"CreateGroup::execute(): New grp: \" + newGrpName +\n            \" will be added to parent element = \" + parentID);\n      IEntityGroup parentGroup = null;\n      Class parentEntityType;\n      Element parentElem = GroupsManagerXML.getElementByTagNameAndId(model, GROUP_TAGNAME, parentID);\n      String parentKey = parentElem.getAttribute(\"key\");\n      String retMsg;\n      Iterator parentNodes;\n      if (parentElem == null) {\n         retMsg = \"Unable to find Parent element!\";\n         sessionData.feedback = retMsg;\n         Utility.logMessage(\"ERROR\", \"CreateGroup::execute(): \" + retMsg);\n         return;\n      }\n      Utility.logMessage(\"DEBUG\", \"CreateGroup::execute(): Parent element was found!\");\n\n      // The parent could be an IGroupMember or an IInitialGroupContext.\n      if (!parentIsInitialGroupContext) {\n         parentGroup = GroupsManagerXML.retrieveGroup(parentKey);\n         if (parentGroup == null) {\n            retMsg = \"Unable to retrieve Parent Entity Group!\";\n            sessionData.feedback = retMsg;\n            return;\n         }\n         else {\n            parentEntityType = parentGroup.getLeafType();\n         }\n      }\n      else {\n         /** @todo A list will be presented to the user who will select the type\n          *  of group to create */\n         parentEntityType = Class.forName((String) GroupsManagerXML.getEntityTypes().get(\"IPerson\"));\n      }\n      Utility.logMessage(\"DEBUG\", \"CreateGroup::execute(): About to create new group: \"\n            + newGrpName);\n      // Next line creates a group that will hold iEntities\n      String userID = getUserID(sessionData);\n      IEntityGroup childEntGrp = GroupService.newGroup(parentEntityType);\n      childEntGrp.setName(newGrpName);\n      childEntGrp.setCreatorID(userID);\n      childEntGrp.update();\n      Utility.logMessage(\"DEBUG\", \"CreateGroup::execute(): About to add new group: \"\n            + newGrpName);\n      if (parentIsInitialGroupContext) {\n         IInitialGroupContext igc = Utility.createInitialGroupContext(userID, \"p\",\n               childEntGrp.getKey(), 1, false, null);\n         igc.update();\n         Node parentNode = (Node)parentElem;\n         Element childElem = GroupsManagerXML.getGroupMemberXml((IGroupMember)childEntGrp,\n               false, null, model);\n         parentNode.appendChild((Node)childElem);\n      }\n      else {\n         parentGroup.addMember((IGroupMember)childEntGrp);\n         parentGroup.updateMembers();\n         parentNodes = GroupsManagerXML.getNodesByTagNameAndKey(model, GROUP_TAGNAME, parentKey);\n         // add new group to all parent group xml nodes\n         while (parentNodes.hasNext()) {\n            Element parentNode = (Element)parentNodes.next();\n            GroupsManagerXML.getGroupMemberXml((IGroupMember)parentGroup, true, parentNode,\n                  model);\n            ((Element)parentNode).setAttribute(\"hasMembers\", \"true\");\n         }\n      }\n\n      /** Grant all permissions for the new group to the creator */\n      /** @todo need to catch following exceptions for next block of code\n       *  org.jasig.portal.AuthorizationException\n       *  java.lang.IllegalAccessException\n       *  java.lang.InstantiationException */\n      ArrayList perms = new ArrayList();\n      IUpdatingPermissionManager upm = AuthorizationService.instance().newUpdatingPermissionManager(OWNER);\n      IAuthorizationPrincipal ap = staticData.getAuthorizationPrincipal();\n      Utility.logMessage(\"DEBUG\", \"CreateGroup::execute(): The IAuthorizationPrincipal: \" + ap);\n      String[] activities = ((IPermissible)Class.forName(OWNER).newInstance()).getActivityTokens();\n      IPermission prm;\n      for (int a = 0; a < activities.length; a++) {\n         prm = upm.newPermission(ap);\n         prm.setActivity(activities[a]);\n         prm.setTarget(childEntGrp.getKey());\n         prm.setType(\"GRANT\");\n         perms.add(prm);\n      }\n      upm.addPermissions((IPermission[])perms.toArray(new IPermission[perms.size()]));\n\n      // create permission elements\n      /** @todo should make sure there is one and only one principal element */\n      NodeList principals = model.getDocumentElement().getElementsByTagName(\"principal\");\n      Element princElem = (Element)principals.item(0);\n      for (int p = 0; p < perms.size(); p++) {\n         prm = (IPermission)perms.get(p);\n         Element permElem = GroupsManagerXML.getPermissionXml(model, prm.getPrincipal(), prm.getActivity(), prm.getType(), prm.getTarget());\n         /** @todo should we check if element already exists??? */\n         princElem.appendChild(permElem);\n      }\n      // Parent was locked so no other thread or process could have changed it, but\n      // child members could have changed.\n      GroupsManagerXML.refreshAllNodesRecursivelyIfRequired(model, parentElem);\n\n      Utility.logMessage(\"DEBUG\", \"CreateGroup::execute(): Finished\");\n   }","commit_id":"96cda17d1df681a885e0f5383409673be6598fd6","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n    * Removes all of the permissions for a GroupMember. We need to get permissions\n    * for the group as a principal and as a target. I am merging the 2 arrays into a\n    * single array in order to use the transaction management in the RDBMPermissionsImpl.\n    * If an exception is generated, I do not delete the group or anything else.\n    * Possible Exceptions: AuthorizationException and GroupsException\n    * @param grpMbr\n    * @throws ChainedException\n    */\n   public static void deletePermissions (IGroupMember grpMbr) throws ChainedException{\n      try {\n         String grpKey = grpMbr.getKey();\n         // first we retrieve all permissions for which the group is the principal\n         IAuthorizationPrincipal iap = AuthorizationService.instance().newPrincipal(grpMbr);\n         IPermission[] perms1 = iap.getPermissions();\n\n         // next we retrieve all permissions for which the group is the target\n         IUpdatingPermissionManager upm = AuthorizationService.instance().newUpdatingPermissionManager(OWNER);\n         IPermission[] perms2 = upm.getPermissions(null, grpKey);\n\n         // merge the permissions\n         IPermission[] allPerms = new IPermission[perms1.length + perms2.length];\n         System.arraycopy(perms1,0,allPerms,0,perms1.length);\n         System.arraycopy(perms2,0,allPerms,perms1.length,perms2.length);\n\n         upm.removePermissions(allPerms);\n      }\n      catch (Exception e) {\n         String errMsg = \"DeleteGropu::deletePermissions(): Error removing permissions for \" + grpMbr;\n         Utility.logMessage(\"ERROR\", errMsg);\n         throw new ChainedException(errMsg, e);\n      }\n   }","id":6011,"modified_method":"/**\n    * Removes all of the permissions for a GroupMember. We need to get permissions\n    * for the group as a principal and as a target. I am merging the 2 arrays into a\n    * single array in order to use the transaction management in the RDBMPermissionsImpl.\n    * If an exception is generated, I do not delete the group or anything else.\n    * Possible Exceptions: AuthorizationException and GroupsException\n    * @param grpMbr\n    * @throws ChainedException\n    */\n   public static void deletePermissions (IGroupMember grpMbr) throws ChainedException{\n      try {\n         String grpKey = grpMbr.getKey();\n         // first we retrieve all permissions for which the group is the principal\n         IAuthorizationPrincipal iap = AuthorizationService.instance().newPrincipal(grpMbr);\n         IPermission[] perms1 = iap.getPermissions();\n\n         // next we retrieve all permissions for which the group is the target\n         IUpdatingPermissionManager upm = AuthorizationService.instance().newUpdatingPermissionManager(OWNER);\n         IPermission[] perms2 = upm.getPermissions(null, grpKey);\n\n         // merge the permissions\n         IPermission[] allPerms = new IPermission[perms1.length + perms2.length];\n         System.arraycopy(perms1,0,allPerms,0,perms1.length);\n         System.arraycopy(perms2,0,allPerms,perms1.length,perms2.length);\n\n         upm.removePermissions(allPerms);\n      }\n      catch (Exception e) {\n         String errMsg = \"DeleteGroup::deletePermissions(): Error removing permissions for \" + grpMbr;\n         Utility.logMessage(\"ERROR\", errMsg);\n         throw new ChainedException(errMsg, e);\n      }\n   }","commit_id":"96cda17d1df681a885e0f5383409673be6598fd6","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n    * put your documentation comment here\n    * @param sessionData\n    */\n   public void execute (CGroupsManagerSessionData sessionData) {\n      ChannelStaticData staticData = sessionData.staticData;\n      ChannelRuntimeData runtimeData= sessionData.runtimeData;\n\n      Utility.logMessage(\"DEBUG\", \"DeleteGroup::execute(): Start\");\n      Document model = getXmlDoc(sessionData);\n      String userID = getUserID(sessionData);\n      String theCommand = runtimeData.getParameter(\"grpCommand\");\n      String delId = getCommandArg(runtimeData);\n      Element delElem = GroupsManagerXML.getElementByTagNameAndId(model, GROUP_TAGNAME, delId);\n      Element pn = ((Element)delElem.getParentNode());\n      if (pn !=null){\n       sessionData.highlightedGroupID = pn.getAttribute(\"id\");\n      }\n      String delKey = delElem.getAttribute(\"key\");\n      String elemName = delElem.getAttribute(\"name\");\n      String retMsg;\n      Node parentNode;\n      Node deletedNode;\n      Utility.logMessage(\"DEBUG\", \"DeleteGroup::execute(): Group: \" + elemName + \"will be deleted\");\n      if (Utility.areEqual(delElem.getAttribute(\"searchResults\"), \"true\")){\n        // if it is search results, just delete the node and skip the rest\n        delElem.getParentNode().removeChild(delElem);\n      }\n      else{\n      try {\n         /** @todo remove this section, no more element caching */\n         // Needed to delete cached element\n         //IGroupsManagerWrapper rap = (IGroupsManagerWrapper)GroupsManagerWrapperFactory.instance().get(ENTITY_TAGNAME);\n\n         IEntityGroup delGroup = GroupsManagerXML.retrieveGroup(delKey);\n         if (delGroup == null) {\n            retMsg = \"Unable to retrieve Group!\";\n            sessionData.feedback = retMsg;\n            return;\n         }\n         Utility.logMessage(\"DEBUG\", \"DeleteGroup::execute(): About to delete group: \"\n               + elemName);\n         // remove permissions associated with group\n         deletePermissions((IGroupMember)delGroup);\n         // delete the group\n         delGroup.delete();\n         Utility.logMessage(\"DEBUG\", \"DeleteGroup::execute(): About to delete xml nodes for group: \"\n               + elemName);\n         // remove all xml nodes for this group\n         Iterator deletedNodes = GroupsManagerXML.getNodesByTagNameAndKey(model, GROUP_TAGNAME,\n               delKey);\n         IEntityGroup parentEntGrp = null;\n         String hasMbrs = \"duh\";\n         while (deletedNodes.hasNext()) {\n            deletedNode = (Node)deletedNodes.next();\n            parentNode = deletedNode.getParentNode();\n            boolean parentIsInitialGroupContext = parentIsInitialGroupContext(((Element)parentNode).getAttribute(\"id\"));\n            if (parentIsInitialGroupContext) {\n               IInitialGroupContext igc = RDBMInitialGroupContextStore.singleton().find(userID, delKey);\n               RDBMInitialGroupContextStore.singleton().delete(igc);\n               hasMbrs = \"true\";\n            }\n            else {\n               String nodeKey = ((Element)parentNode).getAttribute(\"key\");\n               if (parentEntGrp == null || !parentEntGrp.getKey().equals(nodeKey)) {\n                  parentEntGrp = GroupsManagerXML.retrieveGroup(nodeKey);\n                  hasMbrs = String.valueOf(parentEntGrp.hasMembers());\n               }\n            }\n            parentNode.removeChild(deletedNode);\n            ((Element)parentNode).setAttribute(\"hasMembers\", hasMbrs);\n         }\n\n         /** Remove the permission elements in the xmlDoc */\n         Node principalNode = (Node)model.getDocumentElement().getElementsByTagName(\"principal\").item(0);\n         NodeList permElems = model.getElementsByTagName(\"permission\");\n         /** If we delete from the bottom up, the NodeList elements shift down\n          *  everytime we delete an element. Since the elements that we are looking\n          *  for are sequential and because we increment the counter at the end of\n          *  the loop, the element that we should process next slips down into the\n          *  slot that we just processed. We therefore end up deleting every other\n          *  element. The solution is to delete from the top down.\n          */\n         for (int i = permElems.getLength() - 1; i > -1; i--) {\n            Element permElem = (Element)permElems.item(i);\n            if (permElem.getAttribute(\"target\").equals(delKey)) {\n               principalNode.removeChild(permElem);\n            }\n         }\n         sessionData.mode=BROWSE_MODE;\n      } catch (GroupsException ge) {\n         retMsg = \"Unable to delete group : \" + elemName;\n         sessionData.feedback = retMsg;\n         Utility.logMessage(\"ERROR\", \"DeleteGroup::execute(): \" + retMsg + ge);\n      } catch (ChainedException ce) {\n         retMsg = \"Unable to delete group : \" + elemName;\n         sessionData.feedback = retMsg;\n         Utility.logMessage(\"ERROR\", \"DeleteGroup::execute(): \" + retMsg + \".\\n\" + ce);\n      } catch (Exception e) {\n         retMsg = \"Unable to delete group : \" + elemName;\n         sessionData.feedback = retMsg;\n         Utility.logMessage(\"ERROR\", \"DeleteGroup::execute(): \" + retMsg + \".\\n\" + e);\n      }\n      }\n      Utility.logMessage(\"DEBUG\", \"DeleteGroup::execute(): Finished\");\n   }","id":6012,"modified_method":"/**\n    * put your documentation comment here\n    * @throws Exception\n    * @param sessionData\n    */\n   public void execute (CGroupsManagerSessionData sessionData) throws Exception{\n      ChannelStaticData staticData = sessionData.staticData;\n      ChannelRuntimeData runtimeData= sessionData.runtimeData;\n\n      Utility.logMessage(\"DEBUG\", \"DeleteGroup::execute(): Start\");\n      Document model = getXmlDoc(sessionData);\n      String userID = getUserID(sessionData);\n      String theCommand = runtimeData.getParameter(\"grpCommand\");\n      String delId = getCommandArg(runtimeData);\n      Element delElem = GroupsManagerXML.getElementByTagNameAndId(model, GROUP_TAGNAME, delId);\n      Element pn = ((Element)delElem.getParentNode());\n      if (pn !=null){\n       sessionData.highlightedGroupID = pn.getAttribute(\"id\");\n      }\n      String delKey = delElem.getAttribute(\"key\");\n      String elemName = delElem.getAttribute(\"name\");\n      String retMsg;\n      Node parentNode;\n      Node deletedNode;\n      Utility.logMessage(\"DEBUG\", \"DeleteGroup::execute(): Group: \" + elemName + \"will be deleted\");\n      if (Utility.areEqual(delElem.getAttribute(\"searchResults\"), \"true\")){\n        // if it is search results, just delete the node and skip the rest\n        delElem.getParentNode().removeChild(delElem);\n      }\n      else{\n         IEntityGroup delGroup = GroupsManagerXML.retrieveGroup(delKey);\n         if (delGroup == null) {\n            retMsg = \"Unable to retrieve Group!\";\n            sessionData.feedback = retMsg;\n            return;\n         }\n         Utility.logMessage(\"DEBUG\", \"DeleteGroup::execute(): About to delete group: \"\n               + elemName);\n         // remove permissions associated with group\n         deletePermissions((IGroupMember)delGroup);\n         // delete the group\n         delGroup.delete();\n         Utility.logMessage(\"DEBUG\", \"DeleteGroup::execute(): About to delete xml nodes for group: \"\n               + elemName);\n         // remove all xml nodes for this group\n         Iterator deletedNodes = GroupsManagerXML.getNodesByTagNameAndKey(model, GROUP_TAGNAME,\n               delKey);\n         IEntityGroup parentEntGrp = null;\n         String hasMbrs = \"duh\";\n         while (deletedNodes.hasNext()) {\n            deletedNode = (Node)deletedNodes.next();\n            parentNode = deletedNode.getParentNode();\n            boolean parentIsInitialGroupContext = parentIsInitialGroupContext(((Element)parentNode).getAttribute(\"id\"));\n            if (parentIsInitialGroupContext) {\n               IInitialGroupContext igc = RDBMInitialGroupContextStore.singleton().find(userID, delKey);\n               RDBMInitialGroupContextStore.singleton().delete(igc);\n               hasMbrs = \"true\";\n            }\n            else {\n               String nodeKey = ((Element)parentNode).getAttribute(\"key\");\n               if (parentEntGrp == null || !parentEntGrp.getKey().equals(nodeKey)) {\n                  parentEntGrp = GroupsManagerXML.retrieveGroup(nodeKey);\n                  hasMbrs = String.valueOf(parentEntGrp.hasMembers());\n               }\n            }\n            parentNode.removeChild(deletedNode);\n            ((Element)parentNode).setAttribute(\"hasMembers\", hasMbrs);\n         }\n\n         /** Remove the permission elements in the xmlDoc */\n         Node principalNode = (Node)model.getDocumentElement().getElementsByTagName(\"principal\").item(0);\n         NodeList permElems = model.getElementsByTagName(\"permission\");\n         /** If we delete from the bottom up, the NodeList elements shift down\n          *  everytime we delete an element. Since the elements that we are looking\n          *  for are sequential and because we increment the counter at the end of\n          *  the loop, the element that we should process next slips down into the\n          *  slot that we just processed. We therefore end up deleting every other\n          *  element. The solution is to delete from the top down.\n          */\n         for (int i = permElems.getLength() - 1; i > -1; i--) {\n            Element permElem = (Element)permElems.item(i);\n            if (permElem.getAttribute(\"target\").equals(delKey)) {\n               principalNode.removeChild(permElem);\n            }\n         }\n         sessionData.mode=BROWSE_MODE;\n      }\n      Utility.logMessage(\"DEBUG\", \"DeleteGroup::execute(): Finished\");\n   }","commit_id":"96cda17d1df681a885e0f5383409673be6598fd6","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n    * This method processes the xml document looking for selected groupmembers.\n    * It then creates an instance of IGroupMember for each selected\n    * member and passes the collection back.\n    * @param gmCollection\n    * @param nList\n    * @exception AuthorizationException\n    * @exception ClassNotFoundException\n    */\n   public void addGroupMemberToCollection (Vector gmCollection, NodeList nList) throws org.jasig.portal.AuthorizationException,\n         ClassNotFoundException {\n      boolean addit;\n      for (int i = 0; i < nList.getLength(); i++) {\n         Element elem = (org.w3c.dom.Element)nList.item(i);\n         if (Utility.areEqual(elem.getAttribute(\"selected\"), \"true\")) {\n            addit = true;\n            Iterator gmItr = gmCollection.iterator();\n            while (gmItr.hasNext()) {\n               IGroupMember ggmm = (IGroupMember)gmItr.next();\n               if ((ggmm.getKey().equals(elem.getAttribute(\"key\")))\n                        && (ggmm.getType().equals(elem.getAttribute(\"type\")))){\n                       addit = false;\n                       break;\n               }\n            }\n            if (addit) {\n               IGroupMember gm = Utility.retrieveGroupMemberForKeyAndType(elem.getAttribute(\"key\"),elem.getAttribute(\"type\"));\n               gmCollection.add(gm);\n               Utility.logMessage(\"DEBUG\", \"DoneWithSelection::addGroupMemberToCollection(): \" +\n                     \"- adding group member\" + elem.getAttribute(\"key\"));\n            }\n         }\n      }\n   }","id":6013,"modified_method":"/**\n    * This method processes the xml document looking for selected groupmembers.\n    * It then creates an instance of IGroupMember for each selected\n    * member and passes the collection back.\n    * @param gmCollection\n    * @param nList\n    * @throws ChainedException\n    */\n   public void addGroupMemberToCollection (Vector gmCollection, NodeList nList)\n         throws ChainedException {\n      try{\n         boolean addit;\n         for (int i = 0; i < nList.getLength(); i++) {\n            Element elem = (org.w3c.dom.Element)nList.item(i);\n            if (Utility.areEqual(elem.getAttribute(\"selected\"), \"true\")) {\n               addit = true;\n               Iterator gmItr = gmCollection.iterator();\n               while (gmItr.hasNext()) {\n                  IGroupMember ggmm = (IGroupMember)gmItr.next();\n                  if ((ggmm.getKey().equals(elem.getAttribute(\"key\")))\n                           && (ggmm.getType().equals(elem.getAttribute(\"type\")))){\n                          addit = false;\n                          break;\n                  }\n               }\n               if (addit) {\n                  IGroupMember gm = Utility.retrieveGroupMemberForKeyAndType(elem.getAttribute(\"key\"),elem.getAttribute(\"type\"));\n                  gmCollection.add(gm);\n                  Utility.logMessage(\"DEBUG\", \"DoneWithSelection::addGroupMemberToCollection(): \" +\n                        \"- adding group member\" + elem.getAttribute(\"key\"));\n               }\n            }\n         }\n      }\n      catch (Exception e) {\n         String errMsg = \"DoneWithSelection::addGroupMemberToCollection(): \";\n         Utility.logMessage(\"ERROR\", errMsg);\n         throw new ChainedException(errMsg, e);\n      }\n   }","commit_id":"96cda17d1df681a885e0f5383409673be6598fd6","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n    * This section adds the selected members to an IInitialContextGroup.\n    * @param gmCollection\n    * @param sessionData\n    * @param parentElem\n    * @param model\n    */\n   public void addChildrenToContext (Vector gmCollection, CGroupsManagerSessionData sessionData,\n         Element parentElem, Document model) {\n          ChannelRuntimeData runtimeData = sessionData.runtimeData;\n      // Considerations:\n      // The parent element is myGroups and there is only one.\n      String childName = \"\";\n      IGroupMember childGm = null;\n      String userID = getUserID(sessionData);\n      String ownerType = \"p\";\n      int ordinal = 1;\n      boolean expanded = false;\n      /** @todo should put this in the RDBM add method */\n      java.sql.Timestamp dateCreated = new java.sql.Timestamp(System.currentTimeMillis());\n      Element childElem;\n      Iterator gmItr = gmCollection.iterator();\n      while (gmItr.hasNext()) {\n         childGm = (IGroupMember) gmItr.next();\n         String type = \"\";\n         try{\n            childName = GroupsManagerXML.getEntityName(childGm.getType(), childGm.getKey());\n            type = childGm.getType().getName();\n         }\n         catch (Exception e){\n            Utility.logMessage(\"ERROR\", \"DoneWithSelection::execute: erorr\"+e);\n         }\n         String groupID = childGm.getKey();\n\n         // can only add groups as initial group contexts\n         if (type.equals(GROUP_CLASSNAME)) {\n            Utility.logMessage(\"DEBUG\", \"DoneWithSelection::addChildrenToContext: About to add child\");\n            try {\n               // add to users initial contexts\n               IInitialGroupContext igc = Utility.createInitialGroupContext(userID, ownerType,\n                     groupID, ordinal, expanded, dateCreated);\n               // save to persistent source\n               igc.update();\n\n               // add child to user's igc node\n               IEntityGroup entGrp = GroupsManagerXML.retrieveGroup(groupID);\n               childElem = GroupsManagerXML.getGroupMemberXml((IGroupMember)entGrp, false,\n                     null, model);\n               parentElem.appendChild((Node)childElem);\n               parentElem.setAttribute(\"hasMembers\", \"true\");\n            } catch (Exception e) {\n               sessionData.feedback = sessionData.feedback + \"\\n Unable to add : \"\n                     + childName;\n            }\n         }\n      }\n   }","id":6014,"modified_method":"/**\n    * This section adds the selected members to an IInitialContextGroup.\n    * @throws ChainedException\n    * @param gmCollection\n    * @param sessionData\n    * @param parentElem\n    * @param model\n    */\n   public void addChildrenToContext (Vector gmCollection, CGroupsManagerSessionData sessionData,\n         Element parentElem, Document model) throws ChainedException {\n          ChannelRuntimeData runtimeData = sessionData.runtimeData;\n      // Considerations:\n      // The parent element is myGroups and there is only one.\n      String childName = \"\";\n      IGroupMember childGm = null;\n      String userID = getUserID(sessionData);\n      String ownerType = \"p\";\n      int ordinal = 1;\n      boolean expanded = false;\n      try{\n         /** @todo should put this in the RDBM add method */\n         java.sql.Timestamp dateCreated = new java.sql.Timestamp(System.currentTimeMillis());\n         Element childElem;\n         Iterator gmItr = gmCollection.iterator();\n         while (gmItr.hasNext()) {\n            childGm = (IGroupMember) gmItr.next();\n            String type = \"\";\n            childName = GroupsManagerXML.getEntityName(childGm.getType(), childGm.getKey());\n            type = childGm.getType().getName();\n            String groupID = childGm.getKey();\n\n            // can only add groups as initial group contexts\n            if (type.equals(GROUP_CLASSNAME)) {\n               Utility.logMessage(\"DEBUG\", \"DoneWithSelection::addChildrenToContext: About to add child\");\n               // add to users initial contexts\n               IInitialGroupContext igc = Utility.createInitialGroupContext(userID, ownerType,\n                     groupID, ordinal, expanded, dateCreated);\n               // save to persistent source\n               igc.update();\n\n               // add child to user's igc node\n               IEntityGroup entGrp = GroupsManagerXML.retrieveGroup(groupID);\n               childElem = GroupsManagerXML.getGroupMemberXml((IGroupMember)entGrp, false,\n                     null, model);\n               parentElem.appendChild((Node)childElem);\n               parentElem.setAttribute(\"hasMembers\", \"true\");\n            }\n         }\n      } catch (Exception e) {\n         String errMsg = \"DoneWithSelection::addChildrenToContext(): Unable to add child to context\";\n         Utility.logMessage(\"ERROR\", errMsg);\n         throw new ChainedException(errMsg, e);\n      }\n   }","commit_id":"96cda17d1df681a885e0f5383409673be6598fd6","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n    * This section adds the selected members to an IEntityGroup.\n    * @param gmCollection\n    * @param sessionData\n    * @param parentElem\n    * @param model\n    */\n   public void addChildrenToGroup (Vector gmCollection, CGroupsManagerSessionData sessionData,\n      Element parentElem, Document model) {\n      ChannelRuntimeData runtimeData = sessionData.runtimeData;\n      Element parent;\n      IEntityGroup parentGroup = null;\n      IGroupMember childGm = null;\n      Element childElem;\n      String parentName;\n      String childName = \"\";\n      parentGroup = GroupsManagerXML.retrieveGroup(parentElem.getAttribute(\"key\"));\n      Iterator gmItr = gmCollection.iterator();\n      while (gmItr.hasNext()) {\n         childGm = (IGroupMember) gmItr.next();\n         try {\n            childName = GroupsManagerXML.getEntityName(childGm.getType(), childGm.getKey());\n         }\n         catch (Exception e){\n            Utility.logMessage(\"ERROR\", \"DoneWithSelection::execute: erorr\"+e);\n         }\n         parentName = parentGroup.getName();\n         Utility.logMessage(\"DEBUG\", \"DoneWithSelection::execute: About to add child\");\n         try {\n            // add to parent group\n            parentGroup.addMember(childGm);\n            // update parent group\n            parentGroup.updateMembers();\n            // get parent element(s) and add element for child group member\n            Iterator parentNodes = GroupsManagerXML.getNodesByTagNameAndKey(model, GROUP_TAGNAME,\n                  parentElem.getAttribute(\"key\"));\n            while (parentNodes.hasNext()) {\n               parent = (Element)parentNodes.next();\n\n               childElem = GroupsManagerXML.getGroupMemberXml(childGm, false, null, model);\n               parent.appendChild((Node)childElem);\n               parent.setAttribute(\"hasMembers\", \"true\");\n            }\n         } catch (GroupsException ge) {\n            // We let groups catch any error for the adds (ie. group member is already in the parent group).\n            // Processing subsequent adds is allowed to continue.\n            sessionData.feedback = sessionData.feedback + \"\\n Unable to add : \"\n                  + childName + \" to: \" + parentName;\n         }\n      }\n   }","id":6015,"modified_method":"/**\n    * This section adds the selected members to an IEntityGroup.\n    * @throws ChainedException\n    * @param gmCollection\n    * @param sessionData\n    * @param parentElem\n    * @param model\n    */\n   public void addChildrenToGroup (Vector gmCollection, CGroupsManagerSessionData sessionData,\n      Element parentElem, Document model) throws ChainedException {\n      ChannelRuntimeData runtimeData = sessionData.runtimeData;\n      Element parent;\n      IEntityGroup parentGroup = null;\n      IGroupMember childGm = null;\n      Element childElem;\n      String parentName = parentElem.getAttribute(\"key\");\n      String childName = \"\";\n      try{\n         parentGroup = GroupsManagerXML.retrieveGroup(parentElem.getAttribute(\"key\"));\n         Iterator gmItr = gmCollection.iterator();\n         while (gmItr.hasNext()) {\n            childGm = (IGroupMember) gmItr.next();\n            childName = GroupsManagerXML.getEntityName(childGm.getType(), childGm.getKey());\n            parentName = parentGroup.getName();\n            Utility.logMessage(\"DEBUG\", \"DoneWithSelection::execute: About to add child\");\n            // add to parent group\n            parentGroup.addMember(childGm);\n            // update parent group\n            parentGroup.updateMembers();\n            // get parent element(s) and add element for child group member\n            Iterator parentNodes = GroupsManagerXML.getNodesByTagNameAndKey(model, GROUP_TAGNAME,\n                  parentElem.getAttribute(\"key\"));\n            while (parentNodes.hasNext()) {\n               parent = (Element)parentNodes.next();\n\n               childElem = GroupsManagerXML.getGroupMemberXml(childGm, false, null, model);\n               parent.appendChild((Node)childElem);\n               parent.setAttribute(\"hasMembers\", \"true\");\n            }\n         }\n      } catch (Exception e) {\n         String errMsg = \"DoneWithSelection::addChildrenToGroup(): Unable to add : \" + childName + \" to: \" + parentName;\n         Utility.logMessage(\"ERROR\", errMsg);\n         throw new ChainedException(errMsg, e);\n      }\n   }","commit_id":"96cda17d1df681a885e0f5383409673be6598fd6","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n    * put your documentation comment here\n    * @param sessionData\n    */\n   public void execute (CGroupsManagerSessionData sessionData) {\n      ChannelStaticData staticData = sessionData.staticData;\n      ChannelRuntimeData runtimeData= sessionData.runtimeData;\n\n      Utility.logMessage(\"DEBUG\", \"DoneWithSelection::execute(): Start\");\n      String parentId = null;\n      boolean hasParentId = hasParentId(staticData);\n      try {\n         Utility.logMessage(\"DEBUG\", \"DoneWithSelection::execute(): Parent ID is set: \"\n               + hasParentId);\n         IGroupMember[] princResults = null;\n         Document model = getXmlDoc(sessionData);\n         Element rootElem = model.getDocumentElement();\n         NodeList nGroupList = rootElem.getElementsByTagName(GROUP_TAGNAME);\n         NodeList nEntityList = rootElem.getElementsByTagName(ENTITY_TAGNAME);\n         Vector gmCollection = new Vector();\n         Element parentElem = null;\n         String cmdResponse;\n         try {\n            Utility.logMessage(\"DEBUG\", \"DoneWithSelection::execute(): Starting group process\");\n            addGroupMemberToCollection(gmCollection, nGroupList);\n            Utility.logMessage(\"DEBUG\", \"DoneWithSelection::execute(): Starting entity process\");\n            addGroupMemberToCollection(gmCollection, nEntityList);\n            // null pointer exception\n         } catch (org.jasig.portal.AuthorizationException ae) {\n            Utility.logMessage(\"ERROR\", \"DoneWithSelection::execute():AuthorizationException /n \"\n                  + ae);\n         } catch (ClassNotFoundException cnfe) {\n            Utility.logMessage(\"ERROR\", \"DoneWithSelection::execute():ClassNotFoundException /n \"\n                  + cnfe);\n         }\n         // check if selections were made\n         if (gmCollection.size() <1) {\n            sessionData.feedback = sessionData.feedback + \"\\n No groups or people were selected! \";\n            return;\n         }\n\n         /** Presence of parentID means the process is not in servant mode. That is,\n          * the master channel is the Groups Manager channel and AddMembers had\n          * been selected\n          */\n         if (hasParentId) {\n            parentId = getParentId(staticData);\n            Utility.logMessage(\"DEBUG\", \"DoneWithSelection::execute(): Parent ID is set to: \"\n                  + parentId);\n            parentElem = GroupsManagerXML.getElementByTagNameAndId(model, GROUP_TAGNAME, parentId);\n            if (parentElem == null) {\n               Utility.logMessage(\"ERROR\", \"DoneWithSelection::execute: Error parent element not found\");\n               return;\n            }\n            /** @todo refactor: */\n            if (parentIsInitialGroupContext(staticData)) {\n               addChildrenToContext(gmCollection, sessionData, parentElem, model);\n            }\n            else {\n               addChildrenToGroup(gmCollection, sessionData, parentElem, model);\n            }\n            clearSelected(sessionData);\n            sessionData.mode=EDIT_MODE;\n            sessionData.highlightedGroupID = parentId;\n            sessionData.rootViewGroupID=\"0\";\n            staticData.remove(\"groupParentId\");\n         }\n         else {\n            princResults = (IGroupMember[])gmCollection.toArray(new IGroupMember[0]);\n            if (princResults.length > 0) {\n               staticData.put(\"princResults\", princResults);\n               staticData.setParameter(\"groupManagerFinished\", \"true\");\n            }\n         }\n         // Parent was locked so no other thread or process could have changed it, but\n         // child members could have changed.\n         GroupsManagerXML.refreshAllNodesRecursivelyIfRequired(model, parentElem);\n      } catch (Exception e) {\n         Utility.logMessage(\"ERROR\", \"DoneWithSelection Error: \" + sessionData.feedback\n               + \"/n\" + e);\n      }\n   }","id":6016,"modified_method":"/**\n    * put your documentation comment here\n    * @throws Exception\n    * @param sessionData\n    */\n   public void execute (CGroupsManagerSessionData sessionData) throws Exception{\n      ChannelStaticData staticData = sessionData.staticData;\n      ChannelRuntimeData runtimeData= sessionData.runtimeData;\n\n      Utility.logMessage(\"DEBUG\", \"DoneWithSelection::execute(): Start\");\n      String parentId = null;\n      boolean hasParentId = hasParentId(staticData);\n      Utility.logMessage(\"DEBUG\", \"DoneWithSelection::execute(): Parent ID is set: \"\n            + hasParentId);\n      IGroupMember[] princResults = null;\n      Document model = getXmlDoc(sessionData);\n      Element rootElem = model.getDocumentElement();\n      NodeList nGroupList = rootElem.getElementsByTagName(GROUP_TAGNAME);\n      NodeList nEntityList = rootElem.getElementsByTagName(ENTITY_TAGNAME);\n      Vector gmCollection = new Vector();\n      Element parentElem = null;\n      Utility.logMessage(\"DEBUG\", \"DoneWithSelection::execute(): Starting group process\");\n      addGroupMemberToCollection(gmCollection, nGroupList);\n      Utility.logMessage(\"DEBUG\", \"DoneWithSelection::execute(): Starting entity process\");\n      addGroupMemberToCollection(gmCollection, nEntityList);\n      // check if selections were made\n      if (gmCollection.size() <1) {\n         sessionData.feedback = sessionData.feedback + \"\\n No groups or people were selected! \";\n         return;\n      }\n\n      /** Presence of parentID means the process is not in servant mode. That is,\n       * the master channel is the Groups Manager channel and AddMembers had\n       * been selected\n       */\n      if (hasParentId) {\n         parentId = getParentId(staticData);\n         Utility.logMessage(\"DEBUG\", \"DoneWithSelection::execute(): Parent ID is set to: \"\n               + parentId);\n         parentElem = GroupsManagerXML.getElementByTagNameAndId(model, GROUP_TAGNAME, parentId);\n         if (parentElem == null) {\n            Utility.logMessage(\"ERROR\", \"DoneWithSelection::execute: Error parent element not found\");\n            return;\n         }\n         /** @todo refactor: */\n         if (parentIsInitialGroupContext(staticData)) {\n            addChildrenToContext(gmCollection, sessionData, parentElem, model);\n         }\n         else {\n            addChildrenToGroup(gmCollection, sessionData, parentElem, model);\n         }\n         clearSelected(sessionData);\n         sessionData.mode=EDIT_MODE;\n         sessionData.highlightedGroupID = parentId;\n         sessionData.rootViewGroupID=\"0\";\n         staticData.remove(\"groupParentId\");\n      }\n      else {\n         princResults = (IGroupMember[])gmCollection.toArray(new IGroupMember[0]);\n         if (princResults.length > 0) {\n            staticData.put(\"princResults\", princResults);\n            staticData.setParameter(\"groupManagerFinished\", \"true\");\n         }\n      }\n      // Parent was locked so no other thread or process could have changed it, but\n      // child members could have changed.\n      GroupsManagerXML.refreshAllNodesRecursivelyIfRequired(model, parentElem);\n   }","commit_id":"96cda17d1df681a885e0f5383409673be6598fd6","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n    * put your documentation comment here\n    * @param sessionData\n    */\n   public void execute (CGroupsManagerSessionData sessionData) {\n      ChannelStaticData staticData = sessionData.staticData;\n      ChannelRuntimeData runtimeData= sessionData.runtimeData;\n\n      Document model = getXmlDoc(sessionData);\n      Utility.logMessage(\"DEBUG\", \"EditGroup::execute(): Start\");\n      String parentElemId = getCommandArg(runtimeData);\n      // if not IPerson group, then set view root to root for requested type\n      try{\n         String userID = getUserID(sessionData);\n         String userName = GroupsManagerXML.getEntityName(ENTITY_CLASSNAME, userID);\n         String lockKey = userID + \"::\" + userName;\n         Element parentElem = GroupsManagerXML.getElementById(model, parentElemId);\n         String parentKey = parentElem.getAttribute(\"key\");\n         ILockableEntityGroup lockedGroup = GroupService.findLockableGroup(parentKey, lockKey);\n         if (lockedGroup != null){\n            GroupsManagerXML.refreshAllNodesRecursivelyIfRequired(model, parentElem);\n            // store in sessionData\n            sessionData.lockedGroup=lockedGroup;\n            sessionData.mode = EDIT_MODE;\n            staticData.setParameter(\"groupParentId\", parentElemId);\n         }\n         else{\n            // need to display group name\n            String msg = \"Unable to aquire lock for group: \" + parentKey;\n            runtimeData.setParameter(\"cmdResponse\", msg);\n         }\n      }\n      catch(Exception e){\n        LogService.instance().log(LogService.ERROR,e);\n      }\n      Utility.logMessage(\"DEBUG\", \"EditGroup::execute(): Uid of parent element = \" +\n            parentElemId);\n   }","id":6017,"modified_method":"/**\n    * put your documentation comment here\n    * @throws Exception\n    * @param sessionData\n    */\n   public void execute (CGroupsManagerSessionData sessionData) throws Exception{\n      ChannelStaticData staticData = sessionData.staticData;\n      ChannelRuntimeData runtimeData= sessionData.runtimeData;\n\n      Document model = getXmlDoc(sessionData);\n      Utility.logMessage(\"DEBUG\", \"EditGroup::execute(): Start\");\n      String parentElemId = getCommandArg(runtimeData);\n      // if not IPerson group, then set view root to root for requested type\n\n      String userID = getUserID(sessionData);\n      String userName = GroupsManagerXML.getEntityName(ENTITY_CLASSNAME, userID);\n      String lockKey = userID + \"::\" + userName;\n      Element parentElem = GroupsManagerXML.getElementById(model, parentElemId);\n      String parentKey = parentElem.getAttribute(\"key\");\n      ILockableEntityGroup lockedGroup = GroupService.findLockableGroup(parentKey, lockKey);\n      // if lockedGroup is null, an exception has probably already been thrown\n      if (lockedGroup != null){\n         GroupsManagerXML.refreshAllNodesRecursivelyIfRequired(model, parentElem);\n         // store in sessionData\n         sessionData.lockedGroup=lockedGroup;\n         sessionData.mode = EDIT_MODE;\n         staticData.setParameter(\"groupParentId\", parentElemId);\n      }\n\n      Utility.logMessage(\"DEBUG\", \"EditGroup::execute(): Uid of parent element = \" +\n            parentElemId);\n   }","commit_id":"96cda17d1df681a885e0f5383409673be6598fd6","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n    * put your documentation comment here\n    * @param sessionData\n    */\n   public void execute (CGroupsManagerSessionData sessionData) {\n      ChannelStaticData staticData = sessionData.staticData;\n      ChannelRuntimeData runtimeData= sessionData.runtimeData;\n\n      Utility.logMessage(\"DEBUG\", \"ExpandGroup::execute(): Start\");\n      Document model = getXmlDoc(sessionData);\n      // Due to the networked relationship of groups, the next method has to return a list of elements.\n      String elemUid = getCommandArg(runtimeData);\n      Utility.logMessage(\"DEBUG\", \"ExpandGroup::execute(): Uid of expanded element = \"\n            + elemUid);\n      Element expandedElem = GroupsManagerXML.getElementByTagNameAndId(model, GROUP_TAGNAME, elemUid);\n      String rootOwner;\n      if (expandedElem != null) {\n        GroupsManagerXML.refreshAllNodesRecursivelyIfRequired(model, expandedElem);\n\n        if (expandedElem.getAttribute(\"searchResults\").equals(\"true\")){\n          expandedElem.setAttribute(\"expanded\",\"true\");\n        }\n        else{\n          GroupsManagerXML.expandGroupElementXML(expandedElem,model);\n        }\n      }\n   }","id":6018,"modified_method":"/**\n    * put your documentation comment here\n    * @throws Exception\n    * @param sessionData\n    */\n   public void execute (CGroupsManagerSessionData sessionData) throws Exception{\n      ChannelStaticData staticData = sessionData.staticData;\n      ChannelRuntimeData runtimeData= sessionData.runtimeData;\n\n      Utility.logMessage(\"DEBUG\", \"ExpandGroup::execute(): Start\");\n      Document model = getXmlDoc(sessionData);\n      // Due to the networked relationship of groups, the next method has to return a list of elements.\n      String elemUid = getCommandArg(runtimeData);\n      Utility.logMessage(\"DEBUG\", \"ExpandGroup::execute(): Uid of expanded element = \"\n            + elemUid);\n      Element expandedElem = GroupsManagerXML.getElementByTagNameAndId(model, GROUP_TAGNAME, elemUid);\n      String rootOwner;\n      if (expandedElem != null) {\n        GroupsManagerXML.refreshAllNodesRecursivelyIfRequired(model, expandedElem);\n\n        if (expandedElem.getAttribute(\"searchResults\").equals(\"true\")){\n          expandedElem.setAttribute(\"expanded\",\"true\");\n        }\n        else{\n          GroupsManagerXML.expandGroupElementXML(expandedElem,model);\n        }\n      }\n   }","commit_id":"96cda17d1df681a885e0f5383409673be6598fd6","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n    * Returns the IGroupMember represented by an Element\n    * @param aDoc\n    * @param id\n    * @return IGroupMember\n    */\n   public static IGroupMember retrieveGroupMemberForElementId (Document aDoc, String id) {\n      Element gmElem = getElementById(aDoc, id);\n      IGroupMember gm;\n      if (gmElem == null || !isPersistentGroup(gmElem)) {\n         Utility.logMessage(\"INFO\", \"GroupsManagerXML::retrieveGroupMemberForElementId(): Unable to retrieve the element with id = \"\n               + id);\n         return  null;\n      }\n      else {\n         Utility.logMessage(\"DEBUG\", \"GroupsManagerXML::retrieveGroupMemberForElementId(): The child type = \"\n               + gmElem.getTagName());\n      }\n      String gmKey = gmElem.getAttribute(\"key\");\n      Utility.logMessage(\"DEBUG\", \"GroupsManagerXML::retrieveGroupMemberForElementId(): About to retrieve group member (\"\n            + gmElem.getTagName() + \" for key: \" + gmKey);\n      if (gmElem.getTagName().equals(GROUP_TAGNAME)) {\n         gm = (IGroupMember)GroupsManagerXML.retrieveGroup(gmKey);\n      }\n      else {\n         gm = (IGroupMember)GroupsManagerXML.retrieveEntity(gmKey,gmElem.getAttribute(\"type\"));\n      }\n      return  gm;\n   }","id":6019,"modified_method":"/**\n    * Returns the IGroupMember represented by an Element\n    * @param aDoc\n    * @param id\n    * @return IGroupMember\n    */\n   public static IGroupMember retrieveGroupMemberForElementId (Document aDoc, String id) {\n      Element gmElem = getElementById(aDoc, id);\n      IGroupMember gm;\n\n      // A null is returned if the element is null OR if the element is for a group that\n      // is non-persistent\n      if (gmElem == null || (Utility.areEqual(gmElem.getNodeName(), GROUP_TAGNAME) && !isPersistentGroup(gmElem))) {\n         Utility.logMessage(\"INFO\", \"GroupsManagerXML::retrieveGroupMemberForElementId(): Unable to retrieve the element with id = \"\n               + id);\n         return  null;\n      }\n      else {\n         Utility.logMessage(\"DEBUG\", \"GroupsManagerXML::retrieveGroupMemberForElementId(): The child type = \"\n               + gmElem.getTagName());\n      }\n      String gmKey = gmElem.getAttribute(\"key\");\n      Utility.logMessage(\"DEBUG\", \"GroupsManagerXML::retrieveGroupMemberForElementId(): About to retrieve group member (\"\n            + gmElem.getTagName() + \" for key: \" + gmKey);\n      if (gmElem.getTagName().equals(GROUP_TAGNAME)) {\n         gm = (IGroupMember)GroupsManagerXML.retrieveGroup(gmKey);\n      }\n      else {\n         gm = (IGroupMember)GroupsManagerXML.retrieveEntity(gmKey,gmElem.getAttribute(\"type\"));\n      }\n      return  gm;\n   }","commit_id":"96cda17d1df681a885e0f5383409673be6598fd6","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n    * Group elements that hold search results are non-persistent and should be treated differently.\n    * For example, they do not have a \"key\" attribute so code that attempts to retreive\n    * a GroupMember should not be attempted.\n    * @param anElem Element\n    * @return boolean\n    */\n    public static boolean isPersistentGroup(Element anElem){\n       boolean rval = true;\n       if (!Utility.areEqual(anElem.getNodeName(), GROUP_TAGNAME)\n               || Utility.areEqual(anElem.getAttribute(\"searchResults\"), \"true\")) {\n          rval= false;\n       }\n       return rval;\n   }","id":6020,"modified_method":"/**\n    * Group elements that hold search results are non-persistent and should be treated differently.\n    * For example, they do not have a \"key\" attribute so code that attempts to retreive\n    * a GroupMember should not be attempted.\n    * @param anElem Element\n    * @return boolean\n    */\n   public static boolean isPersistentGroup(Element anElem){\n      boolean rval = true;\n      if (anElem == null){\n         /** @todo this should be an error */\n         Utility.logMessage(\"INFO\", \"GroupsManagerXML::isPersistentGroup(): anElem is null\");\n      }\n      if (!Utility.areEqual(anElem.getNodeName(), GROUP_TAGNAME)\n              || Utility.areEqual(anElem.getAttribute(\"searchResults\"), \"true\")) {\n         rval= false;\n      }\n      return rval;\n   }","commit_id":"96cda17d1df681a885e0f5383409673be6598fd6","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void execute (CGroupsManagerSessionData sessionData) {\n    Document model = getXmlDoc(sessionData);\n    String id = this.getCommandArg(sessionData.runtimeData);\n    Element e = GroupsManagerXML.getElementById(model,id);\n    if (e != null){\n      NodeList nl = e.getChildNodes();\n      for(int i=(nl.getLength()-1); i>=0;i--){\n        if (nl.item(i).getNodeName().equals(\"properties\")){\n          e.removeChild(nl.item(i));\n        }\n      }\n    }\n  }","id":6021,"modified_method":"/**\n    * put your documentation comment here\n    * @throws Exception\n    * @param sessionData\n    */\n   public void execute (CGroupsManagerSessionData sessionData) throws Exception{\n      Document model = getXmlDoc(sessionData);\n      String id = this.getCommandArg(sessionData.runtimeData);\n      Element e = GroupsManagerXML.getElementById(model,id);\n      if (e != null){\n         NodeList nl = e.getChildNodes();\n         for(int i=(nl.getLength()-1); i>=0;i--){\n            if (nl.item(i).getNodeName().equals(\"properties\")){\n               e.removeChild(nl.item(i));\n            }\n         }\n      }\n   }","commit_id":"96cda17d1df681a885e0f5383409673be6598fd6","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void execute(CGroupsManagerSessionData sessionData) {\n    Document model = getXmlDoc(sessionData);\n    sessionData.highlightedGroupID = getCommandArg(sessionData.runtimeData);\n    sessionData.currentPage = 1;\n    GroupsManagerCommandFactory.get(\"Expand\").execute(sessionData);\n    // expand parent\n    try{\n      Element expandedElem = GroupsManagerXML.getElementByTagNameAndId(model, GROUP_TAGNAME, getCommandArg(sessionData.runtimeData));\n      if (expandedElem != null) {\n        GroupsManagerXML.expandGroupElementXML((Element) expandedElem.getParentNode(),model);\n      }\n    }\n    catch(Exception e){}\n    // unlock and discard any other group that may be held in a locked state\n    if((sessionData.lockedGroup!=null) && (!sessionData.lockedGroup.getEntityIdentifier().getKey().equals(sessionData.highlightedGroupID)) && (!sessionData.mode.equals(\"select\"))){\n      try{\n        sessionData.lockedGroup.getLock().release();\n      }\n      catch(Exception e){}\n      sessionData.lockedGroup = null;\n      sessionData.mode = BROWSE_MODE;\n    }\n  }","id":6022,"modified_method":"/**\n    * put your documentation comment here\n    * @throws Exception\n    * @param sessionData\n    */\n   public void execute(CGroupsManagerSessionData sessionData) throws Exception{\n      Document model = getXmlDoc(sessionData);\n      sessionData.highlightedGroupID = getCommandArg(sessionData.runtimeData);\n      sessionData.currentPage = 1;\n      GroupsManagerCommandFactory.get(\"Expand\").execute(sessionData);\n      // expand parent\n      Element expandedElem = GroupsManagerXML.getElementByTagNameAndId(model, GROUP_TAGNAME, getCommandArg(sessionData.runtimeData));\n      if (expandedElem != null) {\n        GroupsManagerXML.expandGroupElementXML((Element) expandedElem.getParentNode(),model);\n      }\n      // unlock and discard any other group that may be held in a locked state\n      if((sessionData.lockedGroup!=null) && (!sessionData.lockedGroup.getEntityIdentifier().getKey().equals(sessionData.highlightedGroupID)) && (!sessionData.mode.equals(\"select\"))){\n         sessionData.lockedGroup.getLock().release();\n         sessionData.lockedGroup = null;\n         sessionData.mode = BROWSE_MODE;\n      }\n   }","commit_id":"96cda17d1df681a885e0f5383409673be6598fd6","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n    * This section removes the selected member from an IEntityGroup.\n    * @param parentGroup\n    * @param childGm\n    * @exception ChainedException\n    */\n   public void removeChildFromGroup (Object parentGroup, IGroupMember childGm) throws ChainedException {\n      Utility.logMessage(\"DEBUG\", \"RemoveMember::removeChildrenFromGroup(): about to remove child\");\n      if (parentGroup != null && childGm != null) {\n         // parentEntGrp can be an EntityGroup or an InitialGroupContext\n         // SHOULD WRAPPER HANDLE THIS\n         try {\n            ((IEntityGroup)parentGroup).removeMember(childGm);\n            ((IEntityGroup)parentGroup).updateMembers();\n         } catch (GroupsException ge) {\n            String aMsg = \"Unable to remove child from parent/n\" + ge;\n            Utility.logMessage(\"ERROR\", aMsg);\n            throw  new ChainedException(aMsg, ge);\n         }\n      }\n      else {\n         throw  new ChainedException(\"Parent and/or child group members were not found\");\n      }\n   }","id":6023,"modified_method":"/**\n    * This section removes the selected member from an IEntityGroup.\n    * @param parentGroup\n    * @param childGm\n    * @exception ChainedException\n    */\n   public void removeChildFromGroup (Object parentGroup, IGroupMember childGm) throws ChainedException {\n      Utility.logMessage(\"DEBUG\", \"RemoveMember::removeChildrenFromGroup(): about to remove child\");\n      if (parentGroup != null && childGm != null) {\n         // parentEntGrp can be an EntityGroup or an InitialGroupContext\n         // SHOULD WRAPPER HANDLE THIS\n         try {\n            ((IEntityGroup)parentGroup).removeMember(childGm);\n            ((IEntityGroup)parentGroup).updateMembers();\n         } catch (GroupsException ge) {\n            String aMsg = \"Unable to remove child from parent/n\" + ge;\n            Utility.logMessage(\"ERROR\", aMsg);\n            throw  new ChainedException(aMsg, ge);\n         }\n      }\n      else {\n         String suspect = (parentGroup==null ? \"Parent\" : \"Child\");\n         throw  new ChainedException(suspect + \" group member was not found\");\n      }\n   }","commit_id":"96cda17d1df681a885e0f5383409673be6598fd6","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n    * The execute() method is the main method for the RemoveMember command.\n    * @param sessionData\n    */\n   public void execute (CGroupsManagerSessionData sessionData) {\n      ChannelStaticData staticData = sessionData.staticData;\n      ChannelRuntimeData runtimeData= sessionData.runtimeData;\n\n     Utility.logMessage(\"DEBUG\", \"RemoveMember::execute(): Start\");\n      Document model = getXmlDoc(sessionData);\n      String theCommand = getCommand(runtimeData);\n      String cmdIds = getCommandArg(runtimeData);\n      Object parentGroup = null;\n      IGroupMember childGm = null;\n      String hasMbrs = \"duh\";\n      String userID = getUserID(sessionData);\n      Utility.logMessage(\"DEBUG\", \"RemoveMember::execute(): About to get parent and child keys\");\n      String parentID = Utility.parseStringDelimitedBy(\"parent.\", cmdIds, \"|\");\n      String childID = Utility.parseStringDelimitedBy(\"child.\", cmdIds, \"|\");\n      Utility.logMessage(\"DEBUG\", \"RemoveMember::execute(): Uid of parent element = \"\n            + parentID + \" child element = \" + childID);\n      try {\n         Element parentElem = GroupsManagerXML.getElementByTagNameAndId(model, GROUP_TAGNAME,\n               parentID);\n         if (parentElem == null) {\n            Utility.logMessage(\"ERROR\", \"RemoveMember::execute(): Unable to retrieve parent element!\");\n            return;\n         }\n         Utility.logMessage(\"DEBUG\", \"RemoveMember::execute(): About to get child element = \"\n               + childID);\n         Element childElem = GroupsManagerXML.getElementById(model, childID);\n         if (childElem == null) {\n            Utility.logMessage(\"ERROR\", \"RemoveMember::execute(): Unable to retrieve Child element!\");\n            return;\n         }\n         // The child will always be an IGroupMember\n         childGm = GroupsManagerXML.retrieveGroupMemberForElementId(model, childID);\n         // The parent could be an IGroupMember or an IInitialGroupContext.\n         if (parentIsInitialGroupContext(parentID)) {\n            // Put method in GroupsManagerXML and change render method to use it\n            IInitialGroupContext igc = RDBMInitialGroupContextStore.singleton().find(userID,\n                  childElem.getAttribute(\"key\"));\n            RDBMInitialGroupContextStore.singleton().delete(igc);\n            hasMbrs = \"true\";\n         }\n         else {\n            // check for null\n            parentGroup = (Object)GroupsManagerXML.retrieveGroupMemberForElementId(model, parentID);\n            removeChildFromGroup(parentGroup, childGm);\n            hasMbrs = String.valueOf(((IEntityGroup)parentGroup).hasMembers());\n            Utility.logMessage(\"DEBUG\", \"RemoveMember::execute(): Got the parent group \");\n         }\n         Utility.logMessage(\"DEBUG\", \"RemoveMember::execute(): about to remove child elements\");\n         Iterator parentNodes = GroupsManagerXML.getNodesByTagNameAndKey(model, GROUP_TAGNAME,\n               parentElem.getAttribute(\"key\"));\n         Node parentNode;\n         NodeList childNodes;\n         Node childNode;\n         while (parentNodes.hasNext()) {\n            parentNode = (Node)parentNodes.next();\n            childNodes = parentNode.getChildNodes();\n            for (int i = 0; i < childNodes.getLength(); i++) {\n               childNode = (org.w3c.dom.Node)childNodes.item(i);\n               if (((Element)childNode).getAttribute(\"key\").equals(childElem.getAttribute(\"key\"))) {\n                  parentNode.removeChild(childNode);\n                  ((Element)parentNode).setAttribute(\"hasMembers\", hasMbrs);\n               }\n            }\n         }\n      } catch (Exception ge) {\n         // We let groups catch any error for the adds (ie. group member is already in the parent group).\n         // Processing subsequent adds is allowed to continue.\n         sessionData.feedback = sessionData.feedback + \"\\n Unable to remove : child\";\n      }\n      Utility.logMessage(\"DEBUG\", \"RemoveMember::execute(): Completed\");\n   }","id":6024,"modified_method":"/**\n    * The execute() method is the main method for the RemoveMember command.\n    * @throws Exception\n    * @param sessionData\n    */\n   public void execute (CGroupsManagerSessionData sessionData) throws Exception {\n      ChannelStaticData staticData = sessionData.staticData;\n      ChannelRuntimeData runtimeData = sessionData.runtimeData;\n      Utility.logMessage(\"DEBUG\", \"RemoveMember::execute(): Start\");\n      Document model = getXmlDoc(sessionData);\n      String theCommand = getCommand(runtimeData);\n      String cmdIds = getCommandArg(runtimeData);\n      Object parentGroup = null;\n      IGroupMember childGm = null;\n      String hasMbrs = \"duh\";\n      String userID = getUserID(sessionData);\n      Utility.logMessage(\"DEBUG\", \"RemoveMember::execute(): About to get parent and child keys\");\n      String parentID = Utility.parseStringDelimitedBy(\"parent.\", cmdIds, \"|\");\n      String childID = Utility.parseStringDelimitedBy(\"child.\", cmdIds, \"|\");\n      Utility.logMessage(\"DEBUG\", \"RemoveMember::execute(): Uid of parent element = \"\n            + parentID + \" child element = \" + childID);\n      Element parentElem = GroupsManagerXML.getElementByTagNameAndId(model, GROUP_TAGNAME,\n            parentID);\n      if (parentElem == null) {\n         Utility.logMessage(\"ERROR\", \"RemoveMember::execute(): Unable to retrieve parent element!\");\n         return;\n      }\n      Utility.logMessage(\"DEBUG\", \"RemoveMember::execute(): About to get child element = \"\n            + childID);\n      Element childElem = GroupsManagerXML.getElementById(model, childID);\n      if (childElem == null) {\n         Utility.logMessage(\"ERROR\", \"RemoveMember::execute(): Unable to retrieve Child element!\");\n         return;\n      }\n      // The child will always be an IGroupMember\n      childGm = GroupsManagerXML.retrieveGroupMemberForElementId(model, childID);\n      // The parent could be an IGroupMember or an IInitialGroupContext.\n      if (parentIsInitialGroupContext(parentID)) {\n         // Put method in GroupsManagerXML and change render method to use it\n         IInitialGroupContext igc = RDBMInitialGroupContextStore.singleton().find(userID,\n               childElem.getAttribute(\"key\"));\n         RDBMInitialGroupContextStore.singleton().delete(igc);\n         hasMbrs = \"true\";\n      }\n      else {\n         // check for null\n         parentGroup = (Object)GroupsManagerXML.retrieveGroupMemberForElementId(model,\n               parentID);\n         removeChildFromGroup(parentGroup, childGm);\n         hasMbrs = String.valueOf(((IEntityGroup)parentGroup).hasMembers());\n         Utility.logMessage(\"DEBUG\", \"RemoveMember::execute(): Got the parent group \");\n      }\n      Utility.logMessage(\"DEBUG\", \"RemoveMember::execute(): about to remove child elements\");\n      Iterator parentNodes = GroupsManagerXML.getNodesByTagNameAndKey(model, GROUP_TAGNAME,\n            parentElem.getAttribute(\"key\"));\n      Node parentNode;\n      NodeList childNodes;\n      Node childNode;\n      while (parentNodes.hasNext()) {\n         parentNode = (Node)parentNodes.next();\n         childNodes = parentNode.getChildNodes();\n         for (int i = 0; i < childNodes.getLength(); i++) {\n            childNode = (org.w3c.dom.Node)childNodes.item(i);\n            if (((Element)childNode).getAttribute(\"key\").equals(childElem.getAttribute(\"key\"))) {\n               parentNode.removeChild(childNode);\n               ((Element)parentNode).setAttribute(\"hasMembers\", hasMbrs);\n            }\n         }\n      }\n      Utility.logMessage(\"DEBUG\", \"RemoveMember::execute(): Completed\");\n   }","commit_id":"96cda17d1df681a885e0f5383409673be6598fd6","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n    * put your documentation comment here\n    * @param sessionData\n    */\n   public void execute (CGroupsManagerSessionData sessionData) {\n      Utility.logMessage(\"DEBUG\", \"SearchForEntities::execute(): Start\");\n      ChannelStaticData staticData = sessionData.staticData;\n      ChannelRuntimeData runtimeData= sessionData.runtimeData;\n\n      Class type;\n      String grpTypeName = null;\n      EntityIdentifier[] results;\n      String label = null;\n      boolean isGroupSearch;\n      // if present, the command arg will be the ancestor\n      String ancestorKey = getCommandArg(runtimeData);\n      IEntityGroup entGrp = GroupsManagerXML.retrieveGroup(ancestorKey);\n      String query = runtimeData.getParameter(\"grpQuery\");\n      String method = runtimeData.getParameter(\"grpMethod\");\n      int methodInt = Integer.parseInt(method);\n      // For an EntityGroup search, the grpType will have the  form of \"IEntityGroup::classname\"\n      // For an Entity search, the grpType will have the  form of \"classname\"\n      String grpType = runtimeData.getParameter(\"grpType\");\n      String searchCriteria = \"grpQuery.\" + query + \"|\" + \"grpMethod.\" + method + \"|\"\n            + \"grpType.\" + grpType + \"|\" + \"ancestor.\" + ancestorKey;\n      try{\n         if (grpType.startsWith(grpPrefix)){\n            isGroupSearch = true;\n            grpTypeName = grpType.substring(grpPrefix.length());\n         }\n         else{\n            isGroupSearch = false;\n            grpTypeName = grpType;\n         }\n         type = Class.forName(grpTypeName);\n         if (isGroupSearch){\n            label = \"Group of \"+org.jasig.portal.EntityTypes.getDescriptiveName(type)+\"s\";\n            if (entGrp != null){\n               results = GroupService.searchForGroups(query, methodInt, type, entGrp);\n            }\n            else{\n               results = GroupService.searchForGroups(query, methodInt, type);\n            }\n         }\n         else{\n            label = org.jasig.portal.EntityTypes.getDescriptiveName(type);\n            if (entGrp != null){\n               results = GroupService.searchForEntities(query, methodInt, type, entGrp);\n            }\n            else{\n               results = GroupService.searchForEntities(query, methodInt, type);\n            }\n         }\n         Document model = getXmlDoc(sessionData);\n         IEntityGroup sr = new EntityGroupImpl(null,type);\n         sr.setName(\"Search Results\");\n         sr.setDescription(\"Search for a \"+label+\" that\"+methods[methodInt]+query);\n\n         for (int sub=0 ; sub < results.length ; sub++) {\n            EntityIdentifier entID = results[sub];\n            IGroupMember resultGroup = GroupService.getGroupMember(entID);\n            sr.addMember(resultGroup);\n         }\n         Element searchElem = GroupsManagerXML.getGroupMemberXml(sr,true,null,model);\n         searchElem.setAttribute(\"searchResults\", \"true\");\n         model.getDocumentElement().appendChild(searchElem);\n\n         this.setCommandArg(sessionData.runtimeData,searchElem.getAttribute(\"id\"));\n         GroupsManagerCommandFactory.get(\"Highlight\").execute(sessionData);\n      }\n      catch (GroupsException ge){\n         Utility.logMessage(\"ERROR\", \"Search failed for criteria = \" + searchCriteria + \"/n\" + ge);\n      }\n      catch (ClassNotFoundException cnfe){\n         Utility.logMessage(\"ERROR\", \"Unable to instantiate class for \" + grpTypeName + \"/n\" + cnfe);\n      }\n   }","id":6025,"modified_method":"/**\n    * put your documentation comment here\n    * @throws Exception\n    * @param sessionData\n    */\n   public void execute (CGroupsManagerSessionData sessionData) throws Exception {\n      Utility.logMessage(\"DEBUG\", \"SearchForEntities::execute(): Start\");\n      ChannelStaticData staticData = sessionData.staticData;\n      ChannelRuntimeData runtimeData = sessionData.runtimeData;\n      Class type;\n      String grpTypeName = null;\n      EntityIdentifier[] results;\n      String label = null;\n      boolean isGroupSearch;\n      // if present, the command arg will be the ancestor\n      String ancestorKey = getCommandArg(runtimeData);\n      IEntityGroup entGrp = GroupsManagerXML.retrieveGroup(ancestorKey);\n      String query = runtimeData.getParameter(\"grpQuery\");\n      String method = runtimeData.getParameter(\"grpMethod\");\n      int methodInt = Integer.parseInt(method);\n      // For an EntityGroup search, the grpType will have the  form of \"IEntityGroup::classname\"\n      // For an Entity search, the grpType will have the  form of \"classname\"\n      String grpType = runtimeData.getParameter(\"grpType\");\n      String searchCriteria = \"grpQuery.\" + query + \"|\" + \"grpMethod.\" + method + \"|\"\n            + \"grpType.\" + grpType + \"|\" + \"ancestor.\" + ancestorKey;\n      if (grpType.startsWith(grpPrefix)) {\n         isGroupSearch = true;\n         grpTypeName = grpType.substring(grpPrefix.length());\n      }\n      else {\n         isGroupSearch = false;\n         grpTypeName = grpType;\n      }\n      type = Class.forName(grpTypeName);\n      if (isGroupSearch) {\n         label = \"Group of \" + org.jasig.portal.EntityTypes.getDescriptiveName(type) +\n               \"s\";\n         if (entGrp != null) {\n            results = GroupService.searchForGroups(query, methodInt, type, entGrp);\n         }\n         else {\n            results = GroupService.searchForGroups(query, methodInt, type);\n         }\n      }\n      else {\n         label = org.jasig.portal.EntityTypes.getDescriptiveName(type);\n         if (entGrp != null) {\n            results = GroupService.searchForEntities(query, methodInt, type, entGrp);\n         }\n         else {\n            results = GroupService.searchForEntities(query, methodInt, type);\n         }\n      }\n      Document model = getXmlDoc(sessionData);\n      IEntityGroup sr = new EntityGroupImpl(null, type);\n      sr.setName(\"Search Results\");\n      sr.setDescription(\"Search for a \" + label + \" that\" + methods[methodInt] + query);\n      for (int sub = 0; sub < results.length; sub++) {\n         EntityIdentifier entID = results[sub];\n         IGroupMember resultGroup = GroupService.getGroupMember(entID);\n         sr.addMember(resultGroup);\n      }\n      Element searchElem = GroupsManagerXML.getGroupMemberXml(sr, true, null, model);\n      searchElem.setAttribute(\"searchResults\", \"true\");\n      model.getDocumentElement().appendChild(searchElem);\n      this.setCommandArg(sessionData.runtimeData, searchElem.getAttribute(\"id\"));\n      GroupsManagerCommandFactory.get(\"Highlight\").execute(sessionData);\n   }","commit_id":"96cda17d1df681a885e0f5383409673be6598fd6","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n    * put your documentation comment here\n    * @param sessionData\n    */\n   public void execute (CGroupsManagerSessionData sessionData) {\n      ChannelStaticData staticData = sessionData.staticData;\n      ChannelRuntimeData runtimeData= sessionData.runtimeData;\n\n      Utility.logMessage(\"DEBUG\", \"SelectMembers::execute(): Start\");\n      Document model = getXmlDoc(sessionData);\n      String theCommand = getCommand(runtimeData);\n      Utility.logMessage(\"DEBUG\", \"SelectMembers::execute(): action = \" + theCommand);\n      Iterator itr = runtimeData.keySet().iterator();\n      Element theElement;\n      while (itr.hasNext()) {\n         String key = (String)itr.next();\n         String thisPerm = null;\n         String tagname = theCommand + \"//\";\n         if (key.indexOf(tagname) > -1) {\n            thisPerm = key.substring(key.lastIndexOf(\"/\") + 1);\n            if (Utility.notEmpty(thisPerm)) {\n               //Utility.logMessage(\"DEBUG\",\"SelectMembers::renderXML(): Iterating over input\");\n               String princeKey = thisPerm.substring(0, thisPerm.lastIndexOf(\"|\"));\n               String princeType = thisPerm.substring(thisPerm.lastIndexOf(\"|\") + 1);\n               //String principal = princeType + \".\" + princeKey;\n               theElement = GroupsManagerXML.getElementByTagNameAndId(model, princeType, princeKey);\n               // test first\n               if (theElement != null) {\n                  GroupsManagerXML.refreshAllNodesIfRequired(model, theElement);\n                  theElement.setAttribute(\"selected\", String.valueOf(theCommand.equals(\"Select\")));\n                  Utility.logMessage(\"DEBUG\", \"SelectMembers::execute(): \" + theCommand\n                        + \"ed element \" + princeType + \" \" + princeKey);\n               }\n            }\n         }\n      }\n   }","id":6026,"modified_method":"/**\n    * put your documentation comment here\n    * @throws Exception\n    * @param sessionData\n    */\n   public void execute (CGroupsManagerSessionData sessionData) throws Exception{\n      ChannelStaticData staticData = sessionData.staticData;\n      ChannelRuntimeData runtimeData= sessionData.runtimeData;\n\n      Utility.logMessage(\"DEBUG\", \"SelectMembers::execute(): Start\");\n      Document model = getXmlDoc(sessionData);\n      String theCommand = getCommand(runtimeData);\n      Utility.logMessage(\"DEBUG\", \"SelectMembers::execute(): action = \" + theCommand);\n      Iterator itr = runtimeData.keySet().iterator();\n      Element theElement;\n      while (itr.hasNext()) {\n         String key = (String)itr.next();\n         String thisPerm = null;\n         String tagname = theCommand + \"//\";\n         if (key.indexOf(tagname) > -1) {\n            thisPerm = key.substring(key.lastIndexOf(\"/\") + 1);\n            if (Utility.notEmpty(thisPerm)) {\n               //Utility.logMessage(\"DEBUG\",\"SelectMembers::renderXML(): Iterating over input\");\n               String princeKey = thisPerm.substring(0, thisPerm.lastIndexOf(\"|\"));\n               String princeType = thisPerm.substring(thisPerm.lastIndexOf(\"|\") + 1);\n               //String principal = princeType + \".\" + princeKey;\n               theElement = GroupsManagerXML.getElementByTagNameAndId(model, princeType, princeKey);\n               // test first\n               if (theElement != null) {\n                  GroupsManagerXML.refreshAllNodesIfRequired(model, theElement);\n                  theElement.setAttribute(\"selected\", String.valueOf(theCommand.equals(\"Select\")));\n                  Utility.logMessage(\"DEBUG\", \"SelectMembers::execute(): \" + theCommand\n                        + \"ed element \" + princeType + \" \" + princeKey);\n               }\n            }\n         }\n      }\n   }","commit_id":"96cda17d1df681a885e0f5383409673be6598fd6","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void execute (CGroupsManagerSessionData sessionData) {\n    Document model = getXmlDoc(sessionData);\n    String id = this.getCommandArg(sessionData.runtimeData);\n    Element e = GroupsManagerXML.getElementById(model,id);\n    if (e != null){\n      Element props = model.createElement(\"properties\");\n      EntityIdentifier ei = null;\n      try{\n        ei = new EntityIdentifier(e.getAttribute(\"key\"),Class.forName(e.getAttribute(\"type\")));\n      }\n      catch (ClassNotFoundException ce){\n        throw new RuntimeException(\"Unable to instatiate class:  type \"+e.getAttribute(\"type\")+\" unknown\");\n      }\n      String[] names = EntityPropertyRegistry.getPropertyNames(ei);\n      //System.out.println(\"Found \"+names.length+\" properties\");\n      for(int i=0; i<names.length;i++){\n          Element prop = model.createElement(\"property\");\n          prop.setAttribute(\"name\",names[i]);\n          prop.setAttribute(\"value\",EntityPropertyRegistry.getProperty(ei,names[i]));\n          props.appendChild(prop);\n      }\n      e.appendChild(props);\n    }\n  }","id":6027,"modified_method":"/**\n    * put your documentation comment here\n    * @throws Exception\n    * @param sessionData\n    */\n  public void execute (CGroupsManagerSessionData sessionData) throws Exception{\n    Document model = getXmlDoc(sessionData);\n    String id = this.getCommandArg(sessionData.runtimeData);\n    Element e = GroupsManagerXML.getElementById(model,id);\n    if (e != null){\n      Element props = model.createElement(\"properties\");\n      EntityIdentifier ei = null;\n      try{\n        ei = new EntityIdentifier(e.getAttribute(\"key\"),Class.forName(e.getAttribute(\"type\")));\n      }\n      catch (ClassNotFoundException ce){\n        throw new RuntimeException(\"Unable to instantiate class:  type \"+e.getAttribute(\"type\")+\" unknown\");\n      }\n      String[] names = EntityPropertyRegistry.getPropertyNames(ei);\n      //System.out.println(\"Found \"+names.length+\" properties\");\n      for(int i=0; i<names.length;i++){\n          Element prop = model.createElement(\"property\");\n          prop.setAttribute(\"name\",names[i]);\n          prop.setAttribute(\"value\",EntityPropertyRegistry.getProperty(ei,names[i]));\n          props.appendChild(prop);\n      }\n      e.appendChild(props);\n    }\n  }","commit_id":"96cda17d1df681a885e0f5383409673be6598fd6","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void execute (CGroupsManagerSessionData sessionData) {\n      try{\n        sessionData.lockedGroup.getLock().release();\n      }\n      catch(Exception e){\n      }\n      sessionData.mode = BROWSE_MODE;\n\n      // Parent was locked so no other thread or process could have changed it, but\n      // child members could have changed.\n      Document model = sessionData.model;\n      String parentID = sessionData.staticData.getParameter(\"groupParentId\");\n      Element parentElem = GroupsManagerXML.getElementById(model, parentID);\n      GroupsManagerXML.refreshAllNodesRecursivelyIfRequired(model, parentElem);\n   }","id":6028,"modified_method":"public void execute (CGroupsManagerSessionData sessionData) throws Exception{\n      Element parentElem = null;\n      sessionData.mode = BROWSE_MODE;\n      Document model = sessionData.model;\n      String key = sessionData.lockedGroup.getLock().getEntityKey();\n      Utility.logMessage(\"DEBUG\", \"UnlockGroup::execute(): Locked group key = \" + key);\n      sessionData.lockedGroup.getLock().release();\n      String parentID = getParentId(sessionData.staticData);\n\n      // Parent was locked so no other thread or process could have changed it, but\n      // child members could have changed.\n      // Parent element id is not always set.\n      if (!Utility.areEqual(parentID, \"\")){\n         parentElem = GroupsManagerXML.getElementById(model, parentID);\n      }\n      Utility.logMessage(\"DEBUG\", \"UnlockGroup::execute(): parentElem = \" + parentElem);\n      if (parentElem != null){\n         GroupsManagerXML.refreshAllNodesRecursivelyIfRequired(model, parentElem);\n      }\n   }","commit_id":"96cda17d1df681a885e0f5383409673be6598fd6","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n    * put your documentation comment here\n    * @param sessionData\n    */\n   public void execute (CGroupsManagerSessionData sessionData) {\n      ChannelStaticData staticData = sessionData.staticData;\n      ChannelRuntimeData runtimeData= sessionData.runtimeData;\n\n      Utility.logMessage(\"DEBUG\", \"UpdateGroup::execute(): Start\");\n      Document model = getXmlDoc(sessionData);\n      String theCommand = runtimeData.getParameter(\"grpCommand\");\n      String newName = runtimeData.getParameter(\"grpName\");\n      String newDescription = runtimeData.getParameter(\"grpDescription\");\n      String updId = getCommandArg(runtimeData);\n      Node titleNode;\n      Element updElem = GroupsManagerXML.getElementByTagNameAndId(model, GROUP_TAGNAME, updId);\n      String updKey = updElem.getAttribute(\"key\");\n      String retMsg;\n      String curName = GroupsManagerXML.getElementValueForTagName(updElem, \"dc:title\");\n      if (curName == null || curName.equals(\"\")) {\n         Utility.logMessage(\"ERROR\", \"UpdateGroup::execute(): Cannot find dc:title element for: \"\n               + updElem.getAttribute(\"name\"));\n         return;\n      }\n      String curDescription = GroupsManagerXML.getElementValueForTagName(updElem, \"dc:description\");\n      boolean hasChanged = false;\n      if (!Utility.areEqual(curName, newName)){\n         Utility.logMessage(\"DEBUG\", \"UpdateGroup::execute(): Group name: '\" + curName\n            + \"' will be updated to : '\" + newName +\"'\");\n         hasChanged = true;\n      }\n      if (!Utility.areEqual(curDescription, newDescription)){\n         Utility.logMessage(\"DEBUG\", \"UpdateGroup::execute(): Group: '\" + newDescription\n            + \"' will be updated to : '\" + newDescription +\"'\");\n         hasChanged = true;\n      }\n\n      // Notify user if nothing was changed\n      if (!hasChanged){\n         Utility.logMessage(\"DEBUG\", \"UpdateGroup::execute(): Update was not applied because nothing has been changed.\");\n         retMsg = \"Update was not applied. No changes were entered.\";\n         sessionData.feedback = retMsg;\n         return;\n      }\n\n      IEntityGroup updGroup = GroupsManagerXML.retrieveGroup(updKey);\n      if (updGroup == null) {\n         retMsg = \"Unable to retrieve Group!\";\n         sessionData.feedback = retMsg;\n         return;\n      }\n      try {\n         Utility.logMessage(\"DEBUG\", \"UpdateGroup::execute(): About to update group: \"\n               + curName);\n         updGroup.setName(newName);\n         updGroup.setDescription(newDescription);\n         updGroup.update();\n         Utility.logMessage(\"DEBUG\", \"UpdateGroup::execute(): About to update xml nodes for group: \"\n               + curName);\n         // update all xml nodes for this group\n         GroupsManagerXML.refreshAllNodes(model, updGroup);\n      } catch (GroupsException ge) {\n         retMsg = \"Unable to create new group\\n\" + ge;\n         sessionData.feedback = retMsg;\n         Utility.logMessage(\"ERROR\", \"UpdateGroup::execute(): \" + retMsg + ge);\n      } catch (Exception e) {\n         retMsg = \"Unable to update group : \" + curName;\n         sessionData.feedback = retMsg;\n         Utility.logMessage(\"ERROR\", \"UpdateGroup::execute(): \" + retMsg + \".\\n\" + e);\n      }\n      Utility.logMessage(\"DEBUG\", \"UpdateGroup::execute(): Finished\");\n   }","id":6029,"modified_method":"/**\n    * put your documentation comment here\n    * @throws Exception\n    * @param sessionData\n    */\n   public void execute (CGroupsManagerSessionData sessionData) throws Exception {\n      ChannelStaticData staticData = sessionData.staticData;\n      ChannelRuntimeData runtimeData = sessionData.runtimeData;\n      Utility.logMessage(\"DEBUG\", \"UpdateGroup::execute(): Start\");\n      Document model = getXmlDoc(sessionData);\n      String theCommand = runtimeData.getParameter(\"grpCommand\");\n      String newName = runtimeData.getParameter(\"grpName\");\n      String newDescription = runtimeData.getParameter(\"grpDescription\");\n      String updId = getCommandArg(runtimeData);\n      Node titleNode;\n      Element updElem = GroupsManagerXML.getElementByTagNameAndId(model, GROUP_TAGNAME,\n            updId);\n      String updKey = updElem.getAttribute(\"key\");\n      String retMsg;\n      String curName = GroupsManagerXML.getElementValueForTagName(updElem, \"dc:title\");\n      if (curName == null || curName.equals(\"\")) {\n         Utility.logMessage(\"ERROR\", \"UpdateGroup::execute(): Cannot find dc:title element for: \"\n               + updElem.getAttribute(\"name\"));\n         return;\n      }\n      String curDescription = GroupsManagerXML.getElementValueForTagName(updElem, \"dc:description\");\n      boolean hasChanged = false;\n      if (!Utility.areEqual(curName, newName)) {\n         Utility.logMessage(\"DEBUG\", \"UpdateGroup::execute(): Group name: '\" + curName\n               + \"' will be updated to : '\" + newName + \"'\");\n         hasChanged = true;\n      }\n      if (!Utility.areEqual(curDescription, newDescription)) {\n         Utility.logMessage(\"DEBUG\", \"UpdateGroup::execute(): Group: '\" + newDescription\n               + \"' will be updated to : '\" + newDescription + \"'\");\n         hasChanged = true;\n      }\n      // Notify user if nothing was changed\n      if (!hasChanged) {\n         Utility.logMessage(\"DEBUG\", \"UpdateGroup::execute(): Update was not applied because nothing has been changed.\");\n         retMsg = \"Update was not applied. No changes were entered.\";\n         sessionData.feedback = retMsg;\n         return;\n      }\n      IEntityGroup updGroup = GroupsManagerXML.retrieveGroup(updKey);\n      if (updGroup == null) {\n         retMsg = \"Unable to retrieve Group!\";\n         sessionData.feedback = retMsg;\n         return;\n      }\n      Utility.logMessage(\"DEBUG\", \"UpdateGroup::execute(): About to update group: \" +\n            curName);\n      updGroup.setName(newName);\n      updGroup.setDescription(newDescription);\n      updGroup.update();\n      Utility.logMessage(\"DEBUG\", \"UpdateGroup::execute(): About to update xml nodes for group: \"\n            + curName);\n      // update all xml nodes for this group\n      GroupsManagerXML.refreshAllNodes(model, updGroup);\n      Utility.logMessage(\"DEBUG\", \"UpdateGroup::execute(): Finished\");\n   }","commit_id":"96cda17d1df681a885e0f5383409673be6598fd6","url":"https://github.com/Jasig/uPortal"},{"original_method":"public CoreApplicationEnvironment(Disposable parentDisposable) {\n    myParentDisposable = parentDisposable;\n    Extensions.cleanRootArea(myParentDisposable);\n\n    myFileTypeRegistry = new CoreFileTypeRegistry();\n    myEncodingRegistry = new CoreEncodingRegistry();\n\n    myApplication = new MockApplication(myParentDisposable);\n    ApplicationManager.setApplication(myApplication,\n                                      new StaticGetter<FileTypeRegistry>(myFileTypeRegistry),\n                                      new StaticGetter<EncodingRegistry>(myEncodingRegistry),\n                                      myParentDisposable);\n    myLocalFileSystem = createLocalFileSystem();\n    myJarFileSystem = createJarFileSystem();\n\n    Extensions.registerAreaClass(ExtensionAreas.IDEA_PROJECT, null);\n\n    final MutablePicoContainer appContainer = myApplication.getPicoContainer();\n    registerComponentInstance(appContainer, FileDocumentManager.class, new MockFileDocumentManagerImpl(new Function<CharSequence, Document>() {\n      @Override\n      public Document fun(CharSequence charSequence) {\n        return new DocumentImpl(charSequence);\n      }\n    }, null));\n\n    FileSystemPersistence fileSystemPersistence = new FileSystemPersistence() {\n      @Override\n      public void refresh(boolean asynchronous, Runnable postAction, @NotNull ModalityState modalityState) {\n      }\n\n      @Override\n      public int getCheapFileSystemModificationCount() {\n        return 0;\n      }\n\n      @Nullable\n      @Override\n      public VirtualFile findFileById(int id) {\n        return null;\n      }\n    };\n    VirtualFileManagerImpl virtualFileManager = new VirtualFileManagerImpl(new VirtualFileSystem[]{myLocalFileSystem, myJarFileSystem},\n                                                                       new MessageBusImpl(myApplication, null),\n                                                                       fileSystemPersistence\n    );\n    registerComponentInstance(appContainer, VirtualFileManager.class, virtualFileManager\n    );\n    myApplication.registerService(VirtualFilePointerManager.class, new CoreVirtualFilePointerManager());\n\n    myApplication.registerService(DefaultASTFactory.class, new CoreASTFactory());\n    myApplication.registerService(PsiBuilderFactory.class, new PsiBuilderFactoryImpl());\n    myApplication.registerService(ReferenceProvidersRegistry.class, new MockReferenceProvidersRegistry());\n    myApplication.registerService(StubTreeLoader.class, new CoreStubTreeLoader());\n    myApplication.registerService(PsiReferenceService.class, new PsiReferenceServiceImpl());\n\n    registerApplicationExtensionPoint(ContentBasedFileSubstitutor.EP_NAME, ContentBasedFileSubstitutor.class);\n    registerExtensionPoint(Extensions.getRootArea(), BinaryFileStubBuilders.EP_NAME, FileTypeExtensionPoint.class);\n\n    ProgressIndicatorProvider.ourInstance = createProgressIndicatorProvider();\n\n    myApplication.registerService(JobLauncher.class, new JobLauncher() {\n      @Override\n      public <T> boolean invokeConcurrentlyUnderProgress(@NotNull List<T> things,\n                                                         ProgressIndicator progress,\n                                                         boolean failFastOnAcquireReadAction,\n                                                         @NotNull Processor<T> thingProcessor) throws ProcessCanceledException {\n        for (T thing : things) {\n          if (!thingProcessor.process(thing))\n            return false;\n        }\n        return true;\n      }\n\n      @Override\n      public Job<Void> submitToJobThread(int priority, @NotNull Runnable action, Consumer<Future> onDoneCallback) {\n        action.run();\n        if (onDoneCallback != null)\n          onDoneCallback.consume(new Future() {\n            @Override\n            public boolean cancel(boolean mayInterruptIfRunning) {\n              return false;\n            }\n\n            @Override\n            public boolean isCancelled() {\n              return false;\n            }\n\n            @Override\n            public boolean isDone() {\n              return true;\n            }\n\n            @Override\n            public Object get() throws InterruptedException, ExecutionException {\n              return null;\n            }\n\n            @Override\n            public Object get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n              return null;\n            }\n          });\n        return null;\n      }\n    });\n\n  }","id":6030,"modified_method":"public CoreApplicationEnvironment(Disposable parentDisposable) {\n    myParentDisposable = parentDisposable;\n    Extensions.cleanRootArea(myParentDisposable);\n\n    myFileTypeRegistry = new CoreFileTypeRegistry();\n    myEncodingRegistry = new CoreEncodingRegistry();\n\n    myApplication = new MockApplication(myParentDisposable);\n    ApplicationManager.setApplication(myApplication,\n                                      new StaticGetter<FileTypeRegistry>(myFileTypeRegistry),\n                                      new StaticGetter<EncodingRegistry>(myEncodingRegistry),\n                                      myParentDisposable);\n    myLocalFileSystem = createLocalFileSystem();\n    myJarFileSystem = createJarFileSystem();\n\n    Extensions.registerAreaClass(ExtensionAreas.IDEA_PROJECT, null);\n\n    final MutablePicoContainer appContainer = myApplication.getPicoContainer();\n    registerComponentInstance(appContainer, FileDocumentManager.class, new MockFileDocumentManagerImpl(new Function<CharSequence, Document>() {\n      @Override\n      public Document fun(CharSequence charSequence) {\n        return new DocumentImpl(charSequence);\n      }\n    }, null));\n\n    FileSystemPersistence fileSystemPersistence = new FileSystemPersistence() {\n      @Override\n      public void refresh(boolean asynchronous, Runnable postAction, @NotNull ModalityState modalityState) {\n      }\n\n      @Override\n      public int getCheapFileSystemModificationCount() {\n        return 0;\n      }\n\n      @Nullable\n      @Override\n      public VirtualFile findFileById(int id) {\n        return null;\n      }\n    };\n    VirtualFileManagerImpl virtualFileManager = new VirtualFileManagerImpl(new VirtualFileSystem[]{myLocalFileSystem, myJarFileSystem},\n                                                                       new MessageBusImpl(myApplication, null),\n                                                                       fileSystemPersistence\n    );\n    registerComponentInstance(appContainer, VirtualFileManager.class, virtualFileManager\n    );\n    myApplication.registerService(VirtualFilePointerManager.class, new CoreVirtualFilePointerManager());\n\n    myApplication.registerService(DefaultASTFactory.class, new CoreASTFactory());\n    myApplication.registerService(PsiBuilderFactory.class, new PsiBuilderFactoryImpl());\n    myApplication.registerService(ReferenceProvidersRegistry.class, new MockReferenceProvidersRegistry());\n    myApplication.registerService(StubTreeLoader.class, new CoreStubTreeLoader());\n    myApplication.registerService(PsiReferenceService.class, new PsiReferenceServiceImpl());\n\n    registerApplicationExtensionPoint(ContentBasedFileSubstitutor.EP_NAME, ContentBasedFileSubstitutor.class);\n    registerExtensionPoint(Extensions.getRootArea(), BinaryFileStubBuilders.EP_NAME, FileTypeExtensionPoint.class);\n\n    ProgressIndicatorProvider.ourInstance = createProgressIndicatorProvider();\n\n    myApplication.registerService(JobLauncher.class, new JobLauncher() {\n      @Override\n      public <T> boolean invokeConcurrentlyUnderProgress(@NotNull List<T> things,\n                                                         ProgressIndicator progress,\n                                                         boolean failFastOnAcquireReadAction,\n                                                         @NotNull Processor<T> thingProcessor) throws ProcessCanceledException {\n        for (T thing : things) {\n          if (!thingProcessor.process(thing))\n            return false;\n        }\n        return true;\n      }\n\n      @Override\n      public <T> AsyncFuture<Boolean> invokeConcurrentlyUnderProgressAsync(@NotNull List<T> things,\n                                                                           ProgressIndicator progress,\n                                                                           boolean failFastOnAcquireReadAction,\n                                                                           @NotNull Processor<T> thingProcessor) {\n        final AsyncFutureResult<Boolean> asyncFutureResult = AsyncFutureFactory.getInstance().createAsyncFutureResult();\n        try {\n          final boolean result = invokeConcurrentlyUnderProgress(things, progress, failFastOnAcquireReadAction, thingProcessor);\n          asyncFutureResult.set(result);\n        } catch (Throwable t) {\n          asyncFutureResult.setException(t);\n        }\n        return asyncFutureResult;\n      }\n\n      @Override\n      public Job<Void> submitToJobThread(int priority, @NotNull Runnable action, Consumer<Future> onDoneCallback) {\n        action.run();\n        if (onDoneCallback != null)\n          onDoneCallback.consume(new Future() {\n            @Override\n            public boolean cancel(boolean mayInterruptIfRunning) {\n              return false;\n            }\n\n            @Override\n            public boolean isCancelled() {\n              return false;\n            }\n\n            @Override\n            public boolean isDone() {\n              return true;\n            }\n\n            @Override\n            public Object get() throws InterruptedException, ExecutionException {\n              return null;\n            }\n\n            @Override\n            public Object get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n              return null;\n            }\n          });\n        return null;\n      }\n    });\n\n  }","commit_id":"f0228498c27ac862cc6558bec2917a759f3e857b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean processElementsWithWord(@NotNull final TextOccurenceProcessor processor,\n                                         @NotNull SearchScope searchScope,\n                                         @NotNull final String text,\n                                         short searchContext,\n                                         final boolean caseSensitively) {\n    if (text.isEmpty()) {\n      throw new IllegalArgumentException(\"Cannot search for elements with empty text\");\n    }\n    final ProgressIndicator progress = ProgressIndicatorProvider.getGlobalProgressIndicator();\n    if (searchScope instanceof GlobalSearchScope) {\n      StringSearcher searcher = new StringSearcher(text, caseSensitively, true);\n\n      return processElementsWithTextInGlobalScope(processor,\n                                                  (GlobalSearchScope)searchScope,\n                                                  searcher,\n                                                  searchContext, caseSensitively, progress);\n    }\n    else {\n      LocalSearchScope scope = (LocalSearchScope)searchScope;\n      PsiElement[] scopeElements = scope.getScope();\n      final boolean ignoreInjectedPsi = scope.isIgnoreInjectedPsi();\n\n      return JobLauncher.getInstance().invokeConcurrentlyUnderProgress(Arrays.asList(scopeElements), progress, false,\n                                                                       new Processor<PsiElement>() {\n                                                                         @Override\n                                                                         public boolean process(PsiElement scopeElement) {\n                                                                           return processElementsWithWordInScopeElement(scopeElement,\n                                                                                                                        processor, text,\n                                                                                                                        caseSensitively,\n                                                                                                                        ignoreInjectedPsi,\n                                                                                                                        progress);\n                                                                         }\n                                                                       });\n    }\n  }","id":6031,"modified_method":"@Override\n  public boolean processElementsWithWord(@NotNull TextOccurenceProcessor processor,\n                                         @NotNull SearchScope searchScope,\n                                         @NotNull String text,\n                                         short searchContext,\n                                         boolean caseSensitive) {\n    final AsyncFuture<Boolean> result =\n      processElementsWithWordAsync(processor, searchScope, text, searchContext, caseSensitive);\n    return AsyncUtil.get(result);\n  }","commit_id":"f0228498c27ac862cc6558bec2917a759f3e857b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean processGlobalRequestsOptimized(@NotNull MultiMap<Set<IdIndexEntry>, RequestWithProcessor> singles,\n                                                 final ProgressIndicator progress) {\n    if (singles.isEmpty()) {\n      return true;\n    }\n\n    if (singles.size() == 1) {\n      final Collection<RequestWithProcessor> requests = singles.get(singles.keySet().iterator().next());\n      if (requests.size() == 1) {\n        final RequestWithProcessor theOnly = requests.iterator().next();\n        return processSingleRequest(theOnly.request, theOnly.refProcessor);\n      }\n    }\n\n    if (progress != null) {\n      progress.pushState();\n      progress.setText(PsiBundle.message(\"psi.scanning.files.progress\"));\n    }\n\n    final MultiMap<VirtualFile, RequestWithProcessor> candidateFiles = collectFiles(singles, progress);\n\n    try {\n      if (candidateFiles.isEmpty()) {\n        return true;\n      }\n\n      final Map<RequestWithProcessor, StringSearcher> searchers = new HashMap<RequestWithProcessor, StringSearcher>();\n      final Set<String> allWords = new TreeSet<String>();\n      for (RequestWithProcessor singleRequest : candidateFiles.values()) {\n        searchers.put(singleRequest, new StringSearcher(singleRequest.request.word, singleRequest.request.caseSensitive, true));\n        allWords.add(singleRequest.request.word);\n      }\n\n      if (progress != null) {\n        final StringBuilder result = new StringBuilder();\n        for (String string : allWords) {\n          if (string != null && !string.isEmpty()) {\n            if (result.length() > 50) {\n              result.append(\"...\");\n              break;\n            }\n            if (result.length() != 0) result.append(\", \");\n            result.append(string);\n          }\n        }\n        progress.setText(PsiBundle.message(\"psi.search.for.word.progress\", result.toString()));\n      }\n\n      return processPsiFileRoots(new ArrayList<VirtualFile>(candidateFiles.keySet()), new Processor<PsiElement>() {\n                                   @Override\n                                   public boolean process(PsiElement psiRoot) {\n                                     final VirtualFile vfile = psiRoot.getContainingFile().getVirtualFile();\n                                     for (final RequestWithProcessor singleRequest : candidateFiles.get(vfile)) {\n                                       StringSearcher searcher = searchers.get(singleRequest);\n                                       TextOccurenceProcessor adapted = adaptProcessor(singleRequest.request, singleRequest.refProcessor);\n                                       if (!LowLevelSearchUtil.processElementsContainingWordInElement(adapted, psiRoot, searcher, true, progress)) {\n                                         return false;\n                                       }\n                                     }\n                                     return true;\n                                   }\n                                 }, progress);\n    }\n    finally {\n      if (progress != null) {\n        progress.popState();\n      }\n    }\n  }","id":6032,"modified_method":"private boolean processGlobalRequestsOptimized(MultiMap<Set<IdIndexEntry>, RequestWithProcessor> singles,\n                                                 final ProgressIndicator progress) {\n    return AsyncUtil.get(processGlobalRequestsOptimizedAsync(singles, progress));\n  }","commit_id":"f0228498c27ac862cc6558bec2917a759f3e857b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean processElementsWithTextInGlobalScope(@NotNull final TextOccurenceProcessor processor,\n                                                       @NotNull final GlobalSearchScope scope,\n                                                       @NotNull final StringSearcher searcher,\n                                                       final short searchContext,\n                                                       final boolean caseSensitively,\n                                                       final ProgressIndicator progress) {\n    LOG.assertTrue(!Thread.holdsLock(PsiLock.LOCK), \"You must not run search from within updating PSI activity. Please consider invokeLatering it instead.\");\n    if (progress != null) {\n      progress.pushState();\n      progress.setText(PsiBundle.message(\"psi.scanning.files.progress\"));\n    }\n\n    String text = searcher.getPattern();\n    List<VirtualFile> fileSet = getFilesWithText(scope, searchContext, caseSensitively, text, progress);\n\n    if (progress != null) {\n      progress.setText(PsiBundle.message(\"psi.search.for.word.progress\", text));\n    }\n\n    try {\n      return processPsiFileRoots(fileSet, new Processor<PsiElement>() {\n        @Override\n        public boolean process(PsiElement psiRoot) {\n          return LowLevelSearchUtil.processElementsContainingWordInElement(processor, psiRoot, searcher, true, progress);\n        }\n      }, progress);\n    }\n    finally {\n      if (progress != null) {\n        progress.popState();\n      }\n    }\n  }","id":6033,"modified_method":"private AsyncFuture<Boolean> processElementsWithTextInGlobalScopeAsync(@NotNull final TextOccurenceProcessor processor,\n                                                       @NotNull final GlobalSearchScope scope,\n                                                       @NotNull final StringSearcher searcher,\n                                                       final short searchContext,\n                                                       final boolean caseSensitively,\n                                                       final ProgressIndicator progress) {\n    LOG.assertTrue(!Thread.holdsLock(PsiLock.LOCK),\n                   \"You must not run search from within updating PSI activity. Please consider invokeLatering it instead.\");\n    if (progress != null) {\n      progress.pushState();\n      progress.setText(PsiBundle.message(\"psi.scanning.files.progress\"));\n    }\n\n    String text = searcher.getPattern();\n    List<VirtualFile> fileSet = getFilesWithText(scope, searchContext, caseSensitively, text, progress);\n\n    if (progress != null) {\n      progress.setText(PsiBundle.message(\"psi.search.for.word.progress\", text));\n    }\n\n      final AsyncFuture<Boolean> result = processPsiFileRootsAsync(fileSet, new Processor<PsiElement>() {\n        @Override\n        public boolean process(PsiElement psiRoot) {\n          return LowLevelSearchUtil.processElementsContainingWordInElement(processor, psiRoot, searcher, true, progress);\n        }\n      }, progress);\n      return new FinallyFuture<Boolean>(result, new Runnable() {\n        @Override\n        public void run() {\n          if (progress != null) {\n            progress.popState();\n          }\n        }\n      });\n  }","commit_id":"f0228498c27ac862cc6558bec2917a759f3e857b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean processPsiFileRoots(@NotNull List<VirtualFile> files,\n                                      @NotNull final Processor<PsiElement> psiRootProcessor,\n                                      final ProgressIndicator progress) {\n    myManager.startBatchFilesProcessingMode();\n    try {\n      final AtomicInteger counter = new AtomicInteger(0);\n      final AtomicBoolean canceled = new AtomicBoolean(false);\n      final AtomicBoolean pceThrown = new AtomicBoolean(false);\n\n      final int size = files.size();\n      boolean completed = JobLauncher.getInstance().invokeConcurrentlyUnderProgress(files, progress, false, new Processor<VirtualFile>() {\n        @Override\n        public boolean process(final VirtualFile vfile) {\n          final PsiFile file = ApplicationManager.getApplication().runReadAction(new Computable<PsiFile>() {\n            @Override\n            public PsiFile compute() {\n              return vfile.isValid() ? myManager.findFile(vfile) : null;\n            }\n          });\n          if (file != null && !(file instanceof PsiBinaryFile)) {\n            file.getViewProvider().getContents(); // load contents outside readaction\n            ApplicationManager.getApplication().runReadAction(new Runnable() {\n              @Override\n              public void run() {\n                try {\n                  if (myManager.getProject().isDisposed()) throw new ProcessCanceledException();\n                  List<PsiFile> psiRoots = file.getViewProvider().getAllFiles();\n                  Set<PsiElement> processed = new HashSet<PsiElement>(psiRoots.size() * 2, (float)0.5);\n                  for (PsiElement psiRoot : psiRoots) {\n                    if (progress != null) progress.checkCanceled();\n                    if (!processed.add(psiRoot)) continue;\n                    if (!psiRoot.isValid()) continue;\n                    assert psiRoot != null : \"One of the roots of file \" +\n                                             file +\n                                             \" is null. All roots: \" +\n                                             Arrays.asList(psiRoots) +\n                                             \"; Viewprovider: \" +\n                                             file.getViewProvider() +\n                                             \"; Virtual file: \" +\n                                             file.getViewProvider().getVirtualFile();\n                    if (!psiRootProcessor.process(psiRoot)) {\n                      canceled.set(true);\n                      return;\n                    }\n                  }\n                  myManager.dropResolveCaches();\n                }\n                catch (ProcessCanceledException e) {\n                  canceled.set(true);\n                  pceThrown.set(true);\n                }\n              }\n            });\n          }\n          if (progress != null && progress.isRunning()) {\n            double fraction = (double)counter.incrementAndGet() / size;\n            progress.setFraction(fraction);\n          }\n          return !canceled.get();\n        }\n      });\n\n      if (pceThrown.get()) {\n        throw new ProcessCanceledException();\n      }\n\n      return completed;\n    }\n    finally {\n      myManager.finishBatchFilesProcessingMode();\n    }\n  }","id":6034,"modified_method":"private AsyncFuture<Boolean> processPsiFileRootsAsync(@NotNull List<VirtualFile> files,\n                                      @NotNull final Processor<PsiElement> psiRootProcessor,\n                                      final ProgressIndicator progress) {\n    myManager.startBatchFilesProcessingMode();\n      final AtomicInteger counter = new AtomicInteger(0);\n      final AtomicBoolean canceled = new AtomicBoolean(false);\n      final AtomicBoolean pceThrown = new AtomicBoolean(false);\n\n      final int size = files.size();\n      AsyncFuture<Boolean>\n        completed = JobLauncher.getInstance().invokeConcurrentlyUnderProgressAsync(files, progress, false, new Processor<VirtualFile>() {\n        @Override\n        public boolean process(final VirtualFile vfile) {\n          final PsiFile file = ApplicationManager.getApplication().runReadAction(new Computable<PsiFile>() {\n            @Override\n            public PsiFile compute() {\n              return vfile.isValid() ? myManager.findFile(vfile) : null;\n            }\n          });\n          if (file != null && !(file instanceof PsiBinaryFile)) {\n            file.getViewProvider().getContents(); // load contents outside readaction\n            ApplicationManager.getApplication().runReadAction(new Runnable() {\n              @Override\n              public void run() {\n                try {\n                  if (myManager.getProject().isDisposed()) throw new ProcessCanceledException();\n                  List<PsiFile> psiRoots = file.getViewProvider().getAllFiles();\n                  Set<PsiElement> processed = new HashSet<PsiElement>(psiRoots.size() * 2, (float)0.5);\n                  for (PsiElement psiRoot : psiRoots) {\n                    if (progress != null) progress.checkCanceled();\n                    if (!processed.add(psiRoot)) continue;\n                    if (!psiRoot.isValid()) continue;\n                    assert psiRoot != null : \"One of the roots of file \" +\n                                             file +\n                                             \" is null. All roots: \" +\n                                             Arrays.asList(psiRoots) +\n                                             \"; Viewprovider: \" +\n                                             file.getViewProvider() +\n                                             \"; Virtual file: \" +\n                                             file.getViewProvider().getVirtualFile();\n                    if (!psiRootProcessor.process(psiRoot)) {\n                      canceled.set(true);\n                      return;\n                    }\n                  }\n                  myManager.dropResolveCaches();\n                }\n                catch (ProcessCanceledException e) {\n                  canceled.set(true);\n                  pceThrown.set(true);\n                }\n              }\n            });\n          }\n          if (progress != null && progress.isRunning()) {\n            double fraction = (double)counter.incrementAndGet() / size;\n            progress.setFraction(fraction);\n          }\n          return !canceled.get();\n        }\n      });\n\n      final AsyncFutureResult<Boolean> ourResult = AsyncFutureFactory.getInstance().createAsyncFutureResult();\n      completed.addConsumer(SameThreadExecutor.INSTANCE, new ResultConsumer<Boolean>() {\n        @Override\n        public void onSuccess(Boolean value) {\n          if (pceThrown.get())\n            ourResult.setException(new ProcessCanceledException());\n          else\n            ourResult.set(value);\n        }\n\n        @Override\n        public void onFailure(Throwable t) {\n          ourResult.setException(t);\n        }\n      });\n\n\n      return new FinallyFuture<Boolean>(ourResult, new Runnable() {\n        @Override\n        public void run() {\n          myManager.finishBatchFilesProcessingMode();\n        }\n      });\n  }","commit_id":"f0228498c27ac862cc6558bec2917a759f3e857b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean processSingleRequest(@NotNull PsiSearchRequest single, @NotNull Processor<PsiReference> consumer) {\n    return processElementsWithWord(adaptProcessor(single, consumer), single.searchScope, single.word, single.searchContext, single.caseSensitive);\n  }","id":6035,"modified_method":"private boolean processSingleRequest(PsiSearchRequest single, Processor<PsiReference> consumer) {\n    return AsyncUtil.get(processSingleRequestAsync(single, consumer));\n  }","commit_id":"f0228498c27ac862cc6558bec2917a759f3e857b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CoreApplicationEnvironment(Disposable parentDisposable) {\n    myParentDisposable = parentDisposable;\n    Extensions.cleanRootArea(myParentDisposable);\n\n    myFileTypeRegistry = new CoreFileTypeRegistry();\n    myEncodingRegistry = new CoreEncodingRegistry();\n\n    myApplication = new MockApplication(myParentDisposable);\n    ApplicationManager.setApplication(myApplication,\n                                      new StaticGetter<FileTypeRegistry>(myFileTypeRegistry),\n                                      new StaticGetter<EncodingRegistry>(myEncodingRegistry),\n                                      myParentDisposable);\n    myLocalFileSystem = createLocalFileSystem();\n    myJarFileSystem = createJarFileSystem();\n\n    Extensions.registerAreaClass(ExtensionAreas.IDEA_PROJECT, null);\n\n    final MutablePicoContainer appContainer = myApplication.getPicoContainer();\n    registerComponentInstance(appContainer, FileDocumentManager.class, new MockFileDocumentManagerImpl(new Function<CharSequence, Document>() {\n      @Override\n      public Document fun(CharSequence charSequence) {\n        return new DocumentImpl(charSequence);\n      }\n    }, null));\n\n    registerComponentInstance(appContainer, VirtualFileManager.class,\n                              new VirtualFileManagerImpl(new VirtualFileSystem[] {myLocalFileSystem, myJarFileSystem},\n                                                         new MessageBusImpl(myApplication, null),\n                                                         new FileSystemPersistence() {\n                                                           @Override\n                                                           public void refresh(boolean asynchronous, Runnable postAction, @NotNull ModalityState modalityState) {\n                                                           }\n\n                                                           @Override\n                                                           public int getCheapFileSystemModificationCount() {\n                                                             return 0;\n                                                           }\n                                                         }\n                              )\n    );\n    myApplication.registerService(VirtualFilePointerManager.class, new CoreVirtualFilePointerManager());\n\n    myApplication.registerService(DefaultASTFactory.class, new CoreASTFactory());\n    myApplication.registerService(PsiBuilderFactory.class, new PsiBuilderFactoryImpl());\n    myApplication.registerService(ReferenceProvidersRegistry.class, new MockReferenceProvidersRegistry());\n    myApplication.registerService(StubTreeLoader.class, new CoreStubTreeLoader());\n    myApplication.registerService(PsiReferenceService.class, new PsiReferenceServiceImpl());\n\n    registerApplicationExtensionPoint(ContentBasedFileSubstitutor.EP_NAME, ContentBasedFileSubstitutor.class);\n    registerExtensionPoint(Extensions.getRootArea(), BinaryFileStubBuilders.EP_NAME, FileTypeExtensionPoint.class);\n\n    ProgressIndicatorProvider.ourInstance = createProgressIndicatorProvider();\n\n    myApplication.registerService(JobLauncher.class, new JobLauncher() {\n      @Override\n      public <T> boolean invokeConcurrentlyUnderProgress(@NotNull List<T> things,\n                                                         ProgressIndicator progress,\n                                                         boolean failFastOnAcquireReadAction,\n                                                         @NotNull Processor<T> thingProcessor) throws ProcessCanceledException {\n        for (T thing : things) {\n          if (!thingProcessor.process(thing))\n            return false;\n        }\n        return true;\n      }\n\n      @Override\n      public Job<Void> submitToJobThread(int priority, @NotNull Runnable action, Consumer<Future> onDoneCallback) {\n        action.run();\n        if (onDoneCallback != null)\n          onDoneCallback.consume(new Future() {\n            @Override\n            public boolean cancel(boolean mayInterruptIfRunning) {\n              return false;\n            }\n\n            @Override\n            public boolean isCancelled() {\n              return false;\n            }\n\n            @Override\n            public boolean isDone() {\n              return true;\n            }\n\n            @Override\n            public Object get() throws InterruptedException, ExecutionException {\n              return null;\n            }\n\n            @Override\n            public Object get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n              return null;\n            }\n          });\n        return null;\n      }\n    });\n\n  }","id":6036,"modified_method":"public CoreApplicationEnvironment(Disposable parentDisposable) {\n    myParentDisposable = parentDisposable;\n    Extensions.cleanRootArea(myParentDisposable);\n\n    myFileTypeRegistry = new CoreFileTypeRegistry();\n    myEncodingRegistry = new CoreEncodingRegistry();\n\n    myApplication = new MockApplication(myParentDisposable);\n    ApplicationManager.setApplication(myApplication,\n                                      new StaticGetter<FileTypeRegistry>(myFileTypeRegistry),\n                                      new StaticGetter<EncodingRegistry>(myEncodingRegistry),\n                                      myParentDisposable);\n    myLocalFileSystem = createLocalFileSystem();\n    myJarFileSystem = createJarFileSystem();\n\n    Extensions.registerAreaClass(ExtensionAreas.IDEA_PROJECT, null);\n\n    final MutablePicoContainer appContainer = myApplication.getPicoContainer();\n    registerComponentInstance(appContainer, FileDocumentManager.class, new MockFileDocumentManagerImpl(new Function<CharSequence, Document>() {\n      @Override\n      public Document fun(CharSequence charSequence) {\n        return new DocumentImpl(charSequence);\n      }\n    }, null));\n\n    registerComponentInstance(appContainer, VirtualFileManager.class,\n                              new VirtualFileManagerImpl(new VirtualFileSystem[] {myLocalFileSystem, myJarFileSystem},\n                                                         new MessageBusImpl(myApplication, null),\n                                                         new FileSystemPersistence() {\n                                                           @Override\n                                                           public void refresh(boolean asynchronous, Runnable postAction, @NotNull ModalityState modalityState) {\n                                                           }\n\n                                                           @Override\n                                                           public int getCheapFileSystemModificationCount() {\n                                                             return 0;\n                                                           }\n                                                         }\n                              )\n    );\n    myApplication.registerService(VirtualFilePointerManager.class, new CoreVirtualFilePointerManager());\n\n    myApplication.registerService(DefaultASTFactory.class, new CoreASTFactory());\n    myApplication.registerService(PsiBuilderFactory.class, new PsiBuilderFactoryImpl());\n    myApplication.registerService(ReferenceProvidersRegistry.class, new MockReferenceProvidersRegistry());\n    myApplication.registerService(StubTreeLoader.class, new CoreStubTreeLoader());\n    myApplication.registerService(PsiReferenceService.class, new PsiReferenceServiceImpl());\n\n    registerApplicationExtensionPoint(ContentBasedFileSubstitutor.EP_NAME, ContentBasedFileSubstitutor.class);\n    registerExtensionPoint(Extensions.getRootArea(), BinaryFileStubBuilders.EP_NAME, FileTypeExtensionPoint.class);\n\n    ProgressIndicatorProvider.ourInstance = createProgressIndicatorProvider();\n\n    myApplication.registerService(JobLauncher.class, new JobLauncher() {\n      @Override\n      public <T> boolean invokeConcurrentlyUnderProgress(@NotNull List<T> things,\n                                                         ProgressIndicator progress,\n                                                         boolean failFastOnAcquireReadAction,\n                                                         @NotNull Processor<T> thingProcessor) throws ProcessCanceledException {\n        for (T thing : things) {\n          if (!thingProcessor.process(thing))\n            return false;\n        }\n        return true;\n      }\n\n      @Override\n      public <T> AsyncFuture<Boolean> invokeConcurrentlyUnderProgressAsync(@NotNull List<T> things,\n                                                                           ProgressIndicator progress,\n                                                                           boolean failFastOnAcquireReadAction,\n                                                                           @NotNull Processor<T> thingProcessor) {\n        final AsyncFutureResult<Boolean> asyncFutureResult = AsyncFutureFactory.getInstance().createAsyncFutureResult();\n        try {\n          final boolean result = invokeConcurrentlyUnderProgress(things, progress, failFastOnAcquireReadAction, thingProcessor);\n          asyncFutureResult.set(result);\n        } catch (Throwable t) {\n          asyncFutureResult.setException(t);\n        }\n        return asyncFutureResult;\n      }\n\n      @Override\n      public Job<Void> submitToJobThread(int priority, @NotNull Runnable action, Consumer<Future> onDoneCallback) {\n        action.run();\n        if (onDoneCallback != null)\n          onDoneCallback.consume(new Future() {\n            @Override\n            public boolean cancel(boolean mayInterruptIfRunning) {\n              return false;\n            }\n\n            @Override\n            public boolean isCancelled() {\n              return false;\n            }\n\n            @Override\n            public boolean isDone() {\n              return true;\n            }\n\n            @Override\n            public Object get() throws InterruptedException, ExecutionException {\n              return null;\n            }\n\n            @Override\n            public Object get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n              return null;\n            }\n          });\n        return null;\n      }\n    });\n\n  }","commit_id":"8f5bde24d5fabad4917fcf38f7fbd6e3920fc535","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean processGlobalRequestsOptimized(@NotNull MultiMap<Set<IdIndexEntry>, RequestWithProcessor> singles,\n                                                 final ProgressIndicator progress) {\n    if (singles.isEmpty()) {\n      return true;\n    }\n\n    if (singles.size() == 1) {\n      final Collection<RequestWithProcessor> requests = singles.get(singles.keySet().iterator().next());\n      if (requests.size() == 1) {\n        final RequestWithProcessor theOnly = requests.iterator().next();\n        return processSingleRequest(theOnly.request, theOnly.refProcessor);\n      }\n    }\n\n    if (progress != null) {\n      progress.pushState();\n      progress.setText(PsiBundle.message(\"psi.scanning.files.progress\"));\n    }\n\n    final MultiMap<VirtualFile, RequestWithProcessor> candidateFiles = collectFiles(singles, progress);\n\n    try {\n      if (candidateFiles.isEmpty()) {\n        return true;\n      }\n\n      final Map<RequestWithProcessor, StringSearcher> searchers = new HashMap<RequestWithProcessor, StringSearcher>();\n      final Set<String> allWords = new TreeSet<String>();\n      for (RequestWithProcessor singleRequest : candidateFiles.values()) {\n        searchers.put(singleRequest, new StringSearcher(singleRequest.request.word, singleRequest.request.caseSensitive, true));\n        allWords.add(singleRequest.request.word);\n      }\n\n      if (progress != null) {\n        final StringBuilder result = new StringBuilder();\n        for (String string : allWords) {\n          if (string != null && !string.isEmpty()) {\n            if (result.length() > 50) {\n              result.append(\"...\");\n              break;\n            }\n            if (result.length() != 0) result.append(\", \");\n            result.append(string);\n          }\n        }\n        progress.setText(PsiBundle.message(\"psi.search.for.word.progress\", result.toString()));\n      }\n\n      return processPsiFileRoots(new ArrayList<VirtualFile>(candidateFiles.keySet()), new Processor<PsiElement>() {\n                                   @Override\n                                   public boolean process(PsiElement psiRoot) {\n                                     final VirtualFile vfile = psiRoot.getContainingFile().getVirtualFile();\n                                     for (final RequestWithProcessor singleRequest : candidateFiles.get(vfile)) {\n                                       StringSearcher searcher = searchers.get(singleRequest);\n                                       TextOccurenceProcessor adapted = adaptProcessor(singleRequest.request, singleRequest.refProcessor);\n                                       if (!LowLevelSearchUtil.processElementsContainingWordInElement(adapted, psiRoot, searcher, true, progress)) {\n                                         return false;\n                                       }\n                                     }\n                                     return true;\n                                   }\n                                 }, progress);\n    }\n    finally {\n      if (progress != null) {\n        progress.popState();\n      }\n    }\n  }","id":6037,"modified_method":"private boolean processGlobalRequestsOptimized(MultiMap<Set<IdIndexEntry>, RequestWithProcessor> singles,\n                                                 final ProgressIndicator progress) {\n    return AsyncUtil.get(processGlobalRequestsOptimizedAsync(singles, progress));\n  }","commit_id":"8f5bde24d5fabad4917fcf38f7fbd6e3920fc535","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean processElementsWithTextInGlobalScope(@NotNull final TextOccurenceProcessor processor,\n                                                       @NotNull final GlobalSearchScope scope,\n                                                       @NotNull final StringSearcher searcher,\n                                                       final short searchContext,\n                                                       final boolean caseSensitively,\n                                                       final ProgressIndicator progress) {\n    LOG.assertTrue(!Thread.holdsLock(PsiLock.LOCK), \"You must not run search from within updating PSI activity. Please consider invokeLatering it instead.\");\n    if (progress != null) {\n      progress.pushState();\n      progress.setText(PsiBundle.message(\"psi.scanning.files.progress\"));\n    }\n\n    String text = searcher.getPattern();\n    List<VirtualFile> fileSet = getFilesWithText(scope, searchContext, caseSensitively, text, progress);\n\n    if (progress != null) {\n      progress.setText(PsiBundle.message(\"psi.search.for.word.progress\", text));\n    }\n\n    try {\n      return processPsiFileRoots(fileSet, new Processor<PsiElement>() {\n        @Override\n        public boolean process(PsiElement psiRoot) {\n          return LowLevelSearchUtil.processElementsContainingWordInElement(processor, psiRoot, searcher, true, progress);\n        }\n      }, progress);\n    }\n    finally {\n      if (progress != null) {\n        progress.popState();\n      }\n    }\n  }","id":6038,"modified_method":"private AsyncFuture<Boolean> processElementsWithTextInGlobalScopeAsync(@NotNull final TextOccurenceProcessor processor,\n                                                       @NotNull final GlobalSearchScope scope,\n                                                       @NotNull final StringSearcher searcher,\n                                                       final short searchContext,\n                                                       final boolean caseSensitively,\n                                                       final ProgressIndicator progress) {\n    LOG.assertTrue(!Thread.holdsLock(PsiLock.LOCK),\n                   \"You must not run search from within updating PSI activity. Please consider invokeLatering it instead.\");\n    if (progress != null) {\n      progress.pushState();\n      progress.setText(PsiBundle.message(\"psi.scanning.files.progress\"));\n    }\n\n    String text = searcher.getPattern();\n    List<VirtualFile> fileSet = getFilesWithText(scope, searchContext, caseSensitively, text, progress);\n\n    if (progress != null) {\n      progress.setText(PsiBundle.message(\"psi.search.for.word.progress\", text));\n    }\n\n      final AsyncFuture<Boolean> result = processPsiFileRootsAsync(fileSet, new Processor<PsiElement>() {\n        @Override\n        public boolean process(PsiElement psiRoot) {\n          return LowLevelSearchUtil.processElementsContainingWordInElement(processor, psiRoot, searcher, true, progress);\n        }\n      }, progress);\n      return new FinallyFuture<Boolean>(result, new Runnable() {\n        @Override\n        public void run() {\n          if (progress != null) {\n            progress.popState();\n          }\n        }\n      });\n  }","commit_id":"8f5bde24d5fabad4917fcf38f7fbd6e3920fc535","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean processElementsWithWord(@NotNull final TextOccurenceProcessor processor,\n                                         @NotNull SearchScope searchScope,\n                                         @NotNull final String text,\n                                         short searchContext,\n                                         final boolean caseSensitively) {\n    if (text.isEmpty()) {\n      throw new IllegalArgumentException(\"Cannot search for elements with empty text\");\n    }\n    final ProgressIndicator progress = ProgressIndicatorProvider.getGlobalProgressIndicator();\n    if (searchScope instanceof GlobalSearchScope) {\n      StringSearcher searcher = new StringSearcher(text, caseSensitively, true);\n\n      return processElementsWithTextInGlobalScope(processor,\n                                                  (GlobalSearchScope)searchScope,\n                                                  searcher,\n                                                  searchContext, caseSensitively, progress);\n    }\n    else {\n      LocalSearchScope scope = (LocalSearchScope)searchScope;\n      PsiElement[] scopeElements = scope.getScope();\n      final boolean ignoreInjectedPsi = scope.isIgnoreInjectedPsi();\n\n      return JobLauncher.getInstance().invokeConcurrentlyUnderProgress(Arrays.asList(scopeElements), progress, false,\n                                                                       new Processor<PsiElement>() {\n                                                                         @Override\n                                                                         public boolean process(PsiElement scopeElement) {\n                                                                           return processElementsWithWordInScopeElement(scopeElement,\n                                                                                                                        processor, text,\n                                                                                                                        caseSensitively,\n                                                                                                                        ignoreInjectedPsi,\n                                                                                                                        progress);\n                                                                         }\n                                                                       });\n    }\n  }","id":6039,"modified_method":"@Override\n  public boolean processElementsWithWord(@NotNull TextOccurenceProcessor processor,\n                                         @NotNull SearchScope searchScope,\n                                         @NotNull String text,\n                                         short searchContext,\n                                         boolean caseSensitive) {\n    final AsyncFuture<Boolean> result =\n      processElementsWithWordAsync(processor, searchScope, text, searchContext, caseSensitive);\n    return AsyncUtil.get(result);\n  }","commit_id":"8f5bde24d5fabad4917fcf38f7fbd6e3920fc535","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean processSingleRequest(@NotNull PsiSearchRequest single, @NotNull Processor<PsiReference> consumer) {\n    return processElementsWithWord(adaptProcessor(single, consumer), single.searchScope, single.word, single.searchContext, single.caseSensitive);\n  }","id":6040,"modified_method":"private boolean processSingleRequest(PsiSearchRequest single, Processor<PsiReference> consumer) {\n    return AsyncUtil.get(processSingleRequestAsync(single, consumer));\n  }","commit_id":"8f5bde24d5fabad4917fcf38f7fbd6e3920fc535","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean processPsiFileRoots(@NotNull List<VirtualFile> files,\n                                      @NotNull final Processor<PsiElement> psiRootProcessor,\n                                      final ProgressIndicator progress) {\n    myManager.startBatchFilesProcessingMode();\n    try {\n      final AtomicInteger counter = new AtomicInteger(0);\n      final AtomicBoolean canceled = new AtomicBoolean(false);\n      final AtomicBoolean pceThrown = new AtomicBoolean(false);\n\n      final int size = files.size();\n      boolean completed = JobLauncher.getInstance().invokeConcurrentlyUnderProgress(files, progress, false, new Processor<VirtualFile>() {\n        @Override\n        public boolean process(final VirtualFile vfile) {\n          final PsiFile file = ApplicationManager.getApplication().runReadAction(new Computable<PsiFile>() {\n            @Override\n            public PsiFile compute() {\n              return vfile.isValid() ? myManager.findFile(vfile) : null;\n            }\n          });\n          if (file != null && !(file instanceof PsiBinaryFile)) {\n            file.getViewProvider().getContents(); // load contents outside readaction\n            ApplicationManager.getApplication().runReadAction(new Runnable() {\n              @Override\n              public void run() {\n                try {\n                  if (myManager.getProject().isDisposed()) throw new ProcessCanceledException();\n                  List<PsiFile> psiRoots = file.getViewProvider().getAllFiles();\n                  Set<PsiElement> processed = new HashSet<PsiElement>(psiRoots.size() * 2, (float)0.5);\n                  for (PsiElement psiRoot : psiRoots) {\n                    if (progress != null) progress.checkCanceled();\n                    if (!processed.add(psiRoot)) continue;\n                    if (!psiRoot.isValid()) continue;\n                    assert psiRoot != null : \"One of the roots of file \" +\n                                             file +\n                                             \" is null. All roots: \" +\n                                             Arrays.asList(psiRoots) +\n                                             \"; Viewprovider: \" +\n                                             file.getViewProvider() +\n                                             \"; Virtual file: \" +\n                                             file.getViewProvider().getVirtualFile();\n                    if (!psiRootProcessor.process(psiRoot)) {\n                      canceled.set(true);\n                      return;\n                    }\n                  }\n                  myManager.dropResolveCaches();\n                }\n                catch (ProcessCanceledException e) {\n                  canceled.set(true);\n                  pceThrown.set(true);\n                }\n              }\n            });\n          }\n          if (progress != null && progress.isRunning()) {\n            double fraction = (double)counter.incrementAndGet() / size;\n            progress.setFraction(fraction);\n          }\n          return !canceled.get();\n        }\n      });\n\n      if (pceThrown.get()) {\n        throw new ProcessCanceledException();\n      }\n\n      return completed;\n    }\n    finally {\n      myManager.finishBatchFilesProcessingMode();\n    }\n  }","id":6041,"modified_method":"private AsyncFuture<Boolean> processPsiFileRootsAsync(@NotNull List<VirtualFile> files,\n                                      @NotNull final Processor<PsiElement> psiRootProcessor,\n                                      final ProgressIndicator progress) {\n    myManager.startBatchFilesProcessingMode();\n      final AtomicInteger counter = new AtomicInteger(0);\n      final AtomicBoolean canceled = new AtomicBoolean(false);\n      final AtomicBoolean pceThrown = new AtomicBoolean(false);\n\n      final int size = files.size();\n      AsyncFuture<Boolean>\n        completed = JobLauncher.getInstance().invokeConcurrentlyUnderProgressAsync(files, progress, false, new Processor<VirtualFile>() {\n        @Override\n        public boolean process(final VirtualFile vfile) {\n          final PsiFile file = ApplicationManager.getApplication().runReadAction(new Computable<PsiFile>() {\n            @Override\n            public PsiFile compute() {\n              return vfile.isValid() ? myManager.findFile(vfile) : null;\n            }\n          });\n          if (file != null && !(file instanceof PsiBinaryFile)) {\n            file.getViewProvider().getContents(); // load contents outside readaction\n            ApplicationManager.getApplication().runReadAction(new Runnable() {\n              @Override\n              public void run() {\n                try {\n                  if (myManager.getProject().isDisposed()) throw new ProcessCanceledException();\n                  List<PsiFile> psiRoots = file.getViewProvider().getAllFiles();\n                  Set<PsiElement> processed = new HashSet<PsiElement>(psiRoots.size() * 2, (float)0.5);\n                  for (PsiElement psiRoot : psiRoots) {\n                    if (progress != null) progress.checkCanceled();\n                    if (!processed.add(psiRoot)) continue;\n                    if (!psiRoot.isValid()) continue;\n                    assert psiRoot != null : \"One of the roots of file \" +\n                                             file +\n                                             \" is null. All roots: \" +\n                                             Arrays.asList(psiRoots) +\n                                             \"; Viewprovider: \" +\n                                             file.getViewProvider() +\n                                             \"; Virtual file: \" +\n                                             file.getViewProvider().getVirtualFile();\n                    if (!psiRootProcessor.process(psiRoot)) {\n                      canceled.set(true);\n                      return;\n                    }\n                  }\n                  myManager.dropResolveCaches();\n                }\n                catch (ProcessCanceledException e) {\n                  canceled.set(true);\n                  pceThrown.set(true);\n                }\n              }\n            });\n          }\n          if (progress != null && progress.isRunning()) {\n            double fraction = (double)counter.incrementAndGet() / size;\n            progress.setFraction(fraction);\n          }\n          return !canceled.get();\n        }\n      });\n\n      final AsyncFutureResult<Boolean> ourResult = AsyncFutureFactory.getInstance().createAsyncFutureResult();\n      completed.addConsumer(SameThreadExecutor.INSTANCE, new ResultConsumer<Boolean>() {\n        @Override\n        public void onSuccess(Boolean value) {\n          if (pceThrown.get())\n            ourResult.setException(new ProcessCanceledException());\n          else\n            ourResult.set(value);\n        }\n\n        @Override\n        public void onFailure(Throwable t) {\n          ourResult.setException(t);\n        }\n      });\n\n\n      return new FinallyFuture<Boolean>(ourResult, new Runnable() {\n        @Override\n        public void run() {\n          myManager.finishBatchFilesProcessingMode();\n        }\n      });\n  }","commit_id":"8f5bde24d5fabad4917fcf38f7fbd6e3920fc535","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CoreApplicationEnvironment(Disposable parentDisposable) {\n    myParentDisposable = parentDisposable;\n    Extensions.cleanRootArea(myParentDisposable);\n\n    myFileTypeRegistry = new CoreFileTypeRegistry();\n    myEncodingRegistry = new CoreEncodingRegistry();\n\n    myApplication = new MockApplication(myParentDisposable);\n    ApplicationManager.setApplication(myApplication,\n                                      new StaticGetter<FileTypeRegistry>(myFileTypeRegistry),\n                                      new StaticGetter<EncodingRegistry>(myEncodingRegistry),\n                                      myParentDisposable);\n    myLocalFileSystem = createLocalFileSystem();\n    myJarFileSystem = createJarFileSystem();\n\n    Extensions.registerAreaClass(ExtensionAreas.IDEA_PROJECT, null);\n\n    final MutablePicoContainer appContainer = myApplication.getPicoContainer();\n    registerComponentInstance(appContainer, FileDocumentManager.class, new MockFileDocumentManagerImpl(new Function<CharSequence, Document>() {\n      @Override\n      public Document fun(CharSequence charSequence) {\n        return new DocumentImpl(charSequence);\n      }\n    }, null));\n\n    registerComponentInstance(appContainer, VirtualFileManager.class,\n                              new VirtualFileManagerImpl(new VirtualFileSystem[] {myLocalFileSystem, myJarFileSystem},\n                                                         new MessageBusImpl(myApplication, null),\n                                                         new FileSystemPersistence() {\n                                                           @Override\n                                                           public void refresh(boolean asynchronous, Runnable postAction, @NotNull ModalityState modalityState) {\n                                                           }\n\n                                                           @Override\n                                                           public int getCheapFileSystemModificationCount() {\n                                                             return 0;\n                                                           }\n                                                         }\n                              )\n    );\n    myApplication.registerService(VirtualFilePointerManager.class, new CoreVirtualFilePointerManager());\n\n    myApplication.registerService(DefaultASTFactory.class, new CoreASTFactory());\n    myApplication.registerService(PsiBuilderFactory.class, new PsiBuilderFactoryImpl());\n    myApplication.registerService(ReferenceProvidersRegistry.class, new MockReferenceProvidersRegistry());\n    myApplication.registerService(StubTreeLoader.class, new CoreStubTreeLoader());\n    myApplication.registerService(PsiReferenceService.class, new PsiReferenceServiceImpl());\n\n    registerApplicationExtensionPoint(ContentBasedFileSubstitutor.EP_NAME, ContentBasedFileSubstitutor.class);\n    registerExtensionPoint(Extensions.getRootArea(), BinaryFileStubBuilders.EP_NAME, FileTypeExtensionPoint.class);\n\n    ProgressIndicatorProvider.ourInstance = createProgressIndicatorProvider();\n\n    myApplication.registerService(JobLauncher.class, new JobLauncher() {\n      @Override\n      public <T> boolean invokeConcurrentlyUnderProgress(@NotNull List<T> things,\n                                                         ProgressIndicator progress,\n                                                         boolean failFastOnAcquireReadAction,\n                                                         @NotNull Processor<T> thingProcessor) throws ProcessCanceledException {\n        for (T thing : things) {\n          if (!thingProcessor.process(thing))\n            return false;\n        }\n        return true;\n      }\n\n      @Override\n      public Job<Void> submitToJobThread(int priority, @NotNull Runnable action, Consumer<Future> onDoneCallback) {\n        action.run();\n        if (onDoneCallback != null)\n          onDoneCallback.consume(new Future() {\n            @Override\n            public boolean cancel(boolean mayInterruptIfRunning) {\n              return false;\n            }\n\n            @Override\n            public boolean isCancelled() {\n              return false;\n            }\n\n            @Override\n            public boolean isDone() {\n              return true;\n            }\n\n            @Override\n            public Object get() throws InterruptedException, ExecutionException {\n              return null;\n            }\n\n            @Override\n            public Object get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n              return null;\n            }\n          });\n        return null;\n      }\n    });\n\n  }","id":6042,"modified_method":"public CoreApplicationEnvironment(Disposable parentDisposable) {\n    myParentDisposable = parentDisposable;\n    Extensions.cleanRootArea(myParentDisposable);\n\n    myFileTypeRegistry = new CoreFileTypeRegistry();\n    myEncodingRegistry = new CoreEncodingRegistry();\n\n    myApplication = new MockApplication(myParentDisposable);\n    ApplicationManager.setApplication(myApplication,\n                                      new StaticGetter<FileTypeRegistry>(myFileTypeRegistry),\n                                      new StaticGetter<EncodingRegistry>(myEncodingRegistry),\n                                      myParentDisposable);\n    myLocalFileSystem = createLocalFileSystem();\n    myJarFileSystem = createJarFileSystem();\n\n    Extensions.registerAreaClass(ExtensionAreas.IDEA_PROJECT, null);\n\n    final MutablePicoContainer appContainer = myApplication.getPicoContainer();\n    registerComponentInstance(appContainer, FileDocumentManager.class, new MockFileDocumentManagerImpl(new Function<CharSequence, Document>() {\n      @Override\n      public Document fun(CharSequence charSequence) {\n        return new DocumentImpl(charSequence);\n      }\n    }, null));\n\n    registerComponentInstance(appContainer, VirtualFileManager.class,\n                              new VirtualFileManagerImpl(new VirtualFileSystem[] {myLocalFileSystem, myJarFileSystem},\n                                                         new MessageBusImpl(myApplication, null),\n                                                         new FileSystemPersistence() {\n                                                           @Override\n                                                           public void refresh(boolean asynchronous, Runnable postAction, @NotNull ModalityState modalityState) {\n                                                           }\n\n                                                           @Override\n                                                           public int getCheapFileSystemModificationCount() {\n                                                             return 0;\n                                                           }\n                                                         }\n                              )\n    );\n    myApplication.registerService(VirtualFilePointerManager.class, new CoreVirtualFilePointerManager());\n\n    myApplication.registerService(DefaultASTFactory.class, new CoreASTFactory());\n    myApplication.registerService(PsiBuilderFactory.class, new PsiBuilderFactoryImpl());\n    myApplication.registerService(ReferenceProvidersRegistry.class, new MockReferenceProvidersRegistry());\n    myApplication.registerService(StubTreeLoader.class, new CoreStubTreeLoader());\n    myApplication.registerService(PsiReferenceService.class, new PsiReferenceServiceImpl());\n\n    registerApplicationExtensionPoint(ContentBasedFileSubstitutor.EP_NAME, ContentBasedFileSubstitutor.class);\n    registerExtensionPoint(Extensions.getRootArea(), BinaryFileStubBuilders.EP_NAME, FileTypeExtensionPoint.class);\n\n    ProgressIndicatorProvider.ourInstance = createProgressIndicatorProvider();\n\n    myApplication.registerService(JobLauncher.class, new JobLauncher() {\n      @Override\n      public <T> boolean invokeConcurrentlyUnderProgress(@NotNull List<T> things,\n                                                         ProgressIndicator progress,\n                                                         boolean failFastOnAcquireReadAction,\n                                                         @NotNull Processor<T> thingProcessor) throws ProcessCanceledException {\n        for (T thing : things) {\n          if (!thingProcessor.process(thing))\n            return false;\n        }\n        return true;\n      }\n\n      @Override\n      public <T> AsyncFuture<Boolean> invokeConcurrentlyUnderProgressAsync(@NotNull List<T> things,\n                                                                           ProgressIndicator progress,\n                                                                           boolean failFastOnAcquireReadAction,\n                                                                           @NotNull Processor<T> thingProcessor) {\n        final AsyncFutureResult<Boolean> asyncFutureResult = AsyncFutureFactory.getInstance().createAsyncFutureResult();\n        try {\n          final boolean result = invokeConcurrentlyUnderProgress(things, progress, failFastOnAcquireReadAction, thingProcessor);\n          asyncFutureResult.set(result);\n        } catch (Throwable t) {\n          asyncFutureResult.setException(t);\n        }\n        return asyncFutureResult;\n      }\n\n      @Override\n      public Job<Void> submitToJobThread(int priority, @NotNull Runnable action, Consumer<Future> onDoneCallback) {\n        action.run();\n        if (onDoneCallback != null)\n          onDoneCallback.consume(new Future() {\n            @Override\n            public boolean cancel(boolean mayInterruptIfRunning) {\n              return false;\n            }\n\n            @Override\n            public boolean isCancelled() {\n              return false;\n            }\n\n            @Override\n            public boolean isDone() {\n              return true;\n            }\n\n            @Override\n            public Object get() throws InterruptedException, ExecutionException {\n              return null;\n            }\n\n            @Override\n            public Object get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n              return null;\n            }\n          });\n        return null;\n      }\n    });\n\n  }","commit_id":"ed4d538b8fa002648b7c2ee3908a47ff822ec4cf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean processElementsWithWord(@NotNull final TextOccurenceProcessor processor,\n                                         @NotNull SearchScope searchScope,\n                                         @NotNull final String text,\n                                         short searchContext,\n                                         final boolean caseSensitively) {\n    if (text.isEmpty()) {\n      throw new IllegalArgumentException(\"Cannot search for elements with empty text\");\n    }\n    final ProgressIndicator progress = ProgressIndicatorProvider.getGlobalProgressIndicator();\n    if (searchScope instanceof GlobalSearchScope) {\n      StringSearcher searcher = new StringSearcher(text, caseSensitively, true);\n\n      return processElementsWithTextInGlobalScope(processor,\n                                                  (GlobalSearchScope)searchScope,\n                                                  searcher,\n                                                  searchContext, caseSensitively, progress);\n    }\n    else {\n      LocalSearchScope scope = (LocalSearchScope)searchScope;\n      PsiElement[] scopeElements = scope.getScope();\n      final boolean ignoreInjectedPsi = scope.isIgnoreInjectedPsi();\n\n      return JobLauncher.getInstance().invokeConcurrentlyUnderProgress(Arrays.asList(scopeElements), progress, false,\n                                                                       new Processor<PsiElement>() {\n                                                                         @Override\n                                                                         public boolean process(PsiElement scopeElement) {\n                                                                           return processElementsWithWordInScopeElement(scopeElement,\n                                                                                                                        processor, text,\n                                                                                                                        caseSensitively,\n                                                                                                                        ignoreInjectedPsi,\n                                                                                                                        progress);\n                                                                         }\n                                                                       });\n    }\n  }","id":6043,"modified_method":"@Override\n  public boolean processElementsWithWord(@NotNull TextOccurenceProcessor processor,\n                                         @NotNull SearchScope searchScope,\n                                         @NotNull String text,\n                                         short searchContext,\n                                         boolean caseSensitive) {\n    final AsyncFuture<Boolean> result =\n      processElementsWithWordAsync(processor, searchScope, text, searchContext, caseSensitive);\n    return AsyncUtil.get(result);\n  }","commit_id":"ed4d538b8fa002648b7c2ee3908a47ff822ec4cf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean processElementsWithTextInGlobalScope(@NotNull final TextOccurenceProcessor processor,\n                                                       @NotNull final GlobalSearchScope scope,\n                                                       @NotNull final StringSearcher searcher,\n                                                       final short searchContext,\n                                                       final boolean caseSensitively,\n                                                       final ProgressIndicator progress) {\n    LOG.assertTrue(!Thread.holdsLock(PsiLock.LOCK), \"You must not run search from within updating PSI activity. Please consider invokeLatering it instead.\");\n    if (progress != null) {\n      progress.pushState();\n      progress.setText(PsiBundle.message(\"psi.scanning.files.progress\"));\n    }\n\n    String text = searcher.getPattern();\n    List<VirtualFile> fileSet = getFilesWithText(scope, searchContext, caseSensitively, text, progress);\n\n    if (progress != null) {\n      progress.setText(PsiBundle.message(\"psi.search.for.word.progress\", text));\n    }\n\n    try {\n      return processPsiFileRoots(fileSet, new Processor<PsiElement>() {\n        @Override\n        public boolean process(PsiElement psiRoot) {\n          return LowLevelSearchUtil.processElementsContainingWordInElement(processor, psiRoot, searcher, true, progress);\n        }\n      }, progress);\n    }\n    finally {\n      if (progress != null) {\n        progress.popState();\n      }\n    }\n  }","id":6044,"modified_method":"private AsyncFuture<Boolean> processElementsWithTextInGlobalScopeAsync(@NotNull final TextOccurenceProcessor processor,\n                                                       @NotNull final GlobalSearchScope scope,\n                                                       @NotNull final StringSearcher searcher,\n                                                       final short searchContext,\n                                                       final boolean caseSensitively,\n                                                       final ProgressIndicator progress) {\n    LOG.assertTrue(!Thread.holdsLock(PsiLock.LOCK),\n                   \"You must not run search from within updating PSI activity. Please consider invokeLatering it instead.\");\n    if (progress != null) {\n      progress.pushState();\n      progress.setText(PsiBundle.message(\"psi.scanning.files.progress\"));\n    }\n\n    String text = searcher.getPattern();\n    List<VirtualFile> fileSet = getFilesWithText(scope, searchContext, caseSensitively, text, progress);\n\n    if (progress != null) {\n      progress.setText(PsiBundle.message(\"psi.search.for.word.progress\", text));\n    }\n\n      final AsyncFuture<Boolean> result = processPsiFileRootsAsync(fileSet, new Processor<PsiElement>() {\n        @Override\n        public boolean process(PsiElement psiRoot) {\n          return LowLevelSearchUtil.processElementsContainingWordInElement(processor, psiRoot, searcher, true, progress);\n        }\n      }, progress);\n      return new FinallyFuture<Boolean>(result, new Runnable() {\n        @Override\n        public void run() {\n          if (progress != null) {\n            progress.popState();\n          }\n        }\n      });\n  }","commit_id":"ed4d538b8fa002648b7c2ee3908a47ff822ec4cf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean processSingleRequest(@NotNull PsiSearchRequest single, @NotNull Processor<PsiReference> consumer) {\n    return processElementsWithWord(adaptProcessor(single, consumer), single.searchScope, single.word, single.searchContext, single.caseSensitive);\n  }","id":6045,"modified_method":"private boolean processSingleRequest(PsiSearchRequest single, Processor<PsiReference> consumer) {\n    return AsyncUtil.get(processSingleRequestAsync(single, consumer));\n  }","commit_id":"ed4d538b8fa002648b7c2ee3908a47ff822ec4cf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean processGlobalRequestsOptimized(@NotNull MultiMap<Set<IdIndexEntry>, RequestWithProcessor> singles,\n                                                 final ProgressIndicator progress) {\n    if (singles.isEmpty()) {\n      return true;\n    }\n\n    if (singles.size() == 1) {\n      final Collection<RequestWithProcessor> requests = singles.get(singles.keySet().iterator().next());\n      if (requests.size() == 1) {\n        final RequestWithProcessor theOnly = requests.iterator().next();\n        return processSingleRequest(theOnly.request, theOnly.refProcessor);\n      }\n    }\n\n    if (progress != null) {\n      progress.pushState();\n      progress.setText(PsiBundle.message(\"psi.scanning.files.progress\"));\n    }\n\n    final MultiMap<VirtualFile, RequestWithProcessor> candidateFiles = collectFiles(singles, progress);\n\n    try {\n      if (candidateFiles.isEmpty()) {\n        return true;\n      }\n\n      final Map<RequestWithProcessor, StringSearcher> searchers = new HashMap<RequestWithProcessor, StringSearcher>();\n      final Set<String> allWords = new TreeSet<String>();\n      for (RequestWithProcessor singleRequest : candidateFiles.values()) {\n        searchers.put(singleRequest, new StringSearcher(singleRequest.request.word, singleRequest.request.caseSensitive, true));\n        allWords.add(singleRequest.request.word);\n      }\n\n      if (progress != null) {\n        final StringBuilder result = new StringBuilder();\n        for (String string : allWords) {\n          if (string != null && !string.isEmpty()) {\n            if (result.length() > 50) {\n              result.append(\"...\");\n              break;\n            }\n            if (result.length() != 0) result.append(\", \");\n            result.append(string);\n          }\n        }\n        progress.setText(PsiBundle.message(\"psi.search.for.word.progress\", result.toString()));\n      }\n\n      return processPsiFileRoots(new ArrayList<VirtualFile>(candidateFiles.keySet()), new Processor<PsiElement>() {\n                                   @Override\n                                   public boolean process(PsiElement psiRoot) {\n                                     final VirtualFile vfile = psiRoot.getContainingFile().getVirtualFile();\n                                     for (final RequestWithProcessor singleRequest : candidateFiles.get(vfile)) {\n                                       StringSearcher searcher = searchers.get(singleRequest);\n                                       TextOccurenceProcessor adapted = adaptProcessor(singleRequest.request, singleRequest.refProcessor);\n                                       if (!LowLevelSearchUtil.processElementsContainingWordInElement(adapted, psiRoot, searcher, true, progress)) {\n                                         return false;\n                                       }\n                                     }\n                                     return true;\n                                   }\n                                 }, progress);\n    }\n    finally {\n      if (progress != null) {\n        progress.popState();\n      }\n    }\n  }","id":6046,"modified_method":"private boolean processGlobalRequestsOptimized(MultiMap<Set<IdIndexEntry>, RequestWithProcessor> singles,\n                                                 final ProgressIndicator progress) {\n    return AsyncUtil.get(processGlobalRequestsOptimizedAsync(singles, progress));\n  }","commit_id":"ed4d538b8fa002648b7c2ee3908a47ff822ec4cf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean processPsiFileRoots(@NotNull List<VirtualFile> files,\n                                      @NotNull final Processor<PsiElement> psiRootProcessor,\n                                      final ProgressIndicator progress) {\n    myManager.startBatchFilesProcessingMode();\n    try {\n      final AtomicInteger counter = new AtomicInteger(0);\n      final AtomicBoolean canceled = new AtomicBoolean(false);\n      final AtomicBoolean pceThrown = new AtomicBoolean(false);\n\n      final int size = files.size();\n      boolean completed = JobLauncher.getInstance().invokeConcurrentlyUnderProgress(files, progress, false, new Processor<VirtualFile>() {\n        @Override\n        public boolean process(final VirtualFile vfile) {\n          final PsiFile file = ApplicationManager.getApplication().runReadAction(new Computable<PsiFile>() {\n            @Override\n            public PsiFile compute() {\n              return vfile.isValid() ? myManager.findFile(vfile) : null;\n            }\n          });\n          if (file != null && !(file instanceof PsiBinaryFile)) {\n            file.getViewProvider().getContents(); // load contents outside readaction\n            ApplicationManager.getApplication().runReadAction(new Runnable() {\n              @Override\n              public void run() {\n                try {\n                  if (myManager.getProject().isDisposed()) throw new ProcessCanceledException();\n                  List<PsiFile> psiRoots = file.getViewProvider().getAllFiles();\n                  Set<PsiElement> processed = new HashSet<PsiElement>(psiRoots.size() * 2, (float)0.5);\n                  for (PsiElement psiRoot : psiRoots) {\n                    if (progress != null) progress.checkCanceled();\n                    if (!processed.add(psiRoot)) continue;\n                    if (!psiRoot.isValid()) continue;\n                    assert psiRoot != null : \"One of the roots of file \" +\n                                             file +\n                                             \" is null. All roots: \" +\n                                             Arrays.asList(psiRoots) +\n                                             \"; Viewprovider: \" +\n                                             file.getViewProvider() +\n                                             \"; Virtual file: \" +\n                                             file.getViewProvider().getVirtualFile();\n                    if (!psiRootProcessor.process(psiRoot)) {\n                      canceled.set(true);\n                      return;\n                    }\n                  }\n                  myManager.dropResolveCaches();\n                }\n                catch (ProcessCanceledException e) {\n                  canceled.set(true);\n                  pceThrown.set(true);\n                }\n              }\n            });\n          }\n          if (progress != null && progress.isRunning()) {\n            double fraction = (double)counter.incrementAndGet() / size;\n            progress.setFraction(fraction);\n          }\n          return !canceled.get();\n        }\n      });\n\n      if (pceThrown.get()) {\n        throw new ProcessCanceledException();\n      }\n\n      return completed;\n    }\n    finally {\n      myManager.finishBatchFilesProcessingMode();\n    }\n  }","id":6047,"modified_method":"private AsyncFuture<Boolean> processPsiFileRootsAsync(@NotNull List<VirtualFile> files,\n                                      @NotNull final Processor<PsiElement> psiRootProcessor,\n                                      final ProgressIndicator progress) {\n    myManager.startBatchFilesProcessingMode();\n      final AtomicInteger counter = new AtomicInteger(0);\n      final AtomicBoolean canceled = new AtomicBoolean(false);\n      final AtomicBoolean pceThrown = new AtomicBoolean(false);\n\n      final int size = files.size();\n      AsyncFuture<Boolean>\n        completed = JobLauncher.getInstance().invokeConcurrentlyUnderProgressAsync(files, progress, false, new Processor<VirtualFile>() {\n        @Override\n        public boolean process(final VirtualFile vfile) {\n          final PsiFile file = ApplicationManager.getApplication().runReadAction(new Computable<PsiFile>() {\n            @Override\n            public PsiFile compute() {\n              return vfile.isValid() ? myManager.findFile(vfile) : null;\n            }\n          });\n          if (file != null && !(file instanceof PsiBinaryFile)) {\n            file.getViewProvider().getContents(); // load contents outside readaction\n            ApplicationManager.getApplication().runReadAction(new Runnable() {\n              @Override\n              public void run() {\n                try {\n                  if (myManager.getProject().isDisposed()) throw new ProcessCanceledException();\n                  List<PsiFile> psiRoots = file.getViewProvider().getAllFiles();\n                  Set<PsiElement> processed = new HashSet<PsiElement>(psiRoots.size() * 2, (float)0.5);\n                  for (PsiElement psiRoot : psiRoots) {\n                    if (progress != null) progress.checkCanceled();\n                    if (!processed.add(psiRoot)) continue;\n                    if (!psiRoot.isValid()) continue;\n                    assert psiRoot != null : \"One of the roots of file \" +\n                                             file +\n                                             \" is null. All roots: \" +\n                                             Arrays.asList(psiRoots) +\n                                             \"; Viewprovider: \" +\n                                             file.getViewProvider() +\n                                             \"; Virtual file: \" +\n                                             file.getViewProvider().getVirtualFile();\n                    if (!psiRootProcessor.process(psiRoot)) {\n                      canceled.set(true);\n                      return;\n                    }\n                  }\n                  myManager.dropResolveCaches();\n                }\n                catch (ProcessCanceledException e) {\n                  canceled.set(true);\n                  pceThrown.set(true);\n                }\n              }\n            });\n          }\n          if (progress != null && progress.isRunning()) {\n            double fraction = (double)counter.incrementAndGet() / size;\n            progress.setFraction(fraction);\n          }\n          return !canceled.get();\n        }\n      });\n\n      final AsyncFutureResult<Boolean> ourResult = AsyncFutureFactory.getInstance().createAsyncFutureResult();\n      completed.addConsumer(SameThreadExecutor.INSTANCE, new ResultConsumer<Boolean>() {\n        @Override\n        public void onSuccess(Boolean value) {\n          if (pceThrown.get())\n            ourResult.setException(new ProcessCanceledException());\n          else\n            ourResult.set(value);\n        }\n\n        @Override\n        public void onFailure(Throwable t) {\n          ourResult.setException(t);\n        }\n      });\n\n\n      return new FinallyFuture<Boolean>(ourResult, new Runnable() {\n        @Override\n        public void run() {\n          myManager.finishBatchFilesProcessingMode();\n        }\n      });\n  }","commit_id":"ed4d538b8fa002648b7c2ee3908a47ff822ec4cf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * This method is used to convert the service name into a service id. It\n     * first looks up the information from a service map of Eventd and if no\n     * match is found, by performing a lookup in the database. If the conversion\n     * is successful then the corresponding integer identifier will be returned\n     * to the caller.\n     * \n     * @param name\n     *            The name of the service\n     * \n     * @return The integer identifier for the service name.\n     * \n     * @exception java.sql.SQLException\n     *                Thrown if there is an error accessing the stored data or\n     *                the SQL text is malformed. This will also be thrown if the\n     *                result cannot be obtained.\n     * \n     * @see EventdConstants#SQL_DB_SVCNAME_TO_SVCID\n     * \n     */\n    private int getServiceID(String name) throws SQLException {\n        //\n        // Check the name to make sure that it is not null\n        //\n        if (name == null)\n            throw new NullPointerException(\"The service name was null\");\n\n        // ask persistd\n        //\n        int id = Eventd.getServiceID(name);\n        if (id != -1)\n            return id;\n\n        //\n        // talk to the database and get the identifer\n        //\n        m_getSvcIdStmt.setString(1, name);\n        ResultSet rset = null;\n        try {\n            rset = m_getSvcIdStmt.executeQuery();\n            if (rset.next()) {\n                id = rset.getInt(1);\n            }\n\n        } catch (SQLException e) {\n            throw e;\n        } finally {\n            rset.close();\n        }\n\n        // inform persistd about the new find\n        //\n        if (id != -1)\n            Eventd.addServiceMapping(name, id);\n\n        //\n        // return the id to the caller\n        //\n        return id;\n    }","id":6048,"modified_method":"/**\n     * This method is used to convert the service name into a service id. It\n     * first looks up the information from a service map of Eventd and if no\n     * match is found, by performing a lookup in the database. If the conversion\n     * is successful then the corresponding integer identifier will be returned\n     * to the caller.\n     * \n     * @param name\n     *            The name of the service\n     * \n     * @return The integer identifier for the service name.\n     * \n     * @exception java.sql.SQLException\n     *                Thrown if there is an error accessing the stored data or\n     *                the SQL text is malformed. This will also be thrown if the\n     *                result cannot be obtained.\n     * \n     * @see EventdConstants#SQL_DB_SVCNAME_TO_SVCID\n     * \n     */\n    private int getServiceID(String name) throws SQLException {\n        Assert.notNull(name, \"The service name must not be null\");\n\n        // ask persistd\n        int id = Eventd.getServiceID(name);\n        if (id != -1) {\n            return id;\n        }\n\n        // talk to the database and get the identifer\n        m_getSvcIdStmt.setString(1, name);\n        ResultSet rset = null;\n        try {\n            rset = m_getSvcIdStmt.executeQuery();\n            if (rset.next()) {\n                id = rset.getInt(1);\n            }\n        } catch (SQLException e) {\n            throw e;\n        } finally {\n            rset.close();\n        }\n\n        // inform persistd about the new find\n        if (id != -1) {\n            Eventd.addServiceMapping(name, id);\n        }\n\n        return id;\n    }","commit_id":"1eac11e0e8ff29a831c7c017eddddda8743fe1ba","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * @param event\n     * @param log\n     * @return\n     */\n    private java.sql.Timestamp getEventTime(Event event, Category log) {\n        java.sql.Timestamp eventTime = null;\n        try {\n            java.util.Date date = EventConstants.parseToDate(event.getTime());\n            eventTime = new java.sql.Timestamp(date.getTime());\n        } catch (java.text.ParseException pe) {\n            log.warn(\"Failed to convert time \" + event.getTime() + \" to java.sql.Timestamp, Setting current time instead\", pe);\n            eventTime = new java.sql.Timestamp((new java.util.Date()).getTime());\n        }\n        return eventTime;\n    }","id":6049,"modified_method":"/**\n     * @param event\n     * @param log\n     * @return\n     */\n    private Timestamp getEventTime(Event event) {\n        try {\n            return new Timestamp(EventConstants.parseToDate(event.getTime()).getTime());\n        } catch (ParseException e) {\n            log().warn(\"Failed to convert time \" + event.getTime() + \" to Timestamp, setting current time instead.  Exception: \" + e, e);\n            return new Timestamp(System.currentTimeMillis());\n        }\n    }","commit_id":"1eac11e0e8ff29a831c7c017eddddda8743fe1ba","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void insertOrUpdateAlarm(Header eventHeader, Event event) throws SQLException {\n        \n        int alarmId = isReductionNeeded(eventHeader, event);\n        if (alarmId != -1) {\n            log().debug(\"AlarmWriter is reducing event for: \" +event.getDbid()+ \": \"+ event.getUei());\n            updateAlarm(eventHeader, event, alarmId);\n            \n            /*\n             * This removes all previous events that have been reduced.\n             */\n            log().debug(\"insertOrUpdate: auto-clean is: \"+event.getAlarmData().getAutoClean());\n            if (event.getAlarmData().getAutoClean() == true) {\n                log().debug(\"insertOrUpdate: deleting previous events.\");\n                cleanPreviousEvents(alarmId, event.getDbid());\n            }\n            \n        } else {\n            log().debug(\"AlarmWriter is not reducing event for: \" +event.getDbid()+ \": \"+ event.getUei());\n            insertAlarm(eventHeader, event);\n        }\n    }","id":6050,"modified_method":"public void insertOrUpdateAlarm(Header eventHeader, Event event) throws SQLException {\n        int alarmId = isReductionNeeded(eventHeader, event);\n        if (alarmId != -1) {\n            if (log().isDebugEnabled()) {\n                log().debug(\"Reducing event for: \" + event.getDbid() + \": \" + event.getUei());\n            }\n            updateAlarm(eventHeader, event, alarmId);\n            \n            // This removes all previous events that have been reduced.\n            if (log().isDebugEnabled()) {\n                log().debug(\"insertOrUpdate: auto-clean is: \" + event.getAlarmData().getAutoClean());\n            }\n            if (event.getAlarmData().getAutoClean() == true) {\n                log().debug(\"insertOrUpdate: deleting previous events\");\n                cleanPreviousEvents(alarmId, event.getDbid());\n            }\n            \n        } else {\n            if (log().isDebugEnabled()) {\n                log().debug(\"Not reducing event for: \" + event.getDbid() + \": \" + event.getUei());\n            }\n            insertAlarm(eventHeader, event);\n        }\n    }","commit_id":"1eac11e0e8ff29a831c7c017eddddda8743fe1ba","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Insert values into the ALARMS table\n     * \n     * @exception java.sql.SQLException\n     *                Thrown if there is an error adding the event to the\n     *                database.\n     * @exception java.lang.NullPointerException\n     *                Thrown if a required resource cannot be found in the\n     *                properties file.\n     */\n    private void insertAlarm(Header eventHeader, Event event) throws SQLException {\n        int alarmID = -1;\n        Category log = ThreadCategory.getInstance(AlarmWriter.class);\n        \n        alarmID = getNextId();\n        if (log.isDebugEnabled()) log.debug(\"AlarmWriter: DBID: \"+ alarmID);\n\n        //Column 1, alarmId\n        m_insStmt.setInt(1, alarmID);\n        \n        //Column 2, eventUie\n        m_insStmt.setString(2, Constants.format(event.getUei(), EVENT_UEI_FIELD_SIZE));\n        \n        //Column 3, dpName\n        m_insStmt.setString(3, (eventHeader != null) ? Constants.format(eventHeader.getDpName(), EVENT_DPNAME_FIELD_SIZE) : \"undefined\");\n        \n        // Column 4, nodeID\n        int nodeid = (int) event.getNodeid();\n        m_insStmt.setObject(4, event.hasNodeid() ? new Integer(nodeid) : null);\n        \n        // Column 5, ipaddr\n        m_insStmt.setString(5, event.getInterface());\n        \n        //Column 6, serviceId\n        //\n        // convert the service name to a service id\n        //\n        int svcId = -1;\n        if (event.getService() != null) {\n            try {\n                svcId = getServiceID(event.getService());\n            } catch (SQLException sqlE) {\n                log.warn(\"AlarmWriter.insertAlarm: Error converting service name \\\"\" + event.getService() + \"\\\" to an integer identifier, storing -1\", sqlE);\n            }\n        }\n        m_insStmt.setObject(6, (svcId == -1 ? null : new Integer(svcId)));\n\n        //Column 7, reductionKey\n        m_insStmt.setString(7, event.getAlarmData().getReductionKey());\n        \n        //Column 8, alarmType\n        m_insStmt.setInt(8, event.getAlarmData().getAlarmType());\n        \n        //Column 9, counter\n        m_insStmt.setInt(9, 1);\n        \n        //Column 10, serverity\n        set(m_insStmt, 10, Constants.getSeverity(event.getSeverity()));\n\n        //Column 11, lastEventId\n        m_insStmt.setInt(11, event.getDbid());\n        \n        //Column 12, firstEventTime\n        java.sql.Timestamp eventTime = getEventTime(event, log);\n        m_insStmt.setTimestamp(12, eventTime);\n        \n        //Column 13, lastEventTime\n        m_insStmt.setTimestamp(13, eventTime);\n        \n        //Column 14, description\n        set(m_insStmt, 14, Constants.format(event.getDescr(), EVENT_DESCR_FIELD_SIZE));\n\n        //Column 15, logMsg\n        if (event.getLogmsg() != null) {\n            // set log message\n            set(m_insStmt, 15, Constants.format(event.getLogmsg().getContent(), EVENT_LOGMSG_FIELD_SIZE));\n        } else {\n            m_insStmt.setNull(15, Types.VARCHAR);\n        }\n\n        //Column 16, operInstruct\n        set(m_insStmt, 16, Constants.format(event.getOperinstruct(), EVENT_OPERINSTRUCT_FIELD_SIZE));\n        \n        //Column 17, tticketId\n        //Column 18, tticketState\n        if (event.getTticket() != null) {\n            set(m_insStmt, 17, Constants.format(event.getTticket().getContent(), EVENT_TTICKET_FIELD_SIZE));\n            int ttstate = 0;\n            if (event.getTticket().getState().equals(\"on\"))\n                ttstate = 1;\n            set(m_insStmt, 18, ttstate);\n        } else {\n            m_insStmt.setNull(17, Types.VARCHAR);\n            m_insStmt.setNull(18, Types.INTEGER);\n        }\n\n        //Column 19, mouseOverText\n        set(m_insStmt, 19, Constants.format(event.getMouseovertext(), EVENT_MOUSEOVERTEXT_FIELD_SIZE));\n\n        //Column 20, suppressedUntil\n        set(m_insStmt, 20, eventTime);\n        \n        //Column 21, suppressedUser\n        m_insStmt.setString(21, null);\n        \n        //Column 22, suppressedTime\n        set(m_insStmt, 22, eventTime);\n        \n        //Column 23, alarmAckUser\n        m_insStmt.setString(23, null);\n        \n        //Column 24, alarmAckTime\n        m_insStmt.setTimestamp(24, null);\n        \n        //Column 25, clearUie\n        //Column 26, x733AlarmType\n        //Column 27, x733ProbableCause\n        //Column 28, clearKey\n        if (event.getAlarmData() == null) {\n            m_insStmt.setString(25, null);\n            m_insStmt.setString(26, null);\n            m_insStmt.setInt(27, -1);\n            m_insStmt.setString(28, null);\n        } else {\n            m_insStmt.setString(25, Constants.format(event.getAlarmData().getClearUei(), EVENT_UEI_FIELD_SIZE));\n            m_insStmt.setString(26, Constants.format(event.getAlarmData().getX733AlarmType(), EVENT_X733_ALARMTYPE_SIZE));\n            set(m_insStmt, 27, event.getAlarmData().getX733ProbableCause());\n            set(m_insStmt, 28, event.getAlarmData().getClearKey());\n        }\n        \n        if (log.isDebugEnabled())\n            log.debug(\"m_insStmt is: \"+m_insStmt.toString());\n        \n        m_insStmt.executeUpdate();\n        \n        m_updateEventStmt.setInt(1, alarmID);\n        m_updateEventStmt.setInt(2, event.getDbid());\n        m_updateEventStmt.executeUpdate();\n\n        if (log.isDebugEnabled())\n            log.debug(\"SUCCESSFULLY added \" + event.getUei() + \" related  data into the ALARMS table\");\n   \n    }","id":6051,"modified_method":"/**\n     * Insert values into the ALARMS table\n     * \n     * @exception java.sql.SQLException\n     *                Thrown if there is an error adding the event to the\n     *                database.\n     * @exception java.lang.NullPointerException\n     *                Thrown if a required resource cannot be found in the\n     *                properties file.\n     */\n    private void insertAlarm(Header eventHeader, Event event) throws SQLException {\n        int alarmID = -1;\n        alarmID = getNextId();\n        if (log().isDebugEnabled()) {\n            log().debug(\"AlarmWriter: DBID: \" + alarmID);\n        }\n\n        //Column 1, alarmId\n        m_insStmt.setInt(1, alarmID);\n        \n        //Column 2, eventUie\n        m_insStmt.setString(2, Constants.format(event.getUei(), EVENT_UEI_FIELD_SIZE));\n        \n        //Column 3, dpName\n        m_insStmt.setString(3, (eventHeader != null) ? Constants.format(eventHeader.getDpName(), EVENT_DPNAME_FIELD_SIZE) : \"undefined\");\n        \n        // Column 4, nodeID\n        int nodeid = (int) event.getNodeid();\n        m_insStmt.setObject(4, event.hasNodeid() ? new Integer(nodeid) : null);\n        \n        // Column 5, ipaddr\n        m_insStmt.setString(5, event.getInterface());\n        \n        //Column 6, serviceId\n        //\n        // convert the service name to a service id\n        //\n        int svcId = -1;\n        if (event.getService() != null) {\n            try {\n                svcId = getServiceID(event.getService());\n            } catch (SQLException e) {\n                log().warn(\"insertAlarm: Error converting service name \\\"\" + event.getService() + \"\\\" to an integer identifier, storing -1: \" + e, e);\n            }\n        }\n        m_insStmt.setObject(6, (svcId == -1 ? null : new Integer(svcId)));\n\n        //Column 7, reductionKey\n        m_insStmt.setString(7, event.getAlarmData().getReductionKey());\n        \n        //Column 8, alarmType\n        m_insStmt.setInt(8, event.getAlarmData().getAlarmType());\n        \n        //Column 9, counter\n        m_insStmt.setInt(9, 1);\n        \n        //Column 10, serverity\n        set(m_insStmt, 10, Constants.getSeverity(event.getSeverity()));\n\n        //Column 11, lastEventId\n        m_insStmt.setInt(11, event.getDbid());\n        \n        //Column 12, firstEventTime\n        //Column 13, lastEventTime\n        Timestamp eventTime = getEventTime(event);\n        m_insStmt.setTimestamp(12, eventTime);\n        m_insStmt.setTimestamp(13, eventTime);\n        \n        //Column 14, description\n        set(m_insStmt, 14, Constants.format(event.getDescr(), EVENT_DESCR_FIELD_SIZE));\n\n        //Column 15, logMsg\n        if (event.getLogmsg() != null) {\n            // set log message\n            set(m_insStmt, 15, Constants.format(event.getLogmsg().getContent(), EVENT_LOGMSG_FIELD_SIZE));\n        } else {\n            m_insStmt.setNull(15, Types.VARCHAR);\n        }\n\n        //Column 16, operInstruct\n        set(m_insStmt, 16, Constants.format(event.getOperinstruct(), EVENT_OPERINSTRUCT_FIELD_SIZE));\n        \n        //Column 17, tticketId\n        //Column 18, tticketState\n        if (event.getTticket() != null) {\n            set(m_insStmt, 17, Constants.format(event.getTticket().getContent(), EVENT_TTICKET_FIELD_SIZE));\n            int ttstate = 0;\n            if (event.getTticket().getState().equals(\"on\")) {\n                ttstate = 1;\n            }\n            set(m_insStmt, 18, ttstate);\n        } else {\n            m_insStmt.setNull(17, Types.VARCHAR);\n            m_insStmt.setNull(18, Types.INTEGER);\n        }\n\n        //Column 19, mouseOverText\n        set(m_insStmt, 19, Constants.format(event.getMouseovertext(), EVENT_MOUSEOVERTEXT_FIELD_SIZE));\n\n        //Column 20, suppressedUntil\n        set(m_insStmt, 20, eventTime);\n        \n        //Column 21, suppressedUser\n        m_insStmt.setString(21, null);\n        \n        //Column 22, suppressedTime\n        set(m_insStmt, 22, eventTime);\n        \n        //Column 23, alarmAckUser\n        m_insStmt.setString(23, null);\n        \n        //Column 24, alarmAckTime\n        m_insStmt.setTimestamp(24, null);\n        \n        //Column 25, clearUie\n        //Column 26, x733AlarmType\n        //Column 27, x733ProbableCause\n        //Column 28, clearKey\n        if (event.getAlarmData() == null) {\n            m_insStmt.setString(25, null);\n            m_insStmt.setString(26, null);\n            m_insStmt.setInt(27, -1);\n            m_insStmt.setString(28, null);\n        } else {\n            m_insStmt.setString(25, Constants.format(event.getAlarmData().getClearUei(), EVENT_UEI_FIELD_SIZE));\n            m_insStmt.setString(26, Constants.format(event.getAlarmData().getX733AlarmType(), EVENT_X733_ALARMTYPE_SIZE));\n            set(m_insStmt, 27, event.getAlarmData().getX733ProbableCause());\n            set(m_insStmt, 28, event.getAlarmData().getClearKey());\n        }\n        \n        if (log().isDebugEnabled()) {\n            log().debug(\"m_insStmt is: \" + m_insStmt.toString());\n        }\n        \n        m_insStmt.executeUpdate();\n        \n        m_updateEventStmt.setInt(1, alarmID);\n        m_updateEventStmt.setInt(2, event.getDbid());\n        m_updateEventStmt.executeUpdate();\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"SUCCESSFULLY added \" + event.getUei() + \" related  data into the ALARMS table\");\n        }\n   \n    }","commit_id":"1eac11e0e8ff29a831c7c017eddddda8743fe1ba","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is used to convert the event host into a hostname id by\n     * performing a lookup in the database. If the conversion is successful then\n     * the corresponding hosname will be returned to the caller.\n     * \n     * @param hostip\n     *            The event host\n     * \n     * @return The hostname\n     * \n     * @exception java.sql.SQLException\n     *                Thrown if there is an error accessing the stored data or\n     *                the SQL text is malformed.\n     * \n     * @see EventdConstants#SQL_DB_HOSTIP_TO_HOSTNAME\n     * \n     */\n    private String getHostName(String hostip) throws SQLException {\n\n        //\n        // talk to the database and get the identifer\n        //\n        String hostname = hostip;\n\n        m_getHostNameStmt.setString(1, hostip);\n        ResultSet rset = null;\n        \n        try {\n            rset = m_getHostNameStmt.executeQuery();\n            if (rset.next()) {\n                hostname = rset.getString(1);\n            }\n\n        } catch (SQLException e) {\n            throw e;\n        } finally {\n            rset.close();\n        }\n\n        // hostname can be null - if it is, return the ip\n        //\n        if (hostname == null)\n            hostname = hostip;\n\n        //\n        // return the hostname to the caller\n        //\n        return hostname;\n    }","id":6052,"modified_method":"/**\n     * This method is used to convert the event host into a hostname id by\n     * performing a lookup in the database. If the conversion is successful then\n     * the corresponding hosname will be returned to the caller.\n     * \n     * @param hostip\n     *            The event host\n     * \n     * @return The hostname\n     * \n     * @exception java.sql.SQLException\n     *                Thrown if there is an error accessing the stored data or\n     *                the SQL text is malformed.\n     * \n     * @see EventdConstants#SQL_DB_HOSTIP_TO_HOSTNAME\n     * \n     */\n    private String getHostName(String hostip) throws SQLException {\n        // talk to the database and get the identifer\n        String hostname = hostip;\n\n        m_getHostNameStmt.setString(1, hostip);\n        ResultSet rset = null;\n        \n        try {\n            rset = m_getHostNameStmt.executeQuery();\n            if (rset.next()) {\n                hostname = rset.getString(1);\n            }\n        } catch (SQLException e) {\n            throw e;\n        } finally {\n            rset.close();\n        }\n\n        // hostname can be null - if it is, return the ip\n        if (hostname == null) {\n            hostname = hostip;\n        }\n\n        return hostname;\n    }","commit_id":"1eac11e0e8ff29a831c7c017eddddda8743fe1ba","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Close all the connection statements\n     */\n    public void close() {\n        try {\n            m_dsConn.close();\n        } catch (SQLException e) {\n            ThreadCategory.getInstance(EventWriter.class).warn(\"SQLException while closing database connection\", e);\n        }\n    }","id":6053,"modified_method":"/**\n     * Close all the connection statements\n     */\n    public void close() {\n        try {\n            m_dsConn.close();\n        } catch (SQLException e) {\n            log().warn(\"SQLException while closing database connection\", e);\n        }\n    }","commit_id":"1eac11e0e8ff29a831c7c017eddddda8743fe1ba","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void cleanPreviousEvents(int alarmId, int eventId) {\n        PreparedStatement stmt = null;\n        try {\n            stmt = m_dsConn.prepareStatement(\"DELETE FROM events WHERE alarmId = ? AND eventId != ?\");\n            stmt.setInt(1, alarmId);\n            stmt.setInt(2, eventId);\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            log().error(\"cleanPreviousEvents: Couldn't remove old events.\", e);\n        }\n\n        try {\n            stmt.close();\n        } catch (SQLException e) {\n            log().error(\"cleanPreviousEvents: Couldn't close statement.\", e);\n        }\n    }","id":6054,"modified_method":"private void cleanPreviousEvents(int alarmId, int eventId) {\n        PreparedStatement stmt = null;\n        try {\n            stmt = m_dsConn.prepareStatement(\"DELETE FROM events WHERE alarmId = ? AND eventId != ?\");\n            stmt.setInt(1, alarmId);\n            stmt.setInt(2, eventId);\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            log().error(\"cleanPreviousEvents: Couldn't remove old events: \" + e, e);\n        }\n\n        try {\n            stmt.close();\n        } catch (SQLException e) {\n            log().error(\"cleanPreviousEvents: Couldn't close statement: \" + e, e);\n        }\n    }","commit_id":"1eac11e0e8ff29a831c7c017eddddda8743fe1ba","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Insert values into the EVENTS table\n     * \n     * @exception java.sql.SQLException\n     *                Thrown if there is an error adding the event to the\n     *                database.\n     * @exception java.lang.NullPointerException\n     *                Thrown if a required resource cannot be found in the\n     *                properties file.\n     */\n    protected void insertEvent(Header eventHeader, Event event) throws SQLException {\n        Category log = ThreadCategory.getInstance(EventWriter.class);\n\n        // events next id from sequence\n        //\n        // Execute the statement to get the next event id\n        //\n        int eventID = getNextId();\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"EventWriter: DBID: \" + eventID);\n        }\n\n        synchronized (event) {\n            event.setDbid(eventID);\n        }\n\n        //\n        // Set up the sql information now\n        //\n\n        // eventID\n        m_insStmt.setInt(1, eventID);\n\n        // eventUEI\n        m_insStmt.setString(2, Constants.format(event.getUei(), EVENT_UEI_FIELD_SIZE));\n\n        // nodeID\n        int nodeid = (int) event.getNodeid();\n        set(m_insStmt, 3, event.hasNodeid() ? nodeid : -1);\n\n        // eventTime\n        java.sql.Timestamp eventTime = getEventTime(event, log);\n        m_insStmt.setTimestamp(4, eventTime);\n        \n        //\n        // Resolve the event host to a hostname using\n        // the ipinterface table\n        //\n        String hostname = getEventHost(event);\n\n        // eventHost\n        set(m_insStmt, 5, Constants.format(hostname, EVENT_HOST_FIELD_SIZE));\n\n        // ipAddr\n        set(m_insStmt, 6, Constants.format(event.getInterface(), EVENT_INTERFACE_FIELD_SIZE));\n\n        // eventDpName\n        m_insStmt.setString(7, (eventHeader != null) ? Constants.format(eventHeader.getDpName(), EVENT_DPNAME_FIELD_SIZE) : \"undefined\");\n\n        // eventSnmpHost\n        set(m_insStmt, 8, Constants.format(event.getSnmphost(), EVENT_SNMPHOST_FIELD_SIZE));\n\n        //\n        // convert the service name to a service id\n        //\n        int svcId = getEventServiceId(event, log);\n\n        // service identifier\n        set(m_insStmt, 9, svcId);\n\n        // eventSnmp\n        if (event.getSnmp() != null)\n            m_insStmt.setString(10, SnmpInfo.format(event.getSnmp(), EVENT_SNMP_FIELD_SIZE));\n        else\n            m_insStmt.setNull(10, Types.VARCHAR);\n\n        // eventParms\n\n        //Replace any null bytes with a space, otherwise postgres will complain about encoding in UNICODE \n        String parametersString=(event.getParms() != null) ? Parameter.format(event.getParms()) : null;\n        if(parametersString!=null) {\n            parametersString=parametersString.replace((char)0, ' ');\n        }\n        \n        set(m_insStmt, 11, parametersString);\n\n        // grab the ifIndex out of the parms if it is defined   \n        if (event.getIfIndex() != null) {\n            if (event.getParms() != null) {\n                Parameter.format(event.getParms());\n            }\n        }\n\n        // eventCreateTime\n        java.sql.Timestamp eventCreateTime = new java.sql.Timestamp((new java.util.Date()).getTime());\n        m_insStmt.setTimestamp(12, eventCreateTime);\n\n        // eventDescr\n        set(m_insStmt, 13, Constants.format(event.getDescr(), EVENT_DESCR_FIELD_SIZE));\n\n        // eventLoggroup\n        set(m_insStmt, 14, (event.getLoggroupCount() > 0) ? Constants.format(event.getLoggroup(), EVENT_LOGGRP_FIELD_SIZE) : null);\n\n        // eventLogMsg\n        // eventLog\n        // eventDisplay\n        if (event.getLogmsg() != null) {\n            // set log message\n            set(m_insStmt, 15, Constants.format(event.getLogmsg().getContent(), EVENT_LOGMSG_FIELD_SIZE));\n            String logdest = event.getLogmsg().getDest();\n            // if 'logndisplay' set both log and display\n            // column to yes\n            if (logdest.equals(\"logndisplay\")) {\n                set(m_insStmt, 16, MSG_YES);\n                set(m_insStmt, 17, MSG_YES);\n            }\n            // if 'logonly' set log column to true\n            else if (logdest.equals(\"logonly\")) {\n                set(m_insStmt, 16, MSG_YES);\n                set(m_insStmt, 17, MSG_NO);\n            }\n            // if 'displayonly' set display column to true\n            else if (logdest.equals(\"displayonly\")) {\n                set(m_insStmt, 16, MSG_NO);\n                set(m_insStmt, 17, MSG_YES);\n            }\n            // if 'suppress' set both log and display to false\n            else if (logdest.equals(\"suppress\")) {\n                set(m_insStmt, 16, MSG_NO);\n                set(m_insStmt, 17, MSG_NO);\n            }\n        } else {\n            m_insStmt.setNull(15, Types.VARCHAR);\n\n            // If this is an event that had no match in the event conf\n            // mark it as to be logged and displayed so that there\n            // are no events that slip through the system\n            // without the user knowing about them\n\n            set(m_insStmt, 16, MSG_YES);\n            set(m_insStmt, 17, MSG_YES);\n        }\n\n        // eventSeverity\n        set(m_insStmt, 18, Constants.getSeverity(event.getSeverity()));\n\n        // eventPathOutage\n        set(m_insStmt, 19, (event.getPathoutage() != null) ? Constants.format(event.getPathoutage(), EVENT_PATHOUTAGE_FIELD_SIZE) : null);\n\n        // eventCorrelation\n        set(m_insStmt, 20, (event.getCorrelation() != null) ? org.opennms.netmgt.eventd.db.Correlation.format(event.getCorrelation(), EVENT_CORRELATION_FIELD_SIZE) : null);\n\n        // eventSuppressedCount\n        m_insStmt.setNull(21, Types.INTEGER);\n\n        // eventOperInstruct\n        set(m_insStmt, 22, Constants.format(event.getOperinstruct(), EVENT_OPERINSTRUCT_FIELD_SIZE));\n\n        // eventAutoAction\n        set(m_insStmt, 23, (event.getAutoactionCount() > 0) ? AutoAction.format(event.getAutoaction(), EVENT_AUTOACTION_FIELD_SIZE) : null);\n\n        // eventOperAction / eventOperActionMenuText\n        if (event.getOperactionCount() > 0) {\n            List a = new ArrayList();\n            List b = new ArrayList();\n\n            Enumeration en = event.enumerateOperaction();\n            while (en.hasMoreElements()) {\n                Operaction eoa = (Operaction) en.nextElement();\n                a.add(eoa);\n                b.add(eoa.getMenutext());\n            }\n\n            set(m_insStmt, 24, OperatorAction.format(a, EVENT_OPERACTION_FIELD_SIZE));\n            set(m_insStmt, 25, Constants.format(b, EVENT_OPERACTION_MENU_FIELD_SIZE));\n        } else {\n            m_insStmt.setNull(24, Types.VARCHAR);\n            m_insStmt.setNull(25, Types.VARCHAR);\n        }\n\n        // eventNotification, this column no longer needed\n        m_insStmt.setNull(26, Types.VARCHAR);\n\n        // eventTroubleTicket / eventTroubleTicket state\n        if (event.getTticket() != null) {\n            set(m_insStmt, 27, Constants.format(event.getTticket().getContent(), EVENT_TTICKET_FIELD_SIZE));\n            int ttstate = 0;\n            if (event.getTticket().getState().equals(\"on\"))\n                ttstate = 1;\n\n            set(m_insStmt, 28, ttstate);\n        } else {\n            m_insStmt.setNull(27, Types.VARCHAR);\n            m_insStmt.setNull(28, Types.INTEGER);\n        }\n\n        // eventForward\n        set(m_insStmt, 29, (event.getForwardCount() > 0) ? org.opennms.netmgt.eventd.db.Forward.format(event.getForward(), EVENT_FORWARD_FIELD_SIZE) : null);\n\n        // event mouseOverText\n        set(m_insStmt, 30, Constants.format(event.getMouseovertext(), EVENT_MOUSEOVERTEXT_FIELD_SIZE));\n\n        // eventAckUser\n        if (event.getAutoacknowledge() != null && event.getAutoacknowledge().getState().equals(\"on\")) {\n\n            set(m_insStmt, 31, Constants.format(event.getAutoacknowledge().getContent(), EVENT_ACKUSER_FIELD_SIZE));\n\n            // eventAckTime - if autoacknowledge is present,\n            // set time to event create time\n            set(m_insStmt, 32, eventCreateTime);\n        } else {\n            m_insStmt.setNull(31, Types.INTEGER);\n            m_insStmt.setNull(32, Types.TIMESTAMP);\n        }\n\n        // eventSource\n        set(m_insStmt, 33, Constants.format(event.getSource(), EVENT_SOURCE_FIELD_SIZE));\n\n        // execute\n        m_insStmt.executeUpdate();\n\n        if (log.isDebugEnabled())\n            log.debug(\"SUCCESSFULLY added \" + event.getUei() + \" related  data into the EVENTS table\");\n    }","id":6055,"modified_method":"/**\n     * Insert values into the EVENTS table\n     * \n     * @exception java.sql.SQLException\n     *                Thrown if there is an error adding the event to the\n     *                database.\n     * @exception java.lang.NullPointerException\n     *                Thrown if a required resource cannot be found in the\n     *                properties file.\n     */\n    protected void insertEvent(Header eventHeader, Event event) throws SQLException {\n        // Execute the statement to get the next event id\n        int eventID = getNextId();\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"EventWriter: DBID: \" + eventID);\n        }\n\n        synchronized (event) {\n            event.setDbid(eventID);\n        }\n\n        // Set up the sql information now\n\n        // eventID\n        m_insStmt.setInt(1, eventID);\n\n        // eventUEI\n        m_insStmt.setString(2, Constants.format(event.getUei(), EVENT_UEI_FIELD_SIZE));\n\n        // nodeID\n        int nodeid = (int) event.getNodeid();\n        set(m_insStmt, 3, event.hasNodeid() ? nodeid : -1);\n\n        // eventTime\n        m_insStmt.setTimestamp(4, getEventTime(event));\n        \n        // Resolve the event host to a hostname using the ipInterface table\n        String hostname = getEventHost(event);\n\n        // eventHost\n        set(m_insStmt, 5, Constants.format(hostname, EVENT_HOST_FIELD_SIZE));\n\n        // ipAddr\n        set(m_insStmt, 6, Constants.format(event.getInterface(), EVENT_INTERFACE_FIELD_SIZE));\n\n        // eventDpName\n        m_insStmt.setString(7, (eventHeader != null) ? Constants.format(eventHeader.getDpName(), EVENT_DPNAME_FIELD_SIZE) : \"undefined\");\n\n        // eventSnmpHost\n        set(m_insStmt, 8, Constants.format(event.getSnmphost(), EVENT_SNMPHOST_FIELD_SIZE));\n\n        // service identifier - convert the service name to a service id\n        set(m_insStmt, 9, getEventServiceId(event));\n\n        // eventSnmp\n        if (event.getSnmp() != null) {\n            m_insStmt.setString(10, SnmpInfo.format(event.getSnmp(), EVENT_SNMP_FIELD_SIZE));\n        } else {\n            m_insStmt.setNull(10, Types.VARCHAR);\n        }\n\n        // eventParms\n\n        // Replace any null bytes with a space, otherwise postgres will complain about encoding in UNICODE \n        String parametersString=(event.getParms() != null) ? Parameter.format(event.getParms()) : null;\n        if (parametersString != null) {\n            parametersString=parametersString.replace((char)0, ' ');\n        }\n        \n        set(m_insStmt, 11, parametersString);\n\n        // grab the ifIndex out of the parms if it is defined   \n        if (event.getIfIndex() != null) {\n            if (event.getParms() != null) {\n                Parameter.format(event.getParms());\n            }\n        }\n\n        // eventCreateTime\n        Timestamp eventCreateTime = new Timestamp(System.currentTimeMillis());\n        m_insStmt.setTimestamp(12, eventCreateTime);\n\n        // eventDescr\n        set(m_insStmt, 13, Constants.format(event.getDescr(), EVENT_DESCR_FIELD_SIZE));\n\n        // eventLoggroup\n        set(m_insStmt, 14, (event.getLoggroupCount() > 0) ? Constants.format(event.getLoggroup(), EVENT_LOGGRP_FIELD_SIZE) : null);\n\n        // eventLogMsg\n        // eventLog\n        // eventDisplay\n        if (event.getLogmsg() != null) {\n            // set log message\n            set(m_insStmt, 15, Constants.format(event.getLogmsg().getContent(), EVENT_LOGMSG_FIELD_SIZE));\n            String logdest = event.getLogmsg().getDest();\n            if (logdest.equals(\"logndisplay\")) {\n                // if 'logndisplay' set both log and display column to yes\n                set(m_insStmt, 16, MSG_YES);\n                set(m_insStmt, 17, MSG_YES);\n            } else if (logdest.equals(\"logonly\")) {\n                // if 'logonly' set log column to true\n                set(m_insStmt, 16, MSG_YES);\n                set(m_insStmt, 17, MSG_NO);\n            } else if (logdest.equals(\"displayonly\")) {\n                // if 'displayonly' set display column to true\n                set(m_insStmt, 16, MSG_NO);\n                set(m_insStmt, 17, MSG_YES);\n            } else if (logdest.equals(\"suppress\")) {\n                // if 'suppress' set both log and display to false\n                set(m_insStmt, 16, MSG_NO);\n                set(m_insStmt, 17, MSG_NO);\n            }\n        } else {\n            m_insStmt.setNull(15, Types.VARCHAR);\n\n            /*\n             * If this is an event that had no match in the event conf\n             * mark it as to be logged and displayed so that there\n             * are no events that slip through the system\n             * without the user knowing about them\n             */\n            set(m_insStmt, 17, MSG_YES);\n        }\n\n        // eventSeverity\n        set(m_insStmt, 18, Constants.getSeverity(event.getSeverity()));\n\n        // eventPathOutage\n        set(m_insStmt, 19, (event.getPathoutage() != null) ? Constants.format(event.getPathoutage(), EVENT_PATHOUTAGE_FIELD_SIZE) : null);\n\n        // eventCorrelation\n        set(m_insStmt, 20, (event.getCorrelation() != null) ? org.opennms.netmgt.eventd.db.Correlation.format(event.getCorrelation(), EVENT_CORRELATION_FIELD_SIZE) : null);\n\n        // eventSuppressedCount\n        m_insStmt.setNull(21, Types.INTEGER);\n\n        // eventOperInstruct\n        set(m_insStmt, 22, Constants.format(event.getOperinstruct(), EVENT_OPERINSTRUCT_FIELD_SIZE));\n\n        // eventAutoAction\n        set(m_insStmt, 23, (event.getAutoactionCount() > 0) ? AutoAction.format(event.getAutoaction(), EVENT_AUTOACTION_FIELD_SIZE) : null);\n\n        // eventOperAction / eventOperActionMenuText\n        if (event.getOperactionCount() > 0) {\n            List<Operaction> a = new ArrayList<Operaction>();\n            List<String> b = new ArrayList<String>();\n\n            for (Operaction eoa : event.getOperactionCollection()) {\n                a.add(eoa);\n                b.add(eoa.getMenutext());\n            }\n\n            set(m_insStmt, 24, OperatorAction.format(a, EVENT_OPERACTION_FIELD_SIZE));\n            set(m_insStmt, 25, Constants.format(b, EVENT_OPERACTION_MENU_FIELD_SIZE));\n        } else {\n            m_insStmt.setNull(24, Types.VARCHAR);\n            m_insStmt.setNull(25, Types.VARCHAR);\n        }\n\n        // eventNotification, this column no longer needed\n        m_insStmt.setNull(26, Types.VARCHAR);\n\n        // eventTroubleTicket / eventTroubleTicket state\n        if (event.getTticket() != null) {\n            set(m_insStmt, 27, Constants.format(event.getTticket().getContent(), EVENT_TTICKET_FIELD_SIZE));\n            int ttstate = 0;\n            if (event.getTticket().getState().equals(\"on\")) {\n                ttstate = 1;\n            }\n\n            set(m_insStmt, 28, ttstate);\n        } else {\n            m_insStmt.setNull(27, Types.VARCHAR);\n            m_insStmt.setNull(28, Types.INTEGER);\n        }\n\n        // eventForward\n        set(m_insStmt, 29, (event.getForwardCount() > 0) ? org.opennms.netmgt.eventd.db.Forward.format(event.getForward(), EVENT_FORWARD_FIELD_SIZE) : null);\n\n        // event mouseOverText\n        set(m_insStmt, 30, Constants.format(event.getMouseovertext(), EVENT_MOUSEOVERTEXT_FIELD_SIZE));\n\n        // eventAckUser\n        if (event.getAutoacknowledge() != null && event.getAutoacknowledge().getState().equals(\"on\")) {\n            set(m_insStmt, 31, Constants.format(event.getAutoacknowledge().getContent(), EVENT_ACKUSER_FIELD_SIZE));\n\n            // eventAckTime - if autoacknowledge is present,\n            // set time to event create time\n            set(m_insStmt, 32, eventCreateTime);\n        } else {\n            m_insStmt.setNull(31, Types.INTEGER);\n            m_insStmt.setNull(32, Types.TIMESTAMP);\n        }\n\n        // eventSource\n        set(m_insStmt, 33, Constants.format(event.getSource(), EVENT_SOURCE_FIELD_SIZE));\n\n        // execute\n        m_insStmt.executeUpdate();\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"SUCCESSFULLY added \" + event.getUei() + \" related  data into the EVENTS table\");\n        }\n    }","commit_id":"1eac11e0e8ff29a831c7c017eddddda8743fe1ba","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * @param event\n     * @param log\n     * @return\n     */\n    private int getEventServiceId(Event event, Category log) {\n        int svcId = -1;\n        if (event.getService() != null) {\n            try {\n                svcId = getServiceID(event.getService());\n            } catch (SQLException sqlE) {\n                log.warn(\"EventWriter.add: Error converting service name \\\"\" + event.getService() + \"\\\" to an integer identifier, storing -1\", sqlE);\n            }\n        }\n        return svcId;\n    }","id":6056,"modified_method":"/**\n     * @param event\n     * @param log\n     * @return\n     */\n    private int getEventServiceId(Event event) {\n        int svcId = -1;\n        if (event.getService() != null) {\n            try {\n                svcId = getServiceID(event.getService());\n            } catch (SQLException e) {\n                log().warn(\"EventWriter.add: Error converting service name \\\"\" + event.getService() + \"\\\" to an integer identifier, storing -1: e\" + e, e);\n            }\n        }\n        return svcId;\n    }","commit_id":"1eac11e0e8ff29a831c7c017eddddda8743fe1ba","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void updateAlarm(Header eventHeader, Event event, int alarmId) throws SQLException {\n\n        Category log = ThreadCategory.getInstance(Persist.class);\n\n        m_upDateStmt.setInt(1, event.getDbid());\n        \n        java.sql.Timestamp eventTime = getEventTime(event, log);\n        m_upDateStmt.setTimestamp(2, eventTime);\n        m_upDateStmt.setString(3, event.getAlarmData().getReductionKey());\n\n        if (log.isDebugEnabled())\n            log.debug(\"Persist.updateAlarm: reducing event: \"+event.getDbid()+ \"into alarm: \");\n        \n        m_upDateStmt.executeUpdate();\n\n\n        m_updateEventStmt.setInt(1, alarmId);\n        m_updateEventStmt.setInt(2, event.getDbid());\n        m_updateEventStmt.executeUpdate();\n        \n    }","id":6057,"modified_method":"private void updateAlarm(Header eventHeader, Event event, int alarmId) throws SQLException {\n        m_upDateStmt.setInt(1, event.getDbid());\n        m_upDateStmt.setTimestamp(2, getEventTime(event));\n        m_upDateStmt.setString(3, event.getAlarmData().getReductionKey());\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"Persist.updateAlarm: reducing event: \" + event.getDbid() +  \" into alarm\");\n        }\n        \n        m_upDateStmt.executeUpdate();\n\n        m_updateEventStmt.setInt(1, alarmId);\n        m_updateEventStmt.setInt(2, event.getDbid());\n        m_updateEventStmt.executeUpdate();\n    }","commit_id":"1eac11e0e8ff29a831c7c017eddddda8743fe1ba","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Category log() {\n        Category log = ThreadCategory.getInstance(AlarmWriter.class);\n        return log;\n    }","id":6058,"modified_method":"private Category log() {\n        return ThreadCategory.getInstance(getClass());\n    }","commit_id":"1eac11e0e8ff29a831c7c017eddddda8743fe1ba","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Close all the connection statements\n     */\n    public void close() {\n        try {\n            m_dsConn.close();\n        } catch (SQLException e) {\n            ThreadCategory.getInstance(EventWriter.class).warn(\"SQLException while closing database connection\", e);\n        }\n    }","id":6059,"modified_method":"/**\n     * Close all the connection statements\n     */\n    public void close() {\n        try {\n            m_dsConn.close();\n        } catch (SQLException e) {\n            log().warn(\"SQLException while closing database connection\", e);\n        }\n    }","commit_id":"cf46fff9bc89d42d5f23b2da1c2d807e1bcb3b89","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Insert values into the EVENTS table\n     * \n     * @exception java.sql.SQLException\n     *                Thrown if there is an error adding the event to the\n     *                database.\n     * @exception java.lang.NullPointerException\n     *                Thrown if a required resource cannot be found in the\n     *                properties file.\n     */\n    protected void insertEvent(Header eventHeader, Event event) throws SQLException {\n        Category log = ThreadCategory.getInstance(EventWriter.class);\n\n        // events next id from sequence\n        //\n        // Execute the statement to get the next event id\n        //\n        int eventID = getNextId();\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"EventWriter: DBID: \" + eventID);\n        }\n\n        synchronized (event) {\n            event.setDbid(eventID);\n        }\n\n        //\n        // Set up the sql information now\n        //\n\n        // eventID\n        m_insStmt.setInt(1, eventID);\n\n        // eventUEI\n        m_insStmt.setString(2, Constants.format(event.getUei(), EVENT_UEI_FIELD_SIZE));\n\n        // nodeID\n        int nodeid = (int) event.getNodeid();\n        set(m_insStmt, 3, event.hasNodeid() ? nodeid : -1);\n\n        // eventTime\n        java.sql.Timestamp eventTime = getEventTime(event, log);\n        m_insStmt.setTimestamp(4, eventTime);\n        \n        //\n        // Resolve the event host to a hostname using\n        // the ipinterface table\n        //\n        String hostname = getEventHost(event);\n\n        // eventHost\n        set(m_insStmt, 5, Constants.format(hostname, EVENT_HOST_FIELD_SIZE));\n\n        // ipAddr\n        set(m_insStmt, 6, Constants.format(event.getInterface(), EVENT_INTERFACE_FIELD_SIZE));\n\n        // eventDpName\n        m_insStmt.setString(7, (eventHeader != null) ? Constants.format(eventHeader.getDpName(), EVENT_DPNAME_FIELD_SIZE) : \"undefined\");\n\n        // eventSnmpHost\n        set(m_insStmt, 8, Constants.format(event.getSnmphost(), EVENT_SNMPHOST_FIELD_SIZE));\n\n        //\n        // convert the service name to a service id\n        //\n        int svcId = getEventServiceId(event, log);\n\n        // service identifier\n        set(m_insStmt, 9, svcId);\n\n        // eventSnmp\n        if (event.getSnmp() != null)\n            m_insStmt.setString(10, SnmpInfo.format(event.getSnmp(), EVENT_SNMP_FIELD_SIZE));\n        else\n            m_insStmt.setNull(10, Types.VARCHAR);\n\n        // eventParms\n\n        //Replace any null bytes with a space, otherwise postgres will complain about encoding in UNICODE \n        String parametersString=(event.getParms() != null) ? Parameter.format(event.getParms()) : null;\n        if(parametersString!=null) {\n            parametersString=parametersString.replace((char)0, ' ');\n        }\n        \n        set(m_insStmt, 11, parametersString);\n\n        // grab the ifIndex out of the parms if it is defined   \n        if (event.getIfIndex() != null) {\n            if (event.getParms() != null) {\n                Parameter.format(event.getParms());\n            }\n        }\n\n        // eventCreateTime\n        java.sql.Timestamp eventCreateTime = new java.sql.Timestamp((new java.util.Date()).getTime());\n        m_insStmt.setTimestamp(12, eventCreateTime);\n\n        // eventDescr\n        set(m_insStmt, 13, Constants.format(event.getDescr(), EVENT_DESCR_FIELD_SIZE));\n\n        // eventLoggroup\n        set(m_insStmt, 14, (event.getLoggroupCount() > 0) ? Constants.format(event.getLoggroup(), EVENT_LOGGRP_FIELD_SIZE) : null);\n\n        // eventLogMsg\n        // eventLog\n        // eventDisplay\n        if (event.getLogmsg() != null) {\n            // set log message\n            set(m_insStmt, 15, Constants.format(event.getLogmsg().getContent(), EVENT_LOGMSG_FIELD_SIZE));\n            String logdest = event.getLogmsg().getDest();\n            // if 'logndisplay' set both log and display\n            // column to yes\n            if (logdest.equals(\"logndisplay\")) {\n                set(m_insStmt, 16, MSG_YES);\n                set(m_insStmt, 17, MSG_YES);\n            }\n            // if 'logonly' set log column to true\n            else if (logdest.equals(\"logonly\")) {\n                set(m_insStmt, 16, MSG_YES);\n                set(m_insStmt, 17, MSG_NO);\n            }\n            // if 'displayonly' set display column to true\n            else if (logdest.equals(\"displayonly\")) {\n                set(m_insStmt, 16, MSG_NO);\n                set(m_insStmt, 17, MSG_YES);\n            }\n            // if 'suppress' set both log and display to false\n            else if (logdest.equals(\"suppress\")) {\n                set(m_insStmt, 16, MSG_NO);\n                set(m_insStmt, 17, MSG_NO);\n            }\n        } else {\n            m_insStmt.setNull(15, Types.VARCHAR);\n\n            // If this is an event that had no match in the event conf\n            // mark it as to be logged and displayed so that there\n            // are no events that slip through the system\n            // without the user knowing about them\n\n            set(m_insStmt, 16, MSG_YES);\n            set(m_insStmt, 17, MSG_YES);\n        }\n\n        // eventSeverity\n        set(m_insStmt, 18, Constants.getSeverity(event.getSeverity()));\n\n        // eventPathOutage\n        set(m_insStmt, 19, (event.getPathoutage() != null) ? Constants.format(event.getPathoutage(), EVENT_PATHOUTAGE_FIELD_SIZE) : null);\n\n        // eventCorrelation\n        set(m_insStmt, 20, (event.getCorrelation() != null) ? org.opennms.netmgt.eventd.db.Correlation.format(event.getCorrelation(), EVENT_CORRELATION_FIELD_SIZE) : null);\n\n        // eventSuppressedCount\n        m_insStmt.setNull(21, Types.INTEGER);\n\n        // eventOperInstruct\n        set(m_insStmt, 22, Constants.format(event.getOperinstruct(), EVENT_OPERINSTRUCT_FIELD_SIZE));\n\n        // eventAutoAction\n        set(m_insStmt, 23, (event.getAutoactionCount() > 0) ? AutoAction.format(event.getAutoaction(), EVENT_AUTOACTION_FIELD_SIZE) : null);\n\n        // eventOperAction / eventOperActionMenuText\n        if (event.getOperactionCount() > 0) {\n            List a = new ArrayList();\n            List b = new ArrayList();\n\n            Enumeration en = event.enumerateOperaction();\n            while (en.hasMoreElements()) {\n                Operaction eoa = (Operaction) en.nextElement();\n                a.add(eoa);\n                b.add(eoa.getMenutext());\n            }\n\n            set(m_insStmt, 24, OperatorAction.format(a, EVENT_OPERACTION_FIELD_SIZE));\n            set(m_insStmt, 25, Constants.format(b, EVENT_OPERACTION_MENU_FIELD_SIZE));\n        } else {\n            m_insStmt.setNull(24, Types.VARCHAR);\n            m_insStmt.setNull(25, Types.VARCHAR);\n        }\n\n        // eventNotification, this column no longer needed\n        m_insStmt.setNull(26, Types.VARCHAR);\n\n        // eventTroubleTicket / eventTroubleTicket state\n        if (event.getTticket() != null) {\n            set(m_insStmt, 27, Constants.format(event.getTticket().getContent(), EVENT_TTICKET_FIELD_SIZE));\n            int ttstate = 0;\n            if (event.getTticket().getState().equals(\"on\"))\n                ttstate = 1;\n\n            set(m_insStmt, 28, ttstate);\n        } else {\n            m_insStmt.setNull(27, Types.VARCHAR);\n            m_insStmt.setNull(28, Types.INTEGER);\n        }\n\n        // eventForward\n        set(m_insStmt, 29, (event.getForwardCount() > 0) ? org.opennms.netmgt.eventd.db.Forward.format(event.getForward(), EVENT_FORWARD_FIELD_SIZE) : null);\n\n        // event mouseOverText\n        set(m_insStmt, 30, Constants.format(event.getMouseovertext(), EVENT_MOUSEOVERTEXT_FIELD_SIZE));\n\n        // eventAckUser\n        if (event.getAutoacknowledge() != null && event.getAutoacknowledge().getState().equals(\"on\")) {\n\n            set(m_insStmt, 31, Constants.format(event.getAutoacknowledge().getContent(), EVENT_ACKUSER_FIELD_SIZE));\n\n            // eventAckTime - if autoacknowledge is present,\n            // set time to event create time\n            set(m_insStmt, 32, eventCreateTime);\n        } else {\n            m_insStmt.setNull(31, Types.INTEGER);\n            m_insStmt.setNull(32, Types.TIMESTAMP);\n        }\n\n        // eventSource\n        set(m_insStmt, 33, Constants.format(event.getSource(), EVENT_SOURCE_FIELD_SIZE));\n\n        // execute\n        m_insStmt.executeUpdate();\n\n        if (log.isDebugEnabled())\n            log.debug(\"SUCCESSFULLY added \" + event.getUei() + \" related  data into the EVENTS table\");\n    }","id":6060,"modified_method":"/**\n     * Insert values into the EVENTS table\n     * \n     * @exception java.sql.SQLException\n     *                Thrown if there is an error adding the event to the\n     *                database.\n     * @exception java.lang.NullPointerException\n     *                Thrown if a required resource cannot be found in the\n     *                properties file.\n     */\n    protected void insertEvent(Header eventHeader, Event event) throws SQLException {\n        // Execute the statement to get the next event id\n        int eventID = getNextId();\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"EventWriter: DBID: \" + eventID);\n        }\n\n        synchronized (event) {\n            event.setDbid(eventID);\n        }\n\n        // Set up the sql information now\n\n        // eventID\n        m_insStmt.setInt(1, eventID);\n\n        // eventUEI\n        m_insStmt.setString(2, Constants.format(event.getUei(), EVENT_UEI_FIELD_SIZE));\n\n        // nodeID\n        int nodeid = (int) event.getNodeid();\n        set(m_insStmt, 3, event.hasNodeid() ? nodeid : -1);\n\n        // eventTime\n        m_insStmt.setTimestamp(4, getEventTime(event));\n        \n        // Resolve the event host to a hostname using the ipInterface table\n        String hostname = getEventHost(event);\n\n        // eventHost\n        set(m_insStmt, 5, Constants.format(hostname, EVENT_HOST_FIELD_SIZE));\n\n        // ipAddr\n        set(m_insStmt, 6, Constants.format(event.getInterface(), EVENT_INTERFACE_FIELD_SIZE));\n\n        // eventDpName\n        m_insStmt.setString(7, (eventHeader != null) ? Constants.format(eventHeader.getDpName(), EVENT_DPNAME_FIELD_SIZE) : \"undefined\");\n\n        // eventSnmpHost\n        set(m_insStmt, 8, Constants.format(event.getSnmphost(), EVENT_SNMPHOST_FIELD_SIZE));\n\n        // service identifier - convert the service name to a service id\n        set(m_insStmt, 9, getEventServiceId(event));\n\n        // eventSnmp\n        if (event.getSnmp() != null) {\n            m_insStmt.setString(10, SnmpInfo.format(event.getSnmp(), EVENT_SNMP_FIELD_SIZE));\n        } else {\n            m_insStmt.setNull(10, Types.VARCHAR);\n        }\n\n        // eventParms\n\n        // Replace any null bytes with a space, otherwise postgres will complain about encoding in UNICODE \n        String parametersString=(event.getParms() != null) ? Parameter.format(event.getParms()) : null;\n        if (parametersString != null) {\n            parametersString=parametersString.replace((char)0, ' ');\n        }\n        \n        set(m_insStmt, 11, parametersString);\n\n        // grab the ifIndex out of the parms if it is defined   \n        if (event.getIfIndex() != null) {\n            if (event.getParms() != null) {\n                Parameter.format(event.getParms());\n            }\n        }\n\n        // eventCreateTime\n        Timestamp eventCreateTime = new Timestamp(System.currentTimeMillis());\n        m_insStmt.setTimestamp(12, eventCreateTime);\n\n        // eventDescr\n        set(m_insStmt, 13, Constants.format(event.getDescr(), EVENT_DESCR_FIELD_SIZE));\n\n        // eventLoggroup\n        set(m_insStmt, 14, (event.getLoggroupCount() > 0) ? Constants.format(event.getLoggroup(), EVENT_LOGGRP_FIELD_SIZE) : null);\n\n        // eventLogMsg\n        // eventLog\n        // eventDisplay\n        if (event.getLogmsg() != null) {\n            // set log message\n            set(m_insStmt, 15, Constants.format(event.getLogmsg().getContent(), EVENT_LOGMSG_FIELD_SIZE));\n            String logdest = event.getLogmsg().getDest();\n            if (logdest.equals(\"logndisplay\")) {\n                // if 'logndisplay' set both log and display column to yes\n                set(m_insStmt, 16, MSG_YES);\n                set(m_insStmt, 17, MSG_YES);\n            } else if (logdest.equals(\"logonly\")) {\n                // if 'logonly' set log column to true\n                set(m_insStmt, 16, MSG_YES);\n                set(m_insStmt, 17, MSG_NO);\n            } else if (logdest.equals(\"displayonly\")) {\n                // if 'displayonly' set display column to true\n                set(m_insStmt, 16, MSG_NO);\n                set(m_insStmt, 17, MSG_YES);\n            } else if (logdest.equals(\"suppress\")) {\n                // if 'suppress' set both log and display to false\n                set(m_insStmt, 16, MSG_NO);\n                set(m_insStmt, 17, MSG_NO);\n            }\n        } else {\n            m_insStmt.setNull(15, Types.VARCHAR);\n\n            /*\n             * If this is an event that had no match in the event conf\n             * mark it as to be logged and displayed so that there\n             * are no events that slip through the system\n             * without the user knowing about them\n             */\n            set(m_insStmt, 17, MSG_YES);\n        }\n\n        // eventSeverity\n        set(m_insStmt, 18, Constants.getSeverity(event.getSeverity()));\n\n        // eventPathOutage\n        set(m_insStmt, 19, (event.getPathoutage() != null) ? Constants.format(event.getPathoutage(), EVENT_PATHOUTAGE_FIELD_SIZE) : null);\n\n        // eventCorrelation\n        set(m_insStmt, 20, (event.getCorrelation() != null) ? org.opennms.netmgt.eventd.db.Correlation.format(event.getCorrelation(), EVENT_CORRELATION_FIELD_SIZE) : null);\n\n        // eventSuppressedCount\n        m_insStmt.setNull(21, Types.INTEGER);\n\n        // eventOperInstruct\n        set(m_insStmt, 22, Constants.format(event.getOperinstruct(), EVENT_OPERINSTRUCT_FIELD_SIZE));\n\n        // eventAutoAction\n        set(m_insStmt, 23, (event.getAutoactionCount() > 0) ? AutoAction.format(event.getAutoaction(), EVENT_AUTOACTION_FIELD_SIZE) : null);\n\n        // eventOperAction / eventOperActionMenuText\n        if (event.getOperactionCount() > 0) {\n            List<Operaction> a = new ArrayList<Operaction>();\n            List<String> b = new ArrayList<String>();\n\n            for (Operaction eoa : event.getOperactionCollection()) {\n                a.add(eoa);\n                b.add(eoa.getMenutext());\n            }\n\n            set(m_insStmt, 24, OperatorAction.format(a, EVENT_OPERACTION_FIELD_SIZE));\n            set(m_insStmt, 25, Constants.format(b, EVENT_OPERACTION_MENU_FIELD_SIZE));\n        } else {\n            m_insStmt.setNull(24, Types.VARCHAR);\n            m_insStmt.setNull(25, Types.VARCHAR);\n        }\n\n        // eventNotification, this column no longer needed\n        m_insStmt.setNull(26, Types.VARCHAR);\n\n        // eventTroubleTicket / eventTroubleTicket state\n        if (event.getTticket() != null) {\n            set(m_insStmt, 27, Constants.format(event.getTticket().getContent(), EVENT_TTICKET_FIELD_SIZE));\n            int ttstate = 0;\n            if (event.getTticket().getState().equals(\"on\")) {\n                ttstate = 1;\n            }\n\n            set(m_insStmt, 28, ttstate);\n        } else {\n            m_insStmt.setNull(27, Types.VARCHAR);\n            m_insStmt.setNull(28, Types.INTEGER);\n        }\n\n        // eventForward\n        set(m_insStmt, 29, (event.getForwardCount() > 0) ? org.opennms.netmgt.eventd.db.Forward.format(event.getForward(), EVENT_FORWARD_FIELD_SIZE) : null);\n\n        // event mouseOverText\n        set(m_insStmt, 30, Constants.format(event.getMouseovertext(), EVENT_MOUSEOVERTEXT_FIELD_SIZE));\n\n        // eventAckUser\n        if (event.getAutoacknowledge() != null && event.getAutoacknowledge().getState().equals(\"on\")) {\n            set(m_insStmt, 31, Constants.format(event.getAutoacknowledge().getContent(), EVENT_ACKUSER_FIELD_SIZE));\n\n            // eventAckTime - if autoacknowledge is present,\n            // set time to event create time\n            set(m_insStmt, 32, eventCreateTime);\n        } else {\n            m_insStmt.setNull(31, Types.INTEGER);\n            m_insStmt.setNull(32, Types.TIMESTAMP);\n        }\n\n        // eventSource\n        set(m_insStmt, 33, Constants.format(event.getSource(), EVENT_SOURCE_FIELD_SIZE));\n\n        // execute\n        m_insStmt.executeUpdate();\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"SUCCESSFULLY added \" + event.getUei() + \" related  data into the EVENTS table\");\n        }\n    }","commit_id":"cf46fff9bc89d42d5f23b2da1c2d807e1bcb3b89","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is used to convert the event host into a hostname id by\n     * performing a lookup in the database. If the conversion is successful then\n     * the corresponding hosname will be returned to the caller.\n     * \n     * @param hostip\n     *            The event host\n     * \n     * @return The hostname\n     * \n     * @exception java.sql.SQLException\n     *                Thrown if there is an error accessing the stored data or\n     *                the SQL text is malformed.\n     * \n     * @see EventdConstants#SQL_DB_HOSTIP_TO_HOSTNAME\n     * \n     */\n    private String getHostName(String hostip) throws SQLException {\n\n        //\n        // talk to the database and get the identifer\n        //\n        String hostname = hostip;\n\n        m_getHostNameStmt.setString(1, hostip);\n        ResultSet rset = null;\n        \n        try {\n            rset = m_getHostNameStmt.executeQuery();\n            if (rset.next()) {\n                hostname = rset.getString(1);\n            }\n\n        } catch (SQLException e) {\n            throw e;\n        } finally {\n            rset.close();\n        }\n\n        // hostname can be null - if it is, return the ip\n        //\n        if (hostname == null)\n            hostname = hostip;\n\n        //\n        // return the hostname to the caller\n        //\n        return hostname;\n    }","id":6061,"modified_method":"/**\n     * This method is used to convert the event host into a hostname id by\n     * performing a lookup in the database. If the conversion is successful then\n     * the corresponding hosname will be returned to the caller.\n     * \n     * @param hostip\n     *            The event host\n     * \n     * @return The hostname\n     * \n     * @exception java.sql.SQLException\n     *                Thrown if there is an error accessing the stored data or\n     *                the SQL text is malformed.\n     * \n     * @see EventdConstants#SQL_DB_HOSTIP_TO_HOSTNAME\n     * \n     */\n    private String getHostName(String hostip) throws SQLException {\n        // talk to the database and get the identifer\n        String hostname = hostip;\n\n        m_getHostNameStmt.setString(1, hostip);\n        ResultSet rset = null;\n        \n        try {\n            rset = m_getHostNameStmt.executeQuery();\n            if (rset.next()) {\n                hostname = rset.getString(1);\n            }\n        } catch (SQLException e) {\n            throw e;\n        } finally {\n            rset.close();\n        }\n\n        // hostname can be null - if it is, return the ip\n        if (hostname == null) {\n            hostname = hostip;\n        }\n\n        return hostname;\n    }","commit_id":"cf46fff9bc89d42d5f23b2da1c2d807e1bcb3b89","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is used to convert the service name into a service id. It\n     * first looks up the information from a service map of Eventd and if no\n     * match is found, by performing a lookup in the database. If the conversion\n     * is successful then the corresponding integer identifier will be returned\n     * to the caller.\n     * \n     * @param name\n     *            The name of the service\n     * \n     * @return The integer identifier for the service name.\n     * \n     * @exception java.sql.SQLException\n     *                Thrown if there is an error accessing the stored data or\n     *                the SQL text is malformed. This will also be thrown if the\n     *                result cannot be obtained.\n     * \n     * @see EventdConstants#SQL_DB_SVCNAME_TO_SVCID\n     * \n     */\n    private int getServiceID(String name) throws SQLException {\n        //\n        // Check the name to make sure that it is not null\n        //\n        if (name == null)\n            throw new NullPointerException(\"The service name was null\");\n\n        // ask persistd\n        //\n        int id = Eventd.getServiceID(name);\n        if (id != -1)\n            return id;\n\n        //\n        // talk to the database and get the identifer\n        //\n        m_getSvcIdStmt.setString(1, name);\n        ResultSet rset = null;\n        try {\n            rset = m_getSvcIdStmt.executeQuery();\n            if (rset.next()) {\n                id = rset.getInt(1);\n            }\n\n        } catch (SQLException e) {\n            throw e;\n        } finally {\n            rset.close();\n        }\n\n        // inform persistd about the new find\n        //\n        if (id != -1)\n            Eventd.addServiceMapping(name, id);\n\n        //\n        // return the id to the caller\n        //\n        return id;\n    }","id":6062,"modified_method":"/**\n     * This method is used to convert the service name into a service id. It\n     * first looks up the information from a service map of Eventd and if no\n     * match is found, by performing a lookup in the database. If the conversion\n     * is successful then the corresponding integer identifier will be returned\n     * to the caller.\n     * \n     * @param name\n     *            The name of the service\n     * \n     * @return The integer identifier for the service name.\n     * \n     * @exception java.sql.SQLException\n     *                Thrown if there is an error accessing the stored data or\n     *                the SQL text is malformed. This will also be thrown if the\n     *                result cannot be obtained.\n     * \n     * @see EventdConstants#SQL_DB_SVCNAME_TO_SVCID\n     * \n     */\n    private int getServiceID(String name) throws SQLException {\n        Assert.notNull(name, \"The service name must not be null\");\n\n        // ask persistd\n        int id = Eventd.getServiceID(name);\n        if (id != -1) {\n            return id;\n        }\n\n        // talk to the database and get the identifer\n        m_getSvcIdStmt.setString(1, name);\n        ResultSet rset = null;\n        try {\n            rset = m_getSvcIdStmt.executeQuery();\n            if (rset.next()) {\n                id = rset.getInt(1);\n            }\n        } catch (SQLException e) {\n            throw e;\n        } finally {\n            rset.close();\n        }\n\n        // inform persistd about the new find\n        if (id != -1) {\n            Eventd.addServiceMapping(name, id);\n        }\n\n        return id;\n    }","commit_id":"cf46fff9bc89d42d5f23b2da1c2d807e1bcb3b89","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void updateAlarm(Header eventHeader, Event event, int alarmId) throws SQLException {\n\n        Category log = ThreadCategory.getInstance(Persist.class);\n\n        m_upDateStmt.setInt(1, event.getDbid());\n        \n        java.sql.Timestamp eventTime = getEventTime(event, log);\n        m_upDateStmt.setTimestamp(2, eventTime);\n        m_upDateStmt.setString(3, event.getAlarmData().getReductionKey());\n\n        if (log.isDebugEnabled())\n            log.debug(\"Persist.updateAlarm: reducing event: \"+event.getDbid()+ \"into alarm: \");\n        \n        m_upDateStmt.executeUpdate();\n\n\n        m_updateEventStmt.setInt(1, alarmId);\n        m_updateEventStmt.setInt(2, event.getDbid());\n        m_updateEventStmt.executeUpdate();\n        \n    }","id":6063,"modified_method":"private void updateAlarm(Header eventHeader, Event event, int alarmId) throws SQLException {\n        m_upDateStmt.setInt(1, event.getDbid());\n        m_upDateStmt.setTimestamp(2, getEventTime(event));\n        m_upDateStmt.setString(3, event.getAlarmData().getReductionKey());\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"Persist.updateAlarm: reducing event: \" + event.getDbid() +  \" into alarm\");\n        }\n        \n        m_upDateStmt.executeUpdate();\n\n        m_updateEventStmt.setInt(1, alarmId);\n        m_updateEventStmt.setInt(2, event.getDbid());\n        m_updateEventStmt.executeUpdate();\n    }","commit_id":"cf46fff9bc89d42d5f23b2da1c2d807e1bcb3b89","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void insertOrUpdateAlarm(Header eventHeader, Event event) throws SQLException {\n        \n        int alarmId = isReductionNeeded(eventHeader, event);\n        if (alarmId != -1) {\n            log().debug(\"AlarmWriter is reducing event for: \" +event.getDbid()+ \": \"+ event.getUei());\n            updateAlarm(eventHeader, event, alarmId);\n            \n            /*\n             * This removes all previous events that have been reduced.\n             */\n            log().debug(\"insertOrUpdate: auto-clean is: \"+event.getAlarmData().getAutoClean());\n            if (event.getAlarmData().getAutoClean() == true) {\n                log().debug(\"insertOrUpdate: deleting previous events.\");\n                cleanPreviousEvents(alarmId, event.getDbid());\n            }\n            \n        } else {\n            log().debug(\"AlarmWriter is not reducing event for: \" +event.getDbid()+ \": \"+ event.getUei());\n            insertAlarm(eventHeader, event);\n        }\n    }","id":6064,"modified_method":"public void insertOrUpdateAlarm(Header eventHeader, Event event) throws SQLException {\n        int alarmId = isReductionNeeded(eventHeader, event);\n        if (alarmId != -1) {\n            if (log().isDebugEnabled()) {\n                log().debug(\"Reducing event for: \" + event.getDbid() + \": \" + event.getUei());\n            }\n            updateAlarm(eventHeader, event, alarmId);\n            \n            // This removes all previous events that have been reduced.\n            if (log().isDebugEnabled()) {\n                log().debug(\"insertOrUpdate: auto-clean is: \" + event.getAlarmData().getAutoClean());\n            }\n            if (event.getAlarmData().getAutoClean() == true) {\n                log().debug(\"insertOrUpdate: deleting previous events\");\n                cleanPreviousEvents(alarmId, event.getDbid());\n            }\n            \n        } else {\n            if (log().isDebugEnabled()) {\n                log().debug(\"Not reducing event for: \" + event.getDbid() + \": \" + event.getUei());\n            }\n            insertAlarm(eventHeader, event);\n        }\n    }","commit_id":"cf46fff9bc89d42d5f23b2da1c2d807e1bcb3b89","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Insert values into the ALARMS table\n     * \n     * @exception java.sql.SQLException\n     *                Thrown if there is an error adding the event to the\n     *                database.\n     * @exception java.lang.NullPointerException\n     *                Thrown if a required resource cannot be found in the\n     *                properties file.\n     */\n    private void insertAlarm(Header eventHeader, Event event) throws SQLException {\n        int alarmID = -1;\n        Category log = ThreadCategory.getInstance(AlarmWriter.class);\n        \n        alarmID = getNextId();\n        if (log.isDebugEnabled()) log.debug(\"AlarmWriter: DBID: \"+ alarmID);\n\n        //Column 1, alarmId\n        m_insStmt.setInt(1, alarmID);\n        \n        //Column 2, eventUie\n        m_insStmt.setString(2, Constants.format(event.getUei(), EVENT_UEI_FIELD_SIZE));\n        \n        //Column 3, dpName\n        m_insStmt.setString(3, (eventHeader != null) ? Constants.format(eventHeader.getDpName(), EVENT_DPNAME_FIELD_SIZE) : \"undefined\");\n        \n        // Column 4, nodeID\n        int nodeid = (int) event.getNodeid();\n        m_insStmt.setObject(4, event.hasNodeid() ? new Integer(nodeid) : null);\n        \n        // Column 5, ipaddr\n        m_insStmt.setString(5, event.getInterface());\n        \n        //Column 6, serviceId\n        //\n        // convert the service name to a service id\n        //\n        int svcId = -1;\n        if (event.getService() != null) {\n            try {\n                svcId = getServiceID(event.getService());\n            } catch (SQLException sqlE) {\n                log.warn(\"AlarmWriter.insertAlarm: Error converting service name \\\"\" + event.getService() + \"\\\" to an integer identifier, storing -1\", sqlE);\n            }\n        }\n        m_insStmt.setObject(6, (svcId == -1 ? null : new Integer(svcId)));\n\n        //Column 7, reductionKey\n        m_insStmt.setString(7, event.getAlarmData().getReductionKey());\n        \n        //Column 8, alarmType\n        m_insStmt.setInt(8, event.getAlarmData().getAlarmType());\n        \n        //Column 9, counter\n        m_insStmt.setInt(9, 1);\n        \n        //Column 10, serverity\n        set(m_insStmt, 10, Constants.getSeverity(event.getSeverity()));\n\n        //Column 11, lastEventId\n        m_insStmt.setInt(11, event.getDbid());\n        \n        //Column 12, firstEventTime\n        java.sql.Timestamp eventTime = getEventTime(event, log);\n        m_insStmt.setTimestamp(12, eventTime);\n        \n        //Column 13, lastEventTime\n        m_insStmt.setTimestamp(13, eventTime);\n        \n        //Column 14, description\n        set(m_insStmt, 14, Constants.format(event.getDescr(), EVENT_DESCR_FIELD_SIZE));\n\n        //Column 15, logMsg\n        if (event.getLogmsg() != null) {\n            // set log message\n            set(m_insStmt, 15, Constants.format(event.getLogmsg().getContent(), EVENT_LOGMSG_FIELD_SIZE));\n        } else {\n            m_insStmt.setNull(15, Types.VARCHAR);\n        }\n\n        //Column 16, operInstruct\n        set(m_insStmt, 16, Constants.format(event.getOperinstruct(), EVENT_OPERINSTRUCT_FIELD_SIZE));\n        \n        //Column 17, tticketId\n        //Column 18, tticketState\n        if (event.getTticket() != null) {\n            set(m_insStmt, 17, Constants.format(event.getTticket().getContent(), EVENT_TTICKET_FIELD_SIZE));\n            int ttstate = 0;\n            if (event.getTticket().getState().equals(\"on\"))\n                ttstate = 1;\n            set(m_insStmt, 18, ttstate);\n        } else {\n            m_insStmt.setNull(17, Types.VARCHAR);\n            m_insStmt.setNull(18, Types.INTEGER);\n        }\n\n        //Column 19, mouseOverText\n        set(m_insStmt, 19, Constants.format(event.getMouseovertext(), EVENT_MOUSEOVERTEXT_FIELD_SIZE));\n\n        //Column 20, suppressedUntil\n        set(m_insStmt, 20, eventTime);\n        \n        //Column 21, suppressedUser\n        m_insStmt.setString(21, null);\n        \n        //Column 22, suppressedTime\n        set(m_insStmt, 22, eventTime);\n        \n        //Column 23, alarmAckUser\n        m_insStmt.setString(23, null);\n        \n        //Column 24, alarmAckTime\n        m_insStmt.setTimestamp(24, null);\n        \n        //Column 25, clearUie\n        //Column 26, x733AlarmType\n        //Column 27, x733ProbableCause\n        //Column 28, clearKey\n        if (event.getAlarmData() == null) {\n            m_insStmt.setString(25, null);\n            m_insStmt.setString(26, null);\n            m_insStmt.setInt(27, -1);\n            m_insStmt.setString(28, null);\n        } else {\n            m_insStmt.setString(25, Constants.format(event.getAlarmData().getClearUei(), EVENT_UEI_FIELD_SIZE));\n            m_insStmt.setString(26, Constants.format(event.getAlarmData().getX733AlarmType(), EVENT_X733_ALARMTYPE_SIZE));\n            set(m_insStmt, 27, event.getAlarmData().getX733ProbableCause());\n            set(m_insStmt, 28, event.getAlarmData().getClearKey());\n        }\n        \n        if (log.isDebugEnabled())\n            log.debug(\"m_insStmt is: \"+m_insStmt.toString());\n        \n        m_insStmt.executeUpdate();\n        \n        m_updateEventStmt.setInt(1, alarmID);\n        m_updateEventStmt.setInt(2, event.getDbid());\n        m_updateEventStmt.executeUpdate();\n\n        if (log.isDebugEnabled())\n            log.debug(\"SUCCESSFULLY added \" + event.getUei() + \" related  data into the ALARMS table\");\n   \n    }","id":6065,"modified_method":"/**\n     * Insert values into the ALARMS table\n     * \n     * @exception java.sql.SQLException\n     *                Thrown if there is an error adding the event to the\n     *                database.\n     * @exception java.lang.NullPointerException\n     *                Thrown if a required resource cannot be found in the\n     *                properties file.\n     */\n    private void insertAlarm(Header eventHeader, Event event) throws SQLException {\n        int alarmID = -1;\n        alarmID = getNextId();\n        if (log().isDebugEnabled()) {\n            log().debug(\"AlarmWriter: DBID: \" + alarmID);\n        }\n\n        //Column 1, alarmId\n        m_insStmt.setInt(1, alarmID);\n        \n        //Column 2, eventUie\n        m_insStmt.setString(2, Constants.format(event.getUei(), EVENT_UEI_FIELD_SIZE));\n        \n        //Column 3, dpName\n        m_insStmt.setString(3, (eventHeader != null) ? Constants.format(eventHeader.getDpName(), EVENT_DPNAME_FIELD_SIZE) : \"undefined\");\n        \n        // Column 4, nodeID\n        int nodeid = (int) event.getNodeid();\n        m_insStmt.setObject(4, event.hasNodeid() ? new Integer(nodeid) : null);\n        \n        // Column 5, ipaddr\n        m_insStmt.setString(5, event.getInterface());\n        \n        //Column 6, serviceId\n        //\n        // convert the service name to a service id\n        //\n        int svcId = -1;\n        if (event.getService() != null) {\n            try {\n                svcId = getServiceID(event.getService());\n            } catch (SQLException e) {\n                log().warn(\"insertAlarm: Error converting service name \\\"\" + event.getService() + \"\\\" to an integer identifier, storing -1: \" + e, e);\n            }\n        }\n        m_insStmt.setObject(6, (svcId == -1 ? null : new Integer(svcId)));\n\n        //Column 7, reductionKey\n        m_insStmt.setString(7, event.getAlarmData().getReductionKey());\n        \n        //Column 8, alarmType\n        m_insStmt.setInt(8, event.getAlarmData().getAlarmType());\n        \n        //Column 9, counter\n        m_insStmt.setInt(9, 1);\n        \n        //Column 10, serverity\n        set(m_insStmt, 10, Constants.getSeverity(event.getSeverity()));\n\n        //Column 11, lastEventId\n        m_insStmt.setInt(11, event.getDbid());\n        \n        //Column 12, firstEventTime\n        //Column 13, lastEventTime\n        Timestamp eventTime = getEventTime(event);\n        m_insStmt.setTimestamp(12, eventTime);\n        m_insStmt.setTimestamp(13, eventTime);\n        \n        //Column 14, description\n        set(m_insStmt, 14, Constants.format(event.getDescr(), EVENT_DESCR_FIELD_SIZE));\n\n        //Column 15, logMsg\n        if (event.getLogmsg() != null) {\n            // set log message\n            set(m_insStmt, 15, Constants.format(event.getLogmsg().getContent(), EVENT_LOGMSG_FIELD_SIZE));\n        } else {\n            m_insStmt.setNull(15, Types.VARCHAR);\n        }\n\n        //Column 16, operInstruct\n        set(m_insStmt, 16, Constants.format(event.getOperinstruct(), EVENT_OPERINSTRUCT_FIELD_SIZE));\n        \n        //Column 17, tticketId\n        //Column 18, tticketState\n        if (event.getTticket() != null) {\n            set(m_insStmt, 17, Constants.format(event.getTticket().getContent(), EVENT_TTICKET_FIELD_SIZE));\n            int ttstate = 0;\n            if (event.getTticket().getState().equals(\"on\")) {\n                ttstate = 1;\n            }\n            set(m_insStmt, 18, ttstate);\n        } else {\n            m_insStmt.setNull(17, Types.VARCHAR);\n            m_insStmt.setNull(18, Types.INTEGER);\n        }\n\n        //Column 19, mouseOverText\n        set(m_insStmt, 19, Constants.format(event.getMouseovertext(), EVENT_MOUSEOVERTEXT_FIELD_SIZE));\n\n        //Column 20, suppressedUntil\n        set(m_insStmt, 20, eventTime);\n        \n        //Column 21, suppressedUser\n        m_insStmt.setString(21, null);\n        \n        //Column 22, suppressedTime\n        set(m_insStmt, 22, eventTime);\n        \n        //Column 23, alarmAckUser\n        m_insStmt.setString(23, null);\n        \n        //Column 24, alarmAckTime\n        m_insStmt.setTimestamp(24, null);\n        \n        //Column 25, clearUie\n        //Column 26, x733AlarmType\n        //Column 27, x733ProbableCause\n        //Column 28, clearKey\n        if (event.getAlarmData() == null) {\n            m_insStmt.setString(25, null);\n            m_insStmt.setString(26, null);\n            m_insStmt.setInt(27, -1);\n            m_insStmt.setString(28, null);\n        } else {\n            m_insStmt.setString(25, Constants.format(event.getAlarmData().getClearUei(), EVENT_UEI_FIELD_SIZE));\n            m_insStmt.setString(26, Constants.format(event.getAlarmData().getX733AlarmType(), EVENT_X733_ALARMTYPE_SIZE));\n            set(m_insStmt, 27, event.getAlarmData().getX733ProbableCause());\n            set(m_insStmt, 28, event.getAlarmData().getClearKey());\n        }\n        \n        if (log().isDebugEnabled()) {\n            log().debug(\"m_insStmt is: \" + m_insStmt.toString());\n        }\n        \n        m_insStmt.executeUpdate();\n        \n        m_updateEventStmt.setInt(1, alarmID);\n        m_updateEventStmt.setInt(2, event.getDbid());\n        m_updateEventStmt.executeUpdate();\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"SUCCESSFULLY added \" + event.getUei() + \" related  data into the ALARMS table\");\n        }\n   \n    }","commit_id":"cf46fff9bc89d42d5f23b2da1c2d807e1bcb3b89","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void cleanPreviousEvents(int alarmId, int eventId) {\n        PreparedStatement stmt = null;\n        try {\n            stmt = m_dsConn.prepareStatement(\"DELETE FROM events WHERE alarmId = ? AND eventId != ?\");\n            stmt.setInt(1, alarmId);\n            stmt.setInt(2, eventId);\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            log().error(\"cleanPreviousEvents: Couldn't remove old events.\", e);\n        }\n\n        try {\n            stmt.close();\n        } catch (SQLException e) {\n            log().error(\"cleanPreviousEvents: Couldn't close statement.\", e);\n        }\n    }","id":6066,"modified_method":"private void cleanPreviousEvents(int alarmId, int eventId) {\n        PreparedStatement stmt = null;\n        try {\n            stmt = m_dsConn.prepareStatement(\"DELETE FROM events WHERE alarmId = ? AND eventId != ?\");\n            stmt.setInt(1, alarmId);\n            stmt.setInt(2, eventId);\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            log().error(\"cleanPreviousEvents: Couldn't remove old events: \" + e, e);\n        }\n\n        try {\n            stmt.close();\n        } catch (SQLException e) {\n            log().error(\"cleanPreviousEvents: Couldn't close statement: \" + e, e);\n        }\n    }","commit_id":"cf46fff9bc89d42d5f23b2da1c2d807e1bcb3b89","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * @param event\n     * @param log\n     * @return\n     */\n    private int getEventServiceId(Event event, Category log) {\n        int svcId = -1;\n        if (event.getService() != null) {\n            try {\n                svcId = getServiceID(event.getService());\n            } catch (SQLException sqlE) {\n                log.warn(\"EventWriter.add: Error converting service name \\\"\" + event.getService() + \"\\\" to an integer identifier, storing -1\", sqlE);\n            }\n        }\n        return svcId;\n    }","id":6067,"modified_method":"/**\n     * @param event\n     * @param log\n     * @return\n     */\n    private int getEventServiceId(Event event) {\n        int svcId = -1;\n        if (event.getService() != null) {\n            try {\n                svcId = getServiceID(event.getService());\n            } catch (SQLException e) {\n                log().warn(\"EventWriter.add: Error converting service name \\\"\" + event.getService() + \"\\\" to an integer identifier, storing -1: e\" + e, e);\n            }\n        }\n        return svcId;\n    }","commit_id":"cf46fff9bc89d42d5f23b2da1c2d807e1bcb3b89","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Category log() {\n        Category log = ThreadCategory.getInstance(AlarmWriter.class);\n        return log;\n    }","id":6068,"modified_method":"private Category log() {\n        return ThreadCategory.getInstance(getClass());\n    }","commit_id":"cf46fff9bc89d42d5f23b2da1c2d807e1bcb3b89","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * @param event\n     * @param log\n     * @return\n     */\n    private java.sql.Timestamp getEventTime(Event event, Category log) {\n        java.sql.Timestamp eventTime = null;\n        try {\n            java.util.Date date = EventConstants.parseToDate(event.getTime());\n            eventTime = new java.sql.Timestamp(date.getTime());\n        } catch (java.text.ParseException pe) {\n            log.warn(\"Failed to convert time \" + event.getTime() + \" to java.sql.Timestamp, Setting current time instead\", pe);\n            eventTime = new java.sql.Timestamp((new java.util.Date()).getTime());\n        }\n        return eventTime;\n    }","id":6069,"modified_method":"/**\n     * @param event\n     * @param log\n     * @return\n     */\n    private Timestamp getEventTime(Event event) {\n        try {\n            return new Timestamp(EventConstants.parseToDate(event.getTime()).getTime());\n        } catch (ParseException e) {\n            log().warn(\"Failed to convert time \" + event.getTime() + \" to Timestamp, setting current time instead.  Exception: \" + e, e);\n            return new Timestamp(System.currentTimeMillis());\n        }\n    }","commit_id":"cf46fff9bc89d42d5f23b2da1c2d807e1bcb3b89","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * @param event\n     * @param log\n     * @return\n     */\n    private int getEventServiceId(Event event, Category log) {\n        int svcId = -1;\n        if (event.getService() != null) {\n            try {\n                svcId = getServiceID(event.getService());\n            } catch (SQLException sqlE) {\n                log.warn(\"EventWriter.add: Error converting service name \\\"\" + event.getService() + \"\\\" to an integer identifier, storing -1\", sqlE);\n            }\n        }\n        return svcId;\n    }","id":6070,"modified_method":"/**\n     * @param event\n     * @param log\n     * @return\n     */\n    private int getEventServiceId(Event event) {\n        int svcId = -1;\n        if (event.getService() != null) {\n            try {\n                svcId = getServiceID(event.getService());\n            } catch (SQLException e) {\n                log().warn(\"EventWriter.add: Error converting service name \\\"\" + event.getService() + \"\\\" to an integer identifier, storing -1: e\" + e, e);\n            }\n        }\n        return svcId;\n    }","commit_id":"d6761c55eb1d8b858150479aa6f50e1dbf272208","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void cleanPreviousEvents(int alarmId, int eventId) {\n        PreparedStatement stmt = null;\n        try {\n            stmt = m_dsConn.prepareStatement(\"DELETE FROM events WHERE alarmId = ? AND eventId != ?\");\n            stmt.setInt(1, alarmId);\n            stmt.setInt(2, eventId);\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            log().error(\"cleanPreviousEvents: Couldn't remove old events.\", e);\n        }\n\n        try {\n            stmt.close();\n        } catch (SQLException e) {\n            log().error(\"cleanPreviousEvents: Couldn't close statement.\", e);\n        }\n    }","id":6071,"modified_method":"private void cleanPreviousEvents(int alarmId, int eventId) {\n        PreparedStatement stmt = null;\n        try {\n            stmt = m_dsConn.prepareStatement(\"DELETE FROM events WHERE alarmId = ? AND eventId != ?\");\n            stmt.setInt(1, alarmId);\n            stmt.setInt(2, eventId);\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            log().error(\"cleanPreviousEvents: Couldn't remove old events: \" + e, e);\n        }\n\n        try {\n            stmt.close();\n        } catch (SQLException e) {\n            log().error(\"cleanPreviousEvents: Couldn't close statement: \" + e, e);\n        }\n    }","commit_id":"d6761c55eb1d8b858150479aa6f50e1dbf272208","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is used to convert the service name into a service id. It\n     * first looks up the information from a service map of Eventd and if no\n     * match is found, by performing a lookup in the database. If the conversion\n     * is successful then the corresponding integer identifier will be returned\n     * to the caller.\n     * \n     * @param name\n     *            The name of the service\n     * \n     * @return The integer identifier for the service name.\n     * \n     * @exception java.sql.SQLException\n     *                Thrown if there is an error accessing the stored data or\n     *                the SQL text is malformed. This will also be thrown if the\n     *                result cannot be obtained.\n     * \n     * @see EventdConstants#SQL_DB_SVCNAME_TO_SVCID\n     * \n     */\n    private int getServiceID(String name) throws SQLException {\n        //\n        // Check the name to make sure that it is not null\n        //\n        if (name == null)\n            throw new NullPointerException(\"The service name was null\");\n\n        // ask persistd\n        //\n        int id = Eventd.getServiceID(name);\n        if (id != -1)\n            return id;\n\n        //\n        // talk to the database and get the identifer\n        //\n        m_getSvcIdStmt.setString(1, name);\n        ResultSet rset = null;\n        try {\n            rset = m_getSvcIdStmt.executeQuery();\n            if (rset.next()) {\n                id = rset.getInt(1);\n            }\n\n        } catch (SQLException e) {\n            throw e;\n        } finally {\n            rset.close();\n        }\n\n        // inform persistd about the new find\n        //\n        if (id != -1)\n            Eventd.addServiceMapping(name, id);\n\n        //\n        // return the id to the caller\n        //\n        return id;\n    }","id":6072,"modified_method":"/**\n     * This method is used to convert the service name into a service id. It\n     * first looks up the information from a service map of Eventd and if no\n     * match is found, by performing a lookup in the database. If the conversion\n     * is successful then the corresponding integer identifier will be returned\n     * to the caller.\n     * \n     * @param name\n     *            The name of the service\n     * \n     * @return The integer identifier for the service name.\n     * \n     * @exception java.sql.SQLException\n     *                Thrown if there is an error accessing the stored data or\n     *                the SQL text is malformed. This will also be thrown if the\n     *                result cannot be obtained.\n     * \n     * @see EventdConstants#SQL_DB_SVCNAME_TO_SVCID\n     * \n     */\n    private int getServiceID(String name) throws SQLException {\n        Assert.notNull(name, \"The service name must not be null\");\n\n        // ask persistd\n        int id = Eventd.getServiceID(name);\n        if (id != -1) {\n            return id;\n        }\n\n        // talk to the database and get the identifer\n        m_getSvcIdStmt.setString(1, name);\n        ResultSet rset = null;\n        try {\n            rset = m_getSvcIdStmt.executeQuery();\n            if (rset.next()) {\n                id = rset.getInt(1);\n            }\n        } catch (SQLException e) {\n            throw e;\n        } finally {\n            rset.close();\n        }\n\n        // inform persistd about the new find\n        if (id != -1) {\n            Eventd.addServiceMapping(name, id);\n        }\n\n        return id;\n    }","commit_id":"d6761c55eb1d8b858150479aa6f50e1dbf272208","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * @param event\n     * @param log\n     * @return\n     */\n    private java.sql.Timestamp getEventTime(Event event, Category log) {\n        java.sql.Timestamp eventTime = null;\n        try {\n            java.util.Date date = EventConstants.parseToDate(event.getTime());\n            eventTime = new java.sql.Timestamp(date.getTime());\n        } catch (java.text.ParseException pe) {\n            log.warn(\"Failed to convert time \" + event.getTime() + \" to java.sql.Timestamp, Setting current time instead\", pe);\n            eventTime = new java.sql.Timestamp((new java.util.Date()).getTime());\n        }\n        return eventTime;\n    }","id":6073,"modified_method":"/**\n     * @param event\n     * @param log\n     * @return\n     */\n    private Timestamp getEventTime(Event event) {\n        try {\n            return new Timestamp(EventConstants.parseToDate(event.getTime()).getTime());\n        } catch (ParseException e) {\n            log().warn(\"Failed to convert time \" + event.getTime() + \" to Timestamp, setting current time instead.  Exception: \" + e, e);\n            return new Timestamp(System.currentTimeMillis());\n        }\n    }","commit_id":"d6761c55eb1d8b858150479aa6f50e1dbf272208","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void insertOrUpdateAlarm(Header eventHeader, Event event) throws SQLException {\n        \n        int alarmId = isReductionNeeded(eventHeader, event);\n        if (alarmId != -1) {\n            log().debug(\"AlarmWriter is reducing event for: \" +event.getDbid()+ \": \"+ event.getUei());\n            updateAlarm(eventHeader, event, alarmId);\n            \n            /*\n             * This removes all previous events that have been reduced.\n             */\n            log().debug(\"insertOrUpdate: auto-clean is: \"+event.getAlarmData().getAutoClean());\n            if (event.getAlarmData().getAutoClean() == true) {\n                log().debug(\"insertOrUpdate: deleting previous events.\");\n                cleanPreviousEvents(alarmId, event.getDbid());\n            }\n            \n        } else {\n            log().debug(\"AlarmWriter is not reducing event for: \" +event.getDbid()+ \": \"+ event.getUei());\n            insertAlarm(eventHeader, event);\n        }\n    }","id":6074,"modified_method":"public void insertOrUpdateAlarm(Header eventHeader, Event event) throws SQLException {\n        int alarmId = isReductionNeeded(eventHeader, event);\n        if (alarmId != -1) {\n            if (log().isDebugEnabled()) {\n                log().debug(\"Reducing event for: \" + event.getDbid() + \": \" + event.getUei());\n            }\n            updateAlarm(eventHeader, event, alarmId);\n            \n            // This removes all previous events that have been reduced.\n            if (log().isDebugEnabled()) {\n                log().debug(\"insertOrUpdate: auto-clean is: \" + event.getAlarmData().getAutoClean());\n            }\n            if (event.getAlarmData().getAutoClean() == true) {\n                log().debug(\"insertOrUpdate: deleting previous events\");\n                cleanPreviousEvents(alarmId, event.getDbid());\n            }\n            \n        } else {\n            if (log().isDebugEnabled()) {\n                log().debug(\"Not reducing event for: \" + event.getDbid() + \": \" + event.getUei());\n            }\n            insertAlarm(eventHeader, event);\n        }\n    }","commit_id":"d6761c55eb1d8b858150479aa6f50e1dbf272208","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Insert values into the ALARMS table\n     * \n     * @exception java.sql.SQLException\n     *                Thrown if there is an error adding the event to the\n     *                database.\n     * @exception java.lang.NullPointerException\n     *                Thrown if a required resource cannot be found in the\n     *                properties file.\n     */\n    private void insertAlarm(Header eventHeader, Event event) throws SQLException {\n        int alarmID = -1;\n        Category log = ThreadCategory.getInstance(AlarmWriter.class);\n        \n        alarmID = getNextId();\n        if (log.isDebugEnabled()) log.debug(\"AlarmWriter: DBID: \"+ alarmID);\n\n        //Column 1, alarmId\n        m_insStmt.setInt(1, alarmID);\n        \n        //Column 2, eventUie\n        m_insStmt.setString(2, Constants.format(event.getUei(), EVENT_UEI_FIELD_SIZE));\n        \n        //Column 3, dpName\n        m_insStmt.setString(3, (eventHeader != null) ? Constants.format(eventHeader.getDpName(), EVENT_DPNAME_FIELD_SIZE) : \"undefined\");\n        \n        // Column 4, nodeID\n        int nodeid = (int) event.getNodeid();\n        m_insStmt.setObject(4, event.hasNodeid() ? new Integer(nodeid) : null);\n        \n        // Column 5, ipaddr\n        m_insStmt.setString(5, event.getInterface());\n        \n        //Column 6, serviceId\n        //\n        // convert the service name to a service id\n        //\n        int svcId = -1;\n        if (event.getService() != null) {\n            try {\n                svcId = getServiceID(event.getService());\n            } catch (SQLException sqlE) {\n                log.warn(\"AlarmWriter.insertAlarm: Error converting service name \\\"\" + event.getService() + \"\\\" to an integer identifier, storing -1\", sqlE);\n            }\n        }\n        m_insStmt.setObject(6, (svcId == -1 ? null : new Integer(svcId)));\n\n        //Column 7, reductionKey\n        m_insStmt.setString(7, event.getAlarmData().getReductionKey());\n        \n        //Column 8, alarmType\n        m_insStmt.setInt(8, event.getAlarmData().getAlarmType());\n        \n        //Column 9, counter\n        m_insStmt.setInt(9, 1);\n        \n        //Column 10, serverity\n        set(m_insStmt, 10, Constants.getSeverity(event.getSeverity()));\n\n        //Column 11, lastEventId\n        m_insStmt.setInt(11, event.getDbid());\n        \n        //Column 12, firstEventTime\n        java.sql.Timestamp eventTime = getEventTime(event, log);\n        m_insStmt.setTimestamp(12, eventTime);\n        \n        //Column 13, lastEventTime\n        m_insStmt.setTimestamp(13, eventTime);\n        \n        //Column 14, description\n        set(m_insStmt, 14, Constants.format(event.getDescr(), EVENT_DESCR_FIELD_SIZE));\n\n        //Column 15, logMsg\n        if (event.getLogmsg() != null) {\n            // set log message\n            set(m_insStmt, 15, Constants.format(event.getLogmsg().getContent(), EVENT_LOGMSG_FIELD_SIZE));\n        } else {\n            m_insStmt.setNull(15, Types.VARCHAR);\n        }\n\n        //Column 16, operInstruct\n        set(m_insStmt, 16, Constants.format(event.getOperinstruct(), EVENT_OPERINSTRUCT_FIELD_SIZE));\n        \n        //Column 17, tticketId\n        //Column 18, tticketState\n        if (event.getTticket() != null) {\n            set(m_insStmt, 17, Constants.format(event.getTticket().getContent(), EVENT_TTICKET_FIELD_SIZE));\n            int ttstate = 0;\n            if (event.getTticket().getState().equals(\"on\"))\n                ttstate = 1;\n            set(m_insStmt, 18, ttstate);\n        } else {\n            m_insStmt.setNull(17, Types.VARCHAR);\n            m_insStmt.setNull(18, Types.INTEGER);\n        }\n\n        //Column 19, mouseOverText\n        set(m_insStmt, 19, Constants.format(event.getMouseovertext(), EVENT_MOUSEOVERTEXT_FIELD_SIZE));\n\n        //Column 20, suppressedUntil\n        set(m_insStmt, 20, eventTime);\n        \n        //Column 21, suppressedUser\n        m_insStmt.setString(21, null);\n        \n        //Column 22, suppressedTime\n        set(m_insStmt, 22, eventTime);\n        \n        //Column 23, alarmAckUser\n        m_insStmt.setString(23, null);\n        \n        //Column 24, alarmAckTime\n        m_insStmt.setTimestamp(24, null);\n        \n        //Column 25, clearUie\n        //Column 26, x733AlarmType\n        //Column 27, x733ProbableCause\n        //Column 28, clearKey\n        if (event.getAlarmData() == null) {\n            m_insStmt.setString(25, null);\n            m_insStmt.setString(26, null);\n            m_insStmt.setInt(27, -1);\n            m_insStmt.setString(28, null);\n        } else {\n            m_insStmt.setString(25, Constants.format(event.getAlarmData().getClearUei(), EVENT_UEI_FIELD_SIZE));\n            m_insStmt.setString(26, Constants.format(event.getAlarmData().getX733AlarmType(), EVENT_X733_ALARMTYPE_SIZE));\n            set(m_insStmt, 27, event.getAlarmData().getX733ProbableCause());\n            set(m_insStmt, 28, event.getAlarmData().getClearKey());\n        }\n        \n        if (log.isDebugEnabled())\n            log.debug(\"m_insStmt is: \"+m_insStmt.toString());\n        \n        m_insStmt.executeUpdate();\n        \n        m_updateEventStmt.setInt(1, alarmID);\n        m_updateEventStmt.setInt(2, event.getDbid());\n        m_updateEventStmt.executeUpdate();\n\n        if (log.isDebugEnabled())\n            log.debug(\"SUCCESSFULLY added \" + event.getUei() + \" related  data into the ALARMS table\");\n   \n    }","id":6075,"modified_method":"/**\n     * Insert values into the ALARMS table\n     * \n     * @exception java.sql.SQLException\n     *                Thrown if there is an error adding the event to the\n     *                database.\n     * @exception java.lang.NullPointerException\n     *                Thrown if a required resource cannot be found in the\n     *                properties file.\n     */\n    private void insertAlarm(Header eventHeader, Event event) throws SQLException {\n        int alarmID = -1;\n        alarmID = getNextId();\n        if (log().isDebugEnabled()) {\n            log().debug(\"AlarmWriter: DBID: \" + alarmID);\n        }\n\n        //Column 1, alarmId\n        m_insStmt.setInt(1, alarmID);\n        \n        //Column 2, eventUie\n        m_insStmt.setString(2, Constants.format(event.getUei(), EVENT_UEI_FIELD_SIZE));\n        \n        //Column 3, dpName\n        m_insStmt.setString(3, (eventHeader != null) ? Constants.format(eventHeader.getDpName(), EVENT_DPNAME_FIELD_SIZE) : \"undefined\");\n        \n        // Column 4, nodeID\n        int nodeid = (int) event.getNodeid();\n        m_insStmt.setObject(4, event.hasNodeid() ? new Integer(nodeid) : null);\n        \n        // Column 5, ipaddr\n        m_insStmt.setString(5, event.getInterface());\n        \n        //Column 6, serviceId\n        //\n        // convert the service name to a service id\n        //\n        int svcId = -1;\n        if (event.getService() != null) {\n            try {\n                svcId = getServiceID(event.getService());\n            } catch (SQLException e) {\n                log().warn(\"insertAlarm: Error converting service name \\\"\" + event.getService() + \"\\\" to an integer identifier, storing -1: \" + e, e);\n            }\n        }\n        m_insStmt.setObject(6, (svcId == -1 ? null : new Integer(svcId)));\n\n        //Column 7, reductionKey\n        m_insStmt.setString(7, event.getAlarmData().getReductionKey());\n        \n        //Column 8, alarmType\n        m_insStmt.setInt(8, event.getAlarmData().getAlarmType());\n        \n        //Column 9, counter\n        m_insStmt.setInt(9, 1);\n        \n        //Column 10, serverity\n        set(m_insStmt, 10, Constants.getSeverity(event.getSeverity()));\n\n        //Column 11, lastEventId\n        m_insStmt.setInt(11, event.getDbid());\n        \n        //Column 12, firstEventTime\n        //Column 13, lastEventTime\n        Timestamp eventTime = getEventTime(event);\n        m_insStmt.setTimestamp(12, eventTime);\n        m_insStmt.setTimestamp(13, eventTime);\n        \n        //Column 14, description\n        set(m_insStmt, 14, Constants.format(event.getDescr(), EVENT_DESCR_FIELD_SIZE));\n\n        //Column 15, logMsg\n        if (event.getLogmsg() != null) {\n            // set log message\n            set(m_insStmt, 15, Constants.format(event.getLogmsg().getContent(), EVENT_LOGMSG_FIELD_SIZE));\n        } else {\n            m_insStmt.setNull(15, Types.VARCHAR);\n        }\n\n        //Column 16, operInstruct\n        set(m_insStmt, 16, Constants.format(event.getOperinstruct(), EVENT_OPERINSTRUCT_FIELD_SIZE));\n        \n        //Column 17, tticketId\n        //Column 18, tticketState\n        if (event.getTticket() != null) {\n            set(m_insStmt, 17, Constants.format(event.getTticket().getContent(), EVENT_TTICKET_FIELD_SIZE));\n            int ttstate = 0;\n            if (event.getTticket().getState().equals(\"on\")) {\n                ttstate = 1;\n            }\n            set(m_insStmt, 18, ttstate);\n        } else {\n            m_insStmt.setNull(17, Types.VARCHAR);\n            m_insStmt.setNull(18, Types.INTEGER);\n        }\n\n        //Column 19, mouseOverText\n        set(m_insStmt, 19, Constants.format(event.getMouseovertext(), EVENT_MOUSEOVERTEXT_FIELD_SIZE));\n\n        //Column 20, suppressedUntil\n        set(m_insStmt, 20, eventTime);\n        \n        //Column 21, suppressedUser\n        m_insStmt.setString(21, null);\n        \n        //Column 22, suppressedTime\n        set(m_insStmt, 22, eventTime);\n        \n        //Column 23, alarmAckUser\n        m_insStmt.setString(23, null);\n        \n        //Column 24, alarmAckTime\n        m_insStmt.setTimestamp(24, null);\n        \n        //Column 25, clearUie\n        //Column 26, x733AlarmType\n        //Column 27, x733ProbableCause\n        //Column 28, clearKey\n        if (event.getAlarmData() == null) {\n            m_insStmt.setString(25, null);\n            m_insStmt.setString(26, null);\n            m_insStmt.setInt(27, -1);\n            m_insStmt.setString(28, null);\n        } else {\n            m_insStmt.setString(25, Constants.format(event.getAlarmData().getClearUei(), EVENT_UEI_FIELD_SIZE));\n            m_insStmt.setString(26, Constants.format(event.getAlarmData().getX733AlarmType(), EVENT_X733_ALARMTYPE_SIZE));\n            set(m_insStmt, 27, event.getAlarmData().getX733ProbableCause());\n            set(m_insStmt, 28, event.getAlarmData().getClearKey());\n        }\n        \n        if (log().isDebugEnabled()) {\n            log().debug(\"m_insStmt is: \" + m_insStmt.toString());\n        }\n        \n        m_insStmt.executeUpdate();\n        \n        m_updateEventStmt.setInt(1, alarmID);\n        m_updateEventStmt.setInt(2, event.getDbid());\n        m_updateEventStmt.executeUpdate();\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"SUCCESSFULLY added \" + event.getUei() + \" related  data into the ALARMS table\");\n        }\n   \n    }","commit_id":"d6761c55eb1d8b858150479aa6f50e1dbf272208","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Close all the connection statements\n     */\n    public void close() {\n        try {\n            m_dsConn.close();\n        } catch (SQLException e) {\n            ThreadCategory.getInstance(EventWriter.class).warn(\"SQLException while closing database connection\", e);\n        }\n    }","id":6076,"modified_method":"/**\n     * Close all the connection statements\n     */\n    public void close() {\n        try {\n            m_dsConn.close();\n        } catch (SQLException e) {\n            log().warn(\"SQLException while closing database connection\", e);\n        }\n    }","commit_id":"d6761c55eb1d8b858150479aa6f50e1dbf272208","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is used to convert the event host into a hostname id by\n     * performing a lookup in the database. If the conversion is successful then\n     * the corresponding hosname will be returned to the caller.\n     * \n     * @param hostip\n     *            The event host\n     * \n     * @return The hostname\n     * \n     * @exception java.sql.SQLException\n     *                Thrown if there is an error accessing the stored data or\n     *                the SQL text is malformed.\n     * \n     * @see EventdConstants#SQL_DB_HOSTIP_TO_HOSTNAME\n     * \n     */\n    private String getHostName(String hostip) throws SQLException {\n\n        //\n        // talk to the database and get the identifer\n        //\n        String hostname = hostip;\n\n        m_getHostNameStmt.setString(1, hostip);\n        ResultSet rset = null;\n        \n        try {\n            rset = m_getHostNameStmt.executeQuery();\n            if (rset.next()) {\n                hostname = rset.getString(1);\n            }\n\n        } catch (SQLException e) {\n            throw e;\n        } finally {\n            rset.close();\n        }\n\n        // hostname can be null - if it is, return the ip\n        //\n        if (hostname == null)\n            hostname = hostip;\n\n        //\n        // return the hostname to the caller\n        //\n        return hostname;\n    }","id":6077,"modified_method":"/**\n     * This method is used to convert the event host into a hostname id by\n     * performing a lookup in the database. If the conversion is successful then\n     * the corresponding hosname will be returned to the caller.\n     * \n     * @param hostip\n     *            The event host\n     * \n     * @return The hostname\n     * \n     * @exception java.sql.SQLException\n     *                Thrown if there is an error accessing the stored data or\n     *                the SQL text is malformed.\n     * \n     * @see EventdConstants#SQL_DB_HOSTIP_TO_HOSTNAME\n     * \n     */\n    private String getHostName(String hostip) throws SQLException {\n        // talk to the database and get the identifer\n        String hostname = hostip;\n\n        m_getHostNameStmt.setString(1, hostip);\n        ResultSet rset = null;\n        \n        try {\n            rset = m_getHostNameStmt.executeQuery();\n            if (rset.next()) {\n                hostname = rset.getString(1);\n            }\n        } catch (SQLException e) {\n            throw e;\n        } finally {\n            rset.close();\n        }\n\n        // hostname can be null - if it is, return the ip\n        if (hostname == null) {\n            hostname = hostip;\n        }\n\n        return hostname;\n    }","commit_id":"d6761c55eb1d8b858150479aa6f50e1dbf272208","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void updateAlarm(Header eventHeader, Event event, int alarmId) throws SQLException {\n\n        Category log = ThreadCategory.getInstance(Persist.class);\n\n        m_upDateStmt.setInt(1, event.getDbid());\n        \n        java.sql.Timestamp eventTime = getEventTime(event, log);\n        m_upDateStmt.setTimestamp(2, eventTime);\n        m_upDateStmt.setString(3, event.getAlarmData().getReductionKey());\n\n        if (log.isDebugEnabled())\n            log.debug(\"Persist.updateAlarm: reducing event: \"+event.getDbid()+ \"into alarm: \");\n        \n        m_upDateStmt.executeUpdate();\n\n\n        m_updateEventStmt.setInt(1, alarmId);\n        m_updateEventStmt.setInt(2, event.getDbid());\n        m_updateEventStmt.executeUpdate();\n        \n    }","id":6078,"modified_method":"private void updateAlarm(Header eventHeader, Event event, int alarmId) throws SQLException {\n        m_upDateStmt.setInt(1, event.getDbid());\n        m_upDateStmt.setTimestamp(2, getEventTime(event));\n        m_upDateStmt.setString(3, event.getAlarmData().getReductionKey());\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"Persist.updateAlarm: reducing event: \" + event.getDbid() +  \" into alarm\");\n        }\n        \n        m_upDateStmt.executeUpdate();\n\n        m_updateEventStmt.setInt(1, alarmId);\n        m_updateEventStmt.setInt(2, event.getDbid());\n        m_updateEventStmt.executeUpdate();\n    }","commit_id":"d6761c55eb1d8b858150479aa6f50e1dbf272208","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Category log() {\n        Category log = ThreadCategory.getInstance(AlarmWriter.class);\n        return log;\n    }","id":6079,"modified_method":"private Category log() {\n        return ThreadCategory.getInstance(getClass());\n    }","commit_id":"d6761c55eb1d8b858150479aa6f50e1dbf272208","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Insert values into the EVENTS table\n     * \n     * @exception java.sql.SQLException\n     *                Thrown if there is an error adding the event to the\n     *                database.\n     * @exception java.lang.NullPointerException\n     *                Thrown if a required resource cannot be found in the\n     *                properties file.\n     */\n    protected void insertEvent(Header eventHeader, Event event) throws SQLException {\n        Category log = ThreadCategory.getInstance(EventWriter.class);\n\n        // events next id from sequence\n        //\n        // Execute the statement to get the next event id\n        //\n        int eventID = getNextId();\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"EventWriter: DBID: \" + eventID);\n        }\n\n        synchronized (event) {\n            event.setDbid(eventID);\n        }\n\n        //\n        // Set up the sql information now\n        //\n\n        // eventID\n        m_insStmt.setInt(1, eventID);\n\n        // eventUEI\n        m_insStmt.setString(2, Constants.format(event.getUei(), EVENT_UEI_FIELD_SIZE));\n\n        // nodeID\n        int nodeid = (int) event.getNodeid();\n        set(m_insStmt, 3, event.hasNodeid() ? nodeid : -1);\n\n        // eventTime\n        java.sql.Timestamp eventTime = getEventTime(event, log);\n        m_insStmt.setTimestamp(4, eventTime);\n        \n        //\n        // Resolve the event host to a hostname using\n        // the ipinterface table\n        //\n        String hostname = getEventHost(event);\n\n        // eventHost\n        set(m_insStmt, 5, Constants.format(hostname, EVENT_HOST_FIELD_SIZE));\n\n        // ipAddr\n        set(m_insStmt, 6, Constants.format(event.getInterface(), EVENT_INTERFACE_FIELD_SIZE));\n\n        // eventDpName\n        m_insStmt.setString(7, (eventHeader != null) ? Constants.format(eventHeader.getDpName(), EVENT_DPNAME_FIELD_SIZE) : \"undefined\");\n\n        // eventSnmpHost\n        set(m_insStmt, 8, Constants.format(event.getSnmphost(), EVENT_SNMPHOST_FIELD_SIZE));\n\n        //\n        // convert the service name to a service id\n        //\n        int svcId = getEventServiceId(event, log);\n\n        // service identifier\n        set(m_insStmt, 9, svcId);\n\n        // eventSnmp\n        if (event.getSnmp() != null)\n            m_insStmt.setString(10, SnmpInfo.format(event.getSnmp(), EVENT_SNMP_FIELD_SIZE));\n        else\n            m_insStmt.setNull(10, Types.VARCHAR);\n\n        // eventParms\n\n        //Replace any null bytes with a space, otherwise postgres will complain about encoding in UNICODE \n        String parametersString=(event.getParms() != null) ? Parameter.format(event.getParms()) : null;\n        if(parametersString!=null) {\n            parametersString=parametersString.replace((char)0, ' ');\n        }\n        \n        set(m_insStmt, 11, parametersString);\n\n        // grab the ifIndex out of the parms if it is defined   \n        if (event.getIfIndex() != null) {\n            if (event.getParms() != null) {\n                Parameter.format(event.getParms());\n            }\n        }\n\n        // eventCreateTime\n        java.sql.Timestamp eventCreateTime = new java.sql.Timestamp((new java.util.Date()).getTime());\n        m_insStmt.setTimestamp(12, eventCreateTime);\n\n        // eventDescr\n        set(m_insStmt, 13, Constants.format(event.getDescr(), EVENT_DESCR_FIELD_SIZE));\n\n        // eventLoggroup\n        set(m_insStmt, 14, (event.getLoggroupCount() > 0) ? Constants.format(event.getLoggroup(), EVENT_LOGGRP_FIELD_SIZE) : null);\n\n        // eventLogMsg\n        // eventLog\n        // eventDisplay\n        if (event.getLogmsg() != null) {\n            // set log message\n            set(m_insStmt, 15, Constants.format(event.getLogmsg().getContent(), EVENT_LOGMSG_FIELD_SIZE));\n            String logdest = event.getLogmsg().getDest();\n            // if 'logndisplay' set both log and display\n            // column to yes\n            if (logdest.equals(\"logndisplay\")) {\n                set(m_insStmt, 16, MSG_YES);\n                set(m_insStmt, 17, MSG_YES);\n            }\n            // if 'logonly' set log column to true\n            else if (logdest.equals(\"logonly\")) {\n                set(m_insStmt, 16, MSG_YES);\n                set(m_insStmt, 17, MSG_NO);\n            }\n            // if 'displayonly' set display column to true\n            else if (logdest.equals(\"displayonly\")) {\n                set(m_insStmt, 16, MSG_NO);\n                set(m_insStmt, 17, MSG_YES);\n            }\n            // if 'suppress' set both log and display to false\n            else if (logdest.equals(\"suppress\")) {\n                set(m_insStmt, 16, MSG_NO);\n                set(m_insStmt, 17, MSG_NO);\n            }\n        } else {\n            m_insStmt.setNull(15, Types.VARCHAR);\n\n            // If this is an event that had no match in the event conf\n            // mark it as to be logged and displayed so that there\n            // are no events that slip through the system\n            // without the user knowing about them\n\n            set(m_insStmt, 16, MSG_YES);\n            set(m_insStmt, 17, MSG_YES);\n        }\n\n        // eventSeverity\n        set(m_insStmt, 18, Constants.getSeverity(event.getSeverity()));\n\n        // eventPathOutage\n        set(m_insStmt, 19, (event.getPathoutage() != null) ? Constants.format(event.getPathoutage(), EVENT_PATHOUTAGE_FIELD_SIZE) : null);\n\n        // eventCorrelation\n        set(m_insStmt, 20, (event.getCorrelation() != null) ? org.opennms.netmgt.eventd.db.Correlation.format(event.getCorrelation(), EVENT_CORRELATION_FIELD_SIZE) : null);\n\n        // eventSuppressedCount\n        m_insStmt.setNull(21, Types.INTEGER);\n\n        // eventOperInstruct\n        set(m_insStmt, 22, Constants.format(event.getOperinstruct(), EVENT_OPERINSTRUCT_FIELD_SIZE));\n\n        // eventAutoAction\n        set(m_insStmt, 23, (event.getAutoactionCount() > 0) ? AutoAction.format(event.getAutoaction(), EVENT_AUTOACTION_FIELD_SIZE) : null);\n\n        // eventOperAction / eventOperActionMenuText\n        if (event.getOperactionCount() > 0) {\n            List a = new ArrayList();\n            List b = new ArrayList();\n\n            Enumeration en = event.enumerateOperaction();\n            while (en.hasMoreElements()) {\n                Operaction eoa = (Operaction) en.nextElement();\n                a.add(eoa);\n                b.add(eoa.getMenutext());\n            }\n\n            set(m_insStmt, 24, OperatorAction.format(a, EVENT_OPERACTION_FIELD_SIZE));\n            set(m_insStmt, 25, Constants.format(b, EVENT_OPERACTION_MENU_FIELD_SIZE));\n        } else {\n            m_insStmt.setNull(24, Types.VARCHAR);\n            m_insStmt.setNull(25, Types.VARCHAR);\n        }\n\n        // eventNotification, this column no longer needed\n        m_insStmt.setNull(26, Types.VARCHAR);\n\n        // eventTroubleTicket / eventTroubleTicket state\n        if (event.getTticket() != null) {\n            set(m_insStmt, 27, Constants.format(event.getTticket().getContent(), EVENT_TTICKET_FIELD_SIZE));\n            int ttstate = 0;\n            if (event.getTticket().getState().equals(\"on\"))\n                ttstate = 1;\n\n            set(m_insStmt, 28, ttstate);\n        } else {\n            m_insStmt.setNull(27, Types.VARCHAR);\n            m_insStmt.setNull(28, Types.INTEGER);\n        }\n\n        // eventForward\n        set(m_insStmt, 29, (event.getForwardCount() > 0) ? org.opennms.netmgt.eventd.db.Forward.format(event.getForward(), EVENT_FORWARD_FIELD_SIZE) : null);\n\n        // event mouseOverText\n        set(m_insStmt, 30, Constants.format(event.getMouseovertext(), EVENT_MOUSEOVERTEXT_FIELD_SIZE));\n\n        // eventAckUser\n        if (event.getAutoacknowledge() != null && event.getAutoacknowledge().getState().equals(\"on\")) {\n\n            set(m_insStmt, 31, Constants.format(event.getAutoacknowledge().getContent(), EVENT_ACKUSER_FIELD_SIZE));\n\n            // eventAckTime - if autoacknowledge is present,\n            // set time to event create time\n            set(m_insStmt, 32, eventCreateTime);\n        } else {\n            m_insStmt.setNull(31, Types.INTEGER);\n            m_insStmt.setNull(32, Types.TIMESTAMP);\n        }\n\n        // eventSource\n        set(m_insStmt, 33, Constants.format(event.getSource(), EVENT_SOURCE_FIELD_SIZE));\n\n        // execute\n        m_insStmt.executeUpdate();\n\n        if (log.isDebugEnabled())\n            log.debug(\"SUCCESSFULLY added \" + event.getUei() + \" related  data into the EVENTS table\");\n    }","id":6080,"modified_method":"/**\n     * Insert values into the EVENTS table\n     * \n     * @exception java.sql.SQLException\n     *                Thrown if there is an error adding the event to the\n     *                database.\n     * @exception java.lang.NullPointerException\n     *                Thrown if a required resource cannot be found in the\n     *                properties file.\n     */\n    protected void insertEvent(Header eventHeader, Event event) throws SQLException {\n        // Execute the statement to get the next event id\n        int eventID = getNextId();\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"EventWriter: DBID: \" + eventID);\n        }\n\n        synchronized (event) {\n            event.setDbid(eventID);\n        }\n\n        // Set up the sql information now\n\n        // eventID\n        m_insStmt.setInt(1, eventID);\n\n        // eventUEI\n        m_insStmt.setString(2, Constants.format(event.getUei(), EVENT_UEI_FIELD_SIZE));\n\n        // nodeID\n        int nodeid = (int) event.getNodeid();\n        set(m_insStmt, 3, event.hasNodeid() ? nodeid : -1);\n\n        // eventTime\n        m_insStmt.setTimestamp(4, getEventTime(event));\n        \n        // Resolve the event host to a hostname using the ipInterface table\n        String hostname = getEventHost(event);\n\n        // eventHost\n        set(m_insStmt, 5, Constants.format(hostname, EVENT_HOST_FIELD_SIZE));\n\n        // ipAddr\n        set(m_insStmt, 6, Constants.format(event.getInterface(), EVENT_INTERFACE_FIELD_SIZE));\n\n        // eventDpName\n        m_insStmt.setString(7, (eventHeader != null) ? Constants.format(eventHeader.getDpName(), EVENT_DPNAME_FIELD_SIZE) : \"undefined\");\n\n        // eventSnmpHost\n        set(m_insStmt, 8, Constants.format(event.getSnmphost(), EVENT_SNMPHOST_FIELD_SIZE));\n\n        // service identifier - convert the service name to a service id\n        set(m_insStmt, 9, getEventServiceId(event));\n\n        // eventSnmp\n        if (event.getSnmp() != null) {\n            m_insStmt.setString(10, SnmpInfo.format(event.getSnmp(), EVENT_SNMP_FIELD_SIZE));\n        } else {\n            m_insStmt.setNull(10, Types.VARCHAR);\n        }\n\n        // eventParms\n\n        // Replace any null bytes with a space, otherwise postgres will complain about encoding in UNICODE \n        String parametersString=(event.getParms() != null) ? Parameter.format(event.getParms()) : null;\n        if (parametersString != null) {\n            parametersString=parametersString.replace((char)0, ' ');\n        }\n        \n        set(m_insStmt, 11, parametersString);\n\n        // grab the ifIndex out of the parms if it is defined   \n        if (event.getIfIndex() != null) {\n            if (event.getParms() != null) {\n                Parameter.format(event.getParms());\n            }\n        }\n\n        // eventCreateTime\n        Timestamp eventCreateTime = new Timestamp(System.currentTimeMillis());\n        m_insStmt.setTimestamp(12, eventCreateTime);\n\n        // eventDescr\n        set(m_insStmt, 13, Constants.format(event.getDescr(), EVENT_DESCR_FIELD_SIZE));\n\n        // eventLoggroup\n        set(m_insStmt, 14, (event.getLoggroupCount() > 0) ? Constants.format(event.getLoggroup(), EVENT_LOGGRP_FIELD_SIZE) : null);\n\n        // eventLogMsg\n        // eventLog\n        // eventDisplay\n        if (event.getLogmsg() != null) {\n            // set log message\n            set(m_insStmt, 15, Constants.format(event.getLogmsg().getContent(), EVENT_LOGMSG_FIELD_SIZE));\n            String logdest = event.getLogmsg().getDest();\n            if (logdest.equals(\"logndisplay\")) {\n                // if 'logndisplay' set both log and display column to yes\n                set(m_insStmt, 16, MSG_YES);\n                set(m_insStmt, 17, MSG_YES);\n            } else if (logdest.equals(\"logonly\")) {\n                // if 'logonly' set log column to true\n                set(m_insStmt, 16, MSG_YES);\n                set(m_insStmt, 17, MSG_NO);\n            } else if (logdest.equals(\"displayonly\")) {\n                // if 'displayonly' set display column to true\n                set(m_insStmt, 16, MSG_NO);\n                set(m_insStmt, 17, MSG_YES);\n            } else if (logdest.equals(\"suppress\")) {\n                // if 'suppress' set both log and display to false\n                set(m_insStmt, 16, MSG_NO);\n                set(m_insStmt, 17, MSG_NO);\n            }\n        } else {\n            m_insStmt.setNull(15, Types.VARCHAR);\n\n            /*\n             * If this is an event that had no match in the event conf\n             * mark it as to be logged and displayed so that there\n             * are no events that slip through the system\n             * without the user knowing about them\n             */\n            set(m_insStmt, 17, MSG_YES);\n        }\n\n        // eventSeverity\n        set(m_insStmt, 18, Constants.getSeverity(event.getSeverity()));\n\n        // eventPathOutage\n        set(m_insStmt, 19, (event.getPathoutage() != null) ? Constants.format(event.getPathoutage(), EVENT_PATHOUTAGE_FIELD_SIZE) : null);\n\n        // eventCorrelation\n        set(m_insStmt, 20, (event.getCorrelation() != null) ? org.opennms.netmgt.eventd.db.Correlation.format(event.getCorrelation(), EVENT_CORRELATION_FIELD_SIZE) : null);\n\n        // eventSuppressedCount\n        m_insStmt.setNull(21, Types.INTEGER);\n\n        // eventOperInstruct\n        set(m_insStmt, 22, Constants.format(event.getOperinstruct(), EVENT_OPERINSTRUCT_FIELD_SIZE));\n\n        // eventAutoAction\n        set(m_insStmt, 23, (event.getAutoactionCount() > 0) ? AutoAction.format(event.getAutoaction(), EVENT_AUTOACTION_FIELD_SIZE) : null);\n\n        // eventOperAction / eventOperActionMenuText\n        if (event.getOperactionCount() > 0) {\n            List<Operaction> a = new ArrayList<Operaction>();\n            List<String> b = new ArrayList<String>();\n\n            for (Operaction eoa : event.getOperactionCollection()) {\n                a.add(eoa);\n                b.add(eoa.getMenutext());\n            }\n\n            set(m_insStmt, 24, OperatorAction.format(a, EVENT_OPERACTION_FIELD_SIZE));\n            set(m_insStmt, 25, Constants.format(b, EVENT_OPERACTION_MENU_FIELD_SIZE));\n        } else {\n            m_insStmt.setNull(24, Types.VARCHAR);\n            m_insStmt.setNull(25, Types.VARCHAR);\n        }\n\n        // eventNotification, this column no longer needed\n        m_insStmt.setNull(26, Types.VARCHAR);\n\n        // eventTroubleTicket / eventTroubleTicket state\n        if (event.getTticket() != null) {\n            set(m_insStmt, 27, Constants.format(event.getTticket().getContent(), EVENT_TTICKET_FIELD_SIZE));\n            int ttstate = 0;\n            if (event.getTticket().getState().equals(\"on\")) {\n                ttstate = 1;\n            }\n\n            set(m_insStmt, 28, ttstate);\n        } else {\n            m_insStmt.setNull(27, Types.VARCHAR);\n            m_insStmt.setNull(28, Types.INTEGER);\n        }\n\n        // eventForward\n        set(m_insStmt, 29, (event.getForwardCount() > 0) ? org.opennms.netmgt.eventd.db.Forward.format(event.getForward(), EVENT_FORWARD_FIELD_SIZE) : null);\n\n        // event mouseOverText\n        set(m_insStmt, 30, Constants.format(event.getMouseovertext(), EVENT_MOUSEOVERTEXT_FIELD_SIZE));\n\n        // eventAckUser\n        if (event.getAutoacknowledge() != null && event.getAutoacknowledge().getState().equals(\"on\")) {\n            set(m_insStmt, 31, Constants.format(event.getAutoacknowledge().getContent(), EVENT_ACKUSER_FIELD_SIZE));\n\n            // eventAckTime - if autoacknowledge is present,\n            // set time to event create time\n            set(m_insStmt, 32, eventCreateTime);\n        } else {\n            m_insStmt.setNull(31, Types.INTEGER);\n            m_insStmt.setNull(32, Types.TIMESTAMP);\n        }\n\n        // eventSource\n        set(m_insStmt, 33, Constants.format(event.getSource(), EVENT_SOURCE_FIELD_SIZE));\n\n        // execute\n        m_insStmt.executeUpdate();\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"SUCCESSFULLY added \" + event.getUei() + \" related  data into the EVENTS table\");\n        }\n    }","commit_id":"d6761c55eb1d8b858150479aa6f50e1dbf272208","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void handleBatchReceived(Address sender, Map<Short,List<Message>> map) {\n        for(Map.Entry<Short,List<Message>> element: map.entrySet()) {\n            final List<Message> msg_list=element.getValue();\n            if(log.isTraceEnabled()) {\n                StringBuilder sb=new StringBuilder();\n                sb.append(local_addr).append(\" <-- DATA(\").append(sender).append(\": \" + printMessageList(msg_list)).append(')');\n                log.trace(sb);\n            }\n\n            short          conn_id=element.getKey();\n            ReceiverEntry  entry=null;\n            Table<Message> win=null;\n            boolean        added=false; // set to true when at least 1 message was added\n            int            total_len=0;\n            for(Message msg: msg_list) {\n                Unicast2Header hdr=(Unicast2Header)msg.getHeader(id);\n                entry=getReceiverEntry(sender, hdr.seqno, hdr.first, conn_id);\n                if(entry == null)\n                    continue;\n                win=entry.received_msgs;\n                boolean msg_added=win.add(hdr.seqno, msg); // win is guaranteed to be non-null if we get here\n                added|=msg_added;\n                num_messages_received++;\n                total_len+=msg.getLength();\n\n                if(hdr.first && msg_added)\n                    sendAck(sender, hdr.seqno, hdr.conn_id);\n\n                // An OOB message is passed up immediately. Later, when remove() is called, we discard it. This affects ordering !\n                // http://jira.jboss.com/jira/browse/JGRP-377\n                if(msg.isFlagSet(Message.OOB) && msg_added) {\n                    try {\n                        up_prot.up(new Event(Event.MSG, msg));\n                    }\n                    catch(Throwable t) {\n                        log.error(\"couldn't deliver OOB message \" + msg, t);\n                    }\n                }\n            }\n            if(entry != null && conn_expiry_timeout > 0)\n                entry.update();\n            if(added && total_len > 0 && entry.incrementStable(total_len))\n                sendStableMessage(sender, entry.recv_conn_id, win.getHighestDelivered(), win.getHighestReceived());\n        }\n\n        ReceiverEntry tmp=recv_table.get(sender);\n        Table<Message> win=tmp != null? tmp.received_msgs : null;\n        if(win != null)\n            removeAndPassUp(win);\n    }","id":6081,"modified_method":"protected void handleBatchReceived(Address sender, Map<Short,List<Message>> map) {\n        for(Map.Entry<Short,List<Message>> element: map.entrySet()) {\n            final List<Message> msg_list=element.getValue();\n            if(log.isTraceEnabled()) {\n                StringBuilder sb=new StringBuilder();\n                sb.append(local_addr).append(\" <-- DATA(\").append(sender).append(\": \" + printMessageList(msg_list)).append(')');\n                log.trace(sb);\n            }\n\n            short          conn_id=element.getKey();\n            ReceiverEntry  entry=null;\n            Table<Message> win=null;\n            boolean        added=false; // set to true when at least 1 message was added\n            int            total_len=0;\n            for(Message msg: msg_list) {\n                Unicast2Header hdr=(Unicast2Header)msg.getHeader(id);\n                entry=getReceiverEntry(sender, hdr.seqno, hdr.first, conn_id);\n                if(entry == null)\n                    continue;\n                win=entry.received_msgs;\n                boolean msg_added=win.add(hdr.seqno, msg); // win is guaranteed to be non-null if we get here\n                added|=msg_added;\n                num_messages_received++;\n                total_len+=msg.getLength();\n\n                if(hdr.first && msg_added)\n                    sendAck(sender, hdr.seqno, hdr.conn_id);\n\n                // An OOB message is passed up immediately. Later, when remove() is called, we discard it. This affects ordering !\n                // http://jira.jboss.com/jira/browse/JGRP-377\n                if(msg.isFlagSet(Message.OOB) && msg_added) {\n                    try {\n                        up_prot.up(new Event(Event.MSG, msg));\n                    }\n                    catch(Throwable t) {\n                        log.error(\"couldn't deliver OOB message \" + msg, t);\n                    }\n                }\n            }\n            if(entry != null && conn_expiry_timeout > 0)\n                entry.update();\n            if(added && total_len > 0 && entry.incrementStable(total_len) && win != null) {\n                long[] digest=win.getDigest();\n                sendStableMessage(sender, entry.recv_conn_id, digest[0], digest[1]);\n            }\n        }\n\n        ReceiverEntry tmp=recv_table.get(sender);\n        Table<Message> win=tmp != null? tmp.received_msgs : null;\n        if(win != null)\n            removeAndPassUp(win);\n    }","commit_id":"f673345d84949b42a7bb167a86f8eb3fb5340719","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Check whether the hashmap contains an entry e for <code>sender<\/code> (create if not). If\n     * e.received_msgs is null and <code>first<\/code> is true: create a new AckReceiverWindow(seqno) and\n     * add message. Set e.received_msgs to the new window. Else just add the message.\n     */\n    protected boolean handleDataReceived(Address sender, long seqno, short conn_id, boolean first, Message msg, Event evt) {\n        if(log.isTraceEnabled()) {\n            StringBuilder sb=new StringBuilder();\n            sb.append(local_addr).append(\" <-- DATA(\").append(sender).append(\": #\").append(seqno);\n            if(conn_id != 0) sb.append(\", conn_id=\").append(conn_id);\n            if(first) sb.append(\", first\");\n            sb.append(')');\n            log.trace(sb);\n        }\n        \n        ReceiverEntry entry=getReceiverEntry(sender, seqno, first, conn_id);\n        if(entry == null)\n            return false;\n        if(conn_expiry_timeout > 0)\n            entry.update();\n        Table<Message> win=entry.received_msgs;\n        boolean added=win.add(seqno, msg); // win is guaranteed to be non-null if we get here\n        num_messages_received++;\n\n        if(added) {\n            int len=msg.getLength();\n            if(len > 0 &&  entry.incrementStable(len))\n                sendStableMessage(sender, entry.recv_conn_id, win.getHighestDelivered(), win.getHighestReceived());\n        }\n\n        // An OOB message is passed up immediately. Later, when remove() is called, we discard it. This affects ordering !\n        // http://jira.jboss.com/jira/browse/JGRP-377\n        if(msg.isFlagSet(Message.OOB) && added) {\n            try {\n                up_prot.up(evt);\n            }\n            catch(Throwable t) {\n                log.error(\"couldn't deliver OOB message \" + msg, t);\n            }\n        }\n\n        removeAndPassUp(win);\n        return true;\n    }","id":6082,"modified_method":"/**\n     * Check whether the hashmap contains an entry e for <code>sender<\/code> (create if not). If\n     * e.received_msgs is null and <code>first<\/code> is true: create a new AckReceiverWindow(seqno) and\n     * add message. Set e.received_msgs to the new window. Else just add the message.\n     */\n    protected boolean handleDataReceived(Address sender, long seqno, short conn_id, boolean first, Message msg, Event evt) {\n        if(log.isTraceEnabled()) {\n            StringBuilder sb=new StringBuilder();\n            sb.append(local_addr).append(\" <-- DATA(\").append(sender).append(\": #\").append(seqno);\n            if(conn_id != 0) sb.append(\", conn_id=\").append(conn_id);\n            if(first) sb.append(\", first\");\n            sb.append(')');\n            log.trace(sb);\n        }\n        \n        ReceiverEntry entry=getReceiverEntry(sender, seqno, first, conn_id);\n        if(entry == null)\n            return false;\n        if(conn_expiry_timeout > 0)\n            entry.update();\n        Table<Message> win=entry.received_msgs;\n        boolean added=win.add(seqno, msg); // win is guaranteed to be non-null if we get here\n        num_messages_received++;\n\n        if(added) {\n            int len=msg.getLength();\n            if(len > 0 &&  entry.incrementStable(len)) {\n                long[] digest=win.getDigest();\n                sendStableMessage(sender, entry.recv_conn_id, digest[0], digest[1]);\n            }\n        }\n\n        // An OOB message is passed up immediately. Later, when remove() is called, we discard it. This affects ordering !\n        // http://jira.jboss.com/jira/browse/JGRP-377\n        if(msg.isFlagSet(Message.OOB) && added) {\n            try {\n                up_prot.up(evt);\n            }\n            catch(Throwable t) {\n                log.error(\"couldn't deliver OOB message \" + msg, t);\n            }\n        }\n\n        removeAndPassUp(win);\n        return true;\n    }","commit_id":"f673345d84949b42a7bb167a86f8eb3fb5340719","url":"https://github.com/belaban/JGroups"},{"original_method":"public void removeReceiveConnection(Address mbr) {\n        ReceiverEntry entry2=recv_table.remove(mbr);\n        if(entry2 != null) {\n            Table<Message> win=entry2.received_msgs;\n            if(win != null)\n                sendStableMessage(mbr, entry2.recv_conn_id, win.getHighestDelivered(), win.getHighestReceived());\n            entry2.reset();\n        }\n    }","id":6083,"modified_method":"public void removeReceiveConnection(Address mbr) {\n        ReceiverEntry entry2=recv_table.remove(mbr);\n        if(entry2 != null) {\n            Table<Message> win=entry2.received_msgs;\n            if(win != null) {\n                long[] digest=win.getDigest();\n                sendStableMessage(mbr, entry2.recv_conn_id, digest[0], digest[1]);\n            }\n            entry2.reset();\n        }\n    }","commit_id":"f673345d84949b42a7bb167a86f8eb3fb5340719","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns the name of the directory where SIP Communicator is to store user\n     * specific data such as configuration files, message and call history\n     * as well as is bundle repository.\n     *\n     * @return the name of the directory where SIP Communicator is to store\n     * user specific data such as configuration files, message and call history\n     * as well as is bundle repository.\n     */\n    public String getScHomeDirName()\n    {\n        //first let's check whether we already have the name of the directory\n        //set as a configuration property\n        String scHomeDirName = getString(PNAME_SC_HOME_DIR_NAME);\n\n        if (scHomeDirName == null)\n        {\n            //no luck, check whether user has specified a custom name in the\n            //system properties\n            scHomeDirName\n                = getSystemProperty(PNAME_SC_HOME_DIR_NAME);\n\n            if (scHomeDirName == null)\n            {\n                scHomeDirName = \".sip-communicator\";\n            }\n\n            //now save all this as a configuration property so that we don't\n            //have to look for it in the sys props next time and so that it is\n            // available for other bundles to consult.\n            store.setNonSystemProperty(PNAME_SC_HOME_DIR_NAME, scHomeDirName);\n        }\n\n        return scHomeDirName;\n    }","id":6084,"modified_method":"/**\n     * Returns the name of the directory where SIP Communicator is to store user\n     * specific data such as configuration files, message and call history\n     * as well as is bundle repository.\n     *\n     * @return the name of the directory where SIP Communicator is to store\n     * user specific data such as configuration files, message and call history\n     * as well as is bundle repository.\n     */\n    public String getScHomeDirName()\n    {\n        //first let's check whether we already have the name of the directory\n        //set as a configuration property\n        String scHomeDirName = getString(PNAME_SC_HOME_DIR_NAME);\n\n        if (scHomeDirName == null)\n        {\n            //no luck, check whether user has specified a custom name in the\n            //system properties\n            scHomeDirName\n                = getSystemProperty(PNAME_SC_HOME_DIR_NAME);\n\n            if (scHomeDirName == null)\n            {\n                scHomeDirName = \".sip-communicator\";\n            }\n\n            //now save all this as a configuration property so that we don't\n            //have to look for it in the sys props next time and so that it is\n            //available for other bundles to consult.\n            properties.put(PNAME_SC_HOME_DIR_NAME, scHomeDirName);\n        }\n\n        return scHomeDirName;\n    }","commit_id":"3e93ed6a906ae892018a092a2913d68760d8b5fb","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns a reference to the configuration file that the service should\n     * load. The method would try to load a file with the name\n     * sip-communicator.xml unless a different one is specified in the system\n     * property net.java.sip.communicator.PROPERTIES_FILE_NAME . The method\n     * would first try to load the file from the current directory if it exists\n     * this is not the case a load would be attempted from the\n     * $HOME/.sip-communicator directory. In case it was not found there either\n     * we'll look for it in all locations currently present in the $CLASSPATH.\n     * In case we find it in there we will copy it to the\n     * $HOME/.sip-communicator directory in case it was in a jar archive and\n     * return the reference to the newly created file. In case the file is\n     * to be found noweher - a new empty file in the user home directory and\n     * returns a link to that one.\n     *\n     *\n     * @return the configuration file currently used by the implementation.\n     */\n    File createConfigurationFile()\n    {\n        try\n        {\n            //see whether we have a user specified name for the conf file\n            String pFileName = getSystemProperty(\n                FILE_NAME_PROPERTY);\n            if (pFileName == null)\n            {\n                pFileName = \"sip-communicator.xml\";\n            }\n\n            // try to open the file in current directory\n            File configFileInCurrentDir = new File(pFileName);\n            if (configFileInCurrentDir.exists())\n            {\n                logger.debug(\"Using config file in current dir: \"\n                             + configFileInCurrentDir.getCanonicalPath());\n                return configFileInCurrentDir;\n            }\n\n            // we didn't find it in \".\", try the SIP Communicator home directory\n            // first check whether a custom SC home directory is specified\n\n            //name of the sip-communicator home directory\n            String scHomeDirName = getScHomeDirName();\n\n            //location of the sip-communicator home directory\n            String scHomeDirLocation = getScHomeDirLocation();\n\n            File configDir = new File( scHomeDirLocation\n                                       + File.separator + scHomeDirName);\n\n            File configFileInUserHomeDir =\n                new File(configDir, pFileName);\n\n            if (configFileInUserHomeDir.exists())\n            {\n                logger.debug(\"Using config file in $HOME/.sip-communicator: \"\n                             + configFileInCurrentDir.getCanonicalPath());\n                return configFileInUserHomeDir;\n            }\n\n            // If we are in a jar - copy config file from jar to user home.\n            logger.trace(\"Copying config file.\");\n\n            configDir.mkdirs();\n            InputStream in = getClass().getClassLoader().\n                getResourceAsStream(pFileName);\n\n            //Return an empty file if there wasn't any in the jar\n            //null check report from John J. Barton - IBM\n            if (in == null)\n            {\n                configFileInUserHomeDir.createNewFile();\n                logger.debug(\"Created an empty file in $HOME: \"\n                             + configFileInCurrentDir.getCanonicalPath());\n                return configFileInUserHomeDir;\n            }\n            BufferedReader reader =\n                new BufferedReader(new InputStreamReader(in));\n\n            PrintWriter writer = new PrintWriter(new FileWriter(\n                configFileInUserHomeDir));\n\n            String line;\n            logger.debug(\"Copying properties file:\");\n            while ( (line = reader.readLine()) != null)\n            {\n                writer.println(line);\n                logger.debug(line);\n            }\n            writer.flush();\n            return configFileInUserHomeDir;\n        }\n        catch (IOException ex)\n        {\n            logger.error(\"Error creating config file\", ex);\n            return null;\n        }\n    }","id":6085,"modified_method":"/**\n     * Returns a reference to the configuration file that the service should\n     * load. The method would try to load a file with the name\n     * sip-communicator.xml unless a different one is specified in the system\n     * property net.java.sip.communicator.PROPERTIES_FILE_NAME . The method\n     * would first try to load the file from the current directory if it exists\n     * this is not the case a load would be attempted from the\n     * $HOME/.sip-communicator directory. In case it was not found there either\n     * we'll look for it in all locations currently present in the $CLASSPATH.\n     * In case we find it in there we will copy it to the\n     * $HOME/.sip-communicator directory in case it was in a jar archive and\n     * return the reference to the newly created file. In case the file is\n     * to be found noweher - a new empty file in the user home directory and\n     * returns a link to that one.\n     *\n     *\n     * @return the configuration file currently used by the implementation.\n     */\n    File createConfigurationFile()\n    {\n        try\n        {\n            //see whether we have a user specified name for the conf file\n            String pFileName = getSystemProperty(\n                FILE_NAME_PROPERTY);\n            if (pFileName == null)\n            {\n                pFileName = \"sip-communicator.xml\";\n            }\n\n            // try to open the file in current directory\n            File configFileInCurrentDir = new File(pFileName);\n            if (configFileInCurrentDir.exists())\n            {\n                logger.debug(\"Using config file in current dir: \"\n                             + configFileInCurrentDir.getCanonicalPath());\n                return configFileInCurrentDir;\n            }\n\n            // we didn't find it in \".\", try the SIP Communicator home directory\n            // first check whether a custom SC home directory is specified\n\n            //name of the sip-communicator home directory\n            String scHomeDirName = getScHomeDirName();\n\n            //location of the sip-communicator home directory\n            String scHomeDirLocation = getScHomeDirLocation();\n\n            File configDir = new File( scHomeDirLocation\n                                       + File.separator + scHomeDirName);\n\n            File configFileInUserHomeDir =\n                new File(configDir, pFileName);\n\n            if (configFileInUserHomeDir.exists())\n            {\n                logger.debug(\"Using config file in $HOME/.sip-communicator: \"\n                             + configFileInCurrentDir.getCanonicalPath());\n                return configFileInUserHomeDir;\n            }\n\n            // If we are in a jar - copy config file from jar to user home.\n            logger.trace(\"Copying config file.\");\n\n            configDir.mkdirs();\n            InputStream in = getClass().getClassLoader().\n                getResourceAsStream(pFileName);\n\n            //Return an empty file if there wasn't any in the jar\n            //null check report from John J. Barton - IBM\n            if (in == null)\n            {\n                configFileInUserHomeDir.createNewFile();\n                logger.debug(\"Created an empty file in $HOME: \"\n                             + configFileInCurrentDir.getCanonicalPath());\n                return configFileInUserHomeDir;\n            }\n            BufferedReader reader =\n                new BufferedReader(new InputStreamReader(in));\n\n            PrintWriter writer = new PrintWriter(new FileWriter(\n                configFileInUserHomeDir));\n\n            String line = null;\n            logger.debug(\"Copying properties file:\");\n            while ( (line = reader.readLine()) != null)\n            {\n                writer.println(line);\n                logger.debug(line);\n            }\n            writer.flush();\n            return configFileInUserHomeDir;\n        }\n        catch (IOException ex)\n        {\n            logger.error(\"Error creating config file\", ex);\n            return null;\n        }\n    }","commit_id":"3e93ed6a906ae892018a092a2913d68760d8b5fb","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns a <tt>java.util.List<\/tt> of <tt>String<\/tt>s containing the\n     * all property names that have the specified prefix. Depending on the value\n     * of the <tt>exactPrefixMatch<\/tt> parameter the method will (when false)\n     * or will not (when exactPrefixMatch is true) include property names that\n     * have prefixes longer than the specified <tt>prefix<\/tt> param.\n     * <p>\n     * Example:\n     * <p>\n     * Imagine a configuration service instance containing 2 properties only:<br>\n     * <code>\n     * net.java.sip.communicator.PROP1=value1<br>\n     * net.java.sip.communicator.service.protocol.PROP1=value2\n     * <\/code>\n     * <p>\n     * A call to this method with a prefix=\"net.java.sip.communicator\" and\n     * exactPrefixMatch=true would only return the first property -\n     * net.java.sip.communicator.PROP1, whereas the same call with\n     * exactPrefixMatch=false would return both properties as the second prefix\n     * includes the requested prefix string.\n     * <p>\n     * @param prefix a String containing the prefix (the non dotted non-caps\n     * part of a property name) that we're looking for.\n     * @param exactPrefixMatch a boolean indicating whether the returned\n     * property names should all have a prefix that is an exact match of the\n     * the <tt>prefix<\/tt> param or whether properties with prefixes that\n     * contain it but are longer than it are also accepted.\n     * @return a <tt>java.util.List<\/tt>containing all property name String-s\n     * matching the specified conditions.\n     */\n    public List<String> getPropertyNamesByPrefix(String prefix, boolean exactPrefixMatch)\n    {\n        List<String> resultKeySet = new LinkedList<String>();\n\n        for (String key : store.getPropertyNames())\n        {\n            int ix = key.lastIndexOf('.');\n            \n            if(ix == -1)\n                continue;\n            \n            String keyPrefix = key.substring(0, ix);\n\n            if(exactPrefixMatch)\n            {\n                if(prefix.equals(keyPrefix))\n                    resultKeySet.add(key);\n            }\n            else\n            {\n                if(keyPrefix.startsWith(prefix))\n                    resultKeySet.add(key);\n            }\n        }\n\n        return resultKeySet;\n    }","id":6086,"modified_method":"/**\n     * Returns a <tt>java.util.List<\/tt> of <tt>String<\/tt>s containing the\n     * all property names that have the specified prefix. Depending on the value\n     * of the <tt>exactPrefixMatch<\/tt> parameter the method will (when false)\n     * or will not (when exactPrefixMatch is true) include property names that\n     * have prefixes longer than the specified <tt>prefix<\/tt> param.\n     * <p>\n     * Example:\n     * <p>\n     * Imagine a configuration service instance containing 2 properties only:<br>\n     * <code>\n     * net.java.sip.communicator.PROP1=value1<br>\n     * net.java.sip.communicator.service.protocol.PROP1=value2\n     * <\/code>\n     * <p>\n     * A call to this method with a prefix=\"net.java.sip.communicator\" and\n     * exactPrefixMatch=true would only return the first property -\n     * net.java.sip.communicator.PROP1, whereas the same call with\n     * exactPrefixMatch=false would return both properties as the second prefix\n     * includes the requested prefix string.\n     * <p>\n     * @param prefix a String containing the prefix (the non dotted non-caps\n     * part of a property name) that we're looking for.\n     * @param exactPrefixMatch a boolean indicating whether the returned\n     * property names should all have a prefix that is an exact match of the\n     * the <tt>prefix<\/tt> param or whether properties with prefixes that\n     * contain it but are longer than it are also accepted.\n     * @return a <tt>java.util.List<\/tt>containing all property name String-s\n     * matching the specified conditions.\n     */\n    public List<String> getPropertyNamesByPrefix(String prefix, boolean exactPrefixMatch)\n    {\n        List<String> resultKeySet = new LinkedList<String>();\n\n        for (String key : properties.keySet())\n        {\n            int ix = key.lastIndexOf('.');\n            \n            if(ix == -1)\n                continue;\n            \n            String keyPrefix = key.substring(0, ix);\n\n            if(exactPrefixMatch)\n            {\n                if(prefix.equals(keyPrefix))\n                    resultKeySet.add(key);\n            }\n            else\n            {\n                if(keyPrefix.startsWith(prefix))\n                    resultKeySet.add(key);\n            }\n        }\n\n        return resultKeySet;\n    }","commit_id":"3e93ed6a906ae892018a092a2913d68760d8b5fb","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void reloadConfiguration()\n        throws IOException, XMLException\n    {\n        this.configurationFile = null;\n\n        File file = getConfigurationFile();\n\n        // restore the file if needed\n        FailSafeTransaction trans = this.faService\n            .createFailSafeTransaction(file);\n        try {\n            trans.restoreFile();\n        } catch (Exception e) {\n            logger.error(\"can't restore the configuration file before loading\" +\n                    \" it\", e);\n        }\n\n        store.reloadConfiguration(file);\n    }","id":6087,"modified_method":"public void reloadConfiguration()\n        throws IOException, XMLException\n    {\n        properties = new Hashtable<String, Object>();\n        this.configurationFile = null;\n\n        fileExtractedProperties =\n                loadConfiguration(getConfigurationFile());\n        this.properties.putAll(fileExtractedProperties);\n    }","commit_id":"3e93ed6a906ae892018a092a2913d68760d8b5fb","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the location of the directory where SIP Communicator is to store\n     * user specific data such as configuration files, message and call history\n     * as well as is bundle repository.\n     *\n     * @return the location of the directory where SIP Communicator is to store\n     * user specific data such as configuration files, message and call history\n     * as well as is bundle repository.\n     */\n    public String getScHomeDirLocation()\n    {\n        //first let's check whether we already have the name of the directory\n        //set as a configuration property\n        String scHomeDirLocation = getString(PNAME_SC_HOME_DIR_LOCATION);\n\n        if (scHomeDirLocation == null)\n        {\n            //no luck, check whether user has specified a custom name in the\n            //system properties\n            scHomeDirLocation\n                = getSystemProperty(PNAME_SC_HOME_DIR_LOCATION);\n\n            if (scHomeDirLocation == null)\n            {\n                scHomeDirLocation = getSystemProperty(\"user.home\");\n            }\n\n            //now save all this as a configuration property so that we don't\n            //have to look for it in the sys props next time and so that it is\n            // available for other bundles to consult.\n            store.setNonSystemProperty(PNAME_SC_HOME_DIR_LOCATION,\n                scHomeDirLocation);\n        }\n\n        return scHomeDirLocation;\n    }","id":6088,"modified_method":"/**\n     * Returns the location of the directory where SIP Communicator is to store\n     * user specific data such as configuration files, message and call history\n     * as well as is bundle repository.\n     *\n     * @return the location of the directory where SIP Communicator is to store\n     * user specific data such as configuration files, message and call history\n     * as well as is bundle repository.\n     */\n    public String getScHomeDirLocation()\n    {\n        //first let's check whether we already have the name of the directory\n        //set as a configuration property\n        String scHomeDirLocation = getString(PNAME_SC_HOME_DIR_LOCATION);\n\n        if (scHomeDirLocation == null)\n        {\n            //no luck, check whether user has specified a custom name in the\n            //system properties\n            scHomeDirLocation\n                = getSystemProperty(PNAME_SC_HOME_DIR_LOCATION);\n\n            if (scHomeDirLocation == null)\n            {\n                scHomeDirLocation = getSystemProperty(\"user.home\");\n            }\n\n            //now save all this as a configuration property so that we don't\n            //have to look for it in the sys props next time and so that it is\n            //available for other bundles to consult.\n            properties.put(PNAME_SC_HOME_DIR_LOCATION, scHomeDirLocation);\n        }\n\n        return scHomeDirLocation;\n    }","commit_id":"3e93ed6a906ae892018a092a2913d68760d8b5fb","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Determines whether the property with the specified\n     * <tt>propertyName<\/tt> has been previously declared as System\n     *\n     * @param propertyName the name of the property to verify\n     * @return true if someone at some point specified that property to be\n     * system. (This could have been either through a call to\n     * setProperty(string, true)) or by setting the system attribute in the\n     * xml conf file to true.\n     */\n    private boolean isSystem(String propertyName)\n    {\n        return store.isSystem(propertyName);\n    }","id":6089,"modified_method":"/**\n     * Determines whether the property with the specified\n     * <tt>propertyName<\/tt> has been previously declared as System\n     *\n     * @param propertyName the name of the property to verify\n     * @return true if someone at some point specified that property to be\n     * system. (This could have been either through a call to\n     * setProperty(string, true)) or by setting the system attribute in the\n     * xml conf file to true.\n     */\n    private boolean isSystem(String propertyName)\n    {\n        return properties.containsKey(propertyName)\n               && properties.get(propertyName) instanceof PropertyReference;\n    }","commit_id":"3e93ed6a906ae892018a092a2913d68760d8b5fb","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the value of the property with the specified name or null if no\n     * such property exists.\n     * \n     * @param propertyName the name of the property that is being queried.\n     * @return the value of the property with the specified name.\n     */\n    public Object getProperty(String propertyName)\n    {\n        return store.getProperty(propertyName);\n    }","id":6090,"modified_method":"/**\n     * Returns the value of the property with the specified name or null if no\n     * such property exists.\n     * @param propertyName the name of the property that is being queried.\n     * @return the value of the property with the specified name.\n     */\n    public Object getProperty(String propertyName)\n    {\n        Object value = properties.get(propertyName);\n\n        //if this is a property reference make sure we return the referenced\n        //value and not the reference itself\n        if(value instanceof PropertyReference)\n            return ((PropertyReference)value).getValue();\n        else\n            return value;\n    }","commit_id":"3e93ed6a906ae892018a092a2913d68760d8b5fb","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Removes the property with the specified name. Calling\n     * this method would first trigger a PropertyChangeEvent that will\n     * be dispatched to all VetoableChangeListeners. In case no complaints\n     * (PropertyVetoException) have been received, the property will be actually\n     * changed and a PropertyChangeEvent will be dispatched.\n     * All properties with prefix propertyName will also be removed.\n     * <p>\n     * @param propertyName the name of the property to change.\n     * @throws PropertyVetoException in case the changed has been refused by\n     * at least one propertychange listener.\n     */\n    public void removeProperty(String propertyName)\n        throws PropertyVetoException\n    {\n        List<String> childPropertyNames = \n            getPropertyNamesByPrefix(propertyName, false);\n\n        //remove all properties\n        for (String pName : childPropertyNames)\n        {\n            removeProperty(pName);\n        }\n        \n        Object oldValue = getProperty(propertyName);\n        //first check whether the change is ok with everyone\n        if (changeEventDispatcher.hasVetoableChangeListeners(propertyName))\n            changeEventDispatcher.fireVetoableChange(\n                propertyName, oldValue, null);\n\n        //no exception was thrown - lets change the property and fire a\n        //change event\n\n        logger.trace(\"Will remove prop: \" + propertyName + \".\");\n\n        store.removeProperty(propertyName);\n        \n        if (changeEventDispatcher.hasPropertyChangeListeners(propertyName))\n            changeEventDispatcher.firePropertyChange(\n                propertyName, oldValue, null);\n\n        try\n        {\n            storeConfiguration();\n        }\n        catch (IOException ex)\n        {\n            logger.error(\"Failed to store configuration after \"\n                         + \"a property change\");\n        }\n    }","id":6091,"modified_method":"/**\n     * Removes the property with the specified name. Calling\n     * this method would first trigger a PropertyChangeEvent that will\n     * be dispatched to all VetoableChangeListeners. In case no complaints\n     * (PropertyVetoException) have been received, the property will be actually\n     * changed and a PropertyChangeEvent will be dispatched.\n     * All properties with prefix propertyName will also be removed.\n     * <p>\n     * @param propertyName the name of the property to change.\n     * @param property the new value of the specified property.\n     * @throws PropertyVetoException in case the changed has been refused by\n     * at least one propertychange listener.\n     */\n    public void removeProperty(String propertyName)\n        throws PropertyVetoException\n    {\n        List<String> childPropertyNames = \n            getPropertyNamesByPrefix(propertyName, false);\n\n        //remove all properties\n        for (String pName : childPropertyNames)\n        {\n            removeProperty(pName);\n        }\n        \n        Object oldValue = getProperty(propertyName);\n        //first check whether the change is ok with everyone\n        if (changeEventDispatcher.hasVetoableChangeListeners(propertyName))\n            changeEventDispatcher.fireVetoableChange(\n                propertyName, oldValue, null);\n\n        //no exception was thrown - lets change the property and fire a\n        //change event\n\n        logger.trace(\"Will remove prop: \" + propertyName + \".\");\n\n        properties.remove(propertyName);\n\n        fileExtractedProperties.remove(propertyName);\n        \n        if (changeEventDispatcher.hasPropertyChangeListeners(propertyName))\n            changeEventDispatcher.firePropertyChange(\n                propertyName, oldValue, null);\n\n        try\n        {\n            storeConfiguration();\n        }\n        catch (IOException ex)\n        {\n            logger.error(\"Failed to store configuration after \"\n                         + \"a property change\");\n        }\n    }","commit_id":"3e93ed6a906ae892018a092a2913d68760d8b5fb","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Sets the property with the specified name to the specified. Calling\n     * this method would first trigger a PropertyChangeEvent that will\n     * be dispatched to all VetoableChangeListeners. In case no complaints\n     * (PropertyVetoException) have been received, the property will be actually\n     * changed and a PropertyChangeEvent will be dispatched. This method also\n     * allows the caller to specify whether or not the specified property is a\n     * system one.\n     * <p>\n     * @param propertyName the name of the property to change.\n     * @param property the new value of the specified property.\n     * @param isSystem specifies whether or not the property being is a System\n     *                 property and should be resolved against the system\n     *                 property set. If the property has previously been\n     *                 specified as system then this value is inteernally forced\n     *                 to true.\n     * @throws PropertyVetoException in case the changed has been refused by\n     * at least one propertychange listener.\n     */\n    public void setProperty(String propertyName, Object property,\n                            boolean isSystem)\n        throws PropertyVetoException\n    {\n        Object oldValue = getProperty(propertyName);\n        //first check whether the change is ok with everyone\n        if (changeEventDispatcher.hasVetoableChangeListeners(propertyName))\n            changeEventDispatcher.fireVetoableChange(\n                propertyName, oldValue, property);\n\n        //no exception was thrown - lets change the property and fire a\n        //change event\n\n        logger.trace(propertyName + \"( oldValue=\" + oldValue\n                     + \", newValue=\" + property + \".\");\n\n        //once set system, a property remains system even if the user\n        //specified sth else\n\n        if (isSystem(propertyName))\n            isSystem = true;\n\n        if (property == null)\n        {\n            store.removeProperty(propertyName);\n\n            if (isSystem)\n            {\n                //we can't remove or nullset a sys prop so let's \"empty\" it.\n                System.setProperty(propertyName, \"\");\n            }\n        }\n        else\n        {\n            if (isSystem)\n            {\n                //in case this is a system property, we must only store it\n                //in the System property set and keep only a ref locally.\n                System.setProperty(propertyName, property.toString());\n                store.setSystemProperty(propertyName);\n            }\n            else\n            {\n                store.setNonSystemProperty(propertyName, property);\n            }\n        }\n        if (changeEventDispatcher.hasPropertyChangeListeners(propertyName))\n            changeEventDispatcher.firePropertyChange(\n                propertyName, oldValue, property);\n\n        try\n        {\n            storeConfiguration();\n        }\n        catch (IOException ex)\n        {\n            logger.error(\"Failed to store configuration after \"\n                         + \"a property change\");\n        }\n    }","id":6092,"modified_method":"/**\n     * Sets the property with the specified name to the specified. Calling\n     * this method would first trigger a PropertyChangeEvent that will\n     * be dispatched to all VetoableChangeListeners. In case no complaints\n     * (PropertyVetoException) have been received, the property will be actually\n     * changed and a PropertyChangeEvent will be dispatched. This method also\n     * allows the caller to specify whether or not the specified property is a\n     * system one.\n     * <p>\n     * @param propertyName the name of the property to change.\n     * @param property the new value of the specified property.\n     * @param isSystem specifies whether or not the property being is a System\n     *                 property and should be resolved against the system\n     *                 property set. If the property has previously been\n     *                 specified as system then this value is inteernally forced\n     *                 to true.\n     * @throws PropertyVetoException in case the changed has been refused by\n     * at least one propertychange listener.\n     */\n    public void setProperty(String propertyName, Object property,\n                            boolean isSystem)\n        throws PropertyVetoException\n    {\n        Object oldValue = getProperty(propertyName);\n        //first check whether the change is ok with everyone\n        if (changeEventDispatcher.hasVetoableChangeListeners(propertyName))\n            changeEventDispatcher.fireVetoableChange(\n                propertyName, oldValue, property);\n\n        //no exception was thrown - lets change the property and fire a\n        //change event\n\n        logger.trace(propertyName + \"( oldValue=\" + oldValue\n                     + \", newValue=\" + property + \".\");\n\n        //once set system, a property remains system event if the user\n        //specified sth else\n\n        if (isSystem(propertyName))\n            isSystem = true;\n\n        if (property == null)\n        {\n            properties.remove(propertyName);\n\n            fileExtractedProperties.remove(propertyName);\n\n            if (isSystem)\n            {\n                //we can't remove or nullset a sys prop so let's \"empty\" it.\n                System.setProperty(propertyName, \"\");\n            }\n        }\n        else\n        {\n            if (isSystem)\n            {\n                //in case this is a system property, we must only store it\n                //in the System property set and keep only a ref locally.\n                System.setProperty(propertyName, property.toString());\n                properties.put(propertyName,\n                               new PropertyReference(propertyName));\n            }\n            else\n            {\n                properties.put(propertyName, property);\n            }\n        }\n        if (changeEventDispatcher.hasPropertyChangeListeners(propertyName))\n            changeEventDispatcher.firePropertyChange(\n                propertyName, oldValue, property);\n\n        try\n        {\n            storeConfiguration();\n        }\n        catch (IOException ex)\n        {\n            logger.error(\"Failed to store configuration after \"\n                         + \"a property change\");\n        }\n    }","commit_id":"3e93ed6a906ae892018a092a2913d68760d8b5fb","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Stores local properties in the specified configuration file.\n     * \n     * @param file a reference to the configuration file where properties should\n     *            be stored.\n     * @throws IOException if there was a problem writing to the specified file.\n     */\n    private void storeConfiguration(File file) throws IOException\n    {\n        if (!started)\n            throw new IllegalStateException(\n                \"Service is stopped or has not been started\");\n\n        // write the file.\n        File config = getConfigurationFile();\n        FailSafeTransaction trans =\n            this.faService.createFailSafeTransaction(config);\n        try\n        {\n            trans.beginTransaction();\n            OutputStream stream = new FileOutputStream(config);\n\n            store.storeConfiguration(stream);\n\n            stream.close();\n            trans.commit();\n        }\n        catch (Exception e)\n        {\n            logger.error(\"can't write data in the configuration file\", e);\n            trans.rollback();\n        }\n    }","id":6093,"modified_method":"/**\n     * Stores local properties in the specified configuration file.\n     * @param file a reference to the configuration file where properties should\n     *  be stored.\n     * @throws IOException if there was a problem writing to the specified file.\n     */\n    private void storeConfiguration(File file)\n        throws IOException\n    {\n        if(!started)\n            throw new IllegalStateException(\"Service is stopped or has not been started\");\n        \n        //resolve the properties that were initially in the file - back to\n        //the document.\n\n        if (propertiesDocument == null)\n            propertiesDocument = createPropertiesDocument();\n\n        Node root = propertiesDocument.getFirstChild();\n\n        Node currentNode = null;\n        NodeList children = root.getChildNodes();\n        for (int i = 0; i < children.getLength(); i++)\n        {\n            currentNode = children.item(i);\n\n            if (currentNode.getNodeType() == Node.ELEMENT_NODE)\n            {\n                StringBuffer propertyNameBuff = new StringBuffer();\n                propertyNameBuff.append(currentNode.getNodeName());\n                updateNode(currentNode, propertyNameBuff, properties);\n            }\n        }\n\n        //create in the document the properties that were added by other\n        //bundles after the initial property load.\n\n        Map<String, Object> newlyAddedProperties = cloneProperties();\n\n        //remove those that were originally there;\n        for (String propName : fileExtractedProperties.keySet())\n            newlyAddedProperties.remove(propName);\n\n        this.processNewProperties(propertiesDocument,\n                                  newlyAddedProperties);\n\n        //write the file.\n        File config = getConfigurationFile();\n        FailSafeTransaction trans = this.faService\n                                        .createFailSafeTransaction(config);\n        try {\n            trans.beginTransaction();\n            OutputStream stream = new FileOutputStream(config);\n            XMLUtils.indentedWriteXML(\n                    propertiesDocument, stream);\n            stream.close();\n            trans.commit();\n        } catch (Exception e) {\n            logger.error(\"can't write data in the configuration file\", e);\n            trans.rollback();\n        }\n    }","commit_id":"3e93ed6a906ae892018a092a2913d68760d8b5fb","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\r\n     * Stores an account represented in the form of an <code>AccountID<\/code>\r\n     * created by a specific <code>ProtocolProviderFactory<\/code>.\r\n     *\r\n     * @param factory the <code>ProtocolProviderFactory<\/code> which created the\r\n     *            account to be stored\r\n     * @param accountID the account in the form of <code>AccountID<\/code> to be\r\n     *            stored\r\n     */\r\n    public void storeAccount(ProtocolProviderFactory factory,\r\n        AccountID accountID)\r\n    {\r\n        ConfigurationService configurationService = getConfigurationService();\r\n        String factoryPackage = getFactoryImplPackageName(factory);\r\n\r\n        // First check if such accountID already exist in the configuration.\r\n        List<String> storedAccounts =\r\n            configurationService.getPropertyNamesByPrefix(factoryPackage, true);\r\n        String accountUID = accountID.getAccountUniqueID();\r\n        String accountNodeName = null;\r\n\r\n        for (Iterator<String> storedAccountIter = storedAccounts.iterator();\r\n             storedAccountIter.hasNext();)\r\n        {\r\n            String storedAccount = storedAccountIter.next();\r\n            String storedAccountUID =\r\n                configurationService.getString(storedAccount + \".ACCOUNT_UID\");\r\n\r\n            if (storedAccountUID.equals(accountUID))\r\n            {\r\n                accountNodeName = configurationService.getString(storedAccount);\r\n            }\r\n        }\r\n\r\n        // Create a unique node name of the properties node that will contain\r\n        // this account's properties.\r\n        if (accountNodeName == null)\r\n        {\r\n            accountNodeName = \"acc\" + Long.toString(System.currentTimeMillis());\r\n\r\n            // set a value for the persistent node so that we could later\r\n            // retrieve it as a property\r\n            configurationService.setProperty(factoryPackage // prefix\r\n                + \".\" + accountNodeName, accountNodeName);\r\n\r\n            // register the account in the configuration service.\r\n            // we register all the properties in the following hierarchy\r\n            //net.java.sip.communicator.impl.protocol.PROTO_NAME.ACC_ID.PROP_NAME\r\n            configurationService.setProperty(factoryPackage// prefix\r\n                + \".\" + accountNodeName // node name for the account id\r\n                + \".\" + ProtocolProviderFactory.ACCOUNT_UID, // propname\r\n                accountID.getAccountUniqueID()); // value\r\n        }\r\n\r\n        // store the rest of the properties\r\n        Map<String, String> accountProperties = accountID.getAccountProperties();\r\n\r\n        for (Map.Entry<String, String> entry : accountProperties.entrySet())\r\n        {\r\n            String property = entry.getKey();\r\n            String value = entry.getValue();\r\n\r\n            // if this is a password - encode it.\r\n            if (property.equals(ProtocolProviderFactory.PASSWORD))\r\n                value = new String(Base64.encode(value.getBytes()));\r\n\r\n            configurationService.setProperty(factoryPackage // prefix\r\n                + \".\" + accountNodeName // a uniew node name for the account id\r\n                + \".\" + property, // propname\r\n                value); // value\r\n        }\r\n\r\n        logger.debug(\"Stored account for id \" + accountID.getAccountUniqueID()\r\n            + \" for package \" + factoryPackage);\r\n    }","id":6094,"modified_method":"/**\r\n     * Stores an account represented in the form of an <code>AccountID<\/code>\r\n     * created by a specific <code>ProtocolProviderFactory<\/code>.\r\n     *\r\n     * @param factory the <code>ProtocolProviderFactory<\/code> which created the\r\n     *            account to be stored\r\n     * @param accountID the account in the form of <code>AccountID<\/code> to be\r\n     *            stored\r\n     */\r\n    public void storeAccount(ProtocolProviderFactory factory,\r\n        AccountID accountID)\r\n    {\r\n        ConfigurationService configurationService = getConfigurationService();\r\n        String factoryPackage = getFactoryImplPackageName(factory);\r\n\r\n        // First check if such accountID already exist in the configuration.\r\n        List<String> storedAccounts =\r\n            configurationService.getPropertyNamesByPrefix(factoryPackage, true);\r\n        String accountUID = accountID.getAccountUniqueID();\r\n        String accountNodeName = null;\r\n\r\n        for (Iterator<String> storedAccountIter = storedAccounts.iterator();\r\n             storedAccountIter.hasNext();)\r\n        {\r\n            String storedAccount = storedAccountIter.next();\r\n            String storedAccountUID =\r\n                configurationService.getString(storedAccount + \".ACCOUNT_UID\");\r\n\r\n            if (storedAccountUID.equals(accountUID))\r\n            {\r\n                accountNodeName = configurationService.getString(storedAccount);\r\n            }\r\n        }\r\n\r\n        Map<String, Object> configurationProperties\r\n            = new HashMap<String, Object>();\r\n\r\n        // Create a unique node name of the properties node that will contain\r\n        // this account's properties.\r\n        if (accountNodeName == null)\r\n        {\r\n            accountNodeName = \"acc\" + Long.toString(System.currentTimeMillis());\r\n\r\n            // set a value for the persistent node so that we could later\r\n            // retrieve it as a property\r\n            configurationProperties.put(factoryPackage // prefix\r\n                + \".\" + accountNodeName, accountNodeName);\r\n\r\n            // register the account in the configuration service.\r\n            // we register all the properties in the following hierarchy\r\n            //net.java.sip.communicator.impl.protocol.PROTO_NAME.ACC_ID.PROP_NAME\r\n            configurationProperties.put(factoryPackage// prefix\r\n                + \".\" + accountNodeName // node name for the account id\r\n                + \".\" + ProtocolProviderFactory.ACCOUNT_UID, // propname\r\n                accountID.getAccountUniqueID()); // value\r\n        }\r\n\r\n        // store the rest of the properties\r\n        Map<String, String> accountProperties = accountID.getAccountProperties();\r\n\r\n        for (Map.Entry<String, String> entry : accountProperties.entrySet())\r\n        {\r\n            String property = entry.getKey();\r\n            String value = entry.getValue();\r\n\r\n            // if this is a password - encode it.\r\n            if (property.equals(ProtocolProviderFactory.PASSWORD))\r\n                value = new String(Base64.encode(value.getBytes()));\r\n\r\n            configurationProperties.put(factoryPackage // prefix\r\n                + \".\" + accountNodeName // a unique node name for the account id\r\n                + \".\" + property, // propname\r\n                value); // value\r\n        }\r\n\r\n        if (configurationProperties.size() > 0)\r\n            configurationService.setProperties(configurationProperties);\r\n\r\n        logger.debug(\"Stored account for id \" + accountID.getAccountUniqueID()\r\n            + \" for package \" + factoryPackage);\r\n    }","commit_id":"19f509b6524fea5b253e1166841c7e0947b06573","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Causes the configuration service to store the properties object and\n     * unregisters the configuration servcice.\n     *\n     * @param bundlecontext BundleContext\n     * @throws Exception\n     */\n    public void stop(BundleContext bundlecontext) throws Exception\n    {\n        logger.logEntry();\n        impl.stop();\n        logger.info(\"The ConfigurationService stop method has been called.\");\n    }","id":6095,"modified_method":"/**\n     * Causes the configuration service to store the properties object and\n     * unregisters the configuration service.\n     *\n     * @param bundleContext BundleContext\n     * @throws Exception\n     */\n    public void stop(BundleContext bundleContext)\n        throws Exception\n    {\n        logger.logEntry();\n        impl.stop();\n        logger.info(\"The ConfigurationService stop method has been called.\");\n    }","commit_id":"19f509b6524fea5b253e1166841c7e0947b06573","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Starts the configuration service\n     *\n     * @param bundleContext the BundleContext as provided from the osgi\n     * framework.\n     * @throws Exception if anything goes wrong\n     */\n    public void start(BundleContext bContext) throws Exception\n    {\n        logger.debug(\"Service Impl: \" + getClass().getName() + \" [  STARTED ]\");\n        \n        ConfigurationActivator.bundleContext = bContext;\n        impl.start();\n\n        bundleContext.registerService(ConfigurationService.class.getName(),\n                                      impl,\n                                      null);\n\n        logger.debug(\"Service Impl: \" + getClass().getName() + \" [REGISTERED]\");\n    }","id":6096,"modified_method":"/**\n     * Starts the configuration service\n     * \n     * @param bundleContext\n     *            the BundleContext as provided from the OSGi framework.\n     * @throws Exception\n     *             if anything goes wrong\n     */\n    public void start(BundleContext bundleContext)\n        throws Exception\n    {\n        logger.debug(\"Service Impl: \" + getClass().getName() + \" [  STARTED ]\");\n\n        impl.start(bundleContext);\n\n        bundleContext.registerService(ConfigurationService.class.getName(),\n                                      impl,\n                                      null);\n\n        logger.debug(\"Service Impl: \" + getClass().getName() + \" [REGISTERED]\");\n    }","commit_id":"19f509b6524fea5b253e1166841c7e0947b06573","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns a <tt>java.util.List<\/tt> of <tt>String<\/tt>s containing the\n     * all property names that have the specified prefix. Depending on the value\n     * of the <tt>exactPrefixMatch<\/tt> parameter the method will (when false)\n     * or will not (when exactPrefixMatch is true) include property names that\n     * have prefixes longer than the specified <tt>prefix<\/tt> param.\n     * <p>\n     * Example:\n     * <p>\n     * Imagine a configuration service instance containing 2 properties only:<br>\n     * <code>\n     * net.java.sip.communicator.PROP1=value1<br>\n     * net.java.sip.communicator.service.protocol.PROP1=value2\n     * <\/code>\n     * <p>\n     * A call to this method with a prefix=\"net.java.sip.communicator\" and\n     * exactPrefixMatch=true would only return the first property -\n     * net.java.sip.communicator.PROP1, whereas the same call with\n     * exactPrefixMatch=false would return both properties as the second prefix\n     * includes the requested prefix string.\n     * <p>\n     * @param prefix a String containing the prefix (the non dotted non-caps\n     * part of a property name) that we're looking for.\n     * @param exactPrefixMatch a boolean indicating whether the returned\n     * property names should all have a prefix that is an exact match of the\n     * the <tt>prefix<\/tt> param or whether properties with prefixes that\n     * contain it but are longer than it are also accepted.\n     * @return a <tt>java.util.List<\/tt>containing all property name String-s\n     * matching the specified conditions.\n     */\n    public List<String> getPropertyNamesByPrefix(String prefix, boolean exactPrefixMatch)\n    {\n        List<String> resultKeySet = new LinkedList<String>();\n\n        for (String key : properties.keySet())\n        {\n            int ix = key.lastIndexOf('.');\n            \n            if(ix == -1)\n                continue;\n            \n            String keyPrefix = key.substring(0, ix);\n\n            if(exactPrefixMatch)\n            {\n                if(prefix.equals(keyPrefix))\n                    resultKeySet.add(key);\n            }\n            else\n            {\n                if(keyPrefix.startsWith(prefix))\n                    resultKeySet.add(key);\n            }\n        }\n\n        return resultKeySet;\n    }","id":6097,"modified_method":"/**\n     * Returns a <tt>java.util.List<\/tt> of <tt>String<\/tt>s containing the\n     * all property names that have the specified prefix. Depending on the value\n     * of the <tt>exactPrefixMatch<\/tt> parameter the method will (when false)\n     * or will not (when exactPrefixMatch is true) include property names that\n     * have prefixes longer than the specified <tt>prefix<\/tt> param.\n     * <p>\n     * Example:\n     * <p>\n     * Imagine a configuration service instance containing 2 properties only:<br>\n     * <code>\n     * net.java.sip.communicator.PROP1=value1<br>\n     * net.java.sip.communicator.service.protocol.PROP1=value2\n     * <\/code>\n     * <p>\n     * A call to this method with a prefix=\"net.java.sip.communicator\" and\n     * exactPrefixMatch=true would only return the first property -\n     * net.java.sip.communicator.PROP1, whereas the same call with\n     * exactPrefixMatch=false would return both properties as the second prefix\n     * includes the requested prefix string.\n     * <p>\n     * @param prefix a String containing the prefix (the non dotted non-caps\n     * part of a property name) that we're looking for.\n     * @param exactPrefixMatch a boolean indicating whether the returned\n     * property names should all have a prefix that is an exact match of the\n     * the <tt>prefix<\/tt> param or whether properties with prefixes that\n     * contain it but are longer than it are also accepted.\n     * @return a <tt>java.util.List<\/tt>containing all property name String-s\n     * matching the specified conditions.\n     */\n    public List<String> getPropertyNamesByPrefix(String prefix, boolean exactPrefixMatch)\n    {\n        List<String> resultKeySet = new LinkedList<String>();\n\n        for (String key : store.getPropertyNames())\n        {\n            int ix = key.lastIndexOf('.');\n            \n            if(ix == -1)\n                continue;\n            \n            String keyPrefix = key.substring(0, ix);\n\n            if(exactPrefixMatch)\n            {\n                if(prefix.equals(keyPrefix))\n                    resultKeySet.add(key);\n            }\n            else\n            {\n                if(keyPrefix.startsWith(prefix))\n                    resultKeySet.add(key);\n            }\n        }\n\n        return resultKeySet;\n    }","commit_id":"19f509b6524fea5b253e1166841c7e0947b06573","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void reloadConfiguration()\n        throws IOException, XMLException\n    {\n        properties = new Hashtable<String, Object>();\n        this.configurationFile = null;\n\n        fileExtractedProperties =\n                loadConfiguration(getConfigurationFile());\n        this.properties.putAll(fileExtractedProperties);\n    }","id":6098,"modified_method":"public void reloadConfiguration()\n        throws IOException, XMLException\n    {\n        this.configurationFile = null;\n\n        File file = getConfigurationFile();\n\n        // restore the file if needed\n        FailSafeTransaction trans = this.faService\n            .createFailSafeTransaction(file);\n        try {\n            trans.restoreFile();\n        } catch (Exception e) {\n            logger.error(\"can't restore the configuration file before loading\" +\n                    \" it\", e);\n        }\n\n        store.reloadConfiguration(file);\n    }","commit_id":"19f509b6524fea5b253e1166841c7e0947b06573","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns a reference to the configuration file that the service should\n     * load. The method would try to load a file with the name\n     * sip-communicator.xml unless a different one is specified in the system\n     * property net.java.sip.communicator.PROPERTIES_FILE_NAME . The method\n     * would first try to load the file from the current directory if it exists\n     * this is not the case a load would be attempted from the\n     * $HOME/.sip-communicator directory. In case it was not found there either\n     * we'll look for it in all locations currently present in the $CLASSPATH.\n     * In case we find it in there we will copy it to the\n     * $HOME/.sip-communicator directory in case it was in a jar archive and\n     * return the reference to the newly created file. In case the file is\n     * to be found noweher - a new empty file in the user home directory and\n     * returns a link to that one.\n     *\n     *\n     * @return the configuration file currently used by the implementation.\n     */\n    File createConfigurationFile()\n    {\n        try\n        {\n            //see whether we have a user specified name for the conf file\n            String pFileName = getSystemProperty(\n                FILE_NAME_PROPERTY);\n            if (pFileName == null)\n            {\n                pFileName = \"sip-communicator.xml\";\n            }\n\n            // try to open the file in current directory\n            File configFileInCurrentDir = new File(pFileName);\n            if (configFileInCurrentDir.exists())\n            {\n                logger.debug(\"Using config file in current dir: \"\n                             + configFileInCurrentDir.getCanonicalPath());\n                return configFileInCurrentDir;\n            }\n\n            // we didn't find it in \".\", try the SIP Communicator home directory\n            // first check whether a custom SC home directory is specified\n\n            //name of the sip-communicator home directory\n            String scHomeDirName = getScHomeDirName();\n\n            //location of the sip-communicator home directory\n            String scHomeDirLocation = getScHomeDirLocation();\n\n            File configDir = new File( scHomeDirLocation\n                                       + File.separator + scHomeDirName);\n\n            File configFileInUserHomeDir =\n                new File(configDir, pFileName);\n\n            if (configFileInUserHomeDir.exists())\n            {\n                logger.debug(\"Using config file in $HOME/.sip-communicator: \"\n                             + configFileInCurrentDir.getCanonicalPath());\n                return configFileInUserHomeDir;\n            }\n\n            // If we are in a jar - copy config file from jar to user home.\n            logger.trace(\"Copying config file.\");\n\n            configDir.mkdirs();\n            InputStream in = getClass().getClassLoader().\n                getResourceAsStream(pFileName);\n\n            //Return an empty file if there wasn't any in the jar\n            //null check report from John J. Barton - IBM\n            if (in == null)\n            {\n                configFileInUserHomeDir.createNewFile();\n                logger.debug(\"Created an empty file in $HOME: \"\n                             + configFileInCurrentDir.getCanonicalPath());\n                return configFileInUserHomeDir;\n            }\n            BufferedReader reader =\n                new BufferedReader(new InputStreamReader(in));\n\n            PrintWriter writer = new PrintWriter(new FileWriter(\n                configFileInUserHomeDir));\n\n            String line = null;\n            logger.debug(\"Copying properties file:\");\n            while ( (line = reader.readLine()) != null)\n            {\n                writer.println(line);\n                logger.debug(line);\n            }\n            writer.flush();\n            return configFileInUserHomeDir;\n        }\n        catch (IOException ex)\n        {\n            logger.error(\"Error creating config file\", ex);\n            return null;\n        }\n    }","id":6099,"modified_method":"/**\n     * Returns a reference to the configuration file that the service should\n     * load. The method would try to load a file with the name\n     * sip-communicator.xml unless a different one is specified in the system\n     * property net.java.sip.communicator.PROPERTIES_FILE_NAME . The method\n     * would first try to load the file from the current directory if it exists\n     * this is not the case a load would be attempted from the\n     * $HOME/.sip-communicator directory. In case it was not found there either\n     * we'll look for it in all locations currently present in the $CLASSPATH.\n     * In case we find it in there we will copy it to the\n     * $HOME/.sip-communicator directory in case it was in a jar archive and\n     * return the reference to the newly created file. In case the file is to be\n     * found nowhere - a new empty file in the user home directory and returns a\n     * link to that one.\n     * \n     * @param extension\n     *            the extension of the file name of the configuration file. The\n     *            specified extension may not be taken into account if the the\n     *            configuration file name is forced through a system property.\n     * @param create\n     *            <tt>true<\/tt> to create the configuration file with the\n     *            determined file name if it does not exist; <tt>false<\/tt> to\n     *            only figure out the file name of the configuration file\n     *            without creating it\n     * @return the configuration file currently used by the implementation.\n     */\n    private File getConfigurationFile(String extension, boolean create)\n        throws IOException\n    {\n        //see whether we have a user specified name for the conf file\n        String pFileName = getSystemProperty(FILE_NAME_PROPERTY);\n        if (pFileName == null)\n            pFileName = \"sip-communicator.\" + extension;\n\n        // try to open the file in current directory\n        File configFileInCurrentDir = new File(pFileName);\n        if (configFileInCurrentDir.exists())\n        {\n            logger.debug(\n                \"Using config file in current dir: \"\n                    + configFileInCurrentDir.getAbsolutePath());\n            return configFileInCurrentDir;\n        }\n\n        // we didn't find it in \".\", try the SIP Communicator home directory\n        // first check whether a custom SC home directory is specified\n\n        File configDir\n            = new File(\n                    getScHomeDirLocation()\n                        + File.separator\n                        + getScHomeDirName());\n        File configFileInUserHomeDir = new File(configDir, pFileName);\n\n        if (configFileInUserHomeDir.exists())\n        {\n            logger.debug(\n                \"Using config file in $HOME/.sip-communicator: \"\n                    + configFileInUserHomeDir.getAbsolutePath());\n            return configFileInUserHomeDir;\n        }\n\n        // If we are in a jar - copy config file from jar to user home.\n        InputStream in\n            = getClass().getClassLoader().getResourceAsStream(pFileName);\n\n        //Return an empty file if there wasn't any in the jar\n        //null check report from John J. Barton - IBM\n        if (in == null)\n        {\n            if (create)\n            {\n                configDir.mkdirs();\n                configFileInUserHomeDir.createNewFile();\n            }\n            logger.debug(\n                \"Created an empty file in $HOME: \"\n                    + configFileInUserHomeDir.getAbsolutePath());\n            return configFileInUserHomeDir;\n        }\n\n        logger.trace(\n            \"Copying config file from JAR into \"\n                + configFileInUserHomeDir.getAbsolutePath());\n        configDir.mkdirs();\n        try\n        {\n            copy(in, configFileInUserHomeDir);\n        }\n        finally\n        {\n            try\n            {\n                in.close();\n            }\n            catch (IOException ioex)\n            {\n                /*\n                 * Ignore it because it doesn't matter and, most importantly, it\n                 * shouldn't prevent us from using the configuration file.\n                 */\n            }\n        }\n        return configFileInUserHomeDir;\n    }","commit_id":"19f509b6524fea5b253e1166841c7e0947b06573","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the value of the property with the specified name or null if no\n     * such property exists.\n     * @param propertyName the name of the property that is being queried.\n     * @return the value of the property with the specified name.\n     */\n    public Object getProperty(String propertyName)\n    {\n        Object value = properties.get(propertyName);\n\n        //if this is a property reference make sure we return the referenced\n        //value and not the reference itself\n        if(value instanceof PropertyReference)\n            return ((PropertyReference)value).getValue();\n        else\n            return value;\n    }","id":6100,"modified_method":"/**\n     * Returns the value of the property with the specified name or null if no\n     * such property exists.\n     * \n     * @param propertyName the name of the property that is being queried.\n     * @return the value of the property with the specified name.\n     */\n    public Object getProperty(String propertyName)\n    {\n        return store.getProperty(propertyName);\n    }","commit_id":"19f509b6524fea5b253e1166841c7e0947b06573","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the configuration file currently used by the implementation.\n     * If there is no such file or this is the first time we reference it\n     * a new one is created.\n     * @return the configuration File currently used by the implementation.\n     */\n    private File getConfigurationFile()\n    {\n        if ( configurationFile == null )\n            configurationFile = createConfigurationFile();\n\n        return configurationFile;\n    }","id":6101,"modified_method":"/**\n     * Returns the configuration file currently used by the implementation.\n     * If there is no such file or this is the first time we reference it\n     * a new one is created.\n     * @return the configuration File currently used by the implementation.\n     */\n    private File getConfigurationFile()\n        throws IOException\n    {\n        if (this.configurationFile == null)\n        {\n            File configurationFile = getConfigurationFile(\"xml\", false);\n\n            if (configurationFile == null)\n            {\n                /*\n                 * Quite strange but let it play out as it did when the\n                 * configuration file was in XML format.\n                 */\n                this.configurationFile = getConfigurationFile(\"xml\", true);\n                if (!(this.store instanceof XMLConfigurationStore))\n                    this.store = new XMLConfigurationStore();\n            }\n            else if (configurationFile.exists())\n            {\n                String name = configurationFile.getName();\n                int extensionBeginIndex = name.lastIndexOf('.');\n                String extension\n                    = (extensionBeginIndex > -1)\n                            ? name.substring(extensionBeginIndex)\n                            : null;\n\n                if (\".properties\".equalsIgnoreCase(extension))\n                {\n                    this.configurationFile = configurationFile;\n                    if (!(this.store instanceof PropertyConfigurationStore))\n                        this.store = new PropertyConfigurationStore();\n                }\n                else\n                {\n                    File newConfigurationFile\n                        = new File(\n                                configurationFile.getParentFile(),\n                                ((extensionBeginIndex > -1)\n                                        ? name.substring(0, extensionBeginIndex)\n                                        : name)\n                                    + \".properties\");\n\n                    if (newConfigurationFile.exists())\n                    {\n                        this.configurationFile = newConfigurationFile;\n                        if (!(this.store instanceof PropertyConfigurationStore))\n                            this.store = new PropertyConfigurationStore();\n                    }\n                    else\n                    {\n                        this.configurationFile = configurationFile;\n                        if (!(this.store instanceof XMLConfigurationStore))\n                            this.store = new XMLConfigurationStore();\n                    }\n                }\n            }\n            else\n            {\n                this.configurationFile\n                        = getConfigurationFile(\"properties\", true);\n                if (!(this.store instanceof PropertyConfigurationStore))\n                    this.store = new PropertyConfigurationStore();\n            }\n\n            /*\n             * Make sure that the properties SC_HOME_DIR_LOCATION and\n             * SC_HOME_DIR_NAME are available in the store of this instance so\n             * that users don't have to ask the system properties again.\n             */\n            getScHomeDirLocation();\n            getScHomeDirName();\n        }\n        return this.configurationFile;\n    }","commit_id":"19f509b6524fea5b253e1166841c7e0947b06573","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Sets the property with the specified name to the specified. Calling\n     * this method would first trigger a PropertyChangeEvent that will\n     * be dispatched to all VetoableChangeListeners. In case no complaints\n     * (PropertyVetoException) have been received, the property will be actually\n     * changed and a PropertyChangeEvent will be dispatched. This method also\n     * allows the caller to specify whether or not the specified property is a\n     * system one.\n     * <p>\n     * @param propertyName the name of the property to change.\n     * @param property the new value of the specified property.\n     * @param isSystem specifies whether or not the property being is a System\n     *                 property and should be resolved against the system\n     *                 property set. If the property has previously been\n     *                 specified as system then this value is inteernally forced\n     *                 to true.\n     * @throws PropertyVetoException in case the changed has been refused by\n     * at least one propertychange listener.\n     */\n    public void setProperty(String propertyName, Object property,\n                            boolean isSystem)\n        throws PropertyVetoException\n    {\n        Object oldValue = getProperty(propertyName);\n        //first check whether the change is ok with everyone\n        if (changeEventDispatcher.hasVetoableChangeListeners(propertyName))\n            changeEventDispatcher.fireVetoableChange(\n                propertyName, oldValue, property);\n\n        //no exception was thrown - lets change the property and fire a\n        //change event\n\n        logger.trace(propertyName + \"( oldValue=\" + oldValue\n                     + \", newValue=\" + property + \".\");\n\n        //once set system, a property remains system event if the user\n        //specified sth else\n\n        if (isSystem(propertyName))\n            isSystem = true;\n\n        if (property == null)\n        {\n            properties.remove(propertyName);\n\n            fileExtractedProperties.remove(propertyName);\n\n            if (isSystem)\n            {\n                //we can't remove or nullset a sys prop so let's \"empty\" it.\n                System.setProperty(propertyName, \"\");\n            }\n        }\n        else\n        {\n            if (isSystem)\n            {\n                //in case this is a system property, we must only store it\n                //in the System property set and keep only a ref locally.\n                System.setProperty(propertyName, property.toString());\n                properties.put(propertyName,\n                               new PropertyReference(propertyName));\n            }\n            else\n            {\n                properties.put(propertyName, property);\n            }\n        }\n        if (changeEventDispatcher.hasPropertyChangeListeners(propertyName))\n            changeEventDispatcher.firePropertyChange(\n                propertyName, oldValue, property);\n\n        try\n        {\n            storeConfiguration();\n        }\n        catch (IOException ex)\n        {\n            logger.error(\"Failed to store configuration after \"\n                         + \"a property change\");\n        }\n    }","id":6102,"modified_method":"/**\n     * Sets the property with the specified name to the specified. Calling\n     * this method would first trigger a PropertyChangeEvent that will\n     * be dispatched to all VetoableChangeListeners. In case no complaints\n     * (PropertyVetoException) have been received, the property will be actually\n     * changed and a PropertyChangeEvent will be dispatched. This method also\n     * allows the caller to specify whether or not the specified property is a\n     * system one.\n     * <p>\n     * @param propertyName the name of the property to change.\n     * @param property the new value of the specified property.\n     * @param isSystem specifies whether or not the property being is a System\n     *                 property and should be resolved against the system\n     *                 property set. If the property has previously been\n     *                 specified as system then this value is internally forced\n     *                 to true.\n     * @throws PropertyVetoException in case the changed has been refused by\n     * at least one propertychange listener.\n     */\n    public void setProperty(String propertyName, Object property,\n                            boolean isSystem)\n        throws PropertyVetoException\n    {\n        Object oldValue = getProperty(propertyName);\n\n        //first check whether the change is ok with everyone\n        if (changeEventDispatcher.hasVetoableChangeListeners(propertyName))\n            changeEventDispatcher.fireVetoableChange(\n                propertyName, oldValue, property);\n\n        //no exception was thrown - lets change the property and fire a\n        //change event\n\n        logger.trace(propertyName + \"( oldValue=\" + oldValue\n                     + \", newValue=\" + property + \".\");\n\n        doSetProperty(propertyName, property, isSystem);\n\n        try\n        {\n            storeConfiguration();\n        }\n        catch (IOException ex)\n        {\n            logger.error(\n                \"Failed to store configuration after a property change\");\n        }\n\n        if (changeEventDispatcher.hasPropertyChangeListeners(propertyName))\n            changeEventDispatcher.firePropertyChange(\n                propertyName, oldValue, property);\n    }","commit_id":"19f509b6524fea5b253e1166841c7e0947b06573","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the location of the directory where SIP Communicator is to store\n     * user specific data such as configuration files, message and call history\n     * as well as is bundle repository.\n     *\n     * @return the location of the directory where SIP Communicator is to store\n     * user specific data such as configuration files, message and call history\n     * as well as is bundle repository.\n     */\n    public String getScHomeDirLocation()\n    {\n        //first let's check whether we already have the name of the directory\n        //set as a configuration property\n        String scHomeDirLocation = getString(PNAME_SC_HOME_DIR_LOCATION);\n\n        if (scHomeDirLocation == null)\n        {\n            //no luck, check whether user has specified a custom name in the\n            //system properties\n            scHomeDirLocation\n                = getSystemProperty(PNAME_SC_HOME_DIR_LOCATION);\n\n            if (scHomeDirLocation == null)\n            {\n                scHomeDirLocation = getSystemProperty(\"user.home\");\n            }\n\n            //now save all this as a configuration property so that we don't\n            //have to look for it in the sys props next time and so that it is\n            //available for other bundles to consult.\n            properties.put(PNAME_SC_HOME_DIR_LOCATION, scHomeDirLocation);\n        }\n\n        return scHomeDirLocation;\n    }","id":6103,"modified_method":"/**\n     * Returns the location of the directory where SIP Communicator is to store\n     * user specific data such as configuration files, message and call history\n     * as well as is bundle repository.\n     *\n     * @return the location of the directory where SIP Communicator is to store\n     * user specific data such as configuration files, message and call history\n     * as well as is bundle repository.\n     */\n    public String getScHomeDirLocation()\n    {\n        //first let's check whether we already have the name of the directory\n        //set as a configuration property\n        String scHomeDirLocation = null;\n\n        if (store != null)\n            scHomeDirLocation = getString(PNAME_SC_HOME_DIR_LOCATION);\n\n        if (scHomeDirLocation == null)\n        {\n            //no luck, check whether user has specified a custom name in the\n            //system properties\n            scHomeDirLocation\n                = getSystemProperty(PNAME_SC_HOME_DIR_LOCATION);\n\n            if (scHomeDirLocation == null)\n                scHomeDirLocation = getSystemProperty(\"user.home\");\n\n            //now save all this as a configuration property so that we don't\n            //have to look for it in the sys props next time and so that it is\n            //available for other bundles to consult.\n            if (store != null)\n                store\n                    .setNonSystemProperty(\n                        PNAME_SC_HOME_DIR_LOCATION,\n                        scHomeDirLocation);\n        }\n\n        return scHomeDirLocation;\n    }","commit_id":"19f509b6524fea5b253e1166841c7e0947b06573","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Stores local properties in the specified configuration file.\n     * @param file a reference to the configuration file where properties should\n     *  be stored.\n     * @throws IOException if there was a problem writing to the specified file.\n     */\n    private void storeConfiguration(File file)\n        throws IOException\n    {\n        if(!started)\n            throw new IllegalStateException(\"Service is stopped or has not been started\");\n        \n        //resolve the properties that were initially in the file - back to\n        //the document.\n\n        if (propertiesDocument == null)\n            propertiesDocument = createPropertiesDocument();\n\n        Node root = propertiesDocument.getFirstChild();\n\n        Node currentNode = null;\n        NodeList children = root.getChildNodes();\n        for (int i = 0; i < children.getLength(); i++)\n        {\n            currentNode = children.item(i);\n\n            if (currentNode.getNodeType() == Node.ELEMENT_NODE)\n            {\n                StringBuffer propertyNameBuff = new StringBuffer();\n                propertyNameBuff.append(currentNode.getNodeName());\n                updateNode(currentNode, propertyNameBuff, properties);\n            }\n        }\n\n        //create in the document the properties that were added by other\n        //bundles after the initial property load.\n\n        Map<String, Object> newlyAddedProperties = cloneProperties();\n\n        //remove those that were originally there;\n        for (String propName : fileExtractedProperties.keySet())\n            newlyAddedProperties.remove(propName);\n\n        this.processNewProperties(propertiesDocument,\n                                  newlyAddedProperties);\n\n        //write the file.\n        File config = getConfigurationFile();\n        FailSafeTransaction trans = this.faService\n                                        .createFailSafeTransaction(config);\n        try {\n            trans.beginTransaction();\n            OutputStream stream = new FileOutputStream(config);\n            XMLUtils.indentedWriteXML(\n                    propertiesDocument, stream);\n            stream.close();\n            trans.commit();\n        } catch (Exception e) {\n            logger.error(\"can't write data in the configuration file\", e);\n            trans.rollback();\n        }\n    }","id":6104,"modified_method":"/**\n     * Stores local properties in the specified configuration file.\n     * \n     * @param file a reference to the configuration file where properties should\n     *            be stored.\n     * @throws IOException if there was a problem writing to the specified file.\n     */\n    private void storeConfiguration(File file)\n        throws IOException\n    {\n        if (!started)\n            throw new IllegalStateException(\n                \"Service is stopped or has not been started\");\n\n        // write the file.\n        File config = getConfigurationFile();\n        FailSafeTransaction trans =\n            this.faService.createFailSafeTransaction(config);\n        try\n        {\n            trans.beginTransaction();\n            OutputStream stream = new FileOutputStream(config);\n\n            store.storeConfiguration(stream);\n\n            stream.close();\n            trans.commit();\n        }\n        catch (Exception e)\n        {\n            logger.error(\"can't write data in the configuration file\", e);\n            trans.rollback();\n        }\n    }","commit_id":"19f509b6524fea5b253e1166841c7e0947b06573","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates an entry in the xml <tt>doc<\/tt> for the specified key value\n     * pair.\n     * @param doc the XML <tt>document<\/tt> to update.\n     * @param key the value of the <tt>name<\/tt> attribute for the new entry\n     * @param value the value of the <tt>value<\/tt> attribue for the new\n     * @param isSystem specifies whether this is a system property (system\n     *                 attribute will be set to true).\n     * entry.\n     */\n    private void processNewProperty(Document doc,\n                                    String key,\n                                    String value,\n                                    boolean isSystem)\n    {\n        StringTokenizer tokenizer = new StringTokenizer(key, \".\");\n        String[] toks = new String[tokenizer.countTokens()];\n        int i = 0;\n        while(tokenizer.hasMoreTokens())\n            toks[i++] = tokenizer.nextToken();\n\n        String[] chain = new String[toks.length - 1];\n        for (int j = 0; j < chain.length; j++)\n        {\n            chain[j] = toks[j];\n        }\n\n        String nodeName = toks[toks.length - 1];\n\n        Element parent = XMLConfUtils.createLastPathComponent(doc, chain);\n        Element newNode = XMLConfUtils.findChild(parent, nodeName);\n        if (newNode == null)\n        {\n            newNode = doc.createElement(nodeName);\n            parent.appendChild(newNode);\n        }\n        newNode.setAttribute(\"value\", value);\n\n        if(isSystem)\n            newNode.setAttribute(SYSTEM_ATTRIBUTE_NAME, SYSTEM_ATTRIBUTE_TRUE);\n    }","id":6105,"modified_method":"private void doSetProperty(\n        String propertyName, Object property, boolean isSystem)\n    {\n        //once set system, a property remains system even if the user\n        //specified sth else\n\n        if (isSystem(propertyName))\n            isSystem = true;\n\n        if (property == null)\n        {\n            store.removeProperty(propertyName);\n\n            if (isSystem)\n            {\n                //we can't remove or nullset a sys prop so let's \"empty\" it.\n                System.setProperty(propertyName, \"\");\n            }\n        }\n        else\n        {\n            if (isSystem)\n            {\n                //in case this is a system property, we must only store it\n                //in the System property set and keep only a ref locally.\n                System.setProperty(propertyName, property.toString());\n                store.setSystemProperty(propertyName);\n            }\n            else\n            {\n                store.setNonSystemProperty(propertyName, property);\n            }\n        }\n    }","commit_id":"19f509b6524fea5b253e1166841c7e0947b06573","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Removes the property with the specified name. Calling\n     * this method would first trigger a PropertyChangeEvent that will\n     * be dispatched to all VetoableChangeListeners. In case no complaints\n     * (PropertyVetoException) have been received, the property will be actually\n     * changed and a PropertyChangeEvent will be dispatched.\n     * All properties with prefix propertyName will also be removed.\n     * <p>\n     * @param propertyName the name of the property to change.\n     * @param property the new value of the specified property.\n     * @throws PropertyVetoException in case the changed has been refused by\n     * at least one propertychange listener.\n     */\n    public void removeProperty(String propertyName)\n        throws PropertyVetoException\n    {\n        List<String> childPropertyNames = \n            getPropertyNamesByPrefix(propertyName, false);\n\n        //remove all properties\n        for (String pName : childPropertyNames)\n        {\n            removeProperty(pName);\n        }\n        \n        Object oldValue = getProperty(propertyName);\n        //first check whether the change is ok with everyone\n        if (changeEventDispatcher.hasVetoableChangeListeners(propertyName))\n            changeEventDispatcher.fireVetoableChange(\n                propertyName, oldValue, null);\n\n        //no exception was thrown - lets change the property and fire a\n        //change event\n\n        logger.trace(\"Will remove prop: \" + propertyName + \".\");\n\n        properties.remove(propertyName);\n\n        fileExtractedProperties.remove(propertyName);\n        \n        if (changeEventDispatcher.hasPropertyChangeListeners(propertyName))\n            changeEventDispatcher.firePropertyChange(\n                propertyName, oldValue, null);\n\n        try\n        {\n            storeConfiguration();\n        }\n        catch (IOException ex)\n        {\n            logger.error(\"Failed to store configuration after \"\n                         + \"a property change\");\n        }\n    }","id":6106,"modified_method":"/**\n     * Removes the property with the specified name. Calling\n     * this method would first trigger a PropertyChangeEvent that will\n     * be dispatched to all VetoableChangeListeners. In case no complaints\n     * (PropertyVetoException) have been received, the property will be actually\n     * changed and a PropertyChangeEvent will be dispatched.\n     * All properties with prefix propertyName will also be removed.\n     * <p>\n     * @param propertyName the name of the property to change.\n     * @throws PropertyVetoException in case the changed has been refused by\n     * at least one propertychange listener.\n     */\n    public void removeProperty(String propertyName)\n        throws PropertyVetoException\n    {\n        List<String> childPropertyNames = \n            getPropertyNamesByPrefix(propertyName, false);\n\n        //remove all properties\n        for (String pName : childPropertyNames)\n        {\n            removeProperty(pName);\n        }\n        \n        Object oldValue = getProperty(propertyName);\n        //first check whether the change is ok with everyone\n        if (changeEventDispatcher.hasVetoableChangeListeners(propertyName))\n            changeEventDispatcher.fireVetoableChange(\n                propertyName, oldValue, null);\n\n        //no exception was thrown - lets change the property and fire a\n        //change event\n\n        logger.trace(\"Will remove prop: \" + propertyName + \".\");\n\n        store.removeProperty(propertyName);\n        \n        if (changeEventDispatcher.hasPropertyChangeListeners(propertyName))\n            changeEventDispatcher.firePropertyChange(\n                propertyName, oldValue, null);\n\n        try\n        {\n            storeConfiguration();\n        }\n        catch (IOException ex)\n        {\n            logger.error(\"Failed to store configuration after \"\n                         + \"a property change\");\n        }\n    }","commit_id":"19f509b6524fea5b253e1166841c7e0947b06573","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Goes over all system properties and outputs their names and values for\n     * debug purposes. The method has no effect if the logger is at a log level\n     * other than DEBUG or TRACE (FINE or FINEST).\n     */\n    private void debugPrintSystemProperties()\n    {\n        if (logger.isDebugEnabled())\n        {\n            Properties pValues = System.getProperties();\n            for (Map.Entry<Object, Object> entry : pValues.entrySet())\n                logger.debug(entry.getKey() + \"=\" + entry.getValue());\n        }\n    }","id":6107,"modified_method":"/**\n     * Goes over all system properties and outputs their names and values for\n     * debug purposes. The method has no effect if the logger is at a log level\n     * other than DEBUG or TRACE (FINE or FINEST).\n     */\n    private void debugPrintSystemProperties()\n    {\n        if (logger.isDebugEnabled())\n        {\n            for (Map.Entry<Object, Object> entry\n                    : System.getProperties().entrySet())\n                logger.debug(entry.getKey() + \"=\" + entry.getValue());\n        }\n    }","commit_id":"19f509b6524fea5b253e1166841c7e0947b06573","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * The method scans the contents of the SYS_PROPS_FILE_NAME_PROPERTY where\n     * it expects to find a comma separated list of names of files that should\n     * be loaded as system properties. The method then parses these files and\n     * loads their contents as system properties. All such files have to be in\n     * a location that's in the classpath.\n     */\n    public void preloadSystemPropertyFiles()\n    {\n        String propertyFilesListStr\n            = System.getProperty( SYS_PROPS_FILE_NAME_PROPERTY );\n\n        if(propertyFilesListStr == null || propertyFilesListStr.trim().length() == 0)\n            return;\n\n        StringTokenizer tokenizer\n            = new StringTokenizer(propertyFilesListStr, \";,\", false);\n\n        while( tokenizer.hasMoreTokens())\n        {\n            String fileName = tokenizer.nextToken();\n            try\n            {\n                fileName = fileName.trim();\n\n                Properties fileProps = new Properties();\n\n                fileProps.load(ClassLoader.getSystemResourceAsStream(fileName));\n\n                // now set all of this file's properties as system properties\n                for (Map.Entry<Object, Object> entry : fileProps.entrySet())\n                    System.setProperty((String) entry.getKey(), (String) entry\n                        .getValue());\n            }\n            catch (Exception ex)\n            {\n                //this is an insignificant method that should never affect\n                //the rest of the application so we'll afford ourselves to\n                //kind of silence all possible exceptions (which would most\n                //often be IOExceptions). We will however log them in case\n                //anyone would be interested.\n                logger.error(\"Failed to load property file: \"\n                    + fileName\n                    , ex);\n            }\n        }\n    }","id":6108,"modified_method":"/**\n     * The method scans the contents of the SYS_PROPS_FILE_NAME_PROPERTY where\n     * it expects to find a comma separated list of names of files that should\n     * be loaded as system properties. The method then parses these files and\n     * loads their contents as system properties. All such files have to be in\n     * a location that's in the classpath.\n     */\n    private void preloadSystemPropertyFiles()\n    {\n        String propertyFilesListStr\n            = System.getProperty( SYS_PROPS_FILE_NAME_PROPERTY );\n\n        if(propertyFilesListStr == null || propertyFilesListStr.trim().length() == 0)\n            return;\n\n        StringTokenizer tokenizer\n            = new StringTokenizer(propertyFilesListStr, \";,\", false);\n\n        while( tokenizer.hasMoreTokens())\n        {\n            String fileName = tokenizer.nextToken();\n            try\n            {\n                fileName = fileName.trim();\n\n                Properties fileProps = new Properties();\n\n                fileProps.load(ClassLoader.getSystemResourceAsStream(fileName));\n\n                // now set all of this file's properties as system properties\n                for (Map.Entry<Object, Object> entry : fileProps.entrySet())\n                    System.setProperty((String) entry.getKey(), (String) entry\n                        .getValue());\n            }\n            catch (Exception ex)\n            {\n                //this is an insignificant method that should never affect\n                //the rest of the application so we'll afford ourselves to\n                //kind of silence all possible exceptions (which would most\n                //often be IOExceptions). We will however log them in case\n                //anyone would be interested.\n                logger.error(\"Failed to load property file: \"\n                    + fileName\n                    , ex);\n            }\n        }\n    }","commit_id":"19f509b6524fea5b253e1166841c7e0947b06573","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Deletes the configuration file currently used by this implementation.\n     */\n    public void purgeStoredConfiguration()\n    {\n        if (this.configurationFile != null)\n        {\n            configurationFile.delete();\n            configurationFile = null;\n        }\n    }","id":6109,"modified_method":"/**\n     * Deletes the configuration file currently used by this implementation.\n     */\n    public void purgeStoredConfiguration()\n    {\n        if (configurationFile != null)\n        {\n            configurationFile.delete();\n            configurationFile = null;\n        }\n    }","commit_id":"19f509b6524fea5b253e1166841c7e0947b06573","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Determines whether the property with the specified\n     * <tt>propertyName<\/tt> has been previously declared as System\n     *\n     * @param propertyName the name of the property to verify\n     * @return true if someone at some point specified that property to be\n     * system. (This could have been either through a call to\n     * setProperty(string, true)) or by setting the system attribute in the\n     * xml conf file to true.\n     */\n    private boolean isSystem(String propertyName)\n    {\n        return properties.containsKey(propertyName)\n               && properties.get(propertyName) instanceof PropertyReference;\n    }","id":6110,"modified_method":"/**\n     * Determines whether the property with the specified\n     * <tt>propertyName<\/tt> has been previously declared as System\n     *\n     * @param propertyName the name of the property to verify\n     * @return true if someone at some point specified that property to be\n     * system. (This could have been either through a call to\n     * setProperty(string, true)) or by setting the system attribute in the\n     * xml conf file to true.\n     */\n    private boolean isSystem(String propertyName)\n    {\n        return store.isSystem(propertyName);\n    }","commit_id":"19f509b6524fea5b253e1166841c7e0947b06573","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates new entries in the XML <tt>doc<\/tt> for every element in the\n     * <tt>newProperties<\/tt> table.\n     * \n     * @param doc the XML <tt>Document<\/tt> where the new entries should be\n     *            created\n     * @param newProperties the table containing the properties that are to be\n     *            introduced in the document.\n     */\n    private void processNewProperties(Document doc,\n                                      Map<String, Object>      newProperties)\n    {\n        for (Map.Entry<String, Object> entry : newProperties.entrySet())\n        {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n            boolean isSystem = value instanceof PropertyReference;\n            value = isSystem\n                        ?((PropertyReference)value).getValue()\n                        :value;\n            processNewProperty(doc, key, value.toString(), isSystem);\n        }\n    }","id":6111,"modified_method":"public void setProperties(Map<String, Object> properties)\n        throws PropertyVetoException\n    {\n        //first check whether the changes are ok with everyone\n        Map<String, Object> oldValues\n            = new HashMap<String, Object>(properties.size());\n        for (Map.Entry<String, Object> property : properties.entrySet())\n        {\n            String propertyName = property.getKey();\n            Object oldValue = getProperty(propertyName);\n\n            oldValues.put(propertyName, oldValue);\n\n            if (changeEventDispatcher.hasVetoableChangeListeners(propertyName))\n                changeEventDispatcher\n                    .fireVetoableChange(\n                        propertyName,\n                        oldValue,\n                        property.getValue());\n        }\n\n        for (Map.Entry<String, Object> property : properties.entrySet())\n            doSetProperty(property.getKey(), property.getValue(), false);\n\n        try\n        {\n            storeConfiguration();\n        }\n        catch (IOException ex)\n        {\n            logger.error(\n                \"Failed to store configuration after property changes\");\n        }\n\n        for (Map.Entry<String, Object> property : properties.entrySet())\n        {\n            String propertyName = property.getKey();\n\n            if (changeEventDispatcher.hasPropertyChangeListeners(propertyName))\n                changeEventDispatcher\n                    .firePropertyChange(\n                        propertyName,\n                        oldValues.get(propertyName),\n                        property.getValue());\n        }\n    }","commit_id":"19f509b6524fea5b253e1166841c7e0947b06573","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the name of the directory where SIP Communicator is to store user\n     * specific data such as configuration files, message and call history\n     * as well as is bundle repository.\n     *\n     * @return the name of the directory where SIP Communicator is to store\n     * user specific data such as configuration files, message and call history\n     * as well as is bundle repository.\n     */\n    public String getScHomeDirName()\n    {\n        //first let's check whether we already have the name of the directory\n        //set as a configuration property\n        String scHomeDirName = getString(PNAME_SC_HOME_DIR_NAME);\n\n        if (scHomeDirName == null)\n        {\n            //no luck, check whether user has specified a custom name in the\n            //system properties\n            scHomeDirName\n                = getSystemProperty(PNAME_SC_HOME_DIR_NAME);\n\n            if (scHomeDirName == null)\n            {\n                scHomeDirName = \".sip-communicator\";\n            }\n\n            //now save all this as a configuration property so that we don't\n            //have to look for it in the sys props next time and so that it is\n            //available for other bundles to consult.\n            properties.put(PNAME_SC_HOME_DIR_NAME, scHomeDirName);\n        }\n\n        return scHomeDirName;\n    }","id":6112,"modified_method":"/**\n     * Returns the name of the directory where SIP Communicator is to store user\n     * specific data such as configuration files, message and call history\n     * as well as is bundle repository.\n     *\n     * @return the name of the directory where SIP Communicator is to store\n     * user specific data such as configuration files, message and call history\n     * as well as is bundle repository.\n     */\n    public String getScHomeDirName()\n    {\n        //first let's check whether we already have the name of the directory\n        //set as a configuration property\n        String scHomeDirName = null;\n\n        if (store != null)\n            scHomeDirName = getString(PNAME_SC_HOME_DIR_NAME);\n\n        if (scHomeDirName == null)\n        {\n            //no luck, check whether user has specified a custom name in the\n            //system properties\n            scHomeDirName\n                = getSystemProperty(PNAME_SC_HOME_DIR_NAME);\n\n            if (scHomeDirName == null)\n                scHomeDirName = \".sip-communicator\";\n\n            //now save all this as a configuration property so that we don't\n            //have to look for it in the sys props next time and so that it is\n            // available for other bundles to consult.\n            if (store != null)\n                store\n                    .setNonSystemProperty(\n                        PNAME_SC_HOME_DIR_NAME,\n                        scHomeDirName);\n        }\n\n        return scHomeDirName;\n    }","commit_id":"19f509b6524fea5b253e1166841c7e0947b06573","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the value of the specified java system property. In case the\n     * value was a zero length String or one that only contained whitespaces,\n     * null is returned. This method is for internal use only. Users of the\n     * configuration service are to use the getProperty() or getString() methods\n     * which would automatically determine whether a property is system or not.\n     * @param propertyName the name of the property whose value we need.\n     * @return the value of the property with name propertyName or null if\n     * the value had length 0 or only contained spaces tabs or new lines.\n     */\n    private static String getSystemProperty(String propertyName)\n    {\n        String retval = System.getProperty(propertyName);\n        if (retval == null){\n            return retval;\n        }\n\n        if (retval.trim().length() == 0){\n            return null;\n        }\n        return retval;\n    }","id":6113,"modified_method":"/**\n     * Returns the value of the specified java system property. In case the\n     * value was a zero length String or one that only contained whitespaces,\n     * null is returned. This method is for internal use only. Users of the\n     * configuration service are to use the getProperty() or getString() methods\n     * which would automatically determine whether a property is system or not.\n     * @param propertyName the name of the property whose value we need.\n     * @return the value of the property with name propertyName or null if\n     * the value had length 0 or only contained spaces tabs or new lines.\n     */\n    private static String getSystemProperty(String propertyName)\n    {\n        String retval = System.getProperty(propertyName);\n        if ((retval != null) && (retval.trim().length() == 0))\n            retval = null;\n        return retval;\n    }","commit_id":"19f509b6524fea5b253e1166841c7e0947b06573","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Saves the event notification given by these parameters through the\n     * <tt>ConfigurationService<\/tt>.\n     * \n     * @param eventType the name of the event\n     * @param actionType the type of action\n     * @param actionHandler the notification action handler responsible for\n     * handling the given <tt>actionType<\/tt>\n     */\n    private void saveNotification(  String eventType,\n                                    String actionType,\n                                    NotificationActionHandler actionHandler,\n                                    boolean isActive,\n                                    boolean isDefault)\n    {\n        String eventTypeNodeName = null;\n        String actionTypeNodeName = null;\n\n        List<String> eventTypes = configService\n                .getPropertyNamesByPrefix(NOTIFICATIONS_PREFIX, true);\n\n        for (String eventTypeRootPropName : eventTypes)\n        {\n            String eType\n                = configService.getString(eventTypeRootPropName);\n            \n            if(eType.equals(eventType))\n                eventTypeNodeName = eventTypeRootPropName;\n        }\n\n        // If we didn't find the given event type in the configuration we save\n        // it here.\n        if(eventTypeNodeName == null)\n        {\n            eventTypeNodeName = NOTIFICATIONS_PREFIX\n                                + \".eventType\" \n                                + Long.toString(System.currentTimeMillis());\n            \n            configService.setProperty(eventTypeNodeName, eventType);\n        }\n        \n        // if we set active/inactive for the whole event notification\n        if(actionType == null && actionHandler == null)\n        {\n            configService.setProperty(\n                eventTypeNodeName + \".active\",\n                Boolean.toString(isActive));\n            \n            return;\n        }\n        \n        // Go through contained actions.\n        String actionPrefix = eventTypeNodeName + \".actions\";\n    \n        List<String> actionTypes = configService\n                .getPropertyNamesByPrefix(actionPrefix, true);\n\n        for (String actionTypeRootPropName : actionTypes)\n        {\n            String aType\n                = configService.getString(actionTypeRootPropName);\n            \n            if(aType.equals(actionType))\n                actionTypeNodeName = actionTypeRootPropName;\n        }\n\n        // If we didn't find the given actionType in the configuration we save\n        // it here.\n        if(actionTypeNodeName == null)\n        {\n            actionTypeNodeName = actionPrefix\n                                    + \".actionType\"\n                                    + Long.toString(System.currentTimeMillis());\n        \n            configService.setProperty(actionTypeNodeName, actionType);        \n        }\n        \n        if(actionHandler instanceof SoundNotificationHandler)\n        {\n            SoundNotificationHandler soundHandler\n                = (SoundNotificationHandler) actionHandler;\n            \n            configService.setProperty(\n                actionTypeNodeName + \".soundFileDescriptor\",\n                soundHandler.getDescriptor());\n            \n            configService.setProperty(\n                actionTypeNodeName + \".loopInterval\",\n                soundHandler.getLoopInterval());\n            \n            configService.setProperty(\n                actionTypeNodeName + \".enabled\",\n                Boolean.toString(isActive));\n            \n            configService.setProperty(\n                actionTypeNodeName + \".default\",\n                Boolean.toString(isDefault));\n        }\n        else if(actionHandler instanceof PopupMessageNotificationHandler)\n        {\n            PopupMessageNotificationHandler messageHandler\n                = (PopupMessageNotificationHandler) actionHandler;\n        \n            configService.setProperty(\n                actionTypeNodeName + \".defaultMessage\",\n                messageHandler.getDefaultMessage());      \n            \n            configService.setProperty(\n                actionTypeNodeName + \".enabled\",\n                Boolean.toString(isActive));\n            \n            configService.setProperty(\n                actionTypeNodeName + \".default\",\n                Boolean.toString(isDefault));\n        }\n        else if(actionHandler instanceof LogMessageNotificationHandler)\n        {\n            LogMessageNotificationHandler logMessageHandler\n                = (LogMessageNotificationHandler) actionHandler;\n    \n            configService.setProperty(\n                actionTypeNodeName + \".logType\",\n                logMessageHandler.getLogType());\n            \n            configService.setProperty(\n                actionTypeNodeName + \".enabled\",\n                Boolean.toString(isActive));\n            \n            configService.setProperty(\n                actionTypeNodeName + \".default\",\n                Boolean.toString(isDefault));\n        }\n        else if(actionHandler instanceof CommandNotificationHandler)\n        {\n            CommandNotificationHandler commandHandler\n                = (CommandNotificationHandler) actionHandler;\n    \n            configService.setProperty(\n                actionTypeNodeName + \".commandDescriptor\",\n                commandHandler.getDescriptor());\n            \n            configService.setProperty(\n                actionTypeNodeName + \".enabled\",\n                Boolean.toString(isActive));\n            \n            configService.setProperty(\n                actionTypeNodeName + \".default\",\n                Boolean.toString(isDefault));\n        }\n    }","id":6114,"modified_method":"/**\n     * Saves the event notification given by these parameters through the\n     * <tt>ConfigurationService<\/tt>.\n     * \n     * @param eventType the name of the event\n     * @param actionType the type of action\n     * @param actionHandler the notification action handler responsible for\n     * handling the given <tt>actionType<\/tt>\n     */\n    private void saveNotification(  String eventType,\n                                    String actionType,\n                                    NotificationActionHandler actionHandler,\n                                    boolean isActive,\n                                    boolean isDefault)\n    {\n        String eventTypeNodeName = null;\n        String actionTypeNodeName = null;\n\n        List<String> eventTypes = configService\n                .getPropertyNamesByPrefix(NOTIFICATIONS_PREFIX, true);\n\n        for (String eventTypeRootPropName : eventTypes)\n        {\n            String eType\n                = configService.getString(eventTypeRootPropName);\n            \n            if(eType.equals(eventType))\n                eventTypeNodeName = eventTypeRootPropName;\n        }\n\n        // If we didn't find the given event type in the configuration we save\n        // it here.\n        if(eventTypeNodeName == null)\n        {\n            eventTypeNodeName = NOTIFICATIONS_PREFIX\n                                + \".eventType\" \n                                + Long.toString(System.currentTimeMillis());\n            \n            configService.setProperty(eventTypeNodeName, eventType);\n        }\n        \n        // if we set active/inactive for the whole event notification\n        if(actionType == null && actionHandler == null)\n        {\n            configService.setProperty(\n                eventTypeNodeName + \".active\",\n                Boolean.toString(isActive));\n            return;\n        }\n        \n        // Go through contained actions.\n        String actionPrefix = eventTypeNodeName + \".actions\";\n    \n        List<String> actionTypes = configService\n                .getPropertyNamesByPrefix(actionPrefix, true);\n\n        for (String actionTypeRootPropName : actionTypes)\n        {\n            String aType\n                = configService.getString(actionTypeRootPropName);\n            \n            if(aType.equals(actionType))\n                actionTypeNodeName = actionTypeRootPropName;\n        }\n\n        Map<String, Object> configProperties = new HashMap<String, Object>();\n\n        // If we didn't find the given actionType in the configuration we save\n        // it here.\n        if(actionTypeNodeName == null)\n        {\n            actionTypeNodeName = actionPrefix\n                                    + \".actionType\"\n                                    + Long.toString(System.currentTimeMillis());\n        \n            configProperties.put(actionTypeNodeName, actionType);        \n        }\n        \n        if(actionHandler instanceof SoundNotificationHandler)\n        {\n            SoundNotificationHandler soundHandler\n                = (SoundNotificationHandler) actionHandler;\n            \n            configProperties.put(\n                actionTypeNodeName + \".soundFileDescriptor\",\n                soundHandler.getDescriptor());\n            \n            configProperties.put(\n                actionTypeNodeName + \".loopInterval\",\n                soundHandler.getLoopInterval());\n            \n            configProperties.put(\n                actionTypeNodeName + \".enabled\",\n                Boolean.toString(isActive));\n            \n            configProperties.put(\n                actionTypeNodeName + \".default\",\n                Boolean.toString(isDefault));\n        }\n        else if(actionHandler instanceof PopupMessageNotificationHandler)\n        {\n            PopupMessageNotificationHandler messageHandler\n                = (PopupMessageNotificationHandler) actionHandler;\n        \n            configProperties.put(\n                actionTypeNodeName + \".defaultMessage\",\n                messageHandler.getDefaultMessage());      \n            \n            configProperties.put(\n                actionTypeNodeName + \".enabled\",\n                Boolean.toString(isActive));\n            \n            configProperties.put(\n                actionTypeNodeName + \".default\",\n                Boolean.toString(isDefault));\n        }\n        else if(actionHandler instanceof LogMessageNotificationHandler)\n        {\n            LogMessageNotificationHandler logMessageHandler\n                = (LogMessageNotificationHandler) actionHandler;\n    \n            configProperties.put(\n                actionTypeNodeName + \".logType\",\n                logMessageHandler.getLogType());\n            \n            configProperties.put(\n                actionTypeNodeName + \".enabled\",\n                Boolean.toString(isActive));\n            \n            configProperties.put(\n                actionTypeNodeName + \".default\",\n                Boolean.toString(isDefault));\n        }\n        else if(actionHandler instanceof CommandNotificationHandler)\n        {\n            CommandNotificationHandler commandHandler\n                = (CommandNotificationHandler) actionHandler;\n    \n            configProperties.put(\n                actionTypeNodeName + \".commandDescriptor\",\n                commandHandler.getDescriptor());\n            \n            configProperties.put(\n                actionTypeNodeName + \".enabled\",\n                Boolean.toString(isActive));\n            \n            configProperties.put(\n                actionTypeNodeName + \".default\",\n                Boolean.toString(isDefault));\n        }\n\n        if (configProperties.size() > 0)\n            configService.setProperties(configProperties);\n    }","commit_id":"19f509b6524fea5b253e1166841c7e0947b06573","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Constructs a <tt>PropertyVetoException<\/tt> with a\n     * detailed message.\n     *\n     * @param mess Descriptive message\n     * @param evt A PropertyChangeEvent describing the vetoed change.\n     */\n    public PropertyVetoException(String mess, PropertyChangeEvent evt)\n    {\n        super(mess);\n        this.evt = evt;\n    }","id":6115,"modified_method":"/**\n     * Constructs a <tt>PropertyVetoException<\/tt> with a\n     * detailed message.\n     *\n     * @param message Descriptive message\n     * @param evt A PropertyChangeEvent describing the vetoed change.\n     */\n    public PropertyVetoException(String message, PropertyChangeEvent evt)\n    {\n        super(message);\n\n        this.evt = evt;\n    }","commit_id":"19f509b6524fea5b253e1166841c7e0947b06573","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Sets the property with the specified name to the specified. Calling\n     * this method would first trigger a PropertyChangeEvent that will\n     * be dispatched to all VetoableChangeListeners. In case no complaints\n     * (PropertyVetoException) have been received, the property will be actually\n     * changed and a PropertyChangeEvent will be dispatched. This method also\n     * allows the caller to specify whether or not the specified property is a\n     * system one.\n     * <p>\n     * @param propertyName the name of the property to change.\n     * @param property the new value of the specified property.\n     * @param isSystem specifies whether or not the property being is a System\n     *                 property and should be resolved against the system\n     *                 property set. If the property has previously been\n     *                 specified as system then this value is inteernally forced\n     *                 to true.\n     * @throws PropertyVetoException in case the changed has been refused by\n     * at least one propertychange listener.\n     */\n    public void setProperty(String propertyName, Object property,\n                            boolean isSystem)\n        throws PropertyVetoException\n    {\n        Object oldValue = getProperty(propertyName);\n        //first check whether the change is ok with everyone\n        if (changeEventDispatcher.hasVetoableChangeListeners(propertyName))\n            changeEventDispatcher.fireVetoableChange(\n                propertyName, oldValue, property);\n\n        //no exception was thrown - lets change the property and fire a\n        //change event\n\n        logger.trace(propertyName + \"( oldValue=\" + oldValue\n                     + \", newValue=\" + property + \".\");\n\n        //once set system, a property remains system event if the user\n        //specified sth else\n\n        if (isSystem(propertyName))\n            isSystem = true;\n\n        if (property == null)\n        {\n            properties.remove(propertyName);\n\n            fileExtractedProperties.remove(propertyName);\n\n            if (isSystem)\n            {\n                //we can't remove or nullset a sys prop so let's \"empty\" it.\n                System.setProperty(propertyName, \"\");\n            }\n        }\n        else\n        {\n            if (isSystem)\n            {\n                //in case this is a system property, we must only store it\n                //in the System property set and keep only a ref locally.\n                System.setProperty(propertyName, property.toString());\n                properties.put(propertyName,\n                               new PropertyReference(propertyName));\n            }\n            else\n            {\n                properties.put(propertyName, property);\n            }\n        }\n        if (changeEventDispatcher.hasPropertyChangeListeners(propertyName))\n            changeEventDispatcher.firePropertyChange(\n                propertyName, oldValue, property);\n\n        try\n        {\n            storeConfiguration();\n        }\n        catch (IOException ex)\n        {\n            logger.error(\"Failed to store configuration after \"\n                         + \"a property change\");\n        }\n    }","id":6116,"modified_method":"/**\n     * Sets the property with the specified name to the specified. Calling\n     * this method would first trigger a PropertyChangeEvent that will\n     * be dispatched to all VetoableChangeListeners. In case no complaints\n     * (PropertyVetoException) have been received, the property will be actually\n     * changed and a PropertyChangeEvent will be dispatched. This method also\n     * allows the caller to specify whether or not the specified property is a\n     * system one.\n     * <p>\n     * @param propertyName the name of the property to change.\n     * @param property the new value of the specified property.\n     * @param isSystem specifies whether or not the property being is a System\n     *                 property and should be resolved against the system\n     *                 property set. If the property has previously been\n     *                 specified as system then this value is inteernally forced\n     *                 to true.\n     * @throws PropertyVetoException in case the changed has been refused by\n     * at least one propertychange listener.\n     */\n    public void setProperty(String propertyName, Object property,\n                            boolean isSystem)\n        throws PropertyVetoException\n    {\n        Object oldValue = getProperty(propertyName);\n        //first check whether the change is ok with everyone\n        if (changeEventDispatcher.hasVetoableChangeListeners(propertyName))\n            changeEventDispatcher.fireVetoableChange(\n                propertyName, oldValue, property);\n\n        //no exception was thrown - lets change the property and fire a\n        //change event\n\n        logger.trace(propertyName + \"( oldValue=\" + oldValue\n                     + \", newValue=\" + property + \".\");\n\n        //once set system, a property remains system even if the user\n        //specified sth else\n\n        if (isSystem(propertyName))\n            isSystem = true;\n\n        if (property == null)\n        {\n            store.removeProperty(propertyName);\n\n            if (isSystem)\n            {\n                //we can't remove or nullset a sys prop so let's \"empty\" it.\n                System.setProperty(propertyName, \"\");\n            }\n        }\n        else\n        {\n            if (isSystem)\n            {\n                //in case this is a system property, we must only store it\n                //in the System property set and keep only a ref locally.\n                System.setProperty(propertyName, property.toString());\n                store.setSystemProperty(propertyName);\n            }\n            else\n            {\n                store.setNonSystemProperty(propertyName, property);\n            }\n        }\n        if (changeEventDispatcher.hasPropertyChangeListeners(propertyName))\n            changeEventDispatcher.firePropertyChange(\n                propertyName, oldValue, property);\n\n        try\n        {\n            storeConfiguration();\n        }\n        catch (IOException ex)\n        {\n            logger.error(\"Failed to store configuration after \"\n                         + \"a property change\");\n        }\n    }","commit_id":"10064c4066db73be5d7afff78d1a080fd2c157e3","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the value of the property with the specified name or null if no\n     * such property exists.\n     * @param propertyName the name of the property that is being queried.\n     * @return the value of the property with the specified name.\n     */\n    public Object getProperty(String propertyName)\n    {\n        Object value = properties.get(propertyName);\n\n        //if this is a property reference make sure we return the referenced\n        //value and not the reference itself\n        if(value instanceof PropertyReference)\n            return ((PropertyReference)value).getValue();\n        else\n            return value;\n    }","id":6117,"modified_method":"/**\n     * Returns the value of the property with the specified name or null if no\n     * such property exists.\n     * \n     * @param propertyName the name of the property that is being queried.\n     * @return the value of the property with the specified name.\n     */\n    public Object getProperty(String propertyName)\n    {\n        return store.getProperty(propertyName);\n    }","commit_id":"10064c4066db73be5d7afff78d1a080fd2c157e3","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns a reference to the configuration file that the service should\n     * load. The method would try to load a file with the name\n     * sip-communicator.xml unless a different one is specified in the system\n     * property net.java.sip.communicator.PROPERTIES_FILE_NAME . The method\n     * would first try to load the file from the current directory if it exists\n     * this is not the case a load would be attempted from the\n     * $HOME/.sip-communicator directory. In case it was not found there either\n     * we'll look for it in all locations currently present in the $CLASSPATH.\n     * In case we find it in there we will copy it to the\n     * $HOME/.sip-communicator directory in case it was in a jar archive and\n     * return the reference to the newly created file. In case the file is\n     * to be found noweher - a new empty file in the user home directory and\n     * returns a link to that one.\n     *\n     *\n     * @return the configuration file currently used by the implementation.\n     */\n    File createConfigurationFile()\n    {\n        try\n        {\n            //see whether we have a user specified name for the conf file\n            String pFileName = getSystemProperty(\n                FILE_NAME_PROPERTY);\n            if (pFileName == null)\n            {\n                pFileName = \"sip-communicator.xml\";\n            }\n\n            // try to open the file in current directory\n            File configFileInCurrentDir = new File(pFileName);\n            if (configFileInCurrentDir.exists())\n            {\n                logger.debug(\"Using config file in current dir: \"\n                             + configFileInCurrentDir.getCanonicalPath());\n                return configFileInCurrentDir;\n            }\n\n            // we didn't find it in \".\", try the SIP Communicator home directory\n            // first check whether a custom SC home directory is specified\n\n            //name of the sip-communicator home directory\n            String scHomeDirName = getScHomeDirName();\n\n            //location of the sip-communicator home directory\n            String scHomeDirLocation = getScHomeDirLocation();\n\n            File configDir = new File( scHomeDirLocation\n                                       + File.separator + scHomeDirName);\n\n            File configFileInUserHomeDir =\n                new File(configDir, pFileName);\n\n            if (configFileInUserHomeDir.exists())\n            {\n                logger.debug(\"Using config file in $HOME/.sip-communicator: \"\n                             + configFileInCurrentDir.getCanonicalPath());\n                return configFileInUserHomeDir;\n            }\n\n            // If we are in a jar - copy config file from jar to user home.\n            logger.trace(\"Copying config file.\");\n\n            configDir.mkdirs();\n            InputStream in = getClass().getClassLoader().\n                getResourceAsStream(pFileName);\n\n            //Return an empty file if there wasn't any in the jar\n            //null check report from John J. Barton - IBM\n            if (in == null)\n            {\n                configFileInUserHomeDir.createNewFile();\n                logger.debug(\"Created an empty file in $HOME: \"\n                             + configFileInCurrentDir.getCanonicalPath());\n                return configFileInUserHomeDir;\n            }\n            BufferedReader reader =\n                new BufferedReader(new InputStreamReader(in));\n\n            PrintWriter writer = new PrintWriter(new FileWriter(\n                configFileInUserHomeDir));\n\n            String line = null;\n            logger.debug(\"Copying properties file:\");\n            while ( (line = reader.readLine()) != null)\n            {\n                writer.println(line);\n                logger.debug(line);\n            }\n            writer.flush();\n            return configFileInUserHomeDir;\n        }\n        catch (IOException ex)\n        {\n            logger.error(\"Error creating config file\", ex);\n            return null;\n        }\n    }","id":6118,"modified_method":"/**\n     * Returns a reference to the configuration file that the service should\n     * load. The method would try to load a file with the name\n     * sip-communicator.xml unless a different one is specified in the system\n     * property net.java.sip.communicator.PROPERTIES_FILE_NAME . The method\n     * would first try to load the file from the current directory if it exists\n     * this is not the case a load would be attempted from the\n     * $HOME/.sip-communicator directory. In case it was not found there either\n     * we'll look for it in all locations currently present in the $CLASSPATH.\n     * In case we find it in there we will copy it to the\n     * $HOME/.sip-communicator directory in case it was in a jar archive and\n     * return the reference to the newly created file. In case the file is\n     * to be found noweher - a new empty file in the user home directory and\n     * returns a link to that one.\n     *\n     *\n     * @return the configuration file currently used by the implementation.\n     */\n    File createConfigurationFile()\n    {\n        try\n        {\n            //see whether we have a user specified name for the conf file\n            String pFileName = getSystemProperty(\n                FILE_NAME_PROPERTY);\n            if (pFileName == null)\n            {\n                pFileName = \"sip-communicator.xml\";\n            }\n\n            // try to open the file in current directory\n            File configFileInCurrentDir = new File(pFileName);\n            if (configFileInCurrentDir.exists())\n            {\n                logger.debug(\"Using config file in current dir: \"\n                             + configFileInCurrentDir.getCanonicalPath());\n                return configFileInCurrentDir;\n            }\n\n            // we didn't find it in \".\", try the SIP Communicator home directory\n            // first check whether a custom SC home directory is specified\n\n            //name of the sip-communicator home directory\n            String scHomeDirName = getScHomeDirName();\n\n            //location of the sip-communicator home directory\n            String scHomeDirLocation = getScHomeDirLocation();\n\n            File configDir = new File( scHomeDirLocation\n                                       + File.separator + scHomeDirName);\n\n            File configFileInUserHomeDir =\n                new File(configDir, pFileName);\n\n            if (configFileInUserHomeDir.exists())\n            {\n                logger.debug(\"Using config file in $HOME/.sip-communicator: \"\n                             + configFileInCurrentDir.getCanonicalPath());\n                return configFileInUserHomeDir;\n            }\n\n            // If we are in a jar - copy config file from jar to user home.\n            logger.trace(\"Copying config file.\");\n\n            configDir.mkdirs();\n            InputStream in = getClass().getClassLoader().\n                getResourceAsStream(pFileName);\n\n            //Return an empty file if there wasn't any in the jar\n            //null check report from John J. Barton - IBM\n            if (in == null)\n            {\n                configFileInUserHomeDir.createNewFile();\n                logger.debug(\"Created an empty file in $HOME: \"\n                             + configFileInCurrentDir.getCanonicalPath());\n                return configFileInUserHomeDir;\n            }\n            BufferedReader reader =\n                new BufferedReader(new InputStreamReader(in));\n\n            PrintWriter writer = new PrintWriter(new FileWriter(\n                configFileInUserHomeDir));\n\n            String line;\n            logger.debug(\"Copying properties file:\");\n            while ( (line = reader.readLine()) != null)\n            {\n                writer.println(line);\n                logger.debug(line);\n            }\n            writer.flush();\n            return configFileInUserHomeDir;\n        }\n        catch (IOException ex)\n        {\n            logger.error(\"Error creating config file\", ex);\n            return null;\n        }\n    }","commit_id":"10064c4066db73be5d7afff78d1a080fd2c157e3","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns a <tt>java.util.List<\/tt> of <tt>String<\/tt>s containing the\n     * all property names that have the specified prefix. Depending on the value\n     * of the <tt>exactPrefixMatch<\/tt> parameter the method will (when false)\n     * or will not (when exactPrefixMatch is true) include property names that\n     * have prefixes longer than the specified <tt>prefix<\/tt> param.\n     * <p>\n     * Example:\n     * <p>\n     * Imagine a configuration service instance containing 2 properties only:<br>\n     * <code>\n     * net.java.sip.communicator.PROP1=value1<br>\n     * net.java.sip.communicator.service.protocol.PROP1=value2\n     * <\/code>\n     * <p>\n     * A call to this method with a prefix=\"net.java.sip.communicator\" and\n     * exactPrefixMatch=true would only return the first property -\n     * net.java.sip.communicator.PROP1, whereas the same call with\n     * exactPrefixMatch=false would return both properties as the second prefix\n     * includes the requested prefix string.\n     * <p>\n     * @param prefix a String containing the prefix (the non dotted non-caps\n     * part of a property name) that we're looking for.\n     * @param exactPrefixMatch a boolean indicating whether the returned\n     * property names should all have a prefix that is an exact match of the\n     * the <tt>prefix<\/tt> param or whether properties with prefixes that\n     * contain it but are longer than it are also accepted.\n     * @return a <tt>java.util.List<\/tt>containing all property name String-s\n     * matching the specified conditions.\n     */\n    public List<String> getPropertyNamesByPrefix(String prefix, boolean exactPrefixMatch)\n    {\n        List<String> resultKeySet = new LinkedList<String>();\n\n        for (String key : properties.keySet())\n        {\n            int ix = key.lastIndexOf('.');\n            \n            if(ix == -1)\n                continue;\n            \n            String keyPrefix = key.substring(0, ix);\n\n            if(exactPrefixMatch)\n            {\n                if(prefix.equals(keyPrefix))\n                    resultKeySet.add(key);\n            }\n            else\n            {\n                if(keyPrefix.startsWith(prefix))\n                    resultKeySet.add(key);\n            }\n        }\n\n        return resultKeySet;\n    }","id":6119,"modified_method":"/**\n     * Returns a <tt>java.util.List<\/tt> of <tt>String<\/tt>s containing the\n     * all property names that have the specified prefix. Depending on the value\n     * of the <tt>exactPrefixMatch<\/tt> parameter the method will (when false)\n     * or will not (when exactPrefixMatch is true) include property names that\n     * have prefixes longer than the specified <tt>prefix<\/tt> param.\n     * <p>\n     * Example:\n     * <p>\n     * Imagine a configuration service instance containing 2 properties only:<br>\n     * <code>\n     * net.java.sip.communicator.PROP1=value1<br>\n     * net.java.sip.communicator.service.protocol.PROP1=value2\n     * <\/code>\n     * <p>\n     * A call to this method with a prefix=\"net.java.sip.communicator\" and\n     * exactPrefixMatch=true would only return the first property -\n     * net.java.sip.communicator.PROP1, whereas the same call with\n     * exactPrefixMatch=false would return both properties as the second prefix\n     * includes the requested prefix string.\n     * <p>\n     * @param prefix a String containing the prefix (the non dotted non-caps\n     * part of a property name) that we're looking for.\n     * @param exactPrefixMatch a boolean indicating whether the returned\n     * property names should all have a prefix that is an exact match of the\n     * the <tt>prefix<\/tt> param or whether properties with prefixes that\n     * contain it but are longer than it are also accepted.\n     * @return a <tt>java.util.List<\/tt>containing all property name String-s\n     * matching the specified conditions.\n     */\n    public List<String> getPropertyNamesByPrefix(String prefix, boolean exactPrefixMatch)\n    {\n        List<String> resultKeySet = new LinkedList<String>();\n\n        for (String key : store.getPropertyNames())\n        {\n            int ix = key.lastIndexOf('.');\n            \n            if(ix == -1)\n                continue;\n            \n            String keyPrefix = key.substring(0, ix);\n\n            if(exactPrefixMatch)\n            {\n                if(prefix.equals(keyPrefix))\n                    resultKeySet.add(key);\n            }\n            else\n            {\n                if(keyPrefix.startsWith(prefix))\n                    resultKeySet.add(key);\n            }\n        }\n\n        return resultKeySet;\n    }","commit_id":"10064c4066db73be5d7afff78d1a080fd2c157e3","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void reloadConfiguration()\n        throws IOException, XMLException\n    {\n        properties = new Hashtable<String, Object>();\n        this.configurationFile = null;\n\n        fileExtractedProperties =\n                loadConfiguration(getConfigurationFile());\n        this.properties.putAll(fileExtractedProperties);\n    }","id":6120,"modified_method":"public void reloadConfiguration()\n        throws IOException, XMLException\n    {\n        this.configurationFile = null;\n\n        File file = getConfigurationFile();\n\n        // restore the file if needed\n        FailSafeTransaction trans = this.faService\n            .createFailSafeTransaction(file);\n        try {\n            trans.restoreFile();\n        } catch (Exception e) {\n            logger.error(\"can't restore the configuration file before loading\" +\n                    \" it\", e);\n        }\n\n        store.reloadConfiguration(file);\n    }","commit_id":"10064c4066db73be5d7afff78d1a080fd2c157e3","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Stores local properties in the specified configuration file.\n     * @param file a reference to the configuration file where properties should\n     *  be stored.\n     * @throws IOException if there was a problem writing to the specified file.\n     */\n    private void storeConfiguration(File file)\n        throws IOException\n    {\n        if(!started)\n            throw new IllegalStateException(\"Service is stopped or has not been started\");\n        \n        //resolve the properties that were initially in the file - back to\n        //the document.\n\n        if (propertiesDocument == null)\n            propertiesDocument = createPropertiesDocument();\n\n        Node root = propertiesDocument.getFirstChild();\n\n        Node currentNode = null;\n        NodeList children = root.getChildNodes();\n        for (int i = 0; i < children.getLength(); i++)\n        {\n            currentNode = children.item(i);\n\n            if (currentNode.getNodeType() == Node.ELEMENT_NODE)\n            {\n                StringBuffer propertyNameBuff = new StringBuffer();\n                propertyNameBuff.append(currentNode.getNodeName());\n                updateNode(currentNode, propertyNameBuff, properties);\n            }\n        }\n\n        //create in the document the properties that were added by other\n        //bundles after the initial property load.\n\n        Map<String, Object> newlyAddedProperties = cloneProperties();\n\n        //remove those that were originally there;\n        for (String propName : fileExtractedProperties.keySet())\n            newlyAddedProperties.remove(propName);\n\n        this.processNewProperties(propertiesDocument,\n                                  newlyAddedProperties);\n\n        //write the file.\n        File config = getConfigurationFile();\n        FailSafeTransaction trans = this.faService\n                                        .createFailSafeTransaction(config);\n        try {\n            trans.beginTransaction();\n            OutputStream stream = new FileOutputStream(config);\n            XMLUtils.indentedWriteXML(\n                    propertiesDocument, stream);\n            stream.close();\n            trans.commit();\n        } catch (Exception e) {\n            logger.error(\"can't write data in the configuration file\", e);\n            trans.rollback();\n        }\n    }","id":6121,"modified_method":"/**\n     * Stores local properties in the specified configuration file.\n     * \n     * @param file a reference to the configuration file where properties should\n     *            be stored.\n     * @throws IOException if there was a problem writing to the specified file.\n     */\n    private void storeConfiguration(File file) throws IOException\n    {\n        if (!started)\n            throw new IllegalStateException(\n                \"Service is stopped or has not been started\");\n\n        // write the file.\n        File config = getConfigurationFile();\n        FailSafeTransaction trans =\n            this.faService.createFailSafeTransaction(config);\n        try\n        {\n            trans.beginTransaction();\n            OutputStream stream = new FileOutputStream(config);\n\n            store.storeConfiguration(stream);\n\n            stream.close();\n            trans.commit();\n        }\n        catch (Exception e)\n        {\n            logger.error(\"can't write data in the configuration file\", e);\n            trans.rollback();\n        }\n    }","commit_id":"10064c4066db73be5d7afff78d1a080fd2c157e3","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the location of the directory where SIP Communicator is to store\n     * user specific data such as configuration files, message and call history\n     * as well as is bundle repository.\n     *\n     * @return the location of the directory where SIP Communicator is to store\n     * user specific data such as configuration files, message and call history\n     * as well as is bundle repository.\n     */\n    public String getScHomeDirLocation()\n    {\n        //first let's check whether we already have the name of the directory\n        //set as a configuration property\n        String scHomeDirLocation = getString(PNAME_SC_HOME_DIR_LOCATION);\n\n        if (scHomeDirLocation == null)\n        {\n            //no luck, check whether user has specified a custom name in the\n            //system properties\n            scHomeDirLocation\n                = getSystemProperty(PNAME_SC_HOME_DIR_LOCATION);\n\n            if (scHomeDirLocation == null)\n            {\n                scHomeDirLocation = getSystemProperty(\"user.home\");\n            }\n\n            //now save all this as a configuration property so that we don't\n            //have to look for it in the sys props next time and so that it is\n            //available for other bundles to consult.\n            properties.put(PNAME_SC_HOME_DIR_LOCATION, scHomeDirLocation);\n        }\n\n        return scHomeDirLocation;\n    }","id":6122,"modified_method":"/**\n     * Returns the location of the directory where SIP Communicator is to store\n     * user specific data such as configuration files, message and call history\n     * as well as is bundle repository.\n     *\n     * @return the location of the directory where SIP Communicator is to store\n     * user specific data such as configuration files, message and call history\n     * as well as is bundle repository.\n     */\n    public String getScHomeDirLocation()\n    {\n        //first let's check whether we already have the name of the directory\n        //set as a configuration property\n        String scHomeDirLocation = getString(PNAME_SC_HOME_DIR_LOCATION);\n\n        if (scHomeDirLocation == null)\n        {\n            //no luck, check whether user has specified a custom name in the\n            //system properties\n            scHomeDirLocation\n                = getSystemProperty(PNAME_SC_HOME_DIR_LOCATION);\n\n            if (scHomeDirLocation == null)\n            {\n                scHomeDirLocation = getSystemProperty(\"user.home\");\n            }\n\n            //now save all this as a configuration property so that we don't\n            //have to look for it in the sys props next time and so that it is\n            // available for other bundles to consult.\n            store.setNonSystemProperty(PNAME_SC_HOME_DIR_LOCATION,\n                scHomeDirLocation);\n        }\n\n        return scHomeDirLocation;\n    }","commit_id":"10064c4066db73be5d7afff78d1a080fd2c157e3","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Determines whether the property with the specified\n     * <tt>propertyName<\/tt> has been previously declared as System\n     *\n     * @param propertyName the name of the property to verify\n     * @return true if someone at some point specified that property to be\n     * system. (This could have been either through a call to\n     * setProperty(string, true)) or by setting the system attribute in the\n     * xml conf file to true.\n     */\n    private boolean isSystem(String propertyName)\n    {\n        return properties.containsKey(propertyName)\n               && properties.get(propertyName) instanceof PropertyReference;\n    }","id":6123,"modified_method":"/**\n     * Determines whether the property with the specified\n     * <tt>propertyName<\/tt> has been previously declared as System\n     *\n     * @param propertyName the name of the property to verify\n     * @return true if someone at some point specified that property to be\n     * system. (This could have been either through a call to\n     * setProperty(string, true)) or by setting the system attribute in the\n     * xml conf file to true.\n     */\n    private boolean isSystem(String propertyName)\n    {\n        return store.isSystem(propertyName);\n    }","commit_id":"10064c4066db73be5d7afff78d1a080fd2c157e3","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Removes the property with the specified name. Calling\n     * this method would first trigger a PropertyChangeEvent that will\n     * be dispatched to all VetoableChangeListeners. In case no complaints\n     * (PropertyVetoException) have been received, the property will be actually\n     * changed and a PropertyChangeEvent will be dispatched.\n     * All properties with prefix propertyName will also be removed.\n     * <p>\n     * @param propertyName the name of the property to change.\n     * @param property the new value of the specified property.\n     * @throws PropertyVetoException in case the changed has been refused by\n     * at least one propertychange listener.\n     */\n    public void removeProperty(String propertyName)\n        throws PropertyVetoException\n    {\n        List<String> childPropertyNames = \n            getPropertyNamesByPrefix(propertyName, false);\n\n        //remove all properties\n        for (String pName : childPropertyNames)\n        {\n            removeProperty(pName);\n        }\n        \n        Object oldValue = getProperty(propertyName);\n        //first check whether the change is ok with everyone\n        if (changeEventDispatcher.hasVetoableChangeListeners(propertyName))\n            changeEventDispatcher.fireVetoableChange(\n                propertyName, oldValue, null);\n\n        //no exception was thrown - lets change the property and fire a\n        //change event\n\n        logger.trace(\"Will remove prop: \" + propertyName + \".\");\n\n        properties.remove(propertyName);\n\n        fileExtractedProperties.remove(propertyName);\n        \n        if (changeEventDispatcher.hasPropertyChangeListeners(propertyName))\n            changeEventDispatcher.firePropertyChange(\n                propertyName, oldValue, null);\n\n        try\n        {\n            storeConfiguration();\n        }\n        catch (IOException ex)\n        {\n            logger.error(\"Failed to store configuration after \"\n                         + \"a property change\");\n        }\n    }","id":6124,"modified_method":"/**\n     * Removes the property with the specified name. Calling\n     * this method would first trigger a PropertyChangeEvent that will\n     * be dispatched to all VetoableChangeListeners. In case no complaints\n     * (PropertyVetoException) have been received, the property will be actually\n     * changed and a PropertyChangeEvent will be dispatched.\n     * All properties with prefix propertyName will also be removed.\n     * <p>\n     * @param propertyName the name of the property to change.\n     * @throws PropertyVetoException in case the changed has been refused by\n     * at least one propertychange listener.\n     */\n    public void removeProperty(String propertyName)\n        throws PropertyVetoException\n    {\n        List<String> childPropertyNames = \n            getPropertyNamesByPrefix(propertyName, false);\n\n        //remove all properties\n        for (String pName : childPropertyNames)\n        {\n            removeProperty(pName);\n        }\n        \n        Object oldValue = getProperty(propertyName);\n        //first check whether the change is ok with everyone\n        if (changeEventDispatcher.hasVetoableChangeListeners(propertyName))\n            changeEventDispatcher.fireVetoableChange(\n                propertyName, oldValue, null);\n\n        //no exception was thrown - lets change the property and fire a\n        //change event\n\n        logger.trace(\"Will remove prop: \" + propertyName + \".\");\n\n        store.removeProperty(propertyName);\n        \n        if (changeEventDispatcher.hasPropertyChangeListeners(propertyName))\n            changeEventDispatcher.firePropertyChange(\n                propertyName, oldValue, null);\n\n        try\n        {\n            storeConfiguration();\n        }\n        catch (IOException ex)\n        {\n            logger.error(\"Failed to store configuration after \"\n                         + \"a property change\");\n        }\n    }","commit_id":"10064c4066db73be5d7afff78d1a080fd2c157e3","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the name of the directory where SIP Communicator is to store user\n     * specific data such as configuration files, message and call history\n     * as well as is bundle repository.\n     *\n     * @return the name of the directory where SIP Communicator is to store\n     * user specific data such as configuration files, message and call history\n     * as well as is bundle repository.\n     */\n    public String getScHomeDirName()\n    {\n        //first let's check whether we already have the name of the directory\n        //set as a configuration property\n        String scHomeDirName = getString(PNAME_SC_HOME_DIR_NAME);\n\n        if (scHomeDirName == null)\n        {\n            //no luck, check whether user has specified a custom name in the\n            //system properties\n            scHomeDirName\n                = getSystemProperty(PNAME_SC_HOME_DIR_NAME);\n\n            if (scHomeDirName == null)\n            {\n                scHomeDirName = \".sip-communicator\";\n            }\n\n            //now save all this as a configuration property so that we don't\n            //have to look for it in the sys props next time and so that it is\n            //available for other bundles to consult.\n            properties.put(PNAME_SC_HOME_DIR_NAME, scHomeDirName);\n        }\n\n        return scHomeDirName;\n    }","id":6125,"modified_method":"/**\n     * Returns the name of the directory where SIP Communicator is to store user\n     * specific data such as configuration files, message and call history\n     * as well as is bundle repository.\n     *\n     * @return the name of the directory where SIP Communicator is to store\n     * user specific data such as configuration files, message and call history\n     * as well as is bundle repository.\n     */\n    public String getScHomeDirName()\n    {\n        //first let's check whether we already have the name of the directory\n        //set as a configuration property\n        String scHomeDirName = getString(PNAME_SC_HOME_DIR_NAME);\n\n        if (scHomeDirName == null)\n        {\n            //no luck, check whether user has specified a custom name in the\n            //system properties\n            scHomeDirName\n                = getSystemProperty(PNAME_SC_HOME_DIR_NAME);\n\n            if (scHomeDirName == null)\n            {\n                scHomeDirName = \".sip-communicator\";\n            }\n\n            //now save all this as a configuration property so that we don't\n            //have to look for it in the sys props next time and so that it is\n            // available for other bundles to consult.\n            store.setNonSystemProperty(PNAME_SC_HOME_DIR_NAME, scHomeDirName);\n        }\n\n        return scHomeDirName;\n    }","commit_id":"10064c4066db73be5d7afff78d1a080fd2c157e3","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Enables or disables the \"Next\" wizard button according to whether the\n     * User ID field is empty.\n     */\n    private void setNextButtonAccordingToUserID()\n    {\n        if (nickField.getText() == null\n                || nickField.getText().equals(\"\")\n                || serverField.getText() == null\n                || serverField.getText().equals(\"\")\n                || (!passwordNotRequired.isSelected()\n                        && passField.getText().equals(\"\")))\n        {\n            wizard.getWizardContainer().setNextFinishButtonEnabled(false);\n        }\n        else\n        {\n            wizard.getWizardContainer().setNextFinishButtonEnabled(true);\n        }\n    }","id":6126,"modified_method":"/**\n     * Enables or disables the \"Next\" wizard button according to whether the\n     * User ID field is empty.\n     */\n    private void setNextButtonAccordingToUserID()\n    {\n        if (nickField.getText() == null\n                || nickField.getText().equals(\"\")\n                || serverField.getText() == null\n                || serverField.getText().equals(\"\")\n                || (!passwordNotRequired.isSelected() && isEmpty(passField)))\n        {\n            wizard.getWizardContainer().setNextFinishButtonEnabled(false);\n        }\n        else\n        {\n            wizard.getWizardContainer().setNextFinishButtonEnabled(true);\n        }\n    }","commit_id":"10064c4066db73be5d7afff78d1a080fd2c157e3","url":"https://github.com/jitsi/jitsi"},{"original_method":"@Nullable\n    private static CompileTimeConstant<?> createCompileTimeConstantForCompareTo(\n            @NotNull Object result,\n            @NotNull JetBinaryExpression expression\n    ) {\n        if (result instanceof Integer) {\n            int resultCode = ((Integer) result).intValue();\n            IElementType operationToken = expression.getOperationToken();\n            if (resultCode == 0) {\n                if (operationToken == JetTokens.EQEQ ||\n                    operationToken == JetTokens.LTEQ ||\n                    operationToken == JetTokens.GTEQ) {\n                    return BooleanValue.TRUE;\n                }\n                else {\n                    return BooleanValue.FALSE;\n                }\n            }\n            if (resultCode == 1) {\n                if (operationToken == JetTokens.GT ||\n                    operationToken == JetTokens.GTEQ) {\n                    return BooleanValue.TRUE;\n                }\n                else {\n                    return BooleanValue.FALSE;\n                }\n            }\n            if (resultCode == -1) {\n                if (operationToken == JetTokens.LT ||\n                    operationToken == JetTokens.LTEQ) {\n                    return BooleanValue.TRUE;\n                }\n                else {\n                    return BooleanValue.FALSE;\n                }\n            }\n        }\n        return null;\n    }","id":6127,"modified_method":"@Nullable\n    private static CompileTimeConstant<?> createCompileTimeConstantForCompareTo(\n            @NotNull Object result,\n            @NotNull IElementType operationToken\n    ) {\n        if (result instanceof Integer) {\n            int resultCode = ((Integer) result).intValue();\n            if (resultCode == 0) {\n                if (operationToken == JetTokens.EQEQ ||\n                    operationToken == JetTokens.LTEQ ||\n                    operationToken == JetTokens.GTEQ) {\n                    return BooleanValue.TRUE;\n                }\n                else {\n                    return BooleanValue.FALSE;\n                }\n            }\n            if (resultCode == 1) {\n                if (operationToken == JetTokens.GT ||\n                    operationToken == JetTokens.GTEQ) {\n                    return BooleanValue.TRUE;\n                }\n                else {\n                    return BooleanValue.FALSE;\n                }\n            }\n            if (resultCode == -1) {\n                if (operationToken == JetTokens.LT ||\n                    operationToken == JetTokens.LTEQ) {\n                    return BooleanValue.TRUE;\n                }\n                else {\n                    return BooleanValue.FALSE;\n                }\n            }\n        }\n        return null;\n    }","commit_id":"1bd63fefa49dcf547f41f36e54be90e5ce3e05fb","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public CompileTimeConstant<?> visitUnaryExpression(@NotNull JetUnaryExpression expression, Void data) {\n        JetExpression leftExpression = expression.getBaseExpression();\n        if (leftExpression == null) {\n            return null;\n        }\n        return getCallConstant(expression.getOperationReference(), leftExpression);\n    }","id":6128,"modified_method":"@Override\n    public CompileTimeConstant<?> visitUnaryExpression(@NotNull JetUnaryExpression expression, Void data) {\n        JetExpression leftExpression = expression.getBaseExpression();\n        if (leftExpression == null) {\n            return null;\n        }\n        Object result = evaluateCall(expression.getOperationReference(), leftExpression);\n        if (result == null) {\n            return null;\n        }\n        return createCompileTimeConstant(result, expectedType);\n    }","commit_id":"1bd63fefa49dcf547f41f36e54be90e5ce3e05fb","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public CompileTimeConstant<?> visitQualifiedExpression(@NotNull JetQualifiedExpression expression, Void data) {\n        CompileTimeConstant wholeExpressionValue = trace.getBindingContext().get(BindingContext.COMPILE_TIME_VALUE, expression);\n        if (wholeExpressionValue != null) {\n            return wholeExpressionValue;\n        }\n\n        JetExpression receiverExpression = expression.getReceiverExpression();\n        JetExpression selectorExpression = expression.getSelectorExpression();\n\n\n        if (selectorExpression instanceof JetCallExpression) {\n            JetExpression calleeExpression = ((JetCallExpression) selectorExpression).getCalleeExpression();\n            if (!(calleeExpression instanceof JetSimpleNameExpression)) {\n                return null;\n            }\n\n            if (((JetCallExpression) selectorExpression).getValueArguments().size() < 2) {\n                return getCallConstant(calleeExpression, receiverExpression);\n            }\n        }\n\n        if (selectorExpression != null) {\n            return selectorExpression.accept(this, null);\n        }\n        return super.visitQualifiedExpression(expression, data);\n    }","id":6129,"modified_method":"@Override\n    public CompileTimeConstant<?> visitQualifiedExpression(@NotNull JetQualifiedExpression expression, Void data) {\n        CompileTimeConstant wholeExpressionValue = trace.getBindingContext().get(BindingContext.COMPILE_TIME_VALUE, expression);\n        if (wholeExpressionValue != null) {\n            return wholeExpressionValue;\n        }\n\n        JetExpression receiverExpression = expression.getReceiverExpression();\n        JetExpression selectorExpression = expression.getSelectorExpression();\n\n\n        if (selectorExpression instanceof JetCallExpression) {\n            JetExpression calleeExpression = ((JetCallExpression) selectorExpression).getCalleeExpression();\n            if (!(calleeExpression instanceof JetSimpleNameExpression)) {\n                return null;\n            }\n\n            if (((JetCallExpression) selectorExpression).getValueArguments().size() < 2) {\n                Object result = evaluateCall(calleeExpression, receiverExpression);\n                if (result == null) {\n                    return null;\n                }\n                return createCompileTimeConstant(result, expectedType);\n            }\n        }\n\n        if (selectorExpression != null) {\n            return selectorExpression.accept(this, null);\n        }\n        return super.visitQualifiedExpression(expression, data);\n    }","commit_id":"1bd63fefa49dcf547f41f36e54be90e5ce3e05fb","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    private CompileTimeConstant<?> getCallConstant(@NotNull JetExpression resolvedCallExpression, @NotNull JetExpression receiverExpression) {\n        ResolvedCall<?> resolvedCall = trace.getBindingContext().get(BindingContext.RESOLVED_CALL, resolvedCallExpression);\n        if (resolvedCall != null) {\n            CallableDescriptor resultingDescriptor = resolvedCall.getResultingDescriptor();\n            JetType receiverExpressionType = getReceiverExpressionType(resolvedCall);\n            if (receiverExpressionType == null) {\n                return null;\n            }\n            ConstantExpressionEvaluator evaluator = new ConstantExpressionEvaluator(trace, receiverExpressionType);\n            CompileTimeConstant<?> receiverValue = receiverExpression.accept(evaluator, null);\n            if (receiverValue == null) {\n                return null;\n            }\n            List<CompileTimeConstant<?>> arguments = Lists.newArrayList();\n            for (Map.Entry<ValueParameterDescriptor, ResolvedValueArgument> argumentEntry : resolvedCall.getValueArguments().entrySet()) {\n                arguments.addAll(resolveArguments(argumentEntry.getValue().getArguments(), argumentEntry.getKey().getType(), trace));\n            }\n            Name resultingDescriptorName = resultingDescriptor.getName();\n            if (arguments.isEmpty()) {\n                Object result = EvaluatePackage.evaluateUnaryExpression(receiverValue, resultingDescriptorName);\n                if (result == null) {\n                    return null;\n                }\n                return createCompileTimeConstant(result, expectedType);\n            }\n            else if (arguments.size() == 1) {\n                Object result = EvaluatePackage.evaluateBinaryExpression(receiverValue, arguments.iterator().next(), resultingDescriptorName);\n                if (result == null) {\n                    return null;\n                }\n                if (OperatorConventions.COMPARE_TO.equals(resultingDescriptorName)) {\n                    PsiElement parentExpression = resolvedCallExpression.getParent();\n                    if (parentExpression instanceof JetBinaryExpression) {\n                        return createCompileTimeConstantForCompareTo(result, (JetBinaryExpression) parentExpression);\n                    }\n                }\n                else {\n                    return createCompileTimeConstant(result, expectedType);\n                }\n            }\n\n            return null;\n        }\n\n        return null;\n    }","id":6130,"modified_method":"@Nullable\n    private Object evaluateCall(@NotNull JetExpression resolvedCallExpression, @NotNull JetExpression receiverExpression) {\n        ResolvedCall<?> resolvedCall = trace.getBindingContext().get(BindingContext.RESOLVED_CALL, resolvedCallExpression);\n        if (resolvedCall != null) {\n            CallableDescriptor resultingDescriptor = resolvedCall.getResultingDescriptor();\n            JetType receiverExpressionType = getReceiverExpressionType(resolvedCall);\n            if (receiverExpressionType == null) {\n                return null;\n            }\n            ConstantExpressionEvaluator evaluator = new ConstantExpressionEvaluator(trace, receiverExpressionType);\n            CompileTimeConstant<?> receiverValue = receiverExpression.accept(evaluator, null);\n            if (receiverValue == null) {\n                return null;\n            }\n            List<CompileTimeConstant<?>> arguments = Lists.newArrayList();\n            for (Map.Entry<ValueParameterDescriptor, ResolvedValueArgument> argumentEntry : resolvedCall.getValueArguments().entrySet()) {\n                arguments.addAll(resolveArguments(argumentEntry.getValue().getArguments(), argumentEntry.getKey().getType(), trace));\n            }\n            Name resultingDescriptorName = resultingDescriptor.getName();\n            if (arguments.isEmpty()) {\n                return EvaluatePackage.evaluateUnaryExpression(receiverValue, resultingDescriptorName);\n            }\n            else if (arguments.size() == 1) {\n                return EvaluatePackage.evaluateBinaryExpression(receiverValue, arguments.iterator().next(), resultingDescriptorName);\n            }\n        }\n\n        return null;\n    }","commit_id":"1bd63fefa49dcf547f41f36e54be90e5ce3e05fb","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public CompileTimeConstant<?> visitBinaryExpression(@NotNull JetBinaryExpression expression, Void data) {\n        JetExpression leftExpression = expression.getLeft();\n        if (leftExpression == null) {\n            return null;\n        }\n\n        IElementType operationToken = expression.getOperationToken();\n        if (OperatorConventions.BOOLEAN_OPERATIONS.containsKey(operationToken)) {\n            JetType booleanType = KotlinBuiltIns.getInstance().getBooleanType();\n            CompileTimeConstant<?> leftConstant = leftExpression.accept(new ConstantExpressionEvaluator(trace, booleanType), null);\n            if (leftConstant == null) {\n                return null;\n            }\n            JetExpression rightExpression = expression.getRight();\n            if (rightExpression == null) {\n                return null;\n            }\n            CompileTimeConstant<?> rightConstant = rightExpression.accept(new ConstantExpressionEvaluator(trace, booleanType), null);\n            if (rightConstant == null) {\n                return null;\n            }\n\n            Name operationName = operationToken == JetTokens.ANDAND ? Name.identifier(\"andand\") : Name.identifier(\"oror\");\n            Object result = EvaluatePackage.evaluateBinaryExpression(leftConstant, rightConstant, operationName);\n            if (result == null) {\n                return null;\n            }\n            return createCompileTimeConstant(result, expectedType);\n        }\n        else {\n            return getCallConstant(expression.getOperationReference(), leftExpression);\n        }\n\n    }","id":6131,"modified_method":"@Override\n    public CompileTimeConstant<?> visitBinaryExpression(@NotNull JetBinaryExpression expression, Void data) {\n        JetExpression leftExpression = expression.getLeft();\n        if (leftExpression == null) {\n            return null;\n        }\n\n        IElementType operationToken = expression.getOperationToken();\n        if (OperatorConventions.BOOLEAN_OPERATIONS.containsKey(operationToken)) {\n            JetType booleanType = KotlinBuiltIns.getInstance().getBooleanType();\n            CompileTimeConstant<?> leftConstant = leftExpression.accept(new ConstantExpressionEvaluator(trace, booleanType), null);\n            if (leftConstant == null) {\n                return null;\n            }\n            JetExpression rightExpression = expression.getRight();\n            if (rightExpression == null) {\n                return null;\n            }\n            CompileTimeConstant<?> rightConstant = rightExpression.accept(new ConstantExpressionEvaluator(trace, booleanType), null);\n            if (rightConstant == null) {\n                return null;\n            }\n\n            Name operationName = operationToken == JetTokens.ANDAND ? Name.identifier(\"andand\") : Name.identifier(\"oror\");\n            Object result = EvaluatePackage.evaluateBinaryExpression(leftConstant, rightConstant, operationName);\n            if (result == null) {\n                return null;\n            }\n            return createCompileTimeConstant(result, expectedType);\n        }\n        else {\n            Object result = evaluateCall(expression.getOperationReference(), leftExpression);\n            if (result == null) {\n                return null;\n            }\n            if (OperatorConventions.COMPARISON_OPERATIONS.contains(operationToken)) {\n                return createCompileTimeConstantForCompareTo(result, operationToken);\n            }\n            else if (OperatorConventions.EQUALS_OPERATIONS.contains(operationToken)) {\n                return createCompileTimeConstantForEquals(result, operationToken);\n            }\n            else {\n                return createCompileTimeConstant(result, expectedType);\n            }\n        }\n    }","commit_id":"1bd63fefa49dcf547f41f36e54be90e5ce3e05fb","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n        * Returns an array of the first n bytes for a given file.\n     * @param f file to get the bytes from\n     * @param n number of bytes to read from input file\n     * @throws IOException if things go wrong\n     * @return byte array of the first n bytes from the file.\n     */\n    public static byte[] bytesFromFile(File f, int n) throws IOException {\n        if (f == null) throw new IllegalArgumentException(\"null file\");\n        FileInputStream fis = new FileInputStream(f);\n        byte[] data = new byte[n];\n        int bytesRead = 0;\n        while (bytesRead < n)\n            bytesRead += fis.read(data, bytesRead, n - bytesRead);\n        fis.close();\n        return data;\n    }","id":6132,"modified_method":"/**\n        * Returns an array of the first n bytes for a given file.\n     * @param f file to get the bytes from\n     * @param n number of bytes to read from input file\n     * @throws IOException if things go wrong\n     * @return byte array of the first n bytes from the file.\n     */\n    public static byte[] bytesFromFile(File f, int n) throws IOException {\n        if (f == null) throw new IllegalArgumentException(\"null file\");\n        FileInputStream fis = new FileInputStream(f);\n        try {\n        \tbyte[] result = bytesFromInputStream(fis,n);\n            return result;\n        }\n        finally {\n        \tfis.close();\n        }\n    }","commit_id":"08ae72b31395dc09afc7419bb0fa48da2d34141d","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n        * Writes the contents of an InputStream to a specified file.\n     * @param file to write to\n     * @param stream to pull data from\n     */\n    public static void writeInputStreamToFile(InputStream stream, File file) throws IOException {\n    \tFileOutputStream out;\n    \ttry {\n\t        if (file == null) throw new IllegalArgumentException(\"Attempting to write to a null file!\");\n\t        File parent = file.getParentFile();\n\t        if(parent != null && !parent.exists()) {\n\t            parent.mkdirs();\n\t        }\n\t        out = new FileOutputStream(file);\n    \t}\n    \tcatch (IOException e) {\n    \t\tstream.close();\n    \t\tthrow e;\n    \t}\n    \tcatch (RuntimeException e) {\n    \t\tstream.close();\n    \t\tthrow e;\n    \t}\n        writeInputStreamToOutputStream(stream, out);\n    }","id":6133,"modified_method":"/**\n        * Writes the contents of an InputStream to a specified file.\n     * @param file to write to\n     * @param stream to pull data from\n     */\n    public static void writeInputStreamToFile(InputStream stream, File file) throws IOException {\n    \tFileOutputStream out;\n    \ttry {\n\t        if (file == null) throw new IllegalArgumentException(\"Attempting to write to a null file!\");\n\t        File parent = file.getParentFile();\n\t        if(parent != null && !parent.exists()) {\n\t            parent.mkdirs();\n\t        }\n\t        out = new FileOutputStream(file);\n    \t}\n    \tcatch (IOException e) {\n    \t\tstream.close();\n    \t\tthrow e;\n    \t}\n    \tcatch (RuntimeException e) {\n    \t\tstream.close();\n    \t\tthrow e;\n    \t}\n        ERXFileUtilities.writeInputStreamToOutputStream(stream, true, out, true);\n    }","commit_id":"08ae72b31395dc09afc7419bb0fa48da2d34141d","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Copies the contents of the input stream to the given output stream.  Both streams are\n     * guaranteed to be closed by the end of this method.\n     * \n     * @param in the input stream to copy from\n     * @param out the output stream to copy to\n     * @throws IOException if there is any failure\n     */\n    public static void writeInputStreamToOutputStream(InputStream in, OutputStream out) throws IOException {\n    \ttry {\n\t        BufferedInputStream bis = new BufferedInputStream(in);\n\t        try {\n\t\t        byte buf[] = new byte[1024 * 50]; //64 KBytes buffer\n\t\t        int read = -1;\n\t\t        while ((read = bis.read(buf)) != -1) {\n\t\t            out.write(buf, 0, read);\n\t\t        }\n\t        }\n\t        finally {\n\t        \tbis.close();\n\t        }\n\t\t\tout.flush();\n    \t}\n    \tfinally {\n\t\t\tout.close();\n    \t}\n    }","id":6134,"modified_method":"/**\n     * Copies the contents of the input stream to the given output stream.  Both streams are\n     * guaranteed to be closed by the end of this method.\n     * \n     * @param in the input stream to copy from\n     * @param out the output stream to copy to\n     * @throws IOException if there is any failure\n     */\n    public static void writeInputStreamToOutputStream(InputStream in, OutputStream out) throws IOException {\n    \tERXFileUtilities.writeInputStreamToOutputStream(in, true, out, true);\n    }","commit_id":"08ae72b31395dc09afc7419bb0fa48da2d34141d","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n        * Copys the source file to the destination\n     *\n     * @param srcFile source file\n     * @param dstFile destination file\n     * @param deleteOriginals tells if original file will be deleted. Note that if the appuser has no write rights\n     * on the file it is NOT deleted unless force delete is true\n     * @param forceDelete if true then missing write rights are ignored and the file is deleted.\n     */\n    public static void copyFileToFile(File srcFile, File dstFile, boolean deleteOriginals, boolean forceDelete)\n        throws FileNotFoundException, IOException {\n            if (srcFile.exists() && srcFile.isFile()) {\n            \t\tboolean copied = false;\n                if (deleteOriginals && (!forceDelete || srcFile.canWrite())) {\n                    copied = srcFile.renameTo(dstFile);\n                } \n                if(!copied) {\n                    Throwable thrownException=null;\n                    File  parent = dstFile.getParentFile();\n                    parent.mkdirs();\n                    FileInputStream in = new FileInputStream(srcFile);\n                    FileOutputStream out = new FileOutputStream(dstFile);\n                    try {\n\n                        //50 KBytes buffer\n                        byte buf[] = new byte[1024 * 50];\n                        int read = -1;\n                        while ((read = in.read(buf)) != -1) {\n                            out.write(buf, 0, read);\n                        }\n\n                        if (deleteOriginals && (srcFile.canWrite() || forceDelete))\n                            srcFile.delete();\n                    } catch (Throwable t) {\n                        thrownException=t;\n                    } finally {\n                        if (out != null)\n                            try {\n                                out.close();\n                            } catch (IOException io) {\n                                if (thrownException==null) thrownException=io;\n                            }\n                        if (in != null) {\n                            try {\n                                in.close();\n                            } catch (IOException io) {\n                                if (thrownException==null) thrownException=io;\n                            }\n                        }\n                    }\n                    if (thrownException!=null) {\n                        if (thrownException instanceof IOException) throw (IOException)thrownException;\n                        else if (thrownException instanceof Error) throw (Error)thrownException;\n                        else throw (RuntimeException)thrownException;\n                    }\n                }\n            }\n        }","id":6135,"modified_method":"/**\n     * Copys the source file to the destination\n     *\n     * @param srcFile source file\n     * @param dstFile destination file\n     * @param deleteOriginals tells if original file will be deleted. Note that if the appuser has no write rights\n     * on the file it is NOT deleted unless force delete is true\n     * @param forceDelete if true then missing write rights are ignored and the file is deleted.\n     */\n    public static void copyFileToFile(File srcFile, File dstFile, boolean deleteOriginals, boolean forceDelete) throws FileNotFoundException, IOException {\n        if (srcFile.exists() && srcFile.isFile()) {\n        \tboolean copied = false;\n            if (deleteOriginals && (!forceDelete || srcFile.canWrite())) {\n                copied = srcFile.renameTo(dstFile);\n            } \n            if (!copied) {\n                Throwable thrownException = null;\n                File parent = dstFile.getParentFile();\n                if (!parent.exists() && !parent.mkdirs()) {\n                \tthrow new IOException(\"Failed to create the directory \" + parent + \".\");\n                }\n                \n                FileInputStream in = new FileInputStream(srcFile);\n                try {\n                \t// Create channel on the source\n                \tFileChannel srcChannel = in.getChannel();\n                \ttry {\n                        FileOutputStream out = new FileOutputStream(dstFile);\n                        try {\n\t                    \t// Create channel on the destination\n\t                    \tFileChannel dstChannel = out.getChannel();\n\t                    \ttry {\n\t\t                    \t// Copy file contents from source to destination\n\t\t                    \tdstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n\t                    \t}\n\t                    \tcatch (Throwable t) {\n\t                    \t\tthrownException = t;\n\t                    \t}\n\t                    \tfinally {\n\t                        \tdstChannel.close();\n\t                    \t}\n                        }\n                        catch (Throwable t) {\n                    \t\tif (thrownException == null) {\n                    \t\t\tthrownException = t;\n                    \t\t}\n                        }\n                        finally {\n                        \tout.close();\n                        }\n                \t}\n                    catch (Throwable t) {\n                \t\tif (thrownException == null) {\n                \t\t\tthrownException = t;\n                \t\t}\n                    }\n                \tfinally {\n                    \tsrcChannel.close();\n                \t}\n                } catch (Throwable t) {\n                \tif (thrownException == null) {\n                \t\tthrownException = t;\n                \t}\n                }\n                finally {\n                \ttry {\n                \t\tin.close();\n                \t}\n                \tcatch (IOException e) {\n                \t\tif (thrownException == null) {\n                \t\t\tthrownException = e;\n                \t\t}\n                \t}\n                }\n\n                if (deleteOriginals && (srcFile.canWrite() || forceDelete)) {\n                    if (!srcFile.delete()) {\n                    \tthrow new IOException(\"Failed to delete \" + srcFile + \".\");\n                    }\n                }\n\n                if (thrownException != null) {\n                    if (thrownException instanceof IOException) {\n                    \tthrow (IOException)thrownException;\n                    }\n                    else if (thrownException instanceof Error) {\n                    \tthrow (Error)thrownException;\n                    }\n                    else {\n                    \tthrow (RuntimeException)thrownException;\n                    }\n                }\n            }\n        }\n    }","commit_id":"08ae72b31395dc09afc7419bb0fa48da2d34141d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public Object load(String queue, Object id) throws IOException\n    {\n        File file = FileUtils.newFile(store, queue + File.separator + id + EXTENSION);\n        ObjectInputStream ois = null;\n        try\n        {\n            ois = new ObjectInputStream(new FileInputStream(file));\n            Object obj = ois.readObject();\n            return obj;\n        }\n        catch (ClassNotFoundException e)\n        {\n            throw (IOException) new IOException(\"Error loading persistent object\").initCause(e);\n        }\n        finally\n        {\n            if (ois != null)\n            {\n                ois.close();\n            }\n        }\n    }","id":6136,"modified_method":"public Object load(String queue, Object id) throws IOException\n    {\n        File file = FileUtils.newFile(store, queue + File.separator + id + EXTENSION);\n        ObjectInputStream ois = null;\n        try\n        {\n            ois = new ObjectInputStream(new FileInputStream(file));\n            return ois.readObject();\n        }\n        catch (ClassNotFoundException e)\n        {\n            throw (IOException) new IOException(\"Error loading persistent object\").initCause(e);\n        }\n        finally\n        {\n            if (ois != null)\n            {\n                ois.close();\n            }\n        }\n    }","commit_id":"d2cd3ac75e1fb83df88b60d8268526d1cf3348f7","url":"https://github.com/mulesoft/mule"},{"original_method":"protected String getId(Object obj)\n    {\n        String id = gen.generateRandomBasedUUID().toString();\n        return id;\n    }","id":6137,"modified_method":"protected String getId(Object obj)\n    {\n        return UUID.getUUID();\n    }","commit_id":"d2cd3ac75e1fb83df88b60d8268526d1cf3348f7","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void restoreFiles(File dir, List msgs) throws IOException, ClassNotFoundException\n    {\n        File[] files = dir.listFiles();\n        if (files == null)\n        {\n            return;\n        }\n\n        for (int i = 0; i < files.length; i++)\n        {\n            if (files[i].isDirectory())\n            {\n                restoreFiles(files[i], msgs);\n            }\n            else if (files[i].getName().endsWith(EXTENSION))\n            {\n                String id = files[i].getCanonicalPath();\n                id = id.substring(store.getCanonicalPath().length() + 1, id.length() - EXTENSION.length());\n                String queue = id.substring(0, id.indexOf(File.separator));\n                id = id.substring(queue.length() + 1);\n                msgs.add(new HolderImpl(queue, id));\n            }\n        }\n    }","id":6138,"modified_method":"protected void restoreFiles(File dir, List<Holder> msgs) throws IOException, ClassNotFoundException\n    {\n        File[] files = dir.listFiles();\n        if (files == null)\n        {\n            return;\n        }\n\n        for (int i = 0; i < files.length; i++)\n        {\n            if (files[i].isDirectory())\n            {\n                restoreFiles(files[i], msgs);\n            }\n            else if (files[i].getName().endsWith(EXTENSION))\n            {\n                String id = files[i].getCanonicalPath();\n                id = id.substring(store.getCanonicalPath().length() + 1, id.length() - EXTENSION.length());\n                String queue = id.substring(0, id.indexOf(File.separator));\n                id = id.substring(queue.length() + 1);\n                msgs.add(new HolderImpl(queue, id));\n            }\n        }\n    }","commit_id":"d2cd3ac75e1fb83df88b60d8268526d1cf3348f7","url":"https://github.com/mulesoft/mule"},{"original_method":"public List restore() throws IOException\n    {\n        List msgs = new ArrayList();\n        if (store == null)\n        {\n            logger.warn(\"No store has be set on the File Persistence Strategy. Not restoring at this time\");\n            return msgs;\n        }\n        try\n        {\n            restoreFiles(store, msgs);\n            logger.debug(\"Restore retrieved \" + msgs.size() + \" objects\");\n            return msgs;\n        }\n        catch (ClassNotFoundException e)\n        {\n            throw (IOException) new IOException(\"Could not restore\").initCause(e);\n        }\n    }","id":6139,"modified_method":"public List<Holder> restore() throws IOException\n    {\n        List<Holder> msgs = new ArrayList<Holder>();\n        if (store == null)\n        {\n            logger.warn(\"No store has be set on the File Persistence Strategy. Not restoring at this time\");\n            return msgs;\n        }\n        try\n        {\n            restoreFiles(store, msgs);\n            logger.debug(\"Restore retrieved \" + msgs.size() + \" objects\");\n            return msgs;\n        }\n        catch (ClassNotFoundException e)\n        {\n            throw (IOException) new IOException(\"Could not restore\").initCause(e);\n        }\n    }","commit_id":"d2cd3ac75e1fb83df88b60d8268526d1cf3348f7","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object store(String queue, Object obj) throws IOException\n    {\n        String id = getId(obj);\n        File file = FileUtils.newFile(store, queue + File.separator + id + EXTENSION);\n        file.getParentFile().mkdirs();\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file));\n        oos.writeObject(obj);\n        oos.close();\n        return id;\n    }","id":6140,"modified_method":"public Object store(String queue, Object obj) throws IOException\n    {\n        String id = getId(obj);\n        File file = FileUtils.newFile(store, queue + File.separator + id + EXTENSION);\n        if(!file.getParentFile().exists() && !file.getParentFile().mkdirs())\n        {\n            throw new IOException(\"Failed to create directory: \" + file.getAbsolutePath());\n        }\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file));\n        oos.writeObject(obj);\n        oos.close();\n        return id;\n    }","commit_id":"d2cd3ac75e1fb83df88b60d8268526d1cf3348f7","url":"https://github.com/mulesoft/mule"},{"original_method":"public void open() throws IOException\n    {\n        String path = muleContext.getConfiguration().getWorkingDirectory() + File.separator + DEFAULT_QUEUE_STORE;\n        store = FileUtils.newFile(path).getCanonicalFile();\n        store.mkdirs();\n    }","id":6141,"modified_method":"public void open() throws IOException\n    {\n        String path = muleContext.getConfiguration().getWorkingDirectory() + File.separator + DEFAULT_QUEUE_STORE;\n        store = FileUtils.newFile(path).getCanonicalFile();\n        if(!store.exists() && !store.mkdirs())\n        {\n            throw new IOException(\"Failed to create directory: \" + store.getAbsolutePath());\n        }\n    }","commit_id":"d2cd3ac75e1fb83df88b60d8268526d1cf3348f7","url":"https://github.com/mulesoft/mule"},{"original_method":"protected Object getId(Object obj)\n    {\n        return gen.generateRandomBasedUUID();\n    }","id":6142,"modified_method":"protected Object getId(Object obj)\n    {\n        return UUID.getUUID();\n    }","commit_id":"d2cd3ac75e1fb83df88b60d8268526d1cf3348f7","url":"https://github.com/mulesoft/mule"},{"original_method":"public static String getUUID()\n    {\n        return generator.generateTimeBasedUUID().toString();\n    }","id":6143,"modified_method":"public static String getUUID()\n    {\n        return java.util.UUID.randomUUID().toString();\n    }","commit_id":"d2cd3ac75e1fb83df88b60d8268526d1cf3348f7","url":"https://github.com/mulesoft/mule"},{"original_method":"protected File createTempDir(final String subDir) {\n    try {\n      String _tempDir = this.getTempDir();\n      File _file = new File(_tempDir);\n      File _file_1 = new File(_file, subDir);\n      final File file = _file_1;\n      boolean _mkdirs = file.mkdirs();\n      boolean _not = (!_mkdirs);\n      if (_not) {\n        String _absolutePath = file.getAbsolutePath();\n        String _plus = (\"Failed to create directory \\'\" + _absolutePath);\n        String _plus_1 = (_plus + \"\\'\");\n        IOException _iOException = new IOException(_plus_1);\n        throw _iOException;\n      }\n      return file;\n    } catch (Throwable _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","id":6144,"modified_method":"protected File createTempDir(final String subDir) {\n    try {\n      File _tempDir = this.getTempDir();\n      File _file = new File(_tempDir, subDir);\n      final File file = _file;\n      boolean _and = false;\n      boolean _mkdirs = file.mkdirs();\n      boolean _not = (!_mkdirs);\n      if (!_not) {\n        _and = false;\n      } else {\n        boolean _exists = file.exists();\n        boolean _not_1 = (!_exists);\n        _and = (_not && _not_1);\n      }\n      if (_and) {\n        String _absolutePath = file.getAbsolutePath();\n        String _plus = (\"Failed to create directory \\'\" + _absolutePath);\n        String _plus_1 = (_plus + \"\\'\");\n        IOException _iOException = new IOException(_plus_1);\n        throw _iOException;\n      }\n      return file;\n    } catch (Throwable _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","commit_id":"6b8f98460382c4d9827bb0d489c5ce77b00014d0","url":"https://github.com/eclipse/xtext"},{"original_method":"public String getTempDir() {\n    return this._tempDir;\n  }","id":6145,"modified_method":"public File getTempDir() {\n    return this._tempDir;\n  }","commit_id":"6b8f98460382c4d9827bb0d489c5ce77b00014d0","url":"https://github.com/eclipse/xtext"},{"original_method":"public void setTempDir(final String tempDir) {\n    this._tempDir = tempDir;\n  }","id":6146,"modified_method":"public void setTempDir(final String pathAsString) {\n    boolean _notEquals = (!Objects.equal(pathAsString, null));\n    if (_notEquals) {\n      File _file = new File(pathAsString);\n      this._tempDir = _file;\n    }\n  }","commit_id":"6b8f98460382c4d9827bb0d489c5ce77b00014d0","url":"https://github.com/eclipse/xtext"},{"original_method":"private File createTempDir() {\n\t\tFile tmpDir = new File(tmpClassDirectory);\n\t\ttmpDir.mkdirs();\n\t\treturn tmpDir;\n\t}","id":6147,"modified_method":"private File createTempDir() {\n\t\tFile tmpDir = new File(tmpClassDirectory);\n\t\tif (!tmpDir.mkdirs() && !tmpDir.exists()) {\n\t\t\tthrow new IllegalArgumentException(\"Couldn't create directory '\"+tmpClassDirectory+\"'.\");\n\t\t}\n\t\treturn tmpDir;\n\t}","commit_id":"6b8f98460382c4d9827bb0d489c5ce77b00014d0","url":"https://github.com/eclipse/xtext"},{"original_method":"@SuppressWarnings(\"unused\")\n    private static void writeopensearchcfg(final Switchboard sb, final serverObjects post) {\n        // read index schema table flags\n\n        final File f = new File(sb.getDataPath(), \"DATA/SETTINGS/heuristicopensearch.conf\");\n        try {\n            Configuration cfg = new Configuration(f);\n            final Iterator<Configuration.Entry> cfgentries = cfg.entryIterator();\n            Configuration.Entry entry;\n            boolean modified = false; // flag to remember changes\n            while (cfgentries.hasNext()) {\n                entry = cfgentries.next();\n                final String sfn = post.get(\"ossys_url_\" + entry.key());\n                if (sfn != null) {\n                    if (!sfn.equals(entry.getValue())) {\n                        entry.setValue(sfn);\n                        modified = true;\n    }\n                }\n                // set enable flag\n                String v = post.get(\"ossys_\" + entry.key());\n                boolean c = v != null && v.equals(\"checked\");\n                if (entry.enabled() != c) {\n                    entry.setEnable(c);\n                    modified = true;\n                }\n                // delete entry from config\n                v = post.get(\"ossys_del_\" + entry.key());\n                c = v != null && v.equals(\"checked\");\n                if (c) {\n                    cfgentries.remove();\n                    modified = true;\n                }\n            }\n            if (modified) { // save settings to config file if modified\n                try {\n                    cfg.commit();\n                } catch (final IOException ex) {\n                }\n            }\n        } catch (final IOException e) {\n            ConcurrentLog.logException(e);\n        }\n        \n        // re-read config (and create/update work table)\n        if (sb.getConfigBool(SwitchboardConstants.HEURISTIC_OPENSEARCH, true)) {\n            new OpenSearchConnector(sb, true);\n        }\n    }","id":6148,"modified_method":"@SuppressWarnings(\"unused\")\n    private static void writeopensearchcfg(final Switchboard sb, final serverObjects post) {\n        // read index schema table flags\n\n        final File f = new File(sb.getDataPath(), \"DATA/SETTINGS/heuristicopensearch.conf\");\n        try {\n            Configuration cfg = new Configuration(f);\n            final Iterator<Configuration.Entry> cfgentries = cfg.entryIterator();\n            Configuration.Entry entry;\n            boolean modified = false; // flag to remember changes\n            while (cfgentries.hasNext()) {\n                entry = cfgentries.next();\n                final String sfn = post.get(\"ossys_url_\" + entry.key());\n                if (sfn != null) {\n                    if (!sfn.equals(entry.getValue())) {\n                        entry.setValue(sfn);\n                        modified = true;\n                    }\n                }\n                // set enable flag\n                String v = post.get(\"ossys_\" + entry.key());\n                boolean c = v != null && v.equals(\"checked\");\n                if (entry.enabled() != c) {\n                    entry.setEnable(c);\n                    modified = true;\n                }\n                // delete entry from config\n                v = post.get(\"ossys_del_\" + entry.key());\n                c = v != null && v.equals(\"checked\");\n                if (c) {\n                    cfgentries.remove();\n                    modified = true;\n                }\n            }\n            if (modified) { // save settings to config file if modified\n                try {\n                    cfg.commit();\n                } catch (final IOException ex) {\n                }\n            }\n        } catch (final IOException e) {\n            ConcurrentLog.warn(\"OpenSearchConnector\", \"file not found \" + f.getAbsolutePath());\n        }\n        \n        // re-read config (and create/update work table)\n        if (sb.getConfigBool(SwitchboardConstants.HEURISTIC_OPENSEARCH, true)) {\n            new OpenSearchConnector(sb, true);\n        }\n    }","commit_id":"1d3ea35d6909af2ae8de1b1c3d9f18ee0d5ed8b6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@Test\n  public void testApplyingProxyRules() {\n    assertChange(\"/v2/data/explore/datasets/continuuity.user.myTable/schema\",\n                 \"/v2/data/explore/datasets/myTable/schema\");\n    assertChange(\"/v2/data/datasets/continuuity.user.myTable\", \"/v2/data/datasets/myTable\");\n    assertChange(\"/v2/data/datasets/continuuity.user.myTable/admin\", \"/v2/data/datasets/myTable/admin\");\n    assertChange(\"/v2/data/datasets/continuuity.user.myTable/admin/truncate\",\n                 \"/v2/data/datasets/myTable/admin/truncate\");\n    assertSame(\"/v2/data/types/myType\");\n    assertSame(\"/v2/metrics\");\n    assertSame(\"/v2/metrics/data/datasets/myTable\");\n  }","id":6149,"modified_method":"@Test\n  public void testApplyingProxyRules() {\n    assertChange(\"/v2/data/explore/datasets/cdap.user.myTable/schema\",\n                 \"/v2/data/explore/datasets/myTable/schema\");\n    assertChange(\"/v2/data/datasets/cdap.user.myTable\", \"/v2/data/datasets/myTable\");\n    assertChange(\"/v2/data/datasets/cdap.user.myTable/admin\", \"/v2/data/datasets/myTable/admin\");\n    assertChange(\"/v2/data/datasets/cdap.user.myTable/admin/truncate\",\n                 \"/v2/data/datasets/myTable/admin/truncate\");\n    assertSame(\"/v2/data/types/myType\");\n    assertSame(\"/v2/metrics\");\n    assertSame(\"/v2/metrics/data/datasets/myTable\");\n  }","commit_id":"c126c996595e71f40ea3b25c33b707903bfa1046","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\n  public static void setup() throws Exception {\n    Injector injector = Guice.createInjector(\n      new ConfigModule(new Configuration()),\n      new LocationRuntimeModule().getInMemoryModules(),\n      new DiscoveryRuntimeModule().getInMemoryModules(),\n      new DataFabricModules().getInMemoryModules(),\n      new TransactionMetricsModule(),\n      new AbstractModule() {\n        @Override\n        protected void configure() {\n          install(new FactoryModuleBuilder()\n                    .implement(DatasetDefinitionRegistry.class,\n                               DefaultDatasetDefinitionRegistry.class)\n                    .build(DatasetDefinitionRegistryFactory.class));\n        }\n      });\n\n    dsFramework = new InMemoryDatasetFramework(injector.getInstance(DatasetDefinitionRegistryFactory.class));\n    dsFramework.addModule(\"metrics-inmemory\", new InMemoryMetricsTableModule());\n  }","id":6150,"modified_method":"@BeforeClass\n  public static void setup() throws Exception {\n    Injector injector = Guice.createInjector(\n      new ConfigModule(),\n      new LocationRuntimeModule().getInMemoryModules(),\n      new DiscoveryRuntimeModule().getInMemoryModules(),\n      new DataFabricModules().getInMemoryModules(),\n      new TransactionMetricsModule(),\n      new AbstractModule() {\n        @Override\n        protected void configure() {\n          install(new FactoryModuleBuilder()\n                    .implement(DatasetDefinitionRegistry.class,\n                               DefaultDatasetDefinitionRegistry.class)\n                    .build(DatasetDefinitionRegistryFactory.class));\n        }\n      });\n\n    dsFramework = new InMemoryDatasetFramework(injector.getInstance(DatasetDefinitionRegistryFactory.class));\n    dsFramework.addModule(\"metrics-inmemory\", new InMemoryMetricsTableModule());\n  }","commit_id":"c126c996595e71f40ea3b25c33b707903bfa1046","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\n  public static void init() throws Exception {\n\n    injector = Guice.createInjector(\n      new ConfigModule(new Configuration()),\n      new LocationRuntimeModule().getInMemoryModules(),\n      new DiscoveryRuntimeModule().getInMemoryModules(),\n      new DataFabricModules().getInMemoryModules(),\n      new DataSetsModules().getInMemoryModule(),\n      new TransactionMetricsModule());\n    // transaction manager is a \"service\" and must be started\n    transactionManager = injector.getInstance(TransactionManager.class);\n    transactionManager.startAndWait();\n    txSystemClient = injector.getInstance(TransactionSystemClient.class);\n    queueClientFactory = injector.getInstance(QueueClientFactory.class);\n    queueAdmin = injector.getInstance(QueueAdmin.class);\n    streamAdmin = injector.getInstance(StreamAdmin.class);\n    executorFactory = injector.getInstance(TransactionExecutorFactory.class);\n  }","id":6151,"modified_method":"@BeforeClass\n  public static void init() throws Exception {\n\n    injector = Guice.createInjector(\n      new ConfigModule(),\n      new LocationRuntimeModule().getInMemoryModules(),\n      new DiscoveryRuntimeModule().getInMemoryModules(),\n      new DataFabricModules().getInMemoryModules(),\n      new DataSetsModules().getInMemoryModule(),\n      new TransactionMetricsModule());\n    // transaction manager is a \"service\" and must be started\n    transactionManager = injector.getInstance(TransactionManager.class);\n    transactionManager.startAndWait();\n    txSystemClient = injector.getInstance(TransactionSystemClient.class);\n    queueClientFactory = injector.getInstance(QueueClientFactory.class);\n    queueAdmin = injector.getInstance(QueueAdmin.class);\n    streamAdmin = injector.getInstance(StreamAdmin.class);\n    executorFactory = injector.getInstance(TransactionExecutorFactory.class);\n  }","commit_id":"c126c996595e71f40ea3b25c33b707903bfa1046","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    protected void before() throws Throwable {\n      CConfiguration cConf = CConfiguration.create();\n      Injector injector = Guice.createInjector(new IOModule(), new SecurityModules().getInMemoryModules(),\n                                               new DiscoveryRuntimeModule().getInMemoryModules());\n      DiscoveryServiceClient discoveryServiceClient = injector.getInstance(DiscoveryServiceClient.class);\n      AccessTokenTransformer accessTokenTransformer = injector.getInstance(AccessTokenTransformer.class);\n      cConf.set(Constants.Router.ADDRESS, hostname);\n      cConf.setStrings(Constants.Router.FORWARD, forwards.toArray(new String[forwards.size()]));\n      router =\n        new NettyRouter(cConf, InetAddresses.forString(hostname),\n                        new RouterServiceLookup((DiscoveryServiceClient) discoveryService,\n                                                new RouterPathLookup(new NoAuthenticator())),\n                        new SuccessTokenValidator(), accessTokenTransformer, discoveryServiceClient);\n      router.startAndWait();\n\n      for (Map.Entry<Integer, String> entry : router.getServiceLookup().getServiceMap().entrySet()) {\n        serviceMap.put(entry.getValue(), entry.getKey());\n      }\n    }","id":6152,"modified_method":"@Override\n    protected void before() throws Throwable {\n      CConfiguration cConf = CConfiguration.create();\n      Injector injector = Guice.createInjector(new ConfigModule(), new IOModule(),\n                                               new SecurityModules().getInMemoryModules(),\n                                               new DiscoveryRuntimeModule().getInMemoryModules());\n      DiscoveryServiceClient discoveryServiceClient = injector.getInstance(DiscoveryServiceClient.class);\n      AccessTokenTransformer accessTokenTransformer = injector.getInstance(AccessTokenTransformer.class);\n      cConf.set(Constants.Router.ADDRESS, hostname);\n      cConf.setStrings(Constants.Router.FORWARD, forwards.toArray(new String[forwards.size()]));\n      router =\n        new NettyRouter(cConf, InetAddresses.forString(hostname),\n                        new RouterServiceLookup((DiscoveryServiceClient) discoveryService,\n                                                new RouterPathLookup(new NoAuthenticator())),\n                        new SuccessTokenValidator(), accessTokenTransformer, discoveryServiceClient);\n      router.startAndWait();\n\n      for (Map.Entry<Integer, String> entry : router.getServiceLookup().getServiceMap().entrySet()) {\n        serviceMap.put(entry.getValue(), entry.getKey());\n      }\n    }","commit_id":"c126c996595e71f40ea3b25c33b707903bfa1046","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testInstanceHandlerRequests() throws Exception {\n    Assert.assertEquals(\"list\", doRequest(\"/data/datasets\", \"GET\"));\n    Assert.assertEquals(\"post:continuuity.user.myInstance\", doRequest(\"/data/datasets/myInstance\", \"POST\"));\n    Assert.assertEquals(\"delete:continuuity.user.myInstance\", doRequest(\"/data/datasets/myInstance\", \"DELETE\"));\n    Assert.assertEquals(\"get:continuuity.user.myInstance\", doRequest(\"/data/datasets/myInstance\", \"GET\"));\n  }","id":6153,"modified_method":"@Test\n  public void testInstanceHandlerRequests() throws Exception {\n    Assert.assertEquals(\"list\", doRequest(\"/data/datasets\", \"GET\"));\n    Assert.assertEquals(\"post:cdap.user.myInstance\", doRequest(\"/data/datasets/myInstance\", \"POST\"));\n    Assert.assertEquals(\"delete:cdap.user.myInstance\", doRequest(\"/data/datasets/myInstance\", \"DELETE\"));\n    Assert.assertEquals(\"get:cdap.user.myInstance\", doRequest(\"/data/datasets/myInstance\", \"GET\"));\n  }","commit_id":"c126c996595e71f40ea3b25c33b707903bfa1046","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\n  public static void before() throws Exception {\n    Injector injector = Guice.createInjector(new IOModule(), new SecurityModules().getInMemoryModules(),\n                                             new DiscoveryRuntimeModule().getInMemoryModules());\n\n    // Starting router\n    DiscoveryServiceClient discoveryServiceClient = injector.getInstance(DiscoveryServiceClient.class);\n    AccessTokenTransformer accessTokenTransformer = injector.getInstance(AccessTokenTransformer.class);\n    CConfiguration cConf = CConfiguration.create();\n    cConf.set(Constants.Router.ADDRESS, \"localhost\");\n    port = Networks.getRandomPort();\n    cConf.set(Constants.Router.FORWARD, port + \":\" + Constants.Service.GATEWAY);\n    nettyRouter = new NettyRouter(cConf, InetAddresses.forString(\"127.0.0.1\"),\n                                  new RouterServiceLookup(discoveryServiceClient,\n                                                          new RouterPathLookup(new NoAuthenticator())),\n                                  new SuccessTokenValidator(), accessTokenTransformer, discoveryServiceClient);\n    nettyRouter.startAndWait();\n\n    // Starting mock DataSet service\n    DiscoveryService discoveryService = injector.getInstance(DiscoveryService.class);\n    mockService = new MockHttpService(discoveryService, Constants.Service.DATASET_MANAGER,\n                                      new MockDatasetTypeHandler(), new DatasetInstanceHandler());\n    mockService.startAndWait();\n  }","id":6154,"modified_method":"@BeforeClass\n  public static void before() throws Exception {\n    Injector injector = Guice.createInjector(new ConfigModule(), new IOModule(),\n                                             new SecurityModules().getInMemoryModules(),\n                                             new DiscoveryRuntimeModule().getInMemoryModules());\n\n    // Starting router\n    DiscoveryServiceClient discoveryServiceClient = injector.getInstance(DiscoveryServiceClient.class);\n    AccessTokenTransformer accessTokenTransformer = injector.getInstance(AccessTokenTransformer.class);\n    CConfiguration cConf = CConfiguration.create();\n    cConf.set(Constants.Router.ADDRESS, \"localhost\");\n    port = Networks.getRandomPort();\n    cConf.set(Constants.Router.FORWARD, port + \":\" + Constants.Service.GATEWAY);\n    nettyRouter = new NettyRouter(cConf, InetAddresses.forString(\"127.0.0.1\"),\n                                  new RouterServiceLookup(discoveryServiceClient,\n                                                          new RouterPathLookup(new NoAuthenticator())),\n                                  new SuccessTokenValidator(), accessTokenTransformer, discoveryServiceClient);\n    nettyRouter.startAndWait();\n\n    // Starting mock DataSet service\n    DiscoveryService discoveryService = injector.getInstance(DiscoveryService.class);\n    mockService = new MockHttpService(discoveryService, Constants.Service.DATASET_MANAGER,\n                                      new MockDatasetTypeHandler(), new DatasetInstanceHandler());\n    mockService.startAndWait();\n  }","commit_id":"c126c996595e71f40ea3b25c33b707903bfa1046","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testExploreExecutorHandlerRequests() throws Exception {\n    Assert.assertEquals(\"schema:continuuity.user.foobar\", doRequest(\"/data/explore/datasets/foobar/schema\", \"GET\"));\n  }","id":6155,"modified_method":"@Test\n  public void testExploreExecutorHandlerRequests() throws Exception {\n    Assert.assertEquals(\"schema:cdap.user.foobar\", doRequest(\"/data/explore/datasets/foobar/schema\", \"GET\"));\n  }","commit_id":"c126c996595e71f40ea3b25c33b707903bfa1046","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\n  public static void before() throws Exception {\n    Injector injector = Guice.createInjector(new IOModule(), new SecurityModules().getInMemoryModules(),\n        new DiscoveryRuntimeModule().getInMemoryModules());\n\n    // Starting router\n    DiscoveryServiceClient discoveryServiceClient = injector.getInstance(DiscoveryServiceClient.class);\n    AccessTokenTransformer accessTokenTransformer = injector.getInstance(AccessTokenTransformer.class);\n    CConfiguration cConf = CConfiguration.create();\n    cConf.set(Constants.Router.ADDRESS, \"localhost\");\n    port = Networks.getRandomPort();\n    cConf.set(Constants.Router.FORWARD, port + \":\" + Constants.Service.GATEWAY);\n    nettyRouter = new NettyRouter(cConf, InetAddresses.forString(\"127.0.0.1\"),\n        new RouterServiceLookup(discoveryServiceClient,\n            new RouterPathLookup(new NoAuthenticator())),\n        new SuccessTokenValidator(), accessTokenTransformer, discoveryServiceClient);\n    nettyRouter.startAndWait();\n\n    // Starting mock DataSet service\n    DiscoveryService discoveryService = injector.getInstance(DiscoveryService.class);\n    mockService = new MockHttpService(discoveryService, Constants.Service.EXPLORE_HTTP_USER_SERVICE,\n                                      new MockQueryExecutorHandler(), new MockExplorePingHandler(),\n                                      new MockExploreExecutorHandler(), new MockExploreMetadataHandler());\n    mockService.startAndWait();\n  }","id":6156,"modified_method":"@BeforeClass\n  public static void before() throws Exception {\n    Injector injector = Guice.createInjector(new ConfigModule(), new IOModule(),\n                                             new SecurityModules().getInMemoryModules(),\n                                             new DiscoveryRuntimeModule().getInMemoryModules());\n\n    // Starting router\n    DiscoveryServiceClient discoveryServiceClient = injector.getInstance(DiscoveryServiceClient.class);\n    AccessTokenTransformer accessTokenTransformer = injector.getInstance(AccessTokenTransformer.class);\n    CConfiguration cConf = CConfiguration.create();\n    cConf.set(Constants.Router.ADDRESS, \"localhost\");\n    port = Networks.getRandomPort();\n    cConf.set(Constants.Router.FORWARD, port + \":\" + Constants.Service.GATEWAY);\n    nettyRouter = new NettyRouter(cConf, InetAddresses.forString(\"127.0.0.1\"),\n        new RouterServiceLookup(discoveryServiceClient,\n            new RouterPathLookup(new NoAuthenticator())),\n        new SuccessTokenValidator(), accessTokenTransformer, discoveryServiceClient);\n    nettyRouter.startAndWait();\n\n    // Starting mock DataSet service\n    DiscoveryService discoveryService = injector.getInstance(DiscoveryService.class);\n    mockService = new MockHttpService(discoveryService, Constants.Service.EXPLORE_HTTP_USER_SERVICE,\n                                      new MockQueryExecutorHandler(), new MockExplorePingHandler(),\n                                      new MockExploreExecutorHandler(), new MockExploreMetadataHandler());\n    mockService.startAndWait();\n  }","commit_id":"c126c996595e71f40ea3b25c33b707903bfa1046","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test(timeout = 60000L)\n  public void testSQLQuery() throws Exception {\n\n    deployDatasetModule(\"my-kv\", AppsWithDataset.KeyValueTableDefinition.Module.class);\n    ApplicationManager appManager = deployApplication(AppsWithDataset.AppWithAutoCreate.class);\n    DataSetManager<AppsWithDataset.KeyValueTableDefinition.KeyValueTable> myTableManager =\n        appManager.getDataSet(\"myTable\");\n    AppsWithDataset.KeyValueTableDefinition.KeyValueTable kvTable = myTableManager.get();\n    kvTable.put(\"a\", \"1\");\n    kvTable.put(\"b\", \"2\");\n    kvTable.put(\"c\", \"1\");\n    myTableManager.flush();\n\n    Connection connection = getQueryClient();\n    try {\n      // list the tables and make sure the table is there\n      ResultSet results = connection.prepareStatement(\"show tables\").executeQuery();\n      Assert.assertTrue(results.next());\n      Assert.assertTrue(\"continuuity_user_mytable\".equalsIgnoreCase(results.getString(1)));\n\n      // run a query over the dataset\n      results = connection.prepareStatement(\"select first from continuuity_user_mytable where second = '1'\")\n          .executeQuery();\n      Assert.assertTrue(results.next());\n      Assert.assertEquals(\"a\", results.getString(1));\n      Assert.assertTrue(results.next());\n      Assert.assertEquals(\"c\", results.getString(1));\n      Assert.assertFalse(results.next());\n\n    } finally {\n      connection.close();\n      appManager.stopAll();\n    }\n  }","id":6157,"modified_method":"@Test(timeout = 60000L)\n  public void testSQLQuery() throws Exception {\n\n    deployDatasetModule(\"my-kv\", AppsWithDataset.KeyValueTableDefinition.Module.class);\n    ApplicationManager appManager = deployApplication(AppsWithDataset.AppWithAutoCreate.class);\n    DataSetManager<AppsWithDataset.KeyValueTableDefinition.KeyValueTable> myTableManager =\n        appManager.getDataSet(\"myTable\");\n    AppsWithDataset.KeyValueTableDefinition.KeyValueTable kvTable = myTableManager.get();\n    kvTable.put(\"a\", \"1\");\n    kvTable.put(\"b\", \"2\");\n    kvTable.put(\"c\", \"1\");\n    myTableManager.flush();\n\n    Connection connection = getQueryClient();\n    try {\n      // list the tables and make sure the table is there\n      ResultSet results = connection.prepareStatement(\"show tables\").executeQuery();\n      Assert.assertTrue(results.next());\n      Assert.assertTrue(\"cdap_user_mytable\".equalsIgnoreCase(results.getString(1)));\n\n      // run a query over the dataset\n      results = connection.prepareStatement(\"select first from cdap_user_mytable where second = '1'\")\n          .executeQuery();\n      Assert.assertTrue(results.next());\n      Assert.assertEquals(\"a\", results.getString(1));\n      Assert.assertTrue(results.next());\n      Assert.assertEquals(\"c\", results.getString(1));\n      Assert.assertFalse(results.next());\n\n    } finally {\n      connection.close();\n      appManager.stopAll();\n    }\n  }","commit_id":"c126c996595e71f40ea3b25c33b707903bfa1046","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void publish(MetricsScope scope, Iterator<MetricsRecord> metrics) throws Exception {\n    // Currently the test framework only supports REACTOR metrics.\n    if (scope != MetricsScope.REACTOR) {\n      return;\n    }\n    while (metrics.hasNext()) {\n      MetricsRecord metricsRecord = metrics.next();\n      String context = metricsRecord.getContext();\n      // Remove the last part, which is the runID\n      context = context.substring(0, context.lastIndexOf('.'));\n      RuntimeStats.count(String.format(\"%s.%s\", context, metricsRecord.getName()), metricsRecord.getValue());\n    }\n  }","id":6158,"modified_method":"@Override\n  protected void publish(MetricsScope scope, Iterator<MetricsRecord> metrics) throws Exception {\n    // Currently the test framework only supports REACTOR metrics.\n    if (scope != MetricsScope.REACTOR) {\n      return;\n    }\n    while (metrics.hasNext()) {\n      MetricsRecord metricsRecord = metrics.next();\n      String context = metricsRecord.getContext();\n      // Remove the last part, which is the runID\n      int idx = context.lastIndexOf('.');\n      if (idx >= 0) {\n        context = context.substring(0, idx);\n      }\n      RuntimeStats.count(String.format(\"%s.%s\", context, metricsRecord.getName()), metricsRecord.getValue());\n    }\n  }","commit_id":"c126c996595e71f40ea3b25c33b707903bfa1046","url":"https://github.com/caskdata/cdap"},{"original_method":"protected String createTestGroup() throws IOException {\n        String postUrl = HTTP_BASE_URL + \"/system/userManager/group.create.html\";\n\n\t\tString testGroupId = \"testGroup\" + (counter++);\n\t\tList<NameValuePair> postParams = new ArrayList<NameValuePair>();\n\t\tpostParams.add(new NameValuePair(\":name\", testGroupId));\n\t\t\n\t\t//success would be a redirect to the welcome page of the webapp\n        Credentials creds = new UsernamePasswordCredentials(\"admin\", \"admin\");\n\t\tassertAuthenticatedPostStatus(creds, postUrl, HttpServletResponse.SC_OK, postParams, null);\n\t\t\n\t\treturn testGroupId;\n\t}","id":6159,"modified_method":"protected String createTestGroup() throws IOException {\n        String postUrl = HTTP_BASE_URL + \"/system/userManager/group.create.html\";\n\n\t\tString testGroupId = \"testGroup\" + random.nextInt();\n\t\tList<NameValuePair> postParams = new ArrayList<NameValuePair>();\n\t\tpostParams.add(new NameValuePair(\":name\", testGroupId));\n\t\t\n\t\t//success would be a redirect to the welcome page of the webapp\n        Credentials creds = new UsernamePasswordCredentials(\"admin\", \"admin\");\n\t\tassertAuthenticatedPostStatus(creds, postUrl, HttpServletResponse.SC_OK, postParams, null);\n\t\t\n\t\treturn testGroupId;\n\t}","commit_id":"4e0ef3d1aad7ad492d4e007912f00c56bcc5f3a5","url":"https://github.com/apache/sling"},{"original_method":"protected String createTestFolder() throws IOException {\n        String postUrl = HTTP_BASE_URL + TEST_BASE_PATH + \"/\" + \"testFolder\" + (counter++);\n\n        final String location = testClient.createNode(postUrl + SlingPostConstants.DEFAULT_CREATE_SUFFIX, null);\n        assertHttpStatus(location + DEFAULT_EXT, HttpServletResponse.SC_OK,\n                \"POST must redirect to created resource (\" + location + \")\");\n        assertTrue(\"Node (\" + location + \") must have generated name\",\n                !location.endsWith(\"/*\"));\n        assertTrue(\"Node (\" + location + \") must created be under POST URL (\" + postUrl + \")\",\n                location.contains(postUrl + \"/\"));\n\n        return location;\n\t}","id":6160,"modified_method":"protected String createTestFolder() throws IOException {\n        String postUrl = HTTP_BASE_URL + TEST_BASE_PATH + \"/\" + \"testFolder\" + random.nextInt();\n\n        final String location = testClient.createNode(postUrl + SlingPostConstants.DEFAULT_CREATE_SUFFIX, null);\n        assertHttpStatus(location + DEFAULT_EXT, HttpServletResponse.SC_OK,\n                \"POST must redirect to created resource (\" + location + \")\");\n        assertTrue(\"Node (\" + location + \") must have generated name\",\n                !location.endsWith(\"/*\"));\n        assertTrue(\"Node (\" + location + \") must created be under POST URL (\" + postUrl + \")\",\n                location.contains(postUrl + \"/\"));\n\n        return location;\n\t}","commit_id":"4e0ef3d1aad7ad492d4e007912f00c56bcc5f3a5","url":"https://github.com/apache/sling"},{"original_method":"protected String createTestUser() throws IOException {\n        String postUrl = HTTP_BASE_URL + \"/system/userManager/user.create.html\";\n\n\t\tString testUserId = \"testUser\" + (counter++);\n\t\tList<NameValuePair> postParams = new ArrayList<NameValuePair>();\n\t\tpostParams.add(new NameValuePair(\":name\", testUserId));\n\t\tpostParams.add(new NameValuePair(\"pwd\", \"testPwd\"));\n\t\tpostParams.add(new NameValuePair(\"pwdConfirm\", \"testPwd\"));\n\t\tassertPostStatus(postUrl, HttpServletResponse.SC_OK, postParams, null);\n\t\t\n\t\treturn testUserId;\n\t}","id":6161,"modified_method":"protected String createTestUser() throws IOException {\n        String postUrl = HTTP_BASE_URL + \"/system/userManager/user.create.html\";\n\n\t\tString testUserId = \"testUser\" + random.nextInt();\n\t\tList<NameValuePair> postParams = new ArrayList<NameValuePair>();\n\t\tpostParams.add(new NameValuePair(\":name\", testUserId));\n\t\tpostParams.add(new NameValuePair(\"pwd\", \"testPwd\"));\n\t\tpostParams.add(new NameValuePair(\"pwdConfirm\", \"testPwd\"));\n\t\tassertPostStatus(postUrl, HttpServletResponse.SC_OK, postParams, null);\n\t\t\n\t\treturn testUserId;\n\t}","commit_id":"4e0ef3d1aad7ad492d4e007912f00c56bcc5f3a5","url":"https://github.com/apache/sling"},{"original_method":"/**\n\t * Checks whether the current user has been granted privileges\n\t * to delete the specified path.\n\t *  \n\t * @param session the JCR session of the current user\n\t * @param absPath the path of the resource to check\n\t * @return true if the current user has the privileges, false otherwise\n\t */\n\tpublic boolean canDelete(Session session, String absPath) {\n\t\ttry {\n\t\t\tAccessControlManager accessControlManager = AccessControlUtil.getAccessControlManager(session);\n\t\t\t\n\t\t\tString parentPath = absPath.substring(0, absPath.lastIndexOf('/'));\n\t\t\tboolean canDelete = accessControlManager.hasPrivileges(absPath, new Privilege[] {\n\t\t\t\t\t\t\taccessControlManager.privilegeFromName(Privilege.JCR_REMOVE_NODE)\n\t\t\t\t\t\t}) && canDeleteChildren(session, parentPath);\n\t\t\treturn canDelete;\n\t\t} catch (RepositoryException e) {\n\t\t\treturn false;\n\t\t}\n\t}","id":6162,"modified_method":"/**\n\t * Checks whether the current user has been granted privileges\n\t * to delete the specified path.\n\t *  \n\t * @param session the JCR session of the current user\n\t * @param absPath the path of the resource to check\n\t * @return true if the current user has the privileges, false otherwise\n\t */\n\tpublic boolean canDelete(Session session, String absPath) {\n\t\ttry {\n\t\t\tAccessControlManager accessControlManager = AccessControlUtil.getAccessControlManager(session);\n\t\t\t\n\t\t\tString parentPath;\n\t\t\tint lastSlash = absPath.lastIndexOf('/');\n\t\t\tif (lastSlash == 0) {\n\t\t\t\t//the parent is the root folder.\n\t\t\t\tparentPath = \"/\";\n\t\t\t} else {\n\t\t\t\t//strip the last segment\n\t\t\t\tparentPath = absPath.substring(0, lastSlash);\n\t\t\t}\n\t\t\tboolean canDelete = accessControlManager.hasPrivileges(absPath, new Privilege[] {\n\t\t\t\t\t\t\taccessControlManager.privilegeFromName(Privilege.JCR_REMOVE_NODE)\n\t\t\t\t\t\t}) && canDeleteChildren(session, parentPath);\n\t\t\treturn canDelete;\n\t\t} catch (RepositoryException e) {\n\t\t\treturn false;\n\t\t}\n\t}","commit_id":"4e0ef3d1aad7ad492d4e007912f00c56bcc5f3a5","url":"https://github.com/apache/sling"},{"original_method":"private VirtualFile findFileByPath(String path, boolean createIfNoCache, final boolean refreshIfNotFound) {\n    if (SystemInfo.isWindows || SystemInfo.isOS2) {\n      if (path.endsWith(\":/\")) { // instead of getting canonical path - see below\n        path = Character.toUpperCase(path.charAt(0)) + path.substring(1);\n      }\n    }\n\n    initRoots();\n    for (VirtualFile root : myFSRootsToPaths.keySet()) {\n      //noinspection NonConstantStringShouldBeStringBuffer\n      String runPath = root.getPath();\n      if (runPath.endsWith(\"/\")) runPath = runPath.substring(0, runPath.length() - 1);\n      if (!FileUtil.startsWith(path, runPath)) continue;\n      if (path.length() == runPath.length()) return root;\n      String tail;\n      if (path.charAt(runPath.length()) == '/') {\n        tail = path.substring(runPath.length() + 1);\n      }\n      else if (StringUtil.endsWithChar(runPath, '/')) {\n        tail = path.substring(runPath.length());\n      }\n      else {\n        continue;\n      }\n      StringTokenizer tokenizer = new StringTokenizer(tail, \"/\");\n      while (tokenizer.hasMoreTokens()) {\n        final String name = tokenizer.nextToken();\n        if (\".\".equals(name)) continue;\n        if (\"..\".equals(name)) {\n          runPath = runPath.substring(0, runPath.lastIndexOf(\"/\"));\n          root = root.getParent();\n          if (root == null) return null;\n        }\n        else {\n          runPath = runPath + \"/\" + name;\n          if (!((VirtualFileImpl)root).areChildrenCached()) {\n            VirtualFile child = myUnaccountedFiles.get(runPath);\n            if (child == null || !child.isValid()) {\n              if (!createIfNoCache) return null;\n              if (myUnaccountedFiles.containsKey(runPath)) {\n                if (refreshIfNotFound) {\n                  root.refresh(false, false);\n                  child = root.findChild(name);\n                  if (child == null) return null;\n                  root = child;\n                } else {\n                  return null;\n                }\n              } else {\n                root = ((VirtualFileImpl)root).findSingleChild(name);\n                if (root == null) return null;\n              }\n            } else {\n              root = child;\n            }\n          }\n          else {\n            VirtualFile child = root.findChild(name);\n            if (child == null) {\n              if (refreshIfNotFound) {\n                root.refresh(false, false);\n                child = root.findChild(name);\n                if (child == null) return null;\n              }\n              else {\n                return null;\n              }\n            }\n            root = child;\n          }\n        }\n      }\n\n      return root;\n    }\n\n    return null;\n  }","id":6163,"modified_method":"private VirtualFile findFileByPath(String path, boolean createIfNoCache, final boolean refreshIfNotFound) {\n    if (SystemInfo.isWindows || SystemInfo.isOS2) {\n      if (path.endsWith(\":/\")) { // instead of getting canonical path - see below\n        path = Character.toUpperCase(path.charAt(0)) + path.substring(1);\n      }\n    }\n\n    initRoots();\n    for (VirtualFile root : myFSRootsToPaths.keySet()) {\n      //noinspection NonConstantStringShouldBeStringBuffer\n      String runPath = root.getPath();\n      if (runPath.endsWith(\"/\")) runPath = runPath.substring(0, runPath.length() - 1);\n      if (!FileUtil.startsWith(path, runPath)) continue;\n      if (path.length() == runPath.length()) return root;\n      String tail;\n      if (path.charAt(runPath.length()) == '/') {\n        tail = path.substring(runPath.length() + 1);\n      }\n      else if (StringUtil.endsWithChar(runPath, '/')) {\n        tail = path.substring(runPath.length());\n      }\n      else {\n        continue;\n      }\n      StringTokenizer tokenizer = new StringTokenizer(tail, \"/\");\n      while (tokenizer.hasMoreTokens()) {\n        final String name = tokenizer.nextToken();\n        if (\".\".equals(name)) continue;\n        if (\"..\".equals(name)) {\n          final int index = runPath.lastIndexOf(\"/\");\n          if (index >= 0) {\n            runPath = runPath.substring(0, index);\n          }\n          root = root.getParent();\n          if (root == null) return null;\n        }\n        else {\n          runPath = runPath + \"/\" + name;\n          if (!((VirtualFileImpl)root).areChildrenCached()) {\n            VirtualFile child = myUnaccountedFiles.get(runPath);\n            if (child == null || !child.isValid()) {\n              if (!createIfNoCache) return null;\n              if (myUnaccountedFiles.containsKey(runPath)) {\n                if (refreshIfNotFound) {\n                  root.refresh(false, false);\n                  child = root.findChild(name);\n                  if (child == null) return null;\n                  root = child;\n                } else {\n                  return null;\n                }\n              } else {\n                root = ((VirtualFileImpl)root).findSingleChild(name);\n                if (root == null) return null;\n              }\n            } else {\n              root = child;\n            }\n          }\n          else {\n            VirtualFile child = root.findChild(name);\n            if (child == null) {\n              if (refreshIfNotFound) {\n                root.refresh(false, false);\n                child = root.findChild(name);\n                if (child == null) return null;\n              }\n              else {\n                return null;\n              }\n            }\n            root = child;\n          }\n        }\n      }\n\n      return root;\n    }\n\n    return null;\n  }","commit_id":"3ff6e2cf0d2a04c9bece640a0e2fb15799fdbde4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Updates the workspace as well as locate changes.\n     *\n     * @return\n     *      List of affected file names, relative to the workspace directory.\n     *      Null if the operation failed.\n     */\n    private List<String> update(boolean dryRun, Launcher launcher, FilePath workspace, TaskListener listener, Date date) throws IOException, InterruptedException {\n\n        List<String> changedFileNames = new ArrayList<String>();    // file names relative to the workspace\n\n        ArgumentListBuilder cmd = new ArgumentListBuilder();\n        cmd.add(getDescriptor().getCvsExe(),\"-q\",\"-z9\");\n        if(dryRun)\n            cmd.add(\"-n\");\n        cmd.add(\"update\",\"-PdC\");\n        if (branch != null) {\n            cmd.add(\"-r\", branch);\n        }\n        configureDate(cmd, date);\n\n        if(flatten) {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n            if(!run(launcher,cmd,listener,workspace,\n                new ForkOutputStream(baos,listener.getLogger())))\n                return null;\n\n            parseUpdateOutput(\"\",baos, changedFileNames);\n        } else {\n            @SuppressWarnings(\"unchecked\") // StringTokenizer oddly has the wrong type\n            final Set<String> moduleNames = new TreeSet(Collections.list(new StringTokenizer(module)));\n\n            // Add in any existing CVS dirs, in case project checked out its own.\n            moduleNames.addAll(workspace.act(new FileCallable<Set<String>>() {\n                public Set<String> invoke(File ws, VirtualChannel channel) throws IOException {\n                    File[] subdirs = ws.listFiles();\n                    if (subdirs != null) {\n                        SUBDIR: for (File s : subdirs) {\n                            if (new File(s, \"CVS\").isDirectory()) {\n                                String top = s.getName();\n                                for (String mod : moduleNames) {\n                                    if (mod.startsWith(top + \"/\")) {\n                                        // #190: user asked to check out foo/bar foo/baz quux\n                                        // Our top-level dirs are \"foo\" and \"quux\".\n                                        // Do not add \"foo\" to checkout or we will check out foo/*!\n                                        continue SUBDIR;\n                                    }\n                                }\n                                moduleNames.add(top);\n                            }\n                        }\n                    }\n                    return moduleNames;\n                }\n            }));\n\n            for (String moduleName : moduleNames) {\n                // capture the output during update\n                ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                FilePath modulePath = new FilePath(workspace, moduleName);\n\n                ArgumentListBuilder actualCmd = cmd;\n                String baseName = moduleName;\n\n                if(!modulePath.isDirectory()) {\n                    // updating just one file, like \"foo/bar.txt\".\n                    // run update command from \"foo\" directory with \"bar.txt\" as the command line argument\n                    actualCmd = cmd.clone();\n                    actualCmd.add(modulePath.getName());\n                    modulePath = modulePath.getParent();\n                    baseName = baseName.substring(0,baseName.lastIndexOf('/'));\n                }\n\n                if(!run(launcher,actualCmd,listener,\n                    modulePath,\n                    new ForkOutputStream(baos,listener.getLogger())))\n                    return null;\n\n                // we'll run one \"cvs log\" command with workspace as the base,\n                // so use path names that are relative to moduleName.\n                parseUpdateOutput(baseName+'/',baos, changedFileNames);\n            }\n        }\n\n        return changedFileNames;\n    }","id":6164,"modified_method":"/**\n     * Updates the workspace as well as locate changes.\n     *\n     * @return\n     *      List of affected file names, relative to the workspace directory.\n     *      Null if the operation failed.\n     */\n    private List<String> update(boolean dryRun, Launcher launcher, FilePath workspace, TaskListener listener, Date date) throws IOException, InterruptedException {\n\n        List<String> changedFileNames = new ArrayList<String>();    // file names relative to the workspace\n\n        ArgumentListBuilder cmd = new ArgumentListBuilder();\n        cmd.add(getDescriptor().getCvsExe(),\"-q\",\"-z9\");\n        if(dryRun)\n            cmd.add(\"-n\");\n        cmd.add(\"update\",\"-PdC\");\n        if (branch != null) {\n            cmd.add(\"-r\", branch);\n        }\n        configureDate(cmd, date);\n\n        if(flatten) {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n            if(!run(launcher,cmd,listener,workspace,\n                new ForkOutputStream(baos,listener.getLogger())))\n                return null;\n\n            parseUpdateOutput(\"\",baos, changedFileNames);\n        } else {\n            @SuppressWarnings(\"unchecked\") // StringTokenizer oddly has the wrong type\n            final Set<String> moduleNames = new TreeSet(Collections.list(new StringTokenizer(module)));\n\n            // Add in any existing CVS dirs, in case project checked out its own.\n            moduleNames.addAll(workspace.act(new FileCallable<Set<String>>() {\n                public Set<String> invoke(File ws, VirtualChannel channel) throws IOException {\n                    File[] subdirs = ws.listFiles();\n                    if (subdirs != null) {\n                        SUBDIR: for (File s : subdirs) {\n                            if (new File(s, \"CVS\").isDirectory()) {\n                                String top = s.getName();\n                                for (String mod : moduleNames) {\n                                    if (mod.startsWith(top + \"/\")) {\n                                        // #190: user asked to check out foo/bar foo/baz quux\n                                        // Our top-level dirs are \"foo\" and \"quux\".\n                                        // Do not add \"foo\" to checkout or we will check out foo/*!\n                                        continue SUBDIR;\n                                    }\n                                }\n                                moduleNames.add(top);\n                            }\n                        }\n                    }\n                    return moduleNames;\n                }\n            }));\n\n            for (String moduleName : moduleNames) {\n                // capture the output during update\n                ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                FilePath modulePath = new FilePath(workspace, moduleName);\n\n                ArgumentListBuilder actualCmd = cmd;\n                String baseName = moduleName;\n\n                if(!modulePath.isDirectory()) {\n                    // updating just one file, like \"foo/bar.txt\".\n                    // run update command from \"foo\" directory with \"bar.txt\" as the command line argument\n                    actualCmd = cmd.clone();\n                    actualCmd.add(modulePath.getName());\n                    modulePath = modulePath.getParent();\n                    int slash = baseName.lastIndexOf('/');\n                    if (slash > 0) {\n                        baseName = baseName.substring(0, slash);\n                    }\n                }\n\n                if(!run(launcher,actualCmd,listener,\n                    modulePath,\n                    new ForkOutputStream(baos,listener.getLogger())))\n                    return null;\n\n                // we'll run one \"cvs log\" command with workspace as the base,\n                // so use path names that are relative to moduleName.\n                parseUpdateOutput(baseName+'/',baos, changedFileNames);\n            }\n        }\n\n        return changedFileNames;\n    }","commit_id":"60cca83f0bbd628b3086b9a20d41a198f4b4769d","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Builds the errors tree\n     */\n    public void buildTree() {\n        updateCount++;\n        final DefaultMutableTreeNode rootNode = new DefaultMutableTreeNode();\n\n        if (errors == null || errors.isEmpty()) {\n            GuiHelper.runInEDTAndWait(new Runnable() {\n                @Override\n                public void run() {\n                    valTreeModel.setRoot(rootNode);\n                }\n            });\n            return;\n        }\n        // Sort validation errors - #8517\n        Collections.sort(errors);\n\n        // Remember the currently expanded rows\n        Set<Object> oldSelectedRows = new HashSet<>();\n        Enumeration<TreePath> expanded = getExpandedDescendants(new TreePath(getRoot()));\n        if (expanded != null) {\n            while (expanded.hasMoreElements()) {\n                TreePath path = expanded.nextElement();\n                DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();\n                Object userObject = node.getUserObject();\n                if (userObject instanceof Severity) {\n                    oldSelectedRows.add(userObject);\n                } else if (userObject instanceof String) {\n                    String msg = (String) userObject;\n                    msg = msg.substring(0, msg.lastIndexOf(\" (\"));\n                    oldSelectedRows.add(msg);\n                }\n            }\n        }\n\n        Map<Severity, MultiMap<String, TestError>> errorTree = new HashMap<>();\n        Map<Severity, HashMap<String, MultiMap<String, TestError>>> errorTreeDeep = new HashMap<>();\n        for (Severity s : Severity.values()) {\n            errorTree.put(s, new MultiMap<String, TestError>(20));\n            errorTreeDeep.put(s, new HashMap<String, MultiMap<String, TestError>>());\n        }\n\n        final Boolean other = ValidatorPreference.PREF_OTHER.get();\n        for (TestError e : errors) {\n            if (e.getIgnored()) {\n                continue;\n            }\n            Severity s = e.getSeverity();\n            if(!other && s == Severity.OTHER) {\n                continue;\n            }\n            String d = e.getDescription();\n            String m = e.getMessage();\n            if (filter != null) {\n                boolean found = false;\n                for (OsmPrimitive p : e.getPrimitives()) {\n                    if (filter.contains(p)) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    continue;\n                }\n            }\n            if (d != null) {\n                MultiMap<String, TestError> b = errorTreeDeep.get(s).get(m);\n                if (b == null) {\n                    b = new MultiMap<>(20);\n                    errorTreeDeep.get(s).put(m, b);\n                }\n                b.put(d, e);\n            } else {\n                errorTree.get(s).put(m, e);\n            }\n        }\n\n        List<TreePath> expandedPaths = new ArrayList<>();\n        for (Severity s : Severity.values()) {\n            MultiMap<String, TestError> severityErrors = errorTree.get(s);\n            Map<String, MultiMap<String, TestError>> severityErrorsDeep = errorTreeDeep.get(s);\n            if (severityErrors.isEmpty() && severityErrorsDeep.isEmpty()) {\n                continue;\n            }\n\n            // Severity node\n            DefaultMutableTreeNode severityNode = new GroupTreeNode(s);\n            rootNode.add(severityNode);\n\n            if (oldSelectedRows.contains(s)) {\n                expandedPaths.add(new TreePath(new Object[] { rootNode, severityNode }));\n            }\n\n            for (Entry<String, Set<TestError>> msgErrors : severityErrors.entrySet()) {\n                // Message node\n                Set<TestError> errs = msgErrors.getValue();\n                String msg = tr(\"{0} ({1})\", msgErrors.getKey(), errs.size());\n                DefaultMutableTreeNode messageNode = new DefaultMutableTreeNode(msg);\n                severityNode.add(messageNode);\n\n                if (oldSelectedRows.contains(msgErrors.getKey())) {\n                    expandedPaths.add(new TreePath(new Object[] { rootNode, severityNode, messageNode }));\n                }\n\n                for (TestError error : errs) {\n                    // Error node\n                    DefaultMutableTreeNode errorNode = new DefaultMutableTreeNode(error);\n                    messageNode.add(errorNode);\n                }\n            }\n            for (Entry<String, MultiMap<String, TestError>> bag : severityErrorsDeep.entrySet()) {\n                // Group node\n                MultiMap<String, TestError> errorlist = bag.getValue();\n                DefaultMutableTreeNode groupNode = null;\n                if (errorlist.size() > 1) {\n                    groupNode = new GroupTreeNode(bag.getKey());\n                    severityNode.add(groupNode);\n                    if (oldSelectedRows.contains(bag.getKey())) {\n                        expandedPaths.add(new TreePath(new Object[] { rootNode, severityNode, groupNode }));\n                    }\n                }\n\n                for (Entry<String, Set<TestError>> msgErrors : errorlist.entrySet()) {\n                    // Message node\n                    Set<TestError> errs = msgErrors.getValue();\n                    String msg;\n                    if (groupNode != null) {\n                        msg = tr(\"{0} ({1})\", msgErrors.getKey(), errs.size());\n                    } else {\n                        msg = tr(\"{0} - {1} ({2})\", msgErrors.getKey(), bag.getKey(), errs.size());\n                    }\n                    DefaultMutableTreeNode messageNode = new DefaultMutableTreeNode(msg);\n                    if (groupNode != null) {\n                        groupNode.add(messageNode);\n                    } else {\n                        severityNode.add(messageNode);\n                    }\n\n                    if (oldSelectedRows.contains(msgErrors.getKey())) {\n                        if (groupNode != null) {\n                            expandedPaths.add(new TreePath(new Object[] { rootNode, severityNode, groupNode,\n                                    messageNode }));\n                        } else {\n                            expandedPaths.add(new TreePath(new Object[] { rootNode, severityNode, messageNode }));\n                        }\n                    }\n\n                    for (TestError error : errs) {\n                        // Error node\n                        DefaultMutableTreeNode errorNode = new DefaultMutableTreeNode(error);\n                        messageNode.add(errorNode);\n                    }\n                }\n            }\n        }\n\n        valTreeModel.setRoot(rootNode);\n        for (TreePath path : expandedPaths) {\n            this.expandPath(path);\n        }\n    }","id":6165,"modified_method":"/**\n     * Builds the errors tree\n     */\n    public void buildTree() {\n        updateCount++;\n        final DefaultMutableTreeNode rootNode = new DefaultMutableTreeNode();\n\n        if (errors == null || errors.isEmpty()) {\n            GuiHelper.runInEDTAndWait(new Runnable() {\n                @Override\n                public void run() {\n                    valTreeModel.setRoot(rootNode);\n                }\n            });\n            return;\n        }\n        // Sort validation errors - #8517\n        Collections.sort(errors);\n\n        // Remember the currently expanded rows\n        Set<Object> oldSelectedRows = new HashSet<>();\n        Enumeration<TreePath> expanded = getExpandedDescendants(new TreePath(getRoot()));\n        if (expanded != null) {\n            while (expanded.hasMoreElements()) {\n                TreePath path = expanded.nextElement();\n                DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();\n                Object userObject = node.getUserObject();\n                if (userObject instanceof Severity) {\n                    oldSelectedRows.add(userObject);\n                } else if (userObject instanceof String) {\n                    String msg = (String) userObject;\n                    int index = msg.lastIndexOf(\" (\");\n                    if (index > 0) {\n                        msg = msg.substring(0, index);\n                    }\n                    oldSelectedRows.add(msg);\n                }\n            }\n        }\n\n        Map<Severity, MultiMap<String, TestError>> errorTree = new HashMap<>();\n        Map<Severity, HashMap<String, MultiMap<String, TestError>>> errorTreeDeep = new HashMap<>();\n        for (Severity s : Severity.values()) {\n            errorTree.put(s, new MultiMap<String, TestError>(20));\n            errorTreeDeep.put(s, new HashMap<String, MultiMap<String, TestError>>());\n        }\n\n        final Boolean other = ValidatorPreference.PREF_OTHER.get();\n        for (TestError e : errors) {\n            if (e.getIgnored()) {\n                continue;\n            }\n            Severity s = e.getSeverity();\n            if(!other && s == Severity.OTHER) {\n                continue;\n            }\n            String d = e.getDescription();\n            String m = e.getMessage();\n            if (filter != null) {\n                boolean found = false;\n                for (OsmPrimitive p : e.getPrimitives()) {\n                    if (filter.contains(p)) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    continue;\n                }\n            }\n            if (d != null) {\n                MultiMap<String, TestError> b = errorTreeDeep.get(s).get(m);\n                if (b == null) {\n                    b = new MultiMap<>(20);\n                    errorTreeDeep.get(s).put(m, b);\n                }\n                b.put(d, e);\n            } else {\n                errorTree.get(s).put(m, e);\n            }\n        }\n\n        List<TreePath> expandedPaths = new ArrayList<>();\n        for (Severity s : Severity.values()) {\n            MultiMap<String, TestError> severityErrors = errorTree.get(s);\n            Map<String, MultiMap<String, TestError>> severityErrorsDeep = errorTreeDeep.get(s);\n            if (severityErrors.isEmpty() && severityErrorsDeep.isEmpty()) {\n                continue;\n            }\n\n            // Severity node\n            DefaultMutableTreeNode severityNode = new GroupTreeNode(s);\n            rootNode.add(severityNode);\n\n            if (oldSelectedRows.contains(s)) {\n                expandedPaths.add(new TreePath(new Object[] { rootNode, severityNode }));\n            }\n\n            for (Entry<String, Set<TestError>> msgErrors : severityErrors.entrySet()) {\n                // Message node\n                Set<TestError> errs = msgErrors.getValue();\n                String msg = tr(\"{0} ({1})\", msgErrors.getKey(), errs.size());\n                DefaultMutableTreeNode messageNode = new DefaultMutableTreeNode(msg);\n                severityNode.add(messageNode);\n\n                if (oldSelectedRows.contains(msgErrors.getKey())) {\n                    expandedPaths.add(new TreePath(new Object[] { rootNode, severityNode, messageNode }));\n                }\n\n                for (TestError error : errs) {\n                    // Error node\n                    DefaultMutableTreeNode errorNode = new DefaultMutableTreeNode(error);\n                    messageNode.add(errorNode);\n                }\n            }\n            for (Entry<String, MultiMap<String, TestError>> bag : severityErrorsDeep.entrySet()) {\n                // Group node\n                MultiMap<String, TestError> errorlist = bag.getValue();\n                DefaultMutableTreeNode groupNode = null;\n                if (errorlist.size() > 1) {\n                    groupNode = new GroupTreeNode(bag.getKey());\n                    severityNode.add(groupNode);\n                    if (oldSelectedRows.contains(bag.getKey())) {\n                        expandedPaths.add(new TreePath(new Object[] { rootNode, severityNode, groupNode }));\n                    }\n                }\n\n                for (Entry<String, Set<TestError>> msgErrors : errorlist.entrySet()) {\n                    // Message node\n                    Set<TestError> errs = msgErrors.getValue();\n                    String msg;\n                    if (groupNode != null) {\n                        msg = tr(\"{0} ({1})\", msgErrors.getKey(), errs.size());\n                    } else {\n                        msg = tr(\"{0} - {1} ({2})\", msgErrors.getKey(), bag.getKey(), errs.size());\n                    }\n                    DefaultMutableTreeNode messageNode = new DefaultMutableTreeNode(msg);\n                    if (groupNode != null) {\n                        groupNode.add(messageNode);\n                    } else {\n                        severityNode.add(messageNode);\n                    }\n\n                    if (oldSelectedRows.contains(msgErrors.getKey())) {\n                        if (groupNode != null) {\n                            expandedPaths.add(new TreePath(new Object[] { rootNode, severityNode, groupNode,\n                                    messageNode }));\n                        } else {\n                            expandedPaths.add(new TreePath(new Object[] { rootNode, severityNode, messageNode }));\n                        }\n                    }\n\n                    for (TestError error : errs) {\n                        // Error node\n                        DefaultMutableTreeNode errorNode = new DefaultMutableTreeNode(error);\n                        messageNode.add(errorNode);\n                    }\n                }\n            }\n        }\n\n        valTreeModel.setRoot(rootNode);\n        for (TreePath path : expandedPaths) {\n            this.expandPath(path);\n        }\n    }","commit_id":"a71ec5ac60a4b001ad27bcf5e9a3e25e43110b4e","url":"https://github.com/openstreetmap/josm"},{"original_method":"public Class<?> fastFindClass( final String name ) {\n            Class<?> cls = findLoadedClass( name );\n\n            if (cls == null) {\n                final byte[] clazzBytes = this.map.get( convertClassToResourcePath( name ) );\n                if (clazzBytes != null) {\n                    String pkgName = name.substring( 0,\n                                                     name.lastIndexOf( '.' ) );\n                    if (getPackage( pkgName ) == null) {\n                        definePackage( pkgName,\n                                       \"\",\n                                       \"\",\n                                       \"\",\n                                       \"\",\n                                       \"\",\n                                       \"\",\n                                       null );\n                    }\n\n                    cls = defineClass( name,\n                                       clazzBytes,\n                                       0,\n                                       clazzBytes.length,\n                                       PROTECTION_DOMAIN );\n                }\n\n                if (cls != null) {\n                    resolveClass( cls );\n                }\n            }\n\n            return cls;\n        }","id":6166,"modified_method":"public Class<?> fastFindClass( final String name ) {\n            Class<?> cls = findLoadedClass( name );\n\n            if (cls == null) {\n                final byte[] clazzBytes = this.map.get( convertClassToResourcePath( name ) );\n                if (clazzBytes != null) {\n                    int lastDotPos = name.lastIndexOf( '.' );\n                    String pkgName = lastDotPos > 0 ? name.substring( 0, lastDotPos ) : \"\";\n\n                    if (getPackage( pkgName ) == null) {\n                        definePackage( pkgName,\n                                       \"\",\n                                       \"\",\n                                       \"\",\n                                       \"\",\n                                       \"\",\n                                       \"\",\n                                       null );\n                    }\n\n                    cls = defineClass( name,\n                                       clazzBytes,\n                                       0,\n                                       clazzBytes.length,\n                                       PROTECTION_DOMAIN );\n                }\n\n                if (cls != null) {\n                    resolveClass( cls );\n                }\n            }\n\n            return cls;\n        }","commit_id":"a6953cc92897a3f46f679e2d9d7c1cb9aa26301c","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public Class<?> getClass(String pkgName, String className) {\n        try {\n            return Class.forName(pkgName + \".\" + className, false, getClassLoader());\n        } catch (ClassNotFoundException e) {\n            return null;\n        }\n    }","id":6167,"modified_method":"public Class<?> getClass(String pkgName, String className) {\n        try {\n            return Class.forName((pkgName == null || pkgName.trim().length() == 0) ? className : pkgName + \".\" + className, false, getClassLoader());\n        } catch (ClassNotFoundException e) {\n            return null;\n        }\n    }","commit_id":"a6953cc92897a3f46f679e2d9d7c1cb9aa26301c","url":"https://github.com/droolsjbpm/drools"},{"original_method":"static String getPackageName(String clazz) {\n        return clazz.substring(0, clazz.lastIndexOf('.'));\n    }","id":6168,"modified_method":"static String getPackageName(String clazz) {\n        final int lastDot = clazz.lastIndexOf('.');\n        return lastDot <= 0 ? \"\" : clazz.substring(0, lastDot);\n    }","commit_id":"c7ef436a64e20aee308c7ceb2ad19957b485af06","url":"https://github.com/apache/sling"},{"original_method":"@Parameters\n    public static Collection<Object[]> data() {\n        return Arrays.asList(new Object[][] {   \n                { \"java.lang.Foo\", \"java.lang\" },\n                //{ \"noPackageName\", \"\" },\n                //{ \"\", \"\" }\n        });\n    }","id":6169,"modified_method":"@Parameters\n    public static Collection<Object[]> data() {\n        return Arrays.asList(new Object[][] {   \n                { \"java.lang.Foo\", \"java.lang\" },\n                { \"noPackageName\", \"\" },\n                { \"\", \"\" }\n        });\n    }","commit_id":"c7ef436a64e20aee308c7ceb2ad19957b485af06","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Imports the resources and writes them to the cms.<p>\n     * \n     * @param excludeList filenames of files and folders which should not \n     *      be (over)written in the virtual file system (not used when null)\n     * @param writtenFilenames filenames of the files and folder which have actually been \n     *      successfully written (not used when null)\n     * @param fileCodes code of the written files (for the registry)\n     *      (not used when null)\n     * @param propertyName name of a property to be added to all resources\n     * @param propertyValue value of that property\n     * @throws CmsException if something goes wrong\n     */\n    private void importAllResources(Vector excludeList, Vector writtenFilenames, Vector fileCodes, String propertyName, String propertyValue) throws CmsException {\n        List fileNodes = null, acentryNodes = null;\n        Element currentElement = null, currentEntry = null;\n        String source = null, destination = null, resourceTypeName = null, timestamp = null, uuid = null, uuidresource = null;\n        long lastmodified = 0;\n        int resourceTypeId = I_CmsConstants.C_UNKNOWN_ID;\n        List properties = null;\n        boolean old_overwriteCollidingResources = false;\n\n        if (m_importingChannelData) {\n            m_cms.getRequestContext().saveSiteRoot();\n            m_cms.getRequestContext().setSiteRoot(I_CmsConstants.VFS_FOLDER_CHANNELS);\n        }\n\n        if (excludeList == null) {\n            excludeList = new Vector();\n        }\n\n        try {\n            m_webAppNames = getCompatibilityWebAppNames();\n        } catch (Exception e) {\n            if (OpenCms.getLog(this).isErrorEnabled()) {\n                OpenCms.getLog(this).error(\"Error getting compatibility web-app names\", e);\n            }\n            m_report.println(e);\n        }\n        if (m_webAppNames == null) {\n            m_webAppNames = Collections.EMPTY_LIST;\n        }\n\n        // get the old webapp url from the OpenCms properties\n        m_webappUrl = OpenCms.getImportExportManager().getOldWebAppUrl();\n        if (m_webappUrl == null) {\n            // use a default value\n            m_webappUrl = \"http://localhost:8080/opencms/opencms\";\n        }\n        // cut last \"/\" from webappUrl if present\n        if (m_webappUrl.endsWith(\"/\")) {\n            m_webappUrl = m_webappUrl.substring(0, m_webappUrl.lastIndexOf(\"/\"));\n        }\n\n        // get list of unwanted properties\n        List deleteProperties = OpenCms.getImportExportManager().getIgnoredProperties();\n\n        // get list of immutable resources\n        List immutableResources = OpenCms.getImportExportManager().getImmutableResources();\n        if (DEBUG > 0) {\n            System.err.println(\"Import: Immutable resources size is \" + immutableResources.size());\n        }\n        \n        // save the value of the boolean flag whether colliding resources should be overwritten\n        old_overwriteCollidingResources = OpenCms.getImportExportManager().overwriteCollidingResources();\n        \n        // force v1 and v2 imports to overwrite colliding resources, because they dont have resource \n        // UUIDs in their manifest anyway\n        OpenCms.getImportExportManager().setOverwriteCollidingResources(true);\n        \n        try {\n            // get all file-nodes\n            fileNodes = m_docXml.selectNodes(\"//\" + I_CmsConstants.C_EXPORT_TAG_FILE);\n            int importSize = fileNodes.size();\n\n            // walk through all files in manifest\n            for (int i = 0; i < importSize; i++) {\n\n                m_report.print(\" ( \" + (i + 1) + \" / \" + importSize + \" ) \", I_CmsReport.C_FORMAT_NOTE);\n                currentElement = (Element) fileNodes.get(i);\n\n                // get all information for a file-import\n                source = CmsImport.getChildElementTextValue(currentElement, I_CmsConstants.C_EXPORT_TAG_SOURCE);\n                destination = CmsImport.getChildElementTextValue(currentElement, I_CmsConstants.C_EXPORT_TAG_DESTINATION);\n                \n                resourceTypeName = CmsImport.getChildElementTextValue(currentElement, I_CmsConstants.C_EXPORT_TAG_TYPE);\n                if (C_RESOURCE_TYPE_NEWPAGE_NAME.equals(resourceTypeName)) {\n                    resourceTypeId = C_RESOURCE_TYPE_NEWPAGE_ID;\n                } else if (C_RESOURCE_TYPE_PAGE_NAME.equals(resourceTypeName)) {\n                    // resource with a \"legacy\" resource type are imported using the \"plain\" resource\n                    // type because you cannot import a resource without having the resource type object\n                    resourceTypeId = CmsResourceTypePlain.C_RESOURCE_TYPE_ID;\n                } else if (C_RESOURCE_TYPE_LINK_NAME.equals(resourceTypeName)) {\n                    // set resource type of legacy \"link\" which is converted later\n                    resourceTypeId = C_RESOURCE_TYPE_LINK_ID;\n                } else {\n                    I_CmsResourceType type = OpenCms.getResourceManager().getResourceType(resourceTypeName);\n                    resourceTypeId = type.getTypeId();\n                }\n                \n                uuid = CmsImport.getChildElementTextValue(currentElement, I_CmsConstants.C_EXPORT_TAG_UUIDSTRUCTURE);\n                uuidresource = CmsImport.getChildElementTextValue(currentElement, I_CmsConstants.C_EXPORT_TAG_UUIDRESOURCE);\n\n                if ((timestamp = CmsImport.getChildElementTextValue(currentElement, I_CmsConstants.C_EXPORT_TAG_LASTMODIFIED)) != null) {\n                    lastmodified = Long.parseLong(timestamp);\n                } else {\n                    lastmodified = System.currentTimeMillis();\n                }\n\n                // if the type is \"script\" set it to plain\n                if (\"script\".equals(resourceTypeName)) {\n                    resourceTypeName = CmsResourceTypePlain.C_RESOURCE_TYPE_NAME;\n                }\n\n                if (OpenCms.getLog(this).isDebugEnabled()) {\n                    OpenCms.getLog(this).debug(\"Import: Original resource name is \" + destination);\n                }                \n                String translatedName = m_cms.getRequestContext().addSiteRoot(m_importPath + destination);                \n                if (CmsResourceTypeFolder.C_RESOURCE_TYPE_NAME.equals(resourceTypeName)) {\n                    translatedName += I_CmsConstants.C_FOLDER_SEPARATOR;\n                }\n                if (OpenCms.getLog(this).isDebugEnabled()) {\n                    OpenCms.getLog(this).debug(\"Import: Translated resource name is \" + translatedName);\n                }\n\n                boolean resourceNotImmutable = checkImmutable(translatedName, immutableResources);\n\n                translatedName = m_cms.getRequestContext().removeSiteRoot(translatedName);\n                                \n                if (resourceNotImmutable && (!excludeList.contains(translatedName))) {\n\n                    // print out the information to the report\n                    m_report.print(m_report.key(\"report.importing\"), I_CmsReport.C_FORMAT_NOTE);\n                    m_report.print(translatedName);\n                    m_report.print(m_report.key(\"report.dots\"));\n\n                    // get all properties\n                    properties = readPropertiesFromManifest(currentElement, propertyName, propertyValue, deleteProperties);\n\n                    // import the specified file \n                    CmsResource res = importResource(source, destination, uuid, uuidresource, resourceTypeId, resourceTypeName, lastmodified, properties, writtenFilenames, fileCodes);\n                    \n                    List aceList = new ArrayList();\n                    if (res != null) {\n\n                        // write all imported access control entries for this file\n                        acentryNodes = currentElement.selectNodes(\"*/\" + I_CmsConstants.C_EXPORT_TAG_ACCESSCONTROL_ENTRY);\n                        // collect all access control entries\n                        for (int j = 0; j < acentryNodes.size(); j++) {\n                            currentEntry = (Element)acentryNodes.get(j);\n                            // get the data of the access control entry\n                            String id = CmsImport.getChildElementTextValue(currentEntry, I_CmsConstants.C_EXPORT_TAG_ID);\n                            String acflags = CmsImport.getChildElementTextValue(currentEntry, I_CmsConstants.C_EXPORT_TAG_FLAGS);\n                            String allowed = CmsImport.getChildElementTextValue(currentEntry, I_CmsConstants.C_EXPORT_TAG_ACCESSCONTROL_ALLOWEDPERMISSIONS);\n                            String denied = CmsImport.getChildElementTextValue(currentEntry, I_CmsConstants.C_EXPORT_TAG_ACCESSCONTROL_DENIEDPERMISSIONS);\n\n                            // add the entry to the list\n                            aceList.add(getImportAccessControlEntry(res, id, allowed, denied, acflags));\n                        }\n                        importAccessControlEntries(res, aceList);\n\n                    } else {\n                        // resource import failed, since no CmsResource was created\n                        m_report.print(m_report.key(\"report.skipping\"), I_CmsReport.C_FORMAT_OK);\n                        m_report.println(translatedName);\n                    }\n                } else {\n                    // skip the file import, just print out the information to the report\n                    m_report.print(m_report.key(\"report.skipping\"), I_CmsReport.C_FORMAT_NOTE);\n                    m_report.println(translatedName);\n                }\n            }\n\n            // now merge the body and page control files. this only has to be done if the import\n            // version is below version 3\n            if (getVersion() < 3 && m_convertToXmlPage) {\n                mergePageFiles();\n                removeFolders();\n            }\n        } catch (Exception exc) {\n            if (OpenCms.getLog(this).isErrorEnabled()) {\n                OpenCms.getLog(this).error(exc);\n            }            \n            m_report.println(exc);\n            \n            throw new CmsException(CmsException.C_UNKNOWN_EXCEPTION, exc);\n        } finally {\n            if (m_importingChannelData) {\n                m_cms.getRequestContext().restoreSiteRoot();\n            }\n            \n            // set the flag to overwrite colliding resources back to its original value\n            OpenCms.getImportExportManager().setOverwriteCollidingResources(old_overwriteCollidingResources);\n        }\n    }","id":6170,"modified_method":"/**\n     * Imports the resources and writes them to the cms.<p>\n     * \n     * @param excludeList filenames of files and folders which should not \n     *      be (over)written in the virtual file system (not used when null)\n     * @param writtenFilenames filenames of the files and folder which have actually been \n     *      successfully written (not used when null)\n     * @param fileCodes code of the written files (for the registry)\n     *      (not used when null)\n     * @param propertyName name of a property to be added to all resources\n     * @param propertyValue value of that property\n     * @throws CmsException if something goes wrong\n     */\n    private void importAllResources(Vector excludeList, Vector writtenFilenames, Vector fileCodes, String propertyName, String propertyValue) throws CmsException {\n        List fileNodes = null, acentryNodes = null;\n        Element currentElement = null, currentEntry = null;\n        String source = null, destination = null, resourceTypeName = null, timestamp = null, uuid = null, uuidresource = null;\n        long lastmodified = 0;\n        int resourceTypeId = I_CmsConstants.C_UNKNOWN_ID;\n        List properties = null;\n        boolean old_overwriteCollidingResources = false;\n\n        if (m_importingChannelData) {\n            m_cms.getRequestContext().saveSiteRoot();\n            m_cms.getRequestContext().setSiteRoot(I_CmsConstants.VFS_FOLDER_CHANNELS);\n        }\n\n        if (excludeList == null) {\n            excludeList = new Vector();\n        }\n\n        try {\n            m_webAppNames = getCompatibilityWebAppNames();\n        } catch (Exception e) {\n            if (OpenCms.getLog(this).isErrorEnabled()) {\n                OpenCms.getLog(this).error(\"Error getting compatibility web-app names\", e);\n            }\n            m_report.println(e);\n        }\n        if (m_webAppNames == null) {\n            m_webAppNames = Collections.EMPTY_LIST;\n        }\n\n        // get the old webapp url from the OpenCms properties\n        m_webappUrl = OpenCms.getImportExportManager().getOldWebAppUrl();\n        if (m_webappUrl == null) {\n            // use a default value\n            m_webappUrl = \"http://localhost:8080/opencms/opencms\";\n        }\n        // cut last \"/\" from webappUrl if present\n        if (m_webappUrl.endsWith(\"/\")) {\n            m_webappUrl = m_webappUrl.substring(0, m_webappUrl.lastIndexOf(\"/\"));\n        }\n\n        // get list of unwanted properties\n        List deleteProperties = OpenCms.getImportExportManager().getIgnoredProperties();\n\n        // get list of immutable resources\n        List immutableResources = OpenCms.getImportExportManager().getImmutableResources();\n        if (DEBUG > 0) {\n            System.err.println(\"Import: Immutable resources size is \" + immutableResources.size());\n        }\n        \n        // save the value of the boolean flag whether colliding resources should be overwritten\n        old_overwriteCollidingResources = OpenCms.getImportExportManager().overwriteCollidingResources();\n        \n        // force v1 and v2 imports to overwrite colliding resources, because they dont have resource \n        // UUIDs in their manifest anyway\n        OpenCms.getImportExportManager().setOverwriteCollidingResources(true);\n        \n        try {\n            // get all file-nodes\n            fileNodes = m_docXml.selectNodes(\"//\" + I_CmsConstants.C_EXPORT_TAG_FILE);\n            int importSize = fileNodes.size();\n\n            // walk through all files in manifest\n            for (int i = 0; i < importSize; i++) {\n\n                m_report.print(\" ( \" + (i + 1) + \" / \" + importSize + \" ) \", I_CmsReport.C_FORMAT_NOTE);\n                currentElement = (Element) fileNodes.get(i);\n\n                // get all information for a file-import\n                source = CmsImport.getChildElementTextValue(currentElement, I_CmsConstants.C_EXPORT_TAG_SOURCE);\n                destination = CmsImport.getChildElementTextValue(currentElement, I_CmsConstants.C_EXPORT_TAG_DESTINATION);\n                \n                resourceTypeName = CmsImport.getChildElementTextValue(currentElement, I_CmsConstants.C_EXPORT_TAG_TYPE);\n                if (C_RESOURCE_TYPE_NEWPAGE_NAME.equals(resourceTypeName)) {\n                    resourceTypeId = C_RESOURCE_TYPE_NEWPAGE_ID;\n                } else if (C_RESOURCE_TYPE_PAGE_NAME.equals(resourceTypeName)) {\n                    // resource with a \"legacy\" resource type are imported using the \"plain\" resource\n                    // type because you cannot import a resource without having the resource type object\n                    resourceTypeId = CmsResourceTypePlain.C_RESOURCE_TYPE_ID;\n                } else if (C_RESOURCE_TYPE_LINK_NAME.equals(resourceTypeName)) {\n                    // set resource type of legacy \"link\" which is converted later\n                    resourceTypeId = C_RESOURCE_TYPE_LINK_ID;\n                } else {\n                    I_CmsResourceType type = OpenCms.getResourceManager().getResourceType(resourceTypeName);\n                    resourceTypeId = type.getTypeId();\n                }\n                \n                uuid = CmsImport.getChildElementTextValue(currentElement, I_CmsConstants.C_EXPORT_TAG_UUIDSTRUCTURE);\n                uuidresource = CmsImport.getChildElementTextValue(currentElement, I_CmsConstants.C_EXPORT_TAG_UUIDRESOURCE);\n\n                if ((timestamp = CmsImport.getChildElementTextValue(currentElement, I_CmsConstants.C_EXPORT_TAG_LASTMODIFIED)) != null) {\n                    lastmodified = Long.parseLong(timestamp);\n                } else {\n                    lastmodified = System.currentTimeMillis();\n                }\n\n                // if the type is \"script\" set it to plain\n                if (\"script\".equals(resourceTypeName)) {\n                    resourceTypeName = CmsResourceTypePlain.C_RESOURCE_TYPE_NAME;\n                }\n\n                if (OpenCms.getLog(this).isDebugEnabled()) {\n                    OpenCms.getLog(this).debug(\"Original import resource name is: \" + destination);\n                }                \n                String translatedName = m_cms.getRequestContext().addSiteRoot(m_importPath + destination);                \n                if (CmsResourceTypeFolder.C_RESOURCE_TYPE_NAME.equals(resourceTypeName)) {\n                    // ensure folders end with a \"/\"\n                    if (! CmsResource.isFolder(translatedName)) {\n                        translatedName += I_CmsConstants.C_FOLDER_SEPARATOR;\n                    }\n                }\n                if (OpenCms.getLog(this).isDebugEnabled()) {\n                    OpenCms.getLog(this).debug(\"Translated import resource name is: \" + translatedName);\n                }\n\n                boolean resourceNotImmutable = checkImmutable(translatedName, immutableResources);\n\n                translatedName = m_cms.getRequestContext().removeSiteRoot(translatedName);\n                                \n                if (resourceNotImmutable && (!excludeList.contains(translatedName))) {\n\n                    // print out the information to the report\n                    m_report.print(m_report.key(\"report.importing\"), I_CmsReport.C_FORMAT_NOTE);\n                    m_report.print(translatedName);\n                    m_report.print(m_report.key(\"report.dots\"));\n\n                    // get all properties\n                    properties = readPropertiesFromManifest(currentElement, propertyName, propertyValue, deleteProperties);\n\n                    // import the specified file \n                    CmsResource res = importResource(source, destination, uuid, uuidresource, resourceTypeId, resourceTypeName, lastmodified, properties, writtenFilenames, fileCodes);\n                    \n                    if (res != null) {                                         \n\n                        List aceList = new ArrayList();\n                        // write all imported access control entries for this file\n                        acentryNodes = currentElement.selectNodes(\"*/\" + I_CmsConstants.C_EXPORT_TAG_ACCESSCONTROL_ENTRY);\n                        // collect all access control entries\n                        for (int j = 0; j < acentryNodes.size(); j++) {\n                            currentEntry = (Element)acentryNodes.get(j);\n                            // get the data of the access control entry\n                            String id = CmsImport.getChildElementTextValue(currentEntry, I_CmsConstants.C_EXPORT_TAG_ID);\n                            String acflags = CmsImport.getChildElementTextValue(currentEntry, I_CmsConstants.C_EXPORT_TAG_FLAGS);\n                            String allowed = CmsImport.getChildElementTextValue(currentEntry, I_CmsConstants.C_EXPORT_TAG_ACCESSCONTROL_ALLOWEDPERMISSIONS);\n                            String denied = CmsImport.getChildElementTextValue(currentEntry, I_CmsConstants.C_EXPORT_TAG_ACCESSCONTROL_DENIEDPERMISSIONS);\n\n                            // add the entry to the list\n                            aceList.add(getImportAccessControlEntry(res, id, allowed, denied, acflags));\n                        }\n                        importAccessControlEntries(res, aceList);\n\n                        if (OpenCms.getLog(this).isInfoEnabled()) {\n                            OpenCms.getLog(this).info(\n                                \"( \" + (i + 1) + \" / \" + importSize + \" ) \"\n                                + m_report.key(\"report.importing\")\n                                + translatedName\n                                + \" (\"\n                                + destination\n                                + \")\"\n                                + m_report.key(\"report.dots\")\n                                + m_report.key(\"report.ok\"));\n                        }      \n                        \n                    } else {\n                        // resource import failed, since no CmsResource was created\n                        m_report.print(m_report.key(\"report.skipping\"), I_CmsReport.C_FORMAT_OK);\n                        m_report.println(translatedName);\n                        \n                        if (OpenCms.getLog(this).isInfoEnabled()) {\n                            OpenCms.getLog(this).info(\n                                \" ( \" + (i + 1) + \" / \" + importSize + \" ) \"\n                                + m_report.key(\"report.skipping\")\n                                + translatedName);\n                        }\n                    }\n                } else {\n                    // skip the file import, just print out the information to the report\n                    m_report.print(m_report.key(\"report.skipping\"), I_CmsReport.C_FORMAT_NOTE);\n                    m_report.println(translatedName);\n                    \n                    if (OpenCms.getLog(this).isInfoEnabled()) {\n                        OpenCms.getLog(this).info(\n                            \" ( \" + (i + 1) + \" / \" + importSize + \" ) \"\n                            + m_report.key(\"report.skipping\")\n                            + translatedName);\n                    }                    \n                }\n            }\n\n            // now merge the body and page control files. this only has to be done if the import\n            // version is below version 3\n            if (getVersion() < 3 && m_convertToXmlPage) {\n                mergePageFiles();\n                removeFolders();\n            }\n        } catch (Exception exc) {\n            if (OpenCms.getLog(this).isErrorEnabled()) {\n                OpenCms.getLog(this).error(exc);\n            }            \n            m_report.println(exc);\n            \n            throw new CmsException(CmsException.C_UNKNOWN_EXCEPTION, exc);\n        } finally {\n            if (m_importingChannelData) {\n                m_cms.getRequestContext().restoreSiteRoot();\n            }\n            \n            // set the flag to overwrite colliding resources back to its original value\n            OpenCms.getImportExportManager().setOverwriteCollidingResources(old_overwriteCollidingResources);\n        }\n    }","commit_id":"fbed819c1bd409a410713ebe6c5863f2e740f6ee","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Merges the page control files and their corresponding bodies into a single files.<p>\n     * \n     * \n     * @throws CmsException if something goes wrong\n     */\n    private void mergePageFiles() throws CmsException {\n\n        // check if the template property exists. If not, create it.\n        try {\n            m_cms.readPropertydefinition(I_CmsConstants.C_PROPERTY_TEMPLATE);\n        } catch (CmsException e) {\n            // the template propertydefintion does not exist. So create it.\n            m_cms.createPropertydefinition(I_CmsConstants.C_PROPERTY_TEMPLATE);\n        }\n        // copy all propertydefinitions of the old page to the new page\n        List definitions = m_cms.readAllPropertydefinitions();\n\n        Iterator j = definitions.iterator();\n        while (j.hasNext()) {\n            CmsPropertydefinition definition = (CmsPropertydefinition)j.next();\n            // check if this propertydef already exits\n            try {\n                m_cms.readPropertydefinition(definition.getName());\n            } catch (Exception e) {\n                m_cms.createPropertydefinition(definition.getName());\n            }\n        }\n\n        // iterate through the list of all page controlfiles found during the import process\n        int size = m_pageStorage.size();\n\n        m_report.println(m_report.key(\"report.merge_start\"), I_CmsReport.C_FORMAT_HEADLINE);\n\n        Iterator i = m_pageStorage.iterator();\n        int counter = 1;\n        while (i.hasNext()) {\n            String resname = (String)i.next();\n            // adjust the resourcename if nescessary\n            if (!resname.startsWith(\"/\")) {\n                resname = \"/\" + resname;\n            }\n\n            m_report.print(\"( \" + counter + \" / \" + size + \" ) \", I_CmsReport.C_FORMAT_NOTE);\n            m_report.print(m_report.key(\"report.merge\") + \" \" , I_CmsReport.C_FORMAT_NOTE);\n            m_report.print(resname, I_CmsReport.C_FORMAT_DEFAULT);\n\n            try {\n                \n                mergePageFile(resname);\n                \n            } catch (Exception e) {\n                if (OpenCms.getLog(this).isErrorEnabled()) {\n                    OpenCms.getLog(this).error(\"Error merging page file \" + resname, e);\n                }\n                \n                m_report.println(e);\n            }\n\n            counter++;\n\n        }\n        // free mem\n        m_pageStorage.clear();\n\n    }","id":6171,"modified_method":"/**\n     * Merges the page control files and their corresponding bodies into a single files.<p>\n     * \n     * \n     * @throws CmsException if something goes wrong\n     */\n    private void mergePageFiles() throws CmsException {\n\n        // check if the template property exists. If not, create it.\n        try {\n            m_cms.readPropertydefinition(I_CmsConstants.C_PROPERTY_TEMPLATE);\n        } catch (CmsException e) {\n            // the template propertydefintion does not exist. So create it.\n            m_cms.createPropertydefinition(I_CmsConstants.C_PROPERTY_TEMPLATE);\n        }\n        // copy all propertydefinitions of the old page to the new page\n        List definitions = m_cms.readAllPropertydefinitions();\n\n        Iterator j = definitions.iterator();\n        while (j.hasNext()) {\n            CmsPropertydefinition definition = (CmsPropertydefinition)j.next();\n            // check if this propertydef already exits\n            try {\n                m_cms.readPropertydefinition(definition.getName());\n            } catch (Exception e) {\n                m_cms.createPropertydefinition(definition.getName());\n            }\n        }\n\n        // iterate through the list of all page controlfiles found during the import process\n        int size = m_pageStorage.size();\n\n        m_report.println(m_report.key(\"report.merge_start\"), I_CmsReport.C_FORMAT_HEADLINE);\n\n        Iterator i = m_pageStorage.iterator();\n        int counter = 1;\n        while (i.hasNext()) {\n            String resname = (String)i.next();\n            // adjust the resourcename if nescessary\n            if (!resname.startsWith(\"/\")) {\n                resname = \"/\" + resname;\n            }\n\n            m_report.print(\"( \" + counter + \" / \" + size + \" ) \", I_CmsReport.C_FORMAT_NOTE);\n            m_report.print(m_report.key(\"report.merge\") + \" \" , I_CmsReport.C_FORMAT_NOTE);\n            m_report.print(resname, I_CmsReport.C_FORMAT_DEFAULT);\n\n            try {\n                \n                mergePageFile(resname);\n                \n                if (OpenCms.getLog(this).isInfoEnabled()) {\n                    OpenCms.getLog(this).info(\n                        \n                        \"( \" + counter + \" / \" + size + \" ) \"\n                        + m_report.key(\"report.merge\")\n                        + \" \"\n                        + resname\n                        + \" \"\n                        + m_report.key(\"report.ok\"));\n                }  \n                \n            } catch (Exception e) {\n                if (OpenCms.getLog(this).isErrorEnabled()) {\n                    OpenCms.getLog(this).error(\"Error merging page file \" + resname, e);\n                }\n                \n                m_report.println(e);\n            }\n\n            counter++;\n\n        }\n        // free mem\n        m_pageStorage.clear();\n\n    }","commit_id":"fbed819c1bd409a410713ebe6c5863f2e740f6ee","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/** \n     * Translates directory Strings from OpenCms 4.x structure to new 5.0 structure.<p>\n     * \n     * @param content the filecontent\n     * @param rules the translation rules\n     * @return String the manipulated file content\n     */\n    public static String setDirectories(String content, String[] rules) {\n        // get translation rules\n        for (int i = 0; i < rules.length; i++) {\n            String actRule = rules[i];\n            // cut String \"/default/vfs/\" from rule\n            actRule = CmsStringUtil.substitute(actRule, \"/default/vfs\", \"\");\n            // divide rule into search and replace parts and delete regular expressions\n            StringTokenizer ruleT = new StringTokenizer(actRule, \"#\");\n            ruleT.nextToken();\n            String search = ruleT.nextToken();\n            search = search.substring(0, search.lastIndexOf(\"(.*)\"));\n            String replace = ruleT.nextToken();\n            replace = replace.substring(0, replace.lastIndexOf(\"$1\"));\n            // scan content for paths if the replace String is not present\n            if (content.indexOf(replace) == -1 && content.indexOf(search) != -1) {\n                // ensure subdirectories of the same name are not replaced\n                search = \"([}>\\\"'\\\\[]\\\\s*)\" + search;\n                replace = \"$1\" + replace;\n                content = CmsStringUtil.substitutePerl(content, search, replace, \"g\");\n            }\n        }\n        return content;\n    }","id":6172,"modified_method":"/** \n     * Translates directory Strings from OpenCms 4.x structure to new 5.0 structure.<p>\n     * \n     * @param content the filecontent\n     * @param rules the translation rules\n     * @return String the manipulated file content\n     */\n    public static String setDirectories(String content, String[] rules) {\n        // get translation rules\n        for (int i = 0; i < rules.length; i++) {\n            String actRule = rules[i];\n            // cut String \"/default/vfs/\" from rule\n            actRule = CmsStringUtil.substitute(actRule, \"/default/vfs\", \"\");\n            // divide rule into search and replace parts and delete regular expressions\n            StringTokenizer ruleT = new StringTokenizer(actRule, \"#\");\n            ruleT.nextToken();\n            String search = ruleT.nextToken();\n            int pos = search.lastIndexOf(\"(.*)\");\n            if (pos >= 0) {\n                search = search.substring(0, pos);\n            }\n            String replace = ruleT.nextToken();\n            if (pos >= 0) {\n                replace = replace.substring(0, replace.lastIndexOf(\"$1\"));\n            }\n            // scan content for paths if the replace String is not present\n            if (content.indexOf(replace) == -1 && content.indexOf(search) != -1) {\n                // ensure subdirectories of the same name are not replaced\n                search = \"([}>\\\"'\\\\[]\\\\s*)\" + search;\n                replace = \"$1\" + replace;\n                content = CmsStringUtil.substitutePerl(content, search, replace, \"g\");\n            }\n        }\n        return content;\n    }","commit_id":"fbed819c1bd409a410713ebe6c5863f2e740f6ee","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n         * @return\n         * @throws IOException\n         * @see javax.management.MBeanServerConnection#getDefaultDomain()\n         */\n        public String getDefaultDomain() throws IOException {\n            checkConnection();\n            return connection.getDefaultDomain();\n        }","id":6173,"modified_method":"@Override\n        public String getDefaultDomain() throws IOException {\n            try {\n                return connection.getDefaultDomain();\n            } catch (IOException e) {\n                checkConnection();\n                return connection.getDefaultDomain();\n            }\n        }","commit_id":"5e8c89f41c1a0afed822e5abf6e406f6149050ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * @param name\n         * @return\n         * @throws InstanceNotFoundException\n         * @throws IntrospectionException\n         * @throws ReflectionException\n         * @throws IOException\n         * @see javax.management.MBeanServerConnection#getMBeanInfo(javax.management.ObjectName)\n         */\n        public MBeanInfo getMBeanInfo(ObjectName name) throws InstanceNotFoundException, IntrospectionException,\n                ReflectionException, IOException {\n            checkConnection();\n            return connection.getMBeanInfo(name);\n        }","id":6174,"modified_method":"@Override\n        public MBeanInfo getMBeanInfo(ObjectName name) throws InstanceNotFoundException, IntrospectionException,\n                ReflectionException, IOException {\n            try {\n                return connection.getMBeanInfo(name);\n            } catch (IOException e) {\n                checkConnection();\n                return connection.getMBeanInfo(name);\n            }\n        }","commit_id":"5e8c89f41c1a0afed822e5abf6e406f6149050ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * @param name\n         * @throws InstanceNotFoundException\n         * @throws MBeanRegistrationException\n         * @throws IOException\n         * @see javax.management.MBeanServerConnection#unregisterMBean(javax.management.ObjectName)\n         */\n        public void unregisterMBean(ObjectName name) throws InstanceNotFoundException, MBeanRegistrationException, IOException {\n            checkConnection();\n            connection.unregisterMBean(name);\n        }","id":6175,"modified_method":"@Override\n        public void unregisterMBean(ObjectName name) throws InstanceNotFoundException, MBeanRegistrationException, IOException {\n            checkConnection();\n            connection.unregisterMBean(name);\n        }","commit_id":"5e8c89f41c1a0afed822e5abf6e406f6149050ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * @param className\n         * @param name\n         * @param loaderName\n         * @param params\n         * @param signature\n         * @return\n         * @throws ReflectionException\n         * @throws InstanceAlreadyExistsException\n         * @throws MBeanRegistrationException\n         * @throws MBeanException\n         * @throws NotCompliantMBeanException\n         * @throws InstanceNotFoundException\n         * @throws IOException\n         * @see javax.management.MBeanServerConnection#createMBean(java.lang.String, javax.management.ObjectName, javax.management.ObjectName, java.lang.Object[], java.lang.String[])\n         */\n        public ObjectInstance createMBean(String className, ObjectName name, ObjectName loaderName, Object[] params,\n                String[] signature) throws ReflectionException, InstanceAlreadyExistsException,\n                MBeanException, NotCompliantMBeanException, InstanceNotFoundException, IOException {\n            checkConnection();\n            return connection.createMBean(className, name, loaderName, params, signature);\n        }","id":6176,"modified_method":"@Override\n        public ObjectInstance createMBean(String className, ObjectName name, ObjectName loaderName, Object[] params,\n                String[] signature) throws ReflectionException, InstanceAlreadyExistsException,\n                MBeanException, NotCompliantMBeanException, InstanceNotFoundException, IOException {\n            checkConnection();\n            return connection.createMBean(className, name, loaderName, params, signature);\n        }","commit_id":"5e8c89f41c1a0afed822e5abf6e406f6149050ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * @param name\n         * @param listener\n         * @param filter\n         * @param handback\n         * @throws InstanceNotFoundException\n         * @throws ListenerNotFoundException\n         * @throws IOException\n         * @see javax.management.MBeanServerConnection#removeNotificationListener(javax.management.ObjectName, javax.management.ObjectName, javax.management.NotificationFilter, java.lang.Object)\n         */\n        public void removeNotificationListener(ObjectName name, ObjectName listener, NotificationFilter filter, Object handback)\n                throws InstanceNotFoundException, ListenerNotFoundException, IOException {\n            checkConnection();\n            connection.removeNotificationListener(name, listener, filter, handback);\n        }","id":6177,"modified_method":"@Override\n        public void removeNotificationListener(ObjectName name, ObjectName listener, NotificationFilter filter, Object handback)\n                throws InstanceNotFoundException, ListenerNotFoundException, IOException {\n            try {\n                connection.removeNotificationListener(name, listener, filter, handback);\n            } catch (IOException e) {\n                if (!checkConnection()) {\n                    connection.removeNotificationListener(name, listener, filter, handback);\n                } else {\n                    throw e;\n                }\n            }\n        }","commit_id":"5e8c89f41c1a0afed822e5abf6e406f6149050ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * @param name\n         * @return\n         * @throws InstanceNotFoundException\n         * @throws IOException\n         * @see javax.management.MBeanServerConnection#getObjectInstance(javax.management.ObjectName)\n         */\n        public ObjectInstance getObjectInstance(ObjectName name) throws InstanceNotFoundException, IOException {\n            checkConnection();\n            return connection.getObjectInstance(name);\n        }","id":6178,"modified_method":"@Override\n        public ObjectInstance getObjectInstance(ObjectName name) throws InstanceNotFoundException, IOException {\n            try {\n                return connection.getObjectInstance(name);\n            } catch (IOException e) {\n                checkConnection();\n                return connection.getObjectInstance(name);\n            }\n        }","commit_id":"5e8c89f41c1a0afed822e5abf6e406f6149050ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * @param className\n         * @param name\n         * @return\n         * @throws ReflectionException\n         * @throws InstanceAlreadyExistsException\n         * @throws MBeanRegistrationException\n         * @throws MBeanException\n         * @throws NotCompliantMBeanException\n         * @throws IOException\n         * @see javax.management.MBeanServerConnection#createMBean(java.lang.String, javax.management.ObjectName)\n         */\n        public ObjectInstance createMBean(String className, ObjectName name) throws ReflectionException,\n                InstanceAlreadyExistsException, MBeanException, NotCompliantMBeanException,\n                IOException {\n            checkConnection();\n            return connection.createMBean(className, name);\n        }","id":6179,"modified_method":"@Override\n        public ObjectInstance createMBean(String className, ObjectName name) throws ReflectionException,\n                InstanceAlreadyExistsException, MBeanException, NotCompliantMBeanException,\n                IOException {\n            checkConnection();\n            return connection.createMBean(className, name);\n        }","commit_id":"5e8c89f41c1a0afed822e5abf6e406f6149050ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * @param name\n         * @param operationName\n         * @param params\n         * @param signature\n         * @return\n         * @throws InstanceNotFoundException\n         * @throws MBeanException\n         * @throws ReflectionException\n         * @throws IOException\n         * @see javax.management.MBeanServerConnection#invoke(javax.management.ObjectName, java.lang.String, java.lang.Object[], java.lang.String[])\n         */\n        public Object invoke(ObjectName name, String operationName, Object[] params, String[] signature)\n                throws InstanceNotFoundException, MBeanException, ReflectionException, IOException {\n            checkConnection();\n            return connection.invoke(name, operationName, params, signature);\n        }","id":6180,"modified_method":"@Override\n        public Object invoke(ObjectName name, String operationName, Object[] params, String[] signature)\n                throws InstanceNotFoundException, MBeanException, ReflectionException, IOException {\n            checkConnection();\n            return connection.invoke(name, operationName, params, signature);\n        }","commit_id":"5e8c89f41c1a0afed822e5abf6e406f6149050ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * @param name\n         * @param listener\n         * @param filter\n         * @param handback\n         * @throws InstanceNotFoundException\n         * @throws IOException\n         * @see javax.management.MBeanServerConnection#addNotificationListener(javax.management.ObjectName, javax.management.NotificationListener, javax.management.NotificationFilter, java.lang.Object)\n         */\n        public void addNotificationListener(ObjectName name, NotificationListener listener, NotificationFilter filter,\n                Object handback) throws InstanceNotFoundException, IOException {\n            checkConnection();\n            connection.addNotificationListener(name, listener, filter, handback);\n        }","id":6181,"modified_method":"@Override\n        public void addNotificationListener(ObjectName name, NotificationListener listener, NotificationFilter filter,\n                Object handback) throws InstanceNotFoundException, IOException {\n            try {\n                connection.addNotificationListener(name, listener, filter, handback);\n            } catch (IOException e) {\n                if (!checkConnection()) {\n                    connection.addNotificationListener(name, listener, filter, handback);\n                } else {\n                    throw e;\n                }\n            }\n        }","commit_id":"5e8c89f41c1a0afed822e5abf6e406f6149050ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * @param name\n         * @return\n         * @throws IOException\n         * @see javax.management.MBeanServerConnection#isRegistered(javax.management.ObjectName)\n         */\n        public boolean isRegistered(ObjectName name) throws IOException {\n            checkConnection();\n            return connection.isRegistered(name);\n        }","id":6182,"modified_method":"@Override\n        public boolean isRegistered(ObjectName name) throws IOException {\n            try {\n                return connection.isRegistered(name);\n            } catch (IOException e) {\n                checkConnection();\n                return connection.isRegistered(name);\n            }\n        }","commit_id":"5e8c89f41c1a0afed822e5abf6e406f6149050ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * @param name\n         * @param attribute\n         * @throws InstanceNotFoundException\n         * @throws AttributeNotFoundException\n         * @throws InvalidAttributeValueException\n         * @throws MBeanException\n         * @throws ReflectionException\n         * @throws IOException\n         * @see javax.management.MBeanServerConnection#setAttribute(javax.management.ObjectName, javax.management.Attribute)\n         */\n        public void setAttribute(ObjectName name, Attribute attribute) throws InstanceNotFoundException,\n                AttributeNotFoundException, InvalidAttributeValueException, MBeanException, ReflectionException, IOException {\n            checkConnection();\n            connection.setAttribute(name, attribute);\n        }","id":6183,"modified_method":"@Override\n        public void setAttribute(ObjectName name, Attribute attribute) throws InstanceNotFoundException,\n                AttributeNotFoundException, InvalidAttributeValueException, MBeanException, ReflectionException, IOException {\n            checkConnection();\n            connection.setAttribute(name, attribute);\n        }","commit_id":"5e8c89f41c1a0afed822e5abf6e406f6149050ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * @param name\n         * @param query\n         * @return\n         * @throws IOException\n         * @see javax.management.MBeanServerConnection#queryMBeans(javax.management.ObjectName, javax.management.QueryExp)\n         */\n        public Set<ObjectInstance> queryMBeans(ObjectName name, QueryExp query) throws IOException {\n            checkConnection();\n            return connection.queryMBeans(name, query);\n        }","id":6184,"modified_method":"@Override\n        public Set<ObjectInstance> queryMBeans(ObjectName name, QueryExp query) throws IOException {\n            try {\n                return connection.queryMBeans(name, query);\n            } catch (IOException e) {\n                checkConnection();\n                return connection.queryMBeans(name, query);\n            }\n        }","commit_id":"5e8c89f41c1a0afed822e5abf6e406f6149050ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * @return\n         * @throws IOException\n         * @see javax.management.MBeanServerConnection#getMBeanCount()\n         */\n        public Integer getMBeanCount() throws IOException {\n            checkConnection();\n            return connection.getMBeanCount();\n        }","id":6185,"modified_method":"@Override\n        public Integer getMBeanCount() throws IOException {\n            try {\n                return connection.getMBeanCount();\n            } catch (IOException e) {\n                checkConnection();\n                return connection.getMBeanCount();\n            }\n        }","commit_id":"5e8c89f41c1a0afed822e5abf6e406f6149050ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * @param name\n         * @param query\n         * @return\n         * @throws IOException\n         * @see javax.management.MBeanServerConnection#queryNames(javax.management.ObjectName, javax.management.QueryExp)\n         */\n        public Set<ObjectName> queryNames(ObjectName name, QueryExp query) throws IOException {\n            checkConnection();\n            return connection.queryNames(name, query);\n        }","id":6186,"modified_method":"@Override\n        public Set<ObjectName> queryNames(ObjectName name, QueryExp query) throws IOException {\n            try {\n                return connection.queryNames(name, query);\n            } catch (IOException e) {\n                checkConnection();\n                return connection.queryNames(name, query);\n            }\n        }","commit_id":"5e8c89f41c1a0afed822e5abf6e406f6149050ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * @param name\n         * @param listener\n         * @throws InstanceNotFoundException\n         * @throws ListenerNotFoundException\n         * @throws IOException\n         * @see javax.management.MBeanServerConnection#removeNotificationListener(javax.management.ObjectName, javax.management.ObjectName)\n         */\n        public void removeNotificationListener(ObjectName name, ObjectName listener) throws InstanceNotFoundException,\n                ListenerNotFoundException, IOException {\n            checkConnection();\n            connection.removeNotificationListener(name, listener);\n        }","id":6187,"modified_method":"@Override\n        public void removeNotificationListener(ObjectName name, ObjectName listener) throws InstanceNotFoundException,\n                ListenerNotFoundException, IOException {\n            try {\n                connection.removeNotificationListener(name, listener);\n            } catch (IOException e) {\n                if (!checkConnection()) {\n                    connection.removeNotificationListener(name, listener);\n                } else {\n                    throw e;\n                }\n            }\n        }","commit_id":"5e8c89f41c1a0afed822e5abf6e406f6149050ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * @param name\n         * @param className\n         * @return\n         * @throws InstanceNotFoundException\n         * @throws IOException\n         * @see javax.management.MBeanServerConnection#isInstanceOf(javax.management.ObjectName, java.lang.String)\n         */\n        public boolean isInstanceOf(ObjectName name, String className) throws InstanceNotFoundException, IOException {\n            checkConnection();\n            return connection.isInstanceOf(name, className);\n        }","id":6188,"modified_method":"@Override\n        public boolean isInstanceOf(ObjectName name, String className) throws InstanceNotFoundException, IOException {\n            try {\n                return connection.isInstanceOf(name, className);\n            } catch (IOException e) {\n                checkConnection();\n                return connection.isInstanceOf(name, className);\n            }\n        }","commit_id":"5e8c89f41c1a0afed822e5abf6e406f6149050ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * @param name\n         * @param listener\n         * @param filter\n         * @param handback\n         * @throws InstanceNotFoundException\n         * @throws IOException\n         * @see javax.management.MBeanServerConnection#addNotificationListener(javax.management.ObjectName, javax.management.ObjectName, javax.management.NotificationFilter, java.lang.Object)\n         */\n        public void addNotificationListener(ObjectName name, ObjectName listener, NotificationFilter filter, Object handback)\n                throws InstanceNotFoundException, IOException {\n            checkConnection();\n            connection.addNotificationListener(name, listener, filter, handback);\n        }","id":6189,"modified_method":"@Override\n        public void addNotificationListener(ObjectName name, ObjectName listener, NotificationFilter filter, Object handback)\n                throws InstanceNotFoundException, IOException {\n            try {\n                connection.addNotificationListener(name, listener, filter, handback);\n            } catch (IOException e) {\n                if (!checkConnection()) {\n                    connection.addNotificationListener(name, listener, filter, handback);\n                } else {\n                    throw e;\n                }\n            }\n        }","commit_id":"5e8c89f41c1a0afed822e5abf6e406f6149050ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"private MBeanServerConnection getConnection() {\n                try {\n                    final HashMap<String, Object> env = new HashMap<String, Object>();\n                    env.put(CallbackHandler.class.getName(), Authentication.getCallbackHandler());\n                    connection = JMXConnectorFactory.connect(getRemoteJMXURL(), env).getMBeanServerConnection();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            return connection;\n        }","id":6190,"modified_method":"private MBeanServerConnection getConnection() {\n                try {\n                    final HashMap<String, Object> env = new HashMap<String, Object>();\n                    env.put(CallbackHandler.class.getName(), Authentication.getCallbackHandler());\n                    connector = JMXConnectorFactory.connect(getRemoteJMXURL(), env);\n                    connection = connector.getMBeanServerConnection();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            return connection;\n        }","commit_id":"5e8c89f41c1a0afed822e5abf6e406f6149050ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * @param name\n         * @param attributes\n         * @return\n         * @throws InstanceNotFoundException\n         * @throws ReflectionException\n         * @throws IOException\n         * @see javax.management.MBeanServerConnection#getAttributes(javax.management.ObjectName, java.lang.String[])\n         */\n        public AttributeList getAttributes(ObjectName name, String[] attributes) throws InstanceNotFoundException,\n                ReflectionException, IOException {\n            checkConnection();\n            return connection.getAttributes(name, attributes);\n        }","id":6191,"modified_method":"@Override\n        public AttributeList getAttributes(ObjectName name, String[] attributes) throws InstanceNotFoundException,\n                ReflectionException, IOException {\n            try {\n                return connection.getAttributes(name, attributes);\n            } catch (IOException e) {\n                checkConnection();\n                return connection.getAttributes(name, attributes);\n            }\n        }","commit_id":"5e8c89f41c1a0afed822e5abf6e406f6149050ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * @param name\n         * @param listener\n         * @throws InstanceNotFoundException\n         * @throws ListenerNotFoundException\n         * @throws IOException\n         * @see javax.management.MBeanServerConnection#removeNotificationListener(javax.management.ObjectName, javax.management.NotificationListener)\n         */\n        public void removeNotificationListener(ObjectName name, NotificationListener listener)\n                throws InstanceNotFoundException, ListenerNotFoundException, IOException {\n            checkConnection();\n            connection.removeNotificationListener(name, listener);\n        }","id":6192,"modified_method":"@Override\n        public void removeNotificationListener(ObjectName name, NotificationListener listener)\n                throws InstanceNotFoundException, ListenerNotFoundException, IOException {\n            try {\n                connection.removeNotificationListener(name, listener);\n            } catch (IOException e) {\n                if (!checkConnection()) {\n                    connection.removeNotificationListener(name, listener);\n                } else {\n                    throw e;\n                }\n            }\n        }","commit_id":"5e8c89f41c1a0afed822e5abf6e406f6149050ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * @param connection\n         */\n        public MBeanConnectionProxy(MBeanServerConnection connection) {\n            super();\n            this.connection = connection;\n        }","id":6193,"modified_method":"/**\n         * @param connection connection to delegate to\n         */\n        private MBeanConnectionProxy(MBeanServerConnection connection) {\n            super();\n            this.connection = connection;\n        }","commit_id":"5e8c89f41c1a0afed822e5abf6e406f6149050ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * @param name\n         * @param attribute\n         * @return\n         * @throws MBeanException\n         * @throws AttributeNotFoundException\n         * @throws InstanceNotFoundException\n         * @throws ReflectionException\n         * @throws IOException\n         * @see javax.management.MBeanServerConnection#getAttribute(javax.management.ObjectName, java.lang.String)\n         */\n        public Object getAttribute(ObjectName name, String attribute) throws MBeanException, AttributeNotFoundException,\n                InstanceNotFoundException, ReflectionException, IOException {\n            checkConnection();\n            return connection.getAttribute(name, attribute);\n        }","id":6194,"modified_method":"@Override\n        public Object getAttribute(ObjectName name, String attribute) throws MBeanException, AttributeNotFoundException,\n                InstanceNotFoundException, ReflectionException, IOException {\n            try {\n                return connection.getAttribute(name, attribute);\n            } catch (IOException e) {\n                checkConnection();\n                return connection.getAttribute(name, attribute);\n            }\n        }","commit_id":"5e8c89f41c1a0afed822e5abf6e406f6149050ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * @param className\n         * @param name\n         * @param params\n         * @param signature\n         * @return\n         * @throws ReflectionException\n         * @throws InstanceAlreadyExistsException\n         * @throws MBeanRegistrationException\n         * @throws MBeanException\n         * @throws NotCompliantMBeanException\n         * @throws IOException\n         * @see javax.management.MBeanServerConnection#createMBean(java.lang.String, javax.management.ObjectName, java.lang.Object[], java.lang.String[])\n         */\n        public ObjectInstance createMBean(String className, ObjectName name, Object[] params, String[] signature)\n                throws ReflectionException, InstanceAlreadyExistsException, MBeanException,\n                NotCompliantMBeanException, IOException {\n            checkConnection();\n            return connection.createMBean(className, name, params, signature);\n        }","id":6195,"modified_method":"@Override\n        public ObjectInstance createMBean(String className, ObjectName name, Object[] params, String[] signature)\n                throws ReflectionException, InstanceAlreadyExistsException, MBeanException,\n                NotCompliantMBeanException, IOException {\n            checkConnection();\n            return connection.createMBean(className, name, params, signature);\n        }","commit_id":"5e8c89f41c1a0afed822e5abf6e406f6149050ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * @param name\n         * @param attributes\n         * @return\n         * @throws InstanceNotFoundException\n         * @throws ReflectionException\n         * @throws IOException\n         * @see javax.management.MBeanServerConnection#setAttributes(javax.management.ObjectName, javax.management.AttributeList)\n         */\n        public AttributeList setAttributes(ObjectName name, AttributeList attributes) throws InstanceNotFoundException,\n                ReflectionException, IOException {\n            checkConnection();\n            return connection.setAttributes(name, attributes);\n        }","id":6196,"modified_method":"@Override\n        public AttributeList setAttributes(ObjectName name, AttributeList attributes) throws InstanceNotFoundException,\n                ReflectionException, IOException {\n            checkConnection();\n            return connection.setAttributes(name, attributes);\n        }","commit_id":"5e8c89f41c1a0afed822e5abf6e406f6149050ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void checkConnection(){\n            try{\n                this.connection.getMBeanCount();\n                return;\n            }catch(IOException ioe){\n            }\n            this.connection = this.getConnection();\n        }","id":6197,"modified_method":"private boolean checkConnection(){\n            try{\n                this.connection.getMBeanCount();\n                return true;\n            }catch(IOException ioe){\n            }\n            this.connection = this.getConnection();\n            return false;\n        }","commit_id":"5e8c89f41c1a0afed822e5abf6e406f6149050ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * @return\n         * @throws IOException\n         * @see javax.management.MBeanServerConnection#getDomains()\n         */\n        public String[] getDomains() throws IOException {\n            checkConnection();\n            return connection.getDomains();\n        }","id":6198,"modified_method":"@Override\n        public String[] getDomains() throws IOException {\n            try {\n                return connection.getDomains();\n            } catch (IOException e) {\n                checkConnection();\n                return connection.getDomains();\n            }\n        }","commit_id":"5e8c89f41c1a0afed822e5abf6e406f6149050ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * @param name\n         * @param listener\n         * @param filter\n         * @param handback\n         * @throws InstanceNotFoundException\n         * @throws ListenerNotFoundException\n         * @throws IOException\n         * @see javax.management.MBeanServerConnection#removeNotificationListener(javax.management.ObjectName, javax.management.NotificationListener, javax.management.NotificationFilter, java.lang.Object)\n         */\n        public void removeNotificationListener(ObjectName name, NotificationListener listener, NotificationFilter filter,\n                Object handback) throws InstanceNotFoundException, ListenerNotFoundException, IOException {\n            checkConnection();\n            connection.removeNotificationListener(name, listener, filter, handback);\n        }","id":6199,"modified_method":"@Override\n        public void removeNotificationListener(ObjectName name, NotificationListener listener, NotificationFilter filter,\n                Object handback) throws InstanceNotFoundException, ListenerNotFoundException, IOException {\n            try {\n                connection.removeNotificationListener(name, listener, filter, handback);\n            } catch (IOException e) {\n                if (!checkConnection()) {\n                    connection.removeNotificationListener(name, listener, filter, handback);\n                } else {\n                    throw e;\n                }\n            }\n        }","commit_id":"5e8c89f41c1a0afed822e5abf6e406f6149050ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * @param className\n         * @param name\n         * @param loaderName\n         * @return\n         * @throws ReflectionException\n         * @throws InstanceAlreadyExistsException\n         * @throws MBeanRegistrationException\n         * @throws MBeanException\n         * @throws NotCompliantMBeanException\n         * @throws InstanceNotFoundException\n         * @throws IOException\n         * @see javax.management.MBeanServerConnection#createMBean(java.lang.String, javax.management.ObjectName, javax.management.ObjectName)\n         */\n        public ObjectInstance createMBean(String className, ObjectName name, ObjectName loaderName) throws ReflectionException,\n                InstanceAlreadyExistsException, MBeanException, NotCompliantMBeanException,\n                InstanceNotFoundException, IOException {\n            checkConnection();\n            return connection.createMBean(className, name, loaderName);\n        }","id":6200,"modified_method":"@Override\n        public ObjectInstance createMBean(String className, ObjectName name, ObjectName loaderName) throws ReflectionException,\n                InstanceAlreadyExistsException, MBeanException, NotCompliantMBeanException,\n                InstanceNotFoundException, IOException {\n            checkConnection();\n            return connection.createMBean(className, name, loaderName);\n        }","commit_id":"5e8c89f41c1a0afed822e5abf6e406f6149050ef","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void setAttribute(\n\t\tLoggerElement loggerElement, String attributeName,\n\t\tString attributeValue) {\n\n\t\tif (!isLoggerStarted()) {\n\t\t\treturn;\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(\"var node = document.getElementById('\");\n\t\tsb.append(loggerElement.getID());\n\t\tsb.append(\"');\");\n\n\t\tsb.append(\"node.setAttribute('\");\n\t\tsb.append(StringEscapeUtils.escapeEcmaScript(attributeName));\n\t\tsb.append(\"', '\");\n\t\tsb.append(StringEscapeUtils.escapeEcmaScript(attributeValue));\n\t\tsb.append(\"');\");\n\n\t\tString strAttributeName = StringEscapeUtils.escapeEcmaScript(\n\t\t\tattributeName);\n\t\tString strAttributeValue = StringEscapeUtils.escapeEcmaScript(\n\t\t\tattributeValue);\n\n\t\t_javascriptExecutor.executeScript(\"setAttribute(\" +\n\t\t\tloggerElement.getID() + \", '\" + strAttributeName + \"', '\" +\n\t\t\tstrAttributeValue + \"');\");\n\t}","id":6201,"modified_method":"public static void setAttribute(\n\t\tLoggerElement loggerElement, String attributeName,\n\t\tString attributeValue) {\n\n\t\tif (!isLoggerStarted()) {\n\t\t\treturn;\n\t\t}\n\n\t\tString strAttributeName = StringEscapeUtils.escapeEcmaScript(\n\t\t\tattributeName);\n\t\tString strAttributeValue = StringEscapeUtils.escapeEcmaScript(\n\t\t\tattributeValue);\n\n\t\t_javascriptExecutor.executeScript(\n\t\t\t\"setAttribute(\" + loggerElement.getID() + \", '\" + strAttributeName +\n\t\t\t\t\"', '\" + strAttributeValue + \"');\");\n\t}","commit_id":"f83da0ddfafe946428cc4b3769a9c7326812aacb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void setID(LoggerElement loggerElement) {\n\t\tif (!isLoggerStarted()) {\n\t\t\treturn;\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(\"var node = document.getElementById('\");\n\t\tsb.append(loggerElement.getID());\n\t\tsb.append(\"');\");\n\n\t\tsb.append(\"node.setAttribute('id', '\");\n\t\tsb.append(StringEscapeUtils.escapeEcmaScript(loggerElement.getID()));\n\t\tsb.append(\"');\");\n\n\t\tString id = StringEscapeUtils.escapeEcmaScript(loggerElement.getID());\n\n\t\t_javascriptExecutor.executeScript(\"setID(\" + loggerElement.getID() +\n\t\t\t\", '\" + id + \"');\");\n\t}","id":6202,"modified_method":"public static void setID(LoggerElement loggerElement) {\n\t\tif (!isLoggerStarted()) {\n\t\t\treturn;\n\t\t}\n\n\t\tString id = StringEscapeUtils.escapeEcmaScript(loggerElement.getID());\n\n\t\t_javascriptExecutor.executeScript(\n\t\t\t\"setID(\" + loggerElement.getID() + \", '\" + id + \"');\");\n\t}","commit_id":"f83da0ddfafe946428cc4b3769a9c7326812aacb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean isWrittenToLogger(LoggerElement loggerElement) {\n\t\tif (!isLoggerStarted() && !isJavascriptLoaded()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(\"var node = document.getElementById('\");\n\t\tsb.append(loggerElement.getID());\n\t\tsb.append(\"');\");\n\n\t\tsb.append(\"if (node == null) {\");\n\t\tsb.append(\"return false;\");\n\t\tsb.append(\"}\");\n\n\t\tsb.append(\"return true;\");\n\n\t\ttry {\n\t\t\treturn (boolean)_javascriptExecutor.executeScript(\n\t\t\t\t\"isWrittenToLogger(\" + loggerElement.getID() + \");\");\n\t\t}\n\t\tcatch (Exception error) {\n\t\t\treturn false;\n\t\t}\n\t}","id":6203,"modified_method":"public static boolean isWrittenToLogger(LoggerElement loggerElement) {\n\t\tif (!isLoggerStarted()) {\n\t\t\treturn false;\n\t\t}\n\n\t\ttry {\n\t\t\treturn (boolean)_javascriptExecutor.executeScript(\n\t\t\t\t\"isWrittenToLogger(\" + loggerElement.getID() + \");\");\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn false;\n\t\t}\n\t}","commit_id":"f83da0ddfafe946428cc4b3769a9c7326812aacb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void addChildLoggerElement(\n\t\tLoggerElement parentLoggerElement, LoggerElement childLoggerElement) {\n\n\t\tif (!isLoggerStarted()) {\n\t\t\treturn;\n\t\t}\n\n\t\tStringBuilder defaultAttr = new StringBuilder();\n\n\t\tString cssClass = StringEscapeUtils.escapeEcmaScript(\n\t\t\tchildLoggerElement.getClassName());\n\t\tString id = StringEscapeUtils.escapeEcmaScript(\n\t\t\tchildLoggerElement.getID());\n\t\tString innerHTML = StringEscapeUtils.escapeEcmaScript(\n\t\t\tchildLoggerElement.getText());\n\t\tString name = StringEscapeUtils.escapeEcmaScript(\n\t\t\tchildLoggerElement.getName());\n\t\tString parentId = StringEscapeUtils.escapeEcmaScript(\n\t\t\tparentLoggerElement.getID());\n\n\t\tdefaultAttr.append(\"{\");\n\t\tdefaultAttr.append(\"cssClass : '\" + cssClass + \"',\");\n\t\tdefaultAttr.append(\"id : '\" + id + \"',\");\n\t\tdefaultAttr.append(\"innerHTML : '\" + innerHTML + \"',\");\n\t\tdefaultAttr.append(\"name : '\" + name + \"',\");\n\t\tdefaultAttr.append(\"parentId : '\" + parentId + \"'\");\n\t\tdefaultAttr.append(\"}\");\n\n\t\tStringBuilder extraAttr = new StringBuilder();\n\n\t\textraAttr.append(\"{\");\n\n\t\tList<String> attributeNames = childLoggerElement.getAttributeNames();\n\n\t\tIterator<String> iterator = attributeNames.iterator();\n\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tString attributeName = iterator.next();\n\n\t\t\t\tString strAttributeName = StringEscapeUtils.escapeEcmaScript(\n\t\t\t\t\tattributeName);\n\t\t\t\tString strAttributeValue = StringEscapeUtils.escapeEcmaScript(\n\t\t\t\t\tchildLoggerElement.getAttributeValue(attributeName));\n\n\t\t\t\textraAttr.append(\"'\" + strAttributeName + \"' : '\" +\n\t\t\t\t\tstrAttributeValue + \"'\");\n\n\t\t\t\tif (iterator.hasNext()) {\n\t\t\t\t\textraAttr.append(\",\");\n\t\t\t\t}\n\t\t\t}\n\n\t\textraAttr.append(\"}\");\n\n\t\t_javascriptExecutor.executeScript(\"addChildLoggerElement(\" + defaultAttr\n\t\t\t+ \", \" + extraAttr + \");\");\n\t}","id":6204,"modified_method":"public static void addChildLoggerElement(\n\t\tLoggerElement parentLoggerElement, LoggerElement childLoggerElement) {\n\n\t\tif (!isLoggerStarted()) {\n\t\t\treturn;\n\t\t}\n\n\t\tStringBuilder defaultAttr = new StringBuilder();\n\n\t\tdefaultAttr.append(\"{\");\n\t\tdefaultAttr.append(\"cssClass : '\");\n\t\tdefaultAttr.append(\n\t\t\tStringEscapeUtils.escapeEcmaScript(\n\t\t\t\tchildLoggerElement.getClassName()));\n\t\tdefaultAttr.append(\"',\");\n\t\tdefaultAttr.append(\"id : '\");\n\t\tdefaultAttr.append(\n\t\t\tStringEscapeUtils.escapeEcmaScript(childLoggerElement.getID()));\n\t\tdefaultAttr.append(\"',\");\n\t\tdefaultAttr.append(\"innerHTML : '\");\n\t\tdefaultAttr.append(\n\t\t\tStringEscapeUtils.escapeEcmaScript(childLoggerElement.getText()));\n\t\tdefaultAttr.append(\"',\");\n\t\tdefaultAttr.append(\"name : '\");\n\t\tdefaultAttr.append(\n\t\t\tStringEscapeUtils.escapeEcmaScript(childLoggerElement.getName()));\n\t\tdefaultAttr.append(\"',\");\n\t\tdefaultAttr.append(\"parentId : '\");\n\t\tdefaultAttr.append(\n\t\t\tStringEscapeUtils.escapeEcmaScript(parentLoggerElement.getID()));\n\t\tdefaultAttr.append(\"'\");\n\t\tdefaultAttr.append(\"}\");\n\n\t\tStringBuilder extraAttr = new StringBuilder();\n\n\t\textraAttr.append(\"{\");\n\n\t\tList<String> attributeNames = childLoggerElement.getAttributeNames();\n\n\t\tIterator<String> iterator = attributeNames.iterator();\n\n\t\twhile (iterator.hasNext()) {\n\t\t\tString attributeName = iterator.next();\n\n\t\t\tString strAttributeName = StringEscapeUtils.escapeEcmaScript(\n\t\t\t\tattributeName);\n\t\t\tString strAttributeValue = StringEscapeUtils.escapeEcmaScript(\n\t\t\t\tchildLoggerElement.getAttributeValue(attributeName));\n\n\t\t\textraAttr.append(\n\t\t\t\t\"'\" + strAttributeName + \"' : '\" + strAttributeValue + \"'\");\n\n\t\t\tif (iterator.hasNext()) {\n\t\t\t\textraAttr.append(\",\");\n\t\t\t}\n\t\t}\n\n\t\textraAttr.append(\"}\");\n\n\t\t_javascriptExecutor.executeScript(\n\t\t\t\"addChildLoggerElement(\" + defaultAttr + \", \" + extraAttr + \");\");\n\t}","commit_id":"f83da0ddfafe946428cc4b3769a9c7326812aacb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void startLogger() throws Exception {\n\t\tif (isLoggerStarted() || !PropsValues.SELENIUM_LOGGER_ENABLED) {\n\t\t\treturn;\n\t\t}\n\n\t\t_webDriver = new FirefoxDriver();\n\n\t\tWebDriver.Options options = _webDriver.manage();\n\n\t\tWebDriver.Window window = options.window();\n\n\t\twindow.setPosition(new Point(1050, 45));\n\t\twindow.setSize(new Dimension(850, 950));\n\n\t\t_javascriptExecutor = (JavascriptExecutor)_webDriver;\n\n\t\tString cssContent = _readResource(\"META-INF/resources/css/main.css\");\n\n\t\tFileUtil.write(_CURRENT_DIR + \"/test-results/css/main.css\", cssContent);\n\n\t\tString jsContent = _readResource(\"META-INF/resources/js/main.js\");\n\n\t\tFileUtil.write(_CURRENT_DIR + \"/test-results/js/main.js\", jsContent);\n\n\t\tString htmlContent = _readResource(\n\t\t\t\"META-INF/resources/html/index.html\");\n\n\t\thtmlContent = htmlContent.replace(\n\t\t\t\"<ul class=\\\"command-log\\\" data-logid=\\\"01\\\" id=\\\"commandLog\\\">\" +\n\t\t\t\t\"<\/ul>\",\n\t\t\tCommandLoggerHandler.getCommandLogText());\n\t\thtmlContent = htmlContent.replace(\n\t\t\t\"<ul class=\\\"xml-log-container\\\" id=\\\"xmlLogContainer\\\"><\/ul>\",\n\t\t\tXMLLoggerHandler.getXMLLogText());\n\n\t\tFileUtil.write(_getHtmlFilePath(), htmlContent);\n\n\t\t_webDriver.get(\"file://\" + _getHtmlFilePath());\n\n\t\t_javascriptLoaded = true;\n\t}","id":6205,"modified_method":"public static void startLogger() throws Exception {\n\t\tif (isLoggerStarted() || !PropsValues.SELENIUM_LOGGER_ENABLED) {\n\t\t\treturn;\n\t\t}\n\n\t\t_webDriver = new FirefoxDriver();\n\n\t\tWebDriver.Options options = _webDriver.manage();\n\n\t\tWebDriver.Window window = options.window();\n\n\t\twindow.setPosition(new Point(1050, 45));\n\t\twindow.setSize(new Dimension(850, 950));\n\n\t\t_javascriptExecutor = (JavascriptExecutor)_webDriver;\n\n\t\tString cssContent = _readResource(\"META-INF/resources/css/main.css\");\n\n\t\tFileUtil.write(_CURRENT_DIR + \"/test-results/css/main.css\", cssContent);\n\n\t\tString jsMain = _readResource(\"META-INF/resources/js/main.js\");\n\n\t\tFileUtil.write(_CURRENT_DIR + \"/test-results/js/main.js\", jsMain);\n\n\t\tString jsComponent = _readResource(\n\t\t\t\"META-INF/resources/js/component.js\");\n\n\t\tFileUtil.write(\n\t\t\t_CURRENT_DIR + \"/test-results/js/component.js\", jsComponent);\n\n\t\tString htmlContent = _readResource(\n\t\t\t\"META-INF/resources/html/index.html\");\n\n\t\thtmlContent = htmlContent.replace(\n\t\t\t\"<ul class=\\\"command-log\\\" data-logid=\\\"01\\\" id=\\\"commandLog\\\">\" +\n\t\t\t\t\"<\/ul>\",\n\t\t\tCommandLoggerHandler.getCommandLogText());\n\t\thtmlContent = htmlContent.replace(\n\t\t\t\"<ul class=\\\"xml-log-container\\\" id=\\\"xmlLogContainer\\\"><\/ul>\",\n\t\t\tXMLLoggerHandler.getXMLLogText());\n\n\t\tFileUtil.write(_getHtmlFilePath(), htmlContent);\n\n\t\t_webDriver.get(\"file://\" + _getHtmlFilePath());\n\t}","commit_id":"f83da0ddfafe946428cc4b3769a9c7326812aacb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void setText(LoggerElement loggerElement) {\n\t\tif (!isLoggerStarted()) {\n\t\t\treturn;\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(\"var node = document.getElementById('\");\n\t\tsb.append(loggerElement.getID());\n\t\tsb.append(\"');\");\n\n\t\tsb.append(\"node.innerHTML = '\");\n\t\tsb.append(StringEscapeUtils.escapeEcmaScript(loggerElement.getText()));\n\t\tsb.append(\"';\");\n\n\t\tString text = StringEscapeUtils.escapeEcmaScript(\n\t\t\tloggerElement.getText());\n\n\t\t_javascriptExecutor.executeScript(\"setText(\" + loggerElement.getID() +\n\t\t\t\", '\" + text + \"');\");\n\t}","id":6206,"modified_method":"public static void setText(LoggerElement loggerElement) {\n\t\tif (!isLoggerStarted()) {\n\t\t\treturn;\n\t\t}\n\n\t\tString text = StringEscapeUtils.escapeEcmaScript(\n\t\t\tloggerElement.getText());\n\n\t\t_javascriptExecutor.executeScript(\n\t\t\t\"setText(\" + loggerElement.getID() + \", '\" + text + \"');\");\n\t}","commit_id":"f83da0ddfafe946428cc4b3769a9c7326812aacb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void stopLogger() throws Exception {\n\t\tif (!PropsValues.SELENIUM_LOGGER_ENABLED) {\n\t\t\tString cssContent = _readResource(\n\t\t\t\t\"META-INF/resources/css/main.css\");\n\n\t\t\tFileUtil.write(\n\t\t\t\t_CURRENT_DIR + \"/test-results/css/main.css\", cssContent);\n\n\t\t\tString jsContent = _readResource(\"META-INF/resources/js/main.js\");\n\n\t\t\tFileUtil.write(\n\t\t\t\t_CURRENT_DIR + \"/test-results/js/main.js\", jsContent);\n\t\t}\n\n\t\tString htmlContent = _readResource(\n\t\t\t\"META-INF/resources/html/index.html\");\n\n\t\thtmlContent = htmlContent.replace(\n\t\t\t\"<ul class=\\\"command-log\\\" data-logid=\\\"01\\\" id=\\\"commandLog\\\">\" +\n\t\t\t\t\"<\/ul>\",\n\t\t\tCommandLoggerHandler.getCommandLogText());\n\t\thtmlContent = htmlContent.replace(\n\t\t\t\"<ul class=\\\"xml-log-container\\\" id=\\\"xmlLogContainer\\\"><\/ul>\",\n\t\t\tXMLLoggerHandler.getXMLLogText());\n\n\t\tif (!PropsValues.TEST_RUN_LOCALLY) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\n\t\t\tsb.append(\"http://rawgit.com/liferay/liferay-portal/master/\");\n\t\t\tsb.append(\"modules/test/poshi-runner/src/META-INF/resources\");\n\n\t\t\thtmlContent = StringUtil.replace(\n\t\t\t\thtmlContent, \"<link href=\\\"../css/main.css\\\"\",\n\t\t\t\t\"<link href=\\\"\" + sb.toString() + \"/css/.sass-cache/\" +\n\t\t\t\t\t\"main.css\\\"\");\n\t\t\thtmlContent = StringUtil.replace(\n\t\t\t\thtmlContent, \"<script src=\\\"../js/main.js\\\"\",\n\t\t\t\t\"<script src=\\\"\" + sb.toString() + \"/js/main.js\\\"\");\n\t\t}\n\n\t\tFileUtil.write(_getHtmlFilePath(), htmlContent);\n\n\t\tif (isLoggerStarted()) {\n\t\t\t_webDriver.quit();\n\n\t\t\t_webDriver = null;\n\t\t}\n\t}","id":6207,"modified_method":"public static void stopLogger() throws Exception {\n\t\tif (!PropsValues.SELENIUM_LOGGER_ENABLED) {\n\t\t\tString cssContent = _readResource(\n\t\t\t\t\"META-INF/resources/css/main.css\");\n\n\t\t\tFileUtil.write(\n\t\t\t\t_CURRENT_DIR + \"/test-results/css/main.css\", cssContent);\n\n\t\t\tString jsMain = _readResource(\"META-INF/resources/js/main.js\");\n\n\t\t\tFileUtil.write(_CURRENT_DIR + \"/test-results/js/main.js\", jsMain);\n\n\t\t\tString jsComponent = _readResource(\n\t\t\t\t\"META-INF/resources/js/component.js\");\n\n\t\t\tFileUtil.write(\n\t\t\t\t_CURRENT_DIR + \"/test-results/js/component.js\", jsComponent);\n\t\t}\n\n\t\tString htmlContent = _readResource(\n\t\t\t\"META-INF/resources/html/index.html\");\n\n\t\thtmlContent = htmlContent.replace(\n\t\t\t\"<ul class=\\\"command-log\\\" data-logid=\\\"01\\\" id=\\\"commandLog\\\">\" +\n\t\t\t\t\"<\/ul>\",\n\t\t\tCommandLoggerHandler.getCommandLogText());\n\t\thtmlContent = htmlContent.replace(\n\t\t\t\"<ul class=\\\"xml-log-container\\\" id=\\\"xmlLogContainer\\\"><\/ul>\",\n\t\t\tXMLLoggerHandler.getXMLLogText());\n\n\t\tif (!PropsValues.TEST_RUN_LOCALLY) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\n\t\t\tsb.append(\"http://rawgit.com/liferay/liferay-portal/master/\");\n\t\t\tsb.append(\"modules/test/poshi-runner/src/META-INF/resources\");\n\n\t\t\thtmlContent = StringUtil.replace(\n\t\t\t\thtmlContent, \"<link href=\\\"../css/main.css\\\"\",\n\t\t\t\t\"<link href=\\\"\" + sb.toString() + \"/css/.sass-cache/\" +\n\t\t\t\t\t\"main.css\\\"\");\n\t\t\thtmlContent = StringUtil.replace(\n\t\t\t\thtmlContent, \"<script src=\\\"../js/main.js\\\"\",\n\t\t\t\t\"<script src=\\\"\" + sb.toString() + \"/js/main.js\\\"\");\n\t\t\thtmlContent = StringUtil.replace(\n\t\t\t\thtmlContent, \"<script src=\\\"../js/component.js\\\"\",\n\t\t\t\t\"<script src=\\\"\" + sb.toString() + \"/js/component.js\\\"\");\n\t\t}\n\n\t\tFileUtil.write(_getHtmlFilePath(), htmlContent);\n\n\t\tif (isLoggerStarted()) {\n\t\t\t_webDriver.quit();\n\n\t\t\t_webDriver = null;\n\t\t}\n\t}","commit_id":"f83da0ddfafe946428cc4b3769a9c7326812aacb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void setClassName(LoggerElement loggerElement) {\n\t\tif (!isLoggerStarted()) {\n\t\t\treturn;\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(\"var node = document.getElementById('\");\n\t\tsb.append(loggerElement.getID());\n\t\tsb.append(\"');\");\n\n\t\tsb.append(\"node.setAttribute('class', '\");\n\t\tsb.append(\n\t\t\tStringEscapeUtils.escapeEcmaScript(loggerElement.getClassName()));\n\t\tsb.append(\"');\");\n\n\t\tString className = StringEscapeUtils.escapeEcmaScript(\n\t\t\tloggerElement.getClassName());\n\n\t\t_javascriptExecutor.executeScript(\"setClassName(\" +\n\t\t\tloggerElement.getID() + \", '\" + className + \"');\");\n\t}","id":6208,"modified_method":"public static void setClassName(LoggerElement loggerElement) {\n\t\tif (!isLoggerStarted()) {\n\t\t\treturn;\n\t\t}\n\n\t\tString className = StringEscapeUtils.escapeEcmaScript(\n\t\t\tloggerElement.getClassName());\n\n\t\t_javascriptExecutor.executeScript(\n\t\t\t\"setClassName(\" + loggerElement.getID() + \", '\" + className +\n\t\t\t\t\"');\");\n\t}","commit_id":"f83da0ddfafe946428cc4b3769a9c7326812aacb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void setName(LoggerElement loggerElement) {\n\t\tif (!isLoggerStarted()) {\n\t\t\treturn;\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(\"var oldNode = document.getElementById('\");\n\t\tsb.append(loggerElement.getID());\n\t\tsb.append(\"');\");\n\n\t\tsb.append(\"var newNode = document.createElement('\");\n\t\tsb.append(StringEscapeUtils.escapeEcmaScript(loggerElement.getName()));\n\t\tsb.append(\"');\");\n\n\t\tsb.append(\"newNode.innerHTML = oldNode.innerHTML;\");\n\t\tsb.append(\n\t\t\t\"newNode.setAttribute('class', oldNode.getAttribute('class'));\");\n\t\tsb.append(\"newNode.setAttribute('id', oldNode.getAttribute('id'));\");\n\n\t\tsb.append(\n\t\t\t\"oldNode.parentNode.insertBefore(newNode, oldNode.nextSibling);\");\n\n\t\tsb.append(\"var parentNode = oldNode.parentNode;\");\n\n\t\tsb.append(\"parentNode.removeChild(oldNode);\");\n\n\t\tString name = StringEscapeUtils.escapeEcmaScript(\n\t\t\tloggerElement.getName());\n\n\t\t_javascriptExecutor.executeScript(\"setName(\" + loggerElement.getID() +\n\t\t\t\", '\" + name + \"');\");\n\t}","id":6209,"modified_method":"public static void setName(LoggerElement loggerElement) {\n\t\tif (!isLoggerStarted()) {\n\t\t\treturn;\n\t\t}\n\n\t\tString name = StringEscapeUtils.escapeEcmaScript(\n\t\t\tloggerElement.getName());\n\n\t\t_javascriptExecutor.executeScript(\n\t\t\t\"setName(\" + loggerElement.getID() + \", '\" + name + \"');\");\n\t}","commit_id":"f83da0ddfafe946428cc4b3769a9c7326812aacb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void clear( Context context ) {\n    Context ctx = uuidContexts.remove( context.getCorrelationId( ) );\n    Channel channel = null;\n    if ( ctx != null && ( channel = ctx.getChannel( ) ) != null ) {\n      channelContexts.remove( channel );\n    } else {\n      throw new RuntimeException( \"Missing reference to channel for the request.\" );\n    }\n    ctx.clear( );\n  }","id":6210,"modified_method":"public static void clear( Context context ) {\n    clear( context.getCorrelationId( ) );\n  }","commit_id":"ca57c563cfecefa3267604036f27799cd21833ed","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static void clear( String correlationId ) {\n    try {\n      clear( lookup( correlationId ) );\n    } catch ( NoSuchContextException e ) {\n      LOG.error( e, e );\n    }\n  }","id":6211,"modified_method":"public static void clear( String corrId ) {\n    Assertions.assertNotNull( corrId );\n    Context ctx = uuidContexts.remove( corrId );\n    Channel channel = null;\n    if ( ctx != null && ( channel = ctx.getChannel( ) ) != null ) {\n      channelContexts.remove( channel );\n    } else {\n      LOG.debug( \"Context.clear() failed for correlationId=\" + corrId, new RuntimeException( \"Missing reference to channel for the request.\" ) );\n    }\n    ctx.clear( );\n  }","commit_id":"ca57c563cfecefa3267604036f27799cd21833ed","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public TYPE getUnique( TYPE example ) throws EucalyptusCloudException {\n    if ( TRACE ) EventRecord.here( EntityWrapper.class, EventType.PERSISTENCE, DbEvent.UNIQUE.begin( ), this.tx.getTxUuid( ) ).trace( );\n    List<TYPE> res = this.query( example );\n    if ( res.size( ) != 1 ) {\n      String msg = null;\n      try {\n        msg = LogUtil.dumpObject( example );\n      } catch ( Exception e ) {\n        msg = example.toString( );\n      }\n      if ( TRACE ) EventRecord.here( EntityWrapper.class, EventType.PERSISTENCE, DbEvent.QUERY.fail( ), Long.toString( this.tx.splitOperation( ) ),\n                                     this.tx.getTxUuid( ) ).trace( );\n      throw new EucalyptusCloudException( \"Error locating information for \" + msg );\n    }\n    if ( TRACE ) EventRecord.here( EntityWrapper.class, EventType.PERSISTENCE, DbEvent.QUERY.end( ), Long.toString( this.tx.splitOperation( ) ),\n                                   this.tx.getTxUuid( ) ).trace( );\n    return res.get( 0 );\n  }","id":6212,"modified_method":"public TYPE getUnique( TYPE example ) throws EucalyptusCloudException {\n    if ( LogLevels.EXTREME ) LOG.debug( Join.join( \":\", EventType.PERSISTENCE, DbEvent.UNIQUE.begin( ), this.tx.getTxUuid( ) ) );\n    List<TYPE> res = this.query( example );\n    if ( res.size( ) != 1 ) {\n      String msg = null;\n      try {\n        msg = LogUtil.dumpObject( example );\n      } catch ( Exception e ) {\n        msg = example.toString( );\n      }\n      if ( LogLevels.EXTREME ) LOG.debug( Join.join( \":\", EventType.PERSISTENCE, DbEvent.QUERY.fail( ), Long.toString( this.tx.splitOperation( ) ),\n                                     this.tx.getTxUuid( ) ) );\n      throw new EucalyptusCloudException( \"Error locating information for \" + msg );\n    }\n    if ( LogLevels.EXTREME ) LOG.debug( Join.join( \":\", EventType.PERSISTENCE, DbEvent.QUERY.end( ), Long.toString( this.tx.splitOperation( ) ),\n                                   this.tx.getTxUuid( ) ) );\n    return res.get( 0 );\n  }","commit_id":"ca57c563cfecefa3267604036f27799cd21833ed","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@SuppressWarnings( \"unchecked\" )\n  public List<TYPE> query( TYPE example ) {\n    if ( TRACE ) EventRecord.here( EntityWrapper.class, EventType.PERSISTENCE, DbEvent.QUERY.begin( ), this.tx.getTxUuid( ) ).trace( );\n    Example qbe = Example.create( example ).enableLike( MatchMode.EXACT );\n    List<TYPE> resultList = ( List<TYPE> ) this.getSession( ).createCriteria( example.getClass( ) ).setCacheable( true ).add( qbe ).list( );\n    if ( TRACE ) EventRecord.here( EntityWrapper.class, EventType.PERSISTENCE, DbEvent.QUERY.end( ), Long.toString( this.tx.splitOperation( ) ),\n                                   this.tx.getTxUuid( ) ).trace( );\n    return Lists.newArrayList( Sets.newHashSet( resultList ) );\n  }","id":6213,"modified_method":"@SuppressWarnings( \"unchecked\" )\n  public List<TYPE> query( TYPE example ) {\n    if ( LogLevels.EXTREME ) LOG.debug( Join.join( \":\", EventType.PERSISTENCE, DbEvent.QUERY.begin( ), this.tx.getTxUuid( ) ) );\n    Example qbe = Example.create( example ).enableLike( MatchMode.EXACT );\n    List<TYPE> resultList = ( List<TYPE> ) this.getSession( ).createCriteria( example.getClass( ) ).setCacheable( true ).add( qbe ).list( );\n    if ( LogLevels.EXTREME ) LOG.debug( Join.join( \":\", EventType.PERSISTENCE, DbEvent.QUERY.end( ), Long.toString( this.tx.splitOperation( ) ),\n                                   this.tx.getTxUuid( ) ) );\n    return Lists.newArrayList( Sets.newHashSet( resultList ) );\n  }","commit_id":"ca57c563cfecefa3267604036f27799cd21833ed","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void rollback( ) {\n    if ( TRACE ) EventRecord.here( EntityWrapper.class, EventType.PERSISTENCE, DbEvent.ROLLBACK.begin( ), this.tx.getTxUuid( ) ).trace( );\n    try {\n      this.tx.rollback( );\n    } catch ( Throwable e ) {\n      if ( TRACE ) EventRecord.here( EntityWrapper.class, EventType.PERSISTENCE, DbEvent.ROLLBACK.fail( ), Long.toString( this.tx.splitOperation( ) ),\n                                     this.tx.getTxUuid( ) ).trace( );\n      PersistenceErrorFilter.exceptionCaught( e );\n    }\n    if ( TRACE ) EventRecord.here( EntityWrapper.class, EventType.PERSISTENCE, DbEvent.ROLLBACK.end( ), Long.toString( this.tx.splitOperation( ) ),\n                                   this.tx.getTxUuid( ) ).trace( );\n  }","id":6214,"modified_method":"public void rollback( ) {\n    if ( LogLevels.EXTREME ) LOG.debug( Join.join( \":\", EventType.PERSISTENCE, DbEvent.ROLLBACK.begin( ), this.tx.getTxUuid( ) ) );\n    try {\n      this.tx.rollback( );\n    } catch ( Throwable e ) {\n      if ( LogLevels.EXTREME ) LOG.debug( Join.join( \":\", EventType.PERSISTENCE, DbEvent.ROLLBACK.fail( ), Long.toString( this.tx.splitOperation( ) ),\n                                     this.tx.getTxUuid( ) ) );\n      PersistenceErrorFilter.exceptionCaught( e );\n    }\n    if ( LogLevels.EXTREME ) LOG.debug( Join.join( \":\", EventType.PERSISTENCE, DbEvent.ROLLBACK.end( ), Long.toString( this.tx.splitOperation( ) ),\n                                   this.tx.getTxUuid( ) ) );\n  }","commit_id":"ca57c563cfecefa3267604036f27799cd21833ed","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void commit( ) {\n    if ( TRACE ) EventRecord.here( EntityWrapper.class, EventType.PERSISTENCE, DbEvent.COMMIT.begin( ), this.tx.getTxUuid( ) ).trace( );\n    try {\n      this.tx.commit( );\n    } catch ( RuntimeException e ) {\n      if ( TRACE ) EventRecord.here( EntityWrapper.class, EventType.PERSISTENCE, DbEvent.COMMIT.fail( ), Long.toString( this.tx.splitOperation( ) ),\n                                     this.tx.getTxUuid( ) ).trace( );\n      PersistenceErrorFilter.exceptionCaught( e );\n      throw e;\n    } catch ( Throwable e ) {\n      if ( TRACE ) EventRecord.here( EntityWrapper.class, EventType.PERSISTENCE, DbEvent.COMMIT.fail( ), Long.toString( this.tx.splitOperation( ) ),\n                                     this.tx.getTxUuid( ) ).trace( );\n      PersistenceErrorFilter.exceptionCaught( e );\n      throw new RuntimeException( e );\n    }\n    if ( TRACE ) EventRecord.here( EntityWrapper.class, EventType.PERSISTENCE, DbEvent.COMMIT.end( ), Long.toString( this.tx.splitOperation( ) ),\n                                   this.tx.getTxUuid( ) ).trace( );\n  }","id":6215,"modified_method":"public void commit( ) {\n    if ( LogLevels.EXTREME ) LOG.debug( Join.join( \":\", EventType.PERSISTENCE, DbEvent.COMMIT.begin( ), this.tx.getTxUuid( ) ) );\n    try {\n      this.tx.commit( );\n    } catch ( RuntimeException e ) {\n      if ( LogLevels.EXTREME ) LOG.debug( Join.join( \":\", EventType.PERSISTENCE, DbEvent.COMMIT.fail( ), Long.toString( this.tx.splitOperation( ) ),\n                                     this.tx.getTxUuid( ) ) );\n      PersistenceErrorFilter.exceptionCaught( e );\n      throw e;\n    } catch ( Throwable e ) {\n      if ( LogLevels.EXTREME ) LOG.debug( Join.join( \":\", EventType.PERSISTENCE, DbEvent.COMMIT.fail( ), Long.toString( this.tx.splitOperation( ) ),\n                                     this.tx.getTxUuid( ) ) );\n      PersistenceErrorFilter.exceptionCaught( e );\n      throw new RuntimeException( e );\n    }\n    if ( LogLevels.EXTREME ) LOG.debug( Join.join( \":\", EventType.PERSISTENCE, DbEvent.COMMIT.end( ), Long.toString( this.tx.splitOperation( ) ),\n                                   this.tx.getTxUuid( ) ) );\n  }","commit_id":"ca57c563cfecefa3267604036f27799cd21833ed","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@SuppressWarnings( \"unchecked\" )\n  public EntityWrapper( String persistenceContext ) {\n    try {\n      if ( TRACE ) EventRecord.here( EntityWrapper.class, EventType.PERSISTENCE, DbEvent.CREATE.begin( ) ).trace( );\n      this.tx = new TxHandle( persistenceContext );\n    } catch ( Throwable e ) {\n      if ( TRACE ) EventRecord.here( EntityWrapper.class, EventType.PERSISTENCE, DbEvent.CREATE.fail( ), e.getMessage( ) ).trace( );\n      PersistenceErrorFilter.exceptionCaught( e );\n      throw ( RuntimeException ) e;\n    }\n    if ( TRACE ) EventRecord.here( EntityWrapper.class, EventType.PERSISTENCE, DbEvent.CREATE.end( ), Long.toString( this.tx.splitOperation( ) ),\n                                   this.tx.getTxUuid( ) ).trace( );\n  }","id":6216,"modified_method":"@SuppressWarnings( \"unchecked\" )\n  public EntityWrapper( String persistenceContext ) {\n    try {\n      if ( LogLevels.EXTREME ) LOG.debug( Join.join( \":\", EntityWrapper.class, EventType.PERSISTENCE, DbEvent.CREATE.begin( ) ) );\n      this.tx = new TxHandle( persistenceContext );\n    } catch ( Throwable e ) {\n      if ( LogLevels.EXTREME ) LOG.debug( Join.join( \":\", EntityWrapper.class, EventType.PERSISTENCE, DbEvent.CREATE.fail( ), e.getMessage( ) ) );\n      PersistenceErrorFilter.exceptionCaught( e );\n      throw ( RuntimeException ) e;\n    }\n    if ( LogLevels.EXTREME ) LOG.debug( Join.join( \":\", EntityWrapper.class, EventType.PERSISTENCE, DbEvent.CREATE.end( ), Long.toString( this.tx.splitOperation( ) ),\n                                   this.tx.getTxUuid( ) ) );\n  }","commit_id":"ca57c563cfecefa3267604036f27799cd21833ed","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private static Record create( final Class component, final EventClass eventClass, final EventType eventName, final String other, int dist ) {\n    EucalyptusMessage msg = tryForMessage( );\n    StackTraceElement[] stack = Thread.currentThread( ).getStackTrace( );\n    StackTraceElement ste = stack[dist+3<stack.length?dist+3:stack.length-1];\n    UserFullName userFn = FakePrincipals.NOBODY_USER_ERN;\n    try {\n      userFn = Contexts.lookup( msg.getCorrelationId( ) ).getUserFullName( );\n    } catch ( Exception ex ) {\n    }\n    return new LogFileRecord( eventClass, eventName, component, ste, msg == BOGUS ? \"nobody\" : userFn.toString( ), msg.getCorrelationId( ), other );\n  }","id":6217,"modified_method":"private static Record create( final Class component, final EventClass eventClass, final EventType eventName, final String other, int dist ) {\n    EucalyptusMessage msg = tryForMessage( );\n    StackTraceElement[] stack = Thread.currentThread( ).getStackTrace( );\n    StackTraceElement ste = stack[dist+3<stack.length?dist+3:stack.length-1];\n    UserFullName userFn = FakePrincipals.NOBODY_USER_ERN;\n    try {\n      Context ctx = Contexts.lookup( msg.getCorrelationId( ) );\n      userFn = ctx.getUserFullName( );\n    } catch ( Exception ex ) {\n    }\n    return new LogFileRecord( eventClass, eventName, component, ste, msg == BOGUS ? \"nobody\" : userFn.toString( ), msg.getCorrelationId( ), other );\n  }","commit_id":"ca57c563cfecefa3267604036f27799cd21833ed","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"/** Draws a polyline in the x/y plane using {@link ShapeType#Line}. The vertices must contain at least 2 points (4 floats x,y). */\r\n\tpublic void polyline (float[] vertices, int offset, int count) {\r\n\t\tif (count < 4) throw new IllegalArgumentException(\"Polylines must contain at least 2 points.\");\r\n\t\tif (count % 2 != 0) throw new IllegalArgumentException(\"Polylines must have an even number of vertices.\");\r\n\r\n\t\tcheck(ShapeType.Line, null, count);\r\n\r\n\t\tfor (int i = offset, n = offset + count - 2; i < n; i += 2) {\r\n\t\t\tfloat x1 = vertices[i];\r\n\t\t\tfloat y1 = vertices[i + 1];\r\n\r\n\t\t\tfloat x2;\r\n\t\t\tfloat y2;\r\n\r\n\t\t\tx2 = vertices[i + 2];\r\n\t\t\ty2 = vertices[i + 3];\r\n\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x1, y1, 0);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x2, y2, 0);\r\n\t\t}\r\n\t}","id":6218,"modified_method":"/** Draws a polyline in the x/y plane using {@link ShapeType#Line}. The vertices must contain at least 2 points (4 floats x,y). */\r\n\tpublic void polyline (float[] vertices, int offset, int count) {\r\n\t\tif (count < 4) throw new IllegalArgumentException(\"Polylines must contain at least 2 points.\");\r\n\t\tif (count % 2 != 0) throw new IllegalArgumentException(\"Polylines must have an even number of vertices.\");\r\n\r\n\t\tcheck(ShapeType.Line, null, count);\r\n\t\tfloat colorBits = color.toFloatBits();\r\n\t\tfor (int i = offset, n = offset + count - 2; i < n; i += 2) {\r\n\t\t\tfloat x1 = vertices[i];\r\n\t\t\tfloat y1 = vertices[i + 1];\r\n\r\n\t\t\tfloat x2;\r\n\t\t\tfloat y2;\r\n\r\n\t\t\tx2 = vertices[i + 2];\r\n\t\t\ty2 = vertices[i + 3];\r\n\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x1, y1, 0);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x2, y2, 0);\r\n\t\t}\r\n\t}","commit_id":"6c0ef51e9e769219abdcb6d6f93c3d267b0c2202","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Draws a cube using {@link ShapeType#Line} or {@link ShapeType#Filled}. The x, y and z specify the bottom, left, front corner\r\n\t * of the rectangle. */\r\n\tpublic void box (float x, float y, float z, float width, float height, float depth) {\r\n\t\tdepth = -depth;\r\n\r\n\t\tif (shapeType == ShapeType.Line) {\r\n\t\t\tcheck(ShapeType.Line, ShapeType.Filled, 24);\r\n\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y, z);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y, z);\r\n\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y, z);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y, z + depth);\r\n\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y, z + depth);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y, z + depth);\r\n\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y, z + depth);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y, z);\r\n\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y, z);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y + height, z);\r\n\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y + height, z);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y + height, z);\r\n\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y + height, z);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y + height, z + depth);\r\n\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y + height, z + depth);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y + height, z + depth);\r\n\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y + height, z + depth);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y + height, z);\r\n\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y, z);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y + height, z);\r\n\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y, z + depth);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y + height, z + depth);\r\n\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y, z + depth);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y + height, z + depth);\r\n\t\t} else {\r\n\t\t\tcheck(ShapeType.Line, ShapeType.Filled, 36);\r\n\r\n\t\t\t// Front\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y, z);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y, z);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y + height, z);\r\n\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y, z);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y + height, z);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y + height, z);\r\n\r\n\t\t\t// Back\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y, z + depth);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y, z + depth);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y + height, z + depth);\r\n\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y + height, z + depth);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y, z + depth);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y + height, z + depth);\r\n\r\n\t\t\t// Left\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y, z + depth);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y, z);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y + height, z);\r\n\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y, z + depth);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y + height, z);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y + height, z + depth);\r\n\r\n\t\t\t// Right\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y, z);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y, z + depth);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y + height, z + depth);\r\n\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y, z);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y + height, z + depth);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y + height, z);\r\n\r\n\t\t\t// Top\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y + height, z);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y + height, z);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y + height, z + depth);\r\n\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y + height, z);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y + height, z + depth);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y + height, z + depth);\r\n\r\n\t\t\t// Bottom\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y, z + depth);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y, z + depth);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y, z);\r\n\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y, z + depth);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y, z);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y, z);\r\n\t\t}\r\n\r\n\t}","id":6219,"modified_method":"/** Draws a cube using {@link ShapeType#Line} or {@link ShapeType#Filled}. The x, y and z specify the bottom, left, front corner\r\n\t * of the rectangle. */\r\n\tpublic void box (float x, float y, float z, float width, float height, float depth) {\r\n\t\tdepth = -depth;\r\n\t\tfloat colorBits = color.toFloatBits();\r\n\t\tif (shapeType == ShapeType.Line) {\r\n\t\t\tcheck(ShapeType.Line, ShapeType.Filled, 24);\r\n\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y, z);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y, z);\r\n\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y, z);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y, z + depth);\r\n\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y, z + depth);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y, z + depth);\r\n\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y, z + depth);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y, z);\r\n\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y, z);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y + height, z);\r\n\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y + height, z);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y + height, z);\r\n\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y + height, z);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y + height, z + depth);\r\n\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y + height, z + depth);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y + height, z + depth);\r\n\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y + height, z + depth);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y + height, z);\r\n\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y, z);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y + height, z);\r\n\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y, z + depth);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y + height, z + depth);\r\n\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y, z + depth);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y + height, z + depth);\r\n\t\t} else {\r\n\t\t\tcheck(ShapeType.Line, ShapeType.Filled, 36);\r\n\r\n\t\t\t// Front\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y, z);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y, z);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y + height, z);\r\n\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y, z);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y + height, z);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y + height, z);\r\n\r\n\t\t\t// Back\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y, z + depth);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y, z + depth);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y + height, z + depth);\r\n\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y + height, z + depth);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y, z + depth);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y + height, z + depth);\r\n\r\n\t\t\t// Left\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y, z + depth);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y, z);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y + height, z);\r\n\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y, z + depth);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y + height, z);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y + height, z + depth);\r\n\r\n\t\t\t// Right\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y, z);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y, z + depth);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y + height, z + depth);\r\n\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y, z);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y + height, z + depth);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y + height, z);\r\n\r\n\t\t\t// Top\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y + height, z);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y + height, z);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y + height, z + depth);\r\n\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y + height, z);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y + height, z + depth);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y + height, z + depth);\r\n\r\n\t\t\t// Bottom\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y, z + depth);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y, z + depth);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y, z);\r\n\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y, z + depth);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y, z);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y, z);\r\n\t\t}\r\n\r\n\t}","commit_id":"6c0ef51e9e769219abdcb6d6f93c3d267b0c2202","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Draws an ellipse using {@link ShapeType#Line} or {@link ShapeType#Filled}. */\r\n\tpublic void ellipse (float x, float y, float width, float height, int segments) {\r\n\t\tif (segments <= 0) throw new IllegalArgumentException(\"segments must be > 0.\");\r\n\t\tcheck(ShapeType.Line, ShapeType.Filled, segments * 3);\r\n\r\n\t\tfloat angle = 2 * MathUtils.PI / segments;\r\n\r\n\t\tfloat cx = x + width / 2, cy = y + height / 2;\r\n\t\tif (shapeType == ShapeType.Line) {\r\n\t\t\tfor (int i = 0; i < segments; i++) {\r\n\t\t\t\trenderer.color(color);\r\n\t\t\t\trenderer.vertex(cx + (width * 0.5f * MathUtils.cos(i * angle)), cy + (height * 0.5f * MathUtils.sin(i * angle)), 0);\r\n\r\n\t\t\t\trenderer.color(color);\r\n\t\t\t\trenderer.vertex(cx + (width * 0.5f * MathUtils.cos((i + 1) * angle)),\r\n\t\t\t\t\tcy + (height * 0.5f * MathUtils.sin((i + 1) * angle)), 0);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (int i = 0; i < segments; i++) {\r\n\t\t\t\trenderer.color(color);\r\n\t\t\t\trenderer.vertex(cx + (width * 0.5f * MathUtils.cos(i * angle)), cy + (height * 0.5f * MathUtils.sin(i * angle)), 0);\r\n\r\n\t\t\t\trenderer.color(color);\r\n\t\t\t\trenderer.vertex(cx, cy, 0);\r\n\r\n\t\t\t\trenderer.color(color);\r\n\t\t\t\trenderer.vertex(cx + (width * 0.5f * MathUtils.cos((i + 1) * angle)),\r\n\t\t\t\t\tcy + (height * 0.5f * MathUtils.sin((i + 1) * angle)), 0);\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":6220,"modified_method":"/** Draws an ellipse using {@link ShapeType#Line} or {@link ShapeType#Filled}. */\r\n\tpublic void ellipse (float x, float y, float width, float height, int segments) {\r\n\t\tif (segments <= 0) throw new IllegalArgumentException(\"segments must be > 0.\");\r\n\t\tcheck(ShapeType.Line, ShapeType.Filled, segments * 3);\r\n\t\tfloat colorBits = color.toFloatBits();\r\n\t\tfloat angle = 2 * MathUtils.PI / segments;\r\n\r\n\t\tfloat cx = x + width / 2, cy = y + height / 2;\r\n\t\tif (shapeType == ShapeType.Line) {\r\n\t\t\tfor (int i = 0; i < segments; i++) {\r\n\t\t\t\trenderer.color(colorBits);\r\n\t\t\t\trenderer.vertex(cx + (width * 0.5f * MathUtils.cos(i * angle)), cy + (height * 0.5f * MathUtils.sin(i * angle)), 0);\r\n\r\n\t\t\t\trenderer.color(colorBits);\r\n\t\t\t\trenderer.vertex(cx + (width * 0.5f * MathUtils.cos((i + 1) * angle)),\r\n\t\t\t\t\tcy + (height * 0.5f * MathUtils.sin((i + 1) * angle)), 0);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (int i = 0; i < segments; i++) {\r\n\t\t\t\trenderer.color(colorBits);\r\n\t\t\t\trenderer.vertex(cx + (width * 0.5f * MathUtils.cos(i * angle)), cy + (height * 0.5f * MathUtils.sin(i * angle)), 0);\r\n\r\n\t\t\t\trenderer.color(colorBits);\r\n\t\t\t\trenderer.vertex(cx, cy, 0);\r\n\r\n\t\t\t\trenderer.color(colorBits);\r\n\t\t\t\trenderer.vertex(cx + (width * 0.5f * MathUtils.cos((i + 1) * angle)),\r\n\t\t\t\t\tcy + (height * 0.5f * MathUtils.sin((i + 1) * angle)), 0);\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"6c0ef51e9e769219abdcb6d6f93c3d267b0c2202","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Draws a circle using {@link ShapeType#Line} or {@link ShapeType#Filled}. */\r\n\tpublic void circle (float x, float y, float radius, int segments) {\r\n\t\tif (segments <= 0) throw new IllegalArgumentException(\"segments must be > 0.\");\r\n\r\n\t\tfloat angle = 2 * MathUtils.PI / segments;\r\n\t\tfloat cos = MathUtils.cos(angle);\r\n\t\tfloat sin = MathUtils.sin(angle);\r\n\t\tfloat cx = radius, cy = 0;\r\n\t\tif (shapeType == ShapeType.Line) {\r\n\t\t\tcheck(ShapeType.Line, ShapeType.Filled, segments * 2 + 2);\r\n\t\t\tfor (int i = 0; i < segments; i++) {\r\n\t\t\t\trenderer.color(color);\r\n\t\t\t\trenderer.vertex(x + cx, y + cy, 0);\r\n\t\t\t\tfloat temp = cx;\r\n\t\t\t\tcx = cos * cx - sin * cy;\r\n\t\t\t\tcy = sin * temp + cos * cy;\r\n\t\t\t\trenderer.color(color);\r\n\t\t\t\trenderer.vertex(x + cx, y + cy, 0);\r\n\t\t\t}\r\n\t\t\t// Ensure the last segment is identical to the first.\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + cx, y + cy, 0);\r\n\t\t} else {\r\n\t\t\tcheck(ShapeType.Line, ShapeType.Filled, segments * 3 + 3);\r\n\t\t\tsegments--;\r\n\t\t\tfor (int i = 0; i < segments; i++) {\r\n\t\t\t\trenderer.color(color);\r\n\t\t\t\trenderer.vertex(x, y, 0);\r\n\t\t\t\trenderer.color(color);\r\n\t\t\t\trenderer.vertex(x + cx, y + cy, 0);\r\n\t\t\t\tfloat temp = cx;\r\n\t\t\t\tcx = cos * cx - sin * cy;\r\n\t\t\t\tcy = sin * temp + cos * cy;\r\n\t\t\t\trenderer.color(color);\r\n\t\t\t\trenderer.vertex(x + cx, y + cy, 0);\r\n\t\t\t}\r\n\t\t\t// Ensure the last segment is identical to the first.\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y, 0);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + cx, y + cy, 0);\r\n\t\t}\r\n\r\n\t\tfloat temp = cx;\r\n\t\tcx = radius;\r\n\t\tcy = 0;\r\n\t\trenderer.color(color);\r\n\t\trenderer.vertex(x + cx, y + cy, 0);\r\n\t}","id":6221,"modified_method":"/** Draws a circle using {@link ShapeType#Line} or {@link ShapeType#Filled}. */\r\n\tpublic void circle (float x, float y, float radius, int segments) {\r\n\t\tif (segments <= 0) throw new IllegalArgumentException(\"segments must be > 0.\");\r\n\t\tfloat colorBits = color.toFloatBits();\r\n\t\tfloat angle = 2 * MathUtils.PI / segments;\r\n\t\tfloat cos = MathUtils.cos(angle);\r\n\t\tfloat sin = MathUtils.sin(angle);\r\n\t\tfloat cx = radius, cy = 0;\r\n\t\tif (shapeType == ShapeType.Line) {\r\n\t\t\tcheck(ShapeType.Line, ShapeType.Filled, segments * 2 + 2);\r\n\t\t\tfor (int i = 0; i < segments; i++) {\r\n\t\t\t\trenderer.color(colorBits);\r\n\t\t\t\trenderer.vertex(x + cx, y + cy, 0);\r\n\t\t\t\tfloat temp = cx;\r\n\t\t\t\tcx = cos * cx - sin * cy;\r\n\t\t\t\tcy = sin * temp + cos * cy;\r\n\t\t\t\trenderer.color(colorBits);\r\n\t\t\t\trenderer.vertex(x + cx, y + cy, 0);\r\n\t\t\t}\r\n\t\t\t// Ensure the last segment is identical to the first.\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + cx, y + cy, 0);\r\n\t\t} else {\r\n\t\t\tcheck(ShapeType.Line, ShapeType.Filled, segments * 3 + 3);\r\n\t\t\tsegments--;\r\n\t\t\tfor (int i = 0; i < segments; i++) {\r\n\t\t\t\trenderer.color(colorBits);\r\n\t\t\t\trenderer.vertex(x, y, 0);\r\n\t\t\t\trenderer.color(colorBits);\r\n\t\t\t\trenderer.vertex(x + cx, y + cy, 0);\r\n\t\t\t\tfloat temp = cx;\r\n\t\t\t\tcx = cos * cx - sin * cy;\r\n\t\t\t\tcy = sin * temp + cos * cy;\r\n\t\t\t\trenderer.color(colorBits);\r\n\t\t\t\trenderer.vertex(x + cx, y + cy, 0);\r\n\t\t\t}\r\n\t\t\t// Ensure the last segment is identical to the first.\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y, 0);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + cx, y + cy, 0);\r\n\t\t}\r\n\r\n\t\tfloat temp = cx;\r\n\t\tcx = radius;\r\n\t\tcy = 0;\r\n\t\trenderer.color(colorBits);\r\n\t\trenderer.vertex(x + cx, y + cy, 0);\r\n\t}","commit_id":"6c0ef51e9e769219abdcb6d6f93c3d267b0c2202","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Draws a cone using {@link ShapeType#Line} or {@link ShapeType#Filled}. */\r\n\tpublic void cone (float x, float y, float z, float radius, float height, int segments) {\r\n\t\tif (segments <= 0) throw new IllegalArgumentException(\"segments must be > 0.\");\r\n\t\tcheck(ShapeType.Line, ShapeType.Filled, segments * 4 + 2);\r\n\r\n\t\tfloat angle = 2 * MathUtils.PI / segments;\r\n\t\tfloat cos = MathUtils.cos(angle);\r\n\t\tfloat sin = MathUtils.sin(angle);\r\n\t\tfloat cx = radius, cy = 0;\r\n\t\tif (shapeType == ShapeType.Line) {\r\n\t\t\tfor (int i = 0; i < segments; i++) {\r\n\t\t\t\trenderer.color(color);\r\n\t\t\t\trenderer.vertex(x + cx, y + cy, z);\r\n\t\t\t\trenderer.color(color);\r\n\t\t\t\trenderer.vertex(x, y, z + height);\r\n\t\t\t\trenderer.color(color);\r\n\t\t\t\trenderer.vertex(x + cx, y + cy, z);\r\n\t\t\t\tfloat temp = cx;\r\n\t\t\t\tcx = cos * cx - sin * cy;\r\n\t\t\t\tcy = sin * temp + cos * cy;\r\n\t\t\t\trenderer.color(color);\r\n\t\t\t\trenderer.vertex(x + cx, y + cy, z);\r\n\t\t\t}\r\n\t\t\t// Ensure the last segment is identical to the first.\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + cx, y + cy, z);\r\n\t\t} else {\r\n\t\t\tsegments--;\r\n\t\t\tfor (int i = 0; i < segments; i++) {\r\n\t\t\t\trenderer.color(color);\r\n\t\t\t\trenderer.vertex(x, y, z);\r\n\t\t\t\trenderer.color(color);\r\n\t\t\t\trenderer.vertex(x + cx, y + cy, z);\r\n\t\t\t\tfloat temp = cx;\r\n\t\t\t\tfloat temp2 = cy;\r\n\t\t\t\tcx = cos * cx - sin * cy;\r\n\t\t\t\tcy = sin * temp + cos * cy;\r\n\t\t\t\trenderer.color(color);\r\n\t\t\t\trenderer.vertex(x + cx, y + cy, z);\r\n\r\n\t\t\t\trenderer.color(color);\r\n\t\t\t\trenderer.vertex(x + temp, y + temp2, z);\r\n\t\t\t\trenderer.color(color);\r\n\t\t\t\trenderer.vertex(x + cx, y + cy, z);\r\n\t\t\t\trenderer.color(color);\r\n\t\t\t\trenderer.vertex(x, y, z + height);\r\n\t\t\t}\r\n\t\t\t// Ensure the last segment is identical to the first.\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y, z);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + cx, y + cy, z);\r\n\t\t}\r\n\t\tfloat temp = cx;\r\n\t\tfloat temp2 = cy;\r\n\t\tcx = radius;\r\n\t\tcy = 0;\r\n\t\trenderer.color(color);\r\n\t\trenderer.vertex(x + cx, y + cy, z);\r\n\t\tif (shapeType != ShapeType.Line) {\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + temp, y + temp2, z);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + cx, y + cy, z);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y, z + height);\r\n\t\t}\r\n\t}","id":6222,"modified_method":"/** Draws a cone using {@link ShapeType#Line} or {@link ShapeType#Filled}. */\r\n\tpublic void cone (float x, float y, float z, float radius, float height, int segments) {\r\n\t\tif (segments <= 0) throw new IllegalArgumentException(\"segments must be > 0.\");\r\n\t\tcheck(ShapeType.Line, ShapeType.Filled, segments * 4 + 2);\r\n\t\tfloat colorBits = color.toFloatBits();\r\n\t\tfloat angle = 2 * MathUtils.PI / segments;\r\n\t\tfloat cos = MathUtils.cos(angle);\r\n\t\tfloat sin = MathUtils.sin(angle);\r\n\t\tfloat cx = radius, cy = 0;\r\n\t\tif (shapeType == ShapeType.Line) {\r\n\t\t\tfor (int i = 0; i < segments; i++) {\r\n\t\t\t\trenderer.color(colorBits);\r\n\t\t\t\trenderer.vertex(x + cx, y + cy, z);\r\n\t\t\t\trenderer.color(colorBits);\r\n\t\t\t\trenderer.vertex(x, y, z + height);\r\n\t\t\t\trenderer.color(colorBits);\r\n\t\t\t\trenderer.vertex(x + cx, y + cy, z);\r\n\t\t\t\tfloat temp = cx;\r\n\t\t\t\tcx = cos * cx - sin * cy;\r\n\t\t\t\tcy = sin * temp + cos * cy;\r\n\t\t\t\trenderer.color(colorBits);\r\n\t\t\t\trenderer.vertex(x + cx, y + cy, z);\r\n\t\t\t}\r\n\t\t\t// Ensure the last segment is identical to the first.\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + cx, y + cy, z);\r\n\t\t} else {\r\n\t\t\tsegments--;\r\n\t\t\tfor (int i = 0; i < segments; i++) {\r\n\t\t\t\trenderer.color(colorBits);\r\n\t\t\t\trenderer.vertex(x, y, z);\r\n\t\t\t\trenderer.color(colorBits);\r\n\t\t\t\trenderer.vertex(x + cx, y + cy, z);\r\n\t\t\t\tfloat temp = cx;\r\n\t\t\t\tfloat temp2 = cy;\r\n\t\t\t\tcx = cos * cx - sin * cy;\r\n\t\t\t\tcy = sin * temp + cos * cy;\r\n\t\t\t\trenderer.color(colorBits);\r\n\t\t\t\trenderer.vertex(x + cx, y + cy, z);\r\n\r\n\t\t\t\trenderer.color(colorBits);\r\n\t\t\t\trenderer.vertex(x + temp, y + temp2, z);\r\n\t\t\t\trenderer.color(colorBits);\r\n\t\t\t\trenderer.vertex(x + cx, y + cy, z);\r\n\t\t\t\trenderer.color(colorBits);\r\n\t\t\t\trenderer.vertex(x, y, z + height);\r\n\t\t\t}\r\n\t\t\t// Ensure the last segment is identical to the first.\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y, z);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + cx, y + cy, z);\r\n\t\t}\r\n\t\tfloat temp = cx;\r\n\t\tfloat temp2 = cy;\r\n\t\tcx = radius;\r\n\t\tcy = 0;\r\n\t\trenderer.color(colorBits);\r\n\t\trenderer.vertex(x + cx, y + cy, z);\r\n\t\tif (shapeType != ShapeType.Line) {\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + temp, y + temp2, z);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + cx, y + cy, z);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y, z + height);\r\n\t\t}\r\n\t}","commit_id":"6c0ef51e9e769219abdcb6d6f93c3d267b0c2202","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Draws a rectangle in the x/y plane using {@link ShapeType#Line} or {@link ShapeType#Filled}. */\r\n\tpublic void rect (float x, float y, float width, float height) {\r\n\t\tcheck(ShapeType.Line, ShapeType.Filled, 8);\r\n\r\n\t\tif (shapeType == ShapeType.Line) {\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y, 0);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y, 0);\r\n\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y, 0);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y + height, 0);\r\n\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y + height, 0);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y + height, 0);\r\n\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y + height, 0);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y, 0);\r\n\t\t} else {\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y, 0);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y, 0);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y + height, 0);\r\n\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + width, y + height, 0);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y + height, 0);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y, 0);\r\n\t\t}\r\n\t}","id":6223,"modified_method":"/** Draws a rectangle in the x/y plane using {@link ShapeType#Line} or {@link ShapeType#Filled}. */\r\n\tpublic void rect (float x, float y, float width, float height) {\r\n\t\tcheck(ShapeType.Line, ShapeType.Filled, 8);\r\n\t\tfloat colorBits = color.toFloatBits();\r\n\t\tif (shapeType == ShapeType.Line) {\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y, 0);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y, 0);\r\n\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y, 0);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y + height, 0);\r\n\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y + height, 0);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y + height, 0);\r\n\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y + height, 0);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y, 0);\r\n\t\t} else {\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y, 0);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y, 0);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y + height, 0);\r\n\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + width, y + height, 0);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y + height, 0);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y, 0);\r\n\t\t}\r\n\t}","commit_id":"6c0ef51e9e769219abdcb6d6f93c3d267b0c2202","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Draws a line using a rotated rectangle, where with one edge is centered at x1, y1 and the opposite edge centered at x2, y2. */\r\n\tpublic void rectLine (float x1, float y1, float x2, float y2, float width) {\r\n\t\tcheck(ShapeType.Line, ShapeType.Filled, 8);\r\n\r\n\t\tVector2 t = tmp.set(y2 - y1, x1 - x2).nor();\r\n\t\twidth *= 0.5f;\r\n\t\tfloat tx = t.x * width;\r\n\t\tfloat ty = t.y * width;\r\n\t\tif (shapeType == ShapeType.Line) {\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x1 + tx, y1 + ty, 0);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x1 - tx, y1 - ty, 0);\r\n\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x2 + tx, y2 + ty, 0);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x2 - tx, y2 - ty, 0);\r\n\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x2 + tx, y2 + ty, 0);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x1 + tx, y1 + ty, 0);\r\n\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x2 - tx, y2 - ty, 0);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x1 - tx, y1 - ty, 0);\r\n\t\t} else {\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x1 + tx, y1 + ty, 0);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x1 - tx, y1 - ty, 0);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x2 + tx, y2 + ty, 0);\r\n\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x2 - tx, y2 - ty, 0);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x2 + tx, y2 + ty, 0);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x1 - tx, y1 - ty, 0);\r\n\t\t}\r\n\t}","id":6224,"modified_method":"/** Draws a line using a rotated rectangle, where with one edge is centered at x1, y1 and the opposite edge centered at x2, y2. */\r\n\tpublic void rectLine (float x1, float y1, float x2, float y2, float width) {\r\n\t\tcheck(ShapeType.Line, ShapeType.Filled, 8);\r\n\t\tfloat colorBits = color.toFloatBits();\r\n\t\tVector2 t = tmp.set(y2 - y1, x1 - x2).nor();\r\n\t\twidth *= 0.5f;\r\n\t\tfloat tx = t.x * width;\r\n\t\tfloat ty = t.y * width;\r\n\t\tif (shapeType == ShapeType.Line) {\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x1 + tx, y1 + ty, 0);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x1 - tx, y1 - ty, 0);\r\n\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x2 + tx, y2 + ty, 0);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x2 - tx, y2 - ty, 0);\r\n\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x2 + tx, y2 + ty, 0);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x1 + tx, y1 + ty, 0);\r\n\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x2 - tx, y2 - ty, 0);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x1 - tx, y1 - ty, 0);\r\n\t\t} else {\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x1 + tx, y1 + ty, 0);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x1 - tx, y1 - ty, 0);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x2 + tx, y2 + ty, 0);\r\n\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x2 - tx, y2 - ty, 0);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x2 + tx, y2 + ty, 0);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x1 - tx, y1 - ty, 0);\r\n\t\t}\r\n\t}","commit_id":"6c0ef51e9e769219abdcb6d6f93c3d267b0c2202","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Draws a polygon in the x/y plane using {@link ShapeType#Line}. The vertices must contain at least 3 points (6 floats x,y). */\r\n\tpublic void polygon (float[] vertices, int offset, int count) {\r\n\t\tif (count < 6) throw new IllegalArgumentException(\"Polygons must contain at least 3 points.\");\r\n\t\tif (count % 2 != 0) throw new IllegalArgumentException(\"Polygons must have an even number of vertices.\");\r\n\r\n\t\tcheck(ShapeType.Line, null, count);\r\n\r\n\t\tfloat firstX = vertices[0];\r\n\t\tfloat firstY = vertices[1];\r\n\r\n\t\tfor (int i = offset, n = offset + count; i < n; i += 2) {\r\n\t\t\tfloat x1 = vertices[i];\r\n\t\t\tfloat y1 = vertices[i + 1];\r\n\r\n\t\t\tfloat x2;\r\n\t\t\tfloat y2;\r\n\r\n\t\t\tif (i + 2 >= count) {\r\n\t\t\t\tx2 = firstX;\r\n\t\t\t\ty2 = firstY;\r\n\t\t\t} else {\r\n\t\t\t\tx2 = vertices[i + 2];\r\n\t\t\t\ty2 = vertices[i + 3];\r\n\t\t\t}\r\n\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x1, y1, 0);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x2, y2, 0);\r\n\t\t}\r\n\t}","id":6225,"modified_method":"/** Draws a polygon in the x/y plane using {@link ShapeType#Line}. The vertices must contain at least 3 points (6 floats x,y). */\r\n\tpublic void polygon (float[] vertices, int offset, int count) {\r\n\t\tif (count < 6) throw new IllegalArgumentException(\"Polygons must contain at least 3 points.\");\r\n\t\tif (count % 2 != 0) throw new IllegalArgumentException(\"Polygons must have an even number of vertices.\");\r\n\r\n\t\tcheck(ShapeType.Line, null, count);\r\n\t\tfloat colorBits = color.toFloatBits();\r\n\t\tfloat firstX = vertices[0];\r\n\t\tfloat firstY = vertices[1];\r\n\r\n\t\tfor (int i = offset, n = offset + count; i < n; i += 2) {\r\n\t\t\tfloat x1 = vertices[i];\r\n\t\t\tfloat y1 = vertices[i + 1];\r\n\r\n\t\t\tfloat x2;\r\n\t\t\tfloat y2;\r\n\r\n\t\t\tif (i + 2 >= count) {\r\n\t\t\t\tx2 = firstX;\r\n\t\t\t\ty2 = firstY;\r\n\t\t\t} else {\r\n\t\t\t\tx2 = vertices[i + 2];\r\n\t\t\t\ty2 = vertices[i + 3];\r\n\t\t\t}\r\n\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x1, y1, 0);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x2, y2, 0);\r\n\t\t}\r\n\t}","commit_id":"6c0ef51e9e769219abdcb6d6f93c3d267b0c2202","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Draws a curve using {@link ShapeType#Line}. */\r\n\tpublic void curve (float x1, float y1, float cx1, float cy1, float cx2, float cy2, float x2, float y2, int segments) {\r\n\t\tcheck(ShapeType.Line, null, segments * 2 + 2);\r\n\r\n\t\t// Algorithm from: http://www.antigrain.com/research/bezier_interpolation/index.html#PAGE_BEZIER_INTERPOLATION\r\n\t\tfloat subdiv_step = 1f / segments;\r\n\t\tfloat subdiv_step2 = subdiv_step * subdiv_step;\r\n\t\tfloat subdiv_step3 = subdiv_step * subdiv_step * subdiv_step;\r\n\r\n\t\tfloat pre1 = 3 * subdiv_step;\r\n\t\tfloat pre2 = 3 * subdiv_step2;\r\n\t\tfloat pre4 = 6 * subdiv_step2;\r\n\t\tfloat pre5 = 6 * subdiv_step3;\r\n\r\n\t\tfloat tmp1x = x1 - cx1 * 2 + cx2;\r\n\t\tfloat tmp1y = y1 - cy1 * 2 + cy2;\r\n\r\n\t\tfloat tmp2x = (cx1 - cx2) * 3 - x1 + x2;\r\n\t\tfloat tmp2y = (cy1 - cy2) * 3 - y1 + y2;\r\n\r\n\t\tfloat fx = x1;\r\n\t\tfloat fy = y1;\r\n\r\n\t\tfloat dfx = (cx1 - x1) * pre1 + tmp1x * pre2 + tmp2x * subdiv_step3;\r\n\t\tfloat dfy = (cy1 - y1) * pre1 + tmp1y * pre2 + tmp2y * subdiv_step3;\r\n\r\n\t\tfloat ddfx = tmp1x * pre4 + tmp2x * pre5;\r\n\t\tfloat ddfy = tmp1y * pre4 + tmp2y * pre5;\r\n\r\n\t\tfloat dddfx = tmp2x * pre5;\r\n\t\tfloat dddfy = tmp2y * pre5;\r\n\r\n\t\twhile (segments-- > 0) {\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(fx, fy, 0);\r\n\t\t\tfx += dfx;\r\n\t\t\tfy += dfy;\r\n\t\t\tdfx += ddfx;\r\n\t\t\tdfy += ddfy;\r\n\t\t\tddfx += dddfx;\r\n\t\t\tddfy += dddfy;\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(fx, fy, 0);\r\n\t\t}\r\n\t\trenderer.color(color);\r\n\t\trenderer.vertex(fx, fy, 0);\r\n\t\trenderer.color(color);\r\n\t\trenderer.vertex(x2, y2, 0);\r\n\t}","id":6226,"modified_method":"/** Draws a curve using {@link ShapeType#Line}. */\r\n\tpublic void curve (float x1, float y1, float cx1, float cy1, float cx2, float cy2, float x2, float y2, int segments) {\r\n\t\tcheck(ShapeType.Line, null, segments * 2 + 2);\r\n\t\tfloat colorBits = color.toFloatBits();\r\n\t\t\r\n\t\t// Algorithm from: http://www.antigrain.com/research/bezier_interpolation/index.html#PAGE_BEZIER_INTERPOLATION\r\n\t\tfloat subdiv_step = 1f / segments;\r\n\t\tfloat subdiv_step2 = subdiv_step * subdiv_step;\r\n\t\tfloat subdiv_step3 = subdiv_step * subdiv_step * subdiv_step;\r\n\r\n\t\tfloat pre1 = 3 * subdiv_step;\r\n\t\tfloat pre2 = 3 * subdiv_step2;\r\n\t\tfloat pre4 = 6 * subdiv_step2;\r\n\t\tfloat pre5 = 6 * subdiv_step3;\r\n\r\n\t\tfloat tmp1x = x1 - cx1 * 2 + cx2;\r\n\t\tfloat tmp1y = y1 - cy1 * 2 + cy2;\r\n\r\n\t\tfloat tmp2x = (cx1 - cx2) * 3 - x1 + x2;\r\n\t\tfloat tmp2y = (cy1 - cy2) * 3 - y1 + y2;\r\n\r\n\t\tfloat fx = x1;\r\n\t\tfloat fy = y1;\r\n\r\n\t\tfloat dfx = (cx1 - x1) * pre1 + tmp1x * pre2 + tmp2x * subdiv_step3;\r\n\t\tfloat dfy = (cy1 - y1) * pre1 + tmp1y * pre2 + tmp2y * subdiv_step3;\r\n\r\n\t\tfloat ddfx = tmp1x * pre4 + tmp2x * pre5;\r\n\t\tfloat ddfy = tmp1y * pre4 + tmp2y * pre5;\r\n\r\n\t\tfloat dddfx = tmp2x * pre5;\r\n\t\tfloat dddfy = tmp2y * pre5;\r\n\r\n\t\twhile (segments-- > 0) {\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(fx, fy, 0);\r\n\t\t\tfx += dfx;\r\n\t\t\tfy += dfy;\r\n\t\t\tdfx += ddfx;\r\n\t\t\tdfy += ddfy;\r\n\t\t\tddfx += dddfx;\r\n\t\t\tddfy += dddfy;\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(fx, fy, 0);\r\n\t\t}\r\n\t\trenderer.color(colorBits);\r\n\t\trenderer.vertex(fx, fy, 0);\r\n\t\trenderer.color(colorBits);\r\n\t\trenderer.vertex(x2, y2, 0);\r\n\t}","commit_id":"6c0ef51e9e769219abdcb6d6f93c3d267b0c2202","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Draws an arc using {@link ShapeType#Line} or {@link ShapeType#Filled}. */\r\n\tpublic void arc (float x, float y, float radius, float start, float degrees, int segments) {\r\n\t\tif (segments <= 0) throw new IllegalArgumentException(\"segments must be > 0.\");\r\n\r\n\t\tfloat theta = (2 * MathUtils.PI * (degrees / 360.0f)) / segments;\r\n\t\tfloat cos = MathUtils.cos(theta);\r\n\t\tfloat sin = MathUtils.sin(theta);\r\n\t\tfloat cx = radius * MathUtils.cos(start * MathUtils.degreesToRadians);\r\n\t\tfloat cy = radius * MathUtils.sin(start * MathUtils.degreesToRadians);\r\n\r\n\t\tif (shapeType == ShapeType.Line) {\r\n\t\t\tcheck(ShapeType.Line, ShapeType.Filled, segments * 2 + 2);\r\n\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y, 0);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + cx, y + cy, 0);\r\n\t\t\tfor (int i = 0; i < segments; i++) {\r\n\t\t\t\trenderer.color(color);\r\n\t\t\t\trenderer.vertex(x + cx, y + cy, 0);\r\n\t\t\t\tfloat temp = cx;\r\n\t\t\t\tcx = cos * cx - sin * cy;\r\n\t\t\t\tcy = sin * temp + cos * cy;\r\n\t\t\t\trenderer.color(color);\r\n\t\t\t\trenderer.vertex(x + cx, y + cy, 0);\r\n\t\t\t}\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + cx, y + cy, 0);\r\n\t\t} else {\r\n\t\t\tcheck(ShapeType.Line, ShapeType.Filled, segments * 3 + 3);\r\n\r\n\t\t\tfor (int i = 0; i < segments; i++) {\r\n\t\t\t\trenderer.color(color);\r\n\t\t\t\trenderer.vertex(x, y, 0);\r\n\t\t\t\trenderer.color(color);\r\n\t\t\t\trenderer.vertex(x + cx, y + cy, 0);\r\n\t\t\t\tfloat temp = cx;\r\n\t\t\t\tcx = cos * cx - sin * cy;\r\n\t\t\t\tcy = sin * temp + cos * cy;\r\n\t\t\t\trenderer.color(color);\r\n\t\t\t\trenderer.vertex(x + cx, y + cy, 0);\r\n\t\t\t}\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x, y, 0);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x + cx, y + cy, 0);\r\n\t\t}\r\n\r\n\t\tfloat temp = cx;\r\n\t\tcx = 0;\r\n\t\tcy = 0;\r\n\t\trenderer.color(color);\r\n\t\trenderer.vertex(x + cx, y + cy, 0);\r\n\t}","id":6227,"modified_method":"/** Draws an arc using {@link ShapeType#Line} or {@link ShapeType#Filled}. */\r\n\tpublic void arc (float x, float y, float radius, float start, float degrees, int segments) {\r\n\t\tif (segments <= 0) throw new IllegalArgumentException(\"segments must be > 0.\");\r\n\t\tfloat colorBits = color.toFloatBits();\r\n\t\tfloat theta = (2 * MathUtils.PI * (degrees / 360.0f)) / segments;\r\n\t\tfloat cos = MathUtils.cos(theta);\r\n\t\tfloat sin = MathUtils.sin(theta);\r\n\t\tfloat cx = radius * MathUtils.cos(start * MathUtils.degreesToRadians);\r\n\t\tfloat cy = radius * MathUtils.sin(start * MathUtils.degreesToRadians);\r\n\r\n\t\tif (shapeType == ShapeType.Line) {\r\n\t\t\tcheck(ShapeType.Line, ShapeType.Filled, segments * 2 + 2);\r\n\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y, 0);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + cx, y + cy, 0);\r\n\t\t\tfor (int i = 0; i < segments; i++) {\r\n\t\t\t\trenderer.color(colorBits);\r\n\t\t\t\trenderer.vertex(x + cx, y + cy, 0);\r\n\t\t\t\tfloat temp = cx;\r\n\t\t\t\tcx = cos * cx - sin * cy;\r\n\t\t\t\tcy = sin * temp + cos * cy;\r\n\t\t\t\trenderer.color(colorBits);\r\n\t\t\t\trenderer.vertex(x + cx, y + cy, 0);\r\n\t\t\t}\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + cx, y + cy, 0);\r\n\t\t} else {\r\n\t\t\tcheck(ShapeType.Line, ShapeType.Filled, segments * 3 + 3);\r\n\r\n\t\t\tfor (int i = 0; i < segments; i++) {\r\n\t\t\t\trenderer.color(colorBits);\r\n\t\t\t\trenderer.vertex(x, y, 0);\r\n\t\t\t\trenderer.color(colorBits);\r\n\t\t\t\trenderer.vertex(x + cx, y + cy, 0);\r\n\t\t\t\tfloat temp = cx;\r\n\t\t\t\tcx = cos * cx - sin * cy;\r\n\t\t\t\tcy = sin * temp + cos * cy;\r\n\t\t\t\trenderer.color(colorBits);\r\n\t\t\t\trenderer.vertex(x + cx, y + cy, 0);\r\n\t\t\t}\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x, y, 0);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x + cx, y + cy, 0);\r\n\t\t}\r\n\r\n\t\tfloat temp = cx;\r\n\t\tcx = 0;\r\n\t\tcy = 0;\r\n\t\trenderer.color(colorBits);\r\n\t\trenderer.vertex(x + cx, y + cy, 0);\r\n\t}","commit_id":"6c0ef51e9e769219abdcb6d6f93c3d267b0c2202","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Draws a triangle in x/y plane using {@link ShapeType#Line} or {@link ShapeType#Filled}. */\r\n\tpublic void triangle (float x1, float y1, float x2, float y2, float x3, float y3) {\r\n\t\tcheck(ShapeType.Line, ShapeType.Filled, 6);\r\n\t\tif (shapeType == ShapeType.Line) {\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x1, y1, 0);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x2, y2, 0);\r\n\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x2, y2, 0);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x3, y3, 0);\r\n\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x3, y3, 0);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x1, y1, 0);\r\n\t\t} else {\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x1, y1, 0);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x2, y2, 0);\r\n\t\t\trenderer.color(color);\r\n\t\t\trenderer.vertex(x3, y3, 0);\r\n\t\t}\r\n\t}","id":6228,"modified_method":"/** Draws a triangle in x/y plane using {@link ShapeType#Line} or {@link ShapeType#Filled}. */\r\n\tpublic void triangle (float x1, float y1, float x2, float y2, float x3, float y3) {\r\n\t\tcheck(ShapeType.Line, ShapeType.Filled, 6);\r\n\t\tfloat colorBits = color.toFloatBits();\r\n\t\tif (shapeType == ShapeType.Line) {\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x1, y1, 0);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x2, y2, 0);\r\n\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x2, y2, 0);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x3, y3, 0);\r\n\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x3, y3, 0);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x1, y1, 0);\r\n\t\t} else {\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x1, y1, 0);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x2, y2, 0);\r\n\t\t\trenderer.color(colorBits);\r\n\t\t\trenderer.vertex(x3, y3, 0);\r\n\t\t}\r\n\t}","commit_id":"6c0ef51e9e769219abdcb6d6f93c3d267b0c2202","url":"https://github.com/libgdx/libgdx"},{"original_method":"protected void initSelectStatement() {\n        String cql = generateSelect(table,\n                getAllColumns(),\n                pkColumns).toString();\n        LOGGER.debug(\"Generated Select {}\", cql);\n        selectStatement = applyConsistencyLevel(getSession().prepare(cql), readConsistencyLevel);\n    }","id":6229,"modified_method":"protected void initSelectStatement() {\n        Select select = generateSelect(table,\n                getAllColumns(),\n                pkColumns);\n        select = (Select) applyConsistencyLevel(select, readConsistencyLevel);\n        LOGGER.debug(\"Generated Select {}\", select);\n        selectStatement = getSession().prepare(select);\n    }","commit_id":"00f1014873a10ca800f6c9efdfdb12a82a09c8ee","url":"https://github.com/apache/camel"},{"original_method":"private void initInsertStatement() {\n        String cql = generateInsert(table,\n                getAllColumns(),\n                false, ttl).toString();\n        LOGGER.debug(\"Generated Insert {}\", cql);\n        insertStatement = applyConsistencyLevel(getSession().prepare(cql), writeConsistencyLevel);\n    }","id":6230,"modified_method":"private void initInsertStatement() {\n        Insert insert = generateInsert(table,\n                getAllColumns(),\n                false, ttl);\n        insert = applyConsistencyLevel(insert, writeConsistencyLevel);\n        LOGGER.debug(\"Generated Insert {}\", insert);\n        insertStatement = getSession().prepare(insert);\n    }","commit_id":"00f1014873a10ca800f6c9efdfdb12a82a09c8ee","url":"https://github.com/apache/camel"},{"original_method":"private void initDeleteIfIdStatement() {\n        StringBuilder cqlBuilder = generateDelete(table, pkColumns, false);\n        cqlBuilder.append(\" if \").append(exchangeIdColumn).append(\"=?\");\n        String cql = cqlBuilder.toString();\n        LOGGER.debug(\"Generated Delete If Id {}\", cql);\n        deleteIfIdStatement = applyConsistencyLevel(getSession().prepare(cql), writeConsistencyLevel);\n    }","id":6231,"modified_method":"private void initDeleteIfIdStatement() {\n        Delete delete = generateDelete(table, pkColumns, false);\n        Delete.Conditions deleteIf = delete.onlyIf(eq(exchangeIdColumn, bindMarker()));\n        deleteIf = applyConsistencyLevel(deleteIf, writeConsistencyLevel);\n        LOGGER.debug(\"Generated Delete If Id {}\", deleteIf);\n        deleteIfIdStatement = getSession().prepare(deleteIf);\n    }","commit_id":"00f1014873a10ca800f6c9efdfdb12a82a09c8ee","url":"https://github.com/apache/camel"},{"original_method":"private void initDeleteStatement() {\n        String cql = generateDelete(table, pkColumns, false).toString();\n        LOGGER.debug(\"Generated Delete {}\", cql);\n        deleteStatement = applyConsistencyLevel(getSession().prepare(cql), writeConsistencyLevel);\n    }","id":6232,"modified_method":"private void initDeleteStatement() {\n        Delete delete = generateDelete(table, pkColumns, false);\n        delete = applyConsistencyLevel(delete, writeConsistencyLevel);\n        LOGGER.debug(\"Generated Delete {}\", delete);\n        deleteStatement = getSession().prepare(delete);\n    }","commit_id":"00f1014873a10ca800f6c9efdfdb12a82a09c8ee","url":"https://github.com/apache/camel"},{"original_method":"private void initSelectKeyIdStatement() {\n        String cql = generateSelect(table,\n                new String[]{getKeyColumn(), exchangeIdColumn}, // Key + Exchange Id columns\n                pkColumns, pkColumns.length - 1).toString(); // Where fixed PK columns\n        LOGGER.debug(\"Generated Select keys {}\", cql);\n        selectKeyIdStatement = applyConsistencyLevel(getSession().prepare(cql), readConsistencyLevel);\n    }","id":6233,"modified_method":"private void initSelectKeyIdStatement() {\n        Select select = generateSelect(table,\n                new String[]{getKeyColumn(), exchangeIdColumn}, // Key + Exchange Id columns\n                pkColumns, pkColumns.length - 1); // Where fixed PK columns\n        select = applyConsistencyLevel(select, readConsistencyLevel);\n        LOGGER.debug(\"Generated Select keys {}\", select);\n        selectKeyIdStatement = getSession().prepare(select);\n    }","commit_id":"00f1014873a10ca800f6c9efdfdb12a82a09c8ee","url":"https://github.com/apache/camel"},{"original_method":"protected void initInsertStatement() {\n        String cql = generateInsert(table, pkColumns, true, ttl).toString();\n        LOGGER.debug(\"Generated Insert {}\", cql);\n        insertStatement = applyConsistencyLevel(getSession().prepare(cql), writeConsistencyLevel);\n    }","id":6234,"modified_method":"protected void initInsertStatement() {\n        Insert insert = generateInsert(table, pkColumns, true, ttl);\n        insert = applyConsistencyLevel(insert, writeConsistencyLevel);\n        LOGGER.debug(\"Generated Insert {}\", insert);\n        insertStatement = getSession().prepare(insert);\n    }","commit_id":"00f1014873a10ca800f6c9efdfdb12a82a09c8ee","url":"https://github.com/apache/camel"},{"original_method":"protected void initSelectStatement() {\n        String cql = generateSelect(table, pkColumns, pkColumns).toString();\n        LOGGER.debug(\"Generated Select {}\", cql);\n        selectStatement = applyConsistencyLevel(getSession().prepare(cql), readConsistencyLevel);\n    }","id":6235,"modified_method":"protected void initSelectStatement() {\n        Select select = generateSelect(table, pkColumns, pkColumns);\n        select = applyConsistencyLevel(select, readConsistencyLevel);\n        LOGGER.debug(\"Generated Select {}\", select);\n        selectStatement = getSession().prepare(select);\n    }","commit_id":"00f1014873a10ca800f6c9efdfdb12a82a09c8ee","url":"https://github.com/apache/camel"},{"original_method":"protected void initDeleteStatement() {\n        String cql = generateDelete(table, pkColumns, true).toString();\n        LOGGER.debug(\"Generated Delete {}\", cql);\n        deleteStatement = applyConsistencyLevel(getSession().prepare(cql), writeConsistencyLevel);\n    }","id":6236,"modified_method":"protected void initDeleteStatement() {\n        Delete delete = generateDelete(table, pkColumns, true);\n        delete = applyConsistencyLevel(delete, writeConsistencyLevel);\n        LOGGER.debug(\"Generated Delete {}\", delete);\n        deleteStatement = getSession().prepare(delete);\n    }","commit_id":"00f1014873a10ca800f6c9efdfdb12a82a09c8ee","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Apply consistency level if provided, else leave default.\n     */\n    public static PreparedStatement applyConsistencyLevel(PreparedStatement statement, ConsistencyLevel consistencyLevel) {\n        if (consistencyLevel != null) {\n            statement.setConsistencyLevel(consistencyLevel);\n        }\n        return statement;\n    }","id":6237,"modified_method":"/**\n     * Apply consistency level if provided, else leave default.\n     */\n    public static <T extends RegularStatement> T applyConsistencyLevel(T statement, ConsistencyLevel consistencyLevel) {\n        if (consistencyLevel != null) {\n            statement.setConsistencyLevel(consistencyLevel);\n        }\n        return statement;\n    }","commit_id":"00f1014873a10ca800f6c9efdfdb12a82a09c8ee","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Append where columns = ? to CQL.\n     */\n    public static void appendWhere(StringBuilder cqlBuilder, String[] columns, int maxColumnIndex) {\n        if (isEmpty(columns) || maxColumnIndex<= 0) {\n            return;\n        }\n        cqlBuilder.append(\" where \");\n        appendColumns(cqlBuilder, columns, \"=? and \", maxColumnIndex);\n        cqlBuilder.append(\"=?\");\n    }","id":6238,"modified_method":"private static boolean isWhereClause(String[] whereColumns, int whereColumnsMaxIndex) {\n        return !isEmpty(whereColumns) && whereColumnsMaxIndex > 0;\n    }","commit_id":"00f1014873a10ca800f6c9efdfdb12a82a09c8ee","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Generate delete where columns = ? CQL.\n     */\n    public static StringBuilder generateDelete(String table, String[] whereColumns, int whereColumnsMaxIndex, boolean ifExists) {\n        StringBuilder cqlBuilder = new StringBuilder(\"delete from \")\n                .append(table);\n        appendWhere(cqlBuilder, whereColumns, whereColumnsMaxIndex);\n        if (ifExists) {\n            cqlBuilder.append(\" if exists\");\n        }\n        return cqlBuilder;\n    }","id":6239,"modified_method":"/**\n     * Generate delete where columns = ? CQL.\n     */\n    public static Delete generateDelete(String table, String[] whereColumns, int whereColumnsMaxIndex, boolean ifExists) {\n        Delete delete = delete().from(table);\n        if (isWhereClause(whereColumns, whereColumnsMaxIndex)) {\n            Delete.Where where = delete.where();\n            for(int i = 0; i < whereColumns.length && i < whereColumnsMaxIndex; i++) {\n                where.and(eq(whereColumns[i], bindMarker()));\n            }\n        }\n        if (ifExists) {\n            delete = delete.ifExists();\n        }\n        return delete;\n    }","commit_id":"00f1014873a10ca800f6c9efdfdb12a82a09c8ee","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Generate Insert CQL.\n     */\n    public static StringBuilder generateInsert(String table, String[] columns, boolean ifNotExists, Integer ttl) {\n        StringBuilder cqlBuilder = new StringBuilder(\"insert into \")\n                .append(table).append(\"(\");\n        appendColumns(cqlBuilder, columns, \",\");\n        cqlBuilder.append(\") values (\");\n        appendPlaceholders(cqlBuilder, columns.length);\n        cqlBuilder.append(\")\");\n        if (ifNotExists) {\n            cqlBuilder.append(\" if not exists\");\n        }\n        if (ttl != null) {\n            cqlBuilder.append(\" using ttl=\").append(ttl);\n        }\n        return cqlBuilder;\n    }","id":6240,"modified_method":"/**\n     * Generate Insert CQL.\n     */\n    public static Insert generateInsert(String table, String[] columns, boolean ifNotExists, Integer ttl) {\n        Insert insert = insertInto(table);\n        for(String column: columns) {\n            insert = insert.value(column, bindMarker());\n        }\n        if (ifNotExists) {\n            insert = insert.ifNotExists();\n        }\n        if (ttl != null) {\n            insert.using(ttl(ttl));\n        }\n        return insert;\n    }","commit_id":"00f1014873a10ca800f6c9efdfdb12a82a09c8ee","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Generate delete where columns = ? CQL.\n     */\n    public static StringBuilder generateDelete(String table, String[] whereColumns, boolean ifExists) {\n        return generateDelete(table, whereColumns, size(whereColumns), ifExists);\n    }","id":6241,"modified_method":"/**\n     * Generate delete where columns = ? CQL.\n     */\n    public static Delete generateDelete(String table, String[] whereColumns, boolean ifExists) {\n        return generateDelete(table, whereColumns, size(whereColumns), ifExists);\n    }","commit_id":"00f1014873a10ca800f6c9efdfdb12a82a09c8ee","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Generate select where columns = ? CQL.\n     */\n    public static StringBuilder generateSelect(String table, String[] selectColumns, String[] whereColumns, int whereColumnsMaxIndex) {\n        StringBuilder cqlBuilder = new StringBuilder(\"select \");\n        appendColumns(cqlBuilder, selectColumns, \",\");\n        cqlBuilder.append(\" from \").append(table);\n        appendWhere(cqlBuilder, whereColumns, whereColumnsMaxIndex);\n        return cqlBuilder;\n    }","id":6242,"modified_method":"/**\n     * Generate select where columns = ? CQL.\n     */\n    public static Select generateSelect(String table, String[] selectColumns, String[] whereColumns, int whereColumnsMaxIndex) {\n        Select select = select(selectColumns).from(table);\n        if (isWhereClause(whereColumns, whereColumnsMaxIndex)) {\n            Select.Where where = select.where();\n            for(int i = 0; i < whereColumns.length && i < whereColumnsMaxIndex; i++) {\n                where.and(eq(whereColumns[i], bindMarker()));\n            }\n        }\n        return select;\n    }","commit_id":"00f1014873a10ca800f6c9efdfdb12a82a09c8ee","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Generate select where columns = ? CQL.\n     */\n    public static StringBuilder generateSelect(String table, String[] selectColumns, String[] whereColumns) {\n        return generateSelect(table, selectColumns, whereColumns, size(whereColumns));\n    }","id":6243,"modified_method":"/**\n     * Generate select where columns = ? CQL.\n     */\n    public static Select generateSelect(String table, String[] selectColumns, String[] whereColumns) {\n        return generateSelect(table, selectColumns, whereColumns, size(whereColumns));\n    }","commit_id":"00f1014873a10ca800f6c9efdfdb12a82a09c8ee","url":"https://github.com/apache/camel"},{"original_method":"public void removeEventListener(EventListener listener, List ueiList) {\n        m_listeners.remove(new ListenerKeeper(listener, new HashSet(ueiList)));\n    }","id":6244,"modified_method":"public void removeEventListener(EventListener listener, List<String> ueiList) {\n        m_listeners.remove(new ListenerKeeper(listener, new HashSet<String>(ueiList)));\n    }","commit_id":"1eff155173f5141ee5bc81b3b99432a91ca8f131","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void reset() {\n        m_listeners = new ArrayList();\n        m_anticipator.reset();\n    }","id":6245,"modified_method":"public void reset() {\n        m_listeners = new ArrayList<ListenerKeeper>();\n        m_anticipator.reset();\n    }","commit_id":"1eff155173f5141ee5bc81b3b99432a91ca8f131","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void addEventListener(EventListener listener, List ueilist) {\n        m_listeners.add(new ListenerKeeper(listener, new HashSet(ueilist)));\n    }","id":6246,"modified_method":"public void addEventListener(EventListener listener, List<String> ueilist) {\n        m_listeners.add(new ListenerKeeper(listener, new HashSet<String>(ueilist)));\n    }","commit_id":"1eff155173f5141ee5bc81b3b99432a91ca8f131","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void broadcastNow(Event event) {\n    \t\tMockUtil.println(\"Sending: \" + new EventWrapper(event));\n\t\tIterator it = m_listeners.iterator();\n\t\twhile (it.hasNext()) {\n            ListenerKeeper k = (ListenerKeeper) it.next();\n            k.sendEventIfAppropriate(event);\n        }\n    }","id":6247,"modified_method":"public void broadcastNow(Event event) {\n        MockUtil.println(\"Sending: \" + new EventWrapper(event));\n        for (ListenerKeeper k : m_listeners) {\n            k.sendEventIfAppropriate(event);\n        }\n    }","commit_id":"1eff155173f5141ee5bc81b3b99432a91ca8f131","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void sendNow(Log eventLog) {\n        Events events = eventLog.getEvents();\n        for (int i = 0; i < events.getEventCount(); i++) {\n            Event event = events.getEvent(i);\n            sendNow(event);\n        }\n    }","id":6248,"modified_method":"public void sendNow(Log eventLog) {\n        for (Event event : eventLog.getEvents().getEventCollection()) {\n            sendNow(event);\n        }\n    }","commit_id":"1eff155173f5141ee5bc81b3b99432a91ca8f131","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void reset() {\n        m_listeners = new ArrayList();\n        m_anticipator.reset();\n    }","id":6249,"modified_method":"public void reset() {\n        m_listeners = new ArrayList<ListenerKeeper>();\n        m_anticipator.reset();\n    }","commit_id":"b2105509803cda157e707ded21c842e03847b1d1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void sendNow(Log eventLog) {\n        Events events = eventLog.getEvents();\n        for (int i = 0; i < events.getEventCount(); i++) {\n            Event event = events.getEvent(i);\n            sendNow(event);\n        }\n    }","id":6250,"modified_method":"public void sendNow(Log eventLog) {\n        for (Event event : eventLog.getEvents().getEventCollection()) {\n            sendNow(event);\n        }\n    }","commit_id":"b2105509803cda157e707ded21c842e03847b1d1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void broadcastNow(Event event) {\n    \t\tMockUtil.println(\"Sending: \" + new EventWrapper(event));\n\t\tIterator it = m_listeners.iterator();\n\t\twhile (it.hasNext()) {\n            ListenerKeeper k = (ListenerKeeper) it.next();\n            k.sendEventIfAppropriate(event);\n        }\n    }","id":6251,"modified_method":"public void broadcastNow(Event event) {\n        MockUtil.println(\"Sending: \" + new EventWrapper(event));\n        for (ListenerKeeper k : m_listeners) {\n            k.sendEventIfAppropriate(event);\n        }\n    }","commit_id":"b2105509803cda157e707ded21c842e03847b1d1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void removeEventListener(EventListener listener, List ueiList) {\n        m_listeners.remove(new ListenerKeeper(listener, new HashSet(ueiList)));\n    }","id":6252,"modified_method":"public void removeEventListener(EventListener listener, List<String> ueiList) {\n        m_listeners.remove(new ListenerKeeper(listener, new HashSet<String>(ueiList)));\n    }","commit_id":"b2105509803cda157e707ded21c842e03847b1d1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void addEventListener(EventListener listener, List ueilist) {\n        m_listeners.add(new ListenerKeeper(listener, new HashSet(ueilist)));\n    }","id":6253,"modified_method":"public void addEventListener(EventListener listener, List<String> ueilist) {\n        m_listeners.add(new ListenerKeeper(listener, new HashSet<String>(ueilist)));\n    }","commit_id":"b2105509803cda157e707ded21c842e03847b1d1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void removeEventListener(EventListener listener, List ueiList) {\n        m_listeners.remove(new ListenerKeeper(listener, new HashSet(ueiList)));\n    }","id":6254,"modified_method":"public void removeEventListener(EventListener listener, List<String> ueiList) {\n        m_listeners.remove(new ListenerKeeper(listener, new HashSet<String>(ueiList)));\n    }","commit_id":"46ca9e5085255eba25dad067f37c3cca803b7925","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void broadcastNow(Event event) {\n    \t\tMockUtil.println(\"Sending: \" + new EventWrapper(event));\n\t\tIterator it = m_listeners.iterator();\n\t\twhile (it.hasNext()) {\n            ListenerKeeper k = (ListenerKeeper) it.next();\n            k.sendEventIfAppropriate(event);\n        }\n    }","id":6255,"modified_method":"public void broadcastNow(Event event) {\n        MockUtil.println(\"Sending: \" + new EventWrapper(event));\n        for (ListenerKeeper k : m_listeners) {\n            k.sendEventIfAppropriate(event);\n        }\n    }","commit_id":"46ca9e5085255eba25dad067f37c3cca803b7925","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void reset() {\n        m_listeners = new ArrayList();\n        m_anticipator.reset();\n    }","id":6256,"modified_method":"public void reset() {\n        m_listeners = new ArrayList<ListenerKeeper>();\n        m_anticipator.reset();\n    }","commit_id":"46ca9e5085255eba25dad067f37c3cca803b7925","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void addEventListener(EventListener listener, List ueilist) {\n        m_listeners.add(new ListenerKeeper(listener, new HashSet(ueilist)));\n    }","id":6257,"modified_method":"public void addEventListener(EventListener listener, List<String> ueilist) {\n        m_listeners.add(new ListenerKeeper(listener, new HashSet<String>(ueilist)));\n    }","commit_id":"46ca9e5085255eba25dad067f37c3cca803b7925","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void sendNow(Log eventLog) {\n        Events events = eventLog.getEvents();\n        for (int i = 0; i < events.getEventCount(); i++) {\n            Event event = events.getEvent(i);\n            sendNow(event);\n        }\n    }","id":6258,"modified_method":"public void sendNow(Log eventLog) {\n        for (Event event : eventLog.getEvents().getEventCollection()) {\n            sendNow(event);\n        }\n    }","commit_id":"46ca9e5085255eba25dad067f37c3cca803b7925","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    protected void eol(byte[] b, int len) throws IOException {\n        String line = charset.decode(ByteBuffer.wrap(b, 0, len)).toString();\n\n        // trim off CR/LF from the end\n        line = trimEOL(line);\n\n        // TODO:\n        // we need more support for conveniently putting annotations in the middle of the line, not just at the beginning\n        // we also need the ability for an extension point to have notes hook into the processing\n\n        Matcher m = MavenMojoNote.PATTERN.matcher(line);\n        if (m.matches())\n            new MavenMojoNote().encodeTo(out);\n\n        m = MavenWarningNote.PATTERN.matcher(line);\n        if (m.matches())\n            new MavenWarningNote().encodeTo(out);\n\n        m = MavenErrorNote.PATTERN.matcher(line);\n        if (m.matches())\n            new MavenErrorNote().encodeTo(out);\n\n        out.write(b,0,len);\n    }","id":6259,"modified_method":"@Override\n    protected void eol(byte[] b, int len) throws IOException {\n        String line = charset.decode(ByteBuffer.wrap(b, 0, len)).toString();\n\n        // trim off CR/LF from the end\n        line = trimEOL(line);\n\n        // TODO:\n        // we need more support for conveniently putting annotations in the middle of the line, not just at the beginning\n        // we also need the ability for an extension point to have notes hook into the processing\n\n        Matcher m = MavenMojoNote.PATTERN.matcher(line);\n        if (m.matches())\n            new MavenMojoNote().encodeTo(out);\n\n        m = MavenWarningNote.PATTERN.matcher(line);\n        if (m.find())\n            new MavenWarningNote().encodeTo(out);\n\n        m = MavenErrorNote.PATTERN.matcher(line);\n        if (m.find())\n            new MavenErrorNote().encodeTo(out);\n\n        out.write(b,0,len);\n    }","commit_id":"05dd7f8d4f77049f9763371eab3c925b2a08adce","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Override\n    public ConsoleAnnotator annotate(Object context, MarkupText text, int charPos) {\n        MarkupText.SubText t = text.findToken(Pattern.compile(\"^[^:]+(?=:)\"));\n        if (t!=null)\n            t.addMarkup(0,t.length(),\"<span class=error-inline>\",\"<\/span>\");\n        return null;\n    }","id":6260,"modified_method":"@Override\n    public ConsoleAnnotator annotate(Object context, MarkupText text, int charPos) {\n        text.addMarkup(0,text.length(),\"<span class=error-inline>\",\"<\/span>\");\n        return null;\n    }","commit_id":"05dd7f8d4f77049f9763371eab3c925b2a08adce","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Override\n    public ConsoleAnnotator annotate(Object context, MarkupText text, int charPos) {\n        MarkupText.SubText t = text.findToken(Pattern.compile(\"^[^:]+(?=:)\"));\n        if (t!=null)\n            t.addMarkup(7,t.length(),\"<b class=maven-mojo>\",\"<\/b>\");\n        return null;\n    }","id":6261,"modified_method":"@Override\n    public ConsoleAnnotator annotate(Object context, MarkupText text, int charPos) {\n        text.addMarkup(7,text.length(),\"<b class=maven-mojo>\",\"<\/b>\");\n        return null;\n    }","commit_id":"05dd7f8d4f77049f9763371eab3c925b2a08adce","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Starts maven process.\n     */\n    public NewProcess newProcess(BuildListener listener, OutputStream out) throws IOException, InterruptedException {\n        if(debug)\n            listener.getLogger().println(\"Using env variables: \"+ envVars);\n        try {\n            final Acceptor acceptor = launcher.getChannel().call(new SocketHandler());\n\n            final ArgumentListBuilder cmdLine = buildMavenCmdLine(listener,acceptor.getPort());\n            String[] cmds = cmdLine.toCommandArray();\n            final Proc proc = launcher.launch().cmds(cmds).envs(envVars).stdout(out).pwd(workDir).start();\n\n            Connection con;\n            try {\n                con = acceptor.accept();\n            } catch (SocketTimeoutException e) {\n                // failed to connect. Is the process dead?\n                // if so, the error should have been provided by the launcher already.\n                // so abort gracefully without a stack trace.\n                if(!proc.isAlive())\n                    throw new AbortException(\"Failed to launch Maven. Exit code = \"+proc.join());\n                throw e;\n            }\n\n            return new NewProcess(\n                Channels.forProcess(\"Channel to Maven \"+ Arrays.toString(cmds),\n                    Computer.threadPoolForRemoting, new BufferedInputStream(con.in), new BufferedOutputStream(con.out),\n                    listener.getLogger(), proc),\n                proc);\n        } catch (IOException e) {\n            if(fixNull(e.getMessage()).contains(\"java: not found\")) {\n                // diagnose issue #659\n                JDK jdk = mms.getJDK();\n                if(jdk==null)\n                    throw new IOException2(mms.getDisplayName()+\" is not configured with a JDK, but your PATH doesn't include Java\",e);\n            }\n            throw e;\n        }\n    }","id":6262,"modified_method":"/**\n     * Starts maven process.\n     */\n    public NewProcess newProcess(BuildListener listener, OutputStream out) throws IOException, InterruptedException {\n        if(debug)\n            listener.getLogger().println(\"Using env variables: \"+ envVars);\n        try {\n            final Acceptor acceptor = launcher.getChannel().call(new SocketHandler());\n            Charset charset;\n            try {\n                charset = Charset.forName(launcher.getChannel().call(new GetCharset()));\n            } catch (UnsupportedCharsetException e) {\n                // choose the bit preserving charset. not entirely sure if iso-8859-1 does that though.\n                charset = Charset.forName(\"iso-8859-1\");\n            }\n\n            MavenConsoleAnnotator mca = new MavenConsoleAnnotator(out,charset);\n\n            final ArgumentListBuilder cmdLine = buildMavenCmdLine(listener,acceptor.getPort());\n            String[] cmds = cmdLine.toCommandArray();\n            final Proc proc = launcher.launch().cmds(cmds).envs(envVars).stdout(mca).pwd(workDir).start();\n\n            Connection con;\n            try {\n                con = acceptor.accept();\n            } catch (SocketTimeoutException e) {\n                // failed to connect. Is the process dead?\n                // if so, the error should have been provided by the launcher already.\n                // so abort gracefully without a stack trace.\n                if(!proc.isAlive())\n                    throw new AbortException(\"Failed to launch Maven. Exit code = \"+proc.join());\n                throw e;\n            }\n\n            return new NewProcess(\n                Channels.forProcess(\"Channel to Maven \"+ Arrays.toString(cmds),\n                    Computer.threadPoolForRemoting, new BufferedInputStream(con.in), new BufferedOutputStream(con.out),\n                    listener.getLogger(), proc),\n                proc);\n        } catch (IOException e) {\n            if(fixNull(e.getMessage()).contains(\"java: not found\")) {\n                // diagnose issue #659\n                JDK jdk = mms.getJDK();\n                if(jdk==null)\n                    throw new IOException2(mms.getDisplayName()+\" is not configured with a JDK, but your PATH doesn't include Java\",e);\n            }\n            throw e;\n        }\n    }","commit_id":"05dd7f8d4f77049f9763371eab3c925b2a08adce","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Override\n    public ConsoleAnnotator annotate(Object context, MarkupText text, int charPos) {\n        MarkupText.SubText t = text.findToken(Pattern.compile(\"^[^:]+(?=:)\"));\n        if (t!=null)\n            t.addMarkup(0,t.length(),\"<span class=warning-inline>\",\"<\/span>\");\n        return null;\n    }","id":6263,"modified_method":"@Override\n    public ConsoleAnnotator annotate(Object context, MarkupText text, int charPos) {\n        text.addMarkup(0,text.length(),\"<span class=warning-inline>\",\"<\/span>\");\n        return null;\n    }","commit_id":"05dd7f8d4f77049f9763371eab3c925b2a08adce","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n   * Actual schema generation. It recursively resolves container types.\n   *\n   * @param typeToken    Encapsulate the Java type for generating a {@link Schema}.\n   * @param knownRecords Set of record names that has the schema already generated. It is used for\n   *                     recursive class field references.\n   * @return A {@link Schema} representing the given java {@link Type}.\n   * @throws UnsupportedTypeException Indicates schema generation is not support for the given java {@link Type}.\n   */\n  protected final Schema doGenerate(TypeToken<?> typeToken, Set<String> knownRecords) throws UnsupportedTypeException {\n    Type type = typeToken.getType();\n    Class<?> rawType = typeToken.getRawType();\n\n    if(SIMPLE_SCHEMAS.containsKey(rawType)) {\n      return SIMPLE_SCHEMAS.get(rawType);\n    }\n\n    // Enum type, simply use all the enum constants for ENUM schema.\n    if(rawType.isEnum()) {\n      return Schema.enumWith((Class<Enum<?>>) rawType);\n    }\n\n    // Java array, use ARRAY schema.\n    if(rawType.isArray()) {\n      return Schema.arrayOf(doGenerate(TypeToken.of(rawType.getComponentType()), knownRecords));\n    }\n\n    if(!( type instanceof Class || type instanceof ParameterizedType )) {\n      throw new UnsupportedTypeException(\n                                          \"Type \" + type + \" is not supported. \" +\n                                            \"Only Class or ParameterizedType are supported.\"\n      );\n    }\n\n    // Any parameterized Collection class would be represented by ARRAY schema.\n    if(Collection.class.isAssignableFrom(rawType)) {\n      if(!( type instanceof ParameterizedType )) {\n        throw new UnsupportedTypeException(\"Only supports parameterized Collection type.\");\n      }\n      TypeToken<?> componentType = typeToken.resolveType(( (ParameterizedType) type ).getActualTypeArguments()[0]);\n      return Schema.arrayOf(doGenerate(componentType, knownRecords));\n    }\n\n    // Java Map, use MAP schema.\n    if(Map.class.isAssignableFrom(rawType)) {\n      if(!( type instanceof ParameterizedType )) {\n        throw new UnsupportedTypeException(\"Only supports parameterized Map type.\");\n      }\n      Type[] typeArgs = ( (ParameterizedType) type ).getActualTypeArguments();\n      TypeToken<?> keyType = typeToken.resolveType(typeArgs[0]);\n      TypeToken<?> valueType = typeToken.resolveType(typeArgs[1]);\n\n      return Schema.mapOf(doGenerate(keyType, knownRecords), doGenerate(valueType, knownRecords));\n    }\n\n    // Any Java class, class name as the record name.\n    String recordName = typeToken.getRawType().getName();\n    if(knownRecords.contains(recordName)) {\n      // Record already seen before, simply create a reference RECORD schema by the name.\n      return Schema.recordOf(recordName);\n    }\n\n    // Delegate to child class to generate RECORD schema.\n    return generateRecord(typeToken, knownRecords);\n  }","id":6264,"modified_method":"/**\n   * Actual schema generation. It recursively resolves container types.\n   *\n   * @param typeToken    Encapsulate the Java type for generating a {@link Schema}.\n   * @param knownRecords Set of record names that has the schema already generated. It is used for\n   *                     recursive class field references.\n   * @return A {@link Schema} representing the given java {@link Type}.\n   * @throws UnsupportedTypeException Indicates schema generation is not support for the given java {@link Type}.\n   */\n  protected final Schema doGenerate(TypeToken<?> typeToken, Set<String> knownRecords) throws UnsupportedTypeException {\n    Type type = typeToken.getType();\n    Class<?> rawType = typeToken.getRawType();\n\n    if(SIMPLE_SCHEMAS.containsKey(rawType)) {\n      return SIMPLE_SCHEMAS.get(rawType);\n    }\n\n    // Enum type, simply use all the enum constants for ENUM schema.\n    if(rawType.isEnum()) {\n      return Schema.enumWith((Class<Enum<?>>) rawType);\n    }\n\n    // Java array, use ARRAY schema.\n    if(rawType.isArray()) {\n      Schema componentSchema = doGenerate(TypeToken.of(rawType.getComponentType()), knownRecords);\n      return Schema.arrayOf(Schema.unionOf(componentSchema, Schema.of(Schema.Type.NULL)));\n    }\n\n    if(!( type instanceof Class || type instanceof ParameterizedType )) {\n      throw new UnsupportedTypeException(\n                                          \"Type \" + type + \" is not supported. \" +\n                                            \"Only Class or ParameterizedType are supported.\"\n      );\n    }\n\n    // Any parameterized Collection class would be represented by ARRAY schema.\n    if(Collection.class.isAssignableFrom(rawType)) {\n      if(!( type instanceof ParameterizedType )) {\n        throw new UnsupportedTypeException(\"Only supports parameterized Collection type.\");\n      }\n      TypeToken<?> componentType = typeToken.resolveType(( (ParameterizedType) type ).getActualTypeArguments()[0]);\n      Schema componentSchema = doGenerate(componentType, knownRecords);\n      return Schema.arrayOf(Schema.unionOf(componentSchema, Schema.of(Schema.Type.NULL)));\n    }\n\n    // Java Map, use MAP schema.\n    if(Map.class.isAssignableFrom(rawType)) {\n      if(!( type instanceof ParameterizedType )) {\n        throw new UnsupportedTypeException(\"Only supports parameterized Map type.\");\n      }\n      Type[] typeArgs = ( (ParameterizedType) type ).getActualTypeArguments();\n      TypeToken<?> keyType = typeToken.resolveType(typeArgs[0]);\n      TypeToken<?> valueType = typeToken.resolveType(typeArgs[1]);\n\n      Schema valueSchema = doGenerate(valueType, knownRecords);\n\n      return Schema.mapOf(doGenerate(keyType, knownRecords), Schema.unionOf(valueSchema, Schema.of(Schema.Type.NULL)));\n    }\n\n    // Any Java class, class name as the record name.\n    String recordName = typeToken.getRawType().getName();\n    if(knownRecords.contains(recordName)) {\n      // Record already seen before, simply create a reference RECORD schema by the name.\n      return Schema.recordOf(recordName);\n    }\n\n    // Delegate to child class to generate RECORD schema.\n    return generateRecord(typeToken, knownRecords);\n  }","commit_id":"f3658824a92ae6d5ab71b76ab6b26f07682ae83a","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testConfigureApplication() throws NoSuchMethodException, UnsupportedTypeException {\n    ApplicationSpecification appSpec = new WordCountApp().configure();\n\n    ApplicationSpecificationAdapter adapter = ApplicationSpecificationAdapter.create(new ReflectionSchemaGenerator());\n\n    ApplicationSpecification newSpec = adapter.fromJson(adapter.toJson(appSpec));\n\n    System.out.println(adapter.toJson(newSpec));\n    System.out.println(adapter.toJson(appSpec));\n\n    Assert.assertEquals(1, newSpec.getDataSets().size());\n    Assert.assertEquals(new ReflectionSchemaGenerator().generate(WordCountApp.MyRecord.class),\n                          newSpec.getFlows().get(\"WordCountFlow\").getFlowlets().get(\"Tokenizer\")\n                                 .getInputs().get(\"\").iterator().next());\n  }","id":6265,"modified_method":"@Test\n  public void testConfigureApplication() throws NoSuchMethodException, UnsupportedTypeException {\n    ApplicationSpecification appSpec = new WordCountApp().configure();\n\n    ApplicationSpecificationAdapter adapter = ApplicationSpecificationAdapter.create(new ReflectionSchemaGenerator());\n\n    ApplicationSpecification newSpec = adapter.fromJson(adapter.toJson(appSpec));\n\n    Assert.assertEquals(1, newSpec.getDataSets().size());\n    Assert.assertEquals(new ReflectionSchemaGenerator().generate(WordCountApp.MyRecord.class),\n                          newSpec.getFlows().get(\"WordCountFlow\").getFlowlets().get(\"Tokenizer\")\n                                 .getInputs().get(\"\").iterator().next());\n  }","commit_id":"f3658824a92ae6d5ab71b76ab6b26f07682ae83a","url":"https://github.com/caskdata/cdap"},{"original_method":"public Record1(int i, Map<Integer, Value> properties, URL url) {\n      this.i = i;\n      this.properties = properties;\n      this.numbers = new int[] {1, 2};\n      this.url = url;\n      this.uuid = UUID.randomUUID();\n    }","id":6266,"modified_method":"public Record1(int i, Map<Integer, Value> properties, URL url) {\n      this.i = i;\n      this.properties = properties;\n      this.numbers = new int[] {1, 2};\n      this.url = url;\n      this.uuid = UUID.randomUUID();\n      this.nullStr = null;\n    }","commit_id":"f3658824a92ae6d5ab71b76ab6b26f07682ae83a","url":"https://github.com/caskdata/cdap"},{"original_method":"public Record2(long i, Map<String, Value> properties, String name) {\n      this.i = i;\n      this.properties = properties;\n      this.name = name;\n      this.numbers = new long[0];\n      this.url = null;\n      this.uuid = null;\n    }","id":6267,"modified_method":"public Record2(long i, Map<String, Value> properties, String name) {\n      this.i = i;\n      this.properties = properties;\n      this.name = name;\n      this.numbers = new long[0];\n      this.url = null;\n      this.uuid = null;\n      this.nullStr = null;\n    }","commit_id":"f3658824a92ae6d5ab71b76ab6b26f07682ae83a","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testTypeProject() throws IOException, UnsupportedTypeException {\n    Record1 r1 = new Record1(10, Maps.<Integer, Value>newHashMap(), new URL(\"http://www.yahoo.com\"));\n    r1.properties.put(1, new Value(1, \"Name1\"));\n    r1.properties.put(2, new Value(2, \"Name2\"));\n\n    PipedOutputStream output = new PipedOutputStream();\n    PipedInputStream input = new PipedInputStream(output);\n\n    Schema sourceSchema = new ReflectionSchemaGenerator().generate(Record1.class);\n    Schema targetSchema = new ReflectionSchemaGenerator().generate(Record2.class);\n\n    new ReflectionDatumWriter(sourceSchema).write(r1, new BinaryEncoder(output));\n    Record2 r2 = new ReflectionDatumReader<Record2>(targetSchema, TypeToken.of(Record2.class))\n                            .read(new BinaryDecoder(input), sourceSchema);\n\n    Assert.assertEquals(10L, r2.i.longValue());\n    Assert.assertEquals(ImmutableMap.of(\"1\", new Value(1, \"Name1\"), \"2\", new Value(2, \"Name2\")), r2.properties);\n    Assert.assertNull(r2.name);\n\n    Assert.assertArrayEquals(new long[] {1L, 2L}, r2.numbers);\n    Assert.assertEquals(URI.create(\"http://www.yahoo.com\"), r2.url);\n\n    Assert.assertEquals(r1.uuid, r2.uuid);\n  }","id":6268,"modified_method":"@Test\n  public void testTypeProject() throws IOException, UnsupportedTypeException {\n    final Record1 r1 = new Record1(10, Maps.<Integer, Value>newHashMap(), new URL(\"http://www.yahoo.com\"));\n    r1.properties.put(1, new Value(1, \"Name1\"));\n    r1.properties.put(2, new Value(2, \"Name2\"));\n    r1.properties.put(3, null);\n\n    PipedOutputStream output = new PipedOutputStream();\n    PipedInputStream input = new PipedInputStream(output);\n\n    Schema sourceSchema = new ReflectionSchemaGenerator().generate(Record1.class);\n    Schema targetSchema = new ReflectionSchemaGenerator().generate(Record2.class);\n\n    new ReflectionDatumWriter(sourceSchema).write(r1, new BinaryEncoder(output));\n    Record2 r2 = new ReflectionDatumReader<Record2>(targetSchema, TypeToken.of(Record2.class))\n                            .read(new BinaryDecoder(input), sourceSchema);\n\n    Assert.assertEquals(10L, r2.i.longValue());\n\n    Assert.assertTrue(Iterables.all(r2.properties.entrySet(), new Predicate<Map.Entry<String, Value>>() {\n      @Override\n      public boolean apply(Map.Entry<String, Value> input) {\n        Value value = r1.properties.get(Integer.valueOf(input.getKey()));\n        return (value == null && input.getValue() == null) || (value.equals(input.getValue()));\n      }\n    }));\n\n    Assert.assertNull(r2.name);\n\n    Assert.assertArrayEquals(new long[] {1L, 2L}, r2.numbers);\n    Assert.assertEquals(URI.create(\"http://www.yahoo.com\"), r2.url);\n\n    Assert.assertEquals(r1.uuid, r2.uuid);\n  }","commit_id":"f3658824a92ae6d5ab71b76ab6b26f07682ae83a","url":"https://github.com/caskdata/cdap"},{"original_method":"private void write(Object object, Encoder encoder, Schema objSchema, Set<Object> seenRefs) throws IOException {\n    if(seenRefs.contains(object)) {\n      throw new IOException(\"Circular reference not supported.\");\n    }\n    seenRefs.add(object);\n\n    switch(objSchema.getType()) {\n      case NULL:\n        encoder.writeNull();\n        break;\n      case BOOLEAN:\n        encoder.writeBool((Boolean) object);\n        break;\n      case INT:\n        encoder.writeInt(( (Number) object ).intValue());\n        break;\n      case LONG:\n        encoder.writeLong(( (Number) object ).longValue());\n        break;\n      case FLOAT:\n        encoder.writeFloat((Float) object);\n        break;\n      case DOUBLE:\n        encoder.writeDouble((Double) object);\n        break;\n      case STRING:\n        encoder.writeString(object.toString());\n        break;\n      case BYTES:\n        writeBytes(object, encoder);\n        break;\n      case ENUM:\n        writeEnum(object.toString(), encoder, objSchema);\n        break;\n      case ARRAY:\n        writeArray(object, encoder, objSchema.getComponentSchema(), seenRefs);\n        break;\n      case MAP:\n        writeMap(object, encoder, objSchema.getMapSchema(), seenRefs);\n        break;\n      case RECORD:\n        writeRecord(object, encoder, objSchema, seenRefs);\n    }\n  }","id":6269,"modified_method":"private void write(Object object, Encoder encoder, Schema objSchema, Set<Object> seenRefs) throws IOException {\n    if(object != null) {\n      if (seenRefs.contains(object)) {\n        throw new IOException(\"Circular reference not supported.\");\n      }\n      seenRefs.add(object);\n    }\n\n    switch(objSchema.getType()) {\n      case NULL:\n        encoder.writeNull();\n        break;\n      case BOOLEAN:\n        encoder.writeBool((Boolean) object);\n        break;\n      case INT:\n        encoder.writeInt(( (Number) object ).intValue());\n        break;\n      case LONG:\n        encoder.writeLong(( (Number) object ).longValue());\n        break;\n      case FLOAT:\n        encoder.writeFloat((Float) object);\n        break;\n      case DOUBLE:\n        encoder.writeDouble((Double) object);\n        break;\n      case STRING:\n        encoder.writeString(object.toString());\n        break;\n      case BYTES:\n        writeBytes(object, encoder);\n        break;\n      case ENUM:\n        writeEnum(object.toString(), encoder, objSchema);\n        break;\n      case ARRAY:\n        writeArray(object, encoder, objSchema.getComponentSchema(), seenRefs);\n        break;\n      case MAP:\n        writeMap(object, encoder, objSchema.getMapSchema(), seenRefs);\n        break;\n      case RECORD:\n        writeRecord(object, encoder, objSchema, seenRefs);\n        break;\n      case UNION:\n        // Assumption in schema generation that index 0 is the object type, index 1 is null.\n        if (object == null) {\n          encoder.writeInt(1);\n        } else {\n          seenRefs.remove(object);\n          encoder.writeInt(0);\n          write(object, encoder, objSchema.getUnionSchema(0), seenRefs);\n        }\n        break;\n    }\n  }","commit_id":"f3658824a92ae6d5ab71b76ab6b26f07682ae83a","url":"https://github.com/caskdata/cdap"},{"original_method":"private void writeRecord(Object record, Encoder encoder,\n                           Schema recordSchema, Set<Object> seenRefs) throws IOException {\n    try {\n      TypeToken<?> type = TypeToken.of(record.getClass());\n\n      Map<String, Method> methods = collectByMethod(type, Maps.<String, Method>newHashMap());\n      Map<String, Field> fields = collectByFields(type, Maps.<String, Field>newHashMap());\n\n      for(Schema.Field field : recordSchema.getFields()) {\n        String fieldName = field.getName();\n        Object value;\n        Field recordField = fields.get(fieldName);\n        if(recordField != null) {\n          recordField.setAccessible(true);\n          value = recordField.get(record);\n        } else {\n          Method method = methods.get(fieldName);\n          if(method == null) {\n            throw new IOException(\"Unable to read field value through getter. Class=\" + type + \", field=\" + fieldName);\n          }\n          value = method.invoke(record);\n        }\n\n        Schema fieldSchema = field.getSchema();\n        if(fieldSchema.getType() == Schema.Type.UNION) {\n          // It's assumed that 0 is for the actual type, 1 is for null value.\n          if(value == null) {\n            encoder.writeInt(1);\n            fieldSchema = fieldSchema.getUnionSchemas().get(1);\n          } else {\n            encoder.writeInt(0);\n            fieldSchema = fieldSchema.getUnionSchemas().get(0);\n          }\n        }\n        write(value, encoder, fieldSchema, seenRefs);\n      }\n    } catch(Exception e) {\n      if(e instanceof IOException) {\n        throw (IOException) e;\n      }\n      throw new IOException(e);\n    }\n  }","id":6270,"modified_method":"private void writeRecord(Object record, Encoder encoder,\n                           Schema recordSchema, Set<Object> seenRefs) throws IOException {\n    try {\n      TypeToken<?> type = TypeToken.of(record.getClass());\n\n      Map<String, Method> methods = collectByMethod(type, Maps.<String, Method>newHashMap());\n      Map<String, Field> fields = collectByFields(type, Maps.<String, Field>newHashMap());\n\n      for(Schema.Field field : recordSchema.getFields()) {\n        String fieldName = field.getName();\n        Object value;\n        Field recordField = fields.get(fieldName);\n        if(recordField != null) {\n          recordField.setAccessible(true);\n          value = recordField.get(record);\n        } else {\n          Method method = methods.get(fieldName);\n          if(method == null) {\n            throw new IOException(\"Unable to read field value through getter. Class=\" + type + \", field=\" + fieldName);\n          }\n          value = method.invoke(record);\n        }\n\n        Schema fieldSchema = field.getSchema();\n        write(value, encoder, fieldSchema, seenRefs);\n      }\n    } catch(Exception e) {\n      if(e instanceof IOException) {\n        throw (IOException) e;\n      }\n      throw new IOException(e);\n    }\n  }","commit_id":"f3658824a92ae6d5ab71b76ab6b26f07682ae83a","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n\t\tpublic void shouldUnsetOrganizationOwner() throws Exception {\n\t\t\tUser organizationOwnerUser = UserTestUtil.addOrganizationOwnerUser(\n\t\t\t\t_organization);\n\n\t\t\t_unsetOrganizationUsers(\n\t\t\t\t_organization.getOrganizationId(), _groupAdminUser,\n\t\t\t\torganizationOwnerUser);\n\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserLocalServiceUtil.hasOrganizationUser(\n\t\t\t\t\t_organization.getOrganizationId(),\n\t\t\t\t\torganizationOwnerUser.getUserId()));\n\t\t}","id":6271,"modified_method":"@Test\n\t\tpublic void shouldUnsetOrganizationOwner() throws Exception {\n\t\t\tUser organizationOwnerUser = UserTestUtil.addOrganizationOwnerUser(\n\t\t\t\t_organization);\n\n\t\t\ttry {\n\t\t\t\t_unsetOrganizationUsers(\n\t\t\t\t\t_organization.getOrganizationId(), _groupAdminUser,\n\t\t\t\t\torganizationOwnerUser);\n\n\t\t\t\tAssert.assertTrue(\n\t\t\t\t\tUserLocalServiceUtil.hasOrganizationUser(\n\t\t\t\t\t\t_organization.getOrganizationId(),\n\t\t\t\t\t\torganizationOwnerUser.getUserId()));\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tUserLocalServiceUtil.deleteUser(organizationOwnerUser);\n\t\t\t}\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\t\tpublic void shouldSendResetLinkEmailByUserId() throws Exception {\n\t\t\tgivenThatCompanySendsResetPasswordLink();\n\n\t\t\tint initialInboxSize = MailServiceTestUtil.getInboxSize();\n\n\t\t\tboolean sentPassword = UserServiceUtil.sendPasswordByUserId(\n\t\t\t\t_user.getUserId());\n\n\t\t\tAssert.assertFalse(sentPassword);\n\t\t\tAssert.assertEquals(\n\t\t\t\tinitialInboxSize + 1, MailServiceTestUtil.getInboxSize());\n\t\t\tAssert.assertTrue(\n\t\t\t\tMailServiceTestUtil.lastMailMessageContains(\n\t\t\t\t\t\"email_password_reset_body.tmpl\"));\n\t\t}","id":6272,"modified_method":"@Test\n\t\tpublic void shouldSendResetLinkEmailByUserId() throws Exception {\n\t\t\tPortletPreferences portletPreferences =\n\t\t\t\tgivenThatCompanySendsResetPasswordLink();\n\n\t\t\ttry {\n\t\t\t\tint initialInboxSize = MailServiceTestUtil.getInboxSize();\n\n\t\t\t\tboolean sentPassword = UserServiceUtil.sendPasswordByUserId(\n\t\t\t\t\t_user.getUserId());\n\n\t\t\t\tAssert.assertFalse(sentPassword);\n\t\t\t\tAssert.assertEquals(\n\t\t\t\t\tinitialInboxSize + 1, MailServiceTestUtil.getInboxSize());\n\t\t\t\tAssert.assertTrue(\n\t\t\t\t\tMailServiceTestUtil.lastMailMessageContains(\n\t\t\t\t\t\t\"email_password_reset_body.tmpl\"));\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\trestorePortletPreferences(portletPreferences);\n\t\t\t}\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Before\n\t\tpublic void setUp() throws Exception {\n\t\t\tOrganization organization = OrganizationTestUtil.addOrganization(\n\t\t\t\ttrue);\n\n\t\t\t_group = organization.getGroup();\n\n\t\t\t_organizationOwnerUser = UserTestUtil.addOrganizationOwnerUser(\n\t\t\t\torganization);\n\t\t}","id":6273,"modified_method":"@Before\n\t\tpublic void setUp() throws Exception {\n\t\t\t_organization = OrganizationTestUtil.addOrganization(true);\n\n\t\t\t_group = _organization.getGroup();\n\n\t\t\t_organizationOwnerUser = UserTestUtil.addOrganizationOwnerUser(\n\t\t\t\t_organization);\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\t\tpublic void shouldUnsetGroupAdmin() throws Exception {\n\t\t\tUser groupAdminUser = UserTestUtil.addGroupAdminUser(_group);\n\n\t\t\t_unsetGroupUsers(\n\t\t\t\t_group.getGroupId(), _groupOwnerUser, groupAdminUser);\n\n\t\t\tAssert.assertFalse(\n\t\t\t\tUserLocalServiceUtil.hasGroupUser(\n\t\t\t\t\t_group.getGroupId(), groupAdminUser.getUserId()));\n\t\t}","id":6274,"modified_method":"@Test\n\t\tpublic void shouldUnsetGroupAdmin() throws Exception {\n\t\t\tUser groupAdminUser = UserTestUtil.addGroupAdminUser(_group);\n\n\t\t\ttry {\n\t\t\t\t_unsetGroupUsers(\n\t\t\t\t\t_group.getGroupId(), _groupOwnerUser, groupAdminUser);\n\n\t\t\t\tAssert.assertFalse(\n\t\t\t\t\tUserLocalServiceUtil.hasGroupUser(\n\t\t\t\t\t\t_group.getGroupId(), groupAdminUser.getUserId()));\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tUserLocalServiceUtil.deleteUser(groupAdminUser);\n\t\t\t}\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\t\tpublic void shouldUnsetGroupOwner() throws Exception {\n\t\t\tUser groupOwnerUser = UserTestUtil.addGroupOwnerUser(_group);\n\n\t\t\t_unsetGroupUsers(\n\t\t\t\t_group.getGroupId(), _groupOwnerUser, groupOwnerUser);\n\n\t\t\tAssert.assertFalse(\n\t\t\t\tUserLocalServiceUtil.hasGroupUser(\n\t\t\t\t\t_group.getGroupId(), groupOwnerUser.getUserId()));\n\t\t}","id":6275,"modified_method":"@Test\n\t\tpublic void shouldUnsetGroupOwner() throws Exception {\n\t\t\tUser groupOwnerUser = UserTestUtil.addGroupOwnerUser(_group);\n\n\t\t\ttry {\n\t\t\t\t_unsetGroupUsers(\n\t\t\t\t\t_group.getGroupId(), _groupOwnerUser, groupOwnerUser);\n\n\t\t\t\tAssert.assertFalse(\n\t\t\t\t\tUserLocalServiceUtil.hasGroupUser(\n\t\t\t\t\t\t_group.getGroupId(), groupOwnerUser.getUserId()));\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tUserLocalServiceUtil.deleteUser(groupOwnerUser);\n\t\t\t}\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\t\tpublic void shouldSendResetLinkEmailByEmailAddress() throws Exception {\n\t\t\tgivenThatCompanySendsResetPasswordLink();\n\n\t\t\tint initialInboxSize = MailServiceTestUtil.getInboxSize();\n\n\t\t\tboolean sentPassword = UserServiceUtil.sendPasswordByEmailAddress(\n\t\t\t\t_user.getCompanyId(), _user.getEmailAddress());\n\n\t\t\tAssert.assertFalse(sentPassword);\n\t\t\tAssert.assertEquals(\n\t\t\t\tinitialInboxSize + 1, MailServiceTestUtil.getInboxSize());\n\t\t\tAssert.assertTrue(\n\t\t\t\tMailServiceTestUtil.lastMailMessageContains(\n\t\t\t\t\t\"email_password_reset_body.tmpl\"));\n\t\t}","id":6276,"modified_method":"@Test\n\t\tpublic void shouldSendResetLinkEmailByEmailAddress() throws Exception {\n\t\t\tPortletPreferences portletPreferences =\n\t\t\t\tgivenThatCompanySendsResetPasswordLink();\n\n\t\t\ttry {\n\t\t\t\tint initialInboxSize = MailServiceTestUtil.getInboxSize();\n\n\t\t\t\tboolean sentPassword =\n\t\t\t\t\tUserServiceUtil.sendPasswordByEmailAddress(\n\t\t\t\t\t\t_user.getCompanyId(), _user.getEmailAddress());\n\n\t\t\t\tAssert.assertFalse(sentPassword);\n\t\t\t\tAssert.assertEquals(\n\t\t\t\t\tinitialInboxSize + 1, MailServiceTestUtil.getInboxSize());\n\t\t\t\tAssert.assertTrue(\n\t\t\t\t\tMailServiceTestUtil.lastMailMessageContains(\n\t\t\t\t\t\t\"email_password_reset_body.tmpl\"));\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\trestorePortletPreferences(portletPreferences);\n\t\t\t}\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\t\tpublic void shouldUnsetOrganizationAdmin() throws Exception {\n\t\t\tUser organizationAdminUser = UserTestUtil.addOrganizationAdminUser(\n\t\t\t\t_organization);\n\n\t\t\t_unsetOrganizationUsers(\n\t\t\t\t_organization.getOrganizationId(), _groupAdminUser,\n\t\t\t\torganizationAdminUser);\n\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserLocalServiceUtil.hasOrganizationUser(\n\t\t\t\t\t_organization.getOrganizationId(),\n\t\t\t\t\torganizationAdminUser.getUserId()));\n\t\t}","id":6277,"modified_method":"@Test\n\t\tpublic void shouldUnsetOrganizationAdmin() throws Exception {\n\t\t\tUser organizationAdminUser = UserTestUtil.addOrganizationAdminUser(\n\t\t\t\t_organization);\n\n\t\t\ttry {\n\t\t\t\t_unsetOrganizationUsers(\n\t\t\t\t\t_organization.getOrganizationId(), _groupAdminUser,\n\t\t\t\t\torganizationAdminUser);\n\n\t\t\t\tAssert.assertTrue(\n\t\t\t\t\tUserLocalServiceUtil.hasOrganizationUser(\n\t\t\t\t\t\t_organization.getOrganizationId(),\n\t\t\t\t\t\torganizationAdminUser.getUserId()));\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tUserLocalServiceUtil.deleteUser(organizationAdminUser);\n\t\t\t}\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void givenThatCompanySendsNewPassword() throws Exception {\n\t\t\tPortletPreferences portletPreferences =\n\t\t\t\tPrefsPropsUtil.getPreferences(_user.getCompanyId(), false);\n\n\t\t\tportletPreferences.setValue(\n\t\t\t\tPropsKeys.COMPANY_SECURITY_SEND_PASSWORD,\n\t\t\t\tBoolean.TRUE.toString());\n\n\t\t\tportletPreferences.setValue(\n\t\t\t\tPropsKeys.COMPANY_SECURITY_SEND_PASSWORD_RESET_LINK,\n\t\t\t\tBoolean.FALSE.toString());\n\n\t\t\tportletPreferences.store();\n\t\t}","id":6278,"modified_method":"protected PortletPreferences givenThatCompanySendsNewPassword()\n\t\t\tthrows Exception {\n\n\t\t\tPortletPreferences portletPreferences =\n\t\t\t\tPrefsPropsUtil.getPreferences(_user.getCompanyId(), false);\n\n\t\t\tportletPreferences.setValue(\n\t\t\t\tPropsKeys.COMPANY_SECURITY_SEND_PASSWORD,\n\t\t\t\tBoolean.TRUE.toString());\n\n\t\t\tportletPreferences.setValue(\n\t\t\t\tPropsKeys.COMPANY_SECURITY_SEND_PASSWORD_RESET_LINK,\n\t\t\t\tBoolean.FALSE.toString());\n\n\t\t\tportletPreferences.store();\n\n\t\t\treturn portletPreferences;\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\t\tpublic void shouldUnsetOrganizationAdmin() throws Exception {\n\t\t\tUser organizationAdminUser = UserTestUtil.addOrganizationAdminUser(\n\t\t\t\t_organization);\n\n\t\t\t_unsetOrganizationUsers(\n\t\t\t\t_organization.getOrganizationId(), _organizationGroupUser,\n\t\t\t\torganizationAdminUser);\n\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserLocalServiceUtil.hasOrganizationUser(\n\t\t\t\t\t_organization.getOrganizationId(),\n\t\t\t\t\torganizationAdminUser.getUserId()));\n\t\t}","id":6279,"modified_method":"@Test\n\t\tpublic void shouldUnsetOrganizationAdmin() throws Exception {\n\t\t\tUser organizationAdminUser = UserTestUtil.addOrganizationAdminUser(\n\t\t\t\t_organization);\n\n\t\t\ttry {\n\t\t\t\t_unsetOrganizationUsers(\n\t\t\t\t\t_organization.getOrganizationId(), _organizationGroupUser,\n\t\t\t\t\torganizationAdminUser);\n\n\t\t\t\tAssert.assertTrue(\n\t\t\t\t\tUserLocalServiceUtil.hasOrganizationUser(\n\t\t\t\t\t\t_organization.getOrganizationId(),\n\t\t\t\t\t\torganizationAdminUser.getUserId()));\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tUserLocalServiceUtil.deleteUser(organizationAdminUser);\n\t\t\t}\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\t\tpublic void shouldSendNewPasswordEmailByEmailAddress()\n\t\t\tthrows Exception {\n\n\t\t\tgivenThatCompanySendsNewPassword();\n\n\t\t\tint initialInboxSize = MailServiceTestUtil.getInboxSize();\n\n\t\t\tboolean sentPassword = UserServiceUtil.sendPasswordByEmailAddress(\n\t\t\t\t_user.getCompanyId(), _user.getEmailAddress());\n\n\t\t\tAssert.assertTrue(sentPassword);\n\t\t\tAssert.assertEquals(\n\t\t\t\tinitialInboxSize + 1, MailServiceTestUtil.getInboxSize());\n\t\t\tAssert.assertTrue(\n\t\t\t\tMailServiceTestUtil.lastMailMessageContains(\n\t\t\t\t\t\"email_password_sent_body.tmpl\"));\n\t\t}","id":6280,"modified_method":"@Test\n\t\tpublic void shouldSendNewPasswordEmailByEmailAddress()\n\t\t\tthrows Exception {\n\n\t\t\tPortletPreferences portletPreferences =\n\t\t\t\tgivenThatCompanySendsNewPassword();\n\n\t\t\ttry {\n\t\t\t\tint initialInboxSize = MailServiceTestUtil.getInboxSize();\n\n\t\t\t\tboolean sentPassword =\n\t\t\t\t\tUserServiceUtil.sendPasswordByEmailAddress(\n\t\t\t\t\t\t_user.getCompanyId(), _user.getEmailAddress());\n\n\t\t\t\tAssert.assertTrue(sentPassword);\n\t\t\t\tAssert.assertEquals(\n\t\t\t\t\tinitialInboxSize + 1, MailServiceTestUtil.getInboxSize());\n\t\t\t\tAssert.assertTrue(\n\t\t\t\t\tMailServiceTestUtil.lastMailMessageContains(\n\t\t\t\t\t\t\"email_password_sent_body.tmpl\"));\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\trestorePortletPreferences(portletPreferences);\n\t\t\t}\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\t\tpublic void shouldUnsetOrganizationOwner() throws Exception {\n\t\t\tUser organizationOwnerUser = UserTestUtil.addOrganizationOwnerUser(\n\t\t\t\t_organization);\n\n\t\t\t_unsetOrganizationUsers(\n\t\t\t\t_organization.getOrganizationId(), _organizationGroupUser,\n\t\t\t\torganizationOwnerUser);\n\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserLocalServiceUtil.hasOrganizationUser(\n\t\t\t\t\t_organization.getOrganizationId(),\n\t\t\t\t\torganizationOwnerUser.getUserId()));\n\t\t}","id":6281,"modified_method":"@Test\n\t\tpublic void shouldUnsetOrganizationOwner() throws Exception {\n\t\t\tUser organizationOwnerUser = UserTestUtil.addOrganizationOwnerUser(\n\t\t\t\t_organization);\n\n\t\t\ttry {\n\t\t\t\t_unsetOrganizationUsers(\n\t\t\t\t\t_organization.getOrganizationId(), _organizationGroupUser,\n\t\t\t\t\torganizationOwnerUser);\n\n\t\t\t\tAssert.assertTrue(\n\t\t\t\t\tUserLocalServiceUtil.hasOrganizationUser(\n\t\t\t\t\t\t_organization.getOrganizationId(),\n\t\t\t\t\t\torganizationOwnerUser.getUserId()));\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tUserLocalServiceUtil.deleteUser(organizationOwnerUser);\n\t\t\t}\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\t\tpublic void shouldUnsetSiteOwner() throws Exception {\n\t\t\tUser groupOwnerUser = UserTestUtil.addGroupOwnerUser(_group);\n\n\t\t\t_unsetGroupUsers(\n\t\t\t\t_group.getGroupId(), _organizationAdminUser, groupOwnerUser);\n\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserLocalServiceUtil.hasGroupUser(\n\t\t\t\t\t_group.getGroupId(), groupOwnerUser.getUserId()));\n\t\t}","id":6282,"modified_method":"@Test\n\t\tpublic void shouldUnsetSiteOwner() throws Exception {\n\t\t\tUser groupOwnerUser = UserTestUtil.addGroupOwnerUser(_group);\n\n\t\t\ttry {\n\t\t\t\t_unsetGroupUsers(\n\t\t\t\t\t_group.getGroupId(), _organizationAdminUser,\n\t\t\t\t\tgroupOwnerUser);\n\n\t\t\t\tAssert.assertTrue(\n\t\t\t\t\tUserLocalServiceUtil.hasGroupUser(\n\t\t\t\t\t\t_group.getGroupId(), groupOwnerUser.getUserId()));\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tUserLocalServiceUtil.deleteUser(groupOwnerUser);\n\t\t\t}\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\t\tpublic void shouldUnsetSiteAdmin() throws Exception {\n\t\t\tUser groupAdminUser = UserTestUtil.addGroupAdminUser(_group);\n\n\t\t\t_unsetGroupUsers(\n\t\t\t\t_group.getGroupId(), _organizationAdminUser, groupAdminUser);\n\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserLocalServiceUtil.hasGroupUser(\n\t\t\t\t\t_group.getGroupId(), groupAdminUser.getUserId()));\n\t\t}","id":6283,"modified_method":"@Test\n\t\tpublic void shouldUnsetSiteAdmin() throws Exception {\n\t\t\tUser groupAdminUser = UserTestUtil.addGroupAdminUser(_group);\n\n\t\t\ttry {\n\t\t\t\t_unsetGroupUsers(\n\t\t\t\t\t_group.getGroupId(), _organizationAdminUser,\n\t\t\t\t\tgroupAdminUser);\n\n\t\t\t\tAssert.assertTrue(\n\t\t\t\t\tUserLocalServiceUtil.hasGroupUser(\n\t\t\t\t\t\t_group.getGroupId(), groupAdminUser.getUserId()));\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tUserLocalServiceUtil.deleteUser(groupAdminUser);\n\t\t\t}\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\t\tpublic void shouldReturnUserIfPresent() throws Exception {\n\t\t\tUser user = UserTestUtil.addUser(true);\n\n\t\t\tUser retrievedUser = UserServiceUtil.getUserByEmailAddress(\n\t\t\t\tTestPropsValues.getCompanyId(), user.getEmailAddress());\n\n\t\t\tAssert.assertEquals(user, retrievedUser);\n\t\t}","id":6284,"modified_method":"@Test\n\t\tpublic void shouldReturnUserIfPresent() throws Exception {\n\t\t\tUser user = UserTestUtil.addUser(true);\n\n\t\t\ttry {\n\t\t\t\tUser retrievedUser = UserServiceUtil.getUserByEmailAddress(\n\t\t\t\t\tTestPropsValues.getCompanyId(), user.getEmailAddress());\n\n\t\t\t\tAssert.assertEquals(user, retrievedUser);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tUserLocalServiceUtil.deleteUser(user);\n\t\t\t}\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\t\tpublic void shouldUnsetSiteOwner() throws Exception {\n\t\t\tUser groupOwnerUser = UserTestUtil.addGroupOwnerUser(_group);\n\n\t\t\t_unsetGroupUsers(\n\t\t\t\t_group.getGroupId(), _organizationOwnerUser, groupOwnerUser);\n\n\t\t\tAssert.assertFalse(\n\t\t\t\tUserLocalServiceUtil.hasGroupUser(\n\t\t\t\t\t_group.getGroupId(), groupOwnerUser.getUserId()));\n\t\t}","id":6285,"modified_method":"@Test\n\t\tpublic void shouldUnsetSiteOwner() throws Exception {\n\t\t\tUser groupOwnerUser = UserTestUtil.addGroupOwnerUser(_group);\n\n\t\t\ttry {\n\t\t\t\t_unsetGroupUsers(\n\t\t\t\t\t_group.getGroupId(), _organizationOwnerUser,\n\t\t\t\t\tgroupOwnerUser);\n\n\t\t\t\tAssert.assertFalse(\n\t\t\t\t\tUserLocalServiceUtil.hasGroupUser(\n\t\t\t\t\t\t_group.getGroupId(), groupOwnerUser.getUserId()));\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tUserLocalServiceUtil.deleteUser(groupOwnerUser);\n\t\t\t}\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\t\tpublic void shouldUnsetOrganizationOwner() throws Exception {\n\t\t\tUser otherOrganizationOwnerUser =\n\t\t\t\tUserTestUtil.addOrganizationOwnerUser(_organization);\n\n\t\t\t_unsetOrganizationUsers(\n\t\t\t\t_organization.getOrganizationId(), _organizationOwnerUser,\n\t\t\t\totherOrganizationOwnerUser);\n\n\t\t\tAssert.assertFalse(\n\t\t\t\tUserLocalServiceUtil.hasOrganizationUser(\n\t\t\t\t\t_organization.getOrganizationId(),\n\t\t\t\t\totherOrganizationOwnerUser.getUserId()));\n\t\t}","id":6286,"modified_method":"@Test\n\t\tpublic void shouldUnsetOrganizationOwner() throws Exception {\n\t\t\tUser otherOrganizationOwnerUser =\n\t\t\t\tUserTestUtil.addOrganizationOwnerUser(_organization);\n\n\t\t\ttry {\n\t\t\t\t_unsetOrganizationUsers(\n\t\t\t\t\t_organization.getOrganizationId(), _organizationOwnerUser,\n\t\t\t\t\totherOrganizationOwnerUser);\n\n\t\t\t\tAssert.assertFalse(\n\t\t\t\t\tUserLocalServiceUtil.hasOrganizationUser(\n\t\t\t\t\t\t_organization.getOrganizationId(),\n\t\t\t\t\t\totherOrganizationOwnerUser.getUserId()));\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tUserLocalServiceUtil.deleteUser(otherOrganizationOwnerUser);\n\t\t\t}\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test(expected = ReservedUserEmailAddressException.class)\n\t\tpublic void shouldNotUpdateEmailAddress() throws Exception {\n\t\t\tField field = ReflectionUtil.getDeclaredField(\n\t\t\t\tPropsValues.class, \"COMPANY_SECURITY_STRANGERS_WITH_MX\");\n\n\t\t\tObject value = field.get(null);\n\n\t\t\tString name = PrincipalThreadLocal.getName();\n\n\t\t\ttry {\n\t\t\t\tfield.set(null, Boolean.FALSE);\n\n\t\t\t\tUser user = UserTestUtil.addUser(false);\n\n\t\t\t\tPrincipalThreadLocal.setName(user.getUserId());\n\n\t\t\t\tString emailAddress =\n\t\t\t\t\t\"UserServiceTest.\" + RandomTestUtil.nextLong() +\n\t\t\t\t\t\t\"@liferay.com\";\n\n\t\t\t\tUserServiceUtil.updateEmailAddress(\n\t\t\t\t\tuser.getUserId(), user.getPassword(), emailAddress,\n\t\t\t\t\temailAddress, new ServiceContext());\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tfield.set(null, value);\n\n\t\t\t\tPrincipalThreadLocal.setName(name);\n\t\t\t}\n\t\t}","id":6287,"modified_method":"@Test(expected = ReservedUserEmailAddressException.class)\n\t\tpublic void shouldNotUpdateEmailAddress() throws Exception {\n\t\t\tboolean companySecurityStrangersWithMx =\n\t\t\t\tPropsValues.COMPANY_SECURITY_STRANGERS_WITH_MX;\n\n\t\t\tString name = PrincipalThreadLocal.getName();\n\n\t\t\ttry {\n\t\t\t\tReflectionTestUtil.setFieldValue(\n\t\t\t\t\tPropsValues.class, \"COMPANY_SECURITY_STRANGERS_WITH_MX\",\n\t\t\t\t\tfalse);\n\n\t\t\t\tUser user = UserTestUtil.addUser(false);\n\n\t\t\t\tPrincipalThreadLocal.setName(user.getUserId());\n\n\t\t\t\tString emailAddress =\n\t\t\t\t\t\"UserServiceTest.\" + RandomTestUtil.nextLong() +\n\t\t\t\t\t\t\"@liferay.com\";\n\n\t\t\t\tUserServiceUtil.updateEmailAddress(\n\t\t\t\t\tuser.getUserId(), user.getPassword(), emailAddress,\n\t\t\t\t\temailAddress, new ServiceContext());\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tReflectionTestUtil.setFieldValue(\n\t\t\t\t\tPropsValues.class, \"COMPANY_SECURITY_STRANGERS_WITH_MX\",\n\t\t\t\t\tcompanySecurityStrangersWithMx);\n\n\t\t\t\tPrincipalThreadLocal.setName(name);\n\t\t\t}\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\t\tpublic void shouldSendResetLinkEmailByScreenName() throws Exception {\n\t\t\tgivenThatCompanySendsResetPasswordLink();\n\n\t\t\tint initialInboxSize = MailServiceTestUtil.getInboxSize();\n\n\t\t\tboolean sentPassword = UserServiceUtil.sendPasswordByScreenName(\n\t\t\t\t_user.getCompanyId(), _user.getScreenName());\n\n\t\t\tAssert.assertFalse(sentPassword);\n\t\t\tAssert.assertEquals(\n\t\t\t\tinitialInboxSize + 1, MailServiceTestUtil.getInboxSize());\n\t\t\tAssert.assertTrue(\n\t\t\t\tMailServiceTestUtil.lastMailMessageContains(\n\t\t\t\t\t\"email_password_reset_body.tmpl\"));\n\t\t}","id":6288,"modified_method":"@Test\n\t\tpublic void shouldSendResetLinkEmailByScreenName() throws Exception {\n\t\t\tPortletPreferences portletPreferences =\n\t\t\t\tgivenThatCompanySendsResetPasswordLink();\n\n\t\t\ttry {\n\t\t\t\tint initialInboxSize = MailServiceTestUtil.getInboxSize();\n\n\t\t\t\tboolean sentPassword = UserServiceUtil.sendPasswordByScreenName(\n\t\t\t\t\t_user.getCompanyId(), _user.getScreenName());\n\n\t\t\t\tAssert.assertFalse(sentPassword);\n\t\t\t\tAssert.assertEquals(\n\t\t\t\t\tinitialInboxSize + 1, MailServiceTestUtil.getInboxSize());\n\t\t\t\tAssert.assertTrue(\n\t\t\t\t\tMailServiceTestUtil.lastMailMessageContains(\n\t\t\t\t\t\t\"email_password_reset_body.tmpl\"));\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\trestorePortletPreferences(portletPreferences);\n\t\t\t}\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Before\n\t\tpublic void setUp() throws Exception {\n\t\t\tOrganization organization = OrganizationTestUtil.addOrganization(\n\t\t\t\ttrue);\n\n\t\t\t_group = organization.getGroup();\n\n\t\t\t_organizationAdminUser = UserTestUtil.addOrganizationAdminUser(\n\t\t\t\torganization);\n\t\t}","id":6289,"modified_method":"@Before\n\t\tpublic void setUp() throws Exception {\n\t\t\t_organization = OrganizationTestUtil.addOrganization(true);\n\n\t\t\t_group = _organization.getGroup();\n\n\t\t\t_organizationAdminUser = UserTestUtil.addOrganizationAdminUser(\n\t\t\t\t_organization);\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\t\tpublic void shouldUnsetGroupOwner() throws Exception {\n\t\t\tUser groupOwnerUser = UserTestUtil.addGroupOwnerUser(_group);\n\n\t\t\t_unsetGroupUsers(\n\t\t\t\t_group.getGroupId(), _groupAdminUser, groupOwnerUser);\n\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserLocalServiceUtil.hasGroupUser(\n\t\t\t\t\t_group.getGroupId(), groupOwnerUser.getUserId()));\n\t\t}","id":6290,"modified_method":"@Test\n\t\tpublic void shouldUnsetGroupOwner() throws Exception {\n\t\t\tUser groupOwnerUser = UserTestUtil.addGroupOwnerUser(_group);\n\n\t\t\ttry {\n\t\t\t\t_unsetGroupUsers(\n\t\t\t\t\t_group.getGroupId(), _groupAdminUser, groupOwnerUser);\n\n\t\t\t\tAssert.assertTrue(\n\t\t\t\t\tUserLocalServiceUtil.hasGroupUser(\n\t\t\t\t\t\t_group.getGroupId(), groupOwnerUser.getUserId()));\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tUserLocalServiceUtil.deleteUser(groupOwnerUser);\n\t\t\t}\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test(expected = ReservedUserEmailAddressException.class)\n\t\tpublic void shouldNotAddUser() throws Exception {\n\t\t\tField field = ReflectionUtil.getDeclaredField(\n\t\t\t\tPropsValues.class, \"COMPANY_SECURITY_STRANGERS_WITH_MX\");\n\n\t\t\tObject value = field.get(null);\n\n\t\t\tString name = PrincipalThreadLocal.getName();\n\n\t\t\ttry {\n\t\t\t\tfield.set(null, Boolean.FALSE);\n\n\t\t\t\tPrincipalThreadLocal.setName(0);\n\n\t\t\t\tUserTestUtil.addUser(true);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tfield.set(null, value);\n\n\t\t\t\tPrincipalThreadLocal.setName(name);\n\t\t\t}\n\t\t}","id":6291,"modified_method":"@Test(expected = ReservedUserEmailAddressException.class)\n\t\tpublic void shouldNotAddUser() throws Exception {\n\t\t\tboolean companySecurityStrangersWithMx =\n\t\t\t\tPropsValues.COMPANY_SECURITY_STRANGERS_WITH_MX;\n\n\t\t\tString name = PrincipalThreadLocal.getName();\n\n\t\t\ttry {\n\t\t\t\tReflectionTestUtil.setFieldValue(\n\t\t\t\t\tPropsValues.class, \"COMPANY_SECURITY_STRANGERS_WITH_MX\",\n\t\t\t\t\tfalse);\n\n\t\t\t\tPrincipalThreadLocal.setName(0);\n\n\t\t\t\tUserTestUtil.addUser(true);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tReflectionTestUtil.setFieldValue(\n\t\t\t\t\tPropsValues.class, \"COMPANY_SECURITY_STRANGERS_WITH_MX\",\n\t\t\t\t\tcompanySecurityStrangersWithMx);\n\n\t\t\t\tPrincipalThreadLocal.setName(name);\n\t\t\t}\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\t\tpublic void shouldUnsetGroupAdmin() throws Exception {\n\t\t\tUser groupAdminUser = UserTestUtil.addGroupAdminUser(_group);\n\n\t\t\t_unsetGroupUsers(\n\t\t\t\t_group.getGroupId(), _groupAdminUser, groupAdminUser);\n\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserLocalServiceUtil.hasGroupUser(\n\t\t\t\t\t_group.getGroupId(), groupAdminUser.getUserId()));\n\t\t}","id":6292,"modified_method":"@Test\n\t\tpublic void shouldUnsetGroupAdmin() throws Exception {\n\t\t\tUser groupAdminUser = UserTestUtil.addGroupAdminUser(_group);\n\n\t\t\ttry {\n\t\t\t\t_unsetGroupUsers(\n\t\t\t\t\t_group.getGroupId(), _groupAdminUser, groupAdminUser);\n\n\t\t\t\tAssert.assertTrue(\n\t\t\t\t\tUserLocalServiceUtil.hasGroupUser(\n\t\t\t\t\t\t_group.getGroupId(), groupAdminUser.getUserId()));\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tUserLocalServiceUtil.deleteUser(groupAdminUser);\n\t\t\t}\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\t\tpublic void shouldUnsetSiteAdmin() throws Exception {\n\t\t\tUser groupAdminUser = UserTestUtil.addGroupAdminUser(_group);\n\n\t\t\t_unsetGroupUsers(\n\t\t\t\t_group.getGroupId(), _organizationOwnerUser, groupAdminUser);\n\n\t\t\tAssert.assertFalse(\n\t\t\t\tUserLocalServiceUtil.hasGroupUser(\n\t\t\t\t\t_group.getGroupId(), groupAdminUser.getUserId()));\n\t\t}","id":6293,"modified_method":"@Test\n\t\tpublic void shouldUnsetSiteAdmin() throws Exception {\n\t\t\tUser groupAdminUser = UserTestUtil.addGroupAdminUser(_group);\n\n\t\t\ttry {\n\t\t\t\t_unsetGroupUsers(\n\t\t\t\t\t_group.getGroupId(), _organizationOwnerUser,\n\t\t\t\t\tgroupAdminUser);\n\n\t\t\t\tAssert.assertFalse(\n\t\t\t\t\tUserLocalServiceUtil.hasGroupUser(\n\t\t\t\t\t\t_group.getGroupId(), groupAdminUser.getUserId()));\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tUserLocalServiceUtil.deleteUser(groupAdminUser);\n\t\t\t}\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test(expected = ReservedUserEmailAddressException.class)\n\t\tpublic void shouldNotUpdateUser() throws Exception {\n\t\t\tField field = ReflectionUtil.getDeclaredField(\n\t\t\t\tPropsValues.class, \"COMPANY_SECURITY_STRANGERS_WITH_MX\");\n\n\t\t\tObject value = field.get(null);\n\n\t\t\tString name = PrincipalThreadLocal.getName();\n\n\t\t\ttry {\n\t\t\t\tfield.set(null, Boolean.FALSE);\n\n\t\t\t\tUser user = UserTestUtil.addUser(false);\n\n\t\t\t\tPrincipalThreadLocal.setName(user.getUserId());\n\n\t\t\t\tUserTestUtil.updateUser(user);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tfield.set(null, value);\n\n\t\t\t\tPrincipalThreadLocal.setName(name);\n\t\t\t}\n\t\t}","id":6294,"modified_method":"@Test(expected = ReservedUserEmailAddressException.class)\n\t\tpublic void shouldNotUpdateUser() throws Exception {\n\t\t\tboolean companySecurityStrangersWithMx =\n\t\t\t\tPropsValues.COMPANY_SECURITY_STRANGERS_WITH_MX;\n\n\t\t\tString name = PrincipalThreadLocal.getName();\n\n\t\t\tUser user = UserTestUtil.addUser(false);\n\n\t\t\ttry {\n\t\t\t\tReflectionTestUtil.setFieldValue(\n\t\t\t\t\tPropsValues.class, \"COMPANY_SECURITY_STRANGERS_WITH_MX\",\n\t\t\t\t\tfalse);\n\n\t\t\t\tPrincipalThreadLocal.setName(user.getUserId());\n\n\t\t\t\tUserTestUtil.updateUser(user);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tReflectionTestUtil.setFieldValue(\n\t\t\t\t\tPropsValues.class, \"COMPANY_SECURITY_STRANGERS_WITH_MX\",\n\t\t\t\t\tcompanySecurityStrangersWithMx);\n\n\t\t\t\tPrincipalThreadLocal.setName(name);\n\n\t\t\t\tUserLocalServiceUtil.deleteUser(user);\n\t\t\t}\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\t\tpublic void shouldUnsetOrganizationAdmin() throws Exception {\n\t\t\tUser organizationAdminUser = UserTestUtil.addOrganizationAdminUser(\n\t\t\t\t_organization);\n\n\t\t\t_unsetOrganizationUsers(\n\t\t\t\t_organization.getOrganizationId(), _organizationOwnerUser,\n\t\t\t\torganizationAdminUser);\n\n\t\t\tAssert.assertFalse(\n\t\t\t\tUserLocalServiceUtil.hasOrganizationUser(\n\t\t\t\t\t_organization.getOrganizationId(),\n\t\t\t\t\torganizationAdminUser.getUserId()));\n\t\t}","id":6295,"modified_method":"@Test\n\t\tpublic void shouldUnsetOrganizationAdmin() throws Exception {\n\t\t\tUser organizationAdminUser = UserTestUtil.addOrganizationAdminUser(\n\t\t\t\t_organization);\n\n\t\t\ttry {\n\t\t\t\t_unsetOrganizationUsers(\n\t\t\t\t\t_organization.getOrganizationId(), _organizationOwnerUser,\n\t\t\t\t\torganizationAdminUser);\n\n\t\t\t\tAssert.assertFalse(\n\t\t\t\t\tUserLocalServiceUtil.hasOrganizationUser(\n\t\t\t\t\t\t_organization.getOrganizationId(),\n\t\t\t\t\t\torganizationAdminUser.getUserId()));\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tUserLocalServiceUtil.deleteUser(organizationAdminUser);\n\t\t\t}\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\t\tpublic void shouldSendNewPasswordEmailByScreenName() throws Exception {\n\t\t\tgivenThatCompanySendsNewPassword();\n\n\t\t\tint initialInboxSize = MailServiceTestUtil.getInboxSize();\n\n\t\t\tboolean sentPassword = UserServiceUtil.sendPasswordByScreenName(\n\t\t\t\t_user.getCompanyId(), _user.getScreenName());\n\n\t\t\tAssert.assertTrue(sentPassword);\n\t\t\tAssert.assertEquals(\n\t\t\t\tinitialInboxSize + 1, MailServiceTestUtil.getInboxSize());\n\t\t\tAssert.assertTrue(\n\t\t\t\tMailServiceTestUtil.lastMailMessageContains(\n\t\t\t\t\t\"email_password_sent_body.tmpl\"));\n\t\t}","id":6296,"modified_method":"@Test\n\t\tpublic void shouldSendNewPasswordEmailByScreenName() throws Exception {\n\t\t\tPortletPreferences portletPreferences =\n\t\t\t\tgivenThatCompanySendsNewPassword();\n\n\t\t\ttry {\n\t\t\t\tint initialInboxSize = MailServiceTestUtil.getInboxSize();\n\n\t\t\t\tboolean sentPassword = UserServiceUtil.sendPasswordByScreenName(\n\t\t\t\t\t_user.getCompanyId(), _user.getScreenName());\n\n\t\t\t\tAssert.assertTrue(sentPassword);\n\t\t\t\tAssert.assertEquals(\n\t\t\t\t\tinitialInboxSize + 1, MailServiceTestUtil.getInboxSize());\n\t\t\t\tAssert.assertTrue(\n\t\t\t\t\tMailServiceTestUtil.lastMailMessageContains(\n\t\t\t\t\t\t\"email_password_sent_body.tmpl\"));\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\trestorePortletPreferences(portletPreferences);\n\t\t\t}\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\t\tpublic void shouldSendNewPasswordEmailByUserId() throws Exception {\n\t\t\tint initialInboxSize = MailServiceTestUtil.getInboxSize();\n\n\t\t\tgivenThatCompanySendsNewPassword();\n\n\t\t\tboolean sentPassword = UserServiceUtil.sendPasswordByUserId(\n\t\t\t\t_user.getUserId());\n\n\t\t\tAssert.assertTrue(sentPassword);\n\t\t\tAssert.assertEquals(\n\t\t\t\tinitialInboxSize + 1, MailServiceTestUtil.getInboxSize());\n\t\t\tAssert.assertTrue(\n\t\t\t\tMailServiceTestUtil.lastMailMessageContains(\n\t\t\t\t\t\"email_password_sent_body.tmpl\"));\n\t\t}","id":6297,"modified_method":"@Test\n\t\tpublic void shouldSendNewPasswordEmailByUserId() throws Exception {\n\t\t\tPortletPreferences portletPreferences =\n\t\t\t\tgivenThatCompanySendsNewPassword();\n\n\t\t\ttry {\n\t\t\t\tint initialInboxSize = MailServiceTestUtil.getInboxSize();\n\n\t\t\t\tboolean sentPassword = UserServiceUtil.sendPasswordByUserId(\n\t\t\t\t\t_user.getUserId());\n\n\t\t\t\tAssert.assertTrue(sentPassword);\n\t\t\t\tAssert.assertEquals(\n\t\t\t\t\tinitialInboxSize + 1, MailServiceTestUtil.getInboxSize());\n\t\t\t\tAssert.assertTrue(\n\t\t\t\t\tMailServiceTestUtil.lastMailMessageContains(\n\t\t\t\t\t\t\"email_password_sent_body.tmpl\"));\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\trestorePortletPreferences(portletPreferences);\n\t\t\t}\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void givenThatCompanySendsResetPasswordLink()\n\t\t\tthrows Exception {\n\n\t\t\tPortletPreferences portletPreferences =\n\t\t\t\tPrefsPropsUtil.getPreferences(_user.getCompanyId(), false);\n\n\t\t\tportletPreferences.setValue(\n\t\t\t\tPropsKeys.COMPANY_SECURITY_SEND_PASSWORD,\n\t\t\t\tBoolean.FALSE.toString());\n\t\t\tportletPreferences.setValue(\n\t\t\t\tPropsKeys.COMPANY_SECURITY_SEND_PASSWORD_RESET_LINK,\n\t\t\t\tBoolean.TRUE.toString());\n\n\t\t\tportletPreferences.store();\n\t\t}","id":6298,"modified_method":"protected PortletPreferences givenThatCompanySendsResetPasswordLink()\n\t\t\tthrows Exception {\n\n\t\t\tPortletPreferences portletPreferences =\n\t\t\t\tPrefsPropsUtil.getPreferences(_user.getCompanyId(), false);\n\n\t\t\tportletPreferences.setValue(\n\t\t\t\tPropsKeys.COMPANY_SECURITY_SEND_PASSWORD,\n\t\t\t\tBoolean.FALSE.toString());\n\t\t\tportletPreferences.setValue(\n\t\t\t\tPropsKeys.COMPANY_SECURITY_SEND_PASSWORD_RESET_LINK,\n\t\t\t\tBoolean.TRUE.toString());\n\n\t\t\tportletPreferences.store();\n\n\t\t\treturn portletPreferences;\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\t\tpublic void shouldUnsetOrganizationAdmin() throws Exception {\n\t\t\tUser otherOrganizationAdminUser =\n\t\t\t\tUserTestUtil.addOrganizationAdminUser(_organization);\n\n\t\t\t_unsetOrganizationUsers(\n\t\t\t\t_organization.getOrganizationId(), _organizationAdminUser,\n\t\t\t\totherOrganizationAdminUser);\n\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserLocalServiceUtil.hasOrganizationUser(\n\t\t\t\t\t_organization.getOrganizationId(),\n\t\t\t\t\totherOrganizationAdminUser.getUserId()));\n\t\t}","id":6299,"modified_method":"@Test\n\t\tpublic void shouldUnsetOrganizationAdmin() throws Exception {\n\t\t\tUser otherOrganizationAdminUser =\n\t\t\t\tUserTestUtil.addOrganizationAdminUser(_organization);\n\n\t\t\ttry {\n\t\t\t\t_unsetOrganizationUsers(\n\t\t\t\t\t_organization.getOrganizationId(), _organizationAdminUser,\n\t\t\t\t\totherOrganizationAdminUser);\n\n\t\t\t\tAssert.assertTrue(\n\t\t\t\t\tUserLocalServiceUtil.hasOrganizationUser(\n\t\t\t\t\t\t_organization.getOrganizationId(),\n\t\t\t\t\t\totherOrganizationAdminUser.getUserId()));\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tUserLocalServiceUtil.deleteUser(otherOrganizationAdminUser);\n\t\t\t}\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        Permanent sourcePermanent = game.getPermanent(source.getSourceId());\r\n        if (sourcePermanent == null) {\r\n            sourcePermanent = game.getPermanentEntering(source.getSourceId());\r\n        }\r\n        if (controller != null) {\r\n            Choice choice = new ChoiceImpl(true);\r\n            choice.setMessage(choiceMessage);\r\n            choice.getChoices().addAll(modes);\r\n            while (!choice.isChosen()) {\r\n                if (!controller.canRespond()) {\r\n                    return false;\r\n                }\r\n                controller.choose(Outcome.Neutral, choice, game);\r\n            }\r\n            if (choice.isChosen()) {\r\n                if (!game.isSimulation()) {\r\n                    game.informPlayers(new StringBuilder(sourcePermanent.getLogName()).append(\": \").append(controller.getLogName()).append(\" has chosen \").append(choice.getChoice()).toString());\r\n                }\r\n                game.getState().setValue(source.getSourceId() + \"_modeChoice\", choice.getChoice());\r\n                sourcePermanent.addInfo(\"_modeChoice\", \"<font color = 'blue'>Chosen mode: \" + choice.getChoice() + \"<\/font>\", game);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":6300,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        Permanent sourcePermanent = game.getPermanent(source.getSourceId());\r\n        if (sourcePermanent == null) {\r\n            sourcePermanent = game.getPermanentEntering(source.getSourceId());\r\n        }\r\n        if (controller != null) {\r\n            Choice choice = new ChoiceImpl(true);\r\n            choice.setMessage(choiceMessage);\r\n            choice.getChoices().addAll(modes);\r\n            while (!choice.isChosen()) {\r\n                if (!controller.canRespond()) {\r\n                    return false;\r\n                }\r\n                controller.choose(Outcome.Neutral, choice, game);\r\n            }\r\n            if (choice.isChosen()) {\r\n                if (!game.isSimulation()) {\r\n                    game.informPlayers(sourcePermanent.getLogName() + \": \" + controller.getLogName() + \" has chosen \" + choice.getChoice());\r\n                }\r\n                game.getState().setValue(source.getSourceId() + \"_modeChoice\", choice.getChoice());\r\n                sourcePermanent.addInfo(\"_modeChoice\", \"<font color = 'blue'>Chosen mode: \" + choice.getChoice() + \"<\/font>\", game);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"ae69986aef21f38fc434664e731292c49e7b31f0","url":"https://github.com/magefree/mage"},{"original_method":"@java.lang.Override\n    public boolean apply(Game game, Ability source) {\n        Player player = game.getPlayer(source.getControllerId());\n        if (player.getHand().size() > 0) {\n            TargetCard target = new TargetCard(Zone.HAND, filter);\n            player.choose(Outcome.Benefit, target, source.getSourceId(), game);\n            Card card = player.getHand().get(target.getFirstTarget(), game);\n            if (card != null) {\n                card.moveToExile(getId(), \"Chrome Mox (Imprint)\", source.getSourceId(), game);\n                Permanent permanent = game.getPermanent(source.getSourceId());\n                if (permanent != null) {\n                    permanent.imprint(card.getId(), game);\n                }\n                return true;\n            }\n        }\n        return true;\n    }","id":6301,"modified_method":"@java.lang.Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        MageObject sourceObject = source.getSourceObject(game);\n        if (controller != null && sourceObject != null) {\n            TargetCard target = new TargetCard(Zone.HAND, filter);\n            target.setNotTarget(true);\n            Card cardToImprint = null;\n            Permanent sourcePermanent = game.getPermanent(source.getSourceId());\n            if (controller.getHand().size() > 0 && controller.choose(Outcome.Benefit, target, source.getSourceId(), game)) {\n                cardToImprint = controller.getHand().get(target.getFirstTarget(), game);\n            }\n            if (sourcePermanent != null) {\n                if (cardToImprint != null) {\n                    controller.moveCardsToExile(cardToImprint, source, game, true, source.getSourceId(), sourceObject.getIdName() + \" (Imprint)\");\n                    sourcePermanent.imprint(cardToImprint.getId(), game);\n                    sourcePermanent.addInfo(\"imprint\", CardUtil.addToolTipMarkTags(\"[Imprinted card - \" + GameLog.getColoredObjectIdNameForTooltip(cardToImprint) + \"]\"), game);\n                } else {\n                    sourcePermanent.addInfo(\"imprint\", CardUtil.addToolTipMarkTags(\"[Imprinted card - None]\"), game);\n                }\n            }\n            return true;\n\n        }\n        return false;\n    }","commit_id":"ae69986aef21f38fc434664e731292c49e7b31f0","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean choose(Outcome outcome, Target target, UUID sourceId, Game game, Map<String, Serializable> options) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"chooseTarget: \" + outcome.toString() + \":\" + target.toString());\n        }\n        // sometimes a target selection can be made from a player that does not control the ability\n        UUID abilityControllerId = playerId;\n        if (target.getTargetController() != null && target.getAbilityController() != null) {\n            abilityControllerId = target.getAbilityController();\n        }\n        UUID opponentId = game.getOpponents(abilityControllerId).iterator().next();\n        if (target instanceof TargetPlayer) {\n            if (outcome.isGood()) {\n                if (target.canTarget(abilityControllerId, game)) {\n                    target.add(abilityControllerId, game);\n                    return true;\n                }\n                if (target.isRequired(sourceId, game)) {\n                    if (target.canTarget(opponentId, game)) {\n                        target.add(opponentId, game);\n                        return true;\n                    }\n                }\n            } else {\n                if (target.canTarget(opponentId, game)) {\n                    target.add(opponentId, game);\n                    return true;\n                }\n                if (target.isRequired(sourceId, game)) {\n                    if (target.canTarget(abilityControllerId, game)) {\n                        target.add(abilityControllerId, game);\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        if (target instanceof TargetDiscard) {\n            findPlayables(game);\n            if (unplayable.size() > 0) {\n                for (int i = unplayable.size() - 1; i >= 0; i--) {\n                    if (target.canTarget(unplayable.values().toArray(new Card[0])[i].getId(), game)) {\n                        target.add(unplayable.values().toArray(new Card[0])[i].getId(), game);\n                        if (target.isChosen()) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            if (hand.size() > 0) {\n                for (int i = 0; i < hand.size(); i++) {\n                    if (target.canTarget(hand.toArray(new UUID[0])[i], game)) {\n                        target.add(hand.toArray(new UUID[0])[i], game);\n                        if (target.isChosen()) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n        if (target instanceof TargetControlledPermanent) {\n            List<Permanent> targets;\n            targets = threats(abilityControllerId, sourceId, ((TargetControlledPermanent) target).getFilter(), game, target.getTargets());\n            if (!outcome.isGood()) {\n                Collections.reverse(targets);\n            }\n            for (Permanent permanent : targets) {\n                if (((TargetControlledPermanent) target).canTarget(abilityControllerId, permanent.getId(), sourceId, game, false) && !target.getTargets().contains(permanent.getId())) {\n                    target.add(permanent.getId(), game);\n                    return true;\n                }\n            }\n            return false;\n        }\n        if (target instanceof TargetPermanent) {\n            List<Permanent> targets;\n            if (outcome.isCanTargetAll()) {\n                targets = threats(null, sourceId, ((TargetPermanent) target).getFilter(), game, target.getTargets());\n            } else {\n                if (outcome.isGood()) {\n                    targets = threats(abilityControllerId, sourceId, ((TargetPermanent) target).getFilter(), game, target.getTargets());\n                } else {\n                    targets = threats(opponentId, sourceId, ((TargetPermanent) target).getFilter(), game, target.getTargets());\n                }\n                if (targets.isEmpty() && target.isRequired()) {\n                    if (!outcome.isGood()) {\n                        targets = threats(abilityControllerId, sourceId, ((TargetPermanent) target).getFilter(), game, target.getTargets());\n                    } else {\n                        targets = threats(opponentId, sourceId, ((TargetPermanent) target).getFilter(), game, target.getTargets());\n                    }\n                }\n            }\n            for (Permanent permanent : targets) {\n                if (((TargetPermanent) target).canTarget(abilityControllerId, permanent.getId(), null, game) && !target.getTargets().contains(permanent.getId())) {\n                    // stop to add targets if not needed and outcome is no advantage for AI player\n                    if (target.getNumberOfTargets() == target.getTargets().size()) {\n                        if (outcome.isGood() && hasOpponent(permanent.getControllerId(), game)) {\n                            return true;\n                        }\n                        if (!outcome.isGood() && !hasOpponent(permanent.getControllerId(), game)) {\n                            return true;\n                        }\n                    }\n                    // add the target\n                    target.add(permanent.getId(), game);\n                    if (target.doneChosing()) {\n                        return true;\n                    }\n                }\n            }\n            return target.isChosen();\n        }\n\n        if (target instanceof TargetCardInHand) {\n            List<Card> cards = new ArrayList<>();\n            for (UUID cardId : ((TargetCardInHand) target).possibleTargets(sourceId, this.getId(), game)) {\n                Card card = game.getCard(cardId);\n                if (card != null) {\n                    cards.add(card);\n                }\n            }\n            while ((outcome.isGood() ? target.getTargets().size() < target.getMaxNumberOfTargets() : !target.isChosen())\n                    && !cards.isEmpty()) {\n                Card pick = pickTarget(cards, outcome, target, null, game);\n                if (pick != null) {\n                    target.addTarget(pick.getId(), null, game);\n                    cards.remove(pick);\n                }\n            }\n            return target.isChosen();\n        }\n        if (target instanceof TargetCreatureOrPlayer) {\n            List<Permanent> targets;\n            TargetCreatureOrPlayer t = ((TargetCreatureOrPlayer) target);\n            if (outcome.isGood()) {\n                targets = threats(abilityControllerId, sourceId, ((FilterCreatureOrPlayer) t.getFilter()).getCreatureFilter(), game, target.getTargets());\n            } else {\n                targets = threats(opponentId, sourceId, ((FilterCreatureOrPlayer) t.getFilter()).getCreatureFilter(), game, target.getTargets());\n            }\n            for (Permanent permanent : targets) {\n                List<UUID> alreadyTargetted = target.getTargets();\n                if (t.canTarget(abilityControllerId, permanent.getId(), null, game)) {\n                    if (alreadyTargetted != null && !alreadyTargetted.contains(permanent.getId())) {\n                        target.add(permanent.getId(), game);\n                        return true;\n                    }\n                }\n            }\n            if (outcome.isGood()) {\n                if (target.canTarget(abilityControllerId, null, game)) {\n                    target.add(abilityControllerId, game);\n                    return true;\n                }\n            } else {\n                if (target.canTarget(opponentId, null, game)) {\n                    target.add(opponentId, game);\n                    return true;\n                }\n            }\n            if (!target.isRequired(sourceId, game)) {\n                return false;\n            }\n        }\n\n        if (target instanceof TargetPermanentOrPlayer) {\n            List<Permanent> targets;\n            TargetPermanentOrPlayer t = ((TargetPermanentOrPlayer) target);\n            List<Permanent> ownedTargets = threats(abilityControllerId, sourceId, ((FilterPermanentOrPlayer) t.getFilter()).getPermanentFilter(), game, target.getTargets());;\n            List<Permanent> opponentTargets = threats(opponentId, sourceId, ((FilterPermanentOrPlayer) t.getFilter()).getPermanentFilter(), game, target.getTargets());\n            if (outcome.isGood()) {\n                targets = ownedTargets;\n            } else {\n                targets = opponentTargets;\n            }\n            for (Permanent permanent : targets) {\n                List<UUID> alreadyTargetted = target.getTargets();\n                if (t.canTarget(permanent.getId(), game)) {\n                    if (alreadyTargetted != null && !alreadyTargetted.contains(permanent.getId())) {\n                        target.add(permanent.getId(), game);\n                        return true;\n                    }\n                }\n            }\n            if (outcome.isGood()) {\n                if (target.canTarget(abilityControllerId, null, game)) {\n                    target.add(abilityControllerId, game);\n                    return true;\n                }\n            } else {\n                if (target.canTarget(opponentId, null, game)) {\n                    target.add(opponentId, game);\n                    return true;\n                }\n            }\n            if (!target.isRequired(sourceId, game) || target.getNumberOfTargets() == 0) {\n                return false;\n            }\n            if (target.canTarget(opponentId, null, game)) {\n                target.add(opponentId, game);\n                return true;\n            }\n            if (target.canTarget(abilityControllerId, null, game)) {\n                target.add(abilityControllerId, game);\n                return true;\n            }\n            if (outcome.isGood()) { // no other valid targets so use a permanent\n                targets = opponentTargets;\n            } else {\n                targets = ownedTargets;\n            }\n            for (Permanent permanent : targets) {\n                List<UUID> alreadyTargetted = target.getTargets();\n                if (t.canTarget(permanent.getId(), game)) {\n                    if (alreadyTargetted != null && !alreadyTargetted.contains(permanent.getId())) {\n                        target.add(permanent.getId(), game);\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        if (target instanceof TargetCardInGraveyard) {\n            List<Card> cards = new ArrayList<>();\n            for (Player player : game.getPlayers().values()) {\n                for (Card card : player.getGraveyard().getCards(game)) {\n                    if (target.canTarget(card.getId(), game)) {\n                        cards.add(card);\n                    }\n                }\n            }\n            for (Card card : cards) {\n                target.add(card.getId(), game);\n                if (target.isChosen()) {\n                    return true;\n                }\n            }\n            return target.isChosen();\n        }\n\n        if (target instanceof TargetCardInYourGraveyard) {\n            List<UUID> alreadyTargetted = target.getTargets();\n            List<Card> cards = new ArrayList<>(game.getPlayer(abilityControllerId).getGraveyard().getCards(game));\n            while (!cards.isEmpty()) {\n                Card card = pickTarget(cards, outcome, target, null, game);\n                if (card != null && alreadyTargetted != null && !alreadyTargetted.contains(card.getId())) {\n                    target.add(card.getId(), game);\n                    return true;\n                }\n            }\n            return false;\n        }\n        if (target instanceof TargetSource) {\n            Set<UUID> targets;\n            TargetSource t = ((TargetSource) target);\n            targets = t.possibleTargets(sourceId, abilityControllerId, game);\n            for (UUID targetId : targets) {\n                MageObject targetObject = game.getObject(targetId);\n                if (targetObject != null) {\n                    List<UUID> alreadyTargetted = target.getTargets();\n                    if (t.canTarget(targetObject.getId(), game)) {\n                        if (alreadyTargetted != null && !alreadyTargetted.contains(targetObject.getId())) {\n                            target.add(targetObject.getId(), game);\n                            return true;\n                        }\n                    }\n                }\n            }\n            if (!target.isRequired(sourceId, game)) {\n                return false;\n            }\n            throw new IllegalStateException(\"TargetSource wasn't handled. class:\" + target.getClass().toString());\n        }\n\n        throw new IllegalStateException(\"Target wasn't handled. class:\" + target.getClass().toString());\n    }","id":6302,"modified_method":"@Override\n    public boolean choose(Outcome outcome, Target target, UUID sourceId, Game game, Map<String, Serializable> options) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"chooseTarget: \" + outcome.toString() + \":\" + target.toString());\n        }\n        // sometimes a target selection can be made from a player that does not control the ability\n        UUID abilityControllerId = playerId;\n        if (target.getTargetController() != null && target.getAbilityController() != null) {\n            abilityControllerId = target.getAbilityController();\n        }\n        UUID opponentId = game.getOpponents(abilityControllerId).iterator().next();\n        if (target instanceof TargetPlayer) {\n            if (outcome.isGood()) {\n                if (target.canTarget(abilityControllerId, game)) {\n                    target.add(abilityControllerId, game);\n                    return true;\n                }\n                if (target.isRequired(sourceId, game)) {\n                    if (target.canTarget(opponentId, game)) {\n                        target.add(opponentId, game);\n                        return true;\n                    }\n                }\n            } else {\n                if (target.canTarget(opponentId, game)) {\n                    target.add(opponentId, game);\n                    return true;\n                }\n                if (target.isRequired(sourceId, game)) {\n                    if (target.canTarget(abilityControllerId, game)) {\n                        target.add(abilityControllerId, game);\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        if (target instanceof TargetDiscard) {\n            findPlayables(game);\n            if (unplayable.size() > 0) {\n                for (int i = unplayable.size() - 1; i >= 0; i--) {\n                    if (target.canTarget(unplayable.values().toArray(new Card[0])[i].getId(), game)) {\n                        target.add(unplayable.values().toArray(new Card[0])[i].getId(), game);\n                        if (target.isChosen()) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            if (hand.size() > 0) {\n                for (int i = 0; i < hand.size(); i++) {\n                    if (target.canTarget(hand.toArray(new UUID[0])[i], game)) {\n                        target.add(hand.toArray(new UUID[0])[i], game);\n                        if (target.isChosen()) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n        if (target instanceof TargetControlledPermanent) {\n            List<Permanent> targets;\n            targets = threats(abilityControllerId, sourceId, ((TargetControlledPermanent) target).getFilter(), game, target.getTargets());\n            if (!outcome.isGood()) {\n                Collections.reverse(targets);\n            }\n            for (Permanent permanent : targets) {\n                if (((TargetControlledPermanent) target).canTarget(abilityControllerId, permanent.getId(), sourceId, game, false) && !target.getTargets().contains(permanent.getId())) {\n                    target.add(permanent.getId(), game);\n                    return true;\n                }\n            }\n            return false;\n        }\n        if (target instanceof TargetPermanent) {\n            List<Permanent> targets;\n            if (outcome.isCanTargetAll()) {\n                targets = threats(null, sourceId, ((TargetPermanent) target).getFilter(), game, target.getTargets());\n            } else {\n                if (outcome.isGood()) {\n                    targets = threats(abilityControllerId, sourceId, ((TargetPermanent) target).getFilter(), game, target.getTargets());\n                } else {\n                    targets = threats(opponentId, sourceId, ((TargetPermanent) target).getFilter(), game, target.getTargets());\n                }\n                if (targets.isEmpty() && target.isRequired()) {\n                    if (!outcome.isGood()) {\n                        targets = threats(abilityControllerId, sourceId, ((TargetPermanent) target).getFilter(), game, target.getTargets());\n                    } else {\n                        targets = threats(opponentId, sourceId, ((TargetPermanent) target).getFilter(), game, target.getTargets());\n                    }\n                }\n            }\n            for (Permanent permanent : targets) {\n                if (((TargetPermanent) target).canTarget(abilityControllerId, permanent.getId(), null, game) && !target.getTargets().contains(permanent.getId())) {\n                    // stop to add targets if not needed and outcome is no advantage for AI player\n                    if (target.getNumberOfTargets() == target.getTargets().size()) {\n                        if (outcome.isGood() && hasOpponent(permanent.getControllerId(), game)) {\n                            return true;\n                        }\n                        if (!outcome.isGood() && !hasOpponent(permanent.getControllerId(), game)) {\n                            return true;\n                        }\n                    }\n                    // add the target\n                    target.add(permanent.getId(), game);\n                    if (target.doneChosing()) {\n                        return true;\n                    }\n                }\n            }\n            return target.isChosen();\n        }\n\n        if (target instanceof TargetCardInHand\n                || (target.getZone().equals(Zone.HAND) && (target instanceof TargetCard))) {\n            List<Card> cards = new ArrayList<>();\n            for (UUID cardId : target.possibleTargets(sourceId, this.getId(), game)) {\n                Card card = game.getCard(cardId);\n                if (card != null) {\n                    cards.add(card);\n                }\n            }\n            while ((outcome.isGood() ? target.getTargets().size() < target.getMaxNumberOfTargets() : !target.isChosen())\n                    && !cards.isEmpty()) {\n                Card pick = pickTarget(cards, outcome, target, null, game);\n                if (pick != null) {\n                    target.addTarget(pick.getId(), null, game);\n                    cards.remove(pick);\n                }\n            }\n            return target.isChosen();\n        }\n        if (target instanceof TargetCreatureOrPlayer) {\n            List<Permanent> targets;\n            TargetCreatureOrPlayer t = ((TargetCreatureOrPlayer) target);\n            if (outcome.isGood()) {\n                targets = threats(abilityControllerId, sourceId, ((FilterCreatureOrPlayer) t.getFilter()).getCreatureFilter(), game, target.getTargets());\n            } else {\n                targets = threats(opponentId, sourceId, ((FilterCreatureOrPlayer) t.getFilter()).getCreatureFilter(), game, target.getTargets());\n            }\n            for (Permanent permanent : targets) {\n                List<UUID> alreadyTargetted = target.getTargets();\n                if (t.canTarget(abilityControllerId, permanent.getId(), null, game)) {\n                    if (alreadyTargetted != null && !alreadyTargetted.contains(permanent.getId())) {\n                        target.add(permanent.getId(), game);\n                        return true;\n                    }\n                }\n            }\n            if (outcome.isGood()) {\n                if (target.canTarget(abilityControllerId, null, game)) {\n                    target.add(abilityControllerId, game);\n                    return true;\n                }\n            } else {\n                if (target.canTarget(opponentId, null, game)) {\n                    target.add(opponentId, game);\n                    return true;\n                }\n            }\n            if (!target.isRequired(sourceId, game)) {\n                return false;\n            }\n        }\n\n        if (target instanceof TargetPermanentOrPlayer) {\n            List<Permanent> targets;\n            TargetPermanentOrPlayer t = ((TargetPermanentOrPlayer) target);\n            List<Permanent> ownedTargets = threats(abilityControllerId, sourceId, ((FilterPermanentOrPlayer) t.getFilter()).getPermanentFilter(), game, target.getTargets());;\n            List<Permanent> opponentTargets = threats(opponentId, sourceId, ((FilterPermanentOrPlayer) t.getFilter()).getPermanentFilter(), game, target.getTargets());\n            if (outcome.isGood()) {\n                targets = ownedTargets;\n            } else {\n                targets = opponentTargets;\n            }\n            for (Permanent permanent : targets) {\n                List<UUID> alreadyTargetted = target.getTargets();\n                if (t.canTarget(permanent.getId(), game)) {\n                    if (alreadyTargetted != null && !alreadyTargetted.contains(permanent.getId())) {\n                        target.add(permanent.getId(), game);\n                        return true;\n                    }\n                }\n            }\n            if (outcome.isGood()) {\n                if (target.canTarget(abilityControllerId, null, game)) {\n                    target.add(abilityControllerId, game);\n                    return true;\n                }\n            } else {\n                if (target.canTarget(opponentId, null, game)) {\n                    target.add(opponentId, game);\n                    return true;\n                }\n            }\n            if (!target.isRequired(sourceId, game) || target.getNumberOfTargets() == 0) {\n                return false;\n            }\n            if (target.canTarget(opponentId, null, game)) {\n                target.add(opponentId, game);\n                return true;\n            }\n            if (target.canTarget(abilityControllerId, null, game)) {\n                target.add(abilityControllerId, game);\n                return true;\n            }\n            if (outcome.isGood()) { // no other valid targets so use a permanent\n                targets = opponentTargets;\n            } else {\n                targets = ownedTargets;\n            }\n            for (Permanent permanent : targets) {\n                List<UUID> alreadyTargetted = target.getTargets();\n                if (t.canTarget(permanent.getId(), game)) {\n                    if (alreadyTargetted != null && !alreadyTargetted.contains(permanent.getId())) {\n                        target.add(permanent.getId(), game);\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        if (target instanceof TargetCardInGraveyard) {\n            List<Card> cards = new ArrayList<>();\n            for (Player player : game.getPlayers().values()) {\n                for (Card card : player.getGraveyard().getCards(game)) {\n                    if (target.canTarget(card.getId(), game)) {\n                        cards.add(card);\n                    }\n                }\n            }\n            for (Card card : cards) {\n                target.add(card.getId(), game);\n                if (target.isChosen()) {\n                    return true;\n                }\n            }\n            return target.isChosen();\n        }\n\n        if (target instanceof TargetCardInYourGraveyard) {\n            List<UUID> alreadyTargetted = target.getTargets();\n            List<Card> cards = new ArrayList<>(game.getPlayer(abilityControllerId).getGraveyard().getCards(game));\n            while (!cards.isEmpty()) {\n                Card card = pickTarget(cards, outcome, target, null, game);\n                if (card != null && alreadyTargetted != null && !alreadyTargetted.contains(card.getId())) {\n                    target.add(card.getId(), game);\n                    return true;\n                }\n            }\n            return false;\n        }\n        if (target instanceof TargetSource) {\n            Set<UUID> targets;\n            TargetSource t = ((TargetSource) target);\n            targets = t.possibleTargets(sourceId, abilityControllerId, game);\n            for (UUID targetId : targets) {\n                MageObject targetObject = game.getObject(targetId);\n                if (targetObject != null) {\n                    List<UUID> alreadyTargetted = target.getTargets();\n                    if (t.canTarget(targetObject.getId(), game)) {\n                        if (alreadyTargetted != null && !alreadyTargetted.contains(targetObject.getId())) {\n                            target.add(targetObject.getId(), game);\n                            return true;\n                        }\n                    }\n                }\n            }\n            if (!target.isRequired(sourceId, game)) {\n                return false;\n            }\n            throw new IllegalStateException(\"TargetSource wasn't handled. class:\" + target.getClass().toString());\n        }\n\n        throw new IllegalStateException(\"Target wasn't handled. class:\" + target.getClass().toString());\n    }","commit_id":"ae69986aef21f38fc434664e731292c49e7b31f0","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        MageObject sourceObject = game.getObject(source.getSourceId());\n        if (controller != null && sourceObject != null) {\n            int affectedTargets = 0;\n            for (UUID uuid : targetPointer.getTargets(game, source)) {\n                Permanent permanent = game.getPermanent(uuid);\n                if (permanent != null) {\n                    if (counter != null) {\n                        Counter newCounter = counter.copy();\n                        newCounter.add(amount.calculate(game, source, this));\n                        int before = permanent.getCounters().getCount(counter.getName());\n                        permanent.addCounters(newCounter, game);\n                        int numberAdded = permanent.getCounters().getCount(counter.getName()) - before;\n                        affectedTargets ++;\n                        if (!game.isSimulation()) {\n                            game.informPlayers(sourceObject.getLogName() +\": \"+ controller.getLogName()+ \" puts \" +\n                                numberAdded + \" \" + counter.getName().toLowerCase() + \" counter on \" + permanent.getLogName());\n                        }\n                    }\n                } else {\n                    Player player = game.getPlayer(uuid);\n                    if (player != null) {\n                        Counter newCounter = counter.copy();\n                        newCounter.add(amount.calculate(game, source, this));\n                        player.addCounters(newCounter, game);\n                        affectedTargets ++;\n                        if (!game.isSimulation())\n                            game.informPlayers(new StringBuilder(sourceObject.getLogName()).append(\": \")\n                                .append(controller.getLogName()).append(\" puts \")\n                                .append(counter.getCount()).append(\" \").append(counter.getName().toLowerCase())\n                                .append(\" counter on \").append(player.getLogName()).toString());                        \n                    }\n                }\n            }  \n            return affectedTargets > 0;\n        }\n        return false;\n    }","id":6303,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        MageObject sourceObject = game.getObject(source.getSourceId());\n        if (controller != null && sourceObject != null) {\n            int affectedTargets = 0;\n            for (UUID uuid : targetPointer.getTargets(game, source)) {\n                Permanent permanent = game.getPermanent(uuid);\n                if (permanent != null) {\n                    if (counter != null) {\n                        Counter newCounter = counter.copy();\n                        newCounter.add(amount.calculate(game, source, this));\n                        int before = permanent.getCounters().getCount(counter.getName());\n                        permanent.addCounters(newCounter, game);\n                        int numberAdded = permanent.getCounters().getCount(counter.getName()) - before;\n                        affectedTargets ++;\n                        if (!game.isSimulation()) {\n                            game.informPlayers(sourceObject.getLogName() +\": \"+ controller.getLogName()+ \" puts \" +\n                                numberAdded + \" \" + counter.getName().toLowerCase() + \" counter on \" + permanent.getLogName());\n                        }\n                    }\n                } else {\n                    Player player = game.getPlayer(uuid);\n                    if (player != null) {\n                        Counter newCounter = counter.copy();\n                        newCounter.add(amount.calculate(game, source, this));\n                        player.addCounters(newCounter, game);\n                        affectedTargets ++;\n                        if (!game.isSimulation()) {\n                            game.informPlayers(sourceObject.getLogName() +\": \" + controller.getLogName() + \" puts \" +\n                                    counter.getCount() + \" \" + counter.getName().toLowerCase() + \" counter on \" + player.getLogName());\n                        }                        \n                    }\n                }\n            }  \n            return affectedTargets > 0;\n        }\n        return false;\n    }","commit_id":"7bc8ff9955bb5fcc04d1d09b64247d195f09c7d5","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Permanent permanent = game.getPermanent(source.getFirstTarget());\n        if (permanent != null) {\n            if (permanent.moveToExile(source.getSourceId(), \"Otherworldly Journey\", source.getSourceId(), game)) {\n                ExileZone exile = game.getExile().getExileZone(source.getSourceId());\n                // only if permanent is in exile (tokens would be stop to exist)\n                if (exile != null && !exile.isEmpty()) {\n                    //create delayed triggered ability\n                    AtTheBeginOfNextEndStepDelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(\n                            new ReturnFromExileEffect(source.getSourceId(), Zone.BATTLEFIELD, \"return that card to the battlefield under its owner's control with a +1/+1 counter on it\"));\n                    delayedAbility.setSourceId(source.getSourceId());\n                    delayedAbility.setControllerId(source.getControllerId());\n                    delayedAbility.setSourceObject(source.getSourceObject(game), game);\n                    AddCountersTargetEffect effect = new AddCountersTargetEffect(CounterType.P1P1.createInstance());\n                    effect.setTargetPointer(new FixedTarget(source.getFirstTarget()));\n                    delayedAbility.addEffect(effect);\n                    game.addDelayedTriggeredAbility(delayedAbility);\n                }\n                return true;\n            }\n        }\n        return false;\n    }","id":6304,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Permanent permanent = game.getPermanent(source.getFirstTarget());\n        if (permanent != null) {\n            if (permanent.moveToExile(source.getSourceId(), \"Otherworldly Journey\", source.getSourceId(), game)) {\n                ExileZone exile = game.getExile().getExileZone(source.getSourceId());\n                // only if permanent is in exile (tokens would be stop to exist)\n                if (exile != null && !exile.isEmpty()) {\n                    Card card = game.getCard(permanent.getId());\n                    if (card != null) {\n                        //create delayed triggered ability\n                        DelayedTriggeredAbility delayedAbility = \n                                new AtTheBeginOfNextEndStepDelayedTriggeredAbility(new OtherworldlyJourneyReturnFromExileEffect(new MageObjectReference(card, game)));\n                        delayedAbility.setSourceId(source.getSourceId());\n                        delayedAbility.setControllerId(source.getControllerId());\n                        delayedAbility.setSourceObject(source.getSourceObject(game), game);\n                        AddCountersTargetEffect effect = new AddCountersTargetEffect(CounterType.P1P1.createInstance());\n                        effect.setTargetPointer(new FixedTarget(source.getFirstTarget()));\n                        delayedAbility.addEffect(effect);\n                        game.addDelayedTriggeredAbility(delayedAbility);                    \n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"7bc8ff9955bb5fcc04d1d09b64247d195f09c7d5","url":"https://github.com/magefree/mage"},{"original_method":"public OtherworldlyJourney(UUID ownerId) {\n        super(ownerId, 37, \"Otherworldly Journey\", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, \"{1}{W}\");\n        this.expansionSetCode = \"CHK\";\n        this.subtype.add(\"Arcane\");\n        this.color.setWhite(true);\n        // Exile target creature. At the beginning of the next end step, return that card to the battlefield under its owner's control with a +1/+1 counter on it.\n        this.getSpellAbility().addEffect(new OtherworldlyJourneyEffect());\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent());\n    }","id":6305,"modified_method":"public OtherworldlyJourney(UUID ownerId) {\n        super(ownerId, 37, \"Otherworldly Journey\", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, \"{1}{W}\");\n        this.expansionSetCode = \"CHK\";\n        this.subtype.add(\"Arcane\");\n        \n        // Exile target creature. At the beginning of the next end step, return that card to the battlefield under its owner's control with a +1/+1 counter on it.\n        this.getSpellAbility().addEffect(new OtherworldlyJourneyEffect());\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent());\n    }","commit_id":"7bc8ff9955bb5fcc04d1d09b64247d195f09c7d5","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        Permanent permanent = game.getPermanent(source.getSourceId());\n        if (controller != null && permanent != null) {\n            ChoiceColor choice = new ChoiceColor();\n            while (!choice.isChosen()) {\n                controller.choose(outcome, choice, game);\n                if (!controller.isInGame()) {\n                    return false;\n                }\n            }\n            if (!game.isSimulation()) {\n                game.informPlayers(new StringBuilder(permanent.getLogName()).append(\": \").append(controller.getLogName()).append(\" has chosen \").append(choice.getChoice()).toString());\n            }\n            game.getState().setValue(source.getSourceId() + \"_color\", choice.getColor());\n            permanent.addInfo(\"chosen color\", \"<font color = 'blue'>Chosen color: \" + choice.getColor().getDescription() + \"<\/font>\", game);\n            return true;\n        }\n        return false;\n    }","id":6306,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        Permanent permanent = game.getPermanent(source.getSourceId());\n        if (controller != null && permanent != null) {\n            ChoiceColor choice = new ChoiceColor();\n            while (!choice.isChosen()) {\n                controller.choose(outcome, choice, game);\n                if (!controller.isInGame()) {\n                    return false;\n                }\n            }\n            if (!game.isSimulation()) {\n                game.informPlayers(permanent.getLogName()+\": \"+controller.getLogName()+\" has chosen \"+choice.getChoice());\n            }\n            game.getState().setValue(source.getSourceId() + \"_color\", choice.getColor());\n            permanent.addInfo(\"chosen color\", CardUtil.addToolTipMarkTags(\"Chosen color: \" + choice.getChoice()), game);\n            return true;\n        }\n        return false;\n    }","commit_id":"8f39a0ba1db7fd009d309ec2e64967410c8a8cc9","url":"https://github.com/magefree/mage"},{"original_method":"public IonaShieldOfEmeria(UUID ownerId) {\r\n        super(ownerId, 13, \"Iona, Shield of Emeria\", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, \"{6}{W}{W}{W}\");\r\n        this.expansionSetCode = \"ZEN\";\r\n        this.supertype.add(\"Legendary\");\r\n        this.subtype.add(\"Angel\");\r\n\r\n        this.power = new MageInt(7);\r\n        this.toughness = new MageInt(7);\r\n\r\n        // Flying\r\n        this.addAbility(FlyingAbility.getInstance());\r\n\r\n        // As Iona, Shield of Emeria enters the battlefield, choose a color.\r\n        this.addAbility(new AsEntersBattlefieldAbility(new IonaShieldOfEmeriaChooseColorEffect()));\r\n\r\n        // Your opponents can't cast spells of the chosen color.\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new IonaShieldOfEmeriaReplacementEffect()));\r\n\r\n    }","id":6307,"modified_method":"public IonaShieldOfEmeria(UUID ownerId) {\r\n        super(ownerId, 13, \"Iona, Shield of Emeria\", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, \"{6}{W}{W}{W}\");\r\n        this.expansionSetCode = \"ZEN\";\r\n        this.supertype.add(\"Legendary\");\r\n        this.subtype.add(\"Angel\");\r\n\r\n        this.power = new MageInt(7);\r\n        this.toughness = new MageInt(7);\r\n\r\n        // Flying\r\n        this.addAbility(FlyingAbility.getInstance());\r\n\r\n        // As Iona, Shield of Emeria enters the battlefield, choose a color.\r\n        this.addAbility(new AsEntersBattlefieldAbility(new ChooseColorEffect(Outcome.Benefit)));\r\n\r\n        // Your opponents can't cast spells of the chosen color.\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new IonaShieldOfEmeriaReplacementEffect()));\r\n\r\n    }","commit_id":"8f39a0ba1db7fd009d309ec2e64967410c8a8cc9","url":"https://github.com/magefree/mage"},{"original_method":"private void testCollectionTrackerInnerLoop(CollectionTracker tracker, final SnmpObjId[] expectedOids, SnmpObjId[] receivedOids, final int nonRepeaters) {\n        class OidCheckedPduBuilder extends PduBuilder {\n            int count = 0;\n\n            public void addOid(SnmpObjId snmpObjId) {\n                assertEquals(expectedOids[count].decrement(), snmpObjId);\n                count++;\n            }\n\n            public void setNonRepeaters(int numNonRepeaters) {\n                assertEquals(nonRepeaters, numNonRepeaters);\n            }\n\n            public void setMaxRepetitions(int maxRepititions) {\n                assertTrue(\"MaxRepititions must be positive\", maxRepititions > 0);\n            }\n            \n            public int getCount() {\n                return count;\n            }\n            \n        }\n\n        // ensure it needs to receive something - object id for the instance\n        assertFalse(tracker.isFinished());\n        // ensure that is asks for the oid preceeding\n        OidCheckedPduBuilder builder = new OidCheckedPduBuilder();\n        ResponseProcessor rp = tracker.buildNextPdu(builder);\n        assertNotNull(rp);\n        assertEquals(expectedOids.length, builder.getCount());\n        rp.processErrors(0, 0);\n        for(int i = 0; i < receivedOids.length; i++)\n            rp.processResponse(receivedOids[i], SnmpUtils.getValueFactory().getOctetString(\"Value\".getBytes()));\n        \n        \n    }","id":6308,"modified_method":"private void testCollectionTrackerInnerLoop(CollectionTracker tracker, final SnmpObjId[] expectedOids, SnmpObjId[] receivedOids, final int nonRepeaters) {\n        class OidCheckedPduBuilder extends PduBuilder {\n            int count = 0;\n\n            public void addOid(SnmpObjId snmpObjId) {\n                assertEquals(expectedOids[count].decrement(), snmpObjId);\n                count++;\n            }\n\n            public void setNonRepeaters(int numNonRepeaters) {\n                assertEquals(nonRepeaters, numNonRepeaters);\n            }\n\n            public void setMaxRepetitions(int maxRepititions) {\n                assertTrue(\"MaxRepititions must be positive\", maxRepititions > 0);\n            }\n            \n            public int getCount() {\n                return count;\n            }\n            \n        }\n\n        // ensure it needs to receive something - object id for the instance\n        assertFalse(tracker.isFinished());\n        // ensure that is asks for the OID preceding\n        OidCheckedPduBuilder builder = new OidCheckedPduBuilder();\n        ResponseProcessor rp = tracker.buildNextPdu(builder);\n        assertNotNull(rp);\n        assertEquals(expectedOids.length, builder.getCount());\n        rp.processErrors(0, 0);\n        for (SnmpObjId receivedOid : receivedOids) {\n            rp.processResponse(receivedOid, SnmpUtils.getValueFactory().getOctetString(\"Value\".getBytes()));\n        }\n        \n        \n    }","commit_id":"80d71ada5ba27bb8ac9122a9a1f6b902ad9c9c88","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void storeResult(SnmpObjId base, SnmpInstId inst, SnmpValue val) {\n            m_storageCalled = true;\n            assertTrue(m_expectsStorageCall);\n        }","id":6309,"modified_method":"protected void storeResult(SnmpResult res) {\n            m_storageCalled = true;\n            assertTrue(m_expectsStorageCall);\n        }","commit_id":"80d71ada5ba27bb8ac9122a9a1f6b902ad9c9c88","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void storeResult(SnmpObjId base, SnmpInstId inst, SnmpValue val) {\n            m_storageCalled = true;\n            assertTrue(m_expectsStorageCall);\n        }","id":6310,"modified_method":"protected void storeResult(SnmpResult res) {\n            m_storageCalled = true;\n            assertTrue(m_expectsStorageCall);\n        }","commit_id":"11f6ea2aa3526d4464f95c3f877618e69050059d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void testCollectionTrackerInnerLoop(CollectionTracker tracker, final SnmpObjId[] expectedOids, SnmpObjId[] receivedOids, final int nonRepeaters) {\n        class OidCheckedPduBuilder extends PduBuilder {\n            int count = 0;\n\n            public void addOid(SnmpObjId snmpObjId) {\n                assertEquals(expectedOids[count].decrement(), snmpObjId);\n                count++;\n            }\n\n            public void setNonRepeaters(int numNonRepeaters) {\n                assertEquals(nonRepeaters, numNonRepeaters);\n            }\n\n            public void setMaxRepetitions(int maxRepititions) {\n                assertTrue(\"MaxRepititions must be positive\", maxRepititions > 0);\n            }\n            \n            public int getCount() {\n                return count;\n            }\n            \n        }\n\n        // ensure it needs to receive something - object id for the instance\n        assertFalse(tracker.isFinished());\n        // ensure that is asks for the oid preceeding\n        OidCheckedPduBuilder builder = new OidCheckedPduBuilder();\n        ResponseProcessor rp = tracker.buildNextPdu(builder);\n        assertNotNull(rp);\n        assertEquals(expectedOids.length, builder.getCount());\n        rp.processErrors(0, 0);\n        for(int i = 0; i < receivedOids.length; i++)\n            rp.processResponse(receivedOids[i], SnmpUtils.getValueFactory().getOctetString(\"Value\".getBytes()));\n        \n        \n    }","id":6311,"modified_method":"private void testCollectionTrackerInnerLoop(CollectionTracker tracker, final SnmpObjId[] expectedOids, SnmpObjId[] receivedOids, final int nonRepeaters) {\n        class OidCheckedPduBuilder extends PduBuilder {\n            int count = 0;\n\n            public void addOid(SnmpObjId snmpObjId) {\n                assertEquals(expectedOids[count].decrement(), snmpObjId);\n                count++;\n            }\n\n            public void setNonRepeaters(int numNonRepeaters) {\n                assertEquals(nonRepeaters, numNonRepeaters);\n            }\n\n            public void setMaxRepetitions(int maxRepititions) {\n                assertTrue(\"MaxRepititions must be positive\", maxRepititions > 0);\n            }\n            \n            public int getCount() {\n                return count;\n            }\n            \n        }\n\n        // ensure it needs to receive something - object id for the instance\n        assertFalse(tracker.isFinished());\n        // ensure that is asks for the OID preceding\n        OidCheckedPduBuilder builder = new OidCheckedPduBuilder();\n        ResponseProcessor rp = tracker.buildNextPdu(builder);\n        assertNotNull(rp);\n        assertEquals(expectedOids.length, builder.getCount());\n        rp.processErrors(0, 0);\n        for (SnmpObjId receivedOid : receivedOids) {\n            rp.processResponse(receivedOid, SnmpUtils.getValueFactory().getOctetString(\"Value\".getBytes()));\n        }\n        \n        \n    }","commit_id":"11f6ea2aa3526d4464f95c3f877618e69050059d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void storeResult(SnmpObjId base, SnmpInstId inst, SnmpValue val) {\n            m_storageCalled = true;\n            assertTrue(m_expectsStorageCall);\n        }","id":6312,"modified_method":"protected void storeResult(SnmpResult res) {\n            m_storageCalled = true;\n            assertTrue(m_expectsStorageCall);\n        }","commit_id":"5bb0365b1a475fc31fd40e865a748982537ef3e8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void testCollectionTrackerInnerLoop(CollectionTracker tracker, final SnmpObjId[] expectedOids, SnmpObjId[] receivedOids, final int nonRepeaters) {\n        class OidCheckedPduBuilder extends PduBuilder {\n            int count = 0;\n\n            public void addOid(SnmpObjId snmpObjId) {\n                assertEquals(expectedOids[count].decrement(), snmpObjId);\n                count++;\n            }\n\n            public void setNonRepeaters(int numNonRepeaters) {\n                assertEquals(nonRepeaters, numNonRepeaters);\n            }\n\n            public void setMaxRepetitions(int maxRepititions) {\n                assertTrue(\"MaxRepititions must be positive\", maxRepititions > 0);\n            }\n            \n            public int getCount() {\n                return count;\n            }\n            \n        }\n\n        // ensure it needs to receive something - object id for the instance\n        assertFalse(tracker.isFinished());\n        // ensure that is asks for the oid preceeding\n        OidCheckedPduBuilder builder = new OidCheckedPduBuilder();\n        ResponseProcessor rp = tracker.buildNextPdu(builder);\n        assertNotNull(rp);\n        assertEquals(expectedOids.length, builder.getCount());\n        rp.processErrors(0, 0);\n        for(int i = 0; i < receivedOids.length; i++)\n            rp.processResponse(receivedOids[i], SnmpUtils.getValueFactory().getOctetString(\"Value\".getBytes()));\n        \n        \n    }","id":6313,"modified_method":"private void testCollectionTrackerInnerLoop(CollectionTracker tracker, final SnmpObjId[] expectedOids, SnmpObjId[] receivedOids, final int nonRepeaters) {\n        class OidCheckedPduBuilder extends PduBuilder {\n            int count = 0;\n\n            public void addOid(SnmpObjId snmpObjId) {\n                assertEquals(expectedOids[count].decrement(), snmpObjId);\n                count++;\n            }\n\n            public void setNonRepeaters(int numNonRepeaters) {\n                assertEquals(nonRepeaters, numNonRepeaters);\n            }\n\n            public void setMaxRepetitions(int maxRepititions) {\n                assertTrue(\"MaxRepititions must be positive\", maxRepititions > 0);\n            }\n            \n            public int getCount() {\n                return count;\n            }\n            \n        }\n\n        // ensure it needs to receive something - object id for the instance\n        assertFalse(tracker.isFinished());\n        // ensure that is asks for the OID preceding\n        OidCheckedPduBuilder builder = new OidCheckedPduBuilder();\n        ResponseProcessor rp = tracker.buildNextPdu(builder);\n        assertNotNull(rp);\n        assertEquals(expectedOids.length, builder.getCount());\n        rp.processErrors(0, 0);\n        for (SnmpObjId receivedOid : receivedOids) {\n            rp.processResponse(receivedOid, SnmpUtils.getValueFactory().getOctetString(\"Value\".getBytes()));\n        }\n        \n        \n    }","commit_id":"5bb0365b1a475fc31fd40e865a748982537ef3e8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public SetReference<PrivateNetworkIndex, VmInstance> reclaimNetworkIndex( Long idx ) throws TransactionException {\n    if ( !NetworkGroups.networkingConfiguration( ).hasNetworking( ) ) {\n      try {\n        return PrivateNetworkIndex.bogus( ).allocate( );\n      } catch ( ResourceAllocationException ex ) {\n        throw new RuntimeException( \"BUG BUG BUG: failed to call PrivateNetworkIndex.allocate() on the .bogus() index.\" );\n      }\n    } else if ( !Entities.isPersistent( this ) ) {\n      throw new TransientEntityException( this.toString( ) );\n    } else {\n      SetReference<PrivateNetworkIndex, VmInstance> ref = null;\n      PrivateNetworkIndex netIdx = null;\n      try {\n        netIdx = Entities.uniqueResult( PrivateNetworkIndex.named( this, idx ) );\n        if ( Resource.State.FREE.equals( netIdx.getState( ) ) ) {\n          return netIdx.allocate( );\n        } else {\n          try {\n            netIdx.teardown( );\n            return netIdx.allocate( );\n          } catch ( Exception ex ) {\n            LOG.error( ex , ex );\n          }\n        }\n      } catch ( Exception ex ) {\n        try {\n          netIdx = PrivateNetworkIndex.create( this, idx );\n          Entities.persist( netIdx );\n          this.getIndexes( ).add( netIdx );\n          return netIdx.allocate( );\n        } catch ( Exception ex1 ) {\n          throw new TransactionExecutionException( \"Failed to allocate a private network index in network: \" + this.displayName, ex1 );\n        }\n      }\n    }\n  }","id":6314,"modified_method":"public SetReference<PrivateNetworkIndex, VmInstance> reclaimNetworkIndex( Long idx ) throws TransactionException {\n    if ( !NetworkGroups.networkingConfiguration( ).hasNetworking( ) ) {\n      try {\n        return PrivateNetworkIndex.bogus( ).allocate( );\n      } catch ( ResourceAllocationException ex ) {\n        throw new RuntimeException( \"BUG BUG BUG: failed to call PrivateNetworkIndex.allocate() on the .bogus() index.\" );\n      }\n    } else if ( !Entities.isPersistent( this ) ) {\n      throw new TransientEntityException( this.toString( ) );\n    } else {\n      EntityTransaction db = Entities.get( PrivateNetworkIndex.class );\n      try {\n        try {\n          PrivateNetworkIndex netIdx = Entities.uniqueResult( PrivateNetworkIndex.named( this, idx ) );\n          if ( Resource.State.FREE.equals( netIdx.getState( ) ) ) {\n            SetReference<PrivateNetworkIndex, VmInstance> ref = netIdx.allocate( );\n            db.commit( );\n            return ref;\n          } else {\n            try {\n              netIdx.teardown( );\n            } catch ( Exception ex ) {\n              LOG.error( ex , ex );\n            }\n            SetReference<PrivateNetworkIndex, VmInstance> ref = netIdx.allocate( );\n            db.commit( );\n            return ref;\n          }\n        } catch ( Exception ex ) {\n          try {\n            PrivateNetworkIndex netIdx = PrivateNetworkIndex.create( this, idx );\n            Entities.persist( netIdx );\n            SetReference<PrivateNetworkIndex, VmInstance> ref = netIdx.allocate( );\n            db.commit( );\n            return ref;\n          } catch ( Exception ex1 ) {\n            throw new TransactionExecutionException( \"Failed to allocate a private network index in network: \" + this.displayName, ex1 );\n          }\n        }\n      } catch ( Exception ex ) {\n        Logs.exhaust( ).error( ex, ex );\n        db.rollback( );\n      }\n    }\n  }","commit_id":"fecbcaaf39f4147161839c6c136b434a05320847","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public SetReference<PrivateNetworkIndex, VmInstance> allocateNetworkIndex( ) throws TransactionException {\n    if ( !NetworkGroups.networkingConfiguration( ).hasNetworking( ) ) {\n      try {\n        return PrivateNetworkIndex.bogus( ).allocate( );\n      } catch ( ResourceAllocationException ex ) {\n        throw new RuntimeException( \"BUG BUG BUG: failed to call PrivateNetworkIndex.allocate() on the .bogus() index.\" );\n      }\n    } else if ( !Entities.isPersistent( this ) ) {\n      throw new TransientEntityException( this.toString( ) );\n    } else {\n      SetReference<PrivateNetworkIndex, VmInstance> ref = null;\n      try {\n        PrivateNetworkIndex netIdx = null;\n        for ( Long i : Numbers.shuffled( NetworkGroups.networkIndexInterval( ) ) ) {\n          try {\n            Entities.uniqueResult( PrivateNetworkIndex.named( this, i ) );\n            continue;\n          } catch ( Exception ex ) {\n            try {\n              netIdx = PrivateNetworkIndex.create( this, i );\n              Entities.persist( netIdx );\n              this.getIndexes( ).add( netIdx );\n              return netIdx.allocate( );\n            } catch ( Exception ex1 ) {\n              continue;\n            }\n          }\n        }\n        throw new TransactionExecutionException( \"Failed to allocate a private network index in network: \" + this.displayName );\n      } catch ( TransactionException ex ) {\n        throw ex;\n      } catch ( Exception ex ) {\n        throw new TransactionExecutionException( \"Failed to allocate a private network index in network: \" + this.displayName, ex );\n      }\n    }\n  }","id":6315,"modified_method":"public SetReference<PrivateNetworkIndex, VmInstance> allocateNetworkIndex( ) throws TransactionException {\n    if ( !NetworkGroups.networkingConfiguration( ).hasNetworking( ) ) {\n      try {\n        return PrivateNetworkIndex.bogus( ).allocate( );\n      } catch ( ResourceAllocationException ex ) {\n        throw new RuntimeException( \"BUG BUG BUG: failed to call PrivateNetworkIndex.allocate() on the .bogus() index.\" );\n      }\n    } else if ( !Entities.isPersistent( this ) ) {\n      throw new TransientEntityException( this.toString( ) );\n    } else {\n      SetReference<PrivateNetworkIndex, VmInstance> ref = null;\n      try {\n        PrivateNetworkIndex netIdx = null;\n        for ( Long i : Numbers.shuffled( NetworkGroups.networkIndexInterval( ) ) ) {\n          try {\n            Entities.uniqueResult( PrivateNetworkIndex.named( this, i ) );\n            continue;\n          } catch ( Exception ex ) {\n            try {\n              netIdx = PrivateNetworkIndex.create( this, i );\n              Entities.persist( netIdx );\n              return netIdx.allocate( );\n            } catch ( Exception ex1 ) {\n              continue;\n            }\n          }\n        }\n        throw new TransactionExecutionException( \"Failed to allocate a private network index in network: \" + this.displayName );\n      } catch ( TransactionException ex ) {\n        throw ex;\n      } catch ( Exception ex ) {\n        throw new TransactionExecutionException( \"Failed to allocate a private network index in network: \" + this.displayName, ex );\n      }\n    }\n  }","commit_id":"fecbcaaf39f4147161839c6c136b434a05320847","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"protected void executeReadAttribute(final String attributeName, final OperationContext context, final T component, final PathAddress address) {\n        final boolean hasPool = componentType.hasPool();\n        if (COMPONENT_CLASS_NAME.getName().equals(attributeName)) {\n            context.getResult().set(component.getComponentName());\n        } else if (SECURITY_DOMAIN.getName().equals(attributeName)) {\n            final ModelNode result = context.getResult();\n            EJBSecurityMetaData md = component.getSecurityMetaData();\n            if (md != null && md.getSecurityDomain() != null) {\n                result.set(md.getSecurityDomain());\n            }\n        } else if (RUN_AS_ROLE.getName().equals(attributeName)) {\n            final ModelNode result = context.getResult();\n            EJBSecurityMetaData md = component.getSecurityMetaData();\n            if (md != null && md.getRunAs() != null) {\n                result.set(md.getRunAs());\n            }\n        } else if (DECLARED_ROLES.getName().equals(attributeName)) {\n            final ModelNode result = context.getResult();\n            EJBSecurityMetaData md = component.getSecurityMetaData();\n            if (md != null) {\n                result.setEmptyList();\n                Set<String> roles = md.getDeclaredRoles();\n                if (roles != null) {\n                    for (String role : roles) {\n                        result.add(role);\n                    }\n                }\n            }\n        } else if (componentType.hasTimer() && TimerAttributeDefinition.INSTANCE.getName().equals(attributeName)) {\n            TimerAttributeDefinition.addTimers(component, context.getResult());\n        } else if (hasPool && POOL_AVAILABLE_COUNT.getName().equals(attributeName)) {\n            int count = componentType.getPool(component).getAvailableCount();\n            context.getResult().set(count);\n        } else if (hasPool && POOL_CREATE_COUNT.getName().equals(attributeName)) {\n            int count = componentType.getPool(component).getCreateCount();\n            context.getResult().set(count);\n        } else if (hasPool && POOL_NAME.getName().equals(attributeName)) {\n            final String poolName = componentType.pooledComponent(component).getPoolName();\n            context.getResult().set(poolName);\n        } else if (hasPool && POOL_REMOVE_COUNT.getName().equals(attributeName)) {\n            int count = componentType.getPool(component).getRemoveCount();\n            context.getResult().set(count);\n        } else if (hasPool && POOL_CURRENT_SIZE.getName().equals(attributeName)) {\n            int size = componentType.getPool(component).getCurrentSize();\n            context.getResult().set(size);\n        } else if (hasPool && POOL_MAX_SIZE.getName().equals(attributeName)) {\n            int size = componentType.getPool(component).getMaxSize();\n            context.getResult().set(size);\n        } else {\n            // Bug; we were registered for an attribute but there is no code for handling it\n            throw new IllegalStateException(String.format(\"Unknown attribute %s\", attributeName));\n        }\n    }","id":6316,"modified_method":"protected void executeReadAttribute(final String attributeName, final OperationContext context, final T component, final PathAddress address) {\n        final boolean hasPool = componentType.hasPool();\n        if (COMPONENT_CLASS_NAME.getName().equals(attributeName)) {\n            context.getResult().set(component.getComponentName());\n        } else if (SECURITY_DOMAIN.getName().equals(attributeName)) {\n            final ModelNode result = context.getResult();\n            EJBSecurityMetaData md = component.getSecurityMetaData();\n            if (md != null && md.getSecurityDomain() != null) {\n                result.set(md.getSecurityDomain());\n            }\n        } else if (RUN_AS_ROLE.getName().equals(attributeName)) {\n            final ModelNode result = context.getResult();\n            EJBSecurityMetaData md = component.getSecurityMetaData();\n            if (md != null && md.getRunAs() != null) {\n                result.set(md.getRunAs());\n            }\n        } else if (DECLARED_ROLES.getName().equals(attributeName)) {\n            final ModelNode result = context.getResult();\n            EJBSecurityMetaData md = component.getSecurityMetaData();\n            if (md != null) {\n                result.setEmptyList();\n                Set<String> roles = md.getDeclaredRoles();\n                if (roles != null) {\n                    for (String role : roles) {\n                        result.add(role);\n                    }\n                }\n            }\n        } else if (componentType.hasTimer() && TimerAttributeDefinition.INSTANCE.getName().equals(attributeName)) {\n            TimerAttributeDefinition.addTimers(component, context.getResult());\n        } else if (hasPool && POOL_AVAILABLE_COUNT.getName().equals(attributeName)) {\n            final Pool<?> pool = componentType.getPool(component);\n            final ModelNode result = context.getResult();\n            if (pool != null) {\n                result.set(pool.getAvailableCount());\n            }\n        } else if (hasPool && POOL_CREATE_COUNT.getName().equals(attributeName)) {\n            final Pool<?> pool = componentType.getPool(component);\n            final ModelNode result = context.getResult();\n            if (pool != null) {\n                result.set(pool.getCreateCount());\n            }\n        } else if (hasPool && POOL_NAME.getName().equals(attributeName)) {\n            final String poolName = componentType.pooledComponent(component).getPoolName();\n            final ModelNode result = context.getResult();\n            if (poolName != null) {\n                result.set(poolName);\n            }\n        } else if (hasPool && POOL_REMOVE_COUNT.getName().equals(attributeName)) {\n            final Pool<?> pool = componentType.getPool(component);\n            final ModelNode result = context.getResult();\n            if (pool != null) {\n                result.set(pool.getRemoveCount());\n            }\n        } else if (hasPool && POOL_CURRENT_SIZE.getName().equals(attributeName)) {\n            final Pool<?> pool = componentType.getPool(component);\n            final ModelNode result = context.getResult();\n            if (pool != null) {\n                result.set(pool.getCurrentSize());\n            }\n        } else if (hasPool && POOL_MAX_SIZE.getName().equals(attributeName)) {\n            final Pool<?> pool = componentType.getPool(component);\n            final ModelNode result = context.getResult();\n            if (pool != null) {\n                result.set(pool.getMaxSize());\n            }\n        } else {\n            // Bug; we were registered for an attribute but there is no code for handling it\n            throw MESSAGES.unknownAttribute(attributeName);\n        }\n    }","commit_id":"e8e89ef88c73daddef737cfe0f40c9106f28af25","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void validatePool(ModelNode address, ModelNode resourceDescription, ModelNode resource) {\n\n        for (AttributeDefinition attr : POOL_ATTRIBUTES) {\n            final String name = attr.getName();\n            final ModelType expectedType = attr.getType();\n            assertTrue(resourceDescription.get(ATTRIBUTES, name).isDefined());\n            assertEquals(ModelType.STRING, resourceDescription.get(ATTRIBUTES, name, DESCRIPTION).getType());\n            assertEquals(expectedType, resourceDescription.get(ATTRIBUTES, name, TYPE).asType());\n\n            assertTrue(resource.get(name).isDefined());\n            assertEquals(expectedType, resource.get(name).getType());\n        }\n    }","id":6317,"modified_method":"private void validatePool(ModelNode address, ModelNode resourceDescription, ModelNode resource) {\n\n        for (AttributeDefinition attr : POOL_ATTRIBUTES) {\n            final String name = attr.getName();\n            final ModelType expectedType = attr.getType();\n            assertTrue(resourceDescription.get(ATTRIBUTES, name).isDefined());\n            assertEquals(ModelType.STRING, resourceDescription.get(ATTRIBUTES, name, DESCRIPTION).getType());\n            assertEquals(expectedType, resourceDescription.get(ATTRIBUTES, name, TYPE).asType());\n\n            assertTrue(name + \" is not defined\", resource.get(name).isDefined());\n            assertEquals(expectedType, resource.get(name).getType());\n        }\n    }","commit_id":"e8e89ef88c73daddef737cfe0f40c9106f28af25","url":"https://github.com/wildfly/wildfly"},{"original_method":"public Set<SReference> findUsages(Set<SNode> nodes, IScope scope, IAdaptiveProgressMonitor progress, boolean manageTasks) {\n    return (myState.myUseFastFindUsages) ?\n      myFastFindUsagesManager.findUsages(nodes, scope, progress, manageTasks) :\n      myDefaultFindUsagesManager.findUsages(nodes, scope, progress, manageTasks);\n  }","id":6318,"modified_method":"public Set<SReference> findUsages(Set<SNode> nodes, IScope scope, IAdaptiveProgressMonitor progress, boolean manageTasks) {\n    return getRealManager().findUsages(nodes, scope, progress, manageTasks);\n  }","commit_id":"a4b3002f85e983a37d3ae2fac21721eb1f6cba04","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Set<AbstractConceptDeclaration> findDescendants(AbstractConceptDeclaration node, IScope scope) {\n    return (myState.myUseFastFindUsages) ?\n      myFastFindUsagesManager.findDescendants(node, scope) : myDefaultFindUsagesManager.findDescendants(node, scope);\n  }","id":6319,"modified_method":"public Set<AbstractConceptDeclaration> findDescendants(AbstractConceptDeclaration node, IScope scope) {\n    return getRealManager().findDescendants(node, scope);\n  }","commit_id":"a4b3002f85e983a37d3ae2fac21721eb1f6cba04","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<SNode> findInstances(SNode conceptDeclaration, IScope scope) {\n    return (myState.myUseFastFindUsages) ?\n      myFastFindUsagesManager.findInstances(conceptDeclaration, scope) :\n      myDefaultFindUsagesManager.findInstances(conceptDeclaration, scope);\n  }","id":6320,"modified_method":"public List<SNode> findInstances(SNode conceptDeclaration, IScope scope) {\n    return getRealManager().findInstances(conceptDeclaration, scope);\n  }","commit_id":"a4b3002f85e983a37d3ae2fac21721eb1f6cba04","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Set<SReference> findUsages(SNode node, IScope scope, IAdaptiveProgressMonitor progress) {\n    return (myState.myUseFastFindUsages) ?\n      myFastFindUsagesManager.findUsages(node, scope, progress) : myDefaultFindUsagesManager.findUsages(node, scope, progress);\n\n  }","id":6321,"modified_method":"public Set<SReference> findUsages(SNode node, IScope scope, IAdaptiveProgressMonitor progress) {\n    return getRealManager().findUsages(node, scope, progress);\n\n  }","commit_id":"a4b3002f85e983a37d3ae2fac21721eb1f6cba04","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Set<SReference> findUsages(SNode node, IScope scope) {\n    return (myState.myUseFastFindUsages) ?\n      myFastFindUsagesManager.findUsages(node, scope) : myDefaultFindUsagesManager.findUsages(node, scope);\n  }","id":6322,"modified_method":"public Set<SReference> findUsages(SNode node, IScope scope) {\n    return getRealManager().findUsages(node, scope);\n  }","commit_id":"a4b3002f85e983a37d3ae2fac21721eb1f6cba04","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<SNode> findInstances(SNode conceptDeclaration, IScope scope, IAdaptiveProgressMonitor monitor) {\n    return (myState.myUseFastFindUsages) ?\n      myFastFindUsagesManager.findInstances(conceptDeclaration, scope, monitor) :\n      myDefaultFindUsagesManager.findInstances(conceptDeclaration, scope, monitor);\n  }","id":6323,"modified_method":"public List<SNode> findInstances(SNode conceptDeclaration, IScope scope, IAdaptiveProgressMonitor monitor) {\n    return getRealManager().findInstances(conceptDeclaration, scope, monitor);\n  }","commit_id":"a4b3002f85e983a37d3ae2fac21721eb1f6cba04","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Set<SNode> findExactInstances(AbstractConceptDeclaration concept, IScope scope, IAdaptiveProgressMonitor progress, boolean manageTasks) {\n    return (myState.myUseFastFindUsages) ?\n      myFastFindUsagesManager.findExactInstances(concept, scope, progress, manageTasks) :\n      myDefaultFindUsagesManager.findExactInstances(concept, scope, progress, manageTasks);\n  }","id":6324,"modified_method":"public Set<SNode> findExactInstances(AbstractConceptDeclaration concept, IScope scope, IAdaptiveProgressMonitor progress, boolean manageTasks) {\n    return getRealManager().findExactInstances(concept, scope, progress, manageTasks);\n  }","commit_id":"a4b3002f85e983a37d3ae2fac21721eb1f6cba04","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Set<SNode> findInstances(AbstractConceptDeclaration concept, IScope scope, IAdaptiveProgressMonitor progress, boolean manageTasks) {\n    return (myState.myUseFastFindUsages) ?\n      myFastFindUsagesManager.findInstances(concept, scope, progress, manageTasks) :\n      myDefaultFindUsagesManager.findInstances(concept, scope, progress, manageTasks);\n  }","id":6325,"modified_method":"public Set<SNode> findInstances(AbstractConceptDeclaration concept, IScope scope, IAdaptiveProgressMonitor progress, boolean manageTasks) {\n    return getRealManager().findInstances(concept, scope, progress, manageTasks);\n  }","commit_id":"a4b3002f85e983a37d3ae2fac21721eb1f6cba04","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ExpansionSource nextPosition()\n        {\n            // Exhaust current if not already exhausted\n            while ( true )\n            {\n                ExpansionSource next = current.next();\n                if ( next != null )\n                {\n                    queue.put( next, currentAggregatedValue + calculateValue( next ) );\n                }\n                else\n                {\n                    break;\n                }\n            }\n            \n            // Pop the top from priorityMap\n            Entry<ExpansionSource, Double> entry = queue.pop();\n            if ( entry != null )\n            {\n                current = entry.getEntity();\n                currentAggregatedValue = entry.getPriority();\n                return current;\n            }\n            return null;\n        }","id":6326,"modified_method":"public ExpansionSource nextPosition()\n        {\n            // Exhaust current if not already exhausted\n            while ( true )\n            {\n                ExpansionSource next = current.next();\n                if ( next != null )\n                {\n                    P newPriority = addPriority( next, currentAggregatedValue,\n                            calculateValue( next ) );\n                    queue.put( next, newPriority );\n                }\n                else\n                {\n                    break;\n                }\n            }\n            \n            // Pop the top from priorityMap\n            Entry<ExpansionSource, P> entry = queue.pop();\n            if ( entry != null )\n            {\n                current = entry.getEntity();\n                currentAggregatedValue = entry.getPriority();\n                return current;\n            }\n            return null;\n        }","commit_id":"d39f8afad93d11e26e1475779c84b8fa00a45fc6","url":"https://github.com/neo4j/neo4j"},{"original_method":"public SourceSelector create( ExpansionSource startSource )\n    {\n        return new BestFirstSelector( startSource );\n    }","id":6327,"modified_method":"public SourceSelector create( ExpansionSource startSource )\n    {\n        return new BestFirstSelector( startSource, getStartData() );\n    }","commit_id":"d39f8afad93d11e26e1475779c84b8fa00a45fc6","url":"https://github.com/neo4j/neo4j"},{"original_method":"BestFirstSelector( ExpansionSource source )\n        {\n            this.current = source;\n        }","id":6328,"modified_method":"public BestFirstSelector( ExpansionSource source, P startData )\n        {\n            this.current = source;\n            this.currentAggregatedValue = startData;\n        }","commit_id":"d39f8afad93d11e26e1475779c84b8fa00a45fc6","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected abstract double calculateValue( ExpansionSource next );","id":6329,"modified_method":"protected abstract D calculateValue( ExpansionSource next );","commit_id":"d39f8afad93d11e26e1475779c84b8fa00a45fc6","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        protected double calculateValue( ExpansionSource next )\n        {\n            return next.depth() == 0 ? 0d : evaluator.getCost( next.relationship(), false );\n        }","id":6330,"modified_method":"@Override\n        protected Double calculateValue( ExpansionSource next )\n        {\n            return next.depth() == 0 ? 0d : evaluator.getCost( next.relationship(), false );\n        }","commit_id":"d39f8afad93d11e26e1475779c84b8fa00a45fc6","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void assertPath( Path path, Node... nodes )\n    {\n        int i = 0;\n        for ( Node node : path.nodes() )\n        {\n            assertEquals( nodes[i++], node );\n        }\n        assertEquals( nodes.length, i );\n    }","id":6331,"modified_method":"protected void assertPath( Path path, Node... nodes )\n    {\n        int i = 0;\n        for ( Node node : path.nodes() )\n        {\n            assertEquals( \"Wrong node \" + i + \" in \" + getPathDef( path ),\n                    nodes[i++], node );\n        }\n        assertEquals( nodes.length, i );\n    }","commit_id":"d39f8afad93d11e26e1475779c84b8fa00a45fc6","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    // START SNIPPET: astarUsage\n    public void astarExample()\n    {\n        Node nodeA = createNode( \"name\", \"A\", \"x\", 0d, \"y\", 0d );\n        Node nodeB = createNode( \"name\", \"B\", \"x\", 2d, \"y\", 1d );\n        Node nodeC = createNode( \"name\", \"C\", \"x\", 7d, \"y\", 0d );\n        Relationship relAB = createRelationship( nodeA, nodeB, \"length\", 2d );\n        Relationship relBC = createRelationship( nodeB, nodeC, \"length\", 3d );\n        Relationship relAC = createRelationship( nodeA, nodeC, \"length\", 10d );\n        \n        EstimateEvaluator<Double> estimateEvaluator = new EstimateEvaluator<Double>()\n        {\n            public Double getCost( Node node, Node goal )\n            {\n                double dx = (Double) node.getProperty( \"x\" ) - (Double) goal.getProperty( \"x\" );\n                double dy = (Double) node.getProperty( \"y\" ) - (Double) goal.getProperty( \"y\" );\n                double result = Math.sqrt( Math.pow( dx, 2 ) + Math.pow( dy, 2 ) );\n                return result;\n            }\n        };\n        AStar astar = new AStar( graphDb, TraversalFactory.expanderForAllTypes(),\n                new DoubleEvaluator( \"length\" ), estimateEvaluator );\n        Path path = astar.findSinglePath( nodeA, nodeC );\n    }","id":6332,"modified_method":"@Test\n    // START SNIPPET: astarUsage\n    public void astarExample()\n    {\n        Node nodeA = createNode( \"name\", \"A\", \"x\", 0d, \"y\", 0d );\n        Node nodeB = createNode( \"name\", \"B\", \"x\", 2d, \"y\", 1d );\n        Node nodeC = createNode( \"name\", \"C\", \"x\", 7d, \"y\", 0d );\n        Relationship relAB = createRelationship( nodeA, nodeB, \"length\", 2d );\n        Relationship relBC = createRelationship( nodeB, nodeC, \"length\", 3d );\n        Relationship relAC = createRelationship( nodeA, nodeC, \"length\", 10d );\n        \n        EstimateEvaluator<Double> estimateEvaluator = new EstimateEvaluator<Double>()\n        {\n            public Double getCost( Node node, Node goal )\n            {\n                double dx = (Double) node.getProperty( \"x\" ) - (Double) goal.getProperty( \"x\" );\n                double dy = (Double) node.getProperty( \"y\" ) - (Double) goal.getProperty( \"y\" );\n                double result = Math.sqrt( Math.pow( dx, 2 ) + Math.pow( dy, 2 ) );\n                return result;\n            }\n        };\n        PathFinder<WeightedPath> astar = new AStar( graphDb, TraversalFactory.expanderForAllTypes(),\n                new DoubleEvaluator( \"length\" ), estimateEvaluator );\n        Path path = astar.findSinglePath( nodeA, nodeC );\n    }","commit_id":"d39f8afad93d11e26e1475779c84b8fa00a45fc6","url":"https://github.com/neo4j/neo4j"},{"original_method":"BestFirstSelector( ExpansionSource source )\n        {\n            this.current = source;\n        }","id":6333,"modified_method":"public BestFirstSelector( ExpansionSource source, P startData )\n        {\n            this.current = source;\n            this.currentAggregatedValue = startData;\n        }","commit_id":"285eb0b2426ecaf4a31380b3888bba1b05938bc2","url":"https://github.com/neo4j/neo4j"},{"original_method":"public SourceSelector create( ExpansionSource startSource )\n    {\n        return new BestFirstSelector( startSource );\n    }","id":6334,"modified_method":"public SourceSelector create( ExpansionSource startSource )\n    {\n        return new BestFirstSelector( startSource, getStartData() );\n    }","commit_id":"285eb0b2426ecaf4a31380b3888bba1b05938bc2","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected abstract double calculateValue( ExpansionSource next );","id":6335,"modified_method":"protected abstract D calculateValue( ExpansionSource next );","commit_id":"285eb0b2426ecaf4a31380b3888bba1b05938bc2","url":"https://github.com/neo4j/neo4j"},{"original_method":"public ExpansionSource nextPosition()\n        {\n            // Exhaust current if not already exhausted\n            while ( true )\n            {\n                ExpansionSource next = current.next();\n                if ( next != null )\n                {\n                    queue.put( next, currentAggregatedValue + calculateValue( next ) );\n                }\n                else\n                {\n                    break;\n                }\n            }\n            \n            // Pop the top from priorityMap\n            Entry<ExpansionSource, Double> entry = queue.pop();\n            if ( entry != null )\n            {\n                current = entry.getEntity();\n                currentAggregatedValue = entry.getPriority();\n                return current;\n            }\n            return null;\n        }","id":6336,"modified_method":"public ExpansionSource nextPosition()\n        {\n            // Exhaust current if not already exhausted\n            while ( true )\n            {\n                ExpansionSource next = current.next();\n                if ( next != null )\n                {\n                    P newPriority = addPriority( next, currentAggregatedValue,\n                            calculateValue( next ) );\n                    queue.put( next, newPriority );\n                }\n                else\n                {\n                    break;\n                }\n            }\n            \n            // Pop the top from priorityMap\n            Entry<ExpansionSource, P> entry = queue.pop();\n            if ( entry != null )\n            {\n                current = entry.getEntity();\n                currentAggregatedValue = entry.getPriority();\n                return current;\n            }\n            return null;\n        }","commit_id":"285eb0b2426ecaf4a31380b3888bba1b05938bc2","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        protected double calculateValue( ExpansionSource next )\n        {\n            return next.depth() == 0 ? 0d : evaluator.getCost( next.relationship(), false );\n        }","id":6337,"modified_method":"@Override\n        protected Double calculateValue( ExpansionSource next )\n        {\n            return next.depth() == 0 ? 0d : evaluator.getCost( next.relationship(), false );\n        }","commit_id":"285eb0b2426ecaf4a31380b3888bba1b05938bc2","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void assertPath( Path path, Node... nodes )\n    {\n        int i = 0;\n        for ( Node node : path.nodes() )\n        {\n            assertEquals( nodes[i++], node );\n        }\n        assertEquals( nodes.length, i );\n    }","id":6338,"modified_method":"protected void assertPath( Path path, Node... nodes )\n    {\n        int i = 0;\n        for ( Node node : path.nodes() )\n        {\n            assertEquals( \"Wrong node \" + i + \" in \" + getPathDef( path ),\n                    nodes[i++], node );\n        }\n        assertEquals( nodes.length, i );\n    }","commit_id":"285eb0b2426ecaf4a31380b3888bba1b05938bc2","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    // START SNIPPET: astarUsage\n    public void astarExample()\n    {\n        Node nodeA = createNode( \"name\", \"A\", \"x\", 0d, \"y\", 0d );\n        Node nodeB = createNode( \"name\", \"B\", \"x\", 2d, \"y\", 1d );\n        Node nodeC = createNode( \"name\", \"C\", \"x\", 7d, \"y\", 0d );\n        Relationship relAB = createRelationship( nodeA, nodeB, \"length\", 2d );\n        Relationship relBC = createRelationship( nodeB, nodeC, \"length\", 3d );\n        Relationship relAC = createRelationship( nodeA, nodeC, \"length\", 10d );\n        \n        EstimateEvaluator<Double> estimateEvaluator = new EstimateEvaluator<Double>()\n        {\n            public Double getCost( Node node, Node goal )\n            {\n                double dx = (Double) node.getProperty( \"x\" ) - (Double) goal.getProperty( \"x\" );\n                double dy = (Double) node.getProperty( \"y\" ) - (Double) goal.getProperty( \"y\" );\n                double result = Math.sqrt( Math.pow( dx, 2 ) + Math.pow( dy, 2 ) );\n                return result;\n            }\n        };\n        AStar astar = new AStar( graphDb, TraversalFactory.expanderForAllTypes(),\n                new DoubleEvaluator( \"length\" ), estimateEvaluator );\n        Path path = astar.findSinglePath( nodeA, nodeC );\n    }","id":6339,"modified_method":"@Test\n    // START SNIPPET: astarUsage\n    public void astarExample()\n    {\n        Node nodeA = createNode( \"name\", \"A\", \"x\", 0d, \"y\", 0d );\n        Node nodeB = createNode( \"name\", \"B\", \"x\", 2d, \"y\", 1d );\n        Node nodeC = createNode( \"name\", \"C\", \"x\", 7d, \"y\", 0d );\n        Relationship relAB = createRelationship( nodeA, nodeB, \"length\", 2d );\n        Relationship relBC = createRelationship( nodeB, nodeC, \"length\", 3d );\n        Relationship relAC = createRelationship( nodeA, nodeC, \"length\", 10d );\n        \n        EstimateEvaluator<Double> estimateEvaluator = new EstimateEvaluator<Double>()\n        {\n            public Double getCost( Node node, Node goal )\n            {\n                double dx = (Double) node.getProperty( \"x\" ) - (Double) goal.getProperty( \"x\" );\n                double dy = (Double) node.getProperty( \"y\" ) - (Double) goal.getProperty( \"y\" );\n                double result = Math.sqrt( Math.pow( dx, 2 ) + Math.pow( dy, 2 ) );\n                return result;\n            }\n        };\n        PathFinder<WeightedPath> astar = new AStar( graphDb, TraversalFactory.expanderForAllTypes(),\n                new DoubleEvaluator( \"length\" ), estimateEvaluator );\n        Path path = astar.findSinglePath( nodeA, nodeC );\n    }","commit_id":"285eb0b2426ecaf4a31380b3888bba1b05938bc2","url":"https://github.com/neo4j/neo4j"},{"original_method":"public SourceSelector create( ExpansionSource startSource )\n    {\n        return new BestFirstSelector( startSource );\n    }","id":6340,"modified_method":"public SourceSelector create( ExpansionSource startSource )\n    {\n        return new BestFirstSelector( startSource, getStartData() );\n    }","commit_id":"c4dfea1bccd1085eabdb0ba450d509018324c4f6","url":"https://github.com/neo4j/neo4j"},{"original_method":"BestFirstSelector( ExpansionSource source )\n        {\n            this.current = source;\n        }","id":6341,"modified_method":"public BestFirstSelector( ExpansionSource source, P startData )\n        {\n            this.current = source;\n            this.currentAggregatedValue = startData;\n        }","commit_id":"c4dfea1bccd1085eabdb0ba450d509018324c4f6","url":"https://github.com/neo4j/neo4j"},{"original_method":"public ExpansionSource nextPosition()\n        {\n            // Exhaust current if not already exhausted\n            while ( true )\n            {\n                ExpansionSource next = current.next();\n                if ( next != null )\n                {\n                    queue.put( next, currentAggregatedValue + calculateValue( next ) );\n                }\n                else\n                {\n                    break;\n                }\n            }\n            \n            // Pop the top from priorityMap\n            Entry<ExpansionSource, Double> entry = queue.pop();\n            if ( entry != null )\n            {\n                current = entry.getEntity();\n                currentAggregatedValue = entry.getPriority();\n                return current;\n            }\n            return null;\n        }","id":6342,"modified_method":"public ExpansionSource nextPosition()\n        {\n            // Exhaust current if not already exhausted\n            while ( true )\n            {\n                ExpansionSource next = current.next();\n                if ( next != null )\n                {\n                    P newPriority = addPriority( next, currentAggregatedValue,\n                            calculateValue( next ) );\n                    queue.put( next, newPriority );\n                }\n                else\n                {\n                    break;\n                }\n            }\n            \n            // Pop the top from priorityMap\n            Entry<ExpansionSource, P> entry = queue.pop();\n            if ( entry != null )\n            {\n                current = entry.getEntity();\n                currentAggregatedValue = entry.getPriority();\n                return current;\n            }\n            return null;\n        }","commit_id":"c4dfea1bccd1085eabdb0ba450d509018324c4f6","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected abstract double calculateValue( ExpansionSource next );","id":6343,"modified_method":"protected abstract D calculateValue( ExpansionSource next );","commit_id":"c4dfea1bccd1085eabdb0ba450d509018324c4f6","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        protected double calculateValue( ExpansionSource next )\n        {\n            return next.depth() == 0 ? 0d : evaluator.getCost( next.relationship(), false );\n        }","id":6344,"modified_method":"@Override\n        protected Double calculateValue( ExpansionSource next )\n        {\n            return next.depth() == 0 ? 0d : evaluator.getCost( next.relationship(), false );\n        }","commit_id":"c4dfea1bccd1085eabdb0ba450d509018324c4f6","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void assertPath( Path path, Node... nodes )\n    {\n        int i = 0;\n        for ( Node node : path.nodes() )\n        {\n            assertEquals( nodes[i++], node );\n        }\n        assertEquals( nodes.length, i );\n    }","id":6345,"modified_method":"protected void assertPath( Path path, Node... nodes )\n    {\n        int i = 0;\n        for ( Node node : path.nodes() )\n        {\n            assertEquals( \"Wrong node \" + i + \" in \" + getPathDef( path ),\n                    nodes[i++], node );\n        }\n        assertEquals( nodes.length, i );\n    }","commit_id":"c4dfea1bccd1085eabdb0ba450d509018324c4f6","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    // START SNIPPET: astarUsage\n    public void astarExample()\n    {\n        Node nodeA = createNode( \"name\", \"A\", \"x\", 0d, \"y\", 0d );\n        Node nodeB = createNode( \"name\", \"B\", \"x\", 2d, \"y\", 1d );\n        Node nodeC = createNode( \"name\", \"C\", \"x\", 7d, \"y\", 0d );\n        Relationship relAB = createRelationship( nodeA, nodeB, \"length\", 2d );\n        Relationship relBC = createRelationship( nodeB, nodeC, \"length\", 3d );\n        Relationship relAC = createRelationship( nodeA, nodeC, \"length\", 10d );\n        \n        EstimateEvaluator<Double> estimateEvaluator = new EstimateEvaluator<Double>()\n        {\n            public Double getCost( Node node, Node goal )\n            {\n                double dx = (Double) node.getProperty( \"x\" ) - (Double) goal.getProperty( \"x\" );\n                double dy = (Double) node.getProperty( \"y\" ) - (Double) goal.getProperty( \"y\" );\n                double result = Math.sqrt( Math.pow( dx, 2 ) + Math.pow( dy, 2 ) );\n                return result;\n            }\n        };\n        AStar astar = new AStar( graphDb, TraversalFactory.expanderForAllTypes(),\n                new DoubleEvaluator( \"length\" ), estimateEvaluator );\n        Path path = astar.findSinglePath( nodeA, nodeC );\n    }","id":6346,"modified_method":"@Test\n    // START SNIPPET: astarUsage\n    public void astarExample()\n    {\n        Node nodeA = createNode( \"name\", \"A\", \"x\", 0d, \"y\", 0d );\n        Node nodeB = createNode( \"name\", \"B\", \"x\", 2d, \"y\", 1d );\n        Node nodeC = createNode( \"name\", \"C\", \"x\", 7d, \"y\", 0d );\n        Relationship relAB = createRelationship( nodeA, nodeB, \"length\", 2d );\n        Relationship relBC = createRelationship( nodeB, nodeC, \"length\", 3d );\n        Relationship relAC = createRelationship( nodeA, nodeC, \"length\", 10d );\n        \n        EstimateEvaluator<Double> estimateEvaluator = new EstimateEvaluator<Double>()\n        {\n            public Double getCost( Node node, Node goal )\n            {\n                double dx = (Double) node.getProperty( \"x\" ) - (Double) goal.getProperty( \"x\" );\n                double dy = (Double) node.getProperty( \"y\" ) - (Double) goal.getProperty( \"y\" );\n                double result = Math.sqrt( Math.pow( dx, 2 ) + Math.pow( dy, 2 ) );\n                return result;\n            }\n        };\n        PathFinder<WeightedPath> astar = new AStar( graphDb, TraversalFactory.expanderForAllTypes(),\n                new DoubleEvaluator( \"length\" ), estimateEvaluator );\n        Path path = astar.findSinglePath( nodeA, nodeC );\n    }","commit_id":"c4dfea1bccd1085eabdb0ba450d509018324c4f6","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void testAlternative() {\n\t\tS start = new S(\"start\");\n\t\tS stop = new S(\"stop\");\n\t\tS x = new S(\"x\");\n\t\tS y = new S(\"y\");\n\t\tstart.add(x, y);\n\t\tx.add(stop);\n\t\ty.add(stop);\n\t\tassertEquals(\"start (x | y) stop\", nfa2g(start, stop));\n\t}","id":6347,"modified_method":"public void testAlternative() {\n\t\tStringNfa nfa = new StringNfa(\"start\", \"stop\");\n\t\tnfa.start().followedBy(\"x\", \"y\");\n\t\tnfa.state(\"x\").followedBy(\"stop\");\n\t\tnfa.state(\"y\").followedBy(\"stop\");\n\t\tassertEquals(\"start (x | y) stop\", nfa2g(nfa));\n\t}","commit_id":"e56f801a83b92d54ec3254d3827faa4f9657b98c","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testSimpleMany() {\n\t\tS start = new S(\"start\");\n\t\tS stop = new S(\"stop\");\n\t\tS x = new S(\"x\", stop);\n\t\tstart.add(x);\n\t\tx.add(x);\n\t\tassertEquals(\"start x+ stop\", nfa2g(start, stop));\n\t}","id":6348,"modified_method":"public void testSimpleMany() {\n\t\tStringNfa nfa = new StringNfa(\"start\", \"stop\");\n\t\tnfa.start().followedBy(\"x\");\n\t\tnfa.state(\"x\").followedBy(\"x\", \"stop\");\n\t\tassertEquals(\"start x+ stop\", nfa2g(nfa));\n\t}","commit_id":"e56f801a83b92d54ec3254d3827faa4f9657b98c","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testSplitStateAlternatives1() {\n\t\tS start = new S(\"start\");\n\t\tS stop = new S(\"stop\");\n\t\tS b = new S(\"b\");\n\t\tS c = new S(\"c\");\n\t\tS d = new S(\"d\");\n\t\tS e = new S(\"e\");\n\t\tstart.add(b, c);\n\t\tb.add(d, e);\n\t\tc.add(e);\n\t\td.add(stop);\n\t\te.add(stop);\n\t\tassertEquals(\"start (b (d | e) | c e) stop\", nfa2g(start, stop));\n\t}","id":6349,"modified_method":"public void testSplitStateAlternatives1() {\n\t\tStringNfa nfa = new StringNfa(\"start\", \"stop\");\n\t\tnfa.start().followedBy(\"b\", \"c\");\n\t\tnfa.state(\"b\").followedBy(\"d\", \"e\");\n\t\tnfa.state(\"c\").followedBy(\"e\");\n\t\tnfa.state(\"d\").followedBy(\"stop\");\n\t\tnfa.state(\"e\").followedBy(\"stop\");\n\t\tassertEquals(\"start (b (d | e) | c e) stop\", nfa2g(nfa));\n\t}","commit_id":"e56f801a83b92d54ec3254d3827faa4f9657b98c","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testSimpleOne() {\n\t\tS start = new S(\"start\");\n\t\tS stop = new S(\"stop\");\n\t\tstart.add(new S(\"x\", stop));\n\t\tassertEquals(\"start x stop\", nfa2g(start, stop));\n\t}","id":6350,"modified_method":"public void testSimpleOne() {\n\t\tStringNfa nfa = new StringNfa(\"start\", \"stop\");\n\t\tnfa.start().followedBy(\"x\");\n\t\tnfa.state(\"x\").followedBy(\"stop\");\n\t\tassertEquals(\"start x stop\", nfa2g(nfa));\n\t}","commit_id":"e56f801a83b92d54ec3254d3827faa4f9657b98c","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testSimple() {\n\t\tS start = new S(\"start\");\n\t\tS stop = new S(\"stop\");\n\t\tstart.add(stop);\n\t\tassertEquals(\"start stop\", nfa2g(start, stop));\n\t}","id":6351,"modified_method":"public void testSimple() {\n\t\tStringNfa nfa = new StringNfa(\"start\", \"stop\");\n\t\tnfa.start().followedBy(\"stop\");\n\t\tassertEquals(\"start stop\", nfa2g(nfa));\n\t}","commit_id":"e56f801a83b92d54ec3254d3827faa4f9657b98c","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testSimpleOptional() {\n\t\tS start = new S(\"start\");\n\t\tS stop = new S(\"stop\");\n\t\tstart.add(new S(\"x\", stop));\n\t\tstart.add(stop);\n\t\tassertEquals(\"start x? stop\", nfa2g(start, stop));\n\t}","id":6352,"modified_method":"public void testSimpleOptional() {\n\t\tStringNfa nfa = new StringNfa(\"start\", \"stop\");\n\t\tnfa.start().followedBy(\"x\", \"stop\");\n\t\tnfa.state(\"x\").followedBy(\"stop\");\n\t\tassertEquals(\"start x? stop\", nfa2g(nfa));\n\t}","commit_id":"e56f801a83b92d54ec3254d3827faa4f9657b98c","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testSimpleManyOptional3() {\n\t\tS start = new S(\"start\");\n\t\tS stop = new S(\"stop\");\n\t\tS x = new S(\"x\");\n\t\tS y = new S(\"y\");\n\t\tS z = new S(\"z\");\n\t\tstart.add(x, stop);\n\t\tx.add(y, z);\n\t\ty.add(z);\n\t\tz.add(x, z, stop);\n\t\tassertEquals(\"start (x y? z+)* stop\", nfa2g(start, stop));\n\t}","id":6353,"modified_method":"public void testSimpleManyOptional3() {\n\t\tStringNfa nfa = new StringNfa(\"start\", \"stop\");\n\t\tnfa.start().followedBy(\"x\", \"stop\");\n\t\tnfa.state(\"x\").followedBy(\"y\", \"z\");\n\t\tnfa.state(\"y\").followedBy(\"z\");\n\t\tnfa.state(\"z\").followedBy(\"x\", \"z\", \"stop\");\n\t\tassertEquals(\"start (x y? z+)* stop\", nfa2g(nfa));\n\t}","commit_id":"e56f801a83b92d54ec3254d3827faa4f9657b98c","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testAlternative8() {\n\t\tS start = new S(\"start\");\n\t\tS stop = new S(\"stop\");\n\t\tS a = new S(\"a\");\n\t\tS b = new S(\"b\");\n\t\tS c = new S(\"c\");\n\t\tS d = new S(\"d\");\n\t\tS x = new S(\"x\");\n\t\tS y = new S(\"y\");\n\t\tstart.add(a, b);\n\t\ta.add(c, d);\n\t\tb.add(c, d);\n\t\tc.add(x, y);\n\t\td.add(x, y);\n\t\tx.add(stop);\n\t\ty.add(stop);\n\t\tassertEquals(\"start (a | b) (c | d) (x | y) stop\", nfa2g(start, stop));\n\t}","id":6354,"modified_method":"public void testAlternative8() {\n\t\tStringNfa nfa = new StringNfa(\"start\", \"stop\");\n\t\tnfa.start().followedBy(\"a\", \"b\");\n\t\tnfa.state(\"a\").followedBy(\"c\", \"d\");\n\t\tnfa.state(\"b\").followedBy(\"c\", \"d\");\n\t\tnfa.state(\"c\").followedBy(\"x\", \"y\");\n\t\tnfa.state(\"d\").followedBy(\"x\", \"y\");\n\t\tnfa.state(\"x\").followedBy(\"stop\");\n\t\tnfa.state(\"y\").followedBy(\"stop\");\n\t\tassertEquals(\"start (a | b) (c | d) (x | y) stop\", nfa2g(nfa));\n\t}","commit_id":"e56f801a83b92d54ec3254d3827faa4f9657b98c","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testAlternative4() {\n\t\tS start = new S(\"start\");\n\t\tS stop = new S(\"stop\");\n\t\tS x = new S(\"x\");\n\t\tS y = new S(\"y\");\n\t\tstart.add(x, y, stop);\n\t\tx.add(stop);\n\t\ty.add(stop);\n\t\tassertEquals(\"start (x | y)? stop\", nfa2g(start, stop));\n\t}","id":6355,"modified_method":"public void testAlternative4() {\n\t\tStringNfa nfa = new StringNfa(\"start\", \"stop\");\n\t\tnfa.start().followedBy(\"x\", \"y\", \"stop\");\n\t\tnfa.state(\"x\").followedBy(\"stop\");\n\t\tnfa.state(\"y\").followedBy(\"stop\");\n\t\tassertEquals(\"start (x | y)? stop\", nfa2g(nfa));\n\t}","commit_id":"e56f801a83b92d54ec3254d3827faa4f9657b98c","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testAlternative7() {\n\t\tS start = new S(\"start\");\n\t\tS stop = new S(\"stop\");\n\t\tS a = new S(\"a\");\n\t\tS b = new S(\"b\");\n\t\tS x = new S(\"x\");\n\t\tS y = new S(\"y\");\n\t\tstart.add(a, b);\n\t\ta.add(x, y);\n\t\tb.add(x, y);\n\t\tx.add(stop);\n\t\ty.add(stop);\n\t\tassertEquals(\"start (a | b) (x | y) stop\", nfa2g(start, stop));\n\t}","id":6356,"modified_method":"public void testAlternative7() {\n\t\tStringNfa nfa = new StringNfa(\"start\", \"stop\");\n\t\tnfa.start().followedBy(\"a\", \"b\");\n\t\tnfa.state(\"a\").followedBy(\"x\", \"y\");\n\t\tnfa.state(\"b\").followedBy(\"x\", \"y\");\n\t\tnfa.state(\"x\").followedBy(\"stop\");\n\t\tnfa.state(\"y\").followedBy(\"stop\");\n\t\tassertEquals(\"start (a | b) (x | y) stop\", nfa2g(nfa));\n\t}","commit_id":"e56f801a83b92d54ec3254d3827faa4f9657b98c","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testAlternative2() {\n\t\tS start = new S(\"start\");\n\t\tS stop = new S(\"stop\");\n\t\tS x = new S(\"x\");\n\t\tS y = new S(\"y\");\n\t\tS z = new S(\"z\");\n\t\tstart.add(x, y, z);\n\t\tx.add(stop);\n\t\ty.add(stop);\n\t\tz.add(stop);\n\t\tassertEquals(\"start (x | y | z) stop\", nfa2g(start, stop));\n\t}","id":6357,"modified_method":"public void testAlternative2() {\n\t\tStringNfa nfa = new StringNfa(\"start\", \"stop\");\n\t\tnfa.start().followedBy(\"x\", \"y\", \"z\");\n\t\tnfa.state(\"x\").followedBy(\"stop\");\n\t\tnfa.state(\"y\").followedBy(\"stop\");\n\t\tnfa.state(\"z\").followedBy(\"stop\");\n\t\tassertEquals(\"start (x | y | z) stop\", nfa2g(nfa));\n\t}","commit_id":"e56f801a83b92d54ec3254d3827faa4f9657b98c","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testOptionalChain1() {\n\t\tS start = new S(\"start\");\n\t\tS stop = new S(\"stop\");\n\t\tS x = new S(\"x\");\n\t\tS y = new S(\"y\");\n\t\tstart.add(x, y, stop);\n\t\tx.add(y, stop);\n\t\ty.add(stop);\n\t\tassertEquals(\"start x? y? stop\", nfa2g(start, stop));\n\t}","id":6358,"modified_method":"public void testOptionalChain1() {\n\t\tStringNfa nfa = new StringNfa(\"start\", \"stop\");\n\t\tnfa.start().followedBy(\"x\", \"y\", \"stop\");\n\t\tnfa.state(\"x\").followedBy(\"y\", \"stop\");\n\t\tnfa.state(\"y\").followedBy(\"stop\");\n\t\tassertEquals(\"start x? y? stop\", nfa2g(nfa));\n\t}","commit_id":"e56f801a83b92d54ec3254d3827faa4f9657b98c","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testAlternative3() {\n\t\tS start = new S(\"start\");\n\t\tS stop = new S(\"stop\");\n\t\tS a = new S(\"a\");\n\t\tS b = new S(\"b\");\n\t\tS x = new S(\"x\");\n\t\tS y = new S(\"y\");\n\t\tS z = new S(\"z\");\n\t\tS v = new S(\"v\");\n\t\tS w = new S(\"w\");\n\t\tstart.add(x, y, z, v, w);\n\t\tx.add(a);\n\t\ty.add(a);\n\t\tz.add(a);\n\t\tv.add(b);\n\t\tw.add(b);\n\t\ta.add(stop);\n\t\tb.add(stop);\n\t\tassertEquals(\"start ((v | w) b | (x | y | z) a) stop\", nfa2g(start, stop));\n\t}","id":6359,"modified_method":"public void testAlternative3() {\n\t\tStringNfa nfa = new StringNfa(\"start\", \"stop\");\n\t\tnfa.start().followedBy(\"x\", \"y\", \"z\", \"v\", \"w\");\n\t\tnfa.state(\"x\").followedBy(\"a\");\n\t\tnfa.state(\"y\").followedBy(\"a\");\n\t\tnfa.state(\"z\").followedBy(\"a\");\n\t\tnfa.state(\"v\").followedBy(\"b\");\n\t\tnfa.state(\"w\").followedBy(\"b\");\n\t\tnfa.state(\"a\").followedBy(\"stop\");\n\t\tnfa.state(\"b\").followedBy(\"stop\");\n\t\tassertEquals(\"start ((v | w) b | (x | y | z) a) stop\", nfa2g(nfa));\n\t}","commit_id":"e56f801a83b92d54ec3254d3827faa4f9657b98c","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testSplitStateCycle1() {\n\t\tS start = new S(\"start\");\n\t\tS stop = new S(\"stop\");\n\t\tS x = new S(\"x\");\n\t\tS y = new S(\"y\");\n\t\tstart.add(x);\n\t\tx.add(y, stop);\n\t\ty.add(x);\n\t\tassertEquals(\"start x (y x)* stop\", nfa2g(start, stop));\n\t}","id":6360,"modified_method":"public void testSplitStateCycle1() {\n\t\tStringNfa nfa = new StringNfa(\"start\", \"stop\");\n\t\tnfa.start().followedBy(\"x\");\n\t\tnfa.state(\"x\").followedBy(\"stop\", \"y\");\n\t\tnfa.state(\"y\").followedBy(\"x\");\n\t\tassertEquals(\"start x (y x)* stop\", nfa2g(nfa));\n\t}","commit_id":"e56f801a83b92d54ec3254d3827faa4f9657b98c","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testOptionalChain2() {\n\t\tS start = new S(\"start\");\n\t\tS stop = new S(\"stop\");\n\t\tS x = new S(\"x\");\n\t\tS y = new S(\"y\");\n\t\tS z = new S(\"z\");\n\t\tstart.add(x, y, z, stop);\n\t\tx.add(y, z, stop);\n\t\ty.add(z, stop);\n\t\tz.add(stop);\n\t\tassertEquals(\"start x? y? z? stop\", nfa2g(start, stop));\n\t}","id":6361,"modified_method":"public void testOptionalChain2() {\n\t\tStringNfa nfa = new StringNfa(\"start\", \"stop\");\n\t\tnfa.start().followedBy(\"x\", \"y\", \"z\", \"stop\");\n\t\tnfa.state(\"x\").followedBy(\"y\", \"z\", \"stop\");\n\t\tnfa.state(\"y\").followedBy(\"z\", \"stop\");\n\t\tnfa.state(\"z\").followedBy(\"stop\");\n\t\tassertEquals(\"start x? y? z? stop\", nfa2g(nfa));\n\t}","commit_id":"e56f801a83b92d54ec3254d3827faa4f9657b98c","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testAlternative6() {\n\t\tS start = new S(\"start\");\n\t\tS stop = new S(\"stop\");\n\t\tS x = new S(\"x\");\n\t\tS y = new S(\"y\");\n\t\tstart.add(x, y, stop);\n\t\tx.add(stop, x);\n\t\ty.add(stop);\n\t\tassertEquals(\"start (x+ | y)? stop\", nfa2g(start, stop));\n\t}","id":6362,"modified_method":"public void testAlternative6() {\n\t\tStringNfa nfa = new StringNfa(\"start\", \"stop\");\n\t\tnfa.start().followedBy(\"x\", \"y\", \"stop\");\n\t\tnfa.state(\"x\").followedBy(\"stop\", \"x\");\n\t\tnfa.state(\"y\").followedBy(\"stop\");\n\t\tassertEquals(\"start (x+ | y)? stop\", nfa2g(nfa));\n\t}","commit_id":"e56f801a83b92d54ec3254d3827faa4f9657b98c","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testSplitStateAlternatives2() {\n\t\tS start = new S(\"start\");\n\t\tS stop = new S(\"stop\");\n\t\tS a = new S(\"a\");\n\t\tS b = new S(\"b\");\n\t\tS c = new S(\"c\");\n\t\tS d = new S(\"d\");\n\t\tS e = new S(\"e\");\n\t\tS f = new S(\"f\");\n\t\tS g = new S(\"g\");\n\t\tstart.add(a, b);\n\t\ta.add(c, d);\n\t\tb.add(d, e);\n\t\tc.add(f);\n\t\td.add(f, g);\n\t\te.add(g);\n\t\tf.add(stop);\n\t\tg.add(stop);\n\t\tassertEquals(\"start ((a c f | b e g) | (a | b) d (f | g)) stop\", nfa2g(start, stop));\n\t}","id":6363,"modified_method":"public void testSplitStateAlternatives2() {\n\t\tStringNfa nfa = new StringNfa(\"start\", \"stop\");\n\t\tnfa.start().followedBy(\"a\", \"b\");\n\t\tnfa.state(\"a\").followedBy(\"c\", \"d\");\n\t\tnfa.state(\"b\").followedBy(\"d\", \"e\");\n\t\tnfa.state(\"c\").followedBy(\"f\");\n\t\tnfa.state(\"d\").followedBy(\"f\", \"g\");\n\t\tnfa.state(\"e\").followedBy(\"g\");\n\t\tnfa.state(\"f\").followedBy(\"stop\");\n\t\tnfa.state(\"g\").followedBy(\"stop\");\n\t\tassertEquals(\"start ((a c f | b e g) | (a | b) d (f | g)) stop\", nfa2g(nfa));\n\t}","commit_id":"e56f801a83b92d54ec3254d3827faa4f9657b98c","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testSimpleManyOptional() {\n\t\tS start = new S(\"start\");\n\t\tS stop = new S(\"stop\");\n\t\tS x = new S(\"x\", stop);\n\t\tstart.add(x);\n\t\tx.add(x);\n\t\tstart.add(stop);\n\t\tassertEquals(\"start x* stop\", nfa2g(start, stop));\n\t}","id":6364,"modified_method":"public void testSimpleManyOptional() {\n\t\tStringNfa nfa = new StringNfa(\"start\", \"stop\");\n\t\tnfa.start().followedBy(\"x\", \"stop\");\n\t\tnfa.state(\"x\").followedBy(\"x\", \"stop\");\n\t\tassertEquals(\"start x* stop\", nfa2g(nfa));\n\t}","commit_id":"e56f801a83b92d54ec3254d3827faa4f9657b98c","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testSimpleManyOptional2() {\n\t\tS start = new S(\"start\");\n\t\tS stop = new S(\"stop\");\n\t\tS x = new S(\"x\");\n\t\tS y = new S(\"y\");\n\t\tS z = new S(\"z\");\n\t\tstart.add(x, stop);\n\t\tx.add(y);\n\t\ty.add(z);\n\t\tz.add(x, stop);\n\t\tassertEquals(\"start (x y z)* stop\", nfa2g(start, stop));\n\t}","id":6365,"modified_method":"public void testSimpleManyOptional2() {\n\t\tStringNfa nfa = new StringNfa(\"start\", \"stop\");\n\t\tnfa.start().followedBy(\"x\", \"stop\");\n\t\tnfa.state(\"x\").followedBy(\"y\");\n\t\tnfa.state(\"y\").followedBy(\"z\");\n\t\tnfa.state(\"z\").followedBy(\"x\", \"stop\");\n\t\tassertEquals(\"start (x y z)* stop\", nfa2g(nfa));\n\t}","commit_id":"e56f801a83b92d54ec3254d3827faa4f9657b98c","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testAlternative5() {\n\t\tS start = new S(\"start\");\n\t\tS stop = new S(\"stop\");\n\t\tS x = new S(\"x\");\n\t\tS y = new S(\"y\");\n\t\tstart.add(x, y);\n\t\tx.add(stop, x);\n\t\ty.add(stop);\n\t\tassertEquals(\"start (x+ | y) stop\", nfa2g(start, stop));\n\t}","id":6366,"modified_method":"public void testAlternative5() {\n\t\tStringNfa nfa = new StringNfa(\"start\", \"stop\");\n\t\tnfa.start().followedBy(\"x\", \"y\");\n\t\tnfa.state(\"x\").followedBy(\"stop\", \"x\");\n\t\tnfa.state(\"y\").followedBy(\"stop\");\n\t\tassertEquals(\"start (x+ | y) stop\", nfa2g(nfa));\n\t}","commit_id":"e56f801a83b92d54ec3254d3827faa4f9657b98c","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testShortestStackemptyingPathTwoLoops() {\n\t\tPDA pda = newPDA();\n\t\tpda.state(\"A\").start().to(\"B\");\n\t\tpda.state(\"B\").to(\"C\", \"B\").push(\"Y\");\n\t\tpda.state(\"C\").to(\"D\", \"C\").pop(\"Y\");\n\t\tpda.state(\"D\").stop();\n\t\tassertEquals(\"[A, B, C, D]\", util.shortestStackpruningPathTo(pda, newStack(), \"D\"));\n\t\tassertEquals(\"[A, B, C, C, D]\", util.shortestStackpruningPathTo(pda, newStack(\"Y\"), \"D\"));\n\t\tassertEquals(\"[A, B, C, C, C, D]\", util.shortestStackpruningPathTo(pda, newStack(\"Y\", \"Y\"), \"D\"));\n\t}","id":6367,"modified_method":"public void testShortestStackemptyingPathTwoLoops() {\n\t\tStringPda pda = new StringPda(\"A\", \"D\");\n\t\tpda.state(\"A\").followedBy(\"B\");\n\t\tpda.state(\"B\").followedBy(\"C\", \"B\").push(\"Y\");\n\t\tpda.state(\"C\").followedBy(\"D\", \"C\").pop(\"Y\");\n\t\tassertEquals(\"[A, B, C, D]\", util.shortestStackpruningPathTo(pda, newStack(), \"D\"));\n\t\tassertEquals(\"[A, B, C, C, D]\", util.shortestStackpruningPathTo(pda, newStack(\"Y\"), \"D\"));\n\t\tassertEquals(\"[A, B, C, C, C, D]\", util.shortestStackpruningPathTo(pda, newStack(\"Y\", \"Y\"), \"D\"));\n\t}","commit_id":"e56f801a83b92d54ec3254d3827faa4f9657b98c","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testShortestPathStackSimplePop() {\n\t\tPDA pda = newPDA();\n\t\tpda.state(\"A\").start().to(\"B\").pop(\"X\");\n\t\tpda.state(\"B\").to(\"C\").pop(\"Y\");\n\t\tpda.state(\"C\").stop().pop(\"Z\");\n\t\tassertEquals(\"[A, B, C]\", util.shortestPathTo(pda, newStack(\"Z\", \"Y\"), \"C\"));\n\t\tassertEquals(\"[A, B, C]\", util.shortestPathTo(pda, newStack(\"Y\"), \"C\"));\n\t}","id":6368,"modified_method":"public void testShortestPathStackSimplePop() {\n\t\tStringPda pda = new StringPda(\"A\", \"C\");\n\t\tpda.state(\"A\").followedBy(\"B\").pop(\"X\");\n\t\tpda.state(\"B\").followedBy(\"C\").pop(\"Y\");\n\t\tpda.state(\"C\").pop(\"Z\");\n\t\tassertEquals(\"[A, B, C]\", util.shortestPathTo(pda, newStack(\"Z\", \"Y\"), \"C\"));\n\t\tassertEquals(\"[A, B, C]\", util.shortestPathTo(pda, newStack(\"Y\"), \"C\"));\n\t}","commit_id":"e56f801a83b92d54ec3254d3827faa4f9657b98c","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testShortestStackemptyingPathStackSimplePopLoop() {\n\t\tPDA pda = newPDA();\n\t\tpda.state(\"A\").start().to(\"B\");\n\t\tpda.state(\"B\").to(\"C\", \"B\").pop(\"Y\");\n\t\tpda.state(\"C\").stop();\n\t\tassertEquals(\"[A, B, B, C]\", util.shortestStackpruningPathTo(pda, newStack(\"Y\", \"Y\"), \"C\"));\n\t}","id":6369,"modified_method":"public void testShortestStackemptyingPathStackSimplePopLoop() {\n\t\tStringPda pda = new StringPda(\"A\", \"C\");\n\t\tpda.state(\"A\").followedBy(\"B\");\n\t\tpda.state(\"B\").followedBy(\"C\", \"B\").pop(\"Y\");\n\t\tassertEquals(\"[A, B, B, C]\", util.shortestStackpruningPathTo(pda, newStack(\"Y\", \"Y\"), \"C\"));\n\t}","commit_id":"e56f801a83b92d54ec3254d3827faa4f9657b98c","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testShortestPathStackSimplePopLoop() {\n\t\tPDA pda = newPDA();\n\t\tpda.state(\"A\").start().to(\"B\", \"A\").pop(\"X\");\n\t\tpda.state(\"B\").to(\"C\", \"B\").pop(\"Y\");\n\t\tpda.state(\"C\").stop().pop(\"Z\");\n\t\tassertEquals(\"[A, A, A, B, C]\", util.shortestPathTo(pda, newStack(\"Y\", \"X\", \"X\"), \"C\"));\n\t\tassertEquals(\"[A, B, C]\", util.shortestPathTo(pda, newStack(\"Y\"), \"C\"));\n\t}","id":6370,"modified_method":"public void testShortestPathStackSimplePopLoop() {\n\t\tStringPda pda = new StringPda(\"A\", \"C\");\n\t\tpda.state(\"A\").followedBy(\"B\", \"A\").pop(\"X\");\n\t\tpda.state(\"B\").followedBy(\"C\", \"B\").pop(\"Y\");\n\t\tpda.state(\"C\").pop(\"Z\");\n\t\tassertEquals(\"[A, A, A, B, C]\", util.shortestPathTo(pda, newStack(\"Y\", \"X\", \"X\"), \"C\"));\n\t\tassertEquals(\"[A, B, C]\", util.shortestPathTo(pda, newStack(\"Y\"), \"C\"));\n\t}","commit_id":"e56f801a83b92d54ec3254d3827faa4f9657b98c","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testShortestPathLoop() {\n\t\tPDA pda = newPDA();\n\t\tpda.state(\"A\").start().to(\"B\");\n\t\tpda.state(\"B\").to(\"C\", \"B\");\n\t\tpda.state(\"C\").stop().to(\"B\");\n\t\tassertEquals(\"[A, B, C]\", util.shortestPathTo(pda, newStack(), \"C\"));\n\t}","id":6371,"modified_method":"public void testShortestPathLoop() {\n\t\tStringPda pda = new StringPda(\"A\", \"C\");\n\t\tpda.state(\"A\").followedBy(\"B\");\n\t\tpda.state(\"B\").followedBy(\"C\", \"B\");\n\t\tpda.state(\"C\").followedBy(\"B\");\n\t\tassertEquals(\"[A, B, C]\", util.shortestPathTo(pda, newStack(), \"C\"));\n\t}","commit_id":"e56f801a83b92d54ec3254d3827faa4f9657b98c","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testShortestPathSimple() {\n\t\tPDA pda = newPDA();\n\t\tpda.state(\"A\").start().to(\"B\");\n\t\tpda.state(\"B\").to(\"C\");\n\t\tpda.state(\"C\").stop();\n\t\tassertEquals(\"[A, B, C]\", util.shortestPathTo(pda, newStack(), \"C\"));\n\t}","id":6372,"modified_method":"public void testShortestPathSimple() {\n\t\tStringPda pda = new StringPda(\"A\", \"C\");\n\t\tpda.state(\"A\").followedBy(\"B\");\n\t\tpda.state(\"B\").followedBy(\"C\");\n\t\tassertEquals(\"[A, B, C]\", util.shortestPathTo(pda, newStack(), \"C\"));\n\t}","commit_id":"e56f801a83b92d54ec3254d3827faa4f9657b98c","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testShortestPathStackSimple() {\n\t\tPDA pda = newPDA();\n\t\tpda.state(\"A\").start().to(\"B\");\n\t\tpda.state(\"B\").to(\"C\").pop(\"X\");\n\t\tpda.state(\"C\").stop();\n\t\tassertEquals(\"[A, B, C]\", util.shortestPathTo(pda, newStack(\"X\"), \"C\"));\n\t\tassertEquals(\"null\", util.shortestPathTo(pda, newStack(), \"C\"));\n\t}","id":6373,"modified_method":"public void testShortestPathStackSimple() {\n\t\tStringPda pda = new StringPda(\"A\", \"C\");\n\t\tpda.state(\"A\").followedBy(\"B\");\n\t\tpda.state(\"B\").followedBy(\"C\").pop(\"X\");\n\t\tassertEquals(\"[A, B, C]\", util.shortestPathTo(pda, newStack(\"X\"), \"C\"));\n\t\tassertEquals(\"null\", util.shortestPathTo(pda, newStack(), \"C\"));\n\t}","commit_id":"e56f801a83b92d54ec3254d3827faa4f9657b98c","url":"https://github.com/eclipse/xtext"},{"original_method":"private static Map<String, Object> _getMap(\n\t\tPortletSession portletSession, boolean createIfAbsent) {\n\n\t\tif (portletSession == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tMap<String, Object> map = null;\n\n\t\ttry {\n\t\t\tmap = (Map<String, Object>)portletSession.getAttribute(_CLASS_NAME);\n\n\t\t\tif ((map == null) && createIfAbsent) {\n\t\t\t\tmap = new LinkedHashMap<>();\n\n\t\t\t\tportletSession.setAttribute(_CLASS_NAME, map);\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalStateException ise) {\n\n\t\t\t// Session is already invalidated, just return a null map\n\n\t\t}\n\n\t\treturn map;\n\t}","id":6374,"modified_method":"protected static Map<String, Object> _getMap(\n\t\tPortletRequest portletRequest, boolean createIfAbsent) {\n\n\t\treturn _getMap(\n\t\t\t_getPortalSession(portletRequest), _getPortletKey(portletRequest),\n\t\t\tcreateIfAbsent);\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void add(HttpSession session, String key, Object value) {\n\t\tMap<String, Object> map = _getMap(session, true);\n\n\t\tif (map == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tmap.put(key, value);\n\t}","id":6375,"modified_method":"public static void add(HttpSession session, String key, Object value) {\n\t\tMap<String, Object> map = _getMap(session, null, true);\n\n\t\tif (map == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tmap.put(key, value);\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean contains(HttpSession session, String key) {\n\t\tMap<String, Object> map = _getMap(session, false);\n\n\t\tif (map == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn map.containsKey(key);\n\t}","id":6376,"modified_method":"public static boolean contains(HttpSession session, String key) {\n\t\tMap<String, Object> map = _getMap(session, null, false);\n\n\t\tif (map == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn map.containsKey(key);\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean isEmpty(PortletRequest portletRequest) {\n\t\treturn isEmpty(portletRequest.getPortletSession(false));\n\t}","id":6377,"modified_method":"public static boolean isEmpty(PortletRequest portletRequest) {\n\t\tMap<String, Object> map = _getMap(portletRequest, false);\n\n\t\tif (map == null) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn map.isEmpty();\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static Map<String, Object> _getMap(\n\t\tHttpSession session, boolean createIfAbsent) {\n\n\t\tif (session == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tMap<String, Object> map = null;\n\n\t\ttry {\n\t\t\tmap = (Map<String, Object>)session.getAttribute(_CLASS_NAME);\n\n\t\t\tif ((map == null) && createIfAbsent) {\n\t\t\t\tmap = new LinkedHashMap<>();\n\n\t\t\t\tsession.setAttribute(_CLASS_NAME, map);\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalStateException ise) {\n\n\t\t\t// Session is already invalidated, just return a null map\n\n\t\t}\n\n\t\treturn map;\n\t}","id":6378,"modified_method":"protected static Map<String, Object> _getMap(\n\t\tHttpSession session, String portletKey, boolean createIfAbsent) {\n\n\t\tif (session == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (portletKey == null) {\n\t\t\tportletKey = StringPool.BLANK;\n\t\t}\n\n\t\tMap<String, Object> map = null;\n\n\t\ttry {\n\t\t\tmap = (Map<String, Object>)session.getAttribute(\n\t\t\t\tportletKey + _CLASS_NAME);\n\n\t\t\tif ((map == null) && createIfAbsent) {\n\t\t\t\tmap = new LinkedHashMap<>();\n\n\t\t\t\tsession.setAttribute(portletKey + _CLASS_NAME, map);\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalStateException ise) {\n\n\t\t\t// Session is already invalidated, just return a null map\n\n\t\t}\n\n\t\treturn map;\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void clear(PortletRequest portletRequest) {\n\t\tclear(portletRequest.getPortletSession(false));\n\t}","id":6379,"modified_method":"public static void clear(PortletRequest portletRequest) {\n\t\tMap<String, Object> map = _getMap(portletRequest, false);\n\n\t\tif (map != null) {\n\t\t\tmap.clear();\n\t\t}\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void add(PortletRequest portletRequest, String key) {\n\t\tadd(portletRequest.getPortletSession(false), key);\n\t}","id":6380,"modified_method":"public static void add(PortletRequest portletRequest, String key) {\n\t\tMap<String, Object> map = _getMap(portletRequest, true);\n\n\t\tif (map == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tmap.put(key, key);\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean contains(\n\t\tPortletRequest portletRequest, Class<?>[] classes) {\n\n\t\treturn contains(portletRequest.getPortletSession(false), classes);\n\t}","id":6381,"modified_method":"public static boolean contains(\n\t\tPortletRequest portletRequest, Class<?>[] classes) {\n\n\t\tfor (Class<?> clazz : classes) {\n\t\t\tif (contains(portletRequest, clazz.getName())) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void clear(HttpSession session) {\n\t\tMap<String, Object> map = _getMap(session, false);\n\n\t\tif (map != null) {\n\t\t\tmap.clear();\n\t\t}\n\t}","id":6382,"modified_method":"public static void clear(HttpSession session) {\n\t\tMap<String, Object> map = _getMap(session, null, false);\n\n\t\tif (map != null) {\n\t\t\tmap.clear();\n\t\t}\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void print(PortletRequest portletRequest) {\n\t\tprint(portletRequest.getPortletSession(false));\n\t}","id":6383,"modified_method":"public static void print(PortletRequest portletRequest) {\n\t\tIterator<String> itr = iterator(portletRequest);\n\n\t\twhile (itr.hasNext()) {\n\t\t\tSystem.out.println(itr.next());\n\t\t}\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void add(PortletRequest portletRequest, Class<?> clazz) {\n\t\tadd(portletRequest.getPortletSession(false), clazz.getName());\n\t}","id":6384,"modified_method":"public static void add(PortletRequest portletRequest, Class<?> clazz) {\n\t\tadd(portletRequest, clazz.getName());\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Set<String> keySet(PortletRequest portletRequest) {\n\t\treturn keySet(portletRequest.getPortletSession(false));\n\t}","id":6385,"modified_method":"public static Set<String> keySet(PortletRequest portletRequest) {\n\t\tMap<String, Object> map = _getMap(portletRequest, false);\n\n\t\tif (map == null) {\n\t\t\treturn Collections.emptySet();\n\t\t}\n\n\t\treturn Collections.unmodifiableSet(map.keySet());\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Iterator<String> iterator(HttpSession session) {\n\t\tMap<String, Object> map = _getMap(session, false);\n\n\t\tif (map == null) {\n\t\t\tList<String> list = Collections.<String>emptyList();\n\n\t\t\treturn list.iterator();\n\t\t}\n\n\t\tSet<String> set = Collections.unmodifiableSet(map.keySet());\n\n\t\treturn set.iterator();\n\t}","id":6386,"modified_method":"public static Iterator<String> iterator(HttpSession session) {\n\t\tMap<String, Object> map = _getMap(session, null, false);\n\n\t\tif (map == null) {\n\t\t\tList<String> list = Collections.<String>emptyList();\n\n\t\t\treturn list.iterator();\n\t\t}\n\n\t\tSet<String> set = Collections.unmodifiableSet(map.keySet());\n\n\t\treturn set.iterator();\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static int size(PortletRequest portletRequest) {\n\t\treturn size(portletRequest.getPortletSession(false));\n\t}","id":6387,"modified_method":"public static int size(PortletRequest portletRequest) {\n\t\tMap<String, Object> map = _getMap(portletRequest, false);\n\n\t\tif (map == null) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn map.size();\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Object get(PortletRequest portletRequest, Class<?> clazz) {\n\t\treturn get(portletRequest.getPortletSession(false), clazz.getName());\n\t}","id":6388,"modified_method":"public static Object get(PortletRequest portletRequest, Class<?> clazz) {\n\t\treturn get(portletRequest, clazz.getName());\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Set<String> keySet(HttpSession session) {\n\t\tMap<String, Object> map = _getMap(session, false);\n\n\t\tif (map == null) {\n\t\t\treturn Collections.emptySet();\n\t\t}\n\n\t\treturn Collections.unmodifiableSet(map.keySet());\n\t}","id":6389,"modified_method":"public static Set<String> keySet(HttpSession session) {\n\t\tMap<String, Object> map = _getMap(session, null, false);\n\n\t\tif (map == null) {\n\t\t\treturn Collections.emptySet();\n\t\t}\n\n\t\treturn Collections.unmodifiableSet(map.keySet());\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean contains(PortletRequest portletRequest, String key) {\n\t\treturn contains(portletRequest.getPortletSession(false), key);\n\t}","id":6390,"modified_method":"public static boolean contains(PortletRequest portletRequest, String key) {\n\t\tMap<String, Object> map = _getMap(portletRequest, false);\n\n\t\tif (map == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn map.containsKey(key);\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void add(\n\t\tPortletRequest portletRequest, Class<?> clazz, Object value) {\n\n\t\tadd(portletRequest.getPortletSession(false), clazz.getName(), value);\n\t}","id":6391,"modified_method":"public static void add(\n\t\tPortletRequest portletRequest, Class<?> clazz, Object value) {\n\n\t\tadd(portletRequest, clazz.getName(), value);\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Object get(PortletRequest portletRequest, String key) {\n\t\treturn get(portletRequest.getPortletSession(false), key);\n\t}","id":6392,"modified_method":"public static Object get(PortletRequest portletRequest, String key) {\n\t\tMap<String, Object> map = _getMap(portletRequest, false);\n\n\t\tif (map == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn map.get(key);\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static int size(HttpSession session) {\n\t\tMap<String, Object> map = _getMap(session, false);\n\n\t\tif (map == null) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn map.size();\n\t}","id":6393,"modified_method":"public static int size(HttpSession session) {\n\t\tMap<String, Object> map = _getMap(session, null, false);\n\n\t\tif (map == null) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn map.size();\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean contains(\n\t\tPortletRequest portletRequest, Class<?> clazz) {\n\n\t\treturn contains(\n\t\t\tportletRequest.getPortletSession(false), clazz.getName());\n\t}","id":6394,"modified_method":"public static boolean contains(\n\t\tPortletRequest portletRequest, Class<?> clazz) {\n\n\t\treturn contains(portletRequest, clazz.getName());\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean isEmpty(HttpSession session) {\n\t\tMap<String, Object> map = _getMap(session, false);\n\n\t\tif (map == null) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn map.isEmpty();\n\t}","id":6395,"modified_method":"public static boolean isEmpty(HttpSession session) {\n\t\tMap<String, Object> map = _getMap(session, null, false);\n\n\t\tif (map == null) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn map.isEmpty();\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void add(\n\t\tPortletRequest portletRequest, String key, Object value) {\n\n\t\tadd(portletRequest.getPortletSession(false), key, value);\n\t}","id":6396,"modified_method":"public static void add(\n\t\tPortletRequest portletRequest, String key, Object value) {\n\n\t\tMap<String, Object> map = _getMap(portletRequest, true);\n\n\t\tif (map == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tmap.put(key, value);\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Object get(HttpSession session, String key) {\n\t\tMap<String, Object> map = _getMap(session, false);\n\n\t\tif (map == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn map.get(key);\n\t}","id":6397,"modified_method":"public static Object get(HttpSession session, String key) {\n\t\tMap<String, Object> map = _getMap(session, null, false);\n\n\t\tif (map == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn map.get(key);\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void add(HttpSession session, String key) {\n\t\tMap<String, Object> map = _getMap(session, true);\n\n\t\tif (map == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tmap.put(key, key);\n\t}","id":6398,"modified_method":"public static void add(HttpSession session, String key) {\n\t\tMap<String, Object> map = _getMap(session, null, true);\n\n\t\tif (map == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tmap.put(key, key);\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Iterator<String> iterator(PortletRequest portletRequest) {\n\t\treturn iterator(portletRequest.getPortletSession(false));\n\t}","id":6399,"modified_method":"public static Iterator<String> iterator(PortletRequest portletRequest) {\n\t\tMap<String, Object> map = _getMap(portletRequest, false);\n\n\t\tif (map == null) {\n\t\t\tList<String> list = Collections.<String>emptyList();\n\n\t\t\treturn list.iterator();\n\t\t}\n\n\t\tSet<String> set = Collections.unmodifiableSet(map.keySet());\n\n\t\treturn set.iterator();\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean isEmpty(HttpSession session) {\n\t\tMap<String, Object> map = _getMap(session, false);\n\n\t\tif (map == null) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn map.isEmpty();\n\t}","id":6400,"modified_method":"public static boolean isEmpty(HttpSession session) {\n\t\tMap<String, Object> map = _getMap(session, null, false);\n\n\t\tif (map == null) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn map.isEmpty();\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void add(HttpSession session, String key, Object value) {\n\t\tMap<String, Object> map = _getMap(session, true);\n\n\t\tif (map == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tmap.put(key, value);\n\t}","id":6401,"modified_method":"public static void add(HttpSession session, String key, Object value) {\n\t\tMap<String, Object> map = _getMap(session, null, true);\n\n\t\tif (map == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tmap.put(key, value);\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Set<String> keySet(PortletRequest portletRequest) {\n\t\treturn keySet(portletRequest.getPortletSession(false));\n\t}","id":6402,"modified_method":"public static Set<String> keySet(PortletRequest portletRequest) {\n\t\tMap<String, Object> map = _getMap(portletRequest, false);\n\n\t\tif (map == null) {\n\t\t\treturn Collections.emptySet();\n\t\t}\n\n\t\treturn Collections.unmodifiableSet(map.keySet());\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void add(HttpSession session, String key) {\n\t\tMap<String, Object> map = _getMap(session, true);\n\n\t\tif (map == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tmap.put(key, key);\n\t}","id":6403,"modified_method":"public static void add(HttpSession session, String key) {\n\t\tMap<String, Object> map = _getMap(session, null, true);\n\n\t\tif (map == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tmap.put(key, key);\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void add(PortletRequest portletRequest, String key) {\n\t\tadd(portletRequest.getPortletSession(false), key);\n\t}","id":6404,"modified_method":"public static void add(PortletRequest portletRequest, String key) {\n\t\tMap<String, Object> map = _getMap(portletRequest, true);\n\n\t\tif (map == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tmap.put(key, key);\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Set<String> keySet(HttpSession session) {\n\t\tMap<String, Object> map = _getMap(session, false);\n\n\t\tif (map == null) {\n\t\t\treturn Collections.emptySet();\n\t\t}\n\n\t\treturn Collections.unmodifiableSet(map.keySet());\n\t}","id":6405,"modified_method":"public static Set<String> keySet(HttpSession session) {\n\t\tMap<String, Object> map = _getMap(session, null, false);\n\n\t\tif (map == null) {\n\t\t\treturn Collections.emptySet();\n\t\t}\n\n\t\treturn Collections.unmodifiableSet(map.keySet());\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static int size(HttpSession session) {\n\t\tMap<String, Object> map = _getMap(session, false);\n\n\t\tif (map == null) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn map.size();\n\t}","id":6406,"modified_method":"public static int size(HttpSession session) {\n\t\tMap<String, Object> map = _getMap(session, null, false);\n\n\t\tif (map == null) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn map.size();\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void add(\n\t\tPortletRequest portletRequest, String key, Object value) {\n\n\t\tadd(portletRequest.getPortletSession(false), key, value);\n\t}","id":6407,"modified_method":"public static void add(\n\t\tPortletRequest portletRequest, String key, Object value) {\n\n\t\tMap<String, Object> map = _getMap(portletRequest, true);\n\n\t\tif (map == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tmap.put(key, value);\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Object get(HttpSession session, String key) {\n\t\tMap<String, Object> map = _getMap(session, false);\n\n\t\tif (map == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn map.get(key);\n\t}","id":6408,"modified_method":"public static Object get(HttpSession session, String key) {\n\t\tMap<String, Object> map = _getMap(session, null, false);\n\n\t\tif (map == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn map.get(key);\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void clear(PortletRequest portletRequest) {\n\t\tclear(portletRequest.getPortletSession(false));\n\t}","id":6409,"modified_method":"public static void clear(PortletRequest portletRequest) {\n\t\tMap<String, Object> map = _getMap(portletRequest, false);\n\n\t\tif (map != null) {\n\t\t\tmap.clear();\n\t\t}\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean contains(PortletRequest portletRequest, String key) {\n\t\treturn contains(portletRequest.getPortletSession(false), key);\n\t}","id":6410,"modified_method":"public static boolean contains(PortletRequest portletRequest, String key) {\n\t\tMap<String, Object> map = _getMap(portletRequest, false);\n\n\t\tif (map == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn map.containsKey(key);\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Object get(PortletRequest portletRequest, Class<?> clazz) {\n\t\treturn get(portletRequest.getPortletSession(false), clazz.getName());\n\t}","id":6411,"modified_method":"public static Object get(PortletRequest portletRequest, Class<?> clazz) {\n\t\treturn get(portletRequest, clazz.getName());\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static Map<String, Object> _getMap(\n\t\tPortletSession portletSession, boolean createIfAbsent) {\n\n\t\tif (portletSession == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tMap<String, Object> map = null;\n\n\t\ttry {\n\t\t\tmap = (Map<String, Object>)portletSession.getAttribute(_CLASS_NAME);\n\n\t\t\tif ((map == null) && createIfAbsent) {\n\t\t\t\tmap = new SessionMessagesMap();\n\n\t\t\t\tportletSession.setAttribute(_CLASS_NAME, map);\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalStateException ise) {\n\n\t\t\t// Session is already invalidated, just return a null map\n\n\t\t}\n\n\t\treturn map;\n\t}","id":6412,"modified_method":"protected static Map<String, Object> _getMap(\n\t\tPortletRequest portletRequest, boolean createIfAbsent) {\n\n\t\treturn _getMap(\n\t\t\t_getPortalSession(portletRequest), _getPortletKey(portletRequest),\n\t\t\tcreateIfAbsent);\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void add(\n\t\tPortletRequest portletRequest, Class<?> clazz, Object value) {\n\n\t\tadd(portletRequest.getPortletSession(false), clazz.getName(), value);\n\t}","id":6413,"modified_method":"public static void add(\n\t\tPortletRequest portletRequest, Class<?> clazz, Object value) {\n\n\t\tadd(portletRequest, clazz.getName(), value);\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void add(PortletRequest portletRequest, Class<?> clazz) {\n\t\tadd(portletRequest.getPortletSession(false), clazz.getName());\n\t}","id":6414,"modified_method":"public static void add(PortletRequest portletRequest, Class<?> clazz) {\n\t\tadd(portletRequest, clazz.getName());\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Iterator<String> iterator(PortletRequest portletRequest) {\n\t\treturn iterator(portletRequest.getPortletSession(false));\n\t}","id":6415,"modified_method":"public static Iterator<String> iterator(PortletRequest portletRequest) {\n\t\tMap<String, Object> map = _getMap(portletRequest, false);\n\n\t\tif (map == null) {\n\t\t\tList<String> list = Collections.<String>emptyList();\n\n\t\t\treturn list.iterator();\n\t\t}\n\n\t\tSet<String> set = Collections.unmodifiableSet(map.keySet());\n\n\t\treturn set.iterator();\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Iterator<String> iterator(HttpSession session) {\n\t\tMap<String, Object> map = _getMap(session, false);\n\n\t\tif (map == null) {\n\t\t\tList<String> list = Collections.<String>emptyList();\n\n\t\t\treturn list.iterator();\n\t\t}\n\n\t\tSet<String> set = Collections.unmodifiableSet(map.keySet());\n\n\t\treturn set.iterator();\n\t}","id":6416,"modified_method":"public static Iterator<String> iterator(HttpSession session) {\n\t\tMap<String, Object> map = _getMap(session, null, false);\n\n\t\tif (map == null) {\n\t\t\tList<String> list = Collections.<String>emptyList();\n\n\t\t\treturn list.iterator();\n\t\t}\n\n\t\tSet<String> set = Collections.unmodifiableSet(map.keySet());\n\n\t\treturn set.iterator();\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static int size(PortletRequest portletRequest) {\n\t\treturn size(portletRequest.getPortletSession(false));\n\t}","id":6417,"modified_method":"public static int size(PortletRequest portletRequest) {\n\t\tMap<String, Object> map = _getMap(portletRequest, false);\n\n\t\tif (map == null) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn map.size();\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Object get(PortletRequest portletRequest, String key) {\n\t\treturn get(portletRequest.getPortletSession(false), key);\n\t}","id":6418,"modified_method":"public static Object get(PortletRequest portletRequest, String key) {\n\t\tMap<String, Object> map = _getMap(portletRequest, false);\n\n\t\tif (map == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn map.get(key);\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static Map<String, Object> _getMap(\n\t\tHttpSession session, boolean createIfAbsent) {\n\n\t\tif (session == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tMap<String, Object> map = null;\n\n\t\ttry {\n\t\t\tmap = (Map<String, Object>)session.getAttribute(_CLASS_NAME);\n\n\t\t\tif ((map == null) && createIfAbsent) {\n\t\t\t\tmap = new SessionMessagesMap();\n\n\t\t\t\tsession.setAttribute(_CLASS_NAME, map);\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalStateException ise) {\n\n\t\t\t// Session is already invalidated, just return a null map\n\n\t\t}\n\n\t\treturn map;\n\t}","id":6419,"modified_method":"protected static Map<String, Object> _getMap(\n\t\tHttpSession session, String portletKey, boolean createIfAbsent) {\n\n\t\tif (session == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (portletKey == null) {\n\t\t\tportletKey = StringPool.BLANK;\n\t\t}\n\n\t\tMap<String, Object> map = null;\n\n\t\ttry {\n\t\t\tmap = (Map<String, Object>)session.getAttribute(\n\t\t\t\tportletKey + _CLASS_NAME);\n\n\t\t\tif ((map == null) && createIfAbsent) {\n\t\t\t\tmap = new SessionMessagesMap();\n\n\t\t\t\tsession.setAttribute(portletKey + _CLASS_NAME, map);\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalStateException ise) {\n\n\t\t\t// Session is already invalidated, just return a null map\n\n\t\t}\n\n\t\treturn map;\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean contains(\n\t\tPortletRequest portletRequest, Class<?> clazz) {\n\n\t\treturn contains(\n\t\t\tportletRequest.getPortletSession(false), clazz.getName());\n\t}","id":6420,"modified_method":"public static boolean contains(\n\t\tPortletRequest portletRequest, Class<?> clazz) {\n\n\t\treturn contains(portletRequest, clazz.getName());\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void clear(HttpSession session) {\n\t\tMap<String, Object> map = _getMap(session, false);\n\n\t\tif (map != null) {\n\t\t\tmap.clear();\n\t\t}\n\t}","id":6421,"modified_method":"public static void clear(HttpSession session) {\n\t\tMap<String, Object> map = _getMap(session, null, false);\n\n\t\tif (map != null) {\n\t\t\tmap.clear();\n\t\t}\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void print(PortletRequest portletRequest) {\n\t\tprint(portletRequest.getPortletSession(false));\n\t}","id":6422,"modified_method":"public static void print(PortletRequest portletRequest) {\n\t\tIterator<String> itr = iterator(portletRequest);\n\n\t\twhile (itr.hasNext()) {\n\t\t\tSystem.out.println(itr.next());\n\t\t}\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean contains(HttpSession session, String key) {\n\t\tMap<String, Object> map = _getMap(session, false);\n\n\t\tif (map == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn map.containsKey(key);\n\t}","id":6423,"modified_method":"public static boolean contains(HttpSession session, String key) {\n\t\tMap<String, Object> map = _getMap(session, null, false);\n\n\t\tif (map == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn map.containsKey(key);\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean isEmpty(PortletRequest portletRequest) {\n\t\treturn isEmpty(portletRequest.getPortletSession(false));\n\t}","id":6424,"modified_method":"public static boolean isEmpty(PortletRequest portletRequest) {\n\t\tMap<String, Object> map = _getMap(portletRequest, false);\n\n\t\tif (map == null) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn map.isEmpty();\n\t}","commit_id":"32d14ddaf3e23037a0efe534999d30bbd5877db1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Add rendered document to ZIP stream.\n     * \n     * @param pageName the name (used with\n     *            {@link com.xpn.xwiki.XWiki.XWiki#getDocument(String, XWikiContext)}) of the page\n     *            to render.\n     * @param zos the ZIP output stream.\n     * @param context the XWiki context.\n     * @param vcontext the Velocity context.\n     * @throws XWikiException error when rendering document.\n     * @throws IOException error when rendering document.\n     */\n    private void renderDocument(String pageName, ZipOutputStream zos, XWikiContext context,\n        VelocityContext vcontext) throws XWikiException, IOException\n    {\n        XWikiDocument doc = context.getWiki().getDocument(pageName, context);\n\n        String zipname = doc.getDatabase() + POINT + doc.getSpace() + POINT + doc.getName();\n        String language = doc.getLanguage();\n        if (language != null && language.length() != 0) {\n            zipname += POINT + language;\n        }\n\n        zipname += \".html\";\n\n        ZipEntry zipentry = new ZipEntry(zipname);\n        zos.putNextEntry(zipentry);\n\n        context.setDatabase(doc.getDatabase());\n        context.setDoc(doc);\n        vcontext.put(VCONTEXT_DOC, doc.newDocument(context));\n        vcontext.put(VCONTEXT_CDOC, vcontext.get(VCONTEXT_DOC));\n\n        XWikiDocument tdoc = doc.getTranslatedDocument(context);\n        context.put(CONTEXT_TDOC, tdoc);\n        vcontext.put(VCONTEXT_TDOC, tdoc.newDocument(context));\n\n        String content = context.getWiki().parseTemplate(\"view.vm\", context);\n\n        zos.write(content.getBytes(context.getWiki().getEncoding()));\n        zos.closeEntry();\n    }","id":6425,"modified_method":"/**\n     * Add rendered document to ZIP stream.\n     * \n     * @param pageName the name (used with\n     *            {@link com.xpn.xwiki.XWiki#getDocument(String, XWikiContext)}) of the page\n     *            to render.\n     * @param zos the ZIP output stream.\n     * @param context the XWiki context.\n     * @param vcontext the Velocity context.\n     * @throws XWikiException error when rendering document.\n     * @throws IOException error when rendering document.\n     */\n    private void renderDocument(String pageName, ZipOutputStream zos, XWikiContext context,\n        VelocityContext vcontext) throws XWikiException, IOException\n    {\n        XWikiDocument doc = context.getWiki().getDocument(pageName, context);\n\n        String zipname = doc.getDatabase() + POINT + doc.getSpace() + POINT + doc.getName();\n        String language = doc.getLanguage();\n        if (language != null && language.length() != 0) {\n            zipname += POINT + language;\n        }\n\n        zipname += \".html\";\n\n        ZipEntry zipentry = new ZipEntry(zipname);\n        zos.putNextEntry(zipentry);\n\n        context.setDatabase(doc.getDatabase());\n        context.setDoc(doc);\n        vcontext.put(VCONTEXT_DOC, doc.newDocument(context));\n        vcontext.put(VCONTEXT_CDOC, vcontext.get(VCONTEXT_DOC));\n\n        XWikiDocument tdoc = doc.getTranslatedDocument(context);\n        context.put(CONTEXT_TDOC, tdoc);\n        vcontext.put(VCONTEXT_TDOC, tdoc.newDocument(context));\n\n        String content = context.getWiki().parseTemplate(\"view.vm\", context);\n\n        zos.write(content.getBytes(context.getWiki().getEncoding()));\n        zos.closeEntry();\n    }","commit_id":"e6c818a8acee5b3ec5d49769d1b7abb25ec07b21","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Init provided {@link ExportURLFactory} and add rendered documents to ZIP stream.\n     * \n     * @param zos the ZIP output stream.\n     * @param tempdir the directory where to copy attached files.\n     * @param urlf the {@link com.xpn.xwiki.web.XWikiURLFactory.XWikiURLFactory} used to render the\n     *            documents.\n     * @param context the XWiki context.\n     * @throws XWikiException error when render documents.\n     * @throws IOException error when render documents.\n     */\n    private void renderDocuments(ZipOutputStream zos, File tempdir, ExportURLFactory urlf,\n        XWikiContext context) throws XWikiException, IOException\n    {\n        // Push a clean request in the Container since we don't want the\n        // main request to be used for rendering the HTML pages to export.\n        // The new request automatically gets initialized with a new Velocity Context by\n        // the VelocityRequestInitializer class.\n        Container container = (Container) Utils.getComponent(Container.ROLE, context);\n        DaemonContainerFactory containerFactory =\n            (DaemonContainerFactory) Utils.getComponent(DaemonContainerFactory.ROLE, context);\n\n        VelocityContext oldVelocityContext = (VelocityContext) context.get(\"vcontext\");\n\n        try {\n            container.pushRequest(containerFactory.createRequest());\n\n            XWikiContext renderContext = (XWikiContext) context.clone();\n            renderContext.put(\"action\", \"view\");\n\n            // This is a bridge that we need for old code to play well with new components.\n            // Old code relies on the XWikiContext object whereas new code uses the Container component.\n            container.getRequest().setProperty(\"xwikicontext\", renderContext);\n\n            VelocityManager velocityManager = \n                (VelocityManager) Utils.getComponent(VelocityManager.ROLE, context);\n\n            // At this stage we have a clean Velocity Context\n            VelocityContext vcontext = velocityManager.getVelocityContext();\n            \n            urlf.init(this.pages, tempdir, renderContext);\n            renderContext.setURLFactory(urlf);\n\n            for (String pageName: this.pages) {\n                renderDocument(pageName, zos, renderContext, vcontext);\n            }\n        } catch (DaemonContainerException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_EXPORT, \n                XWikiException.ERROR_XWIKI_INIT_FAILED, \"Failed to initialize request\", e);\n        } finally {\n            // We must ensure that the new request we've used is removed so that the current\n            // thread can continue to use its original request.\n            container.popRequest();\n            \n            context.put(\"vcontext\", oldVelocityContext);\n        }\n    }","id":6426,"modified_method":"/**\n     * Init provided {@link ExportURLFactory} and add rendered documents to ZIP stream.\n     * \n     * @param zos the ZIP output stream.\n     * @param tempdir the directory where to copy attached files.\n     * @param urlf the {@link com.xpn.xwiki.web.XWikiURLFactory} used to render the\n     *            documents.\n     * @param context the XWiki context.\n     * @throws XWikiException error when render documents.\n     * @throws IOException error when render documents.\n     */\n    private void renderDocuments(ZipOutputStream zos, File tempdir, ExportURLFactory urlf,\n        XWikiContext context) throws XWikiException, IOException\n    {\n        // Push a clean request in the Container since we don't want the\n        // main request to be used for rendering the HTML pages to export.\n        // The new request automatically gets initialized with a new Velocity Context by\n        // the VelocityRequestInitializer class.\n        Container container = (Container) Utils.getComponent(Container.ROLE, context);\n        DaemonContainerInitializer containerInitializer =\n            (DaemonContainerInitializer) Utils.getComponent(DaemonContainerInitializer.ROLE,\n                context);\n\n        VelocityContext oldVelocityContext = (VelocityContext) context.get(\"vcontext\");\n\n        try {\n            containerInitializer.initializeRequest();\n\n            XWikiContext renderContext = (XWikiContext) context.clone();\n            renderContext.put(\"action\", \"view\");\n\n            // This is a bridge that we need for old code to play well with new components.\n            // Old code relies on the XWikiContext object whereas new code uses the Container component.\n            container.getRequest().setProperty(\"xwikicontext\", renderContext);\n\n            VelocityManager velocityManager = \n                (VelocityManager) Utils.getComponent(VelocityManager.ROLE, context);\n\n            // At this stage we have a clean Velocity Context\n            VelocityContext vcontext = velocityManager.getVelocityContext();\n            \n            urlf.init(this.pages, tempdir, renderContext);\n            renderContext.setURLFactory(urlf);\n\n            for (String pageName: this.pages) {\n                renderDocument(pageName, zos, renderContext, vcontext);\n            }\n        } catch (DaemonContainerException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_EXPORT, \n                XWikiException.ERROR_XWIKI_INIT_FAILED, \"Failed to initialize request\", e);\n        } finally {\n            // We must ensure that the new request we've used is removed so that the current\n            // thread can continue to use its original request.\n            container.popRequest();\n            \n            context.put(\"vcontext\", oldVelocityContext);\n        }\n    }","commit_id":"e6c818a8acee5b3ec5d49769d1b7abb25ec07b21","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public ActionForward execute(XWikiContext context) throws Exception, ServletException\n    {\n        MonitorPlugin monitor = null;\n        FileUploadPlugin fileupload = null;\n        String docName = \"\";\n        \n        try {\n            // Verify that the requested wiki exists\n            XWiki xwiki;\n            try {\n                xwiki = XWiki.getXWiki(context);\n            } catch (XWikiException e) {\n                // We're checking if there are any redirects when the wiki asked by the user doesn't exist\n                // because we want the ability to redirect somewhere when the wiki asked doesn't exist\n                // (like for example going to a special error page).\n                if (e.getCode() == XWikiException.ERROR_XWIKI_DOES_NOT_EXIST) {\n                    if (!sendGlobalRedirect(context.getResponse(), context.getURL().toString(), context))\n                        context.getResponse().sendRedirect(context.getWiki().Param(\"xwiki.virtual.redirect\"));\n                    return null;\n                } else {\n                    throw e;\n                }\n            }\n\n            // Send global redirection (if any)\n            if (sendGlobalRedirect(context.getResponse(), context.getURL().toString(), context)) {\n                return null;\n            }\n\n            // Start monitoring timer\n            monitor = (MonitorPlugin) xwiki.getPlugin(\"monitor\", context);\n            if (monitor != null) {\n                monitor.startRequest(\"\", context.getAction(), context.getURL());\n                monitor.startTimer(\"multipart\");\n            }\n            \n            // Parses multipart so that params in multipart are available for all actions\n            fileupload = Utils.handleMultipart(context.getRequest().getHttpServletRequest(), context);\n            if (monitor != null) {\n                monitor.endTimer(\"multipart\");\n            }\n\n            XWikiURLFactory urlf =\n                xwiki.getURLFactoryService().createURLFactory(context.getMode(), context);\n            context.setURLFactory(urlf);\n\n            String sajax = context.getRequest().get(\"ajax\");\n            boolean ajax = false;\n            if (sajax != null && !sajax.trim().equals(\"\") && !sajax.equals(\"0\")) {\n                ajax = true;\n            }\n            context.put(\"ajax\", new Boolean(ajax));\n\n            // Any error before this will be treated using a redirection to an error page\n\n            if (monitor != null) {\n                monitor.startTimer(\"request\");\n            }\n\n            VelocityManager velocityManager = \n                (VelocityManager) Utils.getComponent(VelocityManager.ROLE, context);\n            VelocityContext vcontext = velocityManager.getVelocityContext();\n            \n            try {\n                // Prepare documents and put them in the context\n                if (xwiki.prepareDocuments(context.getRequest(), context, vcontext) == false) {\n                    return null;\n                }\n\n                if (monitor != null) {\n                    monitor.setWikiPage(context.getDoc().getFullName());\n                }\n\n                // Let's handle the notification and make sure it never fails\n                if (monitor != null) {\n                    monitor.startTimer(\"prenotify\");\n                }\n                try {\n                    xwiki.getNotificationManager().preverify(context.getDoc(), context.getAction(),\n                        context);\n                } catch (Throwable e) {\n                    LOG.error(\"Exception while pre-notifying\", e);\n                }\n                if (monitor != null) {\n                    monitor.endTimer(\"prenotify\");\n                }\n\n                String renderResult = null;\n                XWikiDocument doc = context.getDoc();\n                docName = doc.getFullName();\n                if (action(context)) {\n                    renderResult = render(context);\n                }\n\n                if (renderResult != null) {\n                    if ((doc.isNew() && (\"view\".equals(context.getAction()) || \"delete\".equals(context.getAction())))\n                        && !\"recyclebin\".equals(context.getRequest().get(\"viewer\"))) {\n                        String page = Utils.getPage(context.getRequest(), \"docdoesnotexist\");\n                        Utils.parseTemplate(page, context);\n                    } else {\n                        String page = Utils.getPage(context.getRequest(), renderResult);\n                        Utils.parseTemplate(page, !page.equals(\"direct\"), context);\n                    }\n                }\n                return null;\n            } catch (Throwable e) {\n                if (e instanceof IOException) {\n                    e =\n                        new XWikiException(XWikiException.MODULE_XWIKI_APP,\n                            XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION,\n                            \"Exception while sending response\",\n                            e);\n                }\n\n                if (!(e instanceof XWikiException)) {\n                    e =\n                        new XWikiException(XWikiException.MODULE_XWIKI_APP,\n                            XWikiException.ERROR_XWIKI_UNKNOWN,\n                            \"Uncaught exception\",\n                            e);\n                }\n\n                try {\n                    XWikiException xex = (XWikiException) e;\n                    if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION) {\n                        // Connection aborted, simply ignore this.\n                        LOG.error(\"Connection aborted\");\n                        // We don't write any other message, as the connection is broken, anyway.\n                        return null;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_ACCESS_DENIED) {\n                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.access_exception\",\n                            \"accessdenied\"), context);\n                        return null;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_USER_INACTIVE) {\n                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.user_exception\",\n                            \"userinactive\"), context);\n                        return null;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_ATTACHMENT_NOT_FOUND) {\n                        context.put(\"message\", \"attachmentdoesnotexist\");\n                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.attachment_exception\",\n                            \"attachmentdoesnotexist\"), context);\n                        return null;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_URL_EXCEPTION) {\n                        vcontext.put(\"message\", context.getMessageTool().get(\n                            \"platform.core.invalidUrl\"));\n                        xwiki.setPhonyDocument(xwiki.getDefaultWeb(context) + \".\"\n                            + xwiki.getDefaultPage(context), context, vcontext);\n                        context.getResponse().setStatus(HttpServletResponse.SC_BAD_REQUEST);\n                        Utils.parseTemplate(context.getWiki().Param(\n                            \"xwiki.invalid_url_exception\", \"error\"), context);\n                        return null;\n                    }\n                    vcontext.put(\"exp\", e);\n                    if (LOG.isWarnEnabled()) {\n                        LOG.warn(\"Uncaught exception: \" + e.getMessage(), e);\n                    }\n                    Utils.parseTemplate(Utils.getPage(context.getRequest(), \"exception\"), context);\n                    return null;\n                } catch (XWikiException ex) {\n                    if (ex.getCode() == XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION) {\n                        LOG.error(\"Connection aborted\");\n                    }\n                } catch (Exception e2) {\n                    // I hope this never happens\n                    LOG.error(\"Uncaught exceptions (inner): \", e);\n                    LOG.error(\"Uncaught exceptions (outer): \", e2);\n                }\n                return null;\n            } finally {\n                // Let's make sure we have flushed content and closed\n                try {\n                    context.getResponse().getWriter().flush();\n                } catch (Throwable e) {\n                    // This might happen if the connection was closed, for example.\n                    // If we can't flush, then there's nothing more we can send to the client.\n                }\n\n                if (monitor != null) {\n                    monitor.endTimer(\"request\");\n                    monitor.startTimer(\"notify\");\n                }\n\n                // Let's handle the notification and make sure it never fails\n                // This is the old notification mechanism. It is kept here because it is in a\n                // deprecation stage. It will be removed later.\n                try {\n                    xwiki.getNotificationManager().verify(context.getDoc(), context.getAction(),\n                        context);\n                } catch (Throwable e) {\n                    e.printStackTrace();\n                }\n                // This is the new notification mechanism, implemented as a Plexus Component.\n                // For the moment we're sending the XWiki context as the data, but this will be\n                // changed in the future, when the whole platform will be written using components\n                // and there won't be a need for the context.\n                try {\n                    ObservationManager om =\n                        (ObservationManager) Utils.getComponent(ObservationManager.ROLE, null,\n                            context);\n                    om.notify(new ActionExecutionEvent(context.getAction()), context.getDoc(), context);\n                } catch (Throwable ex) {\n                    LOG.error(\"Cannot send action notifications for document [\" + docName\n                        + \" using action [\" + context.getAction() + \"]\", ex);\n                }\n\n                if (monitor != null) {\n                    monitor.endTimer(\"notify\");\n                }\n\n                // Make sure we cleanup database connections\n                // There could be cases where we have some\n                if ((context != null) && (xwiki != null)) {\n                    xwiki.getStore().cleanUp(context);\n                }\n            }\n        } finally {\n            // End request\n            if (monitor != null) {\n                monitor.endRequest();\n            }\n\n            if (context != null) {\n            \n                if (fileupload != null) {\n                    fileupload.cleanFileList(context);\n                }\n            }\n            \n            MDC.remove(\"url\");\n        }\n    }","id":6427,"modified_method":"public ActionForward execute(XWikiContext context) throws Exception\n    {\n        MonitorPlugin monitor = null;\n        FileUploadPlugin fileupload = null;\n        String docName = \"\";\n        \n        try {\n            // Verify that the requested wiki exists\n            XWiki xwiki;\n            try {\n                xwiki = XWiki.getXWiki(context);\n            } catch (XWikiException e) {\n                // We're checking if there are any redirects when the wiki asked by the user doesn't exist\n                // because we want the ability to redirect somewhere when the wiki asked doesn't exist\n                // (like for example going to a special error page).\n                if (e.getCode() == XWikiException.ERROR_XWIKI_DOES_NOT_EXIST) {\n                    if (!sendGlobalRedirect(context.getResponse(), context.getURL().toString(), context))\n                        context.getResponse().sendRedirect(context.getWiki().Param(\"xwiki.virtual.redirect\"));\n                    return null;\n                } else {\n                    throw e;\n                }\n            }\n\n            // Send global redirection (if any)\n            if (sendGlobalRedirect(context.getResponse(), context.getURL().toString(), context)) {\n                return null;\n            }\n\n            // Start monitoring timer\n            monitor = (MonitorPlugin) xwiki.getPlugin(\"monitor\", context);\n            if (monitor != null) {\n                monitor.startRequest(\"\", context.getAction(), context.getURL());\n                monitor.startTimer(\"multipart\");\n            }\n            \n            // Parses multipart so that params in multipart are available for all actions\n            fileupload = Utils.handleMultipart(context.getRequest().getHttpServletRequest(), context);\n            if (monitor != null) {\n                monitor.endTimer(\"multipart\");\n            }\n\n            XWikiURLFactory urlf =\n                xwiki.getURLFactoryService().createURLFactory(context.getMode(), context);\n            context.setURLFactory(urlf);\n\n            String sajax = context.getRequest().get(\"ajax\");\n            boolean ajax = false;\n            if (sajax != null && !sajax.trim().equals(\"\") && !sajax.equals(\"0\")) {\n                ajax = true;\n            }\n            context.put(\"ajax\", ajax);\n\n            // Any error before this will be treated using a redirection to an error page\n\n            if (monitor != null) {\n                monitor.startTimer(\"request\");\n            }\n\n            VelocityManager velocityManager = \n                (VelocityManager) Utils.getComponent(VelocityManager.ROLE, context);\n            VelocityContext vcontext = velocityManager.getVelocityContext();\n            \n            try {\n                // Prepare documents and put them in the context\n                if (!xwiki.prepareDocuments(context.getRequest(), context, vcontext)) {\n                    return null;\n                }\n\n                if (monitor != null) {\n                    monitor.setWikiPage(context.getDoc().getFullName());\n                }\n\n                // Let's handle the notification and make sure it never fails\n                if (monitor != null) {\n                    monitor.startTimer(\"prenotify\");\n                }\n                try {\n                    xwiki.getNotificationManager().preverify(context.getDoc(), context.getAction(),\n                        context);\n                } catch (Throwable e) {\n                    LOG.error(\"Exception while pre-notifying\", e);\n                }\n                if (monitor != null) {\n                    monitor.endTimer(\"prenotify\");\n                }\n\n                String renderResult = null;\n                XWikiDocument doc = context.getDoc();\n                docName = doc.getFullName();\n                if (action(context)) {\n                    renderResult = render(context);\n                }\n\n                if (renderResult != null) {\n                    if ((doc.isNew() && (\"view\".equals(context.getAction()) || \"delete\".equals(context.getAction())))\n                        && !\"recyclebin\".equals(context.getRequest().get(\"viewer\"))) {\n                        String page = Utils.getPage(context.getRequest(), \"docdoesnotexist\");\n                        Utils.parseTemplate(page, context);\n                    } else {\n                        String page = Utils.getPage(context.getRequest(), renderResult);\n                        Utils.parseTemplate(page, !page.equals(\"direct\"), context);\n                    }\n                }\n                return null;\n            } catch (Throwable e) {\n                if (e instanceof IOException) {\n                    e =\n                        new XWikiException(XWikiException.MODULE_XWIKI_APP,\n                            XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION,\n                            \"Exception while sending response\",\n                            e);\n                }\n\n                if (!(e instanceof XWikiException)) {\n                    e =\n                        new XWikiException(XWikiException.MODULE_XWIKI_APP,\n                            XWikiException.ERROR_XWIKI_UNKNOWN,\n                            \"Uncaught exception\",\n                            e);\n                }\n\n                try {\n                    XWikiException xex = (XWikiException) e;\n                    if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION) {\n                        // Connection aborted, simply ignore this.\n                        LOG.error(\"Connection aborted\");\n                        // We don't write any other message, as the connection is broken, anyway.\n                        return null;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_ACCESS_DENIED) {\n                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.access_exception\",\n                            \"accessdenied\"), context);\n                        return null;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_USER_INACTIVE) {\n                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.user_exception\",\n                            \"userinactive\"), context);\n                        return null;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_ATTACHMENT_NOT_FOUND) {\n                        context.put(\"message\", \"attachmentdoesnotexist\");\n                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.attachment_exception\",\n                            \"attachmentdoesnotexist\"), context);\n                        return null;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_URL_EXCEPTION) {\n                        vcontext.put(\"message\", context.getMessageTool().get(\n                            \"platform.core.invalidUrl\"));\n                        xwiki.setPhonyDocument(xwiki.getDefaultWeb(context) + \".\"\n                            + xwiki.getDefaultPage(context), context, vcontext);\n                        context.getResponse().setStatus(HttpServletResponse.SC_BAD_REQUEST);\n                        Utils.parseTemplate(context.getWiki().Param(\n                            \"xwiki.invalid_url_exception\", \"error\"), context);\n                        return null;\n                    }\n                    vcontext.put(\"exp\", e);\n                    if (LOG.isWarnEnabled()) {\n                        LOG.warn(\"Uncaught exception: \" + e.getMessage(), e);\n                    }\n                    Utils.parseTemplate(Utils.getPage(context.getRequest(), \"exception\"), context);\n                    return null;\n                } catch (XWikiException ex) {\n                    if (ex.getCode() == XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION) {\n                        LOG.error(\"Connection aborted\");\n                    }\n                } catch (Exception e2) {\n                    // I hope this never happens\n                    LOG.error(\"Uncaught exceptions (inner): \", e);\n                    LOG.error(\"Uncaught exceptions (outer): \", e2);\n                }\n                return null;\n            } finally {\n                // Let's make sure we have flushed content and closed\n                try {\n                    context.getResponse().getWriter().flush();\n                } catch (Throwable e) {\n                    // This might happen if the connection was closed, for example.\n                    // If we can't flush, then there's nothing more we can send to the client.\n                }\n\n                if (monitor != null) {\n                    monitor.endTimer(\"request\");\n                    monitor.startTimer(\"notify\");\n                }\n\n                // Let's handle the notification and make sure it never fails\n                // This is the old notification mechanism. It is kept here because it is in a\n                // deprecation stage. It will be removed later.\n                try {\n                    xwiki.getNotificationManager().verify(context.getDoc(), context.getAction(),\n                        context);\n                } catch (Throwable e) {\n                    e.printStackTrace();\n                }\n                // This is the new notification mechanism, implemented as a Plexus Component.\n                // For the moment we're sending the XWiki context as the data, but this will be\n                // changed in the future, when the whole platform will be written using components\n                // and there won't be a need for the context.\n                try {\n                    ObservationManager om =\n                        (ObservationManager) Utils.getComponent(ObservationManager.ROLE, null,\n                            context);\n                    om.notify(new ActionExecutionEvent(context.getAction()), context.getDoc(), context);\n                } catch (Throwable ex) {\n                    LOG.error(\"Cannot send action notifications for document [\" + docName\n                        + \" using action [\" + context.getAction() + \"]\", ex);\n                }\n\n                if (monitor != null) {\n                    monitor.endTimer(\"notify\");\n                }\n\n                // Make sure we cleanup database connections\n                // There could be cases where we have some\n                if ((context != null) && (xwiki != null)) {\n                    xwiki.getStore().cleanUp(context);\n                }\n            }\n        } finally {\n            // End request\n            if (monitor != null) {\n                monitor.endRequest();\n            }\n\n            if (context != null) {\n            \n                if (fileupload != null) {\n                    fileupload.cleanFileList(context);\n                }\n            }\n            \n            MDC.remove(\"url\");\n        }\n    }","commit_id":"e6c818a8acee5b3ec5d49769d1b7abb25ec07b21","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Send redirection based on a regexp pattern (if any) set at the main wiki level.\n     * To enable this feature you must add xwiki.preferences.redirect=1 to your xwiki.cfg.\n     *\n     * @param response the servlet response\n     * @param url      url of the request\n     * @param context  the XWiki context\n     * @return true if a redirection has been sent\n     * @throws Exception\n     */\n    protected boolean sendGlobalRedirect(XWikiResponse response, String url, XWikiContext context)\n            throws Exception\n    {\n        if (\"1\".equals(context.getWiki().Param(\"xwiki.preferences.redirect\"))) {\n            // Note: This implementation is not performant at all and will slow down the wiki as the number\n            // of redirects increases. A better implementation would use a cache of redirects and would use\n            // the notification mechanism to update the cache when the XWiki.XWikiPreferences document is\n            // modified.\n            XWikiDocument globalPreferences = context.getWiki().getDocument(\"xwiki:XWiki.XWikiPreferences\", context);\n            Vector<BaseObject> redirects = globalPreferences.getObjects(\"XWiki.GlobalRedirect\");\n\n            if (redirects != null) {\n                for (BaseObject redir : redirects) {\n                    String p = redir.getStringValue(\"pattern\");\n                    if (url.matches(p)) {\n                        String dest = redir.getStringValue(\"destination\");\n                        response.sendRedirect(url.replaceAll(p, dest));\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }","id":6428,"modified_method":"/**\n     * Send redirection based on a regexp pattern (if any) set at the main wiki level.\n     * To enable this feature you must add xwiki.preferences.redirect=1 to your xwiki.cfg.\n     *\n     * @param response the servlet response\n     * @param url      url of the request\n     * @param context  the XWiki context\n     * @return true if a redirection has been sent\n     */\n    protected boolean sendGlobalRedirect(XWikiResponse response, String url, XWikiContext context)\n            throws Exception\n    {\n        if (\"1\".equals(context.getWiki().Param(\"xwiki.preferences.redirect\"))) {\n            // Note: This implementation is not performant at all and will slow down the wiki as the number\n            // of redirects increases. A better implementation would use a cache of redirects and would use\n            // the notification mechanism to update the cache when the XWiki.XWikiPreferences document is\n            // modified.\n            XWikiDocument globalPreferences = context.getWiki().getDocument(\"xwiki:XWiki.XWikiPreferences\", context);\n            Vector<BaseObject> redirects = globalPreferences.getObjects(\"XWiki.GlobalRedirect\");\n\n            if (redirects != null) {\n                for (BaseObject redir : redirects) {\n                    String p = redir.getStringValue(\"pattern\");\n                    if (url.matches(p)) {\n                        String dest = redir.getStringValue(\"destination\");\n                        response.sendRedirect(url.replaceAll(p, dest));\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }","commit_id":"e6c818a8acee5b3ec5d49769d1b7abb25ec07b21","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected void initializeContainerComponent(XWikiContext context)\n        throws ServletException\n    {\n        // Initialize the Container fields (request, response, session).\n        // Note that this is a bridge between the old core and the component architecture.\n        // In the new component architecture we use ThreadLocal to transport the request, \n        // response and session to components which require them.\n        // In the future this Servlet will be replaced by the XWikiPlexusServlet Servlet.\n        Container container = (Container) Utils.getComponent(Container.ROLE, context);\n        ServletContainerFactory containerFactory =\n            (ServletContainerFactory) Utils.getComponent(ServletContainerFactory.ROLE, context);\n        try {\n            container.setRequest(containerFactory.createRequest(\n                context.getRequest().getHttpServletRequest()));\n            container.setResponse(containerFactory.createResponse(\n                context.getResponse().getHttpServletResponse()));\n            container.setSession(containerFactory.createSession(\n                context.getRequest().getHttpServletRequest()));\n        } catch (ServletContainerException e) {\n            throw new ServletException(\"Failed to initialize request/response or session\", e);\n        }            \n\n        // This is a bridge that we need for old code to play well with new components.\n        // Old code relies on the XWikiContext object whereas new code uses the Container component.\n        container.getRequest().setProperty(\"xwikicontext\", context);\n    }","id":6429,"modified_method":"protected void initializeContainerComponent(XWikiContext context)\n        throws ServletException\n    {\n        // Initialize the Container fields (request, response, session).\n        // Note that this is a bridge between the old core and the component architecture.\n        // In the new component architecture we use ThreadLocal to transport the request, \n        // response and session to components which require them.\n        // In the future this Servlet will be replaced by the XWikiPlexusServlet Servlet.\n        ServletContainerInitializer containerInitializer =\n            (ServletContainerInitializer) Utils.getComponent(ServletContainerInitializer.ROLE, context);\n        try {\n            containerInitializer.initializeRequest(context.getRequest().getHttpServletRequest());\n            containerInitializer.initializeResponse(context.getResponse().getHttpServletResponse());\n            containerInitializer.initializeSession(context.getRequest().getHttpServletRequest());\n        } catch (ServletContainerException e) {\n            throw new ServletException(\"Failed to initialize request/response or session\", e);\n        }            \n\n        // This is a bridge that we need for old code to play well with new components.\n        // Old code relies on the XWikiContext object whereas new code uses the Container component.\n        Container container = (Container) Utils.getComponent(Container.ROLE, context);\n        container.getRequest().setProperty(\"xwikicontext\", context);\n    }","commit_id":"e6c818a8acee5b3ec5d49769d1b7abb25ec07b21","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected void service(HttpServletRequest httpServletRequest,\n        HttpServletResponse httpServletResponse) throws ServletException, IOException\n    {\n        ActionManager manager = (ActionManager) lookup(ActionManager.ROLE);\n\n        // Initializes XWiki's Container with the Servlet request/response/session so that\n        // components needing them can depend on the Container component to get them.\n        Container container = (Container) lookup(Container.ROLE);\n        ServletContainerFactory containerFactory =\n            (ServletContainerFactory) lookup(ServletContainerFactory.ROLE);\n        try {\n            container.setRequest(containerFactory.createRequest(httpServletRequest));\n            container.setResponse(containerFactory.createResponse(httpServletResponse));\n            container.setSession(containerFactory.createSession(httpServletRequest));\n        } catch (ServletContainerException e) {\n            try {\n                // Call the error Action to handle the exception\n                manager.handleRequest(\"error\", e);\n                return;\n            } catch (ActionException ae) {\n                throw new ServletException(\"Failed to call the error Action\", ae);\n            }\n        }\n\n        // Call the Action Manager to handle the request\n        try {\n            manager.handleRequest();\n        } catch (ActionException e) {\n            // We haven't been able to handle the exception in ActionManager so generate a\n            // container exception.\n            throw new ServletException(\"Failed to handle request\", e);\n        }\n    }","id":6430,"modified_method":"protected void service(HttpServletRequest httpServletRequest,\n        HttpServletResponse httpServletResponse) throws ServletException, IOException\n    {\n        ActionManager manager = (ActionManager) lookup(ActionManager.ROLE);\n\n        // Initializes XWiki's Container with the Servlet request/response/session so that\n        // components needing them can depend on the Container component to get them.\n        ServletContainerInitializer containerInitializer =\n            (ServletContainerInitializer) lookup(ServletContainerInitializer.ROLE);\n        try {\n            containerInitializer.initializeRequest(httpServletRequest);\n            containerInitializer.initializeResponse(httpServletResponse);\n            containerInitializer.initializeSession(httpServletRequest);\n        } catch (ServletContainerException e) {\n            try {\n                // Call the error Action to handle the exception\n                manager.handleRequest(\"error\", e);\n                return;\n            } catch (ActionException ae) {\n                throw new ServletException(\"Failed to call the error Action\", ae);\n            }\n        }\n\n        // Call the Action Manager to handle the request\n        try {\n            manager.handleRequest();\n        } catch (ActionException e) {\n            // We haven't been able to handle the exception in ActionManager so generate a\n            // container exception.\n            throw new ServletException(\"Failed to handle request\", e);\n        }\n    }","commit_id":"e6c818a8acee5b3ec5d49769d1b7abb25ec07b21","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void contextInitialized(ServletContextEvent servletContextEvent)\n    {\n        // Initializes Plexus\n        super.contextInitialized(servletContextEvent);\n\n        // Initializes XWiki's Container with the Servlet Conetext.\n        try {\n            Container container = (Container) PlexusServletUtils.lookup(\n                servletContextEvent.getServletContext(), Container.ROLE);\n            ServletContainerFactory containerFactory = \n                (ServletContainerFactory) PlexusServletUtils.lookup(\n                    servletContextEvent.getServletContext(), ServletContainerFactory.ROLE);\n            container.setApplicationContext(containerFactory.createApplicationContext(\n                servletContextEvent.getServletContext()));\n        } catch (ServletException se) {\n            throw new RuntimeException(\"Failed to initialize application contextt\", se);\n        }\n        \n        // This is a temporary bridge to allow non XWiki components to lookup XWiki components.\n        // We're putting the XWiki Component Manager instance in the Servlet Context so that it's\n        // available in the XWikiAction class which in turn puts it into the XWikiContext instance.\n        // Class that need to lookup then just need to get it from the XWikiContext instance.\n        // This is of course not necessary for XWiki components since they just need to implement\n        // the Composable interface to get access to the Component Manager or better they simply\n        // need to define the Components they require as field members and configure the Plexus\n        // deployment descriptors (components.xml) so that they are automatically injected.\n        PlexusContainer plexusContainer =\n            PlexusServletUtils.getPlexusContainer(servletContextEvent.getServletContext());\n        org.xwiki.component.manager.ComponentManager xwikiManager = new PlexusComponentManager(\n            new PlexusContainerLocator(plexusContainer));\n        servletContextEvent.getServletContext().setAttribute(\n            org.xwiki.component.manager.ComponentManager.class.getName(), xwikiManager);\n    }","id":6431,"modified_method":"public void contextInitialized(ServletContextEvent servletContextEvent)\n    {\n        // Initializes Plexus\n        super.contextInitialized(servletContextEvent);\n\n        // Initializes XWiki's Container with the Servlet Conetext.\n        try {\n            ServletContainerInitializer containerInitializer =\n                (ServletContainerInitializer) PlexusServletUtils.lookup(\n                    servletContextEvent.getServletContext(), ServletContainerInitializer.ROLE);\n            containerInitializer.initializeApplicationContext(\n                servletContextEvent.getServletContext());\n        } catch (ServletException se) {\n            throw new RuntimeException(\"Failed to initialize application contextt\", se);\n        }\n        \n        // This is a temporary bridge to allow non XWiki components to lookup XWiki components.\n        // We're putting the XWiki Component Manager instance in the Servlet Context so that it's\n        // available in the XWikiAction class which in turn puts it into the XWikiContext instance.\n        // Class that need to lookup then just need to get it from the XWikiContext instance.\n        // This is of course not necessary for XWiki components since they just need to implement\n        // the Composable interface to get access to the Component Manager or better they simply\n        // need to define the Components they require as field members and configure the Plexus\n        // deployment descriptors (components.xml) so that they are automatically injected.\n        PlexusContainer plexusContainer =\n            PlexusServletUtils.getPlexusContainer(servletContextEvent.getServletContext());\n        org.xwiki.component.manager.ComponentManager xwikiManager = new PlexusComponentManager(\n            new PlexusContainerLocator(plexusContainer));\n        servletContextEvent.getServletContext().setAttribute(\n            org.xwiki.component.manager.ComponentManager.class.getName(), xwikiManager);\n    }","commit_id":"e6c818a8acee5b3ec5d49769d1b7abb25ec07b21","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected void initializeContainerComponent(XWikiContext context)\n        throws PortletException\n    {\n        // Initialize the Container fields (request, response, session).\n        // Note that this is a bridge between the old core and the component architecture.\n        // In the new component architecture we use ThreadLocal to transport the request, \n        // response and session to components which require them.\n        Container container = (Container) Utils.getComponent(Container.ROLE, context);\n        PortletContainerFactory containerFactory =\n            (PortletContainerFactory) Utils.getComponent(PortletContainerFactory.ROLE, context);\n        try {\n            container.setRequest(containerFactory.createRequest(\n                ((XWikiPortletRequest) context.getRequest()).getPortletRequest()));\n            container.setResponse(containerFactory.createResponse(\n                ((XWikiPortletResponse) context.getResponse()).getPortletResponse()));\n            container.setSession(containerFactory.createSession(\n                ((XWikiPortletRequest) context.getRequest()).getPortletRequest()));\n        } catch (PortletContainerException e) {\n            throw new PortletException(\"Failed to initialize request/response or session\", e);\n        }            \n    \n        // This is a bridge that we need for old code to play well with new components.\n        // Old code relies on the XWikiContext object whereas new code uses the Container component.\n        container.getRequest().setProperty(\"xwikicontext\", context);\n    }","id":6432,"modified_method":"protected void initializeContainerComponent(XWikiContext context)\n        throws PortletException\n    {\n        // Initialize the Container fields (request, response, session).\n        // Note that this is a bridge between the old core and the component architecture.\n        // In the new component architecture we use ThreadLocal to transport the request, \n        // response and session to components which require them.\n        PortletContainerInitializer containerInitializer =\n            (PortletContainerInitializer) Utils.getComponent(PortletContainerInitializer.ROLE,\n                context);\n        try {\n            containerInitializer.initializeRequest(\n                ((XWikiPortletRequest) context.getRequest()).getPortletRequest());\n            containerInitializer.initializeResponse(\n                ((XWikiPortletResponse) context.getResponse()).getPortletResponse());\n            containerInitializer.initializeSession(\n                ((XWikiPortletRequest) context.getRequest()).getPortletRequest());\n        } catch (PortletContainerException e) {\n            throw new PortletException(\"Failed to initialize request/response or session\", e);\n        }            \n    \n        // This is a bridge that we need for old code to play well with new components.\n        // Old code relies on the XWikiContext object whereas new code uses the Container component.\n        Container container = (Container) Utils.getComponent(Container.ROLE, context);\n        container.getRequest().setProperty(\"xwikicontext\", context);\n    }","commit_id":"e6c818a8acee5b3ec5d49769d1b7abb25ec07b21","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void initializeContainerComponent(XWikiContext context)\n        throws XmlRpcException\n    {\n        // Initialize the Container fields (request, response, session).\n        // Note that this is a bridge between the old core and the component architecture.\n        // In the new component architecture we use ThreadLocal to transport the request, \n        // response and session to components which require them.\n        Container container = (Container) Utils.getComponent(Container.ROLE, context);\n        ServletContainerFactory containerFactory =\n            (ServletContainerFactory) Utils.getComponent(ServletContainerFactory.ROLE, context);\n        try {\n            container.setRequest(containerFactory.createRequest(\n                context.getRequest().getHttpServletRequest()));\n            container.setResponse(containerFactory.createResponse(\n                context.getResponse().getHttpServletResponse()));\n            container.setSession(containerFactory.createSession(\n                context.getRequest().getHttpServletRequest()));\n        } catch (ServletContainerException e) {\n            throw new XmlRpcException(\"Failed to initialize request/response or session\", e);\n        }            \n\n        // This is a bridge that we need for old code to play well with new components.\n        // Old code relies on the XWikiContext object whereas new code uses the Container component.\n        container.getRequest().setProperty(\"xwikicontext\", context);\n    }","id":6433,"modified_method":"private void initializeContainerComponent(XWikiContext context)\n        throws XmlRpcException\n    {\n        // Initialize the Container fields (request, response, session).\n        // Note that this is a bridge between the old core and the component architecture.\n        // In the new component architecture we use ThreadLocal to transport the request, \n        // response and session to components which require them.\n        ServletContainerInitializer containerInitializer =\n            (ServletContainerInitializer) Utils.getComponent(ServletContainerInitializer.ROLE, context);\n        try {\n            containerInitializer.initializeRequest(context.getRequest().getHttpServletRequest());\n            containerInitializer.initializeResponse(context.getResponse().getHttpServletResponse());\n            containerInitializer.initializeSession(context.getRequest().getHttpServletRequest());\n        } catch (ServletContainerException e) {\n            throw new XmlRpcException(\"Failed to initialize request/response or session\", e);\n        }            \n\n        // This is a bridge that we need for old code to play well with new components.\n        // Old code relies on the XWikiContext object whereas new code uses the Container component.\n        Container container = (Container) Utils.getComponent(Container.ROLE, context);\n        container.getRequest().setProperty(\"xwikicontext\", context);\n    }","commit_id":"e6c818a8acee5b3ec5d49769d1b7abb25ec07b21","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Here we intercept all the method call and wrap them in a try/catch/finally block.\n     * \n     * @see ReflectiveXmlRpcHandler#execute(XmlRpcRequest)\n     */\n    @Override\n    public Object execute(final XmlRpcRequest request) throws XmlRpcException\n    {\n        XWikiContext context = null;\n        \n        try {\n            // Here we prepare the XWikiXmlRpcContext object and we put it in the config object so\n            // that XMLRPC methods can get it. The config object is the same that is passed to the\n            // XWikiXmlRpcHandler when it is initialized. So modifications made here are reflected\n            // in the config object that is available to XMLRPC methods through the field\n            // XWikiXmlRpcHandler.xwikiXmlRpcHttpRequestConfig.\n            XWikiXmlRpcHttpRequestConfig config =\n                (XWikiXmlRpcHttpRequestConfig) request.getConfig();\n            XWikiRequest xwikiRequest = new XWikiXmlRpcRequest(config.getRequest());\n            XWikiResponse xwikiResponse =\n                new XWikiXmlRpcResponse((XWikiResponse) XWikiUtils.mock(XWikiResponse.class));\n            XWikiServletContext xwikiServletContext =\n                new XWikiServletContext(config.getServlet().getServletContext());\n\n            context = Utils.prepareContext(\"\", xwikiRequest, xwikiResponse, xwikiServletContext);\n            \n            XWiki xwiki = XWiki.getXWiki(context);\n            XWikiURLFactory urlf =\n                xwiki.getURLFactoryService().createURLFactory(context.getMode(), context);\n            context.setURLFactory(urlf);\n\n            // Here we set the prepared context\n            config.setXmlRpcContext(new XWikiXmlRpcContext(context));\n\n            // Initialize new Container subsystem\n            initializeContainerComponent(context);\n            \n            // This performs the actual XMLRPC method invocation using all the logic we don't care\n            // of :)\n            return super.execute(request);\n        } catch (XmlRpcException e) {\n            throw e;\n        } catch (XWikiException e) {\n            throw new XmlRpcException(e.getMessage(), e);\n        } finally {\n            // Cleanup code\n            if (context != null) {\n                cleanupContainerComponent(context);\n            }\n        }\n    }","id":6434,"modified_method":"/**\n     * Here we intercept all the method call and wrap them in a try/catch/finally block.\n     * \n     * @see ReflectiveXmlRpcHandler#execute(XmlRpcRequest)\n     */\n    @Override\n    public Object execute(final XmlRpcRequest request) throws XmlRpcException\n    {\n        XWikiContext context = null;\n        \n        try {\n            // Here we prepare the XWikiXmlRpcContext object and we put it in the config object so\n            // that XMLRPC methods can get it. The config object is the same that is passed to the\n            // XWikiXmlRpcHandler when it is initialized. So modifications made here are reflected\n            // in the config object that is available to XMLRPC methods through the field\n            // XWikiXmlRpcHandler.xwikiXmlRpcHttpRequestConfig.\n            XWikiXmlRpcHttpRequestConfig config =\n                (XWikiXmlRpcHttpRequestConfig) request.getConfig();\n            XWikiRequest xwikiRequest = new XWikiXmlRpcRequest(config.getRequest());\n            XWikiResponse xwikiResponse =\n                new XWikiXmlRpcResponse((XWikiResponse) XWikiUtils.mock(XWikiResponse.class));\n            XWikiServletContext xwikiServletContext =\n                new XWikiServletContext(config.getServlet().getServletContext());\n\n            context = Utils.prepareContext(\"\", xwikiRequest, xwikiResponse, xwikiServletContext);\n            \n            XWiki xwiki = XWiki.getXWiki(context);\n            XWikiURLFactory urlf =\n                xwiki.getURLFactoryService().createURLFactory(context.getMode(), context);\n            context.setURLFactory(urlf);\n\n            // Here we set the prepared context\n            config.setXmlRpcContext(new XWikiXmlRpcContext(context));\n\n            // Initialize new Container subsystem\n            initializeContainerComponent(context);\n            \n            // This performs the actual XMLRPC method invocation using all the logic we don't care\n            // of :)\n            return super.execute(request);\n        } catch (XWikiException e) {\n            throw new XmlRpcException(e.getMessage(), e);\n        } finally {\n            // Cleanup code\n            if (context != null) {\n                cleanupContainerComponent(context);\n            }\n        }\n    }","commit_id":"e6c818a8acee5b3ec5d49769d1b7abb25ec07b21","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void initializeContainerComponent(XWikiContext context)\n        throws ServletException\n    {\n        // Initialize the Container fields (request, response, session).\n        // Note that this is a bridge between the old core and the component architecture.\n        // In the new component architecture we use ThreadLocal to transport the request, \n        // response and session to components which require them.\n        Container container = (Container) Utils.getComponent(Container.ROLE, context);\n        ServletContainerFactory containerFactory =\n            (ServletContainerFactory) Utils.getComponent(ServletContainerFactory.ROLE, context);\n        try {\n            container.setRequest(containerFactory.createRequest(\n                context.getRequest().getHttpServletRequest()));\n            container.setResponse(containerFactory.createResponse(\n                context.getResponse().getHttpServletResponse()));\n            container.setSession(containerFactory.createSession(\n                context.getRequest().getHttpServletRequest()));\n        } catch (ServletContainerException e) {\n            throw new ServletException(\"Failed to initialize request/response or session\", e);\n        }            \n    \n        // This is a bridge that we need for old code to play well with new components.\n        // Old code relies on the XWikiContext object whereas new code uses the Container component.\n        container.getRequest().setProperty(\"xwikicontext\", context);\n    }","id":6435,"modified_method":"private void initializeContainerComponent(XWikiContext context)\n        throws ServletException\n    {\n        // Initialize the Container fields (request, response, session).\n        // Note that this is a bridge between the old core and the component architecture.\n        // In the new component architecture we use ThreadLocal to transport the request, \n        // response and session to components which require them.\n        ServletContainerInitializer containerInitializer =\n            (ServletContainerInitializer) Utils.getComponent(ServletContainerInitializer.ROLE, context);\n        try {\n            containerInitializer.initializeRequest(context.getRequest().getHttpServletRequest());\n            containerInitializer.initializeResponse(context.getResponse().getHttpServletResponse());\n            containerInitializer.initializeSession(context.getRequest().getHttpServletRequest());\n        } catch (ServletContainerException e) {\n            throw new ServletException(\"Failed to initialize request/response or session\", e);\n        }            \n    \n        // This is a bridge that we need for old code to play well with new components.\n        // Old code relies on the XWikiContext object whereas new code uses the Container component.\n        Container container = (Container) Utils.getComponent(Container.ROLE, context);\n        container.getRequest().setProperty(\"xwikicontext\", context);\n    }","commit_id":"ae3e351d5f7226a6a9c30d4ad2b54dfec4bbf108","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Removes and resets from connection table (which is already locked). Returns true if member was found,\n     * otherwise false. This method is public only so it can be invoked by unit testing, but should not otherwise be\n     * used ! \n     */\n    public boolean removeConnection(Address mbr) {\n        Entry entry;\n\n        synchronized(connections) {\n            entry=connections.remove(mbr);\n        }\n        if(entry != null) {\n            entry.reset();\n            return true;\n        }\n        else\n            return false;\n    }","id":6436,"modified_method":"/**\n     * Removes and resets from connection table (which is already locked). Returns true if member was found,\n     * otherwise false. This method is public only so it can be invoked by unit testing, but should not otherwise be\n     * used ! \n     */\n    public void removeConnection(Address mbr) {\n        SenderEntry entry=send_table.remove(mbr);\n        if(entry != null)\n            entry.reset();\n\n        ReceiverEntry entry2=recv_table.remove(mbr);\n        if(entry2 != null)\n            entry2.reset();\n        }","commit_id":"ae592594e71f5af48a52f494bd94376a7c71115c","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Check whether the hashtable contains an entry e for <code>sender<\/code> (create if not). If\n     * e.received_msgs is null and <code>first<\/code> is true: create a new AckReceiverWindow(seqno) and\n     * add message. Set e.received_msgs to the new window. Else just add the message.\n     */\n    private void handleDataReceived(Address sender, long seqno, long conn_id,  boolean first, Message msg) {\n        if(log.isTraceEnabled()) {\n            StringBuilder sb=new StringBuilder();\n            sb.append(local_addr).append(\" <-- DATA(\").append(sender).append(\": #\").append(seqno);\n            if(conn_id != 0) sb.append(\", conn_id=\").append(conn_id);\n            if(first) sb.append(\", first\");\n            sb.append(')');\n            log.trace(sb);\n        }\n\n        AckReceiverWindow win;\n        synchronized(connections) {\n            Entry entry=connections.get(sender);\n            win=entry != null? entry.received_msgs : null;\n\n            if(first) {\n                if(entry == null || win == null) {\n                    win=createReceiverWindow(sender, entry, seqno, conn_id);\n                }\n                else {  // entry != null && win != null\n                    if(conn_id != entry.recv_conn_id) {\n                        if(log.isTraceEnabled())\n                            log.trace(local_addr + \": conn_id=\" + conn_id + \" != \" + entry.recv_conn_id + \"; resetting receiver window\");\n                        win=createReceiverWindow(sender, entry, seqno, conn_id);\n                    }\n                    else {\n                        ;\n                    }\n                }\n            }\n            else { // entry == null && win == null OR entry != null && win == null OR entry != null && win != null\n                if(win == null || entry.recv_conn_id != conn_id) {\n                    sendRequestForFirstSeqno(sender);\n                    return; // drop message\n                }\n            }\n        }\n\n        boolean added=win.add(seqno, msg); // entry.received_msgs is guaranteed to be non-null if we get here\n        num_msgs_received++;\n        num_bytes_received+=msg.getLength();\n\n        if(added && !msg.isFlagSet(Message.OOB))\n            undelivered_msgs.incrementAndGet();\n\n        if(win.smallerThanNextToRemove(seqno))\n            sendAck(msg.getSrc(), seqno);\n\n        // message is passed up if OOB. Later, when remove() is called, we discard it. This affects ordering !\n        // http://jira.jboss.com/jira/browse/JGRP-377\n        if(msg.isFlagSet(Message.OOB)) {\n            if(added)\n                up_prot.up(new Event(Event.MSG, msg));\n            Message oob_msg=win.removeOOBMessage();\n            if(oob_msg != null)\n                sendAckForMessage(oob_msg);\n            \n            if(!(win.hasMessagesToRemove() && undelivered_msgs.get() > 0))\n                return;\n        }\n\n        if(!added && !win.hasMessagesToRemove()) { // no ack if we didn't add the msg (e.g. duplicate)\n            return;\n        }\n\n        final AtomicBoolean processing=win.getProcessing();\n        if(!processing.compareAndSet(false, true)) {\n            return;\n        }\n\n        // Try to remove (from the AckReceiverWindow) as many messages as possible as pass them up\n        boolean released_processing=false;\n        int num_regular_msgs_removed=0;\n\n        // Prevents concurrent passing up of messages by different threads (http://jira.jboss.com/jira/browse/JGRP-198);\n        // this is all the more important once we have a threadless stack (http://jira.jboss.com/jira/browse/JGRP-181),\n        // where lots of threads can come up to this point concurrently, but only 1 is allowed to pass at a time\n        // We *can* deliver messages from *different* senders concurrently, e.g. reception of P1, Q1, P2, Q2 can result in\n        // delivery of P1, Q1, Q2, P2: FIFO (implemented by UNICAST) says messages need to be delivered only in the\n        // order in which they were sent by their senders\n        try {\n            while(true) {\n                Message m=win.remove(processing);\n                if(m == null) {\n                    released_processing=true;\n                    return;\n                }\n\n                // discard OOB msg as it has already been delivered (http://jira.jboss.com/jira/browse/JGRP-377)\n                if(m.isFlagSet(Message.OOB)) {\n                    continue;\n                }\n                num_regular_msgs_removed++;\n                sendAckForMessage(m);\n                up_prot.up(new Event(Event.MSG, m));\n            }\n        }\n        finally {\n            // We keep track of regular messages that we added, but couldn't remove (because of ordering).\n            // When we have such messages pending, then even OOB threads will remove and process them\n            // http://jira.jboss.com/jira/browse/JGRP-781\n            undelivered_msgs.addAndGet(-num_regular_msgs_removed);\n\n            if(!released_processing)\n                processing.set(false);\n        }\n    }","id":6437,"modified_method":"/**\n     * Check whether the hashtable contains an entry e for <code>sender<\/code> (create if not). If\n     * e.received_msgs is null and <code>first<\/code> is true: create a new AckReceiverWindow(seqno) and\n     * add message. Set e.received_msgs to the new window. Else just add the message.\n     */\n    private void handleDataReceived(Address sender, long seqno, long conn_id,  boolean first, Message msg) {\n        if(log.isTraceEnabled()) {\n            StringBuilder sb=new StringBuilder();\n            sb.append(local_addr).append(\" <-- DATA(\").append(sender).append(\": #\").append(seqno);\n            if(conn_id != 0) sb.append(\", conn_id=\").append(conn_id);\n            if(first) sb.append(\", first\");\n            sb.append(')');\n            log.trace(sb);\n        }\n\n        AckReceiverWindow win;\n        Address send_request_for_first_seqno=null;\n        synchronized(recv_table) {\n            ReceiverEntry entry=recv_table.get(sender);\n            win=entry != null? entry.received_msgs : null;\n\n            if(first) {\n                if(entry == null || win == null) {\n                    win=createReceiverWindow(sender, entry, seqno, conn_id);\n                }\n                else {  // entry != null && win != null\n                    if(conn_id != entry.recv_conn_id) {\n                        if(log.isTraceEnabled())\n                            log.trace(local_addr + \": conn_id=\" + conn_id + \" != \" + entry.recv_conn_id + \"; resetting receiver window\");\n                        win=createReceiverWindow(sender, entry, seqno, conn_id);\n                    }\n                    else {\n                        ;\n                    }\n                }\n            }\n            else { // entry == null && win == null OR entry != null && win == null OR entry != null && win != null\n                if(win == null || entry.recv_conn_id != conn_id)\n                    send_request_for_first_seqno=sender; // drops the message and returns (see below)\n            }\n        }\n\n        if(send_request_for_first_seqno != null) {\n            sendRequestForFirstSeqno(send_request_for_first_seqno);\n            return;\n        }\n\n        byte result=win.add2(seqno, msg); // win is guaranteed to be non-null if we get here\n        boolean added=result > 0;\n        num_msgs_received++;\n        num_bytes_received+=msg.getLength();\n\n        if(added && !msg.isFlagSet(Message.OOB))\n            undelivered_msgs.incrementAndGet();\n\n        // Cannot be replaced with if(!added), see https://jira.jboss.org/jira/browse/JGRP-1043 comment 15/Sep/09 06:57 AM\n\n        // We *have* to do send the ACK, to cover the following scenario:\n        // - A sends #3 to B\n        // - B removes #3 and sends ACK(3) to A. B's next_to_remove is now 4\n        // - B's ACK(3) to A is dropped by the network\n        // - A keeps retransmitting #3 to B, until it gets an ACK(3)\n        // -B will never ACK #3 if the 2 lines below are commented ==> endless retransmission of A's #3 !\n        if(result == -1) { // only ack if seqno was < next_to_remove !\n            sendAck(msg.getSrc(), seqno);\n        }\n\n        // message is passed up if OOB. Later, when remove() is called, we discard it. This affects ordering !\n        // http://jira.jboss.com/jira/browse/JGRP-377\n        if(msg.isFlagSet(Message.OOB)) {\n            if(added)\n                up_prot.up(new Event(Event.MSG, msg));\n            Message oob_msg=win.removeOOBMessage();\n            if(!(undelivered_msgs.get() > 0 && win.hasMessagesToRemove())) {\n                if(oob_msg != null)\n                    sendAckForMessage(oob_msg);\n                return;\n            }\n        }\n\n        final AtomicBoolean processing=win.getProcessing();\n        if(!processing.compareAndSet(false, true)) {\n            return;\n        }\n\n        // Try to remove (from the AckReceiverWindow) as many messages as possible as pass them up\n        boolean released_processing=false;\n        int num_regular_msgs_removed=0;\n\n        // Prevents concurrent passing up of messages by different threads (http://jira.jboss.com/jira/browse/JGRP-198);\n        // this is all the more important once we have a threadless stack (http://jira.jboss.com/jira/browse/JGRP-181),\n        // where lots of threads can come up to this point concurrently, but only 1 is allowed to pass at a time\n        // We *can* deliver messages from *different* senders concurrently, e.g. reception of P1, Q1, P2, Q2 can result in\n        // delivery of P1, Q1, Q2, P2: FIFO (implemented by UNICAST) says messages need to be delivered only in the\n        // order in which they were sent by their senders\n        try {\n            while(true) {\n                List<Message> msgs=win.removeMany(processing);\n                if(msgs.isEmpty()) {\n                    released_processing=true;\n                    return;\n                }\n                Message highest_removed=msgs.get(msgs.size() -1);\n                sendAckForMessage(highest_removed); // guaranteed not to throw an exception !\n                for(Message m: msgs) {\n                    // discard OOB msg: it has already been delivered (http://jira.jboss.com/jira/browse/JGRP-377)\n                    if(m.isFlagSet(Message.OOB))\n                        continue;\n                    num_regular_msgs_removed++;\n                    try {\n                        up_prot.up(new Event(Event.MSG, m));\n                    }\n                    catch(Throwable t) {\n                        log.error(\"couldn't deliver message \" + m, t);\n                    }\n                }\n            }\n        }\n        finally {\n            // We keep track of regular messages that we added, but couldn't remove (because of ordering).\n            // When we have such messages pending, then even OOB threads will remove and process them\n            // http://jira.jboss.com/jira/browse/JGRP-781\n            undelivered_msgs.addAndGet(-num_regular_msgs_removed);\n\n            // double dutch: m == null always releases 'processing', however if remove() throws an exception we still\n            // release 'processing'\n            if(!released_processing)\n                processing.set(false);\n        }\n    }","commit_id":"ae592594e71f5af48a52f494bd94376a7c71115c","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Add the ACK to hashtable.sender.sent_msgs */\n    private void handleAckReceived(Address sender, long seqno) {\n        Entry           entry;\n        AckSenderWindow win;\n\n        if(log.isTraceEnabled())\n            log.trace(new StringBuilder().append(local_addr).append(\" <-- ACK(\").append(sender).\n                    append(\": #\").append(seqno).append(')'));\n        synchronized(connections) {\n            entry=connections.get(sender);\n        }\n        if(entry == null || entry.sent_msgs == null)\n            return;\n        win=entry.sent_msgs;\n        win.ack(seqno); // removes message from retransmission\n        num_acks_received++;\n    }","id":6438,"modified_method":"/** Add the ACK to hashtable.sender.sent_msgs */\n    private void handleAckReceived(Address sender, long seqno) {\n        if(log.isTraceEnabled())\n            log.trace(new StringBuilder().append(local_addr).append(\" <-- ACK(\").append(sender).\n                    append(\": #\").append(seqno).append(')'));\n        SenderEntry entry=send_table.get(sender);\n        AckSenderWindow win=entry != null? entry.sent_msgs : null;\n        if(win != null) {\n            win.ack(seqno); // removes message from retransmission\n            num_acks_received++;\n        }\n    }","commit_id":"ae592594e71f5af48a52f494bd94376a7c71115c","url":"https://github.com/belaban/JGroups"},{"original_method":"@ManagedAttribute\n    public int getNumberOfMessagesInReceiveWindows() {\n        int num=0;\n        synchronized(connections) {\n            for(Entry entry: connections.values()) {\n                if(entry.received_msgs != null)\n                    num+=entry.received_msgs.size();\n            }\n        }\n        return num;\n    }","id":6439,"modified_method":"@ManagedAttribute\n    public int getNumberOfMessagesInReceiveWindows() {\n        int num=0;\n        for(ReceiverEntry entry: recv_table.values()) {\n            if(entry.received_msgs != null)\n                num+=entry.received_msgs.size();\n        }\n        return num;\n    }","commit_id":"ae592594e71f5af48a52f494bd94376a7c71115c","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * We need to resend our first message with our conn_id\n     * @param sender\n     */\n    private void handleResendingOfFirstMessage(Address sender) {\n        Entry entry;\n        AckSenderWindow sender_win;\n        Message rsp;\n        if(log.isTraceEnabled())\n            log.trace(local_addr + \" <-- SEND_FIRST_SEQNO(\" + sender + \")\");\n\n        synchronized(connections) {\n            entry=connections.get(sender);\n            sender_win=entry != null? entry.sent_msgs : null;\n            if(sender_win == null) {\n                if(log.isErrorEnabled())\n                    log.error(local_addr + \": sender window for \" + sender + \" not found\");\n                return;\n            }\n            rsp=sender_win.getLowestMessage();\n        }\n        if(rsp == null) {\n            //if(log.isWarnEnabled())\n                // log.warn(\"didn't find any messages in my sender window for \" + sender);\n            return;\n        }\n        // We need to copy the UnicastHeader and put it back into the message because Message.copy() doesn't copy\n        // the headers and therefore we'd modify the original message in the sender retransmission window\n        // (https://jira.jboss.org/jira/browse/JGRP-965)\n        Message copy=rsp.copy();\n        UnicastHeader hdr=(UnicastHeader)copy.getHeader(name);\n        UnicastHeader newhdr=new UnicastHeader(hdr.type, hdr.seqno, entry.send_conn_id, true);\n        copy.putHeader(name, newhdr);\n        down_prot.down(new Event(Event.MSG, copy));\n    }","id":6440,"modified_method":"/**\n     * We need to resend our first message with our conn_id\n     * @param sender\n     */\n    private void handleResendingOfFirstMessage(Address sender) {\n        if(log.isTraceEnabled())\n            log.trace(local_addr + \" <-- SEND_FIRST_SEQNO(\" + sender + \")\");\n        SenderEntry entry=send_table.get(sender);\n        AckSenderWindow win=entry != null? entry.sent_msgs : null;\n        if(win == null) {\n            if(log.isErrorEnabled())\n                log.error(local_addr + \": sender window for \" + sender + \" not found\");\n            return;\n        }\n        Message rsp=win.getLowestMessage();\n        if(rsp == null)\n            return;\n\n        // We need to copy the UnicastHeader and put it back into the message because Message.copy() doesn't copy\n        // the headers and therefore we'd modify the original message in the sender retransmission window\n        // (https://jira.jboss.org/jira/browse/JGRP-965)\n        Message copy=rsp.copy();\n        UnicastHeader hdr=(UnicastHeader)copy.getHeader(name);\n        UnicastHeader newhdr=hdr.copy();\n        newhdr.first=true;\n        copy.putHeader(name, newhdr);\n        down_prot.down(new Event(Event.MSG, copy));\n    }","commit_id":"ae592594e71f5af48a52f494bd94376a7c71115c","url":"https://github.com/belaban/JGroups"},{"original_method":"/** The number of messages in all Entry.sent_msgs tables (haven't received an ACK yet) */\n    @ManagedAttribute\n    public int getNumberOfUnackedMessages() {\n        int num=0;\n        synchronized(connections) {\n            for(Entry entry: connections.values()) {\n                if(entry.sent_msgs != null)\n                    num+=entry.sent_msgs.size();\n            }\n        }\n        return num;\n    }","id":6441,"modified_method":"/** The number of messages in all Entry.sent_msgs tables (haven't received an ACK yet) */\n    @ManagedAttribute\n    public int getNumberOfUnackedMessages() {\n        int num=0;\n        for(SenderEntry entry: send_table.values()) {\n                if(entry.sent_msgs != null)\n                    num+=entry.sent_msgs.size();\n            }\n        return num;\n    }","commit_id":"ae592594e71f5af48a52f494bd94376a7c71115c","url":"https://github.com/belaban/JGroups"},{"original_method":"@ManagedOperation\n    public String printConnections() {\n        StringBuilder sb=new StringBuilder();\n        for(Map.Entry<Address,Entry> entry: connections.entrySet()) {\n            sb.append(entry.getKey()).append(\": \").append(entry.getValue()).append(\"\\n\");\n        }\n        return sb.toString();\n    }","id":6442,"modified_method":"@ManagedOperation\n    public String printConnections() {\n        StringBuilder sb=new StringBuilder();\n        for(Map.Entry<Address,ReceiverEntry> entry: recv_table.entrySet()) {\n            sb.append(entry.getKey()).append(\": \").append(entry.getValue()).append(\"\\n\");\n        }\n        return sb.toString();\n    }","commit_id":"ae592594e71f5af48a52f494bd94376a7c71115c","url":"https://github.com/belaban/JGroups"},{"original_method":"@ManagedOperation\n    public String printUnackedMessages() {\n        StringBuilder sb=new StringBuilder();\n        Entry e;\n        Object member;\n        synchronized(connections) {\n            for(Map.Entry<Address,Entry> entry: connections.entrySet()) {\n                member=entry.getKey();\n                e=entry.getValue();\n                sb.append(member).append(\": \");\n                if(e.sent_msgs != null)\n                    sb.append(e.sent_msgs.toString()).append(\"\\n\");\n            }\n        }\n        return sb.toString();\n    }","id":6443,"modified_method":"@ManagedOperation\n    public String printUnackedMessages() {\n        StringBuilder sb=new StringBuilder();\n        for(Map.Entry<Address,SenderEntry> entry: send_table.entrySet()) {\n            sb.append(entry.getKey()).append(\": \");\n            SenderEntry val=entry.getValue();\n            if(val.sent_msgs != null)\n                sb.append(val.sent_msgs).append(\"\\n\");\n        }\n        return sb.toString();\n    }","commit_id":"ae592594e71f5af48a52f494bd94376a7c71115c","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * This method is public only so it can be invoked by unit testing, but should not otherwise be used !\n     */\n    @ManagedOperation(description=\"Trashes all connections to other nodes. This is only used for testing\")\n    public void removeAllConnections() {\n        synchronized(connections) {\n            for(Entry entry: connections.values()) {\n                entry.reset();\n            }\n            connections.clear();\n        }\n    }","id":6444,"modified_method":"/**\n     * This method is public only so it can be invoked by unit testing, but should not otherwise be used !\n     */\n    @ManagedOperation(description=\"Trashes all connections to other nodes. This is only used for testing\")\n    public void removeAllConnections() {\n        for(SenderEntry entry: send_table.values())\n            entry.reset();\n        send_table.clear();\n\n        for(ReceiverEntry entry2: recv_table.values())\n            entry2.reset();\n        recv_table.clear();\n    }","commit_id":"ae592594e71f5af48a52f494bd94376a7c71115c","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object down(Event evt) {\n        switch (evt.getType()) {\n\n            case Event.MSG: // Add UnicastHeader, add to AckSenderWindow and pass down\n                Message msg=(Message)evt.getArg();\n                Address dst=msg.getDest();\n\n                /* only handle unicast messages */\n                if (dst == null || dst.isMulticastAddress()) {\n                    break;\n                }\n\n                if(!started) {\n                    if(log.isTraceEnabled())\n                        log.trace(\"discarded message as start() has not yet been called, message: \" + msg);\n                    return null;\n                }\n\n                // if the dest is self --> pass the message back up\n                if(loopback && local_addr != null && local_addr.equals(dst)) {\n                    msg.setSrc(local_addr);\n                    up_prot.up(evt);\n                    num_msgs_sent++;\n                    num_bytes_sent+=msg.getLength();\n                    return null;\n                }\n\n                Entry entry;\n                synchronized(connections) {\n                    entry=connections.get(dst);\n                    if(entry == null) {\n                        entry=new Entry();\n                        connections.put(dst, entry);\n                        if(log.isTraceEnabled())\n                            log.trace(local_addr + \": created connection to \" + dst);\n                        if(cache != null && !members.contains(dst))\n                            cache.add(dst);\n                    }\n                }\n\n                long seqno=-2;\n                long send_conn_id=0;\n                UnicastHeader hdr;\n                synchronized(entry) { // threads will only sync if they access the same entry\n                    try {\n                        seqno=entry.sent_msgs_seqno;\n                        if(seqno == DEFAULT_FIRST_SEQNO) // only happens on the first message\n                            entry.send_conn_id=send_conn_id=getNewConnectionId();\n                        if(entry.sent_msgs == null) // first msg to peer 'dst'\n                            entry.sent_msgs=new AckSenderWindow(this, new StaticInterval(timeout), timer, this.local_addr);\n                        hdr=new UnicastHeader(UnicastHeader.DATA, seqno, entry.send_conn_id, seqno == DEFAULT_FIRST_SEQNO);\n                        msg.putHeader(name, hdr);\n                        entry.sent_msgs.add(seqno, msg);  // add *including* UnicastHeader, adds to retransmitter\n                        entry.sent_msgs_seqno++;\n                    }\n                    catch(Throwable t) {\n                        entry.sent_msgs.ack(seqno); // remove seqno again, so it is not transmitted\n                        throw new RuntimeException(\"failure adding msg \" + msg + \" to the retransmit table\", t);\n                    }\n                }\n\n                if(log.isTraceEnabled()) {\n                    StringBuilder sb=new StringBuilder();\n                    sb.append(local_addr).append(\" --> DATA(\").append(dst).append(\": #\").append(seqno).\n                            append(\", conn_id=\").append(send_conn_id);\n                    if(hdr.first) sb.append(\", first\");\n                    sb.append(')');\n                    log.trace(sb);\n                }\n\n                // moved passing down of message out of the synchronized block: similar to NAKACK, we do *not* need\n                // to send unicast messages in order of sequence numbers because they will be sorted into the correct\n                // order at the receiver anyway. Of course, most of the time, the order will be correct (FIFO), so\n                // the cost of reordering is minimal. This is part of http://jira.jboss.com/jira/browse/JGRP-303\n                try { // we catch the exception in this case because the msg is in the XMIT table and will be retransmitted\n                    send(msg, evt);\n                }\n                catch(Throwable t) {\n                    log.warn(\"failed sending the message\", t);\n                }\n                return null; // we already passed the msg down\n\n            case Event.VIEW_CHANGE:  // remove connections to peers that are not members anymore !\n                View view=(View)evt.getArg();\n                Vector<Address> new_members=view.getMembers();\n                Set<Address> non_members=new HashSet<Address>(connections.keySet());\n                synchronized(members) {\n                    members.clear();\n                    if(new_members != null)\n                        members.addAll(new_members);\n                    non_members.removeAll(members);\n                    if(cache != null) {\n                        cache.removeAll(members);\n                    }\n                }\n\n                if(!non_members.isEmpty()) {\n                    if(log.isTraceEnabled())\n                        log.trace(\"removing non members \" + non_members);\n                    for(Address non_mbr: non_members)\n                        removeConnection(non_mbr);\n                }\n                break;\n\n            case Event.SET_LOCAL_ADDRESS:\n                local_addr=(Address)evt.getArg();\n                break;\n\n            case Event.CONNECT:\n                disconnected=false;\n                break;\n\n            case Event.DISCONNECT:\n                disconnected=true;\n                break;\n        }\n\n        return down_prot.down(evt);          // Pass on to the layer below us\n    }","id":6445,"modified_method":"public Object down(Event evt) {\n        switch (evt.getType()) {\n\n            case Event.MSG: // Add UnicastHeader, add to AckSenderWindow and pass down\n                Message msg=(Message)evt.getArg();\n                Address dst=msg.getDest();\n\n                /* only handle unicast messages */\n                if (dst == null || dst.isMulticastAddress()) {\n                    break;\n                }\n\n                if(!started) {\n                    if(log.isTraceEnabled())\n                        log.trace(\"discarded message as start() has not yet been called, message: \" + msg);\n                    return null;\n                }\n\n                // if the dest is self --> pass the message back up\n                if(loopback && local_addr != null && local_addr.equals(dst)) {\n                    msg.setSrc(local_addr);\n                    up_prot.up(evt);\n                    num_msgs_sent++;\n                    num_bytes_sent+=msg.getLength();\n                    return null;\n                }\n\n                SenderEntry entry=send_table.get(dst);\n                    if(entry == null) {\n                    entry=new SenderEntry(getNewConnectionId(), this, timeout, timer, local_addr);\n                    SenderEntry existing=send_table.putIfAbsent(dst, entry);\n                    if(existing != null)\n                        entry=existing;\n                    else {\n                        if(log.isTraceEnabled())\n                            log.trace(local_addr + \": created connection to \" + dst);\n                        if(cache != null && !members.contains(dst))\n                            cache.add(dst);\n                    }\n                }\n\n                long seqno=-2, send_conn_id=-1;\n                UnicastHeader hdr;\n\n                entry.lock(); // threads will only sync if they access the same entry\n                try {\n                    seqno=entry.sent_msgs_seqno;\n                    send_conn_id=entry.send_conn_id;\n                    hdr=new UnicastHeader(UnicastHeader.DATA, seqno, send_conn_id, seqno == DEFAULT_FIRST_SEQNO);\n                    msg.putHeader(getName(), hdr);\n\n                    // AckSenderWindow.add() is costly as it calls Retransmitter.add() which calls TimeScheduler.schedule(),\n                    // which adds the scheduled task to a DelayQueue, which does costly tree rebalancing.\n                    // In 2.9 (or 3.0), we'll replace use of ScheduledThreadPoolExecutor in TimeScheduler with\n                    // a ConcurrentSkipListMap, which is faster (log(n) access cost for most ops). CSLM requires JDK 1.6\n                    // Note that moving the next statement out of the lock scope made for some really ugly code, that's\n                    // why this was reverted !\n                    entry.sent_msgs.add(seqno, msg);  // add *including* UnicastHeader, adds to retransmitter\n                    entry.sent_msgs_seqno++;\n                }\n                finally {\n                    entry.unlock();\n                }\n\n                if(log.isTraceEnabled()) {\n                    StringBuilder sb=new StringBuilder();\n                    sb.append(local_addr).append(\" --> DATA(\").append(dst).append(\": #\").append(seqno).\n                            append(\", conn_id=\").append(send_conn_id);\n                    if(hdr.first) sb.append(\", first\");\n                    sb.append(')');\n                    log.trace(sb);\n                }\n\n                // moved passing down of message out of the synchronized block: similar to NAKACK, we do *not* need\n                // to send unicast messages in order of sequence numbers because they will be sorted into the correct\n                // order at the receiver anyway. Of course, most of the time, the order will be correct (FIFO), so\n                // the cost of reordering is minimal. This is part of http://jira.jboss.com/jira/browse/JGRP-303\n                try { // we catch the exception in this case because the msg is in the XMIT table and will be retransmitted\n                    send(msg, evt);\n                }\n                catch(Throwable t) {\n                    log.warn(\"failed sending the message\", t);\n                }\n                return null; // we already passed the msg down\n\n            case Event.VIEW_CHANGE:  // remove connections to peers that are not members anymore !\n                View view=(View)evt.getArg();\n                Vector<Address> new_members=view.getMembers();\n                Set<Address> non_members=new HashSet<Address>(send_table.keySet());\n                non_members.addAll(recv_table.keySet());\n\n                synchronized(members) {\n                    members.clear();\n                    if(new_members != null)\n                        members.addAll(new_members);\n                    non_members.removeAll(members);\n                    if(cache != null) {\n                        cache.removeAll(members);\n                    }\n                }\n\n                if(!non_members.isEmpty()) {\n                    if(log.isTraceEnabled())\n                        log.trace(\"removing non members \" + non_members);\n                    for(Address non_mbr: non_members)\n                        removeConnection(non_mbr);\n                }\n                break;\n\n            case Event.SET_LOCAL_ADDRESS:\n                local_addr=(Address)evt.getArg();\n                break;\n\n            case Event.CONNECT:\n                disconnected=false;\n                break;\n\n            case Event.DISCONNECT:\n                disconnected=true;\n                break;\n        }\n\n        return down_prot.down(evt);          // Pass on to the layer below us\n    }","commit_id":"ae592594e71f5af48a52f494bd94376a7c71115c","url":"https://github.com/belaban/JGroups"},{"original_method":"private AckReceiverWindow createReceiverWindow(Address sender, Entry entry, long seqno, long conn_id) {\n        if(entry == null) {\n            entry=new Entry();\n            connections.put(sender, entry);\n        }\n        if(entry.received_msgs != null)\n            entry.received_msgs.reset();\n        entry.received_msgs=new AckReceiverWindow(seqno);\n        entry.recv_conn_id=conn_id;\n        if(log.isTraceEnabled())\n            log.trace(local_addr + \": created receiver window for \" + sender + \" at seqno=#\" + seqno + \" for conn-id=\" + conn_id);\n        return entry.received_msgs;\n    }","id":6446,"modified_method":"private AckReceiverWindow createReceiverWindow(Address sender, ReceiverEntry entry, long seqno, long conn_id) {\n        if(entry == null) {\n            entry=new ReceiverEntry();\n            recv_table.put(sender, entry);\n        }\n        if(entry.received_msgs != null)\n            entry.received_msgs.reset();\n        entry.received_msgs=new AckReceiverWindow(seqno);\n        entry.recv_conn_id=conn_id;\n        if(log.isTraceEnabled())\n            log.trace(local_addr + \": created receiver window for \" + sender + \" at seqno=#\" + seqno + \" for conn-id=\" + conn_id);\n        return entry.received_msgs;\n    }","commit_id":"ae592594e71f5af48a52f494bd94376a7c71115c","url":"https://github.com/belaban/JGroups"},{"original_method":"private void sendAck(Address dst, long seqno) {\n        // if we are disconnected, then don't send any acks which stops exceptions on shutdown\n        if (disconnected) \n            return; \n        Message ack=new Message(dst);\n        // commented Jan 23 2008 (bela): TP.enable_unicast_bundling should decide whether we bundle or not, and *not*\n        // the OOB flag ! Bundling UNICAST ACKs should be really fast\n        ack.setFlag(Message.OOB);\n        ack.putHeader(name, new UnicastHeader(UnicastHeader.ACK, seqno));\n        if(log.isTraceEnabled())\n            log.trace(new StringBuilder().append(local_addr).append(\" --> ACK(\").append(dst).\n                      append(\": #\").append(seqno).append(')'));\n        down_prot.down(new Event(Event.MSG, ack));\n        num_acks_sent++;\n    }","id":6447,"modified_method":"private void sendAck(Address dst, long seqno) {\n        if(disconnected) // if we are disconnected, then don't send any acks which throw exceptions on shutdown\n            return;\n        Message ack=new Message(dst);\n        // commented Jan 23 2008 (bela): TP.enable_unicast_bundling should decide whether we bundle or not, and *not*\n        // the OOB flag ! Bundling UNICAST ACKs should be really fast\n        ack.setFlag(Message.OOB);\n        ack.putHeader(name, new UnicastHeader(UnicastHeader.ACK, seqno));\n        if(log.isTraceEnabled())\n            log.trace(new StringBuilder().append(local_addr).append(\" --> ACK(\").append(dst).\n                    append(\": #\").append(seqno).append(')'));\n        try {\n            down_prot.down(new Event(Event.MSG, ack));\n            num_acks_sent++;\n        }\n        catch(Throwable t) {\n            log.error(\"failed sending ACK(\" + seqno + \") to \" + dst, t);\n        }\n    }","commit_id":"ae592594e71f5af48a52f494bd94376a7c71115c","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Adds the message to the sent_msgs table and then passes it down the stack. Change Bela Ban May 26 2002: we don't\n     * store a copy of the message, but a reference ! This saves us a lot of memory. However, this also means that a\n     * message should not be changed after storing it in the sent-table ! See protocols/DESIGN for details.\n     * Made seqno increment and adding to sent_msgs atomic, e.g. seqno won't get incremented if adding to\n     * sent_msgs fails e.g. due to an OOM (see http://jira.jboss.com/jira/browse/JGRP-179). bela Jan 13 2006\n     */\n    private void send(Event evt, Message msg) {\n        if(msg == null)\n            throw new NullPointerException(\"msg is null; event is \" + evt);\n\n        if(!started) {\n            if(log.isTraceEnabled())\n                log.trace(\"[\" + local_addr + \"] discarded message as start() has not been called, message: \" + msg);\n            return;\n        }\n\n        long msg_id;\n        NakReceiverWindow win=xmit_table.get(local_addr);\n        if(win == null) {  // discard message if there is no entry for local_addr\n            if(log.isWarnEnabled() && log_discard_msgs)\n                log.warn(local_addr + \": discarded message from \" + local_addr + \" with no window, my view is \" + view);\n            return;\n        }\n        msg.setSrc(local_addr); // this needs to be done so we can check whether the message sender is the local_addr\n\n        seqno_lock.lock();\n        try {\n            try { // incrementing seqno and adding the msg to sent_msgs needs to be atomic\n                msg_id=seqno +1;\n                msg.putHeader(name, new NakAckHeader(NakAckHeader.MSG, msg_id));\n                if(win.add(msg_id, msg) && !msg.isFlagSet(Message.OOB))\n                    undelivered_msgs.incrementAndGet();\n                seqno=msg_id;\n            }\n            catch(Throwable t) {\n                throw new RuntimeException(\"failure adding msg \" + msg + \" to the retransmit table for \" + local_addr, t);\n            }\n        }\n        finally {\n            seqno_lock.unlock();\n        }\n\n        try { // moved down_prot.down() out of synchronized clause (bela Sept 7 2006) http://jira.jboss.com/jira/browse/JGRP-300\n            if(msg.isFlagSet(Message.OOB))\n                oob_loopback_msgs.add(msg_id);\n            if(log.isTraceEnabled())\n                log.trace(\"sending \" + local_addr + \"#\" + msg_id);\n            down_prot.down(evt); // if this fails, since msg is in sent_msgs, it can be retransmitted\n        }\n        catch(Throwable t) { // eat the exception, don't pass it up the stack\n            if(log.isWarnEnabled()) {\n                log.warn(\"failure passing message down\", t);\n            }\n        }\n    }","id":6448,"modified_method":"/**\n     * Adds the message to the sent_msgs table and then passes it down the stack. Change Bela Ban May 26 2002: we don't\n     * store a copy of the message, but a reference ! This saves us a lot of memory. However, this also means that a\n     * message should not be changed after storing it in the sent-table ! See protocols/DESIGN for details.\n     * Made seqno increment and adding to sent_msgs atomic, e.g. seqno won't get incremented if adding to\n     * sent_msgs fails e.g. due to an OOM (see http://jira.jboss.com/jira/browse/JGRP-179). bela Jan 13 2006\n     */\n    private void send(Event evt, Message msg) {\n        if(msg == null)\n            throw new NullPointerException(\"msg is null; event is \" + evt);\n\n        if(!started) {\n            if(log.isTraceEnabled())\n                log.trace(\"[\" + local_addr + \"] discarded message as start() has not been called, message: \" + msg);\n            return;\n        }\n\n        long msg_id;\n        NakReceiverWindow win=xmit_table.get(local_addr);\n        if(win == null) {  // discard message if there is no entry for local_addr\n            if(log.isWarnEnabled() && log_discard_msgs)\n                log.warn(local_addr + \": discarded message from \" + local_addr + \" with no window, my view is \" + view);\n            return;\n        }\n        msg.setSrc(local_addr); // this needs to be done so we can check whether the message sender is the local_addr\n\n        seqno_lock.lock();\n        try {\n            try { // incrementing seqno and adding the msg to sent_msgs needs to be atomic\n                msg_id=seqno +1;\n                msg.putHeader(name, new NakAckHeader(NakAckHeader.MSG, msg_id));\n                if(win.add(msg_id, msg) && !msg.isFlagSet(Message.OOB))\n                    undelivered_msgs.incrementAndGet();\n                seqno=msg_id;\n            }\n            catch(Throwable t) {\n                throw new RuntimeException(\"failure adding msg \" + msg + \" to the retransmit table for \" + local_addr, t);\n            }\n        }\n        finally {\n            seqno_lock.unlock();\n        }\n\n        try { // moved down_prot.down() out of synchronized clause (bela Sept 7 2006) http://jira.jboss.com/jira/browse/JGRP-300\n            if(log.isTraceEnabled())\n                log.trace(\"sending \" + local_addr + \"#\" + msg_id);\n            down_prot.down(evt); // if this fails, since msg is in sent_msgs, it can be retransmitted\n        }\n        catch(Throwable t) { // eat the exception, don't pass it up the stack\n            if(log.isWarnEnabled()) {\n                log.warn(\"failure passing message down\", t);\n            }\n        }\n    }","commit_id":"12189cde41fde0c3b21668563f4c05448f7f94b6","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Sends a message msg to the requester. We have to wrap the original message into a retransmit message, as we need\n     * to preserve the original message's properties, such as src, headers etc.\n     * @param dest\n     * @param msg\n     * @param seqno\n     */\n    private void sendXmitRsp(Address dest, Message msg, long seqno) {\n        Buffer buf;\n        if(msg == null) {\n            if(log.isErrorEnabled())\n                log.error(\"message is null, cannot send retransmission\");\n            return;\n        }\n\n        if(stats) {\n            xmit_rsps_sent++;\n            updateStats(sent, dest, 0, 1, 0);\n        }\n\n        if(use_mcast_xmit)\n            dest=null;\n\n        if(msg.getSrc() == null)\n            msg.setSrc(local_addr);\n        try {\n            buf=Util.messageToByteBuffer(msg);\n            Message xmit_msg=new Message(dest, null, buf.getBuf(), buf.getOffset(), buf.getLength());\n            // changed Bela Jan 4 2007: we should not use OOB for retransmitted messages, otherwise we tax the\n            // OOB thread pool too much\n            // msg.setFlag(Message.OOB);\n            xmit_msg.putHeader(name, new NakAckHeader(NakAckHeader.XMIT_RSP, seqno));\n            down_prot.down(new Event(Event.MSG, xmit_msg));\n        }\n        catch(IOException ex) {\n            log.error(\"failed marshalling xmit list\", ex);\n        }\n    }","id":6449,"modified_method":"/**\n     * Sends a message msg to the requester. We have to wrap the original message into a retransmit message, as we need\n     * to preserve the original message's properties, such as src, headers etc.\n     * @param dest\n     * @param msg\n     * @param seqno\n     */\n    private void sendXmitRsp(Address dest, Message msg, long seqno) {\n        Buffer buf;\n        if(msg == null) {\n            if(log.isErrorEnabled())\n                log.error(\"message is null, cannot send retransmission\");\n            return;\n        }\n\n        if(stats) {\n            xmit_rsps_sent++;\n            updateStats(sent, dest, 0, 1, 0);\n        }\n\n        if(use_mcast_xmit)\n            dest=null;\n\n        if(msg.getSrc() == null)\n            msg.setSrc(local_addr);\n        try {\n            buf=Util.messageToByteBuffer(msg);\n            Message xmit_msg=new Message(dest, null, buf.getBuf(), buf.getOffset(), buf.getLength());\n            // changed Bela Jan 4 2007: we should not use OOB for retransmitted messages, otherwise we tax the\n            // OOB thread pool too much\n            // xmit_msg.setFlag(Message.OOB);\n\n            if(msg.isFlagSet(Message.OOB)) // set OOB for the wrapping message if the wrapped message is OOB, too\n                xmit_msg.setFlag(Message.OOB);\n\n            xmit_msg.putHeader(name, new NakAckHeader(NakAckHeader.XMIT_RSP, seqno));\n            down_prot.down(new Event(Event.MSG, xmit_msg));\n        }\n        catch(IOException ex) {\n            log.error(\"failed marshalling xmit list\", ex);\n        }\n    }","commit_id":"12189cde41fde0c3b21668563f4c05448f7f94b6","url":"https://github.com/belaban/JGroups"},{"original_method":"public void stop() {\n        started=false;\n        reset();  // clears sent_msgs and destroys all NakReceiverWindows\n        oob_loopback_msgs.clear();\n    }","id":6450,"modified_method":"public void stop() {\n        started=false;\n        reset();  // clears sent_msgs and destroys all NakReceiverWindows\n    }","commit_id":"12189cde41fde0c3b21668563f4c05448f7f94b6","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Finds the corresponding NakReceiverWindow and adds the message to it (according to seqno). Then removes as many\n     * messages as possible from the NRW and passes them up the stack. Discards messages from non-members.\n     */\n    private void  handleMessage(Message msg, NakAckHeader hdr) {\n        Address sender=msg.getSrc();\n        if(sender == null) {\n            if(log.isErrorEnabled())\n                log.error(\"sender of message is null\");\n            return;\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(new StringBuilder().append('[').append(local_addr).append(\": received \").append(sender).append('#').append(hdr.seqno));\n\n        NakReceiverWindow win=xmit_table.get(sender);\n        if(win == null) {  // discard message if there is no entry for sender\n            if(leaving)\n                return;\n            if(log.isWarnEnabled() && log_discard_msgs)\n                log.warn(local_addr + \": discarded message from non-member \" + sender + \", my view is \" + view);\n            return;\n        }\n\n        boolean loopback=local_addr.equals(sender);\n        boolean added_to_window=false;\n        boolean added=loopback || (added_to_window=win.add(hdr.seqno, msg));\n\n        if(added_to_window)\n            undelivered_msgs.incrementAndGet();\n\n        // message is passed up if OOB. Later, when remove() is called, we discard it. This affects ordering !\n        // http://jira.jboss.com/jira/browse/JGRP-379\n        if(added && msg.isFlagSet(Message.OOB)) {\n            if(!loopback || oob_loopback_msgs.remove(hdr.seqno)) {\n                up_prot.up(new Event(Event.MSG, msg));\n                win.removeOOBMessage();\n                if(!(win.hasMessagesToRemove() && undelivered_msgs.get() > 0))\n                    return;\n            }\n        }\n\n        // Efficient way of checking whether another thread is already processing messages from 'sender'.\n        // If that's the case, we return immediately and let the existing thread process our message\n        // (https://jira.jboss.org/jira/browse/JGRP-829). Benefit: fewer threads blocked on the same lock, these threads\n        // can be returned to the thread pool\n        final AtomicBoolean processing=win.getProcessing();\n        if(!processing.compareAndSet(false, true)) {\n            return;\n        }\n\n        // Prevents concurrent passing up of messages by different threads (http://jira.jboss.com/jira/browse/JGRP-198);\n        // this is all the more important once we have a threadless stack (http://jira.jboss.com/jira/browse/JGRP-181),\n        // where lots of threads can come up to this point concurrently, but only 1 is allowed to pass at a time\n        // We *can* deliver messages from *different* senders concurrently, e.g. reception of P1, Q1, P2, Q2 can result in\n        // delivery of P1, Q1, Q2, P2: FIFO (implemented by NAKACK) says messages need to be delivered in the\n        // order in which they were sent by the sender\n        int num_regular_msgs_removed=0;\n\n        // 2nd line of defense: in case of an exception, remove() might not be called, therefore processing would never\n        // be set back to false. If we get an exception and released_processing is not true, then we set\n        // processing to false in the finally clause\n        boolean released_processing=false;\n        try {\n            while(true) {\n                // we're removing a msg and set processing to false (if null) *atomically* (wrt to add())\n                List<Message> msgs=win.removeMany(processing);\n                if(msgs == null || msgs.isEmpty()) {\n                    released_processing=true;\n                    return;\n                }\n\n                for(Message msg_to_deliver: msgs) {\n\n                    // discard OOB msg as it has already been delivered (http://jira.jboss.com/jira/browse/JGRP-379)\n                    if(msg_to_deliver.isFlagSet(Message.OOB)) {\n                        continue;\n                    }\n                    num_regular_msgs_removed++;\n\n                    // Changed by bela Jan 29 2003: not needed (see above)\n                    //msg_to_deliver.removeHeader(getName());\n                    try {\n                        up_prot.up(new Event(Event.MSG, msg_to_deliver));\n                    }\n                    catch(Throwable t) {\n                        log.error(\"couldn't deliver message \" + msg, t);\n                    }\n                }\n            }\n        }\n        finally {\n            // We keep track of regular messages that we added, but couldn't remove (because of ordering).\n            // When we have such messages pending, then even OOB threads will remove and process them\n            // http://jira.jboss.com/jira/browse/JGRP-781\n            undelivered_msgs.addAndGet(-num_regular_msgs_removed);\n\n            // processing is always set in win.remove(processing) above and never here ! This code is just a\n            // 2nd line of defense should there be an exception before win.remove(processing) sets processing\n            if(!released_processing)\n                processing.set(false);\n        }\n    }","id":6451,"modified_method":"/**\n     * Finds the corresponding NakReceiverWindow and adds the message to it (according to seqno). Then removes as many\n     * messages as possible from the NRW and passes them up the stack. Discards messages from non-members.\n     */\n    private void  handleMessage(Message msg, NakAckHeader hdr) {\n        Address sender=msg.getSrc();\n        if(sender == null) {\n            if(log.isErrorEnabled())\n                log.error(\"sender of message is null\");\n            return;\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(new StringBuilder().append('[').append(local_addr).append(\": received \").append(sender).append('#').append(hdr.seqno));\n\n        NakReceiverWindow win=xmit_table.get(sender);\n        if(win == null) {  // discard message if there is no entry for sender\n            if(leaving)\n                return;\n            if(log.isWarnEnabled() && log_discard_msgs)\n                log.warn(local_addr + \": discarded message from non-member \" + sender + \", my view is \" + view);\n            return;\n        }\n\n        boolean loopback=local_addr.equals(sender);\n        boolean added_to_window=false;\n        boolean added=loopback || (added_to_window=win.add(hdr.seqno, msg));\n\n        if(added_to_window && !msg.isFlagSet(Message.OOB))\n            undelivered_msgs.incrementAndGet();\n\n        // message is passed up if OOB. Later, when remove() is called, we discard it. This affects ordering !\n        // http://jira.jboss.com/jira/browse/JGRP-379\n        if(added && msg.isFlagSet(Message.OOB)) {\n            msg=win.get(hdr.seqno);\n            if(msg != null) {\n                boolean pass_up=msg.setTransientFlagIfAbsent(Message.OOB_DELIVERED);\n                if(pass_up)\n                    up_prot.up(new Event(Event.MSG, msg));\n            }\n\n            while(true) {\n                final Message oob_msg=win.removeOOBMessage();\n                if(oob_msg == null)\n                    break;\n                boolean pass_up=oob_msg.setTransientFlagIfAbsent(Message.OOB_DELIVERED);\n                if(pass_up) {\n                    timer.execute(new Runnable() {\n                        public void run() {\n                            up_prot.up(new Event(Event.MSG, oob_msg));\n                        }\n                    });\n                }\n            }\n\n            if(!(win.hasMessagesToRemove() && undelivered_msgs.get() > 0))\n                return;\n        }\n\n        // Efficient way of checking whether another thread is already processing messages from 'sender'.\n        // If that's the case, we return immediately and let the existing thread process our message\n        // (https://jira.jboss.org/jira/browse/JGRP-829). Benefit: fewer threads blocked on the same lock, these threads\n        // can be returned to the thread pool\n        final AtomicBoolean processing=win.getProcessing();\n        if(!processing.compareAndSet(false, true)) {\n            return;\n        }\n\n        // Prevents concurrent passing up of messages by different threads (http://jira.jboss.com/jira/browse/JGRP-198);\n        // this is all the more important once we have a threadless stack (http://jira.jboss.com/jira/browse/JGRP-181),\n        // where lots of threads can come up to this point concurrently, but only 1 is allowed to pass at a time\n        // We *can* deliver messages from *different* senders concurrently, e.g. reception of P1, Q1, P2, Q2 can result in\n        // delivery of P1, Q1, Q2, P2: FIFO (implemented by NAKACK) says messages need to be delivered in the\n        // order in which they were sent by the sender\n        int num_regular_msgs_removed=0;\n\n        // 2nd line of defense: in case of an exception, remove() might not be called, therefore processing would never\n        // be set back to false. If we get an exception and released_processing is not true, then we set\n        // processing to false in the finally clause\n        boolean released_processing=false;\n        try {\n            while(true) {\n                // we're removing a msg and set processing to false (if null) *atomically* (wrt to add())\n                List<Message> msgs=win.removeMany(processing);\n                if(msgs == null || msgs.isEmpty()) {\n                    released_processing=true;\n                    return;\n                }\n\n                for(Message msg_to_deliver: msgs) {\n\n                    // discard OOB msg as it has already been delivered (http://jira.jboss.com/jira/browse/JGRP-379)\n                    if(msg_to_deliver.isFlagSet(Message.OOB)) {\n                        continue;\n                    }\n                    num_regular_msgs_removed++;\n\n                    // Changed by bela Jan 29 2003: not needed (see above)\n                    //msg_to_deliver.removeHeader(getName());\n                    try {\n                        up_prot.up(new Event(Event.MSG, msg_to_deliver));\n                    }\n                    catch(Throwable t) {\n                        log.error(\"couldn't deliver message \" + msg_to_deliver, t);\n                    }\n                }\n            }\n        }\n        finally {\n            // We keep track of regular messages that we added, but couldn't remove (because of ordering).\n            // When we have such messages pending, then even OOB threads will remove and process them\n            // http://jira.jboss.com/jira/browse/JGRP-781\n            undelivered_msgs.addAndGet(-num_regular_msgs_removed);\n\n            // processing is always set in win.remove(processing) above and never here ! This code is just a\n            // 2nd line of defense should there be an exception before win.remove(processing) sets processing\n            if(!released_processing)\n                processing.set(false);\n        }\n    }","commit_id":"12189cde41fde0c3b21668563f4c05448f7f94b6","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * This method is public only so it can be invoked by unit testing, but should not otherwise be used !\n     */\n    @ManagedOperation(description=\"Trashes all connections to other nodes. This is only used for testing\")\n    public void removeAllConnections() {\n        synchronized(connections) {\n            for(Entry entry: connections.values()) {\n                entry.reset();\n            }\n            connections.clear();\n        }\n    }","id":6452,"modified_method":"/**\n     * This method is public only so it can be invoked by unit testing, but should not otherwise be used !\n     */\n    @ManagedOperation(description=\"Trashes all connections to other nodes. This is only used for testing\")\n    public void removeAllConnections() {\n        for(SenderEntry entry: send_table.values())\n            entry.reset();\n        send_table.clear();\n\n        for(ReceiverEntry entry2: recv_table.values())\n            entry2.reset();\n        recv_table.clear();\n    }","commit_id":"823e9cf358df7d6131b8db4ddd6cb9ade4e7baf5","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Add the ACK to hashtable.sender.sent_msgs */\n    private void handleAckReceived(Address sender, long seqno) {\n        Entry           entry;\n        AckSenderWindow win;\n\n        if(log.isTraceEnabled())\n            log.trace(new StringBuilder().append(local_addr).append(\" <-- ACK(\").append(sender).\n                    append(\": #\").append(seqno).append(')'));\n        synchronized(connections) {\n            entry=connections.get(sender);\n        }\n        if(entry == null || entry.sent_msgs == null)\n            return;\n        win=entry.sent_msgs;\n        win.ack(seqno); // removes message from retransmission\n        num_acks_received++;\n    }","id":6453,"modified_method":"/** Add the ACK to hashtable.sender.sent_msgs */\n    private void handleAckReceived(Address sender, long seqno) {\n        if(log.isTraceEnabled())\n            log.trace(new StringBuilder().append(local_addr).append(\" <-- ACK(\").append(sender).\n                    append(\": #\").append(seqno).append(')'));\n        SenderEntry entry=send_table.get(sender);\n        AckSenderWindow win=entry != null? entry.sent_msgs : null;\n        if(win != null) {\n            win.ack(seqno); // removes message from retransmission\n            num_acks_received++;\n        }\n    }","commit_id":"823e9cf358df7d6131b8db4ddd6cb9ade4e7baf5","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Removes and resets from connection table (which is already locked). Returns true if member was found,\n     * otherwise false. This method is public only so it can be invoked by unit testing, but should not otherwise be\n     * used ! \n     */\n    public boolean removeConnection(Address mbr) {\n        Entry entry;\n\n        synchronized(connections) {\n            entry=connections.remove(mbr);\n        }\n        if(entry != null) {\n            entry.reset();\n            return true;\n        }\n        else\n            return false;\n    }","id":6454,"modified_method":"/**\n     * Removes and resets from connection table (which is already locked). Returns true if member was found,\n     * otherwise false. This method is public only so it can be invoked by unit testing, but should not otherwise be\n     * used ! \n     */\n    public void removeConnection(Address mbr) {\n        SenderEntry entry=send_table.remove(mbr);\n        if(entry != null)\n            entry.reset();\n\n        ReceiverEntry entry2=recv_table.remove(mbr);\n        if(entry2 != null)\n            entry2.reset();\n        }","commit_id":"823e9cf358df7d6131b8db4ddd6cb9ade4e7baf5","url":"https://github.com/belaban/JGroups"},{"original_method":"/** The number of messages in all Entry.sent_msgs tables (haven't received an ACK yet) */\n    @ManagedAttribute\n    public int getNumberOfUnackedMessages() {\n        int num=0;\n        synchronized(connections) {\n            for(Entry entry: connections.values()) {\n                if(entry.sent_msgs != null)\n                    num+=entry.sent_msgs.size();\n            }\n        }\n        return num;\n    }","id":6455,"modified_method":"/** The number of messages in all Entry.sent_msgs tables (haven't received an ACK yet) */\n    @ManagedAttribute\n    public int getNumberOfUnackedMessages() {\n        int num=0;\n        for(SenderEntry entry: send_table.values()) {\n                if(entry.sent_msgs != null)\n                    num+=entry.sent_msgs.size();\n            }\n        return num;\n    }","commit_id":"823e9cf358df7d6131b8db4ddd6cb9ade4e7baf5","url":"https://github.com/belaban/JGroups"},{"original_method":"private AckReceiverWindow createReceiverWindow(Address sender, Entry entry, long seqno, long conn_id) {\n        if(entry == null) {\n            entry=new Entry();\n            connections.put(sender, entry);\n        }\n        if(entry.received_msgs != null)\n            entry.received_msgs.reset();\n        entry.received_msgs=new AckReceiverWindow(seqno);\n        entry.recv_conn_id=conn_id;\n        if(log.isTraceEnabled())\n            log.trace(local_addr + \": created receiver window for \" + sender + \" at seqno=#\" + seqno + \" for conn-id=\" + conn_id);\n        return entry.received_msgs;\n    }","id":6456,"modified_method":"private AckReceiverWindow createReceiverWindow(Address sender, ReceiverEntry entry, long seqno, long conn_id) {\n        if(entry == null) {\n            entry=new ReceiverEntry();\n            recv_table.put(sender, entry);\n        }\n        if(entry.received_msgs != null)\n            entry.received_msgs.reset();\n        entry.received_msgs=new AckReceiverWindow(seqno);\n        entry.recv_conn_id=conn_id;\n        if(log.isTraceEnabled())\n            log.trace(local_addr + \": created receiver window for \" + sender + \" at seqno=#\" + seqno + \" for conn-id=\" + conn_id);\n        return entry.received_msgs;\n    }","commit_id":"823e9cf358df7d6131b8db4ddd6cb9ade4e7baf5","url":"https://github.com/belaban/JGroups"},{"original_method":"@ManagedOperation\n    public String printConnections() {\n        StringBuilder sb=new StringBuilder();\n        for(Map.Entry<Address,Entry> entry: connections.entrySet()) {\n            sb.append(entry.getKey()).append(\": \").append(entry.getValue()).append(\"\\n\");\n        }\n        return sb.toString();\n    }","id":6457,"modified_method":"@ManagedOperation\n    public String printConnections() {\n        StringBuilder sb=new StringBuilder();\n        for(Map.Entry<Address,ReceiverEntry> entry: recv_table.entrySet()) {\n            sb.append(entry.getKey()).append(\": \").append(entry.getValue()).append(\"\\n\");\n        }\n        return sb.toString();\n    }","commit_id":"823e9cf358df7d6131b8db4ddd6cb9ade4e7baf5","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Check whether the hashtable contains an entry e for <code>sender<\/code> (create if not). If\n     * e.received_msgs is null and <code>first<\/code> is true: create a new AckReceiverWindow(seqno) and\n     * add message. Set e.received_msgs to the new window. Else just add the message.\n     */\n    private void handleDataReceived(Address sender, long seqno, long conn_id,  boolean first, Message msg) {\n        if(log.isTraceEnabled()) {\n            StringBuilder sb=new StringBuilder();\n            sb.append(local_addr).append(\" <-- DATA(\").append(sender).append(\": #\").append(seqno);\n            if(conn_id != 0) sb.append(\", conn_id=\").append(conn_id);\n            if(first) sb.append(\", first\");\n            sb.append(')');\n            log.trace(sb);\n        }\n\n        AckReceiverWindow win;\n        synchronized(connections) {\n            Entry entry=connections.get(sender);\n            win=entry != null? entry.received_msgs : null;\n\n            if(first) {\n                if(entry == null || win == null) {\n                    win=createReceiverWindow(sender, entry, seqno, conn_id);\n                }\n                else {  // entry != null && win != null\n                    if(conn_id != entry.recv_conn_id) {\n                        if(log.isTraceEnabled())\n                            log.trace(local_addr + \": conn_id=\" + conn_id + \" != \" + entry.recv_conn_id + \"; resetting receiver window\");\n                        win=createReceiverWindow(sender, entry, seqno, conn_id);\n                    }\n                    else {\n                        ;\n                    }\n                }\n            }\n            else { // entry == null && win == null OR entry != null && win == null OR entry != null && win != null\n                if(win == null || entry.recv_conn_id != conn_id) {\n                    sendRequestForFirstSeqno(sender);\n                    return; // drop message\n                }\n            }\n        }\n\n        boolean added=win.add(seqno, msg); // entry.received_msgs is guaranteed to be non-null if we get here\n        num_msgs_received++;\n        num_bytes_received+=msg.getLength();\n\n        if(added && !msg.isFlagSet(Message.OOB))\n            undelivered_msgs.incrementAndGet();\n\n        if(win.smallerThanNextToRemove(seqno))\n            sendAck(msg.getSrc(), seqno);\n\n        // message is passed up if OOB. Later, when remove() is called, we discard it. This affects ordering !\n        // http://jira.jboss.com/jira/browse/JGRP-377\n        if(msg.isFlagSet(Message.OOB)) {\n            if(added)\n                up_prot.up(new Event(Event.MSG, msg));\n            Message oob_msg=win.removeOOBMessage();\n            if(oob_msg != null)\n                sendAckForMessage(oob_msg);\n            \n            if(!(win.hasMessagesToRemove() && undelivered_msgs.get() > 0))\n                return;\n        }\n\n        if(!added && !win.hasMessagesToRemove()) { // no ack if we didn't add the msg (e.g. duplicate)\n            return;\n        }\n\n        final AtomicBoolean processing=win.getProcessing();\n        if(!processing.compareAndSet(false, true)) {\n            return;\n        }\n\n        // Try to remove (from the AckReceiverWindow) as many messages as possible as pass them up\n        boolean released_processing=false;\n        int num_regular_msgs_removed=0;\n\n        // Prevents concurrent passing up of messages by different threads (http://jira.jboss.com/jira/browse/JGRP-198);\n        // this is all the more important once we have a threadless stack (http://jira.jboss.com/jira/browse/JGRP-181),\n        // where lots of threads can come up to this point concurrently, but only 1 is allowed to pass at a time\n        // We *can* deliver messages from *different* senders concurrently, e.g. reception of P1, Q1, P2, Q2 can result in\n        // delivery of P1, Q1, Q2, P2: FIFO (implemented by UNICAST) says messages need to be delivered only in the\n        // order in which they were sent by their senders\n        try {\n            while(true) {\n                Message m=win.remove(processing);\n                if(m == null) {\n                    released_processing=true;\n                    return;\n                }\n\n                // discard OOB msg as it has already been delivered (http://jira.jboss.com/jira/browse/JGRP-377)\n                if(m.isFlagSet(Message.OOB)) {\n                    continue;\n                }\n                num_regular_msgs_removed++;\n                sendAckForMessage(m);\n                up_prot.up(new Event(Event.MSG, m));\n            }\n        }\n        finally {\n            // We keep track of regular messages that we added, but couldn't remove (because of ordering).\n            // When we have such messages pending, then even OOB threads will remove and process them\n            // http://jira.jboss.com/jira/browse/JGRP-781\n            undelivered_msgs.addAndGet(-num_regular_msgs_removed);\n\n            if(!released_processing)\n                processing.set(false);\n        }\n    }","id":6458,"modified_method":"/**\n     * Check whether the hashtable contains an entry e for <code>sender<\/code> (create if not). If\n     * e.received_msgs is null and <code>first<\/code> is true: create a new AckReceiverWindow(seqno) and\n     * add message. Set e.received_msgs to the new window. Else just add the message.\n     */\n    private void handleDataReceived(Address sender, long seqno, long conn_id,  boolean first, Message msg) {\n        if(log.isTraceEnabled()) {\n            StringBuilder sb=new StringBuilder();\n            sb.append(local_addr).append(\" <-- DATA(\").append(sender).append(\": #\").append(seqno);\n            if(conn_id != 0) sb.append(\", conn_id=\").append(conn_id);\n            if(first) sb.append(\", first\");\n            sb.append(')');\n            log.trace(sb);\n        }\n\n        AckReceiverWindow win;\n        Address send_request_for_first_seqno=null;\n        synchronized(recv_table) {\n            ReceiverEntry entry=recv_table.get(sender);\n            win=entry != null? entry.received_msgs : null;\n\n            if(first) {\n                if(entry == null || win == null) {\n                    win=createReceiverWindow(sender, entry, seqno, conn_id);\n                }\n                else {  // entry != null && win != null\n                    if(conn_id != entry.recv_conn_id) {\n                        if(log.isTraceEnabled())\n                            log.trace(local_addr + \": conn_id=\" + conn_id + \" != \" + entry.recv_conn_id + \"; resetting receiver window\");\n                        win=createReceiverWindow(sender, entry, seqno, conn_id);\n                    }\n                    else {\n                        ;\n                    }\n                }\n            }\n            else { // entry == null && win == null OR entry != null && win == null OR entry != null && win != null\n                if(win == null || entry.recv_conn_id != conn_id)\n                    send_request_for_first_seqno=sender; // drops the message and returns (see below)\n            }\n        }\n\n        if(send_request_for_first_seqno != null) {\n            sendRequestForFirstSeqno(send_request_for_first_seqno);\n            return;\n        }\n\n        byte result=win.add2(seqno, msg); // win is guaranteed to be non-null if we get here\n        boolean added=result > 0;\n        num_msgs_received++;\n        num_bytes_received+=msg.getLength();\n\n        if(added && !msg.isFlagSet(Message.OOB))\n            undelivered_msgs.incrementAndGet();\n\n        // Cannot be replaced with if(!added), see https://jira.jboss.org/jira/browse/JGRP-1043 comment 15/Sep/09 06:57 AM\n\n        // We *have* to do send the ACK, to cover the following scenario:\n        // - A sends #3 to B\n        // - B removes #3 and sends ACK(3) to A. B's next_to_remove is now 4\n        // - B's ACK(3) to A is dropped by the network\n        // - A keeps retransmitting #3 to B, until it gets an ACK(3)\n        // -B will never ACK #3 if the 2 lines below are commented ==> endless retransmission of A's #3 !\n        if(result == -1) { // only ack if seqno was < next_to_remove !\n            sendAck(msg.getSrc(), seqno);\n        }\n\n        // message is passed up if OOB. Later, when remove() is called, we discard it. This affects ordering !\n        // http://jira.jboss.com/jira/browse/JGRP-377\n        if(msg.isFlagSet(Message.OOB)) {\n            if(added)\n                up_prot.up(new Event(Event.MSG, msg));\n            Message oob_msg=win.removeOOBMessage();\n            if(!(undelivered_msgs.get() > 0 && win.hasMessagesToRemove())) {\n                if(oob_msg != null)\n                    sendAckForMessage(oob_msg);\n                return;\n            }\n        }\n\n        final AtomicBoolean processing=win.getProcessing();\n        if(!processing.compareAndSet(false, true)) {\n            return;\n        }\n\n        // Try to remove (from the AckReceiverWindow) as many messages as possible as pass them up\n        boolean released_processing=false;\n        int num_regular_msgs_removed=0;\n\n        // Prevents concurrent passing up of messages by different threads (http://jira.jboss.com/jira/browse/JGRP-198);\n        // this is all the more important once we have a threadless stack (http://jira.jboss.com/jira/browse/JGRP-181),\n        // where lots of threads can come up to this point concurrently, but only 1 is allowed to pass at a time\n        // We *can* deliver messages from *different* senders concurrently, e.g. reception of P1, Q1, P2, Q2 can result in\n        // delivery of P1, Q1, Q2, P2: FIFO (implemented by UNICAST) says messages need to be delivered only in the\n        // order in which they were sent by their senders\n        try {\n            while(true) {\n                List<Message> msgs=win.removeMany(processing);\n                if(msgs.isEmpty()) {\n                    released_processing=true;\n                    return;\n                }\n                Message highest_removed=msgs.get(msgs.size() -1);\n                sendAckForMessage(highest_removed); // guaranteed not to throw an exception !\n                for(Message m: msgs) {\n                    // discard OOB msg: it has already been delivered (http://jira.jboss.com/jira/browse/JGRP-377)\n                    if(m.isFlagSet(Message.OOB))\n                        continue;\n                    num_regular_msgs_removed++;\n                    try {\n                        up_prot.up(new Event(Event.MSG, m));\n                    }\n                    catch(Throwable t) {\n                        log.error(\"couldn't deliver message \" + m, t);\n                    }\n                }\n            }\n        }\n        finally {\n            // We keep track of regular messages that we added, but couldn't remove (because of ordering).\n            // When we have such messages pending, then even OOB threads will remove and process them\n            // http://jira.jboss.com/jira/browse/JGRP-781\n            undelivered_msgs.addAndGet(-num_regular_msgs_removed);\n\n            // double dutch: m == null always releases 'processing', however if remove() throws an exception we still\n            // release 'processing'\n            if(!released_processing)\n                processing.set(false);\n        }\n    }","commit_id":"823e9cf358df7d6131b8db4ddd6cb9ade4e7baf5","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object down(Event evt) {\n        switch (evt.getType()) {\n\n            case Event.MSG: // Add UnicastHeader, add to AckSenderWindow and pass down\n                Message msg=(Message)evt.getArg();\n                Address dst=msg.getDest();\n\n                /* only handle unicast messages */\n                if (dst == null || dst.isMulticastAddress()) {\n                    break;\n                }\n\n                if(!started) {\n                    if(log.isTraceEnabled())\n                        log.trace(\"discarded message as start() has not yet been called, message: \" + msg);\n                    return null;\n                }\n\n                // if the dest is self --> pass the message back up\n                if(loopback && local_addr != null && local_addr.equals(dst)) {\n                    msg.setSrc(local_addr);\n                    up_prot.up(evt);\n                    num_msgs_sent++;\n                    num_bytes_sent+=msg.getLength();\n                    return null;\n                }\n\n                Entry entry;\n                synchronized(connections) {\n                    entry=connections.get(dst);\n                    if(entry == null) {\n                        entry=new Entry();\n                        connections.put(dst, entry);\n                        if(log.isTraceEnabled())\n                            log.trace(local_addr + \": created connection to \" + dst);\n                        if(cache != null && !members.contains(dst))\n                            cache.add(dst);\n                    }\n                }\n\n                long seqno=-2;\n                long send_conn_id=0;\n                UnicastHeader hdr;\n                synchronized(entry) { // threads will only sync if they access the same entry\n                    try {\n                        seqno=entry.sent_msgs_seqno;\n                        if(seqno == DEFAULT_FIRST_SEQNO) // only happens on the first message\n                            entry.send_conn_id=send_conn_id=getNewConnectionId();\n                        if(entry.sent_msgs == null) // first msg to peer 'dst'\n                            entry.sent_msgs=new AckSenderWindow(this, new StaticInterval(timeout), timer, this.local_addr);\n                        hdr=new UnicastHeader(UnicastHeader.DATA, seqno, entry.send_conn_id, seqno == DEFAULT_FIRST_SEQNO);\n                        msg.putHeader(name, hdr);\n                        entry.sent_msgs.add(seqno, msg);  // add *including* UnicastHeader, adds to retransmitter\n                        entry.sent_msgs_seqno++;\n                    }\n                    catch(Throwable t) {\n                        entry.sent_msgs.ack(seqno); // remove seqno again, so it is not transmitted\n                        throw new RuntimeException(\"failure adding msg \" + msg + \" to the retransmit table\", t);\n                    }\n                }\n\n                if(log.isTraceEnabled()) {\n                    StringBuilder sb=new StringBuilder();\n                    sb.append(local_addr).append(\" --> DATA(\").append(dst).append(\": #\").append(seqno).\n                            append(\", conn_id=\").append(send_conn_id);\n                    if(hdr.first) sb.append(\", first\");\n                    sb.append(')');\n                    log.trace(sb);\n                }\n\n                // moved passing down of message out of the synchronized block: similar to NAKACK, we do *not* need\n                // to send unicast messages in order of sequence numbers because they will be sorted into the correct\n                // order at the receiver anyway. Of course, most of the time, the order will be correct (FIFO), so\n                // the cost of reordering is minimal. This is part of http://jira.jboss.com/jira/browse/JGRP-303\n                try { // we catch the exception in this case because the msg is in the XMIT table and will be retransmitted\n                    send(msg, evt);\n                }\n                catch(Throwable t) {\n                    log.warn(\"failed sending the message\", t);\n                }\n                return null; // we already passed the msg down\n\n            case Event.VIEW_CHANGE:  // remove connections to peers that are not members anymore !\n                View view=(View)evt.getArg();\n                Vector<Address> new_members=view.getMembers();\n                Set<Address> non_members=new HashSet<Address>(connections.keySet());\n                synchronized(members) {\n                    members.clear();\n                    if(new_members != null)\n                        members.addAll(new_members);\n                    non_members.removeAll(members);\n                    if(cache != null) {\n                        cache.removeAll(members);\n                    }\n                }\n\n                if(!non_members.isEmpty()) {\n                    if(log.isTraceEnabled())\n                        log.trace(\"removing non members \" + non_members);\n                    for(Address non_mbr: non_members)\n                        removeConnection(non_mbr);\n                }\n                break;\n\n            case Event.SET_LOCAL_ADDRESS:\n                local_addr=(Address)evt.getArg();\n                break;\n\n            case Event.CONNECT:\n                disconnected=false;\n                break;\n\n            case Event.DISCONNECT:\n                disconnected=true;\n                break;\n        }\n\n        return down_prot.down(evt);          // Pass on to the layer below us\n    }","id":6459,"modified_method":"public Object down(Event evt) {\n        switch (evt.getType()) {\n\n            case Event.MSG: // Add UnicastHeader, add to AckSenderWindow and pass down\n                Message msg=(Message)evt.getArg();\n                Address dst=msg.getDest();\n\n                /* only handle unicast messages */\n                if (dst == null || dst.isMulticastAddress()) {\n                    break;\n                }\n\n                if(!started) {\n                    if(log.isTraceEnabled())\n                        log.trace(\"discarded message as start() has not yet been called, message: \" + msg);\n                    return null;\n                }\n\n                // if the dest is self --> pass the message back up\n                if(loopback && local_addr != null && local_addr.equals(dst)) {\n                    msg.setSrc(local_addr);\n                    up_prot.up(evt);\n                    num_msgs_sent++;\n                    num_bytes_sent+=msg.getLength();\n                    return null;\n                }\n\n                SenderEntry entry=send_table.get(dst);\n                    if(entry == null) {\n                    entry=new SenderEntry(getNewConnectionId(), this, timeout, timer, local_addr);\n                    SenderEntry existing=send_table.putIfAbsent(dst, entry);\n                    if(existing != null)\n                        entry=existing;\n                    else {\n                        if(log.isTraceEnabled())\n                            log.trace(local_addr + \": created connection to \" + dst);\n                        if(cache != null && !members.contains(dst))\n                            cache.add(dst);\n                    }\n                }\n\n                long seqno=-2, send_conn_id=-1;\n                UnicastHeader hdr;\n\n                entry.lock(); // threads will only sync if they access the same entry\n                try {\n                    seqno=entry.sent_msgs_seqno;\n                    send_conn_id=entry.send_conn_id;\n                    hdr=new UnicastHeader(UnicastHeader.DATA, seqno, send_conn_id, seqno == DEFAULT_FIRST_SEQNO);\n                    msg.putHeader(getName(), hdr);\n\n                    // AckSenderWindow.add() is costly as it calls Retransmitter.add() which calls TimeScheduler.schedule(),\n                    // which adds the scheduled task to a DelayQueue, which does costly tree rebalancing.\n                    // In 2.9 (or 3.0), we'll replace use of ScheduledThreadPoolExecutor in TimeScheduler with\n                    // a ConcurrentSkipListMap, which is faster (log(n) access cost for most ops). CSLM requires JDK 1.6\n                    // Note that moving the next statement out of the lock scope made for some really ugly code, that's\n                    // why this was reverted !\n                    entry.sent_msgs.add(seqno, msg);  // add *including* UnicastHeader, adds to retransmitter\n                    entry.sent_msgs_seqno++;\n                }\n                finally {\n                    entry.unlock();\n                }\n\n                if(log.isTraceEnabled()) {\n                    StringBuilder sb=new StringBuilder();\n                    sb.append(local_addr).append(\" --> DATA(\").append(dst).append(\": #\").append(seqno).\n                            append(\", conn_id=\").append(send_conn_id);\n                    if(hdr.first) sb.append(\", first\");\n                    sb.append(')');\n                    log.trace(sb);\n                }\n\n                // moved passing down of message out of the synchronized block: similar to NAKACK, we do *not* need\n                // to send unicast messages in order of sequence numbers because they will be sorted into the correct\n                // order at the receiver anyway. Of course, most of the time, the order will be correct (FIFO), so\n                // the cost of reordering is minimal. This is part of http://jira.jboss.com/jira/browse/JGRP-303\n                try { // we catch the exception in this case because the msg is in the XMIT table and will be retransmitted\n                    send(msg, evt);\n                }\n                catch(Throwable t) {\n                    log.warn(\"failed sending the message\", t);\n                }\n                return null; // we already passed the msg down\n\n            case Event.VIEW_CHANGE:  // remove connections to peers that are not members anymore !\n                View view=(View)evt.getArg();\n                Vector<Address> new_members=view.getMembers();\n                Set<Address> non_members=new HashSet<Address>(send_table.keySet());\n                non_members.addAll(recv_table.keySet());\n\n                synchronized(members) {\n                    members.clear();\n                    if(new_members != null)\n                        members.addAll(new_members);\n                    non_members.removeAll(members);\n                    if(cache != null) {\n                        cache.removeAll(members);\n                    }\n                }\n\n                if(!non_members.isEmpty()) {\n                    if(log.isTraceEnabled())\n                        log.trace(\"removing non members \" + non_members);\n                    for(Address non_mbr: non_members)\n                        removeConnection(non_mbr);\n                }\n                break;\n\n            case Event.SET_LOCAL_ADDRESS:\n                local_addr=(Address)evt.getArg();\n                break;\n\n            case Event.CONNECT:\n                disconnected=false;\n                break;\n\n            case Event.DISCONNECT:\n                disconnected=true;\n                break;\n        }\n\n        return down_prot.down(evt);          // Pass on to the layer below us\n    }","commit_id":"823e9cf358df7d6131b8db4ddd6cb9ade4e7baf5","url":"https://github.com/belaban/JGroups"},{"original_method":"@ManagedAttribute\n    public int getNumberOfMessagesInReceiveWindows() {\n        int num=0;\n        synchronized(connections) {\n            for(Entry entry: connections.values()) {\n                if(entry.received_msgs != null)\n                    num+=entry.received_msgs.size();\n            }\n        }\n        return num;\n    }","id":6460,"modified_method":"@ManagedAttribute\n    public int getNumberOfMessagesInReceiveWindows() {\n        int num=0;\n        for(ReceiverEntry entry: recv_table.values()) {\n            if(entry.received_msgs != null)\n                num+=entry.received_msgs.size();\n        }\n        return num;\n    }","commit_id":"823e9cf358df7d6131b8db4ddd6cb9ade4e7baf5","url":"https://github.com/belaban/JGroups"},{"original_method":"@ManagedOperation\n    public String printUnackedMessages() {\n        StringBuilder sb=new StringBuilder();\n        Entry e;\n        Object member;\n        synchronized(connections) {\n            for(Map.Entry<Address,Entry> entry: connections.entrySet()) {\n                member=entry.getKey();\n                e=entry.getValue();\n                sb.append(member).append(\": \");\n                if(e.sent_msgs != null)\n                    sb.append(e.sent_msgs.toString()).append(\"\\n\");\n            }\n        }\n        return sb.toString();\n    }","id":6461,"modified_method":"@ManagedOperation\n    public String printUnackedMessages() {\n        StringBuilder sb=new StringBuilder();\n        for(Map.Entry<Address,SenderEntry> entry: send_table.entrySet()) {\n            sb.append(entry.getKey()).append(\": \");\n            SenderEntry val=entry.getValue();\n            if(val.sent_msgs != null)\n                sb.append(val.sent_msgs).append(\"\\n\");\n        }\n        return sb.toString();\n    }","commit_id":"823e9cf358df7d6131b8db4ddd6cb9ade4e7baf5","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * We need to resend our first message with our conn_id\n     * @param sender\n     */\n    private void handleResendingOfFirstMessage(Address sender) {\n        Entry entry;\n        AckSenderWindow sender_win;\n        Message rsp;\n        if(log.isTraceEnabled())\n            log.trace(local_addr + \" <-- SEND_FIRST_SEQNO(\" + sender + \")\");\n\n        synchronized(connections) {\n            entry=connections.get(sender);\n            sender_win=entry != null? entry.sent_msgs : null;\n            if(sender_win == null) {\n                if(log.isErrorEnabled())\n                    log.error(local_addr + \": sender window for \" + sender + \" not found\");\n                return;\n            }\n            rsp=sender_win.getLowestMessage();\n        }\n        if(rsp == null) {\n            //if(log.isWarnEnabled())\n                // log.warn(\"didn't find any messages in my sender window for \" + sender);\n            return;\n        }\n        // We need to copy the UnicastHeader and put it back into the message because Message.copy() doesn't copy\n        // the headers and therefore we'd modify the original message in the sender retransmission window\n        // (https://jira.jboss.org/jira/browse/JGRP-965)\n        Message copy=rsp.copy();\n        UnicastHeader hdr=(UnicastHeader)copy.getHeader(name);\n        UnicastHeader newhdr=new UnicastHeader(hdr.type, hdr.seqno, entry.send_conn_id, true);\n        copy.putHeader(name, newhdr);\n        down_prot.down(new Event(Event.MSG, copy));\n    }","id":6462,"modified_method":"/**\n     * We need to resend our first message with our conn_id\n     * @param sender\n     */\n    private void handleResendingOfFirstMessage(Address sender) {\n        if(log.isTraceEnabled())\n            log.trace(local_addr + \" <-- SEND_FIRST_SEQNO(\" + sender + \")\");\n        SenderEntry entry=send_table.get(sender);\n        AckSenderWindow win=entry != null? entry.sent_msgs : null;\n        if(win == null) {\n            if(log.isErrorEnabled())\n                log.error(local_addr + \": sender window for \" + sender + \" not found\");\n            return;\n        }\n        Message rsp=win.getLowestMessage();\n        if(rsp == null)\n            return;\n\n        // We need to copy the UnicastHeader and put it back into the message because Message.copy() doesn't copy\n        // the headers and therefore we'd modify the original message in the sender retransmission window\n        // (https://jira.jboss.org/jira/browse/JGRP-965)\n        Message copy=rsp.copy();\n        UnicastHeader hdr=(UnicastHeader)copy.getHeader(name);\n        UnicastHeader newhdr=hdr.copy();\n        newhdr.first=true;\n        copy.putHeader(name, newhdr);\n        down_prot.down(new Event(Event.MSG, copy));\n    }","commit_id":"823e9cf358df7d6131b8db4ddd6cb9ade4e7baf5","url":"https://github.com/belaban/JGroups"},{"original_method":"private void sendAck(Address dst, long seqno) {\n        // if we are disconnected, then don't send any acks which stops exceptions on shutdown\n        if (disconnected) \n            return; \n        Message ack=new Message(dst);\n        // commented Jan 23 2008 (bela): TP.enable_unicast_bundling should decide whether we bundle or not, and *not*\n        // the OOB flag ! Bundling UNICAST ACKs should be really fast\n        ack.setFlag(Message.OOB);\n        ack.putHeader(name, new UnicastHeader(UnicastHeader.ACK, seqno));\n        if(log.isTraceEnabled())\n            log.trace(new StringBuilder().append(local_addr).append(\" --> ACK(\").append(dst).\n                      append(\": #\").append(seqno).append(')'));\n        down_prot.down(new Event(Event.MSG, ack));\n        num_acks_sent++;\n    }","id":6463,"modified_method":"private void sendAck(Address dst, long seqno) {\n        if(disconnected) // if we are disconnected, then don't send any acks which throw exceptions on shutdown\n            return;\n        Message ack=new Message(dst);\n        // commented Jan 23 2008 (bela): TP.enable_unicast_bundling should decide whether we bundle or not, and *not*\n        // the OOB flag ! Bundling UNICAST ACKs should be really fast\n        ack.setFlag(Message.OOB);\n        ack.putHeader(name, new UnicastHeader(UnicastHeader.ACK, seqno));\n        if(log.isTraceEnabled())\n            log.trace(new StringBuilder().append(local_addr).append(\" --> ACK(\").append(dst).\n                    append(\": #\").append(seqno).append(')'));\n        try {\n            down_prot.down(new Event(Event.MSG, ack));\n            num_acks_sent++;\n        }\n        catch(Throwable t) {\n            log.error(\"failed sending ACK(\" + seqno + \") to \" + dst, t);\n        }\n    }","commit_id":"823e9cf358df7d6131b8db4ddd6cb9ade4e7baf5","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Finds the corresponding NakReceiverWindow and adds the message to it (according to seqno). Then removes as many\n     * messages as possible from the NRW and passes them up the stack. Discards messages from non-members.\n     */\n    private void  handleMessage(Message msg, NakAckHeader hdr) {\n        Address sender=msg.getSrc();\n        if(sender == null) {\n            if(log.isErrorEnabled())\n                log.error(\"sender of message is null\");\n            return;\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(new StringBuilder().append('[').append(local_addr).append(\": received \").append(sender).append('#').append(hdr.seqno));\n\n        NakReceiverWindow win=xmit_table.get(sender);\n        if(win == null) {  // discard message if there is no entry for sender\n            if(leaving)\n                return;\n            if(log.isWarnEnabled() && log_discard_msgs)\n                log.warn(local_addr + \": discarded message from non-member \" + sender + \", my view is \" + view);\n            return;\n        }\n\n        boolean loopback=local_addr.equals(sender);\n        boolean added_to_window=false;\n        boolean added=loopback || (added_to_window=win.add(hdr.seqno, msg));\n\n        if(added_to_window)\n            undelivered_msgs.incrementAndGet();\n\n        // message is passed up if OOB. Later, when remove() is called, we discard it. This affects ordering !\n        // http://jira.jboss.com/jira/browse/JGRP-379\n        if(added && msg.isFlagSet(Message.OOB)) {\n            if(!loopback || oob_loopback_msgs.remove(hdr.seqno)) {\n                up_prot.up(new Event(Event.MSG, msg));\n                win.removeOOBMessage();\n                if(!(win.hasMessagesToRemove() && undelivered_msgs.get() > 0))\n                    return;\n            }\n        }\n\n        // Efficient way of checking whether another thread is already processing messages from 'sender'.\n        // If that's the case, we return immediately and let the existing thread process our message\n        // (https://jira.jboss.org/jira/browse/JGRP-829). Benefit: fewer threads blocked on the same lock, these threads\n        // can be returned to the thread pool\n        final AtomicBoolean processing=win.getProcessing();\n        if(!processing.compareAndSet(false, true)) {\n            return;\n        }\n\n        // Prevents concurrent passing up of messages by different threads (http://jira.jboss.com/jira/browse/JGRP-198);\n        // this is all the more important once we have a threadless stack (http://jira.jboss.com/jira/browse/JGRP-181),\n        // where lots of threads can come up to this point concurrently, but only 1 is allowed to pass at a time\n        // We *can* deliver messages from *different* senders concurrently, e.g. reception of P1, Q1, P2, Q2 can result in\n        // delivery of P1, Q1, Q2, P2: FIFO (implemented by NAKACK) says messages need to be delivered in the\n        // order in which they were sent by the sender\n        int num_regular_msgs_removed=0;\n\n        // 2nd line of defense: in case of an exception, remove() might not be called, therefore processing would never\n        // be set back to false. If we get an exception and released_processing is not true, then we set\n        // processing to false in the finally clause\n        boolean released_processing=false;\n        try {\n            while(true) {\n                // we're removing a msg and set processing to false (if null) *atomically* (wrt to add())\n                List<Message> msgs=win.removeMany(processing);\n                if(msgs == null || msgs.isEmpty()) {\n                    released_processing=true;\n                    return;\n                }\n\n                for(Message msg_to_deliver: msgs) {\n\n                    // discard OOB msg as it has already been delivered (http://jira.jboss.com/jira/browse/JGRP-379)\n                    if(msg_to_deliver.isFlagSet(Message.OOB)) {\n                        continue;\n                    }\n                    num_regular_msgs_removed++;\n\n                    // Changed by bela Jan 29 2003: not needed (see above)\n                    //msg_to_deliver.removeHeader(getName());\n                    try {\n                        up_prot.up(new Event(Event.MSG, msg_to_deliver));\n                    }\n                    catch(Throwable t) {\n                        log.error(\"couldn't deliver message \" + msg, t);\n                    }\n                }\n            }\n        }\n        finally {\n            // We keep track of regular messages that we added, but couldn't remove (because of ordering).\n            // When we have such messages pending, then even OOB threads will remove and process them\n            // http://jira.jboss.com/jira/browse/JGRP-781\n            undelivered_msgs.addAndGet(-num_regular_msgs_removed);\n\n            // processing is always set in win.remove(processing) above and never here ! This code is just a\n            // 2nd line of defense should there be an exception before win.remove(processing) sets processing\n            if(!released_processing)\n                processing.set(false);\n        }\n    }","id":6464,"modified_method":"/**\n     * Finds the corresponding NakReceiverWindow and adds the message to it (according to seqno). Then removes as many\n     * messages as possible from the NRW and passes them up the stack. Discards messages from non-members.\n     */\n    private void  handleMessage(Message msg, NakAckHeader hdr) {\n        Address sender=msg.getSrc();\n        if(sender == null) {\n            if(log.isErrorEnabled())\n                log.error(\"sender of message is null\");\n            return;\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(new StringBuilder().append('[').append(local_addr).append(\": received \").append(sender).append('#').append(hdr.seqno));\n\n        NakReceiverWindow win=xmit_table.get(sender);\n        if(win == null) {  // discard message if there is no entry for sender\n            if(leaving)\n                return;\n            if(log.isWarnEnabled() && log_discard_msgs)\n                log.warn(local_addr + \": discarded message from non-member \" + sender + \", my view is \" + view);\n            return;\n        }\n\n        boolean loopback=local_addr.equals(sender);\n        boolean added_to_window=false;\n        boolean added=loopback || (added_to_window=win.add(hdr.seqno, msg));\n\n        if(added_to_window && !msg.isFlagSet(Message.OOB))\n            undelivered_msgs.incrementAndGet();\n\n        // message is passed up if OOB. Later, when remove() is called, we discard it. This affects ordering !\n        // http://jira.jboss.com/jira/browse/JGRP-379\n        if(added && msg.isFlagSet(Message.OOB)) {\n            msg=win.get(hdr.seqno);\n            if(msg != null) {\n                boolean pass_up=msg.setTransientFlagIfAbsent(Message.OOB_DELIVERED);\n                if(pass_up)\n                    up_prot.up(new Event(Event.MSG, msg));\n            }\n\n            while(true) {\n                final Message oob_msg=win.removeOOBMessage();\n                if(oob_msg == null)\n                    break;\n                boolean pass_up=oob_msg.setTransientFlagIfAbsent(Message.OOB_DELIVERED);\n                if(pass_up) {\n                    timer.execute(new Runnable() {\n                        public void run() {\n                            up_prot.up(new Event(Event.MSG, oob_msg));\n                        }\n                    });\n                }\n            }\n\n            if(!(win.hasMessagesToRemove() && undelivered_msgs.get() > 0))\n                return;\n        }\n\n        // Efficient way of checking whether another thread is already processing messages from 'sender'.\n        // If that's the case, we return immediately and let the existing thread process our message\n        // (https://jira.jboss.org/jira/browse/JGRP-829). Benefit: fewer threads blocked on the same lock, these threads\n        // can be returned to the thread pool\n        final AtomicBoolean processing=win.getProcessing();\n        if(!processing.compareAndSet(false, true)) {\n            return;\n        }\n\n        // Prevents concurrent passing up of messages by different threads (http://jira.jboss.com/jira/browse/JGRP-198);\n        // this is all the more important once we have a threadless stack (http://jira.jboss.com/jira/browse/JGRP-181),\n        // where lots of threads can come up to this point concurrently, but only 1 is allowed to pass at a time\n        // We *can* deliver messages from *different* senders concurrently, e.g. reception of P1, Q1, P2, Q2 can result in\n        // delivery of P1, Q1, Q2, P2: FIFO (implemented by NAKACK) says messages need to be delivered in the\n        // order in which they were sent by the sender\n        int num_regular_msgs_removed=0;\n\n        // 2nd line of defense: in case of an exception, remove() might not be called, therefore processing would never\n        // be set back to false. If we get an exception and released_processing is not true, then we set\n        // processing to false in the finally clause\n        boolean released_processing=false;\n        try {\n            while(true) {\n                // we're removing a msg and set processing to false (if null) *atomically* (wrt to add())\n                List<Message> msgs=win.removeMany(processing);\n                if(msgs == null || msgs.isEmpty()) {\n                    released_processing=true;\n                    return;\n                }\n\n                for(Message msg_to_deliver: msgs) {\n\n                    // discard OOB msg as it has already been delivered (http://jira.jboss.com/jira/browse/JGRP-379)\n                    if(msg_to_deliver.isFlagSet(Message.OOB)) {\n                        continue;\n                    }\n                    num_regular_msgs_removed++;\n\n                    // Changed by bela Jan 29 2003: not needed (see above)\n                    //msg_to_deliver.removeHeader(getName());\n                    try {\n                        up_prot.up(new Event(Event.MSG, msg_to_deliver));\n                    }\n                    catch(Throwable t) {\n                        log.error(\"couldn't deliver message \" + msg_to_deliver, t);\n                    }\n                }\n            }\n        }\n        finally {\n            // We keep track of regular messages that we added, but couldn't remove (because of ordering).\n            // When we have such messages pending, then even OOB threads will remove and process them\n            // http://jira.jboss.com/jira/browse/JGRP-781\n            undelivered_msgs.addAndGet(-num_regular_msgs_removed);\n\n            // processing is always set in win.remove(processing) above and never here ! This code is just a\n            // 2nd line of defense should there be an exception before win.remove(processing) sets processing\n            if(!released_processing)\n                processing.set(false);\n        }\n    }","commit_id":"b5ef4e907333d8b33bb7b0b047eebce31bd4a0b1","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Sends a message msg to the requester. We have to wrap the original message into a retransmit message, as we need\n     * to preserve the original message's properties, such as src, headers etc.\n     * @param dest\n     * @param msg\n     * @param seqno\n     */\n    private void sendXmitRsp(Address dest, Message msg, long seqno) {\n        Buffer buf;\n        if(msg == null) {\n            if(log.isErrorEnabled())\n                log.error(\"message is null, cannot send retransmission\");\n            return;\n        }\n\n        if(stats) {\n            xmit_rsps_sent++;\n            updateStats(sent, dest, 0, 1, 0);\n        }\n\n        if(use_mcast_xmit)\n            dest=null;\n\n        if(msg.getSrc() == null)\n            msg.setSrc(local_addr);\n        try {\n            buf=Util.messageToByteBuffer(msg);\n            Message xmit_msg=new Message(dest, null, buf.getBuf(), buf.getOffset(), buf.getLength());\n            // changed Bela Jan 4 2007: we should not use OOB for retransmitted messages, otherwise we tax the\n            // OOB thread pool too much\n            // msg.setFlag(Message.OOB);\n            xmit_msg.putHeader(name, new NakAckHeader(NakAckHeader.XMIT_RSP, seqno));\n            down_prot.down(new Event(Event.MSG, xmit_msg));\n        }\n        catch(IOException ex) {\n            log.error(\"failed marshalling xmit list\", ex);\n        }\n    }","id":6465,"modified_method":"/**\n     * Sends a message msg to the requester. We have to wrap the original message into a retransmit message, as we need\n     * to preserve the original message's properties, such as src, headers etc.\n     * @param dest\n     * @param msg\n     * @param seqno\n     */\n    private void sendXmitRsp(Address dest, Message msg, long seqno) {\n        Buffer buf;\n        if(msg == null) {\n            if(log.isErrorEnabled())\n                log.error(\"message is null, cannot send retransmission\");\n            return;\n        }\n\n        if(stats) {\n            xmit_rsps_sent++;\n            updateStats(sent, dest, 0, 1, 0);\n        }\n\n        if(use_mcast_xmit)\n            dest=null;\n\n        if(msg.getSrc() == null)\n            msg.setSrc(local_addr);\n        try {\n            buf=Util.messageToByteBuffer(msg);\n            Message xmit_msg=new Message(dest, null, buf.getBuf(), buf.getOffset(), buf.getLength());\n            // changed Bela Jan 4 2007: we should not use OOB for retransmitted messages, otherwise we tax the\n            // OOB thread pool too much\n            // xmit_msg.setFlag(Message.OOB);\n\n            if(msg.isFlagSet(Message.OOB)) // set OOB for the wrapping message if the wrapped message is OOB, too\n                xmit_msg.setFlag(Message.OOB);\n\n            xmit_msg.putHeader(name, new NakAckHeader(NakAckHeader.XMIT_RSP, seqno));\n            down_prot.down(new Event(Event.MSG, xmit_msg));\n        }\n        catch(IOException ex) {\n            log.error(\"failed marshalling xmit list\", ex);\n        }\n    }","commit_id":"b5ef4e907333d8b33bb7b0b047eebce31bd4a0b1","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Adds the message to the sent_msgs table and then passes it down the stack. Change Bela Ban May 26 2002: we don't\n     * store a copy of the message, but a reference ! This saves us a lot of memory. However, this also means that a\n     * message should not be changed after storing it in the sent-table ! See protocols/DESIGN for details.\n     * Made seqno increment and adding to sent_msgs atomic, e.g. seqno won't get incremented if adding to\n     * sent_msgs fails e.g. due to an OOM (see http://jira.jboss.com/jira/browse/JGRP-179). bela Jan 13 2006\n     */\n    private void send(Event evt, Message msg) {\n        if(msg == null)\n            throw new NullPointerException(\"msg is null; event is \" + evt);\n\n        if(!started) {\n            if(log.isTraceEnabled())\n                log.trace(\"[\" + local_addr + \"] discarded message as start() has not been called, message: \" + msg);\n            return;\n        }\n\n        long msg_id;\n        NakReceiverWindow win=xmit_table.get(local_addr);\n        if(win == null) {  // discard message if there is no entry for local_addr\n            if(log.isWarnEnabled() && log_discard_msgs)\n                log.warn(local_addr + \": discarded message from \" + local_addr + \" with no window, my view is \" + view);\n            return;\n        }\n        msg.setSrc(local_addr); // this needs to be done so we can check whether the message sender is the local_addr\n\n        seqno_lock.lock();\n        try {\n            try { // incrementing seqno and adding the msg to sent_msgs needs to be atomic\n                msg_id=seqno +1;\n                msg.putHeader(name, new NakAckHeader(NakAckHeader.MSG, msg_id));\n                if(win.add(msg_id, msg) && !msg.isFlagSet(Message.OOB))\n                    undelivered_msgs.incrementAndGet();\n                seqno=msg_id;\n            }\n            catch(Throwable t) {\n                throw new RuntimeException(\"failure adding msg \" + msg + \" to the retransmit table for \" + local_addr, t);\n            }\n        }\n        finally {\n            seqno_lock.unlock();\n        }\n\n        try { // moved down_prot.down() out of synchronized clause (bela Sept 7 2006) http://jira.jboss.com/jira/browse/JGRP-300\n            if(msg.isFlagSet(Message.OOB))\n                oob_loopback_msgs.add(msg_id);\n            if(log.isTraceEnabled())\n                log.trace(\"sending \" + local_addr + \"#\" + msg_id);\n            down_prot.down(evt); // if this fails, since msg is in sent_msgs, it can be retransmitted\n        }\n        catch(Throwable t) { // eat the exception, don't pass it up the stack\n            if(log.isWarnEnabled()) {\n                log.warn(\"failure passing message down\", t);\n            }\n        }\n    }","id":6466,"modified_method":"/**\n     * Adds the message to the sent_msgs table and then passes it down the stack. Change Bela Ban May 26 2002: we don't\n     * store a copy of the message, but a reference ! This saves us a lot of memory. However, this also means that a\n     * message should not be changed after storing it in the sent-table ! See protocols/DESIGN for details.\n     * Made seqno increment and adding to sent_msgs atomic, e.g. seqno won't get incremented if adding to\n     * sent_msgs fails e.g. due to an OOM (see http://jira.jboss.com/jira/browse/JGRP-179). bela Jan 13 2006\n     */\n    private void send(Event evt, Message msg) {\n        if(msg == null)\n            throw new NullPointerException(\"msg is null; event is \" + evt);\n\n        if(!started) {\n            if(log.isTraceEnabled())\n                log.trace(\"[\" + local_addr + \"] discarded message as start() has not been called, message: \" + msg);\n            return;\n        }\n\n        long msg_id;\n        NakReceiverWindow win=xmit_table.get(local_addr);\n        if(win == null) {  // discard message if there is no entry for local_addr\n            if(log.isWarnEnabled() && log_discard_msgs)\n                log.warn(local_addr + \": discarded message from \" + local_addr + \" with no window, my view is \" + view);\n            return;\n        }\n        msg.setSrc(local_addr); // this needs to be done so we can check whether the message sender is the local_addr\n\n        seqno_lock.lock();\n        try {\n            try { // incrementing seqno and adding the msg to sent_msgs needs to be atomic\n                msg_id=seqno +1;\n                msg.putHeader(name, new NakAckHeader(NakAckHeader.MSG, msg_id));\n                if(win.add(msg_id, msg) && !msg.isFlagSet(Message.OOB))\n                    undelivered_msgs.incrementAndGet();\n                seqno=msg_id;\n            }\n            catch(Throwable t) {\n                throw new RuntimeException(\"failure adding msg \" + msg + \" to the retransmit table for \" + local_addr, t);\n            }\n        }\n        finally {\n            seqno_lock.unlock();\n        }\n\n        try { // moved down_prot.down() out of synchronized clause (bela Sept 7 2006) http://jira.jboss.com/jira/browse/JGRP-300\n            if(log.isTraceEnabled())\n                log.trace(\"sending \" + local_addr + \"#\" + msg_id);\n            down_prot.down(evt); // if this fails, since msg is in sent_msgs, it can be retransmitted\n        }\n        catch(Throwable t) { // eat the exception, don't pass it up the stack\n            if(log.isWarnEnabled()) {\n                log.warn(\"failure passing message down\", t);\n            }\n        }\n    }","commit_id":"b5ef4e907333d8b33bb7b0b047eebce31bd4a0b1","url":"https://github.com/belaban/JGroups"},{"original_method":"public void stop() {\n        started=false;\n        reset();  // clears sent_msgs and destroys all NakReceiverWindows\n        oob_loopback_msgs.clear();\n    }","id":6467,"modified_method":"public void stop() {\n        started=false;\n        reset();  // clears sent_msgs and destroys all NakReceiverWindows\n    }","commit_id":"b5ef4e907333d8b33bb7b0b047eebce31bd4a0b1","url":"https://github.com/belaban/JGroups"},{"original_method":"public void visitLiteralExpression(@NotNull PsiLiteralExpression expression) {\n      super.visitLiteralExpression(expression);\n      final PsiType type = expression.getType();\n      if (!TypeUtils.isJavaLangString(type)) {\n        return;\n      }\n      final String value = (String)expression.getValue();\n      if (value == null) {\n        return;\n      }\n      if (value.length() != 1) {\n        return;\n      }\n      if (!isArgumentOfConcatenation(expression) &&\n          !isArgumentOfStringAppend(expression)) {\n        return;\n      }\n      registerError(expression);\n    }","id":6468,"modified_method":"public void visitLiteralExpression(\n                @NotNull PsiLiteralExpression expression) {\n            super.visitLiteralExpression(expression);\n            final PsiType type = expression.getType();\n            if (!TypeUtils.isJavaLangString(type)) {\n                return;\n            }\n            final String value = (String)expression.getValue();\n            if (value == null || value.length() != 1) {\n                return;\n            }\n            if (!isArgumentOfConcatenation(expression) &&\n                !isArgumentOfStringAppend(expression)) {\n                return;\n            }\n            registerError(expression);\n        }","commit_id":"3b2c2c227fd2d328bd089d025ebe9c6758a0afec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isArgumentOfConcatenation(PsiExpression expression) {\n      final PsiElement parent = expression.getParent();\n      if (!(parent instanceof PsiBinaryExpression)) {\n        return false;\n      }\n      final PsiBinaryExpression binaryExp = (PsiBinaryExpression)parent;\n      final PsiJavaToken sign = binaryExp.getOperationSign();\n      if (!sign.getTokenType().equals(JavaTokenType.PLUS)) {\n        return false;\n      }\n      final PsiExpression lhs = binaryExp.getLOperand();\n      final PsiExpression sibling;\n      if (lhs.equals(expression)) {\n        sibling = binaryExp.getROperand();\n      }\n      else {\n        sibling = lhs;\n      }\n      if (sibling == null) {\n        return false;\n      }\n      final PsiType siblingType = sibling.getType();\n      return TypeUtils.isJavaLangString(siblingType);\n    }","id":6469,"modified_method":"private static boolean isArgumentOfConcatenation(\n                PsiExpression expression) {\n            final PsiElement parent = expression.getParent();\n            if (!(parent instanceof PsiBinaryExpression)) {\n                return false;\n            }\n            final PsiBinaryExpression binaryExp = (PsiBinaryExpression)parent;\n            final PsiJavaToken sign = binaryExp.getOperationSign();\n            if (!JavaTokenType.PLUS.equals(sign.getTokenType())) {\n                return false;\n            }\n            final PsiExpression lhs = binaryExp.getLOperand();\n            final PsiExpression sibling;\n            if (lhs.equals(expression)) {\n                sibling = binaryExp.getROperand();\n            } else {\n                sibling = lhs;\n            }\n            if (sibling == null) {\n                return false;\n            }\n            final PsiType siblingType = sibling.getType();\n            return TypeUtils.isJavaLangString(siblingType);\n        }","commit_id":"3b2c2c227fd2d328bd089d025ebe9c6758a0afec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static boolean isArgumentOfStringAppend(PsiExpression expression) {\n      final PsiElement parent = expression.getParent();\n      if (parent == null) {\n        return false;\n      }\n      if (!(parent instanceof PsiExpressionList)) {\n        return false;\n      }\n      final PsiExpressionList paramList = (PsiExpressionList)parent;\n      final PsiExpression[] parameters = paramList.getExpressions();\n      if (parameters == null) {\n        return false;\n      }\n      if (parameters.length != 1) {\n        return false;\n      }\n      final PsiElement grandparent = parent.getParent();\n      if (!(grandparent instanceof PsiMethodCallExpression)) {\n        return false;\n      }\n      final PsiMethodCallExpression call = (PsiMethodCallExpression)grandparent;\n      final PsiReferenceExpression methodExpression = call.getMethodExpression();\n      @NonNls final String name = methodExpression.getReferenceName();\n      if (!\"append\".equals(name)) {\n        return false;\n      }\n      final PsiMethod method = call.resolveMethod();\n      if (method == null) {\n        return false;\n      }\n      final PsiClass methodClass = method.getContainingClass();\n      if (methodClass == null) {\n        return false;\n      }\n      final String className = methodClass.getQualifiedName();\n      return \"java.lang.StringBuffer\".equals(className) ||\n             \"java.lang.StringBuilder\".equals(className);\n    }","id":6470,"modified_method":"static boolean isArgumentOfStringAppend(PsiExpression expression) {\n            final PsiElement parent = expression.getParent();\n            if (parent == null) {\n                return false;\n            }\n            if (!(parent instanceof PsiExpressionList)) {\n                return false;\n            }\n            final PsiElement grandparent = parent.getParent();\n            if (!(grandparent instanceof PsiMethodCallExpression)) {\n                return false;\n            }\n            final PsiMethodCallExpression call =\n                    (PsiMethodCallExpression)grandparent;\n            final PsiReferenceExpression methodExpression =\n                    call.getMethodExpression();\n            @NonNls final String name = methodExpression.getReferenceName();\n            if (!\"append\".equals(name) && !\"insert\".equals(name)) {\n                return false;\n            }\n            final PsiMethod method = call.resolveMethod();\n            if (method == null) {\n                return false;\n            }\n            final PsiClass methodClass = method.getContainingClass();\n            if (methodClass == null) {\n                return false;\n            }\n            final String className = methodClass.getQualifiedName();\n            return \"java.lang.StringBuffer\".equals(className) ||\n                   \"java.lang.StringBuilder\".equals(className);\n        }","commit_id":"3b2c2c227fd2d328bd089d025ebe9c6758a0afec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public InspectionGadgetsFix buildFix(PsiElement location) {\n    return fix;\n  }","id":6471,"modified_method":"public InspectionGadgetsFix buildFix(PsiElement location) {\n        return new ReplaceStringsWithCharsFix();\n    }","commit_id":"3b2c2c227fd2d328bd089d025ebe9c6758a0afec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitForStatement(PsiForStatement statement) {\n            super.visitForStatement(statement);\n            final PsiExpression condition = statement.getCondition();\n            checkCondition(condition, statement);\n        }","id":6472,"modified_method":"public void visitForStatement(PsiForStatement statement) {\n            super.visitForStatement(statement);\n            final PsiExpression condition = statement.getCondition();\n            final boolean notUpdated = checkCondition(condition, statement);\n            if (notUpdated) {\n                registerError(condition);\n            }\n        }","commit_id":"3b2c2c227fd2d328bd089d025ebe9c6758a0afec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkCondition(@Nullable PsiExpression condition,\n                                    @NotNull PsiStatement context) {\n            if (condition == null) {\n                return;\n            }\n            if (condition instanceof PsiInstanceOfExpression) {\n                final PsiInstanceOfExpression instanceOfExpression =\n                        (PsiInstanceOfExpression)condition;\n                final PsiExpression operand = instanceOfExpression.getOperand();\n                checkCondition(operand, context);\n            } else if (condition instanceof PsiBinaryExpression) {\n                final PsiBinaryExpression binaryExpression =\n                        (PsiBinaryExpression)condition;\n                PsiExpression lhs = binaryExpression.getLOperand();\n                PsiExpression rhs = binaryExpression.getROperand();\n                if (rhs == null) {\n                    return;\n                }\n                lhs = ParenthesesUtils.stripParentheses(lhs);\n                rhs = ParenthesesUtils.stripParentheses(rhs);\n                if (ComparisonUtils.isComparison(binaryExpression)) {\n                    if (lhs instanceof PsiLiteralExpression) {\n                        checkCondition(rhs, context);\n                    } else if (rhs instanceof PsiLiteralExpression) {\n                        checkCondition(lhs, context);\n                    }\n                }\n            } else if (condition instanceof PsiReferenceExpression) {\n                final PsiReferenceExpression referenceExpression =\n                        (PsiReferenceExpression)condition;\n                final PsiElement element = referenceExpression.resolve();\n                if (element instanceof PsiLocalVariable) {\n                    final PsiLocalVariable variable = (PsiLocalVariable)element;\n                    if (!VariableAccessUtils.variableIsAssigned(variable,\n                            context)) {\n                        registerError(condition);\n                    }\n                } else if (element instanceof PsiParameter) {\n                    final PsiParameter parameter = (PsiParameter)element;\n                    if (!VariableAccessUtils.variableIsAssigned(parameter,\n                            context)) {\n                        registerError(condition);\n                    }\n                }\n            } else if (condition instanceof PsiPrefixExpression) {\n                final PsiPrefixExpression prefixExpression =\n                        (PsiPrefixExpression)condition;\n                final PsiJavaToken sign = prefixExpression.getOperationSign();\n                final IElementType tokenType = sign.getTokenType();\n                if (JavaTokenType.EXCL.equals(tokenType)) {\n                    final PsiExpression operand = prefixExpression.getOperand();\n                    checkCondition(operand, context);\n                }\n            }\n        }","id":6473,"modified_method":"private boolean checkCondition(@Nullable PsiExpression condition,\n                                    @NotNull PsiStatement context) {\n            if (condition == null) {\n                return false;\n            }\n            if (condition instanceof PsiInstanceOfExpression) {\n                final PsiInstanceOfExpression instanceOfExpression =\n                        (PsiInstanceOfExpression)condition;\n                final PsiExpression operand = instanceOfExpression.getOperand();\n                if (checkCondition(operand, context)) {\n                    registerError(operand);\n                }\n                return false;\n            } else if (condition instanceof PsiBinaryExpression) {\n                final PsiBinaryExpression binaryExpression =\n                        (PsiBinaryExpression)condition;\n                PsiExpression lhs = binaryExpression.getLOperand();\n                PsiExpression rhs = binaryExpression.getROperand();\n                if (rhs == null) {\n                    return false;\n                }\n                lhs = ParenthesesUtils.stripParentheses(lhs);\n                rhs = ParenthesesUtils.stripParentheses(rhs);\n                if (ComparisonUtils.isComparison(binaryExpression)) {\n                    if (PsiUtil.isConstantExpression(lhs)) {\n                        if (checkCondition(rhs, context)) {\n                            registerError(rhs);\n                        }\n                        return false;\n                    } else if (PsiUtil.isConstantExpression(rhs)) {\n                        if (checkCondition(lhs, context)) {\n                            registerError(lhs);\n                        }\n                        return false;\n                    } else if (lhs instanceof PsiReferenceExpression &&\n                            rhs instanceof PsiReferenceExpression){\n                        if (checkCondition(lhs, context) &&\n                                checkCondition(rhs, context)) {\n                            registerError(lhs);\n                            registerError(rhs);\n                        }\n                        return false;\n                    }\n                }\n            } else if (condition instanceof PsiReferenceExpression) {\n                final PsiReferenceExpression referenceExpression =\n                        (PsiReferenceExpression)condition;\n                final PsiElement element = referenceExpression.resolve();\n                if (element instanceof PsiLocalVariable) {\n                    final PsiLocalVariable variable = (PsiLocalVariable)element;\n                    if (!VariableAccessUtils.variableIsAssigned(variable,\n                            context)) {\n                        return true;\n                    }\n                } else if (element instanceof PsiParameter) {\n                    final PsiParameter parameter = (PsiParameter)element;\n                    if (!VariableAccessUtils.variableIsAssigned(parameter,\n                            context)) {\n                        return true;\n                    }\n                }\n            } else if (condition instanceof PsiPrefixExpression) {\n                final PsiPrefixExpression prefixExpression =\n                        (PsiPrefixExpression)condition;\n                final PsiJavaToken sign = prefixExpression.getOperationSign();\n                final IElementType tokenType = sign.getTokenType();\n                if (JavaTokenType.EXCL.equals(tokenType) ||\n                        JavaTokenType.MINUS.equals(tokenType) ||\n                        JavaTokenType.PLUS.equals(tokenType)) {\n                    final PsiExpression operand = prefixExpression.getOperand();\n                    if (checkCondition(operand, context)) {\n                        registerError(operand);\n                    }\n                    return false;\n                }\n            }\n            return false;\n        }","commit_id":"3b2c2c227fd2d328bd089d025ebe9c6758a0afec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitWhileStatement(PsiWhileStatement statement) {\n            super.visitWhileStatement(statement);\n            final PsiExpression condition = statement.getCondition();\n            final PsiStatement body = statement.getBody();\n            if (body == null) {\n                return;\n            }\n            checkCondition(condition, body);\n        }","id":6474,"modified_method":"public void visitWhileStatement(PsiWhileStatement statement) {\n            super.visitWhileStatement(statement);\n            final PsiExpression condition = statement.getCondition();\n            checkCondition(condition, statement);\n        }","commit_id":"de6fe2273310915b2e8cf426106f8cef87e0c230","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkCondition(\n                PsiExpression expression, PsiStatement context) {\n            if (expression instanceof PsiInstanceOfExpression) {\n                final PsiInstanceOfExpression instanceOfExpression =\n                        (PsiInstanceOfExpression)expression;\n                final PsiExpression operand = instanceOfExpression.getOperand();\n                checkCondition(operand, context);\n            } else if (expression instanceof PsiBinaryExpression) {\n                final PsiBinaryExpression binaryExpression =\n                        (PsiBinaryExpression)expression;\n                final PsiExpression lhs = binaryExpression.getLOperand();\n                final PsiExpression rhs = binaryExpression.getROperand();\n                checkCondition(lhs, context);\n                checkCondition(rhs, context);\n            } else if (expression instanceof PsiReferenceExpression) {\n                final PsiReferenceExpression referenceExpression =\n                        (PsiReferenceExpression)expression;\n                final PsiElement element = referenceExpression.resolve();\n                if (element instanceof PsiLocalVariable) {\n                    final PsiLocalVariable variable = (PsiLocalVariable)element;\n                    if (!VariableAccessUtils.variableIsAssigned(variable,\n                            context)) {\n                        registerError(expression);\n                    }\n                } else if (element instanceof PsiParameter) {\n                    final PsiParameter parameter = (PsiParameter)element;\n                    if (!VariableAccessUtils.variableIsAssigned(parameter,\n                            context)) {\n                        registerError(expression);\n                    }\n                }\n            }\n        }","id":6475,"modified_method":"private void checkCondition(\n                PsiExpression expression, PsiStatement context) {\n            if (expression instanceof PsiInstanceOfExpression) {\n                final PsiInstanceOfExpression instanceOfExpression =\n                        (PsiInstanceOfExpression)expression;\n                final PsiExpression operand = instanceOfExpression.getOperand();\n                checkCondition(operand, context);\n            } else if (expression instanceof PsiBinaryExpression) {\n                final PsiBinaryExpression binaryExpression =\n                        (PsiBinaryExpression)expression;\n                PsiExpression lhs = binaryExpression.getLOperand();\n                PsiExpression rhs = binaryExpression.getROperand();\n                if (rhs == null) {\n                    return;\n                }\n                lhs = ParenthesesUtils.stripParentheses(lhs);\n                rhs = ParenthesesUtils.stripParentheses(rhs);\n                if (ComparisonUtils.isComparison(binaryExpression)) {\n                    if (lhs instanceof PsiLiteralExpression) {\n                        checkCondition(rhs, context);\n                    } else if (rhs instanceof PsiLiteralExpression) {\n                        checkCondition(lhs, context);\n                    }\n                } else {\n                    checkCondition(rhs, context);\n                    checkCondition(lhs, context);\n                }\n            } else if (expression instanceof PsiReferenceExpression) {\n                final PsiReferenceExpression referenceExpression =\n                        (PsiReferenceExpression)expression;\n                final PsiElement element = referenceExpression.resolve();\n                if (element instanceof PsiLocalVariable) {\n                    final PsiLocalVariable variable = (PsiLocalVariable)element;\n                    if (!VariableAccessUtils.variableIsAssigned(variable,\n                            context)) {\n                        registerError(expression);\n                    }\n                } else if (element instanceof PsiParameter) {\n                    final PsiParameter parameter = (PsiParameter)element;\n                    if (!VariableAccessUtils.variableIsAssigned(parameter,\n                            context)) {\n                        registerError(expression);\n                    }\n                }\n            } else if (expression instanceof PsiPrefixExpression) {\n                final PsiPrefixExpression prefixExpression =\n                        (PsiPrefixExpression)expression;\n                final PsiJavaToken sign = prefixExpression.getOperationSign();\n                final IElementType tokenType = sign.getTokenType();\n                if (JavaTokenType.EXCL.equals(tokenType)) {\n                    final PsiExpression operand = prefixExpression.getOperand();\n                    checkCondition(operand, context);\n                }\n            }\n        }","commit_id":"de6fe2273310915b2e8cf426106f8cef87e0c230","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void validate(Object obj, Errors errors) {\n\n\t\tVoteCollection votes = (VoteCollection)obj;\n\t\tlogger.debug(\"we are validating a vote collection of \" + votes + \" for poll \" + votes.getPollId());\n\t\n\t\tif (votes.getSubmissionStatus().equals(\"cancel\"))\n\t\t\treturn;\n\t\t\n\t\t\n\t//get the poll\n\tPoll poll = manager.getPollById(votes.getPollId());\n\tlogger.debug(\"this is a vote for \" + poll.getText());\n\tList<String> options = new ArrayList<String>();\n\t\n\t//is the poll open?\n\tif (!(poll.getVoteClose().after(new Date()) && new Date().after(poll.getVoteOpen()))) {\n\t\tlogger.warn(\"poll is closed!\");\n\t\terrors.reject(\"vote_closed.voteCollection\",\"vote closed\");\n\t\treturn;\n\t}\n\t\t\n\t//does the user have permission to vote\n\tif (!externalLogic.isUserAdmin()) {\n\t\tif (!pollVoteManager.pollIsVotable(poll))\n\t\t{\n\t\t\tlogger.error(\"attempt to vote in \" + poll.getReference() + \" by unauthorized user\" );\n\t\t\terrors.reject(\"vote_noperm.voteCollection\",\"no permissions\");\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tif (votes.getOptionsSelected() == null && votes.getOption() == null && poll.getMinOptions()>0) {\n\t\tlogger.debug(\"there seems to be no vote on this poll\");  \n\t\tString errStr = Integer.valueOf(poll.getMinOptions()).toString();\n\t\terrors.reject(\"error_novote.voteCollection\", new Object[] {errStr}, \"no vote\");\n\t\t  return;\n\t} else if (votes.getOptionsSelected() == null && votes.getOption() == null && poll.getMinOptions()==0) {\n\t\t//to do we need to map to somthing special\n\t\toptions.add(\"0\");\n\t}\n\t\n\t\n\tif (votes.getOptionsSelected() == null && votes.getOption() != null) {\n\t\t  options.add(votes.getOption());\n\t} else if (votes.getOptionsSelected() != null){\n\t\tfor (int i = 0;i < votes.getOptionsSelected().length;i++){\n\t\t\toptions.add(votes.getOptionsSelected()[i]);\n\t\t}\n\t}\n\t  \n\t  logger.debug(\"options selected is \" + options.size());\n\t  // the exact choise case\n\t  \n\t  if (pollVoteManager.userHasVoted(poll.getPollId()) && poll.getLimitVoting()) {\n\t\t\terrors.reject(\"vote_hasvoted.voteCollection\",\"has voted\");\n\t\t\treturn;\n\t\t}\n\t  \n\t  if (poll.getMaxOptions() == poll.getMinOptions() && options.size() != poll.getMaxOptions()){\n\t\t  logger.debug(\"exact match failure!\");\n\t\t  String errStr = Integer.valueOf(poll.getMinOptions()).toString();\n\t\t  errors.reject(\"error_exact_required\", new Object[] {errStr}, \"exact required\");\n\t  }else if (options.size() > poll.getMaxOptions()) {\n\t\t  logger.debug(\"votes are for more than allowed!\");\n\t\t  String errStr = Integer.valueOf(poll.getMaxOptions()).toString();\n\t\t  errors.reject(\"error_tomany_votes\", new Object[] {errStr}, \"to many votes\");\n\t  }else if (options.size() < poll.getMinOptions()) {\n\t\t  logger.debug(\"votes are for fewer than required!\");\n\t\t  String errStr = Integer.valueOf(poll.getMinOptions()).toString();\n\t\t  errors.reject(\"error_tofew_votes\", new Object[] {errStr}, \"to few\");\n\t  }\n\t}","id":6476,"modified_method":"public void validate(Object obj, Errors errors) {\n\n\t\tVoteCollection votes = (VoteCollection)obj;\n\t\tlogger.debug(\"we are validating a vote collection of \" + votes + \" for poll \" + votes.getPollId());\n\t\n\t\tif (votes.getSubmissionStatus().equals(\"cancel\"))\n\t\t\treturn;\n\t\t\n\t\t\n\t//get the poll\n\tPoll poll = manager.getPollById(votes.getPollId());\n\tlogger.debug(\"this is a vote for \" + poll.getText());\n\tList<String> options = new ArrayList<String>();\n\t\n\t//is the poll open?\n\tif (!(poll.getVoteClose().after(new Date()) && new Date().after(poll.getVoteOpen()))) {\n\t\tlogger.warn(\"poll is closed!\");\n\t\tif (!errors.hasFieldErrors(\"vote_closed\")) {\n\t\t\terrors.reject(\"vote_closed\",\"vote closed\");\n\t\t} else {\n\t\t\terrors.reject(\"vote_closed.voteCollections\",\"vote closed\");\n\t\t}\n\t\treturn;\n\t}\n\t\t\n\t//does the user have permission to vote\n\tif (!externalLogic.isUserAdmin()) {\n\t\tif (!pollVoteManager.pollIsVotable(poll))\n\t\t{\n\t\t\tlogger.error(\"attempt to vote in \" + poll.getReference() + \" by unauthorized user\" );\n\t\t\tif (!errors.hasFieldErrors(\"vote_noperm\")) {\n\t\t\t\terrors.reject(\"vote_noperm\",\"no permissions\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\terrors.reject(\"vote_noperm.voteCollection\",\"no permissions\");\n\t\t\t}\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tif (votes.getOptionsSelected() == null && votes.getOption() == null && poll.getMinOptions()>0) {\n\t\tlogger.debug(\"there seems to be no vote on this poll\");  \n\t\tString errStr = Integer.valueOf(poll.getMinOptions()).toString();\n\t\tif (!errors.hasFieldErrors(\"error_novote\")) {\n\t\t\terrors.reject(\"error_novote\", new Object[] {errStr}, \"no vote\");\n\t\t}\n\t\telse {\n\t\t\terrors.reject(\"error_novote.voteCollection\", new Object[] {errStr}, \"no vote\");\n\t\t}\n\t\treturn;\n\t} else if (votes.getOptionsSelected() == null && votes.getOption() == null && poll.getMinOptions()==0) {\n\t\t//to do we need to map to somthing special\n\t\toptions.add(\"0\");\n\t}\n\t\n\t\n\tif (votes.getOptionsSelected() == null && votes.getOption() != null) {\n\t\t  options.add(votes.getOption());\n\t} else if (votes.getOptionsSelected() != null){\n\t\tfor (int i = 0;i < votes.getOptionsSelected().length;i++){\n\t\t\toptions.add(votes.getOptionsSelected()[i]);\n\t\t}\n\t}\n\t  \n\t  logger.debug(\"options selected is \" + options.size());\n\t  // the exact choise case\n\t  \n\t  if (pollVoteManager.userHasVoted(poll.getPollId()) && poll.getLimitVoting()) {\n\t\t  \tif (!errors.hasFieldErrors(\"vote_hasvoted\")) {\n\t\t  \t\terrors.reject(\"vote_hasvoted\",\"has voted\");\n\t\t  \t}\n\t\t  \telse {\n\t\t  \t\terrors.reject(\"vote_hasvoted.voteCollection\",\"has voted\");\n\t\t  \t}\n\t\t\treturn;\n\t\t}\n\t  \n\t  if (poll.getMaxOptions() == poll.getMinOptions() && options.size() != poll.getMaxOptions()){\n\t\t  logger.debug(\"exact match failure!\");\n\t\t  String errStr = Integer.valueOf(poll.getMinOptions()).toString();\n\t\t  errors.reject(\"error_exact_required\", new Object[] {errStr}, \"exact required\");\n\t  }else if (options.size() > poll.getMaxOptions()) {\n\t\t  logger.debug(\"votes are for more than allowed!\");\n\t\t  String errStr = Integer.valueOf(poll.getMaxOptions()).toString();\n\t\t  errors.reject(\"error_tomany_votes\", new Object[] {errStr}, \"to many votes\");\n\t  }else if (options.size() < poll.getMinOptions()) {\n\t\t  logger.debug(\"votes are for fewer than required!\");\n\t\t  String errStr = Integer.valueOf(poll.getMinOptions()).toString();\n\t\t  errors.reject(\"error_tofew_votes\", new Object[] {errStr}, \"to few\");\n\t  }\n\t}","commit_id":"929eecd0c707bc443ec9d7ffca956520d13d9d04","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public Integer map(RefMetaDataTracker tracker, char ref, LocusContext context) {\n        Map<Character, Integer> midp = new HashMap<Character, Integer>();\n        midp.put('A', Integer.MAX_VALUE);\n        midp.put('C', Integer.MAX_VALUE);\n        midp.put('G', Integer.MAX_VALUE);\n        midp.put('T', Integer.MAX_VALUE);\n\n        // First, exclude DBSNP Sites\n        for ( ReferenceOrderedDatum datum : tracker.getAllRods() )\n        {\n            if ( datum != null )\n            {\n                if ( datum instanceof rodDbSNP) {\n                    // we're at a dbsnp site... move along... nothing to see here... \n                    return -1;\n                }\n            }\n        }\n\n        char upRef = Character.toUpperCase(ref);\n\n        // TODO: should we be able to call mutations at bases where ref is N?\n        if (upRef == 'N') { return -1; }\n        \n        List<SAMRecord> reads = context.getReads();\n\n        LocusReadPile tumorReadPile = new LocusReadPile(ref);\n        LocusReadPile normalReadPile = new LocusReadPile(ref);\n\n        for ( int i = 0; i < reads.size(); i++ )\n        {\n            SAMRecord read = reads.get(i);\n\n            if (read.getNotPrimaryAlignmentFlag() ||\n                read.getDuplicateReadFlag() ||\n                read.getReadUnmappedFlag() ||\n                read.getMappingQuality() <= 0\n\n               || (read.getReadPairedFlag() && (!read.getProperPairFlag() || read.getInferredInsertSize() >= MAX_INSERT_SIZE))\n                    ) {\n                continue;\n            }\n\n            String rg = (String) read.getAttribute(\"RG\");\n            String sample = read.getHeader().getReadGroup(rg).getSample();\n\n            int offset = context.getOffsets().get(i);\n\n            char base = read.getReadString().charAt(offset);\n            if (base == 'N' || base == 'n') { continue; }\n\n\n            // TODO: build a pile of reads and offsets, then pass that into a\n            // constructor for the normalGL class\n            // that way, we can build a different pile of reads later on and extract the genotype\n            if (normalSampleName.equals(sample)) {\n                normalReadPile.add(read, offset);\n\n            } else if (tumorSampleName.equals(sample)) {\n                tumorReadPile.add(read, offset);\n\n\n                int midDist = Math.abs((int)(read.getReadLength() / 2) - offset);\n                if (midDist < midp.get(base)) { midp.put(base, midDist); }\n\n            } else {\n                throw new RuntimeException(\"Unknown Sample Name: \" + sample);\n            }\n        }\n\n        // pretest: if the sum of the quality scores for all non-ref alleles < 60, just quit looking now\n        if (tumorReadPile.qualitySums.getOtherQualities(ref) < MIN_MUTANT_SUM_PRETEST) {\n            return -1;\n        }\n\n\n        // Test each of the poosible alternate alleles\n\n        for (char altAllele : new char[]{'A','C','G','T'}) {\n            if (altAllele == upRef) { continue; }\n\n\n            // (i) either an adjusted quality score sum in the tumor for the mutant base must be\n            //     at least 100 or the LOD score for mutant:ref + mutant:mutant vs ref:ref must\n            //     be at least 6.3;\n            int mutantSum = tumorReadPile.qualitySums.get(altAllele);\n            int refSum = tumorReadPile.qualitySums.get(ref);\n\n            if (tumorReadPile.getAltVsRef(altAllele) >= TUMOR_LOD_THRESHOLD\n//                    ||\n//                (mutantSum >= MIN_MUTANT_SUM && (float)mutantSum / (float) refSum >= 0.05f)\n                ) {\n                // yep -- just fall through... easier to think about this way!\n            } else {\n                continue;\n            }\n\n            // make sure we've seen at least 1 obs of the alternate allele within 20bp of the read-middle\n            boolean failedMidpointCheck = midp.get(altAllele) > 20;\n//            if (failedMidpointCheck) {\n//                out.println(\"Rejecting due to midpoint check!\");\n//                return 0;\n//            }\n\n\n            // do a MSA to figure out if the alternate reads comes from a cluster of reads with more\n            // than one alternate allele (hints at being an alignment artifact)\n            ReferenceSequence refSeq;\n            // TODO: don't hardcode.  Make this the max read length in the pile \n            long refStart = context.getLocation().getStart() - 100;\n            //tumorReadPile.offsets.get(0);\n            long refStop = context.getLocation().getStart() + 100;\n            try {\n                IndexedFastaSequenceFile seqFile = new IndexedFastaSequenceFile(getToolkit().getArguments().referenceFile);\n                refSeq = seqFile.getSubsequenceAt(context.getContig(),refStart, refStop);\n\n            } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n            }\n\n//            System.out.println(\"TESTING \" + context.getContig() + \":\" + context.getPosition()); \n            LocusReadPile t2 = filterHighMismatchScoreReads(tumorReadPile, StringUtil.bytesToString(refSeq.getBases()), refStart);\n\n            // TEST the LOD score again!\n            // TODO: extract this since we'll do it multiple times...\n\n            // (i) either an adjusted quality score sum in the tumor for the mutant base must be\n            //     at least 100 or the LOD score for mutant:ref + mutant:mutant vs ref:ref must\n            //     be at least 6.3;\n            double tumorLod = t2.getAltVsRef(altAllele);\n            if (t2.qualitySums.get(altAllele) < MIN_MUTANT_SUM && tumorLod < TUMOR_LOD_THRESHOLD) {\n                if (OUTPUT_FAILURES) {\n                    System.out.println(\"FAILED \" + context.getContig() + \":\" + context.getPosition() + \" due to MAX MM QSCORE TEST.\" +\n                            \" LOD was \" + tumorReadPile.getAltVsRef(altAllele) +\n                            \" LOD is now \" + t2.getAltVsRef(altAllele) +\n                            \" QSUM was \" + tumorReadPile.qualitySums.get(altAllele) +\n                            \" QSUM is now \" + t2.qualitySums.get(altAllele));\n                }\n                continue;\n            }\n\n            // TODO: using the original pile here since often these artifacts will be supported\n            // by those reads that get thrown out!  Maybe that means we don't need the noise filter...\n            boolean shouldDisalign =\n                    disaligner(context.getPosition(), tumorReadPile, StringUtil.bytesToString(refSeq.getBases()), refStart);\n\n            if (shouldDisalign) {\n                if (OUTPUT_FAILURES) {\n                    System.out.println(\"FAILED \" + context.getContig() + \":\" + context.getPosition() + \" due to DISALIGNMENT TEST.\");\n                }\n                continue;\n            }\n\n\n\n\n\n\n            // (ii) the quality score sum for the mutant base in the normal must be < 50 and the\n            //      LOD score for ref:ref vs mutant:ref + mutant:mutant must be at least 2.3.\n            double normalLod = normalReadPile.getRefVsAlt(altAllele);\n            if ( normalReadPile.qualitySums.get(altAllele) > 50 || normalLod < NORMAL_LOD_THRESHOLD) {\n                continue;\n            }\n\n            // if we're still here... we've got a somatic mutation!  Output the results\n            // and stop looking for mutants!\n            if (bedOutput) {\n                out.println(\n                context.getContig() + \"\\t\" +\n                        context.getPosition() + \"\\t\" +\n                        context.getPosition() + \"\\t\" +\n                        \"TScore:\" + tumorLod +\n                        \"__TRefSum: \" + tumorReadPile.qualitySums.get(ref) +\n                        \"__TAltSum: \" + tumorReadPile.qualitySums.get(altAllele) +\n                        \"__NScore:\" + normalLod +\n                        \"__NRefSum: \" + normalReadPile.qualitySums.get(ref) +\n                        \"__NAltSum: \" + normalReadPile.qualitySums.get(altAllele) +\n                        \"__MIDP: \" + midp.get(altAllele) + \n                        (failedMidpointCheck?\"__FAILED-MPCHECK\":\"\")\n                );\n\n            } else {\n                out.println(context.getLocation() + \" \" + upRef + \" \" + altAllele +\n                \" TScore:\" + tumorLod +\n                \" TRefSum: \" + tumorReadPile.qualitySums.get(ref) +\n                \" TAltSum: \" + tumorReadPile.qualitySums.get(altAllele) +\n                \" NScore:\" + normalLod +\n                \" NRefSum: \" + normalReadPile.qualitySums.get(ref) +\n                \" NAltSum: \" + normalReadPile.qualitySums.get(altAllele) + \" \" +\n                        tumorReadPile.getLocusBases().toString() + \" \" +\n                        normalReadPile.getLocusBases().toString()\n                        );\n            }\n\n\n            return 1;\n\n\n        }\n\n        return -1;\n    }","id":6477,"modified_method":"public Integer map(RefMetaDataTracker tracker, char ref, LocusContext context) {\n        Map<Character, Integer> midp = new HashMap<Character, Integer>();\n        midp.put('A', Integer.MAX_VALUE);\n        midp.put('C', Integer.MAX_VALUE);\n        midp.put('G', Integer.MAX_VALUE);\n        midp.put('T', Integer.MAX_VALUE);\n\n        // First, exclude DBSNP Sites\n        for ( ReferenceOrderedDatum datum : tracker.getAllRods() )\n        {\n            if ( datum != null )\n            {\n                if ( datum instanceof rodDbSNP) {\n                    // we're at a dbsnp site... move along... nothing to see here... \n                    return -1;\n                }\n            }\n        }\n\n        char upRef = Character.toUpperCase(ref);\n\n        // TODO: should we be able to call mutations at bases where ref is N?\n        if (upRef == 'N') { return -1; }\n        \n        List<SAMRecord> reads = context.getReads();\n\n        LocusReadPile tumorReadPile = new LocusReadPile(ref);\n        LocusReadPile normalReadPile = new LocusReadPile(ref);\n\n        for ( int i = 0; i < reads.size(); i++ )\n        {\n            SAMRecord read = reads.get(i);\n\n            if (read.getNotPrimaryAlignmentFlag() ||\n                read.getDuplicateReadFlag() ||\n                read.getReadUnmappedFlag() ||\n                read.getMappingQuality() <= 0\n\n               || (read.getReadPairedFlag() && (!read.getProperPairFlag() || read.getInferredInsertSize() >= MAX_INSERT_SIZE))\n                    ) {\n                continue;\n            }\n\n            String rg = (String) read.getAttribute(\"RG\");\n            String sample = read.getHeader().getReadGroup(rg).getSample();\n\n            int offset = context.getOffsets().get(i);\n\n            char base = read.getReadString().charAt(offset);\n            if (base == 'N' || base == 'n') { continue; }\n\n\n            // TODO: build a pile of reads and offsets, then pass that into a\n            // constructor for the normalGL class\n            // that way, we can build a different pile of reads later on and extract the genotype\n            if (normalSampleName.equals(sample)) {\n                normalReadPile.add(read, offset);\n\n            } else if (tumorSampleName.equals(sample)) {\n                tumorReadPile.add(read, offset);\n\n\n                int midDist = Math.abs((int)(read.getReadLength() / 2) - offset);\n                if (midDist < midp.get(base)) { midp.put(base, midDist); }\n\n            } else {\n                throw new RuntimeException(\"Unknown Sample Name: \" + sample);\n            }\n        }\n\n        // pretest: if the sum of the quality scores for all non-ref alleles < 60, just quit looking now\n        if (tumorReadPile.qualitySums.getOtherQualities(ref) < MIN_MUTANT_SUM_PRETEST) {\n            return -1;\n        }\n\n\n        // Test each of the poosible alternate alleles\n\n        for (char altAllele : new char[]{'A','C','G','T'}) {\n            if (altAllele == upRef) { continue; }\n\n\n            // (i) either an adjusted quality score sum in the tumor for the mutant base must be\n            //     at least 100 or the LOD score for mutant:ref + mutant:mutant vs ref:ref must\n            //     be at least 6.3;\n            int mutantSum = tumorReadPile.qualitySums.get(altAllele);\n            int refSum = tumorReadPile.qualitySums.get(ref);\n\n            if (tumorReadPile.getAltVsRef(altAllele) >= TUMOR_LOD_THRESHOLD\n//                    ||\n//                (mutantSum >= MIN_MUTANT_SUM && (float)mutantSum / (float) refSum >= 0.05f)\n                ) {\n                // yep -- just fall through... easier to think about this way!\n            } else {\n                continue;\n            }\n\n            // make sure we've seen at least 1 obs of the alternate allele within 20bp of the read-middle\n            boolean failedMidpointCheck = midp.get(altAllele) > 20;\n//            if (failedMidpointCheck) {\n//                out.println(\"Rejecting due to midpoint check!\");\n//                return 0;\n//            }\n\n\n            // do a MSA to figure out if the alternate reads comes from a cluster of reads with more\n            // than one alternate allele (hints at being an alignment artifact)\n            ReferenceSequence refSeq;\n            // TODO: don't hardcode.  Make this the max read length in the pile \n            long refStart = context.getLocation().getStart() - 150;\n            //tumorReadPile.offsets.get(0);\n            long refStop = context.getLocation().getStart() + 150;\n            try {\n                IndexedFastaSequenceFile seqFile = new IndexedFastaSequenceFile(getToolkit().getArguments().referenceFile);\n                refSeq = seqFile.getSubsequenceAt(context.getContig(),refStart, refStop);\n\n            } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n            }\n\n//            System.out.println(\"TESTING \" + context.getContig() + \":\" + context.getPosition()); \n            LocusReadPile t2 = filterHighMismatchScoreReads(tumorReadPile, StringUtil.bytesToString(refSeq.getBases()), refStart);\n\n            // TEST the LOD score again!\n            // TODO: extract this since we'll do it multiple times...\n\n            // (i) either an adjusted quality score sum in the tumor for the mutant base must be\n            //     at least 100 or the LOD score for mutant:ref + mutant:mutant vs ref:ref must\n            //     be at least 6.3;\n            double tumorLod = t2.getAltVsRef(altAllele);\n            if (mode.equals(\"full\") && t2.qualitySums.get(altAllele) < MIN_MUTANT_SUM && tumorLod < TUMOR_LOD_THRESHOLD) {\n                if (OUTPUT_FAILURES) {\n\n                    String msg = \"FAILED  due to MAX MM QSCORE TEST.\" +\n                            \" LOD was \" + tumorReadPile.getAltVsRef(altAllele) +\n                            \" LOD is now \" + t2.getAltVsRef(altAllele) +\n                            \" QSUM was \" + tumorReadPile.qualitySums.get(altAllele) +\n                            \" QSUM is now \" + t2.qualitySums.get(altAllele);\n\n                    System.out.println(\n                            context.getContig() + \"\\t\" +\n                                    context.getPosition() + \"\\t\" +\n                                    context.getPosition() + \"\\t\"\n                            + msg.replace(' ','_')\n                            );\n                }\n                continue;\n            }\n\n            // TODO: using the original pile here since often these artifacts will be supported\n            // by those reads that get thrown out!  Maybe that means we don't need the noise filter...\n            boolean shouldDisalign =\n                    disaligner(context.getPosition(), tumorReadPile, StringUtil.bytesToString(refSeq.getBases()), refStart);\n\n            if (mode.equals(\"full\") && shouldDisalign) {\n                if (OUTPUT_FAILURES) {\n                    String msg = \"FAILED due to DISALIGNMENT TEST.\";\n\n                    System.out.println(\n                            context.getContig() + \"\\t\" +\n                                    context.getPosition() + \"\\t\" +\n                                    context.getPosition() + \"\\t\"\n                            + msg.replace(' ','_')\n                            );\n\n                }\n                continue;\n            }\n\n\n\n\n\n\n            // (ii) the quality score sum for the mutant base in the normal must be < 50 and the\n            //      LOD score for ref:ref vs mutant:ref + mutant:mutant must be at least 2.3.\n            double normalLod = normalReadPile.getRefVsAlt(altAllele);\n            if ( normalReadPile.qualitySums.get(altAllele) > 50 || normalLod < NORMAL_LOD_THRESHOLD) {\n                continue;\n            }\n\n            // if we're still here... we've got a somatic mutation!  Output the results\n            // and stop looking for mutants!\n            String msg =\n                        (failedMidpointCheck?\"__FAILED-MPCHECK\":\"\") +\n                        \"TScore:\" + tumorLod +\n                        \"__TRefSum: \" + tumorReadPile.qualitySums.get(ref) +\n                        \"__TAltSum: \" + tumorReadPile.qualitySums.get(altAllele) +\n                        \"__NScore:\" + normalLod +\n                        \"__NRefSum: \" + normalReadPile.qualitySums.get(ref) +\n                        \"__NAltSum: \" + normalReadPile.qualitySums.get(altAllele) +\n                        \"__MIDP: \" + midp.get(altAllele);\n\n            System.out.println(\n                    context.getContig() + \"\\t\" +\n                            context.getPosition() + \"\\t\" +\n                            context.getPosition() + \"\\t\"\n                    + msg.replace(' ','_')\n                    );\n\n\n\n\n            return 1;\n\n\n        }\n\n        return -1;\n    }","commit_id":"673205ed5fe93f907b2e3e7e77fd8f9d006b4bfb","url":"https://github.com/broadgsa/gatk"},{"original_method":"public List<TimeExpression> extractTimeExpressions(CoreMap annotation, String docDateStr)\n  {\n    List<CoreMap> mergedNumbers = NumberNormalizer.findAndMergeNumbers(annotation);\n    annotation.set(CoreAnnotations.NumerizedTokensAnnotation.class, mergedNumbers);\n\n    // TODO: docDate may not have century....\n\n    SUTime.Time docDate = null;\n    try {\n      docDate = SUTime.parseDateTime(docDateStr);\n    } catch (Exception e) {\n      throw new RuntimeException(\"Could not parse date string: [\" + docDateStr + \"]\", e);\n    }\n    List<? extends MatchedExpression> matchedExpressions = expressionExtractor.extractExpressions(annotation);\n    List<TimeExpression> timeExpressions = new ArrayList<TimeExpression>(matchedExpressions.size());\n    for (MatchedExpression expr:matchedExpressions) {\n      if (expr instanceof TimeExpression) {\n        timeExpressions.add((TimeExpression) expr);\n      } else {\n        timeExpressions.add(new TimeExpression(expr));\n      }\n    }\n    // Some resolving is done even if docDate null...\n    if ( /*docDate != null && */ timeExpressions != null) {\n      resolveTimeExpressions(annotation, timeExpressions, docDate);\n    }\n    if (options.restrictToTimex3) {\n      // Keep only TIMEX3 compatible timeExpressions\n      List<TimeExpression> kept = new ArrayList<TimeExpression>(timeExpressions.size());\n      for (TimeExpression te:timeExpressions) {\n        if (te.getTemporal() != null && te.getTemporal().getTimexValue() != null) {\n          kept.add(te);\n        } else {\n          List<? extends CoreMap> children = te.getAnnotation().get(TimeExpression.ChildrenAnnotation.class);\n          if (children != null) {\n            for (CoreMap child:children) {\n              TimeExpression childTe = child.get(TimeExpression.Annotation.class);\n              if (childTe != null) {\n                resolveTimeExpression(annotation, childTe, docDate);\n                if (childTe.getTemporal() != null && childTe.getTemporal().getTimexValue() != null) {\n                  kept.add(childTe);\n                }\n              }\n            }\n          }\n        }\n      }\n      timeExpressions = kept;\n    }\n\n    // Add back nested time expressions for ranges....\n    // For now only one level of nesting...\n    if (options.includeNested) {\n      List<TimeExpression> nestedTimeExpressions = new ArrayList<TimeExpression>();\n      for (TimeExpression te:timeExpressions) {\n        if (te.isIncludeNested())  {\n          List<? extends CoreMap> children = te.getAnnotation().get(TimeExpression.ChildrenAnnotation.class);\n          if (children != null) {\n            for (CoreMap child:children) {\n              TimeExpression childTe = child.get(TimeExpression.Annotation.class);\n              if (childTe != null) {\n                nestedTimeExpressions.add(childTe);\n              }\n            }\n          }\n        }\n      }\n      resolveTimeExpressions(annotation, nestedTimeExpressions, docDate);\n      timeExpressions.addAll(nestedTimeExpressions);\n    }\n    Collections.sort(timeExpressions, MatchedExpression.EXPR_TOKEN_OFFSETS_NESTED_FIRST_COMPARATOR);\n    // Some resolving is done even if docDate null...\n    if ( /*docDate != null && */ timeExpressions != null) {\n      resolveTimeExpressions(annotation, timeExpressions, docDate);\n    }\n    return timeExpressions;\n  }","id":6478,"modified_method":"public List<TimeExpression> extractTimeExpressions(CoreMap annotation, String docDateStr)\n  {\n    List<CoreMap> mergedNumbers = NumberNormalizer.findAndMergeNumbers(annotation);\n    annotation.set(CoreAnnotations.NumerizedTokensAnnotation.class, mergedNumbers);\n\n    // TODO: docDate may not have century....\n\n    SUTime.Time docDate; // = null;  // NO need, as throws RuntimeException if not initialized.\n    try {\n      docDate = SUTime.parseDateTime(docDateStr);\n    } catch (Exception e) {\n      throw new RuntimeException(\"Could not parse date string: [\" + docDateStr + \"]\", e);\n    }\n    List<? extends MatchedExpression> matchedExpressions = expressionExtractor.extractExpressions(annotation);\n    List<TimeExpression> timeExpressions = new ArrayList<TimeExpression>(matchedExpressions.size());\n    for (MatchedExpression expr : matchedExpressions) {\n      if (expr instanceof TimeExpression) {\n        timeExpressions.add((TimeExpression) expr);\n      } else {\n        timeExpressions.add(new TimeExpression(expr));\n      }\n    }\n    // Some resolving is done even if docDate null...\n    // if ( /*docDate != null && */ timeExpressions != null) {\n    resolveTimeExpressions(annotation, timeExpressions, docDate);\n    // }\n    if (options.restrictToTimex3) {\n      // Keep only TIMEX3 compatible timeExpressions\n      List<TimeExpression> kept = new ArrayList<TimeExpression>(timeExpressions.size());\n      for (TimeExpression te:timeExpressions) {\n        if (te.getTemporal() != null && te.getTemporal().getTimexValue() != null) {\n          kept.add(te);\n        } else {\n          List<? extends CoreMap> children = te.getAnnotation().get(TimeExpression.ChildrenAnnotation.class);\n          if (children != null) {\n            for (CoreMap child:children) {\n              TimeExpression childTe = child.get(TimeExpression.Annotation.class);\n              if (childTe != null) {\n                resolveTimeExpression(annotation, childTe, docDate);\n                if (childTe.getTemporal() != null && childTe.getTemporal().getTimexValue() != null) {\n                  kept.add(childTe);\n                }\n              }\n            }\n          }\n        }\n      }\n      timeExpressions = kept;\n    }\n\n    // Add back nested time expressions for ranges....\n    // For now only one level of nesting...\n    if (options.includeNested) {\n      List<TimeExpression> nestedTimeExpressions = new ArrayList<TimeExpression>();\n      for (TimeExpression te:timeExpressions) {\n        if (te.isIncludeNested())  {\n          List<? extends CoreMap> children = te.getAnnotation().get(TimeExpression.ChildrenAnnotation.class);\n          if (children != null) {\n            for (CoreMap child:children) {\n              TimeExpression childTe = child.get(TimeExpression.Annotation.class);\n              if (childTe != null) {\n                nestedTimeExpressions.add(childTe);\n              }\n            }\n          }\n        }\n      }\n      resolveTimeExpressions(annotation, nestedTimeExpressions, docDate);\n      timeExpressions.addAll(nestedTimeExpressions);\n    }\n    Collections.sort(timeExpressions, MatchedExpression.EXPR_TOKEN_OFFSETS_NESTED_FIRST_COMPARATOR);\n    // Some resolving is done even if docDate null...\n    // if ( /*docDate != null && */ timeExpressions != null) {\n    resolveTimeExpressions(annotation, timeExpressions, docDate);\n    // }\n    return timeExpressions;\n  }","commit_id":"890e5e01a7fd8bad33753c590033a15f9793c566","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private List<CoreMap> toCoreMaps(CoreMap annotation, List<TimeExpression> timeExpressions, SUTime.TimeIndex timeIndex)\n  {\n    if (timeExpressions == null) return null;\n    List<CoreMap> coreMaps = new ArrayList<CoreMap>(timeExpressions.size());\n    for (TimeExpression te:timeExpressions) {\n      CoreMap cm = te.getAnnotation();\n      SUTime.Temporal temporal = te.getTemporal();\n      if (temporal != null) {\n        String origText = annotation.get(CoreAnnotations.TextAnnotation.class);\n        String text = cm.get(CoreAnnotations.TextAnnotation.class);\n        if (origText != null) {\n          // Make sure the text is from original (and not from concatenated tokens)\n          ChunkAnnotationUtils.annotateChunkText(cm, annotation);\n          text = cm.get(CoreAnnotations.TextAnnotation.class);\n        }\n        Map<String,String> timexAttributes;\n        try {\n          timexAttributes = temporal.getTimexAttributes(timeIndex);\n          if (options.includeRange) {\n            SUTime.Temporal rangeTemporal = temporal.getRange();\n            if (rangeTemporal != null) {\n              timexAttributes.put(\"range\", rangeTemporal.toString());\n            }\n          }\n        } catch (Exception e) {\n          logger.log(Level.WARNING, \"Failed to get attributes from \" + text + \", timeIndex \" + timeIndex, e);\n          continue;\n        }\n        Timex timex;\n        try {\n          timex = Timex.fromMap(text, timexAttributes);\n        } catch (Exception e) {\n          logger.log(Level.WARNING, \"Failed to process \" + text + \" with attributes \" + timexAttributes, e);\n          continue;\n        }\n        cm.set(TimeAnnotations.TimexAnnotation.class, timex);\n        if (timex != null) {\n          coreMaps.add(cm);\n        } else {\n          logger.warning(\"No timex expression for: \" + text);\n        }\n      }\n    }\n    return coreMaps;\n  }","id":6479,"modified_method":"private List<CoreMap> toCoreMaps(CoreMap annotation, List<TimeExpression> timeExpressions, SUTime.TimeIndex timeIndex)\n  {\n    if (timeExpressions == null) return null;\n    List<CoreMap> coreMaps = new ArrayList<CoreMap>(timeExpressions.size());\n    for (TimeExpression te:timeExpressions) {\n      CoreMap cm = te.getAnnotation();\n      SUTime.Temporal temporal = te.getTemporal();\n      if (temporal != null) {\n        String origText = annotation.get(CoreAnnotations.TextAnnotation.class);\n        String text = cm.get(CoreAnnotations.TextAnnotation.class);\n        if (origText != null) {\n          // Make sure the text is from original (and not from concatenated tokens)\n          ChunkAnnotationUtils.annotateChunkText(cm, annotation);\n          text = cm.get(CoreAnnotations.TextAnnotation.class);\n        }\n        Map<String,String> timexAttributes;\n        try {\n          timexAttributes = temporal.getTimexAttributes(timeIndex);\n          if (options.includeRange) {\n            SUTime.Temporal rangeTemporal = temporal.getRange();\n            if (rangeTemporal != null) {\n              timexAttributes.put(\"range\", rangeTemporal.toString());\n            }\n          }\n        } catch (Exception e) {\n          logger.log(Level.WARNING, \"Failed to get attributes from \" + text + \", timeIndex \" + timeIndex, e);\n          continue;\n        }\n        Timex timex = null;\n        try {\n          timex = Timex.fromMap(text, timexAttributes);\n        } catch (Exception e) {\n          logger.log(Level.WARNING, \"Failed to process \" + text + \" with attributes \" + timexAttributes, e);\n          continue;\n        }\n        cm.set(TimeAnnotations.TimexAnnotation.class, timex);\n        if (timex != null) {\n          coreMaps.add(cm);\n        } else {\n          logger.warning(\"No timex expression for: \" + text);\n        }\n      }\n    }\n    return coreMaps;\n  }","commit_id":"890e5e01a7fd8bad33753c590033a15f9793c566","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private List<CoreMap> toCoreMaps(CoreMap annotation, List<TimeExpression> timeExpressions, SUTime.TimeIndex timeIndex)\n  {\n    if (timeExpressions == null) return null;\n    List<CoreMap> coreMaps = new ArrayList<CoreMap>(timeExpressions.size());\n    for (TimeExpression te:timeExpressions) {\n      CoreMap cm = te.getAnnotation();\n      SUTime.Temporal temporal = te.getTemporal();\n      if (temporal != null) {\n        String origText = annotation.get(CoreAnnotations.TextAnnotation.class);\n        String text = cm.get(CoreAnnotations.TextAnnotation.class);\n        if (origText != null) {\n          // Make sure the text is from original (and not from concatenated tokens)\n          ChunkAnnotationUtils.annotateChunkText(cm, annotation);\n          text = cm.get(CoreAnnotations.TextAnnotation.class);\n        }\n        Map<String,String> timexAttributes;\n        try {\n          timexAttributes = temporal.getTimexAttributes(timeIndex);\n          if (options.includeRange) {\n            SUTime.Temporal rangeTemporal = temporal.getRange();\n            if (rangeTemporal != null) {\n              timexAttributes.put(\"range\", rangeTemporal.toString());\n            }\n          }\n        } catch (Exception e) {\n          logger.log(Level.WARNING, \"Failed to get attributes from \" + text + \", timeIndex \" + timeIndex, e);\n          continue;\n        }\n        Timex timex;\n        try {\n          timex = Timex.fromMap(text, timexAttributes);\n        } catch (Exception e) {\n          logger.log(Level.WARNING, \"Failed to process \" + text + \" with attributes \" + timexAttributes, e);\n          continue;\n        }\n        cm.set(TimeAnnotations.TimexAnnotation.class, timex);\n        if (timex != null) {\n          coreMaps.add(cm);\n        } else {\n          logger.warning(\"No timex expression for: \" + text);\n        }\n      }\n    }\n    return coreMaps;\n  }","id":6480,"modified_method":"private List<CoreMap> toCoreMaps(CoreMap annotation, List<TimeExpression> timeExpressions, SUTime.TimeIndex timeIndex)\n  {\n    if (timeExpressions == null) return null;\n    List<CoreMap> coreMaps = new ArrayList<CoreMap>(timeExpressions.size());\n    for (TimeExpression te:timeExpressions) {\n      CoreMap cm = te.getAnnotation();\n      SUTime.Temporal temporal = te.getTemporal();\n      if (temporal != null) {\n        String origText = annotation.get(CoreAnnotations.TextAnnotation.class);\n        String text = cm.get(CoreAnnotations.TextAnnotation.class);\n        if (origText != null) {\n          // Make sure the text is from original (and not from concatenated tokens)\n          ChunkAnnotationUtils.annotateChunkText(cm, annotation);\n          text = cm.get(CoreAnnotations.TextAnnotation.class);\n        }\n        Map<String,String> timexAttributes;\n        try {\n          timexAttributes = temporal.getTimexAttributes(timeIndex);\n          if (options.includeRange) {\n            SUTime.Temporal rangeTemporal = temporal.getRange();\n            if (rangeTemporal != null) {\n              timexAttributes.put(\"range\", rangeTemporal.toString());\n            }\n          }\n        } catch (Exception e) {\n          logger.log(Level.WARNING, \"Failed to get attributes from \" + text + \", timeIndex \" + timeIndex, e);\n          continue;\n        }\n        Timex timex = null;\n        try {\n          timex = Timex.fromMap(text, timexAttributes);\n        } catch (Exception e) {\n          logger.log(Level.WARNING, \"Failed to process \" + text + \" with attributes \" + timexAttributes, e);\n          continue;\n        }\n        cm.set(TimeAnnotations.TimexAnnotation.class, timex);\n        if (timex != null) {\n          coreMaps.add(cm);\n        } else {\n          logger.warning(\"No timex expression for: \" + text);\n        }\n      }\n    }\n    return coreMaps;\n  }","commit_id":"f6f980905fb94f66460cf0bf4d89ec96cbfa94e5","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public List<TimeExpression> extractTimeExpressions(CoreMap annotation, String docDateStr)\n  {\n    List<CoreMap> mergedNumbers = NumberNormalizer.findAndMergeNumbers(annotation);\n    annotation.set(CoreAnnotations.NumerizedTokensAnnotation.class, mergedNumbers);\n\n    // TODO: docDate may not have century....\n\n    SUTime.Time docDate = null;\n    try {\n      docDate = SUTime.parseDateTime(docDateStr);\n    } catch (Exception e) {\n      throw new RuntimeException(\"Could not parse date string: [\" + docDateStr + \"]\", e);\n    }\n    List<? extends MatchedExpression> matchedExpressions = expressionExtractor.extractExpressions(annotation);\n    List<TimeExpression> timeExpressions = new ArrayList<TimeExpression>(matchedExpressions.size());\n    for (MatchedExpression expr:matchedExpressions) {\n      if (expr instanceof TimeExpression) {\n        timeExpressions.add((TimeExpression) expr);\n      } else {\n        timeExpressions.add(new TimeExpression(expr));\n      }\n    }\n    // Some resolving is done even if docDate null...\n    if ( /*docDate != null && */ timeExpressions != null) {\n      resolveTimeExpressions(annotation, timeExpressions, docDate);\n    }\n    if (options.restrictToTimex3) {\n      // Keep only TIMEX3 compatible timeExpressions\n      List<TimeExpression> kept = new ArrayList<TimeExpression>(timeExpressions.size());\n      for (TimeExpression te:timeExpressions) {\n        if (te.getTemporal() != null && te.getTemporal().getTimexValue() != null) {\n          kept.add(te);\n        } else {\n          List<? extends CoreMap> children = te.getAnnotation().get(TimeExpression.ChildrenAnnotation.class);\n          if (children != null) {\n            for (CoreMap child:children) {\n              TimeExpression childTe = child.get(TimeExpression.Annotation.class);\n              if (childTe != null) {\n                resolveTimeExpression(annotation, childTe, docDate);\n                if (childTe.getTemporal() != null && childTe.getTemporal().getTimexValue() != null) {\n                  kept.add(childTe);\n                }\n              }\n            }\n          }\n        }\n      }\n      timeExpressions = kept;\n    }\n\n    // Add back nested time expressions for ranges....\n    // For now only one level of nesting...\n    if (options.includeNested) {\n      List<TimeExpression> nestedTimeExpressions = new ArrayList<TimeExpression>();\n      for (TimeExpression te:timeExpressions) {\n        if (te.isIncludeNested())  {\n          List<? extends CoreMap> children = te.getAnnotation().get(TimeExpression.ChildrenAnnotation.class);\n          if (children != null) {\n            for (CoreMap child:children) {\n              TimeExpression childTe = child.get(TimeExpression.Annotation.class);\n              if (childTe != null) {\n                nestedTimeExpressions.add(childTe);\n              }\n            }\n          }\n        }\n      }\n      resolveTimeExpressions(annotation, nestedTimeExpressions, docDate);\n      timeExpressions.addAll(nestedTimeExpressions);\n    }\n    Collections.sort(timeExpressions, MatchedExpression.EXPR_TOKEN_OFFSETS_NESTED_FIRST_COMPARATOR);\n    // Some resolving is done even if docDate null...\n    if ( /*docDate != null && */ timeExpressions != null) {\n      resolveTimeExpressions(annotation, timeExpressions, docDate);\n    }\n    return timeExpressions;\n  }","id":6481,"modified_method":"public List<TimeExpression> extractTimeExpressions(CoreMap annotation, String docDateStr)\n  {\n    List<CoreMap> mergedNumbers = NumberNormalizer.findAndMergeNumbers(annotation);\n    annotation.set(CoreAnnotations.NumerizedTokensAnnotation.class, mergedNumbers);\n\n    // TODO: docDate may not have century....\n\n    SUTime.Time docDate; // = null;  // NO need, as throws RuntimeException if not initialized.\n    try {\n      docDate = SUTime.parseDateTime(docDateStr);\n    } catch (Exception e) {\n      throw new RuntimeException(\"Could not parse date string: [\" + docDateStr + \"]\", e);\n    }\n    List<? extends MatchedExpression> matchedExpressions = expressionExtractor.extractExpressions(annotation);\n    List<TimeExpression> timeExpressions = new ArrayList<TimeExpression>(matchedExpressions.size());\n    for (MatchedExpression expr : matchedExpressions) {\n      if (expr instanceof TimeExpression) {\n        timeExpressions.add((TimeExpression) expr);\n      } else {\n        timeExpressions.add(new TimeExpression(expr));\n      }\n    }\n    // Some resolving is done even if docDate null...\n    // if ( /*docDate != null && */ timeExpressions != null) {\n    resolveTimeExpressions(annotation, timeExpressions, docDate);\n    // }\n    if (options.restrictToTimex3) {\n      // Keep only TIMEX3 compatible timeExpressions\n      List<TimeExpression> kept = new ArrayList<TimeExpression>(timeExpressions.size());\n      for (TimeExpression te:timeExpressions) {\n        if (te.getTemporal() != null && te.getTemporal().getTimexValue() != null) {\n          kept.add(te);\n        } else {\n          List<? extends CoreMap> children = te.getAnnotation().get(TimeExpression.ChildrenAnnotation.class);\n          if (children != null) {\n            for (CoreMap child:children) {\n              TimeExpression childTe = child.get(TimeExpression.Annotation.class);\n              if (childTe != null) {\n                resolveTimeExpression(annotation, childTe, docDate);\n                if (childTe.getTemporal() != null && childTe.getTemporal().getTimexValue() != null) {\n                  kept.add(childTe);\n                }\n              }\n            }\n          }\n        }\n      }\n      timeExpressions = kept;\n    }\n\n    // Add back nested time expressions for ranges....\n    // For now only one level of nesting...\n    if (options.includeNested) {\n      List<TimeExpression> nestedTimeExpressions = new ArrayList<TimeExpression>();\n      for (TimeExpression te:timeExpressions) {\n        if (te.isIncludeNested())  {\n          List<? extends CoreMap> children = te.getAnnotation().get(TimeExpression.ChildrenAnnotation.class);\n          if (children != null) {\n            for (CoreMap child:children) {\n              TimeExpression childTe = child.get(TimeExpression.Annotation.class);\n              if (childTe != null) {\n                nestedTimeExpressions.add(childTe);\n              }\n            }\n          }\n        }\n      }\n      resolveTimeExpressions(annotation, nestedTimeExpressions, docDate);\n      timeExpressions.addAll(nestedTimeExpressions);\n    }\n    Collections.sort(timeExpressions, MatchedExpression.EXPR_TOKEN_OFFSETS_NESTED_FIRST_COMPARATOR);\n    // Some resolving is done even if docDate null...\n    // if ( /*docDate != null && */ timeExpressions != null) {\n    resolveTimeExpressions(annotation, timeExpressions, docDate);\n    // }\n    return timeExpressions;\n  }","commit_id":"f6f980905fb94f66460cf0bf4d89ec96cbfa94e5","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public TimeAnnotator(String name, Properties props) {\n    timexExtractor = new TimeExpressionExtractorImpl(name, props);\n    this.quiet = false;\n  }","id":6482,"modified_method":"public TimeAnnotator(String name, Properties props) {\n    this(name, props, false);\n  }","commit_id":"a2cf40cecbd6accd175a399fc4c158abc27f1a1e","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Helper method for people not working from a complete Annotation.\n   * @return a list of CoreMap.  Each CoreMap represents a detected temporal expression.\n   */\n  public List<CoreMap> annotateSingleSentence(CoreMap sentence, String docDate, SUTime.TimeIndex timeIndex) {\n    CoreMap annotationCopy = NumberSequenceClassifier.alignSentence(sentence);\n    if (docDate.equals(\"\")) {\n      docDate = null;\n    }\n    return timexExtractor.extractTimeExpressionCoreMaps(annotationCopy, docDate, timeIndex);\n  }","id":6483,"modified_method":"/**\n   * Helper method for people not working from a complete Annotation.\n   * @return a list of CoreMap.  Each CoreMap represents a detected temporal expression.\n   */\n  public List<CoreMap> annotateSingleSentence(CoreMap sentence, String docDate, SUTime.TimeIndex timeIndex) {\n    CoreMap annotationCopy = NumberSequenceClassifier.alignSentence(sentence);\n    if (docDate.isEmpty()) {\n      docDate = null;\n    }\n    return timexExtractor.extractTimeExpressionCoreMaps(annotationCopy, docDate, timeIndex);\n  }","commit_id":"a2cf40cecbd6accd175a399fc4c158abc27f1a1e","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public List<CoreMap> extractTimeExpressionCoreMaps(CoreMap annotation, CoreMap docAnnotation) {\n    SUTime.TimeIndex timeIndex = null;\n    String docDate = null;\n    if (docAnnotation != null) {\n      timeIndex = docAnnotation.get(TimeExpression.TimeIndexAnnotation.class);\n      if (timeIndex == null) {\n        docAnnotation.set(TimeExpression.TimeIndexAnnotation.class, timeIndex = new SUTime.TimeIndex());\n      }\n      docDate = docAnnotation.get(CoreAnnotations.DocDateAnnotation.class);\n      if(docDate == null){\n        Calendar cal = docAnnotation.get(CoreAnnotations.CalendarAnnotation.class);\n        if(cal == null){\n          logger.log(Level.WARNING, \"No document date specified\");\n        } else {\n          SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd:hh:mm:ss\");\n          docDate = dateFormat.format(cal.getTime());\n        }\n      }\n    } else {\n      timeIndex = new SUTime.TimeIndex();\n    }\n    if (\"\".equals(docDate)) {\n      docDate = null;\n    }\n    if (timeIndex.docDate == null && docDate != null) {\n      try {\n        // TODO: have more robust parsing of document date?  docDate may not have century....\n        // TODO: if docDate didn't change, we can cache the parsing of the docDate and not repeat it for every sentence\n        timeIndex.docDate = SUTime.parseDateTime(docDate,true);\n      } catch (Exception e) {\n        throw new RuntimeException(\"Could not parse date string: [\" + docDate + \"]\", e);\n      }\n    }\n    String sectionDate = annotation.get(CoreAnnotations.SectionDateAnnotation.class);\n    String refDate = (sectionDate != null)? sectionDate:docDate;\n    return extractTimeExpressionCoreMaps(annotation, refDate, timeIndex);\n  }","id":6484,"modified_method":"@Override\n  public List<CoreMap> extractTimeExpressionCoreMaps(CoreMap annotation, CoreMap docAnnotation) {\n    SUTime.TimeIndex timeIndex; // initialized immediately below\n    String docDate = null;\n    if (docAnnotation != null) {\n      timeIndex = docAnnotation.get(TimeExpression.TimeIndexAnnotation.class);\n      if (timeIndex == null) {\n        docAnnotation.set(TimeExpression.TimeIndexAnnotation.class, timeIndex = new SUTime.TimeIndex());\n      }\n      docDate = docAnnotation.get(CoreAnnotations.DocDateAnnotation.class);\n      if(docDate == null){\n        Calendar cal = docAnnotation.get(CoreAnnotations.CalendarAnnotation.class);\n        if(cal == null){\n          logger.log(Level.WARNING, \"No document date specified\");\n        } else {\n          SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd:hh:mm:ss\");\n          docDate = dateFormat.format(cal.getTime());\n        }\n      }\n    } else {\n      timeIndex = new SUTime.TimeIndex();\n    }\n    if (\"\".equals(docDate)) {\n      docDate = null;\n    }\n    if (timeIndex.docDate == null && docDate != null) {\n      try {\n        // TODO: have more robust parsing of document date?  docDate may not have century....\n        // TODO: if docDate didn't change, we can cache the parsing of the docDate and not repeat it for every sentence\n        timeIndex.docDate = SUTime.parseDateTime(docDate,true);\n      } catch (Exception e) {\n        throw new RuntimeException(\"Could not parse date string: [\" + docDate + \"]\", e);\n      }\n    }\n    String sectionDate = annotation.get(CoreAnnotations.SectionDateAnnotation.class);\n    String refDate = (sectionDate != null) ? sectionDate: docDate;\n    return extractTimeExpressionCoreMaps(annotation, refDate, timeIndex);\n  }","commit_id":"a2cf40cecbd6accd175a399fc4c158abc27f1a1e","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private List<CoreMap> toCoreMaps(CoreMap annotation, List<TimeExpression> timeExpressions, SUTime.TimeIndex timeIndex)\n  {\n    if (timeExpressions == null) return null;\n    List<CoreMap> coreMaps = new ArrayList<CoreMap>(timeExpressions.size());\n    for (TimeExpression te:timeExpressions) {\n      CoreMap cm = te.getAnnotation();\n      SUTime.Temporal temporal = te.getTemporal();\n      if (temporal != null) {\n        String origText = annotation.get(CoreAnnotations.TextAnnotation.class);\n        String text = cm.get(CoreAnnotations.TextAnnotation.class);\n        if (origText != null) {\n          // Make sure the text is from original (and not from concatenated tokens)\n          ChunkAnnotationUtils.annotateChunkText(cm, annotation);\n          text = cm.get(CoreAnnotations.TextAnnotation.class);\n        }\n        Map<String,String> timexAttributes;\n        try {\n          timexAttributes = temporal.getTimexAttributes(timeIndex);\n          if (options.includeRange) {\n            SUTime.Temporal rangeTemporal = temporal.getRange();\n            if (rangeTemporal != null) {\n              timexAttributes.put(\"range\", rangeTemporal.toString());\n            }\n          }\n        } catch (Exception e) {\n          logger.log(Level.WARNING, \"Failed to get attributes from \" + text + \", timeIndex \" + timeIndex, e);\n          continue;\n        }\n        Timex timex;\n        try {\n          timex = Timex.fromMap(text, timexAttributes);\n        } catch (Exception e) {\n          logger.log(Level.WARNING, \"Failed to process timex \" + text + \" with attributes \" + timexAttributes, e);\n          continue;\n        }\n        assert timex != null;  // Timex.fromMap never returns null and if it exceptions, we've already done a continue\n        cm.set(TimeAnnotations.TimexAnnotation.class, timex);\n        coreMaps.add(cm);\n      }\n    }\n    return coreMaps;\n  }","id":6485,"modified_method":"private List<CoreMap> toCoreMaps(CoreMap annotation, List<TimeExpression> timeExpressions, SUTime.TimeIndex timeIndex)\n  {\n    if (timeExpressions == null) return null;\n    List<CoreMap> coreMaps = new ArrayList<>(timeExpressions.size());\n    for (TimeExpression te:timeExpressions) {\n      CoreMap cm = te.getAnnotation();\n      SUTime.Temporal temporal = te.getTemporal();\n      if (temporal != null) {\n        String origText = annotation.get(CoreAnnotations.TextAnnotation.class);\n        String text = cm.get(CoreAnnotations.TextAnnotation.class);\n        if (origText != null) {\n          // Make sure the text is from original (and not from concatenated tokens)\n          ChunkAnnotationUtils.annotateChunkText(cm, annotation);\n          text = cm.get(CoreAnnotations.TextAnnotation.class);\n        }\n        Map<String,String> timexAttributes;\n        try {\n          timexAttributes = temporal.getTimexAttributes(timeIndex);\n          if (options.includeRange) {\n            SUTime.Temporal rangeTemporal = temporal.getRange();\n            if (rangeTemporal != null) {\n              timexAttributes.put(\"range\", rangeTemporal.toString());\n            }\n          }\n        } catch (Exception e) {\n          logger.log(Level.WARNING, \"Failed to get attributes from \" + text + \", timeIndex \" + timeIndex, e);\n          continue;\n        }\n        Timex timex;\n        try {\n          timex = Timex.fromMap(text, timexAttributes);\n        } catch (Exception e) {\n          logger.log(Level.WARNING, \"Failed to process timex \" + text + \" with attributes \" + timexAttributes, e);\n          continue;\n        }\n        assert timex != null;  // Timex.fromMap never returns null and if it exceptions, we've already done a continue\n        cm.set(TimeAnnotations.TimexAnnotation.class, timex);\n        coreMaps.add(cm);\n      }\n    }\n    return coreMaps;\n  }","commit_id":"a2cf40cecbd6accd175a399fc4c158abc27f1a1e","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public List<TimeExpression> extractTimeExpressions(CoreMap annotation, SUTime.Time refDate, SUTime.TimeIndex timeIndex)\n  {\n    if (!annotation.containsKey(CoreAnnotations.NumerizedTokensAnnotation.class)) {\n      List<CoreMap> mergedNumbers = NumberNormalizer.findAndMergeNumbers(annotation);\n      annotation.set(CoreAnnotations.NumerizedTokensAnnotation.class, mergedNumbers);\n    }\n\n    List<? extends MatchedExpression> matchedExpressions = expressionExtractor.extractExpressions(annotation);\n    List<TimeExpression> timeExpressions = new ArrayList<TimeExpression>(matchedExpressions.size());\n    for (MatchedExpression expr : matchedExpressions) {\n      // Make sure we have the correct type (instead of just MatchedExpression)\n      //timeExpressions.add(TimeExpression.TimeExpressionConverter.apply(expr));\n\n      // TODO: Fix the extraction pipeline so it creates TimeExpression instead of MatchedExpressions\n      // For now, grab the time expression from the annotation (this is good, so we don't have duplicate copies)\n      TimeExpression annoTe = expr.getAnnotation().get( TimeExpression.Annotation.class );\n      if (annoTe != null) {\n        timeExpressions.add(annoTe);\n      }\n    }\n    // We cache the document date in the timeIndex\n    if (timeIndex.docDate == null) {\n      if (refDate != null) timeIndex.docDate = refDate;\n      else if (options.searchForDocDate) {\n        // there was no document date but option was set to look for document date\n        timeIndex.docDate = findReferenceDate(timeExpressions);\n      }\n    }\n    // Didn't have a reference date - try using cached doc date\n    if (refDate == null) refDate = timeIndex.docDate;\n\n    // Some resolving is done even if refDate null...\n    if ( timeExpressions != null) {\n      resolveTimeExpressions(annotation, timeExpressions, refDate);\n    }\n    if (options.restrictToTimex3) {\n      // Keep only TIMEX3 compatible timeExpressions\n      List<TimeExpression> kept = new ArrayList<TimeExpression>(timeExpressions.size());\n      for (TimeExpression te:timeExpressions) {\n        if (te.getTemporal() != null && te.getTemporal().getTimexValue() != null) {\n          kept.add(te);\n        } else {\n          List<? extends CoreMap> children = te.getAnnotation().get(TimeExpression.ChildrenAnnotation.class);\n          if (children != null) {\n            for (CoreMap child:children) {\n              TimeExpression childTe = child.get(TimeExpression.Annotation.class);\n              if (childTe != null) {\n                resolveTimeExpression(annotation, childTe, refDate);\n                if (childTe.getTemporal() != null && childTe.getTemporal().getTimexValue() != null) {\n                  kept.add(childTe);\n                }\n              }\n            }\n          }\n        }\n      }\n      timeExpressions = kept;\n    }\n\n    // Add back nested time expressions for ranges....\n    // For now only one level of nesting...\n    if (options.includeNested) {\n      List<TimeExpression> nestedTimeExpressions = new ArrayList<TimeExpression>();\n      for (TimeExpression te:timeExpressions) {\n        if (te.isIncludeNested())  {\n          List<? extends CoreMap> children = te.getAnnotation().get(TimeExpression.ChildrenAnnotation.class);\n          if (children != null) {\n            for (CoreMap child:children) {\n              TimeExpression childTe = child.get(TimeExpression.Annotation.class);\n              if (childTe != null) {\n                nestedTimeExpressions.add(childTe);\n              }\n            }\n          }\n        }\n      }\n      resolveTimeExpressions(annotation, nestedTimeExpressions, refDate);\n      timeExpressions.addAll(nestedTimeExpressions);\n    }\n    Collections.sort(timeExpressions, MatchedExpression.EXPR_TOKEN_OFFSETS_NESTED_FIRST_COMPARATOR);\n    // Some resolving is done even if refDate null...\n    if (timeExpressions != null) {\n      resolveTimeExpressions(annotation, timeExpressions, refDate);\n    }\n    return timeExpressions;\n  }","id":6486,"modified_method":"public List<TimeExpression> extractTimeExpressions(CoreMap annotation, SUTime.Time refDate, SUTime.TimeIndex timeIndex) {\n    if (!annotation.containsKey(CoreAnnotations.NumerizedTokensAnnotation.class)) {\n      List<CoreMap> mergedNumbers = NumberNormalizer.findAndMergeNumbers(annotation);\n      annotation.set(CoreAnnotations.NumerizedTokensAnnotation.class, mergedNumbers);\n    }\n\n    List<? extends MatchedExpression> matchedExpressions = expressionExtractor.extractExpressions(annotation);\n    List<TimeExpression> timeExpressions = new ArrayList<>(matchedExpressions.size());\n    for (MatchedExpression expr : matchedExpressions) {\n      // Make sure we have the correct type (instead of just MatchedExpression)\n      //timeExpressions.add(TimeExpression.TimeExpressionConverter.apply(expr));\n\n      // TODO: Fix the extraction pipeline so it creates TimeExpression instead of MatchedExpressions\n      // For now, grab the time expression from the annotation (this is good, so we don't have duplicate copies)\n      TimeExpression annoTe = expr.getAnnotation().get( TimeExpression.Annotation.class );\n      if (annoTe != null) {\n        timeExpressions.add(annoTe);\n      }\n    }\n    // We cache the document date in the timeIndex\n    if (timeIndex.docDate == null) {\n      if (refDate != null) timeIndex.docDate = refDate;\n      else if (options.searchForDocDate) {\n        // there was no document date but option was set to look for document date\n        timeIndex.docDate = findReferenceDate(timeExpressions);\n      }\n    }\n    // Didn't have a reference date - try using cached doc date\n    if (refDate == null) refDate = timeIndex.docDate;\n\n    // Some resolving is done even if refDate null...\n    resolveTimeExpressions(annotation, timeExpressions, refDate);\n\n    if (options.restrictToTimex3) {\n      // Keep only TIMEX3 compatible timeExpressions\n      List<TimeExpression> kept = new ArrayList<>(timeExpressions.size());\n      for (TimeExpression te:timeExpressions) {\n        if (te.getTemporal() != null && te.getTemporal().getTimexValue() != null) {\n          kept.add(te);\n        } else {\n          List<? extends CoreMap> children = te.getAnnotation().get(TimeExpression.ChildrenAnnotation.class);\n          if (children != null) {\n            for (CoreMap child:children) {\n              TimeExpression childTe = child.get(TimeExpression.Annotation.class);\n              if (childTe != null) {\n                resolveTimeExpression(annotation, childTe, refDate);\n                if (childTe.getTemporal() != null && childTe.getTemporal().getTimexValue() != null) {\n                  kept.add(childTe);\n                }\n              }\n            }\n          }\n        }\n      }\n      timeExpressions = kept;\n    }\n\n    // Add back nested time expressions for ranges....\n    // For now only one level of nesting...\n    if (options.includeNested) {\n      List<TimeExpression> nestedTimeExpressions = new ArrayList<>();\n      for (TimeExpression te : timeExpressions) {\n        if (te.isIncludeNested())  {\n          List<? extends CoreMap> children = te.getAnnotation().get(TimeExpression.ChildrenAnnotation.class);\n          if (children != null) {\n            for (CoreMap child:children) {\n              TimeExpression childTe = child.get(TimeExpression.Annotation.class);\n              if (childTe != null) {\n                nestedTimeExpressions.add(childTe);\n              }\n            }\n          }\n        }\n      }\n      resolveTimeExpressions(annotation, nestedTimeExpressions, refDate);\n      timeExpressions.addAll(nestedTimeExpressions);\n    }\n    Collections.sort(timeExpressions, MatchedExpression.EXPR_TOKEN_OFFSETS_NESTED_FIRST_COMPARATOR);\n    // Some resolving is done even if refDate null...\n    resolveTimeExpressions(annotation, timeExpressions, refDate);\n    return timeExpressions;\n  }","commit_id":"a2cf40cecbd6accd175a399fc4c158abc27f1a1e","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private List<CoreMap> toCoreMaps(CoreMap annotation, List<TimeExpression> timeExpressions, SUTime.TimeIndex timeIndex)\n  {\n    if (timeExpressions == null) return null;\n    List<CoreMap> coreMaps = new ArrayList<CoreMap>(timeExpressions.size());\n    for (TimeExpression te:timeExpressions) {\n      CoreMap cm = te.getAnnotation();\n      SUTime.Temporal temporal = te.getTemporal();\n      if (temporal != null) {\n        String origText = annotation.get(CoreAnnotations.TextAnnotation.class);\n        String text = cm.get(CoreAnnotations.TextAnnotation.class);\n        if (origText != null) {\n          // Make sure the text is from original (and not from concatenated tokens)\n          ChunkAnnotationUtils.annotateChunkText(cm, annotation);\n          text = cm.get(CoreAnnotations.TextAnnotation.class);\n        }\n        Map<String,String> timexAttributes;\n        try {\n          timexAttributes = temporal.getTimexAttributes(timeIndex);\n          if (options.includeRange) {\n            SUTime.Temporal rangeTemporal = temporal.getRange();\n            if (rangeTemporal != null) {\n              timexAttributes.put(\"range\", rangeTemporal.toString());\n            }\n          }\n        } catch (Exception e) {\n          logger.log(Level.WARNING, \"Failed to get attributes from \" + text + \", timeIndex \" + timeIndex, e);\n          continue;\n        }\n        Timex timex;\n        try {\n          timex = Timex.fromMap(text, timexAttributes);\n        } catch (Exception e) {\n          logger.log(Level.WARNING, \"Failed to process \" + text + \" with attributes \" + timexAttributes, e);\n          continue;\n        }\n        cm.set(TimeAnnotations.TimexAnnotation.class, timex);\n        if (timex != null) {\n          coreMaps.add(cm);\n        } else {\n          logger.warning(\"No timex expression for: \" + text);\n        }\n      }\n    }\n    return coreMaps;\n  }","id":6487,"modified_method":"private List<CoreMap> toCoreMaps(CoreMap annotation, List<TimeExpression> timeExpressions, SUTime.TimeIndex timeIndex)\n  {\n    if (timeExpressions == null) return null;\n    List<CoreMap> coreMaps = new ArrayList<CoreMap>(timeExpressions.size());\n    for (TimeExpression te:timeExpressions) {\n      CoreMap cm = te.getAnnotation();\n      SUTime.Temporal temporal = te.getTemporal();\n      if (temporal != null) {\n        String origText = annotation.get(CoreAnnotations.TextAnnotation.class);\n        String text = cm.get(CoreAnnotations.TextAnnotation.class);\n        if (origText != null) {\n          // Make sure the text is from original (and not from concatenated tokens)\n          ChunkAnnotationUtils.annotateChunkText(cm, annotation);\n          text = cm.get(CoreAnnotations.TextAnnotation.class);\n        }\n        Map<String,String> timexAttributes;\n        try {\n          timexAttributes = temporal.getTimexAttributes(timeIndex);\n          if (options.includeRange) {\n            SUTime.Temporal rangeTemporal = temporal.getRange();\n            if (rangeTemporal != null) {\n              timexAttributes.put(\"range\", rangeTemporal.toString());\n            }\n          }\n        } catch (Exception e) {\n          logger.log(Level.WARNING, \"Failed to get attributes from \" + text + \", timeIndex \" + timeIndex, e);\n          continue;\n        }\n        Timex timex = null;\n        try {\n          timex = Timex.fromMap(text, timexAttributes);\n        } catch (Exception e) {\n          logger.log(Level.WARNING, \"Failed to process \" + text + \" with attributes \" + timexAttributes, e);\n          continue;\n        }\n        cm.set(TimeAnnotations.TimexAnnotation.class, timex);\n        if (timex != null) {\n          coreMaps.add(cm);\n        } else {\n          logger.warning(\"No timex expression for: \" + text);\n        }\n      }\n    }\n    return coreMaps;\n  }","commit_id":"fb689a331093fe058a51b149a8225e3dd242af96","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public List<TimeExpression> extractTimeExpressions(CoreMap annotation, String docDateStr)\n  {\n    List<CoreMap> mergedNumbers = NumberNormalizer.findAndMergeNumbers(annotation);\n    annotation.set(CoreAnnotations.NumerizedTokensAnnotation.class, mergedNumbers);\n\n    // TODO: docDate may not have century....\n\n    SUTime.Time docDate = null;\n    try {\n      docDate = SUTime.parseDateTime(docDateStr);\n    } catch (Exception e) {\n      throw new RuntimeException(\"Could not parse date string: [\" + docDateStr + \"]\", e);\n    }\n    List<? extends MatchedExpression> matchedExpressions = expressionExtractor.extractExpressions(annotation);\n    List<TimeExpression> timeExpressions = new ArrayList<TimeExpression>(matchedExpressions.size());\n    for (MatchedExpression expr:matchedExpressions) {\n      if (expr instanceof TimeExpression) {\n        timeExpressions.add((TimeExpression) expr);\n      } else {\n        timeExpressions.add(new TimeExpression(expr));\n      }\n    }\n    // Some resolving is done even if docDate null...\n    if ( /*docDate != null && */ timeExpressions != null) {\n      resolveTimeExpressions(annotation, timeExpressions, docDate);\n    }\n    if (options.restrictToTimex3) {\n      // Keep only TIMEX3 compatible timeExpressions\n      List<TimeExpression> kept = new ArrayList<TimeExpression>(timeExpressions.size());\n      for (TimeExpression te:timeExpressions) {\n        if (te.getTemporal() != null && te.getTemporal().getTimexValue() != null) {\n          kept.add(te);\n        } else {\n          List<? extends CoreMap> children = te.getAnnotation().get(TimeExpression.ChildrenAnnotation.class);\n          if (children != null) {\n            for (CoreMap child:children) {\n              TimeExpression childTe = child.get(TimeExpression.Annotation.class);\n              if (childTe != null) {\n                resolveTimeExpression(annotation, childTe, docDate);\n                if (childTe.getTemporal() != null && childTe.getTemporal().getTimexValue() != null) {\n                  kept.add(childTe);\n                }\n              }\n            }\n          }\n        }\n      }\n      timeExpressions = kept;\n    }\n\n    // Add back nested time expressions for ranges....\n    // For now only one level of nesting...\n    if (options.includeNested) {\n      List<TimeExpression> nestedTimeExpressions = new ArrayList<TimeExpression>();\n      for (TimeExpression te:timeExpressions) {\n        if (te.isIncludeNested())  {\n          List<? extends CoreMap> children = te.getAnnotation().get(TimeExpression.ChildrenAnnotation.class);\n          if (children != null) {\n            for (CoreMap child:children) {\n              TimeExpression childTe = child.get(TimeExpression.Annotation.class);\n              if (childTe != null) {\n                nestedTimeExpressions.add(childTe);\n              }\n            }\n          }\n        }\n      }\n      resolveTimeExpressions(annotation, nestedTimeExpressions, docDate);\n      timeExpressions.addAll(nestedTimeExpressions);\n    }\n    Collections.sort(timeExpressions, MatchedExpression.EXPR_TOKEN_OFFSETS_NESTED_FIRST_COMPARATOR);\n    // Some resolving is done even if docDate null...\n    if ( /*docDate != null && */ timeExpressions != null) {\n      resolveTimeExpressions(annotation, timeExpressions, docDate);\n    }\n    return timeExpressions;\n  }","id":6488,"modified_method":"public List<TimeExpression> extractTimeExpressions(CoreMap annotation, String docDateStr)\n  {\n    List<CoreMap> mergedNumbers = NumberNormalizer.findAndMergeNumbers(annotation);\n    annotation.set(CoreAnnotations.NumerizedTokensAnnotation.class, mergedNumbers);\n\n    // TODO: docDate may not have century....\n\n    SUTime.Time docDate; // = null;  // NO need, as throws RuntimeException if not initialized.\n    try {\n      docDate = SUTime.parseDateTime(docDateStr);\n    } catch (Exception e) {\n      throw new RuntimeException(\"Could not parse date string: [\" + docDateStr + \"]\", e);\n    }\n    List<? extends MatchedExpression> matchedExpressions = expressionExtractor.extractExpressions(annotation);\n    List<TimeExpression> timeExpressions = new ArrayList<TimeExpression>(matchedExpressions.size());\n    for (MatchedExpression expr : matchedExpressions) {\n      if (expr instanceof TimeExpression) {\n        timeExpressions.add((TimeExpression) expr);\n      } else {\n        timeExpressions.add(new TimeExpression(expr));\n      }\n    }\n    // Some resolving is done even if docDate null...\n    // if ( /*docDate != null && */ timeExpressions != null) {\n    resolveTimeExpressions(annotation, timeExpressions, docDate);\n    // }\n    if (options.restrictToTimex3) {\n      // Keep only TIMEX3 compatible timeExpressions\n      List<TimeExpression> kept = new ArrayList<TimeExpression>(timeExpressions.size());\n      for (TimeExpression te:timeExpressions) {\n        if (te.getTemporal() != null && te.getTemporal().getTimexValue() != null) {\n          kept.add(te);\n        } else {\n          List<? extends CoreMap> children = te.getAnnotation().get(TimeExpression.ChildrenAnnotation.class);\n          if (children != null) {\n            for (CoreMap child:children) {\n              TimeExpression childTe = child.get(TimeExpression.Annotation.class);\n              if (childTe != null) {\n                resolveTimeExpression(annotation, childTe, docDate);\n                if (childTe.getTemporal() != null && childTe.getTemporal().getTimexValue() != null) {\n                  kept.add(childTe);\n                }\n              }\n            }\n          }\n        }\n      }\n      timeExpressions = kept;\n    }\n\n    // Add back nested time expressions for ranges....\n    // For now only one level of nesting...\n    if (options.includeNested) {\n      List<TimeExpression> nestedTimeExpressions = new ArrayList<TimeExpression>();\n      for (TimeExpression te:timeExpressions) {\n        if (te.isIncludeNested())  {\n          List<? extends CoreMap> children = te.getAnnotation().get(TimeExpression.ChildrenAnnotation.class);\n          if (children != null) {\n            for (CoreMap child:children) {\n              TimeExpression childTe = child.get(TimeExpression.Annotation.class);\n              if (childTe != null) {\n                nestedTimeExpressions.add(childTe);\n              }\n            }\n          }\n        }\n      }\n      resolveTimeExpressions(annotation, nestedTimeExpressions, docDate);\n      timeExpressions.addAll(nestedTimeExpressions);\n    }\n    Collections.sort(timeExpressions, MatchedExpression.EXPR_TOKEN_OFFSETS_NESTED_FIRST_COMPARATOR);\n    // Some resolving is done even if docDate null...\n    // if ( /*docDate != null && */ timeExpressions != null) {\n    resolveTimeExpressions(annotation, timeExpressions, docDate);\n    // }\n    return timeExpressions;\n  }","commit_id":"fb689a331093fe058a51b149a8225e3dd242af96","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public Acknowledgment(final OnmsAlarm a) {\n        this(a.getAlarmAckTime(), a.getAlarmAckUser());\n        m_ackType = AckType.Alarm;\n        m_refId = a.getId();\n    }","id":6489,"modified_method":"public Acknowledgment(final OnmsAlarm a) {\n        \n        if (a == null) {\n            throw new IllegalArgumentException(\"OnmsAlarm is null.\");\n        }\n        \n        m_ackTime = a.getAlarmAckTime();\n        m_ackUser = a.getAlarmAckUser();\n        m_ackType = AckType.Alarm;\n        m_refId = a.getId();\n    }","commit_id":"ff09038a0b59f4754ec670eefb5fddca335aa79e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void populateDatabase() {\n        OnmsDistPoller distPoller = getDistPoller(\"localhost\", \"127.0.0.1\");\n        \n        OnmsCategory ac = getCategory(\"DEV_AC\");\n        OnmsCategory mid = getCategory(\"IMP_mid\");\n        OnmsCategory ops = getCategory(\"OPS_Online\");\n        \n        OnmsCategory catRouter = getCategory(\"Routers\");\n        OnmsCategory catSwitches = getCategory(\"Switches\");\n        OnmsCategory catServers = getCategory(\"Servers\");\n        getCategory(\"Production\");\n        getCategory(\"Test\");\n        getCategory(\"Development\");\n        \n        getServiceType(\"ICMP\");\n        getServiceType(\"SNMP\");\n        getServiceType(\"HTTP\");\n        \n        NetworkBuilder builder = new NetworkBuilder(distPoller);\n        \n        setNode1(builder.addNode(\"node1\").setForeignSource(\"imported:\").setForeignId(\"1\").getNode());\n        Assert.assertNotNull(\"newly built node 1 should not be null\", getNode1());\n        builder.addCategory(ac);\n        builder.addCategory(mid);\n        builder.addCategory(ops);\n        builder.addCategory(catRouter); \n        builder.setBuilding(\"HQ\");\n        builder.addInterface(\"192.168.1.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1).addSnmpInterface(\"192.168.1.1\", 1).setIfSpeed(10000000).setIfDescr(\"ATM0\").setIfType(37);\n        //getNodeDao().save(builder.getCurrentNode());\n        //getNodeDao().flush();\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"192.168.1.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1).addSnmpInterface(\"192.168.1.2\", 2).setIfSpeed(10000000).setIfName(\"eth0\").setIfType(6);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"192.168.1.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1).addSnmpInterface(\"192.168.1.3\", 3).setIfSpeed(10000000);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n        \n        builder.addNode(\"node2\").setForeignSource(\"imported:\").setForeignId(\"2\");\n        builder.addCategory(mid);\n        builder.addCategory(catServers);\n        builder.setBuilding(\"HQ\");\n        builder.addInterface(\"192.168.2.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"192.168.2.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"192.168.2.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n        \n        builder.addNode(\"node3\").setForeignSource(\"imported:\").setForeignId(\"3\");\n        builder.addCategory(ops);\n        builder.addInterface(\"192.168.3.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"192.168.3.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"192.168.3.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n        \n        builder.addNode(\"node4\").setForeignSource(\"imported:\").setForeignId(\"4\");\n        builder.addCategory(ac);\n        builder.addInterface(\"192.168.4.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"192.168.4.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"192.168.4.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n\n        //This node purposely doesn't have a foreignId style assetNumber\n        builder.addNode(\"alternate-node1\").getAssetRecord().setAssetNumber(\"5\");\n        builder.addCategory(ac);\n        builder.addCategory(catSwitches);\n        builder.addInterface(\"10.1.1.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"10.1.1.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"10.1.1.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n        \n        //This node purposely doesn't have a assetNumber and is used by a test to check the category\n        builder.addNode(\"alternate-node2\").getAssetRecord().setDisplayCategory(\"category1\");\n        builder.addCategory(ac);\n        builder.addInterface(\"10.1.2.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"10.1.2.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"10.1.2.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n        \n        OnmsEvent event = new OnmsEvent();\n        event.setDistPoller(distPoller);\n        event.setEventUei(\"uei.opennms.org/test\");\n        event.setEventTime(new Date());\n        event.setEventSource(\"test\");\n        event.setEventCreateTime(new Date());\n        event.setEventSeverity(1);\n        event.setEventLog(\"Y\");\n        event.setEventDisplay(\"Y\");\n        getEventDao().save(event);\n        getEventDao().flush();\n       \n        OnmsMonitoredService svc = getMonitoredServiceDao().get(1, \"192.168.1.1\", \"SNMP\");\n        OnmsOutage resolved = new OnmsOutage(new Date(), new Date(), event, event, svc, null, null);\n        getOutageDao().save(resolved);\n        getOutageDao().flush();\n        \n        OnmsOutage unresolved = new OnmsOutage(new Date(), event, svc);\n        getOutageDao().save(unresolved);\n        getOutageDao().flush();\n        \n        OnmsCategory category = new OnmsCategory();\n        category.setName(\"some category\");\n        getCategoryDao().save(category);\n        getCategoryDao().flush();\n        \n        OnmsAlarm alarm = new OnmsAlarm();\n        alarm.setDistPoller(getDistPollerDao().load(\"localhost\"));\n        alarm.setUei(event.getEventUei());\n        alarm.setCounter(1);\n        alarm.setSeverity(OnmsSeverity.NORMAL);\n        alarm.setLastEvent(event);\n        getAlarmDao().save(alarm);\n        getAlarmDao().flush();\n        \n        \n        Acknowledgment ack = new Acknowledgment(alarm);\n        getAcknowledgmentDao().save(ack);\n        getAcknowledgmentDao().flush();\n        \n    }","id":6490,"modified_method":"public void populateDatabase() {\n        OnmsDistPoller distPoller = getDistPoller(\"localhost\", \"127.0.0.1\");\n        \n        OnmsCategory ac = getCategory(\"DEV_AC\");\n        OnmsCategory mid = getCategory(\"IMP_mid\");\n        OnmsCategory ops = getCategory(\"OPS_Online\");\n        \n        OnmsCategory catRouter = getCategory(\"Routers\");\n        OnmsCategory catSwitches = getCategory(\"Switches\");\n        OnmsCategory catServers = getCategory(\"Servers\");\n        getCategory(\"Production\");\n        getCategory(\"Test\");\n        getCategory(\"Development\");\n        \n        getServiceType(\"ICMP\");\n        getServiceType(\"SNMP\");\n        getServiceType(\"HTTP\");\n        \n        NetworkBuilder builder = new NetworkBuilder(distPoller);\n        \n        setNode1(builder.addNode(\"node1\").setForeignSource(\"imported:\").setForeignId(\"1\").getNode());\n        Assert.assertNotNull(\"newly built node 1 should not be null\", getNode1());\n        builder.addCategory(ac);\n        builder.addCategory(mid);\n        builder.addCategory(ops);\n        builder.addCategory(catRouter); \n        builder.setBuilding(\"HQ\");\n        builder.addInterface(\"192.168.1.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1).addSnmpInterface(\"192.168.1.1\", 1).setIfSpeed(10000000).setIfDescr(\"ATM0\").setIfType(37);\n        //getNodeDao().save(builder.getCurrentNode());\n        //getNodeDao().flush();\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"192.168.1.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1).addSnmpInterface(\"192.168.1.2\", 2).setIfSpeed(10000000).setIfName(\"eth0\").setIfType(6);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"192.168.1.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1).addSnmpInterface(\"192.168.1.3\", 3).setIfSpeed(10000000);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n        \n        builder.addNode(\"node2\").setForeignSource(\"imported:\").setForeignId(\"2\");\n        builder.addCategory(mid);\n        builder.addCategory(catServers);\n        builder.setBuilding(\"HQ\");\n        builder.addInterface(\"192.168.2.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"192.168.2.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"192.168.2.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n        \n        builder.addNode(\"node3\").setForeignSource(\"imported:\").setForeignId(\"3\");\n        builder.addCategory(ops);\n        builder.addInterface(\"192.168.3.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"192.168.3.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"192.168.3.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n        \n        builder.addNode(\"node4\").setForeignSource(\"imported:\").setForeignId(\"4\");\n        builder.addCategory(ac);\n        builder.addInterface(\"192.168.4.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"192.168.4.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"192.168.4.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n\n        //This node purposely doesn't have a foreignId style assetNumber\n        builder.addNode(\"alternate-node1\").getAssetRecord().setAssetNumber(\"5\");\n        builder.addCategory(ac);\n        builder.addCategory(catSwitches);\n        builder.addInterface(\"10.1.1.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"10.1.1.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"10.1.1.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n        \n        //This node purposely doesn't have a assetNumber and is used by a test to check the category\n        builder.addNode(\"alternate-node2\").getAssetRecord().setDisplayCategory(\"category1\");\n        builder.addCategory(ac);\n        builder.addInterface(\"10.1.2.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"10.1.2.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"10.1.2.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n        \n        OnmsEvent event = new OnmsEvent();\n        event.setDistPoller(distPoller);\n        event.setEventUei(\"uei.opennms.org/test\");\n        event.setEventTime(new Date());\n        event.setEventSource(\"test\");\n        event.setEventCreateTime(new Date());\n        event.setEventSeverity(1);\n        event.setEventLog(\"Y\");\n        event.setEventDisplay(\"Y\");\n        getEventDao().save(event);\n        getEventDao().flush();\n       \n        OnmsMonitoredService svc = getMonitoredServiceDao().get(1, \"192.168.1.1\", \"SNMP\");\n        OnmsOutage resolved = new OnmsOutage(new Date(), new Date(), event, event, svc, null, null);\n        getOutageDao().save(resolved);\n        getOutageDao().flush();\n        \n        OnmsOutage unresolved = new OnmsOutage(new Date(), event, svc);\n        getOutageDao().save(unresolved);\n        getOutageDao().flush();\n        \n        OnmsCategory category = new OnmsCategory();\n        category.setName(\"some category\");\n        getCategoryDao().save(category);\n        getCategoryDao().flush();\n        \n        OnmsAlarm alarm = new OnmsAlarm();\n        alarm.setDistPoller(getDistPollerDao().load(\"localhost\"));\n        alarm.setUei(event.getEventUei());\n        alarm.setCounter(1);\n        alarm.setSeverity(OnmsSeverity.NORMAL);\n        alarm.setLastEvent(event);\n        getAlarmDao().save(alarm);\n        getAlarmDao().flush();\n        \n        \n        Acknowledgment ack = new Acknowledgment();\n        ack.setAckTime(new Date());\n        ack.setAckType(AckType.Unspecified);\n        ack.setAckUser(\"admin\");\n        getAcknowledgmentDao().save(ack);\n        getAcknowledgmentDao().flush();\n        \n    }","commit_id":"ff09038a0b59f4754ec670eefb5fddca335aa79e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Acknowledgment(final OnmsAlarm a) {\n        this(a.getAlarmAckTime(), a.getAlarmAckUser());\n        m_ackType = AckType.Alarm;\n        m_refId = a.getId();\n    }","id":6491,"modified_method":"public Acknowledgment(final OnmsAlarm a) {\n        \n        if (a == null) {\n            throw new IllegalArgumentException(\"OnmsAlarm is null.\");\n        }\n        \n        m_ackTime = a.getAlarmAckTime();\n        m_ackUser = a.getAlarmAckUser();\n        m_ackType = AckType.Alarm;\n        m_refId = a.getId();\n    }","commit_id":"28a28c5ac76a2ae7647c2ed19eef495d1b5aba34","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void populateDatabase() {\n        OnmsDistPoller distPoller = getDistPoller(\"localhost\", \"127.0.0.1\");\n        \n        OnmsCategory ac = getCategory(\"DEV_AC\");\n        OnmsCategory mid = getCategory(\"IMP_mid\");\n        OnmsCategory ops = getCategory(\"OPS_Online\");\n        \n        OnmsCategory catRouter = getCategory(\"Routers\");\n        OnmsCategory catSwitches = getCategory(\"Switches\");\n        OnmsCategory catServers = getCategory(\"Servers\");\n        getCategory(\"Production\");\n        getCategory(\"Test\");\n        getCategory(\"Development\");\n        \n        getServiceType(\"ICMP\");\n        getServiceType(\"SNMP\");\n        getServiceType(\"HTTP\");\n        \n        NetworkBuilder builder = new NetworkBuilder(distPoller);\n        \n        setNode1(builder.addNode(\"node1\").setForeignSource(\"imported:\").setForeignId(\"1\").getNode());\n        Assert.assertNotNull(\"newly built node 1 should not be null\", getNode1());\n        builder.addCategory(ac);\n        builder.addCategory(mid);\n        builder.addCategory(ops);\n        builder.addCategory(catRouter); \n        builder.setBuilding(\"HQ\");\n        builder.addInterface(\"192.168.1.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1).addSnmpInterface(\"192.168.1.1\", 1).setIfSpeed(10000000).setIfDescr(\"ATM0\").setIfType(37);\n        //getNodeDao().save(builder.getCurrentNode());\n        //getNodeDao().flush();\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"192.168.1.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1).addSnmpInterface(\"192.168.1.2\", 2).setIfSpeed(10000000).setIfName(\"eth0\").setIfType(6);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"192.168.1.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1).addSnmpInterface(\"192.168.1.3\", 3).setIfSpeed(10000000);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n        \n        builder.addNode(\"node2\").setForeignSource(\"imported:\").setForeignId(\"2\");\n        builder.addCategory(mid);\n        builder.addCategory(catServers);\n        builder.setBuilding(\"HQ\");\n        builder.addInterface(\"192.168.2.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"192.168.2.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"192.168.2.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n        \n        builder.addNode(\"node3\").setForeignSource(\"imported:\").setForeignId(\"3\");\n        builder.addCategory(ops);\n        builder.addInterface(\"192.168.3.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"192.168.3.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"192.168.3.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n        \n        builder.addNode(\"node4\").setForeignSource(\"imported:\").setForeignId(\"4\");\n        builder.addCategory(ac);\n        builder.addInterface(\"192.168.4.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"192.168.4.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"192.168.4.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n\n        //This node purposely doesn't have a foreignId style assetNumber\n        builder.addNode(\"alternate-node1\").getAssetRecord().setAssetNumber(\"5\");\n        builder.addCategory(ac);\n        builder.addCategory(catSwitches);\n        builder.addInterface(\"10.1.1.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"10.1.1.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"10.1.1.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n        \n        //This node purposely doesn't have a assetNumber and is used by a test to check the category\n        builder.addNode(\"alternate-node2\").getAssetRecord().setDisplayCategory(\"category1\");\n        builder.addCategory(ac);\n        builder.addInterface(\"10.1.2.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"10.1.2.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"10.1.2.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n        \n        OnmsEvent event = new OnmsEvent();\n        event.setDistPoller(distPoller);\n        event.setEventUei(\"uei.opennms.org/test\");\n        event.setEventTime(new Date());\n        event.setEventSource(\"test\");\n        event.setEventCreateTime(new Date());\n        event.setEventSeverity(1);\n        event.setEventLog(\"Y\");\n        event.setEventDisplay(\"Y\");\n        getEventDao().save(event);\n        getEventDao().flush();\n       \n        OnmsMonitoredService svc = getMonitoredServiceDao().get(1, \"192.168.1.1\", \"SNMP\");\n        OnmsOutage resolved = new OnmsOutage(new Date(), new Date(), event, event, svc, null, null);\n        getOutageDao().save(resolved);\n        getOutageDao().flush();\n        \n        OnmsOutage unresolved = new OnmsOutage(new Date(), event, svc);\n        getOutageDao().save(unresolved);\n        getOutageDao().flush();\n        \n        OnmsCategory category = new OnmsCategory();\n        category.setName(\"some category\");\n        getCategoryDao().save(category);\n        getCategoryDao().flush();\n        \n        OnmsAlarm alarm = new OnmsAlarm();\n        alarm.setDistPoller(getDistPollerDao().load(\"localhost\"));\n        alarm.setUei(event.getEventUei());\n        alarm.setCounter(1);\n        alarm.setSeverity(OnmsSeverity.NORMAL);\n        alarm.setLastEvent(event);\n        getAlarmDao().save(alarm);\n        getAlarmDao().flush();\n        \n        \n        Acknowledgment ack = new Acknowledgment(alarm);\n        getAcknowledgmentDao().save(ack);\n        getAcknowledgmentDao().flush();\n        \n    }","id":6492,"modified_method":"public void populateDatabase() {\n        OnmsDistPoller distPoller = getDistPoller(\"localhost\", \"127.0.0.1\");\n        \n        OnmsCategory ac = getCategory(\"DEV_AC\");\n        OnmsCategory mid = getCategory(\"IMP_mid\");\n        OnmsCategory ops = getCategory(\"OPS_Online\");\n        \n        OnmsCategory catRouter = getCategory(\"Routers\");\n        OnmsCategory catSwitches = getCategory(\"Switches\");\n        OnmsCategory catServers = getCategory(\"Servers\");\n        getCategory(\"Production\");\n        getCategory(\"Test\");\n        getCategory(\"Development\");\n        \n        getServiceType(\"ICMP\");\n        getServiceType(\"SNMP\");\n        getServiceType(\"HTTP\");\n        \n        NetworkBuilder builder = new NetworkBuilder(distPoller);\n        \n        setNode1(builder.addNode(\"node1\").setForeignSource(\"imported:\").setForeignId(\"1\").getNode());\n        Assert.assertNotNull(\"newly built node 1 should not be null\", getNode1());\n        builder.addCategory(ac);\n        builder.addCategory(mid);\n        builder.addCategory(ops);\n        builder.addCategory(catRouter); \n        builder.setBuilding(\"HQ\");\n        builder.addInterface(\"192.168.1.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1).addSnmpInterface(\"192.168.1.1\", 1).setIfSpeed(10000000).setIfDescr(\"ATM0\").setIfType(37);\n        //getNodeDao().save(builder.getCurrentNode());\n        //getNodeDao().flush();\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"192.168.1.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1).addSnmpInterface(\"192.168.1.2\", 2).setIfSpeed(10000000).setIfName(\"eth0\").setIfType(6);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"192.168.1.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1).addSnmpInterface(\"192.168.1.3\", 3).setIfSpeed(10000000);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n        \n        builder.addNode(\"node2\").setForeignSource(\"imported:\").setForeignId(\"2\");\n        builder.addCategory(mid);\n        builder.addCategory(catServers);\n        builder.setBuilding(\"HQ\");\n        builder.addInterface(\"192.168.2.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"192.168.2.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"192.168.2.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n        \n        builder.addNode(\"node3\").setForeignSource(\"imported:\").setForeignId(\"3\");\n        builder.addCategory(ops);\n        builder.addInterface(\"192.168.3.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"192.168.3.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"192.168.3.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n        \n        builder.addNode(\"node4\").setForeignSource(\"imported:\").setForeignId(\"4\");\n        builder.addCategory(ac);\n        builder.addInterface(\"192.168.4.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"192.168.4.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"192.168.4.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n\n        //This node purposely doesn't have a foreignId style assetNumber\n        builder.addNode(\"alternate-node1\").getAssetRecord().setAssetNumber(\"5\");\n        builder.addCategory(ac);\n        builder.addCategory(catSwitches);\n        builder.addInterface(\"10.1.1.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"10.1.1.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"10.1.1.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n        \n        //This node purposely doesn't have a assetNumber and is used by a test to check the category\n        builder.addNode(\"alternate-node2\").getAssetRecord().setDisplayCategory(\"category1\");\n        builder.addCategory(ac);\n        builder.addInterface(\"10.1.2.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"10.1.2.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"10.1.2.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n        \n        OnmsEvent event = new OnmsEvent();\n        event.setDistPoller(distPoller);\n        event.setEventUei(\"uei.opennms.org/test\");\n        event.setEventTime(new Date());\n        event.setEventSource(\"test\");\n        event.setEventCreateTime(new Date());\n        event.setEventSeverity(1);\n        event.setEventLog(\"Y\");\n        event.setEventDisplay(\"Y\");\n        getEventDao().save(event);\n        getEventDao().flush();\n       \n        OnmsMonitoredService svc = getMonitoredServiceDao().get(1, \"192.168.1.1\", \"SNMP\");\n        OnmsOutage resolved = new OnmsOutage(new Date(), new Date(), event, event, svc, null, null);\n        getOutageDao().save(resolved);\n        getOutageDao().flush();\n        \n        OnmsOutage unresolved = new OnmsOutage(new Date(), event, svc);\n        getOutageDao().save(unresolved);\n        getOutageDao().flush();\n        \n        OnmsCategory category = new OnmsCategory();\n        category.setName(\"some category\");\n        getCategoryDao().save(category);\n        getCategoryDao().flush();\n        \n        OnmsAlarm alarm = new OnmsAlarm();\n        alarm.setDistPoller(getDistPollerDao().load(\"localhost\"));\n        alarm.setUei(event.getEventUei());\n        alarm.setCounter(1);\n        alarm.setSeverity(OnmsSeverity.NORMAL);\n        alarm.setLastEvent(event);\n        getAlarmDao().save(alarm);\n        getAlarmDao().flush();\n        \n        \n        Acknowledgment ack = new Acknowledgment();\n        ack.setAckTime(new Date());\n        ack.setAckType(AckType.Unspecified);\n        ack.setAckUser(\"admin\");\n        getAcknowledgmentDao().save(ack);\n        getAcknowledgmentDao().flush();\n        \n    }","commit_id":"28a28c5ac76a2ae7647c2ed19eef495d1b5aba34","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Acknowledgment(final OnmsAlarm a) {\n        this(a.getAlarmAckTime(), a.getAlarmAckUser());\n        m_ackType = AckType.Alarm;\n        m_refId = a.getId();\n    }","id":6493,"modified_method":"public Acknowledgment(final OnmsAlarm a) {\n        \n        if (a == null) {\n            throw new IllegalArgumentException(\"OnmsAlarm is null.\");\n        }\n        \n        m_ackTime = a.getAlarmAckTime();\n        m_ackUser = a.getAlarmAckUser();\n        m_ackType = AckType.Alarm;\n        m_refId = a.getId();\n    }","commit_id":"25517cb21bb7274564ab23ccbf4009a0549d4668","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void populateDatabase() {\n        OnmsDistPoller distPoller = getDistPoller(\"localhost\", \"127.0.0.1\");\n        \n        OnmsCategory ac = getCategory(\"DEV_AC\");\n        OnmsCategory mid = getCategory(\"IMP_mid\");\n        OnmsCategory ops = getCategory(\"OPS_Online\");\n        \n        OnmsCategory catRouter = getCategory(\"Routers\");\n        OnmsCategory catSwitches = getCategory(\"Switches\");\n        OnmsCategory catServers = getCategory(\"Servers\");\n        getCategory(\"Production\");\n        getCategory(\"Test\");\n        getCategory(\"Development\");\n        \n        getServiceType(\"ICMP\");\n        getServiceType(\"SNMP\");\n        getServiceType(\"HTTP\");\n        \n        NetworkBuilder builder = new NetworkBuilder(distPoller);\n        \n        setNode1(builder.addNode(\"node1\").setForeignSource(\"imported:\").setForeignId(\"1\").getNode());\n        Assert.assertNotNull(\"newly built node 1 should not be null\", getNode1());\n        builder.addCategory(ac);\n        builder.addCategory(mid);\n        builder.addCategory(ops);\n        builder.addCategory(catRouter); \n        builder.setBuilding(\"HQ\");\n        builder.addInterface(\"192.168.1.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1).addSnmpInterface(\"192.168.1.1\", 1).setIfSpeed(10000000).setIfDescr(\"ATM0\").setIfType(37);\n        //getNodeDao().save(builder.getCurrentNode());\n        //getNodeDao().flush();\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"192.168.1.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1).addSnmpInterface(\"192.168.1.2\", 2).setIfSpeed(10000000).setIfName(\"eth0\").setIfType(6);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"192.168.1.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1).addSnmpInterface(\"192.168.1.3\", 3).setIfSpeed(10000000);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n        \n        builder.addNode(\"node2\").setForeignSource(\"imported:\").setForeignId(\"2\");\n        builder.addCategory(mid);\n        builder.addCategory(catServers);\n        builder.setBuilding(\"HQ\");\n        builder.addInterface(\"192.168.2.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"192.168.2.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"192.168.2.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n        \n        builder.addNode(\"node3\").setForeignSource(\"imported:\").setForeignId(\"3\");\n        builder.addCategory(ops);\n        builder.addInterface(\"192.168.3.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"192.168.3.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"192.168.3.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n        \n        builder.addNode(\"node4\").setForeignSource(\"imported:\").setForeignId(\"4\");\n        builder.addCategory(ac);\n        builder.addInterface(\"192.168.4.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"192.168.4.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"192.168.4.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n\n        //This node purposely doesn't have a foreignId style assetNumber\n        builder.addNode(\"alternate-node1\").getAssetRecord().setAssetNumber(\"5\");\n        builder.addCategory(ac);\n        builder.addCategory(catSwitches);\n        builder.addInterface(\"10.1.1.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"10.1.1.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"10.1.1.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n        \n        //This node purposely doesn't have a assetNumber and is used by a test to check the category\n        builder.addNode(\"alternate-node2\").getAssetRecord().setDisplayCategory(\"category1\");\n        builder.addCategory(ac);\n        builder.addInterface(\"10.1.2.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"10.1.2.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"10.1.2.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n        \n        OnmsEvent event = new OnmsEvent();\n        event.setDistPoller(distPoller);\n        event.setEventUei(\"uei.opennms.org/test\");\n        event.setEventTime(new Date());\n        event.setEventSource(\"test\");\n        event.setEventCreateTime(new Date());\n        event.setEventSeverity(1);\n        event.setEventLog(\"Y\");\n        event.setEventDisplay(\"Y\");\n        getEventDao().save(event);\n        getEventDao().flush();\n       \n        OnmsMonitoredService svc = getMonitoredServiceDao().get(1, \"192.168.1.1\", \"SNMP\");\n        OnmsOutage resolved = new OnmsOutage(new Date(), new Date(), event, event, svc, null, null);\n        getOutageDao().save(resolved);\n        getOutageDao().flush();\n        \n        OnmsOutage unresolved = new OnmsOutage(new Date(), event, svc);\n        getOutageDao().save(unresolved);\n        getOutageDao().flush();\n        \n        OnmsCategory category = new OnmsCategory();\n        category.setName(\"some category\");\n        getCategoryDao().save(category);\n        getCategoryDao().flush();\n        \n        OnmsAlarm alarm = new OnmsAlarm();\n        alarm.setDistPoller(getDistPollerDao().load(\"localhost\"));\n        alarm.setUei(event.getEventUei());\n        alarm.setCounter(1);\n        alarm.setSeverity(OnmsSeverity.NORMAL);\n        alarm.setLastEvent(event);\n        getAlarmDao().save(alarm);\n        getAlarmDao().flush();\n        \n        \n        Acknowledgment ack = new Acknowledgment(alarm);\n        getAcknowledgmentDao().save(ack);\n        getAcknowledgmentDao().flush();\n        \n    }","id":6494,"modified_method":"public void populateDatabase() {\n        OnmsDistPoller distPoller = getDistPoller(\"localhost\", \"127.0.0.1\");\n        \n        OnmsCategory ac = getCategory(\"DEV_AC\");\n        OnmsCategory mid = getCategory(\"IMP_mid\");\n        OnmsCategory ops = getCategory(\"OPS_Online\");\n        \n        OnmsCategory catRouter = getCategory(\"Routers\");\n        OnmsCategory catSwitches = getCategory(\"Switches\");\n        OnmsCategory catServers = getCategory(\"Servers\");\n        getCategory(\"Production\");\n        getCategory(\"Test\");\n        getCategory(\"Development\");\n        \n        getServiceType(\"ICMP\");\n        getServiceType(\"SNMP\");\n        getServiceType(\"HTTP\");\n        \n        NetworkBuilder builder = new NetworkBuilder(distPoller);\n        \n        setNode1(builder.addNode(\"node1\").setForeignSource(\"imported:\").setForeignId(\"1\").getNode());\n        Assert.assertNotNull(\"newly built node 1 should not be null\", getNode1());\n        builder.addCategory(ac);\n        builder.addCategory(mid);\n        builder.addCategory(ops);\n        builder.addCategory(catRouter); \n        builder.setBuilding(\"HQ\");\n        builder.addInterface(\"192.168.1.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1).addSnmpInterface(\"192.168.1.1\", 1).setIfSpeed(10000000).setIfDescr(\"ATM0\").setIfType(37);\n        //getNodeDao().save(builder.getCurrentNode());\n        //getNodeDao().flush();\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"192.168.1.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1).addSnmpInterface(\"192.168.1.2\", 2).setIfSpeed(10000000).setIfName(\"eth0\").setIfType(6);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"192.168.1.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1).addSnmpInterface(\"192.168.1.3\", 3).setIfSpeed(10000000);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n        \n        builder.addNode(\"node2\").setForeignSource(\"imported:\").setForeignId(\"2\");\n        builder.addCategory(mid);\n        builder.addCategory(catServers);\n        builder.setBuilding(\"HQ\");\n        builder.addInterface(\"192.168.2.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"192.168.2.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"192.168.2.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n        \n        builder.addNode(\"node3\").setForeignSource(\"imported:\").setForeignId(\"3\");\n        builder.addCategory(ops);\n        builder.addInterface(\"192.168.3.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"192.168.3.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"192.168.3.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n        \n        builder.addNode(\"node4\").setForeignSource(\"imported:\").setForeignId(\"4\");\n        builder.addCategory(ac);\n        builder.addInterface(\"192.168.4.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"192.168.4.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"192.168.4.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n\n        //This node purposely doesn't have a foreignId style assetNumber\n        builder.addNode(\"alternate-node1\").getAssetRecord().setAssetNumber(\"5\");\n        builder.addCategory(ac);\n        builder.addCategory(catSwitches);\n        builder.addInterface(\"10.1.1.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"10.1.1.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"10.1.1.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n        \n        //This node purposely doesn't have a assetNumber and is used by a test to check the category\n        builder.addNode(\"alternate-node2\").getAssetRecord().setDisplayCategory(\"category1\");\n        builder.addCategory(ac);\n        builder.addInterface(\"10.1.2.1\").setIsManaged(\"M\").setIsSnmpPrimary(\"P\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"SNMP\"));\n        builder.addInterface(\"10.1.2.2\").setIsManaged(\"M\").setIsSnmpPrimary(\"S\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        builder.addService(getServiceType(\"HTTP\"));\n        builder.addInterface(\"10.1.2.3\").setIsManaged(\"M\").setIsSnmpPrimary(\"N\").setIpStatus(1);\n        builder.addService(getServiceType(\"ICMP\"));\n        getNodeDao().save(builder.getCurrentNode());\n        getNodeDao().flush();\n        \n        OnmsEvent event = new OnmsEvent();\n        event.setDistPoller(distPoller);\n        event.setEventUei(\"uei.opennms.org/test\");\n        event.setEventTime(new Date());\n        event.setEventSource(\"test\");\n        event.setEventCreateTime(new Date());\n        event.setEventSeverity(1);\n        event.setEventLog(\"Y\");\n        event.setEventDisplay(\"Y\");\n        getEventDao().save(event);\n        getEventDao().flush();\n       \n        OnmsMonitoredService svc = getMonitoredServiceDao().get(1, \"192.168.1.1\", \"SNMP\");\n        OnmsOutage resolved = new OnmsOutage(new Date(), new Date(), event, event, svc, null, null);\n        getOutageDao().save(resolved);\n        getOutageDao().flush();\n        \n        OnmsOutage unresolved = new OnmsOutage(new Date(), event, svc);\n        getOutageDao().save(unresolved);\n        getOutageDao().flush();\n        \n        OnmsCategory category = new OnmsCategory();\n        category.setName(\"some category\");\n        getCategoryDao().save(category);\n        getCategoryDao().flush();\n        \n        OnmsAlarm alarm = new OnmsAlarm();\n        alarm.setDistPoller(getDistPollerDao().load(\"localhost\"));\n        alarm.setUei(event.getEventUei());\n        alarm.setCounter(1);\n        alarm.setSeverity(OnmsSeverity.NORMAL);\n        alarm.setLastEvent(event);\n        getAlarmDao().save(alarm);\n        getAlarmDao().flush();\n        \n        \n        Acknowledgment ack = new Acknowledgment();\n        ack.setAckTime(new Date());\n        ack.setAckType(AckType.Unspecified);\n        ack.setAckUser(\"admin\");\n        getAcknowledgmentDao().save(ack);\n        getAcknowledgmentDao().flush();\n        \n    }","commit_id":"25517cb21bb7274564ab23ccbf4009a0549d4668","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public CompletionPreferencePolicy(PsiManager manager, LookupItem[] allItems, ExpectedTypeInfo[] expectedInfos, String prefix) {\n    myPrefix = prefix;\n    myManager = manager;\n    myCodeStyleManager = CodeStyleManager.getInstance(myManager.getProject());\n    if(expectedInfos != null){\n      final Map<PsiType, ExpectedTypeInfo> map = new java.util.HashMap<PsiType, ExpectedTypeInfo>(expectedInfos.length);\n      for (final ExpectedTypeInfo expectedInfo : expectedInfos) {\n        if (!map.containsKey(expectedInfo.getType())) {\n          map.put(expectedInfo.getType(), expectedInfo);\n        }\n      }\n      myExpectedInfos = map.values().toArray(new ExpectedTypeInfo[map.size()]);\n    }\n    else myExpectedInfos = null;\n    synchronized(myItemToIndexMap){\n      for(int i = 0; i < allItems.length; i++){\n        myItemToIndexMap.put(allItems[i], new Integer(i + 1));\n      }\n    }\n  }","id":6495,"modified_method":"public CompletionPreferencePolicy(PsiManager manager, LookupItem[] allItems, ExpectedTypeInfo[] expectedInfos, String prefix) {\n    setPrefix( prefix );\n    myManager = manager;\n    myCodeStyleManager = CodeStyleManager.getInstance(myManager.getProject());\n    if(expectedInfos != null){\n      final Map<PsiType, ExpectedTypeInfo> map = new java.util.HashMap<PsiType, ExpectedTypeInfo>(expectedInfos.length);\n      for (final ExpectedTypeInfo expectedInfo : expectedInfos) {\n        if (!map.containsKey(expectedInfo.getType())) {\n          map.put(expectedInfo.getType(), expectedInfo);\n        }\n      }\n      myExpectedInfos = map.values().toArray(new ExpectedTypeInfo[map.size()]);\n    }\n    else myExpectedInfos = null;\n    synchronized(myItemToIndexMap){\n      for(int i = 0; i < allItems.length; i++){\n        myItemToIndexMap.put(allItems[i], new Integer(i + 1));\n      }\n    }\n  }","commit_id":"f84bc41b3786b25253ccaabc09074efebc1eb60b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setPrefix(String prefix) {\n    myPrefix = prefix;\n  }","id":6496,"modified_method":"public void setPrefix(String prefix) {\n    myPrefix = prefix;\n    myPrefixLowered = prefix.toLowerCase();\n  }","commit_id":"f84bc41b3786b25253ccaabc09074efebc1eb60b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int compare(final LookupItem item1, final LookupItem item2) {\n    if (item1 == item2) return 0;\n    if(item1.getLookupString().toLowerCase().startsWith(myPrefix.toLowerCase()) && !item2.getLookupString().toLowerCase().startsWith(myPrefix.toLowerCase()))\n      return -1;\n    if(!item1.getLookupString().toLowerCase().startsWith(myPrefix.toLowerCase()) && item2.getLookupString().toLowerCase().startsWith(myPrefix.toLowerCase()))\n      return 1;\n    Object o1 = item1.getObject();\n    Object o2 = item2.getObject();\n\n    if (myExpectedInfos != null) {\n      int matchSize1 = getMatchedWordCount(o1);\n      int matchSize2 = getMatchedWordCount(o2);\n      if (matchSize1 != matchSize2){\n        return matchSize2 - matchSize1;\n      }\n    }\n\n    if(o1 instanceof String || o1 instanceof PsiKeyword){\n      if(!(o2 instanceof String || o2 instanceof PsiKeyword))\n        return 1;\n      else{\n        return o1.toString().compareTo(o2.toString());\n      }\n    }\n    else if(o2 instanceof String || o2 instanceof PsiKeyword)\n      return -1;\n\n    if (o1 instanceof PsiLocalVariable ||\n        o2 instanceof PsiLocalVariable ||\n        o1 instanceof PsiParameter ||\n        o2 instanceof PsiParameter\n    ){\n      if(!(o1 instanceof PsiLocalVariable ||\n           o1 instanceof PsiParameter)) return 1;\n      if(!(o2 instanceof PsiLocalVariable ||\n           o2 instanceof PsiParameter)) return -1;\n      synchronized(myItemToIndexMap){\n        int index1 = myItemToIndexMap.get(item1).intValue() - 1;\n        if (index1 < 0){\n          LOG.error(\"index1 < 0 : \" + item1);\n        }\n        int index2 = myItemToIndexMap.get(item2).intValue() - 1;\n        if (index2 < 0){\n          LOG.error(\"index2 < 0 : \" + item2);\n        }\n        return index1 - index2;\n      }\n    }\n    if (o1 instanceof PsiMember && o2 instanceof PsiMember){\n      boolean equalsName1 = false;\n      boolean equalsName2 = false;\n      if(o1 instanceof PsiNamedElement){\n        equalsName1 = ((PsiNamedElement)o1).getName().equals(myPrefix);\n      }\n      if(o2 instanceof PsiNamedElement){\n        equalsName2 = ((PsiNamedElement)o2).getName().equals(myPrefix);\n      }\n\n      if(equalsName2){\n        if(!equalsName1) return 1;\n      }\n      else if(equalsName1) return -1;\n\n      PsiType qualifierType1 = CompletionUtil.getQualifierType(item1);\n      PsiType qualifierType2 = CompletionUtil.getQualifierType(item2);\n      if (qualifierType1 != null && qualifierType2 != null){\n        int count1 = StatisticsManager.getInstance().getMemberUseCount(qualifierType1, (PsiMember)o1, myNormalizedItems);\n        int count2 = StatisticsManager.getInstance().getMemberUseCount(qualifierType2, (PsiMember)o2, myNormalizedItems);\n        return count2 - count1;\n      }\n    }\n\n    return 0;\n  }","id":6497,"modified_method":"public int compare(final LookupItem item1, final LookupItem item2) {\n    if (item1 == item2) return 0;\n    String item1String = item1.getLookupString();\n    String item2String = item2.getLookupString();\n\n    item1String = item1String.toLowerCase();\n    item2String = item2String.toLowerCase();\n\n    if(item1String.startsWith(myPrefixLowered) && !item2String.startsWith(myPrefixLowered))\n      return -1;\n    if(!item1String.startsWith(myPrefixLowered) && item2String.startsWith(myPrefixLowered))\n      return 1;\n\n    // Check equality in case\n    item1String = item1.getLookupString();\n    item2String = item2.getLookupString();\n\n    if(item1String.startsWith(myPrefix) && !item2String.startsWith(myPrefix))\n      return -1;\n    if(!item1String.startsWith(myPrefix) && item2String.startsWith(myPrefix))\n      return 1;\n\n    Object o1 = item1.getObject();\n    Object o2 = item2.getObject();\n\n    if (myExpectedInfos != null) {\n      int matchSize1 = getMatchedWordCount(o1);\n      int matchSize2 = getMatchedWordCount(o2);\n      if (matchSize1 != matchSize2){\n        return matchSize2 - matchSize1;\n      }\n    }\n\n    if(o1 instanceof String || o1 instanceof PsiKeyword){\n      if(!(o2 instanceof String || o2 instanceof PsiKeyword))\n        return 1;\n      else{\n        return o1.toString().compareTo(o2.toString());\n      }\n    }\n    else if(o2 instanceof String || o2 instanceof PsiKeyword)\n      return -1;\n\n    if (o1 instanceof PsiLocalVariable ||\n        o2 instanceof PsiLocalVariable ||\n        o1 instanceof PsiParameter ||\n        o2 instanceof PsiParameter\n    ){\n      if(!(o1 instanceof PsiLocalVariable ||\n           o1 instanceof PsiParameter)) return 1;\n      if(!(o2 instanceof PsiLocalVariable ||\n           o2 instanceof PsiParameter)) return -1;\n      synchronized(myItemToIndexMap){\n        int index1 = myItemToIndexMap.get(item1).intValue() - 1;\n        if (index1 < 0){\n          LOG.error(\"index1 < 0 : \" + item1);\n        }\n        int index2 = myItemToIndexMap.get(item2).intValue() - 1;\n        if (index2 < 0){\n          LOG.error(\"index2 < 0 : \" + item2);\n        }\n        return index1 - index2;\n      }\n    }\n    if (o1 instanceof PsiMember && o2 instanceof PsiMember){\n      boolean equalsName1 = false;\n      boolean equalsName2 = false;\n      if(o1 instanceof PsiNamedElement){\n        equalsName1 = ((PsiNamedElement)o1).getName().equals(myPrefix);\n      }\n      if(o2 instanceof PsiNamedElement){\n        equalsName2 = ((PsiNamedElement)o2).getName().equals(myPrefix);\n      }\n\n      if(equalsName2){\n        if(!equalsName1) return 1;\n      }\n      else if(equalsName1) return -1;\n\n      PsiType qualifierType1 = CompletionUtil.getQualifierType(item1);\n      PsiType qualifierType2 = CompletionUtil.getQualifierType(item2);\n      if (qualifierType1 != null && qualifierType2 != null){\n        int count1 = StatisticsManager.getInstance().getMemberUseCount(qualifierType1, (PsiMember)o1, myNormalizedItems);\n        int count2 = StatisticsManager.getInstance().getMemberUseCount(qualifierType2, (PsiMember)o2, myNormalizedItems);\n        return count2 - count1;\n      }\n    }\n\n    return 0;\n  }","commit_id":"f84bc41b3786b25253ccaabc09074efebc1eb60b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void selectMostPreferableItem(){\n    //if (!isVisible()) return;\n\n    if (myItemPreferencePolicy == null){\n      myIndex = -1;\n    }\n    else{\n      myItemPreferencePolicy.setPrefix(myPrefix);\n      DefaultListModel model = (DefaultListModel)myList.getModel();\n      Object[] items = model.toArray();\n      LookupItem prefItem = null;\n      int prefItemIndex = -1;\n      for(int i = 0; i < items.length; i++){\n        LookupItem item = (LookupItem)items[i];\n        final Object obj = item.getObject();\n        if (obj instanceof PsiElement && !((PsiElement)obj).isValid()) continue;\n        if (prefItem == null){\n          prefItem = item;\n          prefItemIndex = i;\n        }\n        else{\n          int d = myItemPreferencePolicy.compare(item, prefItem);\n          if (d < 0){\n            prefItem = item;\n            prefItemIndex = i;\n          }\n        }\n      }\n      myIndex = prefItem != null ? prefItemIndex : -1;\n    }\n    myList.setSelectedIndex(myIndex);\n  }","id":6498,"modified_method":"private void selectMostPreferableItem(){\n    //if (!isVisible()) return;\n\n    myIndex = LookupItemUtil.doSelectMostPreferableItem(myItemPreferencePolicy, myPrefix, ((DefaultListModel)myList.getModel()).toArray());\n    myList.setSelectedIndex(myIndex);\n  }","commit_id":"f84bc41b3786b25253ccaabc09074efebc1eb60b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int compare(final LookupItem item1, final LookupItem item2) {\n    if (item1 == item2) return 0;\n    String item1String = item1.getLookupString();\n    String item2String = item2.getLookupString();\n\n    item1String = item1String.toLowerCase();\n    item2String = item2String.toLowerCase();\n\n    if (item1String.startsWith(myPrefixLowered) && !item2String.startsWith(myPrefixLowered)) return -1;\n    if (!item1String.startsWith(myPrefixLowered) && item2String.startsWith(myPrefixLowered)) return 1;\n\n    // Check equality in case\n    item1String = item1.getLookupString();\n    item2String = item2.getLookupString();\n\n    if (item1String.startsWith(myPrefix) && !item2String.startsWith(myPrefix)) return -1;\n    if (!item1String.startsWith(myPrefix) && item2String.startsWith(myPrefix)) return 1;\n\n    Object o1 = item1.getObject();\n    Object o2 = item2.getObject();\n\n    if (myExpectedInfos != null) {\n      int matchSize1 = getMatchedWordCount(o1);\n      int matchSize2 = getMatchedWordCount(o2);\n      if (matchSize1 != matchSize2){\n        return matchSize2 - matchSize1;\n      }\n    }\n\n    if (o1 instanceof String || o1 instanceof PsiKeyword) {\n      if (o2 instanceof String || o2 instanceof PsiKeyword) {\n        return o1.toString().compareTo(o2.toString());\n      }\n      else {\n        return 1;\n      }\n    }\n    if (o2 instanceof String || o2 instanceof PsiKeyword) return -1;\n\n    if (o1 instanceof PsiLocalVariable ||\n        o2 instanceof PsiLocalVariable ||\n        o1 instanceof PsiParameter ||\n        o2 instanceof PsiParameter\n    ){\n      if (!(o1 instanceof PsiLocalVariable || o1 instanceof PsiParameter)) return 1;\n      if (!(o2 instanceof PsiLocalVariable || o2 instanceof PsiParameter)) return -1;\n      synchronized(myItemToIndexMap){\n        int index1 = myItemToIndexMap.get(item1) - 1;\n        if (index1 < 0){\n          LOG.error(\"index1 < 0 : \" + item1);\n        }\n        int index2 = myItemToIndexMap.get(item2) - 1;\n        if (index2 < 0){\n          LOG.error(\"index2 < 0 : \" + item2);\n        }\n        return index1 - index2;\n      }\n    }\n    if (o1 instanceof PsiMember && o2 instanceof PsiMember){\n      boolean equalsName1 = false;\n      if(o1 instanceof PsiNamedElement){\n        equalsName1 = myPrefix.equals(((PsiNamedElement)o1).getName());\n      }\n      boolean equalsName2 = false;\n      if(o2 instanceof PsiNamedElement){\n        equalsName2 = myPrefix.equals(((PsiNamedElement)o2).getName());\n      }\n\n      if(equalsName2){\n        if(!equalsName1) return 1;\n      }\n      else if(equalsName1) return -1;\n\n      PsiType qualifierType1 = CompletionUtil.getQualifierType(item1);\n      PsiType qualifierType2 = CompletionUtil.getQualifierType(item2);\n      if (qualifierType1 != null && qualifierType2 != null){\n        int count1 = StatisticsManager.getInstance().getMemberUseCount(qualifierType1, (PsiMember)o1);\n        int count2 = StatisticsManager.getInstance().getMemberUseCount(qualifierType2, (PsiMember)o2);\n        if (count2 != count1) {\n          return count2 - count1;\n        }\n      }\n    }\n    return 0;\n  }","id":6499,"modified_method":"public int compare(final LookupItem item1, final LookupItem item2) {\n    if (item1 == item2) return 0;\n\n    String item1StringCap = capitalsOnly(item1.getLookupString());\n    String item2StringCap = capitalsOnly(item2.getLookupString());\n\n    if (item1StringCap.startsWith(myPrefixCapitals) && !item2StringCap.startsWith(myPrefixCapitals)) return -1;\n    if (!item1StringCap.startsWith(myPrefixCapitals) && item2StringCap.startsWith(myPrefixCapitals)) return 1;\n\n    // Check equality in case\n    String item1String = item1.getLookupString();\n    String item2String = item2.getLookupString();\n\n    if (item1String.startsWith(myPrefix) && !item2String.startsWith(myPrefix)) return -1;\n    if (!item1String.startsWith(myPrefix) && item2String.startsWith(myPrefix)) return 1;\n\n\n    String item1StringLowered = item1.getLookupString().toLowerCase();\n    String item2StringLowered = item2.getLookupString().toLowerCase();\n\n    if (item1StringLowered.startsWith(myPrefixLowered) && !item2StringLowered.startsWith(myPrefixLowered)) return -1;\n    if (!item1StringLowered.startsWith(myPrefixLowered) && item2StringLowered.startsWith(myPrefixLowered)) return 1;\n\n\n    Object o1 = item1.getObject();\n    Object o2 = item2.getObject();\n\n    if (myExpectedInfos != null) {\n      int matchSize1 = getMatchedWordCount(o1);\n      int matchSize2 = getMatchedWordCount(o2);\n      if (matchSize1 != matchSize2){\n        return matchSize2 - matchSize1;\n      }\n    }\n\n    if (o1 instanceof String || o1 instanceof PsiKeyword) {\n      if (o2 instanceof String || o2 instanceof PsiKeyword) {\n        return o1.toString().compareTo(o2.toString());\n      }\n      else {\n        return 1;\n      }\n    }\n    if (o2 instanceof String || o2 instanceof PsiKeyword) return -1;\n\n    if (o1 instanceof PsiLocalVariable ||\n        o2 instanceof PsiLocalVariable ||\n        o1 instanceof PsiParameter ||\n        o2 instanceof PsiParameter\n    ){\n      if (!(o1 instanceof PsiLocalVariable || o1 instanceof PsiParameter)) return 1;\n      if (!(o2 instanceof PsiLocalVariable || o2 instanceof PsiParameter)) return -1;\n      synchronized(myItemToIndexMap){\n        int index1 = myItemToIndexMap.get(item1) - 1;\n        if (index1 < 0){\n          LOG.error(\"index1 < 0 : \" + item1);\n        }\n        int index2 = myItemToIndexMap.get(item2) - 1;\n        if (index2 < 0){\n          LOG.error(\"index2 < 0 : \" + item2);\n        }\n        return index1 - index2;\n      }\n    }\n    if (o1 instanceof PsiMember && o2 instanceof PsiMember){\n      boolean equalsName1 = false;\n      if(o1 instanceof PsiNamedElement){\n        equalsName1 = myPrefix.equals(((PsiNamedElement)o1).getName());\n      }\n      boolean equalsName2 = false;\n      if(o2 instanceof PsiNamedElement){\n        equalsName2 = myPrefix.equals(((PsiNamedElement)o2).getName());\n      }\n\n      if(equalsName2){\n        if(!equalsName1) return 1;\n      }\n      else if(equalsName1) return -1;\n\n      PsiType qualifierType1 = CompletionUtil.getQualifierType(item1);\n      PsiType qualifierType2 = CompletionUtil.getQualifierType(item2);\n      if (qualifierType1 != null && qualifierType2 != null){\n        int count1 = StatisticsManager.getInstance().getMemberUseCount(qualifierType1, (PsiMember)o1);\n        int count2 = StatisticsManager.getInstance().getMemberUseCount(qualifierType2, (PsiMember)o2);\n        if (count2 != count1) {\n          return count2 - count1;\n        }\n      }\n    }\n    return 0;\n  }","commit_id":"ac80c842b4b45e65f0c2ed1261ca49740f72c2c7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CompletionPreferencePolicy(PsiManager manager, LookupItem[] allItems, ExpectedTypeInfo[] expectedInfos, String prefix) {\n    setPrefix( prefix );\n    myCodeStyleManager = manager.getCodeStyleManager();\n    if(expectedInfos != null){\n      final Map<PsiType, ExpectedTypeInfo> map = new HashMap<PsiType, ExpectedTypeInfo>(expectedInfos.length);\n      for (final ExpectedTypeInfo expectedInfo : expectedInfos) {\n        if (!map.containsKey(expectedInfo.getType())) {\n          map.put(expectedInfo.getType(), expectedInfo);\n        }\n      }\n      myExpectedInfos = map.values().toArray(new ExpectedTypeInfo[map.size()]);\n    }\n    else myExpectedInfos = null;\n    synchronized(myItemToIndexMap){\n      for(int i = 0; i < allItems.length; i++){\n        myItemToIndexMap.put(allItems[i], i + 1);\n      }\n    }\n  }","id":6500,"modified_method":"public CompletionPreferencePolicy(PsiManager manager, LookupItem[] allItems, ExpectedTypeInfo[] expectedInfos, String prefix) {\n    setPrefix( prefix );\n    myPrefixCapitals = capitalsOnly(prefix);\n    myCodeStyleManager = manager.getCodeStyleManager();\n    if(expectedInfos != null){\n      final Map<PsiType, ExpectedTypeInfo> map = new HashMap<PsiType, ExpectedTypeInfo>(expectedInfos.length);\n      for (final ExpectedTypeInfo expectedInfo : expectedInfos) {\n        if (!map.containsKey(expectedInfo.getType())) {\n          map.put(expectedInfo.getType(), expectedInfo);\n        }\n      }\n      myExpectedInfos = map.values().toArray(new ExpectedTypeInfo[map.size()]);\n    }\n    else myExpectedInfos = null;\n    synchronized(myItemToIndexMap){\n      for(int i = 0; i < allItems.length; i++){\n        myItemToIndexMap.put(allItems[i], i + 1);\n      }\n    }\n  }","commit_id":"ac80c842b4b45e65f0c2ed1261ca49740f72c2c7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Pattern createCamelHumpsMatcher(String pattern) {\n    Pattern pat = null;\n    final CodeInsightSettings settings = CodeInsightSettings.getInstance();\n    int variant = settings.COMPLETION_CASE_SENSITIVE;\n    Perl5Compiler compiler = new Perl5Compiler();\n\n    try {\n      switch (variant) {\n        case CodeInsightSettings.NONE:\n          pat = compiler.compile(NameUtil.buildRegexp(pattern, 0, true, true));\n          break;\n        case CodeInsightSettings.FIRST_LETTER:\n          pat = compiler.compile(NameUtil.buildRegexp(pattern, 1, true, false));\n          break;\n        case CodeInsightSettings.ALL:\n          pat = compiler.compile(NameUtil.buildRegexp(pattern, 0, false, false));\n          break;\n        default:\n          pat = compiler.compile(NameUtil.buildRegexp(pattern, 1, true, false));\n      }\n    }\n    catch (MalformedPatternException me) {\n    }\n    return pat;\n  }","id":6501,"modified_method":"public static Pattern createCamelHumpsMatcher(String pattern) {\n    Pattern pat = null;\n    final CodeInsightSettings settings = CodeInsightSettings.getInstance();\n    int variant = settings.COMPLETION_CASE_SENSITIVE;\n    Perl5Compiler compiler = new Perl5Compiler();\n\n    try {\n      switch (variant) {\n        case CodeInsightSettings.NONE:\n          pat = compiler.compile(NameUtil.buildRegexp(pattern, 0, true, true));\n          break;\n        case CodeInsightSettings.FIRST_LETTER:\n          pat = compiler.compile(NameUtil.buildRegexp(pattern, 1, true, true));\n          break;\n        case CodeInsightSettings.ALL:\n          pat = compiler.compile(NameUtil.buildRegexp(pattern, 0, false, false));\n          break;\n        default:\n          pat = compiler.compile(NameUtil.buildRegexp(pattern, 1, true, false));\n      }\n    }\n    catch (MalformedPatternException me) {\n    }\n    return pat;\n  }","commit_id":"ac80c842b4b45e65f0c2ed1261ca49740f72c2c7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PropertyIndexEditor(NodeBuilder definition, NodeState root) {\n        this.parent = null;\n        this.name = null;\n        this.path = \"/\";\n        this.definition = definition;\n\n        // get property names\n        PropertyState names = definition.getProperty(PROPERTY_NAMES);\n        if (names.count() == 1) { // OAK-1273: optimize for the common case\n            this.propertyNames = singleton(names.getValue(NAME, 0));\n        } else {\n            this.propertyNames = newHashSet(names.getValue(NAMES));\n        }\n\n        // get declaring types, and all their subtypes\n        // TODO: should we reindex when type definitions change?\n        if (definition.hasProperty(DECLARING_NODE_TYPES)) {\n            this.typePredicate = new TypePredicate(\n                    root, definition.getNames(DECLARING_NODE_TYPES));\n        } else {\n            this.typePredicate = NodeState.EXISTS;\n        }\n\n        // keep track of modified keys for uniqueness checks\n        if (definition.getBoolean(IndexConstants.UNIQUE_PROPERTY_NAME)) {\n            unique = true;\n            this.keysToCheckForUniqueness = newHashSet();\n        } else {\n            unique = false;\n            this.keysToCheckForUniqueness = null;\n        }\n    }","id":6502,"modified_method":"public PropertyIndexEditor(NodeBuilder definition, NodeState root) {\n        this.parent = null;\n        this.name = null;\n        this.path = \"/\";\n        this.definition = definition;\n\n        // get property names\n        PropertyState names = definition.getProperty(PROPERTY_NAMES);\n        if (names.count() == 1) { // OAK-1273: optimize for the common case\n            this.propertyNames = singleton(names.getValue(NAME, 0));\n        } else {\n            this.propertyNames = newHashSet(names.getValue(NAMES));\n        }\n\n        // get declaring types, and all their subtypes\n        // TODO: should we reindex when type definitions change?\n        if (definition.hasProperty(DECLARING_NODE_TYPES)) {\n            this.typePredicate = new TypePredicate(\n                    root, definition.getNames(DECLARING_NODE_TYPES));\n        } else {\n            this.typePredicate = null;\n        }\n\n        // keep track of modified keys for uniqueness checks\n        if (definition.getBoolean(IndexConstants.UNIQUE_PROPERTY_NAME)) {\n            this.keysToCheckForUniqueness = newHashSet();\n        } else {\n            this.keysToCheckForUniqueness = null;\n        }\n    }","commit_id":"ac469ed5ebd20af356eeda16e327fb2a3385bed4","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private PropertyIndexEditor(PropertyIndexEditor parent, String name) {\n        this.parent = parent;\n        this.name = name;\n        this.path = null;\n        this.definition = parent.definition;\n        this.propertyNames = parent.propertyNames;\n        this.typePredicate = parent.typePredicate;\n        this.unique = parent.unique;\n        this.keysToCheckForUniqueness = parent.keysToCheckForUniqueness;\n    }","id":6503,"modified_method":"private PropertyIndexEditor(PropertyIndexEditor parent, String name) {\n        this.parent = parent;\n        this.name = name;\n        this.path = null;\n        this.definition = parent.definition;\n        this.propertyNames = parent.propertyNames;\n        this.typePredicate = parent.typePredicate;\n        this.keysToCheckForUniqueness = parent.keysToCheckForUniqueness;\n    }","commit_id":"ac469ed5ebd20af356eeda16e327fb2a3385bed4","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private static void addValueKeys(Set<String> keys, PropertyState property) {\n        if (property.getType().tag() != PropertyType.BINARY) {\n            keys.addAll(encode(PropertyValues.create(property)));\n        }\n    }","id":6504,"modified_method":"/**\n     * Adds the encoded values of the given property to the given set.\n     * If the given set is uninitialized, i.e. {@code null}, then a new\n     * set is created for any values to be added. The set, possibly newly\n     * initialized, is returned.\n     *\n     * @param keys set of encoded values, or {@code null}\n     * @param property property whose values are to be added to the set\n     * @return set of encoded values, possibly initialized\n     */\n    private static Set<String> addValueKeys(\n            Set<String> keys, PropertyState property) {\n        if (property.getType().tag() != PropertyType.BINARY\n                && property.count() > 0) {\n            if (keys == null) {\n                keys = newHashSet();\n            }\n            keys.addAll(encode(PropertyValues.create(property)));\n        }\n        return keys;\n    }","commit_id":"ac469ed5ebd20af356eeda16e327fb2a3385bed4","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void enter(NodeState before, NodeState after)\n            throws CommitFailedException {\n        boolean beforeMatches = typePredicate.apply(before);\n        boolean afterMatches  = typePredicate.apply(after);\n\n        if (beforeMatches || afterMatches) {\n            beforeKeys = newHashSet();\n            afterKeys = newHashSet();\n        }\n \n        if (beforeMatches && afterMatches) {\n            trackChanges = true;\n        } else if (beforeMatches) {\n            // all matching values should be removed from the index\n            addMatchingKeys(beforeKeys, before, propertyNames);\n        } else if (afterMatches) {\n            // all matching values should be added to the index\n            addMatchingKeys(afterKeys, after, propertyNames);\n        }\n    }","id":6505,"modified_method":"@Override\n    public void enter(NodeState before, NodeState after) {\n        typeChanged = (typePredicate == null); // disables property name checks\n        beforeKeys = null;\n        afterKeys = null;\n    }","commit_id":"ac469ed5ebd20af356eeda16e327fb2a3385bed4","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void propertyAdded(PropertyState after) {\n        if (trackChanges && propertyNames.contains(after.getName())) {\n            addValueKeys(afterKeys, after);\n        }\n    }","id":6506,"modified_method":"@Override\n    public void propertyAdded(PropertyState after) {\n        String name = after.getName();\n        typeChanged = typeChanged || isTypeProperty(name);\n        if (propertyNames.contains(name)) {\n            afterKeys = addValueKeys(afterKeys, after);\n        }\n    }","commit_id":"ac469ed5ebd20af356eeda16e327fb2a3385bed4","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void propertyDeleted(PropertyState before) {\n        if (trackChanges && propertyNames.contains(before.getName())) {\n            addValueKeys(beforeKeys, before);\n        }\n    }","id":6507,"modified_method":"@Override\n    public void propertyDeleted(PropertyState before) {\n        String name = before.getName();\n        typeChanged = typeChanged || isTypeProperty(name);\n        if (propertyNames.contains(name)) {\n            beforeKeys = addValueKeys(beforeKeys, before);\n        }\n    }","commit_id":"ac469ed5ebd20af356eeda16e327fb2a3385bed4","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void propertyChanged(PropertyState before, PropertyState after) {\n        if (trackChanges && propertyNames.contains(after.getName())) {\n            addValueKeys(beforeKeys, before);\n            addValueKeys(afterKeys, after);\n        }\n    }","id":6508,"modified_method":"@Override\n    public void propertyChanged(PropertyState before, PropertyState after) {\n        String name = after.getName();\n        typeChanged = typeChanged || isTypeProperty(name);\n        if (propertyNames.contains(name)) {\n            beforeKeys = addValueKeys(beforeKeys, before);\n            afterKeys = addValueKeys(afterKeys, after);\n        }\n    }","commit_id":"ac469ed5ebd20af356eeda16e327fb2a3385bed4","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private static void addMatchingKeys(\n            Set<String> keys, NodeState state, Iterable<String> propertyNames) {\n        for (String propertyName : propertyNames) {\n            PropertyState property = state.getProperty(propertyName);\n            if (property != null) {\n                addValueKeys(keys, property);\n            }\n        }\n    }","id":6509,"modified_method":"private static Set<String> getMatchingKeys(\n            NodeState state, Iterable<String> propertyNames) {\n        Set<String> keys = null;\n        for (String propertyName : propertyNames) {\n            PropertyState property = state.getProperty(propertyName);\n            if (property != null) {\n                keys = addValueKeys(keys, property);\n            }\n        }\n        return keys;\n    }","commit_id":"ac469ed5ebd20af356eeda16e327fb2a3385bed4","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void leave(NodeState before, NodeState after)\n            throws CommitFailedException {\n        if (beforeKeys != null) {\n            Set<String> sharedKeys = newHashSet(beforeKeys);\n            sharedKeys.retainAll(afterKeys);\n\n            beforeKeys.removeAll(sharedKeys);\n            afterKeys.removeAll(sharedKeys);\n\n            if (!beforeKeys.isEmpty() || !afterKeys.isEmpty()) {\n                NodeBuilder index = definition.child(INDEX_CONTENT_NODE_NAME);\n\n                getStrategy(unique).update(index, getPath(), beforeKeys, afterKeys);\n                if (unique) {\n                    keysToCheckForUniqueness.addAll(afterKeys);\n                }\n            }\n        }\n\n        if (parent == null) {\n            // make sure that the index node exist, even with no content\n            definition.child(INDEX_CONTENT_NODE_NAME);\n\n            // check uniqueness constraints when leaving the root\n            if (unique && !keysToCheckForUniqueness.isEmpty()) {\n                NodeState indexMeta = definition.getNodeState();\n                IndexStoreStrategy s = getStrategy(unique);\n                for (String key : keysToCheckForUniqueness) {\n                    if (s.count(indexMeta, singleton(key), 2) > 1) {\n                        throw new CommitFailedException(\n                                CONSTRAINT, 30,\n                                \"Uniqueness constraint violated for key \" + key);\n                    }\n                }\n            }\n        }\n    }","id":6510,"modified_method":"@Override\n    public void leave(NodeState before, NodeState after)\n            throws CommitFailedException {\n        // apply the type restrictions\n        if (typePredicate != null) {\n            if (typeChanged) {\n                // possible type change, so ignore diff results and\n                // just load all matching values from both states\n                beforeKeys = getMatchingKeys(before, propertyNames);\n                afterKeys = getMatchingKeys(after, propertyNames);\n            }\n            if (beforeKeys != null && !typePredicate.apply(before)) {\n                // the before state doesn't match the type, so clear its values\n                beforeKeys = null;\n            }\n            if (afterKeys != null && !typePredicate.apply(after)) {\n                // the after state doesn't match the type, so clear its values\n                afterKeys = null;\n            }\n        }\n\n        // if any changes were detected, update the index accordingly\n        if (beforeKeys != null || afterKeys != null) {\n            // first make sure that both the before and after sets are non-null\n            if (beforeKeys == null\n                    || (typePredicate != null && !typePredicate.apply(before))) {\n                beforeKeys = newHashSet();\n            } else if (afterKeys == null) {\n                afterKeys = newHashSet();\n            } else {\n                // both before and after matches found, remove duplicates\n                Set<String> sharedKeys = newHashSet(beforeKeys);\n                sharedKeys.retainAll(afterKeys);\n                beforeKeys.removeAll(sharedKeys);\n                afterKeys.removeAll(sharedKeys);\n            }\n\n            if (!beforeKeys.isEmpty() || !afterKeys.isEmpty()) {\n                NodeBuilder index = definition.child(INDEX_CONTENT_NODE_NAME);\n                getStrategy(keysToCheckForUniqueness != null).update(\n                        index, getPath(), beforeKeys, afterKeys);\n                if (keysToCheckForUniqueness != null) {\n                    keysToCheckForUniqueness.addAll(afterKeys);\n                }\n            }\n        }\n\n        if (parent == null) {\n            // make sure that the index node exist, even with no content\n            definition.child(INDEX_CONTENT_NODE_NAME);\n\n            // check uniqueness constraints when leaving the root\n            if (keysToCheckForUniqueness != null\n                    && !keysToCheckForUniqueness.isEmpty()) {\n                NodeState indexMeta = definition.getNodeState();\n                IndexStoreStrategy s = getStrategy(true);\n                for (String key : keysToCheckForUniqueness) {\n                    if (s.count(indexMeta, singleton(key), 2) > 1) {\n                        throw new CommitFailedException(\n                                CONSTRAINT, 30,\n                                \"Uniqueness constraint violated for key \" + key);\n                    }\n                }\n            }\n        }\n    }","commit_id":"ac469ed5ebd20af356eeda16e327fb2a3385bed4","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public String toString() {\n        return union(primaryTypes, mixinTypes).toString();\n    }","id":6511,"modified_method":"@Override\n    public String toString() {\n        return Iterables.toString(names);\n    }","commit_id":"ac469ed5ebd20af356eeda16e327fb2a3385bed4","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Creates a predicate for checking whether a node state is an instance of\n     * the named node type. This is an O(1) operation in terms of item\n     * accesses.\n     *\n     * @param root root node state\n     * @param name Oak name of the node type to check for\n     */\n    public TypePredicate(@Nonnull NodeState root, @Nonnull String name) {\n        NodeState types = checkNotNull(root)\n                .getChildNode(JCR_SYSTEM)\n                .getChildNode(JCR_NODE_TYPES);\n        addNodeType(types, checkNotNull(name));\n    }","id":6512,"modified_method":"/**\n     * Creates a predicate for checking whether a node state is an instance of\n     * the named node type. This is an O(1) operation in terms of item\n     * accesses.\n     *\n     * @param root root node state\n     * @param name Oak name of the node type to check for\n     */\n    public TypePredicate(@Nonnull NodeState root, @Nonnull String name) {\n        this(root, singleton(name));\n    }","commit_id":"ac469ed5ebd20af356eeda16e327fb2a3385bed4","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean apply(NodeState input) {\n        return primaryTypes.contains(input.getName(JCR_PRIMARYTYPE))\n                || any(input.getNames(JCR_MIXINTYPES), in(mixinTypes));\n    }","id":6513,"modified_method":"@Override\n    public boolean apply(NodeState input) {\n        if (primaryTypes == null) {\n            // lazy initialization of the sets of matching type names\n            primaryTypes = newHashSet();\n            mixinTypes = newHashSet();\n            NodeState types = checkNotNull(root)\n                    .getChildNode(JCR_SYSTEM)\n                    .getChildNode(JCR_NODE_TYPES);\n            for (String name : checkNotNull(names)) {\n                addNodeType(types, name);\n            }\n        }\n\n        return primaryTypes.contains(input.getName(JCR_PRIMARYTYPE))\n                || any(input.getNames(JCR_MIXINTYPES), in(mixinTypes));\n    }","commit_id":"ac469ed5ebd20af356eeda16e327fb2a3385bed4","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Creates a predicate for checking whether a node state is an instance of\n     * any of the named node types. This is an O(n) operation in terms of item\n     * accesses, with n being the number of given node types.\n     *\n     * @param root root node state\n     * @param names Oak names of the node types to check for\n     */\n    public TypePredicate(\n            @Nonnull NodeState root, @Nonnull Iterable<String> names) {\n        NodeState types = checkNotNull(root)\n                .getChildNode(JCR_SYSTEM)\n                .getChildNode(JCR_NODE_TYPES);\n        for (String name : checkNotNull(names)) {\n            addNodeType(types, name);\n        }\n    }","id":6514,"modified_method":"/**\n     * Creates a predicate for checking whether a node state is an instance of\n     * any of the named node types. This is an O(n) operation in terms of item\n     * accesses, with n being the number of given node types.\n     *\n     * @param root root node state\n     * @param names Oak names of the node types to check for\n     */\n    public TypePredicate(\n            @Nonnull NodeState root, @Nonnull Iterable<String> names) {\n        this.root = root;\n        this.names = names;\n    }","commit_id":"ac469ed5ebd20af356eeda16e327fb2a3385bed4","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Creates an instance of <tt>ChatConversationPanel<\/tt>.\n     *\n     * @param chatContainer The parent <tt>ChatConversationContainer<\/tt>.\n     */\n    public ChatConversationPanel(ChatConversationContainer chatContainer)\n    {\n        editorKit = new ChatConversationEditorKit(this);\n\n        this.chatContainer = chatContainer;\n\n        isHistory = (chatContainer instanceof HistoryWindow);\n\n        this.rightButtonMenu = new ChatRightButtonMenu(this);\n\n        this.document = (HTMLDocument) editorKit.createDefaultDocument();\n\n        this.document.addDocumentListener(editorKit);\n\n        this.chatTextPane.setEditorKitForContentType(\"text/html\", editorKit);\n        this.chatTextPane.setEditorKit(editorKit);\n        this.chatTextPane.setEditable(false);\n        this.chatTextPane.setDocument(document);\n        this.chatTextPane.setDragEnabled(true);\n\n        chatTextPane.putClientProperty(\n            JEditorPane.HONOR_DISPLAY_PROPERTIES, Boolean.TRUE);\n        Constants.loadSimpleStyle(\n            document.getStyleSheet(), chatTextPane.getFont());\n\n        this.chatTextPane.addHyperlinkListener(this);\n        this.chatTextPane.addMouseListener(this);\n        this.chatTextPane.setCursor(\n            Cursor.getPredefinedCursor(Cursor.TEXT_CURSOR));\n\n        this.addChatLinkClickedListener(showPreview);\n\n        this.setWheelScrollingEnabled(true);\n\n        this.setViewportView(chatTextPane);\n\n        this.setBorder(null);\n\n        this.setHorizontalScrollBarPolicy(\n            JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n\n        ToolTipManager.sharedInstance().registerComponent(chatTextPane);\n\n        String copyLinkString\n            = GuiActivator.getResources().getI18NString(\"service.gui.COPY_LINK\");\n\n        copyLinkItem\n            = new JMenuItem(copyLinkString,\n                new ImageIcon(ImageLoader.getImage(ImageLoader.COPY_ICON)));\n\n        copyLinkItem.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                StringSelection stringSelection = new StringSelection(\n                    currentHref);\n                Clipboard clipboard = Toolkit.getDefaultToolkit()\n                    .getSystemClipboard();\n                clipboard.setContents(stringSelection,\n                    ChatConversationPanel.this);\n            }\n        });\n\n        String openLinkString\n            = GuiActivator.getResources().getI18NString(\n                \"service.gui.OPEN_IN_BROWSER\");\n\n        openLinkItem =\n            new JMenuItem(\n                openLinkString,\n                new ImageIcon(ImageLoader.getImage(ImageLoader.BROWSER_ICON)));\n\n        openLinkItem.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                GuiActivator.getBrowserLauncher().openURL(currentHref);\n\n                // after opening the link remove the currentHref to avoid\n                // clicking on the window to gain focus to open the link again\n                ChatConversationPanel.this.currentHref = \"\";\n            }\n        });\n\n        openLinkItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\n                \"service.gui.OPEN_IN_BROWSER\"));\n\n        copyLinkItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\n                \"service.gui.COPY_LINK\"));\n\n        this.isSimpleTheme = ConfigurationUtils.isChatSimpleThemeEnabled();\n\n        /*\n         * When we append a new message (regardless of whether it is a string or\n         * an UI component), we want to make it visible in the viewport of this\n         * JScrollPane so that the user can see it.\n         */\n        ComponentListener componentListener = new ComponentAdapter()\n        {\n            @Override\n            public void componentResized(ComponentEvent e)\n            {\n                synchronized (scrollToBottomRunnable)\n                {\n                    if (!scrollToBottomIsPending)\n                        return;\n                    scrollToBottomIsPending = false;\n\n                    /*\n                     * Yana Stamcheva, pointed out that Java 5 (on Linux only?)\n                     * needs invokeLater for JScrollBar.\n                     */\n                    SwingUtilities.invokeLater(scrollToBottomRunnable);\n                }\n            }\n        };\n\n        chatTextPane.addComponentListener(componentListener);\n        getViewport().addComponentListener(componentListener);\n    }","id":6515,"modified_method":"/**\n     * Creates an instance of <tt>ChatConversationPanel<\/tt>.\n     *\n     * @param chatContainer The parent <tt>ChatConversationContainer<\/tt>.\n     */\n    public ChatConversationPanel(ChatConversationContainer chatContainer)\n    {\n        editorKit = new ChatConversationEditorKit(this);\n\n        this.chatContainer = chatContainer;\n\n        isHistory = (chatContainer instanceof HistoryWindow);\n\n        this.rightButtonMenu = new ChatRightButtonMenu(this);\n\n        this.document = (HTMLDocument) editorKit.createDefaultDocument();\n\n        this.document.addDocumentListener(editorKit);\n\n        this.chatTextPane.setEditorKitForContentType(\"text/html\", editorKit);\n        this.chatTextPane.setEditorKit(editorKit);\n        this.chatTextPane.setEditable(false);\n        this.chatTextPane.setDocument(document);\n        this.chatTextPane.setDragEnabled(true);\n\n        chatTextPane.putClientProperty(\n            JEditorPane.HONOR_DISPLAY_PROPERTIES, Boolean.TRUE);\n        Constants.loadSimpleStyle(\n            document.getStyleSheet(), chatTextPane.getFont());\n\n        this.chatTextPane.addHyperlinkListener(this);\n        this.chatTextPane.addMouseListener(this);\n        this.chatTextPane.setCursor(\n            Cursor.getPredefinedCursor(Cursor.TEXT_CURSOR));\n\n        this.addChatLinkClickedListener(showPreview);\n\n        this.setWheelScrollingEnabled(true);\n\n        this.setViewportView(chatTextPane);\n\n        this.setBorder(null);\n\n        this.setHorizontalScrollBarPolicy(\n            JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n\n        ToolTipManager.sharedInstance().registerComponent(chatTextPane);\n\n        String copyLinkString\n            = GuiActivator.getResources().getI18NString(\"service.gui.COPY_LINK\");\n\n        copyLinkItem\n            = new JMenuItem(copyLinkString,\n                new ImageIcon(ImageLoader.getImage(ImageLoader.COPY_ICON)));\n\n        copyLinkItem.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                StringSelection stringSelection = new StringSelection(\n                    currentHref);\n                Clipboard clipboard = Toolkit.getDefaultToolkit()\n                    .getSystemClipboard();\n                clipboard.setContents(stringSelection,\n                    ChatConversationPanel.this);\n            }\n        });\n\n        String openLinkString\n            = GuiActivator.getResources().getI18NString(\n                \"service.gui.OPEN_IN_BROWSER\");\n\n        openLinkItem =\n            new JMenuItem(\n                openLinkString,\n                new ImageIcon(ImageLoader.getImage(ImageLoader.BROWSER_ICON)));\n\n        openLinkItem.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                GuiActivator.getBrowserLauncher().openURL(currentHref);\n\n                // after opening the link remove the currentHref to avoid\n                // clicking on the window to gain focus to open the link again\n                ChatConversationPanel.this.currentHref = \"\";\n            }\n        });\n\n        openLinkItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\n                \"service.gui.OPEN_IN_BROWSER\"));\n\n        copyLinkItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\n                \"service.gui.COPY_LINK\"));\n\n        configureReplacementItem = new JMenuItem(\n            GuiActivator.getResources().getI18NString(\n                \"plugin.chatconfig.replacement.CONFIGURE_REPLACEMENT\"),\n            GuiActivator.getResources().getImage(\n                \"service.gui.icons.CONFIGURE_ICON\"));\n\n        configureReplacementItem.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                final ConfigurationContainer configContainer\n                    = GuiActivator.getUIService().getConfigurationContainer();\n\n                ConfigurationForm chatConfigForm = getChatConfigForm();\n\n                if (chatConfigForm != null)\n                {\n                    configContainer.setSelected(chatConfigForm);\n\n                    configContainer.setVisible(true);\n                }\n            }\n        });\n\n        this.isSimpleTheme = ConfigurationUtils.isChatSimpleThemeEnabled();\n\n        /*\n         * When we append a new message (regardless of whether it is a string or\n         * an UI component), we want to make it visible in the viewport of this\n         * JScrollPane so that the user can see it.\n         */\n        ComponentListener componentListener = new ComponentAdapter()\n        {\n            @Override\n            public void componentResized(ComponentEvent e)\n            {\n                synchronized (scrollToBottomRunnable)\n                {\n                    if (!scrollToBottomIsPending)\n                        return;\n                    scrollToBottomIsPending = false;\n\n                    /*\n                     * Yana Stamcheva, pointed out that Java 5 (on Linux only?)\n                     * needs invokeLater for JScrollBar.\n                     */\n                    SwingUtilities.invokeLater(scrollToBottomRunnable);\n                }\n            }\n        };\n\n        chatTextPane.addComponentListener(componentListener);\n        getViewport().addComponentListener(componentListener);\n    }","commit_id":"fb3f68714c6bba4565c623222bf6a39b2acf0a24","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Opens a link in the default browser when clicked and shows link url in a\n     * popup on mouseover.\n     *\n     * @param e The HyperlinkEvent.\n     */\n    public void hyperlinkUpdate(HyperlinkEvent e)\n    {\n        if (e.getEventType() == HyperlinkEvent.EventType.ENTERED)\n        {\n            String href = e.getDescription();\n\n            this.currentHref = href;\n        }\n        else if (e.getEventType() == HyperlinkEvent.EventType.EXITED)\n        {\n            this.currentHref = \"\";\n        }\n    }","id":6516,"modified_method":"/**\n     * Opens a link in the default browser when clicked and shows link url in a\n     * popup on mouseover.\n     *\n     * @param e The HyperlinkEvent.\n     */\n    public void hyperlinkUpdate(HyperlinkEvent e)\n    {\n        if (e.getEventType() == HyperlinkEvent.EventType.ENTERED)\n        {\n            String href = e.getDescription();\n\n            this.isCurrentHrefImg\n                = e.getSourceElement().getName().equals(\"img\");\n            this.currentHref = href;\n        }\n        else if (e.getEventType() == HyperlinkEvent.EventType.EXITED)\n        {\n            this.currentHref = \"\";\n            this.isCurrentHrefImg = false;\n        }\n    }","commit_id":"fb3f68714c6bba4565c623222bf6a39b2acf0a24","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n         * Process content between plaintext nodes.\n         * @param plainText the nodes text.\n         * @param msgBuff the currently accumulated buffer.\n         * @param pattern the pattern for current replacement service,\n         * created earlier so we don't create it for every text we check.\n         * @param rService the replacement service.\n         * @param skipSmileys whether to skip processing smileys\n         */\n        private void processText(String plainText,\n                                 StringBuilder msgBuff,\n                                 Pattern pattern,\n                                 ReplacementService rService,\n                                 boolean skipSmileys)\n        {\n            Matcher m = pattern.matcher(plainText);\n\n            ConfigurationService cfg = GuiActivator.getConfigurationService();\n            boolean isSmiley\n                = rService instanceof SmiliesReplacementService;\n            boolean isDirectImage\n                = rService instanceof DirectImageReplacementService;\n            boolean isEnabledForSource\n                = cfg.getBoolean(\n                ReplacementProperty.getPropertyName(\n                    rService.getSourceName()), true);\n\n            int startPos = 0;\n            while (m.find())\n            {\n                msgBuff.append(plainText.substring(startPos, m.start()));\n                startPos = m.end();\n\n                String group = m.group();\n                String temp = rService.getReplacement(group);\n                String group0 = m.group(0);\n\n                if(!temp.equals(group0) || isDirectImage)\n                {\n                    if (isSmiley)\n                    {\n                        if (cfg.getBoolean(ReplacementProperty.\n                                getPropertyName(\"SMILEY\"),\n                            true)\n                            && !skipSmileys)\n                        {\n                            msgBuff.append(\n                                ChatHtmlUtils.createEndPlainTextTag(\n                                    contentType));\n                            msgBuff.append(\"<IMG SRC=\\\"\");\n                            msgBuff.append(temp);\n                            msgBuff.append(\"\\\" BORDER=\\\"0\\\" ALT=\\\"\");\n                            msgBuff.append(group0);\n                            msgBuff.append(\"\\\"><\/IMG>\");\n                            msgBuff.append(\n                                ChatHtmlUtils.createStartPlainTextTag(\n                                    contentType));\n                        }\n                        else\n                        {\n                            msgBuff.append(group);\n                        }\n                    }\n                    else if (isEnabled && isEnabledForSource)\n                    {\n                        if (isDirectImage)\n                        {\n                            DirectImageReplacementService service\n                                = (DirectImageReplacementService)rService;\n                            if (service.isDirectImage(group)\n                                && service.getImageSize(group) != -1)\n                            {\n                                msgBuff.append(\n                                    \"<IMG HEIGHT=\\\"90\\\" \"\n                                        + \"WIDTH=\\\"120\\\" SRC=\\\"\");\n                                msgBuff.append(temp);\n                                msgBuff.append(\"\\\" BORDER=\\\"0\\\" ALT=\\\"\");\n                                msgBuff.append(group0);\n                                msgBuff.append(\"\\\"><\/IMG>\");\n                            }\n                            else\n                            {\n                                msgBuff.append(group);\n                            }\n                        }\n                        else\n                        {\n                            msgBuff.append(\n                                \"<IMG HEIGHT=\\\"90\\\" \"\n                                    + \"WIDTH=\\\"120\\\" SRC=\\\"\");\n                            msgBuff.append(temp);\n                            msgBuff.append(\"\\\" BORDER=\\\"0\\\" ALT=\\\"\");\n                            msgBuff.append(group0);\n                            msgBuff.append(\"\\\"><\/IMG>\");\n                        }\n                    }\n                    else if (isProposalEnabled)\n                    {\n                        msgBuff.append(group);\n                        msgBuff.append(\n                            \"<\/A> <A href=\\\"jitsi://\"\n                                + showPreview.getClass().getName()\n                                + \"/SHOWPREVIEW?\" + messageID + \"#\"\n                                + linkCounter + \"\\\">\"\n                                + GuiActivator.getResources().\n                                getI18NString(\"service.gui.SHOW_PREVIEW\"));\n\n                        showPreview.getMsgIDandPositionToLink()\n                            .put(\n                                messageID + \"#\" + linkCounter++, group);\n                        showPreview.getLinkToReplacement()\n                            .put(\n                                group, temp);\n                    }\n                    else\n                    {\n                        msgBuff.append(group);\n                    }\n                }\n                else\n                {\n                    msgBuff.append(group);\n                }\n            }\n\n            msgBuff.append(plainText.substring(startPos));\n        }","id":6517,"modified_method":"/**\n         * Process content between plaintext nodes.\n         * @param plainText the nodes text.\n         * @param msgBuff the currently accumulated buffer.\n         * @param pattern the pattern for current replacement service,\n         * created earlier so we don't create it for every text we check.\n         * @param rService the replacement service.\n         * @param skipSmileys whether to skip processing smileys\n         */\n        private void processText(String plainText,\n                                 StringBuilder msgBuff,\n                                 Pattern pattern,\n                                 ReplacementService rService,\n                                 boolean skipSmileys)\n        {\n            Matcher m = pattern.matcher(plainText);\n\n            ConfigurationService cfg = GuiActivator.getConfigurationService();\n            boolean isSmiley\n                = rService instanceof SmiliesReplacementService;\n            boolean isDirectImage\n                = rService instanceof DirectImageReplacementService;\n            boolean isEnabledForSource\n                = cfg.getBoolean(\n                ReplacementProperty.getPropertyName(\n                    rService.getSourceName()), true);\n\n            int startPos = 0;\n            while (m.find())\n            {\n                msgBuff.append(plainText.substring(startPos, m.start()));\n                startPos = m.end();\n\n                String group = m.group();\n                String temp = rService.getReplacement(group);\n                String group0 = m.group(0);\n\n                if(!temp.equals(group0) || isDirectImage)\n                {\n                    if (isSmiley)\n                    {\n                        if (cfg.getBoolean(ReplacementProperty.\n                                getPropertyName(\"SMILEY\"),\n                            true)\n                            && !skipSmileys)\n                        {\n                            msgBuff.append(\n                                ChatHtmlUtils.createEndPlainTextTag(\n                                    contentType));\n                            msgBuff.append(\"<IMG SRC=\\\"\");\n                            msgBuff.append(temp);\n                            msgBuff.append(\"\\\" BORDER=\\\"0\\\" ALT=\\\"\");\n                            msgBuff.append(group0);\n                            msgBuff.append(\"\\\"><\/IMG>\");\n                            msgBuff.append(\n                                ChatHtmlUtils.createStartPlainTextTag(\n                                    contentType));\n                        }\n                        else\n                        {\n                            msgBuff.append(group);\n                        }\n                    }\n                    else if (isProposalEnabled)\n                    {\n                        msgBuff.append(group);\n                        msgBuff.append(\n                            \"<\/A> <A href=\\\"jitsi://\"\n                                + showPreview.getClass().getName()\n                                + \"/SHOWPREVIEW?\" + messageID + \"#\"\n                                + linkCounter + \"\\\">\"\n                                + GuiActivator.getResources().\n                                getI18NString(\"service.gui.SHOW_PREVIEW\"));\n\n                        showPreview.getMsgIDandPositionToLink()\n                            .put(\n                                messageID + \"#\" + linkCounter++, group);\n                        showPreview.getLinkToReplacement()\n                            .put(\n                                group, temp);\n                    }\n                    else if (isEnabled && isEnabledForSource)\n                    {\n                        if (isDirectImage)\n                        {\n                            DirectImageReplacementService service\n                                = (DirectImageReplacementService)rService;\n                            if (service.isDirectImage(group)\n                                && service.getImageSize(group) != -1)\n                            {\n                                msgBuff.append(\n                                    \"<IMG HEIGHT=\\\"90\\\" \"\n                                        + \"WIDTH=\\\"120\\\" SRC=\\\"\");\n                                msgBuff.append(temp);\n                                msgBuff.append(\"\\\" BORDER=\\\"0\\\" ALT=\\\"\");\n                                msgBuff.append(group0);\n                                msgBuff.append(\"\\\"><\/IMG>\");\n                            }\n                            else\n                            {\n                                msgBuff.append(group);\n                            }\n                        }\n                        else\n                        {\n                            msgBuff.append(\n                                \"<IMG HEIGHT=\\\"90\\\" \"\n                                    + \"WIDTH=\\\"120\\\" SRC=\\\"\");\n                            msgBuff.append(temp);\n                            msgBuff.append(\"\\\" BORDER=\\\"0\\\" ALT=\\\"\");\n                            msgBuff.append(group0);\n                            msgBuff.append(\"\\\"><\/IMG>\");\n                        }\n                    }\n                    else\n                    {\n                        msgBuff.append(group);\n                    }\n                }\n                else\n                {\n                    msgBuff.append(group);\n                }\n            }\n\n            msgBuff.append(plainText.substring(startPos));\n        }","commit_id":"fb3f68714c6bba4565c623222bf6a39b2acf0a24","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Opens this panel context menu at the given point.\n     *\n     * @param p the point where to position the left-top cornet of the context\n     *            menu\n     */\n    private void openContextMenu(Point p)\n    {\n        if (currentHref != null && currentHref.length() != 0\n                && !currentHref.startsWith(\"jitsi://\"))\n        {\n            rightButtonMenu.insert(openLinkItem, 0);\n            rightButtonMenu.insert(copyLinkItem, 1);\n            rightButtonMenu.insert(copyLinkSeparator, 2);\n        }\n        else\n        {\n            rightButtonMenu.remove(openLinkItem);\n            rightButtonMenu.remove(copyLinkItem);\n            rightButtonMenu.remove(copyLinkSeparator);\n        }\n\n        if (chatTextPane.getSelectedText() != null)\n        {\n            rightButtonMenu.enableCopy();\n        }\n        else\n        {\n            rightButtonMenu.disableCopy();\n        }\n        rightButtonMenu.setInvoker(chatTextPane);\n        rightButtonMenu.setLocation(p.x, p.y);\n        rightButtonMenu.setVisible(true);\n    }","id":6518,"modified_method":"/**\n     * Opens this panel context menu at the given point.\n     *\n     * @param p the point where to position the left-top cornet of the context\n     *            menu\n     */\n    private void openContextMenu(Point p)\n    {\n        if (currentHref != null && currentHref.length() != 0\n                && !currentHref.startsWith(\"jitsi://\"))\n        {\n            rightButtonMenu.insert(openLinkItem, 0);\n            rightButtonMenu.insert(copyLinkItem, 1);\n            rightButtonMenu.insert(copyLinkSeparator, 2);\n            if(isCurrentHrefImg)\n            {\n                rightButtonMenu.insert(configureReplacementItem, 3);\n                rightButtonMenu.insert(configureReplacementSeparator, 4);\n            }\n        }\n        else\n        {\n            rightButtonMenu.remove(openLinkItem);\n            rightButtonMenu.remove(copyLinkItem);\n            rightButtonMenu.remove(copyLinkSeparator);\n            rightButtonMenu.remove(configureReplacementItem);\n            rightButtonMenu.remove(configureReplacementSeparator);\n        }\n\n        if (chatTextPane.getSelectedText() != null)\n        {\n            rightButtonMenu.enableCopy();\n        }\n        else\n        {\n            rightButtonMenu.disableCopy();\n        }\n        rightButtonMenu.setInvoker(chatTextPane);\n        rightButtonMenu.setLocation(p.x, p.y);\n        rightButtonMenu.setVisible(true);\n    }","commit_id":"fb3f68714c6bba4565c623222bf6a39b2acf0a24","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Implements <code>ApplicationWindow.show<\/code> method.\n     *\n     * @param isVisible specifies whether the frame is to be visible or not.\n     */\n    @Override\n    public void setVisible(final boolean isVisible)\n    {\n        if(!SwingUtilities.isEventDispatchThread())\n        {\n            SwingUtilities.invokeLater(new Runnable()\n            {\n                public void run()\n                {\n                    setVisible(isVisible);\n                }\n            });\n            return;\n        }\n\n        if (isVisible && configList.getSelectedIndex() < 0)\n        {\n            this.configList.setSelectedIndex(0);\n        }\n        super.setVisible(isVisible);\n    }","id":6519,"modified_method":"/**\n     * Implements <code>ApplicationWindow.show<\/code> method.\n     *\n     * @param isVisible specifies whether the frame is to be visible or not.\n     */\n    @Override\n    public void setVisible(final boolean isVisible)\n    {\n        if(!SwingUtilities.isEventDispatchThread())\n        {\n            SwingUtilities.invokeLater(new Runnable()\n            {\n                public void run()\n                {\n                    setVisible(isVisible);\n                }\n            });\n            return;\n        }\n\n        if (isVisible && configList.getSelectedIndex() < 0)\n        {\n            this.configList.setSelectedIndex(0);\n        }\n        super.setVisible(isVisible);\n        super.toFront();\n    }","commit_id":"fb3f68714c6bba4565c623222bf6a39b2acf0a24","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Init the main panel.\n     *\n     * @return the created component\n     */\n    private Component createMainPanel()\n    {\n        JPanel mainPanel = new TransparentPanel(new BorderLayout());\n\n        mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));\n\n        enableSmiley =\n            new SIPCommCheckBox(ChatConfigActivator.getResources()\n                .getI18NString(\n                    \"plugin.chatconfig.replacement.ENABLE_SMILEY_STATUS\"));\n\n        mainPanel.add(enableSmiley, BorderLayout.WEST);\n\n        enableSmiley.addActionListener(new ActionListener()\n        {\n\n            public void actionPerformed(ActionEvent e)\n            {\n                saveData();\n            }\n        });\n\n        mainPanel.add(Box.createVerticalStrut(10));\n\n        enableReplacement =\n            new SIPCommCheckBox(ChatConfigActivator.getResources()\n                .getI18NString(\n                    \"plugin.chatconfig.replacement.ENABLE_REPLACEMENT_STATUS\"));\n\n        mainPanel.add(enableReplacement, BorderLayout.WEST);\n\n        enableReplacement.addActionListener(new ActionListener()\n        {\n\n            public void actionPerformed(ActionEvent e)\n            {\n                saveData();\n                table.revalidate();\n                table.repaint();\n            }\n        });\n\n        mainPanel.add(Box.createVerticalStrut(10));\n\n        enableReplacementProposal =\n            new SIPCommCheckBox(ChatConfigActivator.getResources()\n                .getI18NString(\n                    \"plugin.chatconfig.replacement.ENABLE_REPLACEMENT_PROPOSAL\"));\n\n        mainPanel.add(enableReplacementProposal, BorderLayout.WEST);\n\n        enableReplacementProposal.addActionListener(new ActionListener(){\n\n            public void actionPerformed(ActionEvent arg0)\n            {\n                saveData();\n            }\n        });\n\n        // the Jtable to list all the available sources\n        table = new JTable();\n        table.setShowGrid(false);\n        table.setTableHeader(null);\n\n        table.setOpaque(true);\n        table.setBackground(Color.white);\n\n        JScrollPane tablePane = new JScrollPane(table);\n        tablePane.setOpaque(false);\n        tablePane.setPreferredSize(new Dimension(mainPanel.getWidth(), 150));\n        tablePane.setAlignmentX(LEFT_ALIGNMENT);\n\n        JPanel container = new TransparentPanel(new BorderLayout());\n        container.setPreferredSize(new Dimension(mainPanel.getWidth(), 200));\n        container.setLayout(new BoxLayout(container, BoxLayout.Y_AXIS));\n\n        JLabel label =\n            new JLabel(ChatConfigActivator.getResources().getI18NString(\n                \"plugin.chatconfig.replacement.REPLACEMENT_SOURCES\"));\n        label.setDisplayedMnemonic(ChatConfigActivator.getResources()\n            .getI18nMnemonic(\n                \"plugin.chatconfig.replacement.REPLACEMENT_SOURCES\"));\n        label.setLabelFor(table);\n\n        container.add(label);\n        container.add(Box.createRigidArea(new Dimension(0, 5)));\n        container.add(tablePane, BorderLayout.EAST);\n\n        /*\n         * list of the source names. Removing 'Smiley' as it shouldn't show up in\n         * the table.\n         */\n        Set<String> keys = ChatConfigActivator.getReplacementSources().keySet();\n        ArrayList<String> sourceList = new ArrayList<String>(keys);\n        sourceList.remove(\"SMILEY\");\n\n        Collections.sort(sourceList);\n\n        table.setModel(new ReplacementConfigurationTableModel(sourceList));\n\n        table.getSelectionModel().addListSelectionListener(\n            new ListSelectionListener()\n            {\n                public void valueChanged(ListSelectionEvent e)\n                {\n                    if (e.getValueIsAdjusting())\n                        return;\n                    if (table.getSelectedRow() != -1)\n                    {\n                        boolean isEnabled =\n                            (Boolean) table.getValueAt(table.getSelectedRow(),\n                                0);\n\n                        if (isEnabled)\n                        {\n                            enableReplacement.setSelected(true);\n                        }\n                    }\n                }\n            });\n\n        TableColumnModel tableColumnModel = table.getColumnModel();\n        TableColumn tableColumn = tableColumnModel.getColumn(0);\n        tableColumn.setMaxWidth(tableColumn.getMinWidth());\n        table.setDefaultRenderer(table.getColumnClass(1),\n            new FixedTableCellRenderer());\n\n        mainPanel.add(Box.createVerticalStrut(10));\n        mainPanel.add(container, BorderLayout.WEST);\n\n        return mainPanel;\n    }","id":6520,"modified_method":"/**\n     * Init the main panel.\n     *\n     * @return the created component\n     */\n    private Component createMainPanel()\n    {\n        JPanel mainPanel = new TransparentPanel();\n\n        mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));\n\n        ResourceManagementService R = ChatConfigActivator.getResources();\n\n        enableSmiley =\n            new SIPCommCheckBox(R.getI18NString(\n                    \"plugin.chatconfig.replacement.ENABLE_SMILEY_STATUS\"));\n\n        mainPanel.add(enableSmiley);\n\n        enableSmiley.addActionListener(new ActionListener()\n        {\n\n            public void actionPerformed(ActionEvent e)\n            {\n                saveData();\n            }\n        });\n\n        mainPanel.add(Box.createVerticalStrut(10));\n\n        JPanel replacementPanel = new TransparentPanel();\n        replacementPanel.setLayout(new BoxLayout(replacementPanel, BoxLayout.Y_AXIS));\n        replacementPanel.setBorder(\n            BorderFactory.createCompoundBorder(\n                BorderFactory.createTitledBorder(R.getI18NString(\n                    \"plugin.chatconfig.replacement.REPLACEMENT_TITLE\")),\n                BorderFactory.createEmptyBorder(3, 3, 3, 3)));\n\n        enableReplacement =\n            new SIPCommRadioButton(R.getI18NString(\n                    \"plugin.chatconfig.replacement.ENABLE_REPLACEMENT_STATUS\"));\n\n        replacementPanel.add(enableReplacement);\n\n        enableReplacement.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                saveData();\n            }\n        });\n\n        enableReplacementProposal =\n            new SIPCommRadioButton(R.getI18NString(\n                    \"plugin.chatconfig.replacement.ENABLE_REPLACEMENT_PROPOSAL\"\n                ));\n\n        replacementPanel.add(enableReplacementProposal);\n\n        enableReplacementProposal.addActionListener(new ActionListener(){\n\n            public void actionPerformed(ActionEvent arg0)\n            {\n                saveData();\n            }\n        });\n        disableReplacement = new SIPCommRadioButton(R.getI18NString(\n            \"plugin.chatconfig.replacement.DISABLE_REPLACEMENT\"));\n\n        replacementPanel.add(disableReplacement);\n\n        disableReplacement.addActionListener(new ActionListener(){\n\n            public void actionPerformed(ActionEvent arg0)\n            {\n                saveData();\n            }\n        });\n\n        ButtonGroup replacementGroup = new ButtonGroup();\n        replacementGroup.add(enableReplacement);\n        replacementGroup.add(enableReplacementProposal);\n        replacementGroup.add(disableReplacement);\n\n        // the JTable to list all the available sources\n        table = new JTable();\n        table.setShowGrid(false);\n        table.setTableHeader(null);\n\n        table.setOpaque(true);\n        table.setBackground(Color.white);\n\n        JScrollPane tablePane = new JScrollPane(table);\n        tablePane.setOpaque(false);\n        tablePane.setPreferredSize(\n            new Dimension(replacementPanel.getWidth(), 150));\n        tablePane.setAlignmentX(LEFT_ALIGNMENT);\n\n        JPanel container = new TransparentPanel(new BorderLayout());\n        container.setPreferredSize(\n            new Dimension(replacementPanel.getWidth(), 200));\n        container.setLayout(new BoxLayout(container, BoxLayout.Y_AXIS));\n\n        JLabel label =\n            new JLabel(R.getI18NString(\n                \"plugin.chatconfig.replacement.REPLACEMENT_SOURCES\"));\n        label.setDisplayedMnemonic(R.getI18nMnemonic(\n                \"plugin.chatconfig.replacement.REPLACEMENT_SOURCES\"));\n        label.setLabelFor(table);\n\n        container.add(label);\n        container.add(Box.createRigidArea(new Dimension(0, 5)));\n        container.add(tablePane, BorderLayout.EAST);\n\n        /*\n         * list of the source names. Removing 'Smiley' as it shouldn't show up in\n         * the table.\n         */\n        Set<String> keys = ChatConfigActivator.getReplacementSources().keySet();\n        ArrayList<String> sourceList = new ArrayList<String>(keys);\n        sourceList.remove(\"SMILEY\");\n\n        Collections.sort(sourceList);\n\n        table.setModel(new ReplacementConfigurationTableModel(sourceList));\n\n        table.getSelectionModel().addListSelectionListener(\n            new ListSelectionListener()\n            {\n                public void valueChanged(ListSelectionEvent e)\n                {\n                    if (e.getValueIsAdjusting())\n                        return;\n                    if (table.getSelectedRow() != -1)\n                    {\n                        boolean isEnabled =\n                            (Boolean) table.getValueAt(table.getSelectedRow(),\n                                0);\n\n                        if (isEnabled)\n                        {\n                            enableReplacement.setSelected(true);\n                        }\n                    }\n                }\n            });\n\n        TableColumnModel tableColumnModel = table.getColumnModel();\n        TableColumn tableColumn = tableColumnModel.getColumn(0);\n        tableColumn.setMaxWidth(tableColumn.getMinWidth());\n        table.setDefaultRenderer(table.getColumnClass(1),\n            new FixedTableCellRenderer());\n\n        replacementPanel.add(Box.createVerticalStrut(10));\n        replacementPanel.add(container);\n\n        mainPanel.add(replacementPanel);\n\n        return mainPanel;\n    }","commit_id":"fb3f68714c6bba4565c623222bf6a39b2acf0a24","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Save data in the configuration file\n     */\n    private void saveData()\n    {\n        ConfigurationService configService =\n            ChatConfigActivator.getConfigurationService();\n\n        configService.setProperty(ReplacementProperty\n            .getPropertyName(ReplacementServiceSmileyImpl.SMILEY_SOURCE),\n            Boolean.toString(enableSmiley.isSelected()));\n\n        configService.setProperty(ReplacementProperty.REPLACEMENT_ENABLE,\n            Boolean.toString(enableReplacement.isSelected()));\n\n        boolean e = enableReplacement.isSelected();\n\n        enableReplacementProposal.setEnabled(!e);\n        configService.setProperty(\n            \"plugin.chatconfig.replacement.proposal.enable\"\n            , Boolean.toString(!e && enableReplacementProposal.isSelected()));\n\n        table.getSelectionModel().clearSelection();\n        table.setEnabled(e);\n    }","id":6521,"modified_method":"/**\n     * Save data in the configuration file\n     */\n    private void saveData()\n    {\n        ConfigurationService configService =\n            ChatConfigActivator.getConfigurationService();\n\n        configService.setProperty(ReplacementProperty\n            .getPropertyName(ReplacementServiceSmileyImpl.SMILEY_SOURCE),\n            Boolean.toString(enableSmiley.isSelected()));\n\n        configService.setProperty(ReplacementProperty.REPLACEMENT_ENABLE,\n            Boolean.toString(enableReplacement.isSelected()));\n\n        configService.setProperty(\n            \"plugin.chatconfig.replacement.proposal.enable\",\n            Boolean.toString(enableReplacementProposal.isSelected()));\n\n        table.getSelectionModel().clearSelection();\n        table.setEnabled(enableReplacement.isSelected()\n            || enableReplacementProposal.isSelected());\n    }","commit_id":"fb3f68714c6bba4565c623222bf6a39b2acf0a24","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Init the values of the widgets\n     */\n    private void initValues()\n    {\n        ConfigurationService configService =\n            ChatConfigActivator.getConfigurationService();\n\n        boolean e =\n            configService.getBoolean(ReplacementProperty\n                .getPropertyName(ReplacementServiceSmileyImpl.SMILEY_SOURCE),\n                true);\n        this.enableSmiley.setSelected(e);\n\n        e =\n            configService.getBoolean(ReplacementProperty.REPLACEMENT_ENABLE,\n                true);\n        this.enableReplacement.setSelected(e);\n\n        this.enableReplacementProposal.setEnabled(!e);\n        e =\n            configService.getBoolean(ReplacementProperty.REPLACEMENT_PROPOSAL,\n                true);\n        this.enableReplacementProposal.setSelected(e);\n\n        this.table.setEnabled(e);\n    }","id":6522,"modified_method":"/**\n     * Init the values of the widgets\n     */\n    private void initValues()\n    {\n        ConfigurationService configService =\n            ChatConfigActivator.getConfigurationService();\n\n        this.enableSmiley.setSelected(\n            configService.getBoolean(\n                ReplacementProperty.getPropertyName(\n                    ReplacementServiceSmileyImpl.SMILEY_SOURCE),\n                true));\n\n        this.enableReplacement.setSelected(\n            configService.getBoolean(\n                ReplacementProperty.REPLACEMENT_ENABLE, true));\n\n        this.enableReplacementProposal.setSelected(\n            configService.getBoolean(\n                ReplacementProperty.REPLACEMENT_PROPOSAL, true));\n\n        this.disableReplacement.setSelected(\n            !this.enableReplacement.isSelected()\n                && !this.enableReplacementProposal.isSelected());\n\n        this.table.setEnabled(enableReplacement.isSelected());\n    }","commit_id":"fb3f68714c6bba4565c623222bf6a39b2acf0a24","url":"https://github.com/jitsi/jitsi"},{"original_method":"@Override\n    public void chatLinkClicked(URI url)\n    {\n        String action = url.getPath();\n        if (action.equals(\"/SHOWPREVIEW\"))\n        {\n            enableReplacement.setSelected(\n                cfg.getBoolean(ReplacementProperty.REPLACEMENT_ENABLE, true));\n            enableReplacementProposal.setSelected(\n                cfg.getBoolean(ReplacementProperty.REPLACEMENT_PROPOSAL, true));\n\n            currentMessageID = url.getQuery();\n            currentLinkPosition = url.getFragment();\n\n            this.setVisible(true);\n            this.setLocationRelativeTo(chatPanel);\n        }\n    }","id":6523,"modified_method":"@Override\n    public void chatLinkClicked(URI url)\n    {\n        String action = url.getPath();\n        if (action.equals(\"/SHOWPREVIEW\"))\n        {\n            currentMessageID = url.getQuery();\n            currentLinkPosition = url.getFragment();\n\n            this.setVisible(true);\n            this.setLocationRelativeTo(chatPanel);\n        }\n    }","commit_id":"fb3f68714c6bba4565c623222bf6a39b2acf0a24","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates an instance of <tt>ShowPreviewDialog<\/tt>\n     * @param chatPanel The <tt>ChatConversationPanel<\/tt> that is associated\n     * with this dialog.\n     */\n    ShowPreviewDialog(final ChatConversationPanel chatPanel)\n    {\n        this.chatPanel = chatPanel;\n\n        this.setTitle(\n            GuiActivator.getResources().getI18NString(\n                \"service.gui.SHOW_PREVIEW_DIALOG_TITLE\"));\n        okButton = new JButton(\n            GuiActivator.getResources().getI18NString(\"service.gui.OK\"));\n        cancelButton = new JButton(\n            GuiActivator.getResources().getI18NString(\"service.gui.CANCEL\"));\n\n        JPanel mainPanel = new TransparentPanel();\n        mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));\n        mainPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n        //mainPanel.setPreferredSize(new Dimension(200, 150));\n        this.getContentPane().add(mainPanel);\n\n        JTextPane descriptionMsg = new JTextPane();\n        descriptionMsg.setEditable(false);\n        descriptionMsg.setOpaque(false);\n        descriptionMsg.setText(\n            GuiActivator.getResources().getI18NString(\n                \"service.gui.SHOW_PREVIEW_WARNING_DESCRIPTION\"));\n\n        Icon warningIcon = null;\n        try\n        {\n            warningIcon =\n                new ImageIcon(\n                    ImageIO.read(GuiActivator.getResources().getImageURL(\n                        \"service.gui.icons.WARNING_ICON\")));\n        }\n        catch (IOException e)\n        {\n            logger.debug(\"failed to load the warning icon\");\n        }\n        JLabel warningSign = new JLabel(warningIcon);\n\n        JPanel warningPanel = new TransparentPanel();\n        warningPanel.setLayout(new BoxLayout(warningPanel, BoxLayout.X_AXIS));\n        warningPanel.add(warningSign);\n        warningPanel.add(Box.createHorizontalStrut(10));\n        warningPanel.add(descriptionMsg);\n\n        enableReplacement\n            = new JCheckBox(\n                GuiActivator.getResources().getI18NString(\n                    \"plugin.chatconfig.replacement.ENABLE_REPLACEMENT_STATUS\"));\n        enableReplacement.setOpaque(false);\n        enableReplacement.setSelected(\n            cfg.getBoolean(ReplacementProperty.REPLACEMENT_ENABLE, true));\n        enableReplacementProposal\n            = new JCheckBox(\n                GuiActivator.getResources().getI18NString(\n                    \"plugin.chatconfig.replacement.ENABLE_REPLACEMENT_PROPOSAL\"));\n        enableReplacementProposal.setOpaque(false);\n\n        JPanel checkBoxPanel = new TransparentPanel();\n        checkBoxPanel.setLayout(new BoxLayout(checkBoxPanel, BoxLayout.Y_AXIS));\n        checkBoxPanel.add(enableReplacement);\n        checkBoxPanel.add(enableReplacementProposal);\n\n        JPanel buttonsPanel\n            = new TransparentPanel(new FlowLayout(FlowLayout.CENTER));\n        buttonsPanel.add(okButton);\n        buttonsPanel.add(cancelButton);\n\n        mainPanel.add(warningPanel);\n        mainPanel.add(Box.createVerticalStrut(10));\n        mainPanel.add(checkBoxPanel);\n        mainPanel.add(buttonsPanel);\n\n        okButton.addActionListener(this);\n        cancelButton.addActionListener(this);\n\n        this.setPreferredSize(new Dimension(390, 230));\n    }","id":6524,"modified_method":"/**\n     * Creates an instance of <tt>ShowPreviewDialog<\/tt>\n     * @param chatPanel The <tt>ChatConversationPanel<\/tt> that is associated\n     * with this dialog.\n     */\n    ShowPreviewDialog(final ChatConversationPanel chatPanel)\n    {\n        this.chatPanel = chatPanel;\n\n        this.setTitle(\n            GuiActivator.getResources().getI18NString(\n                \"service.gui.SHOW_PREVIEW_DIALOG_TITLE\"));\n        okButton = new JButton(\n            GuiActivator.getResources().getI18NString(\"service.gui.OK\"));\n        cancelButton = new JButton(\n            GuiActivator.getResources().getI18NString(\"service.gui.CANCEL\"));\n\n        JPanel mainPanel = new TransparentPanel();\n        mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));\n        mainPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n        //mainPanel.setPreferredSize(new Dimension(200, 150));\n        this.getContentPane().add(mainPanel);\n\n        JTextPane descriptionMsg = new JTextPane();\n        descriptionMsg.setEditable(false);\n        descriptionMsg.setOpaque(false);\n        descriptionMsg.setText(\n            GuiActivator.getResources().getI18NString(\n                \"service.gui.SHOW_PREVIEW_WARNING_DESCRIPTION\"));\n\n        Icon warningIcon = null;\n        try\n        {\n            warningIcon =\n                new ImageIcon(\n                    ImageIO.read(GuiActivator.getResources().getImageURL(\n                        \"service.gui.icons.WARNING_ICON\")));\n        }\n        catch (IOException e)\n        {\n            logger.debug(\"failed to load the warning icon\");\n        }\n        JLabel warningSign = new JLabel(warningIcon);\n\n        JPanel warningPanel = new TransparentPanel();\n        warningPanel.setLayout(new BoxLayout(warningPanel, BoxLayout.X_AXIS));\n        warningPanel.add(warningSign);\n        warningPanel.add(Box.createHorizontalStrut(10));\n        warningPanel.add(descriptionMsg);\n\n        configureReplacement\n            = new SIPCommCheckBox(\n                GuiActivator.getResources().getI18NString(\n                    \"plugin.chatconfig.replacement.CONFIGURE_REPLACEMENT\"));\n\n        JPanel checkBoxPanel = new TransparentPanel(\n            new FlowLayout(FlowLayout.CENTER));\n        checkBoxPanel.add(configureReplacement);\n\n        JPanel buttonsPanel\n            = new TransparentPanel(new FlowLayout(FlowLayout.CENTER));\n        buttonsPanel.add(okButton);\n        buttonsPanel.add(cancelButton);\n\n        mainPanel.add(warningPanel);\n        mainPanel.add(Box.createVerticalStrut(10));\n        mainPanel.add(checkBoxPanel);\n        mainPanel.add(buttonsPanel);\n\n        okButton.addActionListener(this);\n        cancelButton.addActionListener(this);\n\n        this.setPreferredSize(new Dimension(390, 230));\n    }","commit_id":"fb3f68714c6bba4565c623222bf6a39b2acf0a24","url":"https://github.com/jitsi/jitsi"},{"original_method":"@Override\n    public void actionPerformed(ActionEvent arg0)\n    {\n        if (arg0.getSource().equals(okButton))\n        {\n            cfg.setProperty(ReplacementProperty.REPLACEMENT_ENABLE,\n                enableReplacement.isSelected());\n            cfg.setProperty(ReplacementProperty.REPLACEMENT_PROPOSAL\n                , enableReplacementProposal.isSelected());\n            SwingWorker worker = new SwingWorker()\n            {\n                /**\n                 * Called on the event dispatching thread\n                 * (not on the worker thread) after the \n                 * <code>construct<\/code> method has returned.\n                 */\n                @Override\n                public void finished()\n                {\n                    String newChatString = (String)get();\n\n                    if (newChatString != null)\n                    {\n                        try\n                        {\n                            Element elem =\n                                chatPanel.document.getElement(currentMessageID);\n                            chatPanel.document.setOuterHTML(\n                                elem, newChatString);\n                            msgIDToChatString.put(\n                                currentMessageID, newChatString);\n                        }\n                        catch (BadLocationException ex)\n                        {\n                            logger.error(\"Could not replace chat message\", ex);\n                        }\n                        catch (IOException ex)\n                        {\n                            logger.error(\"Could not replace chat message\", ex);\n                        }\n                    }\n                }\n\n                @Override\n                protected Object construct() throws Exception\n                {\n                    String newChatString\n                        = msgIDToChatString.get(currentMessageID);\n                    try\n                    {\n                        String originalLink = msgIDandPositionToLink.get\n                            (currentMessageID + \"#\" + currentLinkPosition);\n                        String replacementLink\n                            = linkToReplacement.get(originalLink);\n                        String replacement;\n                        DirectImageReplacementService source\n                            = GuiActivator.getDirectImageReplacementSource();\n                        if (originalLink.equals(replacementLink) &&\n                            (!source.isDirectImage(originalLink) ||\n                                source.getImageSize(originalLink) == -1))\n                        {\n                            replacement = originalLink;\n                        }\n                        else\n                        {\n                            replacement =\n                                \"<IMG HEIGHT=\\\"90\\\" WIDTH=\\\"120\\\" SRC=\\\"\"\n                                + replacementLink + \"\\\" BORDER=\\\"0\\\" ALT=\\\"\"\n                                + originalLink + \"\\\"><\/IMG>\";\n                        }\n\n                        String old = originalLink + \"<\/A> <A href=\\\"jitsi://\"\n                            + ShowPreviewDialog.this.getClass().getName()\n                            + \"/SHOWPREVIEW?\" + currentMessageID + \"#\"\n                            + currentLinkPosition + \"\\\">\"\n                            + GuiActivator.getResources().\n                            getI18NString(\"service.gui.SHOW_PREVIEW\");\n\n                        newChatString = newChatString.replace(old, replacement);\n                    }\n                    catch (Exception ex)\n                    {\n                        logger.error(\"Could not replace chat message\", ex);\n                    }\n                    return newChatString;\n                }\n            };\n            worker.start();\n            this.setVisible(false);\n        }\n        else if (arg0.getSource().equals(cancelButton))\n        {\n            this.setVisible(false);\n        }\n    }","id":6525,"modified_method":"@Override\n    public void actionPerformed(ActionEvent arg0)\n    {\n        if (arg0.getSource().equals(okButton))\n        {\n            SwingWorker worker = new SwingWorker()\n            {\n                /**\n                 * Called on the event dispatching thread\n                 * (not on the worker thread) after the \n                 * <code>construct<\/code> method has returned.\n                 */\n                @Override\n                public void finished()\n                {\n                    String newChatString = (String)get();\n\n                    if (newChatString != null)\n                    {\n                        try\n                        {\n                            Element elem =\n                                chatPanel.document.getElement(currentMessageID);\n                            chatPanel.document.setOuterHTML(\n                                elem, newChatString);\n                            msgIDToChatString.put(\n                                currentMessageID, newChatString);\n                        }\n                        catch (BadLocationException ex)\n                        {\n                            logger.error(\"Could not replace chat message\", ex);\n                        }\n                        catch (IOException ex)\n                        {\n                            logger.error(\"Could not replace chat message\", ex);\n                        }\n                    }\n                }\n\n                @Override\n                protected Object construct() throws Exception\n                {\n                    String newChatString\n                        = msgIDToChatString.get(currentMessageID);\n                    try\n                    {\n                        String originalLink = msgIDandPositionToLink.get\n                            (currentMessageID + \"#\" + currentLinkPosition);\n                        String replacementLink\n                            = linkToReplacement.get(originalLink);\n                        String replacement;\n                        DirectImageReplacementService source\n                            = GuiActivator.getDirectImageReplacementSource();\n                        if (originalLink.equals(replacementLink) &&\n                            (!source.isDirectImage(originalLink) ||\n                                source.getImageSize(originalLink) == -1))\n                        {\n                            replacement = originalLink;\n                        }\n                        else\n                        {\n                            replacement =\n                                \"<IMG HEIGHT=\\\"90\\\" WIDTH=\\\"120\\\" SRC=\\\"\"\n                                + replacementLink + \"\\\" BORDER=\\\"0\\\" ALT=\\\"\"\n                                + originalLink + \"\\\"><\/IMG>\";\n                        }\n\n                        String old = originalLink + \"<\/A> <A href=\\\"jitsi://\"\n                            + ShowPreviewDialog.this.getClass().getName()\n                            + \"/SHOWPREVIEW?\" + currentMessageID + \"#\"\n                            + currentLinkPosition + \"\\\">\"\n                            + GuiActivator.getResources().\n                            getI18NString(\"service.gui.SHOW_PREVIEW\");\n\n                        newChatString = newChatString.replace(old, replacement);\n                    }\n                    catch (Exception ex)\n                    {\n                        logger.error(\"Could not replace chat message\", ex);\n                    }\n                    return newChatString;\n                }\n            };\n            worker.start();\n            this.setVisible(false);\n        }\n        else if (arg0.getSource().equals(cancelButton))\n        {\n            this.setVisible(false);\n        }\n\n        // Shows chat config panel\n        if(configureReplacement.isSelected())\n        {\n            ConfigurationContainer configContainer\n                = GuiActivator.getUIService().getConfigurationContainer();\n\n            ConfigurationForm chatConfigForm =\n                ChatConversationPanel.getChatConfigForm();\n\n            if(chatConfigForm != null)\n            {\n                configContainer.setSelected(chatConfigForm);\n\n                configContainer.setVisible(true);\n            }\n\n            // reset for next dialog appearance\n            configureReplacement.setSelected(false);\n        }\n    }","commit_id":"fb3f68714c6bba4565c623222bf6a39b2acf0a24","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Registers the settings item for non-MacOS X OS.\n     */\n    private void registerConfigMenuItemNonMacOSX()\n    {\n        configMenuItem = new JMenuItem(\n            GuiActivator.getResources().getI18NString(\"service.gui.SETTINGS\"),\n            GuiActivator.getResources().getImage(\n                                \"service.gui.icons.CONFIGURE_ICON\"));\n\n        this.add(configMenuItem);\n        configMenuItem.setMnemonic(GuiActivator.getResources()\n            .getI18nMnemonic(\"service.gui.SETTINGS\"));\n        configMenuItem.setName(\"config\");\n        configMenuItem.addActionListener(this);\n    }","id":6526,"modified_method":"/**\n     * Registers the settings item for non-MacOS X OS.\n     */\n    private void registerConfigMenuItemNonMacOSX()\n    {\n        ResourceManagementService r = GuiActivator.getResources();\n\n        configMenuItem\n            = new JMenuItem(\n                    r.getI18NString(\"service.gui.SETTINGS\"),\n                    r.getImage(\"service.gui.icons.CONFIGURE_ICON\"));\n        add(configMenuItem);\n        configMenuItem.setMnemonic(\n                r.getI18nMnemonic(\"service.gui.SETTINGS\"));\n        configMenuItem.setName(\"config\");\n        configMenuItem.addActionListener(this);\n    }","commit_id":"afb27d05c34100aa15d1ae8c8d6ecce7a00a5699","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Initializes the appropriate video bridge menu depending on how many\n     * registered providers do we have that support the\n     * <tt>OperationSetVideoBridge<\/tt>.\n     */\n    private void initVideoBridgeMenu()\n    {\n        // If already created remove the previous menu in order to reinitialize\n        // it.\n        if (videoBridgeMenuItem != null)\n        {\n            remove(videoBridgeMenuItem);\n            videoBridgeMenuItem = null;\n        }\n        else\n        {\n            // For now we re-init the video bridge menu item each time the\n            // parent menu is selected in order to be able to refresh the list\n            // of available video bridge active providers.\n            addMenuListener(new MenuListener()\n            {\n                public void menuSelected(MenuEvent arg0)\n                {\n                    initVideoBridgeMenu();\n                }\n\n                public void menuDeselected(MenuEvent arg0) {}\n\n                public void menuCanceled(MenuEvent arg0) {}\n            });\n        }\n\n        List<ProtocolProviderService> videoBridgeProviders\n            = getVideoBridgeProviders();\n\n        // Add a service listener in order to be notified when a new protocol\n        // privder is added or removed and the list should be refreshed.\n        GuiActivator.bundleContext.addServiceListener(this);\n\n        if (videoBridgeProviders == null || videoBridgeProviders.size() <= 0)\n        {\n            videoBridgeMenuItem = new VideoBridgeProviderMenuItem(\n                GuiActivator.getResources().getI18NString(\n                    \"service.gui.CREATE_VIDEO_BRIDGE\"), null);\n            videoBridgeMenuItem.setEnabled(false);\n        }\n        else if (videoBridgeProviders.size() == 1)\n        {\n            videoBridgeMenuItem = new VideoBridgeProviderMenuItem(\n                GuiActivator.getResources().getI18NString(\n                    \"service.gui.CREATE_VIDEO_BRIDGE\"),\n                    videoBridgeProviders.get(0));\n            videoBridgeMenuItem.setName(\"videoBridge\");\n            videoBridgeMenuItem.addActionListener(this);\n        }\n        else if (videoBridgeProviders.size() > 1)\n        {\n            videoBridgeMenuItem = new SIPCommMenu(\n                GuiActivator.getResources().getI18NString(\n                    \"service.gui.CREATE_VIDEO_BRIDGE_MENU\"));\n\n            for (ProtocolProviderService videoBridgeProvider\n                                                        : videoBridgeProviders)\n            {\n                VideoBridgeProviderMenuItem videoBridgeItem\n                    = new VideoBridgeProviderMenuItem(videoBridgeProvider);\n\n                ((JMenu) videoBridgeMenuItem).add(videoBridgeItem);\n                videoBridgeItem.setIcon(\n                    ImageLoader.getAccountStatusImage(videoBridgeProvider));\n            }\n        }\n\n        videoBridgeMenuItem.setIcon(GuiActivator.getResources().getImage(\n            \"service.gui.icons.VIDEO_BRIDGE\"));\n        videoBridgeMenuItem.setMnemonic(GuiActivator.getResources()\n            .getI18nMnemonic(\"service.gui.CREATE_VIDEO_BRIDGE\"));\n\n        insert(videoBridgeMenuItem, 1);\n    }","id":6527,"modified_method":"/**\n     * Initializes the appropriate video bridge menu depending on how many\n     * registered providers do we have that support the\n     * <tt>OperationSetVideoBridge<\/tt>.\n     */\n    private void initVideoBridgeMenu()\n    {\n        // If already created, remove the previous menu in order to reinitialize\n        // it.\n        if (videoBridgeMenuItem != null)\n        {\n            remove(videoBridgeMenuItem);\n            videoBridgeMenuItem = null;\n        }\n        else\n        {\n            // For now we re-init the video bridge menu item each time the\n            // parent menu is selected in order to be able to refresh the list\n            // of available video bridge active providers.\n            addMenuListener(new MenuListener()\n            {\n                public void menuSelected(MenuEvent arg0)\n                {\n                    initVideoBridgeMenu();\n                }\n\n                public void menuDeselected(MenuEvent arg0) {}\n\n                public void menuCanceled(MenuEvent arg0) {}\n            });\n        }\n\n        List<ProtocolProviderService> videoBridgeProviders\n            = getVideoBridgeProviders();\n\n        // Add a service listener in order to be notified when a new protocol\n        // provider is added or removed and the list should be refreshed.\n        GuiActivator.bundleContext.addServiceListener(this);\n\n        int videoBridgeProviderCount\n            = (videoBridgeProviders == null) ? 0 : videoBridgeProviders.size();\n        ResourceManagementService r = GuiActivator.getResources();\n\n        if (videoBridgeProviderCount <= 0)\n        {\n            videoBridgeMenuItem\n                = new VideoBridgeProviderMenuItem(\n                        r.getI18NString(\"service.gui.CREATE_VIDEO_BRIDGE\"),\n                        null);\n            videoBridgeMenuItem.setEnabled(false);\n        }\n        else if (videoBridgeProviderCount == 1)\n        {\n            videoBridgeMenuItem\n                = new VideoBridgeProviderMenuItem(\n                        r.getI18NString(\"service.gui.CREATE_VIDEO_BRIDGE\"),\n                        videoBridgeProviders.get(0));\n            videoBridgeMenuItem.setName(\"videoBridge\");\n            videoBridgeMenuItem.addActionListener(this);\n        }\n        else if (videoBridgeProviderCount > 1)\n        {\n            videoBridgeMenuItem\n                = new SIPCommMenu(\n                        r.getI18NString(\n                                \"service.gui.CREATE_VIDEO_BRIDGE_MENU\"));\n\n            for (ProtocolProviderService videoBridgeProvider\n                    : videoBridgeProviders)\n            {\n                VideoBridgeProviderMenuItem videoBridgeItem\n                    = new VideoBridgeProviderMenuItem(videoBridgeProvider);\n\n                ((JMenu) videoBridgeMenuItem).add(videoBridgeItem);\n                videoBridgeItem.setIcon(\n                        ImageLoader.getAccountStatusImage(videoBridgeProvider));\n            }\n        }\n\n        videoBridgeMenuItem.setIcon(\n                r.getImage(\"service.gui.icons.VIDEO_BRIDGE\"));\n        videoBridgeMenuItem.setMnemonic(\n                r.getI18nMnemonic(\"service.gui.CREATE_VIDEO_BRIDGE\"));\n\n        insert(videoBridgeMenuItem, 1);\n    }","commit_id":"afb27d05c34100aa15d1ae8c8d6ecce7a00a5699","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates an instance of <tt>FileMenu<\/tt>.\n     * @param parentWindow The parent <tt>ChatWindow<\/tt>.\n     */\n    public ToolsMenu(MainFrame parentWindow) {\n\n        super(GuiActivator.getResources().getI18NString(\"service.gui.TOOLS\"));\n\n        this.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\"service.gui.TOOLS\"));\n\n        this.registerMenuItems();\n\n        this.initPluginComponents();\n    }","id":6528,"modified_method":"/**\n     * Creates an instance of <tt>FileMenu<\/tt>.\n     * @param parentWindow The parent <tt>ChatWindow<\/tt>.\n     */\n    public ToolsMenu(MainFrame parentWindow)\n    {\n        ResourceManagementService r = GuiActivator.getResources();\n\n        setText(r.getI18NString(\"service.gui.TOOLS\"));\n        setMnemonic(r.getI18nMnemonic(\"service.gui.TOOLS\"));\n\n        registerMenuItems();\n\n        initPluginComponents();\n    }","commit_id":"afb27d05c34100aa15d1ae8c8d6ecce7a00a5699","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Loads menu item icons.\n     */\n    public void loadSkin()\n    {\n        conferenceMenuItem.setIcon(GuiActivator.getResources().getImage(\n                \"service.gui.icons.CONFERENCE_CALL\"));\n        videoBridgeMenuItem.setIcon(GuiActivator.getResources().getImage(\n                \"service.gui.icons.VIDEO_BRIDGE\"));\n        hideOfflineMenuItem.setIcon(GuiActivator.getResources().getImage(\n                \"service.gui.icons.SHOW_HIDE_OFFLINE_ICON\"));\n        soundMenuItem.setIcon(GuiActivator.getResources().getImage(\n                \"service.gui.icons.SOUND_MENU_ICON\"));\n\n        if(configMenuItem != null)\n        {\n            configMenuItem.setIcon(GuiActivator.getResources().getImage(\n                    \"service.gui.icons.CONFIGURE_ICON\"));\n        }\n    }","id":6529,"modified_method":"/**\n     * Loads menu item icons.\n     */\n    public void loadSkin()\n    {\n        ResourceManagementService r = GuiActivator.getResources();\n\n        conferenceMenuItem.setIcon(\n                r.getImage(\"service.gui.icons.CONFERENCE_CALL\"));\n        if (configMenuItem != null)\n        {\n            configMenuItem.setIcon(\n                    r.getImage(\"service.gui.icons.CONFIGURE_ICON\"));\n        }\n        hideOfflineMenuItem.setIcon(\n                r.getImage(\"service.gui.icons.SHOW_HIDE_OFFLINE_ICON\"));\n        soundMenuItem.setIcon(\n                r.getImage(\"service.gui.icons.SOUND_MENU_ICON\"));\n        if (videoBridgeMenuItem != null)\n        {\n            videoBridgeMenuItem.setIcon(\n                    r.getImage(\"service.gui.icons.VIDEO_BRIDGE\"));\n        }\n    }","commit_id":"afb27d05c34100aa15d1ae8c8d6ecce7a00a5699","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Registers all menu items.\n     */\n    private void registerMenuItems()\n    {\n        // We only add the options button if the property SHOW_OPTIONS_WINDOW\n        // specifies so or if it's not set.\n        Boolean showOptionsProp\n            = GuiActivator.getConfigurationService()\n                .getBoolean(ConfigurationFrame.SHOW_OPTIONS_WINDOW_PROPERTY,\n                            true);\n\n        if (showOptionsProp.booleanValue())\n        {\n            UIService uiService = GuiActivator.getUIService();\n            if ((uiService == null) || !uiService.useMacOSXScreenMenuBar()\n                || !registerConfigMenuItemMacOSX())\n            {\n                registerConfigMenuItemNonMacOSX();\n            }\n        }\n\n        conferenceMenuItem = new JMenuItem(\n            GuiActivator.getResources().getI18NString(\n                \"service.gui.CREATE_CONFERENCE_CALL\"));\n\n        conferenceMenuItem.setMnemonic(GuiActivator.getResources()\n            .getI18nMnemonic(\"service.gui.CREATE_CONFERENCE_CALL\"));\n        conferenceMenuItem.setName(\"conference\");\n        conferenceMenuItem.addActionListener(this);\n        this.add(conferenceMenuItem);\n\n        initVideoBridgeMenu();\n\n        if(!GuiActivator.getConfigurationService().getBoolean(\n            AUTO_ANSWER_MENU_DISABLED_PROP,\n            false))\n        {\n            if(ConfigurationManager.isAutoAnswerDisableSubmenu())\n            {\n                this.addSeparator();\n                AutoAnswerMenu.registerMenuItems(this);\n            }\n            else\n            {\n                AutoAnswerMenu autoAnswerMenu = new AutoAnswerMenu();\n                this.add(autoAnswerMenu);\n            }\n        }\n\n        this.addSeparator();\n\n        // Show/hide offline contacts menu item.\n        String offlineTextKey = ConfigurationManager.isShowOffline()\n                            ? \"service.gui.HIDE_OFFLINE_CONTACTS\"\n                            : \"service.gui.SHOW_OFFLINE_CONTACTS\";\n\n        hideOfflineMenuItem = new JMenuItem(\n            GuiActivator.getResources().getI18NString(offlineTextKey));\n\n        hideOfflineMenuItem.setMnemonic(GuiActivator.getResources()\n            .getI18nMnemonic(offlineTextKey));\n        hideOfflineMenuItem.setName(\"showHideOffline\");\n        hideOfflineMenuItem.addActionListener(this);\n        this.add(hideOfflineMenuItem);\n\n        // Sound on/off menu item.\n        String soundTextKey = GuiActivator.getAudioNotifier().isMute()\n                            ? \"service.gui.SOUND_ON\"\n                            : \"service.gui.SOUND_OFF\";\n\n        soundMenuItem = new JMenuItem(\n            GuiActivator.getResources().getI18NString(soundTextKey));\n\n        soundMenuItem.setMnemonic(GuiActivator.getResources()\n            .getI18nMnemonic(soundTextKey));\n        soundMenuItem.setName(\"sound\");\n        soundMenuItem.addActionListener(this);\n        this.add(soundMenuItem);\n\n        // All items are now instantiated and we could safely load the skin.\n        loadSkin();\n    }","id":6530,"modified_method":"/**\n     * Registers all menu items.\n     */\n    private void registerMenuItems()\n    {\n        // We only add the options button if the property SHOW_OPTIONS_WINDOW\n        // specifies so or if it's not set.\n        ConfigurationService cfg = GuiActivator.getConfigurationService();\n        Boolean showOptionsProp\n            = cfg.getBoolean(\n                    ConfigurationFrame.SHOW_OPTIONS_WINDOW_PROPERTY,\n                    true);\n\n        if (showOptionsProp.booleanValue())\n        {\n            UIService uiService = GuiActivator.getUIService();\n\n            if ((uiService == null)\n                    || !uiService.useMacOSXScreenMenuBar()\n                    || !registerConfigMenuItemMacOSX())\n            {\n                registerConfigMenuItemNonMacOSX();\n            }\n        }\n\n        ResourceManagementService r = GuiActivator.getResources();\n\n        conferenceMenuItem\n            = new JMenuItem(\n                    r.getI18NString(\"service.gui.CREATE_CONFERENCE_CALL\"));\n        conferenceMenuItem.setMnemonic(\n                r.getI18nMnemonic(\"service.gui.CREATE_CONFERENCE_CALL\"));\n        conferenceMenuItem.setName(\"conference\");\n        conferenceMenuItem.addActionListener(this);\n        add(conferenceMenuItem);\n\n        initVideoBridgeMenu();\n\n        if(!cfg.getBoolean(AUTO_ANSWER_MENU_DISABLED_PROP, false))\n        {\n            if(ConfigurationManager.isAutoAnswerDisableSubmenu())\n            {\n                this.addSeparator();\n                AutoAnswerMenu.registerMenuItems(this);\n            }\n            else\n            {\n                AutoAnswerMenu autoAnswerMenu = new AutoAnswerMenu();\n                this.add(autoAnswerMenu);\n            }\n        }\n\n        this.addSeparator();\n\n        // Show/hide offline contacts menu item.\n        String offlineTextKey = ConfigurationManager.isShowOffline()\n                            ? \"service.gui.HIDE_OFFLINE_CONTACTS\"\n                            : \"service.gui.SHOW_OFFLINE_CONTACTS\";\n\n        hideOfflineMenuItem = new JMenuItem(r.getI18NString(offlineTextKey));\n        hideOfflineMenuItem.setMnemonic(r.getI18nMnemonic(offlineTextKey));\n        hideOfflineMenuItem.setName(\"showHideOffline\");\n        hideOfflineMenuItem.addActionListener(this);\n        this.add(hideOfflineMenuItem);\n\n        // Sound on/off menu item.\n        String soundTextKey\n            = GuiActivator.getAudioNotifier().isMute()\n                ? \"service.gui.SOUND_ON\"\n                : \"service.gui.SOUND_OFF\";\n\n        soundMenuItem = new JMenuItem(r.getI18NString(soundTextKey));\n        soundMenuItem.setMnemonic(r.getI18nMnemonic(soundTextKey));\n        soundMenuItem.setName(\"sound\");\n        soundMenuItem.addActionListener(this);\n        this.add(soundMenuItem);\n\n        // All items are now instantiated and we could safely load the skin.\n        loadSkin();\n    }","commit_id":"afb27d05c34100aa15d1ae8c8d6ecce7a00a5699","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Handles the <tt>ActionEvent<\/tt> when one of the menu items is selected.\n     * @param e the <tt>ActionEvent<\/tt> that notified us\n     */\n    public void actionPerformed(ActionEvent e)\n    {\n        JMenuItem menuItem = (JMenuItem) e.getSource();\n        String itemName = menuItem.getName();\n\n        if (itemName.equalsIgnoreCase(\"config\"))\n        {\n            configActionPerformed();\n        }\n        else if (itemName.equals(\"conference\"))\n        {\n            java.util.List<ProtocolProviderService> confProviders\n                = CallManager.getTelephonyConferencingProviders();\n\n            if (confProviders != null && confProviders.size() > 0)\n            {\n                ConferenceInviteDialog confInviteDialog\n                    = new ConferenceInviteDialog();\n\n                confInviteDialog.setVisible(true);\n            }\n            else\n                new ErrorDialog(\n                    null,\n                    GuiActivator.getResources().getI18NString(\n                        \"service.gui.WARNING\"),\n                    GuiActivator.getResources().getI18NString(\n                        \"service.gui.NO_ONLINE_CONFERENCING_ACCOUNT\"))\n                .showDialog();\n        }\n        else if (itemName.equals(\"showHideOffline\"))\n        {\n            boolean isShowOffline = ConfigurationManager.isShowOffline();\n\n            TreeContactList.presenceFilter.setShowOffline(!isShowOffline);\n\n            GuiActivator.getContactList()\n                .setDefaultFilter(TreeContactList.presenceFilter);\n            GuiActivator.getContactList().applyDefaultFilter();\n\n            String itemTextKey = !isShowOffline\n                    ? \"service.gui.HIDE_OFFLINE_CONTACTS\"\n                    : \"service.gui.SHOW_OFFLINE_CONTACTS\";\n\n            menuItem.setText(\n                GuiActivator.getResources().getI18NString(itemTextKey));\n        }\n        else if (itemName.equals(\"sound\"))\n        {\n            boolean mute = !GuiActivator.getAudioNotifier().isMute();\n\n            GuiActivator.getAudioNotifier().setMute(mute);\n            {\n                // Distribute the mute state to the SoundNotificaitonHandler.\n                for(NotificationHandler handler\n                        : GuiActivator.getNotificationService()\n                            .getActionHandlers(NotificationAction.ACTION_SOUND))\n                {\n                    if(handler instanceof SoundNotificationHandler)\n                    {\n                        SoundNotificationHandler soundHandler\n                            = (SoundNotificationHandler) handler;\n\n                        soundHandler.setMute(mute);\n                    }\n                }\n            }\n\n            menuItem.setText(\n                    GuiActivator.getResources().getI18NString(\n                            mute\n                                ? \"service.gui.SOUND_ON\"\n                                : \"service.gui.SOUND_OFF\"));\n        }\n    }","id":6531,"modified_method":"/**\n     * Handles the <tt>ActionEvent<\/tt> when one of the menu items is selected.\n     * @param e the <tt>ActionEvent<\/tt> that notified us\n     */\n    public void actionPerformed(ActionEvent e)\n    {\n        JMenuItem menuItem = (JMenuItem) e.getSource();\n        String itemName = menuItem.getName();\n\n        if (itemName.equalsIgnoreCase(\"config\"))\n        {\n            configActionPerformed();\n        }\n        else if (itemName.equals(\"conference\"))\n        {\n            java.util.List<ProtocolProviderService> confProviders\n                = CallManager.getTelephonyConferencingProviders();\n\n            if (confProviders != null && confProviders.size() > 0)\n            {\n                ConferenceInviteDialog confInviteDialog\n                    = new ConferenceInviteDialog();\n\n                confInviteDialog.setVisible(true);\n            }\n            else\n            {\n                ResourceManagementService r = GuiActivator.getResources();\n\n                new ErrorDialog(\n                        null,\n                        r.getI18NString(\"service.gui.WARNING\"),\n                        r.getI18NString(\n                                \"service.gui.NO_ONLINE_CONFERENCING_ACCOUNT\"))\n                    .showDialog();\n            }\n        }\n        else if (itemName.equals(\"showHideOffline\"))\n        {\n            boolean isShowOffline = ConfigurationManager.isShowOffline();\n\n            TreeContactList.presenceFilter.setShowOffline(!isShowOffline);\n\n            GuiActivator.getContactList()\n                .setDefaultFilter(TreeContactList.presenceFilter);\n            GuiActivator.getContactList().applyDefaultFilter();\n\n            String itemTextKey = !isShowOffline\n                    ? \"service.gui.HIDE_OFFLINE_CONTACTS\"\n                    : \"service.gui.SHOW_OFFLINE_CONTACTS\";\n\n            menuItem.setText(\n                GuiActivator.getResources().getI18NString(itemTextKey));\n        }\n        else if (itemName.equals(\"sound\"))\n        {\n            boolean mute = !GuiActivator.getAudioNotifier().isMute();\n\n            GuiActivator.getAudioNotifier().setMute(mute);\n            {\n                // Distribute the mute state to the SoundNotificaitonHandler.\n                for(NotificationHandler handler\n                        : GuiActivator.getNotificationService()\n                            .getActionHandlers(NotificationAction.ACTION_SOUND))\n                {\n                    if(handler instanceof SoundNotificationHandler)\n                    {\n                        SoundNotificationHandler soundHandler\n                            = (SoundNotificationHandler) handler;\n\n                        soundHandler.setMute(mute);\n                    }\n                }\n            }\n\n            menuItem.setText(\n                    GuiActivator.getResources().getI18NString(\n                            mute\n                                ? \"service.gui.SOUND_ON\"\n                                : \"service.gui.SOUND_OFF\"));\n        }\n    }","commit_id":"afb27d05c34100aa15d1ae8c8d6ecce7a00a5699","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates an instance of <tt>ZrtpConfigurePanel<\/tt>.\n     */\n    public ZrtpConfigurePanel()\n    {\n        super(new BorderLayout());\n\n        JPanel mainPanel = new TransparentPanel(new BorderLayout(0, 10));\n\n        final JButton stdButton = new JButton(\n            NeomediaActivator.getResources()\n                .getI18NString(\"impl.media.security.zrtp.STANDARD\"));\n        stdButton.setOpaque(false);\n\n        final JButton mandButton = new JButton(\n            NeomediaActivator.getResources()\n                .getI18NString(\"impl.media.security.zrtp.MANDATORY\"));\n        mandButton.setOpaque(false);\n\n        final JButton saveButton = new JButton(\n            NeomediaActivator.getResources()\n                .getI18NString(\"service.gui.SAVE\"));\n        saveButton.setOpaque(false);\n\n        JPanel buttonBar = new TransparentPanel(new GridLayout(1, 7));\n        buttonBar.add(stdButton);\n        buttonBar.add(mandButton);\n        buttonBar.add(Box.createHorizontalStrut(10));\n        buttonBar.add(saveButton);\n\n        boolean trusted\n            = NeomediaActivator.getConfigurationService()\n                .getBoolean(TRUSTED_PROP, false);\n        boolean sasSign\n            = NeomediaActivator.getConfigurationService()\n                .getBoolean(SASSIGN_PROP, false);\n\n        JPanel checkBar = new TransparentPanel(new GridLayout(1,2));\n        final JCheckBox trustedMitM\n            = new JCheckBox(NeomediaActivator.getResources()\n                .getI18NString(\"impl.media.security.zrtp.TRUSTED\"), trusted);\n        final JCheckBox sasSignature\n            = new JCheckBox(NeomediaActivator.getResources()\n                .getI18NString(\"impl.media.security.zrtp.SASSIGNATURE\"), sasSign);\n        checkBar.add(trustedMitM);\n        checkBar.add(sasSignature);\n        mainPanel.add(checkBar, BorderLayout.NORTH);\n\n        ActionListener buttonListener = new ActionListener()\n        {\n            public void actionPerformed(ActionEvent event)\n            {\n                Object source = event.getSource();\n                if (source == stdButton)\n                {\n                    inActive.clear();\n                    active.setStandardConfig();\n                    pkc.setStandard();\n                    hc.setStandard();\n                    sc.setStandard();\n                    cc.setStandard();\n                    lc.setStandard();\n                }\n                else if (source == mandButton)\n                {\n                    inActive.clear();\n                    active.setMandatoryOnly();\n                    pkc.setStandard();\n                    hc.setStandard();\n                    sc.setStandard();\n                    cc.setStandard();\n                    lc.setStandard();\n                }\n                else if (source == saveButton)\n                {\n                    Boolean t = new Boolean(active.isTrustedMitM());\n                    Boolean s = new Boolean(active.isSasSignature());\n                    NeomediaActivator.getConfigurationService()\n                        .setProperty(TRUSTED_PROP, t);\n                    NeomediaActivator.getConfigurationService()\n                        .setProperty(SASSIGN_PROP, s);\n                    pkc.saveConfig();\n                    hc.saveConfig();\n                    sc.saveConfig();\n                    cc.saveConfig();\n                    lc.saveConfig();\n                }\n                else\n                    return;\n            }\n        };\n        stdButton.addActionListener(buttonListener);\n        mandButton.addActionListener(buttonListener);\n        saveButton.addActionListener(buttonListener);\n\n        ItemListener itemListener = new ItemListener() {\n            public void itemStateChanged(ItemEvent e) {\n                Object source = e.getItemSelectable();\n\n                if (source == trustedMitM) {\n                     active.setTrustedMitM(trustedMitM.isSelected());\n                } else if (source == sasSignature) {\n                    active.setSasSignature(sasSignature.isSelected());\n                }\n            }\n        };\n        trustedMitM.addItemListener(itemListener);\n        sasSignature.addItemListener(itemListener);\n\n        JTabbedPane algorithmsPane = new JTabbedPane();\n\n        algorithmsPane.addTab(\n            NeomediaActivator.getResources()\n            .getI18NString(\"impl.media.security.zrtp.PUB_KEYS\"), pkc);\n        algorithmsPane.addTab(\n            NeomediaActivator.getResources()\n            .getI18NString(\"impl.media.security.zrtp.HASHES\"), hc);\n        algorithmsPane.addTab(\n            NeomediaActivator.getResources()\n            .getI18NString(\"impl.media.security.zrtp.SYM_CIPHERS\"), cc);\n        algorithmsPane.addTab(\n            NeomediaActivator.getResources()\n            .getI18NString(\"impl.media.security.zrtp.SAS_TYPES\"), sc);\n        algorithmsPane.addTab(\n            NeomediaActivator.getResources()\n            .getI18NString(\"impl.media.security.zrtp.SRTP_LENGTHS\"), lc);\n\n        algorithmsPane.setMinimumSize(new Dimension(400, 100));\n        algorithmsPane.setPreferredSize(new Dimension(400, 200));\n        mainPanel.add(algorithmsPane, BorderLayout.CENTER);\n\n        mainPanel.add(buttonBar, BorderLayout.SOUTH);\n\n        add(mainPanel);\n    }","id":6532,"modified_method":"/**\n     * Creates an instance of <tt>ZrtpConfigurePanel<\/tt>.\n     */\n    public ZrtpConfigurePanel()\n    {\n        super(new BorderLayout());\n\n        ResourceManagementService resources = NeomediaActivator.getResources();\n\n        JPanel mainPanel = new TransparentPanel(new BorderLayout(0, 10));\n\n        final JButton stdButton\n            = new JButton(\n                    resources.getI18NString(\n                            \"impl.media.security.zrtp.STANDARD\"));\n        stdButton.setOpaque(false);\n\n        final JButton mandButton\n            = new JButton(\n                    resources.getI18NString(\n                            \"impl.media.security.zrtp.MANDATORY\"));\n        mandButton.setOpaque(false);\n\n        final JButton saveButton\n            = new JButton(resources.getI18NString(\"service.gui.SAVE\"));\n        saveButton.setOpaque(false);\n\n        JPanel buttonBar = new TransparentPanel(new GridLayout(1, 7));\n        buttonBar.add(stdButton);\n        buttonBar.add(mandButton);\n        buttonBar.add(Box.createHorizontalStrut(10));\n        buttonBar.add(saveButton);\n\n        boolean trusted\n            = NeomediaActivator.getConfigurationService()\n                .getBoolean(TRUSTED_PROP, false);\n        boolean sasSign\n            = NeomediaActivator.getConfigurationService()\n                .getBoolean(SASSIGN_PROP, false);\n\n        JPanel checkBar = new TransparentPanel(new GridLayout(1,2));\n        final JCheckBox trustedMitM\n            = new JCheckBox(\n                    resources.getI18NString(\"impl.media.security.zrtp.TRUSTED\"),\n                    trusted);\n        final JCheckBox sasSignature\n            = new JCheckBox(\n                    resources.getI18NString(\n                            \"impl.media.security.zrtp.SASSIGNATURE\"),\n                    sasSign);\n        checkBar.add(trustedMitM);\n        checkBar.add(sasSignature);\n        mainPanel.add(checkBar, BorderLayout.NORTH);\n\n        ActionListener buttonListener = new ActionListener()\n        {\n            public void actionPerformed(ActionEvent event)\n            {\n                Object source = event.getSource();\n                if (source == stdButton)\n                {\n                    inActive.clear();\n                    active.setStandardConfig();\n                    pkc.setStandard();\n                    hc.setStandard();\n                    sc.setStandard();\n                    cc.setStandard();\n                    lc.setStandard();\n                }\n                else if (source == mandButton)\n                {\n                    inActive.clear();\n                    active.setMandatoryOnly();\n                    pkc.setStandard();\n                    hc.setStandard();\n                    sc.setStandard();\n                    cc.setStandard();\n                    lc.setStandard();\n                }\n                else if (source == saveButton)\n                {\n                    Boolean t = new Boolean(active.isTrustedMitM());\n                    Boolean s = new Boolean(active.isSasSignature());\n                    NeomediaActivator.getConfigurationService()\n                        .setProperty(TRUSTED_PROP, t);\n                    NeomediaActivator.getConfigurationService()\n                        .setProperty(SASSIGN_PROP, s);\n                    pkc.saveConfig();\n                    hc.saveConfig();\n                    sc.saveConfig();\n                    cc.saveConfig();\n                    lc.saveConfig();\n                }\n                else\n                    return;\n            }\n        };\n        stdButton.addActionListener(buttonListener);\n        mandButton.addActionListener(buttonListener);\n        saveButton.addActionListener(buttonListener);\n\n        ItemListener itemListener = new ItemListener() {\n            public void itemStateChanged(ItemEvent e) {\n                Object source = e.getItemSelectable();\n\n                if (source == trustedMitM) {\n                     active.setTrustedMitM(trustedMitM.isSelected());\n                } else if (source == sasSignature) {\n                    active.setSasSignature(sasSignature.isSelected());\n                }\n            }\n        };\n        trustedMitM.addItemListener(itemListener);\n        sasSignature.addItemListener(itemListener);\n\n        JTabbedPane algorithmsPane = new JTabbedPane();\n\n        algorithmsPane.addTab(\n                resources.getI18NString(\"impl.media.security.zrtp.PUB_KEYS\"),\n                pkc);\n        algorithmsPane.addTab(\n                resources.getI18NString(\"impl.media.security.zrtp.HASHES\"),\n                hc);\n        algorithmsPane.addTab(\n                resources.getI18NString(\"impl.media.security.zrtp.SYM_CIPHERS\"),\n                cc);\n        algorithmsPane.addTab(\n                resources.getI18NString(\"impl.media.security.zrtp.SAS_TYPES\"),\n                sc);\n        algorithmsPane.addTab(\n                resources.getI18NString(\n                        \"impl.media.security.zrtp.SRTP_LENGTHS\"),\n                lc);\n\n        algorithmsPane.setMinimumSize(new Dimension(400, 100));\n        algorithmsPane.setPreferredSize(new Dimension(400, 200));\n        mainPanel.add(algorithmsPane, BorderLayout.CENTER);\n\n        mainPanel.add(buttonBar, BorderLayout.SOUTH);\n\n        add(mainPanel);\n    }","commit_id":"5cafd7080b2d99f2022f0c4ca9a97fe94045f385","url":"https://github.com/jitsi/jitsi"},{"original_method":"CipherControls()\n        {\n            String id = getPropertyID(ZrtpConstants.SupportedSymCiphers.AES1);\n            String savedConf\n                = NeomediaActivator.getConfigurationService().getString(id);\n            if (savedConf == null)\n                savedConf = \"\";\n\n            dataModel\n                = new ZrtpConfigureTableModel<ZrtpConstants.SupportedSymCiphers>(\n                    ZrtpConstants.SupportedSymCiphers.AES1,\n                    active,\n                    inActive,\n                    savedConf);\n            createControls(this, dataModel,\n                NeomediaActivator.getResources()\n                    .getI18NString(\n                        \"impl.media.security.zrtp.SYM_CIPHER_ALGORITHMS\"));\n        }","id":6533,"modified_method":"CipherControls()\n        {\n            String id = getPropertyID(ZrtpConstants.SupportedSymCiphers.AES1);\n            String savedConf\n                = NeomediaActivator.getConfigurationService().getString(id);\n            if (savedConf == null)\n                savedConf = \"\";\n\n            dataModel\n                = new ZrtpConfigureTableModel<ZrtpConstants.SupportedSymCiphers>(\n                    ZrtpConstants.SupportedSymCiphers.AES1,\n                    active,\n                    inActive,\n                    savedConf);\n            createControls(this, dataModel);\n        }","commit_id":"5cafd7080b2d99f2022f0c4ca9a97fe94045f385","url":"https://github.com/jitsi/jitsi"},{"original_method":"HashControls()\n        {\n            String id = getPropertyID(ZrtpConstants.SupportedHashes.S256);\n\n            String savedConf\n                = NeomediaActivator.getConfigurationService()\n                    .getString(id);\n            if (savedConf == null)\n                savedConf = \"\";\n\n            dataModel\n                = new ZrtpConfigureTableModel<ZrtpConstants.SupportedHashes>(\n                    ZrtpConstants.SupportedHashes.S256,\n                    active,\n                    inActive,\n                    savedConf);\n            createControls(this, dataModel,\n                NeomediaActivator.getResources()\n                        .getI18NString(\n                            \"impl.media.security.zrtp.HASH_ALGORITHMS\"));\n        }","id":6534,"modified_method":"HashControls()\n        {\n            String id = getPropertyID(ZrtpConstants.SupportedHashes.S256);\n\n            String savedConf\n                = NeomediaActivator.getConfigurationService()\n                    .getString(id);\n            if (savedConf == null)\n                savedConf = \"\";\n\n            dataModel\n                = new ZrtpConfigureTableModel<ZrtpConstants.SupportedHashes>(\n                    ZrtpConstants.SupportedHashes.S256,\n                    active,\n                    inActive,\n                    savedConf);\n            createControls(this, dataModel);\n        }","commit_id":"5cafd7080b2d99f2022f0c4ca9a97fe94045f385","url":"https://github.com/jitsi/jitsi"},{"original_method":"PublicKeyControls()\n        {\n            String id = getPropertyID(ZrtpConstants.SupportedPubKeys.DH2K);\n\n            String savedConf\n                = NeomediaActivator.getConfigurationService().getString(id);\n            if (savedConf == null)\n                savedConf = \"\";\n\n            dataModel\n                = new ZrtpConfigureTableModel<ZrtpConstants.SupportedPubKeys>(\n                    ZrtpConstants.SupportedPubKeys.DH2K,\n                    active,\n                    inActive,\n                    savedConf);\n            createControls(this, dataModel,\n                NeomediaActivator.getResources().getI18NString(\n                        \"impl.media.security.zrtp.PUB_KEY_ALGORITHMS\"));\n        }","id":6535,"modified_method":"PublicKeyControls()\n        {\n            String id = getPropertyID(ZrtpConstants.SupportedPubKeys.DH2K);\n\n            String savedConf\n                = NeomediaActivator.getConfigurationService().getString(id);\n            if (savedConf == null)\n                savedConf = \"\";\n\n            dataModel\n                = new ZrtpConfigureTableModel<ZrtpConstants.SupportedPubKeys>(\n                    ZrtpConstants.SupportedPubKeys.DH2K,\n                    active,\n                    inActive,\n                    savedConf);\n            createControls(this, dataModel);\n        }","commit_id":"5cafd7080b2d99f2022f0c4ca9a97fe94045f385","url":"https://github.com/jitsi/jitsi"},{"original_method":"LengthControls()\n        {\n            String id = getPropertyID(ZrtpConstants.SupportedAuthLengths.HS32);\n            String savedConf\n                = NeomediaActivator.getConfigurationService().getString(id);\n            if (savedConf == null)\n                savedConf = \"\";\n\n            dataModel\n                = new ZrtpConfigureTableModel<ZrtpConstants.SupportedAuthLengths>(\n                    ZrtpConstants.SupportedAuthLengths.HS32,\n                    active,\n                    inActive,\n                    savedConf);\n            createControls(this, dataModel,\n                NeomediaActivator.getResources()\n                    .getI18NString(\"impl.media.security.zrtp.SRTP_LENGTHS\"));\n        }","id":6536,"modified_method":"LengthControls()\n        {\n            String id = getPropertyID(ZrtpConstants.SupportedAuthLengths.HS32);\n            String savedConf\n                = NeomediaActivator.getConfigurationService().getString(id);\n            if (savedConf == null)\n                savedConf = \"\";\n\n            dataModel\n                = new ZrtpConfigureTableModel<ZrtpConstants.SupportedAuthLengths>(\n                    ZrtpConstants.SupportedAuthLengths.HS32,\n                    active,\n                    inActive,\n                    savedConf);\n            createControls(this, dataModel);\n        }","commit_id":"5cafd7080b2d99f2022f0c4ca9a97fe94045f385","url":"https://github.com/jitsi/jitsi"},{"original_method":"SasControls()\n        {\n            String id = getPropertyID(ZrtpConstants.SupportedSASTypes.B32);\n            String savedConf\n                = NeomediaActivator.getConfigurationService()\n                    .getString(id);\n            if (savedConf == null)\n                savedConf = \"\";\n\n            dataModel\n                = new ZrtpConfigureTableModel<ZrtpConstants.SupportedSASTypes>(\n                    ZrtpConstants.SupportedSASTypes.B32,\n                    active,\n                    inActive,\n                    savedConf);\n            createControls(this, dataModel,\n                NeomediaActivator.getResources()\n                    .getI18NString(\"impl.media.security.zrtp.SAS_TYPES\"));\n        }","id":6537,"modified_method":"SasControls()\n        {\n            String id = getPropertyID(ZrtpConstants.SupportedSASTypes.B32);\n            String savedConf\n                = NeomediaActivator.getConfigurationService()\n                    .getString(id);\n            if (savedConf == null)\n                savedConf = \"\";\n\n            dataModel\n                = new ZrtpConfigureTableModel<ZrtpConstants.SupportedSASTypes>(\n                    ZrtpConstants.SupportedSASTypes.B32,\n                    active,\n                    inActive,\n                    savedConf);\n            createControls(this, dataModel);\n        }","commit_id":"5cafd7080b2d99f2022f0c4ca9a97fe94045f385","url":"https://github.com/jitsi/jitsi"},{"original_method":"private <T extends Enum<T>> void createControls(JPanel panel,\n            ZrtpConfigureTableModel<T> model, String title)\n    {\n        final JButton upButton = new JButton(\n            NeomediaActivator.getResources()\n                .getI18NString(\"impl.media.configform.UP\"));\n        upButton.setOpaque(false);\n\n        final JButton downButton = new JButton(\n            NeomediaActivator.getResources()\n                .getI18NString(\"impl.media.configform.DOWN\"));\n        downButton.setOpaque(false);\n\n        Container buttonBar = new TransparentPanel(new GridLayout(0, 1));\n        buttonBar.add(upButton);\n        buttonBar.add(downButton);\n\n        panel.setLayout(new GridBagLayout());\n        panel.setBorder(BorderFactory.createTitledBorder(BorderFactory\n                .createEtchedBorder(EtchedBorder.LOWERED), title));\n\n        final JTable table = new JTable(model.getRowCount(), 2);\n        table.setShowGrid(false);\n        table.setTableHeader(null);\n        table.setModel(model);\n        // table.setFillsViewportHeight(true); // Since 1.6 only - nicer view\n\n        /*\n         * The first column contains the check boxes which enable/disable their\n         * associated encodings and it doesn't make sense to make it wider than\n         * the check boxes.\n         */\n        TableColumnModel tableColumnModel = table.getColumnModel();\n        TableColumn tableColumn = tableColumnModel.getColumn(0);\n        tableColumn.setMaxWidth(tableColumn.getMinWidth() + 5);\n        table.doLayout();\n\n        GridBagConstraints constraints = new GridBagConstraints();\n        constraints.anchor = GridBagConstraints.CENTER;\n        constraints.fill = GridBagConstraints.BOTH;\n        constraints.gridwidth = 1;\n        constraints.gridx = 0;\n        constraints.gridy = 1;\n        constraints.weightx = 1;\n        constraints.weighty = 1;\n        panel.add(new JScrollPane(table), constraints);\n\n        constraints.anchor = GridBagConstraints.NORTHEAST;\n        constraints.fill = GridBagConstraints.NONE;\n        constraints.gridwidth = 1;\n        constraints.gridx = 1;\n        constraints.gridy = 1;\n        constraints.weightx = 0;\n        constraints.weighty = 0;\n        panel.add(buttonBar, constraints);\n\n        ListSelectionListener tableSelectionListener\n            = new ListSelectionListener() {\n            @SuppressWarnings(\"unchecked\")\n            public void valueChanged(ListSelectionEvent event) {\n                if (table.getSelectedRowCount() == 1) {\n                    int selectedRow = table.getSelectedRow();\n                    if (selectedRow > -1) {\n                        ZrtpConfigureTableModel<T> model\n                            = (ZrtpConfigureTableModel<T>) table\n                                .getModel();\n                        upButton.setEnabled(selectedRow > 0\n                                && model.checkEnableUp(selectedRow));\n                        downButton.setEnabled(selectedRow < (table\n                                .getRowCount() - 1)\n                                && model.checkEnableDown(selectedRow));\n                        return;\n                    }\n                }\n                upButton.setEnabled(false);\n                downButton.setEnabled(false);\n            }\n        };\n        table.getSelectionModel().addListSelectionListener(\n                tableSelectionListener);\n\n        TableModelListener tableListener = new TableModelListener() {\n            @SuppressWarnings(\"unchecked\")\n            public void tableChanged(TableModelEvent e) {\n                if (table.getSelectedRowCount() == 1) {\n                    int selectedRow = table.getSelectedRow();\n                    if (selectedRow > -1) {\n                        ZrtpConfigureTableModel<T> model\n                            = (ZrtpConfigureTableModel<T>) table\n                                .getModel();\n                        upButton.setEnabled(selectedRow > 0\n                                && model.checkEnableUp(selectedRow));\n                        downButton.setEnabled(selectedRow < (table\n                                .getRowCount() - 1)\n                                && model.checkEnableDown(selectedRow));\n                        return;\n                    }\n                }\n                upButton.setEnabled(false);\n                downButton.setEnabled(false);\n            }\n        };\n        table.getModel().addTableModelListener(tableListener);\n\n        tableSelectionListener.valueChanged(null);\n\n        ActionListener buttonListener = new ActionListener() {\n            @SuppressWarnings(\"unchecked\")\n            public void actionPerformed(ActionEvent event) {\n                Object source = event.getSource();\n                boolean up;\n                if (source == upButton)\n                    up = true;\n                else if (source == downButton)\n                    up = false;\n                else\n                    return;\n\n                int index = ((ZrtpConfigureTableModel<T>) table.getModel())\n                        .move(table.getSelectedRow(), up, up);\n                table.getSelectionModel().setSelectionInterval(index, index);\n            }\n        };\n        upButton.addActionListener(buttonListener);\n        downButton.addActionListener(buttonListener);\n    }","id":6538,"modified_method":"private <T extends Enum<T>> void createControls(\n            JPanel panel,\n            ZrtpConfigureTableModel<T> model)\n    {\n        ResourceManagementService resources = NeomediaActivator.getResources();\n\n        final JButton upButton\n            = new JButton(resources.getI18NString(\"impl.media.configform.UP\"));\n        upButton.setOpaque(false);\n\n        final JButton downButton\n            = new JButton(\n                    resources.getI18NString(\"impl.media.configform.DOWN\"));\n        downButton.setOpaque(false);\n\n        Container buttonBar = new TransparentPanel(new GridLayout(0, 1));\n        buttonBar.add(upButton);\n        buttonBar.add(downButton);\n\n        panel.setBorder(\n                BorderFactory.createEmptyBorder(\n                        MARGIN,\n                        MARGIN,\n                        MARGIN,\n                        MARGIN));\n        panel.setLayout(new GridBagLayout());\n\n        final JTable table = new JTable(model.getRowCount(), 2);\n        table.setShowGrid(false);\n        table.setTableHeader(null);\n        table.setModel(model);\n        // table.setFillsViewportHeight(true); // Since 1.6 only - nicer view\n\n        /*\n         * The first column contains the check boxes which enable/disable their\n         * associated encodings and it doesn't make sense to make it wider than\n         * the check boxes.\n         */\n        TableColumnModel tableColumnModel = table.getColumnModel();\n        TableColumn tableColumn = tableColumnModel.getColumn(0);\n        tableColumn.setMaxWidth(tableColumn.getMinWidth() + 5);\n        table.doLayout();\n\n        GridBagConstraints constraints = new GridBagConstraints();\n        constraints.anchor = GridBagConstraints.CENTER;\n        constraints.fill = GridBagConstraints.BOTH;\n        constraints.gridwidth = 1;\n        constraints.gridx = 0;\n        constraints.gridy = 1;\n        constraints.weightx = 1;\n        constraints.weighty = 1;\n        panel.add(new JScrollPane(table), constraints);\n\n        constraints.anchor = GridBagConstraints.NORTHEAST;\n        constraints.fill = GridBagConstraints.NONE;\n        constraints.gridwidth = 1;\n        constraints.gridx = 1;\n        constraints.gridy = 1;\n        constraints.weightx = 0;\n        constraints.weighty = 0;\n        panel.add(buttonBar, constraints);\n\n        ListSelectionListener tableSelectionListener\n            = new ListSelectionListener() {\n            @SuppressWarnings(\"unchecked\")\n            public void valueChanged(ListSelectionEvent event) {\n                if (table.getSelectedRowCount() == 1) {\n                    int selectedRow = table.getSelectedRow();\n                    if (selectedRow > -1) {\n                        ZrtpConfigureTableModel<T> model\n                            = (ZrtpConfigureTableModel<T>) table\n                                .getModel();\n                        upButton.setEnabled(selectedRow > 0\n                                && model.checkEnableUp(selectedRow));\n                        downButton.setEnabled(selectedRow < (table\n                                .getRowCount() - 1)\n                                && model.checkEnableDown(selectedRow));\n                        return;\n                    }\n                }\n                upButton.setEnabled(false);\n                downButton.setEnabled(false);\n            }\n        };\n        table.getSelectionModel().addListSelectionListener(\n                tableSelectionListener);\n\n        TableModelListener tableListener = new TableModelListener() {\n            @SuppressWarnings(\"unchecked\")\n            public void tableChanged(TableModelEvent e) {\n                if (table.getSelectedRowCount() == 1) {\n                    int selectedRow = table.getSelectedRow();\n                    if (selectedRow > -1) {\n                        ZrtpConfigureTableModel<T> model\n                            = (ZrtpConfigureTableModel<T>) table\n                                .getModel();\n                        upButton.setEnabled(selectedRow > 0\n                                && model.checkEnableUp(selectedRow));\n                        downButton.setEnabled(selectedRow < (table\n                                .getRowCount() - 1)\n                                && model.checkEnableDown(selectedRow));\n                        return;\n                    }\n                }\n                upButton.setEnabled(false);\n                downButton.setEnabled(false);\n            }\n        };\n        table.getModel().addTableModelListener(tableListener);\n\n        tableSelectionListener.valueChanged(null);\n\n        ActionListener buttonListener = new ActionListener() {\n            @SuppressWarnings(\"unchecked\")\n            public void actionPerformed(ActionEvent event) {\n                Object source = event.getSource();\n                boolean up;\n                if (source == upButton)\n                    up = true;\n                else if (source == downButton)\n                    up = false;\n                else\n                    return;\n\n                int index = ((ZrtpConfigureTableModel<T>) table.getModel())\n                        .move(table.getSelectedRow(), up, up);\n                table.getSelectionModel().setSelectionInterval(index, index);\n            }\n        };\n        upButton.addActionListener(buttonListener);\n        downButton.addActionListener(buttonListener);\n    }","commit_id":"5cafd7080b2d99f2022f0c4ca9a97fe94045f385","url":"https://github.com/jitsi/jitsi"},{"original_method":"public AdminPortletDataHandler() {\n\t\tsetDataLevel(DataLevel.SITE);\n\t\tsetDeletionSystemEventClassNames(\n\t\t\tKBArticle.class.getName(), KBComment.class.getName(),\n\t\t\tKBTemplate.class.getName());\n\t\tsetExportControls(\n\t\t\tnew PortletDataHandlerBoolean(\n\t\t\t\tNAMESPACE, \"kb-articles\", true, true),\n\t\t\tnew PortletDataHandlerBoolean(\n\t\t\t\tNAMESPACE, \"kb-templates-and-kb-comments\", true, true));\n\t}","id":6539,"modified_method":"public AdminPortletDataHandler() {\n\t\tsetDataLevel(DataLevel.SITE);\n\t\tsetDeletionSystemEventStagedModelTypes(\n\t\t\tnew StagedModelType(KBArticle.class),\n\t\t\tnew StagedModelType(KBComment.class),\n\t\t\tnew StagedModelType(KBTemplate.class));\n\t\tsetExportControls(\n\t\t\tnew PortletDataHandlerBoolean(\n\t\t\t\tNAMESPACE, \"kb-articles\", true, true),\n\t\t\tnew PortletDataHandlerBoolean(\n\t\t\t\tNAMESPACE, \"kb-templates-and-kb-comments\", true, true));\n\t}","commit_id":"6a27c8e890b694536ed3f78d1b0b17781d213968","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public CalendarPortletDataHandler() {\n\t\tsetDataLevel(DataLevel.SITE);\n\t\tsetDataLocalized(true);\n\t\tsetDeletionSystemEventClassNames(\n\t\t\tCalendar.class.getName(), CalendarBooking.class.getName(),\n\t\t\tCalendarResource.class.getName());\n\t\tsetDataPortletPreferences(\n\t\t\t\"calendarNotificationBodyEmailInvite\",\n\t\t\t\"calendarNotificationBodyEmailReminder\",\n\t\t\t\"calendarNotificationSubjectEmailInvite\",\n\t\t\t\"calendarNotificationSubjectEmailReminder\", \"defaultDuration\",\n\t\t\t\"defaultView\", \"emailFromAddress\", \"emailFromName\", \"isoTimeFormat\",\n\t\t\t\"timeZoneId\", \"usePortalTimeZone\", \"weekStartsOn\");\n\t\tsetExportControls(\n\t\t\tnew PortletDataHandlerBoolean(NAMESPACE, \"bookings\", true, false));\n\t\tsetImportControls(new PortletDataHandlerControl[0]);\n\t\tsetPublishToLiveByDefault(true);\n\t}","id":6540,"modified_method":"public CalendarPortletDataHandler() {\n\t\tsetDataLevel(DataLevel.SITE);\n\t\tsetDataLocalized(true);\n\t\tsetDeletionSystemEventStagedModelTypes(\n\t\t\tnew StagedModelType(Calendar.class),\n\t\t\tnew StagedModelType(CalendarBooking.class),\n\t\t\tnew StagedModelType(CalendarResource.class));\n\t\tsetDataPortletPreferences(\n\t\t\t\"calendarNotificationBodyEmailInvite\",\n\t\t\t\"calendarNotificationBodyEmailReminder\",\n\t\t\t\"calendarNotificationSubjectEmailInvite\",\n\t\t\t\"calendarNotificationSubjectEmailReminder\", \"defaultDuration\",\n\t\t\t\"defaultView\", \"emailFromAddress\", \"emailFromName\", \"isoTimeFormat\",\n\t\t\t\"timeZoneId\", \"usePortalTimeZone\", \"weekStartsOn\");\n\t\tsetExportControls(\n\t\t\tnew PortletDataHandlerBoolean(NAMESPACE, \"bookings\", true, false));\n\t\tsetImportControls(new PortletDataHandlerControl[0]);\n\t\tsetPublishToLiveByDefault(true);\n\t}","commit_id":"4dc72813fafc5b4390227d8ed8979a7794c56d2c","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public AdminPortletDataHandler() {\n\t\tsetDataLevel(DataLevel.SITE);\n\t\tsetDeletionSystemEventClassNames(\n\t\t\tWSRPConsumer.class.getName(), WSRPConsumerPortlet.class.getName(),\n\t\t\tWSRPProducer.class.getName());\n\t\tsetExportControls(\n\t\t\tnew PortletDataHandlerBoolean(NAMESPACE, \"wsrp-producers\", false),\n\t\t\tnew PortletDataHandlerBoolean(\n\t\t\t\tNAMESPACE, \"wsrp-consumers\", true,\n\t\t\t\tnew PortletDataHandlerControl[] {\n\t\t\t\t\tnew PortletDataHandlerBoolean(\n\t\t\t\t\t\tNAMESPACE, \"wsrp-consumer-portlets\")\n\t\t\t\t}));\n\t\tsetPublishToLiveByDefault(true);\n\t}","id":6541,"modified_method":"public AdminPortletDataHandler() {\n\t\tsetDataLevel(DataLevel.SITE);\n\t\tsetDeletionSystemEventStagedModelTypes(\n\t\t\tnew StagedModelType(WSRPConsumer.class),\n\t\t\tnew StagedModelType(WSRPConsumerPortlet.class),\n\t\t\tnew StagedModelType(WSRPProducer.class));\n\t\tsetExportControls(\n\t\t\tnew PortletDataHandlerBoolean(NAMESPACE, \"wsrp-producers\", false),\n\t\t\tnew PortletDataHandlerBoolean(\n\t\t\t\tNAMESPACE, \"wsrp-consumers\", true,\n\t\t\t\tnew PortletDataHandlerControl[] {\n\t\t\t\t\tnew PortletDataHandlerBoolean(\n\t\t\t\t\t\tNAMESPACE, \"wsrp-consumer-portlets\")\n\t\t\t\t}));\n\t\tsetPublishToLiveByDefault(true);\n\t}","commit_id":"da5e8b73dadc792c76b20c590baad9d2ba670f47","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public ManifestParser(Logger logger, PropertyResolver config, Map headerMap)\n        throws BundleException\n    {\n        m_logger = logger;\n        m_config = config;\n        m_headerMap = headerMap;\n\n        // Verify that only manifest version 2 is specified.\n        String manifestVersion = (String) m_headerMap.get(Constants.BUNDLE_MANIFESTVERSION);\n        if ((manifestVersion != null) && !manifestVersion.equals(\"2\"))\n        {\n            throw new BundleException(\n                \"Unknown 'Bundle-ManifestVersion' value: \" + manifestVersion);\n        }\n\n        // Verify bundle version syntax.\n        if (m_headerMap.get(Constants.BUNDLE_VERSION) != null)\n        {\n            try\n            {\n                m_bundleVersion = Version.parseVersion((String) m_headerMap.get(Constants.BUNDLE_VERSION));\n            }\n            catch (RuntimeException ex)\n            {\n                // R4 bundle versions must parse, R3 bundle version may not.\n                if (getManifestVersion().equals(\"2\"))\n                {\n                    throw ex;\n                }\n                m_bundleVersion = Version.emptyVersion;\n            }\n        }\n\n        // Create map to check for duplicate imports/exports.\n        Map dupeMap = new HashMap();\n\n        //\n        // Get bundle version.\n        //\n\n        //\n        // Parse bundle symbolic name.\n        //\n\n        Object[][][] clauses = parseStandardHeader(\n            (String) headerMap.get(Constants.BUNDLE_SYMBOLICNAME));\n        if (clauses.length > 0)\n        {\n            if (clauses.length > 1)\n            {\n                throw new BundleException(\n                    \"Cannot have multiple symbolic names: \"\n                        + headerMap.get(Constants.BUNDLE_SYMBOLICNAME));\n            }\n            else if (clauses[0][CLAUSE_PATHS_INDEX].length > 1)\n            {\n                throw new BundleException(\n                    \"Cannot have multiple symbolic names: \"\n                        + headerMap.get(Constants.BUNDLE_SYMBOLICNAME));\n            }\n            m_bundleSymbolicName = (String) clauses[0][CLAUSE_PATHS_INDEX][0];\n//            Map propMap = new HashMap();\n//            propMap.put(\"symbolicname\", m_bundleSymbolicName);\n//            propMap.put(\"version\", m_bundleVersion);\n//            capList.add(new Capability(ICapability.MODULE_NAMESPACE, propMap));\n        }\n\n        //\n        // Parse Export-Package.\n        //\n\n        // Get export packages from bundle manifest.\n        R4Package[] pkgs = parseImportExportHeader(\n            (String) headerMap.get(Constants.EXPORT_PACKAGE));\n\n        // Create non-duplicated export array.\n        dupeMap.clear();\n        for (int pkgIdx = 0; pkgIdx < pkgs.length; pkgIdx++)\n        {\n            // Verify that the named package has not already been declared.\n            if (dupeMap.get(pkgs[pkgIdx].getName()) == null)\n            {\n                // Verify that java.* packages are not exported.\n                if (pkgs[pkgIdx].getName().startsWith(\"java.\"))\n                {\n                    throw new BundleException(\n                        \"Exporting java.* packages not allowed: \" + pkgs[pkgIdx].getName());\n                }\n                dupeMap.put(pkgs[pkgIdx].getName(), new R4Export(pkgs[pkgIdx]));\n            }\n            else\n            {\n                // TODO: FRAMEWORK - Exports can be duplicated, so fix this.\n                m_logger.log(Logger.LOG_WARNING, \"Duplicate export - \" + pkgs[pkgIdx].getName());\n            }\n        }\n        m_exports = (R4Export[]) dupeMap.values().toArray(new R4Export[dupeMap.size()]);\n\n        //\n        // Parse Require-Bundle\n        //\n        clauses = parseStandardHeader(\n            (String) headerMap.get(Constants.REQUIRE_BUNDLE));\n        if (clauses.length > 0)\n        {\n            for (int clauseIdx = 0; clauseIdx < clauses.length; clauseIdx++)\n            {\n                for (int pathIdx = 0; pathIdx < clauses[clauseIdx][CLAUSE_PATHS_INDEX].length; pathIdx++)\n                {\n//                    try\n//                    {\n//                        reqList.add(\n//                            new Requirement(\n//                                ICapability.MODULE_NAMESPACE,\n//                                \"(symbolicname=\" + clauses[clauseIdx][HEADER_PATHS_INDEX][pathIdx] + \")\"));\n//                    }\n//                    catch (InvalidSyntaxException ex)\n//                    {\n                        // Should never happen.\n//                    }\n                }\n            }\n        }\n\n        //\n        // Parse Import-Package.\n        //\n\n        // Get import packages from bundle manifest.\n        pkgs = parseImportExportHeader(\n            (String) headerMap.get(Constants.IMPORT_PACKAGE));\n\n        // Create non-duplicated import array.\n        dupeMap.clear();\n        for (int pkgIdx = 0; pkgIdx < pkgs.length; pkgIdx++)\n        {\n            // Verify that the named package has not already been declared.\n            if (dupeMap.get(pkgs[pkgIdx].getName()) == null)\n            {\n                // Verify that java.* packages are not imported.\n                if (pkgs[pkgIdx].getName().startsWith(\"java.\"))\n                {\n                    throw new BundleException(\n                        \"Importing java.* packages not allowed: \" + pkgs[pkgIdx].getName());\n                }\n                dupeMap.put(pkgs[pkgIdx].getName(), new R4Import(pkgs[pkgIdx]));\n            }\n            else\n            {\n                throw new BundleException(\n                    \"Duplicate import - \" + pkgs[pkgIdx].getName());\n            }\n        }\n        m_imports = (R4Import[]) dupeMap.values().toArray(new R4Import[dupeMap.size()]);\n\n        //\n        // Parse DynamicImport-Package.\n        //\n\n        // Get dynamic import packages from bundle manifest.\n        pkgs = parseImportExportHeader(\n            (String) headerMap.get(Constants.DYNAMICIMPORT_PACKAGE));\n\n        // Dynamic imports can have duplicates, so just create an array.\n        List dynList = new ArrayList();\n        for (int pkgIdx = 0; pkgIdx < pkgs.length; pkgIdx++)\n        {\n            // Verify that java.* packages are not imported.\n            if (pkgs[pkgIdx].getName().startsWith(\"java.\"))\n            {\n                throw new BundleException(\n                    \"Dynamically importing java.* packages not allowed: \"\n                    + pkgs[pkgIdx].getName());\n            }\n            dynList.add(new R4Import(pkgs[pkgIdx]));\n        }\n        m_dynamics = (R4Import[]) dynList.toArray(new R4Import[dynList.size()]);\n\n        //\n        // Parse Bundle-NativeCode.\n        //\n\n        // Get native library entry names for module library sources.\n        m_libraryHeaders =\n            Util.parseLibraryStrings(\n                m_logger,\n                Util.parseDelimitedString((String) m_headerMap.get(Constants.BUNDLE_NATIVECODE), \",\"));\n\n        // Check to see if there was an optional native library clause, which is\n        // represented by a null library header; if so, record it and remove it.\n        if ((m_libraryHeaders.length > 0) &&\n            (m_libraryHeaders[m_libraryHeaders.length - 1].getLibraryFiles() == null))\n        {\n            m_libraryHeadersOptional = true;\n            R4LibraryClause[] tmp = new R4LibraryClause[m_libraryHeaders.length - 1];\n            System.arraycopy(m_libraryHeaders, 0, tmp, 0, m_libraryHeaders.length - 1);\n            m_libraryHeaders = tmp;\n        }\n\n        // Do final checks and normalization of manifest.\n        if (getManifestVersion().equals(\"2\"))\n        {\n            checkAndNormalizeR4();\n        }\n        else\n        {\n            checkAndNormalizeR3();\n        }\n    }","id":6542,"modified_method":"public ManifestParser(Logger logger, PropertyResolver config, Map headerMap)\n        throws BundleException\n    {\n        m_logger = logger;\n        m_config = config;\n        m_headerMap = headerMap;\n\n        // Verify that only manifest version 2 is specified.\n        String manifestVersion = (String) m_headerMap.get(Constants.BUNDLE_MANIFESTVERSION);\n        if ((manifestVersion != null) && !manifestVersion.equals(\"2\"))\n        {\n            throw new BundleException(\n                \"Unknown 'Bundle-ManifestVersion' value: \" + manifestVersion);\n        }\n\n        // Verify bundle version syntax.\n        if (m_headerMap.get(Constants.BUNDLE_VERSION) != null)\n        {\n            try\n            {\n                m_bundleVersion = Version.parseVersion((String) m_headerMap.get(Constants.BUNDLE_VERSION));\n            }\n            catch (RuntimeException ex)\n            {\n                // R4 bundle versions must parse, R3 bundle version may not.\n                if (getManifestVersion().equals(\"2\"))\n                {\n                    throw ex;\n                }\n                m_bundleVersion = Version.emptyVersion;\n            }\n        }\n\n        // Create map to check for duplicate imports/exports.\n        Map dupeMap = new HashMap();\n\n        //\n        // Get bundle version.\n        //\n\n        //\n        // Parse bundle symbolic name.\n        //\n\n        Object[][][] clauses = parseStandardHeader(\n            (String) headerMap.get(Constants.BUNDLE_SYMBOLICNAME));\n        if (clauses.length > 0)\n        {\n            if (clauses.length > 1)\n            {\n                throw new BundleException(\n                    \"Cannot have multiple symbolic names: \"\n                        + headerMap.get(Constants.BUNDLE_SYMBOLICNAME));\n            }\n            else if (clauses[0][CLAUSE_PATHS_INDEX].length > 1)\n            {\n                throw new BundleException(\n                    \"Cannot have multiple symbolic names: \"\n                        + headerMap.get(Constants.BUNDLE_SYMBOLICNAME));\n            }\n            m_bundleSymbolicName = (String) clauses[0][CLAUSE_PATHS_INDEX][0];\n//            Map propMap = new HashMap();\n//            propMap.put(\"symbolicname\", m_bundleSymbolicName);\n//            propMap.put(\"version\", m_bundleVersion);\n//            capList.add(new Capability(ICapability.MODULE_NAMESPACE, propMap));\n        }\n\n        //\n        // Parse Export-Package.\n        //\n\n        // Get export packages from bundle manifest.\n        m_exports = (R4Export[]) parseImportExportHeader(\n            (String) headerMap.get(Constants.EXPORT_PACKAGE), true);\n\n        // Create non-duplicated export array.\n        dupeMap.clear();\n        for (int pkgIdx = 0; pkgIdx < m_exports.length; pkgIdx++)\n        {\n            // Verify that the named package has not already been declared.\n            if (dupeMap.get(m_exports[pkgIdx].getName()) == null)\n            {\n                // Verify that java.* packages are not exported.\n                if (m_exports[pkgIdx].getName().startsWith(\"java.\"))\n                {\n                    throw new BundleException(\n                        \"Exporting java.* packages not allowed: \"\n                        + m_exports[pkgIdx].getName());\n                }\n                dupeMap.put(m_exports[pkgIdx].getName(), m_exports[pkgIdx]);\n            }\n            else\n            {\n                // TODO: FRAMEWORK - Exports can be duplicated, so fix this.\n                m_logger.log(Logger.LOG_WARNING, \"Duplicate export - \"\n                    + m_exports[pkgIdx].getName());\n            }\n        }\n        // This following line won't be necessary once duplicate exports are supported.\n        m_exports = (R4Export[]) dupeMap.values().toArray(new R4Export[dupeMap.size()]);\n\n        //\n        // Parse Require-Bundle\n        //\n        clauses = parseStandardHeader(\n            (String) headerMap.get(Constants.REQUIRE_BUNDLE));\n        if (clauses.length > 0)\n        {\n            for (int clauseIdx = 0; clauseIdx < clauses.length; clauseIdx++)\n            {\n                for (int pathIdx = 0; pathIdx < clauses[clauseIdx][CLAUSE_PATHS_INDEX].length; pathIdx++)\n                {\n//                    try\n//                    {\n//                        reqList.add(\n//                            new Requirement(\n//                                ICapability.MODULE_NAMESPACE,\n//                                \"(symbolicname=\" + clauses[clauseIdx][HEADER_PATHS_INDEX][pathIdx] + \")\"));\n//                    }\n//                    catch (InvalidSyntaxException ex)\n//                    {\n                        // Should never happen.\n//                    }\n                }\n            }\n        }\n\n        //\n        // Parse Import-Package.\n        //\n\n        // Get import packages from bundle manifest.\n        m_imports = (R4Import[]) parseImportExportHeader(\n            (String) headerMap.get(Constants.IMPORT_PACKAGE), false);\n\n        // Create non-duplicated import array.\n        dupeMap.clear();\n        for (int pkgIdx = 0; pkgIdx < m_imports.length; pkgIdx++)\n        {\n            // Verify that the named package has not already been declared.\n            if (dupeMap.get(m_imports[pkgIdx].getName()) == null)\n            {\n                // Verify that java.* packages are not imported.\n                if (m_imports[pkgIdx].getName().startsWith(\"java.\"))\n                {\n                    throw new BundleException(\n                        \"Importing java.* packages not allowed: \"\n                        + m_imports[pkgIdx].getName());\n                }\n                dupeMap.put(m_imports[pkgIdx].getName(), m_imports[pkgIdx]);\n            }\n            else\n            {\n                throw new BundleException(\n                    \"Duplicate import - \" + m_imports[pkgIdx].getName());\n            }\n        }\n\n        //\n        // Parse DynamicImport-Package.\n        //\n\n        // Get dynamic import packages from bundle manifest.\n        m_dynamics = (R4Import[]) parseImportExportHeader(\n            (String) headerMap.get(Constants.DYNAMICIMPORT_PACKAGE), false);\n\n        // Dynamic imports can have duplicates, so just check for import\n        // of java.*.\n        List dynList = new ArrayList();\n        for (int pkgIdx = 0; pkgIdx < m_dynamics.length; pkgIdx++)\n        {\n            // Verify that java.* packages are not imported.\n            if (m_dynamics[pkgIdx].getName().startsWith(\"java.\"))\n            {\n                throw new BundleException(\n                    \"Dynamically importing java.* packages not allowed: \"\n                    + m_dynamics[pkgIdx].getName());\n            }\n        }\n\n        //\n        // Parse Bundle-NativeCode.\n        //\n\n        // Get native library entry names for module library sources.\n        m_libraryHeaders =\n            Util.parseLibraryStrings(\n                m_logger,\n                Util.parseDelimitedString((String) m_headerMap.get(Constants.BUNDLE_NATIVECODE), \",\"));\n\n        // Check to see if there was an optional native library clause, which is\n        // represented by a null library header; if so, record it and remove it.\n        if ((m_libraryHeaders.length > 0) &&\n            (m_libraryHeaders[m_libraryHeaders.length - 1].getLibraryFiles() == null))\n        {\n            m_libraryHeadersOptional = true;\n            R4LibraryClause[] tmp = new R4LibraryClause[m_libraryHeaders.length - 1];\n            System.arraycopy(m_libraryHeaders, 0, tmp, 0, m_libraryHeaders.length - 1);\n            m_libraryHeaders = tmp;\n        }\n\n        // Do final checks and normalization of manifest.\n        if (getManifestVersion().equals(\"2\"))\n        {\n            checkAndNormalizeR4();\n        }\n        else\n        {\n            checkAndNormalizeR3();\n        }\n    }","commit_id":"a5158a22236a2f3dea58480ef2122d0b4e00566d","url":"https://github.com/apache/felix"},{"original_method":"public static R4Package[] parseImportExportHeader(String header)\n    {\n        Object[][][] clauses = parseStandardHeader(header);\n\n// TODO: FRAMEWORK - Perhaps verification/normalization should be completely\n// separated from parsing, since verification/normalization may vary.\n\n        // Verify that the values are equals if the package specifies\n        // both version and specification-version attributes.\n        Map attrMap = new HashMap();\n        for (int clauseIdx = 0; clauseIdx < clauses.length; clauseIdx++)\n        {\n            // Put attributes for current clause in a map for easy lookup.\n            attrMap.clear();\n            for (int attrIdx = 0;\n                attrIdx < clauses[clauseIdx][CLAUSE_ATTRIBUTES_INDEX].length;\n                attrIdx++)\n            {\n                R4Attribute attr = (R4Attribute) clauses[clauseIdx][CLAUSE_ATTRIBUTES_INDEX][attrIdx];\n                attrMap.put(attr.getName(), attr);\n            }\n\n            // Check for \"version\" and \"specification-version\" attributes\n            // and verify they are the same if both are specified.\n            R4Attribute v = (R4Attribute) attrMap.get(Constants.VERSION_ATTRIBUTE);\n            R4Attribute sv = (R4Attribute) attrMap.get(Constants.PACKAGE_SPECIFICATION_VERSION);\n            if ((v != null) && (sv != null))\n            {\n                // Verify they are equal.\n                if (!((String) v.getValue()).trim().equals(((String) sv.getValue()).trim()))\n                {\n                    throw new IllegalArgumentException(\n                        \"Both version and specificat-version are specified, but they are not equal.\");\n                }\n            }\n    \n            // Ensure that only the \"version\" attribute is used\n            if (sv != null)\n            {\n                attrMap.remove(Constants.PACKAGE_SPECIFICATION_VERSION);\n                if (v == null)\n                {\n                    attrMap.put(Constants.VERSION_ATTRIBUTE,\n                        new R4Attribute(\n                            Constants.VERSION_ATTRIBUTE,\n                            sv.getValue(),\n                            sv.isMandatory()));\n                    clauses[clauseIdx][CLAUSE_ATTRIBUTES_INDEX] =\n                        attrMap.values().toArray(new R4Attribute[attrMap.size()]);\n                }\n            }\n        }\n\n        // Now convert generic header clauses into packages.\n        List pkgList = new ArrayList();\n        for (int clauseIdx = 0; clauseIdx < clauses.length; clauseIdx++)\n        {\n            for (int pathIdx = 0;\n                pathIdx < clauses[clauseIdx][CLAUSE_PATHS_INDEX].length;\n                pathIdx++)\n            {\n                pkgList.add(\n                    new R4Package(\n                        (String) clauses[clauseIdx][CLAUSE_PATHS_INDEX][pathIdx],\n                        (R4Directive[]) clauses[clauseIdx][CLAUSE_DIRECTIVES_INDEX],\n                        (R4Attribute[]) clauses[clauseIdx][CLAUSE_ATTRIBUTES_INDEX]));\n            }\n        }\n        return (R4Package[]) pkgList.toArray(new R4Package[pkgList.size()]);\n    }","id":6543,"modified_method":"public static R4Package[] parseImportExportHeader(String header, boolean export)\n    {\n        Object[][][] clauses = parseStandardHeader(header);\n\n// TODO: FRAMEWORK - Perhaps verification/normalization should be completely\n// separated from parsing, since verification/normalization may vary.\n\n        // Verify that the values are equals if the package specifies\n        // both version and specification-version attributes.\n        Map attrMap = new HashMap();\n        for (int clauseIdx = 0; clauseIdx < clauses.length; clauseIdx++)\n        {\n            // Put attributes for current clause in a map for easy lookup.\n            attrMap.clear();\n            for (int attrIdx = 0;\n                attrIdx < clauses[clauseIdx][CLAUSE_ATTRIBUTES_INDEX].length;\n                attrIdx++)\n            {\n                R4Attribute attr = (R4Attribute) clauses[clauseIdx][CLAUSE_ATTRIBUTES_INDEX][attrIdx];\n                attrMap.put(attr.getName(), attr);\n            }\n\n            // Check for \"version\" and \"specification-version\" attributes\n            // and verify they are the same if both are specified.\n            R4Attribute v = (R4Attribute) attrMap.get(Constants.VERSION_ATTRIBUTE);\n            R4Attribute sv = (R4Attribute) attrMap.get(Constants.PACKAGE_SPECIFICATION_VERSION);\n            if ((v != null) && (sv != null))\n            {\n                // Verify they are equal.\n                if (!((String) v.getValue()).trim().equals(((String) sv.getValue()).trim()))\n                {\n                    throw new IllegalArgumentException(\n                        \"Both version and specificat-version are specified, but they are not equal.\");\n                }\n            }\n    \n            // Ensure that only the \"version\" attribute is used and convert\n            // it to the appropriate type.\n            if ((v != null) || (sv != null))\n            {\n                attrMap.remove(Constants.PACKAGE_SPECIFICATION_VERSION);\n                v = (v == null) ? sv : v;\n                if (export)\n                {\n                    attrMap.put(Constants.VERSION_ATTRIBUTE,\n                        new R4Attribute(\n                            Constants.VERSION_ATTRIBUTE,\n                            Version.parseVersion(v.getValue().toString()),\n                            v.isMandatory()));\n                }\n                else\n                {\n                    attrMap.put(Constants.VERSION_ATTRIBUTE,\n                        new R4Attribute(\n                            Constants.VERSION_ATTRIBUTE,\n                            VersionRange.parse(v.getValue().toString()),\n                            v.isMandatory()));\n                }\n            }\n\n            // If bundle version is specified, then convert its type to Version.\n            // Only imports can specify this attribue.\n            v = (R4Attribute) attrMap.get(Constants.BUNDLE_VERSION_ATTRIBUTE);\n            if (!export && (v != null))\n            {\n                attrMap.put(Constants.BUNDLE_VERSION_ATTRIBUTE,\n                    new R4Attribute(\n                        Constants.BUNDLE_VERSION_ATTRIBUTE,\n                        VersionRange.parse(v.getValue().toString()),\n                        v.isMandatory()));\n            }\n\n            // Re-copy the attribute array in case it has changed.\n            clauses[clauseIdx][CLAUSE_ATTRIBUTES_INDEX] =\n                attrMap.values().toArray(new R4Attribute[attrMap.size()]);\n        }\n\n        // Now convert generic header clauses into packages.\n        List pkgList = new ArrayList();\n        for (int clauseIdx = 0; clauseIdx < clauses.length; clauseIdx++)\n        {\n            for (int pathIdx = 0;\n                pathIdx < clauses[clauseIdx][CLAUSE_PATHS_INDEX].length;\n                pathIdx++)\n            {\n                if (export)\n                {\n                    pkgList.add(\n                        new R4Export(\n                            (String) clauses[clauseIdx][CLAUSE_PATHS_INDEX][pathIdx],\n                            (R4Directive[]) clauses[clauseIdx][CLAUSE_DIRECTIVES_INDEX],\n                            (R4Attribute[]) clauses[clauseIdx][CLAUSE_ATTRIBUTES_INDEX]));\n                }\n                else\n                {\n                    pkgList.add(\n                        new R4Import(\n                            (String) clauses[clauseIdx][CLAUSE_PATHS_INDEX][pathIdx],\n                            (R4Directive[]) clauses[clauseIdx][CLAUSE_DIRECTIVES_INDEX],\n                            (R4Attribute[]) clauses[clauseIdx][CLAUSE_ATTRIBUTES_INDEX]));\n                }\n            }\n        }\n\n        return (export)\n            ? (R4Package[]) pkgList.toArray(new R4Export[pkgList.size()])\n            : (R4Package[]) pkgList.toArray(new R4Import[pkgList.size()]);\n    }","commit_id":"a5158a22236a2f3dea58480ef2122d0b4e00566d","url":"https://github.com/apache/felix"},{"original_method":"private void checkAndNormalizeR3() throws BundleException\n    {\n        // Check to make sure that R3 bundles have only specified\n        // the 'specification-version' attribute and no directives\n        // on their exports; ignore all unknown attributes.\n        for (int expIdx = 0;\n            (m_exports != null) && (expIdx < m_exports.length);\n            expIdx++)\n        {\n            if (m_exports[expIdx].getDirectives().length != 0)\n            {\n                throw new BundleException(\"R3 exports cannot contain directives.\");\n            }\n\n            // Remove and ignore all attributes other than version.\n            // NOTE: This is checking for \"version\" rather than \"specification-version\"\n            // because the package class normalizes to \"version\" to avoid having\n            // future special cases. This could be changed if more strict behavior\n            // is required.\n            if (m_exports[expIdx].getAttributes() != null)\n            {\n                R4Attribute versionAttr = null;\n                for (int attrIdx = 0;\n                    attrIdx < m_exports[expIdx].getAttributes().length;\n                    attrIdx++)\n                {\n                    if (m_exports[expIdx].getAttributes()[attrIdx]\n                        .getName().equals(Constants.VERSION_ATTRIBUTE))\n                    {\n                        versionAttr = m_exports[expIdx].getAttributes()[attrIdx];\n                    }\n                    else\n                    {\n                        m_logger.log(Logger.LOG_WARNING,\n                            \"Unknown R3 export attribute: \"\n                                + m_exports[expIdx].getAttributes()[attrIdx].getName());\n                    }\n                }\n\n                // Recreate the export if necessary to remove other attributes.\n                if ((versionAttr != null) && (m_exports[expIdx].getAttributes().length > 1))\n                {\n                    m_exports[expIdx] = new R4Export(\n                        m_exports[expIdx].getName(),\n                        null,\n                        new R4Attribute[] { versionAttr } );\n                }\n                else if ((versionAttr == null) && (m_exports[expIdx].getAttributes().length > 0))\n                {\n                    m_exports[expIdx] = new R4Export(\n                        m_exports[expIdx].getName(), null, null);\n                }\n            }\n        }\n\n        // Check to make sure that R3 bundles have only specified\n        // the 'specification-version' attribute and no directives\n        // on their imports; ignore all unknown attributes.\n        for (int impIdx = 0;\n            (m_imports != null) && (impIdx < m_imports.length);\n            impIdx++)\n        {\n            if (m_imports[impIdx].getDirectives().length != 0)\n            {\n                throw new BundleException(\"R3 imports cannot contain directives.\");\n            }\n\n            // Remove and ignore all attributes other than version.\n            // NOTE: This is checking for \"version\" rather than \"specification-version\"\n            // because the package class normalizes to \"version\" to avoid having\n            // future special cases. This could be changed if more strict behavior\n            // is required.\n            if (m_imports[impIdx].getAttributes() != null)\n            {\n                R4Attribute versionAttr = null;\n                for (int attrIdx = 0;\n                    attrIdx < m_imports[impIdx].getAttributes().length;\n                    attrIdx++)\n                {\n                    if (m_imports[impIdx].getAttributes()[attrIdx]\n                        .getName().equals(Constants.VERSION_ATTRIBUTE))\n                    {\n                        versionAttr = m_imports[impIdx].getAttributes()[attrIdx];\n                    }\n                    else\n                    {\n                        m_logger.log(Logger.LOG_WARNING,\n                            \"Unknown R3 import attribute: \"\n                                + m_imports[impIdx].getAttributes()[attrIdx].getName());\n                    }\n                }\n\n                // Recreate the import if necessary to remove other attributes.\n                if ((versionAttr != null) && (m_imports[impIdx].getAttributes().length > 1))\n                {\n                    m_imports[impIdx] = new R4Import(\n                        m_imports[impIdx].getName(),\n                        null,\n                        new R4Attribute[] { versionAttr } );\n                }\n                else if ((versionAttr == null) && (m_imports[impIdx].getAttributes().length > 0))\n                {\n                    m_imports[impIdx] = new R4Import(\n                        m_imports[impIdx].getName(), null, null);\n                }\n            }\n        }\n\n        // Since all R3 exports imply an import, add a corresponding\n        // import for each existing export. Create non-duplicated import array.\n        Map map =  new HashMap();\n        // Add existing imports.\n        for (int i = 0; i < m_imports.length; i++)\n        {\n            map.put(m_imports[i].getName(), m_imports[i]);\n        }\n        // Add import for each export.\n        for (int i = 0; i < m_exports.length; i++)\n        {\n            if (map.get(m_exports[i].getName()) == null)\n            {\n                map.put(m_exports[i].getName(), new R4Import(m_exports[i]));\n            }\n        }\n        m_imports =\n            (R4Import[]) map.values().toArray(new R4Import[map.size()]);\n\n        // Add a \"uses\" directive onto each export of R3 bundles\n        // that references every other import (which will include\n        // exports, since export implies import); this is\n        // necessary since R3 bundles assumed a single class space,\n        // but R4 allows for multiple class spaces.\n        String usesValue = \"\";\n        for (int i = 0; (m_imports != null) && (i < m_imports.length); i++)\n        {\n            usesValue = usesValue\n                + ((usesValue.length() > 0) ? \",\" : \"\")\n                + m_imports[i].getName();\n        }\n        R4Directive uses = new R4Directive(\n            Constants.USES_DIRECTIVE, usesValue);\n        for (int i = 0; (m_exports != null) && (i < m_exports.length); i++)\n        {\n            m_exports[i] = new R4Export(\n                m_exports[i].getName(),\n                new R4Directive[] { uses },\n                m_exports[i].getAttributes());\n        }\n\n        // Check to make sure that R3 bundles have no attributes or\n        // directives on their dynamic imports.\n        for (int i = 0; (m_dynamics != null) && (i < m_dynamics.length); i++)\n        {\n            if (m_dynamics[i].getDirectives().length != 0)\n            {\n                throw new BundleException(\"R3 dynamic imports cannot contain directives.\");\n            }\n            if (m_dynamics[i].getAttributes().length != 0)\n            {\n                throw new BundleException(\"R3 dynamic imports cannot contain attributes.\");\n            }\n        }\n    }","id":6544,"modified_method":"private void checkAndNormalizeR3() throws BundleException\n    {\n        // Check to make sure that R3 bundles have only specified\n        // the 'specification-version' attribute and no directives\n        // on their exports; ignore all unknown attributes.\n        for (int expIdx = 0;\n            (m_exports != null) && (expIdx < m_exports.length);\n            expIdx++)\n        {\n            if (m_exports[expIdx].getDirectives().length != 0)\n            {\n                throw new BundleException(\"R3 exports cannot contain directives.\");\n            }\n\n            // Remove and ignore all attributes other than version.\n            // NOTE: This is checking for \"version\" rather than \"specification-version\"\n            // because the package class normalizes to \"version\" to avoid having\n            // future special cases. This could be changed if more strict behavior\n            // is required.\n            if (m_exports[expIdx].getAttributes() != null)\n            {\n                R4Attribute versionAttr = null;\n                for (int attrIdx = 0;\n                    attrIdx < m_exports[expIdx].getAttributes().length;\n                    attrIdx++)\n                {\n                    if (m_exports[expIdx].getAttributes()[attrIdx]\n                        .getName().equals(Constants.VERSION_ATTRIBUTE))\n                    {\n                        versionAttr = m_exports[expIdx].getAttributes()[attrIdx];\n                    }\n                    else\n                    {\n                        m_logger.log(Logger.LOG_WARNING,\n                            \"Unknown R3 export attribute: \"\n                                + m_exports[expIdx].getAttributes()[attrIdx].getName());\n                    }\n                }\n\n                // Recreate the export if necessary to remove other attributes.\n                if ((versionAttr != null) && (m_exports[expIdx].getAttributes().length > 1))\n                {\n                    m_exports[expIdx] = new R4Export(\n                        m_exports[expIdx].getName(),\n                        null,\n                        new R4Attribute[] { versionAttr } );\n                }\n                else if ((versionAttr == null) && (m_exports[expIdx].getAttributes().length > 0))\n                {\n                    m_exports[expIdx] = new R4Export(\n                        m_exports[expIdx].getName(), null, null);\n                }\n            }\n        }\n\n        // Check to make sure that R3 bundles have only specified\n        // the 'specification-version' attribute and no directives\n        // on their imports; ignore all unknown attributes.\n        for (int impIdx = 0;\n            (m_imports != null) && (impIdx < m_imports.length);\n            impIdx++)\n        {\n            if (m_imports[impIdx].getDirectives().length != 0)\n            {\n                throw new BundleException(\"R3 imports cannot contain directives.\");\n            }\n\n            // Remove and ignore all attributes other than version.\n            // NOTE: This is checking for \"version\" rather than \"specification-version\"\n            // because the package class normalizes to \"version\" to avoid having\n            // future special cases. This could be changed if more strict behavior\n            // is required.\n            if (m_imports[impIdx].getAttributes() != null)\n            {\n                R4Attribute versionAttr = null;\n                for (int attrIdx = 0;\n                    attrIdx < m_imports[impIdx].getAttributes().length;\n                    attrIdx++)\n                {\n                    if (m_imports[impIdx].getAttributes()[attrIdx]\n                        .getName().equals(Constants.VERSION_ATTRIBUTE))\n                    {\n                        versionAttr = m_imports[impIdx].getAttributes()[attrIdx];\n                    }\n                    else\n                    {\n                        m_logger.log(Logger.LOG_WARNING,\n                            \"Unknown R3 import attribute: \"\n                                + m_imports[impIdx].getAttributes()[attrIdx].getName());\n                    }\n                }\n\n                // Recreate the import if necessary to remove other attributes.\n                if ((versionAttr != null) && (m_imports[impIdx].getAttributes().length > 1))\n                {\n                    m_imports[impIdx] = new R4Import(\n                        m_imports[impIdx].getName(),\n                        null,\n                        new R4Attribute[] { versionAttr } );\n                }\n                else if ((versionAttr == null) && (m_imports[impIdx].getAttributes().length > 0))\n                {\n                    m_imports[impIdx] = new R4Import(\n                        m_imports[impIdx].getName(), null, null);\n                }\n            }\n        }\n\n        // Since all R3 exports imply an import, add a corresponding\n        // import for each existing export. Create non-duplicated import array.\n        Map map =  new HashMap();\n        // Add existing imports.\n        for (int i = 0; i < m_imports.length; i++)\n        {\n            map.put(m_imports[i].getName(), m_imports[i]);\n        }\n        // Add import for each export.\n        for (int i = 0; i < m_exports.length; i++)\n        {\n            if (map.get(m_exports[i].getName()) == null)\n            {\n                // Convert Version to VersionRange.\n                R4Attribute[] attrs = (R4Attribute[]) m_exports[i].getAttributes().clone();\n                for (int attrIdx = 0; (attrs != null) && (attrIdx < attrs.length); attrIdx++)\n                {\n                    if (attrs[attrIdx].getName().equals(Constants.VERSION_ATTRIBUTE))\n                    {\n                        attrs[attrIdx] = new R4Attribute(\n                            attrs[attrIdx].getName(),\n                            VersionRange.parse(attrs[attrIdx].getValue().toString()),\n                            attrs[attrIdx].isMandatory());\n                    }\n                }\n                map.put(m_exports[i].getName(),\n                    new R4Import(\n                        m_exports[i].getName(),\n                        m_exports[i].getDirectives(),\n                        attrs));\n            }\n        }\n        m_imports =\n            (R4Import[]) map.values().toArray(new R4Import[map.size()]);\n\n        // Add a \"uses\" directive onto each export of R3 bundles\n        // that references every other import (which will include\n        // exports, since export implies import); this is\n        // necessary since R3 bundles assumed a single class space,\n        // but R4 allows for multiple class spaces.\n        String usesValue = \"\";\n        for (int i = 0; (m_imports != null) && (i < m_imports.length); i++)\n        {\n            usesValue = usesValue\n                + ((usesValue.length() > 0) ? \",\" : \"\")\n                + m_imports[i].getName();\n        }\n        R4Directive uses = new R4Directive(\n            Constants.USES_DIRECTIVE, usesValue);\n        for (int i = 0; (m_exports != null) && (i < m_exports.length); i++)\n        {\n            m_exports[i] = new R4Export(\n                m_exports[i].getName(),\n                new R4Directive[] { uses },\n                m_exports[i].getAttributes());\n        }\n\n        // Check to make sure that R3 bundles have no attributes or\n        // directives on their dynamic imports.\n        for (int i = 0; (m_dynamics != null) && (i < m_dynamics.length); i++)\n        {\n            if (m_dynamics[i].getDirectives().length != 0)\n            {\n                throw new BundleException(\"R3 dynamic imports cannot contain directives.\");\n            }\n            if (m_dynamics[i].getAttributes().length != 0)\n            {\n                throw new BundleException(\"R3 dynamic imports cannot contain attributes.\");\n            }\n        }\n    }","commit_id":"a5158a22236a2f3dea58480ef2122d0b4e00566d","url":"https://github.com/apache/felix"},{"original_method":"public R4Export(String name, R4Directive[] directives, R4Attribute[] attrs)\n    {\n        super(name, directives, attrs);\n\n        // Find all export directives: uses, mandatory, include, and exclude.\n        String mandatory = \"\", uses = \"\";\n        for (int i = 0; i < m_directives.length; i++)\n        {\n            if (m_directives[i].getName().equals(Constants.USES_DIRECTIVE))\n            {\n                uses = m_directives[i].getValue();\n            }\n            else if (m_directives[i].getName().equals(Constants.MANDATORY_DIRECTIVE))\n            {\n                mandatory = m_directives[i].getValue();\n            }\n            else if (m_directives[i].getName().equals(Constants.INCLUDE_DIRECTIVE))\n            {\n                String[] ss = Util.parseDelimitedString(m_directives[i].getValue(), \",\");\n                m_includeFilter = new String[ss.length][];\n                for (int filterIdx = 0; filterIdx < ss.length; filterIdx++)\n                {\n                    m_includeFilter[filterIdx] = parseSubstring(ss[filterIdx]);\n                }\n            }\n            else if (m_directives[i].getName().equals(Constants.EXCLUDE_DIRECTIVE))\n            {\n                String[] ss = Util.parseDelimitedString(m_directives[i].getValue(), \",\");\n                m_excludeFilter = new String[ss.length][];\n                for (int filterIdx = 0; filterIdx < ss.length; filterIdx++)\n                {\n                    m_excludeFilter[filterIdx] = parseSubstring(ss[filterIdx]);\n                }\n            }\n        }\n\n        // Parse these uses directive.\n        StringTokenizer tok = new StringTokenizer(uses, \",\");\n        m_uses = new String[tok.countTokens()];\n        for (int i = 0; i < m_uses.length; i++)\n        {\n            m_uses[i] = tok.nextToken().trim();\n        }\n\n        // Parse mandatory directive and mark specified\n        // attributes as mandatory.\n        tok = new StringTokenizer(mandatory, \",\");\n        while (tok.hasMoreTokens())\n        {\n            // Get attribute name.\n            String attrName = tok.nextToken().trim();\n            // Find attribute and mark it as mandatory.\n            boolean found = false;\n            for (int i = 0; (!found) && (i < m_attrs.length); i++)\n            {\n                if (m_attrs[i].getName().equals(attrName))\n                {\n                    m_attrs[i] = new R4Attribute(\n                        m_attrs[i].getName(),\n                        m_attrs[i].getValue(), true);\n                    found = true;\n                }\n            }\n            // If a specified mandatory attribute was not found,\n            // then error.\n            if (!found)\n            {\n                throw new IllegalArgumentException(\n                    \"Mandatory attribute '\" + attrName + \"' does not exist.\");\n            }\n        }\n\n        // Find the version, if present, and convert to Version.\n        // The version attribute value may be a String or a Version,\n        // since the value may be coming from an R4Export that already\n        // converted it to Version.\n        m_version = Version.emptyVersion;\n        for (int i = 0; i < m_attrs.length; i++)\n        {\n            if (m_attrs[i].getName().equals(Constants.VERSION_ATTRIBUTE))\n            {\n                String versionStr = (m_attrs[i].getValue() instanceof Version)\n                    ? ((Version) m_attrs[i].getValue()).toString()\n                    : (String) m_attrs[i].getValue();\n                m_version = Version.parseVersion(versionStr);\n                m_attrs[i] = new R4Attribute(\n                    m_attrs[i].getName(),\n                    m_version,\n                    m_attrs[i].isMandatory());\n                break;\n            }\n        }\n    }","id":6545,"modified_method":"public R4Export(String name, R4Directive[] directives, R4Attribute[] attrs)\n    {\n        super(name, directives, attrs);\n\n        // Find all export directives: uses, mandatory, include, and exclude.\n        String mandatory = \"\", uses = \"\";\n        for (int i = 0; i < m_directives.length; i++)\n        {\n            if (m_directives[i].getName().equals(Constants.USES_DIRECTIVE))\n            {\n                uses = m_directives[i].getValue();\n            }\n            else if (m_directives[i].getName().equals(Constants.MANDATORY_DIRECTIVE))\n            {\n                mandatory = m_directives[i].getValue();\n            }\n            else if (m_directives[i].getName().equals(Constants.INCLUDE_DIRECTIVE))\n            {\n                String[] ss = Util.parseDelimitedString(m_directives[i].getValue(), \",\");\n                m_includeFilter = new String[ss.length][];\n                for (int filterIdx = 0; filterIdx < ss.length; filterIdx++)\n                {\n                    m_includeFilter[filterIdx] = parseSubstring(ss[filterIdx]);\n                }\n            }\n            else if (m_directives[i].getName().equals(Constants.EXCLUDE_DIRECTIVE))\n            {\n                String[] ss = Util.parseDelimitedString(m_directives[i].getValue(), \",\");\n                m_excludeFilter = new String[ss.length][];\n                for (int filterIdx = 0; filterIdx < ss.length; filterIdx++)\n                {\n                    m_excludeFilter[filterIdx] = parseSubstring(ss[filterIdx]);\n                }\n            }\n        }\n\n        // Parse these uses directive.\n        StringTokenizer tok = new StringTokenizer(uses, \",\");\n        m_uses = new String[tok.countTokens()];\n        for (int i = 0; i < m_uses.length; i++)\n        {\n            m_uses[i] = tok.nextToken().trim();\n        }\n\n        // Parse mandatory directive and mark specified\n        // attributes as mandatory.\n        tok = new StringTokenizer(mandatory, \",\");\n        while (tok.hasMoreTokens())\n        {\n            // Get attribute name.\n            String attrName = tok.nextToken().trim();\n            // Find attribute and mark it as mandatory.\n            boolean found = false;\n            for (int i = 0; (!found) && (i < m_attrs.length); i++)\n            {\n                if (m_attrs[i].getName().equals(attrName))\n                {\n                    m_attrs[i] = new R4Attribute(\n                        m_attrs[i].getName(),\n                        m_attrs[i].getValue(), true);\n                    found = true;\n                }\n            }\n            // If a specified mandatory attribute was not found,\n            // then error.\n            if (!found)\n            {\n                throw new IllegalArgumentException(\n                    \"Mandatory attribute '\" + attrName + \"' does not exist.\");\n            }\n        }\n\n        // Cache version, if present.\n        for (int i = 0; i < m_attrs.length; i++)\n        {\n            if (m_attrs[i].getName().equals(Constants.VERSION_ATTRIBUTE))\n            {\n                m_version = (Version) m_attrs[i].getValue();\n                break;\n            }\n        }\n    }","commit_id":"a5158a22236a2f3dea58480ef2122d0b4e00566d","url":"https://github.com/apache/felix"},{"original_method":"public R4Import(String name, R4Directive[] directives, R4Attribute[] attrs)\n    {\n        super(name, directives, attrs);\n\n        // Find all import directives: resolution.\n        for (int i = 0; i < m_directives.length; i++)\n        {\n            if (m_directives[i].getName().equals(Constants.RESOLUTION_DIRECTIVE))\n            {\n                m_isOptional = m_directives[i].getValue().equals(Constants.RESOLUTION_OPTIONAL);\n            }\n        }\n\n        // Convert version and bundle version attributes to VersionRange.\n        // The attribute value may be a String or a Version, since the\n        // value may be coming from an R4Export that already converted\n        // it to Version.\n        m_versionRange = VersionRange.parse(Version.emptyVersion.toString());\n        m_version = m_versionRange.getLow();\n        for (int i = 0; i < m_attrs.length; i++)\n        {\n            if (m_attrs[i].getName().equals(Constants.VERSION_ATTRIBUTE))\n            {\n                String versionStr = (m_attrs[i].getValue() instanceof Version)\n                    ? ((Version) m_attrs[i].getValue()).toString()\n                    : (String) m_attrs[i].getValue();\n                m_versionRange = VersionRange.parse(versionStr);\n                m_version = m_versionRange.getLow();\n                m_attrs[i] = new R4Attribute(\n                    m_attrs[i].getName(),\n                    m_versionRange,\n                    m_attrs[i].isMandatory());\n            }\n            else if (m_attrs[i].getName().equals(Constants.BUNDLE_VERSION_ATTRIBUTE))\n            {\n                String versionStr = (m_attrs[i].getValue() instanceof Version)\n                    ? ((Version) m_attrs[i].getValue()).toString()\n                    : (String) m_attrs[i].getValue();\n                m_attrs[i] = new R4Attribute(\n                    m_attrs[i].getName(),\n                    VersionRange.parse(versionStr),\n                    m_attrs[i].isMandatory());\n            }\n        }\n    }","id":6546,"modified_method":"public R4Import(String name, R4Directive[] directives, R4Attribute[] attrs)\n    {\n        super(name, directives, attrs);\n\n        // Find all import directives: resolution.\n        for (int i = 0; i < m_directives.length; i++)\n        {\n            if (m_directives[i].getName().equals(Constants.RESOLUTION_DIRECTIVE))\n            {\n                m_isOptional = m_directives[i].getValue().equals(Constants.RESOLUTION_OPTIONAL);\n            }\n        }\n\n        // Cache version and version range, if present.\n        m_versionRange = VersionRange.parse(Version.emptyVersion.toString());\n        m_version = m_versionRange.getLow();\n        for (int i = 0; i < m_attrs.length; i++)\n        {\n            if (m_attrs[i].getName().equals(Constants.VERSION_ATTRIBUTE))\n            {\n                m_versionRange = (VersionRange) m_attrs[i].getValue();\n                m_version = m_versionRange.getLow();\n                break;\n            }\n        }\n    }","commit_id":"a5158a22236a2f3dea58480ef2122d0b4e00566d","url":"https://github.com/apache/felix"},{"original_method":"protected SystemBundle(Felix felix, BundleInfo info, List activatorList)\n    {\n        super(felix, info);\n\n        // Create an activator list if necessary.\n        if (activatorList == null)\n        {\n            activatorList = new ArrayList();\n        }\n\n        // Add the bundle activator for the package admin service.\n        activatorList.add(new PackageAdminActivator(felix));\n\n        // Add the bundle activator for the start level service.\n        activatorList.add(new StartLevelActivator(felix));\n\n        // Add the bundle activator for the URL Handlers service.\n        activatorList.add(new URLHandlersActivator(felix));\n\n        m_activatorList = activatorList;\n\n        // The system bundle exports framework packages as well as\n        // arbitrary user-defined packages from the system class path.\n        // We must construct the system bundle's export metadata.\n\n        // Get system property that specifies which class path\n        // packages should be exported by the system bundle.\n        R4Package[] classPathPkgs = null;\n        try\n        {\n            classPathPkgs = ManifestParser.parseImportExportHeader(\n                getFelix().getConfig().get(Constants.FRAMEWORK_SYSTEMPACKAGES));\n        }\n        catch (Exception ex)\n        {\n            classPathPkgs = new R4Package[0];\n            getFelix().getLogger().log(\n                Logger.LOG_ERROR,\n                \"Error parsing system bundle export statement: \"\n                + getFelix().getConfig().get(Constants.FRAMEWORK_SYSTEMPACKAGES), ex);\n        }\n\n        // Now, create the list of standard framework exports for\n        // the system bundle.\n        m_exports = new R4Export[classPathPkgs.length];\n\n        // Copy the class path exported packages.\n        for (int i = 0; i < classPathPkgs.length; i++)\n        {\n            m_exports[i] = new R4Export(classPathPkgs[i]);\n        }\n\n        m_contentLoader = new SystemBundleContentLoader(getFelix().getLogger());\n\n        StringBuffer exportSB = new StringBuffer(\"\");\n        for (int i = 0; i < m_exports.length; i++)\n        {\n            if (i > 0)\n            {\n                exportSB.append(\", \");\n            }\n\n            exportSB.append(m_exports[i].getName());\n            exportSB.append(\"; version=\\\"\");\n            exportSB.append(m_exports[i].getVersion().toString());\n            exportSB.append(\"\\\"\");\n        }\n\n        // Initialize header map as a case insensitive map.\n        Map map = new StringMap(false);\n        map.put(FelixConstants.BUNDLE_VERSION,\n            getFelix().getConfig().get(FelixConstants.FELIX_VERSION_PROPERTY));\n        map.put(FelixConstants.BUNDLE_SYMBOLICNAME,\n            FelixConstants.SYSTEM_BUNDLE_SYMBOLICNAME);\n        map.put(FelixConstants.BUNDLE_NAME, \"System Bundle\");\n        map.put(FelixConstants.BUNDLE_DESCRIPTION,\n            \"This bundle is system specific; it implements various system services.\");\n        map.put(FelixConstants.EXPORT_PACKAGE, exportSB.toString());\n        map.put(FelixConstants.EXPORT_SERVICE, \"org.osgi.service.packageadmin.PackageAdmin,org.osgi.service.startlevel.StartLevel\");\n        ((SystemBundleArchive) getInfo().getArchive()).setManifestHeader(map);\n\n        // TODO: FRAMEWORK - We need some systematic way for framework services\n        // to add packages and services to the system bundle's headers, something\n        // that will allow for them to be independently configured.\n    }","id":6547,"modified_method":"protected SystemBundle(Felix felix, BundleInfo info, List activatorList)\n    {\n        super(felix, info);\n\n        // Create an activator list if necessary.\n        if (activatorList == null)\n        {\n            activatorList = new ArrayList();\n        }\n\n        // Add the bundle activator for the package admin service.\n        activatorList.add(new PackageAdminActivator(felix));\n\n        // Add the bundle activator for the start level service.\n        activatorList.add(new StartLevelActivator(felix));\n\n        // Add the bundle activator for the URL Handlers service.\n        activatorList.add(new URLHandlersActivator(felix));\n\n        m_activatorList = activatorList;\n\n        // The system bundle exports framework packages as well as\n        // arbitrary user-defined packages from the system class path.\n        // We must construct the system bundle's export metadata.\n\n        // Get system property that specifies which class path\n        // packages should be exported by the system bundle.\n        R4Export[] classPathPkgs = null;\n        try\n        {\n            classPathPkgs = (R4Export[]) ManifestParser.parseImportExportHeader(\n                getFelix().getConfig().get(Constants.FRAMEWORK_SYSTEMPACKAGES), true);\n        }\n        catch (Exception ex)\n        {\n            classPathPkgs = new R4Export[0];\n            getFelix().getLogger().log(\n                Logger.LOG_ERROR,\n                \"Error parsing system bundle export statement: \"\n                + getFelix().getConfig().get(Constants.FRAMEWORK_SYSTEMPACKAGES), ex);\n        }\n\n        // Now, create the list of standard framework exports for\n        // the system bundle.\n        m_exports = new R4Export[classPathPkgs.length];\n\n        // Copy the class path exported packages.\n        for (int i = 0; i < classPathPkgs.length; i++)\n        {\n            m_exports[i] = classPathPkgs[i];\n        }\n\n        m_contentLoader = new SystemBundleContentLoader(getFelix().getLogger());\n\n        StringBuffer exportSB = new StringBuffer(\"\");\n        for (int i = 0; i < m_exports.length; i++)\n        {\n            if (i > 0)\n            {\n                exportSB.append(\", \");\n            }\n\n            exportSB.append(m_exports[i].getName());\n            exportSB.append(\"; version=\\\"\");\n            exportSB.append(m_exports[i].getVersion().toString());\n            exportSB.append(\"\\\"\");\n        }\n\n        // Initialize header map as a case insensitive map.\n        Map map = new StringMap(false);\n        map.put(FelixConstants.BUNDLE_VERSION,\n            getFelix().getConfig().get(FelixConstants.FELIX_VERSION_PROPERTY));\n        map.put(FelixConstants.BUNDLE_SYMBOLICNAME,\n            FelixConstants.SYSTEM_BUNDLE_SYMBOLICNAME);\n        map.put(FelixConstants.BUNDLE_NAME, \"System Bundle\");\n        map.put(FelixConstants.BUNDLE_DESCRIPTION,\n            \"This bundle is system specific; it implements various system services.\");\n        map.put(FelixConstants.EXPORT_PACKAGE, exportSB.toString());\n        map.put(FelixConstants.EXPORT_SERVICE, \"org.osgi.service.packageadmin.PackageAdmin,org.osgi.service.startlevel.StartLevel\");\n        ((SystemBundleArchive) getInfo().getArchive()).setManifestHeader(map);\n\n        // TODO: FRAMEWORK - We need some systematic way for framework services\n        // to add packages and services to the system bundle's headers, something\n        // that will allow for them to be independently configured.\n    }","commit_id":"a5158a22236a2f3dea58480ef2122d0b4e00566d","url":"https://github.com/apache/felix"},{"original_method":"public String toString()\n    {\n        if (m_toString == null)\n        {\n            if (m_high != null)\n            {\n                StringBuffer sb = new StringBuffer();\n                sb.append(m_isLowInclusive ? '[' : '(');\n                sb.append(m_low.toString());\n                sb.append(',');\n                sb.append(m_high.toString());\n                sb.append(m_isHighInclusive ? ']' : ')');\n            }\n            else\n            {\n                m_toString = m_low.toString();\n            }\n        }\n        return m_toString;\n    }","id":6548,"modified_method":"public String toString()\n    {\n        if (m_toString == null)\n        {\n            if (m_high != null)\n            {\n                StringBuffer sb = new StringBuffer();\n                sb.append(m_isLowInclusive ? '[' : '(');\n                sb.append(m_low.toString());\n                sb.append(',');\n                sb.append(m_high.toString());\n                sb.append(m_isHighInclusive ? ']' : ')');\n                m_toString = sb.toString();\n            }\n            else\n            {\n                m_toString = m_low.toString();\n            }\n        }\n        return m_toString;\n    }","commit_id":"a5158a22236a2f3dea58480ef2122d0b4e00566d","url":"https://github.com/apache/felix"},{"original_method":"@Override\n\t@Transactional\n\tpublic NCSComponent addSubcomponent(final String type, final String foreignSource, final String foreignId, final NCSComponent subComponent, final boolean deleteOrphans) {\n\t\tfinal ComponentIdentifier id = new ComponentIdentifier(type, foreignSource, foreignId);\n\t\tfinal ComponentIdentifier subComponentId = getIdentifier(subComponent);\n\t\t\n\t\tLogUtils.debugf(this, \"addSubcomponent(%s, %s, %s, %s, %s)\", type, foreignSource, foreignId, subComponentId, Boolean.valueOf(deleteOrphans));\n\n\t\tfinal ComponentEventQueue ceq = new ComponentEventQueue();\n\t\tfinal NCSComponent component = getComponent(id);\n\n\t\tif (component == null) {\n\t\t\tthrow new ObjectRetrievalFailureException(NCSComponent.class, \"Unable to locate component with type=\" + type + \", foreignSource=\" + foreignSource + \", foreignId=\" + foreignId);\n\t\t}\n\n\t\tfinal NCSComponent updatedSubComponent = addOrUpdateComponents(subComponentId, subComponent, ceq, deleteOrphans);\n\t\tcomponent.addSubcomponent(updatedSubComponent);\n\t\t\n\t\tm_componentDao.update(component);\n\t\tceq.componentUpdated(id);\n\n\t\tceq.sendAll(m_eventForwarder);\n\n\t\treturn getComponent(id);\n\t}","id":6549,"modified_method":"@Override\n\t@Transactional\n\tpublic NCSComponent addSubcomponent(final String type, final String foreignSource, final String foreignId, final NCSComponent subComponent, final boolean deleteOrphans) {\n\t\tfinal ComponentIdentifier id = new ComponentIdentifier(type, foreignSource, foreignId);\n\t\tfinal ComponentIdentifier subComponentId = getIdentifier(subComponent);\n\t\t\n\t\tLogUtils.debugf(this, \"addSubcomponent(%s, %s, %s, %s, %s)\", type, foreignSource, foreignId, subComponentId, Boolean.valueOf(deleteOrphans));\n\n\t\tfinal ComponentEventQueue ceq = new ComponentEventQueue();\n\t\tfinal NCSComponent component = getComponent(id);\n\n\t\tif (component == null) {\n\t\t\tthrow new ObjectRetrievalFailureException(NCSComponent.class, \"Unable to locate component with type=\" + type + \", foreignSource=\" + foreignSource + \", foreignId=\" + foreignId);\n\t\t}\n\n\t\tfinal NCSComponent updatedSubComponent = addOrUpdateComponents(subComponentId, subComponent, ceq, deleteOrphans);\n\t\tcomponent.addSubcomponent(updatedSubComponent);\n\t\t\n\t\tm_componentDao.update(component);\n\t\tceq.componentUpdated(id);\n\n\t\ttry {\n\t\t\tceq.sendAll(m_eventProxy);\n\t\t} catch (final EventProxyException e) {\n\t\t\tLogUtils.warnf(this, e, \"Component %s added to %s, but an error occured while sending add/delete/update events.\", subComponentId, id);\n\t\t}\n\n\t\treturn getComponent(id);\n\t}","commit_id":"4f4c800fb81515879776d1bf6f2fb05a365bf012","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n\t@Transactional\n\tpublic void deleteComponent(final String type, final String foreignSource, final String foreignId, final boolean deleteOrphans) {\n\t\tLogUtils.debugf(this, \"deleteSubcomponent(%s, %s, %s, %s)\", type, foreignSource, foreignId, Boolean.valueOf(deleteOrphans));\n\n\t\tfinal ComponentIdentifier id = new ComponentIdentifier(type, foreignSource, foreignId);\n\t\tfinal ComponentEventQueue ceq = new ComponentEventQueue();\n\t\tdeleteComponent(id, ceq, deleteOrphans);\n\t\tceq.sendAll(m_eventForwarder);\n\t}","id":6550,"modified_method":"@Override\n\t@Transactional\n\tpublic void deleteComponent(final String type, final String foreignSource, final String foreignId, final boolean deleteOrphans) {\n\t\tLogUtils.debugf(this, \"deleteSubcomponent(%s, %s, %s, %s)\", type, foreignSource, foreignId, Boolean.valueOf(deleteOrphans));\n\n\t\tfinal ComponentIdentifier id = new ComponentIdentifier(type, foreignSource, foreignId);\n\t\tfinal ComponentEventQueue ceq = new ComponentEventQueue();\n\t\tdeleteComponent(id, ceq, deleteOrphans);\n\t\ttry {\n\t\t\tceq.sendAll(m_eventProxy);\n\t\t} catch (final EventProxyException e) {\n\t\t\tLogUtils.warnf(this, e, \"Component %s deleted, but an error occured while sending delete/update events.\", id);\n\t\t}\n\t}","commit_id":"4f4c800fb81515879776d1bf6f2fb05a365bf012","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n\t@Transactional\n\tpublic NCSComponent addOrUpdateComponents(final NCSComponent component, final boolean deleteOrphans) {\n\t\tfinal ComponentIdentifier componentId = getIdentifier(component);\n\t\tLogUtils.debugf(this, \"addOrUpdateComponents(%s, %s)\", componentId, Boolean.valueOf(deleteOrphans));\n\t\tfinal ComponentEventQueue ceq = new ComponentEventQueue();\n\t\tfinal NCSComponent updatedComponent = addOrUpdateComponents(componentId, component, ceq, deleteOrphans);\n\t\tceq.sendAll(m_eventForwarder);\n\t\treturn updatedComponent;\n\t}","id":6551,"modified_method":"@Override\n\t@Transactional\n\tpublic NCSComponent addOrUpdateComponents(final NCSComponent component, final boolean deleteOrphans) {\n\t\tfinal ComponentIdentifier componentId = getIdentifier(component);\n\t\tLogUtils.debugf(this, \"addOrUpdateComponents(%s, %s)\", componentId, Boolean.valueOf(deleteOrphans));\n\t\tfinal ComponentEventQueue ceq = new ComponentEventQueue();\n\t\tfinal NCSComponent updatedComponent = addOrUpdateComponents(componentId, component, ceq, deleteOrphans);\n\t\ttry {\n\t\t\tceq.sendAll(m_eventProxy);\n\t\t} catch (final EventProxyException e) {\n\t\t\tLogUtils.warnf(this, e, \"Component %s added, but an error occured while sending add/delete/update events.\", componentId);\n\t\t}\n\t\treturn updatedComponent;\n\t}","commit_id":"4f4c800fb81515879776d1bf6f2fb05a365bf012","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n\tprotected void afterServletStart() throws Exception {\n\t\tm_eventIpcManager = getWebAppContext().getBean(MockEventIpcManager.class);\n\t\tm_eventAnticipator = m_eventIpcManager.getEventAnticipator();\n\t\tfinal NCSComponentService service = getWebAppContext().getBean(NCSComponentService.class);\n\t\tservice.setEventForwarder(m_eventIpcManager);\n\t}","id":6552,"modified_method":"@Override\n\tprotected void afterServletStart() throws Exception {\n\t\tm_eventIpcManager = getWebAppContext().getBean(MockEventIpcManager.class);\n\t\tm_eventAnticipator = m_eventIpcManager.getEventAnticipator();\n\t\tfinal NCSComponentService service = getWebAppContext().getBean(NCSComponentService.class);\n\t\tservice.setEventProxy(m_eventIpcManager);\n\t}","commit_id":"4f4c800fb81515879776d1bf6f2fb05a365bf012","url":"https://github.com/OpenNMS/opennms"},{"original_method":"boolean wasAgentRestartedDuringOperation(Host host, Stage stage, String role) {\n    if (host == null) {\n      // null host is valid in case of server action, skip restart detection\n      return false;\n    } else {\n      String hostName = host.getHostName();\n      long lastStageAttemptTime = stage.getLastAttemptTime(hostName, role);\n      return lastStageAttemptTime > 0 && lastStageAttemptTime <= host.getLastRegistrationTime();\n    }\n  }","id":6553,"modified_method":"protected boolean wasAgentRestartedDuringOperation(Host host, Stage stage, String role) {\n    String hostName = (null == host) ? null : host.getHostName();\n    long lastStageAttemptTime = stage.getLastAttemptTime(hostName, role);\n    return lastStageAttemptTime > 0 && lastStageAttemptTime <= host.getLastRegistrationTime();\n  }","commit_id":"3f2d5bea20ce647d6fff64a9b2d7a488b005f0c9","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Verifies that ActionScheduler respects \"disable parallel stage execution option\"\n   */\n  @Test\n  public void testIndependentStagesExecutionDisabled() throws Exception {\n    ActionQueue aq = new ActionQueue();\n    Clusters fsm = mock(Clusters.class);\n    Cluster oneClusterMock = mock(Cluster.class);\n    Service serviceObj = mock(Service.class);\n    ServiceComponent scomp = mock(ServiceComponent.class);\n    ServiceComponentHost sch = mock(ServiceComponentHost.class);\n    UnitOfWork unitOfWork = mock(UnitOfWork.class);\n    when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);\n    when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);\n    when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);\n    when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);\n    when(serviceObj.getCluster()).thenReturn(oneClusterMock);\n\n    String hostname1 = \"ahost.ambari.apache.org\";\n    String hostname2 = \"bhost.ambari.apache.org\";\n    String hostname3 = \"chost.ambari.apache.org\";\n    String hostname4 = \"chost.ambari.apache.org\";\n    HashMap<String, ServiceComponentHost> hosts =\n            new HashMap<String, ServiceComponentHost>();\n    hosts.put(hostname1, sch);\n    hosts.put(hostname2, sch);\n    hosts.put(hostname3, sch);\n    hosts.put(hostname4, sch);\n    when(scomp.getServiceComponentHosts()).thenReturn(hosts);\n\n    List<Stage> stages = new ArrayList<Stage>();\n    Stage stage = getStageWithSingleTask(\n            hostname1, \"cluster1\", Role.HIVE_CLIENT,\n            RoleCommand.INSTALL, Service.Type.HIVE, 1, 1, 1);\n    Map<String, String> hiveSite = new TreeMap<String, String>();\n    hiveSite.put(\"javax.jdo.option.ConnectionPassword\", \"password\");\n    hiveSite.put(\"hive.server2.thrift.port\", \"10000\");\n    Map<String, Map<String, String>> configurations =\n            new TreeMap<String, Map<String, String>>();\n    configurations.put(\"hive-site\", hiveSite);\n    stage.getExecutionCommands(hostname1).get(0).getExecutionCommand().setConfigurations(configurations);\n    stages.add(stage);\n\n    stages.add( // Stage with the same hostname, should not be scheduled\n        getStageWithSingleTask(\n            hostname1, \"cluster1\", Role.GANGLIA_MONITOR,\n            RoleCommand.START, Service.Type.GANGLIA, 2, 2, 2));\n\n    stages.add(\n        getStageWithSingleTask(\n            hostname2, \"cluster1\", Role.HIVE_CLIENT,\n            RoleCommand.INSTALL, Service.Type.HIVE, 3, 3, 3));\n\n    stages.add(\n        getStageWithSingleTask(\n            hostname3, \"cluster1\", Role.DATANODE,\n            RoleCommand.START, Service.Type.HDFS, 4, 4, 4));\n\n    stages.add( // Stage with the same request id, should not be scheduled\n        getStageWithSingleTask(\n            hostname4, \"cluster1\", Role.GANGLIA_MONITOR,\n            RoleCommand.START, Service.Type.GANGLIA, 5, 5, 4));\n\n    ActionDBAccessor db = mock(ActionDBAccessor.class);\n\n    RequestEntity request = mock(RequestEntity.class);\n    when(request.isExclusive()).thenReturn(false);\n    when(db.getRequestEntity(anyLong())).thenReturn(request);\n\n    when(db.getCommandsInProgressCount()).thenReturn(stages.size());\n    when(db.getStagesInProgress()).thenReturn(stages);\n\n    Properties properties = new Properties();\n    properties.put(Configuration.PARALLEL_STAGE_EXECUTION_KEY, \"false\");\n    Configuration conf = new Configuration(properties);\n    ActionScheduler scheduler = new ActionScheduler(100, 50, db, aq, fsm, 3,\n            new HostsMap((String) null),\n            unitOfWork, null, conf);\n\n    scheduler.doWork();\n\n    Assert.assertEquals(HostRoleStatus.QUEUED, stages.get(0).getHostRoleStatus(hostname1, \"HIVE_CLIENT\"));\n    Assert.assertEquals(HostRoleStatus.PENDING, stages.get(1).getHostRoleStatus(hostname1, \"GANGLIA_MONITOR\"));\n    Assert.assertEquals(HostRoleStatus.PENDING, stages.get(2).getHostRoleStatus(hostname2, \"HIVE_CLIENT\"));\n    Assert.assertEquals(HostRoleStatus.PENDING, stages.get(3).getHostRoleStatus(hostname3, \"DATANODE\"));\n    Assert.assertEquals(HostRoleStatus.PENDING, stages.get(4).getHostRoleStatus(hostname4, \"GANGLIA_MONITOR\"));\n    Assert.assertFalse(stages.get(0).getExecutionCommands(hostname1).get(0).getExecutionCommand().\n            getConfigurations().containsKey(\"javax.jdo.option.ConnectionPassword\"));\n  }","id":6554,"modified_method":"/**\n   * Verifies that ActionScheduler respects \"disable parallel stage execution option\"\n   */\n  @Test\n  public void testIndependentStagesExecutionDisabled() throws Exception {\n    ActionQueue aq = new ActionQueue();\n    Clusters fsm = mock(Clusters.class);\n    Cluster oneClusterMock = mock(Cluster.class);\n    Service serviceObj = mock(Service.class);\n    ServiceComponent scomp = mock(ServiceComponent.class);\n    ServiceComponentHost sch = mock(ServiceComponentHost.class);\n    UnitOfWork unitOfWork = mock(UnitOfWork.class);\n    when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);\n    when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);\n    when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);\n    when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);\n    when(serviceObj.getCluster()).thenReturn(oneClusterMock);\n\n    String hostname1 = \"ahost.ambari.apache.org\";\n    String hostname2 = \"bhost.ambari.apache.org\";\n    String hostname3 = \"chost.ambari.apache.org\";\n    String hostname4 = \"chost.ambari.apache.org\";\n    HashMap<String, ServiceComponentHost> hosts =\n            new HashMap<String, ServiceComponentHost>();\n    hosts.put(hostname1, sch);\n    hosts.put(hostname2, sch);\n    hosts.put(hostname3, sch);\n    hosts.put(hostname4, sch);\n    when(scomp.getServiceComponentHosts()).thenReturn(hosts);\n\n    List<Stage> stages = new ArrayList<Stage>();\n    Stage stage = getStageWithSingleTask(\n            hostname1, \"cluster1\", Role.HIVE_CLIENT,\n            RoleCommand.INSTALL, Service.Type.HIVE, 1, 1, 1);\n    Map<String, String> hiveSite = new TreeMap<String, String>();\n    hiveSite.put(\"javax.jdo.option.ConnectionPassword\", \"password\");\n    hiveSite.put(\"hive.server2.thrift.port\", \"10000\");\n    Map<String, Map<String, String>> configurations =\n            new TreeMap<String, Map<String, String>>();\n    configurations.put(\"hive-site\", hiveSite);\n    stage.getExecutionCommands(hostname1).get(0).getExecutionCommand().setConfigurations(configurations);\n    stages.add(stage);\n\n    stages.add( // Stage with the same hostname, should not be scheduled\n        getStageWithSingleTask(\n            hostname1, \"cluster1\", Role.GANGLIA_MONITOR,\n            RoleCommand.START, Service.Type.GANGLIA, 2, 2, 2));\n\n    stages.add(\n        getStageWithSingleTask(\n            hostname2, \"cluster1\", Role.HIVE_CLIENT,\n            RoleCommand.INSTALL, Service.Type.HIVE, 3, 3, 3));\n\n    stages.add(\n        getStageWithSingleTask(\n            hostname3, \"cluster1\", Role.DATANODE,\n            RoleCommand.START, Service.Type.HDFS, 4, 4, 4));\n\n    stages.add( // Stage with the same request id, should not be scheduled\n        getStageWithSingleTask(\n            hostname4, \"cluster1\", Role.GANGLIA_MONITOR,\n            RoleCommand.START, Service.Type.GANGLIA, 5, 5, 4));\n\n    ActionDBAccessor db = mock(ActionDBAccessor.class);\n\n    RequestEntity request = mock(RequestEntity.class);\n    when(request.isExclusive()).thenReturn(false);\n    when(db.getRequestEntity(anyLong())).thenReturn(request);\n\n    when(db.getCommandsInProgressCount()).thenReturn(stages.size());\n    when(db.getStagesInProgress()).thenReturn(stages);\n\n    Properties properties = new Properties();\n    properties.put(Configuration.PARALLEL_STAGE_EXECUTION_KEY, \"false\");\n    Configuration conf = new Configuration(properties);\n    ActionScheduler scheduler = spy(new ActionScheduler(100, 50, db, aq, fsm, 3,\n            new HostsMap((String) null),\n            unitOfWork, null, conf));\n\n\n    doReturn(false).when(scheduler).wasAgentRestartedDuringOperation(any(Host.class), any(Stage.class), anyString());\n\n    scheduler.doWork();\n\n    Assert.assertEquals(HostRoleStatus.QUEUED, stages.get(0).getHostRoleStatus(hostname1, \"HIVE_CLIENT\"));\n    Assert.assertEquals(HostRoleStatus.PENDING, stages.get(1).getHostRoleStatus(hostname1, \"GANGLIA_MONITOR\"));\n    Assert.assertEquals(HostRoleStatus.PENDING, stages.get(2).getHostRoleStatus(hostname2, \"HIVE_CLIENT\"));\n    Assert.assertEquals(HostRoleStatus.PENDING, stages.get(3).getHostRoleStatus(hostname3, \"DATANODE\"));\n    Assert.assertEquals(HostRoleStatus.PENDING, stages.get(4).getHostRoleStatus(hostname4, \"GANGLIA_MONITOR\"));\n    Assert.assertFalse(stages.get(0).getExecutionCommands(hostname1).get(0).getExecutionCommand().\n            getConfigurations().containsKey(\"javax.jdo.option.ConnectionPassword\"));\n  }","commit_id":"3f2d5bea20ce647d6fff64a9b2d7a488b005f0c9","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Verifies that stages that are executed on different hosts and\n   * rely to different requests are scheduled to be  executed in parallel\n   */\n  @Test\n  public void testIndependentStagesExecution() throws Exception {\n    ActionQueue aq = new ActionQueue();\n    Clusters fsm = mock(Clusters.class);\n    Cluster oneClusterMock = mock(Cluster.class);\n    Service serviceObj = mock(Service.class);\n    ServiceComponent scomp = mock(ServiceComponent.class);\n    ServiceComponentHost sch = mock(ServiceComponentHost.class);\n    UnitOfWork unitOfWork = mock(UnitOfWork.class);\n    //Stage stage = mock(Stage.class);\n    when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);\n    when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);\n    when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);\n    when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);\n    when(serviceObj.getCluster()).thenReturn(oneClusterMock);\n\n    String hostname1 = \"ahost.ambari.apache.org\";\n    String hostname2 = \"bhost.ambari.apache.org\";\n    String hostname3 = \"chost.ambari.apache.org\";\n    String hostname4 = \"chost.ambari.apache.org\";\n    HashMap<String, ServiceComponentHost> hosts =\n            new HashMap<String, ServiceComponentHost>();\n    hosts.put(hostname1, sch);\n    hosts.put(hostname2, sch);\n    hosts.put(hostname3, sch);\n    hosts.put(hostname4, sch);\n    when(scomp.getServiceComponentHosts()).thenReturn(hosts);\n\n    List<Stage> stages = new ArrayList<Stage>();\n    stages.add(\n            getStageWithSingleTask(\n                    hostname1, \"cluster1\", Role.DATANODE,\n                    RoleCommand.START, Service.Type.HDFS, 1, 1, 1));\n    stages.add( // Stage with the same hostname, should not be scheduled\n            getStageWithSingleTask(\n                    hostname1, \"cluster1\", Role.GANGLIA_MONITOR,\n                    RoleCommand.START, Service.Type.GANGLIA, 2, 2, 2));\n\n    stages.add(\n            getStageWithSingleTask(\n                    hostname2, \"cluster1\", Role.DATANODE,\n                    RoleCommand.START, Service.Type.HDFS, 3, 3, 3));\n\n    stages.add(\n        getStageWithSingleTask(\n            hostname3, \"cluster1\", Role.DATANODE,\n            RoleCommand.START, Service.Type.HDFS, 4, 4, 4));\n\n    stages.add( // Stage with the same request id, should not be scheduled\n        getStageWithSingleTask(\n            hostname4, \"cluster1\", Role.GANGLIA_MONITOR,\n            RoleCommand.START, Service.Type.GANGLIA, 5, 5, 4));\n\n    ActionDBAccessor db = mock(ActionDBAccessor.class);\n\n    RequestEntity request = mock(RequestEntity.class);\n    when(request.isExclusive()).thenReturn(false);\n    when(db.getRequestEntity(anyLong())).thenReturn(request);\n\n    when(db.getCommandsInProgressCount()).thenReturn(stages.size());\n    when(db.getStagesInProgress()).thenReturn(stages);\n\n    Properties properties = new Properties();\n    Configuration conf = new Configuration(properties);\n    ActionScheduler scheduler = new ActionScheduler(100, 50, db, aq, fsm, 3,\n            new HostsMap((String) null), unitOfWork, null, conf);\n\n    scheduler.doWork();\n\n    Assert.assertEquals(HostRoleStatus.QUEUED, stages.get(0).getHostRoleStatus(hostname1, \"DATANODE\"));\n    Assert.assertEquals(HostRoleStatus.PENDING, stages.get(1).getHostRoleStatus(hostname1, \"GANGLIA_MONITOR\"));\n    Assert.assertEquals(HostRoleStatus.QUEUED, stages.get(2).getHostRoleStatus(hostname2, \"DATANODE\"));\n    Assert.assertEquals(HostRoleStatus.QUEUED, stages.get(3).getHostRoleStatus(hostname3, \"DATANODE\"));\n    Assert.assertEquals(HostRoleStatus.PENDING, stages.get(4).getHostRoleStatus(hostname4, \"GANGLIA_MONITOR\"));\n  }","id":6555,"modified_method":"/**\n   * Verifies that stages that are executed on different hosts and\n   * rely to different requests are scheduled to be  executed in parallel\n   */\n  @Test\n  public void testIndependentStagesExecution() throws Exception {\n    ActionQueue aq = new ActionQueue();\n    Clusters fsm = mock(Clusters.class);\n    Cluster oneClusterMock = mock(Cluster.class);\n    Service serviceObj = mock(Service.class);\n    ServiceComponent scomp = mock(ServiceComponent.class);\n    ServiceComponentHost sch = mock(ServiceComponentHost.class);\n    UnitOfWork unitOfWork = mock(UnitOfWork.class);\n    //Stage stage = mock(Stage.class);\n    when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);\n    when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);\n    when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);\n    when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);\n    when(serviceObj.getCluster()).thenReturn(oneClusterMock);\n\n    String hostname1 = \"ahost.ambari.apache.org\";\n    String hostname2 = \"bhost.ambari.apache.org\";\n    String hostname3 = \"chost.ambari.apache.org\";\n    String hostname4 = \"chost.ambari.apache.org\";\n    HashMap<String, ServiceComponentHost> hosts =\n            new HashMap<String, ServiceComponentHost>();\n    hosts.put(hostname1, sch);\n    hosts.put(hostname2, sch);\n    hosts.put(hostname3, sch);\n    hosts.put(hostname4, sch);\n    when(scomp.getServiceComponentHosts()).thenReturn(hosts);\n\n    List<Stage> stages = new ArrayList<Stage>();\n    stages.add(\n            getStageWithSingleTask(\n                    hostname1, \"cluster1\", Role.DATANODE,\n                    RoleCommand.START, Service.Type.HDFS, 1, 1, 1));\n    stages.add( // Stage with the same hostname, should not be scheduled\n            getStageWithSingleTask(\n                    hostname1, \"cluster1\", Role.GANGLIA_MONITOR,\n                    RoleCommand.START, Service.Type.GANGLIA, 2, 2, 2));\n\n    stages.add(\n            getStageWithSingleTask(\n                    hostname2, \"cluster1\", Role.DATANODE,\n                    RoleCommand.START, Service.Type.HDFS, 3, 3, 3));\n\n    stages.add(\n        getStageWithSingleTask(\n            hostname3, \"cluster1\", Role.DATANODE,\n            RoleCommand.START, Service.Type.HDFS, 4, 4, 4));\n\n    stages.add( // Stage with the same request id, should not be scheduled\n        getStageWithSingleTask(\n            hostname4, \"cluster1\", Role.GANGLIA_MONITOR,\n            RoleCommand.START, Service.Type.GANGLIA, 5, 5, 4));\n\n    ActionDBAccessor db = mock(ActionDBAccessor.class);\n\n    RequestEntity request = mock(RequestEntity.class);\n    when(request.isExclusive()).thenReturn(false);\n    when(db.getRequestEntity(anyLong())).thenReturn(request);\n\n    when(db.getCommandsInProgressCount()).thenReturn(stages.size());\n    when(db.getStagesInProgress()).thenReturn(stages);\n\n    Properties properties = new Properties();\n    Configuration conf = new Configuration(properties);\n    ActionScheduler scheduler = spy(new ActionScheduler(100, 50, db, aq, fsm, 3,\n            new HostsMap((String) null), unitOfWork, null, conf));\n\n    doReturn(false).when(scheduler).wasAgentRestartedDuringOperation(any(Host.class), any(Stage.class), anyString());\n\n    scheduler.doWork();\n\n    Assert.assertEquals(HostRoleStatus.QUEUED, stages.get(0).getHostRoleStatus(hostname1, \"DATANODE\"));\n    Assert.assertEquals(HostRoleStatus.PENDING, stages.get(1).getHostRoleStatus(hostname1, \"GANGLIA_MONITOR\"));\n    Assert.assertEquals(HostRoleStatus.QUEUED, stages.get(2).getHostRoleStatus(hostname2, \"DATANODE\"));\n    Assert.assertEquals(HostRoleStatus.QUEUED, stages.get(3).getHostRoleStatus(hostname3, \"DATANODE\"));\n    Assert.assertEquals(HostRoleStatus.PENDING, stages.get(4).getHostRoleStatus(hostname4, \"GANGLIA_MONITOR\"));\n  }","commit_id":"3f2d5bea20ce647d6fff64a9b2d7a488b005f0c9","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testExclusiveRequests() throws Exception {\n    ActionQueue aq = new ActionQueue();\n    Clusters fsm = mock(Clusters.class);\n    Cluster oneClusterMock = mock(Cluster.class);\n    Service serviceObj = mock(Service.class);\n    ServiceComponent scomp = mock(ServiceComponent.class);\n    ServiceComponentHost sch = mock(ServiceComponentHost.class);\n    UnitOfWork unitOfWork = mock(UnitOfWork.class);\n    when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);\n    when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);\n    when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);\n    when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);\n    when(serviceObj.getCluster()).thenReturn(oneClusterMock);\n\n    HashMap<String, ServiceComponentHost> hosts =\n            new HashMap<String, ServiceComponentHost>();\n    String hostname1 = \"hostname1\";\n    String hostname2 = \"hostname2\";\n    String hostname3 = \"hostname3\";\n\n    hosts.put(hostname1, sch);\n    hosts.put(hostname2, sch);\n    hosts.put(hostname3, sch);\n    when(scomp.getServiceComponentHosts()).thenReturn(hosts);\n\n    long requestId1 = 1;\n    long requestId2 = 2;\n    long requestId3 = 3;\n\n    final List<Stage> stagesInProgress = new ArrayList<Stage>();\n    int namenodeCmdTaskId = 1;\n    Stage stageInProgress1 = spy(getStageWithSingleTask(\n      hostname1, \"cluster1\", Role.NAMENODE, RoleCommand.START,\n      Service.Type.HDFS, namenodeCmdTaskId, 1, (int) requestId1));\n    Stage stageInProgress2 = spy(getStageWithSingleTask(\n      hostname1, \"cluster1\", Role.DATANODE, RoleCommand.START,\n      Service.Type.HDFS, 2, 2, (int) requestId1));\n    Stage stageInProgress3 = spy(getStageWithSingleTask(\n      hostname2, \"cluster1\", Role.DATANODE, RoleCommand.STOP, //Exclusive\n      Service.Type.HDFS, 3, 3, (int) requestId2));\n    Stage stageInProgress4 = spy(getStageWithSingleTask(\n      hostname3, \"cluster1\", Role.DATANODE, RoleCommand.START,\n      Service.Type.HDFS, 4, 4, (int) requestId3));\n    stagesInProgress.add(stageInProgress1);\n    stagesInProgress.add(stageInProgress2);\n    stagesInProgress.add(stageInProgress3);\n    stagesInProgress.add(stageInProgress4);\n\n\n    Host host1 = mock(Host.class);\n    when(fsm.getHost(anyString())).thenReturn(host1);\n    when(host1.getState()).thenReturn(HostState.HEALTHY);\n    when(host1.getHostName()).thenReturn(hostname);\n    when(host1.getLastRegistrationTime()).thenReturn(HOST_LAST_REGISTRATION_TIME);\n\n    Host host2 = mock(Host.class);\n    when(fsm.getHost(anyString())).thenReturn(host2);\n    when(host2.getState()).thenReturn(HostState.HEALTHY);\n    when(host2.getHostName()).thenReturn(hostname);\n    when(host2.getLastRegistrationTime()).thenReturn(HOST_LAST_REGISTRATION_TIME);\n\n    Host host3 = mock(Host.class);\n    when(fsm.getHost(anyString())).thenReturn(host3);\n    when(host3.getState()).thenReturn(HostState.HEALTHY);\n    when(host3.getHostName()).thenReturn(hostname);\n    when(host3.getLastRegistrationTime()).thenReturn(HOST_LAST_REGISTRATION_TIME);\n\n    ActionDBAccessor db = mock(ActionDBAccessor.class);\n    when(db.getCommandsInProgressCount()).thenReturn(stagesInProgress.size());\n    when(db.getStagesInProgress()).thenReturn(stagesInProgress);\n\n    List<HostRoleCommand> requestTasks = new ArrayList<HostRoleCommand>();\n    for (Stage stage : stagesInProgress) {\n      requestTasks.addAll(stage.getOrderedHostRoleCommands());\n    }\n    when(db.getRequestTasks(anyLong())).thenReturn(requestTasks);\n    when(db.getAllStages(anyLong())).thenReturn(stagesInProgress);\n    doAnswer(new Answer<Void>() {\n      @Override\n      public Void answer(InvocationOnMock invocation) throws Throwable {\n        List<CommandReport> reports = (List<CommandReport>) invocation.getArguments()[0];\n        for (CommandReport report : reports) {\n          String actionId = report.getActionId();\n          long[] requestStageIds = StageUtils.getRequestStage(actionId);\n          Long requestId = requestStageIds[0];\n          Long stageId = requestStageIds[1];\n          Long id = report.getTaskId();\n          for (Stage stage : stagesInProgress) {\n            if (requestId.equals(stage.getRequestId()) && stageId.equals(stage.getStageId())) {\n              for (HostRoleCommand hostRoleCommand : stage.getOrderedHostRoleCommands()) {\n                if (hostRoleCommand.getTaskId() == id) {\n                  hostRoleCommand.setStatus(HostRoleStatus.valueOf(report.getStatus()));\n                }\n              }\n            }\n          }\n\n        }\n\n        return null;\n      }\n    }).when(db).updateHostRoleStates(anyCollectionOf(CommandReport.class));\n\n    when(db.getTask(anyLong())).thenAnswer(new Answer<Object>() {\n      @Override\n      public Object answer(InvocationOnMock invocation) throws Throwable {\n        Long taskId = (Long) invocation.getArguments()[0];\n        for (Stage stage : stagesInProgress) {\n          for (HostRoleCommand command : stage.getOrderedHostRoleCommands()) {\n            if (taskId.equals(command.getTaskId())) {\n              return command;\n            }\n          }\n        }\n        return null;\n      }\n    });\n\n    final Map<Long, Boolean> startedRequests = new HashMap<Long, Boolean>();\n    doAnswer(new Answer<Void>() {\n      @Override\n      public Void answer(InvocationOnMock invocation) throws Throwable {\n        startedRequests.put((Long)invocation.getArguments()[0], true);\n        return null;\n      }\n    }).when(db).startRequest(anyLong());\n\n    RequestEntity request1 = mock(RequestEntity.class);\n    when(request1.isExclusive()).thenReturn(false);\n    RequestEntity request2 = mock(RequestEntity.class);\n    when(request2.isExclusive()).thenReturn(true);\n    RequestEntity request3 = mock(RequestEntity.class);\n    when(request3.isExclusive()).thenReturn(false);\n\n    when(db.getRequestEntity(requestId1)).thenReturn(request1);\n    when(db.getRequestEntity(requestId2)).thenReturn(request2);\n    when(db.getRequestEntity(requestId3)).thenReturn(request3);\n\n    Properties properties = new Properties();\n    Configuration conf = new Configuration(properties);\n\n    ActionScheduler scheduler = new ActionScheduler(100, 50, db, aq, fsm, 3,\n        new HostsMap((String) null), unitOfWork, null, conf);\n\n    doReturn(STAGE_LAST_ATTEMPT_TIME).when(stageInProgress1).getLastAttemptTime(anyString(), anyString());\n    doReturn(STAGE_LAST_ATTEMPT_TIME).when(stageInProgress2).getLastAttemptTime(anyString(), anyString());\n    doReturn(STAGE_LAST_ATTEMPT_TIME).when(stageInProgress3).getLastAttemptTime(anyString(), anyString());\n    doReturn(STAGE_LAST_ATTEMPT_TIME).when(stageInProgress4).getLastAttemptTime(anyString(), anyString());\n\n    // Execution of request 1\n\n    scheduler.doWork();\n\n    Assert.assertTrue(startedRequests.containsKey(requestId1));\n    Assert.assertFalse(startedRequests.containsKey(requestId2));\n    Assert.assertFalse(startedRequests.containsKey(requestId3));\n\n    stagesInProgress.remove(0);\n\n    scheduler.doWork();\n\n    Assert.assertTrue(startedRequests.containsKey(requestId1));\n    Assert.assertFalse(startedRequests.containsKey(requestId2));\n    Assert.assertFalse(startedRequests.containsKey(requestId3));\n\n    // Execution of request 2\n\n    stagesInProgress.remove(0);\n\n    scheduler.doWork();\n\n    Assert.assertTrue(startedRequests.containsKey(requestId1));\n    Assert.assertTrue(startedRequests.containsKey(requestId2));\n    Assert.assertFalse(startedRequests.containsKey(requestId3));\n\n    // Execution of request 3\n\n    stagesInProgress.remove(0);\n\n    scheduler.doWork();\n\n    Assert.assertTrue(startedRequests.containsKey(requestId1));\n    Assert.assertTrue(startedRequests.containsKey(requestId2));\n    Assert.assertTrue(startedRequests.containsKey(requestId3));\n\n  }","id":6556,"modified_method":"@Test\n  public void testExclusiveRequests() throws Exception {\n    ActionQueue aq = new ActionQueue();\n    Clusters fsm = mock(Clusters.class);\n    Cluster oneClusterMock = mock(Cluster.class);\n    Service serviceObj = mock(Service.class);\n    ServiceComponent scomp = mock(ServiceComponent.class);\n    ServiceComponentHost sch = mock(ServiceComponentHost.class);\n    UnitOfWork unitOfWork = mock(UnitOfWork.class);\n    when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);\n    when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);\n    when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);\n    when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);\n    when(serviceObj.getCluster()).thenReturn(oneClusterMock);\n\n    HashMap<String, ServiceComponentHost> hosts =\n            new HashMap<String, ServiceComponentHost>();\n    String hostname1 = \"hostname1\";\n    String hostname2 = \"hostname2\";\n    String hostname3 = \"hostname3\";\n\n    hosts.put(hostname1, sch);\n    hosts.put(hostname2, sch);\n    hosts.put(hostname3, sch);\n    when(scomp.getServiceComponentHosts()).thenReturn(hosts);\n\n    long requestId1 = 1;\n    long requestId2 = 2;\n    long requestId3 = 3;\n\n    final List<Stage> stagesInProgress = new ArrayList<Stage>();\n    int namenodeCmdTaskId = 1;\n    stagesInProgress.add(\n            getStageWithSingleTask(\n                    hostname1, \"cluster1\", Role.NAMENODE, RoleCommand.START,\n                    Service.Type.HDFS, namenodeCmdTaskId, 1, (int) requestId1));\n    stagesInProgress.add(\n            getStageWithSingleTask(\n                    hostname1, \"cluster1\", Role.DATANODE, RoleCommand.START,\n                    Service.Type.HDFS, 2, 2, (int) requestId1));\n    stagesInProgress.add(\n            getStageWithSingleTask(\n                    hostname2, \"cluster1\", Role.DATANODE, RoleCommand.STOP, //Exclusive\n                    Service.Type.HDFS, 3, 3, (int) requestId2));\n\n    stagesInProgress.add(\n            getStageWithSingleTask(\n                    hostname3, \"cluster1\", Role.DATANODE, RoleCommand.START,\n                    Service.Type.HDFS, 4, 4, (int) requestId3));\n\n\n    Host host1 = mock(Host.class);\n    when(fsm.getHost(anyString())).thenReturn(host1);\n    when(host1.getState()).thenReturn(HostState.HEALTHY);\n    when(host1.getHostName()).thenReturn(hostname);\n\n    Host host2 = mock(Host.class);\n    when(fsm.getHost(anyString())).thenReturn(host2);\n    when(host2.getState()).thenReturn(HostState.HEALTHY);\n    when(host2.getHostName()).thenReturn(hostname);\n\n    Host host3 = mock(Host.class);\n    when(fsm.getHost(anyString())).thenReturn(host3);\n    when(host3.getState()).thenReturn(HostState.HEALTHY);\n    when(host3.getHostName()).thenReturn(hostname);\n\n    ActionDBAccessor db = mock(ActionDBAccessor.class);\n    when(db.getCommandsInProgressCount()).thenReturn(stagesInProgress.size());\n    when(db.getStagesInProgress()).thenReturn(stagesInProgress);\n\n    List<HostRoleCommand> requestTasks = new ArrayList<HostRoleCommand>();\n    for (Stage stage : stagesInProgress) {\n      requestTasks.addAll(stage.getOrderedHostRoleCommands());\n    }\n    when(db.getRequestTasks(anyLong())).thenReturn(requestTasks);\n    when(db.getAllStages(anyLong())).thenReturn(stagesInProgress);\n    doAnswer(new Answer<Void>() {\n      @Override\n      public Void answer(InvocationOnMock invocation) throws Throwable {\n        List<CommandReport> reports = (List<CommandReport>) invocation.getArguments()[0];\n        for (CommandReport report : reports) {\n          String actionId = report.getActionId();\n          long[] requestStageIds = StageUtils.getRequestStage(actionId);\n          Long requestId = requestStageIds[0];\n          Long stageId = requestStageIds[1];\n          Long id = report.getTaskId();\n          for (Stage stage : stagesInProgress) {\n            if (requestId.equals(stage.getRequestId()) && stageId.equals(stage.getStageId())) {\n              for (HostRoleCommand hostRoleCommand : stage.getOrderedHostRoleCommands()) {\n                if (hostRoleCommand.getTaskId() == id) {\n                  hostRoleCommand.setStatus(HostRoleStatus.valueOf(report.getStatus()));\n                }\n              }\n            }\n          }\n\n        }\n\n        return null;\n      }\n    }).when(db).updateHostRoleStates(anyCollectionOf(CommandReport.class));\n\n    when(db.getTask(anyLong())).thenAnswer(new Answer<Object>() {\n      @Override\n      public Object answer(InvocationOnMock invocation) throws Throwable {\n        Long taskId = (Long) invocation.getArguments()[0];\n        for (Stage stage : stagesInProgress) {\n          for (HostRoleCommand command : stage.getOrderedHostRoleCommands()) {\n            if (taskId.equals(command.getTaskId())) {\n              return command;\n            }\n          }\n        }\n        return null;\n      }\n    });\n\n    final Map<Long, Boolean> startedRequests = new HashMap<Long, Boolean>();\n    doAnswer(new Answer<Void>() {\n      @Override\n      public Void answer(InvocationOnMock invocation) throws Throwable {\n        startedRequests.put((Long)invocation.getArguments()[0], true);\n        return null;\n      }\n    }).when(db).startRequest(anyLong());\n\n    RequestEntity request1 = mock(RequestEntity.class);\n    when(request1.isExclusive()).thenReturn(false);\n    RequestEntity request2 = mock(RequestEntity.class);\n    when(request2.isExclusive()).thenReturn(true);\n    RequestEntity request3 = mock(RequestEntity.class);\n    when(request3.isExclusive()).thenReturn(false);\n\n    when(db.getRequestEntity(requestId1)).thenReturn(request1);\n    when(db.getRequestEntity(requestId2)).thenReturn(request2);\n    when(db.getRequestEntity(requestId3)).thenReturn(request3);\n\n    Properties properties = new Properties();\n    Configuration conf = new Configuration(properties);\n\n    ActionScheduler scheduler = spy(new ActionScheduler(100, 50, db, aq, fsm, 3,\n        new HostsMap((String) null), unitOfWork, null, conf));\n\n    doReturn(false).when(scheduler).wasAgentRestartedDuringOperation(any(Host.class), any(Stage.class), anyString());\n\n    // Execution of request 1\n\n    scheduler.doWork();\n\n    Assert.assertTrue(startedRequests.containsKey(requestId1));\n    Assert.assertFalse(startedRequests.containsKey(requestId2));\n    Assert.assertFalse(startedRequests.containsKey(requestId3));\n\n    stagesInProgress.remove(0);\n\n    scheduler.doWork();\n\n    Assert.assertTrue(startedRequests.containsKey(requestId1));\n    Assert.assertFalse(startedRequests.containsKey(requestId2));\n    Assert.assertFalse(startedRequests.containsKey(requestId3));\n\n    // Execution of request 2\n\n    stagesInProgress.remove(0);\n\n    scheduler.doWork();\n\n    Assert.assertTrue(startedRequests.containsKey(requestId1));\n    Assert.assertTrue(startedRequests.containsKey(requestId2));\n    Assert.assertFalse(startedRequests.containsKey(requestId3));\n\n    // Execution of request 3\n\n    stagesInProgress.remove(0);\n\n    scheduler.doWork();\n\n    Assert.assertTrue(startedRequests.containsKey(requestId1));\n    Assert.assertTrue(startedRequests.containsKey(requestId2));\n    Assert.assertTrue(startedRequests.containsKey(requestId3));\n\n  }","commit_id":"3f2d5bea20ce647d6fff64a9b2d7a488b005f0c9","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Verifies that ActionScheduler allows to execute background tasks in parallel\n   */\n  @Test\n  public void testBackgroundStagesExecutionEnable() throws Exception {\n    ActionQueue aq = new ActionQueue();\n    Clusters fsm = mock(Clusters.class);\n    Cluster oneClusterMock = mock(Cluster.class);\n    Service serviceObj = mock(Service.class);\n    ServiceComponent scomp = mock(ServiceComponent.class);\n    ServiceComponentHost sch = mock(ServiceComponentHost.class);\n    UnitOfWork unitOfWork = mock(UnitOfWork.class);\n    when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);\n    when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);\n    when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);\n    when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);\n    when(serviceObj.getCluster()).thenReturn(oneClusterMock);\n\n    String hostname1 = \"ahost.ambari.apache.org\";\n    String hostname2 = \"bhost.ambari.apache.org\";\n    HashMap<String, ServiceComponentHost> hosts =\n        new HashMap<String, ServiceComponentHost>();\n    hosts.put(hostname1, sch);\n    hosts.put(hostname2, sch);\n    when(scomp.getServiceComponentHosts()).thenReturn(hosts);\n\n    List<Stage> stages = new ArrayList<Stage>();\n    Stage backgroundStage = null;\n    stages.add(//stage with background command\n        backgroundStage = getStageWithSingleTask(\n            hostname1, \"cluster1\", Role.NAMENODE, RoleCommand.CUSTOM_COMMAND, \"REBALANCEHDFS\", Service.Type.HDFS, 1, 1, 1));\n\n    Assert.assertEquals(AgentCommandType.BACKGROUND_EXECUTION_COMMAND ,backgroundStage.getExecutionCommands(hostname1).get(0).getExecutionCommand().getCommandType());\n\n    stages.add( // Stage with the same hostname, should be scheduled\n        getStageWithSingleTask(\n            hostname1, \"cluster1\", Role.GANGLIA_MONITOR,\n            RoleCommand.START, Service.Type.GANGLIA, 2, 2, 2));\n\n    stages.add(\n        getStageWithSingleTask(\n            hostname2, \"cluster1\", Role.DATANODE,\n            RoleCommand.START, Service.Type.HDFS, 3, 3, 3));\n\n\n    ActionDBAccessor db = mock(ActionDBAccessor.class);\n\n    RequestEntity request = mock(RequestEntity.class);\n    when(request.isExclusive()).thenReturn(false);\n    when(db.getRequestEntity(anyLong())).thenReturn(request);\n\n    when(db.getCommandsInProgressCount()).thenReturn(stages.size());\n    when(db.getStagesInProgress()).thenReturn(stages);\n\n    Properties properties = new Properties();\n    properties.put(Configuration.PARALLEL_STAGE_EXECUTION_KEY, \"true\");\n    Configuration conf = new Configuration(properties);\n    ActionScheduler scheduler = new ActionScheduler(100, 50, db, aq, fsm, 3,\n        new HostsMap((String) null),\n        unitOfWork, null, conf);\n\n    scheduler.doWork();\n\n    Assert.assertEquals(HostRoleStatus.QUEUED, stages.get(0).getHostRoleStatus(hostname1, \"NAMENODE\"));\n    Assert.assertEquals(HostRoleStatus.QUEUED, stages.get(2).getHostRoleStatus(hostname2, \"DATANODE\"));\n\n    Assert.assertEquals(HostRoleStatus.QUEUED, stages.get(1).getHostRoleStatus(hostname1, \"GANGLIA_MONITOR\"));\n  }","id":6557,"modified_method":"/**\n   * Verifies that ActionScheduler allows to execute background tasks in parallel\n   */\n  @Test\n  public void testBackgroundStagesExecutionEnable() throws Exception {\n    ActionQueue aq = new ActionQueue();\n    Clusters fsm = mock(Clusters.class);\n    Cluster oneClusterMock = mock(Cluster.class);\n    Service serviceObj = mock(Service.class);\n    ServiceComponent scomp = mock(ServiceComponent.class);\n    ServiceComponentHost sch = mock(ServiceComponentHost.class);\n    UnitOfWork unitOfWork = mock(UnitOfWork.class);\n    when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);\n    when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);\n    when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);\n    when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);\n    when(serviceObj.getCluster()).thenReturn(oneClusterMock);\n\n    String hostname1 = \"ahost.ambari.apache.org\";\n    String hostname2 = \"bhost.ambari.apache.org\";\n    HashMap<String, ServiceComponentHost> hosts =\n        new HashMap<String, ServiceComponentHost>();\n    hosts.put(hostname1, sch);\n    hosts.put(hostname2, sch);\n    when(scomp.getServiceComponentHosts()).thenReturn(hosts);\n\n    List<Stage> stages = new ArrayList<Stage>();\n    Stage backgroundStage = null;\n    stages.add(//stage with background command\n        backgroundStage = getStageWithSingleTask(\n            hostname1, \"cluster1\", Role.NAMENODE, RoleCommand.CUSTOM_COMMAND, \"REBALANCEHDFS\", Service.Type.HDFS, 1, 1, 1));\n\n    Assert.assertEquals(AgentCommandType.BACKGROUND_EXECUTION_COMMAND ,backgroundStage.getExecutionCommands(hostname1).get(0).getExecutionCommand().getCommandType());\n\n    stages.add( // Stage with the same hostname, should be scheduled\n        getStageWithSingleTask(\n            hostname1, \"cluster1\", Role.GANGLIA_MONITOR,\n            RoleCommand.START, Service.Type.GANGLIA, 2, 2, 2));\n\n    stages.add(\n        getStageWithSingleTask(\n            hostname2, \"cluster1\", Role.DATANODE,\n            RoleCommand.START, Service.Type.HDFS, 3, 3, 3));\n\n\n    ActionDBAccessor db = mock(ActionDBAccessor.class);\n\n    RequestEntity request = mock(RequestEntity.class);\n    when(request.isExclusive()).thenReturn(false);\n    when(db.getRequestEntity(anyLong())).thenReturn(request);\n\n    when(db.getCommandsInProgressCount()).thenReturn(stages.size());\n    when(db.getStagesInProgress()).thenReturn(stages);\n\n    Properties properties = new Properties();\n    properties.put(Configuration.PARALLEL_STAGE_EXECUTION_KEY, \"true\");\n    Configuration conf = new Configuration(properties);\n    ActionScheduler scheduler = spy(new ActionScheduler(100, 50, db, aq, fsm, 3,\n        new HostsMap((String) null),\n        unitOfWork, null, conf));\n\n    doReturn(false).when(scheduler).wasAgentRestartedDuringOperation(any(Host.class), any(Stage.class), anyString());\n\n    scheduler.doWork();\n\n    Assert.assertEquals(HostRoleStatus.QUEUED, stages.get(0).getHostRoleStatus(hostname1, \"NAMENODE\"));\n    Assert.assertEquals(HostRoleStatus.QUEUED, stages.get(2).getHostRoleStatus(hostname2, \"DATANODE\"));\n\n    Assert.assertEquals(HostRoleStatus.QUEUED, stages.get(1).getHostRoleStatus(hostname1, \"GANGLIA_MONITOR\"));\n  }","commit_id":"3f2d5bea20ce647d6fff64a9b2d7a488b005f0c9","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Tests that command failures in skippable stages do not cause the request to\n   * be aborted.\n   */\n  @Test\n  public void testSkippableCommandFailureDoesNotAbortRequest() throws Exception {\n    Properties properties = new Properties();\n    Configuration conf = new Configuration(properties);\n    ActionQueue aq = new ActionQueue();\n    Clusters fsm = mock(Clusters.class);\n    Cluster oneClusterMock = mock(Cluster.class);\n    Service serviceObj = mock(Service.class);\n    ServiceComponent scomp = mock(ServiceComponent.class);\n    ServiceComponentHost sch = mock(ServiceComponentHost.class);\n    UnitOfWork unitOfWork = mock(UnitOfWork.class);\n    when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);\n    when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);\n    when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);\n    when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);\n    when(serviceObj.getCluster()).thenReturn(oneClusterMock);\n\n    String hostname1 = \"ahost.ambari.apache.org\";\n\n    HashMap<String, ServiceComponentHost> hosts = new HashMap<String, ServiceComponentHost>();\n\n    hosts.put(hostname1, sch);\n\n    when(scomp.getServiceComponentHosts()).thenReturn(hosts);\n\n    // create 1 stage with 2 commands and then another stage with 1 command\n    Stage stage = null;\n    Stage stage2 = null;\n    final List<Stage> stages = new ArrayList<Stage>();\n    stages.add(stage = getStageWithSingleTask(hostname1, \"cluster1\", Role.NAMENODE,\n        RoleCommand.STOP, Service.Type.HDFS, 1, 1, 1));\n\n    addInstallTaskToStage(stage, hostname1, \"cluster1\", Role.HBASE_MASTER, RoleCommand.INSTALL,\n        Service.Type.HBASE, 1);\n\n    stages.add(stage2 = getStageWithSingleTask(hostname1, \"cluster1\", Role.DATANODE,\n        RoleCommand.STOP, Service.Type.HDFS, 1, 1, 1));\n\n    // !!! this is the test; make the stages skippable so that when their\n    // commands fail, the entire request is not aborted\n    for (Stage stageToMakeSkippable : stages) {\n      stageToMakeSkippable.setSkippable(true);\n    }\n\n    // fail the first task - normally this would cause an abort, exception that our stages\n    // are skippable now so it should not\n    HostRoleCommand command = stage.getOrderedHostRoleCommands().iterator().next();\n    command.setStatus(HostRoleStatus.FAILED);\n\n    ActionDBAccessor db = mock(ActionDBAccessor.class);\n\n    RequestEntity request = mock(RequestEntity.class);\n    when(request.isExclusive()).thenReturn(false);\n    when(db.getRequestEntity(anyLong())).thenReturn(request);\n\n    when(db.getCommandsInProgressCount()).thenReturn(stages.size());\n    when(db.getStagesInProgress()).thenReturn(stages);\n\n    doAnswer(new Answer<Void>() {\n      @Override\n      public Void answer(InvocationOnMock invocation) throws Throwable {\n        List<CommandReport> reports = (List<CommandReport>) invocation.getArguments()[0];\n        for (CommandReport report : reports) {\n          String actionId = report.getActionId();\n          long[] requestStageIds = StageUtils.getRequestStage(actionId);\n          Long requestId = requestStageIds[0];\n          Long stageId = requestStageIds[1];\n          Long id = report.getTaskId();\n          for (Stage stage : stages) {\n            if (requestId.equals(stage.getRequestId()) && stageId.equals(stage.getStageId())) {\n              for (HostRoleCommand hostRoleCommand : stage.getOrderedHostRoleCommands()) {\n                if (hostRoleCommand.getTaskId() == id) {\n                  hostRoleCommand.setStatus(HostRoleStatus.valueOf(report.getStatus()));\n                }\n              }\n            }\n          }\n\n        }\n\n        return null;\n      }\n    }).when(db).updateHostRoleStates(anyCollectionOf(CommandReport.class));\n\n    when(db.getTask(anyLong())).thenAnswer(new Answer<Object>() {\n      @Override\n      public Object answer(InvocationOnMock invocation) throws Throwable {\n        Long taskId = (Long) invocation.getArguments()[0];\n        for (Stage stage : stages) {\n          for (HostRoleCommand command : stage.getOrderedHostRoleCommands()) {\n            if (taskId.equals(command.getTaskId())) {\n              return command;\n            }\n          }\n        }\n        return null;\n      }\n    });\n    doAnswer(new Answer<Void>() {\n      @Override\n      public Void answer(InvocationOnMock invocation) throws Throwable {\n        Long requestId = (Long) invocation.getArguments()[0];\n        for (Stage stage : stages) {\n          if (requestId.equals(stage.getRequestId())) {\n            for (HostRoleCommand command : stage.getOrderedHostRoleCommands()) {\n              if (command.getStatus() == HostRoleStatus.QUEUED\n                  || command.getStatus() == HostRoleStatus.IN_PROGRESS\n                  || command.getStatus() == HostRoleStatus.PENDING) {\n                command.setStatus(HostRoleStatus.ABORTED);\n              }\n            }\n          }\n        }\n\n        return null;\n      }\n    }).when(db).abortOperation(anyLong());\n\n    ActionScheduler scheduler = new ActionScheduler(100, 50, db, aq, fsm, 3,\n        new HostsMap((String) null), unitOfWork, null, conf);\n\n    scheduler.doWork();\n\n    Assert.assertEquals(HostRoleStatus.FAILED,\n        stages.get(0).getHostRoleStatus(hostname1, \"NAMENODE\"));\n\n    // the remaining tasks should NOT have been aborted since the stage is\n    // skippable - these tasks would normally be ABORTED if the stage was not\n    // skippable\n    Assert.assertEquals(HostRoleStatus.QUEUED,\n        stages.get(0).getHostRoleStatus(hostname1, \"HBASE_MASTER\"));\n\n    Assert.assertEquals(HostRoleStatus.PENDING,\n        stages.get(1).getHostRoleStatus(hostname1, \"DATANODE\"));\n\n  }","id":6558,"modified_method":"/**\n   * Tests that command failures in skippable stages do not cause the request to\n   * be aborted.\n   */\n  @Test\n  public void testSkippableCommandFailureDoesNotAbortRequest() throws Exception {\n    Properties properties = new Properties();\n    Configuration conf = new Configuration(properties);\n    ActionQueue aq = new ActionQueue();\n    Clusters fsm = mock(Clusters.class);\n    Cluster oneClusterMock = mock(Cluster.class);\n    Service serviceObj = mock(Service.class);\n    ServiceComponent scomp = mock(ServiceComponent.class);\n    ServiceComponentHost sch = mock(ServiceComponentHost.class);\n    UnitOfWork unitOfWork = mock(UnitOfWork.class);\n    when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);\n    when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);\n    when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);\n    when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);\n    when(serviceObj.getCluster()).thenReturn(oneClusterMock);\n\n    String hostname1 = \"ahost.ambari.apache.org\";\n\n    HashMap<String, ServiceComponentHost> hosts = new HashMap<String, ServiceComponentHost>();\n\n    hosts.put(hostname1, sch);\n\n    when(scomp.getServiceComponentHosts()).thenReturn(hosts);\n\n    // create 1 stage with 2 commands and then another stage with 1 command\n    Stage stage = null;\n    Stage stage2 = null;\n    final List<Stage> stages = new ArrayList<Stage>();\n    stages.add(stage = getStageWithSingleTask(hostname1, \"cluster1\", Role.NAMENODE,\n        RoleCommand.STOP, Service.Type.HDFS, 1, 1, 1));\n\n    addInstallTaskToStage(stage, hostname1, \"cluster1\", Role.HBASE_MASTER, RoleCommand.INSTALL,\n        Service.Type.HBASE, 1);\n\n    stages.add(stage2 = getStageWithSingleTask(hostname1, \"cluster1\", Role.DATANODE,\n        RoleCommand.STOP, Service.Type.HDFS, 1, 1, 1));\n\n    // !!! this is the test; make the stages skippable so that when their\n    // commands fail, the entire request is not aborted\n    for (Stage stageToMakeSkippable : stages) {\n      stageToMakeSkippable.setSkippable(true);\n    }\n\n    // fail the first task - normally this would cause an abort, exception that our stages\n    // are skippable now so it should not\n    HostRoleCommand command = stage.getOrderedHostRoleCommands().iterator().next();\n    command.setStatus(HostRoleStatus.FAILED);\n\n    ActionDBAccessor db = mock(ActionDBAccessor.class);\n\n    RequestEntity request = mock(RequestEntity.class);\n    when(request.isExclusive()).thenReturn(false);\n    when(db.getRequestEntity(anyLong())).thenReturn(request);\n\n    when(db.getCommandsInProgressCount()).thenReturn(stages.size());\n    when(db.getStagesInProgress()).thenReturn(stages);\n\n    doAnswer(new Answer<Void>() {\n      @Override\n      public Void answer(InvocationOnMock invocation) throws Throwable {\n        List<CommandReport> reports = (List<CommandReport>) invocation.getArguments()[0];\n        for (CommandReport report : reports) {\n          String actionId = report.getActionId();\n          long[] requestStageIds = StageUtils.getRequestStage(actionId);\n          Long requestId = requestStageIds[0];\n          Long stageId = requestStageIds[1];\n          Long id = report.getTaskId();\n          for (Stage stage : stages) {\n            if (requestId.equals(stage.getRequestId()) && stageId.equals(stage.getStageId())) {\n              for (HostRoleCommand hostRoleCommand : stage.getOrderedHostRoleCommands()) {\n                if (hostRoleCommand.getTaskId() == id) {\n                  hostRoleCommand.setStatus(HostRoleStatus.valueOf(report.getStatus()));\n                }\n              }\n            }\n          }\n\n        }\n\n        return null;\n      }\n    }).when(db).updateHostRoleStates(anyCollectionOf(CommandReport.class));\n\n    when(db.getTask(anyLong())).thenAnswer(new Answer<Object>() {\n      @Override\n      public Object answer(InvocationOnMock invocation) throws Throwable {\n        Long taskId = (Long) invocation.getArguments()[0];\n        for (Stage stage : stages) {\n          for (HostRoleCommand command : stage.getOrderedHostRoleCommands()) {\n            if (taskId.equals(command.getTaskId())) {\n              return command;\n            }\n          }\n        }\n        return null;\n      }\n    });\n    doAnswer(new Answer<Void>() {\n      @Override\n      public Void answer(InvocationOnMock invocation) throws Throwable {\n        Long requestId = (Long) invocation.getArguments()[0];\n        for (Stage stage : stages) {\n          if (requestId.equals(stage.getRequestId())) {\n            for (HostRoleCommand command : stage.getOrderedHostRoleCommands()) {\n              if (command.getStatus() == HostRoleStatus.QUEUED\n                  || command.getStatus() == HostRoleStatus.IN_PROGRESS\n                  || command.getStatus() == HostRoleStatus.PENDING) {\n                command.setStatus(HostRoleStatus.ABORTED);\n              }\n            }\n          }\n        }\n\n        return null;\n      }\n    }).when(db).abortOperation(anyLong());\n\n    ActionScheduler scheduler = spy(new ActionScheduler(100, 50, db, aq, fsm, 3,\n        new HostsMap((String) null), unitOfWork, null, conf));\n\n    doReturn(false).when(scheduler).wasAgentRestartedDuringOperation(any(Host.class), any(Stage.class), anyString());\n\n    scheduler.doWork();\n\n    Assert.assertEquals(HostRoleStatus.FAILED,\n        stages.get(0).getHostRoleStatus(hostname1, \"NAMENODE\"));\n\n    // the remaining tasks should NOT have been aborted since the stage is\n    // skippable - these tasks would normally be ABORTED if the stage was not\n    // skippable\n    Assert.assertEquals(HostRoleStatus.QUEUED,\n        stages.get(0).getHostRoleStatus(hostname1, \"HBASE_MASTER\"));\n\n    Assert.assertEquals(HostRoleStatus.PENDING,\n        stages.get(1).getHostRoleStatus(hostname1, \"DATANODE\"));\n\n  }","commit_id":"3f2d5bea20ce647d6fff64a9b2d7a488b005f0c9","url":"https://github.com/apache/ambari"},{"original_method":"protected long[] checkGroups(long userId, long[] groupIds)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong[] oldGroupIds = null;\n\n\t\tPermissionChecker permissionChecker = getPermissionChecker();\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tif (userId != CompanyConstants.SYSTEM) {\n\n\t\t\t// Add back any groups that the administrator does not have the\n\t\t\t// rights to remove or that have a mandatory membership\n\n\t\t\tSet<Group> mandatoryGroups =\n\t\t\t\tMembershipPolicyUtil.getMandatoryGroups(user);\n\n\t\t\tList<Group> oldGroups = groupLocalService.getUserGroups(userId);\n\n\t\t\toldGroupIds = new long[oldGroups.size()];\n\n\t\t\tfor (int i = 0; i < oldGroups.size(); i++) {\n\t\t\t\tGroup group = oldGroups.get(i);\n\n\t\t\t\tif (!ArrayUtil.contains(groupIds, group.getGroupId()) &&\n\t\t\t\t\t(!GroupPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, group.getGroupId(),\n\t\t\t\t\t\tActionKeys.ASSIGN_MEMBERS) ||\n\t\t\t\t\tmandatoryGroups.contains(group))) {\n\n\t\t\t\t\tgroupIds = ArrayUtil.append(groupIds, group.getGroupId());\n\t\t\t\t}\n\n\t\t\t\toldGroupIds[i] = group.getGroupId();\n\t\t\t}\n\t\t}\n\n\t\tMembershipPolicyException membershipPolicyException = null;\n\n\t\t// Check that the administrator has the permission to add a new group\n\t\t// and that the group membership is allowed\n\n\t\tfor (long groupId : groupIds) {\n\t\t\tif ((oldGroupIds == null) ||\n\t\t\t\t!ArrayUtil.contains(oldGroupIds, groupId)) {\n\n\t\t\t\tGroup group = groupPersistence.findByPrimaryKey(groupId);\n\n\t\t\t\tGroupPermissionUtil.check(\n\t\t\t\t\tpermissionChecker, group, ActionKeys.ASSIGN_MEMBERS);\n\n\t\t\t\tif (!MembershipPolicyUtil.isMembershipAllowed(group, user)) {\n\t\t\t\t\tif (membershipPolicyException == null) {\n\t\t\t\t\t\tmembershipPolicyException =\n\t\t\t\t\t\t\tnew MembershipPolicyException(\n\t\t\t\t\t\t\t\tMembershipPolicyException.\n\t\t\t\t\t\t\t\t\tGROUP_MEMBERSHIP_NOT_ALLOWED);\n\n\t\t\t\t\t\tmembershipPolicyException.addUser(user);\n\t\t\t\t\t}\n\n\t\t\t\t\tmembershipPolicyException.addGroup(group);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (membershipPolicyException != null) {\n\t\t\tthrow membershipPolicyException;\n\t\t}\n\n\t\treturn groupIds;\n\t}","id":6559,"modified_method":"protected long[] checkGroups(long userId, long[] groupIds)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong[] oldGroupIds = null;\n\n\t\tPermissionChecker permissionChecker = getPermissionChecker();\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tif (userId != CompanyConstants.SYSTEM) {\n\n\t\t\t// Add back any groups that the administrator does not have the\n\t\t\t// rights to remove or that have a mandatory membership\n\n\t\t\tSet<Group> mandatoryGroups =\n\t\t\t\tMembershipPolicyUtil.getMandatoryGroups(user);\n\n\t\t\tList<Group> oldGroups = groupLocalService.getUserGroups(userId);\n\n\t\t\toldGroupIds = new long[oldGroups.size()];\n\n\t\t\tfor (int i = 0; i < oldGroups.size(); i++) {\n\t\t\t\tGroup group = oldGroups.get(i);\n\n\t\t\t\tif (!ArrayUtil.contains(groupIds, group.getGroupId()) &&\n\t\t\t\t\t(!GroupPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, group.getGroupId(),\n\t\t\t\t\t\tActionKeys.ASSIGN_MEMBERS) ||\n\t\t\t\t\tmandatoryGroups.contains(group))) {\n\n\t\t\t\t\tgroupIds = ArrayUtil.append(groupIds, group.getGroupId());\n\t\t\t\t}\n\n\t\t\t\toldGroupIds[i] = group.getGroupId();\n\t\t\t}\n\t\t}\n\n\t\tMembershipPolicyException membershipPolicyException = null;\n\n\t\t// Check that the administrator has the permission to add a new group\n\t\t// and that the group membership is allowed\n\n\t\tfor (long groupId : groupIds) {\n\t\t\tif ((oldGroupIds != null) &&\n\t\t\t\tArrayUtil.contains(oldGroupIds, groupId)) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tGroup group = groupPersistence.findByPrimaryKey(groupId);\n\n\t\t\tGroupPermissionUtil.check(\n\t\t\t\tpermissionChecker, group, ActionKeys.ASSIGN_MEMBERS);\n\n\t\t\tif (MembershipPolicyUtil.isMembershipAllowed(group, user)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (membershipPolicyException == null) {\n\t\t\t\tmembershipPolicyException = new MembershipPolicyException(\n\t\t\t\t\tMembershipPolicyException.GROUP_MEMBERSHIP_NOT_ALLOWED);\n\n\t\t\t\tmembershipPolicyException.addUser(user);\n\t\t\t}\n\n\t\t\tmembershipPolicyException.addGroup(group);\n\t\t}\n\n\t\tif (membershipPolicyException != null) {\n\t\t\tthrow membershipPolicyException;\n\t\t}\n\n\t\treturn groupIds;\n\t}","commit_id":"d5b20a329801b1bf90ec7eb2e1b8d89a3f6b1286","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected long[] checkRoles(long userId, long[] roleIds)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong[] oldRoleIds = null;\n\n\t\tPermissionChecker permissionChecker = getPermissionChecker();\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tif (userId != CompanyConstants.SYSTEM) {\n\n\t\t\t// Add back any roles that the administrator does not have the\n\t\t\t// rights to remove or that have a mandatory membership\n\n\t\t\tSet<Role> mandatoryRoles = MembershipPolicyUtil.getMandatoryRoles(\n\t\t\t\tuser);\n\n\t\t\tList<Role> oldRoles = roleLocalService.getUserRoles(userId);\n\n\t\t\toldRoleIds = new long[oldRoles.size()];\n\n\t\t\tfor (int i = 0; i < oldRoles.size(); i++) {\n\t\t\t\tRole role = oldRoles.get(i);\n\n\t\t\t\tif (!ArrayUtil.contains(roleIds, role.getRoleId()) &&\n\t\t\t\t\t(!RolePermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, role.getRoleId(),\n\t\t\t\t\t\tActionKeys.ASSIGN_MEMBERS) ||\n\t\t\t\t\tmandatoryRoles.contains(role))) {\n\n\t\t\t\t\troleIds = ArrayUtil.append(roleIds, role.getRoleId());\n\t\t\t\t}\n\n\t\t\t\toldRoleIds[i] = role.getRoleId();\n\t\t\t}\n\t\t}\n\n\t\tMembershipPolicyException membershipPolicyException = null;\n\n\t\t// Check that the administrator has the permission to add a new role\n\t\t// and that the role membership is allowed\n\n\t\tfor (long roleId : roleIds) {\n\t\t\tif ((oldRoleIds == null) ||\n\t\t\t\t!ArrayUtil.contains(oldRoleIds, roleId)) {\n\n\t\t\t\tRolePermissionUtil.check(\n\t\t\t\t\tpermissionChecker, roleId, ActionKeys.ASSIGN_MEMBERS);\n\n\t\t\t\tRole role = rolePersistence.findByPrimaryKey(roleId);\n\n\t\t\t\tif (!MembershipPolicyUtil.isMembershipAllowed(role, user)) {\n\t\t\t\t\tif (membershipPolicyException == null) {\n\t\t\t\t\t\tmembershipPolicyException =\n\t\t\t\t\t\t\tnew MembershipPolicyException(\n\t\t\t\t\t\t\t\tMembershipPolicyException.\n\t\t\t\t\t\t\t\t\tROLE_MEMBERSHIP_NOT_ALLOWED);\n\n\t\t\t\t\t\tmembershipPolicyException.addUser(user);\n\t\t\t\t\t}\n\n\t\t\t\t\tmembershipPolicyException.addRole(role);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (membershipPolicyException != null) {\n\t\t\tthrow membershipPolicyException;\n\t\t}\n\n\t\treturn roleIds;\n\t}","id":6560,"modified_method":"protected long[] checkRoles(long userId, long[] roleIds)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong[] oldRoleIds = null;\n\n\t\tPermissionChecker permissionChecker = getPermissionChecker();\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tif (userId != CompanyConstants.SYSTEM) {\n\n\t\t\t// Add back any roles that the administrator does not have the\n\t\t\t// rights to remove or that have a mandatory membership\n\n\t\t\tSet<Role> mandatoryRoles = MembershipPolicyUtil.getMandatoryRoles(\n\t\t\t\tuser);\n\n\t\t\tList<Role> oldRoles = roleLocalService.getUserRoles(userId);\n\n\t\t\toldRoleIds = new long[oldRoles.size()];\n\n\t\t\tfor (int i = 0; i < oldRoles.size(); i++) {\n\t\t\t\tRole role = oldRoles.get(i);\n\n\t\t\t\tif (!ArrayUtil.contains(roleIds, role.getRoleId()) &&\n\t\t\t\t\t(!RolePermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, role.getRoleId(),\n\t\t\t\t\t\tActionKeys.ASSIGN_MEMBERS) ||\n\t\t\t\t\tmandatoryRoles.contains(role))) {\n\n\t\t\t\t\troleIds = ArrayUtil.append(roleIds, role.getRoleId());\n\t\t\t\t}\n\n\t\t\t\toldRoleIds[i] = role.getRoleId();\n\t\t\t}\n\t\t}\n\n\t\tMembershipPolicyException membershipPolicyException = null;\n\n\t\t// Check that the administrator has the permission to add a new role\n\t\t// and that the role membership is allowed\n\n\t\tfor (long roleId : roleIds) {\n\t\t\tif ((oldRoleIds != null) &&\n\t\t\t\tArrayUtil.contains(oldRoleIds, roleId)) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tRolePermissionUtil.check(\n\t\t\t\tpermissionChecker, roleId, ActionKeys.ASSIGN_MEMBERS);\n\n\t\t\tRole role = rolePersistence.findByPrimaryKey(roleId);\n\n\t\t\tif (MembershipPolicyUtil.isMembershipAllowed(role, user)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (membershipPolicyException == null) {\n\t\t\t\tmembershipPolicyException = new MembershipPolicyException(\n\t\t\t\t\tMembershipPolicyException.ROLE_MEMBERSHIP_NOT_ALLOWED);\n\n\t\t\t\tmembershipPolicyException.addUser(user);\n\t\t\t}\n\n\t\t\tmembershipPolicyException.addRole(role);\n\t\t}\n\n\t\tif (membershipPolicyException != null) {\n\t\t\tthrow membershipPolicyException;\n\t\t}\n\n\t\treturn roleIds;\n\t}","commit_id":"d5b20a329801b1bf90ec7eb2e1b8d89a3f6b1286","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected long[] checkOrganizations(long userId, long[] organizationIds)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong[] oldOrganizationIds = null;\n\n\t\tPermissionChecker permissionChecker = getPermissionChecker();\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tif (userId != CompanyConstants.SYSTEM) {\n\n\t\t\t// Add back any organizations that the administrator does not have\n\t\t\t// the rights to remove or that have a mandatory membership\n\n\t\t\tSet<Organization> mandatoryOrganizations =\n\t\t\t\tMembershipPolicyUtil.getMandatoryOrganizations(user);\n\n\t\t\tList<Organization> oldOrganizations =\n\t\t\t\torganizationLocalService.getUserOrganizations(userId);\n\n\t\t\toldOrganizationIds = new long[oldOrganizations.size()];\n\n\t\t\tfor (int i = 0; i < oldOrganizations.size(); i++) {\n\t\t\t\tOrganization organization = oldOrganizations.get(i);\n\n\t\t\t\tif (!ArrayUtil.contains(\n\t\t\t\t\t\torganizationIds, organization.getOrganizationId()) &&\n\t\t\t\t\t!OrganizationPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, organization.getOrganizationId(),\n\t\t\t\t\t\tActionKeys.ASSIGN_MEMBERS) ||\n\t\t\t\t\tmandatoryOrganizations.contains(organization)) {\n\n\t\t\t\t\torganizationIds = ArrayUtil.append(\n\t\t\t\t\t\torganizationIds, organization.getOrganizationId());\n\t\t\t\t}\n\n\t\t\t\toldOrganizationIds[i] = organization.getOrganizationId();\n\t\t\t}\n\t\t}\n\n\t\tMembershipPolicyException membershipPolicyException = null;\n\n\t\t// Check that the administrator has the permission to add a new\n\t\t// organization and that the organization membership is allowed\n\n\t\tfor (long organizationId : organizationIds) {\n\t\t\tOrganization organization =\n\t\t\t\torganizationPersistence.findByPrimaryKey(organizationId);\n\n\t\t\tif ((oldOrganizationIds == null) ||\n\t\t\t\t!ArrayUtil.contains(oldOrganizationIds, organizationId)) {\n\n\t\t\t\tOrganizationPermissionUtil.check(\n\t\t\t\t\tpermissionChecker, organization, ActionKeys.ASSIGN_MEMBERS);\n\n\t\t\t\tif (!MembershipPolicyUtil.isMembershipAllowed(\n\t\t\t\t\t\torganization, user)) {\n\n\t\t\t\t\tif (membershipPolicyException == null) {\n\t\t\t\t\t\tmembershipPolicyException =\n\t\t\t\t\t\t\tnew MembershipPolicyException(\n\t\t\t\t\t\t\t\tMembershipPolicyException.\n\t\t\t\t\t\t\t\t\tORGANIZATION_MEMBERSHIP_NOT_ALLOWED);\n\n\t\t\t\t\t\tmembershipPolicyException.addUser(user);\n\t\t\t\t\t}\n\n\t\t\t\t\tmembershipPolicyException.addOrganization(organization);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (membershipPolicyException != null) {\n\t\t\tthrow membershipPolicyException;\n\t\t}\n\n\t\treturn organizationIds;\n\t}","id":6561,"modified_method":"protected long[] checkOrganizations(long userId, long[] organizationIds)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong[] oldOrganizationIds = null;\n\n\t\tPermissionChecker permissionChecker = getPermissionChecker();\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tif (userId != CompanyConstants.SYSTEM) {\n\n\t\t\t// Add back any organizations that the administrator does not have\n\t\t\t// the rights to remove or that have a mandatory membership\n\n\t\t\tSet<Organization> mandatoryOrganizations =\n\t\t\t\tMembershipPolicyUtil.getMandatoryOrganizations(user);\n\n\t\t\tList<Organization> oldOrganizations =\n\t\t\t\torganizationLocalService.getUserOrganizations(userId);\n\n\t\t\toldOrganizationIds = new long[oldOrganizations.size()];\n\n\t\t\tfor (int i = 0; i < oldOrganizations.size(); i++) {\n\t\t\t\tOrganization organization = oldOrganizations.get(i);\n\n\t\t\t\tif (!ArrayUtil.contains(\n\t\t\t\t\t\torganizationIds, organization.getOrganizationId()) &&\n\t\t\t\t\t!OrganizationPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, organization.getOrganizationId(),\n\t\t\t\t\t\tActionKeys.ASSIGN_MEMBERS) ||\n\t\t\t\t\tmandatoryOrganizations.contains(organization)) {\n\n\t\t\t\t\torganizationIds = ArrayUtil.append(\n\t\t\t\t\t\torganizationIds, organization.getOrganizationId());\n\t\t\t\t}\n\n\t\t\t\toldOrganizationIds[i] = organization.getOrganizationId();\n\t\t\t}\n\t\t}\n\n\t\tMembershipPolicyException membershipPolicyException = null;\n\n\t\t// Check that the administrator has the permission to add a new\n\t\t// organization and that the organization membership is allowed\n\n\t\tfor (long organizationId : organizationIds) {\n\t\t\tOrganization organization =\n\t\t\t\torganizationPersistence.findByPrimaryKey(organizationId);\n\n\t\t\tif ((oldOrganizationIds != null) &&\n\t\t\t\tArrayUtil.contains(oldOrganizationIds, organizationId)) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tOrganizationPermissionUtil.check(\n\t\t\t\tpermissionChecker, organization, ActionKeys.ASSIGN_MEMBERS);\n\n\t\t\tif (MembershipPolicyUtil.isMembershipAllowed(organization, user)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (membershipPolicyException == null) {\n\t\t\t\tmembershipPolicyException = new MembershipPolicyException(\n\t\t\t\t\tMembershipPolicyException.\n\t\t\t\t\t\tORGANIZATION_MEMBERSHIP_NOT_ALLOWED);\n\n\t\t\t\tmembershipPolicyException.addUser(user);\n\t\t\t}\n\n\t\t\tmembershipPolicyException.addOrganization(organization);\n\t\t}\n\n\t\tif (membershipPolicyException != null) {\n\t\t\tthrow membershipPolicyException;\n\t\t}\n\n\t\treturn organizationIds;\n\t}","commit_id":"d5b20a329801b1bf90ec7eb2e1b8d89a3f6b1286","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Sequence eval(\n\t\tSequence contextSequence,\n\t\tItem contextItem)\n\t\tthrows XPathException {\n\t\tif (contextItem != null)\n\t\t\tcontextSequence = contextItem.toSequence();\n\n\t\tSequence s1 = getArgument(0).eval(contextSequence);\n\t\tSequence s2 = getArgument(1).eval(contextSequence);\n\t\tif (s1.getLength() == 0 || s2.getLength() == 0)\n\t\t\treturn Sequence.EMPTY_SEQUENCE;\n\t\tif (Collations.endsWith(context.getDefaultCollator(), s1.getStringValue(), s2.getStringValue()))\n\t\t\treturn BooleanValue.TRUE;\n\t\telse\n\t\t\treturn BooleanValue.FALSE;\n\t}","id":6562,"modified_method":"public Sequence eval(\n\t\tSequence contextSequence,\n\t\tItem contextItem)\n\t\tthrows XPathException {\n\t\tif (contextItem != null)\n\t\t\tcontextSequence = contextItem.toSequence();\n\n\t\tString s1 = getArgument(0).eval(contextSequence).getStringValue();\n\t\tString s2 = getArgument(1).eval(contextSequence).getStringValue();\n\t\tif (s1.length() == 0 || s2.length() == 0)\n\t\t\treturn Sequence.EMPTY_SEQUENCE;\n\t\tCollator collator = getCollator(contextSequence, contextItem, 3);\n\t\tif (Collations.endsWith(collator, s1, s2))\n\t\t\treturn BooleanValue.TRUE;\n\t\telse\n\t\t\treturn BooleanValue.FALSE;\n\t}","commit_id":"3d8496bd163d4bc1431bd09b3187b4fb4b7ea20b","url":"https://github.com/eXist-db/exist"},{"original_method":"public FunEndsWith(XQueryContext context) {\n\t\tsuper(context, signature);\n\t}","id":6563,"modified_method":"public FunEndsWith(XQueryContext context, FunctionSignature signature) {\n\t\tsuper(context, signature);\n\t}","commit_id":"3d8496bd163d4bc1431bd09b3187b4fb4b7ea20b","url":"https://github.com/eXist-db/exist"},{"original_method":"public FunStartsWith(XQueryContext context) {\n\t\tsuper(context, signature);\n\t}","id":6564,"modified_method":"public FunStartsWith(XQueryContext context, FunctionSignature signature) {\n\t\tsuper(context, signature);\n\t}","commit_id":"3d8496bd163d4bc1431bd09b3187b4fb4b7ea20b","url":"https://github.com/eXist-db/exist"},{"original_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n\t\tif(contextItem != null)\n\t\t\tcontextSequence = contextItem.toSequence();\n\n\t\tSequence s1 = getArgument(0).eval(contextSequence);\n\t\tSequence s2 = getArgument(1).eval(contextSequence);\n\t\tif(s1.getLength() == 0 || s2.getLength() == 0)\n\t\t\treturn Sequence.EMPTY_SEQUENCE;\n\t\tif(Collations.startsWith(context.getDefaultCollator(), s1.getStringValue(), s2.getStringValue()))\n\t\t\treturn BooleanValue.TRUE;\n\t\telse\n\t\t\treturn BooleanValue.FALSE;\n\t}","id":6565,"modified_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n\t\tif(contextItem != null)\n\t\t\tcontextSequence = contextItem.toSequence();\n\n\t\tString s1 = getArgument(0).eval(contextSequence).getStringValue();\n\t\tString s2 = getArgument(1).eval(contextSequence).getStringValue();\n\t\tif(s1.length() == 0 || s2.length() == 0)\n\t\t\treturn Sequence.EMPTY_SEQUENCE;\n\t\tCollator collator = getCollator(contextSequence, contextItem, 3);\n\t\tif(Collations.startsWith(collator, s1, s2))\n\t\t\treturn BooleanValue.TRUE;\n\t\telse\n\t\t\treturn BooleanValue.FALSE;\n\t}","commit_id":"3d8496bd163d4bc1431bd09b3187b4fb4b7ea20b","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * This method is responsible for returning a String object which represents\n     * the content of this ThresholdEntity. Primarily used for debugging\n     * purposes.\n     *\n     * @return String which represents the content of this ThresholdEntity\n     */\n    public String toString() {\n        if (!hasThresholds()) {\n            return \"\";\n        }\n\n        StringBuffer buffer = new StringBuffer(\"{\");\n\n        buffer.append(\"dsName=\").append(this.getDataSourceExpression());\n        buffer.append(\", dsType=\").append(this.getDatasourceType());\n        buffer.append(\", evaluators=[\");\n        for (ThresholdEvaluatorState item : getThresholdEvaluatorStates(null)) {\n            buffer.append(\"{ds=\").append(item.getThresholdConfig().getDatasourceExpression());\n            buffer.append(\", value=\").append(item.getThresholdConfig().getValue());\n            buffer.append(\", rearm=\").append(item.getThresholdConfig().getRearm());\n            buffer.append(\", trigger=\").append(item.getThresholdConfig().getTrigger());\n            buffer.append(\"}\");\n        }\n        buffer.append(\"]}\");\n\n        return buffer.toString();\n    }","id":6566,"modified_method":"/**\n     * This method is responsible for returning a String object which represents\n     * the content of this ThresholdEntity. Primarily used for debugging\n     * purposes.\n     *\n     * @return String which represents the content of this ThresholdEntity\n     */\n    public String toString() {\n        if (!hasThresholds()) {\n            return \"\";\n        }\n\n        StringBuffer buffer = new StringBuffer(\"{\");\n\n        buffer.append(\"evaluator=\").append(this.getThresholdConfig().getType());\n        buffer.append(\", dsName=\").append(this.getDataSourceExpression());\n        buffer.append(\", dsType=\").append(this.getDatasourceType());\n        buffer.append(\", evaluators=[\");\n        for (ThresholdEvaluatorState item : getThresholdEvaluatorStates(null)) {\n            buffer.append(\"{ds=\").append(item.getThresholdConfig().getDatasourceExpression());\n            buffer.append(\", value=\").append(item.getThresholdConfig().getValue());\n            buffer.append(\", rearm=\").append(item.getThresholdConfig().getRearm());\n            buffer.append(\", trigger=\").append(item.getThresholdConfig().getTrigger());\n            buffer.append(\"}\");\n        }\n        buffer.append(\"]}\");\n\n        return buffer.toString();\n    }","commit_id":"ba75f61e3eec2991d50de118c66fa9f28da0f22f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Status evaluate(double dsValue) {\n        \tif(!Double.isNaN(getLastSample())) {\n\t            double threshold = getLastSample()+getChange();\n\t\n\t            if (getChange() < 0.0) {\n\t            \t//Negative change; care if the value is *below* the threshold\n\t                if (dsValue <= threshold) {\n\t                    setPreviousTriggeringSample(getLastSample());\n\t                    setLastSample(dsValue);\n\t                    return Status.TRIGGERED;\n\t                }\n\t            } else {\n\t            \t//Positive change; care if the current value is *above* the threshold\n\t                if (dsValue >= threshold) {\n\t                    setPreviousTriggeringSample(getLastSample());\n\t                    setLastSample(dsValue);\n\t                    return Status.TRIGGERED;\n\t                }\n\t            }\n        \t}\n            setLastSample(dsValue);\n            return Status.NO_CHANGE;\n        }","id":6567,"modified_method":"public Status evaluate(double dsValue) {\n            if(!Double.isNaN(getLastSample())) {\n                double threshold = getLastSample()+getChange();\n\n                if (getChange() < 0.0) {\n                    //Negative change; care if the value is *below* the threshold\n                    if (dsValue <= threshold) {\n                        setPreviousTriggeringSample(getLastSample());\n                        setLastSample(dsValue);\n                        log().debug(\"evaluate: absolute negative change threshold triggered\");\n                        return Status.TRIGGERED;\n                    }\n                } else {\n                    //Positive change; care if the current value is *above* the threshold\n                    if (dsValue >= threshold) {\n                        setPreviousTriggeringSample(getLastSample());\n                        setLastSample(dsValue);\n                        log().debug(\"evaluate: absolute positive change threshold triggered\");\n                        return Status.TRIGGERED;\n                    }\n                }\n            }\n            setLastSample(dsValue);\n            return Status.NO_CHANGE;\n        }","commit_id":"ba75f61e3eec2991d50de118c66fa9f28da0f22f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Event createBasicEvent(String uei, Date date, double dsValue, CollectionResourceWrapper resource) {\n            Map<String,String> params = new HashMap<String,String>();\n            params.put(\"previousValue\", formatValue(getPreviousTriggeringSample()));\n            params.put(\"changeThreshold\", Double.toString(getThresholdConfig().getValue()));\n            return createBasicEvent(uei, date, dsValue, resource, params);\n        }","id":6568,"modified_method":"private Event createBasicEvent(String uei, Date date, double dsValue, CollectionResourceWrapper resource) {\n            Map<String,String> params = new HashMap<String,String>();\n            params.put(\"previousValue\", formatValue(getPreviousTriggeringSample()));\n            params.put(\"changeThreshold\", Double.toString(getThresholdConfig().getValue()));\n            params.put(\"trigger\", Integer.toString(getThresholdConfig().getTrigger()));\n            return createBasicEvent(uei, date, dsValue, resource, params);\n        }","commit_id":"ba75f61e3eec2991d50de118c66fa9f28da0f22f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test    \n    public void testLatencyThresholdingSet() throws Exception {\n        Integer ifIndex = 1;\n        String ifName = \"lo0\";\n        setupSnmpInterfaceDatabase(\"127.0.0.1\", ifName);\n\n        LatencyThresholdingSet thresholdingSet = new LatencyThresholdingSet(1, \"127.0.0.1\", \"HTTP\", getRepository(), 0);\n        assertTrue(thresholdingSet.hasThresholds()); // Global Test\n        Map<String, Double> attributes = new HashMap<String, Double>();\n        attributes.put(\"http\", 90.0);\n        assertTrue(thresholdingSet.hasThresholds(attributes)); // Datasource Test\n        List<Event> triggerEvents = thresholdingSet.applyThresholds(\"http\", attributes);\n        assertTrue(triggerEvents.size() == 0);\n\n        // Test Trigger\n        attributes.put(\"http\", 200.0);\n        for (int i = 1; i < 5; i++) {\n            log().debug(\"testLatencyThresholdingSet: run number \" + i);\n            if (thresholdingSet.hasThresholds(attributes)) {\n                triggerEvents = thresholdingSet.applyThresholds(\"http\", attributes);\n                assertTrue(triggerEvents.size() == 0);\n            }\n        }\n        if (thresholdingSet.hasThresholds(attributes)) {\n            log().debug(\"testLatencyThresholdingSet: run number 5\");\n            triggerEvents = thresholdingSet.applyThresholds(\"http\", attributes);\n            assertTrue(triggerEvents.size() == 1);\n        }\n        \n        // Test Rearm\n        List<Event> rearmEvents = null;\n        if (thresholdingSet.hasThresholds(attributes)) {\n            attributes.put(\"http\", 40.0);\n            rearmEvents = thresholdingSet.applyThresholds(\"http\", attributes);\n            assertTrue(rearmEvents.size() == 1);\n        }\n\n        // Validate Events\n        addEvent(\"uei.opennms.org/threshold/highThresholdExceeded\", \"127.0.0.1\", \"HTTP\", 5, 100, 50, 200, ifName, \"127.0.0.1[http]\", \"http\", ifName, ifIndex.toString());\n        addEvent(\"uei.opennms.org/threshold/highThresholdRearmed\", \"127.0.0.1\", \"HTTP\", 5, 100, 50, 40, ifName, \"127.0.0.1[http]\", \"http\", ifName, ifIndex.toString());\n        ThresholdingEventProxy proxy = new ThresholdingEventProxy();\n        proxy.add(triggerEvents);\n        proxy.add(rearmEvents);\n        proxy.sendAllEvents();\n        verifyEvents(0);\n    }","id":6569,"modified_method":"@Test    \n    public void testLatencyThresholdingSet() throws Exception {\n        Integer ifIndex = 1;\n        String ifName = \"lo0\";\n        setupSnmpInterfaceDatabase(\"127.0.0.1\", ifName);\n\n        LatencyThresholdingSet thresholdingSet = new LatencyThresholdingSet(1, \"127.0.0.1\", \"HTTP\", getRepository(), 0);\n        assertTrue(thresholdingSet.hasThresholds()); // Global Test\n        Map<String, Double> attributes = new HashMap<String, Double>();\n        attributes.put(\"http\", 90.0);\n        assertTrue(thresholdingSet.hasThresholds(attributes)); // Datasource Test\n        List<Event> triggerEvents = thresholdingSet.applyThresholds(\"http\", attributes);\n        assertTrue(triggerEvents.size() == 0);\n\n        // Test Trigger\n        attributes.put(\"http\", 200.0);\n        for (int i = 1; i < 5; i++) {\n            log().debug(\"testLatencyThresholdingSet: run number \" + i);\n            if (thresholdingSet.hasThresholds(attributes)) {\n                triggerEvents = thresholdingSet.applyThresholds(\"http\", attributes);\n                assertTrue(triggerEvents.size() == 0);\n            }\n        }\n        if (thresholdingSet.hasThresholds(attributes)) {\n            log().debug(\"testLatencyThresholdingSet: run number 5\");\n            triggerEvents = thresholdingSet.applyThresholds(\"http\", attributes);\n            assertTrue(triggerEvents.size() == 1);\n        }\n        \n        // Test Rearm\n        List<Event> rearmEvents = null;\n        if (thresholdingSet.hasThresholds(attributes)) {\n            attributes.put(\"http\", 40.0);\n            rearmEvents = thresholdingSet.applyThresholds(\"http\", attributes);\n            assertTrue(rearmEvents.size() == 1);\n        }\n\n        // Validate Events\n        addEvent(\"uei.opennms.org/threshold/highThresholdExceeded\", \"127.0.0.1\", \"HTTP\", 5, 100.0, 50.0, 200.0, ifName, \"127.0.0.1[http]\", \"http\", ifName, ifIndex.toString());\n        addEvent(\"uei.opennms.org/threshold/highThresholdRearmed\", \"127.0.0.1\", \"HTTP\", 5, 100.0, 50.0, 40.0, ifName, \"127.0.0.1[http]\", \"http\", ifName, ifIndex.toString());\n        ThresholdingEventProxy proxy = new ThresholdingEventProxy();\n        proxy.add(triggerEvents);\n        proxy.add(rearmEvents);\n        proxy.sendAllEvents();\n        verifyEvents(0);\n    }","commit_id":"ba75f61e3eec2991d50de118c66fa9f28da0f22f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testBug3146_replaceThreshold() throws Exception {\n        ThresholdingVisitor visitor = createVisitor();\n        \n        // Add Events\n        String lowThresholdUei = \"uei.opennms.org/threshold/lowThresholdExceeded\";\n        String highExpression = \"(((hrStorageAllocUnits*hrStorageUsed)/(hrStorageAllocUnits*hrStorageSize))*100)\";\n        String lowExpression = \"(100-((hrStorageAllocUnits*hrStorageUsed)/(hrStorageAllocUnits*hrStorageSize))*100)\";\n        addHighThresholdEvent(1, 30, 25, 50, \"/opt\", \"1\", highExpression, null, null);\n        addHighRearmEvent(1, 30, 25, Double.NaN, \"/opt\", \"1\", highExpression, null, null);\n        addEvent(lowThresholdUei, \"127.0.0.1\", \"SNMP\", 1, 10, 20, 5, \"/opt\", \"1\", lowExpression, null, null);\n\n        // Step 1: Trigger threshold\n        runFileSystemDataTest(visitor, 1, \"/opt\", 500, 1000);\n\n        // Step 2: Reload Configuration (merge). Threshold definition was replaced.\n        initFactories(\"/threshd-configuration.xml\",\"/test-thresholds-4.xml\");\n        visitor.reload();\n        \n        // Step 3: Must trigger only one low threshold exceeded\n        runFileSystemDataTest(visitor, 1, \"/opt\", 950, 1000);\n        \n        verifyEvents(0);\n    }","id":6570,"modified_method":"@Test\n    public void testBug3146_replaceThreshold() throws Exception {\n        ThresholdingVisitor visitor = createVisitor();\n        \n        // Add Events\n        String lowThresholdUei = \"uei.opennms.org/threshold/lowThresholdExceeded\";\n        String highExpression = \"(((hrStorageAllocUnits*hrStorageUsed)/(hrStorageAllocUnits*hrStorageSize))*100)\";\n        String lowExpression = \"(100-((hrStorageAllocUnits*hrStorageUsed)/(hrStorageAllocUnits*hrStorageSize))*100)\";\n        addHighThresholdEvent(1, 30, 25, 50, \"/opt\", \"1\", highExpression, null, null);\n        addHighRearmEvent(1, 30, 25, Double.NaN, \"/opt\", \"1\", highExpression, null, null);\n        addEvent(lowThresholdUei, \"127.0.0.1\", \"SNMP\", 1, 10.0, 20.0, 5.0, \"/opt\", \"1\", lowExpression, null, null);\n\n        // Step 1: Trigger threshold\n        runFileSystemDataTest(visitor, 1, \"/opt\", 500, 1000);\n\n        // Step 2: Reload Configuration (merge). Threshold definition was replaced.\n        initFactories(\"/threshd-configuration.xml\",\"/test-thresholds-4.xml\");\n        visitor.reload();\n        \n        // Step 3: Must trigger only one low threshold exceeded\n        runFileSystemDataTest(visitor, 1, \"/opt\", 950, 1000);\n        \n        verifyEvents(0);\n    }","commit_id":"ba75f61e3eec2991d50de118c66fa9f28da0f22f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void runTestForBug2711(Integer ifIndex, Integer remainingEvents) throws Exception {\n        Long ifSpeed = 10000000l;\n        String ifName = \"wlan0\";\n        initFactories(\"/threshd-configuration.xml\",\"/test-thresholds-2.xml\");\n        addEvent(\"uei.opennms.org/threshold/highThresholdExceeded\", \"127.0.0.1\", \"SNMP\", 1, 90, 50, 120, ifName, ifIndex.toString(), \"ifOutOctets\", ifName, ifIndex.toString());\n        addEvent(\"uei.opennms.org/threshold/highThresholdExceeded\", \"127.0.0.1\", \"SNMP\", 1, 90, 50, 120, ifName, ifIndex.toString(), \"ifInOctets\", ifName, ifIndex.toString());\n        runInterfaceResource(createVisitor(), \"0.0.0.0\", ifName, ifSpeed, ifIndex, 10000, 46000); // real value = (46000 - 10000)/300 = 120\n        verifyEvents(remainingEvents);\n    }","id":6571,"modified_method":"private void runTestForBug2711(Integer ifIndex, Integer remainingEvents) throws Exception {\n        Long ifSpeed = 10000000l;\n        String ifName = \"wlan0\";\n        initFactories(\"/threshd-configuration.xml\",\"/test-thresholds-2.xml\");\n        addEvent(\"uei.opennms.org/threshold/highThresholdExceeded\", \"127.0.0.1\", \"SNMP\", 1, 90.0, 50.0, 120.0, ifName, ifIndex.toString(), \"ifOutOctets\", ifName, ifIndex.toString());\n        addEvent(\"uei.opennms.org/threshold/highThresholdExceeded\", \"127.0.0.1\", \"SNMP\", 1, 90.0, 50.0, 120.0, ifName, ifIndex.toString(), \"ifInOctets\", ifName, ifIndex.toString());\n        runInterfaceResource(createVisitor(), \"0.0.0.0\", ifName, ifSpeed, ifIndex, 10000, 46000); // real value = (46000 - 10000)/300 = 120\n        verifyEvents(remainingEvents);\n    }","commit_id":"ba75f61e3eec2991d50de118c66fa9f28da0f22f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testBug3575() throws Exception {\n        initFactories(\"/threshd-configuration-bug3575.xml\",\"/test-thresholds-bug3575.xml\");\n        String ipAddress = \"127.0.0.1\";\n        String ifName = \"eth0\";\n        setupSnmpInterfaceDatabase(ipAddress, ifName);\n        LatencyThresholdingSet thresholdingSet = new LatencyThresholdingSet(1, ipAddress, \"StrafePing\", getRepository(), 0);\n        assertTrue(thresholdingSet.hasThresholds());\n        Map<String, Double> attributes = new HashMap<String, Double>();\n        for (double i=1; i<21; i++)\n            attributes.put(\"ping\" + i, 2 * i);\n        attributes.put(\"loss\", 60.0);\n        attributes.put(\"response-time\", 100.0);\n        attributes.put(\"median\", 100.0);\n        assertTrue(thresholdingSet.hasThresholds(attributes));\n        List<Event> triggerEvents = thresholdingSet.applyThresholds(\"StrafePing\", attributes);\n        assertTrue(triggerEvents.size() == 1);\n        addEvent(\"uei.opennms.org/threshold/highThresholdExceeded\", \"127.0.0.1\", \"StrafePing\", 1, 50, 25, 60, ifName, \"127.0.0.1[StrafePing]\", \"loss\", \"eth0\", null);\n        ThresholdingEventProxy proxy = new ThresholdingEventProxy();\n        proxy.add(triggerEvents);\n        proxy.sendAllEvents();\n        verifyEvents(0);\n    }","id":6572,"modified_method":"@Test\n    public void testBug3575() throws Exception {\n        initFactories(\"/threshd-configuration-bug3575.xml\",\"/test-thresholds-bug3575.xml\");\n        String ipAddress = \"127.0.0.1\";\n        String ifName = \"eth0\";\n        setupSnmpInterfaceDatabase(ipAddress, ifName);\n        LatencyThresholdingSet thresholdingSet = new LatencyThresholdingSet(1, ipAddress, \"StrafePing\", getRepository(), 0);\n        assertTrue(thresholdingSet.hasThresholds());\n        Map<String, Double> attributes = new HashMap<String, Double>();\n        for (double i=1; i<21; i++)\n            attributes.put(\"ping\" + i, 2 * i);\n        attributes.put(\"loss\", 60.0);\n        attributes.put(\"response-time\", 100.0);\n        attributes.put(\"median\", 100.0);\n        assertTrue(thresholdingSet.hasThresholds(attributes));\n        List<Event> triggerEvents = thresholdingSet.applyThresholds(\"StrafePing\", attributes);\n        assertTrue(triggerEvents.size() == 1);\n        addEvent(\"uei.opennms.org/threshold/highThresholdExceeded\", \"127.0.0.1\", \"StrafePing\", 1, 50.0, 25.0, 60.0, ifName, \"127.0.0.1[StrafePing]\", \"loss\", \"eth0\", null);\n        ThresholdingEventProxy proxy = new ThresholdingEventProxy();\n        proxy.add(triggerEvents);\n        proxy.sendAllEvents();\n        verifyEvents(0);\n    }","commit_id":"ba75f61e3eec2991d50de118c66fa9f28da0f22f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testBug3333() throws Exception {\n        initFactories(\"/threshd-configuration.xml\",\"/test-thresholds-bug3333.xml\");\n        ThresholdingVisitor visitor = createVisitor();\n        String expression = \"hrStorageSize-hrStorageUsed\";\n\n        // Trigger Low Threshold\n        addEvent(\"uei.opennms.org/threshold/lowThresholdExceeded\", \"127.0.0.1\", \"SNMP\", 1, 10, 15, 5, \"/opt\", \"1\", expression, null, null);\n        runFileSystemDataTest(visitor, 1, \"/opt\", 95, 100);\n        verifyEvents(0);\n\n        // Rearm Low Threshold and Trigger High Threshold\n        addEvent(\"uei.opennms.org/threshold/lowThresholdRearmed\", \"127.0.0.1\", \"SNMP\", 1, 10, 15, 60, \"/opt\", \"1\", expression, null, null);\n        addHighThresholdEvent(1, 50, 45, 60, \"/opt\", \"1\", expression, null, null);\n        runFileSystemDataTest(visitor, 1, \"/opt\", 40, 100);\n        verifyEvents(0);\n    }","id":6573,"modified_method":"@Test\n    public void testBug3333() throws Exception {\n        initFactories(\"/threshd-configuration.xml\",\"/test-thresholds-bug3333.xml\");\n        ThresholdingVisitor visitor = createVisitor();\n        String expression = \"hrStorageSize-hrStorageUsed\";\n\n        // Trigger Low Threshold\n        addEvent(\"uei.opennms.org/threshold/lowThresholdExceeded\", \"127.0.0.1\", \"SNMP\", 1, 10.0, 15.0, 5.0, \"/opt\", \"1\", expression, null, null);\n        runFileSystemDataTest(visitor, 1, \"/opt\", 95, 100);\n        verifyEvents(0);\n\n        // Rearm Low Threshold and Trigger High Threshold\n        addEvent(\"uei.opennms.org/threshold/lowThresholdRearmed\", \"127.0.0.1\", \"SNMP\", 1, 10.0, 15.0, 60.0, \"/opt\", \"1\", expression, null, null);\n        addHighThresholdEvent(1, 50, 45, 60, \"/opt\", \"1\", expression, null, null);\n        runFileSystemDataTest(visitor, 1, \"/opt\", 40, 100);\n        verifyEvents(0);\n    }","commit_id":"ba75f61e3eec2991d50de118c66fa9f28da0f22f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void addEvent(String uei, String ipaddr, String service, int trigger, double threshold, double rearm, double value, String label, String instance, String ds, String ifLabel, String ifIndex) {\n        Event e = new Event();\n        e.setUei(uei);\n        e.setNodeid(1);\n        e.setInterface(ipaddr);\n        e.setService(service);\n        Parms parms = new Parms();\n\n        Parm p = new Parm();\n        p.setParmName(\"label\");\n        Value v = new Value();\n        v.setContent(label);\n        p.setValue(v);\n        parms.addParm(p);\n\n        if (ifLabel != null) {\n            p = new Parm();\n            p.setParmName(\"ifLabel\");\n            v = new Value();\n            v.setContent(ifLabel);\n            p.setValue(v);\n            parms.addParm(p);            \n        }\n        \n        if (ifIndex != null) {\n            p = new Parm();\n            p.setParmName(\"ifIndex\");\n            v = new Value();\n            v.setContent(ifIndex);\n            p.setValue(v);\n            parms.addParm(p);   \n        }\n        \n        p = new Parm();\n        p.setParmName(\"ds\");\n        v = new Value();\n        v.setContent(ds);\n        p.setValue(v);\n        parms.addParm(p);\n        \n        p = new Parm();\n        p.setParmName(\"value\");\n        v = new Value();\n        String pattern = System.getProperty(\"org.opennms.threshd.value.decimalformat\", \"###.##\"); // See Bug 3427\n        DecimalFormat valueFormatter = new DecimalFormat(pattern);\n        v.setContent(valueFormatter.format(value));\n        p.setValue(v);\n        parms.addParm(p);\n\n        p = new Parm();\n        p.setParmName(\"instance\");\n        v = new Value();\n        v.setContent(instance);\n        p.setValue(v);\n        parms.addParm(p);\n\n        p = new Parm();\n        p.setParmName(\"trigger\");\n        v = new Value();\n        v.setContent(Integer.toString(trigger));\n        p.setValue(v);\n        parms.addParm(p);\n\n        p = new Parm();\n        p.setParmName(\"threshold\");\n        v = new Value();\n        v.setContent(Double.toString(threshold));\n        p.setValue(v);\n        parms.addParm(p);\n        \n        p = new Parm();\n        p.setParmName(\"rearm\");\n        v = new Value();\n        v.setContent(Double.toString(rearm));\n        p.setValue(v);\n        parms.addParm(p);\n\n        e.setParms(parms);\n        m_anticipator.anticipateEvent(e, true);\n        m_anticipatedEvents.add(e);\n    }","id":6574,"modified_method":"private void addEvent(String uei, String ipaddr, String service, Integer trigger, Double threshold, Double rearm, Double value, String label, String instance, String ds, String ifLabel, String ifIndex) {\n        Event e = new Event();\n        e.setUei(uei);\n        e.setNodeid(1);\n        e.setInterface(ipaddr);\n        e.setService(service);\n        Parms parms = new Parms();\n\n        Parm p = new Parm();\n        p.setParmName(\"label\");\n        Value v = new Value();\n        v.setContent(label);\n        p.setValue(v);\n        parms.addParm(p);\n\n        if (ifLabel != null) {\n            p = new Parm();\n            p.setParmName(\"ifLabel\");\n            v = new Value();\n            v.setContent(ifLabel);\n            p.setValue(v);\n            parms.addParm(p);            \n        }\n        \n        if (ifIndex != null) {\n            p = new Parm();\n            p.setParmName(\"ifIndex\");\n            v = new Value();\n            v.setContent(ifIndex);\n            p.setValue(v);\n            parms.addParm(p);   \n        }\n        \n        p = new Parm();\n        p.setParmName(\"ds\");\n        v = new Value();\n        v.setContent(ds);\n        p.setValue(v);\n        parms.addParm(p);\n        \n        if (value != null) {\n            p = new Parm();\n            p.setParmName(\"value\");\n            v = new Value();\n            String pattern = System.getProperty(\"org.opennms.threshd.value.decimalformat\", \"###.##\"); // See Bug 3427\n            DecimalFormat valueFormatter = new DecimalFormat(pattern);\n            v.setContent(valueFormatter.format(value));\n            p.setValue(v);\n            parms.addParm(p);\n        }\n\n        p = new Parm();\n        p.setParmName(\"instance\");\n        v = new Value();\n        v.setContent(instance);\n        p.setValue(v);\n        parms.addParm(p);\n\n        p = new Parm();\n        p.setParmName(\"trigger\");\n        v = new Value();\n        v.setContent(Integer.toString(trigger));\n        p.setValue(v);\n        parms.addParm(p);\n\n        if (threshold != null) {\n            p = new Parm();\n            p.setParmName(\"threshold\");\n            v = new Value();\n            v.setContent(Double.toString(threshold));\n            p.setValue(v);\n            parms.addParm(p);\n        }\n\n        if (rearm != null) {\n            p = new Parm();\n            p.setParmName(\"rearm\");\n            v = new Value();\n            v.setContent(Double.toString(rearm));\n            p.setValue(v);\n            parms.addParm(p);\n        }\n\n        e.setParms(parms);\n        m_anticipator.anticipateEvent(e, true);\n        m_anticipatedEvents.add(e);\n    }","commit_id":"ba75f61e3eec2991d50de118c66fa9f28da0f22f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testBug3488() throws Exception {\n        String ipAddress = \"127.0.0.1\";\n        setupSnmpInterfaceDatabase(ipAddress, null);\n        LatencyThresholdingSet thresholdingSet = new LatencyThresholdingSet(1, ipAddress, \"HTTP\", getRepository(), 0);\n        assertTrue(thresholdingSet.hasThresholds()); // Global Test\n        Map<String, Double> attributes = new HashMap<String, Double>();\n        attributes.put(\"http\", 200.0);\n        assertTrue(thresholdingSet.hasThresholds(attributes)); // Datasource Test\n\n        m_defaultErrorLevelToCheck = Level.ERROR;\n        List<Event> triggerEvents = new ArrayList<Event>();\n        for (int i=0; i<5; i++)\n            triggerEvents.addAll(thresholdingSet.applyThresholds(\"http\", attributes));\n        LoggingEvent[] events = MockLogAppender.getEventsGreaterOrEqual(Level.WARN);\n        assertEquals(\"expecting 5 events\", 5, events.length);\n        for (LoggingEvent e : events)\n            assertEquals(\"Interface (nodeId/ipAddr=1/127.0.0.1) has no ifName and no ifDescr...setting to label to 'no_ifLabel'.\", e.getMessage());\n        assertTrue(triggerEvents.size() == 1);\n\n        addEvent(\"uei.opennms.org/threshold/highThresholdExceeded\", \"127.0.0.1\", \"HTTP\", 5, 100, 50, 200, \"no_ifLabel\", \"127.0.0.1[http]\", \"http\", \"no_ifLabel\", null);\n        ThresholdingEventProxy proxy = new ThresholdingEventProxy();\n        proxy.add(triggerEvents);\n        proxy.sendAllEvents();\n        verifyEvents(0);\n    }","id":6575,"modified_method":"@Test\n    public void testBug3488() throws Exception {\n        String ipAddress = \"127.0.0.1\";\n        setupSnmpInterfaceDatabase(ipAddress, null);\n        LatencyThresholdingSet thresholdingSet = new LatencyThresholdingSet(1, ipAddress, \"HTTP\", getRepository(), 0);\n        assertTrue(thresholdingSet.hasThresholds()); // Global Test\n        Map<String, Double> attributes = new HashMap<String, Double>();\n        attributes.put(\"http\", 200.0);\n        assertTrue(thresholdingSet.hasThresholds(attributes)); // Datasource Test\n\n        m_defaultErrorLevelToCheck = Level.ERROR;\n        List<Event> triggerEvents = new ArrayList<Event>();\n        for (int i=0; i<5; i++)\n            triggerEvents.addAll(thresholdingSet.applyThresholds(\"http\", attributes));\n        LoggingEvent[] events = MockLogAppender.getEventsGreaterOrEqual(Level.WARN);\n        assertEquals(\"expecting 5 events\", 5, events.length);\n        for (LoggingEvent e : events)\n            assertEquals(\"Interface (nodeId/ipAddr=1/127.0.0.1) has no ifName and no ifDescr...setting to label to 'no_ifLabel'.\", e.getMessage());\n        assertTrue(triggerEvents.size() == 1);\n\n        addEvent(\"uei.opennms.org/threshold/highThresholdExceeded\", \"127.0.0.1\", \"HTTP\", 5, 100.0, 50.0, 200.0, \"no_ifLabel\", \"127.0.0.1[http]\", \"http\", \"no_ifLabel\", null);\n        ThresholdingEventProxy proxy = new ThresholdingEventProxy();\n        proxy.add(triggerEvents);\n        proxy.sendAllEvents();\n        verifyEvents(0);\n    }","commit_id":"ba75f61e3eec2991d50de118c66fa9f28da0f22f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\r\n   * Set ok flag.\r\n   * @param o ok flag\r\n   */\r\n  public void check(final boolean o) {\r\n    ok = o;\r\n  }","id":6576,"modified_method":"/**\r\n   * Combines the specified boolean with the {@link #ok} flag with the AND\r\n   * operator, and returns the result.\r\n   * @param o ok flag to be combined\r\n   * @return resulting ok flag\r\n   */\r\n  public boolean ok(final boolean o) {\r\n    ok &= o;\r\n    return ok;\r\n  }","commit_id":"b394632646f7860f53daaba904d7cf035a470ed8","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  protected final boolean parseArguments(final String[] args) {\r\n    final StringBuilder serial = new StringBuilder();\r\n    final StringBuilder bind = new StringBuilder();\r\n    try {\r\n      final Args arg = new Args(args, this, sa() ? LOCALINFO : CLIENTINFO,\r\n          Util.info(CONSOLE, sa() ? LOCALMODE : CLIENTMODE));\r\n      while(arg.more()) {\r\n        if(arg.dash()) {\r\n          final char c = arg.next();\r\n          if(c == 'b') {\r\n            // set/add variable binding\r\n            if(bind.length() != 0) bind.append(',');\r\n            bind.append(arg.string());\r\n            arg.check(set(Prop.BINDINGS, bind));\r\n          } else if(c == 'c') {\r\n            // specify command to be evaluated\r\n            commands = arg.remaining();\r\n          } else if(c == 'd') {\r\n            // activate debug mode\r\n            context.mprop.set(MainProp.DEBUG, true);\r\n          } else if(c == 'D' && sa()) {\r\n            // hidden option: show dot query graph\r\n            arg.check(set(Prop.DOTPLAN, true));\r\n          } else if(c == 'i' && sa()) {\r\n            // open initial file or database\r\n            input = arg.string();\r\n          } else if(c == 'n' && !sa()) {\r\n            // set server name\r\n            context.mprop.set(MainProp.HOST, arg.string());\r\n          } else if(c == 'o') {\r\n            // specify file for result output\r\n            out = new PrintOutput(arg.string());\r\n            if(session != null) session.setOutputStream(out);\r\n          } else if(c == 'p' && !sa()) {\r\n            // set server port\r\n            context.mprop.set(MainProp.PORT, arg.num());\r\n          } else if(c == 'P' && !sa()) {\r\n            // specify password\r\n            pass = arg.string();\r\n          } else if(c == 'q') {\r\n            // specify query to be evaluated\r\n            query = arg.remaining();\r\n          } else if(c == 'r') {\r\n            // hidden option: parse number of runs\r\n            arg.check(set(Prop.RUNS, arg.string()));\r\n          } else if(c == 's') {\r\n            // set/add serialization parameter\r\n            if(serial.length() != 0) serial.append(',');\r\n            serial.append(arg.string());\r\n            arg.check(set(Prop.SERIALIZER, serial));\r\n          } else if(c == 'u') {\r\n            // activate write-back for updates\r\n            arg.check(set(Prop.WRITEBACK, true));\r\n          } else if(c == 'U' && !sa()) {\r\n            // specify user name\r\n            user = arg.string();\r\n          } else if(c == 'v') {\r\n            // show command info\r\n            verbose = true;\r\n          } else if(c == 'V') {\r\n            // show query info\r\n            verbose = true;\r\n            arg.check(set(Prop.QUERYINFO, true));\r\n          } else if(c == 'w') {\r\n            // activate write-back for updates\r\n            arg.check(set(Prop.CHOP, false));\r\n          } else if(c == 'W') {\r\n            // hidden option: write properties before exit\r\n            writeProps = true;\r\n          } else if(c == 'x' && sa()) {\r\n            // hidden option: show original query plan\r\n            arg.check(set(Prop.COMPPLAN, false));\r\n          } else if(c == 'X') {\r\n            // hidden option: show xml query plan\r\n            arg.check(set(Prop.XMLPLAN, true));\r\n            verbose = true;\r\n          } else if(c == 'z') {\r\n            // turn off result serialization\r\n            arg.check(set(Prop.SERIALIZE, false));\r\n          } else {\r\n            arg.check(false);\r\n          }\r\n        } else {\r\n          file = file == null ? arg.string() : file + \" \" + arg.string();\r\n        }\r\n      }\r\n      console = file == null && commands == null && query == null;\r\n      return arg.finish();\r\n    } catch(final IOException ex) {\r\n      Util.errln(Util.server(ex));\r\n      return false;\r\n    }\r\n  }","id":6577,"modified_method":"@Override\r\n  protected final boolean parseArguments(final String[] args) {\r\n    final StringBuilder serial = new StringBuilder();\r\n    final StringBuilder bind = new StringBuilder();\r\n    try {\r\n      final HashMap<Object[], Object> options = new HashMap<Object[], Object>();\r\n      final Args arg = new Args(args, this, sa() ? LOCALINFO : CLIENTINFO,\r\n          Util.info(CONSOLE, sa() ? LOCALMODE : CLIENTMODE));\r\n      while(arg.more()) {\r\n        if(arg.dash()) {\r\n          final char c = arg.next();\r\n          if(c == 'b') {\r\n            // set/add variable binding\r\n            if(bind.length() != 0) bind.append(',');\r\n            bind.append(arg.string());\r\n            options.put(Prop.BINDINGS, bind);\r\n          } else if(c == 'c') {\r\n            // specify command to be evaluated\r\n            commands = arg.remaining();\r\n          } else if(c == 'd') {\r\n            // activate debug mode\r\n            context.mprop.set(MainProp.DEBUG, true);\r\n          } else if(c == 'D' && sa()) {\r\n            // hidden option: show dot query graph\r\n            options.put(Prop.DOTPLAN, true);\r\n          } else if(c == 'i' && sa()) {\r\n            // open initial file or database\r\n            input = arg.string();\r\n          } else if(c == 'n' && !sa()) {\r\n            // set server name\r\n            context.mprop.set(MainProp.HOST, arg.string());\r\n          } else if(c == 'o') {\r\n            // specify file for result output\r\n            out = new PrintOutput(arg.string());\r\n            if(session != null) session.setOutputStream(out);\r\n          } else if(c == 'p' && !sa()) {\r\n            // set server port\r\n            context.mprop.set(MainProp.PORT, arg.num());\r\n          } else if(c == 'P' && !sa()) {\r\n            // specify password\r\n            pass = arg.string();\r\n          } else if(c == 'q') {\r\n            // specify query to be evaluated\r\n            query = arg.remaining();\r\n          } else if(c == 'r') {\r\n            // hidden option: parse number of runs\r\n            options.put(Prop.RUNS, arg.string());\r\n          } else if(c == 's') {\r\n            // set/add serialization parameter\r\n            if(serial.length() != 0) serial.append(',');\r\n            serial.append(arg.string());\r\n            options.put(Prop.SERIALIZER, serial);\r\n          } else if(c == 'u') {\r\n            // activate write-back for updates\r\n            options.put(Prop.WRITEBACK, true);\r\n          } else if(c == 'U' && !sa()) {\r\n            // specify user name\r\n            user = arg.string();\r\n          } else if(c == 'v') {\r\n            // show command info\r\n            verbose = true;\r\n          } else if(c == 'V') {\r\n            // show query info\r\n            verbose = true;\r\n            options.put(Prop.QUERYINFO, true);\r\n          } else if(c == 'w') {\r\n            // activate write-back for updates\r\n            options.put(Prop.CHOP, false);\r\n          } else if(c == 'W') {\r\n            // hidden option: write properties before exit\r\n            writeProps = true;\r\n          } else if(c == 'x' && sa()) {\r\n            // hidden option: show original query plan\r\n            options.put(Prop.COMPPLAN, false);\r\n          } else if(c == 'X') {\r\n            // hidden option: show xml query plan\r\n            options.put(Prop.XMLPLAN, true);\r\n            verbose = true;\r\n          } else if(c == 'z') {\r\n            // turn off result serialization\r\n            options.put(Prop.SERIALIZE, false);\r\n          } else {\r\n            arg.ok(false);\r\n          }\r\n        } else {\r\n          file = file == null ? arg.string() : file + \" \" + arg.string();\r\n        }\r\n      }\r\n      console = file == null && commands == null && query == null;\r\n\r\n      // set cached options\r\n      for(final Map.Entry<Object[], Object> entry : options.entrySet()) {\r\n        if(!arg.ok(set(entry.getKey(), entry.getValue()))) break;\r\n      }\r\n      return arg.finish();\r\n    } catch(final IOException ex) {\r\n      Util.errln(Util.server(ex));\r\n      return false;\r\n    }\r\n  }","commit_id":"b394632646f7860f53daaba904d7cf035a470ed8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Parses the command-line arguments, specified by the user.\r\n   * @param args command-line arguments\r\n   * @return success flag\r\n   */\r\n  private boolean parseArguments(final String[] args) {\r\n    final Args arg = new Args(args, this, GUIINFO, Util.info(CONSOLE, GUIMODE));\r\n    while(arg.more()) {\r\n      if(arg.dash()) {\r\n        arg.check(false);\r\n      } else {\r\n        file = file == null ? arg.string() : file + \" \" + arg.string();\r\n      }\r\n    }\r\n    return arg.finish();\r\n  }","id":6578,"modified_method":"/**\r\n   * Parses the command-line arguments, specified by the user.\r\n   * @param args command-line arguments\r\n   * @return success flag\r\n   */\r\n  private boolean parseArguments(final String[] args) {\r\n    final Args arg = new Args(args, this, GUIINFO, Util.info(CONSOLE, GUIMODE));\r\n    while(arg.more()) {\r\n      if(arg.dash()) {\r\n        arg.ok(false);\r\n      } else {\r\n        file = file == null ? arg.string() : file + \" \" + arg.string();\r\n      }\r\n    }\r\n    return arg.finish();\r\n  }","commit_id":"b394632646f7860f53daaba904d7cf035a470ed8","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  protected boolean parseArguments(final String[] args) {\n    final Args arg = new Args(args, this, SERVERINFO, Util.info(CONSOLE,\n        SERVERMODE));\n    boolean daemon = false;\n    while(arg.more()) {\n      if(arg.dash()) {\n        final char c = arg.next();\n        if(c == 'c') {\n          // send database commands\n          commands = arg.remaining();\n        } else if(c == 'd') {\n          // activate debug mode\n          context.mprop.set(MainProp.DEBUG, true);\n        } else if(c == 'D') {\n          // hidden flag: daemon mode\n          daemon = true;\n        } else if(c == 'e') {\n          // parse event port\n          context.mprop.set(MainProp.EVENTPORT, arg.num());\n        } else if(c == 'i') {\n          // activate interactive mode\n          console = true;\n        } else if(c == 'p') {\n          // parse server port\n          context.mprop.set(MainProp.SERVERPORT, arg.num());\n        } else if(c == 's') {\n          // set service flag\n          service = !daemon;\n        } else if(c == 'z') {\n          // suppress logging\n          quiet = true;\n        } else {\n          arg.check(false);\n        }\n      } else {\n        arg.check(false);\n        if(arg.string().equalsIgnoreCase(\"stop\")) {\n          stop(context.mprop.num(MainProp.SERVERPORT),\n              context.mprop.num(MainProp.EVENTPORT));\n          Performance.sleep(1000);\n          return false;\n        }\n      }\n    }\n    if(context.mprop.num(MainProp.SERVERPORT) ==\n       context.mprop.num(MainProp.EVENTPORT)) {\n      arg.check(error(null, SERVERPORTS));\n    }\n    return arg.finish();\n  }","id":6579,"modified_method":"@Override\n  protected boolean parseArguments(final String[] args) {\n    final Args arg = new Args(args, this, SERVERINFO, Util.info(CONSOLE,\n        SERVERMODE));\n    boolean daemon = false;\n    while(arg.more()) {\n      if(arg.dash()) {\n        final char c = arg.next();\n        if(c == 'c') {\n          // send database commands\n          commands = arg.remaining();\n        } else if(c == 'd') {\n          // activate debug mode\n          context.mprop.set(MainProp.DEBUG, true);\n        } else if(c == 'D') {\n          // hidden flag: daemon mode\n          daemon = true;\n        } else if(c == 'e') {\n          // parse event port\n          context.mprop.set(MainProp.EVENTPORT, arg.num());\n        } else if(c == 'i') {\n          // activate interactive mode\n          console = true;\n        } else if(c == 'p') {\n          // parse server port\n          context.mprop.set(MainProp.SERVERPORT, arg.num());\n        } else if(c == 's') {\n          // set service flag\n          service = !daemon;\n        } else if(c == 'z') {\n          // suppress logging\n          quiet = true;\n        } else {\n          arg.ok(false);\n        }\n      } else {\n        arg.ok(false);\n        if(arg.string().equalsIgnoreCase(\"stop\")) {\n          stop(context.mprop.num(MainProp.SERVERPORT),\n              context.mprop.num(MainProp.EVENTPORT));\n          Performance.sleep(1000);\n          return false;\n        }\n      }\n    }\n    if(context.mprop.num(MainProp.SERVERPORT) ==\n       context.mprop.num(MainProp.EVENTPORT)) {\n      arg.ok(error(null, SERVERPORTS));\n    }\n    return arg.finish();\n  }","commit_id":"b394632646f7860f53daaba904d7cf035a470ed8","url":"https://github.com/BaseXdb/basex"},{"original_method":"public List theTable(Collection<OnmsOutage> foundOutages) {\n\n\t\tList<Map<String, Object>> theTable = new LinkedList<Map<String, Object>>();\n\t\t\n\n\t\tfor (Iterator iter = foundOutages.iterator(); iter.hasNext();) {\n\t\t\tOnmsOutage outage = (OnmsOutage) iter.next();\n\t\t\tOnmsMonitoredService monitoredService = outage\n\t\t\t\t\t.getMonitoredService();\n\t\t\tOnmsServiceType serviceType = monitoredService.getServiceType();\n\t\t\tOnmsIpInterface ipInterface = monitoredService.getIpInterface();\n\t\t\t\n\t\t\t// ips.put(outage.getId(), ipInterface.getIpAddress());\n\t\t\t// nodes.put(outage.getId(), ipInterface.getNode().getLabel());\n\t\t\t// nodeids.put(outage.getId(), monitoredService.getNodeId());\n\t\t\t// services.put(outage.getId(), serviceType.getName());\n\t\t\t\n\t\t\t\n\n\t\t\tMap<String, Object> outagerow = new HashMap<String, Object>();\n\t\t\toutagerow.put(\"outageid\", outage.getId());\n\t\t\toutagerow.put(\"node\", ipInterface.getNode().getLabel());\n\t\t\toutagerow.put(\"nodeid\", monitoredService.getNodeId());\n\t\t\toutagerow.put(\"ipaddr\", ipInterface.getIpAddress());\n\t\t\toutagerow.put(\"interfaceid\", ipInterface.getId());\n            outagerow.put(\"ifserviceid\", monitoredService.getId());\n            outagerow.put(\"service\", serviceType.getName());\n\t\t\toutagerow.put(\"serviceid\", serviceType.getId());\n\t\t\toutagerow.put(\"eventid\", outage.getServiceLostEvent().getId());\n\n\t\t\t\n\t\t\t\n\t\t\t// if (outage.getIfLostService() != null) {\n\t\t\t// outagerow.put(\"down\",\n\t\t\t// formatter.format(outage.getIfLostService()));\n\t\t\t// }\n\n\t\t\tif (outage.getIfLostService() != null) {\n\t\t\t\toutagerow.put(\"iflostservice\", outage.getIfLostService());\n\t\t\t\toutagerow.put(\"iflostservicelong\", outage.getIfLostService().getTime());\n\t\t\t}\n\n\t\t\tif (outage.getIfRegainedService() != null) {\n\t\t\t\toutagerow.put(\"ifregainedservice\", outage.getIfRegainedService());\n\t\t\t\toutagerow.put(\"ifregainedservicelong\", outage.getIfRegainedService().getTime());\n\t\t\t}\n\n\t\t\tif (outage.getSuppressTime() != null) {\n\t\t\t\toutagerow.put(\"suppresstime\", outage.getSuppressTime());\n\t\t\t}\n\n\t\t\toutagerow.put(\"suppressedby\", outage.getSuppressedBy());\n\t\t\t\n\t\t\t// Build a droplist for this outage\n\t\t\t\n\t\t\ttheTable.add(outagerow);\n\t\t}\n\t\t\n\t\treturn theTable;\n\n\t}","id":6580,"modified_method":"public List<Map<String, Object>> theTable(Collection<OnmsOutage> foundOutages) {\n        List<Map<String, Object>> theTable = new ArrayList<Map<String, Object>>();\n\n        for (OnmsOutage outage : foundOutages) {\n            OnmsMonitoredService monitoredService = outage.getMonitoredService();\n            OnmsServiceType serviceType = monitoredService.getServiceType();\n            OnmsIpInterface ipInterface = monitoredService.getIpInterface();\n\n            // ips.put(outage.getId(), ipInterface.getIpAddress());\n            // nodes.put(outage.getId(), ipInterface.getNode().getLabel());\n            // nodeids.put(outage.getId(), monitoredService.getNodeId());\n            // services.put(outage.getId(), serviceType.getName());\n\n            Map<String, Object> outagerow = new HashMap<String, Object>();\n            outagerow.put(\"outage\", outage);\n            outagerow.put(\"outageid\", outage.getId());\n            outagerow.put(\"node\", ipInterface.getNode().getLabel());\n            outagerow.put(\"nodeid\", monitoredService.getNodeId());\n            outagerow.put(\"ipaddr\", ipInterface.getIpAddress());\n            outagerow.put(\"interfaceid\", ipInterface.getId());\n            outagerow.put(\"ifserviceid\", monitoredService.getId());\n            outagerow.put(\"service\", serviceType.getName());\n            outagerow.put(\"serviceid\", serviceType.getId());\n            outagerow.put(\"eventid\", outage.getServiceLostEvent().getId());\n\n            // if (outage.getIfLostService() != null) {\n            // outagerow.put(\"down\",\n            // formatter.format(outage.getIfLostService()));\n            // }\n\n            if (outage.getIfLostService() != null) {\n                outagerow.put(\"iflostservice\", outage.getIfLostService());\n                outagerow.put(\"iflostservicelong\", outage.getIfLostService().getTime());\n            }\n\n            if (outage.getIfRegainedService() != null) {\n                outagerow.put(\"ifregainedservice\", outage.getIfRegainedService());\n                outagerow.put(\"ifregainedservicelong\", outage.getIfRegainedService().getTime());\n            }\n\n            if (outage.getSuppressTime() != null) {\n                outagerow.put(\"suppresstime\", outage.getSuppressTime());\n            }\n\n            outagerow.put(\"suppressedby\", outage.getSuppressedBy());\n\n            // Build a droplist for this outage\n\n            theTable.add(outagerow);\n        }\n\n        return theTable;\n\n    }","commit_id":"0b0dc60768cddede0bacce260d41c3b82d3a13c6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void afterPropertiesSet() throws Exception {\n        Assert.notNull(m_categoryDao, \"categoryDao property must be set\");\n    }","id":6581,"modified_method":"public void afterPropertiesSet() throws Exception {\n        Assert.notNull(m_filterView, \"filterView property must be set\");\n        Assert.notNull(m_outageListBuilder, \"outageListBuilder property must be set\");\n    }","commit_id":"0b0dc60768cddede0bacce260d41c3b82d3a13c6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse reply) throws Exception {\n        Context context = new HttpServletRequestContext(request);\n        LimitFactory limitFactory = new TableLimitFactory(context, \"tabledata\");\n        Limit limit = new TableLimit(limitFactory);\n\n        CurrentOutageParseResponse.findSelectedOutagesIDs(request,m_outageService);\n\n        Map<String, Object> myModel = new HashMap<String, Object>();\n\n        myModel.put(\"request\", limit.toString());\n\n        myModel.put(\"all_params\", request.getParameterNames().toString());\n        \n        Integer rowstart;\n        Integer rowend;\n        if (limit.getPage() == 1) {\n            // no offset set\n            rowstart = 0;\n            rowend = getDefaultRowsDisplayed();\n\n            context.setRequestAttribute(\"rowStart\", rowstart);\n            context.setRequestAttribute(\"rowEnd\", rowend);\n        } else {\n            //quirky situation... - as we started on 0 (zero)\n            rowstart = ((limit.getPage() * getDefaultRowsDisplayed() +1 ) - getDefaultRowsDisplayed());\n            rowend = getDefaultRowsDisplayed();\n        }\n        \n        myModel.put(\"rowStart\", rowstart);\n        myModel.put(\"rowEnd\", rowend);\n        myModel.put(\"begin\", rowstart);\n        myModel.put(\"end\", rowend);\n\n        String orderProperty;\n        String sortOrder;\n        \n        if (limit.getSort().getProperty() == null) {\n            orderProperty = null;\n            sortOrder = \"asc\";\n        } else {\n            orderProperty = limit.getSort().getProperty();\n            sortOrder = limit.getSort().getSortOrder();\n        }\n        \n        OutagesFilteringView filterView = new OutagesFilteringView();\n        filterView.setCategoryDao(m_categoryDao);\n        \n        OnmsCriteria criteria = filterView.buildCriteria(request);\n        OnmsCriteria countCriteria = filterView.buildCriteria(request);\n        \n        Integer totalRows = m_outageService.getOutageCount(countCriteria);\n        Collection<OnmsOutage> foundOutages = m_outageService.getOutagesByRange(rowstart, rowend, orderProperty, sortOrder, criteria);\n\n        // Pretty smart to build the collection after any suppressions..... \n        Collection theTable = m_cview.theTable(foundOutages);\n\n        myModel.put(\"tabledata\", theTable);\n        myModel.put(\"totalRows\", totalRows);\n\n        myModel.put(\"selected_outages\", CurrentOutageParseResponse.findSelectedOutagesIDs(request,m_outageService));\n        return new ModelAndView(getSuccessView(), myModel);\n    }","id":6582,"modified_method":"@Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse reply) throws Exception {\n        Context context = new HttpServletRequestContext(request);\n        LimitFactory limitFactory = new TableLimitFactory(context, \"tabledata\");\n        Limit limit = new TableLimit(limitFactory);\n\n        Map<String, Object> myModel = new HashMap<String, Object>();\n\n//        myModel.put(\"request\", limit.toString());\n\n//        myModel.put(\"all_params\", request.getParameterNames().toString());\n        \n        Integer rowstart;\n        Integer rowend;\n        if (limit.getPage() == 1) {\n            // no offset set\n            rowstart = 0;\n            rowend = getDefaultRowsDisplayed();\n//\n//            context.setRequestAttribute(\"rowStart\", rowstart);\n//            context.setRequestAttribute(\"rowEnd\", rowend);\n        } else {\n            //quirky situation... - as we started on 0 (zero)\n            rowstart = ((limit.getPage() * getDefaultRowsDisplayed() + 1) - getDefaultRowsDisplayed());\n            rowend = getDefaultRowsDisplayed();\n        }\n        \n//        myModel.put(\"rowStart\", rowstart);\n//        myModel.put(\"rowEnd\", rowend);\n//        myModel.put(\"begin\", rowstart);\n//        myModel.put(\"end\", rowend);\n\n        OnmsCriteria criteria = m_filterView.buildCriteria(request);\n        OnmsCriteria countCriteria = m_filterView.buildCriteria(request);\n        \n        String orderProperty;\n        String sortOrder;\n        \n        if (limit.getSort().getProperty() == null) {\n            orderProperty = \"outageid\";\n            sortOrder = \"desc\";\n        } else {\n            orderProperty = limit.getSort().getProperty();\n            sortOrder = limit.getSort().getSortOrder();\n        }\n        \n        Collection<OnmsOutage> foundOutages = m_outageService.getOutagesByRange(rowstart, rowend, orderProperty, sortOrder, criteria);\n\n        myModel.put(\"tabledata\", m_outageListBuilder.theTable(foundOutages));\n        myModel.put(\"totalRows\", m_outageService.getOutageCount(countCriteria)); // used by org.extremecomponents.table.callback.LimitCallback.retrieveRows\n\n        //myModel.put(\"selected_outages\", CurrentOutageParseResponse.findSelectedOutagesIDs(request,m_outageService));\n        \n        return new ModelAndView(getSuccessView(), myModel);\n    }","commit_id":"0b0dc60768cddede0bacce260d41c3b82d3a13c6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public OnmsCriteria buildCriteria(HttpServletRequest request) {\n        OnmsCriteria criteria = new OnmsCriteria(OnmsOutage.class);\n\n        if (request.getParameter(\"nodeid\") != null) {\n            criteria.add(Restrictions.eq(\"node.id\", request.getParameter(\"nodeid\")));\n        }\n\n        if (request.getParameter(\"not_nodeid\") != null) {\n            criteria.add(Restrictions.ne(\"node.id\", request.getParameter(\"not_nodeid\")));\n        }\n\n        if (request.getParameter(\"ipaddr\") != null) {\n            criteria.add(Restrictions.eq(\"ipInterface.ipAddress\", request.getParameter(\"ipaddr\")));\n        }\n\n        if (request.getParameter(\"not_ipaddr\") != null) {\n            criteria.add(Restrictions.ne(\"ipInterface.ipAddress\", request.getParameter(\"not_ipaddr\")));\n        }\n\n        if (request.getParameter(\"serviceid\") != null) {\n            criteria.add(Restrictions.eq(\"monitoredService.id\", request.getParameter(\"serviceid\")));\n        }\n\n        if (request.getParameter(\"not_serviceid\") != null) {\n            criteria.add(Restrictions.ne(\"monitoredService.id\", request.getParameter(\"not_serviceid\")));\n        }\n\n        if (request.getParameter(\"smaller_iflostservice\") != null) {\n            Date date = new Date(Long.parseLong(request.getParameter(\"smaller_iflostservice\")));\n            criteria.add(Restrictions.lt(\"ifLostService\", date));\n        }\n\n        if (request.getParameter(\"bigger_iflostservice\") != null) {\n            Date date = new Date(Long.parseLong(request.getParameter(\"bigger_iflostservice\")));\n            criteria.add(Restrictions.gt(\"ifLostService\", date));\n        }\n\n        if (request.getParameter(\"smaller_ifregainedservice\") != null) {\n            Date date = new Date(Long.parseLong(request.getParameter(\"smaller_ifregainedservice\")));\n            criteria.add(Restrictions.lt(\"ifRegainedService\", date));\n        }\n\n        if (request.getParameter(\"bigger_ifregainedservice\") != null) {\n            Date date = new Date(Long.parseLong(request.getParameter(\"bigger_ifregainedservice\")));\n            criteria.add(Restrictions.gt(\"ifRegainedService\", date));\n        }\n\n        if (request.getParameter(\"building\") != null) {\n            criteria.createAlias(\"node.assetRecord\", \"assetRecord\");\n            criteria.add(Restrictions.eq(\"assetRecord.building\", request.getParameter(\"building\")));\n        }\n        \n        if (request.getParameter(\"category1\") != null && request.getParameter(\"category2\") != null) {\n            for (Criterion criterion : m_categoryDao.getCriterionForCategorySetsUnion(request.getParameterValues(\"category1\"), request.getParameterValues(\"category2\"))) {\n                criteria.add(criterion);\n            }\n        } else if (request.getParameter(\"category1\") != null) {\n            for (Criterion criterion : m_categoryDao.getCriterionForCategorySetsUnion(request.getParameterValues(\"category1\"))) {\n                criteria.add(criterion);\n            }\n        }\n\n        if (\"true\".equals(request.getParameter(\"currentOutages\"))) {\n            criteria.add(Restrictions.isNull(\"ifRegainedService\"));\n        }\n\n        if (\"true\".equals(request.getParameter(\"resolvedOutages\"))) {\n            criteria.add(Restrictions.isNotNull(\"ifRegainedService\"));\n        }\n\n        return criteria;\n    }","id":6583,"modified_method":"public OnmsCriteria buildCriteria(HttpServletRequest request) {\n        OnmsCriteria criteria = new OnmsCriteria(OnmsOutage.class);\n\n        if (request.getParameter(\"nodeid\") != null && request.getParameter(\"nodeid\").length() > 0) {\n            criteria.add(Restrictions.eq(\"node.id\", Integer.parseInt(request.getParameter(\"nodeid\"))));\n        }\n\n        if (request.getParameter(\"not_nodeid\") != null && request.getParameter(\"not_nodeid\").length() > 0) {\n            criteria.add(Restrictions.ne(\"node.id\", Integer.parseInt(request.getParameter(\"not_nodeid\"))));\n        }\n\n        if (request.getParameter(\"ipinterfaceid\") != null  && request.getParameter(\"ipinterfaceid\").length() > 0) {\n            criteria.add(Restrictions.eq(\"ipInterface.id\", Integer.parseInt(request.getParameter(\"ipinterfaceid\"))));\n        }\n\n        if (request.getParameter(\"not_ipinterfaceid\") != null && request.getParameter(\"not_ipinterfaceid\").length() > 0) {\n            criteria.add(Restrictions.ne(\"ipInterface.id\", Integer.parseInt(request.getParameter(\"not_ipinterfaceid\"))));\n        }\n\n        if (request.getParameter(\"serviceid\") != null && request.getParameter(\"serviceid\").length() > 0) {\n            criteria.add(Restrictions.eq(\"monitoredService.serviceType.id\", Integer.parseInt(request.getParameter(\"serviceid\"))));\n        }\n\n        if (request.getParameter(\"not_serviceid\") != null && request.getParameter(\"not_serviceid\").length() > 0) {\n            criteria.add(Restrictions.ne(\"monitoredService.serviceType.id\", Integer.parseInt(request.getParameter(\"not_serviceid\"))));\n        }\n        \n        if (request.getParameter(\"ifserviceid\") != null && request.getParameter(\"ifserviceid\").length() > 0) {\n            criteria.add(Restrictions.eq(\"monitoredService.id\", Integer.parseInt(request.getParameter(\"ifserviceid\"))));\n        }\n\n        if (request.getParameter(\"not_ifserviceid\") != null && request.getParameter(\"not_ifserviceid\").length() > 0) {\n            criteria.add(Restrictions.ne(\"monitoredService.id\", Integer.parseInt(request.getParameter(\"not_ifserviceid\"))));\n        }\n\n        if (request.getParameter(\"smaller_iflostservice\") != null && request.getParameter(\"smaller_iflostservice\").length() > 0) {\n            Date date = new Date(Long.parseLong(request.getParameter(\"smaller_iflostservice\")));\n            criteria.add(Restrictions.lt(\"ifLostService\", date));\n        }\n\n        if (request.getParameter(\"bigger_iflostservice\") != null && request.getParameter(\"bigger_iflostservice\").length() > 0) {\n            Date date = new Date(Long.parseLong(request.getParameter(\"bigger_iflostservice\")));\n            criteria.add(Restrictions.gt(\"ifLostService\", date));\n        }\n\n        if (request.getParameter(\"smaller_ifregainedservice\") != null && request.getParameter(\"smaller_ifregainedservice\").length() > 0) {\n            Date date = new Date(Long.parseLong(request.getParameter(\"smaller_ifregainedservice\")));\n            criteria.add(Restrictions.lt(\"ifRegainedService\", date));\n        }\n\n        if (request.getParameter(\"bigger_ifregainedservice\") != null && request.getParameter(\"bigger_ifregainedservice\").length() > 0) {\n            Date date = new Date(Long.parseLong(request.getParameter(\"bigger_ifregainedservice\")));\n            criteria.add(Restrictions.gt(\"ifRegainedService\", date));\n        }\n\n        if (request.getParameter(\"building\") != null && request.getParameter(\"building\").length() > 0) {\n            criteria.createAlias(\"node.assetRecord\", \"assetRecord\");\n            criteria.add(Restrictions.eq(\"assetRecord.building\", request.getParameter(\"building\")));\n        }\n        \n        if (request.getParameter(\"category1\") != null && request.getParameter(\"category1\").length() > 0 && request.getParameter(\"category2\") != null && request.getParameter(\"category2\").length() > 0) {\n            for (Criterion criterion : m_categoryDao.getCriterionForCategorySetsUnion(request.getParameterValues(\"category1\"), request.getParameterValues(\"category2\"))) {\n                criteria.add(criterion);\n            }\n        } else if (request.getParameter(\"category1\") != null && request.getParameter(\"category1\").length() > 0) {\n            for (Criterion criterion : m_categoryDao.getCriterionForCategorySetsUnion(request.getParameterValues(\"category1\"))) {\n                criteria.add(criterion);\n            }\n        }\n\n        if (\"true\".equals(request.getParameter(\"currentOutages\"))) {\n            criteria.add(Restrictions.isNull(\"ifRegainedService\"));\n        }\n\n        if (\"true\".equals(request.getParameter(\"resolvedOutages\"))) {\n            criteria.add(Restrictions.isNotNull(\"ifRegainedService\"));\n        }\n\n        return criteria;\n    }","commit_id":"0b0dc60768cddede0bacce260d41c3b82d3a13c6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String filterQuery(HttpServletRequest request) {\n\n        String queryResult = \"\";\n        Locale locale = Locale.getDefault();\n        SimpleDateFormat d_format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\",\n                                                         locale);\n\n        if (request.getQueryString() != null ) {\n\n            StringTokenizer st = new StringTokenizer(request.getQueryString(), \"&\");\n\n\n            while (st.hasMoreTokens()) {\n                String temp = st.nextToken();\n                String parameterName = temp.substring(0, temp.indexOf('='));\n                String parameterValue = temp.substring(temp.indexOf('=') + 1, temp.length());\n\n                // node\n                if (parameterName.startsWith(\"nodeid\")) {\n\n                    queryResult = queryResult + \" AND outages.nodeid = '\"\n                    + parameterValue + \"'\";\n                }\n\n                if (parameterName.startsWith(\"not_nodeid\")) {\n                    queryResult = queryResult + \" AND outages.nodeid <> '\"\n                    + parameterValue + \"\\'\";\n                }\n\n                if (parameterName.startsWith(\"ipaddr\")) {\n                    queryResult = queryResult + \" AND outages.ipaddr ='\"\n                    + parameterValue + \"'\";\n                }\n\n                if (parameterName.startsWith(\"not_ipaddr\")) {\n                    queryResult = queryResult + \" AND outages.ipaddr <> '\"\n                    + parameterValue + \"'\";\n                }\n\n                if (parameterName.startsWith(\"serviceid\")) {\n                    queryResult = queryResult + \" AND outages.serviceid ='\"\n                    + parameterValue + \"'\";\n                }\n\n                if (parameterName.startsWith(\"not_serviceid\")) {\n                    queryResult = queryResult + \" AND outages.serviceid <> '\"\n                    + parameterValue + \"'\";\n                }\n\n                if (parameterName.startsWith(\"smaller_iflostservice\")) {\n                    Date date = new Date(Long.parseLong(parameterValue));\n                    queryResult = queryResult + \" AND outages.iflostservice < \"\n                    + \"'\" + d_format.format(date) + \"'\";\n\n                }\n\n                if (parameterName.startsWith(\"bigger_iflostservice\")) {\n                    Date date = new Date(Long.parseLong(parameterValue));\n                    queryResult = queryResult + \" AND outages.iflostservice > \"\n                    + \"'\" + d_format.format(date) + \"'\";\n\n                }\n\n                if (parameterName.startsWith(\"smaller_ifregainedservice\")) {\n                    Date date = new Date(Long.parseLong(parameterValue));\n                    queryResult = queryResult + \" AND outages.iflostservice < \"\n                    + \"'\" + d_format.format(date) + \"'\";\n                }\n\n                if (parameterName.startsWith(\"bigger_ifregainedservice\")) {\n                    Date date = new Date(Long.parseLong(parameterValue));\n                    queryResult = queryResult + \" AND outages.iflostservice > \"\n                    + \"'\" + d_format.format(date) + \"'\";\n                }\n\n            }\n        }\n\n        return queryResult;\n    }","id":6584,"modified_method":"public String filterQuery(HttpServletRequest request) {\n\n        String queryResult = \"\";\n        Locale locale = Locale.getDefault();\n        SimpleDateFormat d_format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\",\n                                                         locale);\n\n        if (request.getQueryString() != null ) {\n\n            StringTokenizer st = new StringTokenizer(request.getQueryString(), \"&\");\n\n\n            while (st.hasMoreTokens()) {\n                String temp = st.nextToken();\n                String parameterName = temp.substring(0, temp.indexOf('='));\n                String parameterValue = temp.substring(temp.indexOf('=') + 1, temp.length());\n\n                // node\n                if (parameterName.startsWith(\"nodeid\")) {\n\n                    queryResult = queryResult + \" AND outages.nodeid = '\"\n                    + parameterValue + \"'\";\n                }\n\n                if (parameterName.startsWith(\"not_nodeid\")) {\n                    queryResult = queryResult + \" AND outages.nodeid <> '\"\n                    + parameterValue + \"\\'\";\n                }\n\n                if (parameterName.startsWith(\"ipaddr\")) {\n                    queryResult = queryResult + \" AND outages.ipaddr ='\"\n                    + parameterValue + \"'\";\n                }\n\n                if (parameterName.startsWith(\"not_ipaddr\")) {\n                    queryResult = queryResult + \" AND outages.ipaddr <> '\"\n                    + parameterValue + \"'\";\n                }\n\n                if (parameterName.startsWith(\"smaller_iflostservice\")) {\n                    Date date = new Date(Long.parseLong(parameterValue));\n                    queryResult = queryResult + \" AND outages.iflostservice < \"\n                    + \"'\" + d_format.format(date) + \"'\";\n\n                }\n\n                if (parameterName.startsWith(\"bigger_iflostservice\")) {\n                    Date date = new Date(Long.parseLong(parameterValue));\n                    queryResult = queryResult + \" AND outages.iflostservice > \"\n                    + \"'\" + d_format.format(date) + \"'\";\n\n                }\n\n                if (parameterName.startsWith(\"smaller_ifregainedservice\")) {\n                    Date date = new Date(Long.parseLong(parameterValue));\n                    queryResult = queryResult + \" AND outages.iflostservice < \"\n                    + \"'\" + d_format.format(date) + \"'\";\n                }\n\n                if (parameterName.startsWith(\"bigger_ifregainedservice\")) {\n                    Date date = new Date(Long.parseLong(parameterValue));\n                    queryResult = queryResult + \" AND outages.iflostservice > \"\n                    + \"'\" + d_format.format(date) + \"'\";\n                }\n\n            }\n        }\n\n        return queryResult;\n    }","commit_id":"0b0dc60768cddede0bacce260d41c3b82d3a13c6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void modifyColumnAttributes(TableModel tableModel, Column column) {\n        if (column.getPropertyValue() == null) {\n            column.setStyle(\"background: red;\");\n        } else {\n            column.setStyle(\"\");\n        }\n    }","id":6585,"modified_method":"public void modifyColumnAttributes(TableModel tableModel, Column column) {\n        if (column.getPropertyValue() == null) {\n            column.setStyle(\"background: red;\");\n            column.setValue(\"Down\");\n        } else {\n            column.setStyle(\"\");\n        }\n    }","commit_id":"0b0dc60768cddede0bacce260d41c3b82d3a13c6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public List theTable(Collection<OnmsOutage> foundOutages) {\n\n\t\tList<Map<String, Object>> theTable = new LinkedList<Map<String, Object>>();\n\t\t\n\n\t\tfor (Iterator iter = foundOutages.iterator(); iter.hasNext();) {\n\t\t\tOnmsOutage outage = (OnmsOutage) iter.next();\n\t\t\tOnmsMonitoredService monitoredService = outage\n\t\t\t\t\t.getMonitoredService();\n\t\t\tOnmsServiceType serviceType = monitoredService.getServiceType();\n\t\t\tOnmsIpInterface ipInterface = monitoredService.getIpInterface();\n\t\t\t\n\t\t\t// ips.put(outage.getId(), ipInterface.getIpAddress());\n\t\t\t// nodes.put(outage.getId(), ipInterface.getNode().getLabel());\n\t\t\t// nodeids.put(outage.getId(), monitoredService.getNodeId());\n\t\t\t// services.put(outage.getId(), serviceType.getName());\n\t\t\t\n\t\t\t\n\n\t\t\tMap<String, Object> outagerow = new HashMap<String, Object>();\n\t\t\toutagerow.put(\"outageid\", outage.getId());\n\t\t\toutagerow.put(\"node\", ipInterface.getNode().getLabel());\n\t\t\toutagerow.put(\"nodeid\", monitoredService.getNodeId());\n\t\t\toutagerow.put(\"ipaddr\", ipInterface.getIpAddress());\n\t\t\toutagerow.put(\"interfaceid\", ipInterface.getId());\n            outagerow.put(\"ifserviceid\", monitoredService.getId());\n            outagerow.put(\"service\", serviceType.getName());\n\t\t\toutagerow.put(\"serviceid\", serviceType.getId());\n\t\t\toutagerow.put(\"eventid\", outage.getServiceLostEvent().getId());\n\n\t\t\t\n\t\t\t\n\t\t\t// if (outage.getIfLostService() != null) {\n\t\t\t// outagerow.put(\"down\",\n\t\t\t// formatter.format(outage.getIfLostService()));\n\t\t\t// }\n\n\t\t\tif (outage.getIfLostService() != null) {\n\t\t\t\toutagerow.put(\"iflostservice\", outage.getIfLostService());\n\t\t\t\toutagerow.put(\"iflostservicelong\", outage.getIfLostService().getTime());\n\t\t\t}\n\n\t\t\tif (outage.getIfRegainedService() != null) {\n\t\t\t\toutagerow.put(\"ifregainedservice\", outage.getIfRegainedService());\n\t\t\t\toutagerow.put(\"ifregainedservicelong\", outage.getIfRegainedService().getTime());\n\t\t\t}\n\n\t\t\tif (outage.getSuppressTime() != null) {\n\t\t\t\toutagerow.put(\"suppresstime\", outage.getSuppressTime());\n\t\t\t}\n\n\t\t\toutagerow.put(\"suppressedby\", outage.getSuppressedBy());\n\t\t\t\n\t\t\t// Build a droplist for this outage\n\t\t\t\n\t\t\ttheTable.add(outagerow);\n\t\t}\n\t\t\n\t\treturn theTable;\n\n\t}","id":6586,"modified_method":"public List<Map<String, Object>> theTable(Collection<OnmsOutage> foundOutages) {\n        List<Map<String, Object>> theTable = new ArrayList<Map<String, Object>>();\n\n        for (OnmsOutage outage : foundOutages) {\n            OnmsMonitoredService monitoredService = outage.getMonitoredService();\n            OnmsServiceType serviceType = monitoredService.getServiceType();\n            OnmsIpInterface ipInterface = monitoredService.getIpInterface();\n\n            // ips.put(outage.getId(), ipInterface.getIpAddress());\n            // nodes.put(outage.getId(), ipInterface.getNode().getLabel());\n            // nodeids.put(outage.getId(), monitoredService.getNodeId());\n            // services.put(outage.getId(), serviceType.getName());\n\n            Map<String, Object> outagerow = new HashMap<String, Object>();\n            outagerow.put(\"outage\", outage);\n            outagerow.put(\"outageid\", outage.getId());\n            outagerow.put(\"node\", ipInterface.getNode().getLabel());\n            outagerow.put(\"nodeid\", monitoredService.getNodeId());\n            outagerow.put(\"ipaddr\", ipInterface.getIpAddress());\n            outagerow.put(\"interfaceid\", ipInterface.getId());\n            outagerow.put(\"ifserviceid\", monitoredService.getId());\n            outagerow.put(\"service\", serviceType.getName());\n            outagerow.put(\"serviceid\", serviceType.getId());\n            outagerow.put(\"eventid\", outage.getServiceLostEvent().getId());\n\n            // if (outage.getIfLostService() != null) {\n            // outagerow.put(\"down\",\n            // formatter.format(outage.getIfLostService()));\n            // }\n\n            if (outage.getIfLostService() != null) {\n                outagerow.put(\"iflostservice\", outage.getIfLostService());\n                outagerow.put(\"iflostservicelong\", outage.getIfLostService().getTime());\n            }\n\n            if (outage.getIfRegainedService() != null) {\n                outagerow.put(\"ifregainedservice\", outage.getIfRegainedService());\n                outagerow.put(\"ifregainedservicelong\", outage.getIfRegainedService().getTime());\n            }\n\n            if (outage.getSuppressTime() != null) {\n                outagerow.put(\"suppresstime\", outage.getSuppressTime());\n            }\n\n            outagerow.put(\"suppressedby\", outage.getSuppressedBy());\n\n            // Build a droplist for this outage\n\n            theTable.add(outagerow);\n        }\n\n        return theTable;\n\n    }","commit_id":"a87a543202406adba4caf11eeb5d996faf6fc2e3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse reply) throws Exception {\n        Context context = new HttpServletRequestContext(request);\n        LimitFactory limitFactory = new TableLimitFactory(context, \"tabledata\");\n        Limit limit = new TableLimit(limitFactory);\n\n        CurrentOutageParseResponse.findSelectedOutagesIDs(request,m_outageService);\n\n        Map<String, Object> myModel = new HashMap<String, Object>();\n\n        myModel.put(\"request\", limit.toString());\n\n        myModel.put(\"all_params\", request.getParameterNames().toString());\n        \n        Integer rowstart;\n        Integer rowend;\n        if (limit.getPage() == 1) {\n            // no offset set\n            rowstart = 0;\n            rowend = getDefaultRowsDisplayed();\n\n            context.setRequestAttribute(\"rowStart\", rowstart);\n            context.setRequestAttribute(\"rowEnd\", rowend);\n        } else {\n            //quirky situation... - as we started on 0 (zero)\n            rowstart = ((limit.getPage() * getDefaultRowsDisplayed() +1 ) - getDefaultRowsDisplayed());\n            rowend = getDefaultRowsDisplayed();\n        }\n        \n        myModel.put(\"rowStart\", rowstart);\n        myModel.put(\"rowEnd\", rowend);\n        myModel.put(\"begin\", rowstart);\n        myModel.put(\"end\", rowend);\n\n        String orderProperty;\n        String sortOrder;\n        \n        if (limit.getSort().getProperty() == null) {\n            orderProperty = null;\n            sortOrder = \"asc\";\n        } else {\n            orderProperty = limit.getSort().getProperty();\n            sortOrder = limit.getSort().getSortOrder();\n        }\n        \n        OutagesFilteringView filterView = new OutagesFilteringView();\n        filterView.setCategoryDao(m_categoryDao);\n        \n        OnmsCriteria criteria = filterView.buildCriteria(request);\n        OnmsCriteria countCriteria = filterView.buildCriteria(request);\n        \n        Integer totalRows = m_outageService.getOutageCount(countCriteria);\n        Collection<OnmsOutage> foundOutages = m_outageService.getOutagesByRange(rowstart, rowend, orderProperty, sortOrder, criteria);\n\n        // Pretty smart to build the collection after any suppressions..... \n        Collection theTable = m_cview.theTable(foundOutages);\n\n        myModel.put(\"tabledata\", theTable);\n        myModel.put(\"totalRows\", totalRows);\n\n        myModel.put(\"selected_outages\", CurrentOutageParseResponse.findSelectedOutagesIDs(request,m_outageService));\n        return new ModelAndView(getSuccessView(), myModel);\n    }","id":6587,"modified_method":"@Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse reply) throws Exception {\n        Context context = new HttpServletRequestContext(request);\n        LimitFactory limitFactory = new TableLimitFactory(context, \"tabledata\");\n        Limit limit = new TableLimit(limitFactory);\n\n        Map<String, Object> myModel = new HashMap<String, Object>();\n\n//        myModel.put(\"request\", limit.toString());\n\n//        myModel.put(\"all_params\", request.getParameterNames().toString());\n        \n        Integer rowstart;\n        Integer rowend;\n        if (limit.getPage() == 1) {\n            // no offset set\n            rowstart = 0;\n            rowend = getDefaultRowsDisplayed();\n//\n//            context.setRequestAttribute(\"rowStart\", rowstart);\n//            context.setRequestAttribute(\"rowEnd\", rowend);\n        } else {\n            //quirky situation... - as we started on 0 (zero)\n            rowstart = ((limit.getPage() * getDefaultRowsDisplayed() + 1) - getDefaultRowsDisplayed());\n            rowend = getDefaultRowsDisplayed();\n        }\n        \n//        myModel.put(\"rowStart\", rowstart);\n//        myModel.put(\"rowEnd\", rowend);\n//        myModel.put(\"begin\", rowstart);\n//        myModel.put(\"end\", rowend);\n\n        OnmsCriteria criteria = m_filterView.buildCriteria(request);\n        OnmsCriteria countCriteria = m_filterView.buildCriteria(request);\n        \n        String orderProperty;\n        String sortOrder;\n        \n        if (limit.getSort().getProperty() == null) {\n            orderProperty = \"outageid\";\n            sortOrder = \"desc\";\n        } else {\n            orderProperty = limit.getSort().getProperty();\n            sortOrder = limit.getSort().getSortOrder();\n        }\n        \n        Collection<OnmsOutage> foundOutages = m_outageService.getOutagesByRange(rowstart, rowend, orderProperty, sortOrder, criteria);\n\n        myModel.put(\"tabledata\", m_outageListBuilder.theTable(foundOutages));\n        myModel.put(\"totalRows\", m_outageService.getOutageCount(countCriteria)); // used by org.extremecomponents.table.callback.LimitCallback.retrieveRows\n\n        //myModel.put(\"selected_outages\", CurrentOutageParseResponse.findSelectedOutagesIDs(request,m_outageService));\n        \n        return new ModelAndView(getSuccessView(), myModel);\n    }","commit_id":"a87a543202406adba4caf11eeb5d996faf6fc2e3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void afterPropertiesSet() throws Exception {\n        Assert.notNull(m_categoryDao, \"categoryDao property must be set\");\n    }","id":6588,"modified_method":"public void afterPropertiesSet() throws Exception {\n        Assert.notNull(m_filterView, \"filterView property must be set\");\n        Assert.notNull(m_outageListBuilder, \"outageListBuilder property must be set\");\n    }","commit_id":"a87a543202406adba4caf11eeb5d996faf6fc2e3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public OnmsCriteria buildCriteria(HttpServletRequest request) {\n        OnmsCriteria criteria = new OnmsCriteria(OnmsOutage.class);\n\n        if (request.getParameter(\"nodeid\") != null) {\n            criteria.add(Restrictions.eq(\"node.id\", request.getParameter(\"nodeid\")));\n        }\n\n        if (request.getParameter(\"not_nodeid\") != null) {\n            criteria.add(Restrictions.ne(\"node.id\", request.getParameter(\"not_nodeid\")));\n        }\n\n        if (request.getParameter(\"ipaddr\") != null) {\n            criteria.add(Restrictions.eq(\"ipInterface.ipAddress\", request.getParameter(\"ipaddr\")));\n        }\n\n        if (request.getParameter(\"not_ipaddr\") != null) {\n            criteria.add(Restrictions.ne(\"ipInterface.ipAddress\", request.getParameter(\"not_ipaddr\")));\n        }\n\n        if (request.getParameter(\"serviceid\") != null) {\n            criteria.add(Restrictions.eq(\"monitoredService.id\", request.getParameter(\"serviceid\")));\n        }\n\n        if (request.getParameter(\"not_serviceid\") != null) {\n            criteria.add(Restrictions.ne(\"monitoredService.id\", request.getParameter(\"not_serviceid\")));\n        }\n\n        if (request.getParameter(\"smaller_iflostservice\") != null) {\n            Date date = new Date(Long.parseLong(request.getParameter(\"smaller_iflostservice\")));\n            criteria.add(Restrictions.lt(\"ifLostService\", date));\n        }\n\n        if (request.getParameter(\"bigger_iflostservice\") != null) {\n            Date date = new Date(Long.parseLong(request.getParameter(\"bigger_iflostservice\")));\n            criteria.add(Restrictions.gt(\"ifLostService\", date));\n        }\n\n        if (request.getParameter(\"smaller_ifregainedservice\") != null) {\n            Date date = new Date(Long.parseLong(request.getParameter(\"smaller_ifregainedservice\")));\n            criteria.add(Restrictions.lt(\"ifRegainedService\", date));\n        }\n\n        if (request.getParameter(\"bigger_ifregainedservice\") != null) {\n            Date date = new Date(Long.parseLong(request.getParameter(\"bigger_ifregainedservice\")));\n            criteria.add(Restrictions.gt(\"ifRegainedService\", date));\n        }\n\n        if (request.getParameter(\"building\") != null) {\n            criteria.createAlias(\"node.assetRecord\", \"assetRecord\");\n            criteria.add(Restrictions.eq(\"assetRecord.building\", request.getParameter(\"building\")));\n        }\n        \n        if (request.getParameter(\"category1\") != null && request.getParameter(\"category2\") != null) {\n            for (Criterion criterion : m_categoryDao.getCriterionForCategorySetsUnion(request.getParameterValues(\"category1\"), request.getParameterValues(\"category2\"))) {\n                criteria.add(criterion);\n            }\n        } else if (request.getParameter(\"category1\") != null) {\n            for (Criterion criterion : m_categoryDao.getCriterionForCategorySetsUnion(request.getParameterValues(\"category1\"))) {\n                criteria.add(criterion);\n            }\n        }\n\n        if (\"true\".equals(request.getParameter(\"currentOutages\"))) {\n            criteria.add(Restrictions.isNull(\"ifRegainedService\"));\n        }\n\n        if (\"true\".equals(request.getParameter(\"resolvedOutages\"))) {\n            criteria.add(Restrictions.isNotNull(\"ifRegainedService\"));\n        }\n\n        return criteria;\n    }","id":6589,"modified_method":"public OnmsCriteria buildCriteria(HttpServletRequest request) {\n        OnmsCriteria criteria = new OnmsCriteria(OnmsOutage.class);\n\n        if (request.getParameter(\"nodeid\") != null && request.getParameter(\"nodeid\").length() > 0) {\n            criteria.add(Restrictions.eq(\"node.id\", Integer.parseInt(request.getParameter(\"nodeid\"))));\n        }\n\n        if (request.getParameter(\"not_nodeid\") != null && request.getParameter(\"not_nodeid\").length() > 0) {\n            criteria.add(Restrictions.ne(\"node.id\", Integer.parseInt(request.getParameter(\"not_nodeid\"))));\n        }\n\n        if (request.getParameter(\"ipinterfaceid\") != null  && request.getParameter(\"ipinterfaceid\").length() > 0) {\n            criteria.add(Restrictions.eq(\"ipInterface.id\", Integer.parseInt(request.getParameter(\"ipinterfaceid\"))));\n        }\n\n        if (request.getParameter(\"not_ipinterfaceid\") != null && request.getParameter(\"not_ipinterfaceid\").length() > 0) {\n            criteria.add(Restrictions.ne(\"ipInterface.id\", Integer.parseInt(request.getParameter(\"not_ipinterfaceid\"))));\n        }\n\n        if (request.getParameter(\"serviceid\") != null && request.getParameter(\"serviceid\").length() > 0) {\n            criteria.add(Restrictions.eq(\"monitoredService.serviceType.id\", Integer.parseInt(request.getParameter(\"serviceid\"))));\n        }\n\n        if (request.getParameter(\"not_serviceid\") != null && request.getParameter(\"not_serviceid\").length() > 0) {\n            criteria.add(Restrictions.ne(\"monitoredService.serviceType.id\", Integer.parseInt(request.getParameter(\"not_serviceid\"))));\n        }\n        \n        if (request.getParameter(\"ifserviceid\") != null && request.getParameter(\"ifserviceid\").length() > 0) {\n            criteria.add(Restrictions.eq(\"monitoredService.id\", Integer.parseInt(request.getParameter(\"ifserviceid\"))));\n        }\n\n        if (request.getParameter(\"not_ifserviceid\") != null && request.getParameter(\"not_ifserviceid\").length() > 0) {\n            criteria.add(Restrictions.ne(\"monitoredService.id\", Integer.parseInt(request.getParameter(\"not_ifserviceid\"))));\n        }\n\n        if (request.getParameter(\"smaller_iflostservice\") != null && request.getParameter(\"smaller_iflostservice\").length() > 0) {\n            Date date = new Date(Long.parseLong(request.getParameter(\"smaller_iflostservice\")));\n            criteria.add(Restrictions.lt(\"ifLostService\", date));\n        }\n\n        if (request.getParameter(\"bigger_iflostservice\") != null && request.getParameter(\"bigger_iflostservice\").length() > 0) {\n            Date date = new Date(Long.parseLong(request.getParameter(\"bigger_iflostservice\")));\n            criteria.add(Restrictions.gt(\"ifLostService\", date));\n        }\n\n        if (request.getParameter(\"smaller_ifregainedservice\") != null && request.getParameter(\"smaller_ifregainedservice\").length() > 0) {\n            Date date = new Date(Long.parseLong(request.getParameter(\"smaller_ifregainedservice\")));\n            criteria.add(Restrictions.lt(\"ifRegainedService\", date));\n        }\n\n        if (request.getParameter(\"bigger_ifregainedservice\") != null && request.getParameter(\"bigger_ifregainedservice\").length() > 0) {\n            Date date = new Date(Long.parseLong(request.getParameter(\"bigger_ifregainedservice\")));\n            criteria.add(Restrictions.gt(\"ifRegainedService\", date));\n        }\n\n        if (request.getParameter(\"building\") != null && request.getParameter(\"building\").length() > 0) {\n            criteria.createAlias(\"node.assetRecord\", \"assetRecord\");\n            criteria.add(Restrictions.eq(\"assetRecord.building\", request.getParameter(\"building\")));\n        }\n        \n        if (request.getParameter(\"category1\") != null && request.getParameter(\"category1\").length() > 0 && request.getParameter(\"category2\") != null && request.getParameter(\"category2\").length() > 0) {\n            for (Criterion criterion : m_categoryDao.getCriterionForCategorySetsUnion(request.getParameterValues(\"category1\"), request.getParameterValues(\"category2\"))) {\n                criteria.add(criterion);\n            }\n        } else if (request.getParameter(\"category1\") != null && request.getParameter(\"category1\").length() > 0) {\n            for (Criterion criterion : m_categoryDao.getCriterionForCategorySetsUnion(request.getParameterValues(\"category1\"))) {\n                criteria.add(criterion);\n            }\n        }\n\n        if (\"true\".equals(request.getParameter(\"currentOutages\"))) {\n            criteria.add(Restrictions.isNull(\"ifRegainedService\"));\n        }\n\n        if (\"true\".equals(request.getParameter(\"resolvedOutages\"))) {\n            criteria.add(Restrictions.isNotNull(\"ifRegainedService\"));\n        }\n\n        return criteria;\n    }","commit_id":"a87a543202406adba4caf11eeb5d996faf6fc2e3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String filterQuery(HttpServletRequest request) {\n\n        String queryResult = \"\";\n        Locale locale = Locale.getDefault();\n        SimpleDateFormat d_format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\",\n                                                         locale);\n\n        if (request.getQueryString() != null ) {\n\n            StringTokenizer st = new StringTokenizer(request.getQueryString(), \"&\");\n\n\n            while (st.hasMoreTokens()) {\n                String temp = st.nextToken();\n                String parameterName = temp.substring(0, temp.indexOf('='));\n                String parameterValue = temp.substring(temp.indexOf('=') + 1, temp.length());\n\n                // node\n                if (parameterName.startsWith(\"nodeid\")) {\n\n                    queryResult = queryResult + \" AND outages.nodeid = '\"\n                    + parameterValue + \"'\";\n                }\n\n                if (parameterName.startsWith(\"not_nodeid\")) {\n                    queryResult = queryResult + \" AND outages.nodeid <> '\"\n                    + parameterValue + \"\\'\";\n                }\n\n                if (parameterName.startsWith(\"ipaddr\")) {\n                    queryResult = queryResult + \" AND outages.ipaddr ='\"\n                    + parameterValue + \"'\";\n                }\n\n                if (parameterName.startsWith(\"not_ipaddr\")) {\n                    queryResult = queryResult + \" AND outages.ipaddr <> '\"\n                    + parameterValue + \"'\";\n                }\n\n                if (parameterName.startsWith(\"serviceid\")) {\n                    queryResult = queryResult + \" AND outages.serviceid ='\"\n                    + parameterValue + \"'\";\n                }\n\n                if (parameterName.startsWith(\"not_serviceid\")) {\n                    queryResult = queryResult + \" AND outages.serviceid <> '\"\n                    + parameterValue + \"'\";\n                }\n\n                if (parameterName.startsWith(\"smaller_iflostservice\")) {\n                    Date date = new Date(Long.parseLong(parameterValue));\n                    queryResult = queryResult + \" AND outages.iflostservice < \"\n                    + \"'\" + d_format.format(date) + \"'\";\n\n                }\n\n                if (parameterName.startsWith(\"bigger_iflostservice\")) {\n                    Date date = new Date(Long.parseLong(parameterValue));\n                    queryResult = queryResult + \" AND outages.iflostservice > \"\n                    + \"'\" + d_format.format(date) + \"'\";\n\n                }\n\n                if (parameterName.startsWith(\"smaller_ifregainedservice\")) {\n                    Date date = new Date(Long.parseLong(parameterValue));\n                    queryResult = queryResult + \" AND outages.iflostservice < \"\n                    + \"'\" + d_format.format(date) + \"'\";\n                }\n\n                if (parameterName.startsWith(\"bigger_ifregainedservice\")) {\n                    Date date = new Date(Long.parseLong(parameterValue));\n                    queryResult = queryResult + \" AND outages.iflostservice > \"\n                    + \"'\" + d_format.format(date) + \"'\";\n                }\n\n            }\n        }\n\n        return queryResult;\n    }","id":6590,"modified_method":"public String filterQuery(HttpServletRequest request) {\n\n        String queryResult = \"\";\n        Locale locale = Locale.getDefault();\n        SimpleDateFormat d_format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\",\n                                                         locale);\n\n        if (request.getQueryString() != null ) {\n\n            StringTokenizer st = new StringTokenizer(request.getQueryString(), \"&\");\n\n\n            while (st.hasMoreTokens()) {\n                String temp = st.nextToken();\n                String parameterName = temp.substring(0, temp.indexOf('='));\n                String parameterValue = temp.substring(temp.indexOf('=') + 1, temp.length());\n\n                // node\n                if (parameterName.startsWith(\"nodeid\")) {\n\n                    queryResult = queryResult + \" AND outages.nodeid = '\"\n                    + parameterValue + \"'\";\n                }\n\n                if (parameterName.startsWith(\"not_nodeid\")) {\n                    queryResult = queryResult + \" AND outages.nodeid <> '\"\n                    + parameterValue + \"\\'\";\n                }\n\n                if (parameterName.startsWith(\"ipaddr\")) {\n                    queryResult = queryResult + \" AND outages.ipaddr ='\"\n                    + parameterValue + \"'\";\n                }\n\n                if (parameterName.startsWith(\"not_ipaddr\")) {\n                    queryResult = queryResult + \" AND outages.ipaddr <> '\"\n                    + parameterValue + \"'\";\n                }\n\n                if (parameterName.startsWith(\"smaller_iflostservice\")) {\n                    Date date = new Date(Long.parseLong(parameterValue));\n                    queryResult = queryResult + \" AND outages.iflostservice < \"\n                    + \"'\" + d_format.format(date) + \"'\";\n\n                }\n\n                if (parameterName.startsWith(\"bigger_iflostservice\")) {\n                    Date date = new Date(Long.parseLong(parameterValue));\n                    queryResult = queryResult + \" AND outages.iflostservice > \"\n                    + \"'\" + d_format.format(date) + \"'\";\n\n                }\n\n                if (parameterName.startsWith(\"smaller_ifregainedservice\")) {\n                    Date date = new Date(Long.parseLong(parameterValue));\n                    queryResult = queryResult + \" AND outages.iflostservice < \"\n                    + \"'\" + d_format.format(date) + \"'\";\n                }\n\n                if (parameterName.startsWith(\"bigger_ifregainedservice\")) {\n                    Date date = new Date(Long.parseLong(parameterValue));\n                    queryResult = queryResult + \" AND outages.iflostservice > \"\n                    + \"'\" + d_format.format(date) + \"'\";\n                }\n\n            }\n        }\n\n        return queryResult;\n    }","commit_id":"a87a543202406adba4caf11eeb5d996faf6fc2e3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void modifyColumnAttributes(TableModel tableModel, Column column) {\n        if (column.getPropertyValue() == null) {\n            column.setStyle(\"background: red;\");\n        } else {\n            column.setStyle(\"\");\n        }\n    }","id":6591,"modified_method":"public void modifyColumnAttributes(TableModel tableModel, Column column) {\n        if (column.getPropertyValue() == null) {\n            column.setStyle(\"background: red;\");\n            column.setValue(\"Down\");\n        } else {\n            column.setStyle(\"\");\n        }\n    }","commit_id":"a87a543202406adba4caf11eeb5d996faf6fc2e3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public List theTable(Collection<OnmsOutage> foundOutages) {\n\n\t\tList<Map<String, Object>> theTable = new LinkedList<Map<String, Object>>();\n\t\t\n\n\t\tfor (Iterator iter = foundOutages.iterator(); iter.hasNext();) {\n\t\t\tOnmsOutage outage = (OnmsOutage) iter.next();\n\t\t\tOnmsMonitoredService monitoredService = outage\n\t\t\t\t\t.getMonitoredService();\n\t\t\tOnmsServiceType serviceType = monitoredService.getServiceType();\n\t\t\tOnmsIpInterface ipInterface = monitoredService.getIpInterface();\n\t\t\t\n\t\t\t// ips.put(outage.getId(), ipInterface.getIpAddress());\n\t\t\t// nodes.put(outage.getId(), ipInterface.getNode().getLabel());\n\t\t\t// nodeids.put(outage.getId(), monitoredService.getNodeId());\n\t\t\t// services.put(outage.getId(), serviceType.getName());\n\t\t\t\n\t\t\t\n\n\t\t\tMap<String, Object> outagerow = new HashMap<String, Object>();\n\t\t\toutagerow.put(\"outageid\", outage.getId());\n\t\t\toutagerow.put(\"node\", ipInterface.getNode().getLabel());\n\t\t\toutagerow.put(\"nodeid\", monitoredService.getNodeId());\n\t\t\toutagerow.put(\"ipaddr\", ipInterface.getIpAddress());\n\t\t\toutagerow.put(\"interfaceid\", ipInterface.getId());\n            outagerow.put(\"ifserviceid\", monitoredService.getId());\n            outagerow.put(\"service\", serviceType.getName());\n\t\t\toutagerow.put(\"serviceid\", serviceType.getId());\n\t\t\toutagerow.put(\"eventid\", outage.getServiceLostEvent().getId());\n\n\t\t\t\n\t\t\t\n\t\t\t// if (outage.getIfLostService() != null) {\n\t\t\t// outagerow.put(\"down\",\n\t\t\t// formatter.format(outage.getIfLostService()));\n\t\t\t// }\n\n\t\t\tif (outage.getIfLostService() != null) {\n\t\t\t\toutagerow.put(\"iflostservice\", outage.getIfLostService());\n\t\t\t\toutagerow.put(\"iflostservicelong\", outage.getIfLostService().getTime());\n\t\t\t}\n\n\t\t\tif (outage.getIfRegainedService() != null) {\n\t\t\t\toutagerow.put(\"ifregainedservice\", outage.getIfRegainedService());\n\t\t\t\toutagerow.put(\"ifregainedservicelong\", outage.getIfRegainedService().getTime());\n\t\t\t}\n\n\t\t\tif (outage.getSuppressTime() != null) {\n\t\t\t\toutagerow.put(\"suppresstime\", outage.getSuppressTime());\n\t\t\t}\n\n\t\t\toutagerow.put(\"suppressedby\", outage.getSuppressedBy());\n\t\t\t\n\t\t\t// Build a droplist for this outage\n\t\t\t\n\t\t\ttheTable.add(outagerow);\n\t\t}\n\t\t\n\t\treturn theTable;\n\n\t}","id":6592,"modified_method":"public List<Map<String, Object>> theTable(Collection<OnmsOutage> foundOutages) {\n        List<Map<String, Object>> theTable = new ArrayList<Map<String, Object>>();\n\n        for (OnmsOutage outage : foundOutages) {\n            OnmsMonitoredService monitoredService = outage.getMonitoredService();\n            OnmsServiceType serviceType = monitoredService.getServiceType();\n            OnmsIpInterface ipInterface = monitoredService.getIpInterface();\n\n            // ips.put(outage.getId(), ipInterface.getIpAddress());\n            // nodes.put(outage.getId(), ipInterface.getNode().getLabel());\n            // nodeids.put(outage.getId(), monitoredService.getNodeId());\n            // services.put(outage.getId(), serviceType.getName());\n\n            Map<String, Object> outagerow = new HashMap<String, Object>();\n            outagerow.put(\"outage\", outage);\n            outagerow.put(\"outageid\", outage.getId());\n            outagerow.put(\"node\", ipInterface.getNode().getLabel());\n            outagerow.put(\"nodeid\", monitoredService.getNodeId());\n            outagerow.put(\"ipaddr\", ipInterface.getIpAddress());\n            outagerow.put(\"interfaceid\", ipInterface.getId());\n            outagerow.put(\"ifserviceid\", monitoredService.getId());\n            outagerow.put(\"service\", serviceType.getName());\n            outagerow.put(\"serviceid\", serviceType.getId());\n            outagerow.put(\"eventid\", outage.getServiceLostEvent().getId());\n\n            // if (outage.getIfLostService() != null) {\n            // outagerow.put(\"down\",\n            // formatter.format(outage.getIfLostService()));\n            // }\n\n            if (outage.getIfLostService() != null) {\n                outagerow.put(\"iflostservice\", outage.getIfLostService());\n                outagerow.put(\"iflostservicelong\", outage.getIfLostService().getTime());\n            }\n\n            if (outage.getIfRegainedService() != null) {\n                outagerow.put(\"ifregainedservice\", outage.getIfRegainedService());\n                outagerow.put(\"ifregainedservicelong\", outage.getIfRegainedService().getTime());\n            }\n\n            if (outage.getSuppressTime() != null) {\n                outagerow.put(\"suppresstime\", outage.getSuppressTime());\n            }\n\n            outagerow.put(\"suppressedby\", outage.getSuppressedBy());\n\n            // Build a droplist for this outage\n\n            theTable.add(outagerow);\n        }\n\n        return theTable;\n\n    }","commit_id":"d370370ca456facba7028cd86f4cc0f09666211a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse reply) throws Exception {\n        Context context = new HttpServletRequestContext(request);\n        LimitFactory limitFactory = new TableLimitFactory(context, \"tabledata\");\n        Limit limit = new TableLimit(limitFactory);\n\n        CurrentOutageParseResponse.findSelectedOutagesIDs(request,m_outageService);\n\n        Map<String, Object> myModel = new HashMap<String, Object>();\n\n        myModel.put(\"request\", limit.toString());\n\n        myModel.put(\"all_params\", request.getParameterNames().toString());\n        \n        Integer rowstart;\n        Integer rowend;\n        if (limit.getPage() == 1) {\n            // no offset set\n            rowstart = 0;\n            rowend = getDefaultRowsDisplayed();\n\n            context.setRequestAttribute(\"rowStart\", rowstart);\n            context.setRequestAttribute(\"rowEnd\", rowend);\n        } else {\n            //quirky situation... - as we started on 0 (zero)\n            rowstart = ((limit.getPage() * getDefaultRowsDisplayed() +1 ) - getDefaultRowsDisplayed());\n            rowend = getDefaultRowsDisplayed();\n        }\n        \n        myModel.put(\"rowStart\", rowstart);\n        myModel.put(\"rowEnd\", rowend);\n        myModel.put(\"begin\", rowstart);\n        myModel.put(\"end\", rowend);\n\n        String orderProperty;\n        String sortOrder;\n        \n        if (limit.getSort().getProperty() == null) {\n            orderProperty = null;\n            sortOrder = \"asc\";\n        } else {\n            orderProperty = limit.getSort().getProperty();\n            sortOrder = limit.getSort().getSortOrder();\n        }\n        \n        OutagesFilteringView filterView = new OutagesFilteringView();\n        filterView.setCategoryDao(m_categoryDao);\n        \n        OnmsCriteria criteria = filterView.buildCriteria(request);\n        OnmsCriteria countCriteria = filterView.buildCriteria(request);\n        \n        Integer totalRows = m_outageService.getOutageCount(countCriteria);\n        Collection<OnmsOutage> foundOutages = m_outageService.getOutagesByRange(rowstart, rowend, orderProperty, sortOrder, criteria);\n\n        // Pretty smart to build the collection after any suppressions..... \n        Collection theTable = m_cview.theTable(foundOutages);\n\n        myModel.put(\"tabledata\", theTable);\n        myModel.put(\"totalRows\", totalRows);\n\n        myModel.put(\"selected_outages\", CurrentOutageParseResponse.findSelectedOutagesIDs(request,m_outageService));\n        return new ModelAndView(getSuccessView(), myModel);\n    }","id":6593,"modified_method":"@Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse reply) throws Exception {\n        Context context = new HttpServletRequestContext(request);\n        LimitFactory limitFactory = new TableLimitFactory(context, \"tabledata\");\n        Limit limit = new TableLimit(limitFactory);\n\n        Map<String, Object> myModel = new HashMap<String, Object>();\n\n//        myModel.put(\"request\", limit.toString());\n\n//        myModel.put(\"all_params\", request.getParameterNames().toString());\n        \n        Integer rowstart;\n        Integer rowend;\n        if (limit.getPage() == 1) {\n            // no offset set\n            rowstart = 0;\n            rowend = getDefaultRowsDisplayed();\n//\n//            context.setRequestAttribute(\"rowStart\", rowstart);\n//            context.setRequestAttribute(\"rowEnd\", rowend);\n        } else {\n            //quirky situation... - as we started on 0 (zero)\n            rowstart = ((limit.getPage() * getDefaultRowsDisplayed() + 1) - getDefaultRowsDisplayed());\n            rowend = getDefaultRowsDisplayed();\n        }\n        \n//        myModel.put(\"rowStart\", rowstart);\n//        myModel.put(\"rowEnd\", rowend);\n//        myModel.put(\"begin\", rowstart);\n//        myModel.put(\"end\", rowend);\n\n        OnmsCriteria criteria = m_filterView.buildCriteria(request);\n        OnmsCriteria countCriteria = m_filterView.buildCriteria(request);\n        \n        String orderProperty;\n        String sortOrder;\n        \n        if (limit.getSort().getProperty() == null) {\n            orderProperty = \"outageid\";\n            sortOrder = \"desc\";\n        } else {\n            orderProperty = limit.getSort().getProperty();\n            sortOrder = limit.getSort().getSortOrder();\n        }\n        \n        Collection<OnmsOutage> foundOutages = m_outageService.getOutagesByRange(rowstart, rowend, orderProperty, sortOrder, criteria);\n\n        myModel.put(\"tabledata\", m_outageListBuilder.theTable(foundOutages));\n        myModel.put(\"totalRows\", m_outageService.getOutageCount(countCriteria)); // used by org.extremecomponents.table.callback.LimitCallback.retrieveRows\n\n        //myModel.put(\"selected_outages\", CurrentOutageParseResponse.findSelectedOutagesIDs(request,m_outageService));\n        \n        return new ModelAndView(getSuccessView(), myModel);\n    }","commit_id":"d370370ca456facba7028cd86f4cc0f09666211a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void afterPropertiesSet() throws Exception {\n        Assert.notNull(m_categoryDao, \"categoryDao property must be set\");\n    }","id":6594,"modified_method":"public void afterPropertiesSet() throws Exception {\n        Assert.notNull(m_filterView, \"filterView property must be set\");\n        Assert.notNull(m_outageListBuilder, \"outageListBuilder property must be set\");\n    }","commit_id":"d370370ca456facba7028cd86f4cc0f09666211a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public OnmsCriteria buildCriteria(HttpServletRequest request) {\n        OnmsCriteria criteria = new OnmsCriteria(OnmsOutage.class);\n\n        if (request.getParameter(\"nodeid\") != null) {\n            criteria.add(Restrictions.eq(\"node.id\", request.getParameter(\"nodeid\")));\n        }\n\n        if (request.getParameter(\"not_nodeid\") != null) {\n            criteria.add(Restrictions.ne(\"node.id\", request.getParameter(\"not_nodeid\")));\n        }\n\n        if (request.getParameter(\"ipaddr\") != null) {\n            criteria.add(Restrictions.eq(\"ipInterface.ipAddress\", request.getParameter(\"ipaddr\")));\n        }\n\n        if (request.getParameter(\"not_ipaddr\") != null) {\n            criteria.add(Restrictions.ne(\"ipInterface.ipAddress\", request.getParameter(\"not_ipaddr\")));\n        }\n\n        if (request.getParameter(\"serviceid\") != null) {\n            criteria.add(Restrictions.eq(\"monitoredService.id\", request.getParameter(\"serviceid\")));\n        }\n\n        if (request.getParameter(\"not_serviceid\") != null) {\n            criteria.add(Restrictions.ne(\"monitoredService.id\", request.getParameter(\"not_serviceid\")));\n        }\n\n        if (request.getParameter(\"smaller_iflostservice\") != null) {\n            Date date = new Date(Long.parseLong(request.getParameter(\"smaller_iflostservice\")));\n            criteria.add(Restrictions.lt(\"ifLostService\", date));\n        }\n\n        if (request.getParameter(\"bigger_iflostservice\") != null) {\n            Date date = new Date(Long.parseLong(request.getParameter(\"bigger_iflostservice\")));\n            criteria.add(Restrictions.gt(\"ifLostService\", date));\n        }\n\n        if (request.getParameter(\"smaller_ifregainedservice\") != null) {\n            Date date = new Date(Long.parseLong(request.getParameter(\"smaller_ifregainedservice\")));\n            criteria.add(Restrictions.lt(\"ifRegainedService\", date));\n        }\n\n        if (request.getParameter(\"bigger_ifregainedservice\") != null) {\n            Date date = new Date(Long.parseLong(request.getParameter(\"bigger_ifregainedservice\")));\n            criteria.add(Restrictions.gt(\"ifRegainedService\", date));\n        }\n\n        if (request.getParameter(\"building\") != null) {\n            criteria.createAlias(\"node.assetRecord\", \"assetRecord\");\n            criteria.add(Restrictions.eq(\"assetRecord.building\", request.getParameter(\"building\")));\n        }\n        \n        if (request.getParameter(\"category1\") != null && request.getParameter(\"category2\") != null) {\n            for (Criterion criterion : m_categoryDao.getCriterionForCategorySetsUnion(request.getParameterValues(\"category1\"), request.getParameterValues(\"category2\"))) {\n                criteria.add(criterion);\n            }\n        } else if (request.getParameter(\"category1\") != null) {\n            for (Criterion criterion : m_categoryDao.getCriterionForCategorySetsUnion(request.getParameterValues(\"category1\"))) {\n                criteria.add(criterion);\n            }\n        }\n\n        if (\"true\".equals(request.getParameter(\"currentOutages\"))) {\n            criteria.add(Restrictions.isNull(\"ifRegainedService\"));\n        }\n\n        if (\"true\".equals(request.getParameter(\"resolvedOutages\"))) {\n            criteria.add(Restrictions.isNotNull(\"ifRegainedService\"));\n        }\n\n        return criteria;\n    }","id":6595,"modified_method":"public OnmsCriteria buildCriteria(HttpServletRequest request) {\n        OnmsCriteria criteria = new OnmsCriteria(OnmsOutage.class);\n\n        if (request.getParameter(\"nodeid\") != null && request.getParameter(\"nodeid\").length() > 0) {\n            criteria.add(Restrictions.eq(\"node.id\", Integer.parseInt(request.getParameter(\"nodeid\"))));\n        }\n\n        if (request.getParameter(\"not_nodeid\") != null && request.getParameter(\"not_nodeid\").length() > 0) {\n            criteria.add(Restrictions.ne(\"node.id\", Integer.parseInt(request.getParameter(\"not_nodeid\"))));\n        }\n\n        if (request.getParameter(\"ipinterfaceid\") != null  && request.getParameter(\"ipinterfaceid\").length() > 0) {\n            criteria.add(Restrictions.eq(\"ipInterface.id\", Integer.parseInt(request.getParameter(\"ipinterfaceid\"))));\n        }\n\n        if (request.getParameter(\"not_ipinterfaceid\") != null && request.getParameter(\"not_ipinterfaceid\").length() > 0) {\n            criteria.add(Restrictions.ne(\"ipInterface.id\", Integer.parseInt(request.getParameter(\"not_ipinterfaceid\"))));\n        }\n\n        if (request.getParameter(\"serviceid\") != null && request.getParameter(\"serviceid\").length() > 0) {\n            criteria.add(Restrictions.eq(\"monitoredService.serviceType.id\", Integer.parseInt(request.getParameter(\"serviceid\"))));\n        }\n\n        if (request.getParameter(\"not_serviceid\") != null && request.getParameter(\"not_serviceid\").length() > 0) {\n            criteria.add(Restrictions.ne(\"monitoredService.serviceType.id\", Integer.parseInt(request.getParameter(\"not_serviceid\"))));\n        }\n        \n        if (request.getParameter(\"ifserviceid\") != null && request.getParameter(\"ifserviceid\").length() > 0) {\n            criteria.add(Restrictions.eq(\"monitoredService.id\", Integer.parseInt(request.getParameter(\"ifserviceid\"))));\n        }\n\n        if (request.getParameter(\"not_ifserviceid\") != null && request.getParameter(\"not_ifserviceid\").length() > 0) {\n            criteria.add(Restrictions.ne(\"monitoredService.id\", Integer.parseInt(request.getParameter(\"not_ifserviceid\"))));\n        }\n\n        if (request.getParameter(\"smaller_iflostservice\") != null && request.getParameter(\"smaller_iflostservice\").length() > 0) {\n            Date date = new Date(Long.parseLong(request.getParameter(\"smaller_iflostservice\")));\n            criteria.add(Restrictions.lt(\"ifLostService\", date));\n        }\n\n        if (request.getParameter(\"bigger_iflostservice\") != null && request.getParameter(\"bigger_iflostservice\").length() > 0) {\n            Date date = new Date(Long.parseLong(request.getParameter(\"bigger_iflostservice\")));\n            criteria.add(Restrictions.gt(\"ifLostService\", date));\n        }\n\n        if (request.getParameter(\"smaller_ifregainedservice\") != null && request.getParameter(\"smaller_ifregainedservice\").length() > 0) {\n            Date date = new Date(Long.parseLong(request.getParameter(\"smaller_ifregainedservice\")));\n            criteria.add(Restrictions.lt(\"ifRegainedService\", date));\n        }\n\n        if (request.getParameter(\"bigger_ifregainedservice\") != null && request.getParameter(\"bigger_ifregainedservice\").length() > 0) {\n            Date date = new Date(Long.parseLong(request.getParameter(\"bigger_ifregainedservice\")));\n            criteria.add(Restrictions.gt(\"ifRegainedService\", date));\n        }\n\n        if (request.getParameter(\"building\") != null && request.getParameter(\"building\").length() > 0) {\n            criteria.createAlias(\"node.assetRecord\", \"assetRecord\");\n            criteria.add(Restrictions.eq(\"assetRecord.building\", request.getParameter(\"building\")));\n        }\n        \n        if (request.getParameter(\"category1\") != null && request.getParameter(\"category1\").length() > 0 && request.getParameter(\"category2\") != null && request.getParameter(\"category2\").length() > 0) {\n            for (Criterion criterion : m_categoryDao.getCriterionForCategorySetsUnion(request.getParameterValues(\"category1\"), request.getParameterValues(\"category2\"))) {\n                criteria.add(criterion);\n            }\n        } else if (request.getParameter(\"category1\") != null && request.getParameter(\"category1\").length() > 0) {\n            for (Criterion criterion : m_categoryDao.getCriterionForCategorySetsUnion(request.getParameterValues(\"category1\"))) {\n                criteria.add(criterion);\n            }\n        }\n\n        if (\"true\".equals(request.getParameter(\"currentOutages\"))) {\n            criteria.add(Restrictions.isNull(\"ifRegainedService\"));\n        }\n\n        if (\"true\".equals(request.getParameter(\"resolvedOutages\"))) {\n            criteria.add(Restrictions.isNotNull(\"ifRegainedService\"));\n        }\n\n        return criteria;\n    }","commit_id":"d370370ca456facba7028cd86f4cc0f09666211a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String filterQuery(HttpServletRequest request) {\n\n        String queryResult = \"\";\n        Locale locale = Locale.getDefault();\n        SimpleDateFormat d_format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\",\n                                                         locale);\n\n        if (request.getQueryString() != null ) {\n\n            StringTokenizer st = new StringTokenizer(request.getQueryString(), \"&\");\n\n\n            while (st.hasMoreTokens()) {\n                String temp = st.nextToken();\n                String parameterName = temp.substring(0, temp.indexOf('='));\n                String parameterValue = temp.substring(temp.indexOf('=') + 1, temp.length());\n\n                // node\n                if (parameterName.startsWith(\"nodeid\")) {\n\n                    queryResult = queryResult + \" AND outages.nodeid = '\"\n                    + parameterValue + \"'\";\n                }\n\n                if (parameterName.startsWith(\"not_nodeid\")) {\n                    queryResult = queryResult + \" AND outages.nodeid <> '\"\n                    + parameterValue + \"\\'\";\n                }\n\n                if (parameterName.startsWith(\"ipaddr\")) {\n                    queryResult = queryResult + \" AND outages.ipaddr ='\"\n                    + parameterValue + \"'\";\n                }\n\n                if (parameterName.startsWith(\"not_ipaddr\")) {\n                    queryResult = queryResult + \" AND outages.ipaddr <> '\"\n                    + parameterValue + \"'\";\n                }\n\n                if (parameterName.startsWith(\"serviceid\")) {\n                    queryResult = queryResult + \" AND outages.serviceid ='\"\n                    + parameterValue + \"'\";\n                }\n\n                if (parameterName.startsWith(\"not_serviceid\")) {\n                    queryResult = queryResult + \" AND outages.serviceid <> '\"\n                    + parameterValue + \"'\";\n                }\n\n                if (parameterName.startsWith(\"smaller_iflostservice\")) {\n                    Date date = new Date(Long.parseLong(parameterValue));\n                    queryResult = queryResult + \" AND outages.iflostservice < \"\n                    + \"'\" + d_format.format(date) + \"'\";\n\n                }\n\n                if (parameterName.startsWith(\"bigger_iflostservice\")) {\n                    Date date = new Date(Long.parseLong(parameterValue));\n                    queryResult = queryResult + \" AND outages.iflostservice > \"\n                    + \"'\" + d_format.format(date) + \"'\";\n\n                }\n\n                if (parameterName.startsWith(\"smaller_ifregainedservice\")) {\n                    Date date = new Date(Long.parseLong(parameterValue));\n                    queryResult = queryResult + \" AND outages.iflostservice < \"\n                    + \"'\" + d_format.format(date) + \"'\";\n                }\n\n                if (parameterName.startsWith(\"bigger_ifregainedservice\")) {\n                    Date date = new Date(Long.parseLong(parameterValue));\n                    queryResult = queryResult + \" AND outages.iflostservice > \"\n                    + \"'\" + d_format.format(date) + \"'\";\n                }\n\n            }\n        }\n\n        return queryResult;\n    }","id":6596,"modified_method":"public String filterQuery(HttpServletRequest request) {\n\n        String queryResult = \"\";\n        Locale locale = Locale.getDefault();\n        SimpleDateFormat d_format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\",\n                                                         locale);\n\n        if (request.getQueryString() != null ) {\n\n            StringTokenizer st = new StringTokenizer(request.getQueryString(), \"&\");\n\n\n            while (st.hasMoreTokens()) {\n                String temp = st.nextToken();\n                String parameterName = temp.substring(0, temp.indexOf('='));\n                String parameterValue = temp.substring(temp.indexOf('=') + 1, temp.length());\n\n                // node\n                if (parameterName.startsWith(\"nodeid\")) {\n\n                    queryResult = queryResult + \" AND outages.nodeid = '\"\n                    + parameterValue + \"'\";\n                }\n\n                if (parameterName.startsWith(\"not_nodeid\")) {\n                    queryResult = queryResult + \" AND outages.nodeid <> '\"\n                    + parameterValue + \"\\'\";\n                }\n\n                if (parameterName.startsWith(\"ipaddr\")) {\n                    queryResult = queryResult + \" AND outages.ipaddr ='\"\n                    + parameterValue + \"'\";\n                }\n\n                if (parameterName.startsWith(\"not_ipaddr\")) {\n                    queryResult = queryResult + \" AND outages.ipaddr <> '\"\n                    + parameterValue + \"'\";\n                }\n\n                if (parameterName.startsWith(\"smaller_iflostservice\")) {\n                    Date date = new Date(Long.parseLong(parameterValue));\n                    queryResult = queryResult + \" AND outages.iflostservice < \"\n                    + \"'\" + d_format.format(date) + \"'\";\n\n                }\n\n                if (parameterName.startsWith(\"bigger_iflostservice\")) {\n                    Date date = new Date(Long.parseLong(parameterValue));\n                    queryResult = queryResult + \" AND outages.iflostservice > \"\n                    + \"'\" + d_format.format(date) + \"'\";\n\n                }\n\n                if (parameterName.startsWith(\"smaller_ifregainedservice\")) {\n                    Date date = new Date(Long.parseLong(parameterValue));\n                    queryResult = queryResult + \" AND outages.iflostservice < \"\n                    + \"'\" + d_format.format(date) + \"'\";\n                }\n\n                if (parameterName.startsWith(\"bigger_ifregainedservice\")) {\n                    Date date = new Date(Long.parseLong(parameterValue));\n                    queryResult = queryResult + \" AND outages.iflostservice > \"\n                    + \"'\" + d_format.format(date) + \"'\";\n                }\n\n            }\n        }\n\n        return queryResult;\n    }","commit_id":"d370370ca456facba7028cd86f4cc0f09666211a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void modifyColumnAttributes(TableModel tableModel, Column column) {\n        if (column.getPropertyValue() == null) {\n            column.setStyle(\"background: red;\");\n        } else {\n            column.setStyle(\"\");\n        }\n    }","id":6597,"modified_method":"public void modifyColumnAttributes(TableModel tableModel, Column column) {\n        if (column.getPropertyValue() == null) {\n            column.setStyle(\"background: red;\");\n            column.setValue(\"Down\");\n        } else {\n            column.setStyle(\"\");\n        }\n    }","commit_id":"d370370ca456facba7028cd86f4cc0f09666211a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private static synchronized AnnotatorPool getDefaultAnnotatorPool(final Properties inputProps) {\n    // if the pool already exists reuse!\n    if(pool == null) {\n      // first time we get here\n      pool = new AnnotatorPool();\n    }\n\n    //\n    // tokenizer: breaks text into a sequence of tokens\n    // this is required for all following annotators!\n    //\n    pool.register(STANFORD_TOKENIZE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                          \"false\"))) {\n          return new WhitespaceTokenizerAnnotator(properties);\n        } else {\n          String options = properties.getProperty(\"tokenize.options\",\n                  PTBTokenizerAnnotator.DEFAULT_OPTIONS);\n          boolean keepNewline =\n                  Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                          \"false\"));\n          // If the user specifies \"tokenizeNLs=false\" in tokenize.options, then this default will\n          // be overridden.\n          if (keepNewline) {\n            options = \"tokenizeNLs,\" + options;\n          }\n          return new PTBTokenizerAnnotator(false, options);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(\"tokenize.whitespace:\" +\n                properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                \"false\"))) {\n          os.append(WhitespaceTokenizerAnnotator.EOL_PROPERTY + \":\" +\n                  properties.getProperty(WhitespaceTokenizerAnnotator.EOL_PROPERTY,\n                          \"false\"));\n          os.append(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  properties.getProperty(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY,\n                          \"false\"));\n          return os.toString();\n        } else {\n          os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                          \"false\")));\n        }\n        return os.toString();\n      }\n    });\n\n    pool.register(STANFORD_CLEAN_XML, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String xmlTags =\n          properties.getProperty(\"clean.xmltags\",\n                            CleanXmlAnnotator.DEFAULT_XML_TAGS);\n        String sentenceEndingTags =\n          properties.getProperty(\"clean.sentenceendingtags\",\n                            CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS);\n        String singleSentenceTags =\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS);\n        String allowFlawedString = properties.getProperty(\"clean.allowflawedxml\");\n        boolean allowFlawed = CleanXmlAnnotator.DEFAULT_ALLOW_FLAWS;\n        if (allowFlawedString != null)\n          allowFlawed = Boolean.valueOf(allowFlawedString);\n        String dateTags =\n          properties.getProperty(\"clean.datetags\",\n                            CleanXmlAnnotator.DEFAULT_DATE_TAGS);\n        String docIdTags =\n                properties.getProperty(\"clean.docIdtags\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS);\n        String docTypeTags =\n                properties.getProperty(\"clean.docTypetags\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS);\n        String utteranceTurnTags =\n                properties.getProperty(\"clean.turntags\",\n                        CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS);\n        String speakerTags =\n                properties.getProperty(\"clean.speakertags\",\n                        CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS);\n        String docAnnotations =\n                properties.getProperty(\"clean.docAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS);\n        String tokenAnnotations =\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS);\n        String sectionTags =\n                properties.getProperty(\"clean.sectiontags\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_TAGS);\n        String sectionAnnotations =\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n        String ssplitDiscardTokens =\n                properties.getProperty(\"clean.ssplitDiscardTokens\");\n        CleanXmlAnnotator annotator = new CleanXmlAnnotator(xmlTags,\n            sentenceEndingTags,\n            dateTags,\n            allowFlawed);\n        annotator.setSingleSentenceTagMatcher(singleSentenceTags);\n        annotator.setDocIdTagMatcher(docIdTags);\n        annotator.setDocTypeTagMatcher(docTypeTags);\n        annotator.setDiscourseTags(utteranceTurnTags, speakerTags);\n        annotator.setDocAnnotationPatterns(docAnnotations);\n        annotator.setTokenAnnotationPatterns(tokenAnnotations);\n        annotator.setSectionTagMatcher(sectionTags);\n        annotator.setSectionAnnotationPatterns(sectionAnnotations);\n        annotator.setSsplitDiscardTokensMatcher(ssplitDiscardTokens);\n        return annotator;\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"clean.xmltags:\" +\n                properties.getProperty(\"clean.xmltags\",\n                  CleanXmlAnnotator.DEFAULT_XML_TAGS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.sentenceendingtags\",\n                  CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS) +\n                \"clean.allowflawedxml:\" +\n                properties.getProperty(\"clean.allowflawedxml\", \"\") +\n                \"clean.datetags:\" +\n                properties.getProperty(\"clean.datetags\",\n                  CleanXmlAnnotator.DEFAULT_DATE_TAGS) +\n                \"clean.docidtags:\" +\n                properties.getProperty(\"clean.docid\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS) +\n                \"clean.doctypetags:\" +\n                properties.getProperty(\"clean.doctype\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS) +\n                \"clean.turntags:\" +\n                properties.getProperty(\"clean.turntags\",\n                  CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS) +\n                \"clean.speakertags:\" +\n                properties.getProperty(\"clean.speakertags\",\n                  CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS) +\n                \"clean.docAnnotations:\" +\n                properties.getProperty(\"clean.docAnnotations\",\n                  CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS) +\n                \"clean.tokenAnnotations:\" +\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS) +\n                \"clean.sectiontags:\" +\n                properties.getProperty(\"clean.sectiontags\",\n                  CleanXmlAnnotator.DEFAULT_SECTION_TAGS) +\n                \"clean.sectionAnnotations:\" +\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n      }\n    });\n\n    //\n    // Sentence splitter: splits the above sequence of tokens into\n    // sentences.  This is required when processing entire documents or\n    // text consisting of multiple sentences.\n    //\n    pool.register(STANFORD_SSPLIT, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        boolean nlSplitting = Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (nlSplitting) {\n          boolean whitespaceTokenization = Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\", \"false\"));\n          if (whitespaceTokenization) {\n            if (System.getProperty(\"line.separator\").equals(\"\\n\")) {\n              return WordsToSentencesAnnotator.newlineSplitter(false, \"\\n\");\n            } else {\n              // throw \"\\n\" in just in case files use that instead of\n              // the system separator\n              return WordsToSentencesAnnotator.newlineSplitter(false, System.getProperty(\"line.separator\"), \"\\n\");\n            }\n          } else {\n            return WordsToSentencesAnnotator.newlineSplitter(false, PTBTokenizer.getNewlineToken());\n          }\n\n        } else {\n          // Treat as one sentence: You get a no-op sentence splitter that always returns all tokens as one sentence.\n          String isOneSentence = properties.getProperty(\"ssplit.isOneSentence\");\n          if (Boolean.parseBoolean(isOneSentence)) { // this method treats null as false\n            return WordsToSentencesAnnotator.nonSplitter(false);\n          }\n\n          // multi token sentence boundaries\n          String boundaryMultiTokenRegex = properties.getProperty(\"ssplit.boundaryMultiTokenRegex\");\n\n          // Discard these tokens without marking them as sentence boundaries\n          String tokenPatternsToDiscardProp = properties.getProperty(\"ssplit.tokenPatternsToDiscard\");\n          Set<String> tokenRegexesToDiscard = null;\n          if (tokenPatternsToDiscardProp != null){\n            String [] toks = tokenPatternsToDiscardProp.split(\",\");\n            tokenRegexesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          // regular boundaries\n          String boundaryTokenRegex = properties.getProperty(\"ssplit.boundaryTokenRegex\");\n          Set<String> boundariesToDiscard = null;\n\n          // newline boundaries which are discarded.\n          String bounds = properties.getProperty(\"ssplit.boundariesToDiscard\");\n          if (bounds != null) {\n            String [] toks = bounds.split(\",\");\n            boundariesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          Set<String> htmlElementsToDiscard = null;\n          // HTML boundaries which are discarded\n          bounds = properties.getProperty(\"ssplit.htmlBoundariesToDiscard\");\n          if (bounds != null) {\n            String [] elements = bounds.split(\",\");\n            htmlElementsToDiscard = Generics.newHashSet(Arrays.asList(elements));\n          }\n          String nlsb = properties.getProperty(\"ssplit.newlineIsSentenceBreak\", \"two\");\n\n          return new WordsToSentencesAnnotator(false, boundaryTokenRegex, boundariesToDiscard, htmlElementsToDiscard,\n                  nlsb, boundaryMultiTokenRegex, tokenRegexesToDiscard);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                \"false\"))) {\n          os.append(\"tokenize.whitespace:\" +\n                  properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        } else {\n          os.append(\"ssplit.isOneSentence:\" +\n                  properties.getProperty(\"ssplit.isOneSentence\", \"false\"));\n          if ( ! Boolean.valueOf(properties.getProperty(\"ssplit.isOneSentence\", \"false\"))) {\n            os.append(\"ssplit.boundaryTokenRegex:\" +\n                    properties.getProperty(\"ssplit.boundaryTokenRegex\", \"\"));\n            os.append(\"ssplit.boundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.boundariesToDiscard\", \"\"));\n            os.append(\"ssplit.htmlBoundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.htmlBoundariesToDiscard\", \"\"));\n            os.append(\"ssplit.newlineIsSentenceBreak:\" +\n                    properties.getProperty(\"ssplit.newlineIsSentenceBreak\", \"two\"));\n          }\n        }\n        return os.toString();\n      }\n    });\n\n    //\n    // POS tagger\n    //\n    pool.register(STANFORD_POS, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        try {\n          return new POSTaggerAnnotator(\"pos\", properties);\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return (\"pos.maxlen:\" + properties.getProperty(\"pos.maxlen\", \"\") +\n                \"pos.model:\" + properties.getProperty(\"pos.model\", DefaultPaths.DEFAULT_POS_MODEL) +\n                \"pos.nthreads:\" + properties.getProperty(\"pos.nthreads\", properties.getProperty(\"nthreads\", \"\")));\n      }\n    });\n\n    //\n    // Lemmatizer\n    //\n    pool.register(STANFORD_LEMMA, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new MorphaAnnotator(false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        // nothing for this one\n        return \"\";\n      }\n    });\n\n    //\n    // NER\n    //\n    pool.register(STANFORD_NER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        List<String> models = new ArrayList<String>();\n        String modelNames = properties.getProperty(\"ner.model\");\n        if (modelNames == null) {\n          modelNames = DefaultPaths.DEFAULT_NER_THREECLASS_MODEL + \",\" + DefaultPaths.DEFAULT_NER_MUC_MODEL + \",\" + DefaultPaths.DEFAULT_NER_CONLL_MODEL;\n        }\n        if (modelNames.length() > 0) {\n          models.addAll(Arrays.asList(modelNames.split(\",\")));\n        }\n        if (models.isEmpty()) {\n          // Allow for no real NER model - can just use numeric classifiers or SUTime.\n          // Have to unset ner.model, so unlikely that people got here by accident.\n          System.err.println(\"WARNING: no NER models specified\");\n        }\n        NERClassifierCombiner nerCombiner;\n        try {\n          boolean applyNumericClassifiers =\n            PropertiesUtils.getBool(properties,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT);\n          boolean useSUTime =\n            PropertiesUtils.getBool(properties,\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                NumberSequenceClassifier.USE_SUTIME_DEFAULT);\n          nerCombiner = new NERClassifierCombiner(applyNumericClassifiers,\n                useSUTime, properties,\n                models.toArray(new String[models.size()]));\n        } catch (FileNotFoundException e) {\n          throw new RuntimeIOException(e);\n        }\n        return new NERCombinerAnnotator(nerCombiner, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"ner.model:\" +\n                properties.getProperty(\"ner.model\", \"\") +\n                \"ner.model.3class:\" +\n                properties.getProperty(\"ner.model.3class\",\n                        DefaultPaths.DEFAULT_NER_THREECLASS_MODEL) +\n                \"ner.model.7class:\" +\n                properties.getProperty(\"ner.model.7class\",\n                        DefaultPaths.DEFAULT_NER_MUC_MODEL) +\n                \"ner.model.MISCclass:\" +\n                properties.getProperty(\"ner.model.MISCclass\",\n                        DefaultPaths.DEFAULT_NER_CONLL_MODEL) +\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY + \":\" +\n                properties.getProperty(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                        Boolean.toString(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT)) +\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY + \":\" +\n                properties.getProperty(NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                        Boolean.toString(NumberSequenceClassifier.USE_SUTIME_DEFAULT));\n      }\n    });\n\n    //\n    // Regex NER\n    //\n    pool.register(STANFORD_REGEXNER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new TokensRegexNERAnnotator(\"regexner\", properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return PropertiesUtils.getSignature(\"regexner\", properties, TokensRegexNERAnnotator.SUPPORTED_PROPERTIES);\n      }\n    });\n\n    //\n    // Gender Annotator\n    //\n    pool.register(STANFORD_GENDER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new GenderAnnotator(false, properties.getProperty(\"gender.firstnames\", DefaultPaths.DEFAULT_GENDER_FIRST_NAMES));\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"gender.firstnames:\" +\n                properties.getProperty(\"gender.firstnames\",\n                        DefaultPaths.DEFAULT_GENDER_FIRST_NAMES);\n      }\n    });\n\n\n    //\n    // True caser\n    //\n    pool.register(STANFORD_TRUECASE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String model = properties.getProperty(\"truecase.model\", DefaultPaths.DEFAULT_TRUECASE_MODEL);\n        String bias = properties.getProperty(\"truecase.bias\", TrueCaseAnnotator.DEFAULT_MODEL_BIAS);\n        String mixed = properties.getProperty(\"truecase.mixedcasefile\", DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n        return new TrueCaseAnnotator(model, bias, mixed, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"truecase.model:\" +\n                properties.getProperty(\"truecase.model\",\n                        DefaultPaths.DEFAULT_TRUECASE_MODEL) +\n                \"truecase.bias:\" +\n                properties.getProperty(\"truecase.bias\",\n                        TrueCaseAnnotator.DEFAULT_MODEL_BIAS) +\n                \"truecase.mixedcasefile:\" +\n                properties.getProperty(\"truecase.mixedcasefile\",\n                        DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n      }\n    });\n\n    //\n    // Post-processing tokenization rules for the NFL domain\n    //\n    pool.register(STANFORD_NFL_TOKENIZE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        final String className =\n          \"edu.stanford.nlp.pipeline.NFLTokenizerAnnotator\";\n        return ReflectionLoading.loadByReflection(className);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        // no used props for this one\n        return \"\";\n      }\n    });\n\n    //\n    // Entity and relation extraction for the NFL domain\n    //\n    pool.register(STANFORD_NFL, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        // these paths now extracted inside c'tor\n        // String gazetteer = properties.getProperty(\"nfl.gazetteer\", DefaultPaths.DEFAULT_NFL_GAZETTEER);\n        // String entityModel = properties.getProperty(\"nfl.entity.model\", DefaultPaths.DEFAULT_NFL_ENTITY_MODEL);\n        // String relationModel = properties.getProperty(\"nfl.relation.model\", DefaultPaths.DEFAULT_NFL_RELATION_MODEL);\n        final String className = \"edu.stanford.nlp.pipeline.NFLAnnotator\";\n        return ReflectionLoading.loadByReflection(className, properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"nfl.verbose:\" +\n                properties.getProperty(\"nfl.verbose\",\n                        \"false\") +\n                \"nfl.relations.use.max.recall:\" +\n                properties.getProperty(\"nfl.relations.use.max.recall\",\n                        \"false\") +\n                \"nfl.relations.use.model.merging:\" +\n                properties.getProperty(\"nfl.relations.use.model.merging\",\n                        \"false\") +\n                \"nfl.relations.use.basic.inference:\" +\n                properties.getProperty(\"nfl.relations.use.basic.inference\",\n                        \"true\") +\n                \"nfl.gazetteer:\" +\n                properties.getProperty(\"nfl.gazetteer\",\n                        DefaultPaths.DEFAULT_NFL_GAZETTEER) +\n                \"nfl.entity.model:\" +\n                properties.getProperty(\"nfl.entity.model\",\n                        DefaultPaths.DEFAULT_NFL_ENTITY_MODEL) +\n                \"nfl.relation.model:\" +\n                properties.getProperty(\"nfl.relation.model\",\n                        DefaultPaths.DEFAULT_NFL_RELATION_MODEL);\n      }\n    });\n\n    //\n    // Parser\n    //\n    pool.register(STANFORD_PARSE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String parserType = properties.getProperty(\"parse.type\", \"stanford\");\n        String maxLenStr = properties.getProperty(\"parse.maxlen\");\n\n        if (parserType.equalsIgnoreCase(\"stanford\")) {\n          ParserAnnotator anno = new ParserAnnotator(\"parse\", properties);\n          return anno;\n        } else if (parserType.equalsIgnoreCase(\"charniak\")) {\n          String model = properties.getProperty(\"parse.model\");\n          String parserExecutable = properties.getProperty(\"parse.executable\");\n          if (model == null || parserExecutable == null) {\n            throw new RuntimeException(\"Both parse.model and parse.executable properties must be specified if parse.type=charniak\");\n          }\n          int maxLen = 399;\n          if (maxLenStr != null) {\n            maxLen = Integer.parseInt(maxLenStr);\n          }\n\n          CharniakParserAnnotator anno = new CharniakParserAnnotator(model, parserExecutable, false, maxLen);\n\n          return anno;\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + parserType + \" (currently supported: stanford and charniak)\");\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        String type = properties.getProperty(\"parse.type\", \"stanford\");\n        if(type.equalsIgnoreCase(\"stanford\")){\n          return ParserAnnotator.signature(\"parser\", properties);\n        } else if(type.equalsIgnoreCase(\"charniak\")) {\n          return \"parse.model:\" +\n                  properties.getProperty(\"parse.model\", \"\") +\n                  \"parse.executable:\" +\n                  properties.getProperty(\"parse.executable\", \"\") +\n                  \"parse.maxlen:\" +\n                  properties.getProperty(\"parse.maxlen\", \"\");\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + type +\n                  \" (currently supported: stanford and charniak)\");\n        }\n      }\n    });\n\n    //\n    // Coreference resolution\n    //\n    pool.register(STANFORD_DETERMINISTIC_COREF, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new DeterministicCorefAnnotator(properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return DeterministicCorefAnnotator.signature(properties);\n      }\n    });\n\n    // add annotators loaded via reflection from classnames specified\n    // in the properties\n    for (Object propertyKey : inputProps.stringPropertyNames()) {\n      if (!(propertyKey instanceof String))\n        continue; // should this be an Exception?\n      String property = (String) propertyKey;\n      if (property.startsWith(CUSTOM_ANNOTATOR_PREFIX)) {\n        final String customName =\n          property.substring(CUSTOM_ANNOTATOR_PREFIX.length());\n        final String customClassName = inputProps.getProperty(property);\n        System.err.println(\"Registering annotator \" + customName +\n            \" with class \" + customClassName);\n        pool.register(customName, new AnnotatorFactory(inputProps) {\n          private static final long serialVersionUID = 1L;\n          private final String name = customName;\n          private final String className = customClassName;\n          @Override\n          public Annotator create() {\n            return ReflectionLoading.loadByReflection(className, name,\n                                                      properties);\n          }\n          @Override\n          public String signature() {\n            // keep track of all relevant properties for this annotator here!\n            // since we don't know what props they need, let's copy all\n            // TODO: can we do better here? maybe signature() should be a method in the Annotator?\n            StringBuilder os = new StringBuilder();\n            for(Object key: properties.keySet()) {\n              String skey = (String) key;\n              os.append(skey + \":\" + properties.getProperty(skey));\n            }\n            return os.toString();\n          }\n        });\n      }\n    }\n\n\n    pool.register(STANFORD_RELATION, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        final String className = \"edu.stanford.nlp.pipeline.RelationExtractorAnnotator\";\n        return ReflectionLoading.loadByReflection(className, properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"TODO\";\n      }\n    });\n    \n    //\n    // add more annotators here!\n    //\n    return pool;\n  }","id":6598,"modified_method":"private static synchronized AnnotatorPool getDefaultAnnotatorPool(final Properties inputProps) {\n    // if the pool already exists reuse!\n    if(pool == null) {\n      // first time we get here\n      pool = new AnnotatorPool();\n    }\n\n    //\n    // tokenizer: breaks text into a sequence of tokens\n    // this is required for all following annotators!\n    //\n    pool.register(STANFORD_TOKENIZE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                          \"false\"))) {\n          return new WhitespaceTokenizerAnnotator(properties);\n        } else {\n          String options = properties.getProperty(\"tokenize.options\",\n                  PTBTokenizerAnnotator.DEFAULT_OPTIONS);\n          boolean keepNewline =\n                  Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                          \"false\"));\n          // If the user specifies \"tokenizeNLs=false\" in tokenize.options, then this default will\n          // be overridden.\n          if (keepNewline) {\n            options = \"tokenizeNLs,\" + options;\n          }\n          return new PTBTokenizerAnnotator(false, options);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(\"tokenize.whitespace:\" +\n                properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                \"false\"))) {\n          os.append(WhitespaceTokenizerAnnotator.EOL_PROPERTY + \":\" +\n                  properties.getProperty(WhitespaceTokenizerAnnotator.EOL_PROPERTY,\n                          \"false\"));\n          os.append(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  properties.getProperty(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY,\n                          \"false\"));\n          return os.toString();\n        } else {\n          os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                          \"false\")));\n        }\n        return os.toString();\n      }\n    });\n\n    pool.register(STANFORD_CLEAN_XML, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String xmlTags =\n          properties.getProperty(\"clean.xmltags\",\n                            CleanXmlAnnotator.DEFAULT_XML_TAGS);\n        String sentenceEndingTags =\n          properties.getProperty(\"clean.sentenceendingtags\",\n                            CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS);\n        String singleSentenceTags =\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS);\n        String allowFlawedString = properties.getProperty(\"clean.allowflawedxml\");\n        boolean allowFlawed = CleanXmlAnnotator.DEFAULT_ALLOW_FLAWS;\n        if (allowFlawedString != null)\n          allowFlawed = Boolean.valueOf(allowFlawedString);\n        String dateTags =\n          properties.getProperty(\"clean.datetags\",\n                            CleanXmlAnnotator.DEFAULT_DATE_TAGS);\n        String docIdTags =\n                properties.getProperty(\"clean.docIdtags\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS);\n        String docTypeTags =\n                properties.getProperty(\"clean.docTypetags\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS);\n        String utteranceTurnTags =\n                properties.getProperty(\"clean.turntags\",\n                        CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS);\n        String speakerTags =\n                properties.getProperty(\"clean.speakertags\",\n                        CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS);\n        String docAnnotations =\n                properties.getProperty(\"clean.docAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS);\n        String tokenAnnotations =\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS);\n        String sectionTags =\n                properties.getProperty(\"clean.sectiontags\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_TAGS);\n        String sectionAnnotations =\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n        String ssplitDiscardTokens =\n                properties.getProperty(\"clean.ssplitDiscardTokens\");\n        CleanXmlAnnotator annotator = new CleanXmlAnnotator(xmlTags,\n            sentenceEndingTags,\n            dateTags,\n            allowFlawed);\n        annotator.setSingleSentenceTagMatcher(singleSentenceTags);\n        annotator.setDocIdTagMatcher(docIdTags);\n        annotator.setDocTypeTagMatcher(docTypeTags);\n        annotator.setDiscourseTags(utteranceTurnTags, speakerTags);\n        annotator.setDocAnnotationPatterns(docAnnotations);\n        annotator.setTokenAnnotationPatterns(tokenAnnotations);\n        annotator.setSectionTagMatcher(sectionTags);\n        annotator.setSectionAnnotationPatterns(sectionAnnotations);\n        annotator.setSsplitDiscardTokensMatcher(ssplitDiscardTokens);\n        return annotator;\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"clean.xmltags:\" +\n                properties.getProperty(\"clean.xmltags\",\n                  CleanXmlAnnotator.DEFAULT_XML_TAGS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.sentenceendingtags\",\n                  CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS) +\n                \"clean.allowflawedxml:\" +\n                properties.getProperty(\"clean.allowflawedxml\", \"\") +\n                \"clean.datetags:\" +\n                properties.getProperty(\"clean.datetags\",\n                  CleanXmlAnnotator.DEFAULT_DATE_TAGS) +\n                \"clean.docidtags:\" +\n                properties.getProperty(\"clean.docid\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS) +\n                \"clean.doctypetags:\" +\n                properties.getProperty(\"clean.doctype\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS) +\n                \"clean.turntags:\" +\n                properties.getProperty(\"clean.turntags\",\n                  CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS) +\n                \"clean.speakertags:\" +\n                properties.getProperty(\"clean.speakertags\",\n                  CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS) +\n                \"clean.docAnnotations:\" +\n                properties.getProperty(\"clean.docAnnotations\",\n                  CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS) +\n                \"clean.tokenAnnotations:\" +\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS) +\n                \"clean.sectiontags:\" +\n                properties.getProperty(\"clean.sectiontags\",\n                  CleanXmlAnnotator.DEFAULT_SECTION_TAGS) +\n                \"clean.sectionAnnotations:\" +\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n      }\n    });\n\n    //\n    // Sentence splitter: splits the above sequence of tokens into\n    // sentences.  This is required when processing entire documents or\n    // text consisting of multiple sentences.\n    //\n    pool.register(STANFORD_SSPLIT, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        boolean nlSplitting = Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (nlSplitting) {\n          boolean whitespaceTokenization = Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\", \"false\"));\n          if (whitespaceTokenization) {\n            if (System.getProperty(\"line.separator\").equals(\"\\n\")) {\n              return WordsToSentencesAnnotator.newlineSplitter(false, \"\\n\");\n            } else {\n              // throw \"\\n\" in just in case files use that instead of\n              // the system separator\n              return WordsToSentencesAnnotator.newlineSplitter(false, System.getProperty(\"line.separator\"), \"\\n\");\n            }\n          } else {\n            return WordsToSentencesAnnotator.newlineSplitter(false, PTBTokenizer.getNewlineToken());\n          }\n\n        } else {\n          // Treat as one sentence: You get a no-op sentence splitter that always returns all tokens as one sentence.\n          String isOneSentence = properties.getProperty(\"ssplit.isOneSentence\");\n          if (Boolean.parseBoolean(isOneSentence)) { // this method treats null as false\n            return WordsToSentencesAnnotator.nonSplitter(false);\n          }\n\n          // multi token sentence boundaries\n          String boundaryMultiTokenRegex = properties.getProperty(\"ssplit.boundaryMultiTokenRegex\");\n\n          // Discard these tokens without marking them as sentence boundaries\n          String tokenPatternsToDiscardProp = properties.getProperty(\"ssplit.tokenPatternsToDiscard\");\n          Set<String> tokenRegexesToDiscard = null;\n          if (tokenPatternsToDiscardProp != null){\n            String [] toks = tokenPatternsToDiscardProp.split(\",\");\n            tokenRegexesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          // regular boundaries\n          String boundaryTokenRegex = properties.getProperty(\"ssplit.boundaryTokenRegex\");\n          Set<String> boundariesToDiscard = null;\n\n          // newline boundaries which are discarded.\n          String bounds = properties.getProperty(\"ssplit.boundariesToDiscard\");\n          if (bounds != null) {\n            String [] toks = bounds.split(\",\");\n            boundariesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          Set<String> htmlElementsToDiscard = null;\n          // HTML boundaries which are discarded\n          bounds = properties.getProperty(\"ssplit.htmlBoundariesToDiscard\");\n          if (bounds != null) {\n            String [] elements = bounds.split(\",\");\n            htmlElementsToDiscard = Generics.newHashSet(Arrays.asList(elements));\n          }\n          String nlsb = properties.getProperty(\"ssplit.newlineIsSentenceBreak\", \"two\");\n\n          return new WordsToSentencesAnnotator(false, boundaryTokenRegex, boundariesToDiscard, htmlElementsToDiscard,\n                  nlsb, boundaryMultiTokenRegex, tokenRegexesToDiscard);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                \"false\"))) {\n          os.append(\"tokenize.whitespace:\" +\n                  properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        } else {\n          os.append(\"ssplit.isOneSentence:\" +\n                  properties.getProperty(\"ssplit.isOneSentence\", \"false\"));\n          if ( ! Boolean.valueOf(properties.getProperty(\"ssplit.isOneSentence\", \"false\"))) {\n            os.append(\"ssplit.boundaryTokenRegex:\" +\n                    properties.getProperty(\"ssplit.boundaryTokenRegex\", \"\"));\n            os.append(\"ssplit.boundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.boundariesToDiscard\", \"\"));\n            os.append(\"ssplit.htmlBoundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.htmlBoundariesToDiscard\", \"\"));\n            os.append(\"ssplit.newlineIsSentenceBreak:\" +\n                    properties.getProperty(\"ssplit.newlineIsSentenceBreak\", \"two\"));\n          }\n        }\n        return os.toString();\n      }\n    });\n\n    //\n    // POS tagger\n    //\n    pool.register(STANFORD_POS, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        try {\n          return new POSTaggerAnnotator(\"pos\", properties);\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return (\"pos.maxlen:\" + properties.getProperty(\"pos.maxlen\", \"\") +\n                \"pos.model:\" + properties.getProperty(\"pos.model\", DefaultPaths.DEFAULT_POS_MODEL) +\n                \"pos.nthreads:\" + properties.getProperty(\"pos.nthreads\", properties.getProperty(\"nthreads\", \"\")));\n      }\n    });\n\n    //\n    // Lemmatizer\n    //\n    pool.register(STANFORD_LEMMA, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new MorphaAnnotator(false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        // nothing for this one\n        return \"\";\n      }\n    });\n\n    //\n    // NER\n    //\n    pool.register(STANFORD_NER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        List<String> models = new ArrayList<String>();\n        String modelNames = properties.getProperty(\"ner.model\");\n        if (modelNames == null) {\n          modelNames = DefaultPaths.DEFAULT_NER_THREECLASS_MODEL + \",\" + DefaultPaths.DEFAULT_NER_MUC_MODEL + \",\" + DefaultPaths.DEFAULT_NER_CONLL_MODEL;\n        }\n        if (modelNames.length() > 0) {\n          models.addAll(Arrays.asList(modelNames.split(\",\")));\n        }\n        if (models.isEmpty()) {\n          // Allow for no real NER model - can just use numeric classifiers or SUTime.\n          // Have to unset ner.model, so unlikely that people got here by accident.\n          System.err.println(\"WARNING: no NER models specified\");\n        }\n        NERClassifierCombiner nerCombiner;\n        try {\n          boolean applyNumericClassifiers =\n            PropertiesUtils.getBool(properties,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT);\n          boolean useSUTime =\n            PropertiesUtils.getBool(properties,\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                NumberSequenceClassifier.USE_SUTIME_DEFAULT);\n          nerCombiner = new NERClassifierCombiner(applyNumericClassifiers,\n                useSUTime, properties,\n                models.toArray(new String[models.size()]));\n        } catch (FileNotFoundException e) {\n          throw new RuntimeIOException(e);\n        }\n        return new NERCombinerAnnotator(nerCombiner, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"ner.model:\" +\n                properties.getProperty(\"ner.model\", \"\") +\n                \"ner.model.3class:\" +\n                properties.getProperty(\"ner.model.3class\",\n                        DefaultPaths.DEFAULT_NER_THREECLASS_MODEL) +\n                \"ner.model.7class:\" +\n                properties.getProperty(\"ner.model.7class\",\n                        DefaultPaths.DEFAULT_NER_MUC_MODEL) +\n                \"ner.model.MISCclass:\" +\n                properties.getProperty(\"ner.model.MISCclass\",\n                        DefaultPaths.DEFAULT_NER_CONLL_MODEL) +\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY + \":\" +\n                properties.getProperty(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                        Boolean.toString(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT)) +\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY + \":\" +\n                properties.getProperty(NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                        Boolean.toString(NumberSequenceClassifier.USE_SUTIME_DEFAULT));\n      }\n    });\n\n    //\n    // Regex NER\n    //\n    pool.register(STANFORD_REGEXNER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new TokensRegexNERAnnotator(\"regexner\", properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return PropertiesUtils.getSignature(\"regexner\", properties, TokensRegexNERAnnotator.SUPPORTED_PROPERTIES);\n      }\n    });\n\n    //\n    // Gender Annotator\n    //\n    pool.register(STANFORD_GENDER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new GenderAnnotator(false, properties.getProperty(\"gender.firstnames\", DefaultPaths.DEFAULT_GENDER_FIRST_NAMES));\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"gender.firstnames:\" +\n                properties.getProperty(\"gender.firstnames\",\n                        DefaultPaths.DEFAULT_GENDER_FIRST_NAMES);\n      }\n    });\n\n\n    //\n    // True caser\n    //\n    pool.register(STANFORD_TRUECASE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String model = properties.getProperty(\"truecase.model\", DefaultPaths.DEFAULT_TRUECASE_MODEL);\n        String bias = properties.getProperty(\"truecase.bias\", TrueCaseAnnotator.DEFAULT_MODEL_BIAS);\n        String mixed = properties.getProperty(\"truecase.mixedcasefile\", DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n        return new TrueCaseAnnotator(model, bias, mixed, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"truecase.model:\" +\n                properties.getProperty(\"truecase.model\",\n                        DefaultPaths.DEFAULT_TRUECASE_MODEL) +\n                \"truecase.bias:\" +\n                properties.getProperty(\"truecase.bias\",\n                        TrueCaseAnnotator.DEFAULT_MODEL_BIAS) +\n                \"truecase.mixedcasefile:\" +\n                properties.getProperty(\"truecase.mixedcasefile\",\n                        DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n      }\n    });\n\n    //\n    // Parser\n    //\n    pool.register(STANFORD_PARSE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String parserType = properties.getProperty(\"parse.type\", \"stanford\");\n        String maxLenStr = properties.getProperty(\"parse.maxlen\");\n\n        if (parserType.equalsIgnoreCase(\"stanford\")) {\n          ParserAnnotator anno = new ParserAnnotator(\"parse\", properties);\n          return anno;\n        } else if (parserType.equalsIgnoreCase(\"charniak\")) {\n          String model = properties.getProperty(\"parse.model\");\n          String parserExecutable = properties.getProperty(\"parse.executable\");\n          if (model == null || parserExecutable == null) {\n            throw new RuntimeException(\"Both parse.model and parse.executable properties must be specified if parse.type=charniak\");\n          }\n          int maxLen = 399;\n          if (maxLenStr != null) {\n            maxLen = Integer.parseInt(maxLenStr);\n          }\n\n          CharniakParserAnnotator anno = new CharniakParserAnnotator(model, parserExecutable, false, maxLen);\n\n          return anno;\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + parserType + \" (currently supported: stanford and charniak)\");\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        String type = properties.getProperty(\"parse.type\", \"stanford\");\n        if(type.equalsIgnoreCase(\"stanford\")){\n          return ParserAnnotator.signature(\"parser\", properties);\n        } else if(type.equalsIgnoreCase(\"charniak\")) {\n          return \"parse.model:\" +\n                  properties.getProperty(\"parse.model\", \"\") +\n                  \"parse.executable:\" +\n                  properties.getProperty(\"parse.executable\", \"\") +\n                  \"parse.maxlen:\" +\n                  properties.getProperty(\"parse.maxlen\", \"\");\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + type +\n                  \" (currently supported: stanford and charniak)\");\n        }\n      }\n    });\n\n    //\n    // Coreference resolution\n    //\n    pool.register(STANFORD_DETERMINISTIC_COREF, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new DeterministicCorefAnnotator(properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return DeterministicCorefAnnotator.signature(properties);\n      }\n    });\n\n    // add annotators loaded via reflection from classnames specified\n    // in the properties\n    for (Object propertyKey : inputProps.stringPropertyNames()) {\n      if (!(propertyKey instanceof String))\n        continue; // should this be an Exception?\n      String property = (String) propertyKey;\n      if (property.startsWith(CUSTOM_ANNOTATOR_PREFIX)) {\n        final String customName =\n          property.substring(CUSTOM_ANNOTATOR_PREFIX.length());\n        final String customClassName = inputProps.getProperty(property);\n        System.err.println(\"Registering annotator \" + customName +\n            \" with class \" + customClassName);\n        pool.register(customName, new AnnotatorFactory(inputProps) {\n          private static final long serialVersionUID = 1L;\n          private final String name = customName;\n          private final String className = customClassName;\n          @Override\n          public Annotator create() {\n            return ReflectionLoading.loadByReflection(className, name,\n                                                      properties);\n          }\n          @Override\n          public String signature() {\n            // keep track of all relevant properties for this annotator here!\n            // since we don't know what props they need, let's copy all\n            // TODO: can we do better here? maybe signature() should be a method in the Annotator?\n            StringBuilder os = new StringBuilder();\n            for(Object key: properties.keySet()) {\n              String skey = (String) key;\n              os.append(skey + \":\" + properties.getProperty(skey));\n            }\n            return os.toString();\n          }\n        });\n      }\n    }\n\n\n    pool.register(STANFORD_RELATION, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new RelationExtractorAnnotator(properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"sup.relation.verbose:\" +\n        properties.getProperty(\"sup.relation.verbose\",\n                \"false\") +\n        properties.getProperty(\"sup.relation.model\",\n                DefaultPaths.DEFAULT_SUP_RELATION_EX_RELATION_MODEL);\n      }\n    });\n    \n    //\n    // add more annotators here!\n    //\n    return pool;\n  }","commit_id":"c4a22d77d46a69177c53e687a383434c507d3c2e","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Prints the list of properties required to run the pipeline\n   * @param os PrintStream to print usage to\n   */\n  private static void printRequiredProperties(PrintStream os) {\n    // TODO some annotators (ssplit, regexner, gender, some parser options, dcoref?) are not documented\n    os.println(\"The following properties can be defined:\");\n    os.println(\"(if -props or -annotators is not passed in, default properties will be loaded via the classpath)\");\n    os.println(\"\\t\\\"props\\\" - path to file with configuration properties\");\n    os.println(\"\\t\\\"annotators\\\" - comma separated list of annotators\");\n    os.println(\"\\tThe following annotators are supported: cleanxml, tokenize, ssplit, pos, lemma, ner, truecase, parse, coref, dcoref, nfl\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"tokenize\\\" is defined:\");\n    os.println(\"\\t\\\"tokenize.options\\\" - PTBTokenizer options (see edu.stanford.nlp.process.PTBTokenizer for details)\");\n    os.println(\"\\t\\\"tokenize.whitespace\\\" - If true, just use whitespace tokenization\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"cleanxml\\\" is defined:\");\n    os.println(\"\\t\\\"clean.xmltags\\\" - regex of tags to extract text from\");\n    os.println(\"\\t\\\"clean.sentenceendingtags\\\" - regex of tags which mark sentence endings\");\n    os.println(\"\\t\\\"clean.allowflawedxml\\\" - if set to true, don't complain about XML errors\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"pos\\\" is defined:\");\n    os.println(\"\\t\\\"pos.maxlen\\\" - maximum length of sentence to POS tag\");\n    os.println(\"\\t\\\"pos.model\\\" - path towards the POS tagger model\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"ner\\\" is defined:\");\n    os.println(\"\\t\\\"ner.model.3class\\\" - path towards the three-class NER model\");\n    os.println(\"\\t\\\"ner.model.7class\\\" - path towards the seven-class NER model\");\n    os.println(\"\\t\\\"ner.model.MISCclass\\\" - path towards the NER model with a MISC class\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"truecase\\\" is defined:\");\n    os.println(\"\\t\\\"truecase.model\\\" - path towards the true-casing model; default: \" + DefaultPaths.DEFAULT_TRUECASE_MODEL);\n    os.println(\"\\t\\\"truecase.bias\\\" - class bias of the true case model; default: \" + TrueCaseAnnotator.DEFAULT_MODEL_BIAS);\n    os.println(\"\\t\\\"truecase.mixedcasefile\\\" - path towards the mixed case file; default: \" + DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"nfl\\\" is defined:\");\n    os.println(\"\\t\\\"nfl.gazetteer\\\" - path towards the gazetteer for the NFL domain\");\n    os.println(\"\\t\\\"nfl.relation.model\\\" - path towards the NFL relation extraction model\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"parse\\\" is defined:\");\n    os.println(\"\\t\\\"parse.model\\\" - path towards the PCFG parser model\");\n\n    /* XXX: unstable, do not use for now\n    os.println();\n    os.println(\"\\tIf annotator \\\"srl\\\" is defined:\");\n    os.println(\"\\t\\\"srl.verb.args\\\" - path to the file listing verbs and their core arguments (\\\"verbs.core_args\\\")\");\n    os.println(\"\\t\\\"srl.model.id\\\" - path prefix for the role identification model (adds \\\".model.gz\\\" and \\\".fe\\\" to this prefix)\");\n    os.println(\"\\t\\\"srl.model.cls\\\" - path prefix for the role classification model (adds \\\".model.gz\\\" and \\\".fe\\\" to this prefix)\");\n    os.println(\"\\t\\\"srl.model.jic\\\" - path to the directory containing the joint model's \\\"model.gz\\\", \\\"fe\\\" and \\\"je\\\" files\");\n    os.println(\"\\t                  (if not specified, the joint model will not be used)\");\n    */\n\n    os.println();\n    os.println(\"Command line properties:\");\n    os.println(\"\\t\\\"file\\\" - run the pipeline on the content of this file, or on the content of the files in this directory\");\n    os.println(\"\\t         XML output is generated for every input file \\\"file\\\" as file.xml\");\n    os.println(\"\\t\\\"extension\\\" - if -file used with a directory, process only the files with this extension\");\n    os.println(\"\\t\\\"filelist\\\" - run the pipeline on the list of files given in this file\");\n    os.println(\"\\t             output is generated for every input file as file.outputExtension\");\n    os.println(\"\\t\\\"outputDirectory\\\" - where to put output (defaults to the current directory)\");\n    os.println(\"\\t\\\"outputExtension\\\" - extension to use for the output file (defaults to \\\".xml\\\" for XML, \\\".ser.gz\\\" for serialized).  Don't forget the dot!\");\n    os.println(\"\\t\\\"outputFormat\\\" - \\\"xml\\\" to output XML (default), \\\"serialized\\\" to output serialized Java objects, \\\"text\\\" to output text\");\n    os.println(\"\\t\\\"serializer\\\" - Class of annotation serializer to use when outputFormat is \\\"serialized\\\".  By default, uses Java serialization.\");\n    os.println(\"\\t\\\"replaceExtension\\\" - flag to chop off the last extension before adding outputExtension to file\");\n    os.println(\"\\t\\\"noClobber\\\" - don't automatically override (clobber) output files that already exist\");\n\t\tos.println(\"\\t\\\"threads\\\" - multithread on this number of threads\");\n    os.println();\n    os.println(\"If none of the above are present, run the pipeline in an interactive shell (default properties will be loaded from the classpath).\");\n    os.println(\"The shell accepts input from stdin and displays the output at stdout.\");\n\n    os.println();\n    os.println(\"Run with -help [topic] for more help on a specific topic.\");\n    os.println(\"Current topics include: parser\");\n\n    os.println();\n  }","id":6599,"modified_method":"/**\n   * Prints the list of properties required to run the pipeline\n   * @param os PrintStream to print usage to\n   */\n  private static void printRequiredProperties(PrintStream os) {\n    // TODO some annotators (ssplit, regexner, gender, some parser options, dcoref?) are not documented\n    os.println(\"The following properties can be defined:\");\n    os.println(\"(if -props or -annotators is not passed in, default properties will be loaded via the classpath)\");\n    os.println(\"\\t\\\"props\\\" - path to file with configuration properties\");\n    os.println(\"\\t\\\"annotators\\\" - comma separated list of annotators\");\n    os.println(\"\\tThe following annotators are supported: cleanxml, tokenize, ssplit, pos, lemma, ner, truecase, parse, coref, dcoref, relation\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"tokenize\\\" is defined:\");\n    os.println(\"\\t\\\"tokenize.options\\\" - PTBTokenizer options (see edu.stanford.nlp.process.PTBTokenizer for details)\");\n    os.println(\"\\t\\\"tokenize.whitespace\\\" - If true, just use whitespace tokenization\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"cleanxml\\\" is defined:\");\n    os.println(\"\\t\\\"clean.xmltags\\\" - regex of tags to extract text from\");\n    os.println(\"\\t\\\"clean.sentenceendingtags\\\" - regex of tags which mark sentence endings\");\n    os.println(\"\\t\\\"clean.allowflawedxml\\\" - if set to true, don't complain about XML errors\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"pos\\\" is defined:\");\n    os.println(\"\\t\\\"pos.maxlen\\\" - maximum length of sentence to POS tag\");\n    os.println(\"\\t\\\"pos.model\\\" - path towards the POS tagger model\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"ner\\\" is defined:\");\n    os.println(\"\\t\\\"ner.model.3class\\\" - path towards the three-class NER model\");\n    os.println(\"\\t\\\"ner.model.7class\\\" - path towards the seven-class NER model\");\n    os.println(\"\\t\\\"ner.model.MISCclass\\\" - path towards the NER model with a MISC class\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"truecase\\\" is defined:\");\n    os.println(\"\\t\\\"truecase.model\\\" - path towards the true-casing model; default: \" + DefaultPaths.DEFAULT_TRUECASE_MODEL);\n    os.println(\"\\t\\\"truecase.bias\\\" - class bias of the true case model; default: \" + TrueCaseAnnotator.DEFAULT_MODEL_BIAS);\n    os.println(\"\\t\\\"truecase.mixedcasefile\\\" - path towards the mixed case file; default: \" + DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"relation\\\" is defined:\");\n    os.println(\"\\t\\\"sup.relation.verbose\\\" - whether verbose or not\");\n    os.println(\"\\t\\\"sup.relation.model\\\" - path towards the relation extraction model\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"parse\\\" is defined:\");\n    os.println(\"\\t\\\"parse.model\\\" - path towards the PCFG parser model\");\n\n    /* XXX: unstable, do not use for now\n    os.println();\n    os.println(\"\\tIf annotator \\\"srl\\\" is defined:\");\n    os.println(\"\\t\\\"srl.verb.args\\\" - path to the file listing verbs and their core arguments (\\\"verbs.core_args\\\")\");\n    os.println(\"\\t\\\"srl.model.id\\\" - path prefix for the role identification model (adds \\\".model.gz\\\" and \\\".fe\\\" to this prefix)\");\n    os.println(\"\\t\\\"srl.model.cls\\\" - path prefix for the role classification model (adds \\\".model.gz\\\" and \\\".fe\\\" to this prefix)\");\n    os.println(\"\\t\\\"srl.model.jic\\\" - path to the directory containing the joint model's \\\"model.gz\\\", \\\"fe\\\" and \\\"je\\\" files\");\n    os.println(\"\\t                  (if not specified, the joint model will not be used)\");\n    */\n\n    os.println();\n    os.println(\"Command line properties:\");\n    os.println(\"\\t\\\"file\\\" - run the pipeline on the content of this file, or on the content of the files in this directory\");\n    os.println(\"\\t         XML output is generated for every input file \\\"file\\\" as file.xml\");\n    os.println(\"\\t\\\"extension\\\" - if -file used with a directory, process only the files with this extension\");\n    os.println(\"\\t\\\"filelist\\\" - run the pipeline on the list of files given in this file\");\n    os.println(\"\\t             output is generated for every input file as file.outputExtension\");\n    os.println(\"\\t\\\"outputDirectory\\\" - where to put output (defaults to the current directory)\");\n    os.println(\"\\t\\\"outputExtension\\\" - extension to use for the output file (defaults to \\\".xml\\\" for XML, \\\".ser.gz\\\" for serialized).  Don't forget the dot!\");\n    os.println(\"\\t\\\"outputFormat\\\" - \\\"xml\\\" to output XML (default), \\\"serialized\\\" to output serialized Java objects, \\\"text\\\" to output text\");\n    os.println(\"\\t\\\"serializer\\\" - Class of annotation serializer to use when outputFormat is \\\"serialized\\\".  By default, uses Java serialization.\");\n    os.println(\"\\t\\\"replaceExtension\\\" - flag to chop off the last extension before adding outputExtension to file\");\n    os.println(\"\\t\\\"noClobber\\\" - don't automatically override (clobber) output files that already exist\");\n\t\tos.println(\"\\t\\\"threads\\\" - multithread on this number of threads\");\n    os.println();\n    os.println(\"If none of the above are present, run the pipeline in an interactive shell (default properties will be loaded from the classpath).\");\n    os.println(\"The shell accepts input from stdin and displays the output at stdout.\");\n\n    os.println();\n    os.println(\"Run with -help [topic] for more help on a specific topic.\");\n    os.println(\"Current topics include: parser\");\n\n    os.println();\n  }","commit_id":"c4a22d77d46a69177c53e687a383434c507d3c2e","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private void construct(Properties props, boolean enforceRequirements) {\n    this.numWords = 0;\n    this.constituentTreePrinter = new TreePrint(\"penn\");\n    this.dependencyTreePrinter = new TreePrint(\"typedDependenciesCollapsed\");\n\n    if (props == null) {\n      // if undefined, find the properties file in the classpath\n      props = loadPropertiesFromClasspath();\n    } else if (props.getProperty(\"annotators\") == null) {\n      // this happens when some command line options are specified (e.g just \"-filelist\") but no properties file is.\n      // we use the options that are given and let them override the default properties from the class path properties.\n      Properties fromClassPath = loadPropertiesFromClasspath();\n      fromClassPath.putAll(props);\n      props = fromClassPath;\n    }\n    this.properties = props;\n    AnnotatorPool pool = getDefaultAnnotatorPool(props);\n\n    // now construct the annotators from the given properties in the given order\n    List<String> annoNames = Arrays.asList(getRequiredProperty(props, \"annotators\").split(\"[, \\t]+\"));\n    Set<String> alreadyAddedAnnoNames = Generics.newHashSet();\n    Set<Requirement> requirementsSatisfied = Generics.newHashSet();\n    for (String name : annoNames) {\n      name = name.trim();\n      if (name.isEmpty()) { continue; }\n      System.err.println(\"Adding annotator \" + name);\n\n      Annotator an = pool.get(name);\n      this.addAnnotator(an);\n\n      if (enforceRequirements) {\n        Set<Requirement> allRequirements = an.requires();\n        for (Requirement requirement : allRequirements) {\n          if (!requirementsSatisfied.contains(requirement)) {\n            String fmt = \"annotator \\\"%s\\\" requires annotator \\\"%s\\\"\";\n            throw new IllegalArgumentException(String.format(fmt, name, requirement));\n          }\n        }\n        requirementsSatisfied.addAll(an.requirementsSatisfied());\n      }\n\n      // the NFL domain requires several post-processing rules after\n      // tokenization.  add these transparently if the NFL annotator\n      // is required\n      if (name.equals(STANFORD_TOKENIZE) &&\n          annoNames.contains(STANFORD_NFL) &&\n          !annoNames.contains(STANFORD_NFL_TOKENIZE)) {\n        Annotator pp = pool.get(STANFORD_NFL_TOKENIZE);\n        this.addAnnotator(pp);\n      }\n\n      alreadyAddedAnnoNames.add(name);\n    }\n\n    // Sanity check\n    if (! alreadyAddedAnnoNames.contains(STANFORD_SSPLIT)) {\n      System.setProperty(NEWLINE_SPLITTER_PROPERTY, \"false\");\n    }\n  }","id":6600,"modified_method":"private void construct(Properties props, boolean enforceRequirements) {\n    this.numWords = 0;\n    this.constituentTreePrinter = new TreePrint(\"penn\");\n    this.dependencyTreePrinter = new TreePrint(\"typedDependenciesCollapsed\");\n\n    if (props == null) {\n      // if undefined, find the properties file in the classpath\n      props = loadPropertiesFromClasspath();\n    } else if (props.getProperty(\"annotators\") == null) {\n      // this happens when some command line options are specified (e.g just \"-filelist\") but no properties file is.\n      // we use the options that are given and let them override the default properties from the class path properties.\n      Properties fromClassPath = loadPropertiesFromClasspath();\n      fromClassPath.putAll(props);\n      props = fromClassPath;\n    }\n    this.properties = props;\n    AnnotatorPool pool = getDefaultAnnotatorPool(props);\n\n    // now construct the annotators from the given properties in the given order\n    List<String> annoNames = Arrays.asList(getRequiredProperty(props, \"annotators\").split(\"[, \\t]+\"));\n    Set<String> alreadyAddedAnnoNames = Generics.newHashSet();\n    Set<Requirement> requirementsSatisfied = Generics.newHashSet();\n    for (String name : annoNames) {\n      name = name.trim();\n      if (name.isEmpty()) { continue; }\n      System.err.println(\"Adding annotator \" + name);\n\n      Annotator an = pool.get(name);\n      this.addAnnotator(an);\n\n      if (enforceRequirements) {\n        Set<Requirement> allRequirements = an.requires();\n        for (Requirement requirement : allRequirements) {\n          if (!requirementsSatisfied.contains(requirement)) {\n            String fmt = \"annotator \\\"%s\\\" requires annotator \\\"%s\\\"\";\n            throw new IllegalArgumentException(String.format(fmt, name, requirement));\n          }\n        }\n        requirementsSatisfied.addAll(an.requirementsSatisfied());\n      }\n\n\n      alreadyAddedAnnoNames.add(name);\n    }\n\n    // Sanity check\n    if (! alreadyAddedAnnoNames.contains(STANFORD_SSPLIT)) {\n      System.setProperty(NEWLINE_SPLITTER_PROPERTY, \"false\");\n    }\n  }","commit_id":"c4a22d77d46a69177c53e687a383434c507d3c2e","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private void construct(Properties props, boolean enforceRequirements) {\n    this.numWords = 0;\n    this.constituentTreePrinter = new TreePrint(\"penn\");\n    this.dependencyTreePrinter = new TreePrint(\"typedDependenciesCollapsed\");\n\n    if (props == null) {\n      // if undefined, find the properties file in the classpath\n      props = loadPropertiesFromClasspath();\n    } else if (props.getProperty(\"annotators\") == null) {\n      // this happens when some command line options are specified (e.g just \"-filelist\") but no properties file is.\n      // we use the options that are given and let them override the default properties from the class path properties.\n      Properties fromClassPath = loadPropertiesFromClasspath();\n      fromClassPath.putAll(props);\n      props = fromClassPath;\n    }\n    this.properties = props;\n    AnnotatorPool pool = getDefaultAnnotatorPool(props);\n\n    // now construct the annotators from the given properties in the given order\n    List<String> annoNames = Arrays.asList(getRequiredProperty(props, \"annotators\").split(\"[, \\t]+\"));\n    Set<String> alreadyAddedAnnoNames = Generics.newHashSet();\n    Set<Requirement> requirementsSatisfied = Generics.newHashSet();\n    for (String name : annoNames) {\n      name = name.trim();\n      if (name.isEmpty()) { continue; }\n      System.err.println(\"Adding annotator \" + name);\n\n      Annotator an = pool.get(name);\n      this.addAnnotator(an);\n\n      if (enforceRequirements) {\n        Set<Requirement> allRequirements = an.requires();\n        for (Requirement requirement : allRequirements) {\n          if (!requirementsSatisfied.contains(requirement)) {\n            String fmt = \"annotator \\\"%s\\\" requires annotator \\\"%s\\\"\";\n            throw new IllegalArgumentException(String.format(fmt, name, requirement));\n          }\n        }\n        requirementsSatisfied.addAll(an.requirementsSatisfied());\n      }\n\n      // the NFL domain requires several post-processing rules after\n      // tokenization.  add these transparently if the NFL annotator\n      // is required\n      if (name.equals(STANFORD_TOKENIZE) &&\n          annoNames.contains(STANFORD_NFL) &&\n          !annoNames.contains(STANFORD_NFL_TOKENIZE)) {\n        Annotator pp = pool.get(STANFORD_NFL_TOKENIZE);\n        this.addAnnotator(pp);\n      }\n\n      alreadyAddedAnnoNames.add(name);\n    }\n\n    // Sanity check\n    if (! alreadyAddedAnnoNames.contains(STANFORD_SSPLIT)) {\n      System.setProperty(NEWLINE_SPLITTER_PROPERTY, \"false\");\n    }\n  }","id":6601,"modified_method":"private void construct(Properties props, boolean enforceRequirements) {\n    this.numWords = 0;\n    this.constituentTreePrinter = new TreePrint(\"penn\");\n    this.dependencyTreePrinter = new TreePrint(\"typedDependenciesCollapsed\");\n\n    if (props == null) {\n      // if undefined, find the properties file in the classpath\n      props = loadPropertiesFromClasspath();\n    } else if (props.getProperty(\"annotators\") == null) {\n      // this happens when some command line options are specified (e.g just \"-filelist\") but no properties file is.\n      // we use the options that are given and let them override the default properties from the class path properties.\n      Properties fromClassPath = loadPropertiesFromClasspath();\n      fromClassPath.putAll(props);\n      props = fromClassPath;\n    }\n    this.properties = props;\n    AnnotatorPool pool = getDefaultAnnotatorPool(props);\n\n    // now construct the annotators from the given properties in the given order\n    List<String> annoNames = Arrays.asList(getRequiredProperty(props, \"annotators\").split(\"[, \\t]+\"));\n    Set<String> alreadyAddedAnnoNames = Generics.newHashSet();\n    Set<Requirement> requirementsSatisfied = Generics.newHashSet();\n    for (String name : annoNames) {\n      name = name.trim();\n      if (name.isEmpty()) { continue; }\n      System.err.println(\"Adding annotator \" + name);\n\n      Annotator an = pool.get(name);\n      this.addAnnotator(an);\n\n      if (enforceRequirements) {\n        Set<Requirement> allRequirements = an.requires();\n        for (Requirement requirement : allRequirements) {\n          if (!requirementsSatisfied.contains(requirement)) {\n            String fmt = \"annotator \\\"%s\\\" requires annotator \\\"%s\\\"\";\n            throw new IllegalArgumentException(String.format(fmt, name, requirement));\n          }\n        }\n        requirementsSatisfied.addAll(an.requirementsSatisfied());\n      }\n\n\n      alreadyAddedAnnoNames.add(name);\n    }\n\n    // Sanity check\n    if (! alreadyAddedAnnoNames.contains(STANFORD_SSPLIT)) {\n      System.setProperty(NEWLINE_SPLITTER_PROPERTY, \"false\");\n    }\n  }","commit_id":"3832346aab66a19293177272a2417d97f083e462","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Prints the list of properties required to run the pipeline\n   * @param os PrintStream to print usage to\n   */\n  private static void printRequiredProperties(PrintStream os) {\n    // TODO some annotators (ssplit, regexner, gender, some parser options, dcoref?) are not documented\n    os.println(\"The following properties can be defined:\");\n    os.println(\"(if -props or -annotators is not passed in, default properties will be loaded via the classpath)\");\n    os.println(\"\\t\\\"props\\\" - path to file with configuration properties\");\n    os.println(\"\\t\\\"annotators\\\" - comma separated list of annotators\");\n    os.println(\"\\tThe following annotators are supported: cleanxml, tokenize, ssplit, pos, lemma, ner, truecase, parse, coref, dcoref, nfl\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"tokenize\\\" is defined:\");\n    os.println(\"\\t\\\"tokenize.options\\\" - PTBTokenizer options (see edu.stanford.nlp.process.PTBTokenizer for details)\");\n    os.println(\"\\t\\\"tokenize.whitespace\\\" - If true, just use whitespace tokenization\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"cleanxml\\\" is defined:\");\n    os.println(\"\\t\\\"clean.xmltags\\\" - regex of tags to extract text from\");\n    os.println(\"\\t\\\"clean.sentenceendingtags\\\" - regex of tags which mark sentence endings\");\n    os.println(\"\\t\\\"clean.allowflawedxml\\\" - if set to true, don't complain about XML errors\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"pos\\\" is defined:\");\n    os.println(\"\\t\\\"pos.maxlen\\\" - maximum length of sentence to POS tag\");\n    os.println(\"\\t\\\"pos.model\\\" - path towards the POS tagger model\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"ner\\\" is defined:\");\n    os.println(\"\\t\\\"ner.model.3class\\\" - path towards the three-class NER model\");\n    os.println(\"\\t\\\"ner.model.7class\\\" - path towards the seven-class NER model\");\n    os.println(\"\\t\\\"ner.model.MISCclass\\\" - path towards the NER model with a MISC class\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"truecase\\\" is defined:\");\n    os.println(\"\\t\\\"truecase.model\\\" - path towards the true-casing model; default: \" + DefaultPaths.DEFAULT_TRUECASE_MODEL);\n    os.println(\"\\t\\\"truecase.bias\\\" - class bias of the true case model; default: \" + TrueCaseAnnotator.DEFAULT_MODEL_BIAS);\n    os.println(\"\\t\\\"truecase.mixedcasefile\\\" - path towards the mixed case file; default: \" + DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"nfl\\\" is defined:\");\n    os.println(\"\\t\\\"nfl.gazetteer\\\" - path towards the gazetteer for the NFL domain\");\n    os.println(\"\\t\\\"nfl.relation.model\\\" - path towards the NFL relation extraction model\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"parse\\\" is defined:\");\n    os.println(\"\\t\\\"parse.model\\\" - path towards the PCFG parser model\");\n\n    /* XXX: unstable, do not use for now\n    os.println();\n    os.println(\"\\tIf annotator \\\"srl\\\" is defined:\");\n    os.println(\"\\t\\\"srl.verb.args\\\" - path to the file listing verbs and their core arguments (\\\"verbs.core_args\\\")\");\n    os.println(\"\\t\\\"srl.model.id\\\" - path prefix for the role identification model (adds \\\".model.gz\\\" and \\\".fe\\\" to this prefix)\");\n    os.println(\"\\t\\\"srl.model.cls\\\" - path prefix for the role classification model (adds \\\".model.gz\\\" and \\\".fe\\\" to this prefix)\");\n    os.println(\"\\t\\\"srl.model.jic\\\" - path to the directory containing the joint model's \\\"model.gz\\\", \\\"fe\\\" and \\\"je\\\" files\");\n    os.println(\"\\t                  (if not specified, the joint model will not be used)\");\n    */\n\n    os.println();\n    os.println(\"Command line properties:\");\n    os.println(\"\\t\\\"file\\\" - run the pipeline on the content of this file, or on the content of the files in this directory\");\n    os.println(\"\\t         XML output is generated for every input file \\\"file\\\" as file.xml\");\n    os.println(\"\\t\\\"extension\\\" - if -file used with a directory, process only the files with this extension\");\n    os.println(\"\\t\\\"filelist\\\" - run the pipeline on the list of files given in this file\");\n    os.println(\"\\t             output is generated for every input file as file.outputExtension\");\n    os.println(\"\\t\\\"outputDirectory\\\" - where to put output (defaults to the current directory)\");\n    os.println(\"\\t\\\"outputExtension\\\" - extension to use for the output file (defaults to \\\".xml\\\" for XML, \\\".ser.gz\\\" for serialized).  Don't forget the dot!\");\n    os.println(\"\\t\\\"outputFormat\\\" - \\\"xml\\\" to output XML (default), \\\"serialized\\\" to output serialized Java objects, \\\"text\\\" to output text\");\n    os.println(\"\\t\\\"serializer\\\" - Class of annotation serializer to use when outputFormat is \\\"serialized\\\".  By default, uses Java serialization.\");\n    os.println(\"\\t\\\"replaceExtension\\\" - flag to chop off the last extension before adding outputExtension to file\");\n    os.println(\"\\t\\\"noClobber\\\" - don't automatically override (clobber) output files that already exist\");\n\t\tos.println(\"\\t\\\"threads\\\" - multithread on this number of threads\");\n    os.println();\n    os.println(\"If none of the above are present, run the pipeline in an interactive shell (default properties will be loaded from the classpath).\");\n    os.println(\"The shell accepts input from stdin and displays the output at stdout.\");\n\n    os.println();\n    os.println(\"Run with -help [topic] for more help on a specific topic.\");\n    os.println(\"Current topics include: parser\");\n\n    os.println();\n  }","id":6602,"modified_method":"/**\n   * Prints the list of properties required to run the pipeline\n   * @param os PrintStream to print usage to\n   */\n  private static void printRequiredProperties(PrintStream os) {\n    // TODO some annotators (ssplit, regexner, gender, some parser options, dcoref?) are not documented\n    os.println(\"The following properties can be defined:\");\n    os.println(\"(if -props or -annotators is not passed in, default properties will be loaded via the classpath)\");\n    os.println(\"\\t\\\"props\\\" - path to file with configuration properties\");\n    os.println(\"\\t\\\"annotators\\\" - comma separated list of annotators\");\n    os.println(\"\\tThe following annotators are supported: cleanxml, tokenize, ssplit, pos, lemma, ner, truecase, parse, coref, dcoref, relation\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"tokenize\\\" is defined:\");\n    os.println(\"\\t\\\"tokenize.options\\\" - PTBTokenizer options (see edu.stanford.nlp.process.PTBTokenizer for details)\");\n    os.println(\"\\t\\\"tokenize.whitespace\\\" - If true, just use whitespace tokenization\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"cleanxml\\\" is defined:\");\n    os.println(\"\\t\\\"clean.xmltags\\\" - regex of tags to extract text from\");\n    os.println(\"\\t\\\"clean.sentenceendingtags\\\" - regex of tags which mark sentence endings\");\n    os.println(\"\\t\\\"clean.allowflawedxml\\\" - if set to true, don't complain about XML errors\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"pos\\\" is defined:\");\n    os.println(\"\\t\\\"pos.maxlen\\\" - maximum length of sentence to POS tag\");\n    os.println(\"\\t\\\"pos.model\\\" - path towards the POS tagger model\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"ner\\\" is defined:\");\n    os.println(\"\\t\\\"ner.model.3class\\\" - path towards the three-class NER model\");\n    os.println(\"\\t\\\"ner.model.7class\\\" - path towards the seven-class NER model\");\n    os.println(\"\\t\\\"ner.model.MISCclass\\\" - path towards the NER model with a MISC class\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"truecase\\\" is defined:\");\n    os.println(\"\\t\\\"truecase.model\\\" - path towards the true-casing model; default: \" + DefaultPaths.DEFAULT_TRUECASE_MODEL);\n    os.println(\"\\t\\\"truecase.bias\\\" - class bias of the true case model; default: \" + TrueCaseAnnotator.DEFAULT_MODEL_BIAS);\n    os.println(\"\\t\\\"truecase.mixedcasefile\\\" - path towards the mixed case file; default: \" + DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"relation\\\" is defined:\");\n    os.println(\"\\t\\\"sup.relation.verbose\\\" - whether verbose or not\");\n    os.println(\"\\t\\\"sup.relation.model\\\" - path towards the relation extraction model\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"parse\\\" is defined:\");\n    os.println(\"\\t\\\"parse.model\\\" - path towards the PCFG parser model\");\n\n    /* XXX: unstable, do not use for now\n    os.println();\n    os.println(\"\\tIf annotator \\\"srl\\\" is defined:\");\n    os.println(\"\\t\\\"srl.verb.args\\\" - path to the file listing verbs and their core arguments (\\\"verbs.core_args\\\")\");\n    os.println(\"\\t\\\"srl.model.id\\\" - path prefix for the role identification model (adds \\\".model.gz\\\" and \\\".fe\\\" to this prefix)\");\n    os.println(\"\\t\\\"srl.model.cls\\\" - path prefix for the role classification model (adds \\\".model.gz\\\" and \\\".fe\\\" to this prefix)\");\n    os.println(\"\\t\\\"srl.model.jic\\\" - path to the directory containing the joint model's \\\"model.gz\\\", \\\"fe\\\" and \\\"je\\\" files\");\n    os.println(\"\\t                  (if not specified, the joint model will not be used)\");\n    */\n\n    os.println();\n    os.println(\"Command line properties:\");\n    os.println(\"\\t\\\"file\\\" - run the pipeline on the content of this file, or on the content of the files in this directory\");\n    os.println(\"\\t         XML output is generated for every input file \\\"file\\\" as file.xml\");\n    os.println(\"\\t\\\"extension\\\" - if -file used with a directory, process only the files with this extension\");\n    os.println(\"\\t\\\"filelist\\\" - run the pipeline on the list of files given in this file\");\n    os.println(\"\\t             output is generated for every input file as file.outputExtension\");\n    os.println(\"\\t\\\"outputDirectory\\\" - where to put output (defaults to the current directory)\");\n    os.println(\"\\t\\\"outputExtension\\\" - extension to use for the output file (defaults to \\\".xml\\\" for XML, \\\".ser.gz\\\" for serialized).  Don't forget the dot!\");\n    os.println(\"\\t\\\"outputFormat\\\" - \\\"xml\\\" to output XML (default), \\\"serialized\\\" to output serialized Java objects, \\\"text\\\" to output text\");\n    os.println(\"\\t\\\"serializer\\\" - Class of annotation serializer to use when outputFormat is \\\"serialized\\\".  By default, uses Java serialization.\");\n    os.println(\"\\t\\\"replaceExtension\\\" - flag to chop off the last extension before adding outputExtension to file\");\n    os.println(\"\\t\\\"noClobber\\\" - don't automatically override (clobber) output files that already exist\");\n\t\tos.println(\"\\t\\\"threads\\\" - multithread on this number of threads\");\n    os.println();\n    os.println(\"If none of the above are present, run the pipeline in an interactive shell (default properties will be loaded from the classpath).\");\n    os.println(\"The shell accepts input from stdin and displays the output at stdout.\");\n\n    os.println();\n    os.println(\"Run with -help [topic] for more help on a specific topic.\");\n    os.println(\"Current topics include: parser\");\n\n    os.println();\n  }","commit_id":"3832346aab66a19293177272a2417d97f083e462","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static synchronized AnnotatorPool getDefaultAnnotatorPool(final Properties inputProps) {\n    // if the pool already exists reuse!\n    if(pool == null) {\n      // first time we get here\n      pool = new AnnotatorPool();\n    }\n\n    //\n    // tokenizer: breaks text into a sequence of tokens\n    // this is required for all following annotators!\n    //\n    pool.register(STANFORD_TOKENIZE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                          \"false\"))) {\n          return new WhitespaceTokenizerAnnotator(properties);\n        } else {\n          String options = properties.getProperty(\"tokenize.options\",\n                  PTBTokenizerAnnotator.DEFAULT_OPTIONS);\n          boolean keepNewline =\n                  Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                          \"false\"));\n          // If the user specifies \"tokenizeNLs=false\" in tokenize.options, then this default will\n          // be overridden.\n          if (keepNewline) {\n            options = \"tokenizeNLs,\" + options;\n          }\n          return new PTBTokenizerAnnotator(false, options);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(\"tokenize.whitespace:\" +\n                properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                \"false\"))) {\n          os.append(WhitespaceTokenizerAnnotator.EOL_PROPERTY + \":\" +\n                  properties.getProperty(WhitespaceTokenizerAnnotator.EOL_PROPERTY,\n                          \"false\"));\n          os.append(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  properties.getProperty(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY,\n                          \"false\"));\n          return os.toString();\n        } else {\n          os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                          \"false\")));\n        }\n        return os.toString();\n      }\n    });\n\n    pool.register(STANFORD_CLEAN_XML, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String xmlTags =\n          properties.getProperty(\"clean.xmltags\",\n                            CleanXmlAnnotator.DEFAULT_XML_TAGS);\n        String sentenceEndingTags =\n          properties.getProperty(\"clean.sentenceendingtags\",\n                            CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS);\n        String singleSentenceTags =\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS);\n        String allowFlawedString = properties.getProperty(\"clean.allowflawedxml\");\n        boolean allowFlawed = CleanXmlAnnotator.DEFAULT_ALLOW_FLAWS;\n        if (allowFlawedString != null)\n          allowFlawed = Boolean.valueOf(allowFlawedString);\n        String dateTags =\n          properties.getProperty(\"clean.datetags\",\n                            CleanXmlAnnotator.DEFAULT_DATE_TAGS);\n        String docIdTags =\n                properties.getProperty(\"clean.docIdtags\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS);\n        String docTypeTags =\n                properties.getProperty(\"clean.docTypetags\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS);\n        String utteranceTurnTags =\n                properties.getProperty(\"clean.turntags\",\n                        CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS);\n        String speakerTags =\n                properties.getProperty(\"clean.speakertags\",\n                        CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS);\n        String docAnnotations =\n                properties.getProperty(\"clean.docAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS);\n        String tokenAnnotations =\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS);\n        String sectionTags =\n                properties.getProperty(\"clean.sectiontags\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_TAGS);\n        String sectionAnnotations =\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n        String ssplitDiscardTokens =\n                properties.getProperty(\"clean.ssplitDiscardTokens\");\n        CleanXmlAnnotator annotator = new CleanXmlAnnotator(xmlTags,\n            sentenceEndingTags,\n            dateTags,\n            allowFlawed);\n        annotator.setSingleSentenceTagMatcher(singleSentenceTags);\n        annotator.setDocIdTagMatcher(docIdTags);\n        annotator.setDocTypeTagMatcher(docTypeTags);\n        annotator.setDiscourseTags(utteranceTurnTags, speakerTags);\n        annotator.setDocAnnotationPatterns(docAnnotations);\n        annotator.setTokenAnnotationPatterns(tokenAnnotations);\n        annotator.setSectionTagMatcher(sectionTags);\n        annotator.setSectionAnnotationPatterns(sectionAnnotations);\n        annotator.setSsplitDiscardTokensMatcher(ssplitDiscardTokens);\n        return annotator;\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"clean.xmltags:\" +\n                properties.getProperty(\"clean.xmltags\",\n                  CleanXmlAnnotator.DEFAULT_XML_TAGS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.sentenceendingtags\",\n                  CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS) +\n                \"clean.allowflawedxml:\" +\n                properties.getProperty(\"clean.allowflawedxml\", \"\") +\n                \"clean.datetags:\" +\n                properties.getProperty(\"clean.datetags\",\n                  CleanXmlAnnotator.DEFAULT_DATE_TAGS) +\n                \"clean.docidtags:\" +\n                properties.getProperty(\"clean.docid\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS) +\n                \"clean.doctypetags:\" +\n                properties.getProperty(\"clean.doctype\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS) +\n                \"clean.turntags:\" +\n                properties.getProperty(\"clean.turntags\",\n                  CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS) +\n                \"clean.speakertags:\" +\n                properties.getProperty(\"clean.speakertags\",\n                  CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS) +\n                \"clean.docAnnotations:\" +\n                properties.getProperty(\"clean.docAnnotations\",\n                  CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS) +\n                \"clean.tokenAnnotations:\" +\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS) +\n                \"clean.sectiontags:\" +\n                properties.getProperty(\"clean.sectiontags\",\n                  CleanXmlAnnotator.DEFAULT_SECTION_TAGS) +\n                \"clean.sectionAnnotations:\" +\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n      }\n    });\n\n    //\n    // Sentence splitter: splits the above sequence of tokens into\n    // sentences.  This is required when processing entire documents or\n    // text consisting of multiple sentences.\n    //\n    pool.register(STANFORD_SSPLIT, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        boolean nlSplitting = Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (nlSplitting) {\n          boolean whitespaceTokenization = Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\", \"false\"));\n          if (whitespaceTokenization) {\n            if (System.getProperty(\"line.separator\").equals(\"\\n\")) {\n              return WordsToSentencesAnnotator.newlineSplitter(false, \"\\n\");\n            } else {\n              // throw \"\\n\" in just in case files use that instead of\n              // the system separator\n              return WordsToSentencesAnnotator.newlineSplitter(false, System.getProperty(\"line.separator\"), \"\\n\");\n            }\n          } else {\n            return WordsToSentencesAnnotator.newlineSplitter(false, PTBTokenizer.getNewlineToken());\n          }\n\n        } else {\n          // Treat as one sentence: You get a no-op sentence splitter that always returns all tokens as one sentence.\n          String isOneSentence = properties.getProperty(\"ssplit.isOneSentence\");\n          if (Boolean.parseBoolean(isOneSentence)) { // this method treats null as false\n            return WordsToSentencesAnnotator.nonSplitter(false);\n          }\n\n          // multi token sentence boundaries\n          String boundaryMultiTokenRegex = properties.getProperty(\"ssplit.boundaryMultiTokenRegex\");\n\n          // Discard these tokens without marking them as sentence boundaries\n          String tokenPatternsToDiscardProp = properties.getProperty(\"ssplit.tokenPatternsToDiscard\");\n          Set<String> tokenRegexesToDiscard = null;\n          if (tokenPatternsToDiscardProp != null){\n            String [] toks = tokenPatternsToDiscardProp.split(\",\");\n            tokenRegexesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          // regular boundaries\n          String boundaryTokenRegex = properties.getProperty(\"ssplit.boundaryTokenRegex\");\n          Set<String> boundariesToDiscard = null;\n\n          // newline boundaries which are discarded.\n          String bounds = properties.getProperty(\"ssplit.boundariesToDiscard\");\n          if (bounds != null) {\n            String [] toks = bounds.split(\",\");\n            boundariesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          Set<String> htmlElementsToDiscard = null;\n          // HTML boundaries which are discarded\n          bounds = properties.getProperty(\"ssplit.htmlBoundariesToDiscard\");\n          if (bounds != null) {\n            String [] elements = bounds.split(\",\");\n            htmlElementsToDiscard = Generics.newHashSet(Arrays.asList(elements));\n          }\n          String nlsb = properties.getProperty(\"ssplit.newlineIsSentenceBreak\", \"two\");\n\n          return new WordsToSentencesAnnotator(false, boundaryTokenRegex, boundariesToDiscard, htmlElementsToDiscard,\n                  nlsb, boundaryMultiTokenRegex, tokenRegexesToDiscard);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                \"false\"))) {\n          os.append(\"tokenize.whitespace:\" +\n                  properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        } else {\n          os.append(\"ssplit.isOneSentence:\" +\n                  properties.getProperty(\"ssplit.isOneSentence\", \"false\"));\n          if ( ! Boolean.valueOf(properties.getProperty(\"ssplit.isOneSentence\", \"false\"))) {\n            os.append(\"ssplit.boundaryTokenRegex:\" +\n                    properties.getProperty(\"ssplit.boundaryTokenRegex\", \"\"));\n            os.append(\"ssplit.boundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.boundariesToDiscard\", \"\"));\n            os.append(\"ssplit.htmlBoundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.htmlBoundariesToDiscard\", \"\"));\n            os.append(\"ssplit.newlineIsSentenceBreak:\" +\n                    properties.getProperty(\"ssplit.newlineIsSentenceBreak\", \"two\"));\n          }\n        }\n        return os.toString();\n      }\n    });\n\n    //\n    // POS tagger\n    //\n    pool.register(STANFORD_POS, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        try {\n          return new POSTaggerAnnotator(\"pos\", properties);\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return (\"pos.maxlen:\" + properties.getProperty(\"pos.maxlen\", \"\") +\n                \"pos.model:\" + properties.getProperty(\"pos.model\", DefaultPaths.DEFAULT_POS_MODEL) +\n                \"pos.nthreads:\" + properties.getProperty(\"pos.nthreads\", properties.getProperty(\"nthreads\", \"\")));\n      }\n    });\n\n    //\n    // Lemmatizer\n    //\n    pool.register(STANFORD_LEMMA, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new MorphaAnnotator(false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        // nothing for this one\n        return \"\";\n      }\n    });\n\n    //\n    // NER\n    //\n    pool.register(STANFORD_NER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        List<String> models = new ArrayList<String>();\n        String modelNames = properties.getProperty(\"ner.model\");\n        if (modelNames == null) {\n          modelNames = DefaultPaths.DEFAULT_NER_THREECLASS_MODEL + \",\" + DefaultPaths.DEFAULT_NER_MUC_MODEL + \",\" + DefaultPaths.DEFAULT_NER_CONLL_MODEL;\n        }\n        if (modelNames.length() > 0) {\n          models.addAll(Arrays.asList(modelNames.split(\",\")));\n        }\n        if (models.isEmpty()) {\n          // Allow for no real NER model - can just use numeric classifiers or SUTime.\n          // Have to unset ner.model, so unlikely that people got here by accident.\n          System.err.println(\"WARNING: no NER models specified\");\n        }\n        NERClassifierCombiner nerCombiner;\n        try {\n          boolean applyNumericClassifiers =\n            PropertiesUtils.getBool(properties,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT);\n          boolean useSUTime =\n            PropertiesUtils.getBool(properties,\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                NumberSequenceClassifier.USE_SUTIME_DEFAULT);\n          nerCombiner = new NERClassifierCombiner(applyNumericClassifiers,\n                useSUTime, properties,\n                models.toArray(new String[models.size()]));\n        } catch (FileNotFoundException e) {\n          throw new RuntimeIOException(e);\n        }\n        return new NERCombinerAnnotator(nerCombiner, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"ner.model:\" +\n                properties.getProperty(\"ner.model\", \"\") +\n                \"ner.model.3class:\" +\n                properties.getProperty(\"ner.model.3class\",\n                        DefaultPaths.DEFAULT_NER_THREECLASS_MODEL) +\n                \"ner.model.7class:\" +\n                properties.getProperty(\"ner.model.7class\",\n                        DefaultPaths.DEFAULT_NER_MUC_MODEL) +\n                \"ner.model.MISCclass:\" +\n                properties.getProperty(\"ner.model.MISCclass\",\n                        DefaultPaths.DEFAULT_NER_CONLL_MODEL) +\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY + \":\" +\n                properties.getProperty(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                        Boolean.toString(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT)) +\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY + \":\" +\n                properties.getProperty(NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                        Boolean.toString(NumberSequenceClassifier.USE_SUTIME_DEFAULT));\n      }\n    });\n\n    //\n    // Regex NER\n    //\n    pool.register(STANFORD_REGEXNER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new TokensRegexNERAnnotator(\"regexner\", properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return PropertiesUtils.getSignature(\"regexner\", properties, TokensRegexNERAnnotator.SUPPORTED_PROPERTIES);\n      }\n    });\n\n    //\n    // Gender Annotator\n    //\n    pool.register(STANFORD_GENDER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new GenderAnnotator(false, properties.getProperty(\"gender.firstnames\", DefaultPaths.DEFAULT_GENDER_FIRST_NAMES));\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"gender.firstnames:\" +\n                properties.getProperty(\"gender.firstnames\",\n                        DefaultPaths.DEFAULT_GENDER_FIRST_NAMES);\n      }\n    });\n\n\n    //\n    // True caser\n    //\n    pool.register(STANFORD_TRUECASE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String model = properties.getProperty(\"truecase.model\", DefaultPaths.DEFAULT_TRUECASE_MODEL);\n        String bias = properties.getProperty(\"truecase.bias\", TrueCaseAnnotator.DEFAULT_MODEL_BIAS);\n        String mixed = properties.getProperty(\"truecase.mixedcasefile\", DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n        return new TrueCaseAnnotator(model, bias, mixed, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"truecase.model:\" +\n                properties.getProperty(\"truecase.model\",\n                        DefaultPaths.DEFAULT_TRUECASE_MODEL) +\n                \"truecase.bias:\" +\n                properties.getProperty(\"truecase.bias\",\n                        TrueCaseAnnotator.DEFAULT_MODEL_BIAS) +\n                \"truecase.mixedcasefile:\" +\n                properties.getProperty(\"truecase.mixedcasefile\",\n                        DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n      }\n    });\n\n    //\n    // Post-processing tokenization rules for the NFL domain\n    //\n    pool.register(STANFORD_NFL_TOKENIZE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        final String className =\n          \"edu.stanford.nlp.pipeline.NFLTokenizerAnnotator\";\n        return ReflectionLoading.loadByReflection(className);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        // no used props for this one\n        return \"\";\n      }\n    });\n\n    //\n    // Entity and relation extraction for the NFL domain\n    //\n    pool.register(STANFORD_NFL, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        // these paths now extracted inside c'tor\n        // String gazetteer = properties.getProperty(\"nfl.gazetteer\", DefaultPaths.DEFAULT_NFL_GAZETTEER);\n        // String entityModel = properties.getProperty(\"nfl.entity.model\", DefaultPaths.DEFAULT_NFL_ENTITY_MODEL);\n        // String relationModel = properties.getProperty(\"nfl.relation.model\", DefaultPaths.DEFAULT_NFL_RELATION_MODEL);\n        final String className = \"edu.stanford.nlp.pipeline.NFLAnnotator\";\n        return ReflectionLoading.loadByReflection(className, properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"nfl.verbose:\" +\n                properties.getProperty(\"nfl.verbose\",\n                        \"false\") +\n                \"nfl.relations.use.max.recall:\" +\n                properties.getProperty(\"nfl.relations.use.max.recall\",\n                        \"false\") +\n                \"nfl.relations.use.model.merging:\" +\n                properties.getProperty(\"nfl.relations.use.model.merging\",\n                        \"false\") +\n                \"nfl.relations.use.basic.inference:\" +\n                properties.getProperty(\"nfl.relations.use.basic.inference\",\n                        \"true\") +\n                \"nfl.gazetteer:\" +\n                properties.getProperty(\"nfl.gazetteer\",\n                        DefaultPaths.DEFAULT_NFL_GAZETTEER) +\n                \"nfl.entity.model:\" +\n                properties.getProperty(\"nfl.entity.model\",\n                        DefaultPaths.DEFAULT_NFL_ENTITY_MODEL) +\n                \"nfl.relation.model:\" +\n                properties.getProperty(\"nfl.relation.model\",\n                        DefaultPaths.DEFAULT_NFL_RELATION_MODEL);\n      }\n    });\n\n    //\n    // Parser\n    //\n    pool.register(STANFORD_PARSE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String parserType = properties.getProperty(\"parse.type\", \"stanford\");\n        String maxLenStr = properties.getProperty(\"parse.maxlen\");\n\n        if (parserType.equalsIgnoreCase(\"stanford\")) {\n          ParserAnnotator anno = new ParserAnnotator(\"parse\", properties);\n          return anno;\n        } else if (parserType.equalsIgnoreCase(\"charniak\")) {\n          String model = properties.getProperty(\"parse.model\");\n          String parserExecutable = properties.getProperty(\"parse.executable\");\n          if (model == null || parserExecutable == null) {\n            throw new RuntimeException(\"Both parse.model and parse.executable properties must be specified if parse.type=charniak\");\n          }\n          int maxLen = 399;\n          if (maxLenStr != null) {\n            maxLen = Integer.parseInt(maxLenStr);\n          }\n\n          CharniakParserAnnotator anno = new CharniakParserAnnotator(model, parserExecutable, false, maxLen);\n\n          return anno;\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + parserType + \" (currently supported: stanford and charniak)\");\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        String type = properties.getProperty(\"parse.type\", \"stanford\");\n        if(type.equalsIgnoreCase(\"stanford\")){\n          return ParserAnnotator.signature(\"parser\", properties);\n        } else if(type.equalsIgnoreCase(\"charniak\")) {\n          return \"parse.model:\" +\n                  properties.getProperty(\"parse.model\", \"\") +\n                  \"parse.executable:\" +\n                  properties.getProperty(\"parse.executable\", \"\") +\n                  \"parse.maxlen:\" +\n                  properties.getProperty(\"parse.maxlen\", \"\");\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + type +\n                  \" (currently supported: stanford and charniak)\");\n        }\n      }\n    });\n\n    //\n    // Coreference resolution\n    //\n    pool.register(STANFORD_DETERMINISTIC_COREF, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new DeterministicCorefAnnotator(properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return DeterministicCorefAnnotator.signature(properties);\n      }\n    });\n\n    // add annotators loaded via reflection from classnames specified\n    // in the properties\n    for (Object propertyKey : inputProps.stringPropertyNames()) {\n      if (!(propertyKey instanceof String))\n        continue; // should this be an Exception?\n      String property = (String) propertyKey;\n      if (property.startsWith(CUSTOM_ANNOTATOR_PREFIX)) {\n        final String customName =\n          property.substring(CUSTOM_ANNOTATOR_PREFIX.length());\n        final String customClassName = inputProps.getProperty(property);\n        System.err.println(\"Registering annotator \" + customName +\n            \" with class \" + customClassName);\n        pool.register(customName, new AnnotatorFactory(inputProps) {\n          private static final long serialVersionUID = 1L;\n          private final String name = customName;\n          private final String className = customClassName;\n          @Override\n          public Annotator create() {\n            return ReflectionLoading.loadByReflection(className, name,\n                                                      properties);\n          }\n          @Override\n          public String signature() {\n            // keep track of all relevant properties for this annotator here!\n            // since we don't know what props they need, let's copy all\n            // TODO: can we do better here? maybe signature() should be a method in the Annotator?\n            StringBuilder os = new StringBuilder();\n            for(Object key: properties.keySet()) {\n              String skey = (String) key;\n              os.append(skey + \":\" + properties.getProperty(skey));\n            }\n            return os.toString();\n          }\n        });\n      }\n    }\n\n\n    pool.register(STANFORD_RELATION, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        final String className = \"edu.stanford.nlp.pipeline.RelationExtractorAnnotator\";\n        return ReflectionLoading.loadByReflection(className, properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"TODO\";\n      }\n    });\n    \n    //\n    // add more annotators here!\n    //\n    return pool;\n  }","id":6603,"modified_method":"private static synchronized AnnotatorPool getDefaultAnnotatorPool(final Properties inputProps) {\n    // if the pool already exists reuse!\n    if(pool == null) {\n      // first time we get here\n      pool = new AnnotatorPool();\n    }\n\n    //\n    // tokenizer: breaks text into a sequence of tokens\n    // this is required for all following annotators!\n    //\n    pool.register(STANFORD_TOKENIZE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                          \"false\"))) {\n          return new WhitespaceTokenizerAnnotator(properties);\n        } else {\n          String options = properties.getProperty(\"tokenize.options\",\n                  PTBTokenizerAnnotator.DEFAULT_OPTIONS);\n          boolean keepNewline =\n                  Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                          \"false\"));\n          // If the user specifies \"tokenizeNLs=false\" in tokenize.options, then this default will\n          // be overridden.\n          if (keepNewline) {\n            options = \"tokenizeNLs,\" + options;\n          }\n          return new PTBTokenizerAnnotator(false, options);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(\"tokenize.whitespace:\" +\n                properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                \"false\"))) {\n          os.append(WhitespaceTokenizerAnnotator.EOL_PROPERTY + \":\" +\n                  properties.getProperty(WhitespaceTokenizerAnnotator.EOL_PROPERTY,\n                          \"false\"));\n          os.append(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  properties.getProperty(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY,\n                          \"false\"));\n          return os.toString();\n        } else {\n          os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                          \"false\")));\n        }\n        return os.toString();\n      }\n    });\n\n    pool.register(STANFORD_CLEAN_XML, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String xmlTags =\n          properties.getProperty(\"clean.xmltags\",\n                            CleanXmlAnnotator.DEFAULT_XML_TAGS);\n        String sentenceEndingTags =\n          properties.getProperty(\"clean.sentenceendingtags\",\n                            CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS);\n        String singleSentenceTags =\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS);\n        String allowFlawedString = properties.getProperty(\"clean.allowflawedxml\");\n        boolean allowFlawed = CleanXmlAnnotator.DEFAULT_ALLOW_FLAWS;\n        if (allowFlawedString != null)\n          allowFlawed = Boolean.valueOf(allowFlawedString);\n        String dateTags =\n          properties.getProperty(\"clean.datetags\",\n                            CleanXmlAnnotator.DEFAULT_DATE_TAGS);\n        String docIdTags =\n                properties.getProperty(\"clean.docIdtags\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS);\n        String docTypeTags =\n                properties.getProperty(\"clean.docTypetags\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS);\n        String utteranceTurnTags =\n                properties.getProperty(\"clean.turntags\",\n                        CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS);\n        String speakerTags =\n                properties.getProperty(\"clean.speakertags\",\n                        CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS);\n        String docAnnotations =\n                properties.getProperty(\"clean.docAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS);\n        String tokenAnnotations =\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS);\n        String sectionTags =\n                properties.getProperty(\"clean.sectiontags\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_TAGS);\n        String sectionAnnotations =\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n        String ssplitDiscardTokens =\n                properties.getProperty(\"clean.ssplitDiscardTokens\");\n        CleanXmlAnnotator annotator = new CleanXmlAnnotator(xmlTags,\n            sentenceEndingTags,\n            dateTags,\n            allowFlawed);\n        annotator.setSingleSentenceTagMatcher(singleSentenceTags);\n        annotator.setDocIdTagMatcher(docIdTags);\n        annotator.setDocTypeTagMatcher(docTypeTags);\n        annotator.setDiscourseTags(utteranceTurnTags, speakerTags);\n        annotator.setDocAnnotationPatterns(docAnnotations);\n        annotator.setTokenAnnotationPatterns(tokenAnnotations);\n        annotator.setSectionTagMatcher(sectionTags);\n        annotator.setSectionAnnotationPatterns(sectionAnnotations);\n        annotator.setSsplitDiscardTokensMatcher(ssplitDiscardTokens);\n        return annotator;\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"clean.xmltags:\" +\n                properties.getProperty(\"clean.xmltags\",\n                  CleanXmlAnnotator.DEFAULT_XML_TAGS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.sentenceendingtags\",\n                  CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS) +\n                \"clean.allowflawedxml:\" +\n                properties.getProperty(\"clean.allowflawedxml\", \"\") +\n                \"clean.datetags:\" +\n                properties.getProperty(\"clean.datetags\",\n                  CleanXmlAnnotator.DEFAULT_DATE_TAGS) +\n                \"clean.docidtags:\" +\n                properties.getProperty(\"clean.docid\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS) +\n                \"clean.doctypetags:\" +\n                properties.getProperty(\"clean.doctype\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS) +\n                \"clean.turntags:\" +\n                properties.getProperty(\"clean.turntags\",\n                  CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS) +\n                \"clean.speakertags:\" +\n                properties.getProperty(\"clean.speakertags\",\n                  CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS) +\n                \"clean.docAnnotations:\" +\n                properties.getProperty(\"clean.docAnnotations\",\n                  CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS) +\n                \"clean.tokenAnnotations:\" +\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS) +\n                \"clean.sectiontags:\" +\n                properties.getProperty(\"clean.sectiontags\",\n                  CleanXmlAnnotator.DEFAULT_SECTION_TAGS) +\n                \"clean.sectionAnnotations:\" +\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n      }\n    });\n\n    //\n    // Sentence splitter: splits the above sequence of tokens into\n    // sentences.  This is required when processing entire documents or\n    // text consisting of multiple sentences.\n    //\n    pool.register(STANFORD_SSPLIT, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        boolean nlSplitting = Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (nlSplitting) {\n          boolean whitespaceTokenization = Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\", \"false\"));\n          if (whitespaceTokenization) {\n            if (System.getProperty(\"line.separator\").equals(\"\\n\")) {\n              return WordsToSentencesAnnotator.newlineSplitter(false, \"\\n\");\n            } else {\n              // throw \"\\n\" in just in case files use that instead of\n              // the system separator\n              return WordsToSentencesAnnotator.newlineSplitter(false, System.getProperty(\"line.separator\"), \"\\n\");\n            }\n          } else {\n            return WordsToSentencesAnnotator.newlineSplitter(false, PTBTokenizer.getNewlineToken());\n          }\n\n        } else {\n          // Treat as one sentence: You get a no-op sentence splitter that always returns all tokens as one sentence.\n          String isOneSentence = properties.getProperty(\"ssplit.isOneSentence\");\n          if (Boolean.parseBoolean(isOneSentence)) { // this method treats null as false\n            return WordsToSentencesAnnotator.nonSplitter(false);\n          }\n\n          // multi token sentence boundaries\n          String boundaryMultiTokenRegex = properties.getProperty(\"ssplit.boundaryMultiTokenRegex\");\n\n          // Discard these tokens without marking them as sentence boundaries\n          String tokenPatternsToDiscardProp = properties.getProperty(\"ssplit.tokenPatternsToDiscard\");\n          Set<String> tokenRegexesToDiscard = null;\n          if (tokenPatternsToDiscardProp != null){\n            String [] toks = tokenPatternsToDiscardProp.split(\",\");\n            tokenRegexesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          // regular boundaries\n          String boundaryTokenRegex = properties.getProperty(\"ssplit.boundaryTokenRegex\");\n          Set<String> boundariesToDiscard = null;\n\n          // newline boundaries which are discarded.\n          String bounds = properties.getProperty(\"ssplit.boundariesToDiscard\");\n          if (bounds != null) {\n            String [] toks = bounds.split(\",\");\n            boundariesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          Set<String> htmlElementsToDiscard = null;\n          // HTML boundaries which are discarded\n          bounds = properties.getProperty(\"ssplit.htmlBoundariesToDiscard\");\n          if (bounds != null) {\n            String [] elements = bounds.split(\",\");\n            htmlElementsToDiscard = Generics.newHashSet(Arrays.asList(elements));\n          }\n          String nlsb = properties.getProperty(\"ssplit.newlineIsSentenceBreak\", \"two\");\n\n          return new WordsToSentencesAnnotator(false, boundaryTokenRegex, boundariesToDiscard, htmlElementsToDiscard,\n                  nlsb, boundaryMultiTokenRegex, tokenRegexesToDiscard);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                \"false\"))) {\n          os.append(\"tokenize.whitespace:\" +\n                  properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        } else {\n          os.append(\"ssplit.isOneSentence:\" +\n                  properties.getProperty(\"ssplit.isOneSentence\", \"false\"));\n          if ( ! Boolean.valueOf(properties.getProperty(\"ssplit.isOneSentence\", \"false\"))) {\n            os.append(\"ssplit.boundaryTokenRegex:\" +\n                    properties.getProperty(\"ssplit.boundaryTokenRegex\", \"\"));\n            os.append(\"ssplit.boundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.boundariesToDiscard\", \"\"));\n            os.append(\"ssplit.htmlBoundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.htmlBoundariesToDiscard\", \"\"));\n            os.append(\"ssplit.newlineIsSentenceBreak:\" +\n                    properties.getProperty(\"ssplit.newlineIsSentenceBreak\", \"two\"));\n          }\n        }\n        return os.toString();\n      }\n    });\n\n    //\n    // POS tagger\n    //\n    pool.register(STANFORD_POS, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        try {\n          return new POSTaggerAnnotator(\"pos\", properties);\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return (\"pos.maxlen:\" + properties.getProperty(\"pos.maxlen\", \"\") +\n                \"pos.model:\" + properties.getProperty(\"pos.model\", DefaultPaths.DEFAULT_POS_MODEL) +\n                \"pos.nthreads:\" + properties.getProperty(\"pos.nthreads\", properties.getProperty(\"nthreads\", \"\")));\n      }\n    });\n\n    //\n    // Lemmatizer\n    //\n    pool.register(STANFORD_LEMMA, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new MorphaAnnotator(false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        // nothing for this one\n        return \"\";\n      }\n    });\n\n    //\n    // NER\n    //\n    pool.register(STANFORD_NER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        List<String> models = new ArrayList<String>();\n        String modelNames = properties.getProperty(\"ner.model\");\n        if (modelNames == null) {\n          modelNames = DefaultPaths.DEFAULT_NER_THREECLASS_MODEL + \",\" + DefaultPaths.DEFAULT_NER_MUC_MODEL + \",\" + DefaultPaths.DEFAULT_NER_CONLL_MODEL;\n        }\n        if (modelNames.length() > 0) {\n          models.addAll(Arrays.asList(modelNames.split(\",\")));\n        }\n        if (models.isEmpty()) {\n          // Allow for no real NER model - can just use numeric classifiers or SUTime.\n          // Have to unset ner.model, so unlikely that people got here by accident.\n          System.err.println(\"WARNING: no NER models specified\");\n        }\n        NERClassifierCombiner nerCombiner;\n        try {\n          boolean applyNumericClassifiers =\n            PropertiesUtils.getBool(properties,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT);\n          boolean useSUTime =\n            PropertiesUtils.getBool(properties,\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                NumberSequenceClassifier.USE_SUTIME_DEFAULT);\n          nerCombiner = new NERClassifierCombiner(applyNumericClassifiers,\n                useSUTime, properties,\n                models.toArray(new String[models.size()]));\n        } catch (FileNotFoundException e) {\n          throw new RuntimeIOException(e);\n        }\n        return new NERCombinerAnnotator(nerCombiner, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"ner.model:\" +\n                properties.getProperty(\"ner.model\", \"\") +\n                \"ner.model.3class:\" +\n                properties.getProperty(\"ner.model.3class\",\n                        DefaultPaths.DEFAULT_NER_THREECLASS_MODEL) +\n                \"ner.model.7class:\" +\n                properties.getProperty(\"ner.model.7class\",\n                        DefaultPaths.DEFAULT_NER_MUC_MODEL) +\n                \"ner.model.MISCclass:\" +\n                properties.getProperty(\"ner.model.MISCclass\",\n                        DefaultPaths.DEFAULT_NER_CONLL_MODEL) +\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY + \":\" +\n                properties.getProperty(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                        Boolean.toString(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT)) +\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY + \":\" +\n                properties.getProperty(NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                        Boolean.toString(NumberSequenceClassifier.USE_SUTIME_DEFAULT));\n      }\n    });\n\n    //\n    // Regex NER\n    //\n    pool.register(STANFORD_REGEXNER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new TokensRegexNERAnnotator(\"regexner\", properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return PropertiesUtils.getSignature(\"regexner\", properties, TokensRegexNERAnnotator.SUPPORTED_PROPERTIES);\n      }\n    });\n\n    //\n    // Gender Annotator\n    //\n    pool.register(STANFORD_GENDER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new GenderAnnotator(false, properties.getProperty(\"gender.firstnames\", DefaultPaths.DEFAULT_GENDER_FIRST_NAMES));\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"gender.firstnames:\" +\n                properties.getProperty(\"gender.firstnames\",\n                        DefaultPaths.DEFAULT_GENDER_FIRST_NAMES);\n      }\n    });\n\n\n    //\n    // True caser\n    //\n    pool.register(STANFORD_TRUECASE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String model = properties.getProperty(\"truecase.model\", DefaultPaths.DEFAULT_TRUECASE_MODEL);\n        String bias = properties.getProperty(\"truecase.bias\", TrueCaseAnnotator.DEFAULT_MODEL_BIAS);\n        String mixed = properties.getProperty(\"truecase.mixedcasefile\", DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n        return new TrueCaseAnnotator(model, bias, mixed, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"truecase.model:\" +\n                properties.getProperty(\"truecase.model\",\n                        DefaultPaths.DEFAULT_TRUECASE_MODEL) +\n                \"truecase.bias:\" +\n                properties.getProperty(\"truecase.bias\",\n                        TrueCaseAnnotator.DEFAULT_MODEL_BIAS) +\n                \"truecase.mixedcasefile:\" +\n                properties.getProperty(\"truecase.mixedcasefile\",\n                        DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n      }\n    });\n\n    //\n    // Parser\n    //\n    pool.register(STANFORD_PARSE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String parserType = properties.getProperty(\"parse.type\", \"stanford\");\n        String maxLenStr = properties.getProperty(\"parse.maxlen\");\n\n        if (parserType.equalsIgnoreCase(\"stanford\")) {\n          ParserAnnotator anno = new ParserAnnotator(\"parse\", properties);\n          return anno;\n        } else if (parserType.equalsIgnoreCase(\"charniak\")) {\n          String model = properties.getProperty(\"parse.model\");\n          String parserExecutable = properties.getProperty(\"parse.executable\");\n          if (model == null || parserExecutable == null) {\n            throw new RuntimeException(\"Both parse.model and parse.executable properties must be specified if parse.type=charniak\");\n          }\n          int maxLen = 399;\n          if (maxLenStr != null) {\n            maxLen = Integer.parseInt(maxLenStr);\n          }\n\n          CharniakParserAnnotator anno = new CharniakParserAnnotator(model, parserExecutable, false, maxLen);\n\n          return anno;\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + parserType + \" (currently supported: stanford and charniak)\");\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        String type = properties.getProperty(\"parse.type\", \"stanford\");\n        if(type.equalsIgnoreCase(\"stanford\")){\n          return ParserAnnotator.signature(\"parser\", properties);\n        } else if(type.equalsIgnoreCase(\"charniak\")) {\n          return \"parse.model:\" +\n                  properties.getProperty(\"parse.model\", \"\") +\n                  \"parse.executable:\" +\n                  properties.getProperty(\"parse.executable\", \"\") +\n                  \"parse.maxlen:\" +\n                  properties.getProperty(\"parse.maxlen\", \"\");\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + type +\n                  \" (currently supported: stanford and charniak)\");\n        }\n      }\n    });\n\n    //\n    // Coreference resolution\n    //\n    pool.register(STANFORD_DETERMINISTIC_COREF, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new DeterministicCorefAnnotator(properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return DeterministicCorefAnnotator.signature(properties);\n      }\n    });\n\n    // add annotators loaded via reflection from classnames specified\n    // in the properties\n    for (Object propertyKey : inputProps.stringPropertyNames()) {\n      if (!(propertyKey instanceof String))\n        continue; // should this be an Exception?\n      String property = (String) propertyKey;\n      if (property.startsWith(CUSTOM_ANNOTATOR_PREFIX)) {\n        final String customName =\n          property.substring(CUSTOM_ANNOTATOR_PREFIX.length());\n        final String customClassName = inputProps.getProperty(property);\n        System.err.println(\"Registering annotator \" + customName +\n            \" with class \" + customClassName);\n        pool.register(customName, new AnnotatorFactory(inputProps) {\n          private static final long serialVersionUID = 1L;\n          private final String name = customName;\n          private final String className = customClassName;\n          @Override\n          public Annotator create() {\n            return ReflectionLoading.loadByReflection(className, name,\n                                                      properties);\n          }\n          @Override\n          public String signature() {\n            // keep track of all relevant properties for this annotator here!\n            // since we don't know what props they need, let's copy all\n            // TODO: can we do better here? maybe signature() should be a method in the Annotator?\n            StringBuilder os = new StringBuilder();\n            for(Object key: properties.keySet()) {\n              String skey = (String) key;\n              os.append(skey + \":\" + properties.getProperty(skey));\n            }\n            return os.toString();\n          }\n        });\n      }\n    }\n\n\n    pool.register(STANFORD_RELATION, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new RelationExtractorAnnotator(properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"sup.relation.verbose:\" +\n        properties.getProperty(\"sup.relation.verbose\",\n                \"false\") +\n        properties.getProperty(\"sup.relation.model\",\n                DefaultPaths.DEFAULT_SUP_RELATION_EX_RELATION_MODEL);\n      }\n    });\n    \n    //\n    // add more annotators here!\n    //\n    return pool;\n  }","commit_id":"3832346aab66a19293177272a2417d97f083e462","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Prints the list of properties required to run the pipeline\n   * @param os PrintStream to print usage to\n   */\n  private static void printRequiredProperties(PrintStream os) {\n    // TODO some annotators (ssplit, regexner, gender, some parser options, dcoref?) are not documented\n    os.println(\"The following properties can be defined:\");\n    os.println(\"(if -props or -annotators is not passed in, default properties will be loaded via the classpath)\");\n    os.println(\"\\t\\\"props\\\" - path to file with configuration properties\");\n    os.println(\"\\t\\\"annotators\\\" - comma separated list of annotators\");\n    os.println(\"\\tThe following annotators are supported: cleanxml, tokenize, ssplit, pos, lemma, ner, truecase, parse, coref, dcoref, nfl\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"tokenize\\\" is defined:\");\n    os.println(\"\\t\\\"tokenize.options\\\" - PTBTokenizer options (see edu.stanford.nlp.process.PTBTokenizer for details)\");\n    os.println(\"\\t\\\"tokenize.whitespace\\\" - If true, just use whitespace tokenization\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"cleanxml\\\" is defined:\");\n    os.println(\"\\t\\\"clean.xmltags\\\" - regex of tags to extract text from\");\n    os.println(\"\\t\\\"clean.sentenceendingtags\\\" - regex of tags which mark sentence endings\");\n    os.println(\"\\t\\\"clean.allowflawedxml\\\" - if set to true, don't complain about XML errors\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"pos\\\" is defined:\");\n    os.println(\"\\t\\\"pos.maxlen\\\" - maximum length of sentence to POS tag\");\n    os.println(\"\\t\\\"pos.model\\\" - path towards the POS tagger model\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"ner\\\" is defined:\");\n    os.println(\"\\t\\\"ner.model.3class\\\" - path towards the three-class NER model\");\n    os.println(\"\\t\\\"ner.model.7class\\\" - path towards the seven-class NER model\");\n    os.println(\"\\t\\\"ner.model.MISCclass\\\" - path towards the NER model with a MISC class\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"truecase\\\" is defined:\");\n    os.println(\"\\t\\\"truecase.model\\\" - path towards the true-casing model; default: \" + DefaultPaths.DEFAULT_TRUECASE_MODEL);\n    os.println(\"\\t\\\"truecase.bias\\\" - class bias of the true case model; default: \" + TrueCaseAnnotator.DEFAULT_MODEL_BIAS);\n    os.println(\"\\t\\\"truecase.mixedcasefile\\\" - path towards the mixed case file; default: \" + DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"nfl\\\" is defined:\");\n    os.println(\"\\t\\\"nfl.gazetteer\\\" - path towards the gazetteer for the NFL domain\");\n    os.println(\"\\t\\\"nfl.relation.model\\\" - path towards the NFL relation extraction model\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"parse\\\" is defined:\");\n    os.println(\"\\t\\\"parse.model\\\" - path towards the PCFG parser model\");\n\n    /* XXX: unstable, do not use for now\n    os.println();\n    os.println(\"\\tIf annotator \\\"srl\\\" is defined:\");\n    os.println(\"\\t\\\"srl.verb.args\\\" - path to the file listing verbs and their core arguments (\\\"verbs.core_args\\\")\");\n    os.println(\"\\t\\\"srl.model.id\\\" - path prefix for the role identification model (adds \\\".model.gz\\\" and \\\".fe\\\" to this prefix)\");\n    os.println(\"\\t\\\"srl.model.cls\\\" - path prefix for the role classification model (adds \\\".model.gz\\\" and \\\".fe\\\" to this prefix)\");\n    os.println(\"\\t\\\"srl.model.jic\\\" - path to the directory containing the joint model's \\\"model.gz\\\", \\\"fe\\\" and \\\"je\\\" files\");\n    os.println(\"\\t                  (if not specified, the joint model will not be used)\");\n    */\n\n    os.println();\n    os.println(\"Command line properties:\");\n    os.println(\"\\t\\\"file\\\" - run the pipeline on the content of this file, or on the content of the files in this directory\");\n    os.println(\"\\t         XML output is generated for every input file \\\"file\\\" as file.xml\");\n    os.println(\"\\t\\\"extension\\\" - if -file used with a directory, process only the files with this extension\");\n    os.println(\"\\t\\\"filelist\\\" - run the pipeline on the list of files given in this file\");\n    os.println(\"\\t             output is generated for every input file as file.outputExtension\");\n    os.println(\"\\t\\\"outputDirectory\\\" - where to put output (defaults to the current directory)\");\n    os.println(\"\\t\\\"outputExtension\\\" - extension to use for the output file (defaults to \\\".xml\\\" for XML, \\\".ser.gz\\\" for serialized).  Don't forget the dot!\");\n    os.println(\"\\t\\\"outputFormat\\\" - \\\"xml\\\" to output XML (default), \\\"serialized\\\" to output serialized Java objects, \\\"text\\\" to output text\");\n    os.println(\"\\t\\\"serializer\\\" - Class of annotation serializer to use when outputFormat is \\\"serialized\\\".  By default, uses Java serialization.\");\n    os.println(\"\\t\\\"replaceExtension\\\" - flag to chop off the last extension before adding outputExtension to file\");\n    os.println(\"\\t\\\"noClobber\\\" - don't automatically override (clobber) output files that already exist\");\n\t\tos.println(\"\\t\\\"threads\\\" - multithread on this number of threads\");\n    os.println();\n    os.println(\"If none of the above are present, run the pipeline in an interactive shell (default properties will be loaded from the classpath).\");\n    os.println(\"The shell accepts input from stdin and displays the output at stdout.\");\n\n    os.println();\n    os.println(\"Run with -help [topic] for more help on a specific topic.\");\n    os.println(\"Current topics include: parser\");\n\n    os.println();\n  }","id":6604,"modified_method":"/**\n   * Prints the list of properties required to run the pipeline\n   * @param os PrintStream to print usage to\n   */\n  private static void printRequiredProperties(PrintStream os) {\n    // TODO some annotators (ssplit, regexner, gender, some parser options, dcoref?) are not documented\n    os.println(\"The following properties can be defined:\");\n    os.println(\"(if -props or -annotators is not passed in, default properties will be loaded via the classpath)\");\n    os.println(\"\\t\\\"props\\\" - path to file with configuration properties\");\n    os.println(\"\\t\\\"annotators\\\" - comma separated list of annotators\");\n    os.println(\"\\tThe following annotators are supported: cleanxml, tokenize, ssplit, pos, lemma, ner, truecase, parse, coref, dcoref, relation\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"tokenize\\\" is defined:\");\n    os.println(\"\\t\\\"tokenize.options\\\" - PTBTokenizer options (see edu.stanford.nlp.process.PTBTokenizer for details)\");\n    os.println(\"\\t\\\"tokenize.whitespace\\\" - If true, just use whitespace tokenization\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"cleanxml\\\" is defined:\");\n    os.println(\"\\t\\\"clean.xmltags\\\" - regex of tags to extract text from\");\n    os.println(\"\\t\\\"clean.sentenceendingtags\\\" - regex of tags which mark sentence endings\");\n    os.println(\"\\t\\\"clean.allowflawedxml\\\" - if set to true, don't complain about XML errors\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"pos\\\" is defined:\");\n    os.println(\"\\t\\\"pos.maxlen\\\" - maximum length of sentence to POS tag\");\n    os.println(\"\\t\\\"pos.model\\\" - path towards the POS tagger model\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"ner\\\" is defined:\");\n    os.println(\"\\t\\\"ner.model.3class\\\" - path towards the three-class NER model\");\n    os.println(\"\\t\\\"ner.model.7class\\\" - path towards the seven-class NER model\");\n    os.println(\"\\t\\\"ner.model.MISCclass\\\" - path towards the NER model with a MISC class\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"truecase\\\" is defined:\");\n    os.println(\"\\t\\\"truecase.model\\\" - path towards the true-casing model; default: \" + DefaultPaths.DEFAULT_TRUECASE_MODEL);\n    os.println(\"\\t\\\"truecase.bias\\\" - class bias of the true case model; default: \" + TrueCaseAnnotator.DEFAULT_MODEL_BIAS);\n    os.println(\"\\t\\\"truecase.mixedcasefile\\\" - path towards the mixed case file; default: \" + DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"relation\\\" is defined:\");\n    os.println(\"\\t\\\"sup.relation.verbose\\\" - whether verbose or not\");\n    os.println(\"\\t\\\"sup.relation.model\\\" - path towards the relation extraction model\");\n\n    os.println();\n    os.println(\"\\tIf annotator \\\"parse\\\" is defined:\");\n    os.println(\"\\t\\\"parse.model\\\" - path towards the PCFG parser model\");\n\n    /* XXX: unstable, do not use for now\n    os.println();\n    os.println(\"\\tIf annotator \\\"srl\\\" is defined:\");\n    os.println(\"\\t\\\"srl.verb.args\\\" - path to the file listing verbs and their core arguments (\\\"verbs.core_args\\\")\");\n    os.println(\"\\t\\\"srl.model.id\\\" - path prefix for the role identification model (adds \\\".model.gz\\\" and \\\".fe\\\" to this prefix)\");\n    os.println(\"\\t\\\"srl.model.cls\\\" - path prefix for the role classification model (adds \\\".model.gz\\\" and \\\".fe\\\" to this prefix)\");\n    os.println(\"\\t\\\"srl.model.jic\\\" - path to the directory containing the joint model's \\\"model.gz\\\", \\\"fe\\\" and \\\"je\\\" files\");\n    os.println(\"\\t                  (if not specified, the joint model will not be used)\");\n    */\n\n    os.println();\n    os.println(\"Command line properties:\");\n    os.println(\"\\t\\\"file\\\" - run the pipeline on the content of this file, or on the content of the files in this directory\");\n    os.println(\"\\t         XML output is generated for every input file \\\"file\\\" as file.xml\");\n    os.println(\"\\t\\\"extension\\\" - if -file used with a directory, process only the files with this extension\");\n    os.println(\"\\t\\\"filelist\\\" - run the pipeline on the list of files given in this file\");\n    os.println(\"\\t             output is generated for every input file as file.outputExtension\");\n    os.println(\"\\t\\\"outputDirectory\\\" - where to put output (defaults to the current directory)\");\n    os.println(\"\\t\\\"outputExtension\\\" - extension to use for the output file (defaults to \\\".xml\\\" for XML, \\\".ser.gz\\\" for serialized).  Don't forget the dot!\");\n    os.println(\"\\t\\\"outputFormat\\\" - \\\"xml\\\" to output XML (default), \\\"serialized\\\" to output serialized Java objects, \\\"text\\\" to output text\");\n    os.println(\"\\t\\\"serializer\\\" - Class of annotation serializer to use when outputFormat is \\\"serialized\\\".  By default, uses Java serialization.\");\n    os.println(\"\\t\\\"replaceExtension\\\" - flag to chop off the last extension before adding outputExtension to file\");\n    os.println(\"\\t\\\"noClobber\\\" - don't automatically override (clobber) output files that already exist\");\n\t\tos.println(\"\\t\\\"threads\\\" - multithread on this number of threads\");\n    os.println();\n    os.println(\"If none of the above are present, run the pipeline in an interactive shell (default properties will be loaded from the classpath).\");\n    os.println(\"The shell accepts input from stdin and displays the output at stdout.\");\n\n    os.println();\n    os.println(\"Run with -help [topic] for more help on a specific topic.\");\n    os.println(\"Current topics include: parser\");\n\n    os.println();\n  }","commit_id":"65a8fe26905112e4b26a83d6d4260ebaff7c4266","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static synchronized AnnotatorPool getDefaultAnnotatorPool(final Properties inputProps) {\n    // if the pool already exists reuse!\n    if(pool == null) {\n      // first time we get here\n      pool = new AnnotatorPool();\n    }\n\n    //\n    // tokenizer: breaks text into a sequence of tokens\n    // this is required for all following annotators!\n    //\n    pool.register(STANFORD_TOKENIZE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                          \"false\"))) {\n          return new WhitespaceTokenizerAnnotator(properties);\n        } else {\n          String options = properties.getProperty(\"tokenize.options\",\n                  PTBTokenizerAnnotator.DEFAULT_OPTIONS);\n          boolean keepNewline =\n                  Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                          \"false\"));\n          // If the user specifies \"tokenizeNLs=false\" in tokenize.options, then this default will\n          // be overridden.\n          if (keepNewline) {\n            options = \"tokenizeNLs,\" + options;\n          }\n          return new PTBTokenizerAnnotator(false, options);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(\"tokenize.whitespace:\" +\n                properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                \"false\"))) {\n          os.append(WhitespaceTokenizerAnnotator.EOL_PROPERTY + \":\" +\n                  properties.getProperty(WhitespaceTokenizerAnnotator.EOL_PROPERTY,\n                          \"false\"));\n          os.append(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  properties.getProperty(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY,\n                          \"false\"));\n          return os.toString();\n        } else {\n          os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                          \"false\")));\n        }\n        return os.toString();\n      }\n    });\n\n    pool.register(STANFORD_CLEAN_XML, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String xmlTags =\n          properties.getProperty(\"clean.xmltags\",\n                            CleanXmlAnnotator.DEFAULT_XML_TAGS);\n        String sentenceEndingTags =\n          properties.getProperty(\"clean.sentenceendingtags\",\n                            CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS);\n        String singleSentenceTags =\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS);\n        String allowFlawedString = properties.getProperty(\"clean.allowflawedxml\");\n        boolean allowFlawed = CleanXmlAnnotator.DEFAULT_ALLOW_FLAWS;\n        if (allowFlawedString != null)\n          allowFlawed = Boolean.valueOf(allowFlawedString);\n        String dateTags =\n          properties.getProperty(\"clean.datetags\",\n                            CleanXmlAnnotator.DEFAULT_DATE_TAGS);\n        String docIdTags =\n                properties.getProperty(\"clean.docIdtags\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS);\n        String docTypeTags =\n                properties.getProperty(\"clean.docTypetags\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS);\n        String utteranceTurnTags =\n                properties.getProperty(\"clean.turntags\",\n                        CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS);\n        String speakerTags =\n                properties.getProperty(\"clean.speakertags\",\n                        CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS);\n        String docAnnotations =\n                properties.getProperty(\"clean.docAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS);\n        String tokenAnnotations =\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS);\n        String sectionTags =\n                properties.getProperty(\"clean.sectiontags\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_TAGS);\n        String sectionAnnotations =\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n        String ssplitDiscardTokens =\n                properties.getProperty(\"clean.ssplitDiscardTokens\");\n        CleanXmlAnnotator annotator = new CleanXmlAnnotator(xmlTags,\n            sentenceEndingTags,\n            dateTags,\n            allowFlawed);\n        annotator.setSingleSentenceTagMatcher(singleSentenceTags);\n        annotator.setDocIdTagMatcher(docIdTags);\n        annotator.setDocTypeTagMatcher(docTypeTags);\n        annotator.setDiscourseTags(utteranceTurnTags, speakerTags);\n        annotator.setDocAnnotationPatterns(docAnnotations);\n        annotator.setTokenAnnotationPatterns(tokenAnnotations);\n        annotator.setSectionTagMatcher(sectionTags);\n        annotator.setSectionAnnotationPatterns(sectionAnnotations);\n        annotator.setSsplitDiscardTokensMatcher(ssplitDiscardTokens);\n        return annotator;\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"clean.xmltags:\" +\n                properties.getProperty(\"clean.xmltags\",\n                  CleanXmlAnnotator.DEFAULT_XML_TAGS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.sentenceendingtags\",\n                  CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS) +\n                \"clean.allowflawedxml:\" +\n                properties.getProperty(\"clean.allowflawedxml\", \"\") +\n                \"clean.datetags:\" +\n                properties.getProperty(\"clean.datetags\",\n                  CleanXmlAnnotator.DEFAULT_DATE_TAGS) +\n                \"clean.docidtags:\" +\n                properties.getProperty(\"clean.docid\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS) +\n                \"clean.doctypetags:\" +\n                properties.getProperty(\"clean.doctype\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS) +\n                \"clean.turntags:\" +\n                properties.getProperty(\"clean.turntags\",\n                  CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS) +\n                \"clean.speakertags:\" +\n                properties.getProperty(\"clean.speakertags\",\n                  CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS) +\n                \"clean.docAnnotations:\" +\n                properties.getProperty(\"clean.docAnnotations\",\n                  CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS) +\n                \"clean.tokenAnnotations:\" +\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS) +\n                \"clean.sectiontags:\" +\n                properties.getProperty(\"clean.sectiontags\",\n                  CleanXmlAnnotator.DEFAULT_SECTION_TAGS) +\n                \"clean.sectionAnnotations:\" +\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n      }\n    });\n\n    //\n    // Sentence splitter: splits the above sequence of tokens into\n    // sentences.  This is required when processing entire documents or\n    // text consisting of multiple sentences.\n    //\n    pool.register(STANFORD_SSPLIT, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        boolean nlSplitting = Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (nlSplitting) {\n          boolean whitespaceTokenization = Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\", \"false\"));\n          if (whitespaceTokenization) {\n            if (System.getProperty(\"line.separator\").equals(\"\\n\")) {\n              return WordsToSentencesAnnotator.newlineSplitter(false, \"\\n\");\n            } else {\n              // throw \"\\n\" in just in case files use that instead of\n              // the system separator\n              return WordsToSentencesAnnotator.newlineSplitter(false, System.getProperty(\"line.separator\"), \"\\n\");\n            }\n          } else {\n            return WordsToSentencesAnnotator.newlineSplitter(false, PTBTokenizer.getNewlineToken());\n          }\n\n        } else {\n          // Treat as one sentence: You get a no-op sentence splitter that always returns all tokens as one sentence.\n          String isOneSentence = properties.getProperty(\"ssplit.isOneSentence\");\n          if (Boolean.parseBoolean(isOneSentence)) { // this method treats null as false\n            return WordsToSentencesAnnotator.nonSplitter(false);\n          }\n\n          // multi token sentence boundaries\n          String boundaryMultiTokenRegex = properties.getProperty(\"ssplit.boundaryMultiTokenRegex\");\n\n          // Discard these tokens without marking them as sentence boundaries\n          String tokenPatternsToDiscardProp = properties.getProperty(\"ssplit.tokenPatternsToDiscard\");\n          Set<String> tokenRegexesToDiscard = null;\n          if (tokenPatternsToDiscardProp != null){\n            String [] toks = tokenPatternsToDiscardProp.split(\",\");\n            tokenRegexesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          // regular boundaries\n          String boundaryTokenRegex = properties.getProperty(\"ssplit.boundaryTokenRegex\");\n          Set<String> boundariesToDiscard = null;\n\n          // newline boundaries which are discarded.\n          String bounds = properties.getProperty(\"ssplit.boundariesToDiscard\");\n          if (bounds != null) {\n            String [] toks = bounds.split(\",\");\n            boundariesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          Set<String> htmlElementsToDiscard = null;\n          // HTML boundaries which are discarded\n          bounds = properties.getProperty(\"ssplit.htmlBoundariesToDiscard\");\n          if (bounds != null) {\n            String [] elements = bounds.split(\",\");\n            htmlElementsToDiscard = Generics.newHashSet(Arrays.asList(elements));\n          }\n          String nlsb = properties.getProperty(\"ssplit.newlineIsSentenceBreak\", \"two\");\n\n          return new WordsToSentencesAnnotator(false, boundaryTokenRegex, boundariesToDiscard, htmlElementsToDiscard,\n                  nlsb, boundaryMultiTokenRegex, tokenRegexesToDiscard);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                \"false\"))) {\n          os.append(\"tokenize.whitespace:\" +\n                  properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        } else {\n          os.append(\"ssplit.isOneSentence:\" +\n                  properties.getProperty(\"ssplit.isOneSentence\", \"false\"));\n          if ( ! Boolean.valueOf(properties.getProperty(\"ssplit.isOneSentence\", \"false\"))) {\n            os.append(\"ssplit.boundaryTokenRegex:\" +\n                    properties.getProperty(\"ssplit.boundaryTokenRegex\", \"\"));\n            os.append(\"ssplit.boundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.boundariesToDiscard\", \"\"));\n            os.append(\"ssplit.htmlBoundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.htmlBoundariesToDiscard\", \"\"));\n            os.append(\"ssplit.newlineIsSentenceBreak:\" +\n                    properties.getProperty(\"ssplit.newlineIsSentenceBreak\", \"two\"));\n          }\n        }\n        return os.toString();\n      }\n    });\n\n    //\n    // POS tagger\n    //\n    pool.register(STANFORD_POS, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        try {\n          return new POSTaggerAnnotator(\"pos\", properties);\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return (\"pos.maxlen:\" + properties.getProperty(\"pos.maxlen\", \"\") +\n                \"pos.model:\" + properties.getProperty(\"pos.model\", DefaultPaths.DEFAULT_POS_MODEL) +\n                \"pos.nthreads:\" + properties.getProperty(\"pos.nthreads\", properties.getProperty(\"nthreads\", \"\")));\n      }\n    });\n\n    //\n    // Lemmatizer\n    //\n    pool.register(STANFORD_LEMMA, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new MorphaAnnotator(false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        // nothing for this one\n        return \"\";\n      }\n    });\n\n    //\n    // NER\n    //\n    pool.register(STANFORD_NER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        List<String> models = new ArrayList<String>();\n        String modelNames = properties.getProperty(\"ner.model\");\n        if (modelNames == null) {\n          modelNames = DefaultPaths.DEFAULT_NER_THREECLASS_MODEL + \",\" + DefaultPaths.DEFAULT_NER_MUC_MODEL + \",\" + DefaultPaths.DEFAULT_NER_CONLL_MODEL;\n        }\n        if (modelNames.length() > 0) {\n          models.addAll(Arrays.asList(modelNames.split(\",\")));\n        }\n        if (models.isEmpty()) {\n          // Allow for no real NER model - can just use numeric classifiers or SUTime.\n          // Have to unset ner.model, so unlikely that people got here by accident.\n          System.err.println(\"WARNING: no NER models specified\");\n        }\n        NERClassifierCombiner nerCombiner;\n        try {\n          boolean applyNumericClassifiers =\n            PropertiesUtils.getBool(properties,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT);\n          boolean useSUTime =\n            PropertiesUtils.getBool(properties,\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                NumberSequenceClassifier.USE_SUTIME_DEFAULT);\n          nerCombiner = new NERClassifierCombiner(applyNumericClassifiers,\n                useSUTime, properties,\n                models.toArray(new String[models.size()]));\n        } catch (FileNotFoundException e) {\n          throw new RuntimeIOException(e);\n        }\n        return new NERCombinerAnnotator(nerCombiner, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"ner.model:\" +\n                properties.getProperty(\"ner.model\", \"\") +\n                \"ner.model.3class:\" +\n                properties.getProperty(\"ner.model.3class\",\n                        DefaultPaths.DEFAULT_NER_THREECLASS_MODEL) +\n                \"ner.model.7class:\" +\n                properties.getProperty(\"ner.model.7class\",\n                        DefaultPaths.DEFAULT_NER_MUC_MODEL) +\n                \"ner.model.MISCclass:\" +\n                properties.getProperty(\"ner.model.MISCclass\",\n                        DefaultPaths.DEFAULT_NER_CONLL_MODEL) +\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY + \":\" +\n                properties.getProperty(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                        Boolean.toString(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT)) +\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY + \":\" +\n                properties.getProperty(NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                        Boolean.toString(NumberSequenceClassifier.USE_SUTIME_DEFAULT));\n      }\n    });\n\n    //\n    // Regex NER\n    //\n    pool.register(STANFORD_REGEXNER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new TokensRegexNERAnnotator(\"regexner\", properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return PropertiesUtils.getSignature(\"regexner\", properties, TokensRegexNERAnnotator.SUPPORTED_PROPERTIES);\n      }\n    });\n\n    //\n    // Gender Annotator\n    //\n    pool.register(STANFORD_GENDER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new GenderAnnotator(false, properties.getProperty(\"gender.firstnames\", DefaultPaths.DEFAULT_GENDER_FIRST_NAMES));\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"gender.firstnames:\" +\n                properties.getProperty(\"gender.firstnames\",\n                        DefaultPaths.DEFAULT_GENDER_FIRST_NAMES);\n      }\n    });\n\n\n    //\n    // True caser\n    //\n    pool.register(STANFORD_TRUECASE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String model = properties.getProperty(\"truecase.model\", DefaultPaths.DEFAULT_TRUECASE_MODEL);\n        String bias = properties.getProperty(\"truecase.bias\", TrueCaseAnnotator.DEFAULT_MODEL_BIAS);\n        String mixed = properties.getProperty(\"truecase.mixedcasefile\", DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n        return new TrueCaseAnnotator(model, bias, mixed, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"truecase.model:\" +\n                properties.getProperty(\"truecase.model\",\n                        DefaultPaths.DEFAULT_TRUECASE_MODEL) +\n                \"truecase.bias:\" +\n                properties.getProperty(\"truecase.bias\",\n                        TrueCaseAnnotator.DEFAULT_MODEL_BIAS) +\n                \"truecase.mixedcasefile:\" +\n                properties.getProperty(\"truecase.mixedcasefile\",\n                        DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n      }\n    });\n\n    //\n    // Post-processing tokenization rules for the NFL domain\n    //\n    pool.register(STANFORD_NFL_TOKENIZE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        final String className =\n          \"edu.stanford.nlp.pipeline.NFLTokenizerAnnotator\";\n        return ReflectionLoading.loadByReflection(className);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        // no used props for this one\n        return \"\";\n      }\n    });\n\n    //\n    // Entity and relation extraction for the NFL domain\n    //\n    pool.register(STANFORD_NFL, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        // these paths now extracted inside c'tor\n        // String gazetteer = properties.getProperty(\"nfl.gazetteer\", DefaultPaths.DEFAULT_NFL_GAZETTEER);\n        // String entityModel = properties.getProperty(\"nfl.entity.model\", DefaultPaths.DEFAULT_NFL_ENTITY_MODEL);\n        // String relationModel = properties.getProperty(\"nfl.relation.model\", DefaultPaths.DEFAULT_NFL_RELATION_MODEL);\n        final String className = \"edu.stanford.nlp.pipeline.NFLAnnotator\";\n        return ReflectionLoading.loadByReflection(className, properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"nfl.verbose:\" +\n                properties.getProperty(\"nfl.verbose\",\n                        \"false\") +\n                \"nfl.relations.use.max.recall:\" +\n                properties.getProperty(\"nfl.relations.use.max.recall\",\n                        \"false\") +\n                \"nfl.relations.use.model.merging:\" +\n                properties.getProperty(\"nfl.relations.use.model.merging\",\n                        \"false\") +\n                \"nfl.relations.use.basic.inference:\" +\n                properties.getProperty(\"nfl.relations.use.basic.inference\",\n                        \"true\") +\n                \"nfl.gazetteer:\" +\n                properties.getProperty(\"nfl.gazetteer\",\n                        DefaultPaths.DEFAULT_NFL_GAZETTEER) +\n                \"nfl.entity.model:\" +\n                properties.getProperty(\"nfl.entity.model\",\n                        DefaultPaths.DEFAULT_NFL_ENTITY_MODEL) +\n                \"nfl.relation.model:\" +\n                properties.getProperty(\"nfl.relation.model\",\n                        DefaultPaths.DEFAULT_NFL_RELATION_MODEL);\n      }\n    });\n\n    //\n    // Parser\n    //\n    pool.register(STANFORD_PARSE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String parserType = properties.getProperty(\"parse.type\", \"stanford\");\n        String maxLenStr = properties.getProperty(\"parse.maxlen\");\n\n        if (parserType.equalsIgnoreCase(\"stanford\")) {\n          ParserAnnotator anno = new ParserAnnotator(\"parse\", properties);\n          return anno;\n        } else if (parserType.equalsIgnoreCase(\"charniak\")) {\n          String model = properties.getProperty(\"parse.model\");\n          String parserExecutable = properties.getProperty(\"parse.executable\");\n          if (model == null || parserExecutable == null) {\n            throw new RuntimeException(\"Both parse.model and parse.executable properties must be specified if parse.type=charniak\");\n          }\n          int maxLen = 399;\n          if (maxLenStr != null) {\n            maxLen = Integer.parseInt(maxLenStr);\n          }\n\n          CharniakParserAnnotator anno = new CharniakParserAnnotator(model, parserExecutable, false, maxLen);\n\n          return anno;\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + parserType + \" (currently supported: stanford and charniak)\");\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        String type = properties.getProperty(\"parse.type\", \"stanford\");\n        if(type.equalsIgnoreCase(\"stanford\")){\n          return ParserAnnotator.signature(\"parser\", properties);\n        } else if(type.equalsIgnoreCase(\"charniak\")) {\n          return \"parse.model:\" +\n                  properties.getProperty(\"parse.model\", \"\") +\n                  \"parse.executable:\" +\n                  properties.getProperty(\"parse.executable\", \"\") +\n                  \"parse.maxlen:\" +\n                  properties.getProperty(\"parse.maxlen\", \"\");\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + type +\n                  \" (currently supported: stanford and charniak)\");\n        }\n      }\n    });\n\n    //\n    // Coreference resolution\n    //\n    pool.register(STANFORD_DETERMINISTIC_COREF, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new DeterministicCorefAnnotator(properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return DeterministicCorefAnnotator.signature(properties);\n      }\n    });\n\n    // add annotators loaded via reflection from classnames specified\n    // in the properties\n    for (Object propertyKey : inputProps.stringPropertyNames()) {\n      if (!(propertyKey instanceof String))\n        continue; // should this be an Exception?\n      String property = (String) propertyKey;\n      if (property.startsWith(CUSTOM_ANNOTATOR_PREFIX)) {\n        final String customName =\n          property.substring(CUSTOM_ANNOTATOR_PREFIX.length());\n        final String customClassName = inputProps.getProperty(property);\n        System.err.println(\"Registering annotator \" + customName +\n            \" with class \" + customClassName);\n        pool.register(customName, new AnnotatorFactory(inputProps) {\n          private static final long serialVersionUID = 1L;\n          private final String name = customName;\n          private final String className = customClassName;\n          @Override\n          public Annotator create() {\n            return ReflectionLoading.loadByReflection(className, name,\n                                                      properties);\n          }\n          @Override\n          public String signature() {\n            // keep track of all relevant properties for this annotator here!\n            // since we don't know what props they need, let's copy all\n            // TODO: can we do better here? maybe signature() should be a method in the Annotator?\n            StringBuilder os = new StringBuilder();\n            for(Object key: properties.keySet()) {\n              String skey = (String) key;\n              os.append(skey + \":\" + properties.getProperty(skey));\n            }\n            return os.toString();\n          }\n        });\n      }\n    }\n\n\n    pool.register(STANFORD_RELATION, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        final String className = \"edu.stanford.nlp.pipeline.RelationExtractorAnnotator\";\n        return ReflectionLoading.loadByReflection(className, properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"TODO\";\n      }\n    });\n    \n    //\n    // add more annotators here!\n    //\n    return pool;\n  }","id":6605,"modified_method":"private static synchronized AnnotatorPool getDefaultAnnotatorPool(final Properties inputProps) {\n    // if the pool already exists reuse!\n    if(pool == null) {\n      // first time we get here\n      pool = new AnnotatorPool();\n    }\n\n    //\n    // tokenizer: breaks text into a sequence of tokens\n    // this is required for all following annotators!\n    //\n    pool.register(STANFORD_TOKENIZE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                          \"false\"))) {\n          return new WhitespaceTokenizerAnnotator(properties);\n        } else {\n          String options = properties.getProperty(\"tokenize.options\",\n                  PTBTokenizerAnnotator.DEFAULT_OPTIONS);\n          boolean keepNewline =\n                  Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                          \"false\"));\n          // If the user specifies \"tokenizeNLs=false\" in tokenize.options, then this default will\n          // be overridden.\n          if (keepNewline) {\n            options = \"tokenizeNLs,\" + options;\n          }\n          return new PTBTokenizerAnnotator(false, options);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(\"tokenize.whitespace:\" +\n                properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                \"false\"))) {\n          os.append(WhitespaceTokenizerAnnotator.EOL_PROPERTY + \":\" +\n                  properties.getProperty(WhitespaceTokenizerAnnotator.EOL_PROPERTY,\n                          \"false\"));\n          os.append(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  properties.getProperty(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY,\n                          \"false\"));\n          return os.toString();\n        } else {\n          os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                          \"false\")));\n        }\n        return os.toString();\n      }\n    });\n\n    pool.register(STANFORD_CLEAN_XML, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String xmlTags =\n          properties.getProperty(\"clean.xmltags\",\n                            CleanXmlAnnotator.DEFAULT_XML_TAGS);\n        String sentenceEndingTags =\n          properties.getProperty(\"clean.sentenceendingtags\",\n                            CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS);\n        String singleSentenceTags =\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS);\n        String allowFlawedString = properties.getProperty(\"clean.allowflawedxml\");\n        boolean allowFlawed = CleanXmlAnnotator.DEFAULT_ALLOW_FLAWS;\n        if (allowFlawedString != null)\n          allowFlawed = Boolean.valueOf(allowFlawedString);\n        String dateTags =\n          properties.getProperty(\"clean.datetags\",\n                            CleanXmlAnnotator.DEFAULT_DATE_TAGS);\n        String docIdTags =\n                properties.getProperty(\"clean.docIdtags\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS);\n        String docTypeTags =\n                properties.getProperty(\"clean.docTypetags\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS);\n        String utteranceTurnTags =\n                properties.getProperty(\"clean.turntags\",\n                        CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS);\n        String speakerTags =\n                properties.getProperty(\"clean.speakertags\",\n                        CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS);\n        String docAnnotations =\n                properties.getProperty(\"clean.docAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS);\n        String tokenAnnotations =\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS);\n        String sectionTags =\n                properties.getProperty(\"clean.sectiontags\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_TAGS);\n        String sectionAnnotations =\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n        String ssplitDiscardTokens =\n                properties.getProperty(\"clean.ssplitDiscardTokens\");\n        CleanXmlAnnotator annotator = new CleanXmlAnnotator(xmlTags,\n            sentenceEndingTags,\n            dateTags,\n            allowFlawed);\n        annotator.setSingleSentenceTagMatcher(singleSentenceTags);\n        annotator.setDocIdTagMatcher(docIdTags);\n        annotator.setDocTypeTagMatcher(docTypeTags);\n        annotator.setDiscourseTags(utteranceTurnTags, speakerTags);\n        annotator.setDocAnnotationPatterns(docAnnotations);\n        annotator.setTokenAnnotationPatterns(tokenAnnotations);\n        annotator.setSectionTagMatcher(sectionTags);\n        annotator.setSectionAnnotationPatterns(sectionAnnotations);\n        annotator.setSsplitDiscardTokensMatcher(ssplitDiscardTokens);\n        return annotator;\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"clean.xmltags:\" +\n                properties.getProperty(\"clean.xmltags\",\n                  CleanXmlAnnotator.DEFAULT_XML_TAGS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.sentenceendingtags\",\n                  CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS) +\n                \"clean.allowflawedxml:\" +\n                properties.getProperty(\"clean.allowflawedxml\", \"\") +\n                \"clean.datetags:\" +\n                properties.getProperty(\"clean.datetags\",\n                  CleanXmlAnnotator.DEFAULT_DATE_TAGS) +\n                \"clean.docidtags:\" +\n                properties.getProperty(\"clean.docid\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS) +\n                \"clean.doctypetags:\" +\n                properties.getProperty(\"clean.doctype\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS) +\n                \"clean.turntags:\" +\n                properties.getProperty(\"clean.turntags\",\n                  CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS) +\n                \"clean.speakertags:\" +\n                properties.getProperty(\"clean.speakertags\",\n                  CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS) +\n                \"clean.docAnnotations:\" +\n                properties.getProperty(\"clean.docAnnotations\",\n                  CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS) +\n                \"clean.tokenAnnotations:\" +\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS) +\n                \"clean.sectiontags:\" +\n                properties.getProperty(\"clean.sectiontags\",\n                  CleanXmlAnnotator.DEFAULT_SECTION_TAGS) +\n                \"clean.sectionAnnotations:\" +\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n      }\n    });\n\n    //\n    // Sentence splitter: splits the above sequence of tokens into\n    // sentences.  This is required when processing entire documents or\n    // text consisting of multiple sentences.\n    //\n    pool.register(STANFORD_SSPLIT, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        boolean nlSplitting = Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (nlSplitting) {\n          boolean whitespaceTokenization = Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\", \"false\"));\n          if (whitespaceTokenization) {\n            if (System.getProperty(\"line.separator\").equals(\"\\n\")) {\n              return WordsToSentencesAnnotator.newlineSplitter(false, \"\\n\");\n            } else {\n              // throw \"\\n\" in just in case files use that instead of\n              // the system separator\n              return WordsToSentencesAnnotator.newlineSplitter(false, System.getProperty(\"line.separator\"), \"\\n\");\n            }\n          } else {\n            return WordsToSentencesAnnotator.newlineSplitter(false, PTBTokenizer.getNewlineToken());\n          }\n\n        } else {\n          // Treat as one sentence: You get a no-op sentence splitter that always returns all tokens as one sentence.\n          String isOneSentence = properties.getProperty(\"ssplit.isOneSentence\");\n          if (Boolean.parseBoolean(isOneSentence)) { // this method treats null as false\n            return WordsToSentencesAnnotator.nonSplitter(false);\n          }\n\n          // multi token sentence boundaries\n          String boundaryMultiTokenRegex = properties.getProperty(\"ssplit.boundaryMultiTokenRegex\");\n\n          // Discard these tokens without marking them as sentence boundaries\n          String tokenPatternsToDiscardProp = properties.getProperty(\"ssplit.tokenPatternsToDiscard\");\n          Set<String> tokenRegexesToDiscard = null;\n          if (tokenPatternsToDiscardProp != null){\n            String [] toks = tokenPatternsToDiscardProp.split(\",\");\n            tokenRegexesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          // regular boundaries\n          String boundaryTokenRegex = properties.getProperty(\"ssplit.boundaryTokenRegex\");\n          Set<String> boundariesToDiscard = null;\n\n          // newline boundaries which are discarded.\n          String bounds = properties.getProperty(\"ssplit.boundariesToDiscard\");\n          if (bounds != null) {\n            String [] toks = bounds.split(\",\");\n            boundariesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          Set<String> htmlElementsToDiscard = null;\n          // HTML boundaries which are discarded\n          bounds = properties.getProperty(\"ssplit.htmlBoundariesToDiscard\");\n          if (bounds != null) {\n            String [] elements = bounds.split(\",\");\n            htmlElementsToDiscard = Generics.newHashSet(Arrays.asList(elements));\n          }\n          String nlsb = properties.getProperty(\"ssplit.newlineIsSentenceBreak\", \"two\");\n\n          return new WordsToSentencesAnnotator(false, boundaryTokenRegex, boundariesToDiscard, htmlElementsToDiscard,\n                  nlsb, boundaryMultiTokenRegex, tokenRegexesToDiscard);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                \"false\"))) {\n          os.append(\"tokenize.whitespace:\" +\n                  properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        } else {\n          os.append(\"ssplit.isOneSentence:\" +\n                  properties.getProperty(\"ssplit.isOneSentence\", \"false\"));\n          if ( ! Boolean.valueOf(properties.getProperty(\"ssplit.isOneSentence\", \"false\"))) {\n            os.append(\"ssplit.boundaryTokenRegex:\" +\n                    properties.getProperty(\"ssplit.boundaryTokenRegex\", \"\"));\n            os.append(\"ssplit.boundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.boundariesToDiscard\", \"\"));\n            os.append(\"ssplit.htmlBoundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.htmlBoundariesToDiscard\", \"\"));\n            os.append(\"ssplit.newlineIsSentenceBreak:\" +\n                    properties.getProperty(\"ssplit.newlineIsSentenceBreak\", \"two\"));\n          }\n        }\n        return os.toString();\n      }\n    });\n\n    //\n    // POS tagger\n    //\n    pool.register(STANFORD_POS, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        try {\n          return new POSTaggerAnnotator(\"pos\", properties);\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return (\"pos.maxlen:\" + properties.getProperty(\"pos.maxlen\", \"\") +\n                \"pos.model:\" + properties.getProperty(\"pos.model\", DefaultPaths.DEFAULT_POS_MODEL) +\n                \"pos.nthreads:\" + properties.getProperty(\"pos.nthreads\", properties.getProperty(\"nthreads\", \"\")));\n      }\n    });\n\n    //\n    // Lemmatizer\n    //\n    pool.register(STANFORD_LEMMA, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new MorphaAnnotator(false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        // nothing for this one\n        return \"\";\n      }\n    });\n\n    //\n    // NER\n    //\n    pool.register(STANFORD_NER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        List<String> models = new ArrayList<String>();\n        String modelNames = properties.getProperty(\"ner.model\");\n        if (modelNames == null) {\n          modelNames = DefaultPaths.DEFAULT_NER_THREECLASS_MODEL + \",\" + DefaultPaths.DEFAULT_NER_MUC_MODEL + \",\" + DefaultPaths.DEFAULT_NER_CONLL_MODEL;\n        }\n        if (modelNames.length() > 0) {\n          models.addAll(Arrays.asList(modelNames.split(\",\")));\n        }\n        if (models.isEmpty()) {\n          // Allow for no real NER model - can just use numeric classifiers or SUTime.\n          // Have to unset ner.model, so unlikely that people got here by accident.\n          System.err.println(\"WARNING: no NER models specified\");\n        }\n        NERClassifierCombiner nerCombiner;\n        try {\n          boolean applyNumericClassifiers =\n            PropertiesUtils.getBool(properties,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT);\n          boolean useSUTime =\n            PropertiesUtils.getBool(properties,\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                NumberSequenceClassifier.USE_SUTIME_DEFAULT);\n          nerCombiner = new NERClassifierCombiner(applyNumericClassifiers,\n                useSUTime, properties,\n                models.toArray(new String[models.size()]));\n        } catch (FileNotFoundException e) {\n          throw new RuntimeIOException(e);\n        }\n        return new NERCombinerAnnotator(nerCombiner, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"ner.model:\" +\n                properties.getProperty(\"ner.model\", \"\") +\n                \"ner.model.3class:\" +\n                properties.getProperty(\"ner.model.3class\",\n                        DefaultPaths.DEFAULT_NER_THREECLASS_MODEL) +\n                \"ner.model.7class:\" +\n                properties.getProperty(\"ner.model.7class\",\n                        DefaultPaths.DEFAULT_NER_MUC_MODEL) +\n                \"ner.model.MISCclass:\" +\n                properties.getProperty(\"ner.model.MISCclass\",\n                        DefaultPaths.DEFAULT_NER_CONLL_MODEL) +\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY + \":\" +\n                properties.getProperty(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                        Boolean.toString(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT)) +\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY + \":\" +\n                properties.getProperty(NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                        Boolean.toString(NumberSequenceClassifier.USE_SUTIME_DEFAULT));\n      }\n    });\n\n    //\n    // Regex NER\n    //\n    pool.register(STANFORD_REGEXNER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new TokensRegexNERAnnotator(\"regexner\", properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return PropertiesUtils.getSignature(\"regexner\", properties, TokensRegexNERAnnotator.SUPPORTED_PROPERTIES);\n      }\n    });\n\n    //\n    // Gender Annotator\n    //\n    pool.register(STANFORD_GENDER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new GenderAnnotator(false, properties.getProperty(\"gender.firstnames\", DefaultPaths.DEFAULT_GENDER_FIRST_NAMES));\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"gender.firstnames:\" +\n                properties.getProperty(\"gender.firstnames\",\n                        DefaultPaths.DEFAULT_GENDER_FIRST_NAMES);\n      }\n    });\n\n\n    //\n    // True caser\n    //\n    pool.register(STANFORD_TRUECASE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String model = properties.getProperty(\"truecase.model\", DefaultPaths.DEFAULT_TRUECASE_MODEL);\n        String bias = properties.getProperty(\"truecase.bias\", TrueCaseAnnotator.DEFAULT_MODEL_BIAS);\n        String mixed = properties.getProperty(\"truecase.mixedcasefile\", DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n        return new TrueCaseAnnotator(model, bias, mixed, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"truecase.model:\" +\n                properties.getProperty(\"truecase.model\",\n                        DefaultPaths.DEFAULT_TRUECASE_MODEL) +\n                \"truecase.bias:\" +\n                properties.getProperty(\"truecase.bias\",\n                        TrueCaseAnnotator.DEFAULT_MODEL_BIAS) +\n                \"truecase.mixedcasefile:\" +\n                properties.getProperty(\"truecase.mixedcasefile\",\n                        DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n      }\n    });\n\n    //\n    // Parser\n    //\n    pool.register(STANFORD_PARSE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String parserType = properties.getProperty(\"parse.type\", \"stanford\");\n        String maxLenStr = properties.getProperty(\"parse.maxlen\");\n\n        if (parserType.equalsIgnoreCase(\"stanford\")) {\n          ParserAnnotator anno = new ParserAnnotator(\"parse\", properties);\n          return anno;\n        } else if (parserType.equalsIgnoreCase(\"charniak\")) {\n          String model = properties.getProperty(\"parse.model\");\n          String parserExecutable = properties.getProperty(\"parse.executable\");\n          if (model == null || parserExecutable == null) {\n            throw new RuntimeException(\"Both parse.model and parse.executable properties must be specified if parse.type=charniak\");\n          }\n          int maxLen = 399;\n          if (maxLenStr != null) {\n            maxLen = Integer.parseInt(maxLenStr);\n          }\n\n          CharniakParserAnnotator anno = new CharniakParserAnnotator(model, parserExecutable, false, maxLen);\n\n          return anno;\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + parserType + \" (currently supported: stanford and charniak)\");\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        String type = properties.getProperty(\"parse.type\", \"stanford\");\n        if(type.equalsIgnoreCase(\"stanford\")){\n          return ParserAnnotator.signature(\"parser\", properties);\n        } else if(type.equalsIgnoreCase(\"charniak\")) {\n          return \"parse.model:\" +\n                  properties.getProperty(\"parse.model\", \"\") +\n                  \"parse.executable:\" +\n                  properties.getProperty(\"parse.executable\", \"\") +\n                  \"parse.maxlen:\" +\n                  properties.getProperty(\"parse.maxlen\", \"\");\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + type +\n                  \" (currently supported: stanford and charniak)\");\n        }\n      }\n    });\n\n    //\n    // Coreference resolution\n    //\n    pool.register(STANFORD_DETERMINISTIC_COREF, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new DeterministicCorefAnnotator(properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return DeterministicCorefAnnotator.signature(properties);\n      }\n    });\n\n    // add annotators loaded via reflection from classnames specified\n    // in the properties\n    for (Object propertyKey : inputProps.stringPropertyNames()) {\n      if (!(propertyKey instanceof String))\n        continue; // should this be an Exception?\n      String property = (String) propertyKey;\n      if (property.startsWith(CUSTOM_ANNOTATOR_PREFIX)) {\n        final String customName =\n          property.substring(CUSTOM_ANNOTATOR_PREFIX.length());\n        final String customClassName = inputProps.getProperty(property);\n        System.err.println(\"Registering annotator \" + customName +\n            \" with class \" + customClassName);\n        pool.register(customName, new AnnotatorFactory(inputProps) {\n          private static final long serialVersionUID = 1L;\n          private final String name = customName;\n          private final String className = customClassName;\n          @Override\n          public Annotator create() {\n            return ReflectionLoading.loadByReflection(className, name,\n                                                      properties);\n          }\n          @Override\n          public String signature() {\n            // keep track of all relevant properties for this annotator here!\n            // since we don't know what props they need, let's copy all\n            // TODO: can we do better here? maybe signature() should be a method in the Annotator?\n            StringBuilder os = new StringBuilder();\n            for(Object key: properties.keySet()) {\n              String skey = (String) key;\n              os.append(skey + \":\" + properties.getProperty(skey));\n            }\n            return os.toString();\n          }\n        });\n      }\n    }\n\n\n    pool.register(STANFORD_RELATION, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new RelationExtractorAnnotator(properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"sup.relation.verbose:\" +\n        properties.getProperty(\"sup.relation.verbose\",\n                \"false\") +\n        properties.getProperty(\"sup.relation.model\",\n                DefaultPaths.DEFAULT_SUP_RELATION_EX_RELATION_MODEL);\n      }\n    });\n    \n    //\n    // add more annotators here!\n    //\n    return pool;\n  }","commit_id":"65a8fe26905112e4b26a83d6d4260ebaff7c4266","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private void construct(Properties props, boolean enforceRequirements) {\n    this.numWords = 0;\n    this.constituentTreePrinter = new TreePrint(\"penn\");\n    this.dependencyTreePrinter = new TreePrint(\"typedDependenciesCollapsed\");\n\n    if (props == null) {\n      // if undefined, find the properties file in the classpath\n      props = loadPropertiesFromClasspath();\n    } else if (props.getProperty(\"annotators\") == null) {\n      // this happens when some command line options are specified (e.g just \"-filelist\") but no properties file is.\n      // we use the options that are given and let them override the default properties from the class path properties.\n      Properties fromClassPath = loadPropertiesFromClasspath();\n      fromClassPath.putAll(props);\n      props = fromClassPath;\n    }\n    this.properties = props;\n    AnnotatorPool pool = getDefaultAnnotatorPool(props);\n\n    // now construct the annotators from the given properties in the given order\n    List<String> annoNames = Arrays.asList(getRequiredProperty(props, \"annotators\").split(\"[, \\t]+\"));\n    Set<String> alreadyAddedAnnoNames = Generics.newHashSet();\n    Set<Requirement> requirementsSatisfied = Generics.newHashSet();\n    for (String name : annoNames) {\n      name = name.trim();\n      if (name.isEmpty()) { continue; }\n      System.err.println(\"Adding annotator \" + name);\n\n      Annotator an = pool.get(name);\n      this.addAnnotator(an);\n\n      if (enforceRequirements) {\n        Set<Requirement> allRequirements = an.requires();\n        for (Requirement requirement : allRequirements) {\n          if (!requirementsSatisfied.contains(requirement)) {\n            String fmt = \"annotator \\\"%s\\\" requires annotator \\\"%s\\\"\";\n            throw new IllegalArgumentException(String.format(fmt, name, requirement));\n          }\n        }\n        requirementsSatisfied.addAll(an.requirementsSatisfied());\n      }\n\n      // the NFL domain requires several post-processing rules after\n      // tokenization.  add these transparently if the NFL annotator\n      // is required\n      if (name.equals(STANFORD_TOKENIZE) &&\n          annoNames.contains(STANFORD_NFL) &&\n          !annoNames.contains(STANFORD_NFL_TOKENIZE)) {\n        Annotator pp = pool.get(STANFORD_NFL_TOKENIZE);\n        this.addAnnotator(pp);\n      }\n\n      alreadyAddedAnnoNames.add(name);\n    }\n\n    // Sanity check\n    if (! alreadyAddedAnnoNames.contains(STANFORD_SSPLIT)) {\n      System.setProperty(NEWLINE_SPLITTER_PROPERTY, \"false\");\n    }\n  }","id":6606,"modified_method":"private void construct(Properties props, boolean enforceRequirements) {\n    this.numWords = 0;\n    this.constituentTreePrinter = new TreePrint(\"penn\");\n    this.dependencyTreePrinter = new TreePrint(\"typedDependenciesCollapsed\");\n\n    if (props == null) {\n      // if undefined, find the properties file in the classpath\n      props = loadPropertiesFromClasspath();\n    } else if (props.getProperty(\"annotators\") == null) {\n      // this happens when some command line options are specified (e.g just \"-filelist\") but no properties file is.\n      // we use the options that are given and let them override the default properties from the class path properties.\n      Properties fromClassPath = loadPropertiesFromClasspath();\n      fromClassPath.putAll(props);\n      props = fromClassPath;\n    }\n    this.properties = props;\n    AnnotatorPool pool = getDefaultAnnotatorPool(props);\n\n    // now construct the annotators from the given properties in the given order\n    List<String> annoNames = Arrays.asList(getRequiredProperty(props, \"annotators\").split(\"[, \\t]+\"));\n    Set<String> alreadyAddedAnnoNames = Generics.newHashSet();\n    Set<Requirement> requirementsSatisfied = Generics.newHashSet();\n    for (String name : annoNames) {\n      name = name.trim();\n      if (name.isEmpty()) { continue; }\n      System.err.println(\"Adding annotator \" + name);\n\n      Annotator an = pool.get(name);\n      this.addAnnotator(an);\n\n      if (enforceRequirements) {\n        Set<Requirement> allRequirements = an.requires();\n        for (Requirement requirement : allRequirements) {\n          if (!requirementsSatisfied.contains(requirement)) {\n            String fmt = \"annotator \\\"%s\\\" requires annotator \\\"%s\\\"\";\n            throw new IllegalArgumentException(String.format(fmt, name, requirement));\n          }\n        }\n        requirementsSatisfied.addAll(an.requirementsSatisfied());\n      }\n\n\n      alreadyAddedAnnoNames.add(name);\n    }\n\n    // Sanity check\n    if (! alreadyAddedAnnoNames.contains(STANFORD_SSPLIT)) {\n      System.setProperty(NEWLINE_SPLITTER_PROPERTY, \"false\");\n    }\n  }","commit_id":"65a8fe26905112e4b26a83d6d4260ebaff7c4266","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private void setTupleValue(Tuple pair, int position, Object value) throws ExecException\n    {\n       if (value instanceof BigInteger)\n           pair.set(position, ((BigInteger) value).intValue());\n       else if (value instanceof ByteBuffer)\n           pair.set(position, new DataByteArray(ByteBufferUtil.getArray((ByteBuffer) value)));\n       else\n           pair.set(position, value);\n    }","id":6607,"modified_method":"private void setTupleValue(Tuple pair, int position, Object value) throws ExecException\n    {\n       if (value instanceof BigInteger)\n           pair.set(position, ((BigInteger) value).intValue());\n       else if (value instanceof ByteBuffer)\n           pair.set(position, new DataByteArray(ByteBufferUtil.getArray((ByteBuffer) value)));\n       else if (value instanceof UUID)\n           pair.set(position, new DataByteArray(UUIDGen.decompose((java.util.UUID) value)));\n       else\n           pair.set(position, value);\n    }","commit_id":"0183dc0b36e684082832de43a21b3dc0a9716d48","url":"https://github.com/apache/cassandra"},{"original_method":"private void setTupleValue(Tuple pair, int position, Object value) throws ExecException\n    {\n       if (value instanceof BigInteger)\n           pair.set(position, ((BigInteger) value).intValue());\n       else if (value instanceof ByteBuffer)\n           pair.set(position, new DataByteArray(ByteBufferUtil.getArray((ByteBuffer) value)));\n       else\n           pair.set(position, value);\n    }","id":6608,"modified_method":"private void setTupleValue(Tuple pair, int position, Object value) throws ExecException\n    {\n       if (value instanceof BigInteger)\n           pair.set(position, ((BigInteger) value).intValue());\n       else if (value instanceof ByteBuffer)\n           pair.set(position, new DataByteArray(ByteBufferUtil.getArray((ByteBuffer) value)));\n       else if (value instanceof UUID)\n           pair.set(position, new DataByteArray(UUIDGen.decompose((java.util.UUID) value)));\n       else\n           pair.set(position, value);\n    }","commit_id":"9e6087c0138eb434e3fee769bae2cdc72b863ba5","url":"https://github.com/apache/cassandra"},{"original_method":"private void setTupleValue(Tuple pair, int position, Object value) throws ExecException\n    {\n       if (value instanceof BigInteger)\n           pair.set(position, ((BigInteger) value).intValue());\n       else if (value instanceof ByteBuffer)\n           pair.set(position, new DataByteArray(ByteBufferUtil.getArray((ByteBuffer) value)));\n       else\n           pair.set(position, value);\n    }","id":6609,"modified_method":"private void setTupleValue(Tuple pair, int position, Object value) throws ExecException\n    {\n       if (value instanceof BigInteger)\n           pair.set(position, ((BigInteger) value).intValue());\n       else if (value instanceof ByteBuffer)\n           pair.set(position, new DataByteArray(ByteBufferUtil.getArray((ByteBuffer) value)));\n       else if (value instanceof UUID)\n           pair.set(position, new DataByteArray(UUIDGen.decompose((java.util.UUID) value)));\n       else\n           pair.set(position, value);\n    }","commit_id":"5cdfaab72c6c8a2a9fab0d1a97fd1cdeafd6c2df","url":"https://github.com/apache/cassandra"},{"original_method":"private byte getPigType(AbstractType type)\n    {\n        if (type instanceof LongType)\n            return DataType.LONG;\n        else if (type instanceof IntegerType)\n            return DataType.INTEGER;\n        else if (type instanceof AsciiType)\n            return DataType.CHARARRAY;\n        else if (type instanceof UTF8Type)\n            return DataType.CHARARRAY;\n        else if (type instanceof FloatType)\n            return DataType.FLOAT;\n        else if (type instanceof DoubleType)\n            return DataType.DOUBLE;\n        else if (type instanceof AbstractCompositeType )\n            return DataType.TUPLE;\n\n        return DataType.BYTEARRAY;\n    }","id":6610,"modified_method":"private byte getPigType(AbstractType type)\n    {\n        if (type instanceof LongType || type instanceof DateType) // DateType is bad and it should feel bad\n            return DataType.LONG;\n        else if (type instanceof IntegerType)\n            return DataType.INTEGER;\n        else if (type instanceof AsciiType)\n            return DataType.CHARARRAY;\n        else if (type instanceof UTF8Type)\n            return DataType.CHARARRAY;\n        else if (type instanceof FloatType)\n            return DataType.FLOAT;\n        else if (type instanceof DoubleType)\n            return DataType.DOUBLE;\n        else if (type instanceof AbstractCompositeType )\n            return DataType.TUPLE;\n\n        return DataType.BYTEARRAY;\n    }","commit_id":"6ba063387f3088e4e21aab20509c6d9237809ce9","url":"https://github.com/apache/cassandra"},{"original_method":"private void setTupleValue(Tuple pair, int position, Object value) throws ExecException\n    {\n       if (value instanceof BigInteger)\n           pair.set(position, ((BigInteger) value).intValue());\n       else if (value instanceof ByteBuffer)\n           pair.set(position, new DataByteArray(ByteBufferUtil.getArray((ByteBuffer) value)));\n       else if (value instanceof UUID)\n           pair.set(position, new DataByteArray(UUIDGen.decompose((java.util.UUID) value)));\n       else\n           pair.set(position, value);\n    }","id":6611,"modified_method":"private void setTupleValue(Tuple pair, int position, Object value) throws ExecException\n    {\n       if (value instanceof BigInteger)\n           pair.set(position, ((BigInteger) value).intValue());\n       else if (value instanceof ByteBuffer)\n           pair.set(position, new DataByteArray(ByteBufferUtil.getArray((ByteBuffer) value)));\n       else if (value instanceof UUID)\n           pair.set(position, new DataByteArray(UUIDGen.decompose((java.util.UUID) value)));\n       else if (value instanceof Date)\n           pair.set(position, new DataByteArray(ByteBufferUtil.getArray(DateType.instance.decompose((Date) value))));\n       else\n           pair.set(position, value);\n    }","commit_id":"6ba063387f3088e4e21aab20509c6d9237809ce9","url":"https://github.com/apache/cassandra"},{"original_method":"public int getJobId() { return _id; }","id":6612,"modified_method":"public long getJobId() { return _id; }","commit_id":"05f2a62cbb197e2809c924e2f679f4217015fd77","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void restart() {\n        synchronized (_jobLock) {\n            _timedJobs.clear();\n            _readyJobs.clear();\n            _jobLock.notifyAll();\n        }\n    }","id":6613,"modified_method":"/** @deprecated do you really want to do this? */\n    public void restart() {\n        synchronized (_jobLock) {\n            _timedJobs.clear();\n            _readyJobs.clear();\n            _jobLock.notifyAll();\n        }\n    }","commit_id":"05f2a62cbb197e2809c924e2f679f4217015fd77","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"void shutdown() { \n        _alive = false; \n        synchronized (_jobLock) {\n            _jobLock.notifyAll();\n        }\n        if (_log.shouldLog(Log.WARN)) {\n            StringBuilder buf = new StringBuilder(1024);\n            buf.append(\"current jobs: \\n\");\n            for (Iterator iter = _queueRunners.values().iterator(); iter.hasNext(); ) {\n                JobQueueRunner runner = (JobQueueRunner)iter.next();\n                Job j = runner.getCurrentJob();\n\n                buf.append(\"Runner \").append(runner.getRunnerId()).append(\": \");\n                if (j == null) {\n                    buf.append(\"no current job \");\n                } else {\n                    buf.append(j.toString());\n                    buf.append(\" started \").append(_context.clock().now() - j.getTiming().getActualStart());\n                    buf.append(\"ms ago\");\n                }\n\n                j = runner.getLastJob();\n                if (j == null) {\n                    buf.append(\"no last job\");\n                } else {\n                    buf.append(j.toString());\n                    buf.append(\" started \").append(_context.clock().now() - j.getTiming().getActualStart());\n                    buf.append(\"ms ago and finished \");\n                    buf.append(_context.clock().now() - j.getTiming().getActualEnd());\n                    buf.append(\"ms ago\");\n                }\n            }\n            buf.append(\"\\nready jobs: \").append(_readyJobs.size()).append(\"\\n\\t\");\n            for (int i = 0; i < _readyJobs.size(); i++) \n                buf.append(_readyJobs.get(i).toString()).append(\"\\n\\t\");\n            buf.append(\"\\n\\ntimed jobs: \").append(_timedJobs.size()).append(\"\\n\\t\");\n            for (int i = 0; i < _timedJobs.size(); i++) \n                buf.append(_timedJobs.get(i).toString()).append(\"\\n\\t\");\n            _log.log(Log.WARN, buf.toString());\n        }\n    }","id":6614,"modified_method":"void shutdown() { \n        _alive = false; \n        _timedJobs.clear();\n        _readyJobs.clear();\n        // The JobQueueRunners are NOT daemons,\n        // so they must be stopped.\n        Job poison = new PoisonJob();\n        for (int i = 0; i < _queueRunners.size(); i++)\n            _readyJobs.offer(poison);\n\n\n      /********\n        if (_log.shouldLog(Log.WARN)) {\n            StringBuilder buf = new StringBuilder(1024);\n            buf.append(\"current jobs: \\n\");\n            for (Iterator iter = _queueRunners.values().iterator(); iter.hasNext(); ) {\n                JobQueueRunner runner = iter.next();\n                Job j = runner.getCurrentJob();\n\n                buf.append(\"Runner \").append(runner.getRunnerId()).append(\": \");\n                if (j == null) {\n                    buf.append(\"no current job \");\n                } else {\n                    buf.append(j.toString());\n                    buf.append(\" started \").append(_context.clock().now() - j.getTiming().getActualStart());\n                    buf.append(\"ms ago\");\n                }\n\n                j = runner.getLastJob();\n                if (j == null) {\n                    buf.append(\"no last job\");\n                } else {\n                    buf.append(j.toString());\n                    buf.append(\" started \").append(_context.clock().now() - j.getTiming().getActualStart());\n                    buf.append(\"ms ago and finished \");\n                    buf.append(_context.clock().now() - j.getTiming().getActualEnd());\n                    buf.append(\"ms ago\");\n                }\n            }\n            buf.append(\"\\nready jobs: \").append(_readyJobs.size()).append(\"\\n\\t\");\n            for (int i = 0; i < _readyJobs.size(); i++) \n                buf.append(_readyJobs.get(i).toString()).append(\"\\n\\t\");\n            buf.append(\"\\n\\ntimed jobs: \").append(_timedJobs.size()).append(\"\\n\\t\");\n            for (int i = 0; i < _timedJobs.size(); i++) \n                buf.append(_timedJobs.get(i).toString()).append(\"\\n\\t\");\n            _log.log(Log.WARN, buf.toString());\n        }\n      ********/\n    }","commit_id":"05f2a62cbb197e2809c924e2f679f4217015fd77","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Start up the queue with the specified number of concurrent processors.\n     * If this method has already been called, it will adjust the number of \n     * runners to meet the new number.  This does not kill jobs running on\n     * excess threads, it merely instructs the threads to die after finishing\n     * the current job.\n     *\n     */\n    public void runQueue(int numThreads) {\n        synchronized (_queueRunners) {\n            // we're still starting up [serially] and we've got at least one runner,\n            // so dont do anything\n            if ( (_queueRunners.size() > 0) && (!_allowParallelOperation) ) return;\n\n            // we've already enabled parallel operation, so grow to however many are\n            // specified\n            if (_queueRunners.size() < numThreads) {\n                if (_log.shouldLog(Log.INFO))\n                    _log.info(\"Increasing the number of queue runners from \" \n                              + _queueRunners.size() + \" to \" + numThreads);\n                for (int i = _queueRunners.size(); i < numThreads; i++) {\n                    JobQueueRunner runner = new JobQueueRunner(_context, i);\n                    _queueRunners.put(Integer.valueOf(i), runner);\n                    Thread t = new I2PThread(runner);\n                    t.setName(\"JobQueue\"+(_runnerId++));\n                    //t.setPriority(I2PThread.MAX_PRIORITY-1);\n                    t.setDaemon(false);\n                    t.start();\n                }\n            } else if (_queueRunners.size() == numThreads) {\n                for (Iterator iter = _queueRunners.values().iterator(); iter.hasNext(); ) {\n                    JobQueueRunner runner = (JobQueueRunner)iter.next();\n                    runner.startRunning();\n                }\n            } else { // numThreads < # runners, so shrink\n                //for (int i = _queueRunners.size(); i > numThreads; i++) {\n                //     QueueRunner runner = (QueueRunner)_queueRunners.get(new Integer(i));\n                //     runner.stopRunning();\n                //}\n            }\n        }\n    }","id":6615,"modified_method":"/**\n     * Start up the queue with the specified number of concurrent processors.\n     * If this method has already been called, it will adjust the number of \n     * runners to meet the new number.  This does not kill jobs running on\n     * excess threads, it merely instructs the threads to die after finishing\n     * the current job.\n     *\n     */\n    public synchronized void runQueue(int numThreads) {\n            // we're still starting up [serially] and we've got at least one runner,\n            // so dont do anything\n            if ( (_queueRunners.size() > 0) && (!_allowParallelOperation) ) return;\n\n            // we've already enabled parallel operation, so grow to however many are\n            // specified\n            if (_queueRunners.size() < numThreads) {\n                if (_log.shouldLog(Log.INFO))\n                    _log.info(\"Increasing the number of queue runners from \" \n                              + _queueRunners.size() + \" to \" + numThreads);\n                for (int i = _queueRunners.size(); i < numThreads; i++) {\n                    JobQueueRunner runner = new JobQueueRunner(_context, i);\n                    _queueRunners.put(Integer.valueOf(i), runner);\n                    Thread t = new I2PThread(runner);\n                    t.setName(\"JobQueue\"+(_runnerId++));\n                    //t.setPriority(I2PThread.MAX_PRIORITY-1);\n                    t.setDaemon(false);\n                    t.start();\n                }\n            } else if (_queueRunners.size() == numThreads) {\n                for (JobQueueRunner runner : _queueRunners.values()) {\n                    runner.startRunning();\n                }\n            } else { // numThreads < # runners, so shrink\n                //for (int i = _queueRunners.size(); i > numThreads; i++) {\n                //     QueueRunner runner = (QueueRunner)_queueRunners.get(new Integer(i));\n                //     runner.stopRunning();\n                //}\n            }\n    }","commit_id":"05f2a62cbb197e2809c924e2f679f4217015fd77","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public long getMaxLag() { \n        synchronized (_jobLock) {\n            if (_readyJobs.size() <= 0) return 0;\n            // first job is the one that has been waiting the longest\n            long startAfter = ((Job)_readyJobs.get(0)).getTiming().getStartAfter();\n            return _context.clock().now() - startAfter;\n        }\n    }","id":6616,"modified_method":"public long getMaxLag() { \n            Job j = _readyJobs.peek();\n            if (j == null) return 0;\n            // first job is the one that has been waiting the longest\n            long startAfter = j.getTiming().getStartAfter();\n            return _context.clock().now() - startAfter;\n    }","commit_id":"05f2a62cbb197e2809c924e2f679f4217015fd77","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void allowParallelOperation() { \n        _allowParallelOperation = true; \n        runQueue(4);\n    }","id":6617,"modified_method":"public void allowParallelOperation() { \n        _allowParallelOperation = true; \n        runQueue(RUNNERS);\n    }","commit_id":"05f2a62cbb197e2809c924e2f679f4217015fd77","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * calculate and update the job timings\n     * if it was lagged too much or took too long to run, spit out\n     * a warning (and if its really excessive, kill the router)\n     */ \n    void updateStats(Job job, long doStart, long origStartAfter, long duration) {\n        if (_context.router() == null) return;\n        String key = job.getName();\n        long lag = doStart - origStartAfter; // how long were we ready and waiting?\n        MessageHistory hist = _context.messageHistory();\n        long uptime = _context.router().getUptime();\n\n        if (lag < 0) lag = 0;\n        if (duration < 0) duration = 0;\n        \n        JobStats stats = null;\n        if (!_jobStats.containsKey(key)) {\n            _jobStats.put(key, new JobStats(key));\n            // yes, if two runners finish the same job at the same time, this could\n            // create an extra object.  but, who cares, its pushed out of the map\n            // immediately anyway.\n        }\n        stats = (JobStats)_jobStats.get(key);\n        stats.jobRan(duration, lag);\n\n        String dieMsg = null;\n\n        if (lag > _lagWarning) {\n            dieMsg = \"Lag too long for job \" + job.getName() + \" [\" + lag + \"ms and a run time of \" + duration + \"ms]\";\n        } else if (duration > _runWarning) {\n            dieMsg = \"Job run too long for job \" + job.getName() + \" [\" + lag + \"ms lag and run time of \" + duration + \"ms]\";\n        }\n\n        if (dieMsg != null) {\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(dieMsg);\n            if (hist != null)\n                hist.messageProcessingError(-1, JobQueue.class.getName(), dieMsg);\n        }\n\n        if ( (lag > _lagFatal) && (uptime > _warmupTime) ) {\n            // this is fscking bad - the network at this size shouldn't have this much real contention\n            // so we're going to DIE DIE DIE\n            if (_log.shouldLog(Log.WARN))\n                _log.log(Log.WARN, \"The router is either incredibly overloaded or (more likely) there's an error.\", new Exception(\"ttttooooo mmmuuuccccchhhh llllaaagggg\"));\n            //try { Thread.sleep(5000); } catch (InterruptedException ie) {}\n            //Router.getInstance().shutdown();\n            return;\n        }\n        \n        if ( (uptime > _warmupTime) && (duration > _runFatal) ) {\n            // slow CPUs can get hosed with ElGamal, but 10s is too much.\n            if (_log.shouldLog(Log.WARN))\n                _log.log(Log.WARN, \"The router is incredibly overloaded - either you have a 386, or (more likely) there's an error. \", new Exception(\"ttttooooo sssllloooowww\"));\n            //try { Thread.sleep(5000); } catch (InterruptedException ie) {}\n            //Router.getInstance().shutdown();\n            return;\n        }\n    }","id":6618,"modified_method":"/**\n     * calculate and update the job timings\n     * if it was lagged too much or took too long to run, spit out\n     * a warning (and if its really excessive, kill the router)\n     */ \n    void updateStats(Job job, long doStart, long origStartAfter, long duration) {\n        if (_context.router() == null) return;\n        String key = job.getName();\n        long lag = doStart - origStartAfter; // how long were we ready and waiting?\n        MessageHistory hist = _context.messageHistory();\n        long uptime = _context.router().getUptime();\n\n        if (lag < 0) lag = 0;\n        if (duration < 0) duration = 0;\n        \n        JobStats stats = _jobStats.get(key);\n        if (stats == null) {\n            stats = new JobStats(key);\n            _jobStats.put(key, stats);\n            // yes, if two runners finish the same job at the same time, this could\n            // create an extra object.  but, who cares, its pushed out of the map\n            // immediately anyway.\n        }\n        stats.jobRan(duration, lag);\n\n        String dieMsg = null;\n\n        if (lag > _lagWarning) {\n            dieMsg = \"Lag too long for job \" + job.getName() + \" [\" + lag + \"ms and a run time of \" + duration + \"ms]\";\n        } else if (duration > _runWarning) {\n            dieMsg = \"Job run too long for job \" + job.getName() + \" [\" + lag + \"ms lag and run time of \" + duration + \"ms]\";\n        }\n\n        if (dieMsg != null) {\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(dieMsg);\n            if (hist != null)\n                hist.messageProcessingError(-1, JobQueue.class.getName(), dieMsg);\n        }\n\n        if ( (lag > _lagFatal) && (uptime > _warmupTime) ) {\n            // this is fscking bad - the network at this size shouldn't have this much real contention\n            // so we're going to DIE DIE DIE\n            if (_log.shouldLog(Log.WARN))\n                _log.log(Log.WARN, \"The router is either incredibly overloaded or (more likely) there's an error.\", new Exception(\"ttttooooo mmmuuuccccchhhh llllaaagggg\"));\n            //try { Thread.sleep(5000); } catch (InterruptedException ie) {}\n            //Router.getInstance().shutdown();\n            return;\n        }\n        \n        if ( (uptime > _warmupTime) && (duration > _runFatal) ) {\n            // slow CPUs can get hosed with ElGamal, but 10s is too much.\n            if (_log.shouldLog(Log.WARN))\n                _log.log(Log.WARN, \"The router is incredibly overloaded - either you have a 386, or (more likely) there's an error. \", new Exception(\"ttttooooo sssllloooowww\"));\n            //try { Thread.sleep(5000); } catch (InterruptedException ie) {}\n            //Router.getInstance().shutdown();\n            return;\n        }\n    }","commit_id":"05f2a62cbb197e2809c924e2f679f4217015fd77","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void renderStatusHTML(Writer out) throws IOException {\n        ArrayList readyJobs = null;\n        ArrayList timedJobs = null;\n        ArrayList activeJobs = new ArrayList(1);\n        ArrayList justFinishedJobs = new ArrayList(4);\n        //out.write(\"<!-- jobQueue rendering -->\\n\");\n        out.flush();\n        \n        int states[] = null;\n        int numRunners = 0;\n        synchronized (_queueRunners) {\n            states = new int[_queueRunners.size()];\n            int i = 0;\n            for (Iterator iter = _queueRunners.values().iterator(); iter.hasNext(); i++) {\n                JobQueueRunner runner = (JobQueueRunner)iter.next();\n                states[i] = runner.getState();\n                Job job = runner.getCurrentJob();\n                if (job != null) {\n                    activeJobs.add(job);\n                } else {\n                    job = runner.getLastJob();\n                    if (job != null)\n                        justFinishedJobs.add(job);\n                }\n            }\n            numRunners = _queueRunners.size();\n        }\n        \n/*******\n        StringBuilder str = new StringBuilder(128);\n        str.append(\"<!-- after queueRunner sync: states: \");\n        for (int i = 0; states != null && i < states.length; i++)\n            str.append(states[i]).append(\" \");\n        str.append(\" -->\\n\");\n        str.append(\"<!-- jobs: \");\n        for (int i = 0; i < activeJobs.size(); i++)\n            str.append(activeJobs.get(i).toString()).append(\" \");\n        str.append(\"-->\\n\");\n        out.write(str.toString());\n        out.flush();\n*******/\n        \n        synchronized (_jobLock) {\n            readyJobs = new ArrayList(_readyJobs); \n            timedJobs = new ArrayList(_timedJobs);\n        }\n        //out.write(\"<!-- jobQueue rendering: after jobLock sync -->\\n\");\n        //out.flush();\n        \n        StringBuilder buf = new StringBuilder(32*1024);\n        buf.append(\"<b><div class=\\\"joblog\\\"><h3>I2P Job Queue<\/h3><div class=\\\"wideload\\\">Job runners: \").append(numRunners);\n        //buf.append(\" [states=\");\n        //if (states != null) \n        //    for (int i = 0; i < states.length; i++) \n        //        buf.append(states[i]).append(\" \");\n        //buf.append(']');\n        buf.append(\"<\/b><br>\\n\");\n\n        long now = _context.clock().now();\n\n        buf.append(\"<hr><b>Active jobs: \").append(activeJobs.size()).append(\"<\/b><ol>\\n\");\n        for (int i = 0; i < activeJobs.size(); i++) {\n            Job j = (Job)activeJobs.get(i);\n            buf.append(\"<li>[started \").append(DataHelper.formatDuration(now-j.getTiming().getStartAfter())).append(\" ago]: \");\n            buf.append(j.toString()).append(\"<\/li>\\n\");\n        }\n        buf.append(\"<\/ol>\\n\");\n        buf.append(\"<hr><b>Just finished jobs: \").append(justFinishedJobs.size()).append(\"<\/b><ol>\\n\");\n        for (int i = 0; i < justFinishedJobs.size(); i++) {\n            Job j = (Job)justFinishedJobs.get(i);\n            buf.append(\"<li>[finished \").append(DataHelper.formatDuration(now-j.getTiming().getActualEnd())).append(\" ago]: \");\n            buf.append(j.toString()).append(\"<\/li>\\n\");\n        }\n        buf.append(\"<\/ol>\\n\");\n        buf.append(\"<hr><b>Ready/waiting jobs: \").append(readyJobs.size()).append(\"<\/b><ol>\\n\");\n        for (int i = 0; i < readyJobs.size(); i++) {\n            Job j = (Job)readyJobs.get(i);\n            buf.append(\"<li>[waiting \");\n            buf.append(DataHelper.formatDuration(now-j.getTiming().getStartAfter()));\n            buf.append(\"]: \");\n            buf.append(j.toString()).append(\"<\/li>\\n\");\n        }\n        buf.append(\"<\/ol>\\n\");\n        out.flush();\n\n        buf.append(\"<hr><b>Scheduled jobs: \").append(timedJobs.size()).append(\"<\/b><ol>\\n\");\n        TreeMap ordered = new TreeMap();\n        for (int i = 0; i < timedJobs.size(); i++) {\n            Job j = (Job)timedJobs.get(i);\n            ordered.put(new Long(j.getTiming().getStartAfter()), j);\n        }\n        for (Iterator iter = ordered.values().iterator(); iter.hasNext(); ) {\n            Job j = (Job)iter.next();\n            long time = j.getTiming().getStartAfter() - now;\n            buf.append(\"<li>\").append(j.getName()).append(\" in \");\n            buf.append(DataHelper.formatDuration(time)).append(\"<\/li>\\n\");\n        }\n        buf.append(\"<\/ol><\/div>\\n\");\n        \n        //out.write(\"<!-- jobQueue rendering: after main buffer, before stats -->\\n\");\n        out.flush();\n        \n        getJobStats(buf);\n        \n        //out.write(\"<!-- jobQueue rendering: after stats -->\\n\");\n        out.flush();\n        \n        out.write(buf.toString());\n    }","id":6619,"modified_method":"public void renderStatusHTML(Writer out) throws IOException {\n        List<Job> readyJobs = null;\n        List<Job> timedJobs = null;\n        List<Job> activeJobs = new ArrayList(RUNNERS);\n        List<Job> justFinishedJobs = new ArrayList(RUNNERS);\n        //out.write(\"<!-- jobQueue rendering -->\\n\");\n        out.flush();\n        \n        //int states[] = null;\n        int numRunners = 0;\n\n        {\n            //states = new int[_queueRunners.size()];\n            int i = 0;\n            for (Iterator<JobQueueRunner> iter = _queueRunners.values().iterator(); iter.hasNext(); i++) {\n                JobQueueRunner runner = iter.next();\n                //states[i] = runner.getState();\n                Job job = runner.getCurrentJob();\n                if (job != null) {\n                    activeJobs.add(job);\n                } else {\n                    job = runner.getLastJob();\n                    if (job != null)\n                        justFinishedJobs.add(job);\n                }\n            }\n            numRunners = _queueRunners.size();\n        }\n        \n/*******\n        StringBuilder str = new StringBuilder(128);\n        str.append(\"<!-- after queueRunner sync: states: \");\n        for (int i = 0; states != null && i < states.length; i++)\n            str.append(states[i]).append(\" \");\n        str.append(\" -->\\n\");\n        str.append(\"<!-- jobs: \");\n        for (int i = 0; i < activeJobs.size(); i++)\n            str.append(activeJobs.get(i).toString()).append(\" \");\n        str.append(\"-->\\n\");\n        out.write(str.toString());\n        out.flush();\n*******/\n        \n        synchronized (_jobLock) {\n            readyJobs = new ArrayList(_readyJobs); \n            timedJobs = new ArrayList(_timedJobs);\n        }\n        //out.write(\"<!-- jobQueue rendering: after jobLock sync -->\\n\");\n        //out.flush();\n        \n        StringBuilder buf = new StringBuilder(32*1024);\n        buf.append(\"<b><div class=\\\"joblog\\\"><h3>I2P Job Queue<\/h3><div class=\\\"wideload\\\">Job runners: \").append(numRunners);\n        //buf.append(\" [states=\");\n        //if (states != null) \n        //    for (int i = 0; i < states.length; i++) \n        //        buf.append(states[i]).append(\" \");\n        //buf.append(']');\n        buf.append(\"<\/b><br>\\n\");\n\n        long now = _context.clock().now();\n\n        buf.append(\"<hr><b>Active jobs: \").append(activeJobs.size()).append(\"<\/b><ol>\\n\");\n        for (int i = 0; i < activeJobs.size(); i++) {\n            Job j = activeJobs.get(i);\n            buf.append(\"<li>[started \").append(DataHelper.formatDuration(now-j.getTiming().getStartAfter())).append(\" ago]: \");\n            buf.append(j.toString()).append(\"<\/li>\\n\");\n        }\n        buf.append(\"<\/ol>\\n\");\n        buf.append(\"<hr><b>Just finished jobs: \").append(justFinishedJobs.size()).append(\"<\/b><ol>\\n\");\n        for (int i = 0; i < justFinishedJobs.size(); i++) {\n            Job j = justFinishedJobs.get(i);\n            buf.append(\"<li>[finished \").append(DataHelper.formatDuration(now-j.getTiming().getActualEnd())).append(\" ago]: \");\n            buf.append(j.toString()).append(\"<\/li>\\n\");\n        }\n        buf.append(\"<\/ol>\\n\");\n        buf.append(\"<hr><b>Ready/waiting jobs: \").append(readyJobs.size()).append(\"<\/b><ol>\\n\");\n        for (int i = 0; i < readyJobs.size(); i++) {\n            Job j = readyJobs.get(i);\n            buf.append(\"<li>[waiting \");\n            buf.append(DataHelper.formatDuration(now-j.getTiming().getStartAfter()));\n            buf.append(\"]: \");\n            buf.append(j.toString()).append(\"<\/li>\\n\");\n        }\n        buf.append(\"<\/ol>\\n\");\n        out.flush();\n\n        buf.append(\"<hr><b>Scheduled jobs: \").append(timedJobs.size()).append(\"<\/b><ol>\\n\");\n        TreeMap<Long, Job> ordered = new TreeMap();\n        for (int i = 0; i < timedJobs.size(); i++) {\n            Job j = timedJobs.get(i);\n            ordered.put(new Long(j.getTiming().getStartAfter()), j);\n        }\n        for (Iterator<Job> iter = ordered.values().iterator(); iter.hasNext(); ) {\n            Job j = iter.next();\n            long time = j.getTiming().getStartAfter() - now;\n            buf.append(\"<li>\").append(j.getName()).append(\" in \");\n            buf.append(DataHelper.formatDuration(time)).append(\"<\/li>\\n\");\n        }\n        buf.append(\"<\/ol><\/div>\\n\");\n        \n        //out.write(\"<!-- jobQueue rendering: after main buffer, before stats -->\\n\");\n        out.flush();\n        \n        getJobStats(buf);\n        \n        //out.write(\"<!-- jobQueue rendering: after stats -->\\n\");\n        out.flush();\n        \n        out.write(buf.toString());\n    }","commit_id":"05f2a62cbb197e2809c924e2f679f4217015fd77","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Enqueue the specified job\n     *\n     */\n    public void addJob(Job job) {\n        if (job == null) return;\n\n        if (job instanceof JobImpl)\n            ((JobImpl)job).addedToQueue();\n\n        long numReady = 0;\n        boolean alreadyExists = false;\n        boolean dropped = false;\n        synchronized (_jobLock) {\n            if (_readyJobs.contains(job))\n                alreadyExists = true;\n            numReady = _readyJobs.size();\n            if (!alreadyExists) {\n                if (_timedJobs.contains(job))\n                    alreadyExists = true;\n            }\n\n            if (shouldDrop(job, numReady)) {\n                job.dropped();\n                dropped = true;\n            } else {\n                if (!alreadyExists) {\n                    if (job.getTiming().getStartAfter() <= _context.clock().now()) {\n                        // don't skew us - its 'start after' its been queued, or later\n                        job.getTiming().setStartAfter(_context.clock().now());\n                        if (job instanceof JobImpl)\n                            ((JobImpl)job).madeReady();\n                        _readyJobs.add(job);\n                    } else {\n                        _timedJobs.add(job);\n                    }\n                }\n            }\n            _jobLock.notifyAll();\n        }\n        \n        _context.statManager().addRateData(\"jobQueue.readyJobs\", numReady, 0);\n        if (dropped) {\n            _context.statManager().addRateData(\"jobQueue.droppedJobs\", 1, 1);\n           if (_log.shouldLog(Log.WARN))\n                _log.warn(\"Dropping job due to overload!  # ready jobs: \" \n                          + numReady + \": job = \" + job);\n        }\n\n        return;\n    }","id":6620,"modified_method":"/**\n     * Enqueue the specified job\n     *\n     */\n    public void addJob(Job job) {\n        if (job == null || !_alive) return;\n\n        if (job instanceof JobImpl)\n            ((JobImpl)job).addedToQueue();\n\n        long numReady = 0;\n        boolean alreadyExists = false;\n        boolean dropped = false;\n        // getNext() is now outside the jobLock, is that ok?\n        synchronized (_jobLock) {\n            if (_readyJobs.contains(job))\n                alreadyExists = true;\n            numReady = _readyJobs.size();\n            if (!alreadyExists) {\n                if (_timedJobs.contains(job))\n                    alreadyExists = true;\n            }\n\n            if (shouldDrop(job, numReady)) {\n                job.dropped();\n                dropped = true;\n            } else {\n                if (!alreadyExists) {\n                    if (job.getTiming().getStartAfter() <= _context.clock().now()) {\n                        // don't skew us - its 'start after' its been queued, or later\n                        job.getTiming().setStartAfter(_context.clock().now());\n                        if (job instanceof JobImpl)\n                            ((JobImpl)job).madeReady();\n                        _readyJobs.offer(job);\n                    } else {\n                        _timedJobs.add(job);\n                    }\n                }\n            }\n            _jobLock.notifyAll();\n        }\n        \n        _context.statManager().addRateData(\"jobQueue.readyJobs\", numReady, 0);\n        if (dropped) {\n            _context.statManager().addRateData(\"jobQueue.droppedJobs\", 1, 1);\n            if (_log.shouldLog(Log.ERROR))\n                _log.error(\"Dropping job due to overload!  # ready jobs: \" \n                          + numReady + \": job = \" + job);\n        }\n    }","commit_id":"05f2a62cbb197e2809c924e2f679f4217015fd77","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/** \n     * retrieve the most recently begin and still currently active job, or null if\n     * no jobs are running\n     */\n    public Job getLastJob() { \n        Job j = null;\n        long when = -1;\n        // not synchronized, so might b0rk if the runners are changed\n        for (Iterator iter = _queueRunners.values().iterator(); iter.hasNext(); ) {\n            JobQueueRunner cur = (JobQueueRunner)iter.next();\n            if (cur.getLastBegin() > when) {\n                j = cur.getCurrentJob();\n                when = cur.getLastBegin();\n            }\n        }\n        return j;\n    }","id":6621,"modified_method":"/** \n     * retrieve the most recently begin and still currently active job, or null if\n     * no jobs are running\n     */\n    public Job getLastJob() { \n        Job j = null;\n        long when = -1;\n        for (JobQueueRunner cur : _queueRunners.values()) {\n            if (cur.getLastBegin() > when) {\n                j = cur.getCurrentJob();\n                when = cur.getLastBegin();\n            }\n        }\n        return j;\n    }","commit_id":"05f2a62cbb197e2809c924e2f679f4217015fd77","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Update the clock data for all jobs in process or scheduled for\n     * completion.\n     */\n    private void updateJobTimings(long delta) {\n        synchronized (_jobLock) {\n            for (int i = 0; i < _timedJobs.size(); i++) {\n                Job j = (Job)_timedJobs.get(i);\n                j.getTiming().offsetChanged(delta);\n            }\n            for (int i = 0; i < _readyJobs.size(); i++) {\n                Job j = (Job)_readyJobs.get(i);\n                j.getTiming().offsetChanged(delta);\n            }\n        }\n        synchronized (_runnerLock) {\n            for (Iterator iter = _queueRunners.values().iterator(); iter.hasNext(); ) {\n                JobQueueRunner runner = (JobQueueRunner)iter.next();\n                Job job = runner.getCurrentJob();\n                if (job != null)\n                    job.getTiming().offsetChanged(delta);\n            }\n        }\n    }","id":6622,"modified_method":"/**\n     * Update the clock data for all jobs in process or scheduled for\n     * completion.\n     */\n    private void updateJobTimings(long delta) {\n        synchronized (_jobLock) {\n            for (int i = 0; i < _timedJobs.size(); i++) {\n                Job j = _timedJobs.get(i);\n                j.getTiming().offsetChanged(delta);\n            }\n            for (Job j : _readyJobs) {\n                j.getTiming().offsetChanged(delta);\n            }\n        }\n        synchronized (_runnerLock) {\n            for (JobQueueRunner runner : _queueRunners.values()) {\n                Job job = runner.getCurrentJob();\n                if (job != null)\n                    job.getTiming().offsetChanged(delta);\n            }\n        }\n    }","commit_id":"05f2a62cbb197e2809c924e2f679f4217015fd77","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void run() {\n            try {\n                while (_alive) {\n                    long now = _context.clock().now();\n                    long timeToWait = -1;\n                    ArrayList toAdd = null;\n                    try {\n                        synchronized (_jobLock) {\n                            for (int i = 0; i < _timedJobs.size(); i++) {\n                                Job j = (Job)_timedJobs.get(i);\n                                // find jobs due to start before now\n                                long timeLeft = j.getTiming().getStartAfter() - now;\n                                if (timeLeft <= 0) {\n                                    if (j instanceof JobImpl)\n                                        ((JobImpl)j).madeReady();\n\n                                    if (toAdd == null) toAdd = new ArrayList(4);\n                                    toAdd.add(j);\n                                    _timedJobs.remove(i);\n                                    i--; // so the index stays consistent\n                                } else {\n                                    if ( (timeToWait <= 0) || (timeLeft < timeToWait) )\n                                        timeToWait = timeLeft;\n                                }\n                            }\n\n                            if (toAdd != null) {\n                                if (_log.shouldLog(Log.DEBUG))\n                                    _log.debug(\"Not waiting - we have \" + toAdd.size() + \" newly ready jobs\");\n                                // rather than addAll, which allocs a byte array rv before adding, \n                                // we iterate, since toAdd is usually going to only be 1 or 2 entries\n                                // and since readyJobs will often have the space, we can avoid the\n                                // extra alloc.  (no, i'm not just being insane - i'm updating this based\n                                // on some profiling data ;)\n                                for (int i = 0; i < toAdd.size(); i++)\n                                    _readyJobs.add(toAdd.get(i));\n                                _jobLock.notifyAll();\n                            } else {\n                                if (timeToWait < 0)\n                                    timeToWait = 30*1000;\n                                else if (timeToWait < 10)\n                                    timeToWait = 10;\n                                else if (timeToWait > 10*1000)\n                                    timeToWait = 10*1000;\n                                //if (_log.shouldLog(Log.DEBUG))\n                                //    _log.debug(\"Waiting \" + timeToWait + \" before rechecking the timed queue\");\n                                _jobLock.wait(timeToWait);\n                            }\n                        } // synchronize (_jobLock)\n                    } catch (InterruptedException ie) {}\n                } // while (_alive)\n            } catch (Throwable t) {\n                _context.clock().removeUpdateListener(this);\n                if (_log.shouldLog(Log.ERROR))\n                    _log.error(\"wtf, pumper killed\", t);\n            }\n        }","id":6623,"modified_method":"public void run() {\n            try {\n                while (_alive) {\n                    long now = _context.clock().now();\n                    long timeToWait = -1;\n                    List<Job> toAdd = null;\n                    try {\n                        synchronized (_jobLock) {\n                            for (int i = 0; i < _timedJobs.size(); i++) {\n                                Job j = _timedJobs.get(i);\n                                // find jobs due to start before now\n                                long timeLeft = j.getTiming().getStartAfter() - now;\n                                if (timeLeft <= 0) {\n                                    if (j instanceof JobImpl)\n                                        ((JobImpl)j).madeReady();\n\n                                    if (toAdd == null) toAdd = new ArrayList(4);\n                                    toAdd.add(j);\n                                    _timedJobs.remove(i);\n                                    i--; // so the index stays consistent\n                                } else {\n                                    if ( (timeToWait <= 0) || (timeLeft < timeToWait) )\n                                        timeToWait = timeLeft;\n                                }\n                            }\n\n                            if (toAdd != null) {\n                                if (_log.shouldLog(Log.DEBUG))\n                                    _log.debug(\"Not waiting - we have \" + toAdd.size() + \" newly ready jobs\");\n                                // rather than addAll, which allocs a byte array rv before adding, \n                                // we iterate, since toAdd is usually going to only be 1 or 2 entries\n                                // and since readyJobs will often have the space, we can avoid the\n                                // extra alloc.  (no, i'm not just being insane - i'm updating this based\n                                // on some profiling data ;)\n                                for (int i = 0; i < toAdd.size(); i++)\n                                    _readyJobs.offer(toAdd.get(i));\n                                _jobLock.notifyAll();\n                            } else {\n                                if (timeToWait < 0)\n                                    timeToWait = 30*1000;\n                                else if (timeToWait < 10)\n                                    timeToWait = 10;\n                                else if (timeToWait > 10*1000)\n                                    timeToWait = 10*1000;\n                                //if (_log.shouldLog(Log.DEBUG))\n                                //    _log.debug(\"Waiting \" + timeToWait + \" before rechecking the timed queue\");\n                                _jobLock.wait(timeToWait);\n                            }\n                        } // synchronize (_jobLock)\n                    } catch (InterruptedException ie) {}\n                } // while (_alive)\n            } catch (Throwable t) {\n                _context.clock().removeUpdateListener(this);\n                if (_log.shouldLog(Log.ERROR))\n                    _log.error(\"wtf, pumper killed\", t);\n            }\n        }","commit_id":"05f2a62cbb197e2809c924e2f679f4217015fd77","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public JobQueue(RouterContext context) {\n        _context = context;\n        _log = context.logManager().getLog(JobQueue.class);\n        _context.statManager().createRateStat(\"jobQueue.readyJobs\", \n                                              \"How many ready and waiting jobs there are?\", \n                                              \"JobQueue\", \n                                              new long[] { 60*1000l, 60*60*1000l, 24*60*60*1000l });\n        _context.statManager().createRateStat(\"jobQueue.droppedJobs\", \n                                              \"How many jobs do we drop due to insane overload?\", \n                                              \"JobQueue\", \n                                              new long[] { 60*1000l, 60*60*1000l, 24*60*60*1000l });\n\n        _alive = true;\n        _readyJobs = new ArrayList(16);\n        _timedJobs = new ArrayList(64);\n        _jobLock = new Object();\n        _queueRunners = new HashMap();\n        _jobStats = Collections.synchronizedSortedMap(new TreeMap());\n        _allowParallelOperation = false;\n        _pumper = new QueuePumper();\n        I2PThread pumperThread = new I2PThread(_pumper);\n        pumperThread.setDaemon(true);\n        pumperThread.setName(\"QueuePumper\");\n        //pumperThread.setPriority(I2PThread.NORM_PRIORITY+1);\n        pumperThread.start();\n    }","id":6624,"modified_method":"public JobQueue(RouterContext context) {\n        _context = context;\n        _log = context.logManager().getLog(JobQueue.class);\n        _context.statManager().createRateStat(\"jobQueue.readyJobs\", \n                                              \"How many ready and waiting jobs there are?\", \n                                              \"JobQueue\", \n                                              new long[] { 60*1000l, 60*60*1000l, 24*60*60*1000l });\n        _context.statManager().createRateStat(\"jobQueue.droppedJobs\", \n                                              \"How many jobs do we drop due to insane overload?\", \n                                              \"JobQueue\", \n                                              new long[] { 60*1000l, 60*60*1000l, 24*60*60*1000l });\n\n        _alive = true;\n        _readyJobs = new LinkedBlockingQueue();\n        _timedJobs = new ArrayList(64);\n        _jobLock = new Object();\n        _queueRunners = new ConcurrentHashMap(RUNNERS);\n        _jobStats = new ConcurrentHashMap();\n        _allowParallelOperation = false;\n        _pumper = new QueuePumper();\n        I2PThread pumperThread = new I2PThread(_pumper, \"Job Queue Pumper\", true);\n        //pumperThread.setPriority(I2PThread.NORM_PRIORITY+1);\n        pumperThread.start();\n    }","commit_id":"05f2a62cbb197e2809c924e2f679f4217015fd77","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * When did the most recently begin job start?\n     */\n    public long getLastJobBegin() { \n        long when = -1;\n        // not synchronized, so might b0rk if the runners are changed\n        for (Iterator iter = _queueRunners.values().iterator(); iter.hasNext(); ) {\n            long cur = ((JobQueueRunner)iter.next()).getLastBegin();\n            if (cur > when)\n                cur = when;\n        }\n        return when; \n    }","id":6625,"modified_method":"/**\n     * When did the most recently begin job start?\n     */\n    public long getLastJobBegin() { \n        long when = -1;\n        for (JobQueueRunner runner : _queueRunners.values()) {\n            long cur = runner.getLastBegin();\n            if (cur > when)\n                cur = when;\n        }\n        return when; \n    }","commit_id":"05f2a62cbb197e2809c924e2f679f4217015fd77","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Blocking call to retrieve the next ready job\n     *\n     */\n    Job getNext() {\n        while (_alive) {\n            try {\n                synchronized (_jobLock) {\n                    if (_readyJobs.size() > 0) {\n                        return (Job)_readyJobs.remove(0);\n                    } else {\n                        _jobLock.wait();\n                    }\n                }\n            } catch (InterruptedException ie) {}\n        }\n        if (_log.shouldLog(Log.WARN))\n            _log.warn(\"No longer alive, returning null\");\n        return null;\n    }","id":6626,"modified_method":"/**\n     * Blocking call to retrieve the next ready job\n     *\n     */\n    Job getNext() {\n        while (_alive) {\n            try {\n                Job j = _readyJobs.take();\n                if (j.getJobId() == POISON_ID)\n                    break;\n                return j;\n            } catch (InterruptedException ie) {}\n        }\n        if (_log.shouldLog(Log.WARN))\n            _log.warn(\"No longer alive, returning null\");\n        return null;\n    }","commit_id":"05f2a62cbb197e2809c924e2f679f4217015fd77","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/** render the HTML for the job stats */\n    private void getJobStats(StringBuilder buf) { \n        buf.append(\"<table>\\n\" +\n                   \"<tr><th>Job<\/th><th>Runs<\/th>\" +\n                   \"<th>Time<\/th><th><i>Avg<\/i><\/th><th><i>Max<\/i><\/th><th><i>Min<\/i><\/th>\" +\n                   \"<th>Pending<\/th><th><i>Avg<\/i><\/th><th><i>Max<\/i><\/th><th><i>Min<\/i><\/th><\/tr>\\n\");\n        long totRuns = 0;\n        long totExecTime = 0;\n        long avgExecTime = 0;\n        long maxExecTime = -1;\n        long minExecTime = -1;\n        long totPendingTime = 0;\n        long avgPendingTime = 0;\n        long maxPendingTime = -1;\n        long minPendingTime = -1;\n\n        TreeMap tstats = null;\n        synchronized (_jobStats) {\n            tstats = new TreeMap(_jobStats);\n        }\n        \n        for (Iterator iter = tstats.values().iterator(); iter.hasNext(); ) {\n            JobStats stats = (JobStats)iter.next();\n            buf.append(\"<tr>\");\n            buf.append(\"<td><b>\").append(stats.getName()).append(\"<\/b><\/td>\");\n            buf.append(\"<td align=\\\"right\\\">\").append(stats.getRuns()).append(\"<\/td>\");\n            buf.append(\"<td align=\\\"right\\\">\").append(stats.getTotalTime()).append(\"<\/td>\");\n            buf.append(\"<td align=\\\"right\\\">\").append(stats.getAvgTime()).append(\"<\/td>\");\n            buf.append(\"<td align=\\\"right\\\">\").append(stats.getMaxTime()).append(\"<\/td>\");\n            buf.append(\"<td align=\\\"right\\\">\").append(stats.getMinTime()).append(\"<\/td>\");\n            buf.append(\"<td align=\\\"right\\\">\").append(stats.getTotalPendingTime()).append(\"<\/td>\");\n            buf.append(\"<td align=\\\"right\\\">\").append(stats.getAvgPendingTime()).append(\"<\/td>\");\n            buf.append(\"<td align=\\\"right\\\">\").append(stats.getMaxPendingTime()).append(\"<\/td>\");\n            buf.append(\"<td align=\\\"right\\\">\").append(stats.getMinPendingTime()).append(\"<\/td>\");\n            buf.append(\"<\/tr>\\n\");\n            totRuns += stats.getRuns();\n            totExecTime += stats.getTotalTime();\n            if (stats.getMaxTime() > maxExecTime)\n                maxExecTime = stats.getMaxTime();\n            if ( (minExecTime < 0) || (minExecTime > stats.getMinTime()) )\n                minExecTime = stats.getMinTime();\n            totPendingTime += stats.getTotalPendingTime();\n            if (stats.getMaxPendingTime() > maxPendingTime)\n                maxPendingTime = stats.getMaxPendingTime();\n            if ( (minPendingTime < 0) || (minPendingTime > stats.getMinPendingTime()) )\n                minPendingTime = stats.getMinPendingTime();\n        }\n\n        if (totRuns != 0) {\n            if (totExecTime != 0)\n                avgExecTime = totExecTime / totRuns;\n            if (totPendingTime != 0)\n                avgPendingTime = totPendingTime / totRuns;\n        }\n\n        buf.append(\"<tr class=\\\"tablefooter\\\">\");\n        buf.append(\"<td><b>\").append(\"SUMMARY\").append(\"<\/b><\/td>\");\n        buf.append(\"<td align=\\\"right\\\">\").append(totRuns).append(\"<\/td>\");\n        buf.append(\"<td align=\\\"right\\\">\").append(totExecTime).append(\"<\/td>\");\n        buf.append(\"<td align=\\\"right\\\">\").append(avgExecTime).append(\"<\/td>\");\n        buf.append(\"<td align=\\\"right\\\">\").append(maxExecTime).append(\"<\/td>\");\n        buf.append(\"<td align=\\\"right\\\">\").append(minExecTime).append(\"<\/td>\");\n        buf.append(\"<td align=\\\"right\\\">\").append(totPendingTime).append(\"<\/td>\");\n        buf.append(\"<td align=\\\"right\\\">\").append(avgPendingTime).append(\"<\/td>\");\n        buf.append(\"<td align=\\\"right\\\">\").append(maxPendingTime).append(\"<\/td>\");\n        buf.append(\"<td align=\\\"right\\\">\").append(minPendingTime).append(\"<\/td>\");\n        buf.append(\"<\/tr><\/table><\/div>\\n\");\n    }","id":6627,"modified_method":"/** render the HTML for the job stats */\n    private void getJobStats(StringBuilder buf) { \n        buf.append(\"<table>\\n\" +\n                   \"<tr><th>Job<\/th><th>Runs<\/th>\" +\n                   \"<th>Time<\/th><th><i>Avg<\/i><\/th><th><i>Max<\/i><\/th><th><i>Min<\/i><\/th>\" +\n                   \"<th>Pending<\/th><th><i>Avg<\/i><\/th><th><i>Max<\/i><\/th><th><i>Min<\/i><\/th><\/tr>\\n\");\n        long totRuns = 0;\n        long totExecTime = 0;\n        long avgExecTime = 0;\n        long maxExecTime = -1;\n        long minExecTime = -1;\n        long totPendingTime = 0;\n        long avgPendingTime = 0;\n        long maxPendingTime = -1;\n        long minPendingTime = -1;\n\n        TreeMap<String, JobStats> tstats = new TreeMap(_jobStats);\n        \n        for (Iterator<JobStats> iter = tstats.values().iterator(); iter.hasNext(); ) {\n            JobStats stats = iter.next();\n            buf.append(\"<tr>\");\n            buf.append(\"<td><b>\").append(stats.getName()).append(\"<\/b><\/td>\");\n            buf.append(\"<td align=\\\"right\\\">\").append(stats.getRuns()).append(\"<\/td>\");\n            buf.append(\"<td align=\\\"right\\\">\").append(stats.getTotalTime()).append(\"<\/td>\");\n            buf.append(\"<td align=\\\"right\\\">\").append(stats.getAvgTime()).append(\"<\/td>\");\n            buf.append(\"<td align=\\\"right\\\">\").append(stats.getMaxTime()).append(\"<\/td>\");\n            buf.append(\"<td align=\\\"right\\\">\").append(stats.getMinTime()).append(\"<\/td>\");\n            buf.append(\"<td align=\\\"right\\\">\").append(stats.getTotalPendingTime()).append(\"<\/td>\");\n            buf.append(\"<td align=\\\"right\\\">\").append(stats.getAvgPendingTime()).append(\"<\/td>\");\n            buf.append(\"<td align=\\\"right\\\">\").append(stats.getMaxPendingTime()).append(\"<\/td>\");\n            buf.append(\"<td align=\\\"right\\\">\").append(stats.getMinPendingTime()).append(\"<\/td>\");\n            buf.append(\"<\/tr>\\n\");\n            totRuns += stats.getRuns();\n            totExecTime += stats.getTotalTime();\n            if (stats.getMaxTime() > maxExecTime)\n                maxExecTime = stats.getMaxTime();\n            if ( (minExecTime < 0) || (minExecTime > stats.getMinTime()) )\n                minExecTime = stats.getMinTime();\n            totPendingTime += stats.getTotalPendingTime();\n            if (stats.getMaxPendingTime() > maxPendingTime)\n                maxPendingTime = stats.getMaxPendingTime();\n            if ( (minPendingTime < 0) || (minPendingTime > stats.getMinPendingTime()) )\n                minPendingTime = stats.getMinPendingTime();\n        }\n\n        if (totRuns != 0) {\n            if (totExecTime != 0)\n                avgExecTime = totExecTime / totRuns;\n            if (totPendingTime != 0)\n                avgPendingTime = totPendingTime / totRuns;\n        }\n\n        buf.append(\"<tr class=\\\"tablefooter\\\">\");\n        buf.append(\"<td><b>\").append(\"SUMMARY\").append(\"<\/b><\/td>\");\n        buf.append(\"<td align=\\\"right\\\">\").append(totRuns).append(\"<\/td>\");\n        buf.append(\"<td align=\\\"right\\\">\").append(totExecTime).append(\"<\/td>\");\n        buf.append(\"<td align=\\\"right\\\">\").append(avgExecTime).append(\"<\/td>\");\n        buf.append(\"<td align=\\\"right\\\">\").append(maxExecTime).append(\"<\/td>\");\n        buf.append(\"<td align=\\\"right\\\">\").append(minExecTime).append(\"<\/td>\");\n        buf.append(\"<td align=\\\"right\\\">\").append(totPendingTime).append(\"<\/td>\");\n        buf.append(\"<td align=\\\"right\\\">\").append(avgPendingTime).append(\"<\/td>\");\n        buf.append(\"<td align=\\\"right\\\">\").append(maxPendingTime).append(\"<\/td>\");\n        buf.append(\"<td align=\\\"right\\\">\").append(minPendingTime).append(\"<\/td>\");\n        buf.append(\"<\/tr><\/table><\/div>\\n\");\n    }","commit_id":"05f2a62cbb197e2809c924e2f679f4217015fd77","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public int getReadyCount() { \n        synchronized (_jobLock) {\n            return _readyJobs.size();\n        }\n    }","id":6628,"modified_method":"public int getReadyCount() { \n            return _readyJobs.size();\n    }","commit_id":"05f2a62cbb197e2809c924e2f679f4217015fd77","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * When did the most recently begin job start?\n     */\n    public long getLastJobEnd() { \n        long when = -1;\n        // not synchronized, so might b0rk if the runners are changed\n        for (Iterator iter = _queueRunners.values().iterator(); iter.hasNext(); ) {\n            long cur = ((JobQueueRunner)iter.next()).getLastEnd();\n            if (cur > when)\n                cur = when;\n        }\n        return when; \n    }","id":6629,"modified_method":"/**\n     * When did the most recently begin job start?\n     */\n    public long getLastJobEnd() { \n        long when = -1;\n        for (JobQueueRunner runner : _queueRunners.values()) {\n            long cur = runner.getLastEnd();\n            if (cur > when)\n                cur = when;\n        }\n        return when; \n    }","commit_id":"05f2a62cbb197e2809c924e2f679f4217015fd77","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void run() {\n        _state = 2;\n        long lastActive = _context.clock().now();\n        long jobNum = 0;\n        while ( (_keepRunning) && (_context.jobQueue().isAlive()) ) { \n            _state = 3;\n            try {\n                Job job = _context.jobQueue().getNext();\n                _state = 4;\n                if (job == null) {\n                    _state = 5;\n                    if (_context.router().isAlive())\n                        if (_log.shouldLog(Log.ERROR))\n                            _log.error(\"getNext returned null - dead?\");\n                    continue;\n                }\n                long now = _context.clock().now();\n\n                long enqueuedTime = 0;\n                if (job instanceof JobImpl) {\n                    _state = 6;\n                    long when = ((JobImpl)job).getMadeReadyOn();\n                    if (when <= 0) {\n                        _state = 7;\n                        _log.error(\"Job was not made ready?! \" + job, \n                                   new Exception(\"Not made ready?!\"));\n                    } else {\n                        _state = 8;\n                        enqueuedTime = now - when;\n                    }\n                }\n\n                long betweenJobs = now - lastActive;\n                _currentJob = job;\n                _lastJob = null;\n                _state = 9;\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(\"Runner \" + _id + \" running job \" + job.getJobId() + \": \" + job.getName());\n                long origStartAfter = job.getTiming().getStartAfter();\n                long doStart = _context.clock().now();\n                _state = 10;\n                job.getTiming().start();\n                runCurrentJob();\n                job.getTiming().end();\n                _state = 11;\n                long duration = job.getTiming().getActualEnd() - job.getTiming().getActualStart();\n                long beforeUpdate = _context.clock().now();\n                _state = 12;\n                _context.jobQueue().updateStats(job, doStart, origStartAfter, duration);\n                _state = 13;\n                long diff = _context.clock().now() - beforeUpdate;\n\n                long lag = doStart - origStartAfter;\n                if (lag < 0) lag = 0;\n                \n                _context.statManager().addRateData(\"jobQueue.jobRunnerInactive\", betweenJobs, betweenJobs);\n                _context.statManager().addRateData(\"jobQueue.jobRun\", duration, duration);\n                _context.statManager().addRateData(\"jobQueue.jobLag\", lag, 0);\n                _context.statManager().addRateData(\"jobQueue.jobWait\", enqueuedTime, enqueuedTime);\n\n                if (duration > 1000) {\n                    _context.statManager().addRateData(\"jobQueue.jobRunSlow\", duration, duration);\n                    if (_log.shouldLog(Log.WARN))\n                        _log.warn(\"Duration of \" + duration + \" (lag \"+ (doStart-origStartAfter) \n                                  + \") on job \" + _currentJob);\n                }\n                \n                _state = 14;\n                \n                if (diff > 100) {\n                    if (_log.shouldLog(Log.WARN))\n                        _log.warn(\"Updating statistics for the job took too long [\" + diff + \"ms]\");\n                }\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(\"Job duration \" + duration + \"ms for \" + job.getName() \n                               + \" with lag of \" + (doStart-origStartAfter) + \"ms\");\n                lastActive = _context.clock().now();\n                _lastJob = _currentJob;\n                _currentJob = null;\n                _lastEnd = lastActive;\n                jobNum++;\n                _state = 15;\n                \n                //if ( (jobNum % 10) == 0)\n                //    System.gc();\n            } catch (Throwable t) {\n                if (_log.shouldLog(Log.CRIT))\n                    _log.log(Log.CRIT, \"WTF, error running?\", t);\n            }\n        }\n        _state = 16;\n        if (_context.router().isAlive())\n            if (_log.shouldLog(Log.CRIT))\n                _log.log(Log.CRIT, \"Queue runner \" + _id + \" exiting\");\n        _context.jobQueue().removeRunner(_id);\n        _state = 17;\n    }","id":6630,"modified_method":"public void run() {\n        //_state = 2;\n        long lastActive = _context.clock().now();\n        long jobNum = 0;\n        while ( (_keepRunning) && (_context.jobQueue().isAlive()) ) { \n            //_state = 3;\n            try {\n                Job job = _context.jobQueue().getNext();\n                //_state = 4;\n                if (job == null) {\n                    //_state = 5;\n                    if (_context.router().isAlive())\n                        if (_log.shouldLog(Log.ERROR))\n                            _log.error(\"getNext returned null - dead?\");\n                    continue;\n                }\n                long now = _context.clock().now();\n\n                long enqueuedTime = 0;\n                if (job instanceof JobImpl) {\n                    //_state = 6;\n                    long when = ((JobImpl)job).getMadeReadyOn();\n                    if (when <= 0) {\n                        //_state = 7;\n                        _log.error(\"Job was not made ready?! \" + job, \n                                   new Exception(\"Not made ready?!\"));\n                    } else {\n                        //_state = 8;\n                        enqueuedTime = now - when;\n                    }\n                }\n\n                long betweenJobs = now - lastActive;\n                _currentJob = job;\n                _lastJob = null;\n                //_state = 9;\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(\"Runner \" + _id + \" running job \" + job.getJobId() + \": \" + job.getName());\n                long origStartAfter = job.getTiming().getStartAfter();\n                long doStart = _context.clock().now();\n                //_state = 10;\n                job.getTiming().start();\n                runCurrentJob();\n                job.getTiming().end();\n                //_state = 11;\n                long duration = job.getTiming().getActualEnd() - job.getTiming().getActualStart();\n                long beforeUpdate = _context.clock().now();\n                //_state = 12;\n                _context.jobQueue().updateStats(job, doStart, origStartAfter, duration);\n                //_state = 13;\n                long diff = _context.clock().now() - beforeUpdate;\n\n                long lag = doStart - origStartAfter;\n                if (lag < 0) lag = 0;\n                \n                //_context.statManager().addRateData(\"jobQueue.jobRunnerInactive\", betweenJobs, betweenJobs);\n                _context.statManager().addRateData(\"jobQueue.jobRun\", duration, duration);\n                _context.statManager().addRateData(\"jobQueue.jobLag\", lag, 0);\n                _context.statManager().addRateData(\"jobQueue.jobWait\", enqueuedTime, enqueuedTime);\n\n                if (duration > 1000) {\n                    _context.statManager().addRateData(\"jobQueue.jobRunSlow\", duration, duration);\n                    if (_log.shouldLog(Log.WARN))\n                        _log.warn(\"Duration of \" + duration + \" (lag \"+ (doStart-origStartAfter) \n                                  + \") on job \" + _currentJob);\n                }\n                \n                //_state = 14;\n                \n                if (diff > 100) {\n                    if (_log.shouldLog(Log.WARN))\n                        _log.warn(\"Updating statistics for the job took too long [\" + diff + \"ms]\");\n                }\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(\"Job duration \" + duration + \"ms for \" + job.getName() \n                               + \" with lag of \" + (doStart-origStartAfter) + \"ms\");\n                lastActive = _context.clock().now();\n                _lastJob = _currentJob;\n                _currentJob = null;\n                _lastEnd = lastActive;\n                jobNum++;\n                //_state = 15;\n                \n                //if ( (jobNum % 10) == 0)\n                //    System.gc();\n            } catch (Throwable t) {\n                if (_log.shouldLog(Log.CRIT))\n                    _log.log(Log.CRIT, \"WTF, error running?\", t);\n            }\n        }\n        //_state = 16;\n        if (_context.router().isAlive())\n            if (_log.shouldLog(Log.CRIT))\n                _log.log(Log.CRIT, \"Queue runner \" + _id + \" exiting\");\n        _context.jobQueue().removeRunner(_id);\n        //_state = 17;\n    }","commit_id":"05f2a62cbb197e2809c924e2f679f4217015fd77","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private void runCurrentJob() {\n        try {\n            _state = 18;\n            _lastBegin = _context.clock().now();\n            _currentJob.runJob();\n            _state = 19;\n        } catch (OutOfMemoryError oom) {\n            _state = 20;\n            try {\n                if (_log.shouldLog(Log.CRIT))\n                    _log.log(Log.CRIT, \"Router ran out of memory, shutting down\", oom);\n                _log.log(Log.CRIT, _currentJob.getClass().getName());\n                _context.router().shutdown(Router.EXIT_OOM);\n            } catch (Throwable t) {\t\n                System.err.println(\"***Router ran out of memory, shutting down hard\");\n            }\n            try { Thread.sleep(1000); } catch (InterruptedException ie) {}\n            System.exit(-1);\n        } catch (Throwable t) {\n            _state = 21;\n            if (_log.shouldLog(Log.CRIT))\n                _log.log(Log.CRIT, \"Error processing job [\" + _currentJob.getName() \n                                   + \"] on thread \" + _id + \": \" + t.getMessage(), t);\n            if (_log.shouldLog(Log.ERROR))\n                _log.error(\"The above job was enqueued by: \", _currentJob.getAddedBy());\n        }\n    }","id":6631,"modified_method":"private void runCurrentJob() {\n        try {\n            //_state = 18;\n            _lastBegin = _context.clock().now();\n            _currentJob.runJob();\n            //_state = 19;\n        } catch (OutOfMemoryError oom) {\n            //_state = 20;\n            try {\n                if (_log.shouldLog(Log.CRIT))\n                    _log.log(Log.CRIT, \"Router ran out of memory, shutting down\", oom);\n                _log.log(Log.CRIT, _currentJob.getClass().getName());\n                _context.router().shutdown(Router.EXIT_OOM);\n            } catch (Throwable t) {\t\n                System.err.println(\"***Router ran out of memory, shutting down hard\");\n            }\n            try { Thread.sleep(1000); } catch (InterruptedException ie) {}\n            System.exit(-1);\n        } catch (Throwable t) {\n            //_state = 21;\n            if (_log.shouldLog(Log.CRIT))\n                _log.log(Log.CRIT, \"Error processing job [\" + _currentJob.getName() \n                                   + \"] on thread \" + _id + \": \" + t.getMessage(), t);\n            if (_log.shouldLog(Log.ERROR))\n                _log.error(\"The above job was enqueued by: \", _currentJob.getAddedBy());\n        }\n    }","commit_id":"05f2a62cbb197e2809c924e2f679f4217015fd77","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public JobQueueRunner(RouterContext context, int id) {\n        _context = context;\n        _id = id;\n        _keepRunning = true;\n        _numJobs = 0;\n        _currentJob = null;\n        _lastJob = null;\n        _log = _context.logManager().getLog(JobQueueRunner.class);\n        _context.statManager().createRateStat(\"jobQueue.jobRun\", \"How long jobs take\", \"JobQueue\", new long[] { 60*1000l, 60*60*1000l, 24*60*60*1000l });\n        _context.statManager().createRateStat(\"jobQueue.jobRunSlow\", \"How long jobs that take over a second take\", \"JobQueue\", new long[] { 10*60*1000l, 60*60*1000l, 24*60*60*1000l });\n        _context.statManager().createRateStat(\"jobQueue.jobLag\", \"How long jobs have to wait before running\", \"JobQueue\", new long[] { 60*1000l, 60*60*1000l, 24*60*60*1000l });\n        _context.statManager().createRateStat(\"jobQueue.jobWait\", \"How long does a job sit on the job queue?\", \"JobQueue\", new long[] { 60*1000l, 60*60*1000l, 24*60*60*1000l });\n        _context.statManager().createRateStat(\"jobQueue.jobRunnerInactive\", \"How long are runners inactive?\", \"JobQueue\", new long[] { 60*1000l, 60*60*1000l, 24*60*60*1000l });\n        _state = 1;\n    }","id":6632,"modified_method":"public JobQueueRunner(RouterContext context, int id) {\n        _context = context;\n        _id = id;\n        _keepRunning = true;\n        _numJobs = 0;\n        _currentJob = null;\n        _lastJob = null;\n        _log = _context.logManager().getLog(JobQueueRunner.class);\n        _context.statManager().createRateStat(\"jobQueue.jobRun\", \"How long jobs take\", \"JobQueue\", new long[] { 60*60*1000l, 24*60*60*1000l });\n        _context.statManager().createRateStat(\"jobQueue.jobRunSlow\", \"How long jobs that take over a second take\", \"JobQueue\", new long[] { 60*60*1000l, 24*60*60*1000l });\n        _context.statManager().createRateStat(\"jobQueue.jobLag\", \"How long jobs have to wait before running\", \"JobQueue\", new long[] { 60*1000l, 60*60*1000l, 24*60*60*1000l });\n        _context.statManager().createRateStat(\"jobQueue.jobWait\", \"How long does a job sit on the job queue?\", \"JobQueue\", new long[] { 60*60*1000l, 24*60*60*1000l });\n        //_context.statManager().createRateStat(\"jobQueue.jobRunnerInactive\", \"How long are runners inactive?\", \"JobQueue\", new long[] { 60*1000l, 60*60*1000l, 24*60*60*1000l });\n        //_state = 1;\n    }","commit_id":"05f2a62cbb197e2809c924e2f679f4217015fd77","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * How many peers can we talk to right now?\n     *\n     */\n    @Override\n    public int countActivePeers() { synchronized (_conLock) { return _conByIdent.size(); } }","id":6633,"modified_method":"/**\n     * How many peers can we talk to right now?\n     *\n     */\n    @Override\n    public int countActivePeers() { return _conByIdent.size(); }","commit_id":"d2c16415694a77f03f8509c3023c7a7e5c5aa61f","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public NTCPTransport(RouterContext ctx, DHSessionKeyBuilder.Factory dh) {\n        super(ctx);\n        _dhFactory = dh;\n        _log = ctx.logManager().getLog(getClass());\n\n        _context.statManager().createRateStat(\"ntcp.sendTime\", \"Total message lifetime when sent completely\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.sendQueueSize\", \"How many messages were ahead of the current one on the connection's queue when it was first added\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.receiveTime\", \"How long it takes to receive an inbound message\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.receiveSize\", \"How large the received message was\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.sendBacklogTime\", \"How long the head of the send queue has been waiting when we fail to add a new one to the queue (period is the number of messages queued)\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.failsafeWrites\", \"How many times do we need to proactively add in an extra nio write to a peer at any given failsafe pass?\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.failsafeCloses\", \"How many times do we need to proactively close an idle connection to a peer at any given failsafe pass?\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.failsafeInvalid\", \"How many times do we close a connection to a peer to work around a JVM bug?\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.accept\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.attemptShitlistedPeer\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.attemptUnreachablePeer\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.closeOnBacklog\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.connectFailedIOE\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.connectFailedInvalidPort\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.bidRejectedLocalAddress\", \"\", \"ntcp\", RATES);\n        //_context.statManager().createRateStat(\"ntcp.bidRejectedNoNTCPAddress\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.connectFailedTimeout\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.connectFailedTimeoutIOE\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.connectFailedUnresolved\", \"\", \"ntcp\", RATES);\n        //_context.statManager().createRateStat(\"ntcp.connectImmediate\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.connectSuccessful\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.corruptDecryptedI2NP\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.corruptI2NPCRC\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.corruptI2NPIME\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.corruptI2NPIOE\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.corruptMetaCRC\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.corruptSkew\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.corruptTooLargeI2NP\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.dontSendOnBacklog\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.inboundCheckConnection\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.inboundEstablished\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.inboundEstablishedDuplicate\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.infoMessageEnqueued\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.floodInfoMessageEnqueued\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidDH\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidHXY\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidHXxorBIH\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidInboundDFE\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidInboundIOE\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidInboundSignature\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidInboundSize\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidInboundSkew\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidSignature\", \"\", \"ntcp\", RATES);\n        //_context.statManager().createRateStat(\"ntcp.liveReadBufs\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.multipleCloseOnRemove\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.outboundEstablishFailed\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.outboundFailedIOEImmediate\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidOutboundSkew\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.noBidTooLargeI2NP\", \"send size\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.queuedRecv\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.read\", \"\", \"ntcp\", RATES);\n        //_context.statManager().createRateStat(\"ntcp.readEOF\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.readError\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.receiveCorruptEstablishment\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.receiveMeta\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.registerConnect\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.throttledReadComplete\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.throttledWriteComplete\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.wantsQueuedWrite\", \"\", \"ntcp\", RATES);\n        //_context.statManager().createRateStat(\"ntcp.write\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.writeError\", \"\", \"ntcp\", RATES);\n        _establishing = new ConcurrentHashSet(16);\n        _conLock = new Object();\n        _conByIdent = new HashMap(64);\n\n        _finisher = new NTCPSendFinisher(ctx, this);\n\n        _pumper = new EventPumper(ctx, this);\n        _reader = new Reader(ctx);\n        _writer = new net.i2p.router.transport.ntcp.Writer(ctx);\n\n        _fastBid = new SharedBid(25); // best\n        _slowBid = new SharedBid(70); // better than ssu unestablished, but not better than ssu established\n        _slowCostBid = new SharedBid(85);\n        _nearCapacityBid = new SharedBid(90); // not better than ssu - save our conns for inbound\n        _nearCapacityCostBid = new SharedBid(105);\n        _transientFail = new SharedBid(TransportBid.TRANSIENT_FAIL);\n    }","id":6634,"modified_method":"public NTCPTransport(RouterContext ctx, DHSessionKeyBuilder.Factory dh) {\n        super(ctx);\n        _dhFactory = dh;\n        _log = ctx.logManager().getLog(getClass());\n\n        _context.statManager().createRateStat(\"ntcp.sendTime\", \"Total message lifetime when sent completely\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.sendQueueSize\", \"How many messages were ahead of the current one on the connection's queue when it was first added\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.receiveTime\", \"How long it takes to receive an inbound message\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.receiveSize\", \"How large the received message was\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.sendBacklogTime\", \"How long the head of the send queue has been waiting when we fail to add a new one to the queue (period is the number of messages queued)\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.failsafeWrites\", \"How many times do we need to proactively add in an extra nio write to a peer at any given failsafe pass?\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.failsafeCloses\", \"How many times do we need to proactively close an idle connection to a peer at any given failsafe pass?\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.failsafeInvalid\", \"How many times do we close a connection to a peer to work around a JVM bug?\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.accept\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.attemptShitlistedPeer\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.attemptUnreachablePeer\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.closeOnBacklog\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.connectFailedIOE\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.connectFailedInvalidPort\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.bidRejectedLocalAddress\", \"\", \"ntcp\", RATES);\n        //_context.statManager().createRateStat(\"ntcp.bidRejectedNoNTCPAddress\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.connectFailedTimeout\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.connectFailedTimeoutIOE\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.connectFailedUnresolved\", \"\", \"ntcp\", RATES);\n        //_context.statManager().createRateStat(\"ntcp.connectImmediate\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.connectSuccessful\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.corruptDecryptedI2NP\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.corruptI2NPCRC\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.corruptI2NPIME\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.corruptI2NPIOE\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.corruptMetaCRC\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.corruptSkew\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.corruptTooLargeI2NP\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.dontSendOnBacklog\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.inboundCheckConnection\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.inboundEstablished\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.inboundEstablishedDuplicate\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.infoMessageEnqueued\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.floodInfoMessageEnqueued\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidDH\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidHXY\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidHXxorBIH\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidInboundDFE\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidInboundIOE\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidInboundSignature\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidInboundSize\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidInboundSkew\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidSignature\", \"\", \"ntcp\", RATES);\n        //_context.statManager().createRateStat(\"ntcp.liveReadBufs\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.multipleCloseOnRemove\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.outboundEstablishFailed\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.outboundFailedIOEImmediate\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.invalidOutboundSkew\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.noBidTooLargeI2NP\", \"send size\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.queuedRecv\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.read\", \"\", \"ntcp\", RATES);\n        //_context.statManager().createRateStat(\"ntcp.readEOF\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.readError\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.receiveCorruptEstablishment\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.receiveMeta\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.registerConnect\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.throttledReadComplete\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.throttledWriteComplete\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.wantsQueuedWrite\", \"\", \"ntcp\", RATES);\n        //_context.statManager().createRateStat(\"ntcp.write\", \"\", \"ntcp\", RATES);\n        _context.statManager().createRateStat(\"ntcp.writeError\", \"\", \"ntcp\", RATES);\n        _establishing = new ConcurrentHashSet(16);\n        _conLock = new Object();\n        _conByIdent = new ConcurrentHashMap(64);\n\n        _finisher = new NTCPSendFinisher(ctx, this);\n\n        _pumper = new EventPumper(ctx, this);\n        _reader = new Reader(ctx);\n        _writer = new net.i2p.router.transport.ntcp.Writer(ctx);\n\n        _fastBid = new SharedBid(25); // best\n        _slowBid = new SharedBid(70); // better than ssu unestablished, but not better than ssu established\n        _slowCostBid = new SharedBid(85);\n        _nearCapacityBid = new SharedBid(90); // not better than ssu - save our conns for inbound\n        _nearCapacityCostBid = new SharedBid(105);\n        _transientFail = new SharedBid(TransportBid.TRANSIENT_FAIL);\n    }","commit_id":"d2c16415694a77f03f8509c3023c7a7e5c5aa61f","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Override\n    public boolean isEstablished(Hash dest) {\n        synchronized (_conLock) {\n            NTCPConnection con = _conByIdent.get(dest);\n            return (con != null) && con.isEstablished() && !con.isClosed();\n        }\n    }","id":6635,"modified_method":"@Override\n    public boolean isEstablished(Hash dest) {\n            NTCPConnection con = _conByIdent.get(dest);\n            return (con != null) && con.isEstablished() && !con.isClosed();\n    }","commit_id":"d2c16415694a77f03f8509c3023c7a7e5c5aa61f","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"protected int compare(NTCPConnection l, NTCPConnection r) {\n            // base64 retains binary ordering\n            return l.getRemotePeer().calculateHash().toBase64().compareTo(r.getRemotePeer().calculateHash().toBase64());\n        }","id":6636,"modified_method":"public int compare(NTCPConnection l, NTCPConnection r) {\n            if (l == null || r == null)\n                throw new IllegalArgumentException();\n            // base64 retains binary ordering\n            // UM, no it doesn't, but close enough\n            return l.getRemotePeer().calculateHash().toBase64().compareTo(r.getRemotePeer().calculateHash().toBase64());\n        }","commit_id":"d2c16415694a77f03f8509c3023c7a7e5c5aa61f","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"void inboundEstablished(NTCPConnection con) {\n        _context.statManager().addRateData(\"ntcp.inboundEstablished\", 1);\n        markReachable(con.getRemotePeer().calculateHash(), true);\n        //_context.shitlist().unshitlistRouter(con.getRemotePeer().calculateHash());\n        NTCPConnection old = null;\n        synchronized (_conLock) {\n            old = _conByIdent.put(con.getRemotePeer().calculateHash(), con);\n        }\n        if (old != null) {\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(\"Old connection closed: \" + old + \" replaced by \" + con);\n            _context.statManager().addRateData(\"ntcp.inboundEstablishedDuplicate\", old.getUptime());\n            old.close();\n        }\n    }","id":6637,"modified_method":"void inboundEstablished(NTCPConnection con) {\n        _context.statManager().addRateData(\"ntcp.inboundEstablished\", 1);\n        markReachable(con.getRemotePeer().calculateHash(), true);\n        //_context.shitlist().unshitlistRouter(con.getRemotePeer().calculateHash());\n        NTCPConnection old;\n        synchronized (_conLock) {\n            old = _conByIdent.put(con.getRemotePeer().calculateHash(), con);\n        }\n        if (old != null) {\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(\"Old connection closed: \" + old + \" replaced by \" + con);\n            _context.statManager().addRateData(\"ntcp.inboundEstablishedDuplicate\", old.getUptime());\n            old.close();\n        }\n    }","commit_id":"d2c16415694a77f03f8509c3023c7a7e5c5aa61f","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Return our peer clock skews on this transport.\n     * Vector composed of Long, each element representing a peer skew in seconds.\n     */\n    @Override\n    public Vector<Long> getClockSkews() {\n\n        Vector<NTCPConnection> peers = new Vector();\n        Vector<Long> skews = new Vector();\n\n        synchronized (_conLock) {\n            peers.addAll(_conByIdent.values());\n        }\n\n        for (Iterator<NTCPConnection> iter = peers.iterator(); iter.hasNext(); ) {\n            NTCPConnection con = iter.next();\n            if (con.isEstablished())\n                skews.addElement(Long.valueOf(con.getClockSkew()));\n        }\n\n        // If we don't have many peers, maybe it is because of a bad clock, so\n        // return the last bad skew we got\n        if (skews.size() < 5 && _lastBadSkew != 0)\n            skews.addElement(Long.valueOf(_lastBadSkew));\n\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"NTCP transport returning \" + skews.size() + \" peer clock skews.\");\n        return skews;\n    }","id":6638,"modified_method":"/**\n     * Return our peer clock skews on this transport.\n     * Vector composed of Long, each element representing a peer skew in seconds.\n     */\n    @Override\n    public Vector<Long> getClockSkews() {\n        Vector<Long> skews = new Vector();\n\n        for (NTCPConnection con : _conByIdent.values()) {\n            if (con.isEstablished())\n                skews.addElement(Long.valueOf(con.getClockSkew()));\n        }\n\n        // If we don't have many peers, maybe it is because of a bad clock, so\n        // return the last bad skew we got\n        if (skews.size() < 5 && _lastBadSkew != 0)\n            skews.addElement(Long.valueOf(_lastBadSkew));\n\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"NTCP transport returning \" + skews.size() + \" peer clock skews.\");\n        return skews;\n    }","commit_id":"d2c16415694a77f03f8509c3023c7a7e5c5aa61f","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Override\n    public boolean isBacklogged(Hash dest) {\n        synchronized (_conLock) {\n            NTCPConnection con = _conByIdent.get(dest);\n            return (con != null) && con.isEstablished() && con.tooBacklogged();\n        }\n    }","id":6639,"modified_method":"@Override\n    public boolean isBacklogged(Hash dest) {\n            NTCPConnection con = _conByIdent.get(dest);\n            return (con != null) && con.isEstablished() && con.tooBacklogged();\n    }","commit_id":"d2c16415694a77f03f8509c3023c7a7e5c5aa61f","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"void removeCon(NTCPConnection con) {\n        NTCPConnection removed = null;\n        synchronized (_conLock) {\n            RouterIdentity ident = con.getRemotePeer();\n            if (ident != null)\n                removed = _conByIdent.remove(ident.calculateHash());\n        }\n        if ( (removed != null) && (removed != con) ) {// multiple cons, close 'em both\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"Multiple connections on remove, closing \" + removed + \" (already closed \" + con + \")\");\n            _context.statManager().addRateData(\"ntcp.multipleCloseOnRemove\", removed.getUptime());\n            removed.close();\n        }\n    }","id":6640,"modified_method":"void removeCon(NTCPConnection con) {\n        NTCPConnection removed = null;\n        RouterIdentity ident = con.getRemotePeer();\n        if (ident != null) {\n            synchronized (_conLock) {\n                removed = _conByIdent.remove(ident.calculateHash());\n            }\n        }\n        if ( (removed != null) && (removed != con) ) {// multiple cons, close 'em both\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"Multiple connections on remove, closing \" + removed + \" (already closed \" + con + \")\");\n            _context.statManager().addRateData(\"ntcp.multipleCloseOnRemove\", removed.getUptime());\n            removed.close();\n        }\n    }","commit_id":"d2c16415694a77f03f8509c3023c7a7e5c5aa61f","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * How many peers are we actively sending messages to (this minute)\n     */\n    @Override\n    public int countActiveSendPeers() {\n        int active = 0;\n        synchronized (_conLock) {\n            for (Iterator iter = _conByIdent.values().iterator(); iter.hasNext(); ) {\n                NTCPConnection con = (NTCPConnection)iter.next();\n                if ( (con.getTimeSinceSend() <= 60*1000) || (con.getTimeSinceReceive() <= 60*1000) )\n                    active++;\n            }\n        }\n        return active;\n    }","id":6641,"modified_method":"/**\n     * How many peers are we actively sending messages to (this minute)\n     */\n    @Override\n    public int countActiveSendPeers() {\n        int active = 0;\n        for (NTCPConnection con : _conByIdent.values()) {\n                if ( (con.getTimeSinceSend() <= 60*1000) || (con.getTimeSinceReceive() <= 60*1000) )\n                    active++;\n        }\n        return active;\n    }","commit_id":"d2c16415694a77f03f8509c3023c7a7e5c5aa61f","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Override\n    public void renderStatusHTML(java.io.Writer out, String urlBase, int sortFlags) throws IOException {\n        TreeSet peers = new TreeSet(getComparator(sortFlags));\n        synchronized (_conLock) {\n            peers.addAll(_conByIdent.values());\n        }\n        long offsetTotal = 0;\n\n        float bpsSend = 0;\n        float bpsRecv = 0;\n        long totalUptime = 0;\n        long totalSend = 0;\n        long totalRecv = 0;\n\n        StringBuilder buf = new StringBuilder(512);\n        buf.append(\"<h3 id=\\\"ntcpcon\\\">\").append(_(\"NTCP connections\")).append(\": \").append(peers.size());\n        buf.append(\". \").append(_(\"Limit\")).append(\": \").append(getMaxConnections());\n        buf.append(\". \").append(_(\"Timeout\")).append(\": \").append(DataHelper.formatDuration2(_pumper.getIdleTimeout()));\n        buf.append(\".<\/h3>\\n\" +\n                   \"<table>\\n\" +\n                   \"<tr><th><a href=\\\"#def.peer\\\">\").append(_(\"Peer\")).append(\"<\/a><\/th>\" +\n                   \"<th>\").append(_(\"Dir\")).append(\"<\/th>\" +\n                   \"<th align=\\\"right\\\"><a href=\\\"#def.idle\\\">\").append(_(\"Idle\")).append(\"<\/a><\/th>\" +\n                   \"<th align=\\\"right\\\"><a href=\\\"#def.rate\\\">\").append(_(\"In/Out\")).append(\"<\/a><\/th>\" +\n                   \"<th align=\\\"right\\\"><a href=\\\"#def.up\\\">\").append(_(\"Up\")).append(\"<\/a><\/th>\" +\n                   \"<th align=\\\"right\\\"><a href=\\\"#def.skew\\\">\").append(_(\"Skew\")).append(\"<\/a><\/th>\" +\n                   \"<th align=\\\"right\\\"><a href=\\\"#def.send\\\">\").append(_(\"TX\")).append(\"<\/a><\/th>\" +\n                   \"<th align=\\\"right\\\"><a href=\\\"#def.recv\\\">\").append(_(\"RX\")).append(\"<\/a><\/th>\" +\n                   \"<th>\").append(_(\"Out Queue\")).append(\"<\/th>\" +\n                   \"<th>\").append(_(\"Backlogged?\")).append(\"<\/th>\" +\n                   //\"<th>\").append(_(\"Reading?\")).append(\"<\/th>\" +\n                   \" <\/tr>\\n\");\n        out.write(buf.toString());\n        buf.setLength(0);\n        for (Iterator iter = peers.iterator(); iter.hasNext(); ) {\n            NTCPConnection con = (NTCPConnection)iter.next();\n            buf.append(\"<tr><td class=\\\"cells\\\" align=\\\"left\\\" nowrap>\");\n            buf.append(_context.commSystem().renderPeerHTML(con.getRemotePeer().calculateHash()));\n            //byte[] ip = getIP(con.getRemotePeer().calculateHash());\n            //if (ip != null)\n            //    buf.append(' ').append(_context.blocklist().toStr(ip));\n            buf.append(\"<\/td><td class=\\\"cells\\\" align=\\\"center\\\">\");\n            if (con.isInbound())\n                buf.append(\"<img src=\\\"/themes/console/images/inbound.png\\\" alt=\\\"Inbound\\\" title=\\\"\").append(_(\"Inbound\")).append(\"\\\"/>\");\n            else\n                buf.append(\"<img src=\\\"/themes/console/images/outbound.png\\\" alt=\\\"Outbound\\\" title=\\\"\").append(_(\"Outbound\")).append(\"\\\"/>\");\n            buf.append(\"<\/td><td class=\\\"cells\\\" align=\\\"right\\\">\");\n            buf.append(DataHelper.formatDuration2(con.getTimeSinceReceive()));\n            buf.append(THINSP).append(DataHelper.formatDuration2(con.getTimeSinceSend()));\n            buf.append(\"<\/td><td class=\\\"cells\\\" align=\\\"right\\\">\");\n            if (con.getTimeSinceReceive() < 2*60*1000) {\n                float r = con.getRecvRate();\n                buf.append(formatRate(r / 1024));\n                bpsRecv += r;\n            } else {\n                buf.append(formatRate(0));\n            }\n            buf.append(THINSP);\n            if (con.getTimeSinceSend() < 2*60*1000) {\n                float r = con.getSendRate();\n                buf.append(formatRate(r / 1024));\n                bpsSend += r;\n            } else {\n                buf.append(formatRate(0));\n            }\n            //buf.append(\" K/s\");\n            buf.append(\"<\/td><td class=\\\"cells\\\" align=\\\"right\\\">\").append(DataHelper.formatDuration2(con.getUptime()));\n            totalUptime += con.getUptime();\n            offsetTotal = offsetTotal + con.getClockSkew();\n            buf.append(\"<\/td><td class=\\\"cells\\\" align=\\\"right\\\">\").append(DataHelper.formatDuration2(1000 * con.getClockSkew()));\n            buf.append(\"<\/td><td class=\\\"cells\\\" align=\\\"right\\\">\").append(con.getMessagesSent());\n            totalSend += con.getMessagesSent();\n            buf.append(\"<\/td><td class=\\\"cells\\\" align=\\\"right\\\">\").append(con.getMessagesReceived());\n            totalRecv += con.getMessagesReceived();\n            long outQueue = con.getOutboundQueueSize();\n            buf.append(\"<\/td><td class=\\\"cells\\\" align=\\\"center\\\">\").append(outQueue);\n            buf.append(\"<\/td><td class=\\\"cells\\\" align=\\\"center\\\">\");\n            if (con.isBacklogged())\n                buf.append(\"&#x2713;\");\n            else\n                buf.append(\"&nbsp;\");\n            //long readTime = con.getReadTime();\n            //if (readTime <= 0) {\n            //    buf.append(\"<\/td> <td class=\\\"cells\\\" align=\\\"center\\\">0\");\n            //} else {\n            //    buf.append(\"<\/td> <td class=\\\"cells\\\" align=\\\"center\\\">\").append(DataHelper.formatDuration(readTime));\n            //}\n            buf.append(\"<\/td><\/tr>\\n\");\n            out.write(buf.toString());\n            buf.setLength(0);\n        }\n\n        if (!peers.isEmpty()) {\n//            buf.append(\"<tr> <td colspan=\\\"11\\\"><hr><\/td><\/tr>\\n\");\n            buf.append(\"<tr class=\\\"tablefooter\\\"><td align=\\\"center\\\"><b>\").append(peers.size()).append(' ').append(_(\"peers\")).append(\"<\/b><\/td><td>&nbsp;<\/td><td>&nbsp;\");\n            buf.append(\"<\/td><td align=\\\"center\\\"><b>\").append(formatRate(bpsRecv/1024)).append(THINSP).append(formatRate(bpsSend/1024)).append(\"<\/b>\");\n            buf.append(\"<\/td><td align=\\\"center\\\"><b>\").append(DataHelper.formatDuration2(totalUptime/peers.size()));\n            buf.append(\"<\/b><\/td><td align=\\\"center\\\"><b>\").append(DataHelper.formatDuration2(offsetTotal*1000/peers.size()));\n            buf.append(\"<\/b><\/td><td align=\\\"center\\\"><b>\").append(totalSend).append(\"<\/b><\/td><td align=\\\"center\\\"><b>\").append(totalRecv);\n            buf.append(\"<\/b><\/td><td>&nbsp;<\/td><td>&nbsp;<\/td><\/tr>\\n\");\n        }\n\n        buf.append(\"<\/table>\\n\");\n        out.write(buf.toString());\n        buf.setLength(0);\n    }","id":6642,"modified_method":"@Override\n    public void renderStatusHTML(java.io.Writer out, String urlBase, int sortFlags) throws IOException {\n        TreeSet peers = new TreeSet(getComparator(sortFlags));\n        peers.addAll(_conByIdent.values());\n\n        long offsetTotal = 0;\n        float bpsSend = 0;\n        float bpsRecv = 0;\n        long totalUptime = 0;\n        long totalSend = 0;\n        long totalRecv = 0;\n\n        StringBuilder buf = new StringBuilder(512);\n        buf.append(\"<h3 id=\\\"ntcpcon\\\">\").append(_(\"NTCP connections\")).append(\": \").append(peers.size());\n        buf.append(\". \").append(_(\"Limit\")).append(\": \").append(getMaxConnections());\n        buf.append(\". \").append(_(\"Timeout\")).append(\": \").append(DataHelper.formatDuration2(_pumper.getIdleTimeout()));\n        buf.append(\".<\/h3>\\n\" +\n                   \"<table>\\n\" +\n                   \"<tr><th><a href=\\\"#def.peer\\\">\").append(_(\"Peer\")).append(\"<\/a><\/th>\" +\n                   \"<th>\").append(_(\"Dir\")).append(\"<\/th>\" +\n                   \"<th align=\\\"right\\\"><a href=\\\"#def.idle\\\">\").append(_(\"Idle\")).append(\"<\/a><\/th>\" +\n                   \"<th align=\\\"right\\\"><a href=\\\"#def.rate\\\">\").append(_(\"In/Out\")).append(\"<\/a><\/th>\" +\n                   \"<th align=\\\"right\\\"><a href=\\\"#def.up\\\">\").append(_(\"Up\")).append(\"<\/a><\/th>\" +\n                   \"<th align=\\\"right\\\"><a href=\\\"#def.skew\\\">\").append(_(\"Skew\")).append(\"<\/a><\/th>\" +\n                   \"<th align=\\\"right\\\"><a href=\\\"#def.send\\\">\").append(_(\"TX\")).append(\"<\/a><\/th>\" +\n                   \"<th align=\\\"right\\\"><a href=\\\"#def.recv\\\">\").append(_(\"RX\")).append(\"<\/a><\/th>\" +\n                   \"<th>\").append(_(\"Out Queue\")).append(\"<\/th>\" +\n                   \"<th>\").append(_(\"Backlogged?\")).append(\"<\/th>\" +\n                   //\"<th>\").append(_(\"Reading?\")).append(\"<\/th>\" +\n                   \" <\/tr>\\n\");\n        out.write(buf.toString());\n        buf.setLength(0);\n        for (Iterator iter = peers.iterator(); iter.hasNext(); ) {\n            NTCPConnection con = (NTCPConnection)iter.next();\n            buf.append(\"<tr><td class=\\\"cells\\\" align=\\\"left\\\" nowrap>\");\n            buf.append(_context.commSystem().renderPeerHTML(con.getRemotePeer().calculateHash()));\n            //byte[] ip = getIP(con.getRemotePeer().calculateHash());\n            //if (ip != null)\n            //    buf.append(' ').append(_context.blocklist().toStr(ip));\n            buf.append(\"<\/td><td class=\\\"cells\\\" align=\\\"center\\\">\");\n            if (con.isInbound())\n                buf.append(\"<img src=\\\"/themes/console/images/inbound.png\\\" alt=\\\"Inbound\\\" title=\\\"\").append(_(\"Inbound\")).append(\"\\\"/>\");\n            else\n                buf.append(\"<img src=\\\"/themes/console/images/outbound.png\\\" alt=\\\"Outbound\\\" title=\\\"\").append(_(\"Outbound\")).append(\"\\\"/>\");\n            buf.append(\"<\/td><td class=\\\"cells\\\" align=\\\"right\\\">\");\n            buf.append(DataHelper.formatDuration2(con.getTimeSinceReceive()));\n            buf.append(THINSP).append(DataHelper.formatDuration2(con.getTimeSinceSend()));\n            buf.append(\"<\/td><td class=\\\"cells\\\" align=\\\"right\\\">\");\n            if (con.getTimeSinceReceive() < 2*60*1000) {\n                float r = con.getRecvRate();\n                buf.append(formatRate(r / 1024));\n                bpsRecv += r;\n            } else {\n                buf.append(formatRate(0));\n            }\n            buf.append(THINSP);\n            if (con.getTimeSinceSend() < 2*60*1000) {\n                float r = con.getSendRate();\n                buf.append(formatRate(r / 1024));\n                bpsSend += r;\n            } else {\n                buf.append(formatRate(0));\n            }\n            //buf.append(\" K/s\");\n            buf.append(\"<\/td><td class=\\\"cells\\\" align=\\\"right\\\">\").append(DataHelper.formatDuration2(con.getUptime()));\n            totalUptime += con.getUptime();\n            offsetTotal = offsetTotal + con.getClockSkew();\n            buf.append(\"<\/td><td class=\\\"cells\\\" align=\\\"right\\\">\").append(DataHelper.formatDuration2(1000 * con.getClockSkew()));\n            buf.append(\"<\/td><td class=\\\"cells\\\" align=\\\"right\\\">\").append(con.getMessagesSent());\n            totalSend += con.getMessagesSent();\n            buf.append(\"<\/td><td class=\\\"cells\\\" align=\\\"right\\\">\").append(con.getMessagesReceived());\n            totalRecv += con.getMessagesReceived();\n            long outQueue = con.getOutboundQueueSize();\n            buf.append(\"<\/td><td class=\\\"cells\\\" align=\\\"center\\\">\").append(outQueue);\n            buf.append(\"<\/td><td class=\\\"cells\\\" align=\\\"center\\\">\");\n            if (con.isBacklogged())\n                buf.append(\"&#x2713;\");\n            else\n                buf.append(\"&nbsp;\");\n            //long readTime = con.getReadTime();\n            //if (readTime <= 0) {\n            //    buf.append(\"<\/td> <td class=\\\"cells\\\" align=\\\"center\\\">0\");\n            //} else {\n            //    buf.append(\"<\/td> <td class=\\\"cells\\\" align=\\\"center\\\">\").append(DataHelper.formatDuration(readTime));\n            //}\n            buf.append(\"<\/td><\/tr>\\n\");\n            out.write(buf.toString());\n            buf.setLength(0);\n        }\n\n        if (!peers.isEmpty()) {\n//            buf.append(\"<tr> <td colspan=\\\"11\\\"><hr><\/td><\/tr>\\n\");\n            buf.append(\"<tr class=\\\"tablefooter\\\"><td align=\\\"center\\\"><b>\").append(peers.size()).append(' ').append(_(\"peers\")).append(\"<\/b><\/td><td>&nbsp;<\/td><td>&nbsp;\");\n            buf.append(\"<\/td><td align=\\\"center\\\"><b>\").append(formatRate(bpsRecv/1024)).append(THINSP).append(formatRate(bpsSend/1024)).append(\"<\/b>\");\n            buf.append(\"<\/td><td align=\\\"center\\\"><b>\").append(DataHelper.formatDuration2(totalUptime/peers.size()));\n            buf.append(\"<\/b><\/td><td align=\\\"center\\\"><b>\").append(DataHelper.formatDuration2(offsetTotal*1000/peers.size()));\n            buf.append(\"<\/b><\/td><td align=\\\"center\\\"><b>\").append(totalSend).append(\"<\/b><\/td><td align=\\\"center\\\"><b>\").append(totalRecv);\n            buf.append(\"<\/b><\/td><td>&nbsp;<\/td><td>&nbsp;<\/td><\/tr>\\n\");\n        }\n\n        buf.append(\"<\/table>\\n\");\n        out.write(buf.toString());\n        buf.setLength(0);\n    }","commit_id":"d2c16415694a77f03f8509c3023c7a7e5c5aa61f","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Maybe we should trust UPnP here and report OK if it opened the port, but\n     * for now we don't. Just go through and if we have one inbound connection,\n     * we must be good. As we drop idle connections pretty quickly, this will\n     * be fairly accurate.\n     *\n     * We have to be careful here because much of the router console code assumes\n     * that the reachability status is really just the UDP status.\n     */\n    @Override\n    public short getReachabilityStatus() { \n        if (isAlive() && _myAddress != null) {\n            synchronized (_conLock) {\n                for (NTCPConnection con : _conByIdent.values()) {\n                    if (con.isInbound())\n                        return CommSystemFacade.STATUS_OK;\n                }\n            }\n        }\n        return CommSystemFacade.STATUS_UNKNOWN;\n    }","id":6643,"modified_method":"/**\n     * Maybe we should trust UPnP here and report OK if it opened the port, but\n     * for now we don't. Just go through and if we have one inbound connection,\n     * we must be good. As we drop idle connections pretty quickly, this will\n     * be fairly accurate.\n     *\n     * We have to be careful here because much of the router console code assumes\n     * that the reachability status is really just the UDP status.\n     */\n    @Override\n    public short getReachabilityStatus() { \n        if (isAlive() && _myAddress != null) {\n                for (NTCPConnection con : _conByIdent.values()) {\n                    if (con.isInbound())\n                        return CommSystemFacade.STATUS_OK;\n                }\n        }\n        return CommSystemFacade.STATUS_UNKNOWN;\n    }","commit_id":"d2c16415694a77f03f8509c3023c7a7e5c5aa61f","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Cleans the routing tables while the Router is going down.\n     */\n    private void cleanup() {\n\n        // shutdown the routing threads and cleanup the tables\n        synchronized(routingTable) {\n            Map map;\n            for(Iterator i=routingTable.values().iterator(); i.hasNext();) {\n                map=(Map)i.next();\n                if(map != null) {\n                    for(Iterator j=map.values().iterator(); j.hasNext();) {\n                        AddressEntry e=(AddressEntry)j.next();\n                        e.destroy();\n                    }\n                }\n            }\n            routingTable.clear();\n        }\n    }","id":6644,"modified_method":"/**\n     * Cleans the routing tables while the Router is going down.\n     */\n    private void cleanup() {\n        // shutdown the routing threads and cleanup the tables\n        for(Map<Address,AddressEntry> map: routingTable.values()) {\n            if(map != null) {\n                for(AddressEntry entry: map.values()) {\n                    entry.destroy();\n                }\n            }\n        }\n        routingTable.clear();\n    }","commit_id":"2c174100be2022b999df8c26e73eb1869e217e29","url":"https://github.com/belaban/JGroups"},{"original_method":"private void removeEntry(String groupname, Address logical_addr) {\n        Map val;\n        synchronized(routingTable) {\n            val=routingTable.get(groupname);\n            if(val == null)\n                return;\n        }\n        synchronized(val) {\n            AddressEntry entry=(AddressEntry)val.get(logical_addr);\n            if(entry != null) {\n                entry.destroy();\n                val.remove(logical_addr);\n            }\n        }\n    }","id":6645,"modified_method":"private void removeEntry(String groupname, Address logical_addr) {\n        Map val;\n        val=routingTable.get(groupname);\n        if(val == null)\n            return;\n        synchronized(val) {\n            AddressEntry entry=(AddressEntry)val.get(logical_addr);\n            if(entry != null) {\n                entry.destroy();\n                val.remove(logical_addr);\n            }\n        }\n    }","commit_id":"2c174100be2022b999df8c26e73eb1869e217e29","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * @return null if not found\n     */\n    private AddressEntry findAddressEntry(String group_name, Address logical_addr) {\n        if(group_name == null || logical_addr == null)\n            return null;\n        synchronized(routingTable) {\n            Map val=routingTable.get(group_name);\n            if(val == null)\n                return null;\n            return (AddressEntry)val.get(logical_addr);\n        }\n    }","id":6646,"modified_method":"/**\n     * @return null if not found\n     */\n    private AddressEntry findAddressEntry(String group_name, Address logical_addr) {\n        if(group_name == null || logical_addr == null)\n            return null;\n        Map val=routingTable.get(group_name);\n        if(val == null)\n            return null;\n        return (AddressEntry)val.get(logical_addr);\n    }","commit_id":"2c174100be2022b999df8c26e73eb1869e217e29","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Adds a new member to the routing group.\n     */\n    private void addEntry(String groupname, Address logical_addr, AddressEntry entry, boolean update_only) {\n        if(groupname == null || logical_addr == null) {\n            if(log.isErrorEnabled()) log.error(\"groupname or logical_addr was null, entry was not added\");\n            return;\n        }\n\n        synchronized(routingTable) {\n            Map<Address,AddressEntry> mbrs=routingTable.get(groupname);\n            if(mbrs == null) {\n                mbrs=new HashMap<Address,AddressEntry>();\n                mbrs.put(logical_addr, entry);\n                routingTable.put(groupname, mbrs);\n            }\n            else {\n                AddressEntry tmp=mbrs.get(logical_addr);\n                if(tmp != null) { // already present\n                    if(update_only) {\n                        tmp.update();\n                        return;\n                    }\n                    tmp.destroy();\n                }\n                mbrs.put(logical_addr, entry);\n            }\n        }\n    }","id":6647,"modified_method":"/**\n     * Adds a new member to the routing group.\n     */\n    private void addEntry(String groupname, Address logical_addr, AddressEntry entry, boolean update_only) {\n        if(groupname == null || logical_addr == null) {\n            if(log.isErrorEnabled()) log.error(\"groupname or logical_addr was null, entry was not added\");\n            return;\n        }\n\n        ConcurrentMap<Address,AddressEntry> mbrs=routingTable.get(groupname);\n        if(mbrs == null) {\n            mbrs=new ConcurrentHashMap<Address,AddressEntry>();\n            mbrs.put(logical_addr, entry);\n            routingTable.putIfAbsent(groupname, mbrs);\n        }\n        else {\n            AddressEntry tmp=mbrs.get(logical_addr);\n            if(tmp != null) { // already present\n                if(update_only) {\n                    tmp.update();\n                    return;\n                }\n                tmp.destroy();\n            }\n            mbrs.put(logical_addr, entry);\n        }\n    }","commit_id":"2c174100be2022b999df8c26e73eb1869e217e29","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Removes expired gossip entries (entries older than EXPIRY_TIME msec).\n     * @since 2.2.1\n     */\n    private void sweep() {\n        long diff, currentTime=System.currentTimeMillis();\n        int num_entries_removed=0;\n\n        synchronized(routingTable) {\n            Map.Entry entry, entry2;\n            Map map;\n            AddressEntry ae;\n            for(Iterator it=routingTable.entrySet().iterator(); it.hasNext();) {\n                entry=(Map.Entry)it.next();\n                map=(Map)entry.getValue();\n                if(map == null || map.isEmpty()) {\n                    it.remove();\n                    continue;\n                }\n                for(Iterator it2=map.entrySet().iterator(); it2.hasNext();) {\n                    entry2=(Map.Entry)it2.next();\n                    ae=(GossipRouter.AddressEntry)entry2.getValue();\n                    diff=currentTime - ae.timestamp;\n                    if(diff > expiryTime) {\n                        it2.remove();\n                        if(log.isTraceEnabled())\n                            log.trace(\"removed \" + ae.logical_addr + \" (\" + diff + \" msecs old)\");\n                        num_entries_removed++;\n                    }\n                }\n            }\n        }\n\n        if(num_entries_removed > 0) {\n            if(log.isTraceEnabled()) log.trace(\"done (removed \" + num_entries_removed + \" entries)\");\n        }\n    }","id":6648,"modified_method":"/**\n     * Removes expired gossip entries (entries older than EXPIRY_TIME msec).\n     * @since 2.2.1\n     */\n    private void sweep() {\n        long diff, currentTime=System.currentTimeMillis();\n        int num_entries_removed=0;\n\n        Map.Entry entry, entry2;\n        Map map;\n        AddressEntry ae;\n        for(Iterator it=routingTable.entrySet().iterator(); it.hasNext();) {\n            entry=(Map.Entry)it.next();\n            map=(Map)entry.getValue();\n            if(map == null || map.isEmpty()) {\n                it.remove();\n                continue;\n            }\n            for(Iterator it2=map.entrySet().iterator(); it2.hasNext();) {\n                entry2=(Map.Entry)it2.next();\n                ae=(GossipRouter.AddressEntry)entry2.getValue();\n                diff=currentTime - ae.timestamp;\n                if(diff > expiryTime) {\n                    it2.remove();\n                    if(log.isTraceEnabled())\n                        log.trace(\"removed \" + ae.logical_addr + \" (\" + diff + \" msecs old)\");\n                    num_entries_removed++;\n                }\n            }\n        }\n\n        if(num_entries_removed > 0) {\n            if(log.isTraceEnabled()) log.trace(\"done (removed \" + num_entries_removed + \" entries)\");\n        }\n    }","commit_id":"2c174100be2022b999df8c26e73eb1869e217e29","url":"https://github.com/belaban/JGroups"},{"original_method":"public String dumpRoutingTable() {\n        String label=\"routing\";\n        StringBuilder sb=new StringBuilder();\n\n        synchronized(routingTable) {\n            if(routingTable.isEmpty()) {\n                sb.append(\"empty \");\n                sb.append(label);\n                sb.append(\" table\");\n            }\n            else {\n                for(Iterator i=routingTable.keySet().iterator(); i.hasNext();) {\n                    String gname=(String)i.next();\n                    sb.append(\"GROUP: '\" + gname + \"'\\n\");\n                    Map map=routingTable.get(gname);\n                    if(map == null) {\n                        sb.append(\"\\tnull list of addresses\\n\");\n                    }\n                    else if(map.isEmpty()) {\n                        sb.append(\"\\tempty list of addresses\\n\");\n                    }\n                    else {\n                        AddressEntry ae;\n                        for(Iterator j=map.values().iterator(); j.hasNext();) {\n                            ae=(AddressEntry)j.next();\n                            sb.append('\\t');\n                            sb.append(ae);\n                            sb.append('\\n');\n                        }\n                    }\n                }\n            }\n        }\n        return sb.toString();\n    }","id":6649,"modified_method":"public String dumpRoutingTable() {\n        String label=\"routing\";\n        StringBuilder sb=new StringBuilder();\n\n        if(routingTable.isEmpty()) {\n            sb.append(\"empty \").append(label).append(\" table\");\n        }\n        else {\n            for(Iterator i=routingTable.keySet().iterator(); i.hasNext();) {\n                String gname=(String)i.next();\n                sb.append(\"GROUP: '\" + gname + \"'\\n\");\n                Map map=routingTable.get(gname);\n                if(map == null) {\n                    sb.append(\"\\tnull list of addresses\\n\");\n                }\n                else if(map.isEmpty()) {\n                    sb.append(\"\\tempty list of addresses\\n\");\n                }\n                else {\n                    AddressEntry ae;\n                    for(Iterator j=map.values().iterator(); j.hasNext();) {\n                        ae=(AddressEntry)j.next();\n                        sb.append('\\t').append(ae).append('\\n');\n                    }\n                }\n            }\n        }\n        return sb.toString();\n    }","commit_id":"2c174100be2022b999df8c26e73eb1869e217e29","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * The main server loop. Runs on the JGroups Router Main Thread.\n     */\n    private void mainLoop() {\n        Socket sock=null;\n        DataInputStream input=null;\n        DataOutputStream output=null;\n        Address peer_addr=null, mbr, logical_addr;\n\n        if(bindAddress == null) {\n            bindAddress=srvSock.getInetAddress();\n        }\n        System.out.println(\"GossipRouter started at \" + new Date() +\n                \"\\nListening on port \" + port + \" bound on address \" + bindAddress + '\\n');\n\n        GossipData req;\n        String group;\n\n        while(up && srvSock != null) {\n            try {\n                sock=srvSock.accept();\n                sock.setSoLinger(true, 500);\n                input=new DataInputStream(sock.getInputStream());\n                // if(log.isTraceEnabled())\n                   // log.trace(\"accepted connection from \" + sock);\n\n                req=new GossipData();\n                req.readFrom(input);\n\n                switch(req.getType()) {\n                    case GossipRouter.REGISTER:\n                        mbr=req.getAddress();\n                        group=req.getGroup();\n                        if(log.isTraceEnabled())\n                            log.trace(\"REGISTER(\" + group + \", \" + mbr + \")\");\n                        if(group == null || mbr == null) {\n                            if(log.isErrorEnabled()) log.error(\"group or member is null, cannot register member\");\n                        }\n                        else\n                            addGossipEntry(group, mbr, new AddressEntry(mbr));\n                        Util.close(input);\n                        Util.close(sock);\n                        break;\n\n                    case GossipRouter.UNREGISTER:\n                        mbr=req.getAddress();\n                        group=req.getGroup();\n                        if(log.isTraceEnabled())\n                            log.trace(\"UNREGISTER(\" + group + \", \" + mbr + \")\");\n                        if(group == null || mbr == null) {\n                            if(log.isErrorEnabled()) log.error(\"group or member is null, cannot unregister member\");\n                        }\n                        else\n                            removeGossipEntry(group, mbr);\n                        Util.close(input);\n                        Util.close(output);\n                        Util.close(sock);\n                        break;\n\n                    case GossipRouter.GOSSIP_GET:\n                        group=req.getGroup();\n                        List<Address> mbrs=null;\n                        Map<Address,AddressEntry> map;\n                        synchronized(routingTable) {\n                            map=routingTable.get(group);\n                            if(map != null) {\n                                mbrs=new LinkedList<Address>(map.keySet());\n                            }\n                        }\n\n                        if(log.isTraceEnabled())\n                            log.trace(\"GOSSIP_GET(\" + group + \") --> \" + mbrs);\n                        output=new DataOutputStream(sock.getOutputStream());\n                        GossipData rsp=new GossipData(GossipRouter.GET_RSP, group, null, mbrs);\n                        rsp.writeTo(output);\n                        Util.close(input);\n                        Util.close(output);\n                        Util.close(sock);\n                        break;\n\n                    case GossipRouter.ROUTER_GET:\n                        group=req.getGroup();\n                        output=new DataOutputStream(sock.getOutputStream());\n\n                        List<Address> ret=null;\n                        synchronized(routingTable) {\n                            map=routingTable.get(group);\n                            if(map != null) {\n                                ret=new LinkedList<Address>(map.keySet());\n                            }\n                            else\n                                ret=new LinkedList<Address>();\n                        }\n                        if(log.isTraceEnabled())\n                            log.trace(\"ROUTER_GET(\" + group + \") --> \" + ret);\n                        rsp=new GossipData(GossipRouter.GET_RSP, group, null, ret);\n                        rsp.writeTo(output);\n                        Util.close(input);\n                        Util.close(output);\n                        Util.close(sock);\n                        break;\n\n                    case GossipRouter.DUMP:\n                        output=new DataOutputStream(sock.getOutputStream());\n                        output.writeUTF(dumpRoutingTable());\n                        Util.close(input);\n                        Util.close(output);\n                        Util.close(sock);\n                        break;\n\n                    case GossipRouter.CONNECT:\n                        output=new DataOutputStream(sock.getOutputStream());\n                        peer_addr=new IpAddress(sock.getInetAddress(), sock.getPort());\n                        output=new DataOutputStream(sock.getOutputStream());\n                        logical_addr=req.getAddress();\n                        String group_name=req.getGroup();\n\n                        if(log.isTraceEnabled())\n                            log.trace(\"CONNECT(\" + group_name + \", \" + logical_addr + \")\");\n                        SocketThread st=new SocketThread(sock, input, group_name, logical_addr);\n                        addEntry(group_name, logical_addr, new AddressEntry(logical_addr, peer_addr, sock, st, output));\n                        st.start();\n                        break;\n\n                    case GossipRouter.DISCONNECT:\n                        Address addr=req.getAddress();\n                        group_name=req.getGroup();\n                        removeEntry(group_name, addr);\n                        if(log.isTraceEnabled())\n                            log.trace(\"DISCONNECT(\" + group_name + \", \" + addr + \")\");\n                        Util.close(input);\n                        Util.close(output);\n                        Util.close(sock);\n                        break;\n\n                    case GossipRouter.SHUTDOWN:\n                        if(log.isInfoEnabled()) log.info(\"router shutting down\");\n                        Util.close(input);\n                        Util.close(output);\n                        Util.close(sock);\n                        up=false;\n                        break;\n                    default:\n                        if(log.isWarnEnabled())\n                            log.warn(\"received unkown gossip request (gossip=\" + req + ')');\n                        break;\n                }\n            }\n            catch(Exception e) {\n                if(up)\n                    if(log.isErrorEnabled()) log.error(\"failure handling a client request\", e);\n                Util.close(input);\n                Util.close(output);\n                Util.close(sock);\n            }\n        }\n    }","id":6650,"modified_method":"/**\n     * The main server loop. Runs on the JGroups Router Main Thread.\n     */\n    private void mainLoop() {\n        Socket sock=null;\n        DataInputStream input=null;\n        DataOutputStream output=null;\n        Address peer_addr=null, mbr, logical_addr;\n\n        if(bindAddress == null) {\n            bindAddress=srvSock.getInetAddress();\n        }\n        System.out.println(\"GossipRouter started at \" + new Date() +\n                \"\\nListening on port \" + port + \" bound on address \" + bindAddress + '\\n');\n\n        GossipData req;\n        String group;\n\n        while(up && srvSock != null) {\n            try {\n                sock=srvSock.accept();\n                sock.setSoLinger(true, 500);\n                input=new DataInputStream(sock.getInputStream());\n                // if(log.isTraceEnabled())\n                   // log.trace(\"accepted connection from \" + sock);\n\n                req=new GossipData();\n                req.readFrom(input);\n\n                switch(req.getType()) {\n                    case GossipRouter.REGISTER:\n                        mbr=req.getAddress();\n                        group=req.getGroup();\n                        if(log.isTraceEnabled())\n                            log.trace(\"REGISTER(\" + group + \", \" + mbr + \")\");\n                        if(group == null || mbr == null) {\n                            if(log.isErrorEnabled()) log.error(\"group or member is null, cannot register member\");\n                        }\n                        else\n                            addGossipEntry(group, mbr, new AddressEntry(mbr));\n                        Util.close(input);\n                        Util.close(sock);\n                        break;\n\n                    case GossipRouter.UNREGISTER:\n                        mbr=req.getAddress();\n                        group=req.getGroup();\n                        if(log.isTraceEnabled())\n                            log.trace(\"UNREGISTER(\" + group + \", \" + mbr + \")\");\n                        if(group == null || mbr == null) {\n                            if(log.isErrorEnabled()) log.error(\"group or member is null, cannot unregister member\");\n                        }\n                        else\n                            removeGossipEntry(group, mbr);\n                        Util.close(input);\n                        Util.close(output);\n                        Util.close(sock);\n                        break;\n\n                    case GossipRouter.GOSSIP_GET:\n                        group=req.getGroup();\n                        List<Address> mbrs=null;\n                        Map<Address,AddressEntry> map;\n                        map=routingTable.get(group);\n                        if(map != null) {\n                            mbrs=new LinkedList<Address>(map.keySet());\n                        }\n\n                        if(log.isTraceEnabled())\n                            log.trace(\"GOSSIP_GET(\" + group + \") --> \" + mbrs);\n                        output=new DataOutputStream(sock.getOutputStream());\n                        GossipData rsp=new GossipData(GossipRouter.GET_RSP, group, null, mbrs);\n                        rsp.writeTo(output);\n                        Util.close(input);\n                        Util.close(output);\n                        Util.close(sock);\n                        break;\n\n                    case GossipRouter.ROUTER_GET:\n                        group=req.getGroup();\n                        output=new DataOutputStream(sock.getOutputStream());\n\n                        List<Address> ret=null;\n                        map=routingTable.get(group);\n                        if(map != null) {\n                            ret=new LinkedList<Address>(map.keySet());\n                        }\n                        else\n                            ret=new LinkedList<Address>();\n                        if(log.isTraceEnabled())\n                            log.trace(\"ROUTER_GET(\" + group + \") --> \" + ret);\n                        rsp=new GossipData(GossipRouter.GET_RSP, group, null, ret);\n                        rsp.writeTo(output);\n                        Util.close(input);\n                        Util.close(output);\n                        Util.close(sock);\n                        break;\n\n                    case GossipRouter.DUMP:\n                        output=new DataOutputStream(sock.getOutputStream());\n                        output.writeUTF(dumpRoutingTable());\n                        Util.close(input);\n                        Util.close(output);\n                        Util.close(sock);\n                        break;\n\n                    case GossipRouter.CONNECT:\n                        output=new DataOutputStream(sock.getOutputStream());\n                        peer_addr=new IpAddress(sock.getInetAddress(), sock.getPort());\n                        output=new DataOutputStream(sock.getOutputStream());\n                        logical_addr=req.getAddress();\n                        String group_name=req.getGroup();\n\n                        if(log.isTraceEnabled())\n                            log.trace(\"CONNECT(\" + group_name + \", \" + logical_addr + \")\");\n                        SocketThread st=new SocketThread(sock, input, group_name, logical_addr);\n                        addEntry(group_name, logical_addr, new AddressEntry(logical_addr, peer_addr, sock, st, output));\n                        st.start();\n                        break;\n\n                    case GossipRouter.DISCONNECT:\n                        Address addr=req.getAddress();\n                        group_name=req.getGroup();\n                        removeEntry(group_name, addr);\n                        if(log.isTraceEnabled())\n                            log.trace(\"DISCONNECT(\" + group_name + \", \" + addr + \")\");\n                        Util.close(input);\n                        Util.close(output);\n                        Util.close(sock);\n                        break;\n\n                    case GossipRouter.SHUTDOWN:\n                        if(log.isInfoEnabled()) log.info(\"router shutting down\");\n                        Util.close(input);\n                        Util.close(output);\n                        Util.close(sock);\n                        up=false;\n                        break;\n                    default:\n                        if(log.isWarnEnabled())\n                            log.warn(\"received unkown gossip request (gossip=\" + req + ')');\n                        break;\n                }\n            }\n            catch(Exception e) {\n                if(up)\n                    if(log.isErrorEnabled()) log.error(\"failure handling a client request\", e);\n                Util.close(input);\n                Util.close(output);\n                Util.close(sock);\n            }\n        }\n    }","commit_id":"2c174100be2022b999df8c26e73eb1869e217e29","url":"https://github.com/belaban/JGroups"},{"original_method":"public String dumpRoutingTable() {\n        String label=\"routing\";\n        StringBuilder sb=new StringBuilder();\n\n        synchronized(routingTable) {\n            if(routingTable.isEmpty()) {\n                sb.append(\"empty \");\n                sb.append(label);\n                sb.append(\" table\");\n            }\n            else {\n                for(Iterator i=routingTable.keySet().iterator(); i.hasNext();) {\n                    String gname=(String)i.next();\n                    sb.append(\"GROUP: '\" + gname + \"'\\n\");\n                    Map map=routingTable.get(gname);\n                    if(map == null) {\n                        sb.append(\"\\tnull list of addresses\\n\");\n                    }\n                    else if(map.isEmpty()) {\n                        sb.append(\"\\tempty list of addresses\\n\");\n                    }\n                    else {\n                        AddressEntry ae;\n                        for(Iterator j=map.values().iterator(); j.hasNext();) {\n                            ae=(AddressEntry)j.next();\n                            sb.append('\\t');\n                            sb.append(ae);\n                            sb.append('\\n');\n                        }\n                    }\n                }\n            }\n        }\n        return sb.toString();\n    }","id":6651,"modified_method":"public String dumpRoutingTable() {\n        String label=\"routing\";\n        StringBuilder sb=new StringBuilder();\n\n        if(routingTable.isEmpty()) {\n            sb.append(\"empty \").append(label).append(\" table\");\n        }\n        else {\n            for(Iterator i=routingTable.keySet().iterator(); i.hasNext();) {\n                String gname=(String)i.next();\n                sb.append(\"GROUP: '\" + gname + \"'\\n\");\n                Map map=routingTable.get(gname);\n                if(map == null) {\n                    sb.append(\"\\tnull list of addresses\\n\");\n                }\n                else if(map.isEmpty()) {\n                    sb.append(\"\\tempty list of addresses\\n\");\n                }\n                else {\n                    AddressEntry ae;\n                    for(Iterator j=map.values().iterator(); j.hasNext();) {\n                        ae=(AddressEntry)j.next();\n                        sb.append('\\t').append(ae).append('\\n');\n                    }\n                }\n            }\n        }\n        return sb.toString();\n    }","commit_id":"e06ff228065574d1facd8a1b892afaa2ab144b1b","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Cleans the routing tables while the Router is going down.\n     */\n    private void cleanup() {\n\n        // shutdown the routing threads and cleanup the tables\n        synchronized(routingTable) {\n            Map map;\n            for(Iterator i=routingTable.values().iterator(); i.hasNext();) {\n                map=(Map)i.next();\n                if(map != null) {\n                    for(Iterator j=map.values().iterator(); j.hasNext();) {\n                        AddressEntry e=(AddressEntry)j.next();\n                        e.destroy();\n                    }\n                }\n            }\n            routingTable.clear();\n        }\n    }","id":6652,"modified_method":"/**\n     * Cleans the routing tables while the Router is going down.\n     */\n    private void cleanup() {\n        // shutdown the routing threads and cleanup the tables\n        for(Map<Address,AddressEntry> map: routingTable.values()) {\n            if(map != null) {\n                for(AddressEntry entry: map.values()) {\n                    entry.destroy();\n                }\n            }\n        }\n        routingTable.clear();\n    }","commit_id":"e06ff228065574d1facd8a1b892afaa2ab144b1b","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * The main server loop. Runs on the JGroups Router Main Thread.\n     */\n    private void mainLoop() {\n        Socket sock=null;\n        DataInputStream input=null;\n        DataOutputStream output=null;\n        Address peer_addr=null, mbr, logical_addr;\n\n        if(bindAddress == null) {\n            bindAddress=srvSock.getInetAddress();\n        }\n        System.out.println(\"GossipRouter started at \" + new Date() +\n                \"\\nListening on port \" + port + \" bound on address \" + bindAddress + '\\n');\n\n        GossipData req;\n        String group;\n\n        while(up && srvSock != null) {\n            try {\n                sock=srvSock.accept();\n                sock.setSoLinger(true, 500);\n                input=new DataInputStream(sock.getInputStream());\n                // if(log.isTraceEnabled())\n                   // log.trace(\"accepted connection from \" + sock);\n\n                req=new GossipData();\n                req.readFrom(input);\n\n                switch(req.getType()) {\n                    case GossipRouter.REGISTER:\n                        mbr=req.getAddress();\n                        group=req.getGroup();\n                        if(log.isTraceEnabled())\n                            log.trace(\"REGISTER(\" + group + \", \" + mbr + \")\");\n                        if(group == null || mbr == null) {\n                            if(log.isErrorEnabled()) log.error(\"group or member is null, cannot register member\");\n                        }\n                        else\n                            addGossipEntry(group, mbr, new AddressEntry(mbr));\n                        Util.close(input);\n                        Util.close(sock);\n                        break;\n\n                    case GossipRouter.UNREGISTER:\n                        mbr=req.getAddress();\n                        group=req.getGroup();\n                        if(log.isTraceEnabled())\n                            log.trace(\"UNREGISTER(\" + group + \", \" + mbr + \")\");\n                        if(group == null || mbr == null) {\n                            if(log.isErrorEnabled()) log.error(\"group or member is null, cannot unregister member\");\n                        }\n                        else\n                            removeGossipEntry(group, mbr);\n                        Util.close(input);\n                        Util.close(output);\n                        Util.close(sock);\n                        break;\n\n                    case GossipRouter.GOSSIP_GET:\n                        group=req.getGroup();\n                        List<Address> mbrs=null;\n                        Map<Address,AddressEntry> map;\n                        synchronized(routingTable) {\n                            map=routingTable.get(group);\n                            if(map != null) {\n                                mbrs=new LinkedList<Address>(map.keySet());\n                            }\n                        }\n\n                        if(log.isTraceEnabled())\n                            log.trace(\"GOSSIP_GET(\" + group + \") --> \" + mbrs);\n                        output=new DataOutputStream(sock.getOutputStream());\n                        GossipData rsp=new GossipData(GossipRouter.GET_RSP, group, null, mbrs);\n                        rsp.writeTo(output);\n                        Util.close(input);\n                        Util.close(output);\n                        Util.close(sock);\n                        break;\n\n                    case GossipRouter.ROUTER_GET:\n                        group=req.getGroup();\n                        output=new DataOutputStream(sock.getOutputStream());\n\n                        List<Address> ret=null;\n                        synchronized(routingTable) {\n                            map=routingTable.get(group);\n                            if(map != null) {\n                                ret=new LinkedList<Address>(map.keySet());\n                            }\n                            else\n                                ret=new LinkedList<Address>();\n                        }\n                        if(log.isTraceEnabled())\n                            log.trace(\"ROUTER_GET(\" + group + \") --> \" + ret);\n                        rsp=new GossipData(GossipRouter.GET_RSP, group, null, ret);\n                        rsp.writeTo(output);\n                        Util.close(input);\n                        Util.close(output);\n                        Util.close(sock);\n                        break;\n\n                    case GossipRouter.DUMP:\n                        output=new DataOutputStream(sock.getOutputStream());\n                        output.writeUTF(dumpRoutingTable());\n                        Util.close(input);\n                        Util.close(output);\n                        Util.close(sock);\n                        break;\n\n                    case GossipRouter.CONNECT:\n                        output=new DataOutputStream(sock.getOutputStream());\n                        peer_addr=new IpAddress(sock.getInetAddress(), sock.getPort());\n                        output=new DataOutputStream(sock.getOutputStream());\n                        logical_addr=req.getAddress();\n                        String group_name=req.getGroup();\n\n                        if(log.isTraceEnabled())\n                            log.trace(\"CONNECT(\" + group_name + \", \" + logical_addr + \")\");\n                        SocketThread st=new SocketThread(sock, input, group_name, logical_addr);\n                        addEntry(group_name, logical_addr, new AddressEntry(logical_addr, peer_addr, sock, st, output));\n                        st.start();\n                        break;\n\n                    case GossipRouter.DISCONNECT:\n                        Address addr=req.getAddress();\n                        group_name=req.getGroup();\n                        removeEntry(group_name, addr);\n                        if(log.isTraceEnabled())\n                            log.trace(\"DISCONNECT(\" + group_name + \", \" + addr + \")\");\n                        Util.close(input);\n                        Util.close(output);\n                        Util.close(sock);\n                        break;\n\n                    case GossipRouter.SHUTDOWN:\n                        if(log.isInfoEnabled()) log.info(\"router shutting down\");\n                        Util.close(input);\n                        Util.close(output);\n                        Util.close(sock);\n                        up=false;\n                        break;\n                    default:\n                        if(log.isWarnEnabled())\n                            log.warn(\"received unkown gossip request (gossip=\" + req + ')');\n                        break;\n                }\n            }\n            catch(Exception e) {\n                if(up)\n                    if(log.isErrorEnabled()) log.error(\"failure handling a client request\", e);\n                Util.close(input);\n                Util.close(output);\n                Util.close(sock);\n            }\n        }\n    }","id":6653,"modified_method":"/**\n     * The main server loop. Runs on the JGroups Router Main Thread.\n     */\n    private void mainLoop() {\n        Socket sock=null;\n        DataInputStream input=null;\n        DataOutputStream output=null;\n        Address peer_addr=null, mbr, logical_addr;\n\n        if(bindAddress == null) {\n            bindAddress=srvSock.getInetAddress();\n        }\n        System.out.println(\"GossipRouter started at \" + new Date() +\n                \"\\nListening on port \" + port + \" bound on address \" + bindAddress + '\\n');\n\n        GossipData req;\n        String group;\n\n        while(up && srvSock != null) {\n            try {\n                sock=srvSock.accept();\n                sock.setSoLinger(true, 500);\n                input=new DataInputStream(sock.getInputStream());\n                // if(log.isTraceEnabled())\n                   // log.trace(\"accepted connection from \" + sock);\n\n                req=new GossipData();\n                req.readFrom(input);\n\n                switch(req.getType()) {\n                    case GossipRouter.REGISTER:\n                        mbr=req.getAddress();\n                        group=req.getGroup();\n                        if(log.isTraceEnabled())\n                            log.trace(\"REGISTER(\" + group + \", \" + mbr + \")\");\n                        if(group == null || mbr == null) {\n                            if(log.isErrorEnabled()) log.error(\"group or member is null, cannot register member\");\n                        }\n                        else\n                            addGossipEntry(group, mbr, new AddressEntry(mbr));\n                        Util.close(input);\n                        Util.close(sock);\n                        break;\n\n                    case GossipRouter.UNREGISTER:\n                        mbr=req.getAddress();\n                        group=req.getGroup();\n                        if(log.isTraceEnabled())\n                            log.trace(\"UNREGISTER(\" + group + \", \" + mbr + \")\");\n                        if(group == null || mbr == null) {\n                            if(log.isErrorEnabled()) log.error(\"group or member is null, cannot unregister member\");\n                        }\n                        else\n                            removeGossipEntry(group, mbr);\n                        Util.close(input);\n                        Util.close(output);\n                        Util.close(sock);\n                        break;\n\n                    case GossipRouter.GOSSIP_GET:\n                        group=req.getGroup();\n                        List<Address> mbrs=null;\n                        Map<Address,AddressEntry> map;\n                        map=routingTable.get(group);\n                        if(map != null) {\n                            mbrs=new LinkedList<Address>(map.keySet());\n                        }\n\n                        if(log.isTraceEnabled())\n                            log.trace(\"GOSSIP_GET(\" + group + \") --> \" + mbrs);\n                        output=new DataOutputStream(sock.getOutputStream());\n                        GossipData rsp=new GossipData(GossipRouter.GET_RSP, group, null, mbrs);\n                        rsp.writeTo(output);\n                        Util.close(input);\n                        Util.close(output);\n                        Util.close(sock);\n                        break;\n\n                    case GossipRouter.ROUTER_GET:\n                        group=req.getGroup();\n                        output=new DataOutputStream(sock.getOutputStream());\n\n                        List<Address> ret=null;\n                        map=routingTable.get(group);\n                        if(map != null) {\n                            ret=new LinkedList<Address>(map.keySet());\n                        }\n                        else\n                            ret=new LinkedList<Address>();\n                        if(log.isTraceEnabled())\n                            log.trace(\"ROUTER_GET(\" + group + \") --> \" + ret);\n                        rsp=new GossipData(GossipRouter.GET_RSP, group, null, ret);\n                        rsp.writeTo(output);\n                        Util.close(input);\n                        Util.close(output);\n                        Util.close(sock);\n                        break;\n\n                    case GossipRouter.DUMP:\n                        output=new DataOutputStream(sock.getOutputStream());\n                        output.writeUTF(dumpRoutingTable());\n                        Util.close(input);\n                        Util.close(output);\n                        Util.close(sock);\n                        break;\n\n                    case GossipRouter.CONNECT:\n                        output=new DataOutputStream(sock.getOutputStream());\n                        peer_addr=new IpAddress(sock.getInetAddress(), sock.getPort());\n                        output=new DataOutputStream(sock.getOutputStream());\n                        logical_addr=req.getAddress();\n                        String group_name=req.getGroup();\n\n                        if(log.isTraceEnabled())\n                            log.trace(\"CONNECT(\" + group_name + \", \" + logical_addr + \")\");\n                        SocketThread st=new SocketThread(sock, input, group_name, logical_addr);\n                        addEntry(group_name, logical_addr, new AddressEntry(logical_addr, peer_addr, sock, st, output));\n                        st.start();\n                        break;\n\n                    case GossipRouter.DISCONNECT:\n                        Address addr=req.getAddress();\n                        group_name=req.getGroup();\n                        removeEntry(group_name, addr);\n                        if(log.isTraceEnabled())\n                            log.trace(\"DISCONNECT(\" + group_name + \", \" + addr + \")\");\n                        Util.close(input);\n                        Util.close(output);\n                        Util.close(sock);\n                        break;\n\n                    case GossipRouter.SHUTDOWN:\n                        if(log.isInfoEnabled()) log.info(\"router shutting down\");\n                        Util.close(input);\n                        Util.close(output);\n                        Util.close(sock);\n                        up=false;\n                        break;\n                    default:\n                        if(log.isWarnEnabled())\n                            log.warn(\"received unkown gossip request (gossip=\" + req + ')');\n                        break;\n                }\n            }\n            catch(Exception e) {\n                if(up)\n                    if(log.isErrorEnabled()) log.error(\"failure handling a client request\", e);\n                Util.close(input);\n                Util.close(output);\n                Util.close(sock);\n            }\n        }\n    }","commit_id":"e06ff228065574d1facd8a1b892afaa2ab144b1b","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Adds a new member to the routing group.\n     */\n    private void addEntry(String groupname, Address logical_addr, AddressEntry entry, boolean update_only) {\n        if(groupname == null || logical_addr == null) {\n            if(log.isErrorEnabled()) log.error(\"groupname or logical_addr was null, entry was not added\");\n            return;\n        }\n\n        synchronized(routingTable) {\n            Map<Address,AddressEntry> mbrs=routingTable.get(groupname);\n            if(mbrs == null) {\n                mbrs=new HashMap<Address,AddressEntry>();\n                mbrs.put(logical_addr, entry);\n                routingTable.put(groupname, mbrs);\n            }\n            else {\n                AddressEntry tmp=mbrs.get(logical_addr);\n                if(tmp != null) { // already present\n                    if(update_only) {\n                        tmp.update();\n                        return;\n                    }\n                    tmp.destroy();\n                }\n                mbrs.put(logical_addr, entry);\n            }\n        }\n    }","id":6654,"modified_method":"/**\n     * Adds a new member to the routing group.\n     */\n    private void addEntry(String groupname, Address logical_addr, AddressEntry entry, boolean update_only) {\n        if(groupname == null || logical_addr == null) {\n            if(log.isErrorEnabled()) log.error(\"groupname or logical_addr was null, entry was not added\");\n            return;\n        }\n\n        ConcurrentMap<Address,AddressEntry> mbrs=routingTable.get(groupname);\n        if(mbrs == null) {\n            mbrs=new ConcurrentHashMap<Address,AddressEntry>();\n            mbrs.put(logical_addr, entry);\n            routingTable.putIfAbsent(groupname, mbrs);\n        }\n        else {\n            AddressEntry tmp=mbrs.get(logical_addr);\n            if(tmp != null) { // already present\n                if(update_only) {\n                    tmp.update();\n                    return;\n                }\n                tmp.destroy();\n            }\n            mbrs.put(logical_addr, entry);\n        }\n    }","commit_id":"e06ff228065574d1facd8a1b892afaa2ab144b1b","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Removes expired gossip entries (entries older than EXPIRY_TIME msec).\n     * @since 2.2.1\n     */\n    private void sweep() {\n        long diff, currentTime=System.currentTimeMillis();\n        int num_entries_removed=0;\n\n        synchronized(routingTable) {\n            Map.Entry entry, entry2;\n            Map map;\n            AddressEntry ae;\n            for(Iterator it=routingTable.entrySet().iterator(); it.hasNext();) {\n                entry=(Map.Entry)it.next();\n                map=(Map)entry.getValue();\n                if(map == null || map.isEmpty()) {\n                    it.remove();\n                    continue;\n                }\n                for(Iterator it2=map.entrySet().iterator(); it2.hasNext();) {\n                    entry2=(Map.Entry)it2.next();\n                    ae=(GossipRouter.AddressEntry)entry2.getValue();\n                    diff=currentTime - ae.timestamp;\n                    if(diff > expiryTime) {\n                        it2.remove();\n                        if(log.isTraceEnabled())\n                            log.trace(\"removed \" + ae.logical_addr + \" (\" + diff + \" msecs old)\");\n                        num_entries_removed++;\n                    }\n                }\n            }\n        }\n\n        if(num_entries_removed > 0) {\n            if(log.isTraceEnabled()) log.trace(\"done (removed \" + num_entries_removed + \" entries)\");\n        }\n    }","id":6655,"modified_method":"/**\n     * Removes expired gossip entries (entries older than EXPIRY_TIME msec).\n     * @since 2.2.1\n     */\n    private void sweep() {\n        long diff, currentTime=System.currentTimeMillis();\n        int num_entries_removed=0;\n\n        Map.Entry entry, entry2;\n        Map map;\n        AddressEntry ae;\n        for(Iterator it=routingTable.entrySet().iterator(); it.hasNext();) {\n            entry=(Map.Entry)it.next();\n            map=(Map)entry.getValue();\n            if(map == null || map.isEmpty()) {\n                it.remove();\n                continue;\n            }\n            for(Iterator it2=map.entrySet().iterator(); it2.hasNext();) {\n                entry2=(Map.Entry)it2.next();\n                ae=(GossipRouter.AddressEntry)entry2.getValue();\n                diff=currentTime - ae.timestamp;\n                if(diff > expiryTime) {\n                    it2.remove();\n                    if(log.isTraceEnabled())\n                        log.trace(\"removed \" + ae.logical_addr + \" (\" + diff + \" msecs old)\");\n                    num_entries_removed++;\n                }\n            }\n        }\n\n        if(num_entries_removed > 0) {\n            if(log.isTraceEnabled()) log.trace(\"done (removed \" + num_entries_removed + \" entries)\");\n        }\n    }","commit_id":"e06ff228065574d1facd8a1b892afaa2ab144b1b","url":"https://github.com/belaban/JGroups"},{"original_method":"private void removeEntry(String groupname, Address logical_addr) {\n        Map val;\n        synchronized(routingTable) {\n            val=routingTable.get(groupname);\n            if(val == null)\n                return;\n        }\n        synchronized(val) {\n            AddressEntry entry=(AddressEntry)val.get(logical_addr);\n            if(entry != null) {\n                entry.destroy();\n                val.remove(logical_addr);\n            }\n        }\n    }","id":6656,"modified_method":"private void removeEntry(String groupname, Address logical_addr) {\n        Map val;\n        val=routingTable.get(groupname);\n        if(val == null)\n            return;\n        synchronized(val) {\n            AddressEntry entry=(AddressEntry)val.get(logical_addr);\n            if(entry != null) {\n                entry.destroy();\n                val.remove(logical_addr);\n            }\n        }\n    }","commit_id":"e06ff228065574d1facd8a1b892afaa2ab144b1b","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * @return null if not found\n     */\n    private AddressEntry findAddressEntry(String group_name, Address logical_addr) {\n        if(group_name == null || logical_addr == null)\n            return null;\n        synchronized(routingTable) {\n            Map val=routingTable.get(group_name);\n            if(val == null)\n                return null;\n            return (AddressEntry)val.get(logical_addr);\n        }\n    }","id":6657,"modified_method":"/**\n     * @return null if not found\n     */\n    private AddressEntry findAddressEntry(String group_name, Address logical_addr) {\n        if(group_name == null || logical_addr == null)\n            return null;\n        Map val=routingTable.get(group_name);\n        if(val == null)\n            return null;\n        return (AddressEntry)val.get(logical_addr);\n    }","commit_id":"e06ff228065574d1facd8a1b892afaa2ab144b1b","url":"https://github.com/belaban/JGroups"},{"original_method":"public DataStructure remove(Hash key) {\n        synchronized (_data) {\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(\"Removing key \" + key.toBase64());\n            return (DataStructure)_data.remove(key);\n        }\n    }","id":6658,"modified_method":"public DataStructure remove(Hash key) {\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Removing key \" + key.toBase64());\n        return _data.remove(key);\n    }","commit_id":"44446d76e43e27d529ea2fa90b2ec72893be8def","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void restart() {\n        synchronized (_data) {\n            _data.clear();\n        }\n    }","id":6659,"modified_method":"public void restart() {\n        _data.clear();\n    }","commit_id":"44446d76e43e27d529ea2fa90b2ec72893be8def","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public TransientDataStore(RouterContext ctx) {\n        _context = ctx;\n        _log = ctx.logManager().getLog(TransientDataStore.class);\n        _data = new HashMap(1024);\n        if (_log.shouldLog(Log.INFO))\n            _log.info(\"Data Store initialized\");\n    }","id":6660,"modified_method":"public TransientDataStore(RouterContext ctx) {\n        _context = ctx;\n        _log = ctx.logManager().getLog(TransientDataStore.class);\n        _data = new ConcurrentHashMap(1024);\n        if (_log.shouldLog(Log.INFO))\n            _log.info(\"Data Store initialized\");\n    }","commit_id":"44446d76e43e27d529ea2fa90b2ec72893be8def","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public String toString() {\n        StringBuffer buf = new StringBuffer();\n        buf.append(\"Transient DataStore: \").append(_data.size()).append(\"\\nKeys: \");\n        Map data = new HashMap();\n        synchronized (_data) {\n            data.putAll(_data);\n        }\n        for (Iterator iter = data.keySet().iterator(); iter.hasNext();) {\n            Hash key = (Hash)iter.next();\n            DataStructure dp = (DataStructure)data.get(key);\n            buf.append(\"\\n\\t*Key:   \").append(key.toString()).append(\"\\n\\tContent: \").append(dp.toString());\n        }\n        buf.append(\"\\n\");\n        return buf.toString();\n    }","id":6661,"modified_method":"public String toString() {\n        StringBuffer buf = new StringBuffer();\n        buf.append(\"Transient DataStore: \").append(_data.size()).append(\"\\nKeys: \");\n        for (Map.Entry<Hash, DataStructure> e : _data.entrySet()) {\n            Hash key = e.getKey();\n            DataStructure dp = e.getValue();\n            buf.append(\"\\n\\t*Key:   \").append(key.toString()).append(\"\\n\\tContent: \").append(dp.toString());\n        }\n        buf.append(\"\\n\");\n        return buf.toString();\n    }","commit_id":"44446d76e43e27d529ea2fa90b2ec72893be8def","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void put(Hash key, DataStructure data) {\n        if (data == null) return;\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Storing key \" + key);\n        Object old = null;\n        synchronized (_data) {\n            old = _data.put(key, data);\n        }\n        if (data instanceof RouterInfo) {\n            _context.profileManager().heardAbout(key);\n            RouterInfo ri = (RouterInfo)data;\n            if (old != null) {\n                RouterInfo ori = (RouterInfo)old;\n                if (ri.getPublished() < ori.getPublished()) {\n                    if (_log.shouldLog(Log.INFO))\n                        _log.info(\"Almost clobbered an old router! \" + key + \": [old published on \" + new Date(ori.getPublished()) + \" new on \" + new Date(ri.getPublished()) + \"]\");\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(\"Number of router options for \" + key + \": \" + ri.getOptions().size() + \" (old one had: \" + ori.getOptions().size() + \")\", new Exception(\"Updated routerInfo\"));\n                    synchronized (_data) {\n                        _data.put(key, old);\n                    }\n                } else if (ri.getPublished() > _context.clock().now() + MAX_FUTURE_PUBLISH_DATE) {\n                    if (_log.shouldLog(Log.INFO))\n                        _log.info(\"Hmm, someone tried to give us something with the publication date really far in the future (\" + new Date(ri.getPublished()) + \"), dropping it\");\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(\"Number of router options for \" + key + \": \" + ri.getOptions().size() + \" (old one had: \" + ori.getOptions().size() + \")\", new Exception(\"Updated routerInfo\"));\n                    synchronized (_data) {\n                        _data.put(key, old);\n                    }\n                } else {\n                    if (_log.shouldLog(Log.INFO))\n                        _log.info(\"Updated the old router for \" + key + \": [old published on \" + new Date(ori.getPublished()) + \" new on \" + new Date(ri.getPublished()) + \"]\");\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(\"Number of router options for \" + key + \": \" + ri.getOptions().size() + \" (old one had: \" + ori.getOptions().size() + \")\", new Exception(\"Updated routerInfo\"));\n                }\n            } else {\n                if (_log.shouldLog(Log.INFO))\n                    _log.info(\"Brand new router for \" + key + \": published on \" + new Date(ri.getPublished()));\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(\"Number of router options for \" + key + \": \" + ri.getOptions().size(), new Exception(\"Updated routerInfo\"));\n            }\n        } else if (data instanceof LeaseSet) {\n            LeaseSet ls = (LeaseSet)data;\n            if (old != null) {\n                LeaseSet ols = (LeaseSet)old;\n                if (ls.getEarliestLeaseDate() < ols.getEarliestLeaseDate()) {\n                    if (_log.shouldLog(Log.INFO))\n                        _log.info(\"Almost clobbered an old leaseSet! \" + key + \": [old published on \" + new Date(ols.getEarliestLeaseDate()) + \" new on \" + new Date(ls.getEarliestLeaseDate()) + \"]\");\n                    synchronized (_data) {\n                        _data.put(key, old);\n                    }\n                } else if (ls.getEarliestLeaseDate() > _context.clock().now() + MAX_FUTURE_EXPIRATION_DATE) {\n                    if (_log.shouldLog(Log.INFO))\n                        _log.info(\"Hmm, someone tried to give us something with the expiration date really far in the future (\" + new Date(ls.getEarliestLeaseDate()) + \"), dropping it\");\n                    synchronized (_data) {\n                        _data.put(key, old);\n                    }\n                }\n            }\n        }\n    }","id":6662,"modified_method":"public void put(Hash key, DataStructure data) {\n        if (data == null) return;\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Storing key \" + key);\n        DataStructure old = null;\n        old = _data.put(key, data);\n        if (data instanceof RouterInfo) {\n            _context.profileManager().heardAbout(key);\n            RouterInfo ri = (RouterInfo)data;\n            if (old != null) {\n                RouterInfo ori = (RouterInfo)old;\n                if (ri.getPublished() < ori.getPublished()) {\n                    if (_log.shouldLog(Log.INFO))\n                        _log.info(\"Almost clobbered an old router! \" + key + \": [old published on \" + new Date(ori.getPublished()) + \" new on \" + new Date(ri.getPublished()) + \"]\");\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(\"Number of router options for \" + key + \": \" + ri.getOptions().size() + \" (old one had: \" + ori.getOptions().size() + \")\", new Exception(\"Updated routerInfo\"));\n                    _data.put(key, old);\n                } else if (ri.getPublished() > _context.clock().now() + MAX_FUTURE_PUBLISH_DATE) {\n                    if (_log.shouldLog(Log.INFO))\n                        _log.info(\"Hmm, someone tried to give us something with the publication date really far in the future (\" + new Date(ri.getPublished()) + \"), dropping it\");\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(\"Number of router options for \" + key + \": \" + ri.getOptions().size() + \" (old one had: \" + ori.getOptions().size() + \")\", new Exception(\"Updated routerInfo\"));\n                    _data.put(key, old);\n                } else {\n                    if (_log.shouldLog(Log.INFO))\n                        _log.info(\"Updated the old router for \" + key + \": [old published on \" + new Date(ori.getPublished()) + \" new on \" + new Date(ri.getPublished()) + \"]\");\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(\"Number of router options for \" + key + \": \" + ri.getOptions().size() + \" (old one had: \" + ori.getOptions().size() + \")\", new Exception(\"Updated routerInfo\"));\n                }\n            } else {\n                if (_log.shouldLog(Log.INFO))\n                    _log.info(\"Brand new router for \" + key + \": published on \" + new Date(ri.getPublished()));\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(\"Number of router options for \" + key + \": \" + ri.getOptions().size(), new Exception(\"Updated routerInfo\"));\n            }\n        } else if (data instanceof LeaseSet) {\n            LeaseSet ls = (LeaseSet)data;\n            if (old != null) {\n                LeaseSet ols = (LeaseSet)old;\n                if (ls.getEarliestLeaseDate() < ols.getEarliestLeaseDate()) {\n                    if (_log.shouldLog(Log.INFO))\n                        _log.info(\"Almost clobbered an old leaseSet! \" + key + \": [old published on \" + new Date(ols.getEarliestLeaseDate()) + \" new on \" + new Date(ls.getEarliestLeaseDate()) + \"]\");\n                    _data.put(key, old);\n                } else if (ls.getEarliestLeaseDate() > _context.clock().now() + MAX_FUTURE_EXPIRATION_DATE) {\n                    if (_log.shouldLog(Log.INFO))\n                        _log.info(\"Hmm, someone tried to give us something with the expiration date really far in the future (\" + new Date(ls.getEarliestLeaseDate()) + \"), dropping it\");\n                    _data.put(key, old);\n                }\n            }\n        }\n    }","commit_id":"44446d76e43e27d529ea2fa90b2ec72893be8def","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public boolean isKnown(Hash key) {\n        synchronized (_data) {\n            return _data.containsKey(key);\n        }\n    }","id":6663,"modified_method":"public boolean isKnown(Hash key) {\n        return _data.containsKey(key);\n    }","commit_id":"44446d76e43e27d529ea2fa90b2ec72893be8def","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public DataStructure get(Hash key) {\n        synchronized (_data) {\n            return (DataStructure)_data.get(key);\n        }\n    }","id":6664,"modified_method":"public DataStructure get(Hash key) {\n        return _data.get(key);\n    }","commit_id":"44446d76e43e27d529ea2fa90b2ec72893be8def","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public Set getKeys() {\n        synchronized (_data) {\n            return new HashSet(_data.keySet());\n        }\n    }","id":6665,"modified_method":"public Set getKeys() {\n        return new HashSet(_data.keySet());\n    }","commit_id":"44446d76e43e27d529ea2fa90b2ec72893be8def","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public int countLeaseSets() {\n        int count = 0;\n        synchronized (_data) {\n            for (Iterator iter = _data.values().iterator(); iter.hasNext();) {\n                DataStructure data = (DataStructure)iter.next();\n                if (data instanceof LeaseSet)\n                    count++;\n            }\n        }\n        return count;\n    }","id":6666,"modified_method":"public int countLeaseSets() {\n        int count = 0;\n        for (DataStructure d : _data.values()) {\n            if (d instanceof LeaseSet)\n                count++;\n        }\n        return count;\n    }","commit_id":"44446d76e43e27d529ea2fa90b2ec72893be8def","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Returns the highest seqno seen from sender. E.g. if we received 1, 2, 4, 5 from P, then 5 will be returned\n     * (doesn't take gaps into account). If we are the sender, we will return the highest seqno <em>sent<\/em> rather\n     * then <em>received<\/em>\n     */\n    private long getHighSeqnoSeen(Address sender) {\n        NakReceiverWindow win;\n        long ret=0;\n\n        if(sender == null) {\n            if(log.isErrorEnabled()) {\n                log.error(\"sender is null\");\n            }\n            return ret;\n        }\n        if(sender.equals(local_addr)) {\n            return seqno - 1;\n        }\n\n        synchronized(received_msgs) {\n            win=(NakReceiverWindow)received_msgs.get(sender);\n        }\n        if(win == null) {\n            if(log.isErrorEnabled()) {\n                log.error(\"sender \" + sender + \" not found in received_msgs\");\n            }\n            return ret;\n        }\n        ret=win.getHighestReceived();\n        return ret;\n    }","id":6667,"modified_method":"/**\n     * Returns the highest seqno seen from sender. E.g. if we received 1, 2, 4, 5 from P, then 5 will be returned\n     * (doesn't take gaps into account). If we are the sender, we will return the highest seqno <em>sent<\/em> rather\n     * then <em>received<\/em>\n     */\n    private long getHighSeqnoSeen(Address sender) {\n        NakReceiverWindow win;\n        long ret=0;\n\n        if(sender == null) {\n            if(log.isErrorEnabled()) {\n                log.error(\"sender is null\");\n            }\n            return ret;\n        }\n        if(sender.equals(local_addr)) {\n            return seqno - 1;\n        }\n\n        win=received_msgs.get(sender);\n        if(win == null) {\n            if(log.isErrorEnabled()) {\n                log.error(\"sender \" + sender + \" not found in received_msgs\");\n            }\n            return ret;\n        }\n        ret=win.getHighestReceived();\n        return ret;\n    }","commit_id":"4f2ea4c5ce4a23b986f96d2832f9c14ff7fdd656","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns the lowest seqno still in cache (so it can be retransmitted) and the highest seqno received so far.\n     *\n     * @param sender       The address for which the highest and lowest seqnos are to be retrieved\n     * @param stop_at_gaps If true, the highest seqno *deliverable* will be returned. If false, the highest seqno\n     *                     *received* will be returned. E.g. for [+3 +4 +5 -6 +7 +8], the highest_seqno_received is 8,\n     *                     whereas the higheset_seqno_seen (deliverable) is 5.\n     */\n    private Range getLowestAndHighestSeqno(Address sender, boolean stop_at_gaps) {\n        Range r=null;\n        NakReceiverWindow win;\n\n        if(sender == null) {\n            if(log.isErrorEnabled()) {\n                log.error(\"sender is null\");\n            }\n            return r;\n        }\n        synchronized(received_msgs) {\n            win=(NakReceiverWindow)received_msgs.get(sender);\n        }\n        if(win == null) {\n            if(log.isErrorEnabled()) {\n                log.error(\"sender \" + sender + \" not found in received_msgs\");\n            }\n            return r;\n        }\n        if(stop_at_gaps) {\n            r=new Range(win.getLowestSeen(), win.getHighestSeen());       // deliverable messages (no gaps)\n        }\n        else {\n            r=new Range(win.getLowestSeen(), win.getHighestReceived() + 1); // received messages\n        }\n        return r;\n    }","id":6668,"modified_method":"/**\n     * Returns the lowest seqno still in cache (so it can be retransmitted) and the highest seqno received so far.\n     *\n     * @param sender       The address for which the highest and lowest seqnos are to be retrieved\n     * @param stop_at_gaps If true, the highest seqno *deliverable* will be returned. If false, the highest seqno\n     *                     *received* will be returned. E.g. for [+3 +4 +5 -6 +7 +8], the highest_seqno_received is 8,\n     *                     whereas the higheset_seqno_seen (deliverable) is 5.\n     */\n    private Range getLowestAndHighestSeqno(Address sender, boolean stop_at_gaps) {\n        Range r=null;\n        NakReceiverWindow win;\n\n        if(sender == null) {\n            if(log.isErrorEnabled()) {\n                log.error(\"sender is null\");\n            }\n            return r;\n        }\n        win=received_msgs.get(sender);\n        if(win == null) {\n            if(log.isErrorEnabled()) {\n                log.error(\"sender \" + sender + \" not found in received_msgs\");\n            }\n            return r;\n        }\n        if(stop_at_gaps) {\n            r=new Range(win.getLowestSeen(), win.getHighestSeen());       // deliverable messages (no gaps)\n        }\n        else {\n            r=new Range(win.getLowestSeen(), win.getHighestReceived() + 1); // received messages\n        }\n        return r;\n    }","commit_id":"4f2ea4c5ce4a23b986f96d2832f9c14ff7fdd656","url":"https://github.com/belaban/JGroups"},{"original_method":"private void clear() {\n        NakReceiverWindow win;\n\n        // changed April 21 2004 (bela): SourceForge bug# 938584. We cannot delete our own messages sent between\n        // a join() and a getState(). Otherwise retransmission requests from members who missed those msgs might\n        // fail. Not to worry though: those msgs will be cleared by STABLE (message garbage collection)\n\n        // sent_msgs.clear();\n\n        synchronized(received_msgs) {\n            for(Iterator it=received_msgs.values().iterator(); it.hasNext();) {\n                win=(NakReceiverWindow)it.next();\n                win.reset();\n            }\n            received_msgs.clear();\n        }\n    }","id":6669,"modified_method":"private void clear() {\n        NakReceiverWindow win;\n\n        // changed April 21 2004 (bela): SourceForge bug# 938584. We cannot delete our own messages sent between\n        // a join() and a getState(). Otherwise retransmission requests from members who missed those msgs might\n        // fail. Not to worry though: those msgs will be cleared by STABLE (message garbage collection)\n\n        // sent_msgs.clear();\n\n        for(Iterator it=received_msgs.values().iterator(); it.hasNext();) {\n            win=(NakReceiverWindow)it.next();\n            win.reset();\n        }\n        received_msgs.clear();\n    }","commit_id":"4f2ea4c5ce4a23b986f96d2832f9c14ff7fdd656","url":"https://github.com/belaban/JGroups"},{"original_method":"public int getReceivedTableSize() {\n        int ret=0;\n        NakReceiverWindow win;\n        Set s=new LinkedHashSet(received_msgs.values());\n        for(Iterator it=s.iterator(); it.hasNext();) {\n            win=(NakReceiverWindow)it.next();\n            ret+=win.size();\n        }\n        return ret;\n    }","id":6670,"modified_method":"public int getReceivedTableSize() {\n        return getPendingRetransmissionRequests();\n    }","commit_id":"4f2ea4c5ce4a23b986f96d2832f9c14ff7fdd656","url":"https://github.com/belaban/JGroups"},{"original_method":"public int getPendingRetransmissionRequests() {\n        int num=0;\n        NakReceiverWindow win;\n        synchronized(received_msgs) {\n            for(Iterator it=received_msgs.values().iterator(); it.hasNext();) {\n                win=(NakReceiverWindow)it.next();\n                num+=win.size();\n            }\n        }\n        return num;\n    }","id":6671,"modified_method":"public int getPendingRetransmissionRequests() {\n        int num=0;\n        for(NakReceiverWindow win: received_msgs.values()) {\n            num+=win.size();\n        }\n        return num;\n    }","commit_id":"4f2ea4c5ce4a23b986f96d2832f9c14ff7fdd656","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Creates a NakReceiverWindow for each sender in the digest according to the sender's seqno. If NRW already exists,\n     * reset it.\n     */\n    private void setDigest(Digest digest) {\n        if(digest == null) {\n            if(log.isErrorEnabled()) {\n                log.error(\"digest or digest.senders is null\");\n            }\n            return;\n        }\n\n        clear();\n\n        Map.Entry entry;\n        Address sender;\n        org.jgroups.protocols.pbcast.Digest.Entry val;\n        long initial_seqno;\n        NakReceiverWindow win;\n\n        for(Iterator it=digest.getSenders().entrySet().iterator(); it.hasNext();) {\n            entry=(Map.Entry)it.next();\n            sender=(Address)entry.getKey();\n            val=(org.jgroups.protocols.pbcast.Digest.Entry)entry.getValue();\n\n            if(sender == null || val == null) {\n                if(warn) {\n                    log.warn(\"sender or value is null\");\n                }\n                continue;\n            }\n            initial_seqno=val.getHigh();\n            win=createNakReceiverWindow(sender, initial_seqno);\n            synchronized(received_msgs) {\n                received_msgs.put(sender, win);\n            }\n        }\n    }","id":6672,"modified_method":"/**\n     * Creates a NakReceiverWindow for each sender in the digest according to the sender's seqno. If NRW already exists,\n     * reset it.\n     */\n    private void setDigest(Digest digest) {\n        if(digest == null) {\n            if(log.isErrorEnabled()) {\n                log.error(\"digest or digest.senders is null\");\n            }\n            return;\n        }\n\n        clear();\n\n        Map.Entry entry;\n        Address sender;\n        org.jgroups.protocols.pbcast.Digest.Entry val;\n        long initial_seqno;\n        NakReceiverWindow win;\n\n        for(Iterator it=digest.getSenders().entrySet().iterator(); it.hasNext();) {\n            entry=(Map.Entry)it.next();\n            sender=(Address)entry.getKey();\n            val=(org.jgroups.protocols.pbcast.Digest.Entry)entry.getValue();\n\n            if(sender == null || val == null) {\n                if(warn) {\n                    log.warn(\"sender or value is null\");\n                }\n                continue;\n            }\n            initial_seqno=val.getHigh();\n            win=createNakReceiverWindow(sender, initial_seqno);\n            received_msgs.put(sender, win);\n        }\n    }","commit_id":"4f2ea4c5ce4a23b986f96d2832f9c14ff7fdd656","url":"https://github.com/belaban/JGroups"},{"original_method":"public Map dumpStats() {\n        Map retval=super.dumpStats();\n        if(retval == null)\n            retval=new HashMap();\n\n        retval.put(\"xmit_reqs_received\", new Long(xmit_reqs_received));\n        retval.put(\"xmit_reqs_sent\", new Long(xmit_reqs_sent));\n        retval.put(\"xmit_rsps_received\", new Long(xmit_rsps_received));\n        retval.put(\"xmit_rsps_sent\", new Long(xmit_rsps_sent));\n        retval.put(\"missing_msgs_received\", new Long(missing_msgs_received));\n\n        retval.put(\"sent_msgs\", printSentMsgs());\n\n        StringBuilder sb=new StringBuilder();\n        Map.Entry entry;\n        Address addr;\n        Object w;\n        synchronized(received_msgs) {\n            for(Iterator it=received_msgs.entrySet().iterator(); it.hasNext();) {\n                entry=(Map.Entry)it.next();\n                addr=(Address)entry.getKey();\n                w=entry.getValue();\n                sb.append(addr).append(\": \").append(w.toString()).append('\\n');\n            }\n        }\n\n        retval.put(\"received_msgs\", sb.toString());\n        return retval;        \n    }","id":6673,"modified_method":"public Map dumpStats() {\n        Map retval=super.dumpStats();\n        if(retval == null)\n            retval=new HashMap();\n\n        retval.put(\"xmit_reqs_received\", new Long(xmit_reqs_received));\n        retval.put(\"xmit_reqs_sent\", new Long(xmit_reqs_sent));\n        retval.put(\"xmit_rsps_received\", new Long(xmit_rsps_received));\n        retval.put(\"xmit_rsps_sent\", new Long(xmit_rsps_sent));\n        retval.put(\"missing_msgs_received\", new Long(missing_msgs_received));\n        retval.put(\"sent_msgs\", printSentMsgs());\n\n        StringBuilder sb=new StringBuilder();\n        Address addr;\n        Object w;\n\n        for(Map.Entry<Address,NakReceiverWindow> entry: received_msgs.entrySet()) {\n            addr=entry.getKey();\n            w=entry.getValue();\n            sb.append(addr).append(\": \").append(w.toString()).append('\\n');\n        }\n\n        retval.put(\"received_msgs\", sb.toString());\n        return retval;        \n    }","commit_id":"4f2ea4c5ce4a23b986f96d2832f9c14ff7fdd656","url":"https://github.com/belaban/JGroups"},{"original_method":"public String printMessages() {\n       StringBuilder ret=new StringBuilder();\n        Map.Entry entry;\n        Address addr;\n        Object w;\n\n       ret.append(\"\\nsent_msgs: \").append(printSentMsgs());\n        ret.append(\"\\nreceived_msgs:\\n\");\n        synchronized(received_msgs) {\n            for(Iterator it=received_msgs.entrySet().iterator(); it.hasNext();) {\n                entry=(Map.Entry)it.next();\n                addr=(Address)entry.getKey();\n                w=entry.getValue();\n                ret.append(addr).append(\": \").append(w.toString()).append('\\n');\n            }\n        }\n        return ret.toString();\n    }","id":6674,"modified_method":"public String printMessages() {\n       StringBuilder ret=new StringBuilder();\n        Map.Entry entry;\n        Address addr;\n        Object w;\n\n       ret.append(\"\\nsent_msgs: \").append(printSentMsgs());\n        ret.append(\"\\nreceived_msgs:\\n\");\n       for(Iterator it=received_msgs.entrySet().iterator(); it.hasNext();) {\n           entry=(Map.Entry)it.next();\n           addr=(Address)entry.getKey();\n           w=entry.getValue();\n           ret.append(addr).append(\": \").append(w.toString()).append('\\n');\n       }\n       return ret.toString();\n   }","commit_id":"4f2ea4c5ce4a23b986f96d2832f9c14ff7fdd656","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * For all members of the digest, adjust the NakReceiverWindows in the received_msgs hashtable. If the member\n     * already exists, sets its seqno to be the max of the seqno and the seqno of the member in the digest. If no entry\n     * exists, create one with the initial seqno set to the seqno of the member in the digest.\n     */\n    private void mergeDigest(Digest digest) {\n        if(digest == null) {\n            if(log.isErrorEnabled()) {\n                log.error(\"digest or digest.senders is null\");\n            }\n            return;\n        }\n\n        Map.Entry entry;\n        Address sender;\n        org.jgroups.protocols.pbcast.Digest.Entry val;\n        NakReceiverWindow win;\n        long initial_seqno;\n\n        for(Iterator it=digest.getSenders().entrySet().iterator(); it.hasNext();) {\n            entry=(Map.Entry)it.next();\n            sender=(Address)entry.getKey();\n            val=(org.jgroups.protocols.pbcast.Digest.Entry)entry.getValue();\n\n            if(sender == null || val == null) {\n                if(warn) {\n                    log.warn(\"sender or value is null\");\n                }\n                continue;\n            }\n            initial_seqno=val.getHigh();\n            synchronized(received_msgs) {\n                win=(NakReceiverWindow)received_msgs.get(sender);\n                if(win == null) {\n                    win=createNakReceiverWindow(sender, initial_seqno);\n                    received_msgs.put(sender, win);\n                }\n                else {\n                    if(win.getHighestReceived() < initial_seqno) {\n                        win.reset();\n                        received_msgs.remove(sender);\n                        win=createNakReceiverWindow(sender, initial_seqno);\n                        received_msgs.put(sender, win);\n                    }\n                }\n            }\n        }\n    }","id":6675,"modified_method":"/**\n     * For all members of the digest, adjust the NakReceiverWindows in the received_msgs hashtable. If the member\n     * already exists, sets its seqno to be the max of the seqno and the seqno of the member in the digest. If no entry\n     * exists, create one with the initial seqno set to the seqno of the member in the digest.\n     */\n    private void mergeDigest(Digest digest) {\n        if(digest == null) {\n            if(log.isErrorEnabled()) {\n                log.error(\"digest or digest.senders is null\");\n            }\n            return;\n        }\n\n        Map.Entry entry;\n        Address sender;\n        org.jgroups.protocols.pbcast.Digest.Entry val;\n        NakReceiverWindow win;\n        long initial_seqno;\n\n        for(Iterator it=digest.getSenders().entrySet().iterator(); it.hasNext();) {\n            entry=(Map.Entry)it.next();\n            sender=(Address)entry.getKey();\n            val=(org.jgroups.protocols.pbcast.Digest.Entry)entry.getValue();\n\n            if(sender == null || val == null) {\n                if(warn) {\n                    log.warn(\"sender or value is null\");\n                }\n                continue;\n            }\n            initial_seqno=val.getHigh();\n\n            win=received_msgs.get(sender);\n            if(win == null) {\n                win=createNakReceiverWindow(sender, initial_seqno);\n                received_msgs.putIfAbsent(sender, win);\n            }\n            else {\n                if(win.getHighestReceived() < initial_seqno) {\n                    win.reset();\n                    received_msgs.remove(sender);\n                    win=createNakReceiverWindow(sender, initial_seqno);\n                    received_msgs.put(sender, win);\n                }\n            }\n        }\n    }","commit_id":"4f2ea4c5ce4a23b986f96d2832f9c14ff7fdd656","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Garbage collect messages that have been seen by all members. Update sent_msgs: for the sender P in the digest\n     * which is equal to the local address, garbage collect all messages <= seqno at digest[P]. Update received_msgs:\n     * for each sender P in the digest and its highest seqno seen SEQ, garbage collect all delivered_msgs in the\n     * NakReceiverWindow corresponding to P which are <= seqno at digest[P].\n     */\n    private void stable(Digest d) {\n        NakReceiverWindow recv_win;\n        long my_highest_rcvd;        // highest seqno received in my digest for a sender P\n        long stability_highest_rcvd; // highest seqno received in the stability vector for a sender P\n\n        if(members == null || local_addr == null || d == null) {\n            if(warn)\n                log.warn(\"members, local_addr or digest are null !\");\n            return;\n        }\n\n        if(trace) {\n            log.trace(\"received stable digest \" + d);\n        }\n\n        Map.Entry entry;\n        Address sender;\n        org.jgroups.protocols.pbcast.Digest.Entry val;\n        long high_seqno_delivered, high_seqno_received;\n\n        for(Iterator it=d.getSenders().entrySet().iterator(); it.hasNext();) {\n            entry=(Map.Entry)it.next();\n            sender=(Address)entry.getKey();\n            if(sender == null)\n                continue;\n            val=(org.jgroups.protocols.pbcast.Digest.Entry)entry.getValue();\n            high_seqno_delivered=val.getHigh();\n            high_seqno_received=val.getHighSeen();\n\n\n            // check whether the last seqno received for a sender P in the stability vector is > last seqno\n            // received for P in my digest. if yes, request retransmission (see \"Last Message Dropped\" topic\n            // in DESIGN)\n            synchronized(received_msgs) {\n                recv_win=(NakReceiverWindow)received_msgs.get(sender);\n            }\n            if(recv_win != null) {\n                my_highest_rcvd=recv_win.getHighestReceived();\n                stability_highest_rcvd=high_seqno_received;\n\n                if(stability_highest_rcvd >= 0 && stability_highest_rcvd > my_highest_rcvd) {\n                    if(trace) {\n                        log.trace(\"my_highest_rcvd (\" + my_highest_rcvd + \") < stability_highest_rcvd (\" +\n                                stability_highest_rcvd + \"): requesting retransmission of \" +\n                                sender + '#' + stability_highest_rcvd);\n                    }\n                    retransmit(stability_highest_rcvd, stability_highest_rcvd, sender);\n                }\n            }\n\n            high_seqno_delivered-=gc_lag;\n            if(high_seqno_delivered < 0) {\n                continue;\n            }\n\n            if(trace)\n                log.trace(\"deleting msgs <= \" + high_seqno_delivered + \" from \" + sender);\n\n            // garbage collect from sent_msgs if sender was myself\n            if(sender.equals(local_addr)) {\n                synchronized(sent_msgs) {\n                    // gets us a subset from [lowest seqno - seqno]\n                    SortedMap stable_keys=sent_msgs.headMap(new Long(high_seqno_delivered));\n                    if(stable_keys != null) {\n                        stable_keys.clear(); // this will modify sent_msgs directly\n                    }\n                }\n            }\n\n            // delete *delivered* msgs that are stable\n            // recv_win=(NakReceiverWindow)received_msgs.get(sender);\n            if(recv_win != null)\n                recv_win.stable(high_seqno_delivered);  // delete all messages with seqnos <= seqno\n        }\n    }","id":6676,"modified_method":"/**\n     * Garbage collect messages that have been seen by all members. Update sent_msgs: for the sender P in the digest\n     * which is equal to the local address, garbage collect all messages <= seqno at digest[P]. Update received_msgs:\n     * for each sender P in the digest and its highest seqno seen SEQ, garbage collect all delivered_msgs in the\n     * NakReceiverWindow corresponding to P which are <= seqno at digest[P].\n     */\n    private void stable(Digest d) {\n        NakReceiverWindow recv_win;\n        long my_highest_rcvd;        // highest seqno received in my digest for a sender P\n        long stability_highest_rcvd; // highest seqno received in the stability vector for a sender P\n\n        if(members == null || local_addr == null || d == null) {\n            if(warn)\n                log.warn(\"members, local_addr or digest are null !\");\n            return;\n        }\n\n        if(trace) {\n            log.trace(\"received stable digest \" + d);\n        }\n\n        Map.Entry entry;\n        Address sender;\n        org.jgroups.protocols.pbcast.Digest.Entry val;\n        long high_seqno_delivered, high_seqno_received;\n\n        for(Iterator it=d.getSenders().entrySet().iterator(); it.hasNext();) {\n            entry=(Map.Entry)it.next();\n            sender=(Address)entry.getKey();\n            if(sender == null)\n                continue;\n            val=(org.jgroups.protocols.pbcast.Digest.Entry)entry.getValue();\n            high_seqno_delivered=val.getHigh();\n            high_seqno_received=val.getHighSeen();\n\n\n            // check whether the last seqno received for a sender P in the stability vector is > last seqno\n            // received for P in my digest. if yes, request retransmission (see \"Last Message Dropped\" topic\n            // in DESIGN)\n            recv_win=received_msgs.get(sender);\n            if(recv_win != null) {\n                my_highest_rcvd=recv_win.getHighestReceived();\n                stability_highest_rcvd=high_seqno_received;\n\n                if(stability_highest_rcvd >= 0 && stability_highest_rcvd > my_highest_rcvd) {\n                    if(trace) {\n                        log.trace(\"my_highest_rcvd (\" + my_highest_rcvd + \") < stability_highest_rcvd (\" +\n                                stability_highest_rcvd + \"): requesting retransmission of \" +\n                                sender + '#' + stability_highest_rcvd);\n                    }\n                    retransmit(stability_highest_rcvd, stability_highest_rcvd, sender);\n                }\n            }\n\n            high_seqno_delivered-=gc_lag;\n            if(high_seqno_delivered < 0) {\n                continue;\n            }\n\n            if(trace)\n                log.trace(\"deleting msgs <= \" + high_seqno_delivered + \" from \" + sender);\n\n            // garbage collect from sent_msgs if sender was myself\n            if(sender.equals(local_addr)) {\n                synchronized(sent_msgs) {\n                    // gets us a subset from [lowest seqno - seqno]\n                    SortedMap stable_keys=sent_msgs.headMap(new Long(high_seqno_delivered));\n                    if(stable_keys != null) {\n                        stable_keys.clear(); // this will modify sent_msgs directly\n                    }\n                }\n            }\n\n            // delete *delivered* msgs that are stable\n            // recv_win=(NakReceiverWindow)received_msgs.get(sender);\n            if(recv_win != null)\n                recv_win.stable(high_seqno_delivered);  // delete all messages with seqnos <= seqno\n        }\n    }","commit_id":"4f2ea4c5ce4a23b986f96d2832f9c14ff7fdd656","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Remove old members from NakReceiverWindows and add new members (starting seqno=0). Essentially removes all\n     * entries from received_msgs that are not in <code>members<\/code>\n     */\n    private void adjustReceivers(boolean remove) {\n        NakReceiverWindow win;\n\n        synchronized(received_msgs) {\n            if(remove) {\n                // 1. Remove all senders in received_msgs that are not members anymore\n                for(Iterator it=received_msgs.keySet().iterator(); it.hasNext();) {\n                    Address sender=(Address)it.next();\n                    if(!members.contains(sender)) {\n                        win=(NakReceiverWindow)received_msgs.get(sender);\n                        win.reset();\n                        if(log.isDebugEnabled()) {\n                            log.debug(\"removing \" + sender + \" from received_msgs (not member anymore)\");\n                        }\n                        it.remove();\n                    }\n                }\n            }\n\n            // 2. Add newly joined members to received_msgs (starting seqno=0)\n            for(Address sender: members) {\n                if(!received_msgs.containsKey(sender)) {\n                    win=createNakReceiverWindow(sender, 0);\n                    received_msgs.put(sender, win);\n                }\n            }\n        }\n    }","id":6677,"modified_method":"/**\n     * Remove old members from NakReceiverWindows and add new members (starting seqno=0). Essentially removes all\n     * entries from received_msgs that are not in <code>members<\/code>. This method is not called concurrently\n     * multiple times\n     */\n    private void adjustReceivers(boolean remove) {\n        NakReceiverWindow win;\n\n        if(remove) {\n            // 1. Remove all senders in received_msgs that are not members anymore\n            for(Iterator it=received_msgs.keySet().iterator(); it.hasNext();) {\n                Address sender=(Address)it.next();\n                if(!members.contains(sender)) {\n                    win=received_msgs.get(sender);\n                    win.reset();\n                    if(log.isDebugEnabled()) {\n                        log.debug(\"removing \" + sender + \" from received_msgs (not member anymore)\");\n                    }\n                    it.remove();\n                }\n            }\n        }\n\n        // 2. Add newly joined members to received_msgs (starting seqno=0)\n        for(Address sender: members) {\n            if(!received_msgs.containsKey(sender)) {\n                win=createNakReceiverWindow(sender, 0);\n                received_msgs.put(sender, win);\n            }\n        }\n    }","commit_id":"4f2ea4c5ce4a23b986f96d2832f9c14ff7fdd656","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Retransmit from sent-table, called when XMIT_REQ is received. Bundles all messages to be xmitted into one large\n     * message and sends them back with an XMIT_RSP header. Note that since we cannot count on a fragmentation layer\n     * below us, we have to make sure the message doesn't exceed max_xmit_size bytes. If this is the case, we split the\n     * message into multiple, smaller-chunked messages. But in most cases this still yields fewer messages than if each\n     * requested message was retransmitted separately.\n     *\n     * @param xmit_requester        The sender of the XMIT_REQ, we have to send the requested copy of the message to this address\n     * @param first_seqno The first sequence number to be retransmitted (<= last_seqno)\n     * @param last_seqno  The last sequence number to be retransmitted (>= first_seqno)\n     * @param original_sender The member who originally sent the messsage. Guaranteed to be non-null\n     */\n    private void handleXmitReq(Address xmit_requester, long first_seqno, long last_seqno, Address original_sender) {\n        Message m, tmp;\n        LinkedList list;\n        long size=0, marker=first_seqno, len;\n        NakReceiverWindow win=null;\n        boolean      amISender; // am I the original sender ?\n\n        if(trace) {\n            StringBuilder sb=new StringBuilder();\n            sb.append(local_addr).append(\": received xmit request from \").append(xmit_requester).append(\" for \");\n            sb.append(original_sender).append(\" [\").append(first_seqno).append(\" - \").append(last_seqno).append(\"]\");\n            log.trace(sb.toString());\n        }\n\n        if(first_seqno > last_seqno) {\n            if(log.isErrorEnabled())\n                log.error(\"first_seqno (\" + first_seqno + \") > last_seqno (\" + last_seqno + \"): not able to retransmit\");\n            return;\n        }\n\n        if(stats) {\n            xmit_reqs_received+=last_seqno - first_seqno +1;\n            updateStats(received, xmit_requester, 1, 0, 0);\n        }\n\n        amISender=local_addr.equals(original_sender);\n        if(!amISender)\n            win=(NakReceiverWindow)received_msgs.get(original_sender);\n\n        list=new LinkedList();\n        for(long i=first_seqno; i <= last_seqno; i++) {\n            if(amISender) {\n                m=(Message)sent_msgs.get(new Long(i)); // no need to synchronize\n            }\n            else {\n                m=win != null? win.get(i) : null;\n            }\n            if(m == null) {\n                if(log.isErrorEnabled()) {\n                    StringBuffer sb=new StringBuffer();\n                    sb.append(\"(requester=\").append(xmit_requester).append(\", local_addr=\").append(this.local_addr);\n                    sb.append(\") message \").append(original_sender).append(\"::\").append(i);\n                    sb.append(\" not found in \").append((amISender? \"sent\" : \"received\")).append(\" msgs \");\n                    if(win != null) {\n                        sb.append(\"from \").append(original_sender).append(\": \").append(win.toString());\n                    }\n                    else {\n                        sb.append(printSentMsgs());\n                    }\n                    log.error(sb);\n                }\n                continue;\n            }\n            len=m.size();\n            size+=len;\n            if(size > max_xmit_size && !list.isEmpty()) { // changed from >= to > (yaron-r, bug #943709)\n                // yaronr: added &&listSize()>0 since protocols between FRAG and NAKACK add headers, and message exceeds size.\n\n                // size has reached max_xmit_size. go ahead and send message (excluding the current message)\n                if(trace)\n                    log.trace(\"xmitting msgs [\" + marker + '-' + (i - 1) + \"] to \" + xmit_requester);\n                sendXmitRsp(xmit_requester, (LinkedList)list.clone(), marker, i - 1);\n                marker=i;\n                list.clear();\n                // fixed Dec 15 2003 (bela, patch from Joel Dice (dicej)), see explanantion under\n                // bug report #854887\n                size=len;\n            }\n            tmp=m;\n            // tmp.setDest(xmit_requester);\n            // tmp.setSrc(local_addr);\n            if(tmp.getSrc() == null)\n                tmp.setSrc(local_addr);\n            list.add(tmp);\n        }\n\n        if(!list.isEmpty()) {\n            if(trace)\n                log.trace(\"xmitting msgs [\" + marker + '-' + last_seqno + \"] to \" + xmit_requester);\n            sendXmitRsp(xmit_requester, (LinkedList)list.clone(), marker, last_seqno);\n            list.clear();\n        }\n    }","id":6678,"modified_method":"/**\n     * Retransmit from sent-table, called when XMIT_REQ is received. Bundles all messages to be xmitted into one large\n     * message and sends them back with an XMIT_RSP header. Note that since we cannot count on a fragmentation layer\n     * below us, we have to make sure the message doesn't exceed max_xmit_size bytes. If this is the case, we split the\n     * message into multiple, smaller-chunked messages. But in most cases this still yields fewer messages than if each\n     * requested message was retransmitted separately.\n     *\n     * @param xmit_requester        The sender of the XMIT_REQ, we have to send the requested copy of the message to this address\n     * @param first_seqno The first sequence number to be retransmitted (<= last_seqno)\n     * @param last_seqno  The last sequence number to be retransmitted (>= first_seqno)\n     * @param original_sender The member who originally sent the messsage. Guaranteed to be non-null\n     */\n    private void handleXmitReq(Address xmit_requester, long first_seqno, long last_seqno, Address original_sender) {\n        Message m, tmp;\n        LinkedList list;\n        long size=0, marker=first_seqno, len;\n        NakReceiverWindow win=null;\n        boolean      amISender; // am I the original sender ?\n\n        if(trace) {\n            StringBuilder sb=new StringBuilder();\n            sb.append(local_addr).append(\": received xmit request from \").append(xmit_requester).append(\" for \");\n            sb.append(original_sender).append(\" [\").append(first_seqno).append(\" - \").append(last_seqno).append(\"]\");\n            log.trace(sb.toString());\n        }\n\n        if(first_seqno > last_seqno) {\n            if(log.isErrorEnabled())\n                log.error(\"first_seqno (\" + first_seqno + \") > last_seqno (\" + last_seqno + \"): not able to retransmit\");\n            return;\n        }\n\n        if(stats) {\n            xmit_reqs_received+=last_seqno - first_seqno +1;\n            updateStats(received, xmit_requester, 1, 0, 0);\n        }\n\n        amISender=local_addr.equals(original_sender);\n        if(!amISender)\n            win=received_msgs.get(original_sender);\n\n        list=new LinkedList();\n        for(long i=first_seqno; i <= last_seqno; i++) {\n            if(amISender) {\n                m=(Message)sent_msgs.get(new Long(i)); // no need to synchronize\n            }\n            else {\n                m=win != null? win.get(i) : null;\n            }\n            if(m == null) {\n                if(log.isErrorEnabled()) {\n                    StringBuffer sb=new StringBuffer();\n                    sb.append(\"(requester=\").append(xmit_requester).append(\", local_addr=\").append(this.local_addr);\n                    sb.append(\") message \").append(original_sender).append(\"::\").append(i);\n                    sb.append(\" not found in \").append((amISender? \"sent\" : \"received\")).append(\" msgs \");\n                    if(win != null) {\n                        sb.append(\"from \").append(original_sender).append(\": \").append(win.toString());\n                    }\n                    else {\n                        sb.append(printSentMsgs());\n                    }\n                    log.error(sb);\n                }\n                continue;\n            }\n            len=m.size();\n            size+=len;\n            if(size > max_xmit_size && !list.isEmpty()) { // changed from >= to > (yaron-r, bug #943709)\n                // yaronr: added &&listSize()>0 since protocols between FRAG and NAKACK add headers, and message exceeds size.\n\n                // size has reached max_xmit_size. go ahead and send message (excluding the current message)\n                if(trace)\n                    log.trace(\"xmitting msgs [\" + marker + '-' + (i - 1) + \"] to \" + xmit_requester);\n                sendXmitRsp(xmit_requester, (LinkedList)list.clone(), marker, i - 1);\n                marker=i;\n                list.clear();\n                // fixed Dec 15 2003 (bela, patch from Joel Dice (dicej)), see explanantion under\n                // bug report #854887\n                size=len;\n            }\n            tmp=m;\n            // tmp.setDest(xmit_requester);\n            // tmp.setSrc(local_addr);\n            if(tmp.getSrc() == null)\n                tmp.setSrc(local_addr);\n            list.add(tmp);\n        }\n\n        if(!list.isEmpty()) {\n            if(trace)\n                log.trace(\"xmitting msgs [\" + marker + '-' + last_seqno + \"] to \" + xmit_requester);\n            sendXmitRsp(xmit_requester, (LinkedList)list.clone(), marker, last_seqno);\n            list.clear();\n        }\n    }","commit_id":"4f2ea4c5ce4a23b986f96d2832f9c14ff7fdd656","url":"https://github.com/belaban/JGroups"},{"original_method":"private void reset() {\n        NakReceiverWindow win;\n\n        synchronized(sent_msgs) {\n            sent_msgs.clear();\n            seqno=-1;\n        }\n\n        synchronized(received_msgs) {\n            for(Iterator it=received_msgs.values().iterator(); it.hasNext();) {\n                win=(NakReceiverWindow)it.next();\n                win.destroy();\n            }\n            received_msgs.clear();\n        }\n    }","id":6679,"modified_method":"private void reset() {\n        NakReceiverWindow win;\n\n        synchronized(sent_msgs) {\n            sent_msgs.clear();\n            seqno=-1;\n        }\n\n        for(Iterator it=received_msgs.values().iterator(); it.hasNext();) {\n            win=(NakReceiverWindow)it.next();\n            win.destroy();\n        }\n        received_msgs.clear();\n    }","commit_id":"4f2ea4c5ce4a23b986f96d2832f9c14ff7fdd656","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Finds the corresponding NakReceiverWindow and adds the message to it (according to seqno). Then removes as many\n     * messages as possible from the NRW and passes them up the stack. Discards messages from non-members.\n     */\n    private void handleMessage(Message msg, NakAckHeader hdr) {\n        NakReceiverWindow win;\n        Message msg_to_deliver;\n        Address sender=msg.getSrc();\n\n        if(sender == null) {\n            if(log.isErrorEnabled())\n                log.error(\"sender of message is null\");\n            return;\n        }\n\n        if(trace) {\n            StringBuilder sb=new StringBuilder('[');\n            sb.append(local_addr).append(\": received \").append(sender).append('#').append(hdr.seqno);\n            log.trace(sb.toString());\n        }\n\n        // msg is potentially re-sent later as result of XMIT_REQ reception; that's why hdr is added !\n\n        // Changed by bela Jan 29 2003: we currently don't resend from received msgs, just from sent_msgs !\n        // msg.putHeader(getName(), hdr);\n\n        synchronized(received_msgs) {\n            win=(NakReceiverWindow)received_msgs.get(sender);\n        }\n        if(win == null) {  // discard message if there is no entry for sender\n            if(leaving)\n                return;\n            if(warn) {\n                StringBuffer sb=new StringBuffer('[');\n                sb.append(local_addr).append(\"] discarded message from non-member \")\n                        .append(sender).append(\", my view is \" ).append(this.view);\n                log.warn(sb);\n            }\n            return;\n        }\n\n        boolean added=win.add(hdr.seqno, msg);  // add in order, then remove and pass up as many msgs as possible\n        // message is passed up if OOB. Later, when remove() is called, we discard it. This affects ordering !\n        // http://jira.jboss.com/jira/browse/JGRP-379\n        if(msg.isFlagSet(Message.OOB) && added) {\n            up_prot.up(new Event(Event.MSG, msg));\n        }\n\n        // Prevents concurrent passing up of messages by different threads (http://jira.jboss.com/jira/browse/JGRP-198);\n        // this is all the more important once we have a threadless stack (http://jira.jboss.com/jira/browse/JGRP-181),\n        // where lots of threads can come up to this point concurrently, but only 1 is allowed to pass at a time\n        // We *can* deliver messages from *different* senders concurrently, e.g. reception of P1, Q1, P2, Q2 can result in\n        // delivery of P1, Q1, Q2, P2: FIFO (implemented by NAKACK) says messages need to be delivered in the\n        // order in which they were sent by the sender\n        synchronized(win) {\n            while((msg_to_deliver=win.remove()) != null) {\n\n                // discard OOB msg as it has already been delivered (http://jira.jboss.com/jira/browse/JGRP-379)\n                if(msg_to_deliver.isFlagSet(Message.OOB)) {\n                    continue;\n                }\n\n                // Changed by bela Jan 29 2003: not needed (see above)\n                //msg_to_deliver.removeHeader(getName());\n                up_prot.up(new Event(Event.MSG, msg_to_deliver));\n            }\n        }\n    }","id":6680,"modified_method":"/**\n     * Finds the corresponding NakReceiverWindow and adds the message to it (according to seqno). Then removes as many\n     * messages as possible from the NRW and passes them up the stack. Discards messages from non-members.\n     */\n    private void handleMessage(Message msg, NakAckHeader hdr) {\n        NakReceiverWindow win;\n        Message msg_to_deliver;\n        Address sender=msg.getSrc();\n\n        if(sender == null) {\n            if(log.isErrorEnabled())\n                log.error(\"sender of message is null\");\n            return;\n        }\n\n        if(trace) {\n            StringBuilder sb=new StringBuilder('[');\n            sb.append(local_addr).append(\": received \").append(sender).append('#').append(hdr.seqno);\n            log.trace(sb.toString());\n        }\n\n        // msg is potentially re-sent later as result of XMIT_REQ reception; that's why hdr is added !\n\n        // Changed by bela Jan 29 2003: we currently don't resend from received msgs, just from sent_msgs !\n        // msg.putHeader(getName(), hdr);\n\n        win=received_msgs.get(sender);\n        if(win == null) {  // discard message if there is no entry for sender\n            if(leaving)\n                return;\n            if(warn) {\n                StringBuffer sb=new StringBuffer('[');\n                sb.append(local_addr).append(\"] discarded message from non-member \")\n                        .append(sender).append(\", my view is \" ).append(this.view);\n                log.warn(sb);\n            }\n            return;\n        }\n\n        boolean added=win.add(hdr.seqno, msg);  // add in order, then remove and pass up as many msgs as possible\n        // message is passed up if OOB. Later, when remove() is called, we discard it. This affects ordering !\n        // http://jira.jboss.com/jira/browse/JGRP-379\n        if(msg.isFlagSet(Message.OOB) && added) {\n            up_prot.up(new Event(Event.MSG, msg));\n        }\n\n        // Prevents concurrent passing up of messages by different threads (http://jira.jboss.com/jira/browse/JGRP-198);\n        // this is all the more important once we have a threadless stack (http://jira.jboss.com/jira/browse/JGRP-181),\n        // where lots of threads can come up to this point concurrently, but only 1 is allowed to pass at a time\n        // We *can* deliver messages from *different* senders concurrently, e.g. reception of P1, Q1, P2, Q2 can result in\n        // delivery of P1, Q1, Q2, P2: FIFO (implemented by NAKACK) says messages need to be delivered in the\n        // order in which they were sent by the sender\n        synchronized(win) {\n            while((msg_to_deliver=win.remove()) != null) {\n\n                // discard OOB msg as it has already been delivered (http://jira.jboss.com/jira/browse/JGRP-379)\n                if(msg_to_deliver.isFlagSet(Message.OOB)) {\n                    continue;\n                }\n\n                // Changed by bela Jan 29 2003: not needed (see above)\n                //msg_to_deliver.removeHeader(getName());\n                up_prot.up(new Event(Event.MSG, msg_to_deliver));\n            }\n        }\n    }","commit_id":"4f2ea4c5ce4a23b986f96d2832f9c14ff7fdd656","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Garbage collect messages that have been seen by all members. Update sent_msgs: for the sender P in the digest\n     * which is equal to the local address, garbage collect all messages <= seqno at digest[P]. Update received_msgs:\n     * for each sender P in the digest and its highest seqno seen SEQ, garbage collect all delivered_msgs in the\n     * NakReceiverWindow corresponding to P which are <= seqno at digest[P].\n     */\n    private void stable(Digest d) {\n        NakReceiverWindow recv_win;\n        long my_highest_rcvd;        // highest seqno received in my digest for a sender P\n        long stability_highest_rcvd; // highest seqno received in the stability vector for a sender P\n\n        if(members == null || local_addr == null || d == null) {\n            if(warn)\n                log.warn(\"members, local_addr or digest are null !\");\n            return;\n        }\n\n        if(trace) {\n            log.trace(\"received stable digest \" + d);\n        }\n\n        Map.Entry entry;\n        Address sender;\n        org.jgroups.protocols.pbcast.Digest.Entry val;\n        long high_seqno_delivered, high_seqno_received;\n\n        for(Iterator it=d.getSenders().entrySet().iterator(); it.hasNext();) {\n            entry=(Map.Entry)it.next();\n            sender=(Address)entry.getKey();\n            if(sender == null)\n                continue;\n            val=(org.jgroups.protocols.pbcast.Digest.Entry)entry.getValue();\n            high_seqno_delivered=val.getHigh();\n            high_seqno_received=val.getHighSeen();\n\n\n            // check whether the last seqno received for a sender P in the stability vector is > last seqno\n            // received for P in my digest. if yes, request retransmission (see \"Last Message Dropped\" topic\n            // in DESIGN)\n            synchronized(received_msgs) {\n                recv_win=(NakReceiverWindow)received_msgs.get(sender);\n            }\n            if(recv_win != null) {\n                my_highest_rcvd=recv_win.getHighestReceived();\n                stability_highest_rcvd=high_seqno_received;\n\n                if(stability_highest_rcvd >= 0 && stability_highest_rcvd > my_highest_rcvd) {\n                    if(trace) {\n                        log.trace(\"my_highest_rcvd (\" + my_highest_rcvd + \") < stability_highest_rcvd (\" +\n                                stability_highest_rcvd + \"): requesting retransmission of \" +\n                                sender + '#' + stability_highest_rcvd);\n                    }\n                    retransmit(stability_highest_rcvd, stability_highest_rcvd, sender);\n                }\n            }\n\n            high_seqno_delivered-=gc_lag;\n            if(high_seqno_delivered < 0) {\n                continue;\n            }\n\n            if(trace)\n                log.trace(\"deleting msgs <= \" + high_seqno_delivered + \" from \" + sender);\n\n            // garbage collect from sent_msgs if sender was myself\n            if(sender.equals(local_addr)) {\n                synchronized(sent_msgs) {\n                    // gets us a subset from [lowest seqno - seqno]\n                    SortedMap stable_keys=sent_msgs.headMap(new Long(high_seqno_delivered));\n                    if(stable_keys != null) {\n                        stable_keys.clear(); // this will modify sent_msgs directly\n                    }\n                }\n            }\n\n            // delete *delivered* msgs that are stable\n            // recv_win=(NakReceiverWindow)received_msgs.get(sender);\n            if(recv_win != null)\n                recv_win.stable(high_seqno_delivered);  // delete all messages with seqnos <= seqno\n        }\n    }","id":6681,"modified_method":"/**\n     * Garbage collect messages that have been seen by all members. Update sent_msgs: for the sender P in the digest\n     * which is equal to the local address, garbage collect all messages <= seqno at digest[P]. Update received_msgs:\n     * for each sender P in the digest and its highest seqno seen SEQ, garbage collect all delivered_msgs in the\n     * NakReceiverWindow corresponding to P which are <= seqno at digest[P].\n     */\n    private void stable(Digest d) {\n        NakReceiverWindow recv_win;\n        long my_highest_rcvd;        // highest seqno received in my digest for a sender P\n        long stability_highest_rcvd; // highest seqno received in the stability vector for a sender P\n\n        if(members == null || local_addr == null || d == null) {\n            if(warn)\n                log.warn(\"members, local_addr or digest are null !\");\n            return;\n        }\n\n        if(trace) {\n            log.trace(\"received stable digest \" + d);\n        }\n\n        Map.Entry entry;\n        Address sender;\n        org.jgroups.protocols.pbcast.Digest.Entry val;\n        long high_seqno_delivered, high_seqno_received;\n\n        for(Iterator it=d.getSenders().entrySet().iterator(); it.hasNext();) {\n            entry=(Map.Entry)it.next();\n            sender=(Address)entry.getKey();\n            if(sender == null)\n                continue;\n            val=(org.jgroups.protocols.pbcast.Digest.Entry)entry.getValue();\n            high_seqno_delivered=val.getHigh();\n            high_seqno_received=val.getHighSeen();\n\n\n            // check whether the last seqno received for a sender P in the stability vector is > last seqno\n            // received for P in my digest. if yes, request retransmission (see \"Last Message Dropped\" topic\n            // in DESIGN)\n            recv_win=received_msgs.get(sender);\n            if(recv_win != null) {\n                my_highest_rcvd=recv_win.getHighestReceived();\n                stability_highest_rcvd=high_seqno_received;\n\n                if(stability_highest_rcvd >= 0 && stability_highest_rcvd > my_highest_rcvd) {\n                    if(trace) {\n                        log.trace(\"my_highest_rcvd (\" + my_highest_rcvd + \") < stability_highest_rcvd (\" +\n                                stability_highest_rcvd + \"): requesting retransmission of \" +\n                                sender + '#' + stability_highest_rcvd);\n                    }\n                    retransmit(stability_highest_rcvd, stability_highest_rcvd, sender);\n                }\n            }\n\n            high_seqno_delivered-=gc_lag;\n            if(high_seqno_delivered < 0) {\n                continue;\n            }\n\n            if(trace)\n                log.trace(\"deleting msgs <= \" + high_seqno_delivered + \" from \" + sender);\n\n            // garbage collect from sent_msgs if sender was myself\n            if(sender.equals(local_addr)) {\n                synchronized(sent_msgs) {\n                    // gets us a subset from [lowest seqno - seqno]\n                    SortedMap stable_keys=sent_msgs.headMap(new Long(high_seqno_delivered));\n                    if(stable_keys != null) {\n                        stable_keys.clear(); // this will modify sent_msgs directly\n                    }\n                }\n            }\n\n            // delete *delivered* msgs that are stable\n            // recv_win=(NakReceiverWindow)received_msgs.get(sender);\n            if(recv_win != null)\n                recv_win.stable(high_seqno_delivered);  // delete all messages with seqnos <= seqno\n        }\n    }","commit_id":"3acd27e6ac547a705cdee872b120e1333d6b2a29","url":"https://github.com/belaban/JGroups"},{"original_method":"private void reset() {\n        NakReceiverWindow win;\n\n        synchronized(sent_msgs) {\n            sent_msgs.clear();\n            seqno=-1;\n        }\n\n        synchronized(received_msgs) {\n            for(Iterator it=received_msgs.values().iterator(); it.hasNext();) {\n                win=(NakReceiverWindow)it.next();\n                win.destroy();\n            }\n            received_msgs.clear();\n        }\n    }","id":6682,"modified_method":"private void reset() {\n        NakReceiverWindow win;\n\n        synchronized(sent_msgs) {\n            sent_msgs.clear();\n            seqno=-1;\n        }\n\n        for(Iterator it=received_msgs.values().iterator(); it.hasNext();) {\n            win=(NakReceiverWindow)it.next();\n            win.destroy();\n        }\n        received_msgs.clear();\n    }","commit_id":"3acd27e6ac547a705cdee872b120e1333d6b2a29","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Remove old members from NakReceiverWindows and add new members (starting seqno=0). Essentially removes all\n     * entries from received_msgs that are not in <code>members<\/code>\n     */\n    private void adjustReceivers(boolean remove) {\n        NakReceiverWindow win;\n\n        synchronized(received_msgs) {\n            if(remove) {\n                // 1. Remove all senders in received_msgs that are not members anymore\n                for(Iterator it=received_msgs.keySet().iterator(); it.hasNext();) {\n                    Address sender=(Address)it.next();\n                    if(!members.contains(sender)) {\n                        win=(NakReceiverWindow)received_msgs.get(sender);\n                        win.reset();\n                        if(log.isDebugEnabled()) {\n                            log.debug(\"removing \" + sender + \" from received_msgs (not member anymore)\");\n                        }\n                        it.remove();\n                    }\n                }\n            }\n\n            // 2. Add newly joined members to received_msgs (starting seqno=0)\n            for(Address sender: members) {\n                if(!received_msgs.containsKey(sender)) {\n                    win=createNakReceiverWindow(sender, 0);\n                    received_msgs.put(sender, win);\n                }\n            }\n        }\n    }","id":6683,"modified_method":"/**\n     * Remove old members from NakReceiverWindows and add new members (starting seqno=0). Essentially removes all\n     * entries from received_msgs that are not in <code>members<\/code>. This method is not called concurrently\n     * multiple times\n     */\n    private void adjustReceivers(boolean remove) {\n        NakReceiverWindow win;\n\n        if(remove) {\n            // 1. Remove all senders in received_msgs that are not members anymore\n            for(Iterator it=received_msgs.keySet().iterator(); it.hasNext();) {\n                Address sender=(Address)it.next();\n                if(!members.contains(sender)) {\n                    win=received_msgs.get(sender);\n                    win.reset();\n                    if(log.isDebugEnabled()) {\n                        log.debug(\"removing \" + sender + \" from received_msgs (not member anymore)\");\n                    }\n                    it.remove();\n                }\n            }\n        }\n\n        // 2. Add newly joined members to received_msgs (starting seqno=0)\n        for(Address sender: members) {\n            if(!received_msgs.containsKey(sender)) {\n                win=createNakReceiverWindow(sender, 0);\n                received_msgs.put(sender, win);\n            }\n        }\n    }","commit_id":"3acd27e6ac547a705cdee872b120e1333d6b2a29","url":"https://github.com/belaban/JGroups"},{"original_method":"private void clear() {\n        NakReceiverWindow win;\n\n        // changed April 21 2004 (bela): SourceForge bug# 938584. We cannot delete our own messages sent between\n        // a join() and a getState(). Otherwise retransmission requests from members who missed those msgs might\n        // fail. Not to worry though: those msgs will be cleared by STABLE (message garbage collection)\n\n        // sent_msgs.clear();\n\n        synchronized(received_msgs) {\n            for(Iterator it=received_msgs.values().iterator(); it.hasNext();) {\n                win=(NakReceiverWindow)it.next();\n                win.reset();\n            }\n            received_msgs.clear();\n        }\n    }","id":6684,"modified_method":"private void clear() {\n        NakReceiverWindow win;\n\n        // changed April 21 2004 (bela): SourceForge bug# 938584. We cannot delete our own messages sent between\n        // a join() and a getState(). Otherwise retransmission requests from members who missed those msgs might\n        // fail. Not to worry though: those msgs will be cleared by STABLE (message garbage collection)\n\n        // sent_msgs.clear();\n\n        for(Iterator it=received_msgs.values().iterator(); it.hasNext();) {\n            win=(NakReceiverWindow)it.next();\n            win.reset();\n        }\n        received_msgs.clear();\n    }","commit_id":"3acd27e6ac547a705cdee872b120e1333d6b2a29","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Finds the corresponding NakReceiverWindow and adds the message to it (according to seqno). Then removes as many\n     * messages as possible from the NRW and passes them up the stack. Discards messages from non-members.\n     */\n    private void handleMessage(Message msg, NakAckHeader hdr) {\n        NakReceiverWindow win;\n        Message msg_to_deliver;\n        Address sender=msg.getSrc();\n\n        if(sender == null) {\n            if(log.isErrorEnabled())\n                log.error(\"sender of message is null\");\n            return;\n        }\n\n        if(trace) {\n            StringBuilder sb=new StringBuilder('[');\n            sb.append(local_addr).append(\": received \").append(sender).append('#').append(hdr.seqno);\n            log.trace(sb.toString());\n        }\n\n        // msg is potentially re-sent later as result of XMIT_REQ reception; that's why hdr is added !\n\n        // Changed by bela Jan 29 2003: we currently don't resend from received msgs, just from sent_msgs !\n        // msg.putHeader(getName(), hdr);\n\n        synchronized(received_msgs) {\n            win=(NakReceiverWindow)received_msgs.get(sender);\n        }\n        if(win == null) {  // discard message if there is no entry for sender\n            if(leaving)\n                return;\n            if(warn) {\n                StringBuffer sb=new StringBuffer('[');\n                sb.append(local_addr).append(\"] discarded message from non-member \")\n                        .append(sender).append(\", my view is \" ).append(this.view);\n                log.warn(sb);\n            }\n            return;\n        }\n\n        boolean added=win.add(hdr.seqno, msg);  // add in order, then remove and pass up as many msgs as possible\n        // message is passed up if OOB. Later, when remove() is called, we discard it. This affects ordering !\n        // http://jira.jboss.com/jira/browse/JGRP-379\n        if(msg.isFlagSet(Message.OOB) && added) {\n            up_prot.up(new Event(Event.MSG, msg));\n        }\n\n        // Prevents concurrent passing up of messages by different threads (http://jira.jboss.com/jira/browse/JGRP-198);\n        // this is all the more important once we have a threadless stack (http://jira.jboss.com/jira/browse/JGRP-181),\n        // where lots of threads can come up to this point concurrently, but only 1 is allowed to pass at a time\n        // We *can* deliver messages from *different* senders concurrently, e.g. reception of P1, Q1, P2, Q2 can result in\n        // delivery of P1, Q1, Q2, P2: FIFO (implemented by NAKACK) says messages need to be delivered in the\n        // order in which they were sent by the sender\n        synchronized(win) {\n            while((msg_to_deliver=win.remove()) != null) {\n\n                // discard OOB msg as it has already been delivered (http://jira.jboss.com/jira/browse/JGRP-379)\n                if(msg_to_deliver.isFlagSet(Message.OOB)) {\n                    continue;\n                }\n\n                // Changed by bela Jan 29 2003: not needed (see above)\n                //msg_to_deliver.removeHeader(getName());\n                up_prot.up(new Event(Event.MSG, msg_to_deliver));\n            }\n        }\n    }","id":6685,"modified_method":"/**\n     * Finds the corresponding NakReceiverWindow and adds the message to it (according to seqno). Then removes as many\n     * messages as possible from the NRW and passes them up the stack. Discards messages from non-members.\n     */\n    private void handleMessage(Message msg, NakAckHeader hdr) {\n        NakReceiverWindow win;\n        Message msg_to_deliver;\n        Address sender=msg.getSrc();\n\n        if(sender == null) {\n            if(log.isErrorEnabled())\n                log.error(\"sender of message is null\");\n            return;\n        }\n\n        if(trace) {\n            StringBuilder sb=new StringBuilder('[');\n            sb.append(local_addr).append(\": received \").append(sender).append('#').append(hdr.seqno);\n            log.trace(sb.toString());\n        }\n\n        // msg is potentially re-sent later as result of XMIT_REQ reception; that's why hdr is added !\n\n        // Changed by bela Jan 29 2003: we currently don't resend from received msgs, just from sent_msgs !\n        // msg.putHeader(getName(), hdr);\n\n        win=received_msgs.get(sender);\n        if(win == null) {  // discard message if there is no entry for sender\n            if(leaving)\n                return;\n            if(warn) {\n                StringBuffer sb=new StringBuffer('[');\n                sb.append(local_addr).append(\"] discarded message from non-member \")\n                        .append(sender).append(\", my view is \" ).append(this.view);\n                log.warn(sb);\n            }\n            return;\n        }\n\n        boolean added=win.add(hdr.seqno, msg);  // add in order, then remove and pass up as many msgs as possible\n        // message is passed up if OOB. Later, when remove() is called, we discard it. This affects ordering !\n        // http://jira.jboss.com/jira/browse/JGRP-379\n        if(msg.isFlagSet(Message.OOB) && added) {\n            up_prot.up(new Event(Event.MSG, msg));\n        }\n\n        // Prevents concurrent passing up of messages by different threads (http://jira.jboss.com/jira/browse/JGRP-198);\n        // this is all the more important once we have a threadless stack (http://jira.jboss.com/jira/browse/JGRP-181),\n        // where lots of threads can come up to this point concurrently, but only 1 is allowed to pass at a time\n        // We *can* deliver messages from *different* senders concurrently, e.g. reception of P1, Q1, P2, Q2 can result in\n        // delivery of P1, Q1, Q2, P2: FIFO (implemented by NAKACK) says messages need to be delivered in the\n        // order in which they were sent by the sender\n        synchronized(win) {\n            while((msg_to_deliver=win.remove()) != null) {\n\n                // discard OOB msg as it has already been delivered (http://jira.jboss.com/jira/browse/JGRP-379)\n                if(msg_to_deliver.isFlagSet(Message.OOB)) {\n                    continue;\n                }\n\n                // Changed by bela Jan 29 2003: not needed (see above)\n                //msg_to_deliver.removeHeader(getName());\n                up_prot.up(new Event(Event.MSG, msg_to_deliver));\n            }\n        }\n    }","commit_id":"3acd27e6ac547a705cdee872b120e1333d6b2a29","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns the lowest seqno still in cache (so it can be retransmitted) and the highest seqno received so far.\n     *\n     * @param sender       The address for which the highest and lowest seqnos are to be retrieved\n     * @param stop_at_gaps If true, the highest seqno *deliverable* will be returned. If false, the highest seqno\n     *                     *received* will be returned. E.g. for [+3 +4 +5 -6 +7 +8], the highest_seqno_received is 8,\n     *                     whereas the higheset_seqno_seen (deliverable) is 5.\n     */\n    private Range getLowestAndHighestSeqno(Address sender, boolean stop_at_gaps) {\n        Range r=null;\n        NakReceiverWindow win;\n\n        if(sender == null) {\n            if(log.isErrorEnabled()) {\n                log.error(\"sender is null\");\n            }\n            return r;\n        }\n        synchronized(received_msgs) {\n            win=(NakReceiverWindow)received_msgs.get(sender);\n        }\n        if(win == null) {\n            if(log.isErrorEnabled()) {\n                log.error(\"sender \" + sender + \" not found in received_msgs\");\n            }\n            return r;\n        }\n        if(stop_at_gaps) {\n            r=new Range(win.getLowestSeen(), win.getHighestSeen());       // deliverable messages (no gaps)\n        }\n        else {\n            r=new Range(win.getLowestSeen(), win.getHighestReceived() + 1); // received messages\n        }\n        return r;\n    }","id":6686,"modified_method":"/**\n     * Returns the lowest seqno still in cache (so it can be retransmitted) and the highest seqno received so far.\n     *\n     * @param sender       The address for which the highest and lowest seqnos are to be retrieved\n     * @param stop_at_gaps If true, the highest seqno *deliverable* will be returned. If false, the highest seqno\n     *                     *received* will be returned. E.g. for [+3 +4 +5 -6 +7 +8], the highest_seqno_received is 8,\n     *                     whereas the higheset_seqno_seen (deliverable) is 5.\n     */\n    private Range getLowestAndHighestSeqno(Address sender, boolean stop_at_gaps) {\n        Range r=null;\n        NakReceiverWindow win;\n\n        if(sender == null) {\n            if(log.isErrorEnabled()) {\n                log.error(\"sender is null\");\n            }\n            return r;\n        }\n        win=received_msgs.get(sender);\n        if(win == null) {\n            if(log.isErrorEnabled()) {\n                log.error(\"sender \" + sender + \" not found in received_msgs\");\n            }\n            return r;\n        }\n        if(stop_at_gaps) {\n            r=new Range(win.getLowestSeen(), win.getHighestSeen());       // deliverable messages (no gaps)\n        }\n        else {\n            r=new Range(win.getLowestSeen(), win.getHighestReceived() + 1); // received messages\n        }\n        return r;\n    }","commit_id":"3acd27e6ac547a705cdee872b120e1333d6b2a29","url":"https://github.com/belaban/JGroups"},{"original_method":"public Map dumpStats() {\n        Map retval=super.dumpStats();\n        if(retval == null)\n            retval=new HashMap();\n\n        retval.put(\"xmit_reqs_received\", new Long(xmit_reqs_received));\n        retval.put(\"xmit_reqs_sent\", new Long(xmit_reqs_sent));\n        retval.put(\"xmit_rsps_received\", new Long(xmit_rsps_received));\n        retval.put(\"xmit_rsps_sent\", new Long(xmit_rsps_sent));\n        retval.put(\"missing_msgs_received\", new Long(missing_msgs_received));\n\n        retval.put(\"sent_msgs\", printSentMsgs());\n\n        StringBuilder sb=new StringBuilder();\n        Map.Entry entry;\n        Address addr;\n        Object w;\n        synchronized(received_msgs) {\n            for(Iterator it=received_msgs.entrySet().iterator(); it.hasNext();) {\n                entry=(Map.Entry)it.next();\n                addr=(Address)entry.getKey();\n                w=entry.getValue();\n                sb.append(addr).append(\": \").append(w.toString()).append('\\n');\n            }\n        }\n\n        retval.put(\"received_msgs\", sb.toString());\n        return retval;        \n    }","id":6687,"modified_method":"public Map dumpStats() {\n        Map retval=super.dumpStats();\n        if(retval == null)\n            retval=new HashMap();\n\n        retval.put(\"xmit_reqs_received\", new Long(xmit_reqs_received));\n        retval.put(\"xmit_reqs_sent\", new Long(xmit_reqs_sent));\n        retval.put(\"xmit_rsps_received\", new Long(xmit_rsps_received));\n        retval.put(\"xmit_rsps_sent\", new Long(xmit_rsps_sent));\n        retval.put(\"missing_msgs_received\", new Long(missing_msgs_received));\n        retval.put(\"sent_msgs\", printSentMsgs());\n\n        StringBuilder sb=new StringBuilder();\n        Address addr;\n        Object w;\n\n        for(Map.Entry<Address,NakReceiverWindow> entry: received_msgs.entrySet()) {\n            addr=entry.getKey();\n            w=entry.getValue();\n            sb.append(addr).append(\": \").append(w.toString()).append('\\n');\n        }\n\n        retval.put(\"received_msgs\", sb.toString());\n        return retval;        \n    }","commit_id":"3acd27e6ac547a705cdee872b120e1333d6b2a29","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * For all members of the digest, adjust the NakReceiverWindows in the received_msgs hashtable. If the member\n     * already exists, sets its seqno to be the max of the seqno and the seqno of the member in the digest. If no entry\n     * exists, create one with the initial seqno set to the seqno of the member in the digest.\n     */\n    private void mergeDigest(Digest digest) {\n        if(digest == null) {\n            if(log.isErrorEnabled()) {\n                log.error(\"digest or digest.senders is null\");\n            }\n            return;\n        }\n\n        Map.Entry entry;\n        Address sender;\n        org.jgroups.protocols.pbcast.Digest.Entry val;\n        NakReceiverWindow win;\n        long initial_seqno;\n\n        for(Iterator it=digest.getSenders().entrySet().iterator(); it.hasNext();) {\n            entry=(Map.Entry)it.next();\n            sender=(Address)entry.getKey();\n            val=(org.jgroups.protocols.pbcast.Digest.Entry)entry.getValue();\n\n            if(sender == null || val == null) {\n                if(warn) {\n                    log.warn(\"sender or value is null\");\n                }\n                continue;\n            }\n            initial_seqno=val.getHigh();\n            synchronized(received_msgs) {\n                win=(NakReceiverWindow)received_msgs.get(sender);\n                if(win == null) {\n                    win=createNakReceiverWindow(sender, initial_seqno);\n                    received_msgs.put(sender, win);\n                }\n                else {\n                    if(win.getHighestReceived() < initial_seqno) {\n                        win.reset();\n                        received_msgs.remove(sender);\n                        win=createNakReceiverWindow(sender, initial_seqno);\n                        received_msgs.put(sender, win);\n                    }\n                }\n            }\n        }\n    }","id":6688,"modified_method":"/**\n     * For all members of the digest, adjust the NakReceiverWindows in the received_msgs hashtable. If the member\n     * already exists, sets its seqno to be the max of the seqno and the seqno of the member in the digest. If no entry\n     * exists, create one with the initial seqno set to the seqno of the member in the digest.\n     */\n    private void mergeDigest(Digest digest) {\n        if(digest == null) {\n            if(log.isErrorEnabled()) {\n                log.error(\"digest or digest.senders is null\");\n            }\n            return;\n        }\n\n        Map.Entry entry;\n        Address sender;\n        org.jgroups.protocols.pbcast.Digest.Entry val;\n        NakReceiverWindow win;\n        long initial_seqno;\n\n        for(Iterator it=digest.getSenders().entrySet().iterator(); it.hasNext();) {\n            entry=(Map.Entry)it.next();\n            sender=(Address)entry.getKey();\n            val=(org.jgroups.protocols.pbcast.Digest.Entry)entry.getValue();\n\n            if(sender == null || val == null) {\n                if(warn) {\n                    log.warn(\"sender or value is null\");\n                }\n                continue;\n            }\n            initial_seqno=val.getHigh();\n\n            win=received_msgs.get(sender);\n            if(win == null) {\n                win=createNakReceiverWindow(sender, initial_seqno);\n                received_msgs.putIfAbsent(sender, win);\n            }\n            else {\n                if(win.getHighestReceived() < initial_seqno) {\n                    win.reset();\n                    received_msgs.remove(sender);\n                    win=createNakReceiverWindow(sender, initial_seqno);\n                    received_msgs.put(sender, win);\n                }\n            }\n        }\n    }","commit_id":"3acd27e6ac547a705cdee872b120e1333d6b2a29","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Retransmit from sent-table, called when XMIT_REQ is received. Bundles all messages to be xmitted into one large\n     * message and sends them back with an XMIT_RSP header. Note that since we cannot count on a fragmentation layer\n     * below us, we have to make sure the message doesn't exceed max_xmit_size bytes. If this is the case, we split the\n     * message into multiple, smaller-chunked messages. But in most cases this still yields fewer messages than if each\n     * requested message was retransmitted separately.\n     *\n     * @param xmit_requester        The sender of the XMIT_REQ, we have to send the requested copy of the message to this address\n     * @param first_seqno The first sequence number to be retransmitted (<= last_seqno)\n     * @param last_seqno  The last sequence number to be retransmitted (>= first_seqno)\n     * @param original_sender The member who originally sent the messsage. Guaranteed to be non-null\n     */\n    private void handleXmitReq(Address xmit_requester, long first_seqno, long last_seqno, Address original_sender) {\n        Message m, tmp;\n        LinkedList list;\n        long size=0, marker=first_seqno, len;\n        NakReceiverWindow win=null;\n        boolean      amISender; // am I the original sender ?\n\n        if(trace) {\n            StringBuilder sb=new StringBuilder();\n            sb.append(local_addr).append(\": received xmit request from \").append(xmit_requester).append(\" for \");\n            sb.append(original_sender).append(\" [\").append(first_seqno).append(\" - \").append(last_seqno).append(\"]\");\n            log.trace(sb.toString());\n        }\n\n        if(first_seqno > last_seqno) {\n            if(log.isErrorEnabled())\n                log.error(\"first_seqno (\" + first_seqno + \") > last_seqno (\" + last_seqno + \"): not able to retransmit\");\n            return;\n        }\n\n        if(stats) {\n            xmit_reqs_received+=last_seqno - first_seqno +1;\n            updateStats(received, xmit_requester, 1, 0, 0);\n        }\n\n        amISender=local_addr.equals(original_sender);\n        if(!amISender)\n            win=(NakReceiverWindow)received_msgs.get(original_sender);\n\n        list=new LinkedList();\n        for(long i=first_seqno; i <= last_seqno; i++) {\n            if(amISender) {\n                m=(Message)sent_msgs.get(new Long(i)); // no need to synchronize\n            }\n            else {\n                m=win != null? win.get(i) : null;\n            }\n            if(m == null) {\n                if(log.isErrorEnabled()) {\n                    StringBuffer sb=new StringBuffer();\n                    sb.append(\"(requester=\").append(xmit_requester).append(\", local_addr=\").append(this.local_addr);\n                    sb.append(\") message \").append(original_sender).append(\"::\").append(i);\n                    sb.append(\" not found in \").append((amISender? \"sent\" : \"received\")).append(\" msgs \");\n                    if(win != null) {\n                        sb.append(\"from \").append(original_sender).append(\": \").append(win.toString());\n                    }\n                    else {\n                        sb.append(printSentMsgs());\n                    }\n                    log.error(sb);\n                }\n                continue;\n            }\n            len=m.size();\n            size+=len;\n            if(size > max_xmit_size && !list.isEmpty()) { // changed from >= to > (yaron-r, bug #943709)\n                // yaronr: added &&listSize()>0 since protocols between FRAG and NAKACK add headers, and message exceeds size.\n\n                // size has reached max_xmit_size. go ahead and send message (excluding the current message)\n                if(trace)\n                    log.trace(\"xmitting msgs [\" + marker + '-' + (i - 1) + \"] to \" + xmit_requester);\n                sendXmitRsp(xmit_requester, (LinkedList)list.clone(), marker, i - 1);\n                marker=i;\n                list.clear();\n                // fixed Dec 15 2003 (bela, patch from Joel Dice (dicej)), see explanantion under\n                // bug report #854887\n                size=len;\n            }\n            tmp=m;\n            // tmp.setDest(xmit_requester);\n            // tmp.setSrc(local_addr);\n            if(tmp.getSrc() == null)\n                tmp.setSrc(local_addr);\n            list.add(tmp);\n        }\n\n        if(!list.isEmpty()) {\n            if(trace)\n                log.trace(\"xmitting msgs [\" + marker + '-' + last_seqno + \"] to \" + xmit_requester);\n            sendXmitRsp(xmit_requester, (LinkedList)list.clone(), marker, last_seqno);\n            list.clear();\n        }\n    }","id":6689,"modified_method":"/**\n     * Retransmit from sent-table, called when XMIT_REQ is received. Bundles all messages to be xmitted into one large\n     * message and sends them back with an XMIT_RSP header. Note that since we cannot count on a fragmentation layer\n     * below us, we have to make sure the message doesn't exceed max_xmit_size bytes. If this is the case, we split the\n     * message into multiple, smaller-chunked messages. But in most cases this still yields fewer messages than if each\n     * requested message was retransmitted separately.\n     *\n     * @param xmit_requester        The sender of the XMIT_REQ, we have to send the requested copy of the message to this address\n     * @param first_seqno The first sequence number to be retransmitted (<= last_seqno)\n     * @param last_seqno  The last sequence number to be retransmitted (>= first_seqno)\n     * @param original_sender The member who originally sent the messsage. Guaranteed to be non-null\n     */\n    private void handleXmitReq(Address xmit_requester, long first_seqno, long last_seqno, Address original_sender) {\n        Message m, tmp;\n        LinkedList list;\n        long size=0, marker=first_seqno, len;\n        NakReceiverWindow win=null;\n        boolean      amISender; // am I the original sender ?\n\n        if(trace) {\n            StringBuilder sb=new StringBuilder();\n            sb.append(local_addr).append(\": received xmit request from \").append(xmit_requester).append(\" for \");\n            sb.append(original_sender).append(\" [\").append(first_seqno).append(\" - \").append(last_seqno).append(\"]\");\n            log.trace(sb.toString());\n        }\n\n        if(first_seqno > last_seqno) {\n            if(log.isErrorEnabled())\n                log.error(\"first_seqno (\" + first_seqno + \") > last_seqno (\" + last_seqno + \"): not able to retransmit\");\n            return;\n        }\n\n        if(stats) {\n            xmit_reqs_received+=last_seqno - first_seqno +1;\n            updateStats(received, xmit_requester, 1, 0, 0);\n        }\n\n        amISender=local_addr.equals(original_sender);\n        if(!amISender)\n            win=received_msgs.get(original_sender);\n\n        list=new LinkedList();\n        for(long i=first_seqno; i <= last_seqno; i++) {\n            if(amISender) {\n                m=(Message)sent_msgs.get(new Long(i)); // no need to synchronize\n            }\n            else {\n                m=win != null? win.get(i) : null;\n            }\n            if(m == null) {\n                if(log.isErrorEnabled()) {\n                    StringBuffer sb=new StringBuffer();\n                    sb.append(\"(requester=\").append(xmit_requester).append(\", local_addr=\").append(this.local_addr);\n                    sb.append(\") message \").append(original_sender).append(\"::\").append(i);\n                    sb.append(\" not found in \").append((amISender? \"sent\" : \"received\")).append(\" msgs \");\n                    if(win != null) {\n                        sb.append(\"from \").append(original_sender).append(\": \").append(win.toString());\n                    }\n                    else {\n                        sb.append(printSentMsgs());\n                    }\n                    log.error(sb);\n                }\n                continue;\n            }\n            len=m.size();\n            size+=len;\n            if(size > max_xmit_size && !list.isEmpty()) { // changed from >= to > (yaron-r, bug #943709)\n                // yaronr: added &&listSize()>0 since protocols between FRAG and NAKACK add headers, and message exceeds size.\n\n                // size has reached max_xmit_size. go ahead and send message (excluding the current message)\n                if(trace)\n                    log.trace(\"xmitting msgs [\" + marker + '-' + (i - 1) + \"] to \" + xmit_requester);\n                sendXmitRsp(xmit_requester, (LinkedList)list.clone(), marker, i - 1);\n                marker=i;\n                list.clear();\n                // fixed Dec 15 2003 (bela, patch from Joel Dice (dicej)), see explanantion under\n                // bug report #854887\n                size=len;\n            }\n            tmp=m;\n            // tmp.setDest(xmit_requester);\n            // tmp.setSrc(local_addr);\n            if(tmp.getSrc() == null)\n                tmp.setSrc(local_addr);\n            list.add(tmp);\n        }\n\n        if(!list.isEmpty()) {\n            if(trace)\n                log.trace(\"xmitting msgs [\" + marker + '-' + last_seqno + \"] to \" + xmit_requester);\n            sendXmitRsp(xmit_requester, (LinkedList)list.clone(), marker, last_seqno);\n            list.clear();\n        }\n    }","commit_id":"3acd27e6ac547a705cdee872b120e1333d6b2a29","url":"https://github.com/belaban/JGroups"},{"original_method":"public int getPendingRetransmissionRequests() {\n        int num=0;\n        NakReceiverWindow win;\n        synchronized(received_msgs) {\n            for(Iterator it=received_msgs.values().iterator(); it.hasNext();) {\n                win=(NakReceiverWindow)it.next();\n                num+=win.size();\n            }\n        }\n        return num;\n    }","id":6690,"modified_method":"public int getPendingRetransmissionRequests() {\n        int num=0;\n        for(NakReceiverWindow win: received_msgs.values()) {\n            num+=win.size();\n        }\n        return num;\n    }","commit_id":"3acd27e6ac547a705cdee872b120e1333d6b2a29","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Creates a NakReceiverWindow for each sender in the digest according to the sender's seqno. If NRW already exists,\n     * reset it.\n     */\n    private void setDigest(Digest digest) {\n        if(digest == null) {\n            if(log.isErrorEnabled()) {\n                log.error(\"digest or digest.senders is null\");\n            }\n            return;\n        }\n\n        clear();\n\n        Map.Entry entry;\n        Address sender;\n        org.jgroups.protocols.pbcast.Digest.Entry val;\n        long initial_seqno;\n        NakReceiverWindow win;\n\n        for(Iterator it=digest.getSenders().entrySet().iterator(); it.hasNext();) {\n            entry=(Map.Entry)it.next();\n            sender=(Address)entry.getKey();\n            val=(org.jgroups.protocols.pbcast.Digest.Entry)entry.getValue();\n\n            if(sender == null || val == null) {\n                if(warn) {\n                    log.warn(\"sender or value is null\");\n                }\n                continue;\n            }\n            initial_seqno=val.getHigh();\n            win=createNakReceiverWindow(sender, initial_seqno);\n            synchronized(received_msgs) {\n                received_msgs.put(sender, win);\n            }\n        }\n    }","id":6691,"modified_method":"/**\n     * Creates a NakReceiverWindow for each sender in the digest according to the sender's seqno. If NRW already exists,\n     * reset it.\n     */\n    private void setDigest(Digest digest) {\n        if(digest == null) {\n            if(log.isErrorEnabled()) {\n                log.error(\"digest or digest.senders is null\");\n            }\n            return;\n        }\n\n        clear();\n\n        Map.Entry entry;\n        Address sender;\n        org.jgroups.protocols.pbcast.Digest.Entry val;\n        long initial_seqno;\n        NakReceiverWindow win;\n\n        for(Iterator it=digest.getSenders().entrySet().iterator(); it.hasNext();) {\n            entry=(Map.Entry)it.next();\n            sender=(Address)entry.getKey();\n            val=(org.jgroups.protocols.pbcast.Digest.Entry)entry.getValue();\n\n            if(sender == null || val == null) {\n                if(warn) {\n                    log.warn(\"sender or value is null\");\n                }\n                continue;\n            }\n            initial_seqno=val.getHigh();\n            win=createNakReceiverWindow(sender, initial_seqno);\n            received_msgs.put(sender, win);\n        }\n    }","commit_id":"3acd27e6ac547a705cdee872b120e1333d6b2a29","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns the highest seqno seen from sender. E.g. if we received 1, 2, 4, 5 from P, then 5 will be returned\n     * (doesn't take gaps into account). If we are the sender, we will return the highest seqno <em>sent<\/em> rather\n     * then <em>received<\/em>\n     */\n    private long getHighSeqnoSeen(Address sender) {\n        NakReceiverWindow win;\n        long ret=0;\n\n        if(sender == null) {\n            if(log.isErrorEnabled()) {\n                log.error(\"sender is null\");\n            }\n            return ret;\n        }\n        if(sender.equals(local_addr)) {\n            return seqno - 1;\n        }\n\n        synchronized(received_msgs) {\n            win=(NakReceiverWindow)received_msgs.get(sender);\n        }\n        if(win == null) {\n            if(log.isErrorEnabled()) {\n                log.error(\"sender \" + sender + \" not found in received_msgs\");\n            }\n            return ret;\n        }\n        ret=win.getHighestReceived();\n        return ret;\n    }","id":6692,"modified_method":"/**\n     * Returns the highest seqno seen from sender. E.g. if we received 1, 2, 4, 5 from P, then 5 will be returned\n     * (doesn't take gaps into account). If we are the sender, we will return the highest seqno <em>sent<\/em> rather\n     * then <em>received<\/em>\n     */\n    private long getHighSeqnoSeen(Address sender) {\n        NakReceiverWindow win;\n        long ret=0;\n\n        if(sender == null) {\n            if(log.isErrorEnabled()) {\n                log.error(\"sender is null\");\n            }\n            return ret;\n        }\n        if(sender.equals(local_addr)) {\n            return seqno - 1;\n        }\n\n        win=received_msgs.get(sender);\n        if(win == null) {\n            if(log.isErrorEnabled()) {\n                log.error(\"sender \" + sender + \" not found in received_msgs\");\n            }\n            return ret;\n        }\n        ret=win.getHighestReceived();\n        return ret;\n    }","commit_id":"3acd27e6ac547a705cdee872b120e1333d6b2a29","url":"https://github.com/belaban/JGroups"},{"original_method":"public String printMessages() {\n       StringBuilder ret=new StringBuilder();\n        Map.Entry entry;\n        Address addr;\n        Object w;\n\n       ret.append(\"\\nsent_msgs: \").append(printSentMsgs());\n        ret.append(\"\\nreceived_msgs:\\n\");\n        synchronized(received_msgs) {\n            for(Iterator it=received_msgs.entrySet().iterator(); it.hasNext();) {\n                entry=(Map.Entry)it.next();\n                addr=(Address)entry.getKey();\n                w=entry.getValue();\n                ret.append(addr).append(\": \").append(w.toString()).append('\\n');\n            }\n        }\n        return ret.toString();\n    }","id":6693,"modified_method":"public String printMessages() {\n       StringBuilder ret=new StringBuilder();\n        Map.Entry entry;\n        Address addr;\n        Object w;\n\n       ret.append(\"\\nsent_msgs: \").append(printSentMsgs());\n        ret.append(\"\\nreceived_msgs:\\n\");\n       for(Iterator it=received_msgs.entrySet().iterator(); it.hasNext();) {\n           entry=(Map.Entry)it.next();\n           addr=(Address)entry.getKey();\n           w=entry.getValue();\n           ret.append(addr).append(\": \").append(w.toString()).append('\\n');\n       }\n       return ret.toString();\n   }","commit_id":"3acd27e6ac547a705cdee872b120e1333d6b2a29","url":"https://github.com/belaban/JGroups"},{"original_method":"public int getReceivedTableSize() {\n        int ret=0;\n        NakReceiverWindow win;\n        Set s=new LinkedHashSet(received_msgs.values());\n        for(Iterator it=s.iterator(); it.hasNext();) {\n            win=(NakReceiverWindow)it.next();\n            ret+=win.size();\n        }\n        return ret;\n    }","id":6694,"modified_method":"public int getReceivedTableSize() {\n        return getPendingRetransmissionRequests();\n    }","commit_id":"3acd27e6ac547a705cdee872b120e1333d6b2a29","url":"https://github.com/belaban/JGroups"},{"original_method":"@Override\n    @ActionEvent(eventType = EventTypes.EVENT_ACCOUNT_DISABLE, eventDescription = \"disabling account\", async = true)\n    public AccountVO disableAccount(String accountName, Long domainId) throws ConcurrentOperationException, ResourceUnavailableException {\n        Account caller = UserContext.current().getCaller();\n        \n        Account account = _accountDao.findActiveAccount(accountName, domainId);\n        if (account == null || account.getType() == Account.ACCOUNT_TYPE_PROJECT) {\n            throw new InvalidParameterValueException(\"Unable to find account \" + accountName + \" in domain \" + domainId);\n        }\n        \n        checkAccess(caller, null, account);\n        \n        if (disableAccount(account.getId())) {\n            return _accountDao.findById(account.getId());\n        } else {\n            throw new CloudRuntimeException(\"Unable to update account \" + accountName + \" in domain \" + domainId);\n        }\n    }","id":6695,"modified_method":"@Override\n    @ActionEvent(eventType = EventTypes.EVENT_ACCOUNT_DISABLE, eventDescription = \"disabling account\", async = true)\n    public AccountVO disableAccount(String accountName, Long domainId, Long accountId) throws ConcurrentOperationException, ResourceUnavailableException {\n        Account caller = UserContext.current().getCaller();\n        \n        Account account = null;\n        if(accountId != null){\n            account = _accountDao.findById(accountId);\n        }else{\n            account = _accountDao.findActiveAccount(accountName, domainId);\n        }\n        \n        if (account == null || account.getType() == Account.ACCOUNT_TYPE_PROJECT) {\n            throw new InvalidParameterValueException(\"Unable to find account by accountId: \"+accountId+\" OR by name: \"+ accountName + \" in domain \" + domainId);\n        }\n        \n        checkAccess(caller, null, account);\n        \n        if (disableAccount(account.getId())) {\n            return _accountDao.findById(account.getId());\n        } else {\n            throw new CloudRuntimeException(\"Unable to update account by accountId: \"+accountId+\" OR by name: \"+ accountName + \" in domain \" + domainId);\n        }\n    }","commit_id":"d98130c0610da23db2dccedd58033a647b0afeff","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public AccountVO enableAccount(String accountName, long domainId) {\n        \n        // Check if account exists\n        Account account = _accountDao.findActiveAccount(accountName, domainId);\n        if (account == null || account.getType() == Account.ACCOUNT_TYPE_PROJECT) {\n            throw new InvalidParameterValueException(\"Unable to find account \" + accountName + \" in domain \" + domainId);\n        }\n\n        // Don't allow to modify system account\n        if (account.getId() == Account.ACCOUNT_ID_SYSTEM) {\n            throw new InvalidParameterValueException(\"Can not modify system account\");\n        }\n\n        // Check if user performing the action is allowed to modify this account\n        Account caller = UserContext.current().getCaller();\n        checkAccess(caller, null, account);\n\n        boolean success = enableAccount(account.getId());\n        if (success) {\n            return _accountDao.findById(account.getId());\n        } else {\n            throw new CloudRuntimeException(\"Unable to enable account \" + accountName + \" in domain \" + domainId);\n        }\n    }","id":6696,"modified_method":"@Override\n    public AccountVO enableAccount(String accountName, Long domainId, Long accountId) {\n        \n        // Check if account exists\n        Account account = null;\n        if(accountId != null){\n            account = _accountDao.findById(accountId);\n        }else{\n            account = _accountDao.findActiveAccount(accountName, domainId);\n        }\n        \n        if (account == null || account.getType() == Account.ACCOUNT_TYPE_PROJECT) {\n            throw new InvalidParameterValueException(\"Unable to find account by accountId: \"+accountId+\" OR by name: \"+ accountName + \" in domain \" + domainId);\n        }\n\n        // Don't allow to modify system account\n        if (account.getId() == Account.ACCOUNT_ID_SYSTEM) {\n            throw new InvalidParameterValueException(\"Can not modify system account\");\n        }\n\n        // Check if user performing the action is allowed to modify this account\n        Account caller = UserContext.current().getCaller();\n        checkAccess(caller, null, account);\n\n        boolean success = enableAccount(account.getId());\n        if (success) {\n            return _accountDao.findById(account.getId());\n        } else {\n            throw new CloudRuntimeException(\"Unable to enable account by accountId: \"+accountId+\" OR by name: \"+ accountName + \" in domain \" + domainId);\n        }\n    }","commit_id":"d98130c0610da23db2dccedd58033a647b0afeff","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    @ActionEvent(eventType = EventTypes.EVENT_ACCOUNT_DISABLE, eventDescription = \"locking account\", async = true)\n    public AccountVO lockAccount(String accountName, Long domainId) {\n        Account caller = UserContext.current().getCaller();\n        \n        Account account = _accountDao.findActiveAccount(accountName, domainId);\n        if (account == null || account.getType() == Account.ACCOUNT_TYPE_PROJECT) {\n            throw new InvalidParameterValueException(\"Unable to find active account with name \" + accountName + \" in domain \" + domainId);\n        }\n        \n        checkAccess(caller, null, account);\n \n        // don't allow modify system account\n        if (account.getId() == Account.ACCOUNT_ID_SYSTEM) {\n            throw new InvalidParameterValueException(\"can not lock system account\");\n        }\n\n        if (lockAccount(account.getId())) {\n            return _accountDao.findById(account.getId());\n        } else {\n            throw new CloudRuntimeException(\"Unable to lock account \" + accountName + \" in domain \" + domainId);\n        }\n    }","id":6697,"modified_method":"@Override\n    @ActionEvent(eventType = EventTypes.EVENT_ACCOUNT_DISABLE, eventDescription = \"locking account\", async = true)\n    public AccountVO lockAccount(String accountName, Long domainId, Long accountId) {\n        Account caller = UserContext.current().getCaller();\n        \n        Account account = null;\n        if(accountId != null){\n            account = _accountDao.findById(accountId);\n        }else{\n            account = _accountDao.findActiveAccount(accountName, domainId);\n        }\n        \n        if (account == null || account.getType() == Account.ACCOUNT_TYPE_PROJECT) {\n            throw new InvalidParameterValueException(\"Unable to find active account by accountId: \"+accountId+\" OR by name: \"+ accountName + \" in domain \" + domainId);\n        }\n        \n        checkAccess(caller, null, account);\n \n        // don't allow modify system account\n        if (account.getId() == Account.ACCOUNT_ID_SYSTEM) {\n            throw new InvalidParameterValueException(\"can not lock system account\");\n        }\n\n        if (lockAccount(account.getId())) {\n            return _accountDao.findById(account.getId());\n        } else {\n            throw new CloudRuntimeException(\"Unable to lock account by accountId: \"+accountId+\" OR by name: \"+ accountName + \" in domain \" + domainId);\n        }\n    }","commit_id":"d98130c0610da23db2dccedd58033a647b0afeff","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public AccountVO updateAccount(UpdateAccountCmd cmd) {\n        Long domainId = cmd.getDomainId();\n        String accountName = cmd.getAccountName();\n        String newAccountName = cmd.getNewName();\n        String networkDomain = cmd.getNetworkDomain();\n        Map<String, String>details = cmd.getDetails();\n\n        boolean success = false;\n        Account account = _accountDao.findAccount(accountName, domainId);\n\n        // Check if account exists\n        if (account == null || account.getType() == Account.ACCOUNT_TYPE_PROJECT) {\n            s_logger.error(\"Unable to find account \" + accountName + \" in domain \" + domainId);\n            throw new InvalidParameterValueException(\"Unable to find account \" + accountName + \" in domain \" + domainId);\n        }\n\n        // Don't allow to modify system account\n        if (account.getId() == Account.ACCOUNT_ID_SYSTEM) {\n            throw new InvalidParameterValueException(\"Can not modify system account\");\n        }\n\n        // Check if user performing the action is allowed to modify this account\n        checkAccess(UserContext.current().getCaller(), _domainMgr.getDomain(account.getDomainId()));\n\n        // check if the given account name is unique in this domain for updating\n        Account duplicateAcccount = _accountDao.findAccount(newAccountName, domainId);\n        if (duplicateAcccount != null && duplicateAcccount.getRemoved() == null && duplicateAcccount.getId() != account.getId()) {// allow\n                                                                                                                                  // same\n                                                                                                                                  // account\n                                                                                                                                  // to\n                                                                                                                                  // update\n                                                                                                                                  // itself\n            throw new InvalidParameterValueException(\"There already exists an account with the name:\" + newAccountName + \" in the domain:\" + domainId + \" with existing account id:\"\n                    + duplicateAcccount.getId());\n        }\n\n        if (networkDomain != null) {\n            if (!NetUtils.verifyDomainName(networkDomain)) {\n                throw new InvalidParameterValueException(\n                        \"Invalid network domain. Total length shouldn't exceed 190 chars. Each domain label must be between 1 and 63 characters long, can contain ASCII letters 'a' through 'z', the digits '0' through '9', \"\n                        + \"and the hyphen ('-'); can't start or end with \\\"-\\\"\");\n            }\n        }\n        \n        AccountVO acctForUpdate = _accountDao.findById(account.getId());\n        acctForUpdate.setAccountName(newAccountName);\n        \n        if (networkDomain != null) {\n            acctForUpdate.setNetworkDomain(networkDomain);\n        }\n        \n        success = _accountDao.update(account.getId(), acctForUpdate);\n        \n        if (details != null) {\n        \t_accountDetailsDao.update(account.getId(), details);\n        }\n        \n        if (success) {\n            return _accountDao.findById(account.getId());\n        } else {\n            throw new CloudRuntimeException(\"Unable to update account \" + accountName + \" in domain \" + domainId);\n        }\n    }","id":6698,"modified_method":"@Override\n    public AccountVO updateAccount(UpdateAccountCmd cmd) {\n        Long accountId = cmd.getId();\n        Long domainId = cmd.getDomainId();\n        String accountName = cmd.getAccountName();\n        String newAccountName = cmd.getNewName();\n        String networkDomain = cmd.getNetworkDomain();\n        Map<String, String>details = cmd.getDetails();\n\n        boolean success = false;\n        Account account = null;\n        if(accountId != null){\n            account = _accountDao.findById(accountId);\n        }else{\n            account = _accountDao.findAccount(accountName, domainId);\n        }\n\n        // Check if account exists\n        if (account == null || account.getType() == Account.ACCOUNT_TYPE_PROJECT) {\n            s_logger.error(\"Unable to find account by accountId: \"+accountId+\" OR by name: \"+ accountName + \" in domain \" + domainId);\n            throw new InvalidParameterValueException(\"Unable to find account by accountId: \"+accountId+\" OR by name: \"+ accountName + \" in domain \" + domainId);\n        }\n\n        // Don't allow to modify system account\n        if (account.getId() == Account.ACCOUNT_ID_SYSTEM) {\n            throw new InvalidParameterValueException(\"Can not modify system account\");\n        }\n\n        // Check if user performing the action is allowed to modify this account\n        checkAccess(UserContext.current().getCaller(), _domainMgr.getDomain(account.getDomainId()));\n\n        // check if the given account name is unique in this domain for updating\n        Account duplicateAcccount = _accountDao.findAccount(newAccountName, domainId);\n        if (duplicateAcccount != null && duplicateAcccount.getRemoved() == null && duplicateAcccount.getId() != account.getId()) {// allow\n                                                                                                                                  // same\n                                                                                                                                  // account\n                                                                                                                                  // to\n                                                                                                                                  // update\n                                                                                                                                  // itself\n            throw new InvalidParameterValueException(\"There already exists an account with the name:\" + newAccountName + \" in the domain:\" + domainId + \" with existing account id:\"\n                    + duplicateAcccount.getId());\n        }\n\n        if (networkDomain != null) {\n            if (!NetUtils.verifyDomainName(networkDomain)) {\n                throw new InvalidParameterValueException(\n                        \"Invalid network domain. Total length shouldn't exceed 190 chars. Each domain label must be between 1 and 63 characters long, can contain ASCII letters 'a' through 'z', the digits '0' through '9', \"\n                        + \"and the hyphen ('-'); can't start or end with \\\"-\\\"\");\n            }\n        }\n        \n        AccountVO acctForUpdate = _accountDao.findById(account.getId());\n        acctForUpdate.setAccountName(newAccountName);\n        \n        if (networkDomain != null) {\n            acctForUpdate.setNetworkDomain(networkDomain);\n        }\n        \n        success = _accountDao.update(account.getId(), acctForUpdate);\n        \n        if (details != null) {\n        \t_accountDetailsDao.update(account.getId(), details);\n        }\n        \n        if (success) {\n            return _accountDao.findById(account.getId());\n        } else {\n            throw new CloudRuntimeException(\"Unable to update account by accountId: \"+accountId+\" OR by name: \"+ accountName + \" in domain \" + domainId);\n        }\n    }","commit_id":"d98130c0610da23db2dccedd58033a647b0afeff","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public long getEntityOwnerId() {\n        Account account = _accountService.getActiveAccountByName(getAccountName(), getDomainId());\n        if (account != null) {\n            return account.getAccountId();\n        }\n\n        return Account.ACCOUNT_ID_SYSTEM; // no account info given, parent this command to SYSTEM so ERROR events are tracked\n    }","id":6699,"modified_method":"@Override\n    public long getEntityOwnerId() {\n        Account account = _entityMgr.findById(Account.class, getId());\n        if (account != null) {\n            return account.getAccountId();\n        }\n        \n        account = _accountService.getActiveAccountByName(getAccountName(), getDomainId());\n        if (account != null) {\n            return account.getAccountId();\n        }\n\n        return Account.ACCOUNT_ID_SYSTEM; // no account info given, parent this command to SYSTEM so ERROR events are tracked\n    }","commit_id":"d98130c0610da23db2dccedd58033a647b0afeff","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public void execute() throws ConcurrentOperationException, ResourceUnavailableException{\n        UserContext.current().setEventDetails(\"Account Name: \"+getAccountName()+\", Domain Id:\"+getDomainId());\n    \tAccount result = null;\n    \tif(lockRequested)\n    \t\tresult = _accountService.lockAccount(getAccountName(), getDomainId());\n    \telse\n    \t\tresult = _accountService.disableAccount(getAccountName(), getDomainId());\n        if (result != null){\n            AccountResponse response = _responseGenerator.createAccountResponse(result);\n            response.setResponseName(getCommandName());\n            this.setResponseObject(response);\n        } else {\n            throw new ServerApiException(BaseCmd.INTERNAL_ERROR, lockRequested == true ? \"Failed to lock account\" : \"Failed to disable account\" );\n        }\n    }","id":6700,"modified_method":"@Override\n    public void execute() throws ConcurrentOperationException, ResourceUnavailableException{\n        UserContext.current().setEventDetails(\"Account Name: \"+getAccountName()+\", Domain Id:\"+getDomainId());\n    \tAccount result = null;\n    \tif(lockRequested)\n    \t\tresult = _accountService.lockAccount(getAccountName(), getDomainId(), getId());\n    \telse\n    \t\tresult = _accountService.disableAccount(getAccountName(), getDomainId(), getId());\n        if (result != null){\n            AccountResponse response = _responseGenerator.createAccountResponse(result);\n            response.setResponseName(getCommandName());\n            this.setResponseObject(response);\n        } else {\n            throw new ServerApiException(BaseCmd.INTERNAL_ERROR, lockRequested == true ? \"Failed to lock account\" : \"Failed to disable account\" );\n        }\n    }","commit_id":"d98130c0610da23db2dccedd58033a647b0afeff","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public long getEntityOwnerId() {\n        Account account = _accountService.getActiveAccountByName(getAccountName(), getDomainId());\n        if (account != null) {\n            return account.getAccountId();\n        }\n\n        return Account.ACCOUNT_ID_SYSTEM; // no account info given, parent this command to SYSTEM so ERROR events are tracked\n    }","id":6701,"modified_method":"@Override\n    public long getEntityOwnerId() {\n        Account account = _entityMgr.findById(Account.class, getId());\n        if (account != null) {\n            return account.getAccountId();\n        }\n        \n        account = _accountService.getActiveAccountByName(getAccountName(), getDomainId());\n        if (account != null) {\n            return account.getAccountId();\n        }\n\n        return Account.ACCOUNT_ID_SYSTEM; // no account info given, parent this command to SYSTEM so ERROR events are tracked\n    }","commit_id":"d98130c0610da23db2dccedd58033a647b0afeff","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public void execute(){\n        Account result = _accountService.enableAccount(getAccountName(), getDomainId());\n        if (result != null){\n            AccountResponse response = _responseGenerator.createAccountResponse(result);\n            response.setResponseName(getCommandName());\n            this.setResponseObject(response);\n        } else {\n            throw new ServerApiException(BaseCmd.INTERNAL_ERROR, \"Failed to enable account\");\n        }\n    }","id":6702,"modified_method":"@Override\n    public void execute(){\n        Account result = _accountService.enableAccount(getAccountName(), getDomainId(), getId());\n        if (result != null){\n            AccountResponse response = _responseGenerator.createAccountResponse(result);\n            response.setResponseName(getCommandName());\n            this.setResponseObject(response);\n        } else {\n            throw new ServerApiException(BaseCmd.INTERNAL_ERROR, \"Failed to enable account\");\n        }\n    }","commit_id":"d98130c0610da23db2dccedd58033a647b0afeff","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public long getEntityOwnerId() {\n        Account account = _accountService.getActiveAccountByName(getAccountName(), getDomainId());\n        if (account != null) {\n            return account.getAccountId();\n        }\n\n        return Account.ACCOUNT_ID_SYSTEM; // no account info given, parent this command to SYSTEM so ERROR events are tracked\n    }","id":6703,"modified_method":"@Override\n    public long getEntityOwnerId() {\n        Account account = _entityMgr.findById(Account.class, getId());\n        if (account != null) {\n            return account.getAccountId();\n        }\n        account = _accountService.getActiveAccountByName(getAccountName(), getDomainId());\n        if (account != null) {\n            return account.getAccountId();\n        }\n\n        return Account.ACCOUNT_ID_SYSTEM; // no account info given, parent this command to SYSTEM so ERROR events are tracked\n    }","commit_id":"d98130c0610da23db2dccedd58033a647b0afeff","url":"https://github.com/apache/cloudstack"},{"original_method":"public void addPackages(Set<String> packageNames) {\n        if (packageNames == null || packageNames.size() < 1) {\n            return;\n        }\n\n        for (String pName : packageNames) {\n            servletHolder.setInitParameter(\"com.sun.jersey.config.property.packages\", pName);\n        }\n    }","id":6704,"modified_method":"public void addPackages(String packageNames) {\n        if (packageNames == null) {\n            return;\n        }\n        \n        servletHolder.setInitParameter(\"com.sun.jersey.config.property.packages\", packageNames);\n\n    }","commit_id":"8d866b1e95052d1b97ade88abd36f545544d17b4","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Set<String> getDummyWebResourcePackage() {\n        HashSet<String> result = new HashSet<String>();\n        result.add(\"org.neo4j.server.web\");\n        return result;\n    }","id":6705,"modified_method":"private String getDummyWebResourcePackage() {\n        return \"org.neo4j.server.web\";\n    }","commit_id":"8d866b1e95052d1b97ade88abd36f545544d17b4","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void main(String[] args) {\n        Configurator conf = new Configurator(getConfigFile());\n        JettyWebServer ws = new JettyWebServer();\n        \n        HashSet<String> packages = new HashSet<String>();\n        packages.add(\"org.neo4j.server.web\");\n        ws.addPackages(packages);\n        \n        NeoServer theServer = new NeoServer(conf, \n                                            new Database(conf.configuration().getString(\"database.location\")), \n                                            ws); \n        theServer.start();\n    }","id":6706,"modified_method":"public static void main(String[] args) {\n        Configurator conf = new Configurator(getConfigFile());\n\n        JettyWebServer ws = new JettyWebServer();\n        ws.setPort(conf.configuration().getInt(WEBSERVER_PORT));\n        //ws.addPackages(getPackagesToLoad(conf.configuration().getStringArray(WEBSERVICE_PACKAGES)));\n        ws.addPackages(\"org.example.coffeeshop, org.example.petshop\");\n\n        theServer = new NeoServer(conf, new Database(conf.configuration().getString(DATABASE_LOCATION)), ws);\n        theServer.start();\n    }","commit_id":"8d866b1e95052d1b97ade88abd36f545544d17b4","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void serverShouldProvideAWelcomePage() {\n        \n        Configurator configurator = configurator();\n        Database database = database();\n        WebServer webServer = webServer();\n        webServer.setPort(6666);\n        HashSet<String> packages = new HashSet<String>();\n        packages.add(\"org.neo4j.server.web\");\n        webServer.addPackages(packages);\n        \n        NeoServer server = new NeoServer(configurator, database, webServer);\n        server.start();\n        \n        Client client = Client.create();\n        ClientResponse response = client.resource(\"http://localhost:\" + webServer.getPort() + \"/welcome.html\").get(ClientResponse.class);\n        \n        assertThat(response.getStatus(), is(200));\n        assertThat(response.getHeaders().getFirst(\"Server\"), containsString(\"Jetty\"));\n        assertThat(response.getHeaders().getFirst(\"Content-Type\"), containsString(\"html\"));\n        \n        server.shutdown();\n    }","id":6707,"modified_method":"@Test\n    public void serverShouldProvideAWelcomePage() {\n        \n        Configurator configurator = configurator();\n        Database database = database();\n        WebServer webServer = webServer();\n        webServer.setPort(6666);\n        webServer.addPackages(\"org.neo4j.server.web\");\n        \n        NeoServer server = new NeoServer(configurator, database, webServer);\n        server.start();\n        \n        Client client = Client.create();\n        ClientResponse response = client.resource(\"http://localhost:\" + webServer.getPort() + \"/welcome.html\").get(ClientResponse.class);\n        \n        assertThat(response.getStatus(), is(200));\n        assertThat(response.getHeaders().getFirst(\"Server\"), containsString(\"Jetty\"));\n        assertThat(response.getHeaders().getFirst(\"Content-Type\"), containsString(\"html\"));\n        \n        server.shutdown();\n    }","commit_id":"8d866b1e95052d1b97ade88abd36f545544d17b4","url":"https://github.com/neo4j/neo4j"},{"original_method":"private WebServer webServer() {\n        JettyWebServer server = new JettyWebServer();\n        server.setPort(WebTestUtils.nextAvailablePortNumber());\n        return server;\n    }","id":6708,"modified_method":"private WebServer webServer() {\n        JettyWebServer server = new JettyWebServer();\n        server.setPort(configurator().configuration().getInt(\"webserver.port\"));\n        return server;\n    }","commit_id":"8d866b1e95052d1b97ade88abd36f545544d17b4","url":"https://github.com/neo4j/neo4j"},{"original_method":"private WebServer webServer() {\n        WebServer webServer = new JettyWebServer();\n        webServer.setPort(portNo);\n        HashSet<String> packages = new HashSet<String>();\n        packages.add(\"org.neo4j.server.web\");\n        webServer.addPackages(packages);\n        return webServer;\n    }","id":6709,"modified_method":"private WebServer webServer() {\n        WebServer webServer = new JettyWebServer();\n        webServer.setPort(portNo);\n        webServer.addPackages(\"org.neo4j.server.web\");\n        return webServer;\n    }","commit_id":"8d866b1e95052d1b97ade88abd36f545544d17b4","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void addPackages(Set<String> packageNames) {\n        if (packageNames == null || packageNames.size() < 1) {\n            return;\n        }\n\n        for (String pName : packageNames) {\n            servletHolder.setInitParameter(\"com.sun.jersey.config.property.packages\", pName);\n        }\n    }","id":6710,"modified_method":"public void addPackages(String packageNames) {\n        if (packageNames == null) {\n            return;\n        }\n        \n        servletHolder.setInitParameter(\"com.sun.jersey.config.property.packages\", packageNames);\n\n    }","commit_id":"bd2a043d5e80f1e89cd75344997e83991b93605a","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Set<String> getDummyWebResourcePackage() {\n        HashSet<String> result = new HashSet<String>();\n        result.add(\"org.neo4j.server.web\");\n        return result;\n    }","id":6711,"modified_method":"private String getDummyWebResourcePackage() {\n        return \"org.neo4j.server.web\";\n    }","commit_id":"bd2a043d5e80f1e89cd75344997e83991b93605a","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void main(String[] args) {\n        Configurator conf = new Configurator(getConfigFile());\n        JettyWebServer ws = new JettyWebServer();\n        \n        HashSet<String> packages = new HashSet<String>();\n        packages.add(\"org.neo4j.server.web\");\n        ws.addPackages(packages);\n        \n        NeoServer theServer = new NeoServer(conf, \n                                            new Database(conf.configuration().getString(\"database.location\")), \n                                            ws); \n        theServer.start();\n    }","id":6712,"modified_method":"public static void main(String[] args) {\n        Configurator conf = new Configurator(getConfigFile());\n\n        JettyWebServer ws = new JettyWebServer();\n        ws.setPort(conf.configuration().getInt(WEBSERVER_PORT));\n        //ws.addPackages(getPackagesToLoad(conf.configuration().getStringArray(WEBSERVICE_PACKAGES)));\n        ws.addPackages(\"org.example.coffeeshop, org.example.petshop\");\n\n        theServer = new NeoServer(conf, new Database(conf.configuration().getString(DATABASE_LOCATION)), ws);\n        theServer.start();\n    }","commit_id":"bd2a043d5e80f1e89cd75344997e83991b93605a","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void serverShouldProvideAWelcomePage() {\n        \n        Configurator configurator = configurator();\n        Database database = database();\n        WebServer webServer = webServer();\n        webServer.setPort(6666);\n        HashSet<String> packages = new HashSet<String>();\n        packages.add(\"org.neo4j.server.web\");\n        webServer.addPackages(packages);\n        \n        NeoServer server = new NeoServer(configurator, database, webServer);\n        server.start();\n        \n        Client client = Client.create();\n        ClientResponse response = client.resource(\"http://localhost:\" + webServer.getPort() + \"/welcome.html\").get(ClientResponse.class);\n        \n        assertThat(response.getStatus(), is(200));\n        assertThat(response.getHeaders().getFirst(\"Server\"), containsString(\"Jetty\"));\n        assertThat(response.getHeaders().getFirst(\"Content-Type\"), containsString(\"html\"));\n        \n        server.shutdown();\n    }","id":6713,"modified_method":"@Test\n    public void serverShouldProvideAWelcomePage() {\n        \n        Configurator configurator = configurator();\n        Database database = database();\n        WebServer webServer = webServer();\n        webServer.setPort(6666);\n        webServer.addPackages(\"org.neo4j.server.web\");\n        \n        NeoServer server = new NeoServer(configurator, database, webServer);\n        server.start();\n        \n        Client client = Client.create();\n        ClientResponse response = client.resource(\"http://localhost:\" + webServer.getPort() + \"/welcome.html\").get(ClientResponse.class);\n        \n        assertThat(response.getStatus(), is(200));\n        assertThat(response.getHeaders().getFirst(\"Server\"), containsString(\"Jetty\"));\n        assertThat(response.getHeaders().getFirst(\"Content-Type\"), containsString(\"html\"));\n        \n        server.shutdown();\n    }","commit_id":"bd2a043d5e80f1e89cd75344997e83991b93605a","url":"https://github.com/neo4j/neo4j"},{"original_method":"private WebServer webServer() {\n        JettyWebServer server = new JettyWebServer();\n        server.setPort(WebTestUtils.nextAvailablePortNumber());\n        return server;\n    }","id":6714,"modified_method":"private WebServer webServer() {\n        JettyWebServer server = new JettyWebServer();\n        server.setPort(configurator().configuration().getInt(\"webserver.port\"));\n        return server;\n    }","commit_id":"bd2a043d5e80f1e89cd75344997e83991b93605a","url":"https://github.com/neo4j/neo4j"},{"original_method":"private WebServer webServer() {\n        WebServer webServer = new JettyWebServer();\n        webServer.setPort(portNo);\n        HashSet<String> packages = new HashSet<String>();\n        packages.add(\"org.neo4j.server.web\");\n        webServer.addPackages(packages);\n        return webServer;\n    }","id":6715,"modified_method":"private WebServer webServer() {\n        WebServer webServer = new JettyWebServer();\n        webServer.setPort(portNo);\n        webServer.addPackages(\"org.neo4j.server.web\");\n        return webServer;\n    }","commit_id":"bd2a043d5e80f1e89cd75344997e83991b93605a","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void addPackages(Set<String> packageNames) {\n        if (packageNames == null || packageNames.size() < 1) {\n            return;\n        }\n\n        for (String pName : packageNames) {\n            servletHolder.setInitParameter(\"com.sun.jersey.config.property.packages\", pName);\n        }\n    }","id":6716,"modified_method":"public void addPackages(String packageNames) {\n        if (packageNames == null) {\n            return;\n        }\n        \n        servletHolder.setInitParameter(\"com.sun.jersey.config.property.packages\", packageNames);\n\n    }","commit_id":"a0d02c5506fc159ed891b6463ade845ade6db01c","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Set<String> getDummyWebResourcePackage() {\n        HashSet<String> result = new HashSet<String>();\n        result.add(\"org.neo4j.server.web\");\n        return result;\n    }","id":6717,"modified_method":"private String getDummyWebResourcePackage() {\n        return \"org.neo4j.server.web\";\n    }","commit_id":"a0d02c5506fc159ed891b6463ade845ade6db01c","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void main(String[] args) {\n        Configurator conf = new Configurator(getConfigFile());\n        JettyWebServer ws = new JettyWebServer();\n        \n        HashSet<String> packages = new HashSet<String>();\n        packages.add(\"org.neo4j.server.web\");\n        ws.addPackages(packages);\n        \n        NeoServer theServer = new NeoServer(conf, \n                                            new Database(conf.configuration().getString(\"database.location\")), \n                                            ws); \n        theServer.start();\n    }","id":6718,"modified_method":"public static void main(String[] args) {\n        Configurator conf = new Configurator(getConfigFile());\n\n        JettyWebServer ws = new JettyWebServer();\n        ws.setPort(conf.configuration().getInt(WEBSERVER_PORT));\n        //ws.addPackages(getPackagesToLoad(conf.configuration().getStringArray(WEBSERVICE_PACKAGES)));\n        ws.addPackages(\"org.example.coffeeshop, org.example.petshop\");\n\n        theServer = new NeoServer(conf, new Database(conf.configuration().getString(DATABASE_LOCATION)), ws);\n        theServer.start();\n    }","commit_id":"a0d02c5506fc159ed891b6463ade845ade6db01c","url":"https://github.com/neo4j/neo4j"},{"original_method":"private WebServer webServer() {\n        JettyWebServer server = new JettyWebServer();\n        server.setPort(WebTestUtils.nextAvailablePortNumber());\n        return server;\n    }","id":6719,"modified_method":"private WebServer webServer() {\n        JettyWebServer server = new JettyWebServer();\n        server.setPort(configurator().configuration().getInt(\"webserver.port\"));\n        return server;\n    }","commit_id":"a0d02c5506fc159ed891b6463ade845ade6db01c","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void serverShouldProvideAWelcomePage() {\n        \n        Configurator configurator = configurator();\n        Database database = database();\n        WebServer webServer = webServer();\n        webServer.setPort(6666);\n        HashSet<String> packages = new HashSet<String>();\n        packages.add(\"org.neo4j.server.web\");\n        webServer.addPackages(packages);\n        \n        NeoServer server = new NeoServer(configurator, database, webServer);\n        server.start();\n        \n        Client client = Client.create();\n        ClientResponse response = client.resource(\"http://localhost:\" + webServer.getPort() + \"/welcome.html\").get(ClientResponse.class);\n        \n        assertThat(response.getStatus(), is(200));\n        assertThat(response.getHeaders().getFirst(\"Server\"), containsString(\"Jetty\"));\n        assertThat(response.getHeaders().getFirst(\"Content-Type\"), containsString(\"html\"));\n        \n        server.shutdown();\n    }","id":6720,"modified_method":"@Test\n    public void serverShouldProvideAWelcomePage() {\n        \n        Configurator configurator = configurator();\n        Database database = database();\n        WebServer webServer = webServer();\n        webServer.setPort(6666);\n        webServer.addPackages(\"org.neo4j.server.web\");\n        \n        NeoServer server = new NeoServer(configurator, database, webServer);\n        server.start();\n        \n        Client client = Client.create();\n        ClientResponse response = client.resource(\"http://localhost:\" + webServer.getPort() + \"/welcome.html\").get(ClientResponse.class);\n        \n        assertThat(response.getStatus(), is(200));\n        assertThat(response.getHeaders().getFirst(\"Server\"), containsString(\"Jetty\"));\n        assertThat(response.getHeaders().getFirst(\"Content-Type\"), containsString(\"html\"));\n        \n        server.shutdown();\n    }","commit_id":"a0d02c5506fc159ed891b6463ade845ade6db01c","url":"https://github.com/neo4j/neo4j"},{"original_method":"private WebServer webServer() {\n        WebServer webServer = new JettyWebServer();\n        webServer.setPort(portNo);\n        HashSet<String> packages = new HashSet<String>();\n        packages.add(\"org.neo4j.server.web\");\n        webServer.addPackages(packages);\n        return webServer;\n    }","id":6721,"modified_method":"private WebServer webServer() {\n        WebServer webServer = new JettyWebServer();\n        webServer.setPort(portNo);\n        webServer.addPackages(\"org.neo4j.server.web\");\n        return webServer;\n    }","commit_id":"a0d02c5506fc159ed891b6463ade845ade6db01c","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void addPackages(Set<String> packageNames) {\n        if (packageNames == null || packageNames.size() < 1) {\n            return;\n        }\n\n        for (String pName : packageNames) {\n            servletHolder.setInitParameter(\"com.sun.jersey.config.property.packages\", pName);\n        }\n    }","id":6722,"modified_method":"public void addPackages(String packageNames) {\n        if (packageNames == null) {\n            return;\n        }\n        \n        servletHolder.setInitParameter(\"com.sun.jersey.config.property.packages\", packageNames);\n\n    }","commit_id":"95b8d53da4dbe9962671b12df00fe2964813f8dc","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Set<String> getDummyWebResourcePackage() {\n        HashSet<String> result = new HashSet<String>();\n        result.add(\"org.neo4j.server.web\");\n        return result;\n    }","id":6723,"modified_method":"private String getDummyWebResourcePackage() {\n        return \"org.neo4j.server.web\";\n    }","commit_id":"95b8d53da4dbe9962671b12df00fe2964813f8dc","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void main(String[] args) {\n        Configurator conf = new Configurator(getConfigFile());\n        JettyWebServer ws = new JettyWebServer();\n        \n        HashSet<String> packages = new HashSet<String>();\n        packages.add(\"org.neo4j.server.web\");\n        ws.addPackages(packages);\n        \n        NeoServer theServer = new NeoServer(conf, \n                                            new Database(conf.configuration().getString(\"database.location\")), \n                                            ws); \n        theServer.start();\n    }","id":6724,"modified_method":"public static void main(String[] args) {\n        Configurator conf = new Configurator(getConfigFile());\n\n        JettyWebServer ws = new JettyWebServer();\n        ws.setPort(conf.configuration().getInt(WEBSERVER_PORT));\n        //ws.addPackages(getPackagesToLoad(conf.configuration().getStringArray(WEBSERVICE_PACKAGES)));\n        ws.addPackages(\"org.example.coffeeshop, org.example.petshop\");\n\n        theServer = new NeoServer(conf, new Database(conf.configuration().getString(DATABASE_LOCATION)), ws);\n        theServer.start();\n    }","commit_id":"95b8d53da4dbe9962671b12df00fe2964813f8dc","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void serverShouldProvideAWelcomePage() {\n        \n        Configurator configurator = configurator();\n        Database database = database();\n        WebServer webServer = webServer();\n        webServer.setPort(6666);\n        HashSet<String> packages = new HashSet<String>();\n        packages.add(\"org.neo4j.server.web\");\n        webServer.addPackages(packages);\n        \n        NeoServer server = new NeoServer(configurator, database, webServer);\n        server.start();\n        \n        Client client = Client.create();\n        ClientResponse response = client.resource(\"http://localhost:\" + webServer.getPort() + \"/welcome.html\").get(ClientResponse.class);\n        \n        assertThat(response.getStatus(), is(200));\n        assertThat(response.getHeaders().getFirst(\"Server\"), containsString(\"Jetty\"));\n        assertThat(response.getHeaders().getFirst(\"Content-Type\"), containsString(\"html\"));\n        \n        server.shutdown();\n    }","id":6725,"modified_method":"@Test\n    public void serverShouldProvideAWelcomePage() {\n        \n        Configurator configurator = configurator();\n        Database database = database();\n        WebServer webServer = webServer();\n        webServer.setPort(6666);\n        webServer.addPackages(\"org.neo4j.server.web\");\n        \n        NeoServer server = new NeoServer(configurator, database, webServer);\n        server.start();\n        \n        Client client = Client.create();\n        ClientResponse response = client.resource(\"http://localhost:\" + webServer.getPort() + \"/welcome.html\").get(ClientResponse.class);\n        \n        assertThat(response.getStatus(), is(200));\n        assertThat(response.getHeaders().getFirst(\"Server\"), containsString(\"Jetty\"));\n        assertThat(response.getHeaders().getFirst(\"Content-Type\"), containsString(\"html\"));\n        \n        server.shutdown();\n    }","commit_id":"95b8d53da4dbe9962671b12df00fe2964813f8dc","url":"https://github.com/neo4j/neo4j"},{"original_method":"private WebServer webServer() {\n        JettyWebServer server = new JettyWebServer();\n        server.setPort(WebTestUtils.nextAvailablePortNumber());\n        return server;\n    }","id":6726,"modified_method":"private WebServer webServer() {\n        JettyWebServer server = new JettyWebServer();\n        server.setPort(configurator().configuration().getInt(\"webserver.port\"));\n        return server;\n    }","commit_id":"95b8d53da4dbe9962671b12df00fe2964813f8dc","url":"https://github.com/neo4j/neo4j"},{"original_method":"private WebServer webServer() {\n        WebServer webServer = new JettyWebServer();\n        webServer.setPort(portNo);\n        HashSet<String> packages = new HashSet<String>();\n        packages.add(\"org.neo4j.server.web\");\n        webServer.addPackages(packages);\n        return webServer;\n    }","id":6727,"modified_method":"private WebServer webServer() {\n        WebServer webServer = new JettyWebServer();\n        webServer.setPort(portNo);\n        webServer.addPackages(\"org.neo4j.server.web\");\n        return webServer;\n    }","commit_id":"95b8d53da4dbe9962671b12df00fe2964813f8dc","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void ok() {\n    if ( Const.isEmpty( wName.getText() ) ) {\n      MessageBox mb = new MessageBox( shell, SWT.OK | SWT.ICON_ERROR );\n      mb.setMessage( \"Please give this job entry a name!\" );\n      mb.setText( \"Enter a name\" );\n      mb.open();\n      return;\n    }\n    jobEntry.setName( wName.getText() );\n    jobEntry.setIncludeSubfolders( wIncludeSubfolders.getSelection() );\n    jobEntry.setAsciiMode( wasciiMode.getSelection() );\n    jobEntry.setArgFromPrevious( wPrevious.getSelection() );\n    jobEntry.setAddresultfilesname( wAddFileToResult.getSelection() );\n    jobEntry.setDestinationIsAFile( wDestinationIsAFile.getSelection() );\n    jobEntry.setCreateDestinationFolder( wCreateDestinationFolder.getSelection() );\n    jobEntry.setNrErrorsLessThan( wNrErrorsLessThan.getText() );\n\n    jobEntry.setCreateMoveToFolder( wCreateMoveToFolder.getSelection() );\n\n    if ( wSuccessCondition.getSelectionIndex() == 1 ) {\n      jobEntry.setSuccessCondition( jobEntry.SUCCESS_IF_AT_LEAST_X_FILES_UN_ZIPPED );\n    } else if ( wSuccessCondition.getSelectionIndex() == 2 ) {\n      jobEntry.setSuccessCondition( jobEntry.SUCCESS_IF_ERRORS_LESS );\n    } else {\n      jobEntry.setSuccessCondition( jobEntry.SUCCESS_IF_NO_ERRORS );\n    }\n\n    if ( wIfFileExists.getSelectionIndex() == 1 ) {\n      jobEntry.setIfFileExists( \"overwrite_file\" );\n    } else if ( wIfFileExists.getSelectionIndex() == 2 ) {\n      jobEntry.setIfFileExists( \"unique_name\" );\n    } else if ( wIfFileExists.getSelectionIndex() == 3 ) {\n      jobEntry.setIfFileExists( \"delete_file\" );\n    } else if ( wIfFileExists.getSelectionIndex() == 4 ) {\n      jobEntry.setIfFileExists( \"move_file\" );\n    } else if ( wIfFileExists.getSelectionIndex() == 5 ) {\n      jobEntry.setIfFileExists( \"fail\" );\n    } else {\n      jobEntry.setIfFileExists( \"do_nothing\" );\n    }\n\n    jobEntry.setDestinationFolder( wDestinationFolder.getText() );\n\n    jobEntry.setGPGPLocation( wGpgExe.getText() );\n\n    if ( wIfMovedFileExists.getSelectionIndex() == 1 ) {\n      jobEntry.setIfMovedFileExists( \"overwrite_file\" );\n    } else if ( wIfMovedFileExists.getSelectionIndex() == 2 ) {\n      jobEntry.setIfMovedFileExists( \"unique_name\" );\n    } else if ( wIfMovedFileExists.getSelectionIndex() == 3 ) {\n      jobEntry.setIfMovedFileExists( \"fail\" );\n    } else {\n      jobEntry.setIfMovedFileExists( \"do_nothing\" );\n    }\n\n    jobEntry.setDoNotKeepFolderStructure( wDoNotKeepFolderStructure.getSelection() );\n\n    jobEntry.setAddDate( wAddDate.getSelection() );\n    jobEntry.setAddTime( wAddTime.getSelection() );\n    jobEntry.setSpecifyFormat( wSpecifyFormat.getSelection() );\n    jobEntry.setDateTimeFormat( wDateTimeFormat.getText() );\n    jobEntry.setAddDateBeforeExtension( wAddDateBeforeExtension.getSelection() );\n\n    jobEntry.setAddMovedDate( wAddMovedDate.getSelection() );\n    jobEntry.setAddMovedTime( wAddMovedTime.getSelection() );\n    jobEntry.setSpecifyMoveFormat( wSpecifyMoveFormat.getSelection() );\n    jobEntry.setMovedDateTimeFormat( wMovedDateTimeFormat.getText() );\n    jobEntry.setAddMovedDateBeforeExtension( wAddMovedDateBeforeExtension.getSelection() );\n\n    int nritems = wFields.nrNonEmpty();\n    int nr = 0;\n    for ( int i = 0; i < nritems; i++ ) {\n      String arg = wFields.getNonEmpty( i ).getText( 1 );\n      if ( arg != null && arg.length() != 0 ) {\n        nr++;\n      }\n    }\n    jobEntry.action_type = new int[nr];\n    jobEntry.source_filefolder = new String[nr];\n    jobEntry.userid = new String[nr];\n    jobEntry.destination_filefolder = new String[nr];\n    jobEntry.wildcard = new String[nr];\n    nr = 0;\n    for ( int i = 0; i < nritems; i++ ) {\n      String action = wFields.getNonEmpty( i ).getText( 1 );\n      String source = wFields.getNonEmpty( i ).getText( 2 );\n      String wild = wFields.getNonEmpty( i ).getText( 3 );\n      String userid = wFields.getNonEmpty( i ).getText( 4 );\n      String dest = wFields.getNonEmpty( i ).getText( 5 );\n\n      if ( source != null && source.length() != 0 ) {\n        jobEntry.action_type[nr] = JobEntryPGPEncryptFiles.getActionTypeByDesc( action );\n        jobEntry.source_filefolder[nr] = source;\n        jobEntry.wildcard[nr] = wild;\n        jobEntry.userid[nr] = userid;\n        jobEntry.destination_filefolder[nr] = dest;\n        nr++;\n      }\n    }\n    dispose();\n  }","id":6728,"modified_method":"private void ok() {\n    if ( Const.isEmpty( wName.getText() ) ) {\n      MessageBox mb = new MessageBox( shell, SWT.OK | SWT.ICON_ERROR );\n      mb.setMessage( \"Please give this job entry a name!\" );\n      mb.setText( \"Enter a name\" );\n      mb.open();\n      return;\n    }\n    jobEntry.setName( wName.getText() );\n    jobEntry.setIncludeSubfolders( wIncludeSubfolders.getSelection() );\n    jobEntry.setAsciiMode( wasciiMode.getSelection() );\n    jobEntry.setArgFromPrevious( wPrevious.getSelection() );\n    jobEntry.setAddresultfilesname( wAddFileToResult.getSelection() );\n    jobEntry.setDestinationIsAFile( wDestinationIsAFile.getSelection() );\n    jobEntry.setCreateDestinationFolder( wCreateDestinationFolder.getSelection() );\n    jobEntry.setNrErrorsLessThan( wNrErrorsLessThan.getText() );\n\n    jobEntry.setCreateMoveToFolder( wCreateMoveToFolder.getSelection() );\n\n    if ( wSuccessCondition.getSelectionIndex() == 1 ) {\n      jobEntry.setSuccessCondition( jobEntry.SUCCESS_IF_AT_LEAST_X_FILES_UN_ZIPPED );\n    } else if ( wSuccessCondition.getSelectionIndex() == 2 ) {\n      jobEntry.setSuccessCondition( jobEntry.SUCCESS_IF_ERRORS_LESS );\n    } else {\n      jobEntry.setSuccessCondition( jobEntry.SUCCESS_IF_NO_ERRORS );\n    }\n\n    if ( wIfFileExists.getSelectionIndex() == 1 ) {\n      jobEntry.setIfFileExists( \"overwrite_file\" );\n    } else if ( wIfFileExists.getSelectionIndex() == 2 ) {\n      jobEntry.setIfFileExists( \"unique_name\" );\n    } else if ( wIfFileExists.getSelectionIndex() == 3 ) {\n      jobEntry.setIfFileExists( \"delete_file\" );\n    } else if ( wIfFileExists.getSelectionIndex() == 4 ) {\n      jobEntry.setIfFileExists( \"move_file\" );\n    } else if ( wIfFileExists.getSelectionIndex() == 5 ) {\n      jobEntry.setIfFileExists( \"fail\" );\n    } else {\n      jobEntry.setIfFileExists( \"do_nothing\" );\n    }\n\n    jobEntry.setDestinationFolder( wDestinationFolder.getText() );\n\n    jobEntry.setGPGLocation( wGpgExe.getText() );\n\n    if ( wIfMovedFileExists.getSelectionIndex() == 1 ) {\n      jobEntry.setIfMovedFileExists( \"overwrite_file\" );\n    } else if ( wIfMovedFileExists.getSelectionIndex() == 2 ) {\n      jobEntry.setIfMovedFileExists( \"unique_name\" );\n    } else if ( wIfMovedFileExists.getSelectionIndex() == 3 ) {\n      jobEntry.setIfMovedFileExists( \"fail\" );\n    } else {\n      jobEntry.setIfMovedFileExists( \"do_nothing\" );\n    }\n\n    jobEntry.setDoNotKeepFolderStructure( wDoNotKeepFolderStructure.getSelection() );\n\n    jobEntry.setAddDate( wAddDate.getSelection() );\n    jobEntry.setAddTime( wAddTime.getSelection() );\n    jobEntry.setSpecifyFormat( wSpecifyFormat.getSelection() );\n    jobEntry.setDateTimeFormat( wDateTimeFormat.getText() );\n    jobEntry.setAddDateBeforeExtension( wAddDateBeforeExtension.getSelection() );\n\n    jobEntry.setAddMovedDate( wAddMovedDate.getSelection() );\n    jobEntry.setAddMovedTime( wAddMovedTime.getSelection() );\n    jobEntry.setSpecifyMoveFormat( wSpecifyMoveFormat.getSelection() );\n    jobEntry.setMovedDateTimeFormat( wMovedDateTimeFormat.getText() );\n    jobEntry.setAddMovedDateBeforeExtension( wAddMovedDateBeforeExtension.getSelection() );\n\n    int nritems = wFields.nrNonEmpty();\n    int nr = 0;\n    for ( int i = 0; i < nritems; i++ ) {\n      String arg = wFields.getNonEmpty( i ).getText( 1 );\n      if ( arg != null && arg.length() != 0 ) {\n        nr++;\n      }\n    }\n    jobEntry.action_type = new int[nr];\n    jobEntry.source_filefolder = new String[nr];\n    jobEntry.userid = new String[nr];\n    jobEntry.destination_filefolder = new String[nr];\n    jobEntry.wildcard = new String[nr];\n    nr = 0;\n    for ( int i = 0; i < nritems; i++ ) {\n      String action = wFields.getNonEmpty( i ).getText( 1 );\n      String source = wFields.getNonEmpty( i ).getText( 2 );\n      String wild = wFields.getNonEmpty( i ).getText( 3 );\n      String userid = wFields.getNonEmpty( i ).getText( 4 );\n      String dest = wFields.getNonEmpty( i ).getText( 5 );\n\n      if ( source != null && source.length() != 0 ) {\n        jobEntry.action_type[nr] = JobEntryPGPEncryptFiles.getActionTypeByDesc( action );\n        jobEntry.source_filefolder[nr] = source;\n        jobEntry.wildcard[nr] = wild;\n        jobEntry.userid[nr] = userid;\n        jobEntry.destination_filefolder[nr] = dest;\n        nr++;\n      }\n    }\n    dispose();\n  }","commit_id":"b641c2f73460105a960c65b1f0543bf45d255831","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public JobEntryInterface open() {\n    Shell parent = getParent();\n    Display display = parent.getDisplay();\n\n    shell = new Shell( parent, props.getJobsDialogStyle() );\n    props.setLook( shell );\n    JobDialog.setShellImage( shell, jobEntry );\n\n    ModifyListener lsMod = new ModifyListener() {\n      public void modifyText( ModifyEvent e ) {\n        jobEntry.setChanged();\n      }\n    };\n    changed = jobEntry.hasChanged();\n\n    FormLayout formLayout = new FormLayout();\n    formLayout.marginWidth = Const.FORM_MARGIN;\n    formLayout.marginHeight = Const.FORM_MARGIN;\n\n    shell.setLayout( formLayout );\n    shell.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Title\" ) );\n\n    int middle = props.getMiddlePct();\n    int margin = Const.MARGIN;\n\n    // Filename line\n    wlName = new Label( shell, SWT.RIGHT );\n    wlName.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Name.Label\" ) );\n    props.setLook( wlName );\n    fdlName = new FormData();\n    fdlName.left = new FormAttachment( 0, 0 );\n    fdlName.right = new FormAttachment( middle, -margin );\n    fdlName.top = new FormAttachment( 0, margin );\n    wlName.setLayoutData( fdlName );\n    wName = new Text( shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wName );\n    wName.addModifyListener( lsMod );\n    fdName = new FormData();\n    fdName.left = new FormAttachment( middle, 0 );\n    fdName.top = new FormAttachment( 0, margin );\n    fdName.right = new FormAttachment( 100, 0 );\n    wName.setLayoutData( fdName );\n\n    wTabFolder = new CTabFolder( shell, SWT.BORDER );\n    props.setLook( wTabFolder, Props.WIDGET_STYLE_TAB );\n\n    // ////////////////////////\n    // START OF GENERAL TAB ///\n    // ////////////////////////\n\n    wGeneralTab = new CTabItem( wTabFolder, SWT.NONE );\n    wGeneralTab.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Tab.General.Label\" ) );\n\n    wGeneralComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wGeneralComp );\n\n    FormLayout generalLayout = new FormLayout();\n    generalLayout.marginWidth = 3;\n    generalLayout.marginHeight = 3;\n    wGeneralComp.setLayout( generalLayout );\n\n    // SETTINGS grouping?\n    // ////////////////////////\n    // START OF SETTINGS GROUP\n    //\n\n    wSettings = new Group( wGeneralComp, SWT.SHADOW_NONE );\n    props.setLook( wSettings );\n    wSettings.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Settings.Label\" ) );\n\n    FormLayout groupLayout = new FormLayout();\n    groupLayout.marginWidth = 10;\n    groupLayout.marginHeight = 10;\n    wSettings.setLayout( groupLayout );\n\n    // GPG Program\n    wlGpgExe = new Label( wSettings, SWT.RIGHT );\n    wlGpgExe.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.GpgExe.Label\" ) );\n    props.setLook( wlGpgExe );\n    fdlGpgExe = new FormData();\n    fdlGpgExe.left = new FormAttachment( 0, 0 );\n    fdlGpgExe.top = new FormAttachment( wName, margin );\n    fdlGpgExe.right = new FormAttachment( middle, -margin );\n    wlGpgExe.setLayoutData( fdlGpgExe );\n\n    // Browse Source files button ...\n    wbbGpgExe = new Button( wSettings, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbbGpgExe );\n    wbbGpgExe.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.BrowseFiles.Label\" ) );\n    fdbbGpgExe = new FormData();\n    fdbbGpgExe.right = new FormAttachment( 100, -margin );\n    fdbbGpgExe.top = new FormAttachment( wName, margin );\n    wbbGpgExe.setLayoutData( fdbbGpgExe );\n\n    wbbGpgExe.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        FileDialog dialog = new FileDialog( shell, SWT.OPEN );\n        dialog.setFilterExtensions( new String[] { \"*\" } );\n        if ( wSourceFileFolder.getText() != null ) {\n          dialog.setFileName( jobMeta.environmentSubstitute( wGpgExe.getText() ) );\n        }\n        dialog.setFilterNames( FILETYPES );\n        if ( dialog.open() != null ) {\n          wGpgExe.setText( dialog.getFilterPath() + Const.FILE_SEPARATOR + dialog.getFileName() );\n        }\n      }\n    } );\n\n    wGpgExe = new TextVar( jobMeta, wSettings, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    wGpgExe.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.GpgExe.Tooltip\" ) );\n    props.setLook( wGpgExe );\n    wGpgExe.addModifyListener( lsMod );\n    fdGpgExe = new FormData();\n    fdGpgExe.left = new FormAttachment( middle, 0 );\n    fdGpgExe.top = new FormAttachment( wName, margin );\n    fdGpgExe.right = new FormAttachment( wbbGpgExe, -margin );\n    wGpgExe.setLayoutData( fdGpgExe );\n\n    wlasciiMode = new Label( wSettings, SWT.RIGHT );\n    wlasciiMode.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.asciiMode.Label\" ) );\n    props.setLook( wlasciiMode );\n    fdlasciiMode = new FormData();\n    fdlasciiMode.left = new FormAttachment( 0, 0 );\n    fdlasciiMode.top = new FormAttachment( wGpgExe, margin );\n    fdlasciiMode.right = new FormAttachment( middle, -margin );\n    wlasciiMode.setLayoutData( fdlasciiMode );\n    wasciiMode = new Button( wSettings, SWT.CHECK );\n    props.setLook( wasciiMode );\n    wasciiMode.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.asciiMode.Tooltip\" ) );\n    fdasciiMode = new FormData();\n    fdasciiMode.left = new FormAttachment( middle, 0 );\n    fdasciiMode.top = new FormAttachment( wGpgExe, margin );\n    fdasciiMode.right = new FormAttachment( 100, 0 );\n    wasciiMode.setLayoutData( fdasciiMode );\n    wasciiMode.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    wlIncludeSubfolders = new Label( wSettings, SWT.RIGHT );\n    wlIncludeSubfolders.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.IncludeSubfolders.Label\" ) );\n    props.setLook( wlIncludeSubfolders );\n    fdlIncludeSubfolders = new FormData();\n    fdlIncludeSubfolders.left = new FormAttachment( 0, 0 );\n    fdlIncludeSubfolders.top = new FormAttachment( wasciiMode, margin );\n    fdlIncludeSubfolders.right = new FormAttachment( middle, -margin );\n    wlIncludeSubfolders.setLayoutData( fdlIncludeSubfolders );\n    wIncludeSubfolders = new Button( wSettings, SWT.CHECK );\n    props.setLook( wIncludeSubfolders );\n    wIncludeSubfolders.setToolTipText( BaseMessages\n      .getString( PKG, \"JobPGPEncryptFiles.IncludeSubfolders.Tooltip\" ) );\n    fdIncludeSubfolders = new FormData();\n    fdIncludeSubfolders.left = new FormAttachment( middle, 0 );\n    fdIncludeSubfolders.top = new FormAttachment( wasciiMode, margin );\n    fdIncludeSubfolders.right = new FormAttachment( 100, 0 );\n    wIncludeSubfolders.setLayoutData( fdIncludeSubfolders );\n    wIncludeSubfolders.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        CheckIncludeSubFolders();\n      }\n    } );\n\n    // previous\n    wlPrevious = new Label( wSettings, SWT.RIGHT );\n    wlPrevious.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Previous.Label\" ) );\n    props.setLook( wlPrevious );\n    fdlPrevious = new FormData();\n    fdlPrevious.left = new FormAttachment( 0, 0 );\n    fdlPrevious.top = new FormAttachment( wIncludeSubfolders, margin );\n    fdlPrevious.right = new FormAttachment( middle, -margin );\n    wlPrevious.setLayoutData( fdlPrevious );\n    wPrevious = new Button( wSettings, SWT.CHECK );\n    props.setLook( wPrevious );\n    wPrevious.setSelection( jobEntry.arg_from_previous );\n    wPrevious.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Previous.Tooltip\" ) );\n    fdPrevious = new FormData();\n    fdPrevious.left = new FormAttachment( middle, 0 );\n    fdPrevious.top = new FormAttachment( wIncludeSubfolders, margin );\n    fdPrevious.right = new FormAttachment( 100, 0 );\n    wPrevious.setLayoutData( fdPrevious );\n    wPrevious.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n\n        RefreshArgFromPrevious();\n\n      }\n    } );\n    fdSettings = new FormData();\n    fdSettings.left = new FormAttachment( 0, margin );\n    fdSettings.top = new FormAttachment( wName, margin );\n    fdSettings.right = new FormAttachment( 100, -margin );\n    wSettings.setLayoutData( fdSettings );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF SETTINGS GROUP\n    // ///////////////////////////////////////////////////////////\n\n    // SourceFileFolder line\n    wlSourceFileFolder = new Label( wGeneralComp, SWT.RIGHT );\n    wlSourceFileFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SourceFileFolder.Label\" ) );\n    props.setLook( wlSourceFileFolder );\n    FormData fdlSourceFileFolder = new FormData();\n    fdlSourceFileFolder.left = new FormAttachment( 0, 0 );\n    fdlSourceFileFolder.top = new FormAttachment( wSettings, 2 * margin );\n    fdlSourceFileFolder.right = new FormAttachment( middle, -margin );\n    wlSourceFileFolder.setLayoutData( fdlSourceFileFolder );\n\n    // Browse Source folders button ...\n    wbSourceDirectory = new Button( wGeneralComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbSourceDirectory );\n    wbSourceDirectory.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.BrowseFolders.Label\" ) );\n    FormData fdbSourceDirectory = new FormData();\n    fdbSourceDirectory.right = new FormAttachment( 100, 0 );\n    fdbSourceDirectory.top = new FormAttachment( wSettings, margin );\n    wbSourceDirectory.setLayoutData( fdbSourceDirectory );\n\n    wbSourceDirectory.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        DirectoryDialog ddialog = new DirectoryDialog( shell, SWT.OPEN );\n        if ( wSourceFileFolder.getText() != null ) {\n          ddialog.setFilterPath( jobMeta.environmentSubstitute( wSourceFileFolder.getText() ) );\n        }\n\n        // Calling open() will open and run the dialog.\n        // It will return the selected directory, or\n        // null if user cancels\n        String dir = ddialog.open();\n        if ( dir != null ) {\n          // Set the text box to the new selection\n          wSourceFileFolder.setText( dir );\n        }\n\n      }\n    } );\n\n    // Browse Source files button ...\n    wbSourceFileFolder = new Button( wGeneralComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbSourceFileFolder );\n    wbSourceFileFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.BrowseFiles.Label\" ) );\n    FormData fdbSourceFileFolder = new FormData();\n    fdbSourceFileFolder.right = new FormAttachment( wbSourceDirectory, -margin );\n    fdbSourceFileFolder.top = new FormAttachment( wSettings, margin );\n    wbSourceFileFolder.setLayoutData( fdbSourceFileFolder );\n\n    // Browse Destination file add button ...\n    wbaSourceFileFolder = new Button( wGeneralComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbaSourceFileFolder );\n    wbaSourceFileFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.FilenameAdd.Button\" ) );\n    fdbaSourceFileFolder = new FormData();\n    fdbaSourceFileFolder.right = new FormAttachment( wbSourceFileFolder, -margin );\n    fdbaSourceFileFolder.top = new FormAttachment( wSettings, margin );\n    wbaSourceFileFolder.setLayoutData( fdbaSourceFileFolder );\n\n    wSourceFileFolder = new TextVar( jobMeta, wGeneralComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    wSourceFileFolder\n      .setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SourceFileFolder.Tooltip\" ) );\n\n    props.setLook( wSourceFileFolder );\n    wSourceFileFolder.addModifyListener( lsMod );\n    FormData fdSourceFileFolder = new FormData();\n    fdSourceFileFolder.left = new FormAttachment( middle, 0 );\n    fdSourceFileFolder.top = new FormAttachment( wSettings, 2 * margin );\n    fdSourceFileFolder.right = new FormAttachment( wbSourceFileFolder, -55 );\n    wSourceFileFolder.setLayoutData( fdSourceFileFolder );\n\n    // Whenever something changes, set the tooltip to the expanded version:\n    wSourceFileFolder.addModifyListener( new ModifyListener() {\n      public void modifyText( ModifyEvent e ) {\n        wSourceFileFolder.setToolTipText( jobMeta.environmentSubstitute( wSourceFileFolder.getText() ) );\n      }\n    } );\n\n    wbSourceFileFolder.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        FileDialog dialog = new FileDialog( shell, SWT.OPEN );\n        dialog.setFilterExtensions( new String[] { \"*\" } );\n        if ( wSourceFileFolder.getText() != null ) {\n          dialog.setFileName( jobMeta.environmentSubstitute( wSourceFileFolder.getText() ) );\n        }\n        dialog.setFilterNames( FILETYPES );\n        if ( dialog.open() != null ) {\n          wSourceFileFolder.setText( dialog.getFilterPath() + Const.FILE_SEPARATOR + dialog.getFileName() );\n        }\n      }\n    } );\n\n    // Destination\n    wlDestinationFileFolder = new Label( wGeneralComp, SWT.RIGHT );\n    wlDestinationFileFolder.setText( BaseMessages\n      .getString( PKG, \"JobPGPEncryptFiles.DestinationFileFolder.Label\" ) );\n    props.setLook( wlDestinationFileFolder );\n    fdlDestinationFileFolder = new FormData();\n    fdlDestinationFileFolder.left = new FormAttachment( 0, 0 );\n    fdlDestinationFileFolder.top = new FormAttachment( wSourceFileFolder, margin );\n    fdlDestinationFileFolder.right = new FormAttachment( middle, -margin );\n    wlDestinationFileFolder.setLayoutData( fdlDestinationFileFolder );\n\n    // Browse Destination folders button ...\n    wbDestinationDirectory = new Button( wGeneralComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbDestinationDirectory );\n    wbDestinationDirectory.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.BrowseFolders.Label\" ) );\n    FormData fdbDestinationDirectory = new FormData();\n    fdbDestinationDirectory.right = new FormAttachment( 100, 0 );\n    fdbDestinationDirectory.top = new FormAttachment( wSourceFileFolder, margin );\n    wbDestinationDirectory.setLayoutData( fdbDestinationDirectory );\n\n    wbDestinationDirectory.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        DirectoryDialog ddialog = new DirectoryDialog( shell, SWT.OPEN );\n        if ( wDestinationFileFolder.getText() != null ) {\n          ddialog.setFilterPath( jobMeta.environmentSubstitute( wDestinationFileFolder.getText() ) );\n        }\n\n        // Calling open() will open and run the dialog.\n        // It will return the selected directory, or\n        // null if user cancels\n        String dir = ddialog.open();\n        if ( dir != null ) {\n          // Set the text box to the new selection\n          wDestinationFileFolder.setText( dir );\n        }\n\n      }\n    } );\n\n    // Browse Destination file browse button ...\n    wbDestinationFileFolder = new Button( wGeneralComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbDestinationFileFolder );\n    wbDestinationFileFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.BrowseFiles.Label\" ) );\n    FormData fdbDestinationFileFolder = new FormData();\n    fdbDestinationFileFolder.right = new FormAttachment( wbDestinationDirectory, -margin );\n    fdbDestinationFileFolder.top = new FormAttachment( wSourceFileFolder, margin );\n    wbDestinationFileFolder.setLayoutData( fdbDestinationFileFolder );\n\n    wDestinationFileFolder = new TextVar( jobMeta, wGeneralComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    wDestinationFileFolder.setToolTipText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.DestinationFileFolder.Tooltip\" ) );\n    props.setLook( wDestinationFileFolder );\n    wDestinationFileFolder.addModifyListener( lsMod );\n    fdDestinationFileFolder = new FormData();\n    fdDestinationFileFolder.left = new FormAttachment( middle, 0 );\n    fdDestinationFileFolder.top = new FormAttachment( wSourceFileFolder, margin );\n    fdDestinationFileFolder.right = new FormAttachment( wbSourceFileFolder, -55 );\n    wDestinationFileFolder.setLayoutData( fdDestinationFileFolder );\n\n    wbDestinationFileFolder.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        FileDialog dialog = new FileDialog( shell, SWT.OPEN );\n        dialog.setFilterExtensions( new String[] { \"*\" } );\n        if ( wDestinationFileFolder.getText() != null ) {\n          dialog.setFileName( jobMeta.environmentSubstitute( wDestinationFileFolder.getText() ) );\n        }\n        dialog.setFilterNames( FILETYPES );\n        if ( dialog.open() != null ) {\n          wDestinationFileFolder.setText( dialog.getFilterPath() + Const.FILE_SEPARATOR + dialog.getFileName() );\n        }\n      }\n    } );\n\n    // Buttons to the right of the screen...\n    wbdSourceFileFolder = new Button( wGeneralComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbdSourceFileFolder );\n    wbdSourceFileFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.FilenameDelete.Button\" ) );\n    wbdSourceFileFolder\n      .setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.FilenameDelete.Tooltip\" ) );\n    fdbdSourceFileFolder = new FormData();\n    fdbdSourceFileFolder.right = new FormAttachment( 100, 0 );\n    fdbdSourceFileFolder.top = new FormAttachment( wDestinationFileFolder, 40 );\n    wbdSourceFileFolder.setLayoutData( fdbdSourceFileFolder );\n\n    wbeSourceFileFolder = new Button( wGeneralComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbeSourceFileFolder );\n    wbeSourceFileFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.FilenameEdit.Button\" ) );\n    wbeSourceFileFolder.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.FilenameEdit.Tooltip\" ) );\n    fdbeSourceFileFolder = new FormData();\n    fdbeSourceFileFolder.right = new FormAttachment( 100, 0 );\n    fdbeSourceFileFolder.left = new FormAttachment( wbdSourceFileFolder, 0, SWT.LEFT );\n    fdbeSourceFileFolder.top = new FormAttachment( wbdSourceFileFolder, margin );\n    wbeSourceFileFolder.setLayoutData( fdbeSourceFileFolder );\n\n    // Wildcard\n    wlWildcard = new Label( wGeneralComp, SWT.RIGHT );\n    wlWildcard.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Wildcard.Label\" ) );\n    props.setLook( wlWildcard );\n    fdlWildcard = new FormData();\n    fdlWildcard.left = new FormAttachment( 0, 0 );\n    fdlWildcard.top = new FormAttachment( wDestinationFileFolder, margin );\n    fdlWildcard.right = new FormAttachment( middle, -margin );\n    wlWildcard.setLayoutData( fdlWildcard );\n\n    wWildcard = new TextVar( jobMeta, wGeneralComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    wWildcard.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Wildcard.Tooltip\" ) );\n    props.setLook( wWildcard );\n    wWildcard.addModifyListener( lsMod );\n    fdWildcard = new FormData();\n    fdWildcard.left = new FormAttachment( middle, 0 );\n    fdWildcard.top = new FormAttachment( wDestinationFileFolder, margin );\n    fdWildcard.right = new FormAttachment( wbSourceFileFolder, -55 );\n    wWildcard.setLayoutData( fdWildcard );\n\n    wlFields = new Label( wGeneralComp, SWT.NONE );\n    wlFields.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.Label\" ) );\n    props.setLook( wlFields );\n    fdlFields = new FormData();\n    fdlFields.left = new FormAttachment( 0, 0 );\n    fdlFields.right = new FormAttachment( middle, -margin );\n    fdlFields.top = new FormAttachment( wWildcard, margin );\n    wlFields.setLayoutData( fdlFields );\n\n    int rows =\n      jobEntry.source_filefolder == null ? 1 : ( jobEntry.source_filefolder.length == 0\n        ? 0 : jobEntry.source_filefolder.length );\n    final int FieldsRows = rows;\n\n    ColumnInfo[] colinf =\n      new ColumnInfo[] {\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.Action.Label\" ),\n          ColumnInfo.COLUMN_TYPE_CCOMBO, JobEntryPGPEncryptFiles.actionTypeDesc, false ),\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.SourceFileFolder.Label\" ),\n          ColumnInfo.COLUMN_TYPE_TEXT, false ),\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.Wildcard.Label\" ),\n          ColumnInfo.COLUMN_TYPE_TEXT, false ),\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.UserID.Label\" ),\n          ColumnInfo.COLUMN_TYPE_TEXT, false ),\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.DestinationFileFolder.Label\" ),\n          ColumnInfo.COLUMN_TYPE_TEXT, false ), };\n\n    colinf[0].setUsingVariables( true );\n    colinf[0].setToolTip( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.SourceFileFolder.Tooltip\" ) );\n    colinf[1].setUsingVariables( true );\n    colinf[1].setToolTip( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.Wildcard.Tooltip\" ) );\n\n    colinf[2].setUsingVariables( true );\n    colinf[2].setToolTip( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.UserID.Tooltip\" ) );\n    colinf[3].setUsingVariables( true );\n    colinf[3]\n      .setToolTip( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.DestinationFileFolder.Tooltip\" ) );\n\n    wFields =\n      new TableView(\n        jobMeta, wGeneralComp, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, colinf, FieldsRows, lsMod, props );\n\n    fdFields = new FormData();\n    fdFields.left = new FormAttachment( 0, 0 );\n    fdFields.top = new FormAttachment( wlFields, margin );\n    fdFields.right = new FormAttachment( wbeSourceFileFolder, -margin );\n    fdFields.bottom = new FormAttachment( 100, -margin );\n    wFields.setLayoutData( fdFields );\n\n    RefreshArgFromPrevious();\n\n    // Add the file to the list of files...\n    SelectionAdapter selA = new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent arg0 ) {\n        wFields.add( new String[] {\n          JobEntryPGPEncryptFiles.actionTypeDesc[0], wSourceFileFolder.getText(), wWildcard.getText(), null,\n          wDestinationFileFolder.getText() } );\n        wSourceFileFolder.setText( \"\" );\n        wDestinationFileFolder.setText( \"\" );\n        wWildcard.setText( \"\" );\n        wFields.removeEmptyRows();\n        wFields.setRowNums();\n        wFields.optWidth( true );\n      }\n    };\n    wbaSourceFileFolder.addSelectionListener( selA );\n    wSourceFileFolder.addSelectionListener( selA );\n\n    // Delete files from the list of files...\n    wbdSourceFileFolder.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent arg0 ) {\n        int[] idx = wFields.getSelectionIndices();\n        wFields.remove( idx );\n        wFields.removeEmptyRows();\n        wFields.setRowNums();\n      }\n    } );\n\n    // Edit the selected file & remove from the list...\n    wbeSourceFileFolder.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent arg0 ) {\n        int idx = wFields.getSelectionIndex();\n        if ( idx >= 0 ) {\n          String[] string = wFields.getItem( idx );\n          wSourceFileFolder.setText( string[0] );\n          wDestinationFileFolder.setText( string[1] );\n          wWildcard.setText( string[2] );\n          wFields.remove( idx );\n        }\n        wFields.removeEmptyRows();\n        wFields.setRowNums();\n      }\n    } );\n\n    fdGeneralComp = new FormData();\n    fdGeneralComp.left = new FormAttachment( 0, 0 );\n    fdGeneralComp.top = new FormAttachment( 0, 0 );\n    fdGeneralComp.right = new FormAttachment( 100, 0 );\n    fdGeneralComp.bottom = new FormAttachment( 100, 0 );\n    wGeneralComp.setLayoutData( fdGeneralComp );\n\n    wGeneralComp.layout();\n    wGeneralTab.setControl( wGeneralComp );\n    props.setLook( wGeneralComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF GENERAL TAB\n    // ///////////////////////////////////////////////////////////\n\n    // ////////////////////////////////////\n    // START OF DESTINATION FILE TAB ///\n    // ///////////////////////////////////\n\n    wDestinationFileTab = new CTabItem( wTabFolder, SWT.NONE );\n    wDestinationFileTab.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.DestinationFileTab.Label\" ) );\n\n    FormLayout DestcontentLayout = new FormLayout();\n    DestcontentLayout.marginWidth = 3;\n    DestcontentLayout.marginHeight = 3;\n\n    wDestinationFileComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wDestinationFileComp );\n    wDestinationFileComp.setLayout( DestcontentLayout );\n\n    // DestinationFile grouping?\n    // ////////////////////////\n    // START OF DestinationFile GROUP\n    //\n\n    wDestinationFile = new Group( wDestinationFileComp, SWT.SHADOW_NONE );\n    props.setLook( wDestinationFile );\n    wDestinationFile.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.GroupDestinationFile.Label\" ) );\n\n    FormLayout groupLayoutFile = new FormLayout();\n    groupLayoutFile.marginWidth = 10;\n    groupLayoutFile.marginHeight = 10;\n    wDestinationFile.setLayout( groupLayoutFile );\n\n    // Create destination folder/parent folder\n    wlCreateDestinationFolder = new Label( wDestinationFile, SWT.RIGHT );\n    wlCreateDestinationFolder.setText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.CreateDestinationFolder.Label\" ) );\n    props.setLook( wlCreateDestinationFolder );\n    fdlCreateDestinationFolder = new FormData();\n    fdlCreateDestinationFolder.left = new FormAttachment( 0, 0 );\n    fdlCreateDestinationFolder.top = new FormAttachment( 0, margin );\n    fdlCreateDestinationFolder.right = new FormAttachment( middle, -margin );\n    wlCreateDestinationFolder.setLayoutData( fdlCreateDestinationFolder );\n    wCreateDestinationFolder = new Button( wDestinationFile, SWT.CHECK );\n    props.setLook( wCreateDestinationFolder );\n    wCreateDestinationFolder.setToolTipText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.CreateDestinationFolder.Tooltip\" ) );\n    fdCreateDestinationFolder = new FormData();\n    fdCreateDestinationFolder.left = new FormAttachment( middle, 0 );\n    fdCreateDestinationFolder.top = new FormAttachment( 0, margin );\n    fdCreateDestinationFolder.right = new FormAttachment( 100, 0 );\n    wCreateDestinationFolder.setLayoutData( fdCreateDestinationFolder );\n    wCreateDestinationFolder.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Destination is a file?\n    wlDestinationIsAFile = new Label( wDestinationFile, SWT.RIGHT );\n    wlDestinationIsAFile.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.DestinationIsAFile.Label\" ) );\n    props.setLook( wlDestinationIsAFile );\n    fdlDestinationIsAFile = new FormData();\n    fdlDestinationIsAFile.left = new FormAttachment( 0, 0 );\n    fdlDestinationIsAFile.top = new FormAttachment( wCreateDestinationFolder, margin );\n    fdlDestinationIsAFile.right = new FormAttachment( middle, -margin );\n    wlDestinationIsAFile.setLayoutData( fdlDestinationIsAFile );\n    wDestinationIsAFile = new Button( wDestinationFile, SWT.CHECK );\n    props.setLook( wDestinationIsAFile );\n    wDestinationIsAFile.setToolTipText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.DestinationIsAFile.Tooltip\" ) );\n    fdDestinationIsAFile = new FormData();\n    fdDestinationIsAFile.left = new FormAttachment( middle, 0 );\n    fdDestinationIsAFile.top = new FormAttachment( wCreateDestinationFolder, margin );\n    fdDestinationIsAFile.right = new FormAttachment( 100, 0 );\n    wDestinationIsAFile.setLayoutData( fdDestinationIsAFile );\n    wDestinationIsAFile.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Do not keep folder structure?\n    wlDoNotKeepFolderStructure = new Label( wDestinationFile, SWT.RIGHT );\n    wlDoNotKeepFolderStructure.setText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.DoNotKeepFolderStructure.Label\" ) );\n    props.setLook( wlDoNotKeepFolderStructure );\n    fdlDoNotKeepFolderStructure = new FormData();\n    fdlDoNotKeepFolderStructure.left = new FormAttachment( 0, 0 );\n    fdlDoNotKeepFolderStructure.top = new FormAttachment( wDestinationIsAFile, margin );\n    fdlDoNotKeepFolderStructure.right = new FormAttachment( middle, -margin );\n    wlDoNotKeepFolderStructure.setLayoutData( fdlDoNotKeepFolderStructure );\n    wDoNotKeepFolderStructure = new Button( wDestinationFile, SWT.CHECK );\n    props.setLook( wDoNotKeepFolderStructure );\n    wDoNotKeepFolderStructure.setToolTipText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.DoNotKeepFolderStructure.Tooltip\" ) );\n    fdDoNotKeepFolderStructure = new FormData();\n    fdDoNotKeepFolderStructure.left = new FormAttachment( middle, 0 );\n    fdDoNotKeepFolderStructure.top = new FormAttachment( wDestinationIsAFile, margin );\n    fdDoNotKeepFolderStructure.right = new FormAttachment( 100, 0 );\n    wDoNotKeepFolderStructure.setLayoutData( fdDoNotKeepFolderStructure );\n    wDoNotKeepFolderStructure.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Create multi-part file?\n    wlAddDate = new Label( wDestinationFile, SWT.RIGHT );\n    wlAddDate.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddDate.Label\" ) );\n    props.setLook( wlAddDate );\n    fdlAddDate = new FormData();\n    fdlAddDate.left = new FormAttachment( 0, 0 );\n    fdlAddDate.top = new FormAttachment( wDoNotKeepFolderStructure, margin );\n    fdlAddDate.right = new FormAttachment( middle, -margin );\n    wlAddDate.setLayoutData( fdlAddDate );\n    wAddDate = new Button( wDestinationFile, SWT.CHECK );\n    props.setLook( wAddDate );\n    wAddDate.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddDate.Tooltip\" ) );\n    fdAddDate = new FormData();\n    fdAddDate.left = new FormAttachment( middle, 0 );\n    fdAddDate.top = new FormAttachment( wDoNotKeepFolderStructure, margin );\n    fdAddDate.right = new FormAttachment( 100, 0 );\n    wAddDate.setLayoutData( fdAddDate );\n    wAddDate.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        setAddDateBeforeExtension();\n      }\n    } );\n    // Create multi-part file?\n    wlAddTime = new Label( wDestinationFile, SWT.RIGHT );\n    wlAddTime.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddTime.Label\" ) );\n    props.setLook( wlAddTime );\n    fdlAddTime = new FormData();\n    fdlAddTime.left = new FormAttachment( 0, 0 );\n    fdlAddTime.top = new FormAttachment( wAddDate, margin );\n    fdlAddTime.right = new FormAttachment( middle, -margin );\n    wlAddTime.setLayoutData( fdlAddTime );\n    wAddTime = new Button( wDestinationFile, SWT.CHECK );\n    props.setLook( wAddTime );\n    wAddTime.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddTime.Tooltip\" ) );\n    fdAddTime = new FormData();\n    fdAddTime.left = new FormAttachment( middle, 0 );\n    fdAddTime.top = new FormAttachment( wAddDate, margin );\n    fdAddTime.right = new FormAttachment( 100, 0 );\n    wAddTime.setLayoutData( fdAddTime );\n    wAddTime.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        setAddDateBeforeExtension();\n      }\n    } );\n\n    // Specify date time format?\n    wlSpecifyFormat = new Label( wDestinationFile, SWT.RIGHT );\n    wlSpecifyFormat.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SpecifyFormat.Label\" ) );\n    props.setLook( wlSpecifyFormat );\n    fdlSpecifyFormat = new FormData();\n    fdlSpecifyFormat.left = new FormAttachment( 0, 0 );\n    fdlSpecifyFormat.top = new FormAttachment( wAddTime, margin );\n    fdlSpecifyFormat.right = new FormAttachment( middle, -margin );\n    wlSpecifyFormat.setLayoutData( fdlSpecifyFormat );\n    wSpecifyFormat = new Button( wDestinationFile, SWT.CHECK );\n    props.setLook( wSpecifyFormat );\n    wSpecifyFormat.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SpecifyFormat.Tooltip\" ) );\n    fdSpecifyFormat = new FormData();\n    fdSpecifyFormat.left = new FormAttachment( middle, 0 );\n    fdSpecifyFormat.top = new FormAttachment( wAddTime, margin );\n    fdSpecifyFormat.right = new FormAttachment( 100, 0 );\n    wSpecifyFormat.setLayoutData( fdSpecifyFormat );\n    wSpecifyFormat.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        setDateTimeFormat();\n        setAddDateBeforeExtension();\n      }\n    } );\n\n    // DateTimeFormat\n    wlDateTimeFormat = new Label( wDestinationFile, SWT.RIGHT );\n    wlDateTimeFormat.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.DateTimeFormat.Label\" ) );\n    props.setLook( wlDateTimeFormat );\n    fdlDateTimeFormat = new FormData();\n    fdlDateTimeFormat.left = new FormAttachment( 0, 0 );\n    fdlDateTimeFormat.top = new FormAttachment( wSpecifyFormat, margin );\n    fdlDateTimeFormat.right = new FormAttachment( middle, -margin );\n    wlDateTimeFormat.setLayoutData( fdlDateTimeFormat );\n    wDateTimeFormat = new CCombo( wDestinationFile, SWT.BORDER | SWT.READ_ONLY );\n    wDateTimeFormat.setEditable( true );\n    props.setLook( wDateTimeFormat );\n    wDateTimeFormat.addModifyListener( lsMod );\n    fdDateTimeFormat = new FormData();\n    fdDateTimeFormat.left = new FormAttachment( middle, 0 );\n    fdDateTimeFormat.top = new FormAttachment( wSpecifyFormat, margin );\n    fdDateTimeFormat.right = new FormAttachment( 100, 0 );\n    wDateTimeFormat.setLayoutData( fdDateTimeFormat );\n    // Prepare a list of possible DateTimeFormats...\n    String[] dats = Const.getDateFormats();\n    for ( int x = 0; x < dats.length; x++ ) {\n      wDateTimeFormat.add( dats[x] );\n    }\n\n    // Add Date before extension?\n    wlAddDateBeforeExtension = new Label( wDestinationFile, SWT.RIGHT );\n    wlAddDateBeforeExtension.setText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.AddDateBeforeExtension.Label\" ) );\n    props.setLook( wlAddDateBeforeExtension );\n    fdlAddDateBeforeExtension = new FormData();\n    fdlAddDateBeforeExtension.left = new FormAttachment( 0, 0 );\n    fdlAddDateBeforeExtension.top = new FormAttachment( wDateTimeFormat, margin );\n    fdlAddDateBeforeExtension.right = new FormAttachment( middle, -margin );\n    wlAddDateBeforeExtension.setLayoutData( fdlAddDateBeforeExtension );\n    wAddDateBeforeExtension = new Button( wDestinationFile, SWT.CHECK );\n    props.setLook( wAddDateBeforeExtension );\n    wAddDateBeforeExtension.setToolTipText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.AddDateBeforeExtension.Tooltip\" ) );\n    fdAddDateBeforeExtension = new FormData();\n    fdAddDateBeforeExtension.left = new FormAttachment( middle, 0 );\n    fdAddDateBeforeExtension.top = new FormAttachment( wDateTimeFormat, margin );\n    fdAddDateBeforeExtension.right = new FormAttachment( 100, 0 );\n    wAddDateBeforeExtension.setLayoutData( fdAddDateBeforeExtension );\n    wAddDateBeforeExtension.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // If File Exists\n    wlIfFileExists = new Label( wDestinationFile, SWT.RIGHT );\n    wlIfFileExists.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.IfFileExists.Label\" ) );\n    props.setLook( wlIfFileExists );\n    fdlIfFileExists = new FormData();\n    fdlIfFileExists.left = new FormAttachment( 0, 0 );\n    fdlIfFileExists.right = new FormAttachment( middle, 0 );\n    fdlIfFileExists.top = new FormAttachment( wAddDateBeforeExtension, margin );\n    wlIfFileExists.setLayoutData( fdlIfFileExists );\n    wIfFileExists = new CCombo( wDestinationFile, SWT.SINGLE | SWT.READ_ONLY | SWT.BORDER );\n    wIfFileExists.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Do_Nothing_IfFileExists.Label\" ) );\n    wIfFileExists.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Overwrite_File_IfFileExists.Label\" ) );\n    wIfFileExists.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Unique_Name_IfFileExists.Label\" ) );\n    wIfFileExists.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Delete_Source_File_IfFileExists.Label\" ) );\n    wIfFileExists.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Move_To_Folder_IfFileExists.Label\" ) );\n    wIfFileExists.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fail_IfFileExists.Label\" ) );\n    wIfFileExists.select( 0 ); // +1: starts at -1\n\n    props.setLook( wIfFileExists );\n    fdIfFileExists = new FormData();\n    fdIfFileExists.left = new FormAttachment( middle, 0 );\n    fdIfFileExists.top = new FormAttachment( wAddDateBeforeExtension, margin );\n    fdIfFileExists.right = new FormAttachment( 100, 0 );\n    wIfFileExists.setLayoutData( fdIfFileExists );\n\n    wIfFileExists.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n\n        activeDestinationFolder();\n        setMovedDateTimeFormat();\n        // setAddDateBeforeExtension();\n        setAddMovedDateBeforeExtension();\n\n      }\n    } );\n\n    fdDestinationFile = new FormData();\n    fdDestinationFile.left = new FormAttachment( 0, margin );\n    fdDestinationFile.top = new FormAttachment( wName, margin );\n    fdDestinationFile.right = new FormAttachment( 100, -margin );\n    wDestinationFile.setLayoutData( fdDestinationFile );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF DestinationFile GROUP\n    // ///////////////////////////////////////////////////////////\n\n    // MoveTo grouping?\n    // ////////////////////////\n    // START OF MoveTo GROUP\n    //\n\n    wMoveToGroup = new Group( wDestinationFileComp, SWT.SHADOW_NONE );\n    props.setLook( wMoveToGroup );\n    wMoveToGroup.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.GroupMoveToGroup.Label\" ) );\n\n    FormLayout MovetoLayoutFile = new FormLayout();\n    MovetoLayoutFile.marginWidth = 10;\n    MovetoLayoutFile.marginHeight = 10;\n    wMoveToGroup.setLayout( MovetoLayoutFile );\n\n    // DestinationFolder line\n    wlDestinationFolder = new Label( wMoveToGroup, SWT.RIGHT );\n    wlDestinationFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.DestinationFolder.Label\" ) );\n    props.setLook( wlDestinationFolder );\n    fdlDestinationFolder = new FormData();\n    fdlDestinationFolder.left = new FormAttachment( 0, 0 );\n    fdlDestinationFolder.top = new FormAttachment( wDestinationFile, margin );\n    fdlDestinationFolder.right = new FormAttachment( middle, -margin );\n    wlDestinationFolder.setLayoutData( fdlDestinationFolder );\n\n    wbDestinationFolder = new Button( wMoveToGroup, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbDestinationFolder );\n    wbDestinationFolder.setText( BaseMessages.getString( PKG, \"System.Button.Browse\" ) );\n    fdbDestinationFolder = new FormData();\n    fdbDestinationFolder.right = new FormAttachment( 100, 0 );\n    fdbDestinationFolder.top = new FormAttachment( wDestinationFile, 0 );\n    wbDestinationFolder.setLayoutData( fdbDestinationFolder );\n\n    wDestinationFolder = new TextVar( jobMeta, wMoveToGroup, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wDestinationFolder );\n    wDestinationFolder.addModifyListener( lsMod );\n    fdDestinationFolder = new FormData();\n    fdDestinationFolder.left = new FormAttachment( middle, 0 );\n    fdDestinationFolder.top = new FormAttachment( wDestinationFile, margin );\n    fdDestinationFolder.right = new FormAttachment( wbDestinationFolder, -margin );\n    wDestinationFolder.setLayoutData( fdDestinationFolder );\n\n    // Whenever something changes, set the tooltip to the expanded version:\n    wDestinationFolder.addModifyListener( new ModifyListener() {\n      public void modifyText( ModifyEvent e ) {\n        wDestinationFolder.setToolTipText( jobMeta.environmentSubstitute( wDestinationFolder.getText() ) );\n      }\n    } );\n\n    wbDestinationFolder.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        DirectoryDialog dialog = new DirectoryDialog( shell, SWT.OPEN );\n        if ( wDestinationFolder.getText() != null ) {\n          dialog.setFilterPath( jobMeta.environmentSubstitute( wDestinationFolder.getText() ) );\n        }\n\n        String dir = dialog.open();\n        if ( dir != null ) {\n          wDestinationFolder.setText( dir );\n        }\n      }\n    } );\n\n    // Create destination folder/parent folder\n    wlCreateMoveToFolder = new Label( wMoveToGroup, SWT.RIGHT );\n    wlCreateMoveToFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.CreateMoveToFolder.Label\" ) );\n    props.setLook( wlCreateMoveToFolder );\n    fdlCreateMoveToFolder = new FormData();\n    fdlCreateMoveToFolder.left = new FormAttachment( 0, 0 );\n    fdlCreateMoveToFolder.top = new FormAttachment( wDestinationFolder, margin );\n    fdlCreateMoveToFolder.right = new FormAttachment( middle, -margin );\n    wlCreateMoveToFolder.setLayoutData( fdlCreateMoveToFolder );\n    wCreateMoveToFolder = new Button( wMoveToGroup, SWT.CHECK );\n    props.setLook( wCreateMoveToFolder );\n    wCreateMoveToFolder.setToolTipText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.CreateMoveToFolder.Tooltip\" ) );\n    fdCreateMoveToFolder = new FormData();\n    fdCreateMoveToFolder.left = new FormAttachment( middle, 0 );\n    fdCreateMoveToFolder.top = new FormAttachment( wDestinationFolder, margin );\n    fdCreateMoveToFolder.right = new FormAttachment( 100, 0 );\n    wCreateMoveToFolder.setLayoutData( fdCreateMoveToFolder );\n    wCreateMoveToFolder.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Create multi-part file?\n    wlAddMovedDate = new Label( wMoveToGroup, SWT.RIGHT );\n    wlAddMovedDate.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddMovedDate.Label\" ) );\n    props.setLook( wlAddMovedDate );\n    fdlAddMovedDate = new FormData();\n    fdlAddMovedDate.left = new FormAttachment( 0, 0 );\n    fdlAddMovedDate.top = new FormAttachment( wCreateMoveToFolder, margin );\n    fdlAddMovedDate.right = new FormAttachment( middle, -margin );\n    wlAddMovedDate.setLayoutData( fdlAddMovedDate );\n    wAddMovedDate = new Button( wMoveToGroup, SWT.CHECK );\n    props.setLook( wAddMovedDate );\n    wAddMovedDate.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddMovedDate.Tooltip\" ) );\n    fdAddMovedDate = new FormData();\n    fdAddMovedDate.left = new FormAttachment( middle, 0 );\n    fdAddMovedDate.top = new FormAttachment( wCreateMoveToFolder, margin );\n    fdAddMovedDate.right = new FormAttachment( 100, 0 );\n    wAddMovedDate.setLayoutData( fdAddMovedDate );\n    wAddMovedDate.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        setAddMovedDateBeforeExtension();\n      }\n    } );\n    // Create multi-part file?\n    wlAddMovedTime = new Label( wMoveToGroup, SWT.RIGHT );\n    wlAddMovedTime.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddMovedTime.Label\" ) );\n    props.setLook( wlAddMovedTime );\n    fdlAddMovedTime = new FormData();\n    fdlAddMovedTime.left = new FormAttachment( 0, 0 );\n    fdlAddMovedTime.top = new FormAttachment( wAddMovedDate, margin );\n    fdlAddMovedTime.right = new FormAttachment( middle, -margin );\n    wlAddMovedTime.setLayoutData( fdlAddMovedTime );\n    wAddMovedTime = new Button( wMoveToGroup, SWT.CHECK );\n    props.setLook( wAddMovedTime );\n    wAddMovedTime.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddMovedTime.Tooltip\" ) );\n    fdAddMovedTime = new FormData();\n    fdAddMovedTime.left = new FormAttachment( middle, 0 );\n    fdAddMovedTime.top = new FormAttachment( wAddMovedDate, margin );\n    fdAddMovedTime.right = new FormAttachment( 100, 0 );\n    wAddMovedTime.setLayoutData( fdAddMovedTime );\n    wAddMovedTime.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        setAddMovedDateBeforeExtension();\n      }\n    } );\n\n    // Specify date time format?\n    wlSpecifyMoveFormat = new Label( wMoveToGroup, SWT.RIGHT );\n    wlSpecifyMoveFormat.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SpecifyMoveFormat.Label\" ) );\n    props.setLook( wlSpecifyMoveFormat );\n    fdlSpecifyMoveFormat = new FormData();\n    fdlSpecifyMoveFormat.left = new FormAttachment( 0, 0 );\n    fdlSpecifyMoveFormat.top = new FormAttachment( wAddMovedTime, margin );\n    fdlSpecifyMoveFormat.right = new FormAttachment( middle, -margin );\n    wlSpecifyMoveFormat.setLayoutData( fdlSpecifyMoveFormat );\n    wSpecifyMoveFormat = new Button( wMoveToGroup, SWT.CHECK );\n    props.setLook( wSpecifyMoveFormat );\n    wSpecifyMoveFormat.setToolTipText( BaseMessages\n      .getString( PKG, \"JobPGPEncryptFiles.SpecifyMoveFormat.Tooltip\" ) );\n    fdSpecifyMoveFormat = new FormData();\n    fdSpecifyMoveFormat.left = new FormAttachment( middle, 0 );\n    fdSpecifyMoveFormat.top = new FormAttachment( wAddMovedTime, margin );\n    fdSpecifyMoveFormat.right = new FormAttachment( 100, 0 );\n    wSpecifyMoveFormat.setLayoutData( fdSpecifyMoveFormat );\n    wSpecifyMoveFormat.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        setMovedDateTimeFormat();\n        setAddMovedDateBeforeExtension();\n      }\n    } );\n\n    // Moved DateTimeFormat\n    wlMovedDateTimeFormat = new Label( wMoveToGroup, SWT.RIGHT );\n    wlMovedDateTimeFormat.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.MovedDateTimeFormat.Label\" ) );\n    props.setLook( wlMovedDateTimeFormat );\n    fdlMovedDateTimeFormat = new FormData();\n    fdlMovedDateTimeFormat.left = new FormAttachment( 0, 0 );\n    fdlMovedDateTimeFormat.top = new FormAttachment( wSpecifyMoveFormat, margin );\n    fdlMovedDateTimeFormat.right = new FormAttachment( middle, -margin );\n    wlMovedDateTimeFormat.setLayoutData( fdlMovedDateTimeFormat );\n    wMovedDateTimeFormat = new CCombo( wMoveToGroup, SWT.BORDER | SWT.READ_ONLY );\n    wMovedDateTimeFormat.setEditable( true );\n    props.setLook( wMovedDateTimeFormat );\n    wMovedDateTimeFormat.addModifyListener( lsMod );\n    fdMovedDateTimeFormat = new FormData();\n    fdMovedDateTimeFormat.left = new FormAttachment( middle, 0 );\n    fdMovedDateTimeFormat.top = new FormAttachment( wSpecifyMoveFormat, margin );\n    fdMovedDateTimeFormat.right = new FormAttachment( 100, 0 );\n    wMovedDateTimeFormat.setLayoutData( fdMovedDateTimeFormat );\n\n    for ( int x = 0; x < dats.length; x++ ) {\n      wMovedDateTimeFormat.add( dats[x] );\n    }\n\n    // Add Date before extension?\n    wlAddMovedDateBeforeExtension = new Label( wMoveToGroup, SWT.RIGHT );\n    wlAddMovedDateBeforeExtension.setText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.AddMovedDateBeforeExtension.Label\" ) );\n    props.setLook( wlAddMovedDateBeforeExtension );\n    fdlAddMovedDateBeforeExtension = new FormData();\n    fdlAddMovedDateBeforeExtension.left = new FormAttachment( 0, 0 );\n    fdlAddMovedDateBeforeExtension.top = new FormAttachment( wMovedDateTimeFormat, margin );\n    fdlAddMovedDateBeforeExtension.right = new FormAttachment( middle, -margin );\n    wlAddMovedDateBeforeExtension.setLayoutData( fdlAddMovedDateBeforeExtension );\n    wAddMovedDateBeforeExtension = new Button( wMoveToGroup, SWT.CHECK );\n    props.setLook( wAddMovedDateBeforeExtension );\n    wAddMovedDateBeforeExtension.setToolTipText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.AddMovedDateBeforeExtension.Tooltip\" ) );\n    fdAddMovedDateBeforeExtension = new FormData();\n    fdAddMovedDateBeforeExtension.left = new FormAttachment( middle, 0 );\n    fdAddMovedDateBeforeExtension.top = new FormAttachment( wMovedDateTimeFormat, margin );\n    fdAddMovedDateBeforeExtension.right = new FormAttachment( 100, 0 );\n    wAddMovedDateBeforeExtension.setLayoutData( fdAddMovedDateBeforeExtension );\n    wAddMovedDateBeforeExtension.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // If moved File Exists\n    wlIfMovedFileExists = new Label( wMoveToGroup, SWT.RIGHT );\n    wlIfMovedFileExists.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.IfMovedFileExists.Label\" ) );\n    props.setLook( wlIfMovedFileExists );\n    fdlIfMovedFileExists = new FormData();\n    fdlIfMovedFileExists.left = new FormAttachment( 0, 0 );\n    fdlIfMovedFileExists.right = new FormAttachment( middle, 0 );\n    fdlIfMovedFileExists.top = new FormAttachment( wAddMovedDateBeforeExtension, margin );\n    wlIfMovedFileExists.setLayoutData( fdlIfMovedFileExists );\n    wIfMovedFileExists = new CCombo( wMoveToGroup, SWT.SINGLE | SWT.READ_ONLY | SWT.BORDER );\n    wIfMovedFileExists\n      .add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Do_Nothing_IfMovedFileExists.Label\" ) );\n    wIfMovedFileExists.add( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.Overwrite_Filename_IffMovedFileExists.Label\" ) );\n    wIfMovedFileExists\n      .add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.UniqueName_IfMovedFileExists.Label\" ) );\n    wIfMovedFileExists.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fail_IfMovedFileExists.Label\" ) );\n    wIfMovedFileExists.select( 0 ); // +1: starts at -1\n\n    props.setLook( wIfMovedFileExists );\n    fdIfMovedFileExists = new FormData();\n    fdIfMovedFileExists.left = new FormAttachment( middle, 0 );\n    fdIfMovedFileExists.top = new FormAttachment( wAddMovedDateBeforeExtension, margin );\n    fdIfMovedFileExists.right = new FormAttachment( 100, 0 );\n    wIfMovedFileExists.setLayoutData( fdIfMovedFileExists );\n\n    fdIfMovedFileExists = new FormData();\n    fdIfMovedFileExists.left = new FormAttachment( middle, 0 );\n    fdIfMovedFileExists.top = new FormAttachment( wAddMovedDateBeforeExtension, margin );\n    fdIfMovedFileExists.right = new FormAttachment( 100, 0 );\n    wIfMovedFileExists.setLayoutData( fdIfMovedFileExists );\n\n    fdMoveToGroup = new FormData();\n    fdMoveToGroup.left = new FormAttachment( 0, margin );\n    fdMoveToGroup.top = new FormAttachment( wDestinationFile, margin );\n    fdMoveToGroup.right = new FormAttachment( 100, -margin );\n    wMoveToGroup.setLayoutData( fdMoveToGroup );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF MoveToGroup GROUP\n    // ///////////////////////////////////////////////////////////\n\n    fdDestinationFileComp = new FormData();\n    fdDestinationFileComp.left = new FormAttachment( 0, 0 );\n    fdDestinationFileComp.top = new FormAttachment( 0, 0 );\n    fdDestinationFileComp.right = new FormAttachment( 100, 0 );\n    fdDestinationFileComp.bottom = new FormAttachment( 100, 0 );\n    wDestinationFileComp.setLayoutData( wDestinationFileComp );\n\n    wDestinationFileComp.layout();\n    wDestinationFileTab.setControl( wDestinationFileComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF DESTINATION FILETAB\n    // ///////////////////////////////////////////////////////////\n\n    // ////////////////////////////////////\n    // START OF ADVANCED TAB ///\n    // ///////////////////////////////////\n\n    wAdvancedTab = new CTabItem( wTabFolder, SWT.NONE );\n    wAdvancedTab.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Tab.Advanced.Label\" ) );\n\n    FormLayout contentLayout = new FormLayout();\n    contentLayout.marginWidth = 3;\n    contentLayout.marginHeight = 3;\n\n    wAdvancedComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wAdvancedComp );\n    wAdvancedComp.setLayout( contentLayout );\n\n    // SuccessOngrouping?\n    // ////////////////////////\n    // START OF SUCCESS ON GROUP///\n    // /\n    wSuccessOn = new Group( wAdvancedComp, SWT.SHADOW_NONE );\n    props.setLook( wSuccessOn );\n    wSuccessOn.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SuccessOn.Group.Label\" ) );\n\n    FormLayout successongroupLayout = new FormLayout();\n    successongroupLayout.marginWidth = 10;\n    successongroupLayout.marginHeight = 10;\n\n    wSuccessOn.setLayout( successongroupLayout );\n\n    // Success Condition\n    wlSuccessCondition = new Label( wSuccessOn, SWT.RIGHT );\n    wlSuccessCondition.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SuccessCondition.Label\" ) );\n    props.setLook( wlSuccessCondition );\n    fdlSuccessCondition = new FormData();\n    fdlSuccessCondition.left = new FormAttachment( 0, 0 );\n    fdlSuccessCondition.right = new FormAttachment( middle, 0 );\n    fdlSuccessCondition.top = new FormAttachment( 0, margin );\n    wlSuccessCondition.setLayoutData( fdlSuccessCondition );\n    wSuccessCondition = new CCombo( wSuccessOn, SWT.SINGLE | SWT.READ_ONLY | SWT.BORDER );\n    wSuccessCondition.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SuccessWhenAllWorksFine.Label\" ) );\n    wSuccessCondition.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SuccessWhenAtLeat.Label\" ) );\n    wSuccessCondition.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SuccessWhenErrorsLessThan.Label\" ) );\n\n    wSuccessCondition.select( 0 ); // +1: starts at -1\n\n    props.setLook( wSuccessCondition );\n    fdSuccessCondition = new FormData();\n    fdSuccessCondition.left = new FormAttachment( middle, 0 );\n    fdSuccessCondition.top = new FormAttachment( 0, margin );\n    fdSuccessCondition.right = new FormAttachment( 100, 0 );\n    wSuccessCondition.setLayoutData( fdSuccessCondition );\n    wSuccessCondition.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        activeSuccessCondition();\n\n      }\n    } );\n\n    // Success when number of errors less than\n    wlNrErrorsLessThan = new Label( wSuccessOn, SWT.RIGHT );\n    wlNrErrorsLessThan.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.NrErrorsLessThan.Label\" ) );\n    props.setLook( wlNrErrorsLessThan );\n    fdlNrErrorsLessThan = new FormData();\n    fdlNrErrorsLessThan.left = new FormAttachment( 0, 0 );\n    fdlNrErrorsLessThan.top = new FormAttachment( wSuccessCondition, margin );\n    fdlNrErrorsLessThan.right = new FormAttachment( middle, -margin );\n    wlNrErrorsLessThan.setLayoutData( fdlNrErrorsLessThan );\n\n    wNrErrorsLessThan =\n      new TextVar( jobMeta, wSuccessOn, SWT.SINGLE | SWT.LEFT | SWT.BORDER, BaseMessages.getString(\n        PKG, \"JobPGPEncryptFiles.NrErrorsLessThan.Tooltip\" ) );\n    props.setLook( wNrErrorsLessThan );\n    wNrErrorsLessThan.addModifyListener( lsMod );\n    fdNrErrorsLessThan = new FormData();\n    fdNrErrorsLessThan.left = new FormAttachment( middle, 0 );\n    fdNrErrorsLessThan.top = new FormAttachment( wSuccessCondition, margin );\n    fdNrErrorsLessThan.right = new FormAttachment( 100, -margin );\n    wNrErrorsLessThan.setLayoutData( fdNrErrorsLessThan );\n\n    fdSuccessOn = new FormData();\n    fdSuccessOn.left = new FormAttachment( 0, margin );\n    fdSuccessOn.top = new FormAttachment( wDestinationFile, margin );\n    fdSuccessOn.right = new FormAttachment( 100, -margin );\n    wSuccessOn.setLayoutData( fdSuccessOn );\n    // ///////////////////////////////////////////////////////////\n    // / END OF Success ON GROUP\n    // ///////////////////////////////////////////////////////////\n\n    // fileresult grouping?\n    // ////////////////////////\n    // START OF LOGGING GROUP///\n    // /\n    wFileResult = new Group( wAdvancedComp, SWT.SHADOW_NONE );\n    props.setLook( wFileResult );\n    wFileResult.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.FileResult.Group.Label\" ) );\n\n    FormLayout fileresultgroupLayout = new FormLayout();\n    fileresultgroupLayout.marginWidth = 10;\n    fileresultgroupLayout.marginHeight = 10;\n\n    wFileResult.setLayout( fileresultgroupLayout );\n\n    // Add file to result\n    wlAddFileToResult = new Label( wFileResult, SWT.RIGHT );\n    wlAddFileToResult.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddFileToResult.Label\" ) );\n    props.setLook( wlAddFileToResult );\n    fdlAddFileToResult = new FormData();\n    fdlAddFileToResult.left = new FormAttachment( 0, 0 );\n    fdlAddFileToResult.top = new FormAttachment( wSuccessOn, margin );\n    fdlAddFileToResult.right = new FormAttachment( middle, -margin );\n    wlAddFileToResult.setLayoutData( fdlAddFileToResult );\n    wAddFileToResult = new Button( wFileResult, SWT.CHECK );\n    props.setLook( wAddFileToResult );\n    wAddFileToResult.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddFileToResult.Tooltip\" ) );\n    fdAddFileToResult = new FormData();\n    fdAddFileToResult.left = new FormAttachment( middle, 0 );\n    fdAddFileToResult.top = new FormAttachment( wSuccessOn, margin );\n    fdAddFileToResult.right = new FormAttachment( 100, 0 );\n    wAddFileToResult.setLayoutData( fdAddFileToResult );\n    wAddFileToResult.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    fdFileResult = new FormData();\n    fdFileResult.left = new FormAttachment( 0, margin );\n    fdFileResult.top = new FormAttachment( wSuccessOn, margin );\n    fdFileResult.right = new FormAttachment( 100, -margin );\n    wFileResult.setLayoutData( fdFileResult );\n    // ///////////////////////////////////////////////////////////\n    // / END OF FilesResult GROUP\n    // ///////////////////////////////////////////////////////////\n\n    fdAdvancedComp = new FormData();\n    fdAdvancedComp.left = new FormAttachment( 0, 0 );\n    fdAdvancedComp.top = new FormAttachment( 0, 0 );\n    fdAdvancedComp.right = new FormAttachment( 100, 0 );\n    fdAdvancedComp.bottom = new FormAttachment( 100, 0 );\n    wAdvancedComp.setLayoutData( wAdvancedComp );\n\n    wAdvancedComp.layout();\n    wAdvancedTab.setControl( wAdvancedComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF ADVANCED TAB\n    // ///////////////////////////////////////////////////////////\n\n    fdTabFolder = new FormData();\n    fdTabFolder.left = new FormAttachment( 0, 0 );\n    fdTabFolder.top = new FormAttachment( wName, margin );\n    fdTabFolder.right = new FormAttachment( 100, 0 );\n    fdTabFolder.bottom = new FormAttachment( 100, -50 );\n    wTabFolder.setLayoutData( fdTabFolder );\n\n    wOK = new Button( shell, SWT.PUSH );\n    wOK.setText( BaseMessages.getString( PKG, \"System.Button.OK\" ) );\n    wCancel = new Button( shell, SWT.PUSH );\n    wCancel.setText( BaseMessages.getString( PKG, \"System.Button.Cancel\" ) );\n\n    BaseStepDialog.positionBottomButtons( shell, new Button[] { wOK, wCancel }, margin, wTabFolder );\n\n    // Add listeners\n    lsCancel = new Listener() {\n      public void handleEvent( Event e ) {\n        cancel();\n      }\n    };\n    lsOK = new Listener() {\n      public void handleEvent( Event e ) {\n        ok();\n      }\n    };\n\n    wCancel.addListener( SWT.Selection, lsCancel );\n    wOK.addListener( SWT.Selection, lsOK );\n\n    lsDef = new SelectionAdapter() {\n      public void widgetDefaultSelected( SelectionEvent e ) {\n        ok();\n      }\n    };\n\n    wName.addSelectionListener( lsDef );\n    wSourceFileFolder.addSelectionListener( lsDef );\n\n    // Detect X or ALT-F4 or something that kills this window...\n    shell.addShellListener( new ShellAdapter() {\n      public void shellClosed( ShellEvent e ) {\n        cancel();\n      }\n    } );\n\n    getData();\n    CheckIncludeSubFolders();\n    activeSuccessCondition();\n    setDateTimeFormat();\n    activeSuccessCondition();\n\n    activeDestinationFolder();\n    setMovedDateTimeFormat();\n    setAddDateBeforeExtension();\n    setAddMovedDateBeforeExtension();\n    wTabFolder.setSelection( 0 );\n    BaseStepDialog.setSize( shell );\n\n    shell.open();\n    while ( !shell.isDisposed() ) {\n      if ( !display.readAndDispatch() ) {\n        display.sleep();\n      }\n    }\n    return jobEntry;\n  }","id":6729,"modified_method":"@Override\n  public JobEntryInterface open() {\n    Shell parent = getParent();\n    Display display = parent.getDisplay();\n\n    shell = new Shell( parent, props.getJobsDialogStyle() );\n    props.setLook( shell );\n    JobDialog.setShellImage( shell, jobEntry );\n\n    ModifyListener lsMod = new ModifyListener() {\n      @Override\n      public void modifyText( ModifyEvent e ) {\n        jobEntry.setChanged();\n      }\n    };\n    changed = jobEntry.hasChanged();\n\n    FormLayout formLayout = new FormLayout();\n    formLayout.marginWidth = Const.FORM_MARGIN;\n    formLayout.marginHeight = Const.FORM_MARGIN;\n\n    shell.setLayout( formLayout );\n    shell.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Title\" ) );\n\n    int middle = props.getMiddlePct();\n    int margin = Const.MARGIN;\n\n    // Filename line\n    wlName = new Label( shell, SWT.RIGHT );\n    wlName.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Name.Label\" ) );\n    props.setLook( wlName );\n    fdlName = new FormData();\n    fdlName.left = new FormAttachment( 0, 0 );\n    fdlName.right = new FormAttachment( middle, -margin );\n    fdlName.top = new FormAttachment( 0, margin );\n    wlName.setLayoutData( fdlName );\n    wName = new Text( shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wName );\n    wName.addModifyListener( lsMod );\n    fdName = new FormData();\n    fdName.left = new FormAttachment( middle, 0 );\n    fdName.top = new FormAttachment( 0, margin );\n    fdName.right = new FormAttachment( 100, 0 );\n    wName.setLayoutData( fdName );\n\n    wTabFolder = new CTabFolder( shell, SWT.BORDER );\n    props.setLook( wTabFolder, Props.WIDGET_STYLE_TAB );\n\n    // ////////////////////////\n    // START OF GENERAL TAB ///\n    // ////////////////////////\n\n    wGeneralTab = new CTabItem( wTabFolder, SWT.NONE );\n    wGeneralTab.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Tab.General.Label\" ) );\n\n    wGeneralComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wGeneralComp );\n\n    FormLayout generalLayout = new FormLayout();\n    generalLayout.marginWidth = 3;\n    generalLayout.marginHeight = 3;\n    wGeneralComp.setLayout( generalLayout );\n\n    // SETTINGS grouping?\n    // ////////////////////////\n    // START OF SETTINGS GROUP\n    //\n\n    wSettings = new Group( wGeneralComp, SWT.SHADOW_NONE );\n    props.setLook( wSettings );\n    wSettings.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Settings.Label\" ) );\n\n    FormLayout groupLayout = new FormLayout();\n    groupLayout.marginWidth = 10;\n    groupLayout.marginHeight = 10;\n    wSettings.setLayout( groupLayout );\n\n    // GPG Program\n    wlGpgExe = new Label( wSettings, SWT.RIGHT );\n    wlGpgExe.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.GpgExe.Label\" ) );\n    props.setLook( wlGpgExe );\n    fdlGpgExe = new FormData();\n    fdlGpgExe.left = new FormAttachment( 0, 0 );\n    fdlGpgExe.top = new FormAttachment( wName, margin );\n    fdlGpgExe.right = new FormAttachment( middle, -margin );\n    wlGpgExe.setLayoutData( fdlGpgExe );\n\n    // Browse Source files button ...\n    wbbGpgExe = new Button( wSettings, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbbGpgExe );\n    wbbGpgExe.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.BrowseFiles.Label\" ) );\n    fdbbGpgExe = new FormData();\n    fdbbGpgExe.right = new FormAttachment( 100, -margin );\n    fdbbGpgExe.top = new FormAttachment( wName, margin );\n    wbbGpgExe.setLayoutData( fdbbGpgExe );\n\n    wbbGpgExe.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        FileDialog dialog = new FileDialog( shell, SWT.OPEN );\n        dialog.setFilterExtensions( new String[] { \"*\" } );\n        if ( wSourceFileFolder.getText() != null ) {\n          dialog.setFileName( jobMeta.environmentSubstitute( wGpgExe.getText() ) );\n        }\n        dialog.setFilterNames( FILETYPES );\n        if ( dialog.open() != null ) {\n          wGpgExe.setText( dialog.getFilterPath() + Const.FILE_SEPARATOR + dialog.getFileName() );\n        }\n      }\n    } );\n\n    wGpgExe = new TextVar( jobMeta, wSettings, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    wGpgExe.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.GpgExe.Tooltip\" ) );\n    props.setLook( wGpgExe );\n    wGpgExe.addModifyListener( lsMod );\n    fdGpgExe = new FormData();\n    fdGpgExe.left = new FormAttachment( middle, 0 );\n    fdGpgExe.top = new FormAttachment( wName, margin );\n    fdGpgExe.right = new FormAttachment( wbbGpgExe, -margin );\n    wGpgExe.setLayoutData( fdGpgExe );\n\n    wlasciiMode = new Label( wSettings, SWT.RIGHT );\n    wlasciiMode.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.asciiMode.Label\" ) );\n    props.setLook( wlasciiMode );\n    fdlasciiMode = new FormData();\n    fdlasciiMode.left = new FormAttachment( 0, 0 );\n    fdlasciiMode.top = new FormAttachment( wGpgExe, margin );\n    fdlasciiMode.right = new FormAttachment( middle, -margin );\n    wlasciiMode.setLayoutData( fdlasciiMode );\n    wasciiMode = new Button( wSettings, SWT.CHECK );\n    props.setLook( wasciiMode );\n    wasciiMode.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.asciiMode.Tooltip\" ) );\n    fdasciiMode = new FormData();\n    fdasciiMode.left = new FormAttachment( middle, 0 );\n    fdasciiMode.top = new FormAttachment( wGpgExe, margin );\n    fdasciiMode.right = new FormAttachment( 100, 0 );\n    wasciiMode.setLayoutData( fdasciiMode );\n    wasciiMode.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    wlIncludeSubfolders = new Label( wSettings, SWT.RIGHT );\n    wlIncludeSubfolders.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.IncludeSubfolders.Label\" ) );\n    props.setLook( wlIncludeSubfolders );\n    fdlIncludeSubfolders = new FormData();\n    fdlIncludeSubfolders.left = new FormAttachment( 0, 0 );\n    fdlIncludeSubfolders.top = new FormAttachment( wasciiMode, margin );\n    fdlIncludeSubfolders.right = new FormAttachment( middle, -margin );\n    wlIncludeSubfolders.setLayoutData( fdlIncludeSubfolders );\n    wIncludeSubfolders = new Button( wSettings, SWT.CHECK );\n    props.setLook( wIncludeSubfolders );\n    wIncludeSubfolders.setToolTipText( BaseMessages\n      .getString( PKG, \"JobPGPEncryptFiles.IncludeSubfolders.Tooltip\" ) );\n    fdIncludeSubfolders = new FormData();\n    fdIncludeSubfolders.left = new FormAttachment( middle, 0 );\n    fdIncludeSubfolders.top = new FormAttachment( wasciiMode, margin );\n    fdIncludeSubfolders.right = new FormAttachment( 100, 0 );\n    wIncludeSubfolders.setLayoutData( fdIncludeSubfolders );\n    wIncludeSubfolders.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        CheckIncludeSubFolders();\n      }\n    } );\n\n    // previous\n    wlPrevious = new Label( wSettings, SWT.RIGHT );\n    wlPrevious.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Previous.Label\" ) );\n    props.setLook( wlPrevious );\n    fdlPrevious = new FormData();\n    fdlPrevious.left = new FormAttachment( 0, 0 );\n    fdlPrevious.top = new FormAttachment( wIncludeSubfolders, margin );\n    fdlPrevious.right = new FormAttachment( middle, -margin );\n    wlPrevious.setLayoutData( fdlPrevious );\n    wPrevious = new Button( wSettings, SWT.CHECK );\n    props.setLook( wPrevious );\n    wPrevious.setSelection( jobEntry.arg_from_previous );\n    wPrevious.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Previous.Tooltip\" ) );\n    fdPrevious = new FormData();\n    fdPrevious.left = new FormAttachment( middle, 0 );\n    fdPrevious.top = new FormAttachment( wIncludeSubfolders, margin );\n    fdPrevious.right = new FormAttachment( 100, 0 );\n    wPrevious.setLayoutData( fdPrevious );\n    wPrevious.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n\n        RefreshArgFromPrevious();\n\n      }\n    } );\n    fdSettings = new FormData();\n    fdSettings.left = new FormAttachment( 0, margin );\n    fdSettings.top = new FormAttachment( wName, margin );\n    fdSettings.right = new FormAttachment( 100, -margin );\n    wSettings.setLayoutData( fdSettings );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF SETTINGS GROUP\n    // ///////////////////////////////////////////////////////////\n\n    // SourceFileFolder line\n    wlSourceFileFolder = new Label( wGeneralComp, SWT.RIGHT );\n    wlSourceFileFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SourceFileFolder.Label\" ) );\n    props.setLook( wlSourceFileFolder );\n    FormData fdlSourceFileFolder = new FormData();\n    fdlSourceFileFolder.left = new FormAttachment( 0, 0 );\n    fdlSourceFileFolder.top = new FormAttachment( wSettings, 2 * margin );\n    fdlSourceFileFolder.right = new FormAttachment( middle, -margin );\n    wlSourceFileFolder.setLayoutData( fdlSourceFileFolder );\n\n    // Browse Source folders button ...\n    wbSourceDirectory = new Button( wGeneralComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbSourceDirectory );\n    wbSourceDirectory.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.BrowseFolders.Label\" ) );\n    FormData fdbSourceDirectory = new FormData();\n    fdbSourceDirectory.right = new FormAttachment( 100, 0 );\n    fdbSourceDirectory.top = new FormAttachment( wSettings, margin );\n    wbSourceDirectory.setLayoutData( fdbSourceDirectory );\n\n    wbSourceDirectory.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        DirectoryDialog ddialog = new DirectoryDialog( shell, SWT.OPEN );\n        if ( wSourceFileFolder.getText() != null ) {\n          ddialog.setFilterPath( jobMeta.environmentSubstitute( wSourceFileFolder.getText() ) );\n        }\n\n        // Calling open() will open and run the dialog.\n        // It will return the selected directory, or\n        // null if user cancels\n        String dir = ddialog.open();\n        if ( dir != null ) {\n          // Set the text box to the new selection\n          wSourceFileFolder.setText( dir );\n        }\n\n      }\n    } );\n\n    // Browse Source files button ...\n    wbSourceFileFolder = new Button( wGeneralComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbSourceFileFolder );\n    wbSourceFileFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.BrowseFiles.Label\" ) );\n    FormData fdbSourceFileFolder = new FormData();\n    fdbSourceFileFolder.right = new FormAttachment( wbSourceDirectory, -margin );\n    fdbSourceFileFolder.top = new FormAttachment( wSettings, margin );\n    wbSourceFileFolder.setLayoutData( fdbSourceFileFolder );\n\n    // Browse Destination file add button ...\n    wbaSourceFileFolder = new Button( wGeneralComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbaSourceFileFolder );\n    wbaSourceFileFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.FilenameAdd.Button\" ) );\n    fdbaSourceFileFolder = new FormData();\n    fdbaSourceFileFolder.right = new FormAttachment( wbSourceFileFolder, -margin );\n    fdbaSourceFileFolder.top = new FormAttachment( wSettings, margin );\n    wbaSourceFileFolder.setLayoutData( fdbaSourceFileFolder );\n\n    wSourceFileFolder = new TextVar( jobMeta, wGeneralComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    wSourceFileFolder\n      .setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SourceFileFolder.Tooltip\" ) );\n\n    props.setLook( wSourceFileFolder );\n    wSourceFileFolder.addModifyListener( lsMod );\n    FormData fdSourceFileFolder = new FormData();\n    fdSourceFileFolder.left = new FormAttachment( middle, 0 );\n    fdSourceFileFolder.top = new FormAttachment( wSettings, 2 * margin );\n    fdSourceFileFolder.right = new FormAttachment( wbSourceFileFolder, -55 );\n    wSourceFileFolder.setLayoutData( fdSourceFileFolder );\n\n    // Whenever something changes, set the tooltip to the expanded version:\n    wSourceFileFolder.addModifyListener( new ModifyListener() {\n      @Override\n      public void modifyText( ModifyEvent e ) {\n        wSourceFileFolder.setToolTipText( jobMeta.environmentSubstitute( wSourceFileFolder.getText() ) );\n      }\n    } );\n\n    wbSourceFileFolder.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        FileDialog dialog = new FileDialog( shell, SWT.OPEN );\n        dialog.setFilterExtensions( new String[] { \"*\" } );\n        if ( wSourceFileFolder.getText() != null ) {\n          dialog.setFileName( jobMeta.environmentSubstitute( wSourceFileFolder.getText() ) );\n        }\n        dialog.setFilterNames( FILETYPES );\n        if ( dialog.open() != null ) {\n          wSourceFileFolder.setText( dialog.getFilterPath() + Const.FILE_SEPARATOR + dialog.getFileName() );\n        }\n      }\n    } );\n\n    // Destination\n    wlDestinationFileFolder = new Label( wGeneralComp, SWT.RIGHT );\n    wlDestinationFileFolder.setText( BaseMessages\n      .getString( PKG, \"JobPGPEncryptFiles.DestinationFileFolder.Label\" ) );\n    props.setLook( wlDestinationFileFolder );\n    fdlDestinationFileFolder = new FormData();\n    fdlDestinationFileFolder.left = new FormAttachment( 0, 0 );\n    fdlDestinationFileFolder.top = new FormAttachment( wSourceFileFolder, margin );\n    fdlDestinationFileFolder.right = new FormAttachment( middle, -margin );\n    wlDestinationFileFolder.setLayoutData( fdlDestinationFileFolder );\n\n    // Browse Destination folders button ...\n    wbDestinationDirectory = new Button( wGeneralComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbDestinationDirectory );\n    wbDestinationDirectory.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.BrowseFolders.Label\" ) );\n    FormData fdbDestinationDirectory = new FormData();\n    fdbDestinationDirectory.right = new FormAttachment( 100, 0 );\n    fdbDestinationDirectory.top = new FormAttachment( wSourceFileFolder, margin );\n    wbDestinationDirectory.setLayoutData( fdbDestinationDirectory );\n\n    wbDestinationDirectory.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        DirectoryDialog ddialog = new DirectoryDialog( shell, SWT.OPEN );\n        if ( wDestinationFileFolder.getText() != null ) {\n          ddialog.setFilterPath( jobMeta.environmentSubstitute( wDestinationFileFolder.getText() ) );\n        }\n\n        // Calling open() will open and run the dialog.\n        // It will return the selected directory, or\n        // null if user cancels\n        String dir = ddialog.open();\n        if ( dir != null ) {\n          // Set the text box to the new selection\n          wDestinationFileFolder.setText( dir );\n        }\n\n      }\n    } );\n\n    // Browse Destination file browse button ...\n    wbDestinationFileFolder = new Button( wGeneralComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbDestinationFileFolder );\n    wbDestinationFileFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.BrowseFiles.Label\" ) );\n    FormData fdbDestinationFileFolder = new FormData();\n    fdbDestinationFileFolder.right = new FormAttachment( wbDestinationDirectory, -margin );\n    fdbDestinationFileFolder.top = new FormAttachment( wSourceFileFolder, margin );\n    wbDestinationFileFolder.setLayoutData( fdbDestinationFileFolder );\n\n    wDestinationFileFolder = new TextVar( jobMeta, wGeneralComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    wDestinationFileFolder.setToolTipText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.DestinationFileFolder.Tooltip\" ) );\n    props.setLook( wDestinationFileFolder );\n    wDestinationFileFolder.addModifyListener( lsMod );\n    fdDestinationFileFolder = new FormData();\n    fdDestinationFileFolder.left = new FormAttachment( middle, 0 );\n    fdDestinationFileFolder.top = new FormAttachment( wSourceFileFolder, margin );\n    fdDestinationFileFolder.right = new FormAttachment( wbSourceFileFolder, -55 );\n    wDestinationFileFolder.setLayoutData( fdDestinationFileFolder );\n\n    wbDestinationFileFolder.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        FileDialog dialog = new FileDialog( shell, SWT.OPEN );\n        dialog.setFilterExtensions( new String[] { \"*\" } );\n        if ( wDestinationFileFolder.getText() != null ) {\n          dialog.setFileName( jobMeta.environmentSubstitute( wDestinationFileFolder.getText() ) );\n        }\n        dialog.setFilterNames( FILETYPES );\n        if ( dialog.open() != null ) {\n          wDestinationFileFolder.setText( dialog.getFilterPath() + Const.FILE_SEPARATOR + dialog.getFileName() );\n        }\n      }\n    } );\n\n    // Buttons to the right of the screen...\n    wbdSourceFileFolder = new Button( wGeneralComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbdSourceFileFolder );\n    wbdSourceFileFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.FilenameDelete.Button\" ) );\n    wbdSourceFileFolder\n      .setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.FilenameDelete.Tooltip\" ) );\n    fdbdSourceFileFolder = new FormData();\n    fdbdSourceFileFolder.right = new FormAttachment( 100, 0 );\n    fdbdSourceFileFolder.top = new FormAttachment( wDestinationFileFolder, 40 );\n    wbdSourceFileFolder.setLayoutData( fdbdSourceFileFolder );\n\n    wbeSourceFileFolder = new Button( wGeneralComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbeSourceFileFolder );\n    wbeSourceFileFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.FilenameEdit.Button\" ) );\n    wbeSourceFileFolder.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.FilenameEdit.Tooltip\" ) );\n    fdbeSourceFileFolder = new FormData();\n    fdbeSourceFileFolder.right = new FormAttachment( 100, 0 );\n    fdbeSourceFileFolder.left = new FormAttachment( wbdSourceFileFolder, 0, SWT.LEFT );\n    fdbeSourceFileFolder.top = new FormAttachment( wbdSourceFileFolder, margin );\n    wbeSourceFileFolder.setLayoutData( fdbeSourceFileFolder );\n\n    // Wildcard\n    wlWildcard = new Label( wGeneralComp, SWT.RIGHT );\n    wlWildcard.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Wildcard.Label\" ) );\n    props.setLook( wlWildcard );\n    fdlWildcard = new FormData();\n    fdlWildcard.left = new FormAttachment( 0, 0 );\n    fdlWildcard.top = new FormAttachment( wDestinationFileFolder, margin );\n    fdlWildcard.right = new FormAttachment( middle, -margin );\n    wlWildcard.setLayoutData( fdlWildcard );\n\n    wWildcard = new TextVar( jobMeta, wGeneralComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    wWildcard.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Wildcard.Tooltip\" ) );\n    props.setLook( wWildcard );\n    wWildcard.addModifyListener( lsMod );\n    fdWildcard = new FormData();\n    fdWildcard.left = new FormAttachment( middle, 0 );\n    fdWildcard.top = new FormAttachment( wDestinationFileFolder, margin );\n    fdWildcard.right = new FormAttachment( wbSourceFileFolder, -55 );\n    wWildcard.setLayoutData( fdWildcard );\n\n    wlFields = new Label( wGeneralComp, SWT.NONE );\n    wlFields.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.Label\" ) );\n    props.setLook( wlFields );\n    fdlFields = new FormData();\n    fdlFields.left = new FormAttachment( 0, 0 );\n    fdlFields.right = new FormAttachment( middle, -margin );\n    fdlFields.top = new FormAttachment( wWildcard, margin );\n    wlFields.setLayoutData( fdlFields );\n\n    int rows =\n      jobEntry.source_filefolder == null ? 1 : ( jobEntry.source_filefolder.length == 0\n        ? 0 : jobEntry.source_filefolder.length );\n    final int FieldsRows = rows;\n\n    ColumnInfo[] colinf =\n      new ColumnInfo[] {\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.Action.Label\" ),\n          ColumnInfo.COLUMN_TYPE_CCOMBO, JobEntryPGPEncryptFiles.actionTypeDesc, false ),\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.SourceFileFolder.Label\" ),\n          ColumnInfo.COLUMN_TYPE_TEXT, false ),\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.Wildcard.Label\" ),\n          ColumnInfo.COLUMN_TYPE_TEXT, false ),\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.UserID.Label\" ),\n          ColumnInfo.COLUMN_TYPE_TEXT, false ),\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.DestinationFileFolder.Label\" ),\n          ColumnInfo.COLUMN_TYPE_TEXT, false ), };\n\n    colinf[0].setUsingVariables( true );\n    colinf[1].setUsingVariables( true );\n    colinf[1].setToolTip( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.SourceFileFolder.Tooltip\" ) );\n    colinf[2].setUsingVariables( true );\n    colinf[2].setToolTip( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.Wildcard.Tooltip\" ) );\n    colinf[3].setUsingVariables( true );\n    colinf[3].setToolTip( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.UserID.Tooltip\" ) );\n    colinf[4]\n      .setToolTip( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.DestinationFileFolder.Tooltip\" ) );\n\n    wFields =\n      new TableView(\n        jobMeta, wGeneralComp, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, colinf, FieldsRows, lsMod, props );\n\n    fdFields = new FormData();\n    fdFields.left = new FormAttachment( 0, 0 );\n    fdFields.top = new FormAttachment( wlFields, margin );\n    fdFields.right = new FormAttachment( wbeSourceFileFolder, -margin );\n    fdFields.bottom = new FormAttachment( 100, -margin );\n    wFields.setLayoutData( fdFields );\n\n    RefreshArgFromPrevious();\n\n    // Add the file to the list of files...\n    SelectionAdapter selA = new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent arg0 ) {\n        wFields.add( new String[] {\n          JobEntryPGPEncryptFiles.actionTypeDesc[0], wSourceFileFolder.getText(), wWildcard.getText(), null,\n          wDestinationFileFolder.getText() } );\n        wSourceFileFolder.setText( \"\" );\n        wDestinationFileFolder.setText( \"\" );\n        wWildcard.setText( \"\" );\n        wFields.removeEmptyRows();\n        wFields.setRowNums();\n        wFields.optWidth( true );\n      }\n    };\n    wbaSourceFileFolder.addSelectionListener( selA );\n    wSourceFileFolder.addSelectionListener( selA );\n\n    // Delete files from the list of files...\n    wbdSourceFileFolder.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent arg0 ) {\n        int[] idx = wFields.getSelectionIndices();\n        wFields.remove( idx );\n        wFields.removeEmptyRows();\n        wFields.setRowNums();\n      }\n    } );\n\n    // Edit the selected file & remove from the list...\n    wbeSourceFileFolder.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent arg0 ) {\n        int idx = wFields.getSelectionIndex();\n        if ( idx >= 0 ) {\n          String[] string = wFields.getItem( idx );\n          wSourceFileFolder.setText( string[0] );\n          wDestinationFileFolder.setText( string[1] );\n          wWildcard.setText( string[2] );\n          wFields.remove( idx );\n        }\n        wFields.removeEmptyRows();\n        wFields.setRowNums();\n      }\n    } );\n\n    fdGeneralComp = new FormData();\n    fdGeneralComp.left = new FormAttachment( 0, 0 );\n    fdGeneralComp.top = new FormAttachment( 0, 0 );\n    fdGeneralComp.right = new FormAttachment( 100, 0 );\n    fdGeneralComp.bottom = new FormAttachment( 100, 0 );\n    wGeneralComp.setLayoutData( fdGeneralComp );\n\n    wGeneralComp.layout();\n    wGeneralTab.setControl( wGeneralComp );\n    props.setLook( wGeneralComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF GENERAL TAB\n    // ///////////////////////////////////////////////////////////\n\n    // ////////////////////////////////////\n    // START OF DESTINATION FILE TAB ///\n    // ///////////////////////////////////\n\n    wDestinationFileTab = new CTabItem( wTabFolder, SWT.NONE );\n    wDestinationFileTab.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.DestinationFileTab.Label\" ) );\n\n    FormLayout DestcontentLayout = new FormLayout();\n    DestcontentLayout.marginWidth = 3;\n    DestcontentLayout.marginHeight = 3;\n\n    wDestinationFileComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wDestinationFileComp );\n    wDestinationFileComp.setLayout( DestcontentLayout );\n\n    // DestinationFile grouping?\n    // ////////////////////////\n    // START OF DestinationFile GROUP\n    //\n\n    wDestinationFile = new Group( wDestinationFileComp, SWT.SHADOW_NONE );\n    props.setLook( wDestinationFile );\n    wDestinationFile.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.GroupDestinationFile.Label\" ) );\n\n    FormLayout groupLayoutFile = new FormLayout();\n    groupLayoutFile.marginWidth = 10;\n    groupLayoutFile.marginHeight = 10;\n    wDestinationFile.setLayout( groupLayoutFile );\n\n    // Create destination folder/parent folder\n    wlCreateDestinationFolder = new Label( wDestinationFile, SWT.RIGHT );\n    wlCreateDestinationFolder.setText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.CreateDestinationFolder.Label\" ) );\n    props.setLook( wlCreateDestinationFolder );\n    fdlCreateDestinationFolder = new FormData();\n    fdlCreateDestinationFolder.left = new FormAttachment( 0, 0 );\n    fdlCreateDestinationFolder.top = new FormAttachment( 0, margin );\n    fdlCreateDestinationFolder.right = new FormAttachment( middle, -margin );\n    wlCreateDestinationFolder.setLayoutData( fdlCreateDestinationFolder );\n    wCreateDestinationFolder = new Button( wDestinationFile, SWT.CHECK );\n    props.setLook( wCreateDestinationFolder );\n    wCreateDestinationFolder.setToolTipText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.CreateDestinationFolder.Tooltip\" ) );\n    fdCreateDestinationFolder = new FormData();\n    fdCreateDestinationFolder.left = new FormAttachment( middle, 0 );\n    fdCreateDestinationFolder.top = new FormAttachment( 0, margin );\n    fdCreateDestinationFolder.right = new FormAttachment( 100, 0 );\n    wCreateDestinationFolder.setLayoutData( fdCreateDestinationFolder );\n    wCreateDestinationFolder.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Destination is a file?\n    wlDestinationIsAFile = new Label( wDestinationFile, SWT.RIGHT );\n    wlDestinationIsAFile.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.DestinationIsAFile.Label\" ) );\n    props.setLook( wlDestinationIsAFile );\n    fdlDestinationIsAFile = new FormData();\n    fdlDestinationIsAFile.left = new FormAttachment( 0, 0 );\n    fdlDestinationIsAFile.top = new FormAttachment( wCreateDestinationFolder, margin );\n    fdlDestinationIsAFile.right = new FormAttachment( middle, -margin );\n    wlDestinationIsAFile.setLayoutData( fdlDestinationIsAFile );\n    wDestinationIsAFile = new Button( wDestinationFile, SWT.CHECK );\n    props.setLook( wDestinationIsAFile );\n    wDestinationIsAFile.setToolTipText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.DestinationIsAFile.Tooltip\" ) );\n    fdDestinationIsAFile = new FormData();\n    fdDestinationIsAFile.left = new FormAttachment( middle, 0 );\n    fdDestinationIsAFile.top = new FormAttachment( wCreateDestinationFolder, margin );\n    fdDestinationIsAFile.right = new FormAttachment( 100, 0 );\n    wDestinationIsAFile.setLayoutData( fdDestinationIsAFile );\n    wDestinationIsAFile.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Do not keep folder structure?\n    wlDoNotKeepFolderStructure = new Label( wDestinationFile, SWT.RIGHT );\n    wlDoNotKeepFolderStructure.setText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.DoNotKeepFolderStructure.Label\" ) );\n    props.setLook( wlDoNotKeepFolderStructure );\n    fdlDoNotKeepFolderStructure = new FormData();\n    fdlDoNotKeepFolderStructure.left = new FormAttachment( 0, 0 );\n    fdlDoNotKeepFolderStructure.top = new FormAttachment( wDestinationIsAFile, margin );\n    fdlDoNotKeepFolderStructure.right = new FormAttachment( middle, -margin );\n    wlDoNotKeepFolderStructure.setLayoutData( fdlDoNotKeepFolderStructure );\n    wDoNotKeepFolderStructure = new Button( wDestinationFile, SWT.CHECK );\n    props.setLook( wDoNotKeepFolderStructure );\n    wDoNotKeepFolderStructure.setToolTipText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.DoNotKeepFolderStructure.Tooltip\" ) );\n    fdDoNotKeepFolderStructure = new FormData();\n    fdDoNotKeepFolderStructure.left = new FormAttachment( middle, 0 );\n    fdDoNotKeepFolderStructure.top = new FormAttachment( wDestinationIsAFile, margin );\n    fdDoNotKeepFolderStructure.right = new FormAttachment( 100, 0 );\n    wDoNotKeepFolderStructure.setLayoutData( fdDoNotKeepFolderStructure );\n    wDoNotKeepFolderStructure.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Create multi-part file?\n    wlAddDate = new Label( wDestinationFile, SWT.RIGHT );\n    wlAddDate.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddDate.Label\" ) );\n    props.setLook( wlAddDate );\n    fdlAddDate = new FormData();\n    fdlAddDate.left = new FormAttachment( 0, 0 );\n    fdlAddDate.top = new FormAttachment( wDoNotKeepFolderStructure, margin );\n    fdlAddDate.right = new FormAttachment( middle, -margin );\n    wlAddDate.setLayoutData( fdlAddDate );\n    wAddDate = new Button( wDestinationFile, SWT.CHECK );\n    props.setLook( wAddDate );\n    wAddDate.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddDate.Tooltip\" ) );\n    fdAddDate = new FormData();\n    fdAddDate.left = new FormAttachment( middle, 0 );\n    fdAddDate.top = new FormAttachment( wDoNotKeepFolderStructure, margin );\n    fdAddDate.right = new FormAttachment( 100, 0 );\n    wAddDate.setLayoutData( fdAddDate );\n    wAddDate.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        setAddDateBeforeExtension();\n      }\n    } );\n    // Create multi-part file?\n    wlAddTime = new Label( wDestinationFile, SWT.RIGHT );\n    wlAddTime.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddTime.Label\" ) );\n    props.setLook( wlAddTime );\n    fdlAddTime = new FormData();\n    fdlAddTime.left = new FormAttachment( 0, 0 );\n    fdlAddTime.top = new FormAttachment( wAddDate, margin );\n    fdlAddTime.right = new FormAttachment( middle, -margin );\n    wlAddTime.setLayoutData( fdlAddTime );\n    wAddTime = new Button( wDestinationFile, SWT.CHECK );\n    props.setLook( wAddTime );\n    wAddTime.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddTime.Tooltip\" ) );\n    fdAddTime = new FormData();\n    fdAddTime.left = new FormAttachment( middle, 0 );\n    fdAddTime.top = new FormAttachment( wAddDate, margin );\n    fdAddTime.right = new FormAttachment( 100, 0 );\n    wAddTime.setLayoutData( fdAddTime );\n    wAddTime.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        setAddDateBeforeExtension();\n      }\n    } );\n\n    // Specify date time format?\n    wlSpecifyFormat = new Label( wDestinationFile, SWT.RIGHT );\n    wlSpecifyFormat.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SpecifyFormat.Label\" ) );\n    props.setLook( wlSpecifyFormat );\n    fdlSpecifyFormat = new FormData();\n    fdlSpecifyFormat.left = new FormAttachment( 0, 0 );\n    fdlSpecifyFormat.top = new FormAttachment( wAddTime, margin );\n    fdlSpecifyFormat.right = new FormAttachment( middle, -margin );\n    wlSpecifyFormat.setLayoutData( fdlSpecifyFormat );\n    wSpecifyFormat = new Button( wDestinationFile, SWT.CHECK );\n    props.setLook( wSpecifyFormat );\n    wSpecifyFormat.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SpecifyFormat.Tooltip\" ) );\n    fdSpecifyFormat = new FormData();\n    fdSpecifyFormat.left = new FormAttachment( middle, 0 );\n    fdSpecifyFormat.top = new FormAttachment( wAddTime, margin );\n    fdSpecifyFormat.right = new FormAttachment( 100, 0 );\n    wSpecifyFormat.setLayoutData( fdSpecifyFormat );\n    wSpecifyFormat.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        setDateTimeFormat();\n        setAddDateBeforeExtension();\n      }\n    } );\n\n    // DateTimeFormat\n    wlDateTimeFormat = new Label( wDestinationFile, SWT.RIGHT );\n    wlDateTimeFormat.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.DateTimeFormat.Label\" ) );\n    props.setLook( wlDateTimeFormat );\n    fdlDateTimeFormat = new FormData();\n    fdlDateTimeFormat.left = new FormAttachment( 0, 0 );\n    fdlDateTimeFormat.top = new FormAttachment( wSpecifyFormat, margin );\n    fdlDateTimeFormat.right = new FormAttachment( middle, -margin );\n    wlDateTimeFormat.setLayoutData( fdlDateTimeFormat );\n    wDateTimeFormat = new CCombo( wDestinationFile, SWT.BORDER | SWT.READ_ONLY );\n    wDateTimeFormat.setEditable( true );\n    props.setLook( wDateTimeFormat );\n    wDateTimeFormat.addModifyListener( lsMod );\n    fdDateTimeFormat = new FormData();\n    fdDateTimeFormat.left = new FormAttachment( middle, 0 );\n    fdDateTimeFormat.top = new FormAttachment( wSpecifyFormat, margin );\n    fdDateTimeFormat.right = new FormAttachment( 100, 0 );\n    wDateTimeFormat.setLayoutData( fdDateTimeFormat );\n    // Prepare a list of possible DateTimeFormats...\n    String[] dats = Const.getDateFormats();\n    for ( int x = 0; x < dats.length; x++ ) {\n      wDateTimeFormat.add( dats[x] );\n    }\n\n    // Add Date before extension?\n    wlAddDateBeforeExtension = new Label( wDestinationFile, SWT.RIGHT );\n    wlAddDateBeforeExtension.setText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.AddDateBeforeExtension.Label\" ) );\n    props.setLook( wlAddDateBeforeExtension );\n    fdlAddDateBeforeExtension = new FormData();\n    fdlAddDateBeforeExtension.left = new FormAttachment( 0, 0 );\n    fdlAddDateBeforeExtension.top = new FormAttachment( wDateTimeFormat, margin );\n    fdlAddDateBeforeExtension.right = new FormAttachment( middle, -margin );\n    wlAddDateBeforeExtension.setLayoutData( fdlAddDateBeforeExtension );\n    wAddDateBeforeExtension = new Button( wDestinationFile, SWT.CHECK );\n    props.setLook( wAddDateBeforeExtension );\n    wAddDateBeforeExtension.setToolTipText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.AddDateBeforeExtension.Tooltip\" ) );\n    fdAddDateBeforeExtension = new FormData();\n    fdAddDateBeforeExtension.left = new FormAttachment( middle, 0 );\n    fdAddDateBeforeExtension.top = new FormAttachment( wDateTimeFormat, margin );\n    fdAddDateBeforeExtension.right = new FormAttachment( 100, 0 );\n    wAddDateBeforeExtension.setLayoutData( fdAddDateBeforeExtension );\n    wAddDateBeforeExtension.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // If File Exists\n    wlIfFileExists = new Label( wDestinationFile, SWT.RIGHT );\n    wlIfFileExists.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.IfFileExists.Label\" ) );\n    props.setLook( wlIfFileExists );\n    fdlIfFileExists = new FormData();\n    fdlIfFileExists.left = new FormAttachment( 0, 0 );\n    fdlIfFileExists.right = new FormAttachment( middle, 0 );\n    fdlIfFileExists.top = new FormAttachment( wAddDateBeforeExtension, margin );\n    wlIfFileExists.setLayoutData( fdlIfFileExists );\n    wIfFileExists = new CCombo( wDestinationFile, SWT.SINGLE | SWT.READ_ONLY | SWT.BORDER );\n    wIfFileExists.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Do_Nothing_IfFileExists.Label\" ) );\n    wIfFileExists.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Overwrite_File_IfFileExists.Label\" ) );\n    wIfFileExists.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Unique_Name_IfFileExists.Label\" ) );\n    wIfFileExists.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Delete_Source_File_IfFileExists.Label\" ) );\n    wIfFileExists.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Move_To_Folder_IfFileExists.Label\" ) );\n    wIfFileExists.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fail_IfFileExists.Label\" ) );\n    wIfFileExists.select( 0 ); // +1: starts at -1\n\n    props.setLook( wIfFileExists );\n    fdIfFileExists = new FormData();\n    fdIfFileExists.left = new FormAttachment( middle, 0 );\n    fdIfFileExists.top = new FormAttachment( wAddDateBeforeExtension, margin );\n    fdIfFileExists.right = new FormAttachment( 100, 0 );\n    wIfFileExists.setLayoutData( fdIfFileExists );\n\n    wIfFileExists.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n\n        activeDestinationFolder();\n        setMovedDateTimeFormat();\n        // setAddDateBeforeExtension();\n        setAddMovedDateBeforeExtension();\n\n      }\n    } );\n\n    fdDestinationFile = new FormData();\n    fdDestinationFile.left = new FormAttachment( 0, margin );\n    fdDestinationFile.top = new FormAttachment( wName, margin );\n    fdDestinationFile.right = new FormAttachment( 100, -margin );\n    wDestinationFile.setLayoutData( fdDestinationFile );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF DestinationFile GROUP\n    // ///////////////////////////////////////////////////////////\n\n    // MoveTo grouping?\n    // ////////////////////////\n    // START OF MoveTo GROUP\n    //\n\n    wMoveToGroup = new Group( wDestinationFileComp, SWT.SHADOW_NONE );\n    props.setLook( wMoveToGroup );\n    wMoveToGroup.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.GroupMoveToGroup.Label\" ) );\n\n    FormLayout MovetoLayoutFile = new FormLayout();\n    MovetoLayoutFile.marginWidth = 10;\n    MovetoLayoutFile.marginHeight = 10;\n    wMoveToGroup.setLayout( MovetoLayoutFile );\n\n    // DestinationFolder line\n    wlDestinationFolder = new Label( wMoveToGroup, SWT.RIGHT );\n    wlDestinationFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.DestinationFolder.Label\" ) );\n    props.setLook( wlDestinationFolder );\n    fdlDestinationFolder = new FormData();\n    fdlDestinationFolder.left = new FormAttachment( 0, 0 );\n    fdlDestinationFolder.top = new FormAttachment( wDestinationFile, margin );\n    fdlDestinationFolder.right = new FormAttachment( middle, -margin );\n    wlDestinationFolder.setLayoutData( fdlDestinationFolder );\n\n    wbDestinationFolder = new Button( wMoveToGroup, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbDestinationFolder );\n    wbDestinationFolder.setText( BaseMessages.getString( PKG, \"System.Button.Browse\" ) );\n    fdbDestinationFolder = new FormData();\n    fdbDestinationFolder.right = new FormAttachment( 100, 0 );\n    fdbDestinationFolder.top = new FormAttachment( wDestinationFile, 0 );\n    wbDestinationFolder.setLayoutData( fdbDestinationFolder );\n\n    wDestinationFolder = new TextVar( jobMeta, wMoveToGroup, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wDestinationFolder );\n    wDestinationFolder.addModifyListener( lsMod );\n    fdDestinationFolder = new FormData();\n    fdDestinationFolder.left = new FormAttachment( middle, 0 );\n    fdDestinationFolder.top = new FormAttachment( wDestinationFile, margin );\n    fdDestinationFolder.right = new FormAttachment( wbDestinationFolder, -margin );\n    wDestinationFolder.setLayoutData( fdDestinationFolder );\n\n    // Whenever something changes, set the tooltip to the expanded version:\n    wDestinationFolder.addModifyListener( new ModifyListener() {\n      @Override\n      public void modifyText( ModifyEvent e ) {\n        wDestinationFolder.setToolTipText( jobMeta.environmentSubstitute( wDestinationFolder.getText() ) );\n      }\n    } );\n\n    wbDestinationFolder.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        DirectoryDialog dialog = new DirectoryDialog( shell, SWT.OPEN );\n        if ( wDestinationFolder.getText() != null ) {\n          dialog.setFilterPath( jobMeta.environmentSubstitute( wDestinationFolder.getText() ) );\n        }\n\n        String dir = dialog.open();\n        if ( dir != null ) {\n          wDestinationFolder.setText( dir );\n        }\n      }\n    } );\n\n    // Create destination folder/parent folder\n    wlCreateMoveToFolder = new Label( wMoveToGroup, SWT.RIGHT );\n    wlCreateMoveToFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.CreateMoveToFolder.Label\" ) );\n    props.setLook( wlCreateMoveToFolder );\n    fdlCreateMoveToFolder = new FormData();\n    fdlCreateMoveToFolder.left = new FormAttachment( 0, 0 );\n    fdlCreateMoveToFolder.top = new FormAttachment( wDestinationFolder, margin );\n    fdlCreateMoveToFolder.right = new FormAttachment( middle, -margin );\n    wlCreateMoveToFolder.setLayoutData( fdlCreateMoveToFolder );\n    wCreateMoveToFolder = new Button( wMoveToGroup, SWT.CHECK );\n    props.setLook( wCreateMoveToFolder );\n    wCreateMoveToFolder.setToolTipText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.CreateMoveToFolder.Tooltip\" ) );\n    fdCreateMoveToFolder = new FormData();\n    fdCreateMoveToFolder.left = new FormAttachment( middle, 0 );\n    fdCreateMoveToFolder.top = new FormAttachment( wDestinationFolder, margin );\n    fdCreateMoveToFolder.right = new FormAttachment( 100, 0 );\n    wCreateMoveToFolder.setLayoutData( fdCreateMoveToFolder );\n    wCreateMoveToFolder.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Create multi-part file?\n    wlAddMovedDate = new Label( wMoveToGroup, SWT.RIGHT );\n    wlAddMovedDate.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddMovedDate.Label\" ) );\n    props.setLook( wlAddMovedDate );\n    fdlAddMovedDate = new FormData();\n    fdlAddMovedDate.left = new FormAttachment( 0, 0 );\n    fdlAddMovedDate.top = new FormAttachment( wCreateMoveToFolder, margin );\n    fdlAddMovedDate.right = new FormAttachment( middle, -margin );\n    wlAddMovedDate.setLayoutData( fdlAddMovedDate );\n    wAddMovedDate = new Button( wMoveToGroup, SWT.CHECK );\n    props.setLook( wAddMovedDate );\n    wAddMovedDate.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddMovedDate.Tooltip\" ) );\n    fdAddMovedDate = new FormData();\n    fdAddMovedDate.left = new FormAttachment( middle, 0 );\n    fdAddMovedDate.top = new FormAttachment( wCreateMoveToFolder, margin );\n    fdAddMovedDate.right = new FormAttachment( 100, 0 );\n    wAddMovedDate.setLayoutData( fdAddMovedDate );\n    wAddMovedDate.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        setAddMovedDateBeforeExtension();\n      }\n    } );\n    // Create multi-part file?\n    wlAddMovedTime = new Label( wMoveToGroup, SWT.RIGHT );\n    wlAddMovedTime.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddMovedTime.Label\" ) );\n    props.setLook( wlAddMovedTime );\n    fdlAddMovedTime = new FormData();\n    fdlAddMovedTime.left = new FormAttachment( 0, 0 );\n    fdlAddMovedTime.top = new FormAttachment( wAddMovedDate, margin );\n    fdlAddMovedTime.right = new FormAttachment( middle, -margin );\n    wlAddMovedTime.setLayoutData( fdlAddMovedTime );\n    wAddMovedTime = new Button( wMoveToGroup, SWT.CHECK );\n    props.setLook( wAddMovedTime );\n    wAddMovedTime.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddMovedTime.Tooltip\" ) );\n    fdAddMovedTime = new FormData();\n    fdAddMovedTime.left = new FormAttachment( middle, 0 );\n    fdAddMovedTime.top = new FormAttachment( wAddMovedDate, margin );\n    fdAddMovedTime.right = new FormAttachment( 100, 0 );\n    wAddMovedTime.setLayoutData( fdAddMovedTime );\n    wAddMovedTime.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        setAddMovedDateBeforeExtension();\n      }\n    } );\n\n    // Specify date time format?\n    wlSpecifyMoveFormat = new Label( wMoveToGroup, SWT.RIGHT );\n    wlSpecifyMoveFormat.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SpecifyMoveFormat.Label\" ) );\n    props.setLook( wlSpecifyMoveFormat );\n    fdlSpecifyMoveFormat = new FormData();\n    fdlSpecifyMoveFormat.left = new FormAttachment( 0, 0 );\n    fdlSpecifyMoveFormat.top = new FormAttachment( wAddMovedTime, margin );\n    fdlSpecifyMoveFormat.right = new FormAttachment( middle, -margin );\n    wlSpecifyMoveFormat.setLayoutData( fdlSpecifyMoveFormat );\n    wSpecifyMoveFormat = new Button( wMoveToGroup, SWT.CHECK );\n    props.setLook( wSpecifyMoveFormat );\n    wSpecifyMoveFormat.setToolTipText( BaseMessages\n      .getString( PKG, \"JobPGPEncryptFiles.SpecifyMoveFormat.Tooltip\" ) );\n    fdSpecifyMoveFormat = new FormData();\n    fdSpecifyMoveFormat.left = new FormAttachment( middle, 0 );\n    fdSpecifyMoveFormat.top = new FormAttachment( wAddMovedTime, margin );\n    fdSpecifyMoveFormat.right = new FormAttachment( 100, 0 );\n    wSpecifyMoveFormat.setLayoutData( fdSpecifyMoveFormat );\n    wSpecifyMoveFormat.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        setMovedDateTimeFormat();\n        setAddMovedDateBeforeExtension();\n      }\n    } );\n\n    // Moved DateTimeFormat\n    wlMovedDateTimeFormat = new Label( wMoveToGroup, SWT.RIGHT );\n    wlMovedDateTimeFormat.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.MovedDateTimeFormat.Label\" ) );\n    props.setLook( wlMovedDateTimeFormat );\n    fdlMovedDateTimeFormat = new FormData();\n    fdlMovedDateTimeFormat.left = new FormAttachment( 0, 0 );\n    fdlMovedDateTimeFormat.top = new FormAttachment( wSpecifyMoveFormat, margin );\n    fdlMovedDateTimeFormat.right = new FormAttachment( middle, -margin );\n    wlMovedDateTimeFormat.setLayoutData( fdlMovedDateTimeFormat );\n    wMovedDateTimeFormat = new CCombo( wMoveToGroup, SWT.BORDER | SWT.READ_ONLY );\n    wMovedDateTimeFormat.setEditable( true );\n    props.setLook( wMovedDateTimeFormat );\n    wMovedDateTimeFormat.addModifyListener( lsMod );\n    fdMovedDateTimeFormat = new FormData();\n    fdMovedDateTimeFormat.left = new FormAttachment( middle, 0 );\n    fdMovedDateTimeFormat.top = new FormAttachment( wSpecifyMoveFormat, margin );\n    fdMovedDateTimeFormat.right = new FormAttachment( 100, 0 );\n    wMovedDateTimeFormat.setLayoutData( fdMovedDateTimeFormat );\n\n    for ( int x = 0; x < dats.length; x++ ) {\n      wMovedDateTimeFormat.add( dats[x] );\n    }\n\n    // Add Date before extension?\n    wlAddMovedDateBeforeExtension = new Label( wMoveToGroup, SWT.RIGHT );\n    wlAddMovedDateBeforeExtension.setText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.AddMovedDateBeforeExtension.Label\" ) );\n    props.setLook( wlAddMovedDateBeforeExtension );\n    fdlAddMovedDateBeforeExtension = new FormData();\n    fdlAddMovedDateBeforeExtension.left = new FormAttachment( 0, 0 );\n    fdlAddMovedDateBeforeExtension.top = new FormAttachment( wMovedDateTimeFormat, margin );\n    fdlAddMovedDateBeforeExtension.right = new FormAttachment( middle, -margin );\n    wlAddMovedDateBeforeExtension.setLayoutData( fdlAddMovedDateBeforeExtension );\n    wAddMovedDateBeforeExtension = new Button( wMoveToGroup, SWT.CHECK );\n    props.setLook( wAddMovedDateBeforeExtension );\n    wAddMovedDateBeforeExtension.setToolTipText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.AddMovedDateBeforeExtension.Tooltip\" ) );\n    fdAddMovedDateBeforeExtension = new FormData();\n    fdAddMovedDateBeforeExtension.left = new FormAttachment( middle, 0 );\n    fdAddMovedDateBeforeExtension.top = new FormAttachment( wMovedDateTimeFormat, margin );\n    fdAddMovedDateBeforeExtension.right = new FormAttachment( 100, 0 );\n    wAddMovedDateBeforeExtension.setLayoutData( fdAddMovedDateBeforeExtension );\n    wAddMovedDateBeforeExtension.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // If moved File Exists\n    wlIfMovedFileExists = new Label( wMoveToGroup, SWT.RIGHT );\n    wlIfMovedFileExists.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.IfMovedFileExists.Label\" ) );\n    props.setLook( wlIfMovedFileExists );\n    fdlIfMovedFileExists = new FormData();\n    fdlIfMovedFileExists.left = new FormAttachment( 0, 0 );\n    fdlIfMovedFileExists.right = new FormAttachment( middle, 0 );\n    fdlIfMovedFileExists.top = new FormAttachment( wAddMovedDateBeforeExtension, margin );\n    wlIfMovedFileExists.setLayoutData( fdlIfMovedFileExists );\n    wIfMovedFileExists = new CCombo( wMoveToGroup, SWT.SINGLE | SWT.READ_ONLY | SWT.BORDER );\n    wIfMovedFileExists\n      .add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Do_Nothing_IfMovedFileExists.Label\" ) );\n    wIfMovedFileExists.add( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.Overwrite_Filename_IffMovedFileExists.Label\" ) );\n    wIfMovedFileExists\n      .add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.UniqueName_IfMovedFileExists.Label\" ) );\n    wIfMovedFileExists.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fail_IfMovedFileExists.Label\" ) );\n    wIfMovedFileExists.select( 0 ); // +1: starts at -1\n\n    props.setLook( wIfMovedFileExists );\n    fdIfMovedFileExists = new FormData();\n    fdIfMovedFileExists.left = new FormAttachment( middle, 0 );\n    fdIfMovedFileExists.top = new FormAttachment( wAddMovedDateBeforeExtension, margin );\n    fdIfMovedFileExists.right = new FormAttachment( 100, 0 );\n    wIfMovedFileExists.setLayoutData( fdIfMovedFileExists );\n\n    fdIfMovedFileExists = new FormData();\n    fdIfMovedFileExists.left = new FormAttachment( middle, 0 );\n    fdIfMovedFileExists.top = new FormAttachment( wAddMovedDateBeforeExtension, margin );\n    fdIfMovedFileExists.right = new FormAttachment( 100, 0 );\n    wIfMovedFileExists.setLayoutData( fdIfMovedFileExists );\n\n    fdMoveToGroup = new FormData();\n    fdMoveToGroup.left = new FormAttachment( 0, margin );\n    fdMoveToGroup.top = new FormAttachment( wDestinationFile, margin );\n    fdMoveToGroup.right = new FormAttachment( 100, -margin );\n    wMoveToGroup.setLayoutData( fdMoveToGroup );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF MoveToGroup GROUP\n    // ///////////////////////////////////////////////////////////\n\n    fdDestinationFileComp = new FormData();\n    fdDestinationFileComp.left = new FormAttachment( 0, 0 );\n    fdDestinationFileComp.top = new FormAttachment( 0, 0 );\n    fdDestinationFileComp.right = new FormAttachment( 100, 0 );\n    fdDestinationFileComp.bottom = new FormAttachment( 100, 0 );\n    wDestinationFileComp.setLayoutData( wDestinationFileComp );\n\n    wDestinationFileComp.layout();\n    wDestinationFileTab.setControl( wDestinationFileComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF DESTINATION FILETAB\n    // ///////////////////////////////////////////////////////////\n\n    // ////////////////////////////////////\n    // START OF ADVANCED TAB ///\n    // ///////////////////////////////////\n\n    wAdvancedTab = new CTabItem( wTabFolder, SWT.NONE );\n    wAdvancedTab.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Tab.Advanced.Label\" ) );\n\n    FormLayout contentLayout = new FormLayout();\n    contentLayout.marginWidth = 3;\n    contentLayout.marginHeight = 3;\n\n    wAdvancedComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wAdvancedComp );\n    wAdvancedComp.setLayout( contentLayout );\n\n    // SuccessOngrouping?\n    // ////////////////////////\n    // START OF SUCCESS ON GROUP///\n    // /\n    wSuccessOn = new Group( wAdvancedComp, SWT.SHADOW_NONE );\n    props.setLook( wSuccessOn );\n    wSuccessOn.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SuccessOn.Group.Label\" ) );\n\n    FormLayout successongroupLayout = new FormLayout();\n    successongroupLayout.marginWidth = 10;\n    successongroupLayout.marginHeight = 10;\n\n    wSuccessOn.setLayout( successongroupLayout );\n\n    // Success Condition\n    wlSuccessCondition = new Label( wSuccessOn, SWT.RIGHT );\n    wlSuccessCondition.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SuccessCondition.Label\" ) );\n    props.setLook( wlSuccessCondition );\n    fdlSuccessCondition = new FormData();\n    fdlSuccessCondition.left = new FormAttachment( 0, 0 );\n    fdlSuccessCondition.right = new FormAttachment( middle, 0 );\n    fdlSuccessCondition.top = new FormAttachment( 0, margin );\n    wlSuccessCondition.setLayoutData( fdlSuccessCondition );\n    wSuccessCondition = new CCombo( wSuccessOn, SWT.SINGLE | SWT.READ_ONLY | SWT.BORDER );\n    wSuccessCondition.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SuccessWhenAllWorksFine.Label\" ) );\n    wSuccessCondition.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SuccessWhenAtLeat.Label\" ) );\n    wSuccessCondition.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SuccessWhenErrorsLessThan.Label\" ) );\n\n    wSuccessCondition.select( 0 ); // +1: starts at -1\n\n    props.setLook( wSuccessCondition );\n    fdSuccessCondition = new FormData();\n    fdSuccessCondition.left = new FormAttachment( middle, 0 );\n    fdSuccessCondition.top = new FormAttachment( 0, margin );\n    fdSuccessCondition.right = new FormAttachment( 100, 0 );\n    wSuccessCondition.setLayoutData( fdSuccessCondition );\n    wSuccessCondition.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        activeSuccessCondition();\n\n      }\n    } );\n\n    // Success when number of errors less than\n    wlNrErrorsLessThan = new Label( wSuccessOn, SWT.RIGHT );\n    wlNrErrorsLessThan.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.NrErrorsLessThan.Label\" ) );\n    props.setLook( wlNrErrorsLessThan );\n    fdlNrErrorsLessThan = new FormData();\n    fdlNrErrorsLessThan.left = new FormAttachment( 0, 0 );\n    fdlNrErrorsLessThan.top = new FormAttachment( wSuccessCondition, margin );\n    fdlNrErrorsLessThan.right = new FormAttachment( middle, -margin );\n    wlNrErrorsLessThan.setLayoutData( fdlNrErrorsLessThan );\n\n    wNrErrorsLessThan =\n      new TextVar( jobMeta, wSuccessOn, SWT.SINGLE | SWT.LEFT | SWT.BORDER, BaseMessages.getString(\n        PKG, \"JobPGPEncryptFiles.NrErrorsLessThan.Tooltip\" ) );\n    props.setLook( wNrErrorsLessThan );\n    wNrErrorsLessThan.addModifyListener( lsMod );\n    fdNrErrorsLessThan = new FormData();\n    fdNrErrorsLessThan.left = new FormAttachment( middle, 0 );\n    fdNrErrorsLessThan.top = new FormAttachment( wSuccessCondition, margin );\n    fdNrErrorsLessThan.right = new FormAttachment( 100, -margin );\n    wNrErrorsLessThan.setLayoutData( fdNrErrorsLessThan );\n\n    fdSuccessOn = new FormData();\n    fdSuccessOn.left = new FormAttachment( 0, margin );\n    fdSuccessOn.top = new FormAttachment( wDestinationFile, margin );\n    fdSuccessOn.right = new FormAttachment( 100, -margin );\n    wSuccessOn.setLayoutData( fdSuccessOn );\n    // ///////////////////////////////////////////////////////////\n    // / END OF Success ON GROUP\n    // ///////////////////////////////////////////////////////////\n\n    // fileresult grouping?\n    // ////////////////////////\n    // START OF LOGGING GROUP///\n    // /\n    wFileResult = new Group( wAdvancedComp, SWT.SHADOW_NONE );\n    props.setLook( wFileResult );\n    wFileResult.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.FileResult.Group.Label\" ) );\n\n    FormLayout fileresultgroupLayout = new FormLayout();\n    fileresultgroupLayout.marginWidth = 10;\n    fileresultgroupLayout.marginHeight = 10;\n\n    wFileResult.setLayout( fileresultgroupLayout );\n\n    // Add file to result\n    wlAddFileToResult = new Label( wFileResult, SWT.RIGHT );\n    wlAddFileToResult.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddFileToResult.Label\" ) );\n    props.setLook( wlAddFileToResult );\n    fdlAddFileToResult = new FormData();\n    fdlAddFileToResult.left = new FormAttachment( 0, 0 );\n    fdlAddFileToResult.top = new FormAttachment( wSuccessOn, margin );\n    fdlAddFileToResult.right = new FormAttachment( middle, -margin );\n    wlAddFileToResult.setLayoutData( fdlAddFileToResult );\n    wAddFileToResult = new Button( wFileResult, SWT.CHECK );\n    props.setLook( wAddFileToResult );\n    wAddFileToResult.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddFileToResult.Tooltip\" ) );\n    fdAddFileToResult = new FormData();\n    fdAddFileToResult.left = new FormAttachment( middle, 0 );\n    fdAddFileToResult.top = new FormAttachment( wSuccessOn, margin );\n    fdAddFileToResult.right = new FormAttachment( 100, 0 );\n    wAddFileToResult.setLayoutData( fdAddFileToResult );\n    wAddFileToResult.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    fdFileResult = new FormData();\n    fdFileResult.left = new FormAttachment( 0, margin );\n    fdFileResult.top = new FormAttachment( wSuccessOn, margin );\n    fdFileResult.right = new FormAttachment( 100, -margin );\n    wFileResult.setLayoutData( fdFileResult );\n    // ///////////////////////////////////////////////////////////\n    // / END OF FilesResult GROUP\n    // ///////////////////////////////////////////////////////////\n\n    fdAdvancedComp = new FormData();\n    fdAdvancedComp.left = new FormAttachment( 0, 0 );\n    fdAdvancedComp.top = new FormAttachment( 0, 0 );\n    fdAdvancedComp.right = new FormAttachment( 100, 0 );\n    fdAdvancedComp.bottom = new FormAttachment( 100, 0 );\n    wAdvancedComp.setLayoutData( wAdvancedComp );\n\n    wAdvancedComp.layout();\n    wAdvancedTab.setControl( wAdvancedComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF ADVANCED TAB\n    // ///////////////////////////////////////////////////////////\n\n    fdTabFolder = new FormData();\n    fdTabFolder.left = new FormAttachment( 0, 0 );\n    fdTabFolder.top = new FormAttachment( wName, margin );\n    fdTabFolder.right = new FormAttachment( 100, 0 );\n    fdTabFolder.bottom = new FormAttachment( 100, -50 );\n    wTabFolder.setLayoutData( fdTabFolder );\n\n    wOK = new Button( shell, SWT.PUSH );\n    wOK.setText( BaseMessages.getString( PKG, \"System.Button.OK\" ) );\n    wCancel = new Button( shell, SWT.PUSH );\n    wCancel.setText( BaseMessages.getString( PKG, \"System.Button.Cancel\" ) );\n\n    BaseStepDialog.positionBottomButtons( shell, new Button[] { wOK, wCancel }, margin, wTabFolder );\n\n    // Add listeners\n    lsCancel = new Listener() {\n      @Override\n      public void handleEvent( Event e ) {\n        cancel();\n      }\n    };\n    lsOK = new Listener() {\n      @Override\n      public void handleEvent( Event e ) {\n        ok();\n      }\n    };\n\n    wCancel.addListener( SWT.Selection, lsCancel );\n    wOK.addListener( SWT.Selection, lsOK );\n\n    lsDef = new SelectionAdapter() {\n      @Override\n      public void widgetDefaultSelected( SelectionEvent e ) {\n        ok();\n      }\n    };\n\n    wName.addSelectionListener( lsDef );\n    wSourceFileFolder.addSelectionListener( lsDef );\n\n    // Detect X or ALT-F4 or something that kills this window...\n    shell.addShellListener( new ShellAdapter() {\n      @Override\n      public void shellClosed( ShellEvent e ) {\n        cancel();\n      }\n    } );\n\n    getData();\n    CheckIncludeSubFolders();\n    activeSuccessCondition();\n    setDateTimeFormat();\n    activeSuccessCondition();\n\n    activeDestinationFolder();\n    setMovedDateTimeFormat();\n    setAddDateBeforeExtension();\n    setAddMovedDateBeforeExtension();\n    wTabFolder.setSelection( 0 );\n    BaseStepDialog.setSize( shell );\n\n    shell.open();\n    while ( !shell.isDisposed() ) {\n      if ( !display.readAndDispatch() ) {\n        display.sleep();\n      }\n    }\n    return jobEntry;\n  }","commit_id":"b641c2f73460105a960c65b1f0543bf45d255831","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n   * Copy information from the meta-data input to the dialog fields.\n   */\n  public void getData() {\n    if ( jobEntry.getName() != null ) {\n      wName.setText( jobEntry.getName() );\n    }\n    wCopyEmptyFolders.setSelection( jobEntry.copy_empty_folders );\n\n    if ( jobEntry.source_filefolder != null ) {\n      for ( int i = 0; i < jobEntry.source_filefolder.length; i++ ) {\n        TableItem ti = wFields.table.getItem( i );\n        if ( jobEntry.source_filefolder[i] != null ) {\n          ti.setText( 1, jobEntry.source_filefolder[i] );\n        }\n        if ( jobEntry.destination_filefolder[i] != null ) {\n          ti.setText( 2, jobEntry.destination_filefolder[i] );\n        }\n        if ( jobEntry.wildcard[i] != null ) {\n          ti.setText( 3, jobEntry.wildcard[i] );\n        }\n      }\n      wFields.setRowNums();\n      wFields.optWidth( true );\n    }\n    wPrevious.setSelection( jobEntry.arg_from_previous );\n    wOverwriteFiles.setSelection( jobEntry.overwrite_files );\n    wIncludeSubfolders.setSelection( jobEntry.include_subfolders );\n    wRemoveSourceFiles.setSelection( jobEntry.remove_source_files );\n    wDestinationIsAFile.setSelection( jobEntry.destination_is_a_file );\n    wCreateDestinationFolder.setSelection( jobEntry.create_destination_folder );\n\n    wAddFileToResult.setSelection( jobEntry.add_result_filesname );\n\n    wName.selectAll();\n    wName.setFocus();\n  }","id":6730,"modified_method":"/**\n   * Copy information from the meta-data input to the dialog fields.\n   */\n  public void getData() {\n    if ( jobEntry.getName() != null ) {\n      wName.setText( jobEntry.getName() );\n    }\n    wCopyEmptyFolders.setSelection( jobEntry.copy_empty_folders );\n\n    if ( jobEntry.source_filefolder != null ) {\n      for ( int i = 0; i < jobEntry.source_filefolder.length; i++ ) {\n        TableItem ti = wFields.table.getItem( i );\n        if ( jobEntry.source_filefolder[i] != null ) {\n          ti.setText( 1, jobEntry.source_filefolder[i] );\n        }\n        if ( jobEntry.wildcard[i] != null ) {\n          ti.setText( 2, jobEntry.wildcard[i] );\n        }\n        if ( jobEntry.destination_filefolder[i] != null ) {\n          ti.setText( 4, jobEntry.destination_filefolder[i] );\n        }\n      }\n      wFields.setRowNums();\n      wFields.optWidth( true );\n    }\n    wPrevious.setSelection( jobEntry.arg_from_previous );\n    wOverwriteFiles.setSelection( jobEntry.overwrite_files );\n    wIncludeSubfolders.setSelection( jobEntry.include_subfolders );\n    wRemoveSourceFiles.setSelection( jobEntry.remove_source_files );\n    wDestinationIsAFile.setSelection( jobEntry.destination_is_a_file );\n    wCreateDestinationFolder.setSelection( jobEntry.create_destination_folder );\n\n    wAddFileToResult.setSelection( jobEntry.add_result_filesname );\n\n    wName.selectAll();\n    wName.setFocus();\n  }","commit_id":"552d8adb2723f9fb17d3bce7701d53c9c12f4237","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"protected void initUI() {\n    Shell parent = getParent();\n\n    shell = new Shell( parent, props.getJobsDialogStyle() );\n    props.setLook( shell );\n    Button helpButton = JobDialog.setShellImage( shell, jobEntry );\n\n    ModifyListener lsMod = new ModifyListener() {\n      public void modifyText( ModifyEvent e ) {\n        jobEntry.setChanged();\n      }\n    };\n    changed = jobEntry.hasChanged();\n\n    FormLayout formLayout = new FormLayout();\n    formLayout.marginWidth = Const.FORM_MARGIN;\n    formLayout.marginHeight = Const.FORM_MARGIN;\n\n    shell.setLayout( formLayout );\n    shell.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Title\" ) );\n\n    int middle = props.getMiddlePct();\n    int margin = Const.MARGIN;\n\n    // Filename line\n    wlName = new Label( shell, SWT.LEFT );\n    wlName.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Name.Label\" ) );\n    props.setLook( wlName );\n    fdlName = new FormData();\n    fdlName.left = new FormAttachment( 0, 0 );\n    fdlName.right = new FormAttachment( middle, -margin );\n    fdlName.top = new FormAttachment( 0, margin );\n    wlName.setLayoutData( fdlName );\n    wName = new Text( shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wName );\n    wName.addModifyListener( lsMod );\n    fdName = new FormData();\n    fdName.left = new FormAttachment( 0, 0 );\n    fdName.top = new FormAttachment( wlName, margin );\n    fdName.right = new FormAttachment( 40, 0 );\n    wName.setLayoutData( fdName );\n    Label wlIcon = new Label( shell, SWT.RIGHT );\n    wlIcon.setImage( getImage() );\n    props.setLook( wlIcon );\n    FormData fdlIcon = new FormData();\n    fdlIcon.top = new FormAttachment( 0, margin * 3 );\n    fdlIcon.right = new FormAttachment( 100, -margin );\n    wlIcon.setLayoutData( fdlIcon );\n    \n    Label lTopSeparator = new Label( shell, SWT.HORIZONTAL | SWT.SEPARATOR );\n    FormData fdTopSeparator = new FormData();\n    fdTopSeparator.top = new FormAttachment( wName, margin * 3 );\n    fdTopSeparator.left = new FormAttachment( 0, 0 );\n    fdTopSeparator.right = new FormAttachment( 100, 0 );\n    lTopSeparator.setLayoutData( fdTopSeparator );    \n    \n    \n    wTabFolder = new CTabFolder( shell, SWT.BORDER );\n    props.setLook( wTabFolder, Props.WIDGET_STYLE_TAB );\n\n    fdTabFolder = new FormData();\n    fdTabFolder.left = new FormAttachment( 0, 0 );\n    fdTabFolder.top = new FormAttachment( lTopSeparator, margin * 3 );\n    fdTabFolder.right = new FormAttachment( 100, 0 );\n    fdTabFolder.bottom = new FormAttachment( 100, -60 );\n    wTabFolder.setLayoutData( fdTabFolder );\n    \n    // ///////////////////////////////////////////////////////////\n    // / START OF FILES TAB\n    // ///////////////////////////////////////////////////////////\n    \n    wFilesTab = new CTabItem( wTabFolder, SWT.NONE );\n//    wFilesTab.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Tab.Files.Label\" ) );\n    wFilesTab.setText( \"Files\" );\n\n    wFilesComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wFilesComp );\n    \n    FormLayout filesLayout = new FormLayout();\n    filesLayout.marginWidth = 3;\n    filesLayout.marginHeight = 3;\n    wFilesComp.setLayout( filesLayout );\n    \n    fdFilesComp = new FormData();\n    fdFilesComp.left = new FormAttachment( 0, 0 );\n    fdFilesComp.top = new FormAttachment( 0, 0 );\n    fdFilesComp.right = new FormAttachment( 100, 0 );\n    fdFilesComp.bottom = new FormAttachment( 100, 0 );\n    wFilesComp.setLayoutData( fdFilesComp );\n\n    wFilesComp.layout();\n    wFilesTab.setControl( wFilesComp );\n    \n    // ///////////////////////////////////////////////////////////\n    // / END OF FILES TAB\n    // ///////////////////////////////////////////////////////////    \n    \n    // ////////////////////////\n    // START OF SETTINGS TAB ///\n    // ////////////////////////\n\n    wSettingsTab = new CTabItem( wTabFolder, SWT.NONE );\n    wSettingsTab.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Settings.Label\" ) );\n\n    wSettingsComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wSettingsComp );\n\n    FormLayout settingsLayout = new FormLayout();\n    settingsLayout.marginWidth = 3;\n    settingsLayout.marginHeight = 3;\n    wSettingsComp.setLayout( settingsLayout );\n    \n    wlIncludeSubfolders = new Label( wSettingsComp, SWT.RIGHT );\n    wlIncludeSubfolders.setText( BaseMessages.getString( PKG, \"JobCopyFiles.IncludeSubfolders.Label\" ) );\n    props.setLook( wlIncludeSubfolders );\n    fdlIncludeSubfolders = new FormData();\n    fdlIncludeSubfolders.left = new FormAttachment( 0, 0 );\n    fdlIncludeSubfolders.top = new FormAttachment( wName, margin );\n    fdlIncludeSubfolders.right = new FormAttachment( middle, -margin );\n    wlIncludeSubfolders.setLayoutData( fdlIncludeSubfolders );\n    wIncludeSubfolders = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wIncludeSubfolders );\n    wIncludeSubfolders.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.IncludeSubfolders.Tooltip\" ) );\n    fdIncludeSubfolders = new FormData();\n    fdIncludeSubfolders.left = new FormAttachment( middle, 0 );\n    fdIncludeSubfolders.top = new FormAttachment( wName, margin );\n    fdIncludeSubfolders.right = new FormAttachment( 100, 0 );\n    wIncludeSubfolders.setLayoutData( fdIncludeSubfolders );\n    wIncludeSubfolders.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        CheckIncludeSubFolders();\n      }\n    } );\n\n    // Destination is a file?\n    wlDestinationIsAFile = new Label( wSettingsComp, SWT.RIGHT );\n    wlDestinationIsAFile.setText( BaseMessages.getString( PKG, \"JobCopyFiles.DestinationIsAFile.Label\" ) );\n    props.setLook( wlDestinationIsAFile );\n    fdlDestinationIsAFile = new FormData();\n    fdlDestinationIsAFile.left = new FormAttachment( 0, 0 );\n    fdlDestinationIsAFile.top = new FormAttachment( wIncludeSubfolders, margin );\n    fdlDestinationIsAFile.right = new FormAttachment( middle, -margin );\n    wlDestinationIsAFile.setLayoutData( fdlDestinationIsAFile );\n    wDestinationIsAFile = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wDestinationIsAFile );\n    wDestinationIsAFile.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.DestinationIsAFile.Tooltip\" ) );\n    fdDestinationIsAFile = new FormData();\n    fdDestinationIsAFile.left = new FormAttachment( middle, 0 );\n    fdDestinationIsAFile.top = new FormAttachment( wIncludeSubfolders, margin );\n    fdDestinationIsAFile.right = new FormAttachment( 100, 0 );\n    wDestinationIsAFile.setLayoutData( fdDestinationIsAFile );\n    wDestinationIsAFile.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Copy empty folders\n    wlCopyEmptyFolders = new Label( wSettingsComp, SWT.RIGHT );\n    wlCopyEmptyFolders.setText( BaseMessages.getString( PKG, \"JobCopyFiles.CopyEmptyFolders.Label\" ) );\n    props.setLook( wlCopyEmptyFolders );\n    fdlCopyEmptyFolders = new FormData();\n    fdlCopyEmptyFolders.left = new FormAttachment( 0, 0 );\n    fdlCopyEmptyFolders.top = new FormAttachment( wDestinationIsAFile, margin );\n    fdlCopyEmptyFolders.right = new FormAttachment( middle, -margin );\n    wlCopyEmptyFolders.setLayoutData( fdlCopyEmptyFolders );\n    wCopyEmptyFolders = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wCopyEmptyFolders );\n    wCopyEmptyFolders.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.CopyEmptyFolders.Tooltip\" ) );\n    fdCopyEmptyFolders = new FormData();\n    fdCopyEmptyFolders.left = new FormAttachment( middle, 0 );\n    fdCopyEmptyFolders.top = new FormAttachment( wDestinationIsAFile, margin );\n    fdCopyEmptyFolders.right = new FormAttachment( 100, 0 );\n    wCopyEmptyFolders.setLayoutData( fdCopyEmptyFolders );\n    wCopyEmptyFolders.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Create destination folder/parent folder\n    wlCreateDestinationFolder = new Label( wSettingsComp, SWT.RIGHT );\n    wlCreateDestinationFolder\n      .setText( BaseMessages.getString( PKG, \"JobCopyFiles.CreateDestinationFolder.Label\" ) );\n    props.setLook( wlCreateDestinationFolder );\n    fdlCreateDestinationFolder = new FormData();\n    fdlCreateDestinationFolder.left = new FormAttachment( 0, 0 );\n    fdlCreateDestinationFolder.top = new FormAttachment( wCopyEmptyFolders, margin );\n    fdlCreateDestinationFolder.right = new FormAttachment( middle, -margin );\n    wlCreateDestinationFolder.setLayoutData( fdlCreateDestinationFolder );\n    wCreateDestinationFolder = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wCreateDestinationFolder );\n    wCreateDestinationFolder.setToolTipText( BaseMessages.getString(\n      PKG, \"JobCopyFiles.CreateDestinationFolder.Tooltip\" ) );\n    fdCreateDestinationFolder = new FormData();\n    fdCreateDestinationFolder.left = new FormAttachment( middle, 0 );\n    fdCreateDestinationFolder.top = new FormAttachment( wCopyEmptyFolders, margin );\n    fdCreateDestinationFolder.right = new FormAttachment( 100, 0 );\n    wCreateDestinationFolder.setLayoutData( fdCreateDestinationFolder );\n    wCreateDestinationFolder.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // OverwriteFiles Option\n    wlOverwriteFiles = new Label( wSettingsComp, SWT.RIGHT );\n    wlOverwriteFiles.setText( BaseMessages.getString( PKG, \"JobCopyFiles.OverwriteFiles.Label\" ) );\n    props.setLook( wlOverwriteFiles );\n    fdlOverwriteFiles = new FormData();\n    fdlOverwriteFiles.left = new FormAttachment( 0, 0 );\n    fdlOverwriteFiles.top = new FormAttachment( wCreateDestinationFolder, margin );\n    fdlOverwriteFiles.right = new FormAttachment( middle, -margin );\n    wlOverwriteFiles.setLayoutData( fdlOverwriteFiles );\n    wOverwriteFiles = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wOverwriteFiles );\n    wOverwriteFiles.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.OverwriteFiles.Tooltip\" ) );\n    fdOverwriteFiles = new FormData();\n    fdOverwriteFiles.left = new FormAttachment( middle, 0 );\n    fdOverwriteFiles.top = new FormAttachment( wCreateDestinationFolder, margin );\n    fdOverwriteFiles.right = new FormAttachment( 100, 0 );\n    wOverwriteFiles.setLayoutData( fdOverwriteFiles );\n    wOverwriteFiles.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Remove source files option\n    wlRemoveSourceFiles = new Label( wSettingsComp, SWT.RIGHT );\n    wlRemoveSourceFiles.setText( BaseMessages.getString( PKG, \"JobCopyFiles.RemoveSourceFiles.Label\" ) );\n    props.setLook( wlRemoveSourceFiles );\n    fdlRemoveSourceFiles = new FormData();\n    fdlRemoveSourceFiles.left = new FormAttachment( 0, 0 );\n    fdlRemoveSourceFiles.top = new FormAttachment( wOverwriteFiles, margin );\n    fdlRemoveSourceFiles.right = new FormAttachment( middle, -margin );\n    wlRemoveSourceFiles.setLayoutData( fdlRemoveSourceFiles );\n    wRemoveSourceFiles = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wRemoveSourceFiles );\n    wRemoveSourceFiles.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.RemoveSourceFiles.Tooltip\" ) );\n    fdRemoveSourceFiles = new FormData();\n    fdRemoveSourceFiles.left = new FormAttachment( middle, 0 );\n    fdRemoveSourceFiles.top = new FormAttachment( wOverwriteFiles, margin );\n    fdRemoveSourceFiles.right = new FormAttachment( 100, 0 );\n    wRemoveSourceFiles.setLayoutData( fdRemoveSourceFiles );\n    wRemoveSourceFiles.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    wlPrevious = new Label( wSettingsComp, SWT.RIGHT );\n    wlPrevious.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Previous.Label\" ) );\n    props.setLook( wlPrevious );\n    fdlPrevious = new FormData();\n    fdlPrevious.left = new FormAttachment( 0, 0 );\n    fdlPrevious.top = new FormAttachment( wRemoveSourceFiles, margin );\n    fdlPrevious.right = new FormAttachment( middle, -margin );\n    wlPrevious.setLayoutData( fdlPrevious );\n    wPrevious = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wPrevious );\n    wPrevious.setSelection( jobEntry.arg_from_previous );\n    wPrevious.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.Previous.Tooltip\" ) );\n    fdPrevious = new FormData();\n    fdPrevious.left = new FormAttachment( middle, 0 );\n    fdPrevious.top = new FormAttachment( wRemoveSourceFiles, margin );\n    fdPrevious.right = new FormAttachment( 100, 0 );\n    wPrevious.setLayoutData( fdPrevious );\n    wPrevious.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n\n        refreshArgFromPrevious();\n\n      }\n    } );\n    \n    // Add file to result\n    wlAddFileToResult = new Label( wSettingsComp, SWT.RIGHT );\n    wlAddFileToResult.setText( BaseMessages.getString( PKG, \"JobCopyFiles.AddFileToResult.Label\" ) );\n    props.setLook( wlAddFileToResult );\n    fdlAddFileToResult = new FormData();\n    fdlAddFileToResult.left = new FormAttachment( 0, 0 );\n    fdlAddFileToResult.top = new FormAttachment( wPrevious, margin );\n    fdlAddFileToResult.right = new FormAttachment( middle, -margin );\n    wlAddFileToResult.setLayoutData( fdlAddFileToResult );\n    wAddFileToResult = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wAddFileToResult );\n    wAddFileToResult.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.AddFileToResult.Tooltip\" ) );\n    fdAddFileToResult = new FormData();\n    fdAddFileToResult.left = new FormAttachment( middle, 0 );\n    fdAddFileToResult.top = new FormAttachment( wPrevious, margin );\n    fdAddFileToResult.right = new FormAttachment( 100, 0 );\n    wAddFileToResult.setLayoutData( fdAddFileToResult );\n    wAddFileToResult.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n    \n    fdSettingsComp = new FormData();\n    fdSettingsComp.left = new FormAttachment( 0, 0 );\n    fdSettingsComp.top = new FormAttachment( 0, 0 );\n    fdSettingsComp.right = new FormAttachment( 100, 0 );\n    fdSettingsComp.bottom = new FormAttachment( 100, 0 );\n    wSettingsComp.setLayoutData( fdSettingsComp );\n\n    wSettingsComp.layout();\n    wSettingsTab.setControl( wSettingsComp );\n    props.setLook( wSettingsComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF SETTINGS TAB\n    // ///////////////////////////////////////////////////////////    \n    \n    ToolBar tb = new ToolBar( wFilesComp, SWT.HORIZONTAL | SWT.FLAT );\n    props.setLook( tb );\n    FormData fdTb = new FormData();\n    fdTb.right = new FormAttachment( 100, 0 );\n    fdTb.top = new FormAttachment( wFilesComp, margin );\n    tb.setLayoutData( fdTb );\n\n    deleteToolItem = new ToolItem( tb, SWT.PUSH );\n    deleteToolItem.setImage( GUIResource.getInstance().getImageDelete() );\n    deleteToolItem.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.FilenameDelete.Tooltip\" ) );\n    deleteToolItem.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent arg0 ) {\n        int[] idx = wFields.getSelectionIndices();\n        wFields.remove( idx );\n        wFields.removeEmptyRows();\n        wFields.setRowNums();\n      }\n    } );\n\n    wlFields = new Label( wFilesComp, SWT.NONE );\n    wlFields.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.Label\" ) );\n    props.setLook( wlFields );\n    fdlFields = new FormData();\n    fdlFields.left = new FormAttachment( 0, margin );\n    fdlFields.right = new FormAttachment( middle, -margin );\n    fdlFields.top = new FormAttachment( wFilesComp, 15 );\n    wlFields.setLayoutData( fdlFields );\n\n    int rows =\n      jobEntry.source_filefolder == null ? 1 : ( jobEntry.source_filefolder.length == 0\n        ? 0 : jobEntry.source_filefolder.length );\n    final int FieldsRows = rows;\n\n    ColumnInfo[] colinf =\n      new ColumnInfo[] {\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobCopyFiles.Fields.SourceFileFolder.Label\" ),\n          ColumnInfo.COLUMN_TYPE_TEXT_BUTTON, false ),\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobCopyFiles.Fields.DestinationFileFolder.Label\" ),\n          ColumnInfo.COLUMN_TYPE_TEXT_BUTTON, false ),\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobCopyFiles.Fields.Wildcard.Label\" ), ColumnInfo.COLUMN_TYPE_TEXT,\n          false ), };\n\n    colinf[0].setUsingVariables( true );\n    colinf[0].setToolTip( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.SourceFileFolder.Tooltip\" ) );\n    colinf[1].setUsingVariables( true );\n    colinf[1].setToolTip( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.DestinationFileFolder.Tooltip\" ) );\n    colinf[2].setUsingVariables( true );\n    colinf[2].setToolTip( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.Wildcard.Tooltip\" ) );\n\n    colinf[0].setTextVarButtonSelectionListener( getFileSelectionAdapter() );\n    colinf[1].setTextVarButtonSelectionListener( getFileSelectionAdapter() );\n    \n    wFields =\n      new TableView(\n        jobMeta, wFilesComp, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, colinf, FieldsRows, lsMod, props );\n\n    fdFields = new FormData();\n    fdFields.left = new FormAttachment( 0, margin );\n    fdFields.top = new FormAttachment( tb, margin );\n    fdFields.right = new FormAttachment( 100, -margin );\n    fdFields.bottom = new FormAttachment( 100, -margin );\n    wFields.setLayoutData( fdFields );\n\n    refreshArgFromPrevious();\n\n    wOK = new Button( shell, SWT.PUSH );\n    wOK.setText( BaseMessages.getString( PKG, \"System.Button.OK\" ) );\n    wCancel = new Button( shell, SWT.PUSH );\n    wCancel.setText( BaseMessages.getString( PKG, \"System.Button.Cancel\" ) );\n\n    Label lBottomSeparator = new Label( shell, SWT.HORIZONTAL | SWT.SEPARATOR );\n    FormData fdBottomSeparator = new FormData();\n    fdBottomSeparator.top = new FormAttachment( wTabFolder, margin * 3 );\n    fdBottomSeparator.left = new FormAttachment( 0, 0 );\n    fdBottomSeparator.right = new FormAttachment( 100, 0 );\n    lBottomSeparator.setLayoutData( fdBottomSeparator );\n\n    BaseStepDialog.positionBottomRightButtons( shell, new Button[] { wOK, wCancel }, margin, lBottomSeparator );\n    FormData fdOK = (FormData) wOK.getLayoutData();\n    FormData fdHelpButton = new FormData();\n    fdHelpButton.top = fdOK.top;\n    fdHelpButton.left = new FormAttachment( 0, margin );\n    helpButton.setLayoutData( fdHelpButton );\n\n    // Add listeners\n    lsCancel = new Listener() {\n      public void handleEvent( Event e ) {\n        cancel();\n      }\n    };\n    lsOK = new Listener() {\n      public void handleEvent( Event e ) {\n        ok();\n      }\n    };\n\n    wCancel.addListener( SWT.Selection, lsCancel );\n    wOK.addListener( SWT.Selection, lsOK );\n\n    lsDef = new SelectionAdapter() {\n      public void widgetDefaultSelected( SelectionEvent e ) {\n        ok();\n      }\n    };\n\n    wName.addSelectionListener( lsDef );\n\n    // Detect X or ALT-F4 or something that kills this window...\n    shell.addShellListener( new ShellAdapter() {\n      public void shellClosed( ShellEvent e ) {\n        cancel();\n      }\n    } );\n\n    getData();\n    CheckIncludeSubFolders();\n    wTabFolder.setSelection( 0 );\n    \n  }","id":6731,"modified_method":"protected void initUI() {\n    Shell parent = getParent();\n\n    shell = new Shell( parent, props.getJobsDialogStyle() );\n    props.setLook( shell );\n    Button helpButton = JobDialog.setShellImage( shell, jobEntry );\n\n    ModifyListener lsMod = new ModifyListener() {\n      public void modifyText( ModifyEvent e ) {\n        jobEntry.setChanged();\n      }\n    };\n    changed = jobEntry.hasChanged();\n\n    FormLayout formLayout = new FormLayout();\n    formLayout.marginWidth = Const.FORM_MARGIN;\n    formLayout.marginHeight = Const.FORM_MARGIN;\n\n    shell.setLayout( formLayout );\n    shell.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Title\" ) );\n\n    int middle = props.getMiddlePct();\n    int margin = Const.MARGIN;\n\n    // Filename line\n    wlName = new Label( shell, SWT.LEFT );\n    wlName.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Name.Label\" ) );\n    props.setLook( wlName );\n    fdlName = new FormData();\n    fdlName.left = new FormAttachment( 0, 0 );\n    fdlName.right = new FormAttachment( middle, -margin );\n    fdlName.top = new FormAttachment( 0, margin );\n    wlName.setLayoutData( fdlName );\n    wName = new Text( shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wName );\n    wName.addModifyListener( lsMod );\n    fdName = new FormData();\n    fdName.left = new FormAttachment( 0, 0 );\n    fdName.top = new FormAttachment( wlName, margin );\n    fdName.right = new FormAttachment( 40, 0 );\n    wName.setLayoutData( fdName );\n    Label wlIcon = new Label( shell, SWT.RIGHT );\n    wlIcon.setImage( getImage() );\n    props.setLook( wlIcon );\n    FormData fdlIcon = new FormData();\n    fdlIcon.top = new FormAttachment( 0, margin * 3 );\n    fdlIcon.right = new FormAttachment( 100, -margin );\n    wlIcon.setLayoutData( fdlIcon );\n    \n    Label lTopSeparator = new Label( shell, SWT.HORIZONTAL | SWT.SEPARATOR );\n    FormData fdTopSeparator = new FormData();\n    fdTopSeparator.top = new FormAttachment( wName, margin * 3 );\n    fdTopSeparator.left = new FormAttachment( 0, 0 );\n    fdTopSeparator.right = new FormAttachment( 100, 0 );\n    lTopSeparator.setLayoutData( fdTopSeparator );    \n    \n    \n    wTabFolder = new CTabFolder( shell, SWT.BORDER );\n    props.setLook( wTabFolder, Props.WIDGET_STYLE_TAB );\n\n    fdTabFolder = new FormData();\n    fdTabFolder.left = new FormAttachment( 0, 0 );\n    fdTabFolder.top = new FormAttachment( lTopSeparator, margin * 3 );\n    fdTabFolder.right = new FormAttachment( 100, 0 );\n    fdTabFolder.bottom = new FormAttachment( 100, -60 );\n    wTabFolder.setLayoutData( fdTabFolder );\n    \n    // ///////////////////////////////////////////////////////////\n    // / START OF FILES TAB\n    // ///////////////////////////////////////////////////////////\n    \n    wFilesTab = new CTabItem( wTabFolder, SWT.NONE );\n    wFilesTab.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Tab.Files.Label\" ) );\n\n    wFilesComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wFilesComp );\n    \n    FormLayout filesLayout = new FormLayout();\n    filesLayout.marginWidth = 3;\n    filesLayout.marginHeight = 3;\n    wFilesComp.setLayout( filesLayout );\n    \n    fdFilesComp = new FormData();\n    fdFilesComp.left = new FormAttachment( 0, 0 );\n    fdFilesComp.top = new FormAttachment( 0, 0 );\n    fdFilesComp.right = new FormAttachment( 100, 0 );\n    fdFilesComp.bottom = new FormAttachment( 100, 0 );\n    wFilesComp.setLayoutData( fdFilesComp );\n\n    wFilesComp.layout();\n    wFilesTab.setControl( wFilesComp );\n    \n    // ///////////////////////////////////////////////////////////\n    // / END OF FILES TAB\n    // ///////////////////////////////////////////////////////////    \n    \n    // ////////////////////////\n    // START OF SETTINGS TAB ///\n    // ////////////////////////\n\n    wSettingsTab = new CTabItem( wTabFolder, SWT.NONE );\n    wSettingsTab.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Settings.Label\" ) );\n\n    wSettingsComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wSettingsComp );\n\n    FormLayout settingsLayout = new FormLayout();\n    settingsLayout.marginWidth = 3;\n    settingsLayout.marginHeight = 3;\n    wSettingsComp.setLayout( settingsLayout );\n    \n    wlIncludeSubfolders = new Label( wSettingsComp, SWT.RIGHT );\n    wlIncludeSubfolders.setText( BaseMessages.getString( PKG, \"JobCopyFiles.IncludeSubfolders.Label\" ) );\n    props.setLook( wlIncludeSubfolders );\n    fdlIncludeSubfolders = new FormData();\n    fdlIncludeSubfolders.left = new FormAttachment( 0, 0 );\n    fdlIncludeSubfolders.top = new FormAttachment( wName, margin );\n    fdlIncludeSubfolders.right = new FormAttachment( middle, -margin );\n    wlIncludeSubfolders.setLayoutData( fdlIncludeSubfolders );\n    wIncludeSubfolders = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wIncludeSubfolders );\n    wIncludeSubfolders.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.IncludeSubfolders.Tooltip\" ) );\n    fdIncludeSubfolders = new FormData();\n    fdIncludeSubfolders.left = new FormAttachment( middle, 0 );\n    fdIncludeSubfolders.top = new FormAttachment( wName, margin );\n    fdIncludeSubfolders.right = new FormAttachment( 100, 0 );\n    wIncludeSubfolders.setLayoutData( fdIncludeSubfolders );\n    wIncludeSubfolders.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        CheckIncludeSubFolders();\n      }\n    } );\n\n    // Destination is a file?\n    wlDestinationIsAFile = new Label( wSettingsComp, SWT.RIGHT );\n    wlDestinationIsAFile.setText( BaseMessages.getString( PKG, \"JobCopyFiles.DestinationIsAFile.Label\" ) );\n    props.setLook( wlDestinationIsAFile );\n    fdlDestinationIsAFile = new FormData();\n    fdlDestinationIsAFile.left = new FormAttachment( 0, 0 );\n    fdlDestinationIsAFile.top = new FormAttachment( wIncludeSubfolders, margin );\n    fdlDestinationIsAFile.right = new FormAttachment( middle, -margin );\n    wlDestinationIsAFile.setLayoutData( fdlDestinationIsAFile );\n    wDestinationIsAFile = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wDestinationIsAFile );\n    wDestinationIsAFile.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.DestinationIsAFile.Tooltip\" ) );\n    fdDestinationIsAFile = new FormData();\n    fdDestinationIsAFile.left = new FormAttachment( middle, 0 );\n    fdDestinationIsAFile.top = new FormAttachment( wIncludeSubfolders, margin );\n    fdDestinationIsAFile.right = new FormAttachment( 100, 0 );\n    wDestinationIsAFile.setLayoutData( fdDestinationIsAFile );\n    wDestinationIsAFile.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Copy empty folders\n    wlCopyEmptyFolders = new Label( wSettingsComp, SWT.RIGHT );\n    wlCopyEmptyFolders.setText( BaseMessages.getString( PKG, \"JobCopyFiles.CopyEmptyFolders.Label\" ) );\n    props.setLook( wlCopyEmptyFolders );\n    fdlCopyEmptyFolders = new FormData();\n    fdlCopyEmptyFolders.left = new FormAttachment( 0, 0 );\n    fdlCopyEmptyFolders.top = new FormAttachment( wDestinationIsAFile, margin );\n    fdlCopyEmptyFolders.right = new FormAttachment( middle, -margin );\n    wlCopyEmptyFolders.setLayoutData( fdlCopyEmptyFolders );\n    wCopyEmptyFolders = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wCopyEmptyFolders );\n    wCopyEmptyFolders.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.CopyEmptyFolders.Tooltip\" ) );\n    fdCopyEmptyFolders = new FormData();\n    fdCopyEmptyFolders.left = new FormAttachment( middle, 0 );\n    fdCopyEmptyFolders.top = new FormAttachment( wDestinationIsAFile, margin );\n    fdCopyEmptyFolders.right = new FormAttachment( 100, 0 );\n    wCopyEmptyFolders.setLayoutData( fdCopyEmptyFolders );\n    wCopyEmptyFolders.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Create destination folder/parent folder\n    wlCreateDestinationFolder = new Label( wSettingsComp, SWT.RIGHT );\n    wlCreateDestinationFolder\n      .setText( BaseMessages.getString( PKG, \"JobCopyFiles.CreateDestinationFolder.Label\" ) );\n    props.setLook( wlCreateDestinationFolder );\n    fdlCreateDestinationFolder = new FormData();\n    fdlCreateDestinationFolder.left = new FormAttachment( 0, 0 );\n    fdlCreateDestinationFolder.top = new FormAttachment( wCopyEmptyFolders, margin );\n    fdlCreateDestinationFolder.right = new FormAttachment( middle, -margin );\n    wlCreateDestinationFolder.setLayoutData( fdlCreateDestinationFolder );\n    wCreateDestinationFolder = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wCreateDestinationFolder );\n    wCreateDestinationFolder.setToolTipText( BaseMessages.getString(\n      PKG, \"JobCopyFiles.CreateDestinationFolder.Tooltip\" ) );\n    fdCreateDestinationFolder = new FormData();\n    fdCreateDestinationFolder.left = new FormAttachment( middle, 0 );\n    fdCreateDestinationFolder.top = new FormAttachment( wCopyEmptyFolders, margin );\n    fdCreateDestinationFolder.right = new FormAttachment( 100, 0 );\n    wCreateDestinationFolder.setLayoutData( fdCreateDestinationFolder );\n    wCreateDestinationFolder.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // OverwriteFiles Option\n    wlOverwriteFiles = new Label( wSettingsComp, SWT.RIGHT );\n    wlOverwriteFiles.setText( BaseMessages.getString( PKG, \"JobCopyFiles.OverwriteFiles.Label\" ) );\n    props.setLook( wlOverwriteFiles );\n    fdlOverwriteFiles = new FormData();\n    fdlOverwriteFiles.left = new FormAttachment( 0, 0 );\n    fdlOverwriteFiles.top = new FormAttachment( wCreateDestinationFolder, margin );\n    fdlOverwriteFiles.right = new FormAttachment( middle, -margin );\n    wlOverwriteFiles.setLayoutData( fdlOverwriteFiles );\n    wOverwriteFiles = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wOverwriteFiles );\n    wOverwriteFiles.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.OverwriteFiles.Tooltip\" ) );\n    fdOverwriteFiles = new FormData();\n    fdOverwriteFiles.left = new FormAttachment( middle, 0 );\n    fdOverwriteFiles.top = new FormAttachment( wCreateDestinationFolder, margin );\n    fdOverwriteFiles.right = new FormAttachment( 100, 0 );\n    wOverwriteFiles.setLayoutData( fdOverwriteFiles );\n    wOverwriteFiles.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Remove source files option\n    wlRemoveSourceFiles = new Label( wSettingsComp, SWT.RIGHT );\n    wlRemoveSourceFiles.setText( BaseMessages.getString( PKG, \"JobCopyFiles.RemoveSourceFiles.Label\" ) );\n    props.setLook( wlRemoveSourceFiles );\n    fdlRemoveSourceFiles = new FormData();\n    fdlRemoveSourceFiles.left = new FormAttachment( 0, 0 );\n    fdlRemoveSourceFiles.top = new FormAttachment( wOverwriteFiles, margin );\n    fdlRemoveSourceFiles.right = new FormAttachment( middle, -margin );\n    wlRemoveSourceFiles.setLayoutData( fdlRemoveSourceFiles );\n    wRemoveSourceFiles = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wRemoveSourceFiles );\n    wRemoveSourceFiles.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.RemoveSourceFiles.Tooltip\" ) );\n    fdRemoveSourceFiles = new FormData();\n    fdRemoveSourceFiles.left = new FormAttachment( middle, 0 );\n    fdRemoveSourceFiles.top = new FormAttachment( wOverwriteFiles, margin );\n    fdRemoveSourceFiles.right = new FormAttachment( 100, 0 );\n    wRemoveSourceFiles.setLayoutData( fdRemoveSourceFiles );\n    wRemoveSourceFiles.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    wlPrevious = new Label( wSettingsComp, SWT.RIGHT );\n    wlPrevious.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Previous.Label\" ) );\n    props.setLook( wlPrevious );\n    fdlPrevious = new FormData();\n    fdlPrevious.left = new FormAttachment( 0, 0 );\n    fdlPrevious.top = new FormAttachment( wRemoveSourceFiles, margin );\n    fdlPrevious.right = new FormAttachment( middle, -margin );\n    wlPrevious.setLayoutData( fdlPrevious );\n    wPrevious = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wPrevious );\n    wPrevious.setSelection( jobEntry.arg_from_previous );\n    wPrevious.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.Previous.Tooltip\" ) );\n    fdPrevious = new FormData();\n    fdPrevious.left = new FormAttachment( middle, 0 );\n    fdPrevious.top = new FormAttachment( wRemoveSourceFiles, margin );\n    fdPrevious.right = new FormAttachment( 100, 0 );\n    wPrevious.setLayoutData( fdPrevious );\n    wPrevious.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n\n        refreshArgFromPrevious();\n\n      }\n    } );\n    \n    // Add file to result\n    wlAddFileToResult = new Label( wSettingsComp, SWT.RIGHT );\n    wlAddFileToResult.setText( BaseMessages.getString( PKG, \"JobCopyFiles.AddFileToResult.Label\" ) );\n    props.setLook( wlAddFileToResult );\n    fdlAddFileToResult = new FormData();\n    fdlAddFileToResult.left = new FormAttachment( 0, 0 );\n    fdlAddFileToResult.top = new FormAttachment( wPrevious, margin );\n    fdlAddFileToResult.right = new FormAttachment( middle, -margin );\n    wlAddFileToResult.setLayoutData( fdlAddFileToResult );\n    wAddFileToResult = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wAddFileToResult );\n    wAddFileToResult.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.AddFileToResult.Tooltip\" ) );\n    fdAddFileToResult = new FormData();\n    fdAddFileToResult.left = new FormAttachment( middle, 0 );\n    fdAddFileToResult.top = new FormAttachment( wPrevious, margin );\n    fdAddFileToResult.right = new FormAttachment( 100, 0 );\n    wAddFileToResult.setLayoutData( fdAddFileToResult );\n    wAddFileToResult.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n    \n    fdSettingsComp = new FormData();\n    fdSettingsComp.left = new FormAttachment( 0, 0 );\n    fdSettingsComp.top = new FormAttachment( 0, 0 );\n    fdSettingsComp.right = new FormAttachment( 100, 0 );\n    fdSettingsComp.bottom = new FormAttachment( 100, 0 );\n    wSettingsComp.setLayoutData( fdSettingsComp );\n\n    wSettingsComp.layout();\n    wSettingsTab.setControl( wSettingsComp );\n    props.setLook( wSettingsComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF SETTINGS TAB\n    // ///////////////////////////////////////////////////////////    \n    \n    ToolBar tb = new ToolBar( wFilesComp, SWT.HORIZONTAL | SWT.FLAT );\n    props.setLook( tb );\n    FormData fdTb = new FormData();\n    fdTb.right = new FormAttachment( 100, 0 );\n    fdTb.top = new FormAttachment( wFilesComp, margin );\n    tb.setLayoutData( fdTb );\n\n    deleteToolItem = new ToolItem( tb, SWT.PUSH );\n    deleteToolItem.setImage( GUIResource.getInstance().getImageDelete() );\n    deleteToolItem.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.FilenameDelete.Tooltip\" ) );\n    deleteToolItem.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent arg0 ) {\n        int[] idx = wFields.getSelectionIndices();\n        wFields.remove( idx );\n        wFields.removeEmptyRows();\n        wFields.setRowNums();\n      }\n    } );\n\n    wlFields = new Label( wFilesComp, SWT.NONE );\n    wlFields.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.Label\" ) );\n    props.setLook( wlFields );\n    fdlFields = new FormData();\n    fdlFields.left = new FormAttachment( 0, margin );\n    fdlFields.right = new FormAttachment( middle, -margin );\n    fdlFields.top = new FormAttachment( wFilesComp, 15 );\n    wlFields.setLayoutData( fdlFields );\n\n    int rows =\n      jobEntry.source_filefolder == null ? 1 : ( jobEntry.source_filefolder.length == 0\n        ? 0 : jobEntry.source_filefolder.length );\n    final int FieldsRows = rows;\n\n    ColumnInfo[] colinf =\n        new ColumnInfo[] {\n          new ColumnInfo( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.SourceEnvironment.Label\" ),\n              ColumnInfo.COLUMN_TYPE_CCOMBO, false, true ),\n          new ColumnInfo( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.SourceFileFolder.Label\" ),\n              ColumnInfo.COLUMN_TYPE_TEXT_BUTTON, false ),\n          new ColumnInfo( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.Wildcard.Label\" ),\n              ColumnInfo.COLUMN_TYPE_TEXT, false ),\n          new ColumnInfo( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.DestinationEnvironment.Label\" ),\n              ColumnInfo.COLUMN_TYPE_CCOMBO, false, true ),\n          new ColumnInfo( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.DestinationFileFolder.Label\" ),\n              ColumnInfo.COLUMN_TYPE_TEXT_BUTTON, false ) };\n    \n    setComboValues( colinf[0] );\n    \n    colinf[1].setUsingVariables( true );\n    colinf[1].setToolTip( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.SourceFileFolder.Tooltip\" ) );\n    colinf[1].setTextVarButtonSelectionListener( getFileSelectionAdapter() );\n\n    colinf[2].setUsingVariables( true );\n    colinf[2].setToolTip( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.Wildcard.Tooltip\" ) );\n\n    setComboValues( colinf[3] );\n    \n    colinf[4].setUsingVariables( true );\n    colinf[4].setToolTip( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.DestinationFileFolder.Tooltip\" ) );\n    colinf[4].setTextVarButtonSelectionListener( getFileSelectionAdapter() );\n    \n    wFields =\n      new TableView(\n        jobMeta, wFilesComp, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, colinf, FieldsRows, lsMod, props );\n\n    fdFields = new FormData();\n    fdFields.left = new FormAttachment( 0, margin );\n    fdFields.top = new FormAttachment( tb, margin );\n    fdFields.right = new FormAttachment( 100, -margin );\n    fdFields.bottom = new FormAttachment( 100, -margin );\n    wFields.setLayoutData( fdFields );\n\n    refreshArgFromPrevious();\n\n    wOK = new Button( shell, SWT.PUSH );\n    wOK.setText( BaseMessages.getString( PKG, \"System.Button.OK\" ) );\n    wCancel = new Button( shell, SWT.PUSH );\n    wCancel.setText( BaseMessages.getString( PKG, \"System.Button.Cancel\" ) );\n\n    Label lBottomSeparator = new Label( shell, SWT.HORIZONTAL | SWT.SEPARATOR );\n    FormData fdBottomSeparator = new FormData();\n    fdBottomSeparator.top = new FormAttachment( wTabFolder, margin * 3 );\n    fdBottomSeparator.left = new FormAttachment( 0, 0 );\n    fdBottomSeparator.right = new FormAttachment( 100, 0 );\n    lBottomSeparator.setLayoutData( fdBottomSeparator );\n\n    BaseStepDialog.positionBottomRightButtons( shell, new Button[] { wOK, wCancel }, margin, lBottomSeparator );\n    FormData fdOK = (FormData) wOK.getLayoutData();\n    FormData fdHelpButton = new FormData();\n    fdHelpButton.top = fdOK.top;\n    fdHelpButton.left = new FormAttachment( 0, margin );\n    helpButton.setLayoutData( fdHelpButton );\n\n    // Add listeners\n    lsCancel = new Listener() {\n      public void handleEvent( Event e ) {\n        cancel();\n      }\n    };\n    lsOK = new Listener() {\n      public void handleEvent( Event e ) {\n        ok();\n      }\n    };\n\n    wCancel.addListener( SWT.Selection, lsCancel );\n    wOK.addListener( SWT.Selection, lsOK );\n\n    lsDef = new SelectionAdapter() {\n      public void widgetDefaultSelected( SelectionEvent e ) {\n        ok();\n      }\n    };\n\n    wName.addSelectionListener( lsDef );\n\n    // Detect X or ALT-F4 or something that kills this window...\n    shell.addShellListener( new ShellAdapter() {\n      public void shellClosed( ShellEvent e ) {\n        cancel();\n      }\n    } );\n\n    getData();\n    CheckIncludeSubFolders();\n    wTabFolder.setSelection( 0 );\n    \n  }","commit_id":"552d8adb2723f9fb17d3bce7701d53c9c12f4237","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n   * Copy information from the meta-data input to the dialog fields.\n   */\n  public void getData() {\n    if ( jobEntry.getName() != null ) {\n      wName.setText( jobEntry.getName() );\n    }\n    wCopyEmptyFolders.setSelection( jobEntry.copy_empty_folders );\n\n    if ( jobEntry.source_filefolder != null ) {\n      for ( int i = 0; i < jobEntry.source_filefolder.length; i++ ) {\n        TableItem ti = wFields.table.getItem( i );\n        if ( jobEntry.source_filefolder[i] != null ) {\n          ti.setText( 1, jobEntry.source_filefolder[i] );\n        }\n        if ( jobEntry.destination_filefolder[i] != null ) {\n          ti.setText( 2, jobEntry.destination_filefolder[i] );\n        }\n        if ( jobEntry.wildcard[i] != null ) {\n          ti.setText( 3, jobEntry.wildcard[i] );\n        }\n      }\n      wFields.setRowNums();\n      wFields.optWidth( true );\n    }\n    wPrevious.setSelection( jobEntry.arg_from_previous );\n    wOverwriteFiles.setSelection( jobEntry.overwrite_files );\n    wIncludeSubfolders.setSelection( jobEntry.include_subfolders );\n    wRemoveSourceFiles.setSelection( jobEntry.remove_source_files );\n    wDestinationIsAFile.setSelection( jobEntry.destination_is_a_file );\n    wCreateDestinationFolder.setSelection( jobEntry.create_destination_folder );\n\n    wAddFileToResult.setSelection( jobEntry.add_result_filesname );\n\n    wName.selectAll();\n    wName.setFocus();\n  }","id":6732,"modified_method":"/**\n   * Copy information from the meta-data input to the dialog fields.\n   */\n  public void getData() {\n    if ( jobEntry.getName() != null ) {\n      wName.setText( jobEntry.getName() );\n    }\n    wCopyEmptyFolders.setSelection( jobEntry.copy_empty_folders );\n\n    if ( jobEntry.source_filefolder != null ) {\n      for ( int i = 0; i < jobEntry.source_filefolder.length; i++ ) {\n        TableItem ti = wFields.table.getItem( i );\n        if ( jobEntry.source_filefolder[i] != null ) {\n          ti.setText( 1, jobEntry.source_filefolder[i] );\n        }\n        if ( jobEntry.wildcard[i] != null ) {\n          ti.setText( 2, jobEntry.wildcard[i] );\n        }\n        if ( jobEntry.destination_filefolder[i] != null ) {\n          ti.setText( 4, jobEntry.destination_filefolder[i] );\n        }\n      }\n      wFields.setRowNums();\n      wFields.optWidth( true );\n    }\n    wPrevious.setSelection( jobEntry.arg_from_previous );\n    wOverwriteFiles.setSelection( jobEntry.overwrite_files );\n    wIncludeSubfolders.setSelection( jobEntry.include_subfolders );\n    wRemoveSourceFiles.setSelection( jobEntry.remove_source_files );\n    wDestinationIsAFile.setSelection( jobEntry.destination_is_a_file );\n    wCreateDestinationFolder.setSelection( jobEntry.create_destination_folder );\n\n    wAddFileToResult.setSelection( jobEntry.add_result_filesname );\n\n    wName.selectAll();\n    wName.setFocus();\n  }","commit_id":"3b40563eded4766513075a8cfab98c1a5583ae28","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"protected void initUI() {\n    Shell parent = getParent();\n\n    shell = new Shell( parent, props.getJobsDialogStyle() );\n    props.setLook( shell );\n    Button helpButton = JobDialog.setShellImage( shell, jobEntry );\n\n    ModifyListener lsMod = new ModifyListener() {\n      public void modifyText( ModifyEvent e ) {\n        jobEntry.setChanged();\n      }\n    };\n    changed = jobEntry.hasChanged();\n\n    FormLayout formLayout = new FormLayout();\n    formLayout.marginWidth = Const.FORM_MARGIN;\n    formLayout.marginHeight = Const.FORM_MARGIN;\n\n    shell.setLayout( formLayout );\n    shell.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Title\" ) );\n\n    int middle = props.getMiddlePct();\n    int margin = Const.MARGIN;\n\n    // Filename line\n    wlName = new Label( shell, SWT.LEFT );\n    wlName.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Name.Label\" ) );\n    props.setLook( wlName );\n    fdlName = new FormData();\n    fdlName.left = new FormAttachment( 0, 0 );\n    fdlName.right = new FormAttachment( middle, -margin );\n    fdlName.top = new FormAttachment( 0, margin );\n    wlName.setLayoutData( fdlName );\n    wName = new Text( shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wName );\n    wName.addModifyListener( lsMod );\n    fdName = new FormData();\n    fdName.left = new FormAttachment( 0, 0 );\n    fdName.top = new FormAttachment( wlName, margin );\n    fdName.right = new FormAttachment( 40, 0 );\n    wName.setLayoutData( fdName );\n    Label wlIcon = new Label( shell, SWT.RIGHT );\n    wlIcon.setImage( getImage() );\n    props.setLook( wlIcon );\n    FormData fdlIcon = new FormData();\n    fdlIcon.top = new FormAttachment( 0, margin * 3 );\n    fdlIcon.right = new FormAttachment( 100, -margin );\n    wlIcon.setLayoutData( fdlIcon );\n    \n    Label lTopSeparator = new Label( shell, SWT.HORIZONTAL | SWT.SEPARATOR );\n    FormData fdTopSeparator = new FormData();\n    fdTopSeparator.top = new FormAttachment( wName, margin * 3 );\n    fdTopSeparator.left = new FormAttachment( 0, 0 );\n    fdTopSeparator.right = new FormAttachment( 100, 0 );\n    lTopSeparator.setLayoutData( fdTopSeparator );    \n    \n    \n    wTabFolder = new CTabFolder( shell, SWT.BORDER );\n    props.setLook( wTabFolder, Props.WIDGET_STYLE_TAB );\n\n    fdTabFolder = new FormData();\n    fdTabFolder.left = new FormAttachment( 0, 0 );\n    fdTabFolder.top = new FormAttachment( lTopSeparator, margin * 3 );\n    fdTabFolder.right = new FormAttachment( 100, 0 );\n    fdTabFolder.bottom = new FormAttachment( 100, -60 );\n    wTabFolder.setLayoutData( fdTabFolder );\n    \n    // ///////////////////////////////////////////////////////////\n    // / START OF FILES TAB\n    // ///////////////////////////////////////////////////////////\n    \n    wFilesTab = new CTabItem( wTabFolder, SWT.NONE );\n//    wFilesTab.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Tab.Files.Label\" ) );\n    wFilesTab.setText( \"Files\" );\n\n    wFilesComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wFilesComp );\n    \n    FormLayout filesLayout = new FormLayout();\n    filesLayout.marginWidth = 3;\n    filesLayout.marginHeight = 3;\n    wFilesComp.setLayout( filesLayout );\n    \n    fdFilesComp = new FormData();\n    fdFilesComp.left = new FormAttachment( 0, 0 );\n    fdFilesComp.top = new FormAttachment( 0, 0 );\n    fdFilesComp.right = new FormAttachment( 100, 0 );\n    fdFilesComp.bottom = new FormAttachment( 100, 0 );\n    wFilesComp.setLayoutData( fdFilesComp );\n\n    wFilesComp.layout();\n    wFilesTab.setControl( wFilesComp );\n    \n    // ///////////////////////////////////////////////////////////\n    // / END OF FILES TAB\n    // ///////////////////////////////////////////////////////////    \n    \n    // ////////////////////////\n    // START OF SETTINGS TAB ///\n    // ////////////////////////\n\n    wSettingsTab = new CTabItem( wTabFolder, SWT.NONE );\n    wSettingsTab.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Settings.Label\" ) );\n\n    wSettingsComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wSettingsComp );\n\n    FormLayout settingsLayout = new FormLayout();\n    settingsLayout.marginWidth = 3;\n    settingsLayout.marginHeight = 3;\n    wSettingsComp.setLayout( settingsLayout );\n    \n    wlIncludeSubfolders = new Label( wSettingsComp, SWT.RIGHT );\n    wlIncludeSubfolders.setText( BaseMessages.getString( PKG, \"JobCopyFiles.IncludeSubfolders.Label\" ) );\n    props.setLook( wlIncludeSubfolders );\n    fdlIncludeSubfolders = new FormData();\n    fdlIncludeSubfolders.left = new FormAttachment( 0, 0 );\n    fdlIncludeSubfolders.top = new FormAttachment( wName, margin );\n    fdlIncludeSubfolders.right = new FormAttachment( middle, -margin );\n    wlIncludeSubfolders.setLayoutData( fdlIncludeSubfolders );\n    wIncludeSubfolders = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wIncludeSubfolders );\n    wIncludeSubfolders.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.IncludeSubfolders.Tooltip\" ) );\n    fdIncludeSubfolders = new FormData();\n    fdIncludeSubfolders.left = new FormAttachment( middle, 0 );\n    fdIncludeSubfolders.top = new FormAttachment( wName, margin );\n    fdIncludeSubfolders.right = new FormAttachment( 100, 0 );\n    wIncludeSubfolders.setLayoutData( fdIncludeSubfolders );\n    wIncludeSubfolders.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        CheckIncludeSubFolders();\n      }\n    } );\n\n    // Destination is a file?\n    wlDestinationIsAFile = new Label( wSettingsComp, SWT.RIGHT );\n    wlDestinationIsAFile.setText( BaseMessages.getString( PKG, \"JobCopyFiles.DestinationIsAFile.Label\" ) );\n    props.setLook( wlDestinationIsAFile );\n    fdlDestinationIsAFile = new FormData();\n    fdlDestinationIsAFile.left = new FormAttachment( 0, 0 );\n    fdlDestinationIsAFile.top = new FormAttachment( wIncludeSubfolders, margin );\n    fdlDestinationIsAFile.right = new FormAttachment( middle, -margin );\n    wlDestinationIsAFile.setLayoutData( fdlDestinationIsAFile );\n    wDestinationIsAFile = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wDestinationIsAFile );\n    wDestinationIsAFile.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.DestinationIsAFile.Tooltip\" ) );\n    fdDestinationIsAFile = new FormData();\n    fdDestinationIsAFile.left = new FormAttachment( middle, 0 );\n    fdDestinationIsAFile.top = new FormAttachment( wIncludeSubfolders, margin );\n    fdDestinationIsAFile.right = new FormAttachment( 100, 0 );\n    wDestinationIsAFile.setLayoutData( fdDestinationIsAFile );\n    wDestinationIsAFile.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Copy empty folders\n    wlCopyEmptyFolders = new Label( wSettingsComp, SWT.RIGHT );\n    wlCopyEmptyFolders.setText( BaseMessages.getString( PKG, \"JobCopyFiles.CopyEmptyFolders.Label\" ) );\n    props.setLook( wlCopyEmptyFolders );\n    fdlCopyEmptyFolders = new FormData();\n    fdlCopyEmptyFolders.left = new FormAttachment( 0, 0 );\n    fdlCopyEmptyFolders.top = new FormAttachment( wDestinationIsAFile, margin );\n    fdlCopyEmptyFolders.right = new FormAttachment( middle, -margin );\n    wlCopyEmptyFolders.setLayoutData( fdlCopyEmptyFolders );\n    wCopyEmptyFolders = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wCopyEmptyFolders );\n    wCopyEmptyFolders.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.CopyEmptyFolders.Tooltip\" ) );\n    fdCopyEmptyFolders = new FormData();\n    fdCopyEmptyFolders.left = new FormAttachment( middle, 0 );\n    fdCopyEmptyFolders.top = new FormAttachment( wDestinationIsAFile, margin );\n    fdCopyEmptyFolders.right = new FormAttachment( 100, 0 );\n    wCopyEmptyFolders.setLayoutData( fdCopyEmptyFolders );\n    wCopyEmptyFolders.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Create destination folder/parent folder\n    wlCreateDestinationFolder = new Label( wSettingsComp, SWT.RIGHT );\n    wlCreateDestinationFolder\n      .setText( BaseMessages.getString( PKG, \"JobCopyFiles.CreateDestinationFolder.Label\" ) );\n    props.setLook( wlCreateDestinationFolder );\n    fdlCreateDestinationFolder = new FormData();\n    fdlCreateDestinationFolder.left = new FormAttachment( 0, 0 );\n    fdlCreateDestinationFolder.top = new FormAttachment( wCopyEmptyFolders, margin );\n    fdlCreateDestinationFolder.right = new FormAttachment( middle, -margin );\n    wlCreateDestinationFolder.setLayoutData( fdlCreateDestinationFolder );\n    wCreateDestinationFolder = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wCreateDestinationFolder );\n    wCreateDestinationFolder.setToolTipText( BaseMessages.getString(\n      PKG, \"JobCopyFiles.CreateDestinationFolder.Tooltip\" ) );\n    fdCreateDestinationFolder = new FormData();\n    fdCreateDestinationFolder.left = new FormAttachment( middle, 0 );\n    fdCreateDestinationFolder.top = new FormAttachment( wCopyEmptyFolders, margin );\n    fdCreateDestinationFolder.right = new FormAttachment( 100, 0 );\n    wCreateDestinationFolder.setLayoutData( fdCreateDestinationFolder );\n    wCreateDestinationFolder.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // OverwriteFiles Option\n    wlOverwriteFiles = new Label( wSettingsComp, SWT.RIGHT );\n    wlOverwriteFiles.setText( BaseMessages.getString( PKG, \"JobCopyFiles.OverwriteFiles.Label\" ) );\n    props.setLook( wlOverwriteFiles );\n    fdlOverwriteFiles = new FormData();\n    fdlOverwriteFiles.left = new FormAttachment( 0, 0 );\n    fdlOverwriteFiles.top = new FormAttachment( wCreateDestinationFolder, margin );\n    fdlOverwriteFiles.right = new FormAttachment( middle, -margin );\n    wlOverwriteFiles.setLayoutData( fdlOverwriteFiles );\n    wOverwriteFiles = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wOverwriteFiles );\n    wOverwriteFiles.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.OverwriteFiles.Tooltip\" ) );\n    fdOverwriteFiles = new FormData();\n    fdOverwriteFiles.left = new FormAttachment( middle, 0 );\n    fdOverwriteFiles.top = new FormAttachment( wCreateDestinationFolder, margin );\n    fdOverwriteFiles.right = new FormAttachment( 100, 0 );\n    wOverwriteFiles.setLayoutData( fdOverwriteFiles );\n    wOverwriteFiles.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Remove source files option\n    wlRemoveSourceFiles = new Label( wSettingsComp, SWT.RIGHT );\n    wlRemoveSourceFiles.setText( BaseMessages.getString( PKG, \"JobCopyFiles.RemoveSourceFiles.Label\" ) );\n    props.setLook( wlRemoveSourceFiles );\n    fdlRemoveSourceFiles = new FormData();\n    fdlRemoveSourceFiles.left = new FormAttachment( 0, 0 );\n    fdlRemoveSourceFiles.top = new FormAttachment( wOverwriteFiles, margin );\n    fdlRemoveSourceFiles.right = new FormAttachment( middle, -margin );\n    wlRemoveSourceFiles.setLayoutData( fdlRemoveSourceFiles );\n    wRemoveSourceFiles = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wRemoveSourceFiles );\n    wRemoveSourceFiles.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.RemoveSourceFiles.Tooltip\" ) );\n    fdRemoveSourceFiles = new FormData();\n    fdRemoveSourceFiles.left = new FormAttachment( middle, 0 );\n    fdRemoveSourceFiles.top = new FormAttachment( wOverwriteFiles, margin );\n    fdRemoveSourceFiles.right = new FormAttachment( 100, 0 );\n    wRemoveSourceFiles.setLayoutData( fdRemoveSourceFiles );\n    wRemoveSourceFiles.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    wlPrevious = new Label( wSettingsComp, SWT.RIGHT );\n    wlPrevious.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Previous.Label\" ) );\n    props.setLook( wlPrevious );\n    fdlPrevious = new FormData();\n    fdlPrevious.left = new FormAttachment( 0, 0 );\n    fdlPrevious.top = new FormAttachment( wRemoveSourceFiles, margin );\n    fdlPrevious.right = new FormAttachment( middle, -margin );\n    wlPrevious.setLayoutData( fdlPrevious );\n    wPrevious = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wPrevious );\n    wPrevious.setSelection( jobEntry.arg_from_previous );\n    wPrevious.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.Previous.Tooltip\" ) );\n    fdPrevious = new FormData();\n    fdPrevious.left = new FormAttachment( middle, 0 );\n    fdPrevious.top = new FormAttachment( wRemoveSourceFiles, margin );\n    fdPrevious.right = new FormAttachment( 100, 0 );\n    wPrevious.setLayoutData( fdPrevious );\n    wPrevious.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n\n        refreshArgFromPrevious();\n\n      }\n    } );\n    \n    // Add file to result\n    wlAddFileToResult = new Label( wSettingsComp, SWT.RIGHT );\n    wlAddFileToResult.setText( BaseMessages.getString( PKG, \"JobCopyFiles.AddFileToResult.Label\" ) );\n    props.setLook( wlAddFileToResult );\n    fdlAddFileToResult = new FormData();\n    fdlAddFileToResult.left = new FormAttachment( 0, 0 );\n    fdlAddFileToResult.top = new FormAttachment( wPrevious, margin );\n    fdlAddFileToResult.right = new FormAttachment( middle, -margin );\n    wlAddFileToResult.setLayoutData( fdlAddFileToResult );\n    wAddFileToResult = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wAddFileToResult );\n    wAddFileToResult.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.AddFileToResult.Tooltip\" ) );\n    fdAddFileToResult = new FormData();\n    fdAddFileToResult.left = new FormAttachment( middle, 0 );\n    fdAddFileToResult.top = new FormAttachment( wPrevious, margin );\n    fdAddFileToResult.right = new FormAttachment( 100, 0 );\n    wAddFileToResult.setLayoutData( fdAddFileToResult );\n    wAddFileToResult.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n    \n    fdSettingsComp = new FormData();\n    fdSettingsComp.left = new FormAttachment( 0, 0 );\n    fdSettingsComp.top = new FormAttachment( 0, 0 );\n    fdSettingsComp.right = new FormAttachment( 100, 0 );\n    fdSettingsComp.bottom = new FormAttachment( 100, 0 );\n    wSettingsComp.setLayoutData( fdSettingsComp );\n\n    wSettingsComp.layout();\n    wSettingsTab.setControl( wSettingsComp );\n    props.setLook( wSettingsComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF SETTINGS TAB\n    // ///////////////////////////////////////////////////////////    \n    \n    ToolBar tb = new ToolBar( wFilesComp, SWT.HORIZONTAL | SWT.FLAT );\n    props.setLook( tb );\n    FormData fdTb = new FormData();\n    fdTb.right = new FormAttachment( 100, 0 );\n    fdTb.top = new FormAttachment( wFilesComp, margin );\n    tb.setLayoutData( fdTb );\n\n    deleteToolItem = new ToolItem( tb, SWT.PUSH );\n    deleteToolItem.setImage( GUIResource.getInstance().getImageDelete() );\n    deleteToolItem.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.FilenameDelete.Tooltip\" ) );\n    deleteToolItem.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent arg0 ) {\n        int[] idx = wFields.getSelectionIndices();\n        wFields.remove( idx );\n        wFields.removeEmptyRows();\n        wFields.setRowNums();\n      }\n    } );\n\n    wlFields = new Label( wFilesComp, SWT.NONE );\n    wlFields.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.Label\" ) );\n    props.setLook( wlFields );\n    fdlFields = new FormData();\n    fdlFields.left = new FormAttachment( 0, margin );\n    fdlFields.right = new FormAttachment( middle, -margin );\n    fdlFields.top = new FormAttachment( wFilesComp, 15 );\n    wlFields.setLayoutData( fdlFields );\n\n    int rows =\n      jobEntry.source_filefolder == null ? 1 : ( jobEntry.source_filefolder.length == 0\n        ? 0 : jobEntry.source_filefolder.length );\n    final int FieldsRows = rows;\n\n    ColumnInfo[] colinf =\n      new ColumnInfo[] {\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobCopyFiles.Fields.SourceFileFolder.Label\" ),\n          ColumnInfo.COLUMN_TYPE_TEXT_BUTTON, false ),\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobCopyFiles.Fields.DestinationFileFolder.Label\" ),\n          ColumnInfo.COLUMN_TYPE_TEXT_BUTTON, false ),\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobCopyFiles.Fields.Wildcard.Label\" ), ColumnInfo.COLUMN_TYPE_TEXT,\n          false ), };\n\n    colinf[0].setUsingVariables( true );\n    colinf[0].setToolTip( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.SourceFileFolder.Tooltip\" ) );\n    colinf[1].setUsingVariables( true );\n    colinf[1].setToolTip( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.DestinationFileFolder.Tooltip\" ) );\n    colinf[2].setUsingVariables( true );\n    colinf[2].setToolTip( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.Wildcard.Tooltip\" ) );\n\n    colinf[0].setTextVarButtonSelectionListener( getFileSelectionAdapter() );\n    colinf[1].setTextVarButtonSelectionListener( getFileSelectionAdapter() );\n    \n    wFields =\n      new TableView(\n        jobMeta, wFilesComp, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, colinf, FieldsRows, lsMod, props );\n\n    fdFields = new FormData();\n    fdFields.left = new FormAttachment( 0, margin );\n    fdFields.top = new FormAttachment( tb, margin );\n    fdFields.right = new FormAttachment( 100, -margin );\n    fdFields.bottom = new FormAttachment( 100, -margin );\n    wFields.setLayoutData( fdFields );\n\n    refreshArgFromPrevious();\n\n    wOK = new Button( shell, SWT.PUSH );\n    wOK.setText( BaseMessages.getString( PKG, \"System.Button.OK\" ) );\n    wCancel = new Button( shell, SWT.PUSH );\n    wCancel.setText( BaseMessages.getString( PKG, \"System.Button.Cancel\" ) );\n\n    Label lBottomSeparator = new Label( shell, SWT.HORIZONTAL | SWT.SEPARATOR );\n    FormData fdBottomSeparator = new FormData();\n    fdBottomSeparator.top = new FormAttachment( wTabFolder, margin * 3 );\n    fdBottomSeparator.left = new FormAttachment( 0, 0 );\n    fdBottomSeparator.right = new FormAttachment( 100, 0 );\n    lBottomSeparator.setLayoutData( fdBottomSeparator );\n\n    BaseStepDialog.positionBottomRightButtons( shell, new Button[] { wOK, wCancel }, margin, lBottomSeparator );\n    FormData fdOK = (FormData) wOK.getLayoutData();\n    FormData fdHelpButton = new FormData();\n    fdHelpButton.top = fdOK.top;\n    fdHelpButton.left = new FormAttachment( 0, margin );\n    helpButton.setLayoutData( fdHelpButton );\n\n    // Add listeners\n    lsCancel = new Listener() {\n      public void handleEvent( Event e ) {\n        cancel();\n      }\n    };\n    lsOK = new Listener() {\n      public void handleEvent( Event e ) {\n        ok();\n      }\n    };\n\n    wCancel.addListener( SWT.Selection, lsCancel );\n    wOK.addListener( SWT.Selection, lsOK );\n\n    lsDef = new SelectionAdapter() {\n      public void widgetDefaultSelected( SelectionEvent e ) {\n        ok();\n      }\n    };\n\n    wName.addSelectionListener( lsDef );\n\n    // Detect X or ALT-F4 or something that kills this window...\n    shell.addShellListener( new ShellAdapter() {\n      public void shellClosed( ShellEvent e ) {\n        cancel();\n      }\n    } );\n\n    getData();\n    CheckIncludeSubFolders();\n    wTabFolder.setSelection( 0 );\n    \n  }","id":6733,"modified_method":"protected void initUI() {\n    Shell parent = getParent();\n\n    shell = new Shell( parent, props.getJobsDialogStyle() );\n    props.setLook( shell );\n    Button helpButton = JobDialog.setShellImage( shell, jobEntry );\n\n    ModifyListener lsMod = new ModifyListener() {\n      public void modifyText( ModifyEvent e ) {\n        jobEntry.setChanged();\n      }\n    };\n    changed = jobEntry.hasChanged();\n\n    FormLayout formLayout = new FormLayout();\n    formLayout.marginWidth = Const.FORM_MARGIN;\n    formLayout.marginHeight = Const.FORM_MARGIN;\n\n    shell.setLayout( formLayout );\n    shell.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Title\" ) );\n\n    int middle = props.getMiddlePct();\n    int margin = Const.MARGIN;\n\n    // Filename line\n    wlName = new Label( shell, SWT.LEFT );\n    wlName.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Name.Label\" ) );\n    props.setLook( wlName );\n    fdlName = new FormData();\n    fdlName.left = new FormAttachment( 0, 0 );\n    fdlName.right = new FormAttachment( middle, -margin );\n    fdlName.top = new FormAttachment( 0, margin );\n    wlName.setLayoutData( fdlName );\n    wName = new Text( shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wName );\n    wName.addModifyListener( lsMod );\n    fdName = new FormData();\n    fdName.left = new FormAttachment( 0, 0 );\n    fdName.top = new FormAttachment( wlName, margin );\n    fdName.right = new FormAttachment( 40, 0 );\n    wName.setLayoutData( fdName );\n    Label wlIcon = new Label( shell, SWT.RIGHT );\n    wlIcon.setImage( getImage() );\n    props.setLook( wlIcon );\n    FormData fdlIcon = new FormData();\n    fdlIcon.top = new FormAttachment( 0, margin * 3 );\n    fdlIcon.right = new FormAttachment( 100, -margin );\n    wlIcon.setLayoutData( fdlIcon );\n    \n    Label lTopSeparator = new Label( shell, SWT.HORIZONTAL | SWT.SEPARATOR );\n    FormData fdTopSeparator = new FormData();\n    fdTopSeparator.top = new FormAttachment( wName, margin * 3 );\n    fdTopSeparator.left = new FormAttachment( 0, 0 );\n    fdTopSeparator.right = new FormAttachment( 100, 0 );\n    lTopSeparator.setLayoutData( fdTopSeparator );    \n    \n    \n    wTabFolder = new CTabFolder( shell, SWT.BORDER );\n    props.setLook( wTabFolder, Props.WIDGET_STYLE_TAB );\n\n    fdTabFolder = new FormData();\n    fdTabFolder.left = new FormAttachment( 0, 0 );\n    fdTabFolder.top = new FormAttachment( lTopSeparator, margin * 3 );\n    fdTabFolder.right = new FormAttachment( 100, 0 );\n    fdTabFolder.bottom = new FormAttachment( 100, -60 );\n    wTabFolder.setLayoutData( fdTabFolder );\n    \n    // ///////////////////////////////////////////////////////////\n    // / START OF FILES TAB\n    // ///////////////////////////////////////////////////////////\n    \n    wFilesTab = new CTabItem( wTabFolder, SWT.NONE );\n    wFilesTab.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Tab.Files.Label\" ) );\n\n    wFilesComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wFilesComp );\n    \n    FormLayout filesLayout = new FormLayout();\n    filesLayout.marginWidth = 3;\n    filesLayout.marginHeight = 3;\n    wFilesComp.setLayout( filesLayout );\n    \n    fdFilesComp = new FormData();\n    fdFilesComp.left = new FormAttachment( 0, 0 );\n    fdFilesComp.top = new FormAttachment( 0, 0 );\n    fdFilesComp.right = new FormAttachment( 100, 0 );\n    fdFilesComp.bottom = new FormAttachment( 100, 0 );\n    wFilesComp.setLayoutData( fdFilesComp );\n\n    wFilesComp.layout();\n    wFilesTab.setControl( wFilesComp );\n    \n    // ///////////////////////////////////////////////////////////\n    // / END OF FILES TAB\n    // ///////////////////////////////////////////////////////////    \n    \n    // ////////////////////////\n    // START OF SETTINGS TAB ///\n    // ////////////////////////\n\n    wSettingsTab = new CTabItem( wTabFolder, SWT.NONE );\n    wSettingsTab.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Settings.Label\" ) );\n\n    wSettingsComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wSettingsComp );\n\n    FormLayout settingsLayout = new FormLayout();\n    settingsLayout.marginWidth = 3;\n    settingsLayout.marginHeight = 3;\n    wSettingsComp.setLayout( settingsLayout );\n    \n    wlIncludeSubfolders = new Label( wSettingsComp, SWT.RIGHT );\n    wlIncludeSubfolders.setText( BaseMessages.getString( PKG, \"JobCopyFiles.IncludeSubfolders.Label\" ) );\n    props.setLook( wlIncludeSubfolders );\n    fdlIncludeSubfolders = new FormData();\n    fdlIncludeSubfolders.left = new FormAttachment( 0, 0 );\n    fdlIncludeSubfolders.top = new FormAttachment( wName, margin );\n    fdlIncludeSubfolders.right = new FormAttachment( middle, -margin );\n    wlIncludeSubfolders.setLayoutData( fdlIncludeSubfolders );\n    wIncludeSubfolders = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wIncludeSubfolders );\n    wIncludeSubfolders.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.IncludeSubfolders.Tooltip\" ) );\n    fdIncludeSubfolders = new FormData();\n    fdIncludeSubfolders.left = new FormAttachment( middle, 0 );\n    fdIncludeSubfolders.top = new FormAttachment( wName, margin );\n    fdIncludeSubfolders.right = new FormAttachment( 100, 0 );\n    wIncludeSubfolders.setLayoutData( fdIncludeSubfolders );\n    wIncludeSubfolders.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        CheckIncludeSubFolders();\n      }\n    } );\n\n    // Destination is a file?\n    wlDestinationIsAFile = new Label( wSettingsComp, SWT.RIGHT );\n    wlDestinationIsAFile.setText( BaseMessages.getString( PKG, \"JobCopyFiles.DestinationIsAFile.Label\" ) );\n    props.setLook( wlDestinationIsAFile );\n    fdlDestinationIsAFile = new FormData();\n    fdlDestinationIsAFile.left = new FormAttachment( 0, 0 );\n    fdlDestinationIsAFile.top = new FormAttachment( wIncludeSubfolders, margin );\n    fdlDestinationIsAFile.right = new FormAttachment( middle, -margin );\n    wlDestinationIsAFile.setLayoutData( fdlDestinationIsAFile );\n    wDestinationIsAFile = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wDestinationIsAFile );\n    wDestinationIsAFile.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.DestinationIsAFile.Tooltip\" ) );\n    fdDestinationIsAFile = new FormData();\n    fdDestinationIsAFile.left = new FormAttachment( middle, 0 );\n    fdDestinationIsAFile.top = new FormAttachment( wIncludeSubfolders, margin );\n    fdDestinationIsAFile.right = new FormAttachment( 100, 0 );\n    wDestinationIsAFile.setLayoutData( fdDestinationIsAFile );\n    wDestinationIsAFile.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Copy empty folders\n    wlCopyEmptyFolders = new Label( wSettingsComp, SWT.RIGHT );\n    wlCopyEmptyFolders.setText( BaseMessages.getString( PKG, \"JobCopyFiles.CopyEmptyFolders.Label\" ) );\n    props.setLook( wlCopyEmptyFolders );\n    fdlCopyEmptyFolders = new FormData();\n    fdlCopyEmptyFolders.left = new FormAttachment( 0, 0 );\n    fdlCopyEmptyFolders.top = new FormAttachment( wDestinationIsAFile, margin );\n    fdlCopyEmptyFolders.right = new FormAttachment( middle, -margin );\n    wlCopyEmptyFolders.setLayoutData( fdlCopyEmptyFolders );\n    wCopyEmptyFolders = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wCopyEmptyFolders );\n    wCopyEmptyFolders.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.CopyEmptyFolders.Tooltip\" ) );\n    fdCopyEmptyFolders = new FormData();\n    fdCopyEmptyFolders.left = new FormAttachment( middle, 0 );\n    fdCopyEmptyFolders.top = new FormAttachment( wDestinationIsAFile, margin );\n    fdCopyEmptyFolders.right = new FormAttachment( 100, 0 );\n    wCopyEmptyFolders.setLayoutData( fdCopyEmptyFolders );\n    wCopyEmptyFolders.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Create destination folder/parent folder\n    wlCreateDestinationFolder = new Label( wSettingsComp, SWT.RIGHT );\n    wlCreateDestinationFolder\n      .setText( BaseMessages.getString( PKG, \"JobCopyFiles.CreateDestinationFolder.Label\" ) );\n    props.setLook( wlCreateDestinationFolder );\n    fdlCreateDestinationFolder = new FormData();\n    fdlCreateDestinationFolder.left = new FormAttachment( 0, 0 );\n    fdlCreateDestinationFolder.top = new FormAttachment( wCopyEmptyFolders, margin );\n    fdlCreateDestinationFolder.right = new FormAttachment( middle, -margin );\n    wlCreateDestinationFolder.setLayoutData( fdlCreateDestinationFolder );\n    wCreateDestinationFolder = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wCreateDestinationFolder );\n    wCreateDestinationFolder.setToolTipText( BaseMessages.getString(\n      PKG, \"JobCopyFiles.CreateDestinationFolder.Tooltip\" ) );\n    fdCreateDestinationFolder = new FormData();\n    fdCreateDestinationFolder.left = new FormAttachment( middle, 0 );\n    fdCreateDestinationFolder.top = new FormAttachment( wCopyEmptyFolders, margin );\n    fdCreateDestinationFolder.right = new FormAttachment( 100, 0 );\n    wCreateDestinationFolder.setLayoutData( fdCreateDestinationFolder );\n    wCreateDestinationFolder.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // OverwriteFiles Option\n    wlOverwriteFiles = new Label( wSettingsComp, SWT.RIGHT );\n    wlOverwriteFiles.setText( BaseMessages.getString( PKG, \"JobCopyFiles.OverwriteFiles.Label\" ) );\n    props.setLook( wlOverwriteFiles );\n    fdlOverwriteFiles = new FormData();\n    fdlOverwriteFiles.left = new FormAttachment( 0, 0 );\n    fdlOverwriteFiles.top = new FormAttachment( wCreateDestinationFolder, margin );\n    fdlOverwriteFiles.right = new FormAttachment( middle, -margin );\n    wlOverwriteFiles.setLayoutData( fdlOverwriteFiles );\n    wOverwriteFiles = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wOverwriteFiles );\n    wOverwriteFiles.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.OverwriteFiles.Tooltip\" ) );\n    fdOverwriteFiles = new FormData();\n    fdOverwriteFiles.left = new FormAttachment( middle, 0 );\n    fdOverwriteFiles.top = new FormAttachment( wCreateDestinationFolder, margin );\n    fdOverwriteFiles.right = new FormAttachment( 100, 0 );\n    wOverwriteFiles.setLayoutData( fdOverwriteFiles );\n    wOverwriteFiles.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Remove source files option\n    wlRemoveSourceFiles = new Label( wSettingsComp, SWT.RIGHT );\n    wlRemoveSourceFiles.setText( BaseMessages.getString( PKG, \"JobCopyFiles.RemoveSourceFiles.Label\" ) );\n    props.setLook( wlRemoveSourceFiles );\n    fdlRemoveSourceFiles = new FormData();\n    fdlRemoveSourceFiles.left = new FormAttachment( 0, 0 );\n    fdlRemoveSourceFiles.top = new FormAttachment( wOverwriteFiles, margin );\n    fdlRemoveSourceFiles.right = new FormAttachment( middle, -margin );\n    wlRemoveSourceFiles.setLayoutData( fdlRemoveSourceFiles );\n    wRemoveSourceFiles = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wRemoveSourceFiles );\n    wRemoveSourceFiles.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.RemoveSourceFiles.Tooltip\" ) );\n    fdRemoveSourceFiles = new FormData();\n    fdRemoveSourceFiles.left = new FormAttachment( middle, 0 );\n    fdRemoveSourceFiles.top = new FormAttachment( wOverwriteFiles, margin );\n    fdRemoveSourceFiles.right = new FormAttachment( 100, 0 );\n    wRemoveSourceFiles.setLayoutData( fdRemoveSourceFiles );\n    wRemoveSourceFiles.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    wlPrevious = new Label( wSettingsComp, SWT.RIGHT );\n    wlPrevious.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Previous.Label\" ) );\n    props.setLook( wlPrevious );\n    fdlPrevious = new FormData();\n    fdlPrevious.left = new FormAttachment( 0, 0 );\n    fdlPrevious.top = new FormAttachment( wRemoveSourceFiles, margin );\n    fdlPrevious.right = new FormAttachment( middle, -margin );\n    wlPrevious.setLayoutData( fdlPrevious );\n    wPrevious = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wPrevious );\n    wPrevious.setSelection( jobEntry.arg_from_previous );\n    wPrevious.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.Previous.Tooltip\" ) );\n    fdPrevious = new FormData();\n    fdPrevious.left = new FormAttachment( middle, 0 );\n    fdPrevious.top = new FormAttachment( wRemoveSourceFiles, margin );\n    fdPrevious.right = new FormAttachment( 100, 0 );\n    wPrevious.setLayoutData( fdPrevious );\n    wPrevious.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n\n        refreshArgFromPrevious();\n\n      }\n    } );\n    \n    // Add file to result\n    wlAddFileToResult = new Label( wSettingsComp, SWT.RIGHT );\n    wlAddFileToResult.setText( BaseMessages.getString( PKG, \"JobCopyFiles.AddFileToResult.Label\" ) );\n    props.setLook( wlAddFileToResult );\n    fdlAddFileToResult = new FormData();\n    fdlAddFileToResult.left = new FormAttachment( 0, 0 );\n    fdlAddFileToResult.top = new FormAttachment( wPrevious, margin );\n    fdlAddFileToResult.right = new FormAttachment( middle, -margin );\n    wlAddFileToResult.setLayoutData( fdlAddFileToResult );\n    wAddFileToResult = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wAddFileToResult );\n    wAddFileToResult.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.AddFileToResult.Tooltip\" ) );\n    fdAddFileToResult = new FormData();\n    fdAddFileToResult.left = new FormAttachment( middle, 0 );\n    fdAddFileToResult.top = new FormAttachment( wPrevious, margin );\n    fdAddFileToResult.right = new FormAttachment( 100, 0 );\n    wAddFileToResult.setLayoutData( fdAddFileToResult );\n    wAddFileToResult.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n    \n    fdSettingsComp = new FormData();\n    fdSettingsComp.left = new FormAttachment( 0, 0 );\n    fdSettingsComp.top = new FormAttachment( 0, 0 );\n    fdSettingsComp.right = new FormAttachment( 100, 0 );\n    fdSettingsComp.bottom = new FormAttachment( 100, 0 );\n    wSettingsComp.setLayoutData( fdSettingsComp );\n\n    wSettingsComp.layout();\n    wSettingsTab.setControl( wSettingsComp );\n    props.setLook( wSettingsComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF SETTINGS TAB\n    // ///////////////////////////////////////////////////////////    \n    \n    ToolBar tb = new ToolBar( wFilesComp, SWT.HORIZONTAL | SWT.FLAT );\n    props.setLook( tb );\n    FormData fdTb = new FormData();\n    fdTb.right = new FormAttachment( 100, 0 );\n    fdTb.top = new FormAttachment( wFilesComp, margin );\n    tb.setLayoutData( fdTb );\n\n    deleteToolItem = new ToolItem( tb, SWT.PUSH );\n    deleteToolItem.setImage( GUIResource.getInstance().getImageDelete() );\n    deleteToolItem.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.FilenameDelete.Tooltip\" ) );\n    deleteToolItem.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent arg0 ) {\n        int[] idx = wFields.getSelectionIndices();\n        wFields.remove( idx );\n        wFields.removeEmptyRows();\n        wFields.setRowNums();\n      }\n    } );\n\n    wlFields = new Label( wFilesComp, SWT.NONE );\n    wlFields.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.Label\" ) );\n    props.setLook( wlFields );\n    fdlFields = new FormData();\n    fdlFields.left = new FormAttachment( 0, margin );\n    fdlFields.right = new FormAttachment( middle, -margin );\n    fdlFields.top = new FormAttachment( wFilesComp, 15 );\n    wlFields.setLayoutData( fdlFields );\n\n    int rows =\n      jobEntry.source_filefolder == null ? 1 : ( jobEntry.source_filefolder.length == 0\n        ? 0 : jobEntry.source_filefolder.length );\n    final int FieldsRows = rows;\n\n    ColumnInfo[] colinf =\n        new ColumnInfo[] {\n          new ColumnInfo( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.SourceEnvironment.Label\" ),\n              ColumnInfo.COLUMN_TYPE_CCOMBO, false, true ),\n          new ColumnInfo( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.SourceFileFolder.Label\" ),\n              ColumnInfo.COLUMN_TYPE_TEXT_BUTTON, false ),\n          new ColumnInfo( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.Wildcard.Label\" ),\n              ColumnInfo.COLUMN_TYPE_TEXT, false ),\n          new ColumnInfo( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.DestinationEnvironment.Label\" ),\n              ColumnInfo.COLUMN_TYPE_CCOMBO, false, true ),\n          new ColumnInfo( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.DestinationFileFolder.Label\" ),\n              ColumnInfo.COLUMN_TYPE_TEXT_BUTTON, false ) };\n    \n    setComboValues( colinf[0] );\n    \n    colinf[1].setUsingVariables( true );\n    colinf[1].setToolTip( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.SourceFileFolder.Tooltip\" ) );\n    colinf[1].setTextVarButtonSelectionListener( getFileSelectionAdapter() );\n\n    colinf[2].setUsingVariables( true );\n    colinf[2].setToolTip( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.Wildcard.Tooltip\" ) );\n\n    setComboValues( colinf[3] );\n    \n    colinf[4].setUsingVariables( true );\n    colinf[4].setToolTip( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.DestinationFileFolder.Tooltip\" ) );\n    colinf[4].setTextVarButtonSelectionListener( getFileSelectionAdapter() );\n    \n    wFields =\n      new TableView(\n        jobMeta, wFilesComp, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, colinf, FieldsRows, lsMod, props );\n\n    fdFields = new FormData();\n    fdFields.left = new FormAttachment( 0, margin );\n    fdFields.top = new FormAttachment( tb, margin );\n    fdFields.right = new FormAttachment( 100, -margin );\n    fdFields.bottom = new FormAttachment( 100, -margin );\n    wFields.setLayoutData( fdFields );\n\n    refreshArgFromPrevious();\n\n    wOK = new Button( shell, SWT.PUSH );\n    wOK.setText( BaseMessages.getString( PKG, \"System.Button.OK\" ) );\n    wCancel = new Button( shell, SWT.PUSH );\n    wCancel.setText( BaseMessages.getString( PKG, \"System.Button.Cancel\" ) );\n\n    Label lBottomSeparator = new Label( shell, SWT.HORIZONTAL | SWT.SEPARATOR );\n    FormData fdBottomSeparator = new FormData();\n    fdBottomSeparator.top = new FormAttachment( wTabFolder, margin * 3 );\n    fdBottomSeparator.left = new FormAttachment( 0, 0 );\n    fdBottomSeparator.right = new FormAttachment( 100, 0 );\n    lBottomSeparator.setLayoutData( fdBottomSeparator );\n\n    BaseStepDialog.positionBottomRightButtons( shell, new Button[] { wOK, wCancel }, margin, lBottomSeparator );\n    FormData fdOK = (FormData) wOK.getLayoutData();\n    FormData fdHelpButton = new FormData();\n    fdHelpButton.top = fdOK.top;\n    fdHelpButton.left = new FormAttachment( 0, margin );\n    helpButton.setLayoutData( fdHelpButton );\n\n    // Add listeners\n    lsCancel = new Listener() {\n      public void handleEvent( Event e ) {\n        cancel();\n      }\n    };\n    lsOK = new Listener() {\n      public void handleEvent( Event e ) {\n        ok();\n      }\n    };\n\n    wCancel.addListener( SWT.Selection, lsCancel );\n    wOK.addListener( SWT.Selection, lsOK );\n\n    lsDef = new SelectionAdapter() {\n      public void widgetDefaultSelected( SelectionEvent e ) {\n        ok();\n      }\n    };\n\n    wName.addSelectionListener( lsDef );\n\n    // Detect X or ALT-F4 or something that kills this window...\n    shell.addShellListener( new ShellAdapter() {\n      public void shellClosed( ShellEvent e ) {\n        cancel();\n      }\n    } );\n\n    getData();\n    CheckIncludeSubFolders();\n    wTabFolder.setSelection( 0 );\n    \n  }","commit_id":"3b40563eded4766513075a8cfab98c1a5583ae28","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Override\n\tpublic String toString() {\n\t\tStringBundler sb = new StringBundler((_syncDLObjects.size() * 52) + 5);\n\n\t\tsb.append(\"{\\\"lastAccessTime\\\":\");\n\t\tsb.append(_lastAccessTime);\n\t\tsb.append(\",\\\"resultsTotal\\\":\");\n\t\tsb.append(_resultsTotal);\n\t\tsb.append(\",\\\"syncDLObjects\\\":[\");\n\n\t\tfor (int i = 0; i < _syncDLObjects.size(); i++) {\n\t\t\tSyncDLObject syncDLObject = _syncDLObjects.get(i);\n\n\t\t\tsb.append(\"{\\\"checksum\\\":\\\"\");\n\t\t\tsb.append(syncDLObject.getChecksum());\n\t\t\tsb.append(\"\\\",\\\"changeLog\\\":\\\"\");\n\t\t\tsb.append(\n\t\t\t\tStringEscapeUtils.escapeJava(syncDLObject.getChangeLog()));\n\t\t\tsb.append(\"\\\",\\\"companyId\\\":\");\n\t\t\tsb.append(syncDLObject.getCompanyId());\n\t\t\tsb.append(\",\\\"createTime\\\":\");\n\t\t\tsb.append(syncDLObject.getCreateTime());\n\t\t\tsb.append(\",\\\"description\\\":\\\"\");\n\t\t\tsb.append(\n\t\t\t\tStringEscapeUtils.escapeJava(syncDLObject.getDescription()));\n\t\t\tsb.append(\"\\\",\\\"extension\\\":\\\"\");\n\t\t\tsb.append(syncDLObject.getExtension());\n\t\t\tsb.append(\"\\\",\\\"extraSettings\\\":\\\"\");\n\t\t\tsb.append(\n\t\t\t\tStringEscapeUtils.escapeJava(syncDLObject.getExtraSettings()));\n\t\t\tsb.append(\"\\\",\\\"event\\\":\\\"\");\n\t\t\tsb.append(syncDLObject.getEvent());\n\t\t\tsb.append(\"\\\",\\\"lockExpirationDate\\\":\");\n\t\t\tsb.append(syncDLObject.getLockExpirationDate());\n\t\t\tsb.append(\",\\\"lockUserId\\\":\");\n\t\t\tsb.append(syncDLObject.getLockUserId());\n\t\t\tsb.append(\",\\\"lockUserName\\\":\\\"\");\n\t\t\tsb.append(\n\t\t\t\tStringEscapeUtils.escapeJava(syncDLObject.getLockUserName()));\n\t\t\tsb.append(\"\\\",\\\"mimeType\\\":\\\"\");\n\t\t\tsb.append(syncDLObject.getMimeType());\n\t\t\tsb.append(\"\\\",\\\"modifiedTime\\\":\");\n\t\t\tsb.append(syncDLObject.getModifiedTime());\n\t\t\tsb.append(\",\\\"name\\\":\\\"\");\n\t\t\tsb.append(StringEscapeUtils.escapeJava(syncDLObject.getName()));\n\t\t\tsb.append(\"\\\",\\\"parentFolderId\\\":\");\n\t\t\tsb.append(syncDLObject.getParentFolderId());\n\t\t\tsb.append(\",\\\"repositoryId\\\":\");\n\t\t\tsb.append(syncDLObject.getRepositoryId());\n\t\t\tsb.append(\",\\\"size\\\":\");\n\t\t\tsb.append(syncDLObject.getSize());\n\t\t\tsb.append(\",\\\"syncDLObjectId\\\":\");\n\t\t\tsb.append(syncDLObject.getSyncDLObjectId());\n\t\t\tsb.append(\",\\\"type\\\":\\\"\");\n\t\t\tsb.append(syncDLObject.getType());\n\t\t\tsb.append(\"\\\",\\\"typePK\\\":\");\n\t\t\tsb.append(syncDLObject.getTypePK());\n\t\t\tsb.append(\",\\\"typeUuid\\\":\\\"\");\n\t\t\tsb.append(syncDLObject.getTypeUuid());\n\t\t\tsb.append(\"\\\",\\\"userId\\\":\");\n\t\t\tsb.append(syncDLObject.getUserId());\n\t\t\tsb.append(\",\\\"userName\\\":\\\"\");\n\t\t\tsb.append(StringEscapeUtils.escapeJava(syncDLObject.getUserName()));\n\t\t\tsb.append(\"\\\",\\\"version\\\":\\\"\");\n\t\t\tsb.append(syncDLObject.getVersion());\n\t\t\tsb.append(\"\\\",\\\"versionId\\\":\");\n\t\t\tsb.append(syncDLObject.getVersionId());\n\t\t\tsb.append(StringPool.CLOSE_CURLY_BRACE);\n\n\t\t\tif (i != (_syncDLObjects.size() - 1)) {\n\t\t\t\tsb.append(StringPool.COMMA);\n\t\t\t}\n\t\t}\n\n\t\tsb.append(\"]}\");\n\n\t\treturn sb.toString();\n\t}","id":6734,"modified_method":"@Override\n\tpublic String toString() {\n\t\tStringBundler sb = new StringBundler((_syncDLObjects.size() * 78) + 5);\n\n\t\tsb.append(\"{\\\"lastAccessTime\\\":\");\n\t\tsb.append(_lastAccessTime);\n\t\tsb.append(\",\\\"resultsTotal\\\":\");\n\t\tsb.append(_resultsTotal);\n\t\tsb.append(\",\\\"syncDLObjects\\\":[\");\n\n\t\tfor (int i = 0; i < _syncDLObjects.size(); i++) {\n\t\t\tSyncDLObject syncDLObject = _syncDLObjects.get(i);\n\n\t\t\tsb.append(\"{\\\"checksum\\\":\");\n\t\t\tappendString(sb, syncDLObject.getChecksum(), false);\n\t\t\tsb.append(\",\\\"changeLog\\\":\");\n\t\t\tappendString(sb, syncDLObject.getChangeLog(), false);\n\t\t\tsb.append(\",\\\"companyId\\\":\");\n\t\t\tsb.append(syncDLObject.getCompanyId());\n\t\t\tsb.append(\",\\\"createTime\\\":\");\n\t\t\tsb.append(syncDLObject.getCreateTime());\n\t\t\tsb.append(\",\\\"description\\\":\");\n\t\t\tappendString(sb, syncDLObject.getDescription(), true);\n\t\t\tsb.append(\",\\\"extension\\\":\");\n\t\t\tappendString(sb, syncDLObject.getExtension(), false);\n\t\t\tsb.append(\",\\\"extraSettings\\\":\");\n\t\t\tappendString(sb, syncDLObject.getExtraSettings(), true);\n\t\t\tsb.append(\",\\\"event\\\":\");\n\t\t\tappendString(sb, syncDLObject.getEvent(), false);\n\t\t\tsb.append(\",\\\"lockExpirationDate\\\":\");\n\t\t\tsb.append(syncDLObject.getLockExpirationDate());\n\t\t\tsb.append(\",\\\"lockUserId\\\":\");\n\t\t\tsb.append(syncDLObject.getLockUserId());\n\t\t\tsb.append(\",\\\"lockUserName\\\":\");\n\t\t\tappendString(sb, syncDLObject.getLockUserName(), true);\n\t\t\tsb.append(\",\\\"mimeType\\\":\");\n\t\t\tappendString(sb, syncDLObject.getMimeType(), false);\n\t\t\tsb.append(\",\\\"modifiedTime\\\":\");\n\t\t\tsb.append(syncDLObject.getModifiedTime());\n\t\t\tsb.append(\",\\\"name\\\":\");\n\t\t\tappendString(sb, syncDLObject.getName(), true);\n\t\t\tsb.append(\",\\\"parentFolderId\\\":\");\n\t\t\tsb.append(syncDLObject.getParentFolderId());\n\t\t\tsb.append(\",\\\"repositoryId\\\":\");\n\t\t\tsb.append(syncDLObject.getRepositoryId());\n\t\t\tsb.append(\",\\\"size\\\":\");\n\t\t\tsb.append(syncDLObject.getSize());\n\t\t\tsb.append(\",\\\"syncDLObjectId\\\":\");\n\t\t\tsb.append(syncDLObject.getSyncDLObjectId());\n\t\t\tsb.append(\",\\\"type\\\":\");\n\t\t\tappendString(sb, syncDLObject.getType(), false);\n\t\t\tsb.append(\",\\\"typePK\\\":\");\n\t\t\tsb.append(syncDLObject.getTypePK());\n\t\t\tsb.append(\",\\\"typeUuid\\\":\");\n\t\t\tappendString(sb, syncDLObject.getTypeUuid(), false);\n\t\t\tsb.append(\",\\\"userId\\\":\");\n\t\t\tsb.append(syncDLObject.getUserId());\n\t\t\tsb.append(\",\\\"userName\\\":\");\n\t\t\tappendString(sb, syncDLObject.getUserName(), true);\n\t\t\tsb.append(\",\\\"version\\\":\");\n\t\t\tappendString(sb, syncDLObject.getVersion(), false);\n\t\t\tsb.append(\",\\\"versionId\\\":\");\n\t\t\tsb.append(syncDLObject.getVersionId());\n\t\t\tsb.append(StringPool.CLOSE_CURLY_BRACE);\n\n\t\t\tif (i != (_syncDLObjects.size() - 1)) {\n\t\t\t\tsb.append(StringPool.COMMA);\n\t\t\t}\n\t\t}\n\n\t\tsb.append(\"]}\");\n\n\t\treturn sb.toString();\n\t}","commit_id":"d63ec308dde4c04863a685374d9d3330c1c61202","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"/**\n     * Checks that entries in cache are correct after being unswapped.\n     * If entry is still swapped, it will be unswapped in this method.\n     *\n     * @param cache Cache.\n     * @param lowerBound Lower key bound.\n     * @param upperBound Upper key bound.\n     * @throws Exception In case of error.\n     */\n    private void checkEntries(GridCache<Integer, CacheValue> cache, int lowerBound, int upperBound) throws Exception {\n        for (int i = lowerBound; i < upperBound; i++) {\n            cache.promote(i);\n\n            GridCacheEntryEx entry = dht(cache).entryEx(i);\n\n            assert entry != null;\n            assert entry.key() != null;\n\n            CacheValue val = CU.value(entry.rawGet(), entry.context(), false);\n\n            assertNotNull(\"Value null for key: \" + i, val);\n            assertEquals(entry.key().value(entry.context().cacheObjectContext(), false), (Integer)val.value());\n\n            assertEquals(entry.version(), versions.get(i));\n        }\n    }","id":6735,"modified_method":"/**\n     * Checks that entries in cache are correct after being unswapped.\n     * If entry is still swapped, it will be unswapped in this method.\n     *\n     * @param cache Cache.\n     * @param lowerBound Lower key bound.\n     * @param upperBound Upper key bound.\n     * @throws Exception In case of error.\n     */\n    private void checkEntries(IgniteCache<Integer, CacheValue> cache, int lowerBound, int upperBound) throws Exception {\n        for (int i = lowerBound; i < upperBound; i++) {\n            cache.localPromote(Collections.singleton(i));\n\n            GridCacheEntryEx entry = dht(cache).entryEx(i);\n\n            assert entry != null;\n            assert entry.key() != null;\n\n            CacheValue val = CU.value(entry.rawGet(), entry.context(), false);\n\n            assertNotNull(\"Value null for key: \" + i, val);\n            assertEquals(entry.key().value(entry.context().cacheObjectContext(), false), (Integer)val.value());\n\n            assertEquals(entry.version(), versions.get(i));\n        }\n    }","commit_id":"8837527e8f61bc977ffeeac6d25f32714081f6ec","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Unswaps entries and checks result.\n     *\n     * @param cache Cache.\n     * @param lowerBound Lower key bound.\n     * @param upperBound Upper key bound.\n     * @throws Exception In case of error.\n     */\n    private void unswap(GridCache<Integer, CacheValue> cache, int lowerBound, int upperBound) throws Exception {\n        resetCounters();\n\n        assertEquals(0, swapCnt.get());\n        assertEquals(0, unswapCnt.get());\n\n        for (int i = lowerBound; i < upperBound; i++) {\n            assert cache.peek(i) == null;\n\n            CacheValue val = cache.promote(i);\n\n            assertNotNull(val);\n            assertEquals(i, val.value());\n\n            assertEquals(i - lowerBound + 1, unswapCnt.get());\n        }\n\n        assertEquals(0, swapCnt.get());\n        assertEquals(unswapCnt.get(), upperBound - lowerBound);\n\n        checkEntries(cache, lowerBound, upperBound);\n\n        assertEquals(0, swapCnt.get());\n        assertEquals(unswapCnt.get(), upperBound - lowerBound);\n    }","id":6736,"modified_method":"/**\n     * Unswaps entries and checks result.\n     *\n     * @param cache Cache.\n     * @param lowerBound Lower key bound.\n     * @param upperBound Upper key bound.\n     * @throws Exception In case of error.\n     */\n    private void unswap(IgniteCache<Integer, CacheValue> cache, int lowerBound, int upperBound) throws Exception {\n        resetCounters();\n\n        assertEquals(0, swapCnt.get());\n        assertEquals(0, unswapCnt.get());\n\n        for (int i = lowerBound; i < upperBound; i++) {\n            assert cache.localPeek(i) == null;\n\n            cache.localPromote(Collections.singleton(i));\n            CacheValue val = cache.localPeek(i);\n\n            assertNotNull(val);\n            assertEquals(i, val.value());\n\n            assertEquals(i - lowerBound + 1, unswapCnt.get());\n        }\n\n        assertEquals(0, swapCnt.get());\n        assertEquals(unswapCnt.get(), upperBound - lowerBound);\n\n        checkEntries(cache, lowerBound, upperBound);\n\n        assertEquals(0, swapCnt.get());\n        assertEquals(unswapCnt.get(), upperBound - lowerBound);\n    }","commit_id":"8837527e8f61bc977ffeeac6d25f32714081f6ec","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Runs SQL query and checks result.\n     *\n     * @param cache Cache.\n     * @param lowerBound Lower key bound.\n     * @param upperBound Upper key bound.\n     * @throws Exception In case of error.\n     */\n    private void query(GridCache<Integer, CacheValue> cache, int lowerBound, int upperBound) throws Exception {\n        resetCounters();\n\n        Collection<Map.Entry<Integer, CacheValue>> res = cache.queries().\n            createSqlQuery(CacheValue.class, \"val >= ? and val < ?\").\n            execute(lowerBound, upperBound).\n            get();\n\n        assertEquals(res.size(), upperBound - lowerBound);\n\n        for (Map.Entry<Integer, CacheValue> entry : res) {\n            assert entry != null;\n            assert entry.getKey() != null;\n            assert entry.getValue() != null;\n            assert entry.getKey() == entry.getValue().value();\n        }\n\n        assertEquals(0, swapCnt.get());\n        assertEquals(0, unswapCnt.get());\n\n        checkEntries(cache, lowerBound, upperBound);\n\n        assertEquals(0, swapCnt.get());\n        assertEquals(unswapCnt.get(), upperBound - lowerBound);\n    }","id":6737,"modified_method":"/**\n     * Runs SQL query and checks result.\n     *\n     * @param cache Cache.\n     * @param lowerBound Lower key bound.\n     * @param upperBound Upper key bound.\n     * @throws Exception In case of error.\n     */\n    private void query(IgniteCache<Integer, CacheValue> cache, int lowerBound, int upperBound) throws Exception {\n        resetCounters();\n\n        Collection<Cache.Entry<Integer, CacheValue>> res = cache.query(new SqlQuery<Integer, CacheValue>(CacheValue.class, \"val >= ? and val < ?\").\n            setArgs(lowerBound, upperBound)).\n            getAll();\n\n        assertEquals(res.size(), upperBound - lowerBound);\n\n        for (Cache.Entry<Integer, CacheValue> entry : res) {\n            assert entry != null;\n            assert entry.getKey() != null;\n            assert entry.getValue() != null;\n            assert entry.getKey() == entry.getValue().value();\n        }\n\n        assertEquals(0, swapCnt.get());\n        assertEquals(0, unswapCnt.get());\n\n        checkEntries(cache, lowerBound, upperBound);\n\n        assertEquals(0, swapCnt.get());\n        assertEquals(unswapCnt.get(), upperBound - lowerBound);\n    }","commit_id":"8837527e8f61bc977ffeeac6d25f32714081f6ec","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Unswaps entries via {@code get} method and checks result.\n     *\n     * @param cache Cache.\n     * @param lowerBound Lower key bound.\n     * @param upperBound Upper key bound.\n     * @throws Exception In case of error.\n     */\n    private void get(GridCache<Integer, CacheValue> cache, int lowerBound, int upperBound) throws Exception {\n        resetCounters();\n\n        for (int i = lowerBound; i < upperBound; i++) {\n            assert cache.peek(i) == null;\n\n            CacheValue val = cache.get(i);\n\n            assert val != null;\n            assert val.value() == i;\n        }\n\n        assert swapCnt.get() == 0;\n        assert unswapCnt.get() == upperBound - lowerBound;\n\n        checkEntries(cache, lowerBound, upperBound);\n\n        assert swapCnt.get() == 0;\n        assert unswapCnt.get() == upperBound - lowerBound;\n    }","id":6738,"modified_method":"/**\n     * Unswaps entries via {@code get} method and checks result.\n     *\n     * @param cache Cache.\n     * @param lowerBound Lower key bound.\n     * @param upperBound Upper key bound.\n     * @throws Exception In case of error.\n     */\n    private void get(IgniteCache<Integer, CacheValue> cache, int lowerBound, int upperBound) throws Exception {\n        resetCounters();\n\n        for (int i = lowerBound; i < upperBound; i++) {\n            assert cache.localPeek(i) == null;\n\n            CacheValue val = cache.get(i);\n\n            assert val != null;\n            assert val.value() == i;\n        }\n\n        assert swapCnt.get() == 0;\n        assert unswapCnt.get() == upperBound - lowerBound;\n\n        checkEntries(cache, lowerBound, upperBound);\n\n        assert swapCnt.get() == 0;\n        assert unswapCnt.get() == upperBound - lowerBound;\n    }","commit_id":"8837527e8f61bc977ffeeac6d25f32714081f6ec","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Unswaps entries and checks result.\n     *\n     * @param cache Cache.\n     * @param lowerBound Lower key bound.\n     * @param upperBound Upper key bound.\n     * @throws Exception In case of error.\n     */\n    private void unswapAll(GridCache<Integer, CacheValue> cache, int lowerBound, int upperBound) throws Exception {\n        resetCounters();\n\n        Collection<Integer> keys = new HashSet<>();\n\n        for (int i = lowerBound; i < upperBound; i++) {\n            assert cache.peek(i) == null;\n\n            keys.add(i);\n        }\n\n        cache.promoteAll(keys);\n\n        assert swapCnt.get() == 0;\n        assert unswapCnt.get() == upperBound - lowerBound;\n\n        checkEntries(cache, lowerBound, upperBound);\n\n        assert swapCnt.get() == 0;\n        assert unswapCnt.get() == upperBound - lowerBound;\n    }","id":6739,"modified_method":"/**\n     * Unswaps entries and checks result.\n     *\n     * @param cache Cache.\n     * @param lowerBound Lower key bound.\n     * @param upperBound Upper key bound.\n     * @throws Exception In case of error.\n     */\n    private void unswapAll(IgniteCache<Integer, CacheValue> cache, int lowerBound, int upperBound) throws Exception {\n        resetCounters();\n\n        Set<Integer> keys = new HashSet<>();\n\n        for (int i = lowerBound; i < upperBound; i++) {\n            assert cache.localPeek(i) == null;\n\n            keys.add(i);\n        }\n\n        cache.localPromote(keys);\n\n        assert swapCnt.get() == 0;\n        assert unswapCnt.get() == upperBound - lowerBound;\n\n        checkEntries(cache, lowerBound, upperBound);\n\n        assert swapCnt.get() == 0;\n        assert unswapCnt.get() == upperBound - lowerBound;\n    }","commit_id":"8837527e8f61bc977ffeeac6d25f32714081f6ec","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Peeks entries in {@code SWAP} mode and checks result.\n     *\n     * @param cache Cache.\n     * @param lowerBound Lower key bound.\n     * @param upperBound Upper key bound.\n     * @throws Exception In case of error.\n     */\n    private void peek(GridCache<Integer, CacheValue> cache, int lowerBound, int upperBound) throws Exception {\n        resetCounters();\n\n        for (int i = lowerBound; i < upperBound; i++) {\n            assert cache.peek(i) == null;\n\n            CacheValue val = cache.peek(i, F.asList(SWAP));\n\n            assert val != null;\n            assert val.value() == i;\n        }\n\n        assert swapCnt.get() == 0;\n        assert unswapCnt.get() == 0;\n\n        checkEntries(cache, lowerBound, upperBound);\n\n        assert swapCnt.get() == 0;\n        assert unswapCnt.get() == upperBound - lowerBound;\n    }","id":6740,"modified_method":"/**\n     * Peeks entries in {@code SWAP} mode and checks result.\n     *\n     * @param cache Cache.\n     * @param lowerBound Lower key bound.\n     * @param upperBound Upper key bound.\n     * @throws Exception In case of error.\n     */\n    private void peek(IgniteCache<Integer, CacheValue> cache, int lowerBound, int upperBound) throws Exception {\n        resetCounters();\n\n        for (int i = lowerBound; i < upperBound; i++) {\n            assert cache.localPeek(i) == null;\n\n            CacheValue val = cache.localPeek(i, CachePeekMode.SWAP);\n\n            assert val != null;\n            assert val.value() == i;\n        }\n\n        assert swapCnt.get() == 0;\n        assert unswapCnt.get() == 0;\n\n        checkEntries(cache, lowerBound, upperBound);\n\n        assert swapCnt.get() == 0;\n        assert unswapCnt.get() == upperBound - lowerBound;\n    }","commit_id":"8837527e8f61bc977ffeeac6d25f32714081f6ec","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testOffHeapIterator() throws Exception {\n        try {\n            startGrids(1);\n\n            grid(0);\n\n            GridCache<Integer, Integer> cache = ((IgniteKernal)grid(0)).getCache(null);\n\n            for (int i = 0; i < 100; i++) {\n                info(\"Putting: \" + i);\n\n                cache.put(i, i);\n\n                assert cache.evict(i);\n            }\n\n            Iterator<Map.Entry<Integer, Integer>> iter = cache.offHeapIterator();\n\n            assert iter != null;\n\n            int i = 0;\n\n            while (iter.hasNext()) {\n                Map.Entry<Integer, Integer> e = iter.next();\n\n                Integer key = e.getKey();\n\n                info(\"Key: \" + key);\n\n                i++;\n\n                iter.remove();\n\n                assertNull(cache.get(key));\n            }\n\n            assertEquals(100, i);\n\n            assert cache.isEmpty();\n        }\n        finally {\n            stopAllGrids();\n        }\n    }","id":6741,"modified_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testOffHeapIterator() throws Exception {\n        try {\n            startGrids(1);\n\n            grid(0);\n\n            IgniteCache<Integer, Integer> cache = grid(0).cache(null);\n\n            for (int i = 0; i < 100; i++) {\n                info(\"Putting: \" + i);\n\n                cache.put(i, i);\n\n                cache.localEvict(Collections.singleton(i));\n            }\n\n            int i = 0;\n\n            for (Cache.Entry<Integer, Integer> e : cache.localEntries(CachePeekMode.OFFHEAP)) {\n                Integer key = e.getKey();\n\n                info(\"Key: \" + key);\n\n                i++;\n\n                cache.remove(e.getKey());\n\n                assertNull(cache.get(key));\n            }\n\n            assertEquals(100, i);\n\n            assert cache.localSize() == 0;\n        }\n        finally {\n            stopAllGrids();\n        }\n    }","commit_id":"8837527e8f61bc977ffeeac6d25f32714081f6ec","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @throws Exception If failed.\n     */\n    @SuppressWarnings(\"BusyWait\")\n    public void testOffHeapDeployment() throws Exception {\n        try {\n            Ignite ignite1 = startGrid(1);\n\n            excluded = true;\n\n            Ignite ignite2 = startGrid(2);\n\n            GridCache<Integer, Object> cache1 = ((IgniteKernal)ignite1).getCache(null);\n            GridCache<Integer, Object> cache2 = ((IgniteKernal)ignite2).getCache(null);\n\n            Object v1 = new CacheValue(1);\n\n            cache1.put(1, v1);\n\n            info(\"Stored value in cache1 [v=\" + v1 + \", ldr=\" + v1.getClass().getClassLoader() + ']');\n\n            Object v2 = cache2.get(1);\n\n            assert v2 != null;\n\n            info(\"Read value from cache2 [v=\" + v2 + \", ldr=\" + v2.getClass().getClassLoader() + ']');\n\n            assert v2 != null;\n            assert !v2.getClass().getClassLoader().equals(getClass().getClassLoader());\n            assert v2.getClass().getClassLoader().getClass().getName().contains(\"GridDeploymentClassLoader\");\n\n            SwapListener lsnr = new SwapListener();\n\n            ignite2.events().localListen(lsnr, EVT_CACHE_OBJECT_TO_OFFHEAP, EVT_CACHE_OBJECT_FROM_OFFHEAP);\n\n            cache2.evictAll();\n\n            assert lsnr.awaitSwap();\n\n            assert cache2.get(1) != null;\n\n            assert lsnr.awaitUnswap();\n\n            ignite2.events().stopLocalListen(lsnr);\n\n            lsnr = new SwapListener();\n\n            ignite2.events().localListen(lsnr, EVT_CACHE_OBJECT_TO_OFFHEAP, EVT_CACHE_OBJECT_FROM_OFFHEAP);\n\n            cache2.evictAll();\n\n            assert lsnr.awaitSwap();\n\n            stopGrid(1);\n\n            boolean success = false;\n\n            for (int i = 0; i < 6; i++) {\n                success = cache2.get(1) == null;\n\n                if (success)\n                    break;\n                else if (i < 2) {\n                    info(\"Sleeping to wait for cache clear.\");\n\n                    Thread.sleep(500);\n                }\n            }\n\n            assert success;\n        }\n        finally {\n            stopAllGrids();\n        }\n    }","id":6742,"modified_method":"/**\n     * @throws Exception If failed.\n     */\n    @SuppressWarnings(\"BusyWait\")\n    public void testOffHeapDeployment() throws Exception {\n        try {\n            Ignite ignite1 = startGrid(1);\n\n            excluded = true;\n\n            Ignite ignite2 = startGrid(2);\n\n            IgniteCache<Integer, Object> cache1 = ignite1.cache(null);\n            IgniteCache<Integer, Object> cache2 = ignite2.cache(null);\n\n            Object v1 = new CacheValue(1);\n\n            cache1.put(1, v1);\n\n            info(\"Stored value in cache1 [v=\" + v1 + \", ldr=\" + v1.getClass().getClassLoader() + ']');\n\n            Object v2 = cache2.get(1);\n\n            assert v2 != null;\n\n            info(\"Read value from cache2 [v=\" + v2 + \", ldr=\" + v2.getClass().getClassLoader() + ']');\n\n            assert v2 != null;\n            assert !v2.getClass().getClassLoader().equals(getClass().getClassLoader());\n            assert v2.getClass().getClassLoader().getClass().getName().contains(\"GridDeploymentClassLoader\");\n\n            SwapListener lsnr = new SwapListener();\n\n            ignite2.events().localListen(lsnr, EVT_CACHE_OBJECT_TO_OFFHEAP, EVT_CACHE_OBJECT_FROM_OFFHEAP);\n\n            cache2.localEvict(keySet(cache2));\n\n            assert lsnr.awaitSwap();\n\n            assert cache2.get(1) != null;\n\n            assert lsnr.awaitUnswap();\n\n            ignite2.events().stopLocalListen(lsnr);\n\n            lsnr = new SwapListener();\n\n            ignite2.events().localListen(lsnr, EVT_CACHE_OBJECT_TO_OFFHEAP, EVT_CACHE_OBJECT_FROM_OFFHEAP);\n\n            cache2.localEvict(keySet(cache2));\n\n            assert lsnr.awaitSwap();\n\n            stopGrid(1);\n\n            boolean success = false;\n\n            for (int i = 0; i < 6; i++) {\n                success = cache2.get(1) == null;\n\n                if (success)\n                    break;\n                else if (i < 2) {\n                    info(\"Sleeping to wait for cache clear.\");\n\n                    Thread.sleep(500);\n                }\n            }\n\n            assert success;\n        }\n        finally {\n            stopAllGrids();\n        }\n    }","commit_id":"8837527e8f61bc977ffeeac6d25f32714081f6ec","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Populates cache.\n     *\n     * @param cache Cache.\n     * @throws Exception In case of error.\n     */\n    private void populate(GridCache<Integer, CacheValue> cache) throws Exception {\n        resetCounters();\n\n        for (int i = 0; i < ENTRY_CNT; i++) {\n            cache.put(i, new CacheValue(i));\n\n            CacheValue val = cache.peek(i);\n\n            assert val != null;\n            assert val.value() == i;\n\n            GridCacheEntryEx entry = dht(cache).peekEx(i);\n\n            assert entry != null;\n\n            versions.put(i, entry.version());\n        }\n\n        assert swapCnt.get() == 0;\n        assert unswapCnt.get() == 0;\n    }","id":6743,"modified_method":"/**\n     * Populates cache.\n     *\n     * @param cache Cache.\n     * @throws Exception In case of error.\n     */\n    private void populate(IgniteCache<Integer, CacheValue> cache) throws Exception {\n        resetCounters();\n\n        for (int i = 0; i < ENTRY_CNT; i++) {\n            cache.put(i, new CacheValue(i));\n\n            CacheValue val = cache.localPeek(i);\n\n            assert val != null;\n            assert val.value() == i;\n\n            GridCacheEntryEx entry = dht(cache).peekEx(i);\n\n            assert entry != null;\n\n            versions.put(i, entry.version());\n        }\n\n        assert swapCnt.get() == 0;\n        assert unswapCnt.get() == 0;\n    }","commit_id":"8837527e8f61bc977ffeeac6d25f32714081f6ec","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testOffHeap() throws Exception {\n        try {\n            startGrids(1);\n\n            grid(0).events().localListen(new IgnitePredicate<Event>() {\n                @Override public boolean apply(Event evt) {\n                    assert evt != null;\n\n                    switch (evt.type()) {\n                        case EVT_CACHE_OBJECT_TO_OFFHEAP:\n                            swapCnt.incrementAndGet();\n\n                            break;\n                        case EVT_CACHE_OBJECT_FROM_OFFHEAP:\n                            unswapCnt.incrementAndGet();\n\n                            break;\n                    }\n\n                    return true;\n                }\n            }, EVT_CACHE_OBJECT_TO_OFFHEAP, EVT_CACHE_OBJECT_FROM_OFFHEAP);\n\n            GridCache<Integer, CacheValue> cache = ((IgniteKernal)grid(0)).getCache(null);\n\n            populate(cache);\n            evictAll(cache);\n\n            // Check iterator.\n            Iterator<Map.Entry<Integer, CacheValue>> it = cache.offHeapIterator();\n\n            int cnt = 0;\n\n            while (it.hasNext()) {\n                Map.Entry<Integer, CacheValue> e = it.next();\n\n                assertEquals(e.getKey().intValue(), e.getValue().value());\n\n                cnt++;\n            }\n\n            assertEquals(ENTRY_CNT, cnt);\n\n            query(cache, 0, 200);        // Query swapped entries.\n            unswap(cache, 200, 400);     // Check 'promote' method.\n            unswapAll(cache, 400, 600);  // Check 'promoteAll' method.\n            get(cache, 600, 800);        // Check 'get' method.\n            peek(cache, 800, ENTRY_CNT); // Check 'peek' method in 'SWAP' mode.\n\n            // Check that all entries were unswapped.\n            for (int i = 0; i < ENTRY_CNT; i++) {\n                CacheValue val = cache.peek(i);\n\n                assert val != null;\n                assert val.value() == i;\n            }\n\n            // Query unswapped entries.\n            Collection<Map.Entry<Integer, CacheValue>> res = cache.queries().\n                createSqlQuery(CacheValue.class, \"val >= ? and val < ?\").\n                execute(0, ENTRY_CNT).\n                get();\n\n            assert res.size() == ENTRY_CNT;\n\n            for (Map.Entry<Integer, CacheValue> entry : res) {\n                assert entry != null;\n                assert entry.getKey() != null;\n                assert entry.getValue() != null;\n                assert entry.getKey() == entry.getValue().value();\n            }\n        }\n        finally {\n            stopAllGrids();\n        }\n    }","id":6744,"modified_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testOffHeap() throws Exception {\n        try {\n            startGrids(1);\n\n            grid(0).events().localListen(new IgnitePredicate<Event>() {\n                @Override public boolean apply(Event evt) {\n                    assert evt != null;\n\n                    switch (evt.type()) {\n                        case EVT_CACHE_OBJECT_TO_OFFHEAP:\n                            swapCnt.incrementAndGet();\n\n                            break;\n                        case EVT_CACHE_OBJECT_FROM_OFFHEAP:\n                            unswapCnt.incrementAndGet();\n\n                            break;\n                    }\n\n                    return true;\n                }\n            }, EVT_CACHE_OBJECT_TO_OFFHEAP, EVT_CACHE_OBJECT_FROM_OFFHEAP);\n\n            IgniteCache<Integer, CacheValue> cache = grid(0).cache(null);\n\n            populate(cache);\n            evictAll(cache);\n\n            int cnt = 0;\n\n            for (Cache.Entry<Integer, CacheValue> e : cache.localEntries(CachePeekMode.OFFHEAP)) {\n                assertEquals(e.getKey().intValue(), e.getValue().value());\n\n                cnt++;\n            }\n\n            assertEquals(ENTRY_CNT, cnt);\n\n            query(cache, 0, 200);        // Query swapped entries.\n            unswap(cache, 200, 400);     // Check 'promote' method.\n            unswapAll(cache, 400, 600);  // Check 'promoteAll' method.\n            get(cache, 600, 800);        // Check 'get' method.\n            peek(cache, 800, ENTRY_CNT); // Check 'peek' method in 'SWAP' mode.\n\n            // Check that all entries were unswapped.\n            for (int i = 0; i < ENTRY_CNT; i++) {\n                CacheValue val = cache.localPeek(i);\n\n                assert val != null;\n                assert val.value() == i;\n            }\n\n            // Query unswapped entries.\n            Collection<Cache.Entry<Integer, CacheValue>> res = cache.query(\n                new SqlQuery<Integer, CacheValue>(CacheValue.class, \"val >= ? and val < ?\").\n                setArgs(0, ENTRY_CNT)).\n                getAll();\n\n            assert res.size() == ENTRY_CNT;\n\n            for (Cache.Entry<Integer, CacheValue> entry : res) {\n                assert entry != null;\n                assert entry.getKey() != null;\n                assert entry.getValue() != null;\n                assert entry.getKey() == entry.getValue().value();\n            }\n        }\n        finally {\n            stopAllGrids();\n        }\n    }","commit_id":"8837527e8f61bc977ffeeac6d25f32714081f6ec","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Evicts all entries in cache.\n     *\n     * @param cache Cache.\n     * @throws Exception In case of error.\n     */\n    private void evictAll(GridCache<Integer, CacheValue> cache) throws Exception {\n        resetCounters();\n\n        assertEquals(ENTRY_CNT, cache.size());\n        assertEquals(0, cache.offHeapEntriesCount());\n\n        for (int i = 0; i < ENTRY_CNT; i++) {\n            cache.evict(i);\n\n            assertEquals(ENTRY_CNT - i - 1, cache.size());\n            assertEquals(i + 1, cache.offHeapEntriesCount());\n        }\n        // cache.evictAll();\n\n        assertEquals(0, cache.size());\n        assertEquals(ENTRY_CNT, cache.offHeapEntriesCount());\n\n        for (int i = 0; i < ENTRY_CNT; i++)\n            assertNull(cache.peek(i));\n\n        assertEquals(ENTRY_CNT, swapCnt.get());\n        assertEquals(0, unswapCnt.get());\n    }","id":6745,"modified_method":"/**\n     * Evicts all entries in cache.\n     *\n     * @param cache Cache.\n     * @throws Exception In case of error.\n     */\n    private void evictAll(IgniteCache<Integer, CacheValue> cache) throws Exception {\n        resetCounters();\n\n        assertEquals(ENTRY_CNT, cache.size());\n        assertEquals(0, cache.localSize(CachePeekMode.OFFHEAP));\n\n        for (int i = 0; i < ENTRY_CNT; i++) {\n            cache.localEvict(Collections.singleton(i));\n\n            assertEquals(ENTRY_CNT - i - 1, cache.size());\n            assertEquals(i + 1, cache.localSize(CachePeekMode.OFFHEAP));\n        }\n        // cache.evictAll();\n\n        assertEquals(0, cache.size());\n        assertEquals(ENTRY_CNT, cache.localSize(CachePeekMode.OFFHEAP));\n\n        for (int i = 0; i < ENTRY_CNT; i++)\n            assertNull(cache.localPeek(i));\n\n        assertEquals(ENTRY_CNT, swapCnt.get());\n        assertEquals(0, unswapCnt.get());\n    }","commit_id":"8837527e8f61bc977ffeeac6d25f32714081f6ec","url":"https://github.com/apache/ignite"},{"original_method":"/** @throws Exception If failed. */\n    private void checkSwapMultithreaded() throws Exception {\n        final AtomicBoolean done = new AtomicBoolean();\n        IgniteInternalFuture<?> fut = null;\n\n        try {\n            startGrid(0);\n\n            final GridCache<Integer, Integer> cache = ((IgniteKernal)grid(0)).getCache(null);\n\n            assertNotNull(cache);\n\n            // Populate.\n            for (int i = 0; i < ENTRY_CNT; i++)\n                cache.put(i, i);\n\n            cache.evictAll();\n\n            fut = multithreadedAsync(new Callable<Object>() {\n                @Nullable @Override public Object call() throws Exception {\n                    Random rnd = new Random();\n\n                    while (!done.get()) {\n                        int key = rnd.nextInt(ENTRY_CNT);\n\n                        Integer i = cache.get(key);\n\n                        assertNotNull(i);\n                        assertEquals(Integer.valueOf(key), i);\n\n                        boolean b = cache.evict(rnd.nextInt(ENTRY_CNT));\n\n                        assert b;\n                    }\n\n                    return null;\n                }\n            }, 10);\n\n            startGrid(1);\n\n            done.set(true);\n\n            int size = grid(1).cache(null).localSize();\n\n            info(\"New node cache size: \" + size);\n\n            if (size != ENTRY_CNT) {\n                Set<Integer> keySet = new TreeSet<>();\n\n                int next = 0;\n\n                for (IgniteCache.Entry<Integer, Integer> e : grid(1).<Integer, Integer>cache(null).localEntries())\n                    keySet.add(e.getKey());\n\n                for (Integer i : keySet) {\n                    while (next < i)\n                        info(\"Missing key: \" + next++);\n\n                    next++;\n                }\n            }\n\n            assertEquals(ENTRY_CNT, size);\n        }\n        finally {\n            done.set(true);\n\n            try {\n                if (fut != null)\n                    fut.get();\n            }\n            finally {\n                stopAllGrids();\n            }\n        }\n    }","id":6746,"modified_method":"/** @throws Exception If failed. */\n    private void checkSwapMultithreaded() throws Exception {\n        final AtomicBoolean done = new AtomicBoolean();\n        IgniteInternalFuture<?> fut = null;\n\n        try {\n            startGrid(0);\n\n            final IgniteCache<Integer, Integer> cache = grid(0).cache(null);\n\n            assertNotNull(cache);\n\n            // Populate.\n            for (int i = 0; i < ENTRY_CNT; i++)\n                cache.put(i, i);\n\n            Set<Integer> keys = new HashSet<>();\n\n            for (Cache.Entry<Integer, Integer> entry : cache.localEntries())\n                keys.add(entry.getKey());\n\n            cache.localEvict(keys);\n\n            fut = multithreadedAsync(new Callable<Object>() {\n                @Nullable @Override public Object call() throws Exception {\n                    Random rnd = new Random();\n\n                    while (!done.get()) {\n                        int key = rnd.nextInt(ENTRY_CNT);\n\n                        Integer i = cache.get(key);\n\n                        assertNotNull(i);\n                        assertEquals(Integer.valueOf(key), i);\n\n                        cache.localEvict(Collections.singleton(rnd.nextInt(ENTRY_CNT)));\n                    }\n\n                    return null;\n                }\n            }, 10);\n\n            startGrid(1);\n\n            done.set(true);\n\n            int size = grid(1).cache(null).localSize();\n\n            info(\"New node cache size: \" + size);\n\n            if (size != ENTRY_CNT) {\n                Set<Integer> keySet = new TreeSet<>();\n\n                int next = 0;\n\n                for (IgniteCache.Entry<Integer, Integer> e : grid(1).<Integer, Integer>cache(null).localEntries())\n                    keySet.add(e.getKey());\n\n                for (Integer i : keySet) {\n                    while (next < i)\n                        info(\"Missing key: \" + next++);\n\n                    next++;\n                }\n            }\n\n            assertEquals(ENTRY_CNT, size);\n        }\n        finally {\n            done.set(true);\n\n            try {\n                if (fut != null)\n                    fut.get();\n            }\n            finally {\n                stopAllGrids();\n            }\n        }\n    }","commit_id":"8837527e8f61bc977ffeeac6d25f32714081f6ec","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * JUnit.\n     *\n     * @throws Exception If failed.\n     */\n    public void testRemoveInTxQueriedMultiThreaded() throws Exception {\n        //resetLog4j(Level.INFO, true, GridCacheTxManager.class.getPackage().getName());\n\n        backups = 1;\n\n        try {\n            startGrids(GRID_CNT);\n\n            GridCacheAdapter<String, Integer> cache = ((IgniteKernal)grid(0)).internalCache(null);\n\n            // Store counter.\n            cache.getAndPut(RMVD_CNTR_KEY, 0);\n\n            // Store values.\n            for (int i = 1; i <= GRID_CNT * RETRIES; i++)\n                cache.getAndPut(String.valueOf(i), i);\n\n            for (int j = 0; j < GRID_CNT; j++)\n                assertEquals(0, grid(j).cache(null).get(RMVD_CNTR_KEY));\n\n            for (int i = 1; i <= RETRIES; i++)\n                for (int j = 0; j < GRID_CNT; j++)\n                    assertEquals(i, grid(j).cache(null).get(String.valueOf(i)));\n\n            CacheQuery<Map.Entry<String, Integer>> qry = cache.queries().createSqlQuery(Integer.class, \"_val >= 0\");\n\n            // Load all results.\n            qry.keepAll(true);\n            qry.includeBackups(false);\n\n            // NOTE: for replicated cache includeBackups(false) is not enough since\n            // all nodes are considered primary, so we have to deduplicate result set.\n            if (cache.configuration().getCacheMode() == REPLICATED)\n                qry.enableDedup(true);\n\n            List<Map.Entry<String, Integer>> entries =\n                new ArrayList<>(qry.execute().get());\n\n            Collections.sort(entries, new Comparator<Map.Entry<String, Integer>>() {\n                @Override public int compare(Map.Entry<String, Integer> o1, Map.Entry<String, Integer> o2) {\n                    return o1.getValue().compareTo(o2.getValue());\n                }\n            });\n\n            info(\"Queried entries: \" + entries);\n\n            int val = 0;\n\n            for (Map.Entry<String, Integer> e : entries) {\n                assertEquals(val, e.getValue().intValue());\n\n                val++;\n            }\n\n            assertFalse(entries.isEmpty());\n\n            cntrRmvd.set(0);\n\n            Collection<Thread> threads = new LinkedList<>();\n\n            for (int i = 0; i < GRID_CNT; i++) {\n                final int gridId = i;\n\n                threads.add(new Thread() {\n                    @Override public void run() {\n                        try {\n                            removeRetriesQueried(grid(gridId), true);\n                        }\n                        catch (IgniteCheckedException e) {\n                            throw new IgniteException(e);\n                        }\n                    }\n                });\n            }\n\n            for (Thread th : threads)\n                th.start();\n\n            for (Thread th : threads)\n                th.join();\n\n            for (int i = 0; i < GRID_CNT * RETRIES; i++)\n                for (int ii = 0; ii < GRID_CNT; ii++)\n                    assertEquals(\"Got invalid value from cache [gridIdx=\" + ii + \", key=\" + i + ']',\n                        null, grid(ii).cache(null).get(Integer.toString(i)));\n\n            assertEquals(-GRID_CNT * RETRIES, grid(0).cache(null).localPeek(RMVD_CNTR_KEY, CachePeekMode.ONHEAP));\n        }\n        finally {\n            stopAllGrids();\n        }\n    }","id":6747,"modified_method":"/**\n     * JUnit.\n     *\n     * @throws Exception If failed.\n     */\n    public void testRemoveInTxQueriedMultiThreaded() throws Exception {\n        //resetLog4j(Level.INFO, true, GridCacheTxManager.class.getPackage().getName());\n\n        backups = 1;\n\n        try {\n            startGrids(GRID_CNT);\n\n            IgniteCache<String, Integer> cache = grid(0).cache(null);\n\n            // Store counter.\n            cache.getAndPut(RMVD_CNTR_KEY, 0);\n\n            // Store values.\n            for (int i = 1; i <= GRID_CNT * RETRIES; i++)\n                cache.getAndPut(String.valueOf(i), i);\n\n            for (int j = 0; j < GRID_CNT; j++)\n                assertEquals(0, grid(j).cache(null).get(RMVD_CNTR_KEY));\n\n            for (int i = 1; i <= RETRIES; i++)\n                for (int j = 0; j < GRID_CNT; j++)\n                    assertEquals(i, grid(j).cache(null).get(String.valueOf(i)));\n\n            SqlQuery<String, Integer> qry = new SqlQuery<>(Integer.class, \"_val >= 0\");\n\n            List<Cache.Entry<String, Integer>> entries =\n                new ArrayList<>(cache.query(qry).getAll());\n\n            Collections.sort(entries, new Comparator<Cache.Entry<String, Integer>>() {\n                @Override public int compare(Cache.Entry<String, Integer> o1, Cache.Entry<String, Integer> o2) {\n                    return o1.getValue().compareTo(o2.getValue());\n                }\n            });\n\n            info(\"Queried entries: \" + entries);\n\n            int val = 0;\n\n            for (Cache.Entry<String, Integer> e : entries) {\n                assertEquals(val, e.getValue().intValue());\n\n                val++;\n            }\n\n            assertFalse(entries.isEmpty());\n\n            cntrRmvd.set(0);\n\n            Collection<Thread> threads = new LinkedList<>();\n\n            for (int i = 0; i < GRID_CNT; i++) {\n                final int gridId = i;\n\n                threads.add(new Thread() {\n                    @Override public void run() {\n                        try {\n                            removeRetriesQueried(grid(gridId), true);\n                        }\n                        catch (IgniteCheckedException e) {\n                            throw new IgniteException(e);\n                        }\n                    }\n                });\n            }\n\n            for (Thread th : threads)\n                th.start();\n\n            for (Thread th : threads)\n                th.join();\n\n            for (int i = 0; i < GRID_CNT * RETRIES; i++)\n                for (int ii = 0; ii < GRID_CNT; ii++)\n                    assertEquals(\"Got invalid value from cache [gridIdx=\" + ii + \", key=\" + i + ']',\n                        null, grid(ii).cache(null).get(Integer.toString(i)));\n\n            assertEquals(-GRID_CNT * RETRIES, grid(0).cache(null).localPeek(RMVD_CNTR_KEY, CachePeekMode.ONHEAP));\n        }\n        finally {\n            stopAllGrids();\n        }\n    }","commit_id":"dcf28350532d769337d5f186ce22cb3ab783f283","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Check whether result contains all required points.\n     *\n     * @param res Result.\n     * @param points Expected points.\n     */\n    private void checkPoints( Collection<Map.Entry<Integer, EnemyCamp>> res, String... points) {\n        Set<String> set = new HashSet<>(Arrays.asList(points));\n\n        assertEquals(set.size(), res.size());\n\n        for (Map.Entry<Integer, EnemyCamp> e : res)\n            assertTrue(set.remove(e.getValue().name));\n    }","id":6748,"modified_method":"/**\n     * Check whether result contains all required points.\n     *\n     * @param res Result.\n     * @param points Expected points.\n     */\n    private void checkPoints( Collection<Cache.Entry<Integer, EnemyCamp>> res, String... points) {\n        Set<String> set = new HashSet<>(Arrays.asList(points));\n\n        assertEquals(set.size(), res.size());\n\n        for (Cache.Entry<Integer, EnemyCamp> e : res)\n            assertTrue(set.remove(e.getValue().name));\n    }","commit_id":"b388252ee366fcb8d8b14f9f05d1b10bbcaa8067","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @throws Exception If failed.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public void testGeoMultithreaded() throws Exception {\n        final GridCacheAdapter<Integer, EnemyCamp> cache1 = ((IgniteKernal)grid(0)).internalCache(null);\n        final GridCacheAdapter<Integer, EnemyCamp> cache2 = ((IgniteKernal)grid(1)).internalCache(null);\n        final GridCacheAdapter<Integer, EnemyCamp> cache3 = ((IgniteKernal)grid(2)).internalCache(null);\n\n        final String[] points = new String[CNT];\n\n        WKTReader r = new WKTReader();\n\n        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n\n        for (int idx = 0; idx < CNT; idx++) {\n            int x = rnd.nextInt(1, 100);\n            int y = rnd.nextInt(1, 100);\n\n            cache1.getAndPut(idx, new EnemyCamp(r.read(\"POINT(\" + x + \" \" + y + \")\"), Integer.toString(idx)));\n\n            points[idx] = Integer.toString(idx);\n        }\n\n        Thread.sleep(200);\n\n        final AtomicBoolean stop = new AtomicBoolean();\n        final AtomicReference<Exception> err = new AtomicReference<>();\n\n        IgniteInternalFuture<?> putFut = GridTestUtils.runMultiThreadedAsync(new Callable<Void>() {\n            @Override public Void call() throws Exception {\n                WKTReader r = new WKTReader();\n\n                ThreadLocalRandom rnd = ThreadLocalRandom.current();\n\n                while (!stop.get()) {\n                    int cacheIdx = rnd.nextInt(0, 3);\n\n                    GridCacheAdapter<Integer, EnemyCamp> cache = cacheIdx == 0 ? cache1 : cacheIdx == 1 ? cache2 : cache3;\n\n                    int idx = rnd.nextInt(CNT);\n                    int x = rnd.nextInt(1, 100);\n                    int y = rnd.nextInt(1, 100);\n\n                    cache.getAndPut(idx, new EnemyCamp(r.read(\"POINT(\" + x + \" \" + y + \")\"), Integer.toString(idx)));\n\n                    U.sleep(50);\n                }\n\n                return null;\n            }\n        }, Runtime.getRuntime().availableProcessors(), \"put-thread\");\n\n        IgniteInternalFuture<?> qryFut = GridTestUtils.runMultiThreadedAsync(new Callable<Void>() {\n            @Override public Void call() throws Exception {\n                WKTReader r = new WKTReader();\n\n                ThreadLocalRandom rnd = ThreadLocalRandom.current();\n\n                while (!stop.get()) {\n                    try {\n                        int cacheIdx = rnd.nextInt(0, 3);\n\n                        GridCacheAdapter<Integer, EnemyCamp> cache = cacheIdx == 0 ? cache1 : cacheIdx == 1 ? cache2 : cache3;\n\n                        CacheQuery<Map.Entry<Integer, EnemyCamp>> qry = cache.queries().createSqlQuery(\n                            EnemyCamp.class, \"coords && ?\");\n\n                        Collection<Map.Entry<Integer, EnemyCamp>> res = qry.execute(\n                            r.read(\"POLYGON((0 0, 0 100, 100 100, 100 0, 0 0))\")).get();\n\n                        checkPoints(res, points);\n\n                        U.sleep(5);\n                    }\n                    catch (Exception e) {\n                        err.set(e);\n\n                        stop.set(true);\n\n                        break;\n                    }\n                }\n\n                return null;\n            }\n        }, 4, \"qry-thread\");\n\n        U.sleep(60000L);\n\n        stop.set(true);\n\n        putFut.get();\n        qryFut.get();\n\n        Exception err0 = err.get();\n\n        if (err0 != null)\n            throw err0;\n    }","id":6749,"modified_method":"/**\n     * @throws Exception If failed.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public void testGeoMultithreaded() throws Exception {\n        final IgniteCache<Integer, EnemyCamp> cache1 = grid(0).cache(null);\n        final IgniteCache<Integer, EnemyCamp> cache2 = grid(1).cache(null);\n        final IgniteCache<Integer, EnemyCamp> cache3 = grid(2).cache(null);\n\n        final String[] points = new String[CNT];\n\n        WKTReader r = new WKTReader();\n\n        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n\n        for (int idx = 0; idx < CNT; idx++) {\n            int x = rnd.nextInt(1, 100);\n            int y = rnd.nextInt(1, 100);\n\n            cache1.getAndPut(idx, new EnemyCamp(r.read(\"POINT(\" + x + \" \" + y + \")\"), Integer.toString(idx)));\n\n            points[idx] = Integer.toString(idx);\n        }\n\n        Thread.sleep(200);\n\n        final AtomicBoolean stop = new AtomicBoolean();\n        final AtomicReference<Exception> err = new AtomicReference<>();\n\n        IgniteInternalFuture<?> putFut = GridTestUtils.runMultiThreadedAsync(new Callable<Void>() {\n            @Override public Void call() throws Exception {\n                WKTReader r = new WKTReader();\n\n                ThreadLocalRandom rnd = ThreadLocalRandom.current();\n\n                while (!stop.get()) {\n                    int cacheIdx = rnd.nextInt(0, 3);\n\n                    IgniteCache<Integer, EnemyCamp> cache = cacheIdx == 0 ? cache1 : cacheIdx == 1 ? cache2 : cache3;\n\n                    int idx = rnd.nextInt(CNT);\n                    int x = rnd.nextInt(1, 100);\n                    int y = rnd.nextInt(1, 100);\n\n                    cache.getAndPut(idx, new EnemyCamp(r.read(\"POINT(\" + x + \" \" + y + \")\"), Integer.toString(idx)));\n\n                    U.sleep(50);\n                }\n\n                return null;\n            }\n        }, Runtime.getRuntime().availableProcessors(), \"put-thread\");\n\n        IgniteInternalFuture<?> qryFut = GridTestUtils.runMultiThreadedAsync(new Callable<Void>() {\n            @Override public Void call() throws Exception {\n                WKTReader r = new WKTReader();\n\n                ThreadLocalRandom rnd = ThreadLocalRandom.current();\n\n                while (!stop.get()) {\n                    try {\n                        int cacheIdx = rnd.nextInt(0, 3);\n\n                        IgniteCache<Integer, EnemyCamp> cache = cacheIdx == 0 ? cache1 : cacheIdx == 1 ? cache2 : cache3;\n\n                        SqlQuery<Integer, EnemyCamp> qry = new SqlQuery<>(\n                            EnemyCamp.class, \"coords && ?\");\n\n                        Collection<Cache.Entry<Integer, EnemyCamp>> res = cache.query(qry.setArgs(\n                            r.read(\"POLYGON((0 0, 0 100, 100 100, 100 0, 0 0))\"))).getAll();\n\n                        checkPoints(res, points);\n\n                        U.sleep(5);\n                    }\n                    catch (Exception e) {\n                        err.set(e);\n\n                        stop.set(true);\n\n                        break;\n                    }\n                }\n\n                return null;\n            }\n        }, 4, \"qry-thread\");\n\n        U.sleep(60000L);\n\n        stop.set(true);\n\n        putFut.get();\n        qryFut.get();\n\n        Exception err0 = err.get();\n\n        if (err0 != null)\n            throw err0;\n    }","commit_id":"b388252ee366fcb8d8b14f9f05d1b10bbcaa8067","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @throws Exception If failed.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public void testGeo() throws Exception {\n        GridCacheAdapter<Integer, EnemyCamp> cache = ((IgniteKernal)grid(0)).internalCache(null);\n\n        WKTReader r = new WKTReader();\n\n        cache.getAndPut(0, new EnemyCamp(r.read(\"POINT(25 75)\"), \"A\"));\n        cache.getAndPut(1, new EnemyCamp(r.read(\"POINT(70 70)\"), \"B\"));\n        cache.getAndPut(2, new EnemyCamp(r.read(\"POINT(70 30)\"), \"C\"));\n        cache.getAndPut(3, new EnemyCamp(r.read(\"POINT(75 25)\"), \"D\"));\n\n        CacheQuery<Map.Entry<Integer, EnemyCamp>> qry = cache.queries().createSqlQuery(EnemyCamp.class,\n            \"coords && ?\");\n\n        Collection<Map.Entry<Integer, EnemyCamp>> res = qry.execute(r.read(\"POLYGON((5 70, 5 80, 30 80, 30 70, 5 70))\"))\n            .get();\n\n        checkPoints(res, \"A\");\n\n        res = qry.execute(r.read(\"POLYGON((10 5, 10 35, 70 30, 75 25, 10 5))\")).get();\n\n        checkPoints(res, \"C\", \"D\");\n\n        // Move B to the first polygon.\n        cache.getAndPut(1, new EnemyCamp(r.read(\"POINT(20 75)\"), \"B\"));\n\n        res = qry.execute(r.read(\"POLYGON((5 70, 5 80, 30 80, 30 70, 5 70))\")).get();\n\n        checkPoints(res, \"A\", \"B\");\n\n        // Move B to the second polygon.\n        cache.getAndPut(1, new EnemyCamp(r.read(\"POINT(30 30)\"), \"B\"));\n\n        res = qry.execute(r.read(\"POLYGON((10 5, 10 35, 70 30, 75 25, 10 5))\")).get();\n\n        checkPoints(res, \"B\", \"C\", \"D\");\n\n        // Remove B.\n        cache.getAndRemove(1);\n\n        res = qry.execute(r.read(\"POLYGON((5 70, 5 80, 30 80, 30 70, 5 70))\")).get();\n\n        checkPoints(res, \"A\");\n\n        res = qry.execute(r.read(\"POLYGON((10 5, 10 35, 70 30, 75 25, 10 5))\")).get();\n\n        checkPoints(res, \"C\", \"D\");\n\n        // Check explaint request.\n        assertTrue(F.first(cache.queries().createSqlFieldsQuery(\"explain select * from EnemyCamp \" +\n            \"where coords && 'POINT(25 75)'\").execute().get()).get(0).toString().contains(\"coords_idx\"));\n    }","id":6750,"modified_method":"/**\n     * @throws Exception If failed.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public void testGeo() throws Exception {\n        IgniteCache<Integer, EnemyCamp> cache = grid(0).cache(null);\n\n        WKTReader r = new WKTReader();\n\n        cache.getAndPut(0, new EnemyCamp(r.read(\"POINT(25 75)\"), \"A\"));\n        cache.getAndPut(1, new EnemyCamp(r.read(\"POINT(70 70)\"), \"B\"));\n        cache.getAndPut(2, new EnemyCamp(r.read(\"POINT(70 30)\"), \"C\"));\n        cache.getAndPut(3, new EnemyCamp(r.read(\"POINT(75 25)\"), \"D\"));\n\n        SqlQuery<Integer, EnemyCamp> qry = new SqlQuery(EnemyCamp.class, \"coords && ?\");\n\n        Collection<Cache.Entry<Integer, EnemyCamp>> res = cache.query(\n            qry.setArgs(r.read(\"POLYGON((5 70, 5 80, 30 80, 30 70, 5 70))\"))).getAll();\n\n        checkPoints(res, \"A\");\n\n        res = cache.query(\n            qry.setArgs(r.read(\"POLYGON((10 5, 10 35, 70 30, 75 25, 10 5))\"))).getAll();\n\n        checkPoints(res, \"C\", \"D\");\n\n        // Move B to the first polygon.\n        cache.getAndPut(1, new EnemyCamp(r.read(\"POINT(20 75)\"), \"B\"));\n\n        res = cache.query(\n            qry.setArgs(r.read(\"POLYGON((5 70, 5 80, 30 80, 30 70, 5 70))\"))).getAll();\n\n        checkPoints(res, \"A\", \"B\");\n\n        // Move B to the second polygon.\n        cache.getAndPut(1, new EnemyCamp(r.read(\"POINT(30 30)\"), \"B\"));\n\n        res = cache.query(\n            qry.setArgs(r.read(\"POLYGON((10 5, 10 35, 70 30, 75 25, 10 5))\"))).getAll();\n\n        checkPoints(res, \"B\", \"C\", \"D\");\n\n        // Remove B.\n        cache.getAndRemove(1);\n\n        res = cache.query(\n            qry.setArgs(r.read(\"POLYGON((5 70, 5 80, 30 80, 30 70, 5 70))\"))).getAll();\n\n        checkPoints(res, \"A\");\n\n        res = cache.query(\n            qry.setArgs(r.read(\"POLYGON((10 5, 10 35, 70 30, 75 25, 10 5))\"))).getAll();\n\n        checkPoints(res, \"C\", \"D\");\n\n        // Check explaint request.\n        assertTrue(F.first(cache.query(new SqlFieldsQuery(\"explain select * from EnemyCamp \" +\n            \"where coords && 'POINT(25 75)'\")).getAll()).get(0).toString().contains(\"coords_idx\"));\n    }","commit_id":"b388252ee366fcb8d8b14f9f05d1b10bbcaa8067","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Get the value to use for the ds-label from this threshold\n     */\n    private String getDataSourceLabel(File directory, SnmpThresholdNetworkInterface snmpIface, ThresholdEntity threshold) {\n        String dsLabelValue = null;\n        \n        try {\n            dsLabelValue = ResourceTypeUtils.getStringProperty(directory, threshold.getDatasourceLabel());\n        } catch (DataAccessException e) {\n            if (log().isDebugEnabled()) {\n                log().debug (\"getDataSourceLabel: I/O exception when looking for strings.properties file for node id: \" + snmpIface.getNodeId() + \" looking here: \" + directory + \": \" + e, e);\n            }\n        }\n        \n        return (dsLabelValue == null ? \"Unknown\" : dsLabelValue);\n\n    }","id":6751,"modified_method":"/**\n     * Get the value to use for the ds-label from this threshold\n     */\n    private String getDataSourceLabel(File directory, SnmpThresholdNetworkInterface snmpIface, ThresholdEntity threshold) {\n        String dsLabelValue = null;\n        \n        try {\n            String key = threshold.getDatasourceLabel();\n            dsLabelValue = (key == null ? null : ResourceTypeUtils.getStringProperty(directory, key));\n        } catch (DataAccessException e) {\n            if (log().isDebugEnabled()) {\n                log().debug (\"getDataSourceLabel: I/O exception when looking for strings.properties file for node id: \" + snmpIface.getNodeId() + \" looking here: \" + directory + \": \" + e, e);\n            }\n        }\n        \n        return (dsLabelValue == null ? \"Unknown\" : dsLabelValue);\n\n    }","commit_id":"4927f7c5d0dd87dc91fb6fb522e0f5cf068c2946","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get the value to use for the ds-label from this threshold\n     */\n    private String getDataSourceLabel(File directory, SnmpThresholdNetworkInterface snmpIface, ThresholdEntity threshold) {\n        String dsLabelValue = null;\n        \n        try {\n            dsLabelValue = ResourceTypeUtils.getStringProperty(directory, threshold.getDatasourceLabel());\n        } catch (DataAccessException e) {\n            if (log().isDebugEnabled()) {\n                log().debug (\"getDataSourceLabel: I/O exception when looking for strings.properties file for node id: \" + snmpIface.getNodeId() + \" looking here: \" + directory + \": \" + e, e);\n            }\n        }\n        \n        return (dsLabelValue == null ? \"Unknown\" : dsLabelValue);\n\n    }","id":6752,"modified_method":"/**\n     * Get the value to use for the ds-label from this threshold\n     */\n    private String getDataSourceLabel(File directory, SnmpThresholdNetworkInterface snmpIface, ThresholdEntity threshold) {\n        String dsLabelValue = null;\n        \n        try {\n            String key = threshold.getDatasourceLabel();\n            dsLabelValue = (key == null ? null : ResourceTypeUtils.getStringProperty(directory, key));\n        } catch (DataAccessException e) {\n            if (log().isDebugEnabled()) {\n                log().debug (\"getDataSourceLabel: I/O exception when looking for strings.properties file for node id: \" + snmpIface.getNodeId() + \" looking here: \" + directory + \": \" + e, e);\n            }\n        }\n        \n        return (dsLabelValue == null ? \"Unknown\" : dsLabelValue);\n\n    }","commit_id":"3987d793ca1d12c2799fa43848eec274e4c0ef9b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get the value to use for the ds-label from this threshold\n     */\n    private String getDataSourceLabel(File directory, SnmpThresholdNetworkInterface snmpIface, ThresholdEntity threshold) {\n        String dsLabelValue = null;\n        \n        try {\n            dsLabelValue = ResourceTypeUtils.getStringProperty(directory, threshold.getDatasourceLabel());\n        } catch (DataAccessException e) {\n            if (log().isDebugEnabled()) {\n                log().debug (\"getDataSourceLabel: I/O exception when looking for strings.properties file for node id: \" + snmpIface.getNodeId() + \" looking here: \" + directory + \": \" + e, e);\n            }\n        }\n        \n        return (dsLabelValue == null ? \"Unknown\" : dsLabelValue);\n\n    }","id":6753,"modified_method":"/**\n     * Get the value to use for the ds-label from this threshold\n     */\n    private String getDataSourceLabel(File directory, SnmpThresholdNetworkInterface snmpIface, ThresholdEntity threshold) {\n        String dsLabelValue = null;\n        \n        try {\n            String key = threshold.getDatasourceLabel();\n            dsLabelValue = (key == null ? null : ResourceTypeUtils.getStringProperty(directory, key));\n        } catch (DataAccessException e) {\n            if (log().isDebugEnabled()) {\n                log().debug (\"getDataSourceLabel: I/O exception when looking for strings.properties file for node id: \" + snmpIface.getNodeId() + \" looking here: \" + directory + \": \" + e, e);\n            }\n        }\n        \n        return (dsLabelValue == null ? \"Unknown\" : dsLabelValue);\n\n    }","commit_id":"a7ed0a04b6abf82eee23b19335363ba91eecd546","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void writeTo(DataOutputStream out) throws IOException {\n\t\t\tif (dropMessagesAddressList != null && !dropMessagesAddressList.isEmpty()) {\n\t\t\t\tout.writeShort(dropMessagesAddressList.size());\n\t\t\t\tfor (Iterator iter = dropMessagesAddressList.iterator(); iter\n\t\t\t\t\t\t.hasNext();) {\n\t\t\t\t\tAddress address = (Address) iter.next();\n\t\t\t\t\tUtil.writeAddress(address, out);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tout.writeShort(0);\n\t\t\t}\n\n\t\t}","id":6754,"modified_method":"public void writeTo(DataOutputStream out) throws IOException {\n\t\t\tif (dropMessages != null && !dropMessages.isEmpty()) {\n\t\t\t\tout.writeShort(dropMessages.size());\n\t\t\t\tfor (Address addr: dropMessages) {\n\t\t\t\t\tUtil.writeAddress(addr, out);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tout.writeShort(0);\n\t\t\t}\n\n\t\t}","commit_id":"d12d12a3b688b8593df5e94531509a9be9d103bf","url":"https://github.com/belaban/JGroups"},{"original_method":"public DiscardHeader(List<Address> ignoredAddresses) {\n\t\t\tsuper();\n\t\t\tthis.dropMessagesAddressList = ignoredAddresses;\n\t\t}","id":6755,"modified_method":"public DiscardHeader(Set<Address> ignoredAddresses) {\n\t\t\tsuper();\n\t\t\tthis.dropMessages= ignoredAddresses;\n\t\t}","commit_id":"d12d12a3b688b8593df5e94531509a9be9d103bf","url":"https://github.com/belaban/JGroups"},{"original_method":"public void readFrom(DataInputStream in) throws IOException,\n\t\t\t\tIllegalAccessException, InstantiationException {\n\t\t\tint size = in.readShort();\n\t\t\tif (size > 0) {\n\t\t\t\tdropMessagesAddressList.clear();\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\tdropMessagesAddressList.add(Util.readAddress(in));\n\t\t\t\t}\n\t\t\t}\n\t\t}","id":6756,"modified_method":"public void readFrom(DataInputStream in) throws IOException, IllegalAccessException, InstantiationException {\n\t\t\tint size = in.readShort();\n\t\t\tif (size > 0) {\n\t\t\t\tdropMessages.clear();\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\tdropMessages.add(Util.readAddress(in));\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"d12d12a3b688b8593df5e94531509a9be9d103bf","url":"https://github.com/belaban/JGroups"},{"original_method":"public DiscardHeader() {\n\t\t\tthis.dropMessagesAddressList = new ArrayList<Address>();\t\t\t\n\t\t}","id":6757,"modified_method":"public DiscardHeader() {\n\t\t\tthis.dropMessages= new HashSet<Address>();\n\t\t}","commit_id":"d12d12a3b688b8593df5e94531509a9be9d103bf","url":"https://github.com/belaban/JGroups"},{"original_method":"public void writeExternal(ObjectOutput out) throws IOException {\n\t\t\tout.writeObject(dropMessagesAddressList);\n\t\t}","id":6758,"modified_method":"public void writeExternal(ObjectOutput out) throws IOException {\n\t\t\tout.writeObject(dropMessages);\n\t\t}","commit_id":"d12d12a3b688b8593df5e94531509a9be9d103bf","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt) {\n        Message msg;\n        double r;\n\n        if(evt.getType() == Event.SET_LOCAL_ADDRESS)\n            localAddress=(Address)evt.getArg();\n\n\n        if(evt.getType() == Event.MSG) {\n            msg=(Message)evt.getArg();\n            DiscardHeader dh = (DiscardHeader) msg.getHeader(getName());\n\t\t\tif (dh != null) {\n\t\t\t\tignoredMembers.clear();\n\t\t\t\tignoredMembers.addAll(dh.dropMessagesAddressList);\n\t\t\t\tif (log.isTraceEnabled())\n\t\t\t\t\tlog.trace(\"will potentially drop messages from \" + ignoredMembers);\n\t\t\t} else {\n\t\t\t\tif (up > 0) {\n\t\t\t\t\tr = Math.random();\n\t\t\t\t\tif (r < up) {\n\t\t\t\t\t\tif (excludeItself && msg.getSrc().equals(localAddress)) {\n\t\t\t\t\t\t\tif (log.isTraceEnabled())\n\t\t\t\t\t\t\t\tlog.trace(\"excluding itself\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tboolean dropMessage = ignoredMembers.isEmpty() || \n\t\t\t\t\t\t\t\t\t\t\t\t(!ignoredMembers.isEmpty() && ignoredMembers.contains(msg.getSrc()));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (dropMessage) {\n\t\t\t\t\t\t\t\tif (log.isTraceEnabled())\n\t\t\t\t\t\t\t\t\tlog.trace(\"dropping message from \" + msg.getSrc());\n\t\t\t\t\t\t\t\tnum_up++;\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n        }\n\n        return up_prot.up(evt);\n    }","id":6759,"modified_method":"public Object up(Event evt) {\n        Message msg;\n        double r;\n\n        if(evt.getType() == Event.SET_LOCAL_ADDRESS)\n            localAddress=(Address)evt.getArg();\n\n\n        if(evt.getType() == Event.MSG) {\n            msg=(Message)evt.getArg();\n            Address sender=msg.getSrc();\n            DiscardHeader dh = (DiscardHeader) msg.getHeader(getName());\n\t\t\tif (dh != null) {\n\t\t\t\tignoredMembers.clear();\n\t\t\t\tignoredMembers.addAll(dh.dropMessages);\n\t\t\t\tif (log.isTraceEnabled())\n\t\t\t\t\tlog.trace(\"will potentially drop messages from \" + ignoredMembers);\n\t\t\t} else {\n                boolean dropMessage=ignoredMembers.contains(sender);\n                if (dropMessage) {\n                    if (log.isTraceEnabled())\n                        log.trace(\"dropping message from \" + sender);\n                    num_up++;\n                    return null;\n                }\n\n                if (up > 0) {\n\t\t\t\t\tr = Math.random();\n\t\t\t\t\tif (r < up) {\n\t\t\t\t\t\tif (excludeItself && sender.equals(localAddress)) {\n\t\t\t\t\t\t\tif (log.isTraceEnabled())\n\t\t\t\t\t\t\t\tlog.trace(\"excluding itself\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdropMessage = ignoredMembers.contains(sender);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (dropMessage) {\n\t\t\t\t\t\t\t\tif (log.isTraceEnabled())\n\t\t\t\t\t\t\t\t\tlog.trace(\"dropping message from \" + sender);\n\t\t\t\t\t\t\t\tnum_up++;\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n        }\n\n        return up_prot.up(evt);\n    }","commit_id":"d12d12a3b688b8593df5e94531509a9be9d103bf","url":"https://github.com/belaban/JGroups"},{"original_method":"@SuppressWarnings(\"unchecked\")\n\t\tpublic void readExternal(ObjectInput in) throws IOException,\n\t\t\t\tClassNotFoundException {\n\t\t\tList tmp = (List) in.readObject();\n\t\t\tdropMessagesAddressList.clear();\n\t\t\tdropMessagesAddressList.addAll(tmp);\n\n\t\t}","id":6760,"modified_method":"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n\t\t\tSet tmp = (Set) in.readObject();\n\t\t\tdropMessages.clear();\n\t\t\tdropMessages.addAll(tmp);\n\t\t}","commit_id":"d12d12a3b688b8593df5e94531509a9be9d103bf","url":"https://github.com/belaban/JGroups"},{"original_method":"public FlushHeader(byte type,long viewID,Collection<Address> flushView){\n            this.type = type;\n            this.viewID = viewID;\n            this.flushParticipants = flushView;\n        }","id":6761,"modified_method":"public FlushHeader(byte type,long viewID,Collection<Address> flushView){\n            this.type = type;\n            this.viewID = viewID;\n            if(flushView != null){\n                this.flushParticipants = new ArrayList<Address>(flushView);\n            }\n        }","commit_id":"faf2425ec1e91b52f478dd9faf8d8547af69d8a1","url":"https://github.com/belaban/JGroups"},{"original_method":"public void writeTo(DataOutputStream out) throws IOException {\n            out.writeByte(type);\n            out.writeLong(viewID);\n            if(flushParticipants != null && !flushParticipants.isEmpty()){\n                out.writeShort(flushParticipants.size());\n                for(Iterator<Address> iter = flushParticipants.iterator();iter.hasNext();){\n                    Address address = iter.next();\n                    Util.writeAddress(address, out);\n                }\n            }else{\n                out.writeShort(0);\n            }\n            if(digest != null){\n                out.writeBoolean(true);\n                Util.writeStreamable(digest, out);\n            }else{\n                out.writeBoolean(false);\n            }\n        }","id":6762,"modified_method":"public void writeTo(DataOutputStream out) throws IOException {\n            out.writeByte(type);\n            out.writeLong(viewID);\n            if(flushParticipants != null && !flushParticipants.isEmpty()){\n                out.writeShort(flushParticipants.size());\n                for (Address participant : flushParticipants) {\n                    Util.writeAddress(participant, out);    \n                }                       \n            }else{\n                out.writeShort(0);\n            }\n            if(digest != null){\n                out.writeBoolean(true);\n                Util.writeStreamable(digest, out);\n            }else{\n                out.writeBoolean(false);\n            }\n        }","commit_id":"faf2425ec1e91b52f478dd9faf8d8547af69d8a1","url":"https://github.com/belaban/JGroups"},{"original_method":"public void writeTo(DataOutputStream out) throws IOException {\n\t\t\tif (dropMessagesAddressList != null && !dropMessagesAddressList.isEmpty()) {\n\t\t\t\tout.writeShort(dropMessagesAddressList.size());\n\t\t\t\tfor (Iterator iter = dropMessagesAddressList.iterator(); iter\n\t\t\t\t\t\t.hasNext();) {\n\t\t\t\t\tAddress address = (Address) iter.next();\n\t\t\t\t\tUtil.writeAddress(address, out);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tout.writeShort(0);\n\t\t\t}\n\n\t\t}","id":6763,"modified_method":"public void writeTo(DataOutputStream out) throws IOException {\n\t\t\tif (dropMessages != null && !dropMessages.isEmpty()) {\n\t\t\t\tout.writeShort(dropMessages.size());\n\t\t\t\tfor (Address addr: dropMessages) {\n\t\t\t\t\tUtil.writeAddress(addr, out);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tout.writeShort(0);\n\t\t\t}\n\n\t\t}","commit_id":"ff56a916c47a8bcaa0669ab09cdacb77ab3c49e8","url":"https://github.com/belaban/JGroups"},{"original_method":"public void readFrom(DataInputStream in) throws IOException,\n\t\t\t\tIllegalAccessException, InstantiationException {\n\t\t\tint size = in.readShort();\n\t\t\tif (size > 0) {\n\t\t\t\tdropMessagesAddressList.clear();\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\tdropMessagesAddressList.add(Util.readAddress(in));\n\t\t\t\t}\n\t\t\t}\n\t\t}","id":6764,"modified_method":"public void readFrom(DataInputStream in) throws IOException, IllegalAccessException, InstantiationException {\n\t\t\tint size = in.readShort();\n\t\t\tif (size > 0) {\n\t\t\t\tdropMessages.clear();\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\tdropMessages.add(Util.readAddress(in));\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"ff56a916c47a8bcaa0669ab09cdacb77ab3c49e8","url":"https://github.com/belaban/JGroups"},{"original_method":"public void writeExternal(ObjectOutput out) throws IOException {\n\t\t\tout.writeObject(dropMessagesAddressList);\n\t\t}","id":6765,"modified_method":"public void writeExternal(ObjectOutput out) throws IOException {\n\t\t\tout.writeObject(dropMessages);\n\t\t}","commit_id":"ff56a916c47a8bcaa0669ab09cdacb77ab3c49e8","url":"https://github.com/belaban/JGroups"},{"original_method":"public DiscardHeader() {\n\t\t\tthis.dropMessagesAddressList = new ArrayList<Address>();\t\t\t\n\t\t}","id":6766,"modified_method":"public DiscardHeader() {\n\t\t\tthis.dropMessages= new HashSet<Address>();\n\t\t}","commit_id":"ff56a916c47a8bcaa0669ab09cdacb77ab3c49e8","url":"https://github.com/belaban/JGroups"},{"original_method":"public DiscardHeader(List<Address> ignoredAddresses) {\n\t\t\tsuper();\n\t\t\tthis.dropMessagesAddressList = ignoredAddresses;\n\t\t}","id":6767,"modified_method":"public DiscardHeader(Set<Address> ignoredAddresses) {\n\t\t\tsuper();\n\t\t\tthis.dropMessages= ignoredAddresses;\n\t\t}","commit_id":"ff56a916c47a8bcaa0669ab09cdacb77ab3c49e8","url":"https://github.com/belaban/JGroups"},{"original_method":"@SuppressWarnings(\"unchecked\")\n\t\tpublic void readExternal(ObjectInput in) throws IOException,\n\t\t\t\tClassNotFoundException {\n\t\t\tList tmp = (List) in.readObject();\n\t\t\tdropMessagesAddressList.clear();\n\t\t\tdropMessagesAddressList.addAll(tmp);\n\n\t\t}","id":6768,"modified_method":"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n\t\t\tSet tmp = (Set) in.readObject();\n\t\t\tdropMessages.clear();\n\t\t\tdropMessages.addAll(tmp);\n\t\t}","commit_id":"ff56a916c47a8bcaa0669ab09cdacb77ab3c49e8","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt) {\n        Message msg;\n        double r;\n\n        if(evt.getType() == Event.SET_LOCAL_ADDRESS)\n            localAddress=(Address)evt.getArg();\n\n\n        if(evt.getType() == Event.MSG) {\n            msg=(Message)evt.getArg();\n            DiscardHeader dh = (DiscardHeader) msg.getHeader(getName());\n\t\t\tif (dh != null) {\n\t\t\t\tignoredMembers.clear();\n\t\t\t\tignoredMembers.addAll(dh.dropMessagesAddressList);\n\t\t\t\tif (log.isTraceEnabled())\n\t\t\t\t\tlog.trace(\"will potentially drop messages from \" + ignoredMembers);\n\t\t\t} else {\n\t\t\t\tif (up > 0) {\n\t\t\t\t\tr = Math.random();\n\t\t\t\t\tif (r < up) {\n\t\t\t\t\t\tif (excludeItself && msg.getSrc().equals(localAddress)) {\n\t\t\t\t\t\t\tif (log.isTraceEnabled())\n\t\t\t\t\t\t\t\tlog.trace(\"excluding itself\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tboolean dropMessage = ignoredMembers.isEmpty() || \n\t\t\t\t\t\t\t\t\t\t\t\t(!ignoredMembers.isEmpty() && ignoredMembers.contains(msg.getSrc()));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (dropMessage) {\n\t\t\t\t\t\t\t\tif (log.isTraceEnabled())\n\t\t\t\t\t\t\t\t\tlog.trace(\"dropping message from \" + msg.getSrc());\n\t\t\t\t\t\t\t\tnum_up++;\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n        }\n\n        return up_prot.up(evt);\n    }","id":6769,"modified_method":"public Object up(Event evt) {\n        Message msg;\n        double r;\n\n        if(evt.getType() == Event.SET_LOCAL_ADDRESS)\n            localAddress=(Address)evt.getArg();\n\n\n        if(evt.getType() == Event.MSG) {\n            msg=(Message)evt.getArg();\n            Address sender=msg.getSrc();\n            DiscardHeader dh = (DiscardHeader) msg.getHeader(getName());\n\t\t\tif (dh != null) {\n\t\t\t\tignoredMembers.clear();\n\t\t\t\tignoredMembers.addAll(dh.dropMessages);\n\t\t\t\tif (log.isTraceEnabled())\n\t\t\t\t\tlog.trace(\"will potentially drop messages from \" + ignoredMembers);\n\t\t\t} else {\n                boolean dropMessage=ignoredMembers.contains(sender);\n                if (dropMessage) {\n                    if (log.isTraceEnabled())\n                        log.trace(\"dropping message from \" + sender);\n                    num_up++;\n                    return null;\n                }\n\n                if (up > 0) {\n\t\t\t\t\tr = Math.random();\n\t\t\t\t\tif (r < up) {\n\t\t\t\t\t\tif (excludeItself && sender.equals(localAddress)) {\n\t\t\t\t\t\t\tif (log.isTraceEnabled())\n\t\t\t\t\t\t\t\tlog.trace(\"excluding itself\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdropMessage = ignoredMembers.contains(sender);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (dropMessage) {\n\t\t\t\t\t\t\t\tif (log.isTraceEnabled())\n\t\t\t\t\t\t\t\t\tlog.trace(\"dropping message from \" + sender);\n\t\t\t\t\t\t\t\tnum_up++;\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n        }\n\n        return up_prot.up(evt);\n    }","commit_id":"ff56a916c47a8bcaa0669ab09cdacb77ab3c49e8","url":"https://github.com/belaban/JGroups"},{"original_method":"public FlushHeader(byte type,long viewID,Collection<Address> flushView){\n            this.type = type;\n            this.viewID = viewID;\n            this.flushParticipants = flushView;\n        }","id":6770,"modified_method":"public FlushHeader(byte type,long viewID,Collection<Address> flushView){\n            this.type = type;\n            this.viewID = viewID;\n            if(flushView != null){\n                this.flushParticipants = new ArrayList<Address>(flushView);\n            }\n        }","commit_id":"f98e2cdc7e33b0a2981cf3a60d4ecf1cea74ef0a","url":"https://github.com/belaban/JGroups"},{"original_method":"public void writeTo(DataOutputStream out) throws IOException {\n            out.writeByte(type);\n            out.writeLong(viewID);\n            if(flushParticipants != null && !flushParticipants.isEmpty()){\n                out.writeShort(flushParticipants.size());\n                for(Iterator<Address> iter = flushParticipants.iterator();iter.hasNext();){\n                    Address address = iter.next();\n                    Util.writeAddress(address, out);\n                }\n            }else{\n                out.writeShort(0);\n            }\n            if(digest != null){\n                out.writeBoolean(true);\n                Util.writeStreamable(digest, out);\n            }else{\n                out.writeBoolean(false);\n            }\n        }","id":6771,"modified_method":"public void writeTo(DataOutputStream out) throws IOException {\n            out.writeByte(type);\n            out.writeLong(viewID);\n            if(flushParticipants != null && !flushParticipants.isEmpty()){\n                out.writeShort(flushParticipants.size());\n                for (Address participant : flushParticipants) {\n                    Util.writeAddress(participant, out);    \n                }                       \n            }else{\n                out.writeShort(0);\n            }\n            if(digest != null){\n                out.writeBoolean(true);\n                Util.writeStreamable(digest, out);\n            }else{\n                out.writeBoolean(false);\n            }\n        }","commit_id":"f98e2cdc7e33b0a2981cf3a60d4ecf1cea74ef0a","url":"https://github.com/belaban/JGroups"},{"original_method":"@Override\n        public void propertyAdded(PropertyState after) {\n            if (!stopping && filterRef.get().include(PROPERTY_ADDED, afterTree)) {\n                events.add(createEvent(PROPERTY_ADDED, afterTree, after));\n            }\n        }","id":6772,"modified_method":"@Override\n        public void propertyAdded(PropertyState after) {\n            if (filterRef.get().include(PROPERTY_ADDED, afterTree)) {\n                events.add(createEvent(PROPERTY_ADDED, afterTree, after));\n            }\n        }","commit_id":"0b2a85c47cd21c8c90579bf762c4446076d318b5","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n        public Validator childNodeAdded(String name, NodeState after) {\n            if (stopping) {\n                return null;\n            }\n            EventFilter eventFilter = filterRef.get();\n            if (eventFilter.include(NODE_ADDED, afterTree)) {\n                events.add(createEvent(NODE_ADDED, afterTree.getChild(name)));\n            }\n            return createChildValidator(eventFilter, afterTree.getPath(), name);\n        }","id":6773,"modified_method":"@Override\n        public Validator childNodeAdded(String name, NodeState after) {\n            EventFilter eventFilter = filterRef.get();\n            if (eventFilter.include(NODE_ADDED, afterTree)) {\n                events.add(createEvent(NODE_ADDED, afterTree.getChild(name)));\n            }\n            if (eventFilter.includeChildren(afterTree.getPath())) {\n                childEvents.add(new EventGeneratingValidator(this, name));\n            }\n            return null;\n        }","commit_id":"0b2a85c47cd21c8c90579bf762c4446076d318b5","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n        public void propertyChanged(PropertyState before, PropertyState after) {\n            if (!stopping && filterRef.get().include(Event.PROPERTY_CHANGED, afterTree)) {\n                events.add(createEvent(Event.PROPERTY_CHANGED, afterTree, after));\n            }\n        }","id":6774,"modified_method":"@Override\n        public void propertyChanged(PropertyState before, PropertyState after) {\n            if (filterRef.get().include(Event.PROPERTY_CHANGED, afterTree)) {\n                events.add(createEvent(Event.PROPERTY_CHANGED, afterTree, after));\n            }\n        }","commit_id":"0b2a85c47cd21c8c90579bf762c4446076d318b5","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n        public void leave(NodeState before, NodeState after) throws CommitFailedException {\n            // TODO instead of putting events in a list generate them on demand\n            // on calls to iterator.next()\n            if (isRoot || events.size() > EVENT_LIMIT) {\n                Iterator<Event> eventIterator = newArrayList(events.iterator()).iterator();\n                events.clear();\n                if (eventIterator.hasNext()) {\n                    try {\n                        listener.onEvent(new EventIteratorAdapter(eventIterator) {\n                            @Override\n                            public boolean hasNext() {\n                                return !stopping && super.hasNext();\n                            }\n                        });\n                    }\n                    catch (Exception e) {\n                        log.warn(\"Unhandled exception in observation listener: \" + listener, e);\n                    }\n                }\n            }\n        }","id":6775,"modified_method":"@Override\n        public void leave(NodeState before, NodeState after) throws CommitFailedException {\n        }","commit_id":"0b2a85c47cd21c8c90579bf762c4446076d318b5","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n        public Validator childNodeChanged(String name, NodeState before, NodeState after) {\n            if (stopping) {\n                return null;\n            }\n            return createChildValidator(filterRef.get(), afterTree.getPath(), name);\n        }","id":6776,"modified_method":"@Override\n        public Validator childNodeChanged(String name, NodeState before, NodeState after) {\n            if (filterRef.get().includeChildren(afterTree.getPath())) {\n                childEvents.add(new EventGeneratingValidator(this, name));\n            }\n            return null;\n        }","commit_id":"0b2a85c47cd21c8c90579bf762c4446076d318b5","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n        public void run() {\n            try {\n                ChangeSet changes = changeListener.getChanges(100);\n                while (!stopping) {\n                    EventFilter filter = filterRef.get();\n                    // FIXME don't rely on toString for session id\n                    if (changes != null &&\n                            !(filter.excludeLocal() && changes.isLocal(contentSession.toString()))) {\n                        String path = namePathMapper.getOakPath(filter.getPath());\n                        ImmutableTree beforeTree = getTree(changes.getBeforeState(), path);\n                        ImmutableTree afterTree = getTree(changes.getAfterState(), path);\n                        EventGeneratingValidator events = new EventGeneratingValidator(\n                                changes.getCommitInfo(), beforeTree, afterTree);\n                        VisibleValidator visibleEvents = new VisibleValidator(events, true, true);\n                        SecureValidator.compare(beforeTree, afterTree, visibleEvents);\n                    }\n                    changes = changeListener.getChanges(100);\n                }\n            } catch (Exception e) {\n                log.debug(\"Error while dispatching observation events\", e);\n            } finally {\n                mbean.unregister();\n                changeListener.dispose();\n            }\n        }","id":6777,"modified_method":"@Override\n        public void run() {\n            try {\n                ChangeSet changes = changeListener.getChanges(100);\n                while (!stopping) {\n                    EventFilter filter = filterRef.get();\n                    // FIXME don't rely on toString for session id\n                    if (changes != null &&\n                            !(filter.excludeLocal() && changes.isLocal(contentSession.toString()))) {\n                        String path = namePathMapper.getOakPath(filter.getPath());\n                        ImmutableTree beforeTree = getTree(changes.getBeforeState(), path);\n                        ImmutableTree afterTree = getTree(changes.getAfterState(), path);\n                        EventGeneratingValidator events = new EventGeneratingValidator(\n                                changes.getCommitInfo(), beforeTree, afterTree);\n                        if (events.hasNext()) {\n                            listener.onEvent(new EventIteratorAdapter(events));\n                        }\n                    }\n                    changes = changeListener.getChanges(100);\n                }\n            } catch (Exception e) {\n                log.debug(\"Error while dispatching observation events\", e);\n            } finally {\n                mbean.unregister();\n                changeListener.dispose();\n            }\n        }","commit_id":"0b2a85c47cd21c8c90579bf762c4446076d318b5","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"EventGeneratingValidator(CommitInfo info, Tree beforeTree, Tree afterTree) {\n            if (info != null) {\n                this.userId = info.getUserId();\n                this.message = info.getMessage();\n                this.timestamp = info.getDate();\n                this.external = false;\n            } else {\n                this.userId = CommitInfo.OAK_UNKNOWN;\n                this.message = null;\n                // we can't tell exactly when external changes were committed,\n                // so we just use a rough estimate like this\n                this.timestamp = System.currentTimeMillis();\n                this.external = true;\n            }\n            this.beforeTree = beforeTree;\n            this.afterTree = afterTree;\n            this.events = newArrayList();\n            isRoot = true;\n        }","id":6778,"modified_method":"EventGeneratingValidator(CommitInfo info, ImmutableTree beforeTree, ImmutableTree afterTree) {\n            if (info != null) {\n                this.userId = info.getUserId();\n                this.message = info.getMessage();\n                this.timestamp = info.getDate();\n                this.external = false;\n            } else {\n                this.userId = CommitInfo.OAK_UNKNOWN;\n                this.message = null;\n                // we can't tell exactly when external changes were committed,\n                // so we just use a rough estimate like this\n                this.timestamp = System.currentTimeMillis();\n                this.external = true;\n            }\n            this.beforeTree = beforeTree;\n            this.afterTree = afterTree;\n        }","commit_id":"0b2a85c47cd21c8c90579bf762c4446076d318b5","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n        public Validator childNodeDeleted(String name, NodeState before) {\n            if (stopping) {\n                return null;\n            }\n            EventFilter eventFilter = filterRef.get();\n            if (eventFilter.include(NODE_REMOVED, beforeTree)) {\n                events.add(createEvent(NODE_REMOVED, beforeTree.getChild(name)));\n            }\n            return createChildValidator(eventFilter, beforeTree.getPath(), name);\n        }","id":6779,"modified_method":"@Override\n        public Validator childNodeDeleted(String name, NodeState before) {\n            EventFilter eventFilter = filterRef.get();\n            if (eventFilter.include(NODE_REMOVED, beforeTree)) {\n                events.add(createEvent(NODE_REMOVED, beforeTree.getChild(name)));\n            }\n            if (eventFilter.includeChildren(beforeTree.getPath())) {\n                childEvents.add(new EventGeneratingValidator(this, name));\n            }\n            return null;\n        }","commit_id":"0b2a85c47cd21c8c90579bf762c4446076d318b5","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n        public void propertyDeleted(PropertyState before) {\n            if (!stopping && filterRef.get().include(PROPERTY_REMOVED, afterTree)) {\n                events.add(createEvent(PROPERTY_REMOVED, beforeTree, before));\n            }\n        }","id":6780,"modified_method":"@Override\n        public void propertyDeleted(PropertyState before) {\n            if (filterRef.get().include(PROPERTY_REMOVED, afterTree)) {\n                events.add(createEvent(PROPERTY_REMOVED, beforeTree, before));\n            }\n        }","commit_id":"0b2a85c47cd21c8c90579bf762c4446076d318b5","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private EventGeneratingValidator(EventGeneratingValidator parent, String name) {\n            this.userId = parent.userId;\n            this.message = parent.message;\n            this.timestamp = parent.timestamp;\n            this.external = parent.external;\n            this.beforeTree = parent.beforeTree.getChild(name);\n            this.afterTree = parent.afterTree.getChild(name);\n            this.events = parent.events;\n            isRoot = false;\n        }","id":6781,"modified_method":"private EventGeneratingValidator(EventGeneratingValidator parent, String name) {\n            this.userId = parent.userId;\n            this.message = parent.message;\n            this.timestamp = parent.timestamp;\n            this.external = parent.external;\n            this.beforeTree = parent.beforeTree.getChild(name);\n            this.afterTree = parent.afterTree.getChild(name);\n        }","commit_id":"0b2a85c47cd21c8c90579bf762c4446076d318b5","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public boolean isEntityInspectable() {\n        Integer isEntityInspectable=(Integer)d2wContext().valueForKey(\"isEntityInspectable\");\n        return isEntityReadOnly() && (isEntityInspectable!=null && isEntityInspectable.intValue()!=0);\n    }","id":6782,"modified_method":"public boolean isEntityInspectable() {\n        return isEntityReadOnly() && ERXValueUtilities.booleanValue(d2wContext().valueForKey(\"isEntityInspectable\"));\n    }","commit_id":"df91f862bac268216f5436b73bfd7e9d489f0931","url":"https://github.com/wocommunity/wonder"},{"original_method":"public static boolean booleanForKey(D2WContext context, String key) {\n        // FIXME: Should use ERXUtilities.booleanValue\n        Integer i=(Integer)context.valueForKey(key);\n        return i==null || i.intValue()!=0;\n    }","id":6783,"modified_method":"public static boolean booleanForKey(D2WContext context, String key) {\n    \treturn ERXValueUtilities.booleanValue(context.valueForKey(key));\n    }","commit_id":"b8e3b6891a6ed8a29e3fafd76b4833cbcae5f7bd","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Test\n    public void simpleMatchedQueryFromTopLevelFilter() throws Exception {\n\n        createIndex(\"test\");\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\", \"1\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"test\")\n                .field(\"title\", \"title1\")\n                .endObject()).execute().actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"2\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"test\")\n                .endObject()).execute().actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"3\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"test\")\n                .endObject()).execute().actionGet();\n\n        refresh();\n\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .setFilter(orFilter(\n                        termFilter(\"name\", \"test\").filterName(\"name\"),\n                        termFilter(\"title\", \"title1\").filterName(\"title\")))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 3l);\n\n        for (SearchHit hit : searchResponse.getHits()) {\n            if (hit.id().equals(\"1\")) {\n                assertThat(hit.matchedQueries().length, equalTo(2));\n                assertThat(hit.matchedQueries(), hasItemInArray(\"name\"));\n                assertThat(hit.matchedQueries(), hasItemInArray(\"title\"));\n            } else if (hit.id().equals(\"2\") || hit.id().equals(\"3\")) {\n                assertThat(hit.matchedQueries().length, equalTo(1));\n                assertThat(hit.matchedQueries(), hasItemInArray(\"name\"));\n            } else {\n                fail(\"Unexpected document returned with id \" + hit.id());\n            }\n        }\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .setFilter(queryFilter(boolQuery()\n                        .should(termQuery(\"name\", \"test\").queryName(\"name\"))\n                        .should(termQuery(\"title\", \"title1\").queryName(\"title\"))))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 3l);\n\n        for (SearchHit hit : searchResponse.getHits()) {\n            if (hit.id().equals(\"1\")) {\n                assertThat(hit.matchedQueries().length, equalTo(2));\n                assertThat(hit.matchedQueries(), hasItemInArray(\"name\"));\n                assertThat(hit.matchedQueries(), hasItemInArray(\"title\"));\n            } else if (hit.id().equals(\"2\") || hit.id().equals(\"3\")) {\n                assertThat(hit.matchedQueries().length, equalTo(1));\n                assertThat(hit.matchedQueries(), hasItemInArray(\"name\"));\n            } else {\n                fail(\"Unexpected document returned with id \" + hit.id());\n            }\n        }\n    }","id":6784,"modified_method":"@Test\n    public void simpleMatchedQueryFromTopLevelFilter() throws Exception {\n        createIndex(\"test\");\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\", \"1\").setSource(\"name\", \"test\", \"title\", \"title1\").get();\n        client().prepareIndex(\"test\", \"type1\", \"2\").setSource(\"name\", \"test\").get();\n        client().prepareIndex(\"test\", \"type1\", \"3\").setSource(\"name\", \"test\").get();\n        refresh();\n\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .setFilter(orFilter(\n                        termFilter(\"name\", \"test\").filterName(\"name\"),\n                        termFilter(\"title\", \"title1\").filterName(\"title\"))).get();\n        assertHitCount(searchResponse, 3l);\n        for (SearchHit hit : searchResponse.getHits()) {\n            if (hit.id().equals(\"1\")) {\n                assertThat(hit.matchedQueries().length, equalTo(2));\n                assertThat(hit.matchedQueries(), hasItemInArray(\"name\"));\n                assertThat(hit.matchedQueries(), hasItemInArray(\"title\"));\n            } else if (hit.id().equals(\"2\") || hit.id().equals(\"3\")) {\n                assertThat(hit.matchedQueries().length, equalTo(1));\n                assertThat(hit.matchedQueries(), hasItemInArray(\"name\"));\n            } else {\n                fail(\"Unexpected document returned with id \" + hit.id());\n            }\n        }\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .setFilter(queryFilter(boolQuery()\n                        .should(termQuery(\"name\", \"test\").queryName(\"name\"))\n                        .should(termQuery(\"title\", \"title1\").queryName(\"title\")))).get();\n\n        assertHitCount(searchResponse, 3l);\n        for (SearchHit hit : searchResponse.getHits()) {\n            if (hit.id().equals(\"1\")) {\n                assertThat(hit.matchedQueries().length, equalTo(2));\n                assertThat(hit.matchedQueries(), hasItemInArray(\"name\"));\n                assertThat(hit.matchedQueries(), hasItemInArray(\"title\"));\n            } else if (hit.id().equals(\"2\") || hit.id().equals(\"3\")) {\n                assertThat(hit.matchedQueries().length, equalTo(1));\n                assertThat(hit.matchedQueries(), hasItemInArray(\"name\"));\n            } else {\n                fail(\"Unexpected document returned with id \" + hit.id());\n            }\n        }\n    }","commit_id":"4670a2e514c16388434334dd847f30925d43766d","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void simpleMatchedQueryFromTopLevelFilterAndFilteredQuery() throws Exception {\n\n        createIndex(\"test\");\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\", \"1\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"test\")\n                .field(\"title\", \"title1\")\n                .endObject()).execute().actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"2\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"test\")\n                .field(\"title\", \"title2\")\n                .endObject()).execute().actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"3\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"test\")\n                .field(\"title\", \"title3\")\n                .endObject()).execute().actionGet();\n\n        refresh();\n\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(filteredQuery(matchAllQuery(), termsFilter(\"title\", \"title1\", \"title2\", \"title3\").filterName(\"title\")))\n                        .setFilter(termFilter(\"name\", \"test\").filterName(\"name\"))\n                        .execute().actionGet();\n\n        assertHitCount(searchResponse, 3l);\n\n        for (SearchHit hit : searchResponse.getHits()) {\n            if (hit.id().equals(\"1\") || hit.id().equals(\"2\") || hit.id().equals(\"3\")) {\n                assertThat(hit.matchedQueries().length, equalTo(2));\n                assertThat(hit.matchedQueries(), hasItemInArray(\"name\"));\n                assertThat(hit.matchedQueries(), hasItemInArray(\"title\"));\n            } else {\n                fail(\"Unexpected document returned with id \" + hit.id());\n            }\n        }\n\n        searchResponse = client().prepareSearch()\n                .setQuery(termsQuery(\"title\", \"title1\", \"title2\", \"title3\").queryName(\"title\"))\n                .setFilter(queryFilter(matchQuery(\"name\", \"test\").queryName(\"name\")))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 3l);\n\n        for (SearchHit hit : searchResponse.getHits()) {\n            if (hit.id().equals(\"1\") || hit.id().equals(\"2\") || hit.id().equals(\"3\")) {\n                assertThat(hit.matchedQueries().length, equalTo(2));\n                assertThat(hit.matchedQueries(), hasItemInArray(\"name\"));\n                assertThat(hit.matchedQueries(), hasItemInArray(\"title\"));\n            } else {\n                fail(\"Unexpected document returned with id \" + hit.id());\n            }\n        }\n    }","id":6785,"modified_method":"@Test\n    public void simpleMatchedQueryFromTopLevelFilterAndFilteredQuery() throws Exception {\n        createIndex(\"test\");\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\", \"1\").setSource(\"name\", \"test\", \"title\", \"title1\").get();\n        client().prepareIndex(\"test\", \"type1\", \"2\").setSource(\"name\", \"test\", \"title\", \"title2\").get();\n        client().prepareIndex(\"test\", \"type1\", \"3\").setSource(\"name\", \"test\", \"title\", \"title3\").get();\n        refresh();\n\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(filteredQuery(matchAllQuery(), termsFilter(\"title\", \"title1\", \"title2\", \"title3\").filterName(\"title\")))\n                        .setFilter(termFilter(\"name\", \"test\").filterName(\"name\")).get();\n        assertHitCount(searchResponse, 3l);\n        for (SearchHit hit : searchResponse.getHits()) {\n            if (hit.id().equals(\"1\") || hit.id().equals(\"2\") || hit.id().equals(\"3\")) {\n                assertThat(hit.matchedQueries().length, equalTo(2));\n                assertThat(hit.matchedQueries(), hasItemInArray(\"name\"));\n                assertThat(hit.matchedQueries(), hasItemInArray(\"title\"));\n            } else {\n                fail(\"Unexpected document returned with id \" + hit.id());\n            }\n        }\n\n        searchResponse = client().prepareSearch()\n                .setQuery(termsQuery(\"title\", \"title1\", \"title2\", \"title3\").queryName(\"title\"))\n                .setFilter(queryFilter(matchQuery(\"name\", \"test\").queryName(\"name\"))).get();\n        assertHitCount(searchResponse, 3l);\n        for (SearchHit hit : searchResponse.getHits()) {\n            if (hit.id().equals(\"1\") || hit.id().equals(\"2\") || hit.id().equals(\"3\")) {\n                assertThat(hit.matchedQueries().length, equalTo(2));\n                assertThat(hit.matchedQueries(), hasItemInArray(\"name\"));\n                assertThat(hit.matchedQueries(), hasItemInArray(\"title\"));\n            } else {\n                fail(\"Unexpected document returned with id \" + hit.id());\n            }\n        }\n    }","commit_id":"4670a2e514c16388434334dd847f30925d43766d","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void simpleMatchedQueryFromFilteredQuery() throws Exception {\n\n        createIndex(\"test\");\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\", \"1\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"test1\")\n                .field(\"number\", 1)\n                .endObject()).execute().actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"2\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"test2\")\n                .field(\"number\", 2)\n                .endObject()).execute().actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"3\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"test3\")\n                .field(\"number\", 3)\n                .endObject()).execute().actionGet();\n\n        refresh();\n\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(filteredQuery(matchAllQuery(), orFilter(rangeFilter(\"number\").lte(2).filterName(\"test1\"), rangeFilter(\"number\").gt(2).filterName(\"test2\"))))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 3l);\n\n        for (SearchHit hit : searchResponse.getHits()) {\n            if (hit.id().equals(\"1\") || hit.id().equals(\"2\")) {\n                assertThat(hit.matchedQueries().length, equalTo(1));\n                assertThat(hit.matchedQueries(), hasItemInArray(\"test1\"));\n            } else if (hit.id().equals(\"3\")) {\n                assertThat(hit.matchedQueries().length, equalTo(1));\n                assertThat(hit.matchedQueries(), hasItemInArray(\"test2\"));\n            } else {\n                fail(\"Unexpected document returned with id \" + hit.id());\n            }\n        }\n\n        searchResponse = client().prepareSearch()\n                .setQuery(boolQuery().should(rangeQuery(\"number\").lte(2).queryName(\"test1\")).should(rangeQuery(\"number\").gt(2).queryName(\"test2\")))\n                .execute().actionGet();\n\n\n        assertHitCount(searchResponse, 3l);\n\n        for (SearchHit hit : searchResponse.getHits()) {\n            if (hit.id().equals(\"1\") || hit.id().equals(\"2\")) {\n                assertThat(hit.matchedQueries().length, equalTo(1));\n                assertThat(hit.matchedQueries(), hasItemInArray(\"test1\"));\n            } else if (hit.id().equals(\"3\")) {\n                assertThat(hit.matchedQueries().length, equalTo(1));\n                assertThat(hit.matchedQueries(), hasItemInArray(\"test2\"));\n            } else {\n                fail(\"Unexpected document returned with id \" + hit.id());\n            }\n        }\n    }","id":6786,"modified_method":"@Test\n    public void simpleMatchedQueryFromFilteredQuery() throws Exception {\n        createIndex(\"test\");\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\", \"1\").setSource(\"name\", \"test1\", \"number\", 1).get();\n        client().prepareIndex(\"test\", \"type1\", \"2\").setSource(\"name\", \"test2\", \"number\", 2).get();\n        client().prepareIndex(\"test\", \"type1\", \"3\").setSource(\"name\", \"test3\", \"number\", 3).get();\n        refresh();\n\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(filteredQuery(matchAllQuery(), orFilter(rangeFilter(\"number\").lte(2).filterName(\"test1\"), rangeFilter(\"number\").gt(2).filterName(\"test2\")))).get();\n        assertHitCount(searchResponse, 3l);\n        for (SearchHit hit : searchResponse.getHits()) {\n            if (hit.id().equals(\"1\") || hit.id().equals(\"2\")) {\n                assertThat(hit.matchedQueries().length, equalTo(1));\n                assertThat(hit.matchedQueries(), hasItemInArray(\"test1\"));\n            } else if (hit.id().equals(\"3\")) {\n                assertThat(hit.matchedQueries().length, equalTo(1));\n                assertThat(hit.matchedQueries(), hasItemInArray(\"test2\"));\n            } else {\n                fail(\"Unexpected document returned with id \" + hit.id());\n            }\n        }\n\n        searchResponse = client().prepareSearch()\n                .setQuery(boolQuery().should(rangeQuery(\"number\").lte(2).queryName(\"test1\")).should(rangeQuery(\"number\").gt(2).queryName(\"test2\"))).get();\n        assertHitCount(searchResponse, 3l);\n        for (SearchHit hit : searchResponse.getHits()) {\n            if (hit.id().equals(\"1\") || hit.id().equals(\"2\")) {\n                assertThat(hit.matchedQueries().length, equalTo(1));\n                assertThat(hit.matchedQueries(), hasItemInArray(\"test1\"));\n            } else if (hit.id().equals(\"3\")) {\n                assertThat(hit.matchedQueries().length, equalTo(1));\n                assertThat(hit.matchedQueries(), hasItemInArray(\"test2\"));\n            } else {\n                fail(\"Unexpected document returned with id \" + hit.id());\n            }\n        }\n    }","commit_id":"4670a2e514c16388434334dd847f30925d43766d","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected <P> void applyUpdate(final UpdateContext updateContext, final UpdateResultHandler<? super Void, P> handler, final P param) {\n        final BatchBuilder builder = updateContext.getBatchBuilder();\n        final ScaledCount coreThreadsCount = getCoreThreads();\n        final ScaledCount maxThreadsCount = getMaxThreads();\n        final int maxThreads = maxThreadsCount.getScaledCount();\n        final int coreThreads = coreThreadsCount == null ? maxThreads : coreThreadsCount.getScaledCount();\n        final int queueLength = this.queueLength.getScaledCount();\n        final String name = getName();\n        final BoundedQueueThreadPoolService service = new BoundedQueueThreadPoolService(coreThreads, maxThreads, queueLength, blocking, getKeepaliveTime(), allowCoreTimeout);\n        builder.addService(ThreadsServices.executorName(name), service);\n    }","id":6787,"modified_method":"protected <P> void applyUpdate(final UpdateContext updateContext, final UpdateResultHandler<? super Void, P> handler, final P param) {\n        final BatchBuilder builder = updateContext.getBatchBuilder();\n        final ScaledCount coreThreadsCount = getCoreThreads();\n        final ScaledCount maxThreadsCount = getMaxThreads();\n        final int maxThreads = maxThreadsCount.getScaledCount();\n        final int coreThreads = coreThreadsCount == null ? maxThreads : coreThreadsCount.getScaledCount();\n        final int queueLength = this.queueLength.getScaledCount();\n        final String name = getName();\n        final ServiceName serviceName = ThreadsServices.executorName(name);\n        final BoundedQueueThreadPoolService service = new BoundedQueueThreadPoolService(coreThreads, maxThreads, queueLength, blocking, getKeepaliveTime(), allowCoreTimeout);\n        final BatchServiceBuilder<ExecutorService> serviceBuilder = builder.addService(serviceName, service);\n        addThreadFactoryDependency(serviceName, serviceBuilder, service.getThreadFactoryInjector(), builder);\n    }","commit_id":"27c0ecd9981a9f9816917b41e143f231e4a9049e","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected <P> void applyUpdate(final UpdateContext updateContext, final UpdateResultHandler<? super Void, P> handler, final P param) {\n        final BatchBuilder builder = updateContext.getBatchBuilder();\n        final ScaledCount maxThreadsCount = getMaxThreads();\n        final int maxThreads = maxThreadsCount.getScaledCount();\n        final String name = getName();\n        final QueuelessThreadPoolService service = new QueuelessThreadPoolService(maxThreads, blocking, getKeepaliveTime());\n        builder.addService(ThreadsServices.executorName(name), service);\n    }","id":6788,"modified_method":"protected <P> void applyUpdate(final UpdateContext updateContext, final UpdateResultHandler<? super Void, P> handler, final P param) {\n        final BatchBuilder builder = updateContext.getBatchBuilder();\n        final ScaledCount maxThreadsCount = getMaxThreads();\n        final int maxThreads = maxThreadsCount.getScaledCount();\n        final String name = getName();\n        final ServiceName serviceName = ThreadsServices.executorName(name);\n        final QueuelessThreadPoolService service = new QueuelessThreadPoolService(maxThreads, blocking, getKeepaliveTime());\n        final BatchServiceBuilder<ExecutorService> serviceBuilder = builder.addService(serviceName, service);\n        addThreadFactoryDependency(serviceName, serviceBuilder, service.getThreadFactoryInjector(), builder);\n    }","commit_id":"27c0ecd9981a9f9816917b41e143f231e4a9049e","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected <P> void applyUpdate(final UpdateContext updateContext, final UpdateResultHandler<? super Void, P> handler, final P param) {\n        final BatchBuilder builder = updateContext.getBatchBuilder();\n        final ScaledCount maxThreadsCount = getMaxThreads();\n        final int maxThreads = maxThreadsCount.getScaledCount();\n        final String name = getName();\n        final UnboundedQueueThreadPoolService service = new UnboundedQueueThreadPoolService(maxThreads, getKeepaliveTime());\n        builder.addService(ThreadsServices.executorName(name), service);\n    }","id":6789,"modified_method":"protected <P> void applyUpdate(final UpdateContext updateContext, final UpdateResultHandler<? super Void, P> handler, final P param) {\n        final BatchBuilder builder = updateContext.getBatchBuilder();\n        final ScaledCount maxThreadsCount = getMaxThreads();\n        final int maxThreads = maxThreadsCount.getScaledCount();\n        final String name = getName();\n        final ServiceName serviceName = ThreadsServices.executorName(name);\n        final UnboundedQueueThreadPoolService service = new UnboundedQueueThreadPoolService(maxThreads, getKeepaliveTime());\n        final BatchServiceBuilder<ExecutorService> serviceBuilder = builder.addService(serviceName, service);\n        addThreadFactoryDependency(serviceName, serviceBuilder, service.getThreadFactoryInjector(), builder);\n    }","commit_id":"27c0ecd9981a9f9816917b41e143f231e4a9049e","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected <P> void applyUpdate(final UpdateContext updateContext, final UpdateResultHandler<? super Void, P> handler, final P param) {\n        final BatchBuilder builder = updateContext.getBatchBuilder();\n        final ScaledCount maxThreadsCount = getMaxThreads();\n        final int maxThreads = maxThreadsCount.getScaledCount();\n        final String name = getName();\n        final UnboundedQueueThreadPoolService service = new UnboundedQueueThreadPoolService(maxThreads, getKeepaliveTime());\n        builder.addService(ThreadsServices.executorName(name), service);\n    }","id":6790,"modified_method":"protected <P> void applyUpdate(final UpdateContext updateContext, final UpdateResultHandler<? super Void, P> handler, final P param) {\n        final BatchBuilder builder = updateContext.getBatchBuilder();\n        final ScaledCount maxThreadsCount = getMaxThreads();\n        final int maxThreads = maxThreadsCount.getScaledCount();\n        final String name = getName();\n        final ServiceName serviceName = ThreadsServices.executorName(name);\n        final UnboundedQueueThreadPoolService service = new UnboundedQueueThreadPoolService(maxThreads, getKeepaliveTime());\n        final BatchServiceBuilder<ExecutorService> serviceBuilder = builder.addService(serviceName, service);\n        addThreadFactoryDependency(serviceName, serviceBuilder, service.getThreadFactoryInjector(), builder);\n    }","commit_id":"27c0ecd9981a9f9816917b41e143f231e4a9049e","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void addUser(String s) {\n      users.add(s);\n    }","id":6791,"modified_method":"public Dto addUser(String s) {\n      users.add(s);\n      return this;\n    }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void addGroup(String s) {\n      groups.add(s);\n    }","id":6792,"modified_method":"public Dto addGroup(String s) {\n      groups.add(s);\n      return this;\n    }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void filter_by_resolutions() throws Exception {\n    db.issueDao().insert(session,\n      IssueTesting.newDto(rule, file, project).setResolution(Issue.RESOLUTION_FALSE_POSITIVE),\n      IssueTesting.newDto(rule, file, project).setResolution(Issue.RESOLUTION_FIXED));\n    session.commit();\n    index();\n\n    assertThat(index.search(IssueQuery.builder().resolutions(newArrayList(Issue.RESOLUTION_FALSE_POSITIVE, Issue.RESOLUTION_FIXED)).build(), new QueryContext()).getHits())\n      .hasSize(2);\n    assertThat(index.search(IssueQuery.builder().resolutions(newArrayList(Issue.RESOLUTION_FALSE_POSITIVE)).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().resolutions(newArrayList(Issue.RESOLUTION_REMOVED)).build(), new QueryContext()).getHits()).isEmpty();\n  }","id":6793,"modified_method":"@Test\n  public void filter_by_resolutions() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto file = ComponentTesting.newFileDto(project);\n\n    indexIssues(\n      IssueTesting.newDoc(\"ISSUE1\", file).setResolution(Issue.RESOLUTION_FALSE_POSITIVE),\n      IssueTesting.newDoc(\"ISSUE2\", file).setResolution(Issue.RESOLUTION_FIXED));\n\n    assertThat(index.search(IssueQuery.builder().resolutions(newArrayList(Issue.RESOLUTION_FALSE_POSITIVE, Issue.RESOLUTION_FIXED)).build(), new QueryContext()).getHits())\n      .hasSize(2);\n    assertThat(index.search(IssueQuery.builder().resolutions(newArrayList(Issue.RESOLUTION_FALSE_POSITIVE)).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().resolutions(newArrayList(Issue.RESOLUTION_REMOVED)).build(), new QueryContext()).getHits()).isEmpty();\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void filter_by_planned() throws Exception {\n    db.issueDao().insert(session,\n      IssueTesting.newDto(rule, file, project).setActionPlanKey(\"AP-KEY\"),\n      IssueTesting.newDto(rule, file, project).setActionPlanKey(null),\n      IssueTesting.newDto(rule, file, project).setActionPlanKey(null));\n    session.commit();\n    index();\n\n    assertThat(index.search(IssueQuery.builder().planned(true).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().planned(false).build(), new QueryContext()).getHits()).hasSize(2);\n    assertThat(index.search(IssueQuery.builder().planned(null).build(), new QueryContext()).getHits()).hasSize(3);\n  }","id":6794,"modified_method":"@Test\n  public void filter_by_planned() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto file = ComponentTesting.newFileDto(project);\n\n    indexIssues(\n      IssueTesting.newDoc(\"ISSUE1\", file).setActionPlanKey(\"AP-KEY\"),\n      IssueTesting.newDoc(\"ISSUE2\", file).setActionPlanKey(null),\n      IssueTesting.newDoc(\"ISSUE3\", file).setActionPlanKey(null));\n\n    assertThat(index.search(IssueQuery.builder().planned(true).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().planned(false).build(), new QueryContext()).getHits()).hasSize(2);\n    assertThat(index.search(IssueQuery.builder().planned(null).build(), new QueryContext()).getHits()).hasSize(3);\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void filter_by_rules() throws Exception {\n    db.issueDao().insert(session, IssueTesting.newDto(rule, file, project).setRule(rule));\n\n    tester.get(RuleDao.class).insert(session, RuleTesting.newDto(RuleKey.of(\"rule\", \"without issue\")));\n    session.commit();\n    index();\n\n    assertThat(index.search(IssueQuery.builder().rules(newArrayList(rule.getKey())).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().rules(newArrayList(RuleKey.of(\"rule\", \"without issue\"))).build(), new QueryContext()).getHits()).isEmpty();\n  }","id":6795,"modified_method":"@Test\n  public void filter_by_rules() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto file = ComponentTesting.newFileDto(project);\n    RuleKey ruleKey = RuleKey.of(\"repo\", \"X1\");\n\n    indexIssues(IssueTesting.newDoc(\"ISSUE1\", file).setRuleKey(ruleKey.toString()));\n\n    assertThat(index.search(IssueQuery.builder().rules(newArrayList(ruleKey)).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().rules(newArrayList(RuleKey.of(\"rule\", \"without issue\"))).build(), new QueryContext()).getHits()).isEmpty();\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void filter_by_resolved() throws Exception {\n    db.issueDao().insert(session,\n      IssueTesting.newDto(rule, file, project).setStatus(Issue.STATUS_CLOSED).setResolution(Issue.RESOLUTION_FIXED),\n      IssueTesting.newDto(rule, file, project).setStatus(Issue.STATUS_OPEN).setResolution(null),\n      IssueTesting.newDto(rule, file, project).setStatus(Issue.STATUS_OPEN).setResolution(null));\n    session.commit();\n    index();\n\n    assertThat(index.search(IssueQuery.builder().resolved(true).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().resolved(false).build(), new QueryContext()).getHits()).hasSize(2);\n    assertThat(index.search(IssueQuery.builder().resolved(null).build(), new QueryContext()).getHits()).hasSize(3);\n  }","id":6796,"modified_method":"@Test\n  public void filter_by_resolved() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto file = ComponentTesting.newFileDto(project);\n\n    indexIssues(\n      IssueTesting.newDoc(\"ISSUE1\", file).setStatus(Issue.STATUS_CLOSED).setResolution(Issue.RESOLUTION_FIXED),\n      IssueTesting.newDoc(\"ISSUE2\", file).setStatus(Issue.STATUS_OPEN).setResolution(null),\n      IssueTesting.newDoc(\"ISSUE3\", file).setStatus(Issue.STATUS_OPEN).setResolution(null));\n\n    assertThat(index.search(IssueQuery.builder().resolved(true).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().resolved(false).build(), new QueryContext()).getHits()).hasSize(2);\n    assertThat(index.search(IssueQuery.builder().resolved(null).build(), new QueryContext()).getHits()).hasSize(3);\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void paging() throws Exception {\n    for (int i = 0; i < 12; i++) {\n      IssueDto issue = IssueTesting.newDto(rule, file, project);\n      tester.get(IssueDao.class).insert(session, issue);\n    }\n    session.commit();\n    index();\n\n    IssueQuery.Builder query = IssueQuery.builder();\n    // There are 12 issues in total, with 10 issues per page, the page 2 should only contain 2 elements\n    Result<Issue> result = index.search(query.build(), new QueryContext().setPage(2, 10));\n    assertThat(result.getHits()).hasSize(2);\n    assertThat(result.getTotal()).isEqualTo(12);\n\n    result = index.search(IssueQuery.builder().build(), new QueryContext().setOffset(0).setLimit(5));\n    assertThat(result.getHits()).hasSize(5);\n    assertThat(result.getTotal()).isEqualTo(12);\n\n    result = index.search(IssueQuery.builder().build(), new QueryContext().setOffset(2).setLimit(0));\n    assertThat(result.getHits()).hasSize(0);\n    assertThat(result.getTotal()).isEqualTo(12);\n  }","id":6797,"modified_method":"@Test\n  public void paging() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto file = ComponentTesting.newFileDto(project);\n    for (int i = 0; i < 12; i++) {\n      indexIssues(IssueTesting.newDoc(\"ISSUE\" + i, file));\n    }\n\n    IssueQuery.Builder query = IssueQuery.builder();\n    // There are 12 issues in total, with 10 issues per page, the page 2 should only contain 2 elements\n    Result<Issue> result = index.search(query.build(), new QueryContext().setPage(2, 10));\n    assertThat(result.getHits()).hasSize(2);\n    assertThat(result.getTotal()).isEqualTo(12);\n\n    result = index.search(IssueQuery.builder().build(), new QueryContext().setOffset(0).setLimit(5));\n    assertThat(result.getHits()).hasSize(5);\n    assertThat(result.getTotal()).isEqualTo(12);\n\n    result = index.search(IssueQuery.builder().build(), new QueryContext().setOffset(2).setLimit(0));\n    assertThat(result.getHits()).hasSize(0);\n    assertThat(result.getTotal()).isEqualTo(12);\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void filter_by_assignees() throws Exception {\n    db.issueDao().insert(session,\n      IssueTesting.newDto(rule, file, project).setAssignee(\"steph\"),\n      IssueTesting.newDto(rule, file, project).setAssignee(\"simon\"),\n      IssueTesting.newDto(rule, file, project));\n    session.commit();\n    index();\n\n    assertThat(index.search(IssueQuery.builder().assignees(newArrayList(\"steph\")).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().assignees(newArrayList(\"steph\", \"simon\")).build(), new QueryContext()).getHits()).hasSize(2);\n    assertThat(index.search(IssueQuery.builder().assignees(newArrayList(\"unknown\")).build(), new QueryContext()).getHits()).isEmpty();\n  }","id":6798,"modified_method":"@Test\n  public void filter_by_assignees() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto file = ComponentTesting.newFileDto(project);\n\n    indexIssues(\n      IssueTesting.newDoc(\"ISSUE1\", file).setAssignee(\"steph\"),\n      IssueTesting.newDoc(\"ISSUE2\", file).setAssignee(\"simon\"),\n      IssueTesting.newDoc(\"ISSUE3\", file).setAssignee(null));\n\n    assertThat(index.search(IssueQuery.builder().assignees(newArrayList(\"steph\")).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().assignees(newArrayList(\"steph\", \"simon\")).build(), new QueryContext()).getHits()).hasSize(2);\n    assertThat(index.search(IssueQuery.builder().assignees(newArrayList(\"unknown\")).build(), new QueryContext()).getHits()).isEmpty();\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void authorized_issues_on_user_and_group() throws Exception {\n    ComponentDto project1 = ComponentTesting.newProjectDto().setKey(\"project1\");\n    ComponentDto project2 = ComponentTesting.newProjectDto().setKey(\"project2\");\n    tester.get(ComponentDao.class).insert(session, project1, project2);\n\n    // project1 can be seen by john\n    UserDto john = new UserDto().setLogin(\"john\").setName(\"john\").setActive(true);\n    db.userDao().insert(session, john);\n    tester.get(PermissionFacade.class).insertUserPermission(project1.getId(), john.getId(), UserRole.USER, session);\n\n    // project1 can be seen by sonar-users\n    GroupDto groupDto = new GroupDto().setName(\"sonar-users\");\n    db.groupDao().insert(session, groupDto);\n    session.commit();\n    MockUserSession.set().setLogin(\"admin\").setGlobalPermissions(GlobalPermissions.SYSTEM_ADMIN);\n    tester.get(InternalPermissionService.class).addPermission(new PermissionChange().setComponentKey(project1.getKey()).setGroup(\"sonar-users\").setPermission(UserRole.USER));\n\n    db.issueDao().insert(session,\n      IssueTesting.newDto(rule, file, project1),\n      IssueTesting.newDto(rule, file, project2));\n\n    session.commit();\n    session.clearCache();\n    index();\n\n    IssueQuery.Builder query = IssueQuery.builder();\n\n    MockUserSession.set().setLogin(\"john\").setUserGroups(\"sonar-users\");\n    assertThat(index.search(query.build(), new QueryContext()).getHits()).hasSize(1);\n  }","id":6799,"modified_method":"@Test\n  public void authorized_issues_on_user_and_group() throws Exception {\n    ComponentDto project1 = ComponentTesting.newProjectDto().setKey(\"project1\");\n    ComponentDto project2 = ComponentTesting.newProjectDto().setKey(\"project2\");\n\n    ComponentDto file1 = ComponentTesting.newFileDto(project1).setKey(\"file1\");\n    ComponentDto file2 = ComponentTesting.newFileDto(project2).setKey(\"file2\");\n\n    // project1 can be seen by john and by sonar-users\n    indexIssue(IssueTesting.newDoc(\"ISSUE1\", file1), \"sonar-users\", \"john\");\n    indexIssue(IssueTesting.newDoc(\"ISSUE2\", file2), null, \"max\");\n\n    IssueQuery.Builder query = IssueQuery.builder();\n    MockUserSession.set().setLogin(\"john\").setUserGroups(\"sonar-users\");\n    assertThat(index.search(query.build(), new QueryContext()).getHits()).hasSize(1);\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void filter_by_components() throws Exception {\n    ComponentDto module = ComponentTesting.newModuleDto(project);\n    ComponentDto subModule = ComponentTesting.newModuleDto(module);\n    ComponentDto file1 = ComponentTesting.newFileDto(project);\n    ComponentDto file2 = ComponentTesting.newFileDto(module);\n    ComponentDto file3 = ComponentTesting.newFileDto(subModule);\n    tester.get(ComponentDao.class).insert(session, module, subModule, file1, file2, file3);\n\n    db.issueDao().insert(session,\n      IssueTesting.newDto(rule, project, project),\n      IssueTesting.newDto(rule, file1, project),\n      IssueTesting.newDto(rule, module, project),\n      IssueTesting.newDto(rule, file2, project),\n      IssueTesting.newDto(rule, subModule, project),\n      IssueTesting.newDto(rule, file3, project));\n    session.commit();\n    index();\n\n    assertThat(index.search(IssueQuery.builder().componentUuids(newArrayList(file1.uuid(), file2.uuid(), file3.uuid())).build(), new QueryContext()).getHits()).hasSize(3);\n    assertThat(index.search(IssueQuery.builder().componentUuids(newArrayList(file1.uuid())).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().componentUuids(newArrayList(subModule.uuid())).build(), new QueryContext()).getHits()).hasSize(2);\n    assertThat(index.search(IssueQuery.builder().componentUuids(newArrayList(subModule.uuid())).onComponentOnly(true).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().componentUuids(newArrayList(module.uuid())).build(), new QueryContext()).getHits()).hasSize(4);\n    assertThat(index.search(IssueQuery.builder().componentUuids(newArrayList(module.uuid())).onComponentOnly(true).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().componentUuids(newArrayList(project.uuid())).build(), new QueryContext()).getHits()).hasSize(6);\n    assertThat(index.search(IssueQuery.builder().componentUuids(newArrayList(project.uuid())).onComponentOnly(true).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().componentUuids(newArrayList(\"unknown\")).build(), new QueryContext()).getHits()).isEmpty();\n  }","id":6800,"modified_method":"@Test\n  public void filter_by_components() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto module = ComponentTesting.newModuleDto(project);\n    ComponentDto subModule = ComponentTesting.newModuleDto(module);\n    ComponentDto file1 = ComponentTesting.newFileDto(project);\n    ComponentDto file2 = ComponentTesting.newFileDto(module);\n    ComponentDto file3 = ComponentTesting.newFileDto(subModule);\n\n    indexIssues(\n      IssueTesting.newDoc(\"ISSUE1\", project),\n      IssueTesting.newDoc(\"ISSUE2\", file1),\n      IssueTesting.newDoc(\"ISSUE3\", module),\n      IssueTesting.newDoc(\"ISSUE4\", file2),\n      IssueTesting.newDoc(\"ISSUE5\", subModule),\n      IssueTesting.newDoc(\"ISSUE6\", file3));\n\n    assertThat(index.search(IssueQuery.builder().componentUuids(newArrayList(file1.uuid(), file2.uuid(), file3.uuid())).build(), new QueryContext()).getHits()).hasSize(3);\n    assertThat(index.search(IssueQuery.builder().componentUuids(newArrayList(file1.uuid())).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().componentUuids(newArrayList(subModule.uuid())).build(), new QueryContext()).getHits()).hasSize(2);\n    assertThat(index.search(IssueQuery.builder().componentUuids(newArrayList(subModule.uuid())).onComponentOnly(true).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().componentUuids(newArrayList(module.uuid())).build(), new QueryContext()).getHits()).hasSize(4);\n    assertThat(index.search(IssueQuery.builder().componentUuids(newArrayList(module.uuid())).onComponentOnly(true).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().componentUuids(newArrayList(project.uuid())).build(), new QueryContext()).getHits()).hasSize(6);\n    assertThat(index.search(IssueQuery.builder().componentUuids(newArrayList(project.uuid())).onComponentOnly(true).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().componentUuids(newArrayList(\"unknown\")).build(), new QueryContext()).getHits()).isEmpty();\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void sort_by_creation_date() throws Exception {\n    db.issueDao().insert(session,\n      IssueTesting.newDto(rule, file, project).setIssueCreationDate(DateUtils.parseDate(\"2014-09-23\")),\n      IssueTesting.newDto(rule, file, project).setIssueCreationDate(DateUtils.parseDate(\"2014-09-24\")));\n    session.commit();\n    index();\n\n    IssueQuery.Builder query = IssueQuery.builder().sort(IssueQuery.SORT_BY_CREATION_DATE).asc(true);\n    Result<Issue> result = index.search(query.build(), new QueryContext());\n    assertThat(result.getHits()).hasSize(2);\n    assertThat(result.getHits().get(0).creationDate()).isEqualTo(DateUtils.parseDate(\"2014-09-23\"));\n    assertThat(result.getHits().get(1).creationDate()).isEqualTo(DateUtils.parseDate(\"2014-09-24\"));\n\n    query = IssueQuery.builder().sort(IssueQuery.SORT_BY_CREATION_DATE).asc(false);\n    result = index.search(query.build(), new QueryContext());\n    assertThat(result.getHits()).hasSize(2);\n    assertThat(result.getHits().get(0).creationDate()).isEqualTo(DateUtils.parseDate(\"2014-09-24\"));\n    assertThat(result.getHits().get(1).creationDate()).isEqualTo(DateUtils.parseDate(\"2014-09-23\"));\n  }","id":6801,"modified_method":"@Test\n  public void sort_by_creation_date() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto file = ComponentTesting.newFileDto(project);\n\n    indexIssues(\n      IssueTesting.newDoc(\"ISSUE1\", file).setFuncCreationDate(DateUtils.parseDate(\"2014-09-23\")),\n      IssueTesting.newDoc(\"ISSUE2\", file).setFuncCreationDate(DateUtils.parseDate(\"2014-09-24\")));\n\n    IssueQuery.Builder query = IssueQuery.builder().sort(IssueQuery.SORT_BY_CREATION_DATE).asc(true);\n    Result<Issue> result = index.search(query.build(), new QueryContext());\n    assertThat(result.getHits()).hasSize(2);\n    assertThat(result.getHits().get(0).creationDate()).isEqualTo(DateUtils.parseDate(\"2014-09-23\"));\n    assertThat(result.getHits().get(1).creationDate()).isEqualTo(DateUtils.parseDate(\"2014-09-24\"));\n\n    query = IssueQuery.builder().sort(IssueQuery.SORT_BY_CREATION_DATE).asc(false);\n    result = index.search(query.build(), new QueryContext());\n    assertThat(result.getHits()).hasSize(2);\n    assertThat(result.getHits().get(0).creationDate()).isEqualTo(DateUtils.parseDate(\"2014-09-24\"));\n    assertThat(result.getHits().get(1).creationDate()).isEqualTo(DateUtils.parseDate(\"2014-09-23\"));\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void filter_by_created_before() throws Exception {\n    IssueDto issue1 = IssueTesting.newDto(rule, file, project).setIssueCreationDate(DateUtils.parseDate(\"2014-09-20\"));\n    IssueDto issue2 = IssueTesting.newDto(rule, file, project).setIssueCreationDate(DateUtils.parseDate(\"2014-09-23\"));\n    db.issueDao().insert(session, issue1, issue2);\n    session.commit();\n    index();\n\n    assertThat(index.search(IssueQuery.builder().createdBefore(DateUtils.parseDate(\"2014-09-19\")).build(), new QueryContext()).getHits()).isEmpty();\n    assertThat(index.search(IssueQuery.builder().createdBefore(DateUtils.parseDate(\"2014-09-20\")).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().createdBefore(DateUtils.parseDate(\"2014-09-21\")).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().createdBefore(DateUtils.parseDate(\"2014-09-25\")).build(), new QueryContext()).getHits()).hasSize(2);\n  }","id":6802,"modified_method":"@Test\n  public void filter_by_created_before() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto file = ComponentTesting.newFileDto(project);\n\n    indexIssues(\n      IssueTesting.newDoc(\"ISSUE1\", file).setFuncCreationDate(DateUtils.parseDate(\"2014-09-20\")),\n      IssueTesting.newDoc(\"ISSUE2\", file).setFuncCreationDate(DateUtils.parseDate(\"2014-09-23\")));\n\n    assertThat(index.search(IssueQuery.builder().createdBefore(DateUtils.parseDate(\"2014-09-19\")).build(), new QueryContext()).getHits()).isEmpty();\n    assertThat(index.search(IssueQuery.builder().createdBefore(DateUtils.parseDate(\"2014-09-20\")).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().createdBefore(DateUtils.parseDate(\"2014-09-21\")).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().createdBefore(DateUtils.parseDate(\"2014-09-25\")).build(), new QueryContext()).getHits()).hasSize(2);\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test(expected = IllegalStateException.class)\n  public void comments_field_is_not_available() throws Exception {\n    IssueDto issue = IssueTesting.newDto(rule, file, project);\n    db.issueDao().insert(session, issue);\n    session.commit();\n    index();\n\n    Issue result = index.getByKey(issue.getKey());\n    result.comments();\n  }","id":6803,"modified_method":"@Test(expected = IllegalStateException.class)\n  public void comments_field_is_not_available() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto file = ComponentTesting.newFileDto(project);\n    IssueDoc issue = IssueTesting.newDoc(\"ISSUE1\", file);\n    indexIssues(issue);\n\n    Issue result = index.getByKey(issue.key());\n    result.comments();\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void list_assignees() throws Exception {\n    db.issueDao().insert(session,\n      IssueTesting.newDto(rule, file, project).setAssignee(\"steph\").setStatus(Issue.STATUS_OPEN),\n      IssueTesting.newDto(rule, file, project).setAssignee(\"simon\").setStatus(Issue.STATUS_OPEN),\n      IssueTesting.newDto(rule, file, project).setStatus(Issue.STATUS_OPEN),\n      IssueTesting.newDto(rule, file, project).setAssignee(\"steph\").setStatus(Issue.STATUS_OPEN),\n      // julien should not be returned as the issue is closed\n      IssueTesting.newDto(rule, file, project).setAssignee(\"julien\").setStatus(Issue.STATUS_CLOSED)\n      );\n    session.commit();\n    index();\n\n    List<FacetValue> results = index.listAssignees(IssueQuery.builder().statuses(newArrayList(Issue.STATUS_OPEN)).build());\n\n    assertThat(results).hasSize(3);\n    assertThat(results.get(0).getKey()).isEqualTo(\"steph\");\n    assertThat(results.get(0).getValue()).isEqualTo(2);\n\n    assertThat(results.get(1).getKey()).isEqualTo(\"simon\");\n    assertThat(results.get(1).getValue()).isEqualTo(1);\n\n    assertThat(results.get(2).getKey()).isEqualTo(\"_notAssigned_\");\n    assertThat(results.get(2).getValue()).isEqualTo(1);\n  }","id":6804,"modified_method":"@Test\n  public void list_assignees() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto file = ComponentTesting.newFileDto(project);\n\n    indexIssues(\n      IssueTesting.newDoc(\"ISSUE1\", file).setAssignee(\"steph\").setStatus(Issue.STATUS_OPEN),\n      IssueTesting.newDoc(\"ISSUE2\", file).setAssignee(\"simon\").setStatus(Issue.STATUS_OPEN),\n      IssueTesting.newDoc(\"ISSUE3\", file).setAssignee(null).setStatus(Issue.STATUS_OPEN),\n      IssueTesting.newDoc(\"ISSUE4\", file).setAssignee(\"steph\").setStatus(Issue.STATUS_OPEN),\n      // Issue assigned to julien should not be returned as the issue is closed\n      IssueTesting.newDoc(\"ISSUE5\", file).setAssignee(\"julien\").setStatus(Issue.STATUS_CLOSED));\n\n    List<FacetValue> results = index.listAssignees(IssueQuery.builder().statuses(newArrayList(Issue.STATUS_OPEN)).build());\n\n    assertThat(results).hasSize(3);\n    assertThat(results.get(0).getKey()).isEqualTo(\"steph\");\n    assertThat(results.get(0).getValue()).isEqualTo(2);\n\n    assertThat(results.get(1).getKey()).isEqualTo(\"simon\");\n    assertThat(results.get(1).getValue()).isEqualTo(1);\n\n    assertThat(results.get(2).getKey()).isEqualTo(\"_notAssigned_\");\n    assertThat(results.get(2).getValue()).isEqualTo(1);\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void filter_by_languages() throws Exception {\n    db.issueDao().insert(session, IssueTesting.newDto(rule, file, project).setRule(rule));\n    session.commit();\n    index();\n\n    assertThat(index.search(IssueQuery.builder().languages(newArrayList(rule.getLanguage())).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().languages(newArrayList(\"unknown\")).build(), new QueryContext()).getHits()).isEmpty();\n  }","id":6805,"modified_method":"@Test\n  public void filter_by_languages() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto file = ComponentTesting.newFileDto(project);\n    RuleKey ruleKey = RuleKey.of(\"repo\", \"X1\");\n\n    indexIssues(IssueTesting.newDoc(\"ISSUE1\", file).setRuleKey(ruleKey.toString()).setLanguage(\"xoo\"));\n\n    assertThat(index.search(IssueQuery.builder().languages(newArrayList(\"xoo\")).build(), new\n      QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().languages(newArrayList(\"unknown\")).build(), new QueryContext()).getHits()).isEmpty();\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void sort_by_file_and_line() throws Exception {\n    db.issueDao().insert(session,\n      // file F1\n      IssueTesting.newDto(rule, file, project).setLine(20).setKee(\"F1_2\"),\n      IssueTesting.newDto(rule, file, project).setLine(null).setKee(\"F1_1\"),\n      IssueTesting.newDto(rule, file, project).setLine(25).setKee(\"F1_3\"),\n\n      // file F2\n      IssueTesting.newDto(rule, file2, project).setLine(9).setKee(\"F2_1\"),\n      IssueTesting.newDto(rule, file2, project).setLine(109).setKee(\"F2_2\"),\n      // two issues on the same line -> sort by key\n      IssueTesting.newDto(rule, file2, project).setLine(109).setKee(\"F2_3\")\n      );\n    session.commit();\n    index();\n\n    // ascending sort -> F1 then F2. Line \"0\" first.\n    IssueQuery.Builder query = IssueQuery.builder().sort(IssueQuery.SORT_BY_FILE_LINE).asc(true);\n    Result<Issue> result = index.search(query.build(), new QueryContext());\n    assertThat(result.getHits()).hasSize(6);\n    assertThat(result.getHits().get(0).key()).isEqualTo(\"F1_1\");\n    assertThat(result.getHits().get(1).key()).isEqualTo(\"F1_2\");\n    assertThat(result.getHits().get(2).key()).isEqualTo(\"F1_3\");\n    assertThat(result.getHits().get(3).key()).isEqualTo(\"F2_1\");\n    assertThat(result.getHits().get(4).key()).isEqualTo(\"F2_2\");\n    assertThat(result.getHits().get(5).key()).isEqualTo(\"F2_3\");\n\n    // descending sort -> F2 then F1\n    query = IssueQuery.builder().sort(IssueQuery.SORT_BY_FILE_LINE).asc(false);\n    result = index.search(query.build(), new QueryContext());\n    assertThat(result.getHits()).hasSize(6);\n    assertThat(result.getHits().get(0).key()).isEqualTo(\"F2_3\");\n    assertThat(result.getHits().get(1).key()).isEqualTo(\"F2_2\");\n    assertThat(result.getHits().get(2).key()).isEqualTo(\"F2_1\");\n    assertThat(result.getHits().get(3).key()).isEqualTo(\"F1_3\");\n    assertThat(result.getHits().get(4).key()).isEqualTo(\"F1_2\");\n    assertThat(result.getHits().get(5).key()).isEqualTo(\"F1_1\");\n  }","id":6806,"modified_method":"@Test\n  public void sort_by_file_and_line() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto file1 = ComponentTesting.newFileDto(project, \"F1\").setPath(\"src/main/xoo/org/sonar/samples/File.xoo\");\n    ComponentDto file2 = ComponentTesting.newFileDto(project, \"F2\").setPath(\"src/main/xoo/org/sonar/samples/File2.xoo\");\n\n    indexIssues(\n      // file F1\n      IssueTesting.newDoc(\"F1_2\", file1).setLine(20),\n      IssueTesting.newDoc(\"F1_1\", file1).setLine(null),\n      IssueTesting.newDoc(\"F1_3\", file1).setLine(25),\n\n      // file F2\n      IssueTesting.newDoc(\"F2_1\", file2).setLine(9),\n      IssueTesting.newDoc(\"F2_2\", file2).setLine(109),\n      // two issues on the same line -> sort by key\n      IssueTesting.newDoc(\"F2_3\", file2).setLine(109));\n\n    // ascending sort -> F1 then F2. Line \"0\" first.\n    IssueQuery.Builder query = IssueQuery.builder().sort(IssueQuery.SORT_BY_FILE_LINE).asc(true);\n    Result<Issue> result = index.search(query.build(), new QueryContext());\n    assertThat(result.getHits()).hasSize(6);\n    assertThat(result.getHits().get(0).key()).isEqualTo(\"F1_1\");\n    assertThat(result.getHits().get(1).key()).isEqualTo(\"F1_2\");\n    assertThat(result.getHits().get(2).key()).isEqualTo(\"F1_3\");\n    assertThat(result.getHits().get(3).key()).isEqualTo(\"F2_1\");\n    assertThat(result.getHits().get(4).key()).isEqualTo(\"F2_2\");\n    assertThat(result.getHits().get(5).key()).isEqualTo(\"F2_3\");\n\n    // descending sort -> F2 then F1\n    query = IssueQuery.builder().sort(IssueQuery.SORT_BY_FILE_LINE).asc(false);\n    result = index.search(query.build(), new QueryContext());\n    assertThat(result.getHits()).hasSize(6);\n    assertThat(result.getHits().get(0).key()).isEqualTo(\"F2_3\");\n    assertThat(result.getHits().get(1).key()).isEqualTo(\"F2_2\");\n    assertThat(result.getHits().get(2).key()).isEqualTo(\"F2_1\");\n    assertThat(result.getHits().get(3).key()).isEqualTo(\"F1_3\");\n    assertThat(result.getHits().get(4).key()).isEqualTo(\"F1_2\");\n    assertThat(result.getHits().get(5).key()).isEqualTo(\"F1_1\");\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void filter_by_projects() throws Exception {\n    ComponentDto module = ComponentTesting.newModuleDto(project);\n    ComponentDto subModule = ComponentTesting.newModuleDto(module);\n    ComponentDto file1 = ComponentTesting.newFileDto(project);\n    ComponentDto file2 = ComponentTesting.newFileDto(module);\n    ComponentDto file3 = ComponentTesting.newFileDto(subModule);\n    tester.get(ComponentDao.class).insert(session, module, subModule, file1, file2, file3);\n\n    db.issueDao().insert(session,\n      IssueTesting.newDto(rule, project, project),\n      IssueTesting.newDto(rule, file1, project),\n      IssueTesting.newDto(rule, module, project),\n      IssueTesting.newDto(rule, file2, project),\n      IssueTesting.newDto(rule, subModule, project),\n      IssueTesting.newDto(rule, file3, project));\n    session.commit();\n    index();\n\n    assertThat(index.search(IssueQuery.builder().projectUuids(newArrayList(project.uuid())).build(), new QueryContext()).getHits()).hasSize(6);\n    assertThat(index.search(IssueQuery.builder().projectUuids(newArrayList(project.uuid())).onComponentOnly(true).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().projectUuids(newArrayList(\"unknown\")).build(), new QueryContext()).getHits()).isEmpty();\n  }","id":6807,"modified_method":"@Test\n  public void filter_by_projects() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto module = ComponentTesting.newModuleDto(project);\n    ComponentDto subModule = ComponentTesting.newModuleDto(module);\n\n    indexIssues(\n      IssueTesting.newDoc(\"ISSUE1\", project),\n      IssueTesting.newDoc(\"ISSUE2\", ComponentTesting.newFileDto(project)),\n      IssueTesting.newDoc(\"ISSUE3\", module),\n      IssueTesting.newDoc(\"ISSUE4\", ComponentTesting.newFileDto(module)),\n      IssueTesting.newDoc(\"ISSUE5\", subModule),\n      IssueTesting.newDoc(\"ISSUE6\", ComponentTesting.newFileDto(subModule)));\n\n    assertThat(index.search(IssueQuery.builder().projectUuids(newArrayList(project.uuid())).build(), new QueryContext()).getHits()).hasSize(6);\n    assertThat(index.search(IssueQuery.builder().projectUuids(newArrayList(project.uuid())).onComponentOnly(true).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().projectUuids(newArrayList(\"unknown\")).build(), new QueryContext()).getHits()).isEmpty();\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void filter_by_action_plans() throws Exception {\n    db.issueDao().insert(session,\n      IssueTesting.newDto(rule, file, project).setActionPlanKey(\"plan1\"),\n      IssueTesting.newDto(rule, file, project).setActionPlanKey(\"plan2\"));\n    session.commit();\n    index();\n\n    assertThat(index.search(IssueQuery.builder().actionPlans(newArrayList(\"plan1\")).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().actionPlans(newArrayList(\"plan1\", \"plan2\")).build(), new QueryContext()).getHits()).hasSize(2);\n    assertThat(index.search(IssueQuery.builder().actionPlans(newArrayList(\"unknown\")).build(), new QueryContext()).getHits()).isEmpty();\n  }","id":6808,"modified_method":"@Test\n  public void filter_by_action_plans() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto file = ComponentTesting.newFileDto(project);\n\n    indexIssues(\n      IssueTesting.newDoc(\"ISSUE1\", file).setActionPlanKey(\"plan1\"),\n      IssueTesting.newDoc(\"ISSUE2\", file).setActionPlanKey(\"plan2\"));\n\n    assertThat(index.search(IssueQuery.builder().actionPlans(newArrayList(\"plan1\")).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().actionPlans(newArrayList(\"plan1\", \"plan2\")).build(), new\n      QueryContext()).getHits()).hasSize(2);\n    assertThat(index.search(IssueQuery.builder().actionPlans(newArrayList(\"unknown\")).build(), new QueryContext()).getHits()).isEmpty();\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Before\n  public void setUp() throws Exception {\n    tester.clearDbAndIndexes();\n    db = tester.get(DbClient.class);\n    session = db.openSession(false);\n    index = tester.get(IssueIndex.class);\n\n    tester.get(RuleDao.class).insert(session, rule);\n    tester.get(ComponentDao.class).insert(session, project);\n    file = ComponentTesting.newFileDto(project, \"F1\").setPath(\"src/main/xoo/org/sonar/samples/File.xoo\");\n    file2 = ComponentTesting.newFileDto(project, \"F2\").setPath(\"src/main/xoo/org/sonar/samples/File2.xoo\");\n    tester.get(ComponentDao.class).insert(session, file, file2);\n    session.commit();\n\n    // project can be seen by anyone\n    MockUserSession.set().setLogin(\"admin\").setGlobalPermissions(GlobalPermissions.SYSTEM_ADMIN);\n    tester.get(InternalPermissionService.class).addPermission(new PermissionChange().setComponentKey(project.getKey()).setGroup(DefaultGroups.ANYONE).setPermission(UserRole.USER));\n\n    MockUserSession.set();\n\n    session.commit();\n    session.clearCache();\n  }","id":6809,"modified_method":"@Before\n  public void setUp() throws Exception {\n    tester.clearIndexes();\n    index = tester.get(IssueIndex.class);\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void sort_by_status() throws Exception {\n    db.issueDao().insert(session,\n      IssueTesting.newDto(rule, file, project).setStatus(Issue.STATUS_OPEN),\n      IssueTesting.newDto(rule, file, project).setStatus(Issue.STATUS_CLOSED),\n      IssueTesting.newDto(rule, file, project).setStatus(Issue.STATUS_REOPENED)\n      );\n    session.commit();\n    index();\n\n    IssueQuery.Builder query = IssueQuery.builder().sort(IssueQuery.SORT_BY_STATUS).asc(true);\n    Result<Issue> result = index.search(query.build(), new QueryContext());\n    assertThat(result.getHits().get(0).status()).isEqualTo(Issue.STATUS_CLOSED);\n    assertThat(result.getHits().get(1).status()).isEqualTo(Issue.STATUS_OPEN);\n    assertThat(result.getHits().get(2).status()).isEqualTo(Issue.STATUS_REOPENED);\n\n    query = IssueQuery.builder().sort(IssueQuery.SORT_BY_STATUS).asc(false);\n    result = index.search(query.build(), new QueryContext());\n    assertThat(result.getHits().get(0).status()).isEqualTo(Issue.STATUS_REOPENED);\n    assertThat(result.getHits().get(1).status()).isEqualTo(Issue.STATUS_OPEN);\n    assertThat(result.getHits().get(2).status()).isEqualTo(Issue.STATUS_CLOSED);\n  }","id":6810,"modified_method":"@Test\n  public void sort_by_status() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto file = ComponentTesting.newFileDto(project);\n\n    indexIssues(\n      IssueTesting.newDoc(\"ISSUE1\", file).setStatus(Issue.STATUS_OPEN),\n      IssueTesting.newDoc(\"ISSUE2\", file).setStatus(Issue.STATUS_CLOSED),\n      IssueTesting.newDoc(\"ISSUE3\", file).setStatus(Issue.STATUS_REOPENED));\n\n    IssueQuery.Builder query = IssueQuery.builder().sort(IssueQuery.SORT_BY_STATUS).asc(true);\n    Result<Issue> result = index.search(query.build(), new QueryContext());\n    assertThat(result.getHits().get(0).status()).isEqualTo(Issue.STATUS_CLOSED);\n    assertThat(result.getHits().get(1).status()).isEqualTo(Issue.STATUS_OPEN);\n    assertThat(result.getHits().get(2).status()).isEqualTo(Issue.STATUS_REOPENED);\n\n    query = IssueQuery.builder().sort(IssueQuery.SORT_BY_STATUS).asc(false);\n    result = index.search(query.build(), new QueryContext());\n    assertThat(result.getHits().get(0).status()).isEqualTo(Issue.STATUS_REOPENED);\n    assertThat(result.getHits().get(1).status()).isEqualTo(Issue.STATUS_OPEN);\n    assertThat(result.getHits().get(2).status()).isEqualTo(Issue.STATUS_CLOSED);\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void get_by_key() throws Exception {\n    IssueDoc issue = IssueTesting.newDoc();\n    issue.setKey(\"ABC\");\n    issue.setProjectUuid(project.uuid());\n    tester.get(IssueIndexer.class).index(Iterators.singletonIterator(issue));\n\n    Issue loaded = index.getByKey(issue.key());\n    assertThat(loaded).isNotNull();\n\n  }","id":6811,"modified_method":"@Test\n  public void get_by_key() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto file = ComponentTesting.newFileDto(project);\n    IssueDoc issue = IssueTesting.newDoc(\"ISSUE1\", file);\n    indexIssues(issue);\n\n    Issue loaded = index.getByKey(issue.key());\n    assertThat(loaded).isNotNull();\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void sort_by_assignee() throws Exception {\n    db.issueDao().insert(session,\n      IssueTesting.newDto(rule, file, project).setAssignee(\"steph\"),\n      IssueTesting.newDto(rule, file, project).setAssignee(\"simon\"));\n    session.commit();\n    index();\n\n    IssueQuery.Builder query = IssueQuery.builder().sort(IssueQuery.SORT_BY_ASSIGNEE).asc(true);\n    Result<Issue> result = index.search(query.build(), new QueryContext());\n    assertThat(result.getHits()).hasSize(2);\n    assertThat(result.getHits().get(0).assignee()).isEqualTo(\"simon\");\n    assertThat(result.getHits().get(1).assignee()).isEqualTo(\"steph\");\n\n    query = IssueQuery.builder().sort(IssueQuery.SORT_BY_ASSIGNEE).asc(false);\n    result = index.search(query.build(), new QueryContext());\n    assertThat(result.getHits()).hasSize(2);\n    assertThat(result.getHits().get(0).assignee()).isEqualTo(\"steph\");\n    assertThat(result.getHits().get(1).assignee()).isEqualTo(\"simon\");\n  }","id":6812,"modified_method":"@Test\n  public void sort_by_assignee() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto file = ComponentTesting.newFileDto(project);\n\n    indexIssues(\n      IssueTesting.newDoc(\"ISSUE1\", file).setAssignee(\"steph\"),\n      IssueTesting.newDoc(\"ISSUE2\", file).setAssignee(\"simon\"));\n\n    IssueQuery.Builder query = IssueQuery.builder().sort(IssueQuery.SORT_BY_ASSIGNEE).asc(true);\n    Result<Issue> result = index.search(query.build(), new QueryContext());\n    assertThat(result.getHits()).hasSize(2);\n    assertThat(result.getHits().get(0).assignee()).isEqualTo(\"simon\");\n    assertThat(result.getHits().get(1).assignee()).isEqualTo(\"steph\");\n\n    query = IssueQuery.builder().sort(IssueQuery.SORT_BY_ASSIGNEE).asc(false);\n    result = index.search(query.build(), new QueryContext());\n    assertThat(result.getHits()).hasSize(2);\n    assertThat(result.getHits().get(0).assignee()).isEqualTo(\"steph\");\n    assertThat(result.getHits().get(1).assignee()).isEqualTo(\"simon\");\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void sort_by_close_date() throws Exception {\n    db.issueDao().insert(session,\n      IssueTesting.newDto(rule, file, project).setIssueCloseDate(DateUtils.parseDate(\"2014-09-23\")),\n      IssueTesting.newDto(rule, file, project).setIssueCloseDate(DateUtils.parseDate(\"2014-09-24\")),\n      IssueTesting.newDto(rule, file, project).setIssueCloseDate(null));\n    session.commit();\n    index();\n\n    IssueQuery.Builder query = IssueQuery.builder().sort(IssueQuery.SORT_BY_CLOSE_DATE).asc(true);\n    Result<Issue> result = index.search(query.build(), new QueryContext());\n    assertThat(result.getHits()).hasSize(3);\n    assertThat(result.getHits().get(0).closeDate()).isNull();\n    assertThat(result.getHits().get(1).closeDate()).isEqualTo(DateUtils.parseDate(\"2014-09-23\"));\n    assertThat(result.getHits().get(2).closeDate()).isEqualTo(DateUtils.parseDate(\"2014-09-24\"));\n\n    query = IssueQuery.builder().sort(IssueQuery.SORT_BY_CLOSE_DATE).asc(false);\n    result = index.search(query.build(), new QueryContext());\n    assertThat(result.getHits()).hasSize(3);\n    assertThat(result.getHits().get(0).closeDate()).isEqualTo(DateUtils.parseDate(\"2014-09-24\"));\n    assertThat(result.getHits().get(1).closeDate()).isEqualTo(DateUtils.parseDate(\"2014-09-23\"));\n    assertThat(result.getHits().get(2).closeDate()).isNull();\n  }","id":6813,"modified_method":"@Test\n  public void sort_by_close_date() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto file = ComponentTesting.newFileDto(project);\n\n    indexIssues(\n      IssueTesting.newDoc(\"ISSUE1\", file).setFuncCloseDate(DateUtils.parseDate(\"2014-09-23\")),\n      IssueTesting.newDoc(\"ISSUE2\", file).setFuncCloseDate(DateUtils.parseDate(\"2014-09-24\")),\n      IssueTesting.newDoc(\"ISSUE3\", file).setFuncCloseDate(null));\n\n    IssueQuery.Builder query = IssueQuery.builder().sort(IssueQuery.SORT_BY_CLOSE_DATE).asc(true);\n    Result<Issue> result = index.search(query.build(), new QueryContext());\n    assertThat(result.getHits()).hasSize(3);\n    assertThat(result.getHits().get(0).closeDate()).isNull();\n    assertThat(result.getHits().get(1).closeDate()).isEqualTo(DateUtils.parseDate(\"2014-09-23\"));\n    assertThat(result.getHits().get(2).closeDate()).isEqualTo(DateUtils.parseDate(\"2014-09-24\"));\n\n    query = IssueQuery.builder().sort(IssueQuery.SORT_BY_CLOSE_DATE).asc(false);\n    result = index.search(query.build(), new QueryContext());\n    assertThat(result.getHits()).hasSize(3);\n    assertThat(result.getHits().get(0).closeDate()).isEqualTo(DateUtils.parseDate(\"2014-09-24\"));\n    assertThat(result.getHits().get(1).closeDate()).isEqualTo(DateUtils.parseDate(\"2014-09-23\"));\n    assertThat(result.getHits().get(2).closeDate()).isNull();\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void authorized_issues_on_user() throws Exception {\n    ComponentDto project1 = ComponentTesting.newProjectDto().setKey(\"project1\");\n    ComponentDto project2 = ComponentTesting.newProjectDto().setKey(\"project2\");\n    ComponentDto project3 = ComponentTesting.newProjectDto().setKey(\"project3\");\n\n    ComponentDto file1 = ComponentTesting.newFileDto(project1).setKey(\"file1\");\n    ComponentDto file2 = ComponentTesting.newFileDto(project1).setKey(\"file2\");\n    ComponentDto file3 = ComponentTesting.newFileDto(project1).setKey(\"file3\");\n\n    tester.get(ComponentDao.class).insert(session, project1, project2, project3, file1, file2, file3);\n\n    // project1 can be seen by john and project2 by max. project3 cannot be seen by anyone\n    UserDto john = new UserDto().setLogin(\"john\").setName(\"john\").setActive(true);\n    UserDto max = new UserDto().setLogin(\"max\").setName(\"max\").setActive(true);\n    db.userDao().insert(session, max);\n    db.userDao().insert(session, john);\n    session.commit();\n\n    MockUserSession.set().setLogin(\"admin\").setGlobalPermissions(GlobalPermissions.SYSTEM_ADMIN);\n    tester.get(InternalPermissionService.class).addPermission(new PermissionChange().setComponentKey(project1.getKey()).setUser(john.getLogin()).setPermission(UserRole.USER));\n    tester.get(InternalPermissionService.class).addPermission(new PermissionChange().setComponentKey(project2.getKey()).setUser(max.getLogin()).setPermission(UserRole.USER));\n\n    db.issueDao().insert(session,\n      IssueTesting.newDto(rule, file1, project1),\n      IssueTesting.newDto(rule, file2, project2),\n      IssueTesting.newDto(rule, file2, project3)\n      );\n\n    session.commit();\n    session.clearCache();\n    index();\n\n    IssueQuery.Builder query = IssueQuery.builder();\n\n    MockUserSession.set().setLogin(\"john\");\n    assertThat(index.search(query.build(), new QueryContext()).getHits()).hasSize(1);\n\n    MockUserSession.set().setLogin(\"max\");\n    assertThat(index.search(query.build(), new QueryContext()).getHits()).hasSize(1);\n\n    MockUserSession.set().setLogin(\"another guy\");\n    assertThat(index.search(query.build(), new QueryContext()).getHits()).hasSize(0);\n\n    MockUserSession.set().setLogin(\"john\");\n    assertThat(index.search(query.moduleUuids(newArrayList(project3.key())).build(), new QueryContext()).getHits()).hasSize(0);\n  }","id":6814,"modified_method":"@Test\n  public void authorized_issues_on_user() throws Exception {\n    ComponentDto project1 = ComponentTesting.newProjectDto().setKey(\"project1\");\n    ComponentDto project2 = ComponentTesting.newProjectDto().setKey(\"project2\");\n    ComponentDto project3 = ComponentTesting.newProjectDto().setKey(\"project3\");\n\n    ComponentDto file1 = ComponentTesting.newFileDto(project1).setKey(\"file1\");\n    ComponentDto file2 = ComponentTesting.newFileDto(project2).setKey(\"file2\");\n    ComponentDto file3 = ComponentTesting.newFileDto(project3).setKey(\"file3\");\n\n    // project1 can be seen by john, project2 by max, project3 cannot be seen by anyone\n    indexIssue(IssueTesting.newDoc(\"ISSUE1\", file1), null, \"john\");\n    indexIssue(IssueTesting.newDoc(\"ISSUE2\", file2), null, \"max\");\n    indexIssue(IssueTesting.newDoc(\"ISSUE3\", file3), null, null);\n\n    IssueQuery.Builder query = IssueQuery.builder();\n\n    MockUserSession.set().setLogin(\"john\");\n    assertThat(index.search(query.build(), new QueryContext()).getHits()).hasSize(1);\n\n    MockUserSession.set().setLogin(\"max\");\n    assertThat(index.search(query.build(), new QueryContext()).getHits()).hasSize(1);\n\n    MockUserSession.set().setLogin(\"another guy\");\n    assertThat(index.search(query.build(), new QueryContext()).getHits()).hasSize(0);\n\n    MockUserSession.set().setLogin(\"john\");\n    assertThat(index.search(query.moduleUuids(newArrayList(project3.key())).build(), new QueryContext()).getHits()).hasSize(0);\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void filter_by_reporters() throws Exception {\n    db.issueDao().insert(session,\n      IssueTesting.newDto(rule, file, project).setReporter(\"fabrice\"),\n      IssueTesting.newDto(rule, file, project).setReporter(\"stephane\"));\n    session.commit();\n    index();\n\n    assertThat(index.search(IssueQuery.builder().reporters(newArrayList(\"fabrice\", \"stephane\")).build(), new QueryContext()).getHits()).hasSize(2);\n    assertThat(index.search(IssueQuery.builder().reporters(newArrayList(\"fabrice\")).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().reporters(newArrayList(\"unknown\")).build(), new QueryContext()).getHits()).isEmpty();\n  }","id":6815,"modified_method":"@Test\n  public void filter_by_reporters() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto file = ComponentTesting.newFileDto(project);\n\n    indexIssues(\n      IssueTesting.newDoc(\"ISSUE1\", file).setReporter(\"fabrice\"),\n      IssueTesting.newDoc(\"ISSUE2\", file).setReporter(\"stephane\"));\n\n    assertThat(index.search(IssueQuery.builder().reporters(newArrayList(\"fabrice\", \"stephane\")).build(), new QueryContext()).getHits()).hasSize(2);\n    assertThat(index.search(IssueQuery.builder().reporters(newArrayList(\"fabrice\")).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().reporters(newArrayList(\"unknown\")).build(), new QueryContext()).getHits()).isEmpty();\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void sort_by_severity() throws Exception {\n    db.issueDao().insert(session,\n      IssueTesting.newDto(rule, file, project).setSeverity(Severity.BLOCKER),\n      IssueTesting.newDto(rule, file, project).setSeverity(Severity.INFO),\n      IssueTesting.newDto(rule, file, project).setSeverity(Severity.MINOR),\n      IssueTesting.newDto(rule, file, project).setSeverity(Severity.CRITICAL),\n      IssueTesting.newDto(rule, file, project).setSeverity(Severity.MAJOR)\n      );\n    session.commit();\n    index();\n\n    IssueQuery.Builder query = IssueQuery.builder().sort(IssueQuery.SORT_BY_SEVERITY).asc(true);\n    Result<Issue> result = index.search(query.build(), new QueryContext());\n    assertThat(result.getHits().get(0).severity()).isEqualTo(Severity.INFO);\n    assertThat(result.getHits().get(1).severity()).isEqualTo(Severity.MINOR);\n    assertThat(result.getHits().get(2).severity()).isEqualTo(Severity.MAJOR);\n    assertThat(result.getHits().get(3).severity()).isEqualTo(Severity.CRITICAL);\n    assertThat(result.getHits().get(4).severity()).isEqualTo(Severity.BLOCKER);\n\n    query = IssueQuery.builder().sort(IssueQuery.SORT_BY_SEVERITY).asc(false);\n    result = index.search(query.build(), new QueryContext());\n    assertThat(result.getHits().get(0).severity()).isEqualTo(Severity.BLOCKER);\n    assertThat(result.getHits().get(1).severity()).isEqualTo(Severity.CRITICAL);\n    assertThat(result.getHits().get(2).severity()).isEqualTo(Severity.MAJOR);\n    assertThat(result.getHits().get(3).severity()).isEqualTo(Severity.MINOR);\n    assertThat(result.getHits().get(4).severity()).isEqualTo(Severity.INFO);\n  }","id":6816,"modified_method":"@Test\n  public void sort_by_severity() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto file = ComponentTesting.newFileDto(project);\n\n    indexIssues(\n      IssueTesting.newDoc(\"ISSUE1\", file).setSeverity(Severity.BLOCKER),\n      IssueTesting.newDoc(\"ISSUE2\", file).setSeverity(Severity.INFO),\n      IssueTesting.newDoc(\"ISSUE3\", file).setSeverity(Severity.MINOR),\n      IssueTesting.newDoc(\"ISSUE4\", file).setSeverity(Severity.CRITICAL),\n      IssueTesting.newDoc(\"ISSUE5\", file).setSeverity(Severity.MAJOR));\n\n    IssueQuery.Builder query = IssueQuery.builder().sort(IssueQuery.SORT_BY_SEVERITY).asc(true);\n    Result<Issue> result = index.search(query.build(), new QueryContext());\n    assertThat(result.getHits().get(0).severity()).isEqualTo(Severity.INFO);\n    assertThat(result.getHits().get(1).severity()).isEqualTo(Severity.MINOR);\n    assertThat(result.getHits().get(2).severity()).isEqualTo(Severity.MAJOR);\n    assertThat(result.getHits().get(3).severity()).isEqualTo(Severity.CRITICAL);\n    assertThat(result.getHits().get(4).severity()).isEqualTo(Severity.BLOCKER);\n\n    query = IssueQuery.builder().sort(IssueQuery.SORT_BY_SEVERITY).asc(false);\n    result = index.search(query.build(), new QueryContext());\n    assertThat(result.getHits().get(0).severity()).isEqualTo(Severity.BLOCKER);\n    assertThat(result.getHits().get(1).severity()).isEqualTo(Severity.CRITICAL);\n    assertThat(result.getHits().get(2).severity()).isEqualTo(Severity.MAJOR);\n    assertThat(result.getHits().get(3).severity()).isEqualTo(Severity.MINOR);\n    assertThat(result.getHits().get(4).severity()).isEqualTo(Severity.INFO);\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void filter_by_severities() throws Exception {\n    db.issueDao().insert(session,\n      IssueTesting.newDto(rule, file, project).setSeverity(Severity.INFO),\n      IssueTesting.newDto(rule, file, project).setSeverity(Severity.MAJOR));\n    session.commit();\n    index();\n\n    assertThat(index.search(IssueQuery.builder().severities(newArrayList(Severity.INFO, Severity.MAJOR)).build(), new QueryContext()).getHits()).hasSize(2);\n    assertThat(index.search(IssueQuery.builder().severities(newArrayList(Severity.INFO)).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().severities(newArrayList(Severity.BLOCKER)).build(), new QueryContext()).getHits()).isEmpty();\n  }","id":6817,"modified_method":"@Test\n  public void filter_by_severities() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto file = ComponentTesting.newFileDto(project);\n\n    indexIssues(\n      IssueTesting.newDoc(\"ISSUE1\", file).setSeverity(Severity.INFO),\n      IssueTesting.newDoc(\"ISSUE2\", file).setSeverity(Severity.MAJOR));\n\n    assertThat(index.search(IssueQuery.builder().severities(newArrayList(Severity.INFO, Severity.MAJOR)).build(), new QueryContext()).getHits()).hasSize(2);\n    assertThat(index.search(IssueQuery.builder().severities(newArrayList(Severity.INFO)).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().severities(newArrayList(Severity.BLOCKER)).build(), new QueryContext()).getHits()).isEmpty();\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void filter_by_keys() throws Exception {\n    db.issueDao().insert(session,\n      IssueTesting.newDto(rule, file, project).setKee(\"1\"),\n      IssueTesting.newDto(rule, file, project).setKee(\"2\"));\n    session.commit();\n    index();\n\n    assertThat(index.search(IssueQuery.builder().issueKeys(newArrayList(\"1\", \"2\")).build(), new QueryContext()).getHits()).hasSize(2);\n    assertThat(index.search(IssueQuery.builder().issueKeys(newArrayList(\"1\")).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().issueKeys(newArrayList(\"3\", \"4\")).build(), new QueryContext()).getHits()).isEmpty();\n  }","id":6818,"modified_method":"@Test\n  public void filter_by_keys() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n\n    indexIssues(\n      IssueTesting.newDoc(\"1\", ComponentTesting.newFileDto(project)),\n      IssueTesting.newDoc(\"2\", ComponentTesting.newFileDto(project)));\n\n    assertThat(index.search(IssueQuery.builder().issueKeys(newArrayList(\"1\", \"2\")).build(), new QueryContext()).getHits()).hasSize(2);\n    assertThat(index.search(IssueQuery.builder().issueKeys(newArrayList(\"1\")).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().issueKeys(newArrayList(\"3\", \"4\")).build(), new QueryContext()).getHits()).isEmpty();\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void authorized_issues_on_groups() throws Exception {\n    ComponentDto project1 = ComponentTesting.newProjectDto().setKey(\"project1\");\n    ComponentDto project2 = ComponentTesting.newProjectDto().setKey(\"project2\");\n    ComponentDto project3 = ComponentTesting.newProjectDto().setKey(\"project3\");\n\n    ComponentDto file1 = ComponentTesting.newFileDto(project1).setKey(\"file1\");\n    ComponentDto file2 = ComponentTesting.newFileDto(project1).setKey(\"file2\");\n    ComponentDto file3 = ComponentTesting.newFileDto(project1).setKey(\"file3\");\n\n    tester.get(ComponentDao.class).insert(session, project1, project2, project3, file1, file2, file3);\n\n    // project1 can be seen by sonar-users\n    // project2 can be seen by sonar-admins\n    // project3 cannot be seen by anyone\n    GroupDto userGroup = new GroupDto().setName(\"sonar-users\");\n    db.groupDao().insert(session, userGroup);\n    GroupDto adminGroup = new GroupDto().setName(\"sonar-admins\");\n    db.groupDao().insert(session, adminGroup);\n    session.commit();\n    MockUserSession.set().setLogin(\"admin\").setGlobalPermissions(GlobalPermissions.SYSTEM_ADMIN);\n    tester.get(InternalPermissionService.class).addPermission(new PermissionChange().setComponentKey(project1.getKey()).setGroup(userGroup.getName()).setPermission(UserRole.USER));\n    tester.get(InternalPermissionService.class)\n      .addPermission(new PermissionChange().setComponentKey(project2.getKey()).setGroup(adminGroup.getName()).setPermission(UserRole.USER));\n    db.issueDao().insert(session,\n      IssueTesting.newDto(rule, file1, project1),\n      IssueTesting.newDto(rule, file2, project2),\n      IssueTesting.newDto(rule, file3, project3));\n\n    session.commit();\n    session.clearCache();\n    index();\n\n    IssueQuery.Builder query = IssueQuery.builder();\n\n    MockUserSession.set().setUserGroups(\"sonar-users\");\n    assertThat(index.search(query.build(), new QueryContext()).getHits()).hasSize(1);\n\n    MockUserSession.set().setUserGroups(\"sonar-admins\");\n    assertThat(index.search(query.build(), new QueryContext()).getHits()).hasSize(1);\n\n    MockUserSession.set().setUserGroups(\"sonar-users\", \"sonar-admins\");\n    assertThat(index.search(query.build(), new QueryContext()).getHits()).hasSize(2);\n\n    MockUserSession.set().setUserGroups(\"another group\");\n    assertThat(index.search(query.build(), new QueryContext()).getHits()).hasSize(0);\n\n    MockUserSession.set().setUserGroups(\"sonar-users\", \"sonar-admins\");\n    assertThat(index.search(query.moduleUuids(newArrayList(project3.key())).build(), new QueryContext()).getHits()).hasSize(0);\n  }","id":6819,"modified_method":"@Test\n  public void authorized_issues_on_groups() throws Exception {\n    ComponentDto project1 = ComponentTesting.newProjectDto().setKey(\"project1\");\n    ComponentDto project2 = ComponentTesting.newProjectDto().setKey(\"project2\");\n    ComponentDto project3 = ComponentTesting.newProjectDto().setKey(\"project3\");\n\n    ComponentDto file1 = ComponentTesting.newFileDto(project1).setKey(\"file1\");\n    ComponentDto file2 = ComponentTesting.newFileDto(project2).setKey(\"file2\");\n    ComponentDto file3 = ComponentTesting.newFileDto(project3).setKey(\"file3\");\n\n    // project1 can be seen by sonar-users\n    indexIssue(IssueTesting.newDoc(\"ISSUE1\", file1), \"sonar-users\", null);\n    // project2 can be seen by sonar-admins\n    indexIssue(IssueTesting.newDoc(\"ISSUE2\", file2), \"sonar-admins\", null);\n    // project3 cannot be seen by anyone\n    indexIssue(IssueTesting.newDoc(\"ISSUE3\", file3), null, null);\n\n    IssueQuery.Builder query = IssueQuery.builder();\n\n    MockUserSession.set().setUserGroups(\"sonar-users\");\n    assertThat(index.search(query.build(), new QueryContext()).getHits()).hasSize(1);\n\n    MockUserSession.set().setUserGroups(\"sonar-admins\");\n    assertThat(index.search(query.build(), new QueryContext()).getHits()).hasSize(1);\n\n    MockUserSession.set().setUserGroups(\"sonar-users\", \"sonar-admins\");\n    assertThat(index.search(query.build(), new QueryContext()).getHits()).hasSize(2);\n\n    MockUserSession.set().setUserGroups(\"another group\");\n    assertThat(index.search(query.build(), new QueryContext()).getHits()).hasSize(0);\n\n    MockUserSession.set().setUserGroups(\"sonar-users\", \"sonar-admins\");\n    assertThat(index.search(query.moduleUuids(newArrayList(project3.key())).build(), new QueryContext()).getHits()).hasSize(0);\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void get_by_key_with_attributes() throws Exception {\n    IssueDto issue = IssueTesting.newDto(rule, file, project);\n    issue.setIssueAttributes(KeyValueFormat.format(ImmutableMap.of(\"jira-issue-key\", \"SONAR-1234\")));\n    db.issueDao().insert(session, issue);\n    session.commit();\n    index();\n\n    Issue result = index.getByKey(issue.getKey());\n    IssueTesting.assertIsEquivalent(issue, (IssueDoc) result);\n    assertThat(result.attribute(\"jira-issue-key\")).isEqualTo(\"SONAR-1234\");\n  }","id":6820,"modified_method":"@Test\n  public void get_by_key_with_attributes() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto file = ComponentTesting.newFileDto(project);\n    IssueDoc issue = IssueTesting.newDoc(\"ISSUE1\", file).setAttributes((KeyValueFormat.format(ImmutableMap.of(\"jira-issue-key\", \"SONAR-1234\"))));\n    indexIssues(issue);\n\n    Issue result = index.getByKey(issue.key());\n    assertThat(result.attribute(\"jira-issue-key\")).isEqualTo(\"SONAR-1234\");\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void filter_by_assigned() throws Exception {\n    db.issueDao().insert(session,\n      IssueTesting.newDto(rule, file, project).setAssignee(\"steph\"),\n      IssueTesting.newDto(rule, file, project).setAssignee(null),\n      IssueTesting.newDto(rule, file, project).setAssignee(null));\n    session.commit();\n    index();\n\n    assertThat(index.search(IssueQuery.builder().assigned(true).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().assigned(false).build(), new QueryContext()).getHits()).hasSize(2);\n    assertThat(index.search(IssueQuery.builder().assigned(null).build(), new QueryContext()).getHits()).hasSize(3);\n  }","id":6821,"modified_method":"@Test\n  public void filter_by_assigned() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto file = ComponentTesting.newFileDto(project);\n\n    indexIssues(\n      IssueTesting.newDoc(\"ISSUE1\", file).setAssignee(\"steph\"),\n      IssueTesting.newDoc(\"ISSUE2\", file).setAssignee(null),\n      IssueTesting.newDoc(\"ISSUE3\", file).setAssignee(null));\n\n    assertThat(index.search(IssueQuery.builder().assigned(true).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().assigned(false).build(), new QueryContext()).getHits()).hasSize(2);\n    assertThat(index.search(IssueQuery.builder().assigned(null).build(), new QueryContext()).getHits()).hasSize(3);\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void filter_by_statuses() throws Exception {\n    db.issueDao().insert(session,\n      IssueTesting.newDto(rule, file, project).setStatus(Issue.STATUS_CLOSED),\n      IssueTesting.newDto(rule, file, project).setStatus(Issue.STATUS_OPEN));\n    session.commit();\n    index();\n\n    assertThat(index.search(IssueQuery.builder().statuses(newArrayList(Issue.STATUS_CLOSED, Issue.STATUS_OPEN)).build(), new QueryContext()).getHits()).hasSize(2);\n    assertThat(index.search(IssueQuery.builder().statuses(newArrayList(Issue.STATUS_CLOSED)).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().statuses(newArrayList(Issue.STATUS_CONFIRMED)).build(), new QueryContext()).getHits()).isEmpty();\n  }","id":6822,"modified_method":"@Test\n  public void filter_by_statuses() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto file = ComponentTesting.newFileDto(project);\n\n    indexIssues(\n      IssueTesting.newDoc(\"ISSUE1\", file).setStatus(Issue.STATUS_CLOSED),\n      IssueTesting.newDoc(\"ISSUE2\", file).setStatus(Issue.STATUS_OPEN));\n\n    assertThat(index.search(IssueQuery.builder().statuses(newArrayList(Issue.STATUS_CLOSED, Issue.STATUS_OPEN)).build(), new QueryContext()).getHits()).hasSize(2);\n    assertThat(index.search(IssueQuery.builder().statuses(newArrayList(Issue.STATUS_CLOSED)).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().statuses(newArrayList(Issue.STATUS_CONFIRMED)).build(), new QueryContext()).getHits()).isEmpty();\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test(expected = IllegalStateException.class)\n  public void is_new_field_is_not_available() throws Exception {\n    IssueDto issue = IssueTesting.newDto(rule, file, project);\n    db.issueDao().insert(session, issue);\n    session.commit();\n    index();\n\n    Issue result = index.getByKey(issue.getKey());\n    result.isNew();\n  }","id":6823,"modified_method":"@Test(expected = IllegalStateException.class)\n  public void is_new_field_is_not_available() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto file = ComponentTesting.newFileDto(project);\n    IssueDoc issue = IssueTesting.newDoc(\"ISSUE1\", file);\n    indexIssues(issue);\n\n    Issue result = index.getByKey(issue.key());\n    result.isNew();\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void search_with_max_limit() throws Exception {\n    List<String> issueKeys = newArrayList();\n    for (int i = 0; i < 500; i++) {\n      IssueDto issue = IssueTesting.newDto(rule, file, project);\n      tester.get(IssueDao.class).insert(session, issue);\n      issueKeys.add(issue.getKey());\n    }\n    session.commit();\n    index();\n\n    IssueQuery.Builder query = IssueQuery.builder();\n    Result<Issue> result = index.search(query.build(), new QueryContext().setMaxLimit());\n    assertThat(result.getHits()).hasSize(500);\n  }","id":6824,"modified_method":"@Test\n  public void search_with_max_limit() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto file = ComponentTesting.newFileDto(project);\n    List<IssueDoc> issues = newArrayList();\n    for (int i = 0; i < 500; i++) {\n      String key = \"ISSUE\" + i;\n      issues.add(IssueTesting.newDoc(key, file));\n    }\n    indexIssues(issues.toArray(new IssueDoc[] {}));\n\n    IssueQuery.Builder query = IssueQuery.builder();\n    Result<Issue> result = index.search(query.build(), new QueryContext().setMaxLimit());\n    assertThat(result.getHits()).hasSize(500);\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void filter_by_modules() throws Exception {\n    ComponentDto module = ComponentTesting.newModuleDto(project);\n    ComponentDto subModule = ComponentTesting.newModuleDto(module);\n    ComponentDto file = ComponentTesting.newFileDto(subModule);\n    tester.get(ComponentDao.class).insert(session, module, subModule, file);\n\n    db.issueDao().insert(session,\n      IssueTesting.newDto(rule, module, project),\n      IssueTesting.newDto(rule, subModule, project),\n      IssueTesting.newDto(rule, file, project));\n    session.commit();\n    index();\n\n    assertThat(index.search(IssueQuery.builder().moduleUuids(newArrayList(file.uuid())).build(), new QueryContext()).getHits()).isEmpty();\n    assertThat(index.search(IssueQuery.builder().moduleUuids(newArrayList(module.uuid())).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().moduleUuids(newArrayList(subModule.uuid())).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().moduleUuids(newArrayList(project.uuid())).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().moduleUuids(newArrayList(\"unknown\")).build(), new QueryContext()).getHits()).isEmpty();\n  }","id":6825,"modified_method":"@Test\n  public void filter_by_modules() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto module = ComponentTesting.newModuleDto(project);\n    ComponentDto subModule = ComponentTesting.newModuleDto(module);\n    ComponentDto file = ComponentTesting.newFileDto(subModule);\n\n    indexIssues(\n      IssueTesting.newDoc(\"ISSUE3\", module),\n      IssueTesting.newDoc(\"ISSUE5\", subModule),\n      IssueTesting.newDoc(\"ISSUE2\", file));\n\n    assertThat(index.search(IssueQuery.builder().moduleUuids(newArrayList(file.uuid())).build(), new QueryContext()).getHits()).isEmpty();\n    assertThat(index.search(IssueQuery.builder().moduleUuids(newArrayList(module.uuid())).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().moduleUuids(newArrayList(subModule.uuid())).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().moduleUuids(newArrayList(project.uuid())).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().moduleUuids(newArrayList(\"unknown\")).build(), new QueryContext()).getHits()).isEmpty();\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void delete_closed_issues_from_one_project_older_than_specific_date() {\n    // ARRANGE\n    Date today = new Date();\n    Date yesterday = org.apache.commons.lang.time.DateUtils.addDays(today, -1);\n    Date beforeYesterday = org.apache.commons.lang.time.DateUtils.addDays(yesterday, -1);\n\n    tester.get(IssueDao.class).insert(session, IssueTesting.newDto(rule, file, project).setIssueCloseDate(today));\n    tester.get(IssueDao.class).insert(session, IssueTesting.newDto(rule, file, project).setIssueCloseDate(beforeYesterday));\n    tester.get(IssueDao.class).insert(session, IssueTesting.newDto(rule, file, project));\n    session.commit();\n    index();\n    assertThat(index.countAll()).isEqualTo(3L);\n\n    // ACT\n    index.deleteClosedIssuesOfProjectBefore(project.uuid(), yesterday);\n\n    // ASSERT\n    List<Issue> issues = index.search(IssueQuery.builder().projectUuids(newArrayList(project.uuid())).build(), new QueryContext()).getHits();\n    List<Date> dates = newArrayList();\n    for (Issue issue : issues) {\n      dates.add(issue.closeDate());\n    }\n\n    assertThat(index.countAll()).isEqualTo(2);\n    assertThat(dates).containsOnly(null, today);\n  }","id":6826,"modified_method":"@Test\n  public void delete_closed_issues_from_one_project_older_than_specific_date() {\n    // ARRANGE\n    Date today = new Date();\n    Date yesterday = org.apache.commons.lang.time.DateUtils.addDays(today, -1);\n    Date beforeYesterday = org.apache.commons.lang.time.DateUtils.addDays(yesterday, -1);\n\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto file = ComponentTesting.newFileDto(project);\n\n    indexIssues(\n      IssueTesting.newDoc(\"ISSUE1\", file).setFuncCloseDate(today),\n      IssueTesting.newDoc(\"ISSUE2\", file).setFuncCloseDate(beforeYesterday),\n      IssueTesting.newDoc(\"ISSUE3\", file).setFuncCloseDate(null));\n\n    // ACT\n    index.deleteClosedIssuesOfProjectBefore(project.uuid(), yesterday);\n\n    // ASSERT\n    List<Issue> issues = index.search(IssueQuery.builder().projectUuids(newArrayList(project.uuid())).build(), new QueryContext()).getHits();\n    List<Date> dates = newArrayList();\n    for (Issue issue : issues) {\n      dates.add(issue.closeDate());\n    }\n\n    assertThat(index.countAll()).isEqualTo(2);\n    assertThat(dates).containsOnly(null, today);\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void filter_by_created_after() throws Exception {\n    IssueDto issue1 = IssueTesting.newDto(rule, file, project).setIssueCreationDate(DateUtils.parseDate(\"2014-09-20\"));\n    IssueDto issue2 = IssueTesting.newDto(rule, file, project).setIssueCreationDate(DateUtils.parseDate(\"2014-09-23\"));\n    db.issueDao().insert(session, issue1, issue2);\n    session.commit();\n    index();\n\n    assertThat(index.search(IssueQuery.builder().createdAfter(DateUtils.parseDate(\"2014-09-19\")).build(), new QueryContext()).getHits()).hasSize(2);\n    assertThat(index.search(IssueQuery.builder().createdAfter(DateUtils.parseDate(\"2014-09-20\")).build(), new QueryContext()).getHits()).hasSize(2);\n    assertThat(index.search(IssueQuery.builder().createdAfter(DateUtils.parseDate(\"2014-09-21\")).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().createdAfter(DateUtils.parseDate(\"2014-09-25\")).build(), new QueryContext()).getHits()).isEmpty();\n  }","id":6827,"modified_method":"@Test\n  public void filter_by_created_after() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto file = ComponentTesting.newFileDto(project);\n\n    indexIssues(\n      IssueTesting.newDoc(\"ISSUE1\", file).setFuncCreationDate(DateUtils.parseDate(\"2014-09-20\")),\n      IssueTesting.newDoc(\"ISSUE2\", file).setFuncCreationDate(DateUtils.parseDate(\"2014-09-23\")));\n\n    assertThat(index.search(IssueQuery.builder().createdAfter(DateUtils.parseDate(\"2014-09-19\")).build(), new QueryContext()).getHits()).hasSize(2);\n    assertThat(index.search(IssueQuery.builder().createdAfter(DateUtils.parseDate(\"2014-09-20\")).build(), new QueryContext()).getHits()).hasSize(2);\n    assertThat(index.search(IssueQuery.builder().createdAfter(DateUtils.parseDate(\"2014-09-21\")).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().createdAfter(DateUtils.parseDate(\"2014-09-25\")).build(), new QueryContext()).getHits()).isEmpty();\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void sort_by_update_date() throws Exception {\n    db.issueDao().insert(session,\n      IssueTesting.newDto(rule, file, project).setIssueUpdateDate(DateUtils.parseDate(\"2014-09-23\")),\n      IssueTesting.newDto(rule, file, project).setIssueUpdateDate(DateUtils.parseDate(\"2014-09-24\")));\n    session.commit();\n    index();\n\n    IssueQuery.Builder query = IssueQuery.builder().sort(IssueQuery.SORT_BY_UPDATE_DATE).asc(true);\n    Result<Issue> result = index.search(query.build(), new QueryContext());\n    assertThat(result.getHits()).hasSize(2);\n    assertThat(result.getHits().get(0).updateDate()).isEqualTo(DateUtils.parseDate(\"2014-09-23\"));\n    assertThat(result.getHits().get(1).updateDate()).isEqualTo(DateUtils.parseDate(\"2014-09-24\"));\n\n    query = IssueQuery.builder().sort(IssueQuery.SORT_BY_UPDATE_DATE).asc(false);\n    result = index.search(query.build(), new QueryContext());\n    assertThat(result.getHits()).hasSize(2);\n    assertThat(result.getHits().get(0).updateDate()).isEqualTo(DateUtils.parseDate(\"2014-09-24\"));\n    assertThat(result.getHits().get(1).updateDate()).isEqualTo(DateUtils.parseDate(\"2014-09-23\"));\n  }","id":6828,"modified_method":"@Test\n  public void sort_by_update_date() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto file = ComponentTesting.newFileDto(project);\n\n    indexIssues(\n      IssueTesting.newDoc(\"ISSUE1\", file).setFuncUpdateDate(DateUtils.parseDate(\"2014-09-23\")),\n      IssueTesting.newDoc(\"ISSUE2\", file).setFuncUpdateDate(DateUtils.parseDate(\"2014-09-24\")));\n\n    IssueQuery.Builder query = IssueQuery.builder().sort(IssueQuery.SORT_BY_UPDATE_DATE).asc(true);\n    Result<Issue> result = index.search(query.build(), new QueryContext());\n    assertThat(result.getHits()).hasSize(2);\n    assertThat(result.getHits().get(0).updateDate()).isEqualTo(DateUtils.parseDate(\"2014-09-23\"));\n    assertThat(result.getHits().get(1).updateDate()).isEqualTo(DateUtils.parseDate(\"2014-09-24\"));\n\n    query = IssueQuery.builder().sort(IssueQuery.SORT_BY_UPDATE_DATE).asc(false);\n    result = index.search(query.build(), new QueryContext());\n    assertThat(result.getHits()).hasSize(2);\n    assertThat(result.getHits().get(0).updateDate()).isEqualTo(DateUtils.parseDate(\"2014-09-24\"));\n    assertThat(result.getHits().get(1).updateDate()).isEqualTo(DateUtils.parseDate(\"2014-09-23\"));\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void filter_by_created_at() throws Exception {\n    IssueDto issue = IssueTesting.newDto(rule, file, project).setIssueCreationDate(DateUtils.parseDate(\"2014-09-20\"));\n    db.issueDao().insert(session, issue);\n    session.commit();\n    index();\n\n    assertThat(index.search(IssueQuery.builder().createdAt(DateUtils.parseDate(\"2014-09-20\")).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().createdAt(DateUtils.parseDate(\"2014-09-21\")).build(), new QueryContext()).getHits()).isEmpty();\n  }","id":6829,"modified_method":"@Test\n  public void filter_by_created_at() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto();\n    ComponentDto file = ComponentTesting.newFileDto(project);\n\n    indexIssues(IssueTesting.newDoc(\"ISSUE1\", file).setFuncCreationDate(DateUtils.parseDate(\"2014-09-20\")));\n\n    assertThat(index.search(IssueQuery.builder().createdAt(DateUtils.parseDate(\"2014-09-20\")).build(), new QueryContext()).getHits()).hasSize(1);\n    assertThat(index.search(IssueQuery.builder().createdAt(DateUtils.parseDate(\"2014-09-21\")).build(), new QueryContext()).getHits()).isEmpty();\n  }","commit_id":"7555eb77293161ca13ef8abb84339af483b8135e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n\t * Add the item, if it (or an item of the same number) is not already present.\n\t * @return True if we added the item.\n\t */\n\tpublic synchronized boolean push(IntNumberedItem grabber, ObjectContainer container) {\n\t\tif(persistent)\n\t\t\tcontainer.activate(this, 1);\n\t\tint x = Arrays.binarySearch(data, new Integer(grabber.getNumber()), comparator);\n\t\tif(x >= 0) return false;\n\t\t// insertion point\n\t\tx = -x-1;\n\t\tpush(grabber, x, container);\n\t\treturn true;\n\t}","id":6830,"modified_method":"/**\n\t * Add the item, if it (or an item of the same number) is not already present.\n\t * @return True if we added the item.\n\t */\n\tpublic synchronized boolean push(IntNumberedItem grabber, ObjectContainer container) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(this, 1);\n\t\t\tfor(int i=0;i<length;i++)\n\t\t\t\tcontainer.activate(data[i], 1);\n\t\t}\n\t\tint x = Arrays.binarySearch(data, new Integer(grabber.getNumber()), comparator);\n\t\tif(x >= 0) return false;\n\t\t// insertion point\n\t\tx = -x-1;\n\t\tpush(grabber, x, container);\n\t\treturn true;\n\t}","commit_id":"fddea55a17e738662c6c736a5a15c9c35634d877","url":"https://github.com/freenet/fred"},{"original_method":"public synchronized void add(IntNumberedItem grabber, ObjectContainer container) {\n\t\tif(persistent)\n\t\t\tcontainer.activate(this, 1);\n\t\tint x = Arrays.binarySearch(data, new Integer(grabber.getNumber()), comparator);\n\t\tif(x >= 0) {\n\t\t\tif(grabber != data[x])\n\t\t\t\tthrow new IllegalArgumentException(); // already exists\n\t\t\telse return;\n\t\t}\n\t\t// insertion point\n\t\tx = -x-1;\n\t\tpush(grabber, x, container);\n\t}","id":6831,"modified_method":"public synchronized void add(IntNumberedItem grabber, ObjectContainer container) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(this, 1);\n\t\t\tfor(int i=0;i<length;i++)\n\t\t\t\tcontainer.activate(data[i], 1);\n\t\t}\n\t\tint x = Arrays.binarySearch(data, new Integer(grabber.getNumber()), comparator);\n\t\tif(x >= 0) {\n\t\t\tif(grabber != data[x])\n\t\t\t\tthrow new IllegalArgumentException(); // already exists\n\t\t\telse return;\n\t\t}\n\t\t// insertion point\n\t\tx = -x-1;\n\t\tpush(grabber, x, container);\n\t}","commit_id":"fddea55a17e738662c6c736a5a15c9c35634d877","url":"https://github.com/freenet/fred"},{"original_method":"public synchronized void remove(int item, ObjectContainer container) {\n\t\tif(persistent)\n\t\t\tcontainer.activate(this, 1);\n\t\tint x = Arrays.binarySearch(data, new Integer(item), comparator);\n\t\tif(x >= 0) {\n\t\t\tif(x < length-1)\n\t\t\t\tSystem.arraycopy(data, x+1, data, x, length-x-1);\n\t\t\tdata[--length] = null;\n\t\t}\n\t\tif((length*4 < data.length) && (length > MIN_SIZE)) {\n\t\t\tIntNumberedItem[] newData = new IntNumberedItem[Math.max(length*2, MIN_SIZE)];\n\t\t\tSystem.arraycopy(data, 0, newData, 0, length);\n\t\t\tdata = newData;\n\t\t}\n\t\tif(persistent) container.set(this);\n\t\tverify(container);\n\t}","id":6832,"modified_method":"public synchronized void remove(int item, ObjectContainer container) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(this, 1);\n\t\t\tfor(int i=0;i<length;i++)\n\t\t\t\tcontainer.activate(data[i], 1);\n\t\t}\n\t\tint x = Arrays.binarySearch(data, new Integer(item), comparator);\n\t\tif(x >= 0) {\n\t\t\tif(x < length-1)\n\t\t\t\tSystem.arraycopy(data, x+1, data, x, length-x-1);\n\t\t\tdata[--length] = null;\n\t\t}\n\t\tif((length*4 < data.length) && (length > MIN_SIZE)) {\n\t\t\tIntNumberedItem[] newData = new IntNumberedItem[Math.max(length*2, MIN_SIZE)];\n\t\t\tSystem.arraycopy(data, 0, newData, 0, length);\n\t\t\tdata = newData;\n\t\t}\n\t\tif(persistent) container.set(this);\n\t\tverify(container);\n\t}","commit_id":"fddea55a17e738662c6c736a5a15c9c35634d877","url":"https://github.com/freenet/fred"},{"original_method":"private synchronized void push(IntNumberedItem grabber, int x, ObjectContainer container) {\n\t\tif(persistent)\n\t\t\tcontainer.activate(this, 1);\n\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tif(logMINOR) Logger.minor(this, \"Insertion point: \"+x);\n\t\t// Move the data\n\t\tif(length == data.length) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Expanding from \"+length+\" to \"+length*2);\n\t\t\tIntNumberedItem[] newData = new IntNumberedItem[length*2];\n\t\t\tSystem.arraycopy(data, 0, newData, 0, data.length);\n\t\t\tdata = newData;\n\t\t}\n\t\tif(x < length)\n\t\t\tSystem.arraycopy(data, x, data, x+1, length-x);\n\t\tdata[x] = grabber;\n\t\tlength++;\n\t\tif(persistent)\n\t\t\tcontainer.set(this);\n\t\tverify(container);\n\t}","id":6833,"modified_method":"private synchronized void push(IntNumberedItem grabber, int x, ObjectContainer container) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(this, 1);\n\t\t\tfor(int i=0;i<length;i++)\n\t\t\t\tcontainer.activate(data[i], 1);\n\t\t}\n\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tif(logMINOR) Logger.minor(this, \"Insertion point: \"+x);\n\t\t// Move the data\n\t\tif(length == data.length) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Expanding from \"+length+\" to \"+length*2);\n\t\t\tIntNumberedItem[] newData = new IntNumberedItem[length*2];\n\t\t\tSystem.arraycopy(data, 0, newData, 0, data.length);\n\t\t\tdata = newData;\n\t\t}\n\t\tif(x < length)\n\t\t\tSystem.arraycopy(data, x, data, x+1, length-x);\n\t\tdata[x] = grabber;\n\t\tlength++;\n\t\tif(persistent)\n\t\t\tcontainer.set(this);\n\t\tverify(container);\n\t}","commit_id":"fddea55a17e738662c6c736a5a15c9c35634d877","url":"https://github.com/freenet/fred"},{"original_method":"private static String getConceptName(SConceptId conceptId) {\n    return ConceptRegistry.getInstance().getConceptDescriptor(conceptId).getConceptFqName();\n  }","id":6834,"modified_method":"private static String getConceptName(SConceptId conceptId) {\n    String result = ConceptRegistry.getInstance().getConceptDescriptor(conceptId).getConceptFqName();\n    if (result.equals(MetaIdFactory.INVALID_CONCEPT_NAME)) {\n      return null;\n    }\n    return result;\n  }","commit_id":"3e0f80f52de8b804c436e1d30c4249b433003a71","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void getDebugInfoById(Iterable<SNode> rootNodes, Map<SConceptId, String> conceptIds, Map<SPropertyId, String> propIds,\n      Map<SReferenceLinkId, String> refIds, Map<SContainmentLinkId, String> linkIds) {\n    for (SNode root : rootNodes) {\n      for (SNode n : SNodeUtil.getDescendants(root)) {\n        SConceptId conceptId = IdHelper.getConceptId(n.getConcept());\n        if (conceptId != null) {\n          conceptIds.put(conceptId, n.getConcept().getQualifiedName());\n        }\n\n        if (n.getParent() != null) {\n          SContainmentLink link = n.getContainmentLink();\n          SContainmentLinkId linkId = IdHelper.getLinkId(link);\n          linkIds.put(linkId, link.getRoleName());\n          SConceptId linkConceptId = linkId.getConceptId();\n          if (!conceptIds.containsKey(linkConceptId)) {\n            conceptIds.put(linkConceptId, getConceptName(linkConceptId));\n          }\n        }\n\n        for (SProperty prop : n.getProperties()) {\n          SPropertyId propId = IdHelper.getPropertyId(prop);\n          propIds.put(propId, prop.getName());\n          SConceptId propConceptId = propId.getConceptId();\n          if (!conceptIds.containsKey(propConceptId)) {\n            conceptIds.put(propConceptId, getConceptName(propConceptId));\n          }\n        }\n\n        for (SReference ref : n.getReferences()) {\n          SReferenceLinkId refId = IdHelper.getRefId(ref.getLink());\n          refIds.put(refId, ref.getRole());\n          SConceptId refConceptId = refId.getConceptId();\n          if (!conceptIds.containsKey(refConceptId)) {\n            conceptIds.put(refConceptId, getConceptName(refConceptId));\n          }\n        }\n      }\n    }\n  }","id":6835,"modified_method":"public static void getDebugInfoById(Iterable<SNode> rootNodes, Map<SConceptId, String> conceptIds, Map<SPropertyId, String> propIds,\n      Map<SReferenceLinkId, String> refIds, Map<SContainmentLinkId, String> linkIds) {\n    for (SNode root : rootNodes) {\n      for (SNode n : SNodeUtil.getDescendants(root)) {\n        SConceptId conceptId = IdHelper.getConceptId(n.getConcept());\n        if (conceptId != null) {\n          conceptIds.put(conceptId, n.getConcept().getQualifiedName());\n        }\n\n        if (n.getParent() != null) {\n          SContainmentLink link = n.getContainmentLink();\n          SContainmentLinkId linkId = IdHelper.getLinkId(link);\n          linkIds.put(linkId, link.getRoleName());\n          SConceptId linkConceptId = linkId.getConceptId();\n          if (!conceptIds.containsKey(linkConceptId)) {\n            String conceptName = getConceptName(linkConceptId);\n            if (conceptName != null) {\n              conceptIds.put(linkConceptId, conceptName);\n            }\n          }\n        }\n\n        for (SProperty prop : n.getProperties()) {\n          SPropertyId propId = IdHelper.getPropertyId(prop);\n          propIds.put(propId, prop.getName());\n          SConceptId propConceptId = propId.getConceptId();\n          if (!conceptIds.containsKey(propConceptId)) {\n            String conceptName = getConceptName(propConceptId);\n            if (conceptName != null) {\n              conceptIds.put(propConceptId, conceptName);\n            }\n          }\n        }\n\n        for (SReference ref : n.getReferences()) {\n          SReferenceLinkId refId = IdHelper.getRefId(ref.getLink());\n          refIds.put(refId, ref.getRole());\n          SConceptId refConceptId = refId.getConceptId();\n          if (!conceptIds.containsKey(refConceptId)) {\n            String conceptName = getConceptName(refConceptId);\n            if (conceptName != null) {\n              conceptIds.put(refConceptId, conceptName);\n            }\n          }\n        }\n      }\n    }\n  }","commit_id":"3e0f80f52de8b804c436e1d30c4249b433003a71","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static ArrayList<ProblemDescriptor> checkDuplicateTags(final PsiDocTag[] tags,\n                                                                 ArrayList<ProblemDescriptor> problems,\n                                                                 final InspectionManager manager) {\n    Set<String> documentedParamNames = null;\n    Set<String> documentedExceptions = null;\n    Set<String> uniqueTags = null;\n    for(PsiDocTag tag: tags) {\n      if (\"param\".equals(tag.getName())) {\n        PsiDocTagValue value = tag.getValueElement();\n        if (value instanceof PsiDocParamRef) {\n          PsiDocParamRef paramRef = (PsiDocParamRef)value;\n          final PsiReference reference = paramRef.getReference();\n          if (reference != null) {\n            final String paramName = reference.getCanonicalText();\n            if (documentedParamNames == null) {\n              documentedParamNames = new HashSet<String>();\n            }\n            if (documentedParamNames.contains(paramName)) {\n              if (problems == null) {\n                problems = new ArrayList<ProblemDescriptor>(2);\n              }\n              problems.add(createDescriptor(tag.getNameElement(), InspectionsBundle.message(\"inspection.javadoc.problem.duplicate.param\", paramName), manager));\n            }\n            documentedParamNames.add(paramName);\n          }\n        }\n      }\n      else if (\"throws\".equals(tag.getName()) || \"exception\".equals(tag.getName())) {\n        PsiDocTagValue value = tag.getValueElement();\n        if (value != null) {\n          final PsiElement firstChild = value.getFirstChild();\n          if (firstChild != null && firstChild.getFirstChild() instanceof PsiJavaCodeReferenceElement) {\n            PsiJavaCodeReferenceElement refElement = (PsiJavaCodeReferenceElement) firstChild.getFirstChild();\n            if (refElement != null) {\n              PsiElement element = refElement.resolve();\n              if (element instanceof PsiClass) {\n                String fqName = ((PsiClass)element).getQualifiedName();\n                if (documentedExceptions == null) {\n                  documentedExceptions = new HashSet<String>();\n                }\n                if (documentedExceptions.contains(fqName)) {\n                  if (problems == null) {\n                    problems = new ArrayList<ProblemDescriptor>(2);\n                  }\n                  problems.add(createDescriptor(tag.getNameElement(),\n                                                InspectionsBundle.message(\"inspection.javadoc.problem.duplicate.throws\", fqName),\n                                                manager));\n                }\n                documentedExceptions.add(fqName);\n              }\n            }\n          }\n        }\n      }\n      else if (JavaDocLocalInspection.ourUniqueTags.contains(tag.getName())) {\n        if (uniqueTags == null) {\n          uniqueTags = new HashSet<String>();\n        }\n        if (uniqueTags.contains(tag.getName())) {\n          if (problems == null) {\n            problems = new ArrayList<ProblemDescriptor>(2);\n          }\n          problems.add(createDescriptor(tag.getNameElement(), InspectionsBundle.message(\"inspection.javadoc.problem.duplicate.tag\", tag.getName()), manager));\n        }\n        uniqueTags.add(tag.getName());\n      }\n    }\n    return problems;\n  }","id":6836,"modified_method":"private static void checkDuplicateTags(final PsiDocTag[] tags,\n                                         ArrayList<ProblemDescriptor> problems,\n                                         final InspectionManager manager) {\n    Set<String> documentedParamNames = null;\n    Set<String> documentedExceptions = null;\n    Set<String> uniqueTags = null;\n    for(PsiDocTag tag: tags) {\n      if (\"param\".equals(tag.getName())) {\n        PsiDocTagValue value = tag.getValueElement();\n        if (value instanceof PsiDocParamRef) {\n          PsiDocParamRef paramRef = (PsiDocParamRef)value;\n          final PsiReference reference = paramRef.getReference();\n          if (reference != null) {\n            final String paramName = reference.getCanonicalText();\n            if (documentedParamNames == null) {\n              documentedParamNames = new HashSet<String>();\n            }\n            if (documentedParamNames.contains(paramName)) {\n              problems.add(createDescriptor(tag.getNameElement(), InspectionsBundle.message(\"inspection.javadoc.problem.duplicate.param\", paramName), manager));\n            }\n            documentedParamNames.add(paramName);\n          }\n        }\n      }\n      else if (\"throws\".equals(tag.getName()) || \"exception\".equals(tag.getName())) {\n        PsiDocTagValue value = tag.getValueElement();\n        if (value != null) {\n          final PsiElement firstChild = value.getFirstChild();\n          if (firstChild != null && firstChild.getFirstChild() instanceof PsiJavaCodeReferenceElement) {\n            PsiJavaCodeReferenceElement refElement = (PsiJavaCodeReferenceElement) firstChild.getFirstChild();\n            if (refElement != null) {\n              PsiElement element = refElement.resolve();\n              if (element instanceof PsiClass) {\n                String fqName = ((PsiClass)element).getQualifiedName();\n                if (documentedExceptions == null) {\n                  documentedExceptions = new HashSet<String>();\n                }\n                if (documentedExceptions.contains(fqName)) {\n                  problems.add(createDescriptor(tag.getNameElement(),\n                                                InspectionsBundle.message(\"inspection.javadoc.problem.duplicate.throws\", fqName),\n                                                manager));\n                }\n                documentedExceptions.add(fqName);\n              }\n            }\n          }\n        }\n      }\n      else if (JavaDocLocalInspection.ourUniqueTags.contains(tag.getName())) {\n        if (uniqueTags == null) {\n          uniqueTags = new HashSet<String>();\n        }\n        if (uniqueTags.contains(tag.getName())) {\n          problems.add(createDescriptor(tag.getNameElement(), InspectionsBundle.message(\"inspection.javadoc.problem.duplicate.tag\", tag.getName()), manager));\n        }\n        uniqueTags.add(tag.getName());\n      }\n    }\n  }","commit_id":"210db3184166372686e44a1f97fe53324493ec6d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public ProblemDescriptor[] checkMethod(PsiMethod psiMethod, InspectionManager manager, boolean isOnTheFly) {\n    if (IGNORE_DEPRECATED && (psiMethod.isDeprecated() || psiMethod.getContainingClass().isDeprecated())) {\n      return null;\n    }\n    PsiDocComment docComment = psiMethod.getDocComment();\n    final PsiMethod[] superMethods = psiMethod.findSuperMethods();\n    if (docComment == null) {\n      if (isJavaDocRequired(psiMethod)) {\n        if (superMethods.length > 0) return null;\n        if (EjbHelper.getEjbHelper().getEjbRole(psiMethod) instanceof EjbImplMethodRole) return null;\n        return superMethods.length == 0\n               ? new ProblemDescriptor[]{createDescriptor(psiMethod.getNameIdentifier(), JavaDocLocalInspection.REQUIRED_JAVADOC_IS_ABSENT, manager)}\n               : null;\n      }\n      else {\n        return null;\n      }\n    }\n\n    final PsiElement[] descriptionElements = docComment.getDescriptionElements();\n    for (PsiElement descriptionElement : descriptionElements) {\n      if (descriptionElement instanceof PsiInlineDocTag) {\n        if (\"inheritDoc\".equals(((PsiInlineDocTag)descriptionElement).getName())) return null;\n      }\n    }\n\n     ArrayList<ProblemDescriptor> problems = null;\n\n    final PsiDocTag tagByName = docComment.findTagByName(\"inheritDoc\");\n    if (tagByName != null) {\n      final String tagName = tagByName.getName();\n      final JavadocTagInfo tagInfo = tagByName.getManager().getJavadocManager().getTagInfo(tagName);\n      if (tagInfo != null && tagInfo.isValidInContext(psiMethod)){\n        return null;\n      }\n    }\n\n    PsiDocTag[] tags = docComment.getTags();\n\n    boolean isReturnRequired = false;\n    boolean isReturnAbsent = true;\n    if (superMethods.length == 0 && !psiMethod.isConstructor() && PsiType.VOID != psiMethod.getReturnType() && isTagRequired(psiMethod, \"return\")) {\n      isReturnRequired = true;\n      for (PsiDocTag tag : tags) {\n        if (\"return\".equals(tag.getName())) {\n          isReturnAbsent = false;\n          break;\n        }\n      }\n    }\n\n    ArrayList<PsiParameter> absentParameters = null;\n    if (superMethods.length == 0 && isTagRequired(psiMethod, \"param\") ) {\n      PsiParameter[] params = psiMethod.getParameterList().getParameters();\n      for (PsiParameter param : params) {\n        boolean found = false;\n        for (PsiDocTag tag : tags) {\n          if (\"param\".equals(tag.getName())) {\n            PsiDocTagValue value = tag.getValueElement();\n            if (value instanceof PsiDocParamRef) {\n              PsiDocParamRef paramRef = (PsiDocParamRef)value;\n              if (paramRef.getReference().isReferenceTo(param)) {\n                found = true;\n                break;\n              }\n            }\n          }\n        }\n\n        if (!found) {\n          if (absentParameters == null) absentParameters = new ArrayList<PsiParameter>(2);\n          absentParameters.add(param);\n        }\n      }\n    }\n\n\n\n    if (isReturnRequired && isReturnAbsent) {\n      if (problems == null) {\n        problems = new ArrayList<ProblemDescriptor>(2);\n      }\n\n      ProblemDescriptor descriptor = createMissingTagDescriptor(psiMethod.getNameIdentifier(), \"return\", manager);\n      problems.add(descriptor);\n    }\n\n    if (absentParameters != null) {\n      if (problems == null) problems = new ArrayList<ProblemDescriptor>(2);\n      for (PsiParameter psiParameter : absentParameters) {\n        ProblemDescriptor descriptor = createMissingParamTagDescriptor(psiMethod.getNameIdentifier(), psiParameter.getName(), manager);\n        problems.add(descriptor);\n      }\n    }\n\n    for (PsiDocTag tag : tags) {\n      if (\"param\".equals(tag.getName())) {\n        final PsiElement[] dataElements = tag.getDataElements();\n        final PsiDocTagValue valueElement = tag.getValueElement();\n        boolean hasProblemsWithTag = dataElements.length < 2;\n        if (!hasProblemsWithTag) {\n          final StringBuffer buf = new StringBuffer();\n          for (PsiElement element : dataElements) {\n            if (element != valueElement){\n              buf.append(element.getText());\n            }\n          }\n          hasProblemsWithTag = buf.toString().trim().length() == 0;\n        }\n        if (hasProblemsWithTag) {\n          if (problems == null) problems = new ArrayList<ProblemDescriptor>(2);\n          if (valueElement != null) {\n            problems.add(createDescriptor(valueElement,\n                                          InspectionsBundle.message(\"inspection.javadoc.method.problem.missing.tag.description\", \"<code>@param \" + valueElement.getText() + \"<\/code>\"),\n                                          manager));\n          }\n\n        }\n      }\n    }\n\n    if (superMethods.length == 0 && isTagRequired(psiMethod, \"@throws\") && psiMethod.getThrowsList().getReferencedTypes().length > 0) {\n      final Map<PsiClassType, PsiClass> declaredExceptions = new HashMap<PsiClassType, PsiClass>();\n      final PsiClassType[] classTypes = psiMethod.getThrowsList().getReferencedTypes();\n      for (PsiClassType classType : classTypes) {\n        final PsiClass psiClass = classType.resolve();\n        if (psiClass != null){\n          declaredExceptions.put(classType, psiClass);\n        }\n      }\n      processThrowsTags(tags, declaredExceptions);\n      if (!declaredExceptions.isEmpty()) {\n        if (problems == null) problems = new ArrayList<ProblemDescriptor>(2);\n        for (PsiClassType declaredException : declaredExceptions.keySet()) {\n          ProblemDescriptor descriptor = createMissingThrowsTagDescriptor(psiMethod, manager, declaredException);\n          problems.add(descriptor);\n        }\n      }\n    }\n\n    ArrayList<ProblemDescriptor> tagProblems = getTagValuesProblems(psiMethod, tags, manager);\n    if (tagProblems != null) {\n      if (problems == null) problems = new ArrayList<ProblemDescriptor>(2);\n      problems.addAll(tagProblems);\n    }\n\n    problems = checkForPeriodInDoc(docComment, problems, manager);\n\n    for (PsiDocTag tag : tags) {\n      if (\"param\".equals(tag.getName())) {\n        if (extractTagDescription(tag).length() == 0) {\n          PsiDocTagValue value = tag.getValueElement();\n          if (value instanceof PsiDocParamRef) {\n            PsiDocParamRef paramRef = (PsiDocParamRef)value;\n            PsiParameter[] params = psiMethod.getParameterList().getParameters();\n            for (PsiParameter param : params) {\n              if (paramRef.getReference().isReferenceTo(param)) {\n                if (problems == null) problems = new ArrayList<ProblemDescriptor>(2);\n                problems.add(createDescriptor(value,\n                                              InspectionsBundle.message(\"inspection.javadoc.method.problem.descriptor\", \"<code>@param<\/code>\", \"<code>\" + param.getName() + \"<\/code>\"),\n                                              manager));\n              }\n            }\n          }\n        }\n      }\n      else\n        if (\"return\".equals(tag.getName())) {\n          if (extractTagDescription(tag).length() == 0) {\n            if (problems == null) problems = new ArrayList<ProblemDescriptor>(2);\n            String message = InspectionsBundle.message(\"inspection.javadoc.method.problem.missing.tag.description\", \"<code>@return<\/code>\");\n            ProblemDescriptor descriptor = manager.createProblemDescriptor(tag, message, null, ProblemHighlightType.GENERIC_ERROR_OR_WARNING, true);\n            problems.add(descriptor);\n          }\n        }\n    }\n\n    problems = checkDuplicateTags(tags, problems, manager);\n\n    return problems == null\n           ? null\n           : problems.toArray(new ProblemDescriptorImpl[problems.size()]);\n  }","id":6837,"modified_method":"@Nullable\n  public ProblemDescriptor[] checkMethod(PsiMethod psiMethod, InspectionManager manager, boolean isOnTheFly) {\n    if (IGNORE_DEPRECATED && (psiMethod.isDeprecated() || psiMethod.getContainingClass().isDeprecated())) {\n      return null;\n    }\n    PsiDocComment docComment = psiMethod.getDocComment();\n    final PsiMethod[] superMethods = psiMethod.findSuperMethods();\n    if (docComment == null) {\n      if (isJavaDocRequired(psiMethod)) {\n        if (superMethods.length > 0) return null;\n        if (EjbHelper.getEjbHelper().getEjbRole(psiMethod) instanceof EjbImplMethodRole) return null;\n        return superMethods.length == 0\n               ? new ProblemDescriptor[]{createDescriptor(psiMethod.getNameIdentifier(), JavaDocLocalInspection.REQUIRED_JAVADOC_IS_ABSENT, manager)}\n               : null;\n      }\n      else {\n        return null;\n      }\n    }\n\n    final PsiElement[] descriptionElements = docComment.getDescriptionElements();\n    for (PsiElement descriptionElement : descriptionElements) {\n      if (descriptionElement instanceof PsiInlineDocTag) {\n        if (\"inheritDoc\".equals(((PsiInlineDocTag)descriptionElement).getName())) return null;\n      }\n    }\n\n    final ArrayList<ProblemDescriptor> problems = new ArrayList<ProblemDescriptor>(2);\n\n    final PsiDocTag tagByName = docComment.findTagByName(\"inheritDoc\");\n    if (tagByName != null) {\n      final String tagName = tagByName.getName();\n      final JavadocTagInfo tagInfo = tagByName.getManager().getJavadocManager().getTagInfo(tagName);\n      if (tagInfo != null && tagInfo.isValidInContext(psiMethod)){\n        return null;\n      }\n    }\n\n    PsiDocTag[] tags = docComment.getTags();\n\n    boolean isReturnRequired = false;\n    boolean isReturnAbsent = true;\n    if (superMethods.length == 0 && !psiMethod.isConstructor() && PsiType.VOID != psiMethod.getReturnType() && isTagRequired(psiMethod, \"return\")) {\n      isReturnRequired = true;\n      for (PsiDocTag tag : tags) {\n        if (\"return\".equals(tag.getName())) {\n          isReturnAbsent = false;\n          break;\n        }\n      }\n    }\n\n    ArrayList<PsiParameter> absentParameters = null;\n    if (superMethods.length == 0 && isTagRequired(psiMethod, \"param\") ) {\n      PsiParameter[] params = psiMethod.getParameterList().getParameters();\n      for (PsiParameter param : params) {\n        boolean found = false;\n        for (PsiDocTag tag : tags) {\n          if (\"param\".equals(tag.getName())) {\n            PsiDocTagValue value = tag.getValueElement();\n            if (value instanceof PsiDocParamRef) {\n              PsiDocParamRef paramRef = (PsiDocParamRef)value;\n              if (paramRef.getReference().isReferenceTo(param)) {\n                found = true;\n                break;\n              }\n            }\n          }\n        }\n\n        if (!found) {\n          if (absentParameters == null) absentParameters = new ArrayList<PsiParameter>(2);\n          absentParameters.add(param);\n        }\n      }\n    }\n\n\n\n    if (isReturnRequired && isReturnAbsent) {\n      ProblemDescriptor descriptor = createMissingTagDescriptor(psiMethod.getNameIdentifier(), \"return\", manager);\n      problems.add(descriptor);\n    }\n\n    if (absentParameters != null) {\n      for (PsiParameter psiParameter : absentParameters) {\n        ProblemDescriptor descriptor = createMissingParamTagDescriptor(psiMethod.getNameIdentifier(), psiParameter.getName(), manager);\n        problems.add(descriptor);\n      }\n    }\n\n    for (PsiDocTag tag : tags) {\n      if (\"param\".equals(tag.getName())) {\n        final PsiElement[] dataElements = tag.getDataElements();\n        final PsiDocTagValue valueElement = tag.getValueElement();\n        boolean hasProblemsWithTag = dataElements.length < 2;\n        if (!hasProblemsWithTag) {\n          final StringBuffer buf = new StringBuffer();\n          for (PsiElement element : dataElements) {\n            if (element != valueElement){\n              buf.append(element.getText());\n            }\n          }\n          hasProblemsWithTag = buf.toString().trim().length() == 0;\n        }\n        if (hasProblemsWithTag) {\n          if (valueElement != null) {\n            problems.add(createDescriptor(valueElement,\n                                          InspectionsBundle.message(\"inspection.javadoc.method.problem.missing.tag.description\", \"<code>@param \" + valueElement.getText() + \"<\/code>\"),\n                                          manager));\n          }\n\n        }\n      }\n    }\n\n    if (superMethods.length == 0 && isTagRequired(psiMethod, \"@throws\") && psiMethod.getThrowsList().getReferencedTypes().length > 0) {\n      final Map<PsiClassType, PsiClass> declaredExceptions = new HashMap<PsiClassType, PsiClass>();\n      final PsiClassType[] classTypes = psiMethod.getThrowsList().getReferencedTypes();\n      for (PsiClassType classType : classTypes) {\n        final PsiClass psiClass = classType.resolve();\n        if (psiClass != null){\n          declaredExceptions.put(classType, psiClass);\n        }\n      }\n      processThrowsTags(psiMethod, tags, declaredExceptions, manager, problems);\n      if (!declaredExceptions.isEmpty()) {\n        for (PsiClassType declaredException : declaredExceptions.keySet()) {\n          problems.add(createMissingThrowsTagDescriptor(psiMethod, manager, declaredException, true));\n        }\n      }\n    }\n\n    ArrayList<ProblemDescriptor> tagProblems = getTagValuesProblems(psiMethod, tags, manager);\n    if (tagProblems != null) {\n      problems.addAll(tagProblems);\n    }\n\n    checkForPeriodInDoc(docComment, problems, manager);\n\n    for (PsiDocTag tag : tags) {\n      if (\"param\".equals(tag.getName())) {\n        if (extractTagDescription(tag).length() == 0) {\n          PsiDocTagValue value = tag.getValueElement();\n          if (value instanceof PsiDocParamRef) {\n            PsiDocParamRef paramRef = (PsiDocParamRef)value;\n            PsiParameter[] params = psiMethod.getParameterList().getParameters();\n            for (PsiParameter param : params) {\n              if (paramRef.getReference().isReferenceTo(param)) {\n                problems.add(createDescriptor(value,\n                                              InspectionsBundle.message(\"inspection.javadoc.method.problem.descriptor\", \"<code>@param<\/code>\", \"<code>\" + param.getName() + \"<\/code>\"),\n                                              manager));\n              }\n            }\n          }\n        }\n      }\n      else\n        if (\"return\".equals(tag.getName())) {\n          if (extractTagDescription(tag).length() == 0) {\n            String message = InspectionsBundle.message(\"inspection.javadoc.method.problem.missing.tag.description\", \"<code>@return<\/code>\");\n            ProblemDescriptor descriptor = manager.createProblemDescriptor(tag, message, null, ProblemHighlightType.GENERIC_ERROR_OR_WARNING, true);\n            problems.add(descriptor);\n          }\n        }\n    }\n\n    checkDuplicateTags(tags, problems, manager);\n\n    return problems.isEmpty()\n           ? null\n           : problems.toArray(new ProblemDescriptorImpl[problems.size()]);\n  }","commit_id":"210db3184166372686e44a1f97fe53324493ec6d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void processThrowsTags(final PsiDocTag[] tags, final Map<PsiClassType, PsiClass> declaredExceptions) {\n    for (PsiDocTag tag : tags) {\n      if (\"throws\".equals(tag.getName()) || \"exception\".equals(tag.getName())) {\n        final PsiDocTagValue value = tag.getValueElement();\n        if (value == null) continue;\n        final PsiElement firstChild = value.getFirstChild();\n        if (firstChild == null) continue;\n        final PsiElement psiElement = firstChild.getFirstChild();\n        if (!(psiElement instanceof PsiJavaCodeReferenceElement)) continue;\n        final PsiJavaCodeReferenceElement ref = ((PsiJavaCodeReferenceElement)psiElement);\n        final PsiElement element = ref.resolve();\n        if (element instanceof PsiClass){\n          final PsiClass exceptionClass = (PsiClass)element;\n          for (Iterator<PsiClassType> it = declaredExceptions.keySet().iterator(); it.hasNext();) {\n            PsiClassType classType = it.next();\n            final PsiClass psiClass = declaredExceptions.get(classType);\n            if (InheritanceUtil.isInheritorOrSelf(exceptionClass, psiClass, true)) {\n              if (extractThrowsTagDescription(tag).length() > 0) {\n                it.remove();\n              }\n            }\n          }\n        }\n      }\n    }\n  }","id":6838,"modified_method":"private static void processThrowsTags(final PsiMethod method,\n                                        final PsiDocTag[] tags,\n                                        final Map<PsiClassType, PsiClass> declaredExceptions,\n                                        final InspectionManager mananger,\n                                        @NotNull final ArrayList<ProblemDescriptor> problems) {\n    for (PsiDocTag tag : tags) {\n      if (\"throws\".equals(tag.getName()) || \"exception\".equals(tag.getName())) {\n        final PsiDocTagValue value = tag.getValueElement();\n        if (value == null) continue;\n        final PsiElement firstChild = value.getFirstChild();\n        if (firstChild == null) continue;\n        final PsiElement psiElement = firstChild.getFirstChild();\n        if (!(psiElement instanceof PsiJavaCodeReferenceElement)) continue;\n        final PsiJavaCodeReferenceElement ref = ((PsiJavaCodeReferenceElement)psiElement);\n        final PsiElement element = ref.resolve();\n        if (element instanceof PsiClass){\n          final PsiClass exceptionClass = (PsiClass)element;\n          for (Iterator<PsiClassType> it = declaredExceptions.keySet().iterator(); it.hasNext();) {\n            PsiClassType classType = it.next();\n            final PsiClass psiClass = declaredExceptions.get(classType);\n            if (InheritanceUtil.isInheritorOrSelf(exceptionClass, psiClass, true)) {\n              if (extractThrowsTagDescription(tag).length() == 0) {\n                problems.add(createMissingThrowsTagDescriptor(method, mananger, classType, false));\n              }\n              it.remove();\n            }\n          }\n        }\n      }\n    }\n  }","commit_id":"210db3184166372686e44a1f97fe53324493ec6d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public ProblemDescriptor[] checkField(PsiField psiField, InspectionManager manager, boolean isOnTheFly) {\n    if (IGNORE_DEPRECATED && (psiField.isDeprecated() || psiField.getContainingClass().isDeprecated())) {\n      return null;\n    }\n\n    PsiDocComment docComment = psiField.getDocComment();\n    if (docComment == null) {\n      return isJavaDocRequired(psiField)\n             ? new ProblemDescriptor[]{createDescriptor(psiField.getNameIdentifier(), JavaDocLocalInspection.REQUIRED_JAVADOC_IS_ABSENT, manager)}\n             : null;\n    }\n\n    ArrayList<ProblemDescriptor> problems = null;\n    problems = checkForPeriodInDoc(docComment, problems, manager);\n    problems = checkDuplicateTags(docComment.getTags(), problems, manager);\n    return problems == null\n           ? null\n           : problems.toArray(new ProblemDescriptor[problems.size()]);\n  }","id":6839,"modified_method":"@Nullable\n  public ProblemDescriptor[] checkField(PsiField psiField, InspectionManager manager, boolean isOnTheFly) {\n    if (IGNORE_DEPRECATED && (psiField.isDeprecated() || psiField.getContainingClass().isDeprecated())) {\n      return null;\n    }\n\n    PsiDocComment docComment = psiField.getDocComment();\n    if (docComment == null) {\n      return isJavaDocRequired(psiField)\n             ? new ProblemDescriptor[]{createDescriptor(psiField.getNameIdentifier(), JavaDocLocalInspection.REQUIRED_JAVADOC_IS_ABSENT, manager)}\n             : null;\n    }\n\n    final ArrayList<ProblemDescriptor> problems = new ArrayList<ProblemDescriptor>(2);\n    checkForPeriodInDoc(docComment, problems, manager);\n    checkDuplicateTags(docComment.getTags(), problems, manager);\n    return problems.isEmpty()\n           ? null\n           : problems.toArray(new ProblemDescriptor[problems.size()]);\n  }","commit_id":"210db3184166372686e44a1f97fe53324493ec6d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public ProblemDescriptor[] checkClass(PsiClass psiClass, InspectionManager manager, boolean isOnTheFly) {\n    if (psiClass instanceof PsiAnonymousClass) return null;\n    if (IGNORE_DEPRECATED && psiClass.isDeprecated()) {\n      return null;\n    }\n    PsiDocComment docComment = psiClass.getDocComment();\n    final PsiIdentifier nameIdentifier = psiClass.getNameIdentifier();\n    final PsiElement elementToHighlight = nameIdentifier != null ? nameIdentifier : psiClass;\n    if (docComment == null) {\n      return isJavaDocRequired(psiClass)\n             ? new ProblemDescriptor[]{createDescriptor(elementToHighlight, JavaDocLocalInspection.REQUIRED_JAVADOC_IS_ABSENT, manager)}\n             : null;\n    }\n\n    PsiDocTag[] tags = docComment.getTags();\n    @NonNls String[] tagsToCheck = {\"author\", \"version\", \"since\"};\n    @NonNls String[] absentDescriptionKeys = {\n      \"inspection.javadoc.problem.missing.author.description\",\n      \"inspection.javadoc.problem.missing.version.description\",\n      \"inspection.javadoc.problem.missing.since.description\"};\n\n    boolean[] isTagRequired = new boolean[tagsToCheck.length];\n    boolean[] isTagPresent = new boolean[tagsToCheck.length];\n\n    boolean someTagsAreRequired = false;\n    for (int i = 0; i < tagsToCheck.length; i++) {\n      final String tag = tagsToCheck[i];\n      someTagsAreRequired |= isTagRequired[i] = isTagRequired(psiClass, tag);\n    }\n\n    if (someTagsAreRequired) {\n      for (PsiDocTag tag : tags) {\n        String tagName = tag.getName();\n        for (int i = 0; i < tagsToCheck.length; i++) {\n          final String tagToCheck = tagsToCheck[i];\n          if (tagToCheck.equals(tagName)) {\n            isTagPresent[i] = true;\n          }\n        }\n      }\n    }\n\n    ArrayList<ProblemDescriptor> problems = null;\n\n    for (int i = 0; i < tagsToCheck.length; i++) {\n      final String tagToCheck = tagsToCheck[i];\n      if (isTagRequired[i] && !isTagPresent[i]) {\n        if (problems == null) problems = new ArrayList<ProblemDescriptor>(2);\n        ProblemDescriptor descriptor = createMissingTagDescriptor(elementToHighlight, tagToCheck, manager);\n        problems.add(descriptor);\n      }\n    }\n    problems = checkForPeriodInDoc(docComment, problems, manager);\n\n    for (PsiDocTag tag : tags) {\n      for (int i = 0; i < tagsToCheck.length; i++) {\n        final String tagToCheck = tagsToCheck[i];\n        if (tagToCheck.equals(tag.getName()) && extractTagDescription(tag).length() == 0) {\n          if (problems == null) problems = new ArrayList<ProblemDescriptor>(2);\n          problems.add(createDescriptor(elementToHighlight, InspectionsBundle.message(absentDescriptionKeys[i]), manager));\n        }\n      }\n    }\n\n    problems = checkDuplicateTags(tags, problems, manager);\n\n    return problems == null\n           ? null\n           : problems.toArray(new ProblemDescriptorImpl[problems.size()]);\n  }","id":6840,"modified_method":"@Nullable\n  public ProblemDescriptor[] checkClass(PsiClass psiClass, InspectionManager manager, boolean isOnTheFly) {\n    if (psiClass instanceof PsiAnonymousClass) return null;\n    if (IGNORE_DEPRECATED && psiClass.isDeprecated()) {\n      return null;\n    }\n    PsiDocComment docComment = psiClass.getDocComment();\n    final PsiIdentifier nameIdentifier = psiClass.getNameIdentifier();\n    final PsiElement elementToHighlight = nameIdentifier != null ? nameIdentifier : psiClass;\n    if (docComment == null) {\n      return isJavaDocRequired(psiClass)\n             ? new ProblemDescriptor[]{createDescriptor(elementToHighlight, JavaDocLocalInspection.REQUIRED_JAVADOC_IS_ABSENT, manager)}\n             : null;\n    }\n\n    PsiDocTag[] tags = docComment.getTags();\n    @NonNls String[] tagsToCheck = {\"author\", \"version\", \"since\"};\n    @NonNls String[] absentDescriptionKeys = {\n      \"inspection.javadoc.problem.missing.author.description\",\n      \"inspection.javadoc.problem.missing.version.description\",\n      \"inspection.javadoc.problem.missing.since.description\"};\n\n    boolean[] isTagRequired = new boolean[tagsToCheck.length];\n    boolean[] isTagPresent = new boolean[tagsToCheck.length];\n\n    boolean someTagsAreRequired = false;\n    for (int i = 0; i < tagsToCheck.length; i++) {\n      final String tag = tagsToCheck[i];\n      someTagsAreRequired |= isTagRequired[i] = isTagRequired(psiClass, tag);\n    }\n\n    if (someTagsAreRequired) {\n      for (PsiDocTag tag : tags) {\n        String tagName = tag.getName();\n        for (int i = 0; i < tagsToCheck.length; i++) {\n          final String tagToCheck = tagsToCheck[i];\n          if (tagToCheck.equals(tagName)) {\n            isTagPresent[i] = true;\n          }\n        }\n      }\n    }\n\n    final ArrayList<ProblemDescriptor> problems = new ArrayList<ProblemDescriptor>(2);\n\n    for (int i = 0; i < tagsToCheck.length; i++) {\n      final String tagToCheck = tagsToCheck[i];\n      if (isTagRequired[i] && !isTagPresent[i]) {\n        problems.add(createMissingTagDescriptor(elementToHighlight, tagToCheck, manager));\n      }\n    }\n    checkForPeriodInDoc(docComment, problems, manager);\n\n    for (PsiDocTag tag : tags) {\n      for (int i = 0; i < tagsToCheck.length; i++) {\n        final String tagToCheck = tagsToCheck[i];\n        if (tagToCheck.equals(tag.getName()) && extractTagDescription(tag).length() == 0) {\n          problems.add(createDescriptor(elementToHighlight, InspectionsBundle.message(absentDescriptionKeys[i]), manager));\n        }\n      }\n    }\n\n    checkDuplicateTags(tags, problems, manager);\n\n    return problems.isEmpty()\n           ? null\n           : problems.toArray(new ProblemDescriptorImpl[problems.size()]);\n  }","commit_id":"210db3184166372686e44a1f97fe53324493ec6d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static ProblemDescriptor createMissingThrowsTagDescriptor(final PsiMethod method, final InspectionManager manager, final PsiClassType exceptionClassType) {\n    @NonNls String tag = \"throws\";\n    String message = InspectionsBundle.message(\"inspection.javadoc.problem.missing.tag\", \"<code>@\" + tag + \"<\/code> \" + exceptionClassType.getCanonicalText());\n    final String firstDeclaredException = exceptionClassType.getCanonicalText();\n    final PsiIdentifier nameIdentifier = method.getNameIdentifier();\n    LOG.assertTrue(nameIdentifier != null);\n    return createDescriptor(nameIdentifier, message,new AddMissingTagFix(tag, firstDeclaredException), manager);\n  }","id":6841,"modified_method":"private static ProblemDescriptor createMissingThrowsTagDescriptor(final PsiMethod method,\n                                                                    final InspectionManager manager,\n                                                                    final PsiClassType exceptionClassType,\n                                                                    final boolean quickfixNeeded) {\n    @NonNls String tag = \"throws\";\n    String message = InspectionsBundle.message(\"inspection.javadoc.problem.missing.tag\", \"<code>@\" + tag + \"<\/code> \" + exceptionClassType.getCanonicalText());\n    final String firstDeclaredException = exceptionClassType.getCanonicalText();\n    final PsiIdentifier nameIdentifier = method.getNameIdentifier();\n    LOG.assertTrue(nameIdentifier != null);\n    if (quickfixNeeded) {\n      return createDescriptor(nameIdentifier, message,new AddMissingTagFix(tag, firstDeclaredException), manager);\n    } else {\n      return createDescriptor(nameIdentifier, message, manager);\n    }\n  }","commit_id":"210db3184166372686e44a1f97fe53324493ec6d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private ArrayList<ProblemDescriptor> checkForPeriodInDoc(PsiDocComment docComment,\n                                                           ArrayList<ProblemDescriptor> problems,\n                                                           InspectionManager manager) {\n    if (IGNORE_JAVADOC_PERIOD) return problems;\n    PsiDocTag[] tags = docComment.getTags();\n    int dotIndex = docComment.getText().indexOf('.');\n    int tagOffset = tags.length == 0 ? 0 : tags[0].getTextOffset();\n\n    if (dotIndex == -1 || tagOffset > 0 && dotIndex + docComment.getTextOffset() > tagOffset) {\n      if (problems == null) problems = new ArrayList<ProblemDescriptor>(2);\n      problems.add(manager.createProblemDescriptor(docComment.getFirstChild(),\n                                                   InspectionsBundle.message(\"inspection.javadoc.problem.descriptor1\"),\n                                                   null,\n                                                   ProblemHighlightType.GENERIC_ERROR_OR_WARNING,\n                                                   false));\n    }\n    return problems;\n  }","id":6842,"modified_method":"private void checkForPeriodInDoc(PsiDocComment docComment,\n                                   ArrayList<ProblemDescriptor> problems,\n                                   InspectionManager manager) {\n    if (IGNORE_JAVADOC_PERIOD) return;\n    PsiDocTag[] tags = docComment.getTags();\n    int dotIndex = docComment.getText().indexOf('.');\n    int tagOffset = tags.length == 0 ? 0 : tags[0].getTextOffset();\n\n    if (dotIndex == -1 || tagOffset > 0 && dotIndex + docComment.getTextOffset() > tagOffset) {\n      problems.add(manager.createProblemDescriptor(docComment.getFirstChild(),\n                                                   InspectionsBundle.message(\"inspection.javadoc.problem.descriptor1\"),\n                                                   null,\n                                                   ProblemHighlightType.GENERIC_ERROR_OR_WARNING,\n                                                   false));\n    }\n  }","commit_id":"210db3184166372686e44a1f97fe53324493ec6d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected boolean wasAgentRestartedDuringOperation(Host host, Stage stage, String role) {\n    String hostName = (null == host) ? null : host.getHostName();\n    long lastStageAttemptTime = stage.getLastAttemptTime(hostName, role);\n    return lastStageAttemptTime > 0 && lastStageAttemptTime <= host.getLastRegistrationTime();\n  }","id":6843,"modified_method":"boolean wasAgentRestartedDuringOperation(Host host, Stage stage, String role) {\n    if (host == null) {\n      // null host is valid in case of server action, skip restart detection\n      return false;\n    } else {\n      String hostName = host.getHostName();\n      long lastStageAttemptTime = stage.getLastAttemptTime(hostName, role);\n      return lastStageAttemptTime > 0 && lastStageAttemptTime <= host.getLastRegistrationTime();\n    }\n  }","commit_id":"825d557ae63e5bb6a7d22e0132c96dc599d12ad0","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Verifies that ActionScheduler respects \"disable parallel stage execution option\"\n   */\n  @Test\n  public void testIndependentStagesExecutionDisabled() throws Exception {\n    ActionQueue aq = new ActionQueue();\n    Clusters fsm = mock(Clusters.class);\n    Cluster oneClusterMock = mock(Cluster.class);\n    Service serviceObj = mock(Service.class);\n    ServiceComponent scomp = mock(ServiceComponent.class);\n    ServiceComponentHost sch = mock(ServiceComponentHost.class);\n    UnitOfWork unitOfWork = mock(UnitOfWork.class);\n    when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);\n    when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);\n    when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);\n    when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);\n    when(serviceObj.getCluster()).thenReturn(oneClusterMock);\n\n    String hostname1 = \"ahost.ambari.apache.org\";\n    String hostname2 = \"bhost.ambari.apache.org\";\n    String hostname3 = \"chost.ambari.apache.org\";\n    String hostname4 = \"chost.ambari.apache.org\";\n    HashMap<String, ServiceComponentHost> hosts =\n            new HashMap<String, ServiceComponentHost>();\n    hosts.put(hostname1, sch);\n    hosts.put(hostname2, sch);\n    hosts.put(hostname3, sch);\n    hosts.put(hostname4, sch);\n    when(scomp.getServiceComponentHosts()).thenReturn(hosts);\n\n    List<Stage> stages = new ArrayList<Stage>();\n    Stage stage = getStageWithSingleTask(\n            hostname1, \"cluster1\", Role.HIVE_CLIENT,\n            RoleCommand.INSTALL, Service.Type.HIVE, 1, 1, 1);\n    Map<String, String> hiveSite = new TreeMap<String, String>();\n    hiveSite.put(\"javax.jdo.option.ConnectionPassword\", \"password\");\n    hiveSite.put(\"hive.server2.thrift.port\", \"10000\");\n    Map<String, Map<String, String>> configurations =\n            new TreeMap<String, Map<String, String>>();\n    configurations.put(\"hive-site\", hiveSite);\n    stage.getExecutionCommands(hostname1).get(0).getExecutionCommand().setConfigurations(configurations);\n    stages.add(stage);\n\n    stages.add( // Stage with the same hostname, should not be scheduled\n        getStageWithSingleTask(\n            hostname1, \"cluster1\", Role.GANGLIA_MONITOR,\n            RoleCommand.START, Service.Type.GANGLIA, 2, 2, 2));\n\n    stages.add(\n        getStageWithSingleTask(\n            hostname2, \"cluster1\", Role.HIVE_CLIENT,\n            RoleCommand.INSTALL, Service.Type.HIVE, 3, 3, 3));\n\n    stages.add(\n        getStageWithSingleTask(\n            hostname3, \"cluster1\", Role.DATANODE,\n            RoleCommand.START, Service.Type.HDFS, 4, 4, 4));\n\n    stages.add( // Stage with the same request id, should not be scheduled\n        getStageWithSingleTask(\n            hostname4, \"cluster1\", Role.GANGLIA_MONITOR,\n            RoleCommand.START, Service.Type.GANGLIA, 5, 5, 4));\n\n    ActionDBAccessor db = mock(ActionDBAccessor.class);\n\n    RequestEntity request = mock(RequestEntity.class);\n    when(request.isExclusive()).thenReturn(false);\n    when(db.getRequestEntity(anyLong())).thenReturn(request);\n\n    when(db.getCommandsInProgressCount()).thenReturn(stages.size());\n    when(db.getStagesInProgress()).thenReturn(stages);\n\n    Properties properties = new Properties();\n    properties.put(Configuration.PARALLEL_STAGE_EXECUTION_KEY, \"false\");\n    Configuration conf = new Configuration(properties);\n    ActionScheduler scheduler = spy(new ActionScheduler(100, 50, db, aq, fsm, 3,\n            new HostsMap((String) null),\n            unitOfWork, null, conf));\n\n\n    doReturn(false).when(scheduler).wasAgentRestartedDuringOperation(any(Host.class), any(Stage.class), anyString());\n\n    scheduler.doWork();\n\n    Assert.assertEquals(HostRoleStatus.QUEUED, stages.get(0).getHostRoleStatus(hostname1, \"HIVE_CLIENT\"));\n    Assert.assertEquals(HostRoleStatus.PENDING, stages.get(1).getHostRoleStatus(hostname1, \"GANGLIA_MONITOR\"));\n    Assert.assertEquals(HostRoleStatus.PENDING, stages.get(2).getHostRoleStatus(hostname2, \"HIVE_CLIENT\"));\n    Assert.assertEquals(HostRoleStatus.PENDING, stages.get(3).getHostRoleStatus(hostname3, \"DATANODE\"));\n    Assert.assertEquals(HostRoleStatus.PENDING, stages.get(4).getHostRoleStatus(hostname4, \"GANGLIA_MONITOR\"));\n    Assert.assertFalse(stages.get(0).getExecutionCommands(hostname1).get(0).getExecutionCommand().\n            getConfigurations().containsKey(\"javax.jdo.option.ConnectionPassword\"));\n  }","id":6844,"modified_method":"/**\n   * Verifies that ActionScheduler respects \"disable parallel stage execution option\"\n   */\n  @Test\n  public void testIndependentStagesExecutionDisabled() throws Exception {\n    ActionQueue aq = new ActionQueue();\n    Clusters fsm = mock(Clusters.class);\n    Cluster oneClusterMock = mock(Cluster.class);\n    Service serviceObj = mock(Service.class);\n    ServiceComponent scomp = mock(ServiceComponent.class);\n    ServiceComponentHost sch = mock(ServiceComponentHost.class);\n    UnitOfWork unitOfWork = mock(UnitOfWork.class);\n    when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);\n    when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);\n    when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);\n    when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);\n    when(serviceObj.getCluster()).thenReturn(oneClusterMock);\n\n    String hostname1 = \"ahost.ambari.apache.org\";\n    String hostname2 = \"bhost.ambari.apache.org\";\n    String hostname3 = \"chost.ambari.apache.org\";\n    String hostname4 = \"chost.ambari.apache.org\";\n    HashMap<String, ServiceComponentHost> hosts =\n            new HashMap<String, ServiceComponentHost>();\n    hosts.put(hostname1, sch);\n    hosts.put(hostname2, sch);\n    hosts.put(hostname3, sch);\n    hosts.put(hostname4, sch);\n    when(scomp.getServiceComponentHosts()).thenReturn(hosts);\n\n    List<Stage> stages = new ArrayList<Stage>();\n    Stage stage = getStageWithSingleTask(\n            hostname1, \"cluster1\", Role.HIVE_CLIENT,\n            RoleCommand.INSTALL, Service.Type.HIVE, 1, 1, 1);\n    Map<String, String> hiveSite = new TreeMap<String, String>();\n    hiveSite.put(\"javax.jdo.option.ConnectionPassword\", \"password\");\n    hiveSite.put(\"hive.server2.thrift.port\", \"10000\");\n    Map<String, Map<String, String>> configurations =\n            new TreeMap<String, Map<String, String>>();\n    configurations.put(\"hive-site\", hiveSite);\n    stage.getExecutionCommands(hostname1).get(0).getExecutionCommand().setConfigurations(configurations);\n    stages.add(stage);\n\n    stages.add( // Stage with the same hostname, should not be scheduled\n        getStageWithSingleTask(\n            hostname1, \"cluster1\", Role.GANGLIA_MONITOR,\n            RoleCommand.START, Service.Type.GANGLIA, 2, 2, 2));\n\n    stages.add(\n        getStageWithSingleTask(\n            hostname2, \"cluster1\", Role.HIVE_CLIENT,\n            RoleCommand.INSTALL, Service.Type.HIVE, 3, 3, 3));\n\n    stages.add(\n        getStageWithSingleTask(\n            hostname3, \"cluster1\", Role.DATANODE,\n            RoleCommand.START, Service.Type.HDFS, 4, 4, 4));\n\n    stages.add( // Stage with the same request id, should not be scheduled\n        getStageWithSingleTask(\n            hostname4, \"cluster1\", Role.GANGLIA_MONITOR,\n            RoleCommand.START, Service.Type.GANGLIA, 5, 5, 4));\n\n    ActionDBAccessor db = mock(ActionDBAccessor.class);\n\n    RequestEntity request = mock(RequestEntity.class);\n    when(request.isExclusive()).thenReturn(false);\n    when(db.getRequestEntity(anyLong())).thenReturn(request);\n\n    when(db.getCommandsInProgressCount()).thenReturn(stages.size());\n    when(db.getStagesInProgress()).thenReturn(stages);\n\n    Properties properties = new Properties();\n    properties.put(Configuration.PARALLEL_STAGE_EXECUTION_KEY, \"false\");\n    Configuration conf = new Configuration(properties);\n    ActionScheduler scheduler = new ActionScheduler(100, 50, db, aq, fsm, 3,\n            new HostsMap((String) null),\n            unitOfWork, null, conf);\n\n    scheduler.doWork();\n\n    Assert.assertEquals(HostRoleStatus.QUEUED, stages.get(0).getHostRoleStatus(hostname1, \"HIVE_CLIENT\"));\n    Assert.assertEquals(HostRoleStatus.PENDING, stages.get(1).getHostRoleStatus(hostname1, \"GANGLIA_MONITOR\"));\n    Assert.assertEquals(HostRoleStatus.PENDING, stages.get(2).getHostRoleStatus(hostname2, \"HIVE_CLIENT\"));\n    Assert.assertEquals(HostRoleStatus.PENDING, stages.get(3).getHostRoleStatus(hostname3, \"DATANODE\"));\n    Assert.assertEquals(HostRoleStatus.PENDING, stages.get(4).getHostRoleStatus(hostname4, \"GANGLIA_MONITOR\"));\n    Assert.assertFalse(stages.get(0).getExecutionCommands(hostname1).get(0).getExecutionCommand().\n            getConfigurations().containsKey(\"javax.jdo.option.ConnectionPassword\"));\n  }","commit_id":"825d557ae63e5bb6a7d22e0132c96dc599d12ad0","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testExclusiveRequests() throws Exception {\n    ActionQueue aq = new ActionQueue();\n    Clusters fsm = mock(Clusters.class);\n    Cluster oneClusterMock = mock(Cluster.class);\n    Service serviceObj = mock(Service.class);\n    ServiceComponent scomp = mock(ServiceComponent.class);\n    ServiceComponentHost sch = mock(ServiceComponentHost.class);\n    UnitOfWork unitOfWork = mock(UnitOfWork.class);\n    when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);\n    when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);\n    when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);\n    when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);\n    when(serviceObj.getCluster()).thenReturn(oneClusterMock);\n\n    HashMap<String, ServiceComponentHost> hosts =\n            new HashMap<String, ServiceComponentHost>();\n    String hostname1 = \"hostname1\";\n    String hostname2 = \"hostname2\";\n    String hostname3 = \"hostname3\";\n\n    hosts.put(hostname1, sch);\n    hosts.put(hostname2, sch);\n    hosts.put(hostname3, sch);\n    when(scomp.getServiceComponentHosts()).thenReturn(hosts);\n\n    long requestId1 = 1;\n    long requestId2 = 2;\n    long requestId3 = 3;\n\n    final List<Stage> stagesInProgress = new ArrayList<Stage>();\n    int namenodeCmdTaskId = 1;\n    stagesInProgress.add(\n            getStageWithSingleTask(\n                    hostname1, \"cluster1\", Role.NAMENODE, RoleCommand.START,\n                    Service.Type.HDFS, namenodeCmdTaskId, 1, (int) requestId1));\n    stagesInProgress.add(\n            getStageWithSingleTask(\n                    hostname1, \"cluster1\", Role.DATANODE, RoleCommand.START,\n                    Service.Type.HDFS, 2, 2, (int) requestId1));\n    stagesInProgress.add(\n            getStageWithSingleTask(\n                    hostname2, \"cluster1\", Role.DATANODE, RoleCommand.STOP, //Exclusive\n                    Service.Type.HDFS, 3, 3, (int) requestId2));\n\n    stagesInProgress.add(\n            getStageWithSingleTask(\n                    hostname3, \"cluster1\", Role.DATANODE, RoleCommand.START,\n                    Service.Type.HDFS, 4, 4, (int) requestId3));\n\n\n    Host host1 = mock(Host.class);\n    when(fsm.getHost(anyString())).thenReturn(host1);\n    when(host1.getState()).thenReturn(HostState.HEALTHY);\n    when(host1.getHostName()).thenReturn(hostname);\n\n    Host host2 = mock(Host.class);\n    when(fsm.getHost(anyString())).thenReturn(host2);\n    when(host2.getState()).thenReturn(HostState.HEALTHY);\n    when(host2.getHostName()).thenReturn(hostname);\n\n    Host host3 = mock(Host.class);\n    when(fsm.getHost(anyString())).thenReturn(host3);\n    when(host3.getState()).thenReturn(HostState.HEALTHY);\n    when(host3.getHostName()).thenReturn(hostname);\n\n    ActionDBAccessor db = mock(ActionDBAccessor.class);\n    when(db.getCommandsInProgressCount()).thenReturn(stagesInProgress.size());\n    when(db.getStagesInProgress()).thenReturn(stagesInProgress);\n\n    List<HostRoleCommand> requestTasks = new ArrayList<HostRoleCommand>();\n    for (Stage stage : stagesInProgress) {\n      requestTasks.addAll(stage.getOrderedHostRoleCommands());\n    }\n    when(db.getRequestTasks(anyLong())).thenReturn(requestTasks);\n    when(db.getAllStages(anyLong())).thenReturn(stagesInProgress);\n    doAnswer(new Answer<Void>() {\n      @Override\n      public Void answer(InvocationOnMock invocation) throws Throwable {\n        List<CommandReport> reports = (List<CommandReport>) invocation.getArguments()[0];\n        for (CommandReport report : reports) {\n          String actionId = report.getActionId();\n          long[] requestStageIds = StageUtils.getRequestStage(actionId);\n          Long requestId = requestStageIds[0];\n          Long stageId = requestStageIds[1];\n          Long id = report.getTaskId();\n          for (Stage stage : stagesInProgress) {\n            if (requestId.equals(stage.getRequestId()) && stageId.equals(stage.getStageId())) {\n              for (HostRoleCommand hostRoleCommand : stage.getOrderedHostRoleCommands()) {\n                if (hostRoleCommand.getTaskId() == id) {\n                  hostRoleCommand.setStatus(HostRoleStatus.valueOf(report.getStatus()));\n                }\n              }\n            }\n          }\n\n        }\n\n        return null;\n      }\n    }).when(db).updateHostRoleStates(anyCollectionOf(CommandReport.class));\n\n    when(db.getTask(anyLong())).thenAnswer(new Answer<Object>() {\n      @Override\n      public Object answer(InvocationOnMock invocation) throws Throwable {\n        Long taskId = (Long) invocation.getArguments()[0];\n        for (Stage stage : stagesInProgress) {\n          for (HostRoleCommand command : stage.getOrderedHostRoleCommands()) {\n            if (taskId.equals(command.getTaskId())) {\n              return command;\n            }\n          }\n        }\n        return null;\n      }\n    });\n\n    final Map<Long, Boolean> startedRequests = new HashMap<Long, Boolean>();\n    doAnswer(new Answer<Void>() {\n      @Override\n      public Void answer(InvocationOnMock invocation) throws Throwable {\n        startedRequests.put((Long)invocation.getArguments()[0], true);\n        return null;\n      }\n    }).when(db).startRequest(anyLong());\n\n    RequestEntity request1 = mock(RequestEntity.class);\n    when(request1.isExclusive()).thenReturn(false);\n    RequestEntity request2 = mock(RequestEntity.class);\n    when(request2.isExclusive()).thenReturn(true);\n    RequestEntity request3 = mock(RequestEntity.class);\n    when(request3.isExclusive()).thenReturn(false);\n\n    when(db.getRequestEntity(requestId1)).thenReturn(request1);\n    when(db.getRequestEntity(requestId2)).thenReturn(request2);\n    when(db.getRequestEntity(requestId3)).thenReturn(request3);\n\n    Properties properties = new Properties();\n    Configuration conf = new Configuration(properties);\n\n    ActionScheduler scheduler = spy(new ActionScheduler(100, 50, db, aq, fsm, 3,\n        new HostsMap((String) null), unitOfWork, null, conf));\n\n    doReturn(false).when(scheduler).wasAgentRestartedDuringOperation(any(Host.class), any(Stage.class), anyString());\n\n    // Execution of request 1\n\n    scheduler.doWork();\n\n    Assert.assertTrue(startedRequests.containsKey(requestId1));\n    Assert.assertFalse(startedRequests.containsKey(requestId2));\n    Assert.assertFalse(startedRequests.containsKey(requestId3));\n\n    stagesInProgress.remove(0);\n\n    scheduler.doWork();\n\n    Assert.assertTrue(startedRequests.containsKey(requestId1));\n    Assert.assertFalse(startedRequests.containsKey(requestId2));\n    Assert.assertFalse(startedRequests.containsKey(requestId3));\n\n    // Execution of request 2\n\n    stagesInProgress.remove(0);\n\n    scheduler.doWork();\n\n    Assert.assertTrue(startedRequests.containsKey(requestId1));\n    Assert.assertTrue(startedRequests.containsKey(requestId2));\n    Assert.assertFalse(startedRequests.containsKey(requestId3));\n\n    // Execution of request 3\n\n    stagesInProgress.remove(0);\n\n    scheduler.doWork();\n\n    Assert.assertTrue(startedRequests.containsKey(requestId1));\n    Assert.assertTrue(startedRequests.containsKey(requestId2));\n    Assert.assertTrue(startedRequests.containsKey(requestId3));\n\n  }","id":6845,"modified_method":"@Test\n  public void testExclusiveRequests() throws Exception {\n    ActionQueue aq = new ActionQueue();\n    Clusters fsm = mock(Clusters.class);\n    Cluster oneClusterMock = mock(Cluster.class);\n    Service serviceObj = mock(Service.class);\n    ServiceComponent scomp = mock(ServiceComponent.class);\n    ServiceComponentHost sch = mock(ServiceComponentHost.class);\n    UnitOfWork unitOfWork = mock(UnitOfWork.class);\n    when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);\n    when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);\n    when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);\n    when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);\n    when(serviceObj.getCluster()).thenReturn(oneClusterMock);\n\n    HashMap<String, ServiceComponentHost> hosts =\n            new HashMap<String, ServiceComponentHost>();\n    String hostname1 = \"hostname1\";\n    String hostname2 = \"hostname2\";\n    String hostname3 = \"hostname3\";\n\n    hosts.put(hostname1, sch);\n    hosts.put(hostname2, sch);\n    hosts.put(hostname3, sch);\n    when(scomp.getServiceComponentHosts()).thenReturn(hosts);\n\n    long requestId1 = 1;\n    long requestId2 = 2;\n    long requestId3 = 3;\n\n    final List<Stage> stagesInProgress = new ArrayList<Stage>();\n    int namenodeCmdTaskId = 1;\n    Stage stageInProgress1 = spy(getStageWithSingleTask(\n      hostname1, \"cluster1\", Role.NAMENODE, RoleCommand.START,\n      Service.Type.HDFS, namenodeCmdTaskId, 1, (int) requestId1));\n    Stage stageInProgress2 = spy(getStageWithSingleTask(\n      hostname1, \"cluster1\", Role.DATANODE, RoleCommand.START,\n      Service.Type.HDFS, 2, 2, (int) requestId1));\n    Stage stageInProgress3 = spy(getStageWithSingleTask(\n      hostname2, \"cluster1\", Role.DATANODE, RoleCommand.STOP, //Exclusive\n      Service.Type.HDFS, 3, 3, (int) requestId2));\n    Stage stageInProgress4 = spy(getStageWithSingleTask(\n      hostname3, \"cluster1\", Role.DATANODE, RoleCommand.START,\n      Service.Type.HDFS, 4, 4, (int) requestId3));\n    stagesInProgress.add(stageInProgress1);\n    stagesInProgress.add(stageInProgress2);\n    stagesInProgress.add(stageInProgress3);\n    stagesInProgress.add(stageInProgress4);\n\n\n    Host host1 = mock(Host.class);\n    when(fsm.getHost(anyString())).thenReturn(host1);\n    when(host1.getState()).thenReturn(HostState.HEALTHY);\n    when(host1.getHostName()).thenReturn(hostname);\n    when(host1.getLastRegistrationTime()).thenReturn(HOST_LAST_REGISTRATION_TIME);\n\n    Host host2 = mock(Host.class);\n    when(fsm.getHost(anyString())).thenReturn(host2);\n    when(host2.getState()).thenReturn(HostState.HEALTHY);\n    when(host2.getHostName()).thenReturn(hostname);\n    when(host2.getLastRegistrationTime()).thenReturn(HOST_LAST_REGISTRATION_TIME);\n\n    Host host3 = mock(Host.class);\n    when(fsm.getHost(anyString())).thenReturn(host3);\n    when(host3.getState()).thenReturn(HostState.HEALTHY);\n    when(host3.getHostName()).thenReturn(hostname);\n    when(host3.getLastRegistrationTime()).thenReturn(HOST_LAST_REGISTRATION_TIME);\n\n    ActionDBAccessor db = mock(ActionDBAccessor.class);\n    when(db.getCommandsInProgressCount()).thenReturn(stagesInProgress.size());\n    when(db.getStagesInProgress()).thenReturn(stagesInProgress);\n\n    List<HostRoleCommand> requestTasks = new ArrayList<HostRoleCommand>();\n    for (Stage stage : stagesInProgress) {\n      requestTasks.addAll(stage.getOrderedHostRoleCommands());\n    }\n    when(db.getRequestTasks(anyLong())).thenReturn(requestTasks);\n    when(db.getAllStages(anyLong())).thenReturn(stagesInProgress);\n    doAnswer(new Answer<Void>() {\n      @Override\n      public Void answer(InvocationOnMock invocation) throws Throwable {\n        List<CommandReport> reports = (List<CommandReport>) invocation.getArguments()[0];\n        for (CommandReport report : reports) {\n          String actionId = report.getActionId();\n          long[] requestStageIds = StageUtils.getRequestStage(actionId);\n          Long requestId = requestStageIds[0];\n          Long stageId = requestStageIds[1];\n          Long id = report.getTaskId();\n          for (Stage stage : stagesInProgress) {\n            if (requestId.equals(stage.getRequestId()) && stageId.equals(stage.getStageId())) {\n              for (HostRoleCommand hostRoleCommand : stage.getOrderedHostRoleCommands()) {\n                if (hostRoleCommand.getTaskId() == id) {\n                  hostRoleCommand.setStatus(HostRoleStatus.valueOf(report.getStatus()));\n                }\n              }\n            }\n          }\n\n        }\n\n        return null;\n      }\n    }).when(db).updateHostRoleStates(anyCollectionOf(CommandReport.class));\n\n    when(db.getTask(anyLong())).thenAnswer(new Answer<Object>() {\n      @Override\n      public Object answer(InvocationOnMock invocation) throws Throwable {\n        Long taskId = (Long) invocation.getArguments()[0];\n        for (Stage stage : stagesInProgress) {\n          for (HostRoleCommand command : stage.getOrderedHostRoleCommands()) {\n            if (taskId.equals(command.getTaskId())) {\n              return command;\n            }\n          }\n        }\n        return null;\n      }\n    });\n\n    final Map<Long, Boolean> startedRequests = new HashMap<Long, Boolean>();\n    doAnswer(new Answer<Void>() {\n      @Override\n      public Void answer(InvocationOnMock invocation) throws Throwable {\n        startedRequests.put((Long)invocation.getArguments()[0], true);\n        return null;\n      }\n    }).when(db).startRequest(anyLong());\n\n    RequestEntity request1 = mock(RequestEntity.class);\n    when(request1.isExclusive()).thenReturn(false);\n    RequestEntity request2 = mock(RequestEntity.class);\n    when(request2.isExclusive()).thenReturn(true);\n    RequestEntity request3 = mock(RequestEntity.class);\n    when(request3.isExclusive()).thenReturn(false);\n\n    when(db.getRequestEntity(requestId1)).thenReturn(request1);\n    when(db.getRequestEntity(requestId2)).thenReturn(request2);\n    when(db.getRequestEntity(requestId3)).thenReturn(request3);\n\n    Properties properties = new Properties();\n    Configuration conf = new Configuration(properties);\n\n    ActionScheduler scheduler = new ActionScheduler(100, 50, db, aq, fsm, 3,\n        new HostsMap((String) null), unitOfWork, null, conf);\n\n    doReturn(STAGE_LAST_ATTEMPT_TIME).when(stageInProgress1).getLastAttemptTime(anyString(), anyString());\n    doReturn(STAGE_LAST_ATTEMPT_TIME).when(stageInProgress2).getLastAttemptTime(anyString(), anyString());\n    doReturn(STAGE_LAST_ATTEMPT_TIME).when(stageInProgress3).getLastAttemptTime(anyString(), anyString());\n    doReturn(STAGE_LAST_ATTEMPT_TIME).when(stageInProgress4).getLastAttemptTime(anyString(), anyString());\n\n    // Execution of request 1\n\n    scheduler.doWork();\n\n    Assert.assertTrue(startedRequests.containsKey(requestId1));\n    Assert.assertFalse(startedRequests.containsKey(requestId2));\n    Assert.assertFalse(startedRequests.containsKey(requestId3));\n\n    stagesInProgress.remove(0);\n\n    scheduler.doWork();\n\n    Assert.assertTrue(startedRequests.containsKey(requestId1));\n    Assert.assertFalse(startedRequests.containsKey(requestId2));\n    Assert.assertFalse(startedRequests.containsKey(requestId3));\n\n    // Execution of request 2\n\n    stagesInProgress.remove(0);\n\n    scheduler.doWork();\n\n    Assert.assertTrue(startedRequests.containsKey(requestId1));\n    Assert.assertTrue(startedRequests.containsKey(requestId2));\n    Assert.assertFalse(startedRequests.containsKey(requestId3));\n\n    // Execution of request 3\n\n    stagesInProgress.remove(0);\n\n    scheduler.doWork();\n\n    Assert.assertTrue(startedRequests.containsKey(requestId1));\n    Assert.assertTrue(startedRequests.containsKey(requestId2));\n    Assert.assertTrue(startedRequests.containsKey(requestId3));\n\n  }","commit_id":"825d557ae63e5bb6a7d22e0132c96dc599d12ad0","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Tests that command failures in skippable stages do not cause the request to\n   * be aborted.\n   */\n  @Test\n  public void testSkippableCommandFailureDoesNotAbortRequest() throws Exception {\n    Properties properties = new Properties();\n    Configuration conf = new Configuration(properties);\n    ActionQueue aq = new ActionQueue();\n    Clusters fsm = mock(Clusters.class);\n    Cluster oneClusterMock = mock(Cluster.class);\n    Service serviceObj = mock(Service.class);\n    ServiceComponent scomp = mock(ServiceComponent.class);\n    ServiceComponentHost sch = mock(ServiceComponentHost.class);\n    UnitOfWork unitOfWork = mock(UnitOfWork.class);\n    when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);\n    when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);\n    when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);\n    when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);\n    when(serviceObj.getCluster()).thenReturn(oneClusterMock);\n\n    String hostname1 = \"ahost.ambari.apache.org\";\n\n    HashMap<String, ServiceComponentHost> hosts = new HashMap<String, ServiceComponentHost>();\n\n    hosts.put(hostname1, sch);\n\n    when(scomp.getServiceComponentHosts()).thenReturn(hosts);\n\n    // create 1 stage with 2 commands and then another stage with 1 command\n    Stage stage = null;\n    Stage stage2 = null;\n    final List<Stage> stages = new ArrayList<Stage>();\n    stages.add(stage = getStageWithSingleTask(hostname1, \"cluster1\", Role.NAMENODE,\n        RoleCommand.STOP, Service.Type.HDFS, 1, 1, 1));\n\n    addInstallTaskToStage(stage, hostname1, \"cluster1\", Role.HBASE_MASTER, RoleCommand.INSTALL,\n        Service.Type.HBASE, 1);\n\n    stages.add(stage2 = getStageWithSingleTask(hostname1, \"cluster1\", Role.DATANODE,\n        RoleCommand.STOP, Service.Type.HDFS, 1, 1, 1));\n\n    // !!! this is the test; make the stages skippable so that when their\n    // commands fail, the entire request is not aborted\n    for (Stage stageToMakeSkippable : stages) {\n      stageToMakeSkippable.setSkippable(true);\n    }\n\n    // fail the first task - normally this would cause an abort, exception that our stages\n    // are skippable now so it should not\n    HostRoleCommand command = stage.getOrderedHostRoleCommands().iterator().next();\n    command.setStatus(HostRoleStatus.FAILED);\n\n    ActionDBAccessor db = mock(ActionDBAccessor.class);\n\n    RequestEntity request = mock(RequestEntity.class);\n    when(request.isExclusive()).thenReturn(false);\n    when(db.getRequestEntity(anyLong())).thenReturn(request);\n\n    when(db.getCommandsInProgressCount()).thenReturn(stages.size());\n    when(db.getStagesInProgress()).thenReturn(stages);\n\n    doAnswer(new Answer<Void>() {\n      @Override\n      public Void answer(InvocationOnMock invocation) throws Throwable {\n        List<CommandReport> reports = (List<CommandReport>) invocation.getArguments()[0];\n        for (CommandReport report : reports) {\n          String actionId = report.getActionId();\n          long[] requestStageIds = StageUtils.getRequestStage(actionId);\n          Long requestId = requestStageIds[0];\n          Long stageId = requestStageIds[1];\n          Long id = report.getTaskId();\n          for (Stage stage : stages) {\n            if (requestId.equals(stage.getRequestId()) && stageId.equals(stage.getStageId())) {\n              for (HostRoleCommand hostRoleCommand : stage.getOrderedHostRoleCommands()) {\n                if (hostRoleCommand.getTaskId() == id) {\n                  hostRoleCommand.setStatus(HostRoleStatus.valueOf(report.getStatus()));\n                }\n              }\n            }\n          }\n\n        }\n\n        return null;\n      }\n    }).when(db).updateHostRoleStates(anyCollectionOf(CommandReport.class));\n\n    when(db.getTask(anyLong())).thenAnswer(new Answer<Object>() {\n      @Override\n      public Object answer(InvocationOnMock invocation) throws Throwable {\n        Long taskId = (Long) invocation.getArguments()[0];\n        for (Stage stage : stages) {\n          for (HostRoleCommand command : stage.getOrderedHostRoleCommands()) {\n            if (taskId.equals(command.getTaskId())) {\n              return command;\n            }\n          }\n        }\n        return null;\n      }\n    });\n    doAnswer(new Answer<Void>() {\n      @Override\n      public Void answer(InvocationOnMock invocation) throws Throwable {\n        Long requestId = (Long) invocation.getArguments()[0];\n        for (Stage stage : stages) {\n          if (requestId.equals(stage.getRequestId())) {\n            for (HostRoleCommand command : stage.getOrderedHostRoleCommands()) {\n              if (command.getStatus() == HostRoleStatus.QUEUED\n                  || command.getStatus() == HostRoleStatus.IN_PROGRESS\n                  || command.getStatus() == HostRoleStatus.PENDING) {\n                command.setStatus(HostRoleStatus.ABORTED);\n              }\n            }\n          }\n        }\n\n        return null;\n      }\n    }).when(db).abortOperation(anyLong());\n\n    ActionScheduler scheduler = spy(new ActionScheduler(100, 50, db, aq, fsm, 3,\n        new HostsMap((String) null), unitOfWork, null, conf));\n\n    doReturn(false).when(scheduler).wasAgentRestartedDuringOperation(any(Host.class), any(Stage.class), anyString());\n\n    scheduler.doWork();\n\n    Assert.assertEquals(HostRoleStatus.FAILED,\n        stages.get(0).getHostRoleStatus(hostname1, \"NAMENODE\"));\n\n    // the remaining tasks should NOT have been aborted since the stage is\n    // skippable - these tasks would normally be ABORTED if the stage was not\n    // skippable\n    Assert.assertEquals(HostRoleStatus.QUEUED,\n        stages.get(0).getHostRoleStatus(hostname1, \"HBASE_MASTER\"));\n\n    Assert.assertEquals(HostRoleStatus.PENDING,\n        stages.get(1).getHostRoleStatus(hostname1, \"DATANODE\"));\n\n  }","id":6846,"modified_method":"/**\n   * Tests that command failures in skippable stages do not cause the request to\n   * be aborted.\n   */\n  @Test\n  public void testSkippableCommandFailureDoesNotAbortRequest() throws Exception {\n    Properties properties = new Properties();\n    Configuration conf = new Configuration(properties);\n    ActionQueue aq = new ActionQueue();\n    Clusters fsm = mock(Clusters.class);\n    Cluster oneClusterMock = mock(Cluster.class);\n    Service serviceObj = mock(Service.class);\n    ServiceComponent scomp = mock(ServiceComponent.class);\n    ServiceComponentHost sch = mock(ServiceComponentHost.class);\n    UnitOfWork unitOfWork = mock(UnitOfWork.class);\n    when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);\n    when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);\n    when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);\n    when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);\n    when(serviceObj.getCluster()).thenReturn(oneClusterMock);\n\n    String hostname1 = \"ahost.ambari.apache.org\";\n\n    HashMap<String, ServiceComponentHost> hosts = new HashMap<String, ServiceComponentHost>();\n\n    hosts.put(hostname1, sch);\n\n    when(scomp.getServiceComponentHosts()).thenReturn(hosts);\n\n    // create 1 stage with 2 commands and then another stage with 1 command\n    Stage stage = null;\n    Stage stage2 = null;\n    final List<Stage> stages = new ArrayList<Stage>();\n    stages.add(stage = getStageWithSingleTask(hostname1, \"cluster1\", Role.NAMENODE,\n        RoleCommand.STOP, Service.Type.HDFS, 1, 1, 1));\n\n    addInstallTaskToStage(stage, hostname1, \"cluster1\", Role.HBASE_MASTER, RoleCommand.INSTALL,\n        Service.Type.HBASE, 1);\n\n    stages.add(stage2 = getStageWithSingleTask(hostname1, \"cluster1\", Role.DATANODE,\n        RoleCommand.STOP, Service.Type.HDFS, 1, 1, 1));\n\n    // !!! this is the test; make the stages skippable so that when their\n    // commands fail, the entire request is not aborted\n    for (Stage stageToMakeSkippable : stages) {\n      stageToMakeSkippable.setSkippable(true);\n    }\n\n    // fail the first task - normally this would cause an abort, exception that our stages\n    // are skippable now so it should not\n    HostRoleCommand command = stage.getOrderedHostRoleCommands().iterator().next();\n    command.setStatus(HostRoleStatus.FAILED);\n\n    ActionDBAccessor db = mock(ActionDBAccessor.class);\n\n    RequestEntity request = mock(RequestEntity.class);\n    when(request.isExclusive()).thenReturn(false);\n    when(db.getRequestEntity(anyLong())).thenReturn(request);\n\n    when(db.getCommandsInProgressCount()).thenReturn(stages.size());\n    when(db.getStagesInProgress()).thenReturn(stages);\n\n    doAnswer(new Answer<Void>() {\n      @Override\n      public Void answer(InvocationOnMock invocation) throws Throwable {\n        List<CommandReport> reports = (List<CommandReport>) invocation.getArguments()[0];\n        for (CommandReport report : reports) {\n          String actionId = report.getActionId();\n          long[] requestStageIds = StageUtils.getRequestStage(actionId);\n          Long requestId = requestStageIds[0];\n          Long stageId = requestStageIds[1];\n          Long id = report.getTaskId();\n          for (Stage stage : stages) {\n            if (requestId.equals(stage.getRequestId()) && stageId.equals(stage.getStageId())) {\n              for (HostRoleCommand hostRoleCommand : stage.getOrderedHostRoleCommands()) {\n                if (hostRoleCommand.getTaskId() == id) {\n                  hostRoleCommand.setStatus(HostRoleStatus.valueOf(report.getStatus()));\n                }\n              }\n            }\n          }\n\n        }\n\n        return null;\n      }\n    }).when(db).updateHostRoleStates(anyCollectionOf(CommandReport.class));\n\n    when(db.getTask(anyLong())).thenAnswer(new Answer<Object>() {\n      @Override\n      public Object answer(InvocationOnMock invocation) throws Throwable {\n        Long taskId = (Long) invocation.getArguments()[0];\n        for (Stage stage : stages) {\n          for (HostRoleCommand command : stage.getOrderedHostRoleCommands()) {\n            if (taskId.equals(command.getTaskId())) {\n              return command;\n            }\n          }\n        }\n        return null;\n      }\n    });\n    doAnswer(new Answer<Void>() {\n      @Override\n      public Void answer(InvocationOnMock invocation) throws Throwable {\n        Long requestId = (Long) invocation.getArguments()[0];\n        for (Stage stage : stages) {\n          if (requestId.equals(stage.getRequestId())) {\n            for (HostRoleCommand command : stage.getOrderedHostRoleCommands()) {\n              if (command.getStatus() == HostRoleStatus.QUEUED\n                  || command.getStatus() == HostRoleStatus.IN_PROGRESS\n                  || command.getStatus() == HostRoleStatus.PENDING) {\n                command.setStatus(HostRoleStatus.ABORTED);\n              }\n            }\n          }\n        }\n\n        return null;\n      }\n    }).when(db).abortOperation(anyLong());\n\n    ActionScheduler scheduler = new ActionScheduler(100, 50, db, aq, fsm, 3,\n        new HostsMap((String) null), unitOfWork, null, conf);\n\n    scheduler.doWork();\n\n    Assert.assertEquals(HostRoleStatus.FAILED,\n        stages.get(0).getHostRoleStatus(hostname1, \"NAMENODE\"));\n\n    // the remaining tasks should NOT have been aborted since the stage is\n    // skippable - these tasks would normally be ABORTED if the stage was not\n    // skippable\n    Assert.assertEquals(HostRoleStatus.QUEUED,\n        stages.get(0).getHostRoleStatus(hostname1, \"HBASE_MASTER\"));\n\n    Assert.assertEquals(HostRoleStatus.PENDING,\n        stages.get(1).getHostRoleStatus(hostname1, \"DATANODE\"));\n\n  }","commit_id":"825d557ae63e5bb6a7d22e0132c96dc599d12ad0","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Verifies that ActionScheduler allows to execute background tasks in parallel\n   */\n  @Test\n  public void testBackgroundStagesExecutionEnable() throws Exception {\n    ActionQueue aq = new ActionQueue();\n    Clusters fsm = mock(Clusters.class);\n    Cluster oneClusterMock = mock(Cluster.class);\n    Service serviceObj = mock(Service.class);\n    ServiceComponent scomp = mock(ServiceComponent.class);\n    ServiceComponentHost sch = mock(ServiceComponentHost.class);\n    UnitOfWork unitOfWork = mock(UnitOfWork.class);\n    when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);\n    when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);\n    when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);\n    when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);\n    when(serviceObj.getCluster()).thenReturn(oneClusterMock);\n\n    String hostname1 = \"ahost.ambari.apache.org\";\n    String hostname2 = \"bhost.ambari.apache.org\";\n    HashMap<String, ServiceComponentHost> hosts =\n        new HashMap<String, ServiceComponentHost>();\n    hosts.put(hostname1, sch);\n    hosts.put(hostname2, sch);\n    when(scomp.getServiceComponentHosts()).thenReturn(hosts);\n\n    List<Stage> stages = new ArrayList<Stage>();\n    Stage backgroundStage = null;\n    stages.add(//stage with background command\n        backgroundStage = getStageWithSingleTask(\n            hostname1, \"cluster1\", Role.NAMENODE, RoleCommand.CUSTOM_COMMAND, \"REBALANCEHDFS\", Service.Type.HDFS, 1, 1, 1));\n\n    Assert.assertEquals(AgentCommandType.BACKGROUND_EXECUTION_COMMAND ,backgroundStage.getExecutionCommands(hostname1).get(0).getExecutionCommand().getCommandType());\n\n    stages.add( // Stage with the same hostname, should be scheduled\n        getStageWithSingleTask(\n            hostname1, \"cluster1\", Role.GANGLIA_MONITOR,\n            RoleCommand.START, Service.Type.GANGLIA, 2, 2, 2));\n\n    stages.add(\n        getStageWithSingleTask(\n            hostname2, \"cluster1\", Role.DATANODE,\n            RoleCommand.START, Service.Type.HDFS, 3, 3, 3));\n\n\n    ActionDBAccessor db = mock(ActionDBAccessor.class);\n\n    RequestEntity request = mock(RequestEntity.class);\n    when(request.isExclusive()).thenReturn(false);\n    when(db.getRequestEntity(anyLong())).thenReturn(request);\n\n    when(db.getCommandsInProgressCount()).thenReturn(stages.size());\n    when(db.getStagesInProgress()).thenReturn(stages);\n\n    Properties properties = new Properties();\n    properties.put(Configuration.PARALLEL_STAGE_EXECUTION_KEY, \"true\");\n    Configuration conf = new Configuration(properties);\n    ActionScheduler scheduler = spy(new ActionScheduler(100, 50, db, aq, fsm, 3,\n        new HostsMap((String) null),\n        unitOfWork, null, conf));\n\n    doReturn(false).when(scheduler).wasAgentRestartedDuringOperation(any(Host.class), any(Stage.class), anyString());\n\n    scheduler.doWork();\n\n    Assert.assertEquals(HostRoleStatus.QUEUED, stages.get(0).getHostRoleStatus(hostname1, \"NAMENODE\"));\n    Assert.assertEquals(HostRoleStatus.QUEUED, stages.get(2).getHostRoleStatus(hostname2, \"DATANODE\"));\n\n    Assert.assertEquals(HostRoleStatus.QUEUED, stages.get(1).getHostRoleStatus(hostname1, \"GANGLIA_MONITOR\"));\n  }","id":6847,"modified_method":"/**\n   * Verifies that ActionScheduler allows to execute background tasks in parallel\n   */\n  @Test\n  public void testBackgroundStagesExecutionEnable() throws Exception {\n    ActionQueue aq = new ActionQueue();\n    Clusters fsm = mock(Clusters.class);\n    Cluster oneClusterMock = mock(Cluster.class);\n    Service serviceObj = mock(Service.class);\n    ServiceComponent scomp = mock(ServiceComponent.class);\n    ServiceComponentHost sch = mock(ServiceComponentHost.class);\n    UnitOfWork unitOfWork = mock(UnitOfWork.class);\n    when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);\n    when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);\n    when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);\n    when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);\n    when(serviceObj.getCluster()).thenReturn(oneClusterMock);\n\n    String hostname1 = \"ahost.ambari.apache.org\";\n    String hostname2 = \"bhost.ambari.apache.org\";\n    HashMap<String, ServiceComponentHost> hosts =\n        new HashMap<String, ServiceComponentHost>();\n    hosts.put(hostname1, sch);\n    hosts.put(hostname2, sch);\n    when(scomp.getServiceComponentHosts()).thenReturn(hosts);\n\n    List<Stage> stages = new ArrayList<Stage>();\n    Stage backgroundStage = null;\n    stages.add(//stage with background command\n        backgroundStage = getStageWithSingleTask(\n            hostname1, \"cluster1\", Role.NAMENODE, RoleCommand.CUSTOM_COMMAND, \"REBALANCEHDFS\", Service.Type.HDFS, 1, 1, 1));\n\n    Assert.assertEquals(AgentCommandType.BACKGROUND_EXECUTION_COMMAND ,backgroundStage.getExecutionCommands(hostname1).get(0).getExecutionCommand().getCommandType());\n\n    stages.add( // Stage with the same hostname, should be scheduled\n        getStageWithSingleTask(\n            hostname1, \"cluster1\", Role.GANGLIA_MONITOR,\n            RoleCommand.START, Service.Type.GANGLIA, 2, 2, 2));\n\n    stages.add(\n        getStageWithSingleTask(\n            hostname2, \"cluster1\", Role.DATANODE,\n            RoleCommand.START, Service.Type.HDFS, 3, 3, 3));\n\n\n    ActionDBAccessor db = mock(ActionDBAccessor.class);\n\n    RequestEntity request = mock(RequestEntity.class);\n    when(request.isExclusive()).thenReturn(false);\n    when(db.getRequestEntity(anyLong())).thenReturn(request);\n\n    when(db.getCommandsInProgressCount()).thenReturn(stages.size());\n    when(db.getStagesInProgress()).thenReturn(stages);\n\n    Properties properties = new Properties();\n    properties.put(Configuration.PARALLEL_STAGE_EXECUTION_KEY, \"true\");\n    Configuration conf = new Configuration(properties);\n    ActionScheduler scheduler = new ActionScheduler(100, 50, db, aq, fsm, 3,\n        new HostsMap((String) null),\n        unitOfWork, null, conf);\n\n    scheduler.doWork();\n\n    Assert.assertEquals(HostRoleStatus.QUEUED, stages.get(0).getHostRoleStatus(hostname1, \"NAMENODE\"));\n    Assert.assertEquals(HostRoleStatus.QUEUED, stages.get(2).getHostRoleStatus(hostname2, \"DATANODE\"));\n\n    Assert.assertEquals(HostRoleStatus.QUEUED, stages.get(1).getHostRoleStatus(hostname1, \"GANGLIA_MONITOR\"));\n  }","commit_id":"825d557ae63e5bb6a7d22e0132c96dc599d12ad0","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Verifies that stages that are executed on different hosts and\n   * rely to different requests are scheduled to be  executed in parallel\n   */\n  @Test\n  public void testIndependentStagesExecution() throws Exception {\n    ActionQueue aq = new ActionQueue();\n    Clusters fsm = mock(Clusters.class);\n    Cluster oneClusterMock = mock(Cluster.class);\n    Service serviceObj = mock(Service.class);\n    ServiceComponent scomp = mock(ServiceComponent.class);\n    ServiceComponentHost sch = mock(ServiceComponentHost.class);\n    UnitOfWork unitOfWork = mock(UnitOfWork.class);\n    //Stage stage = mock(Stage.class);\n    when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);\n    when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);\n    when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);\n    when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);\n    when(serviceObj.getCluster()).thenReturn(oneClusterMock);\n\n    String hostname1 = \"ahost.ambari.apache.org\";\n    String hostname2 = \"bhost.ambari.apache.org\";\n    String hostname3 = \"chost.ambari.apache.org\";\n    String hostname4 = \"chost.ambari.apache.org\";\n    HashMap<String, ServiceComponentHost> hosts =\n            new HashMap<String, ServiceComponentHost>();\n    hosts.put(hostname1, sch);\n    hosts.put(hostname2, sch);\n    hosts.put(hostname3, sch);\n    hosts.put(hostname4, sch);\n    when(scomp.getServiceComponentHosts()).thenReturn(hosts);\n\n    List<Stage> stages = new ArrayList<Stage>();\n    stages.add(\n            getStageWithSingleTask(\n                    hostname1, \"cluster1\", Role.DATANODE,\n                    RoleCommand.START, Service.Type.HDFS, 1, 1, 1));\n    stages.add( // Stage with the same hostname, should not be scheduled\n            getStageWithSingleTask(\n                    hostname1, \"cluster1\", Role.GANGLIA_MONITOR,\n                    RoleCommand.START, Service.Type.GANGLIA, 2, 2, 2));\n\n    stages.add(\n            getStageWithSingleTask(\n                    hostname2, \"cluster1\", Role.DATANODE,\n                    RoleCommand.START, Service.Type.HDFS, 3, 3, 3));\n\n    stages.add(\n        getStageWithSingleTask(\n            hostname3, \"cluster1\", Role.DATANODE,\n            RoleCommand.START, Service.Type.HDFS, 4, 4, 4));\n\n    stages.add( // Stage with the same request id, should not be scheduled\n        getStageWithSingleTask(\n            hostname4, \"cluster1\", Role.GANGLIA_MONITOR,\n            RoleCommand.START, Service.Type.GANGLIA, 5, 5, 4));\n\n    ActionDBAccessor db = mock(ActionDBAccessor.class);\n\n    RequestEntity request = mock(RequestEntity.class);\n    when(request.isExclusive()).thenReturn(false);\n    when(db.getRequestEntity(anyLong())).thenReturn(request);\n\n    when(db.getCommandsInProgressCount()).thenReturn(stages.size());\n    when(db.getStagesInProgress()).thenReturn(stages);\n\n    Properties properties = new Properties();\n    Configuration conf = new Configuration(properties);\n    ActionScheduler scheduler = spy(new ActionScheduler(100, 50, db, aq, fsm, 3,\n            new HostsMap((String) null), unitOfWork, null, conf));\n\n    doReturn(false).when(scheduler).wasAgentRestartedDuringOperation(any(Host.class), any(Stage.class), anyString());\n\n    scheduler.doWork();\n\n    Assert.assertEquals(HostRoleStatus.QUEUED, stages.get(0).getHostRoleStatus(hostname1, \"DATANODE\"));\n    Assert.assertEquals(HostRoleStatus.PENDING, stages.get(1).getHostRoleStatus(hostname1, \"GANGLIA_MONITOR\"));\n    Assert.assertEquals(HostRoleStatus.QUEUED, stages.get(2).getHostRoleStatus(hostname2, \"DATANODE\"));\n    Assert.assertEquals(HostRoleStatus.QUEUED, stages.get(3).getHostRoleStatus(hostname3, \"DATANODE\"));\n    Assert.assertEquals(HostRoleStatus.PENDING, stages.get(4).getHostRoleStatus(hostname4, \"GANGLIA_MONITOR\"));\n  }","id":6848,"modified_method":"/**\n   * Verifies that stages that are executed on different hosts and\n   * rely to different requests are scheduled to be  executed in parallel\n   */\n  @Test\n  public void testIndependentStagesExecution() throws Exception {\n    ActionQueue aq = new ActionQueue();\n    Clusters fsm = mock(Clusters.class);\n    Cluster oneClusterMock = mock(Cluster.class);\n    Service serviceObj = mock(Service.class);\n    ServiceComponent scomp = mock(ServiceComponent.class);\n    ServiceComponentHost sch = mock(ServiceComponentHost.class);\n    UnitOfWork unitOfWork = mock(UnitOfWork.class);\n    //Stage stage = mock(Stage.class);\n    when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);\n    when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);\n    when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);\n    when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);\n    when(serviceObj.getCluster()).thenReturn(oneClusterMock);\n\n    String hostname1 = \"ahost.ambari.apache.org\";\n    String hostname2 = \"bhost.ambari.apache.org\";\n    String hostname3 = \"chost.ambari.apache.org\";\n    String hostname4 = \"chost.ambari.apache.org\";\n    HashMap<String, ServiceComponentHost> hosts =\n            new HashMap<String, ServiceComponentHost>();\n    hosts.put(hostname1, sch);\n    hosts.put(hostname2, sch);\n    hosts.put(hostname3, sch);\n    hosts.put(hostname4, sch);\n    when(scomp.getServiceComponentHosts()).thenReturn(hosts);\n\n    List<Stage> stages = new ArrayList<Stage>();\n    stages.add(\n            getStageWithSingleTask(\n                    hostname1, \"cluster1\", Role.DATANODE,\n                    RoleCommand.START, Service.Type.HDFS, 1, 1, 1));\n    stages.add( // Stage with the same hostname, should not be scheduled\n            getStageWithSingleTask(\n                    hostname1, \"cluster1\", Role.GANGLIA_MONITOR,\n                    RoleCommand.START, Service.Type.GANGLIA, 2, 2, 2));\n\n    stages.add(\n            getStageWithSingleTask(\n                    hostname2, \"cluster1\", Role.DATANODE,\n                    RoleCommand.START, Service.Type.HDFS, 3, 3, 3));\n\n    stages.add(\n        getStageWithSingleTask(\n            hostname3, \"cluster1\", Role.DATANODE,\n            RoleCommand.START, Service.Type.HDFS, 4, 4, 4));\n\n    stages.add( // Stage with the same request id, should not be scheduled\n        getStageWithSingleTask(\n            hostname4, \"cluster1\", Role.GANGLIA_MONITOR,\n            RoleCommand.START, Service.Type.GANGLIA, 5, 5, 4));\n\n    ActionDBAccessor db = mock(ActionDBAccessor.class);\n\n    RequestEntity request = mock(RequestEntity.class);\n    when(request.isExclusive()).thenReturn(false);\n    when(db.getRequestEntity(anyLong())).thenReturn(request);\n\n    when(db.getCommandsInProgressCount()).thenReturn(stages.size());\n    when(db.getStagesInProgress()).thenReturn(stages);\n\n    Properties properties = new Properties();\n    Configuration conf = new Configuration(properties);\n    ActionScheduler scheduler = new ActionScheduler(100, 50, db, aq, fsm, 3,\n            new HostsMap((String) null), unitOfWork, null, conf);\n\n    scheduler.doWork();\n\n    Assert.assertEquals(HostRoleStatus.QUEUED, stages.get(0).getHostRoleStatus(hostname1, \"DATANODE\"));\n    Assert.assertEquals(HostRoleStatus.PENDING, stages.get(1).getHostRoleStatus(hostname1, \"GANGLIA_MONITOR\"));\n    Assert.assertEquals(HostRoleStatus.QUEUED, stages.get(2).getHostRoleStatus(hostname2, \"DATANODE\"));\n    Assert.assertEquals(HostRoleStatus.QUEUED, stages.get(3).getHostRoleStatus(hostname3, \"DATANODE\"));\n    Assert.assertEquals(HostRoleStatus.PENDING, stages.get(4).getHostRoleStatus(hostname4, \"GANGLIA_MONITOR\"));\n  }","commit_id":"825d557ae63e5bb6a7d22e0132c96dc599d12ad0","url":"https://github.com/apache/ambari"},{"original_method":"public DeleteResult[] delete(String[] id) throws KettleException\r\n  {\r\n\t  try {\r\n\t\t  return getBinding().delete(id);\r\n\t  }catch(Exception e) {\r\n\t\t  throw new KettleException(\"Erreur while doing delete operation!\", e);\r\n\t  }\r\n  }","id":6849,"modified_method":"public DeleteResult[] delete(String[] id) throws KettleException\r\n  {\r\n\t  try {\r\n\t\t  return getBinding().delete(id);\r\n\t  }catch(Exception e) {\r\n\t\t  throw new KettleException(BaseMessages.getString(PKG, \"SalesforceInput.ErrorDelete\"), e);\r\n\t  }\r\n  }","commit_id":"9a2a1e705c8cb1a4a6e704941a9459dddd07397a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public UpsertResult[] upsert(String upsertField, SObject[] sfBuffer) throws KettleException\r\n  {\r\n\t  try {\r\n\t\t  return getBinding().upsert(upsertField, sfBuffer);\r\n\t  }catch(Exception e) {\r\n\t\t  throw new KettleException(\"Erreur while doing upsert operation!\", e);\r\n\t  }\r\n  }","id":6850,"modified_method":"public UpsertResult[] upsert(String upsertField, SObject[] sfBuffer) throws KettleException\r\n  {\r\n\t  try {\r\n\t\t  return getBinding().upsert(upsertField, sfBuffer);\r\n\t  }catch(Exception e) {\r\n\t\t  throw new KettleException(BaseMessages.getString(PKG, \"SalesforceInput.ErrorUpsert\"), e);\r\n\t  }\r\n  }","commit_id":"9a2a1e705c8cb1a4a6e704941a9459dddd07397a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public SaveResult[] insert(SObject[] sfBuffer) throws KettleException\r\n  {\r\n\t  try {\r\n\t\t  return getBinding().create(sfBuffer);\r\n\t  }catch(Exception e) {\r\n\t\t  throw new KettleException(\"Erreur while doing insert operation!\", e);\r\n\t  }\r\n  }","id":6851,"modified_method":"public SaveResult[] insert(SObject[] sfBuffer) throws KettleException\r\n  {\r\n\t  try {\r\n\t\t  return getBinding().create(sfBuffer);\r\n\t  }catch(Exception e) {\r\n\t\t  throw new KettleException(BaseMessages.getString(PKG, \"SalesforceInput.ErrorInsert\"), e);\r\n\t  }\r\n  }","commit_id":"9a2a1e705c8cb1a4a6e704941a9459dddd07397a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public SaveResult[] update(SObject[] sfBuffer) throws KettleException\r\n  {\r\n\t  try {\r\n\t\t  return getBinding().update(sfBuffer);\r\n\t  }catch(Exception e) {\r\n\t\t  throw new KettleException(\"Erreur while doing update operation!\", e);\r\n\t  }\r\n  }","id":6852,"modified_method":"public SaveResult[] update(SObject[] sfBuffer) throws KettleException\r\n  {\r\n\t  try {\r\n\t\t  return getBinding().update(sfBuffer);\r\n\t  }catch(Exception e) {\r\n\t\t  throw new KettleException(BaseMessages.getString(PKG, \"SalesforceInput.ErrorUpdate\"), e);\r\n\t  }\r\n  }","commit_id":"9a2a1e705c8cb1a4a6e704941a9459dddd07397a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void flushBuffers() throws KettleException\r\n\t{\r\n\t\t\r\n\t\ttry {\r\n\t\t\t// create the object(s) by sending the array to the web service\r\n\t\t\tdata.saveResult = data.connection.insert(data.sfBuffer);\r\n\t\t\tfor (int j = 0; j < data.saveResult.length; j++) {\r\n\t\t\t\tif (data.saveResult[j].isSuccess()) {\r\n\t\t\t\t\t// Row was inserted\r\n\t\t\t\t\tString id=data.saveResult[j].getId();\r\n\t\t\t\t\tif (log.isDebug()) logDebug(\"Row was inserted with id: \" + id);\r\n\r\n\t\t\t\t\t// write out the row with the SalesForce ID\r\n\t\t\t\t\tObject[] newRow = RowDataUtil.resizeArray(data.outputBuffer[j], data.outputRowMeta.size());\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(data.realSalesforceFieldName!=null) {\r\n\t\t\t\t\t\tint newIndex = getInputRowMeta().size();\r\n\t\t\t\t\t\tnewRow[newIndex++] = id;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (log.isDetailed()) logDetailed(\"The new row has an id value of : \" + newRow[0]);\r\n\t\t\t\t\t\r\n\t\t\t\t\t//putRow(data.outputRowMeta, data.outputRowMeta.cloneRow(newRow));  // copy row to output rowset(s);\r\n\t\t\t\t\tputRow(data.outputRowMeta, newRow);  // copy row to output rowset(s);\r\n\t\t\t\t\tincrementLinesOutput();\r\n\t\t\t\t\t\r\n\t\t\t\t    if (checkFeedback(getLinesInput()))\r\n\t\t\t\t    {\r\n\t\t\t\t    \tif(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceInsert.log.LineRow\",\"\"+ getLinesInput()));\r\n\t\t\t\t    }\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// there were errors during the create call, go through the\r\n\t\t\t\t\t// errors\r\n\t\t\t\t\t// array and write them to the screen\r\n\t\t\t        boolean sendToErrorRow=false;\r\n\t\t\t\t\tString errorMessage = null;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (getStepMeta().isDoingErrorHandling())\r\n\t\t\t\t\t{\r\n\t\t\t\t         sendToErrorRow = true;\r\n\t\t\t\t         errorMessage = \"\";\r\n\t\t\t\t         for (int i = 0; i < data.saveResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\t\t// get the next error\r\n\t\t\t\t\t\t\t\tcom.sforce.soap.partner.Error err = data.saveResult[j].getErrors()[i];\r\n\t\t\t\t\t\t\t\terrorMessage+= BaseMessages.getString(PKG, \"SalesforceInsert.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(log.isDebug()) logDebug(\"Found error from SalesForce and raising the exception\"); \r\n\t\t\t\t\t\t//for (int i = 0; i < data.saveResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Only show the first error\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t\tcom.sforce.soap.partner.Error err = data.saveResult[j].getErrors()[0];\r\n\t\t\t\t\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SalesforceInsert.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage()));\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t// } // for error messages\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (sendToErrorRow) {\r\n\t\t\t\t\t\t   // Simply add this row to the error row\r\n\t\t\t\t\t\tif(log.isDetailed()) logDetailed(\"Passing row to error step\");\r\n\t\t\t\t\t\t   putError(getInputRowMeta(), data.outputBuffer[j], 1, errorMessage, null, \"SalesforceInsert001\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t} \r\n\t\t\t\t\r\n\t\t\t} \r\n\t\t\t\r\n\t\t\t// reset the buffers\r\n\t\t\tdata.sfBuffer = new SObject[meta.getBatchSizeInt()];\r\n\t\t\tdata.outputBuffer = new Object[meta.getBatchSizeInt()][];\r\n\t\t\tdata.iBufferPos = 0;\r\n\t\t\t\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new KettleException(\"\\nFailed to upsert object, error message was: \\n\"+ e.getMessage());\r\n\t\t} finally{\r\n\t\t\tif(data.saveResult!=null) data.saveResult=null;\r\n\t\t}\r\n\r\n\t}","id":6853,"modified_method":"private void flushBuffers() throws KettleException\r\n\t{\t\r\n\t\ttry {\r\n\t\t\t// create the object(s) by sending the array to the web service\r\n\t\t\tdata.saveResult = data.connection.insert(data.sfBuffer);\r\n\t\t\tfor (int j = 0; j < data.saveResult.length; j++) {\r\n\t\t\t\tif (data.saveResult[j].isSuccess()) {\r\n\t\t\t\t\t// Row was inserted\r\n\t\t\t\t\tString id=data.saveResult[j].getId();\r\n\t\t\t\t\tif (log.isDebug()) logDebug(BaseMessages.getString(PKG, \"SalesforceInsert.RowInserted\", id));\r\n\r\n\t\t\t\t\t// write out the row with the SalesForce ID\r\n\t\t\t\t\tObject[] newRow = RowDataUtil.resizeArray(data.outputBuffer[j], data.outputRowMeta.size());\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(data.realSalesforceFieldName!=null) {\r\n\t\t\t\t\t\tint newIndex = getInputRowMeta().size();\r\n\t\t\t\t\t\tnewRow[newIndex++] = id;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceInsert.NewRow\", newRow[0]));\r\n\t\t\t\t\t\r\n\t\t\t\t\t//putRow(data.outputRowMeta, data.outputRowMeta.cloneRow(newRow));  // copy row to output rowset(s);\r\n\t\t\t\t\tputRow(data.outputRowMeta, newRow);  // copy row to output rowset(s);\r\n\t\t\t\t\tincrementLinesOutput();\r\n\t\t\t\t\t\r\n\t\t\t\t    if (checkFeedback(getLinesInput()))\r\n\t\t\t\t    {\r\n\t\t\t\t    \tif(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceInsert.log.LineRow\", getLinesInput()));\r\n\t\t\t\t    }\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// there were errors during the create call, go through the\r\n\t\t\t\t\t// errors\r\n\t\t\t\t\t// array and write them to the screen\r\n\t\t\t        boolean sendToErrorRow=false;\r\n\t\t\t\t\tString errorMessage = null;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (getStepMeta().isDoingErrorHandling())\r\n\t\t\t\t\t{\r\n\t\t\t\t         sendToErrorRow = true;\r\n\t\t\t\t         errorMessage = \"\";\r\n\t\t\t\t         for (int i = 0; i < data.saveResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\t\t// get the next error\r\n\t\t\t\t\t\t\t\tcom.sforce.soap.partner.Error err = data.saveResult[j].getErrors()[i];\r\n\t\t\t\t\t\t\t\terrorMessage+= BaseMessages.getString(PKG, \"SalesforceInsert.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(log.isDebug()) logDebug(BaseMessages.getString(PKG, \"SalesforceInsert.ErrorFound\")); \r\n\t\t\t\t\t\t//for (int i = 0; i < data.saveResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Only show the first error\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t\tcom.sforce.soap.partner.Error err = data.saveResult[j].getErrors()[0];\r\n\t\t\t\t\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SalesforceInsert.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage()));\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t// } // for error messages\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (sendToErrorRow) {\r\n\t\t\t\t\t\t   // Simply add this row to the error row\r\n\t\t\t\t\t\tif(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceInsert.PassingRowToErrorStep\"));\r\n\t\t\t\t\t\t   putError(getInputRowMeta(), data.outputBuffer[j], 1, errorMessage, null, \"SalesforceInsert001\");\r\n\t\t\t\t\t}\r\n\t\t\t\t} \r\n\t\t\t\t\r\n\t\t\t} \r\n\t\t\t\r\n\t\t\t// reset the buffers\r\n\t\t\tdata.sfBuffer = new SObject[meta.getBatchSizeInt()];\r\n\t\t\tdata.outputBuffer = new Object[meta.getBatchSizeInt()][];\r\n\t\t\tdata.iBufferPos = 0;\r\n\t\t\t\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SalesforceInsert.FailedToInsertObject\", e.getMessage()));\r\n\t\t} finally{\r\n\t\t\tif(data.saveResult!=null) data.saveResult=null;\r\n\t\t}\r\n\r\n\t}","commit_id":"9a2a1e705c8cb1a4a6e704941a9459dddd07397a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void flushBuffers() throws KettleException\r\n\t{\r\n\t\t\r\n\t\ttry {\r\n\t\t\t// create the object(s) by sending the array to the web service\r\n\t\t\tdata.upsertResult = data.connection.upsert(meta.getUpsertField(), data.sfBuffer);\r\n\t\t\tfor (int j = 0; j < data.upsertResult.length; j++) {\r\n\t\t\t\tif (data.upsertResult[j].isSuccess()) {\r\n\t\t\t\t\tString id=data.upsertResult[j].getId();\r\n\t\t\t\t\tif(data.upsertResult[j].isCreated()) {\r\n\t\t\t\t\t\tif (log.isDetailed()) logDetailed(\"An account was create with an id of: \" + id);\r\n\t\t\t\t\t}else {\r\n\t\t\t\t\t\tif (log.isDetailed()) logDetailed(\"Account with id of: \" + id + \" was updated\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// write out the row with the SalesForce ID\r\n\t\t\t\t\tObject[] newRow = RowDataUtil.resizeArray(data.outputBuffer[j], data.outputRowMeta.size());\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(data.realSalesforceFieldName!=null) {\r\n\t\t\t\t\t\tint newIndex = getInputRowMeta().size();\r\n\t\t\t\t\t\tnewRow[newIndex++] = id;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (log.isDetailed()) logDetailed(\"The new row has an id value of : \" + newRow[0]);\r\n\t\t\t\t\t\r\n\t\t\t\t\t//putRow(data.outputRowMeta, data.outputRowMeta.cloneRow(newRow));  // copy row to output rowset(s);\r\n\t\t\t\t\tputRow(data.outputRowMeta, newRow);  // copy row to output rowset(s);\r\n\t\t\t\t\tincrementLinesOutput();\r\n\t\t\t\t\t\r\n\t\t\t\t    if (checkFeedback(getLinesInput()))\r\n\t\t\t\t    {\r\n\t\t\t\t    \tif(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceUpsert.log.LineRow\",\"\"+ getLinesInput()));\r\n\t\t\t\t    }\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// there were errors during the create call, go through the\r\n\t\t\t\t\t// errors\r\n\t\t\t\t\t// array and write them to the screen\r\n\t\t\t        boolean sendToErrorRow=false;\r\n\t\t\t\t\tString errorMessage = null;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (getStepMeta().isDoingErrorHandling())\r\n\t\t\t\t\t{\r\n\t\t\t\t         sendToErrorRow = true;\r\n\t\t\t\t         errorMessage = \"\";\r\n\t\t\t\t         for (int i = 0; i < data.upsertResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\t\t// get the next error\r\n\t\t\t\t\t\t\t\tcom.sforce.soap.partner.Error err = data.upsertResult[j].getErrors()[i];\r\n\t\t\t\t\t\t\t\terrorMessage+= BaseMessages.getString(PKG, \"SalesforceUpsert.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(log.isDetailed()) logDetailed(\"Found error from SalesForce and raising the exception\"); \r\n\t\t\t\t\t\t// for (int i = 0; i < data.upsertResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Only throw the first error\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t\tcom.sforce.soap.partner.Error err = data.upsertResult[j].getErrors()[0];\r\n\t\t\t\t\t\t\tthrow new KettleException( BaseMessages.getString(PKG, \"SalesforceUpsert.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage()));\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t// } // for error messages\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (sendToErrorRow) {\r\n\t\t\t\t\t\t   // Simply add this row to the error row\r\n\t\t\t\t\t\tif(log.isDebug()) logDebug(\"Passing row to error step\");\r\n\t\t\t\t\t\t   putError(getInputRowMeta(), data.outputBuffer[j], 1, errorMessage, null, \"SalesforceUpsert001\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t} \r\n\t\t\t\t\r\n\t\t\t} \r\n\t\t\t\r\n\t\t\t// reset the buffers\r\n\t\t\tdata.sfBuffer = new SObject[meta.getBatchSizeInt()];\r\n\t\t\tdata.outputBuffer = new Object[meta.getBatchSizeInt()][];\r\n\t\t\tdata.iBufferPos = 0;\r\n\t\t\t\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new KettleException(\"\\nFailed to upsert object, error message was: \\n\"+ e.getMessage());\r\n\t\t} finally {\r\n\t\t\tif(data.upsertResult!=null) data.upsertResult=null;\r\n\t\t}\r\n\r\n\t}","id":6854,"modified_method":"private void flushBuffers() throws KettleException\r\n\t{\r\n\t\t\r\n\t\ttry {\r\n\t\t\t// create the object(s) by sending the array to the web service\r\n\t\t\tdata.upsertResult = data.connection.upsert(meta.getUpsertField(), data.sfBuffer);\r\n\t\t\tfor (int j = 0; j < data.upsertResult.length; j++) {\r\n\t\t\t\tif (data.upsertResult[j].isSuccess()) {\r\n\t\t\t\t\tString id=data.upsertResult[j].getId();\r\n\t\t\t\t\tif(data.upsertResult[j].isCreated()) {\r\n\t\t\t\t\t\tif (log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceUpsert.ObjectCreated\", id));\r\n\t\t\t\t\t}else {\r\n\t\t\t\t\t\tif (log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceUpsert.ObjectUpdated\", id));\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// write out the row with the SalesForce ID\r\n\t\t\t\t\tObject[] newRow = RowDataUtil.resizeArray(data.outputBuffer[j], data.outputRowMeta.size());\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(data.realSalesforceFieldName!=null) {\r\n\t\t\t\t\t\tint newIndex = getInputRowMeta().size();\r\n\t\t\t\t\t\tnewRow[newIndex++] = id;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceUpsert.NewRow\", newRow[0]));\r\n\t\t\t\t\t\r\n\t\t\t\t\t//putRow(data.outputRowMeta, data.outputRowMeta.cloneRow(newRow));  // copy row to output rowset(s);\r\n\t\t\t\t\tputRow(data.outputRowMeta, newRow);  // copy row to output rowset(s);\r\n\t\t\t\t\tincrementLinesOutput();\r\n\t\t\t\t\t\r\n\t\t\t\t    if (checkFeedback(getLinesInput()))\r\n\t\t\t\t    {\r\n\t\t\t\t    \tif(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceUpsert.log.LineRow\",\"\"+ getLinesInput()));\r\n\t\t\t\t    }\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// there were errors during the create call, go through the\r\n\t\t\t\t\t// errors\r\n\t\t\t\t\t// array and write them to the screen\r\n\t\t\t        boolean sendToErrorRow=false;\r\n\t\t\t\t\tString errorMessage = null;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (getStepMeta().isDoingErrorHandling())\r\n\t\t\t\t\t{\r\n\t\t\t\t         sendToErrorRow = true;\r\n\t\t\t\t         errorMessage = \"\";\r\n\t\t\t\t         for (int i = 0; i < data.upsertResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\t\t// get the next error\r\n\t\t\t\t\t\t\t\tcom.sforce.soap.partner.Error err = data.upsertResult[j].getErrors()[i];\r\n\t\t\t\t\t\t\t\terrorMessage+= BaseMessages.getString(PKG, \"SalesforceUpsert.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceUpsert.ErrorFound\")); \r\n\t\t\t\t\t\t// for (int i = 0; i < data.upsertResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Only throw the first error\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t\tcom.sforce.soap.partner.Error err = data.upsertResult[j].getErrors()[0];\r\n\t\t\t\t\t\t\tthrow new KettleException( BaseMessages.getString(PKG, \"SalesforceUpsert.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage()));\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t// } // for error messages\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (sendToErrorRow) {\r\n\t\t\t\t\t\t   // Simply add this row to the error row\r\n\t\t\t\t\t\tif(log.isDebug()) logDebug(BaseMessages.getString(PKG, \"SalesforceUpsert.PassingRowToErrorStep\"));\r\n\t\t\t\t\t\t   putError(getInputRowMeta(), data.outputBuffer[j], 1, errorMessage, null, \"SalesforceUpsert001\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t} \r\n\t\t\t\t\r\n\t\t\t} \r\n\t\t\t\r\n\t\t\t// reset the buffers\r\n\t\t\tdata.sfBuffer = new SObject[meta.getBatchSizeInt()];\r\n\t\t\tdata.outputBuffer = new Object[meta.getBatchSizeInt()][];\r\n\t\t\tdata.iBufferPos = 0;\r\n\t\t\t\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SalesforceUpsert.FailedUpsert\", e.getMessage()));\r\n\t\t} finally {\r\n\t\t\tif(data.upsertResult!=null) data.upsertResult=null;\r\n\t\t}\r\n\r\n\t}","commit_id":"9a2a1e705c8cb1a4a6e704941a9459dddd07397a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\r\n\t{\r\n\r\n\t \t// get one row ... This does some basic initialization of the objects, including loading the info coming in\r\n\t\tObject[] outputRowData = getRow(); \r\n\t\t\r\n\t\tif(outputRowData==null)\r\n\t\t{\r\n\t\t\tif ( data.iBufferPos > 0 ) \r\n\t\t\t{\r\n\t\t\t\tflushBuffers();\r\n\t\t\t}\r\n\t\t\tsetOutputDone();\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\t// If we haven't looked at a row before then do some basic setup.\r\n\t\tif(first)\r\n\t\t{\r\n\t\t\tfirst=false;\r\n\t\t\t\r\n\t\t\tdata.sfBuffer = new SObject[meta.getBatchSizeInt()];\r\n\t\t\tdata.outputBuffer = new Object[meta.getBatchSizeInt()][];\r\n\t\t\t \r\n\t\t\t// get total fields in the grid\r\n\t\t\tdata.nrfields = meta.getUpdateLookup().length;\r\n\t\t\t\t\r\n\t\t\t// Check if field list is filled \r\n\t\t\tif (data.nrfields==0)\r\n\t\t\t{\r\n\t\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SalesforceUpsertDialog.FieldsMissing.DialogMessage\"));\r\n\t\t\t}\r\n \r\n\t\t\t// Create the output row meta-data\r\n\t        data.outputRowMeta = getInputRowMeta().clone();\r\n\t\t\tmeta.getFields(data.outputRowMeta, getStepname(), null, null, this);\r\n\t\t\t\r\n\t\t\t// Build the mapping of input position to field name\r\n\t\t\tdata.fieldnrs = new int[meta.getUpdateStream().length];\r\n\t\t\tfor (int i = 0; i < meta.getUpdateStream().length; i++)\r\n\t\t\t{\r\n\t\t\t\tdata.fieldnrs[i] = getInputRowMeta().indexOfValue(meta.getUpdateStream()[i]);\r\n\t\t\t\tif (data.fieldnrs[i] < 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tthrow new KettleException(\"Field [\" + meta.getUpdateStream()[i]+ \"] couldn't be found in the input stream!\");\r\n\t\t\t\t}\r\n\t\t\t }\r\n\t\t}\r\n\r\n\t\ttry \r\n\t\t{\t\r\n\t\t\twriteToSalesForce(outputRowData);\r\n\r\n\t\t} \r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"SalesforceUpsert.log.Exception\"), e);\r\n\t\t} \r\n\t    return true; \r\n\t}","id":6855,"modified_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\r\n\t{\r\n\r\n\t \t// get one row ... This does some basic initialization of the objects, including loading the info coming in\r\n\t\tObject[] outputRowData = getRow(); \r\n\t\t\r\n\t\tif(outputRowData==null)\r\n\t\t{\r\n\t\t\tif ( data.iBufferPos > 0 ) \r\n\t\t\t{\r\n\t\t\t\tflushBuffers();\r\n\t\t\t}\r\n\t\t\tsetOutputDone();\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\t// If we haven't looked at a row before then do some basic setup.\r\n\t\tif(first)\r\n\t\t{\r\n\t\t\tfirst=false;\r\n\t\t\t\r\n\t\t\tdata.sfBuffer = new SObject[meta.getBatchSizeInt()];\r\n\t\t\tdata.outputBuffer = new Object[meta.getBatchSizeInt()][];\r\n\t\t\t \r\n\t\t\t// get total fields in the grid\r\n\t\t\tdata.nrfields = meta.getUpdateLookup().length;\r\n\t\t\t\t\r\n\t\t\t// Check if field list is filled \r\n\t\t\tif (data.nrfields==0)\r\n\t\t\t{\r\n\t\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SalesforceUpsertDialog.FieldsMissing.DialogMessage\"));\r\n\t\t\t}\r\n \r\n\t\t\t// Create the output row meta-data\r\n\t        data.outputRowMeta = getInputRowMeta().clone();\r\n\t\t\tmeta.getFields(data.outputRowMeta, getStepname(), null, null, this);\r\n\t\t\t\r\n\t\t\t// Build the mapping of input position to field name\r\n\t\t\tdata.fieldnrs = new int[meta.getUpdateStream().length];\r\n\t\t\tfor (int i = 0; i < meta.getUpdateStream().length; i++)\r\n\t\t\t{\r\n\t\t\t\tdata.fieldnrs[i] = getInputRowMeta().indexOfValue(meta.getUpdateStream()[i]);\r\n\t\t\t\tif (data.fieldnrs[i] < 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SalesforceUpsert.FieldNotFound\", meta.getUpdateStream()[i]));\r\n\t\t\t\t}\r\n\t\t\t }\r\n\t\t}\r\n\r\n\t\ttry \r\n\t\t{\t\r\n\t\t\twriteToSalesForce(outputRowData);\r\n\r\n\t\t} \r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"SalesforceUpsert.log.Exception\"), e);\r\n\t\t} \r\n\t    return true; \r\n\t}","commit_id":"9a2a1e705c8cb1a4a6e704941a9459dddd07397a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void writeToSalesForce(Object[] rowData) throws KettleException\r\n\t{\r\n\t\ttry {\t\t\t\r\n\r\n\t\t\tif (log.isDetailed()) logDetailed(\"Called writeToSalesForce with \" + data.iBufferPos + \" out of \" + meta.getBatchSizeInt());\r\n\t\t\t\r\n\t\t\t// if there is room in the buffer\r\n\t\t\tif ( data.iBufferPos < meta.getBatchSizeInt()) {\r\n\t\t\t\t// build the XML node\r\n\t\t\t\tMessageElement[] arNode = new MessageElement[data.nrfields];\r\n\t\t\t\tint index=0;\r\n\t\t\t\tfor ( int i = 0; i < data.nrfields; i++) {\r\n\t\t\t\t\tarNode[index++] = newMessageElement( meta.getUpdateLookup()[i], rowData[data.fieldnrs[i]]);\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t//build the SObject\r\n\t\t\t\tSObject\tsobjPass = new SObject();\r\n\t\t\t\tsobjPass.set_any(arNode);\r\n\t\t\t\tsobjPass.setType(data.realModule);\r\n\t\t\t\t\r\n\t\t\t\t//Load the buffer array\r\n\t\t\t\tdata.sfBuffer[data.iBufferPos] = sobjPass;\r\n\t\t\t\tdata.outputBuffer[data.iBufferPos] = rowData;\r\n\t\t\t\tdata.iBufferPos++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif ( data.iBufferPos >= meta.getBatchSizeInt()) {\r\n\t\t\t\tif (log.isDetailed()) logDetailed(\"Calling flush buffer from writeToSalesForce\");\r\n\t\t\t\tflushBuffers();\r\n\t\t\t}\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new KettleException(\"\\nFailed in writeToSalesForce: \"+ e.getMessage());\t\r\n\t\t}\r\n\t}","id":6856,"modified_method":"private void writeToSalesForce(Object[] rowData) throws KettleException\r\n\t{\r\n\t\ttry {\t\t\t\r\n\r\n\t\t\tif (log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceUpsert.CalledWrite\", data.iBufferPos, meta.getBatchSizeInt()));\r\n\t\t\t\r\n\t\t\t// if there is room in the buffer\r\n\t\t\tif ( data.iBufferPos < meta.getBatchSizeInt()) {\r\n\t\t\t\t// build the XML node\r\n\t\t\t\tMessageElement[] arNode = new MessageElement[data.nrfields];\r\n\t\t\t\tint index=0;\r\n\t\t\t\tfor ( int i = 0; i < data.nrfields; i++) {\r\n\t\t\t\t\tarNode[index++] = newMessageElement( meta.getUpdateLookup()[i], rowData[data.fieldnrs[i]]);\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t//build the SObject\r\n\t\t\t\tSObject\tsobjPass = new SObject();\r\n\t\t\t\tsobjPass.set_any(arNode);\r\n\t\t\t\tsobjPass.setType(data.realModule);\r\n\t\t\t\t\r\n\t\t\t\t//Load the buffer array\r\n\t\t\t\tdata.sfBuffer[data.iBufferPos] = sobjPass;\r\n\t\t\t\tdata.outputBuffer[data.iBufferPos] = rowData;\r\n\t\t\t\tdata.iBufferPos++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif ( data.iBufferPos >= meta.getBatchSizeInt()) {\r\n\t\t\t\tif (log.isDetailed()) logDetailed(\"Calling flush buffer from writeToSalesForce\");\r\n\t\t\t\tflushBuffers();\r\n\t\t\t}\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SalesforceUpsert.FailedInWrite\", e.getMessage()));\t\r\n\t\t}\r\n\t}","commit_id":"9a2a1e705c8cb1a4a6e704941a9459dddd07397a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void writeToSalesForce(Object[] rowData) throws KettleException\r\n\t{\r\n\t\ttry {\t\t\t\r\n\r\n\t\t\tif (log.isDetailed()) logDetailed(\"Called writeToSalesForce with \" + data.iBufferPos + \" out of \" + meta.getBatchSizeInt());\r\n\t\t\t\r\n\t\t\t// if there is room in the buffer\r\n\t\t\tif ( data.iBufferPos < meta.getBatchSizeInt()) {\r\n\r\n\t\t\t\t//Load the buffer array\r\n\t\t\t\tdata.deleteId[data.iBufferPos] = getInputRowMeta().getString(rowData,data.indexOfKeyField);\r\n\t\t\t\tdata.outputBuffer[data.iBufferPos] = rowData;\r\n\t\t\t\tdata.iBufferPos++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif ( data.iBufferPos >= meta.getBatchSizeInt()) {\r\n\t\t\t\tif (log.isDetailed()) logDetailed(\"Calling flush buffer from writeToSalesForce\");\r\n\t\t\t\tflushBuffers();\r\n\t\t\t}\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new KettleException(\"\\nFailed in writeToSalesForce: \"+ e.getMessage());\t\r\n\t\t}\r\n\t}","id":6857,"modified_method":"private void writeToSalesForce(Object[] rowData) throws KettleException\r\n\t{\r\n\t\ttry {\t\t\t\r\n\r\n\t\t\tif (log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceDelete.Log.WriteToSalesforce\", data.iBufferPos , meta.getBatchSizeInt()));\r\n\t\t\t\r\n\t\t\t// if there is room in the buffer\r\n\t\t\tif ( data.iBufferPos < meta.getBatchSizeInt()) {\r\n\r\n\t\t\t\t//Load the buffer array\r\n\t\t\t\tdata.deleteId[data.iBufferPos] = getInputRowMeta().getString(rowData,data.indexOfKeyField);\r\n\t\t\t\tdata.outputBuffer[data.iBufferPos] = rowData;\r\n\t\t\t\tdata.iBufferPos++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif ( data.iBufferPos >= meta.getBatchSizeInt()) {\r\n\t\t\t\tif (log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceDelete.Log.CallingFlush\"));\r\n\t\t\t\tflushBuffers();\r\n\t\t\t}\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SalesforceDelete.Error.WriteToSalesforce\", e.getMessage()));\t\r\n\t\t}\r\n\t}","commit_id":"9bc21c2667265d5879bdcf162c95dc1e099787e9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void flushBuffers() throws KettleException\r\n\t{\r\n\t\t\r\n\t\ttry {\r\n\t\t\t// create the object(s) by sending the array to the web service\r\n\t\t\tdata.deleteResult = data.connection.delete(data.deleteId);\r\n\t\t\tfor (int j = 0; j < data.deleteResult.length; j++) {\r\n\t\t\t\tif (data.deleteResult[j].isSuccess()) {\r\n\r\n\t\t\t\t\tputRow(data.outputRowMeta, data.outputBuffer[j]);  // copy row to output rowset(s);\r\n\t\t\t\t\tincrementLinesOutput();\r\n\t\t\t\t\t\r\n\t\t\t\t    if (checkFeedback(getLinesInput()))\r\n\t\t\t\t    {\r\n\t\t\t\t    \tif(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceDelete.log.LineRow\",\"\"+ getLinesInput()));\r\n\t\t\t\t    }\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// there were errors during the create call, go through the\r\n\t\t\t\t\t// errors\r\n\t\t\t\t\t// array and write them to the screen\r\n\t\t\t        boolean sendToErrorRow=false;\r\n\t\t\t\t\tString errorMessage = null;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (getStepMeta().isDoingErrorHandling())\r\n\t\t\t\t\t{\r\n\t\t\t\t         sendToErrorRow = true;\r\n\t\t\t\t         errorMessage = null;\r\n\t\t\t\t         for (int i = 0; i < data.deleteResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\t\t// get the next error\r\n\t\t\t\t\t\t\t\tcom.sforce.soap.partner.Error err = data.deleteResult[j].getErrors()[i];\r\n\t\t\t\t\t\t\t\terrorMessage = errorMessage \r\n\t\t\t\t\t\t\t\t\t\t+ \": Errors were found on item \"\r\n\t\t\t\t\t\t\t\t\t\t+ new Integer(j).toString()\r\n\t\t\t\t\t\t\t\t\t\t+ \" Error code is: \"\r\n\t\t\t\t\t\t\t\t\t\t+ err.getStatusCode().toString()\r\n\t\t\t\t\t\t\t\t\t\t+ \" Error message: \" + err.getMessage();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(log.isDetailed()) logDetailed(\"Found error from SalesForce and raising the exception\");\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// for (int i = 0; i < data.deleteResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t//\tJust throw the first error...\r\n\t\t\t\t\t\t///\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tcom.sforce.soap.partner.Error err = data.deleteResult[j].getErrors()[0];\r\n\t\t\t\t\t\t\tthrow new KettleException(\"Errors were found on item \"\r\n\t\t\t\t\t\t\t\t\t+ new Integer(j).toString()\r\n\t\t\t\t\t\t\t\t\t+ \" Error code is: \"\r\n\t\t\t\t\t\t\t\t\t+ err.getStatusCode().toString()\r\n\t\t\t\t\t\t\t\t\t+ \" Error message: \" + err.getMessage());\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t// } // for error messages\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (sendToErrorRow) {\r\n\t\t\t\t\t\t   // Simply add this row to the error row\r\n\t\t\t\t\t\tif(log.isDetailed()) logDetailed(\"Passing row to error step\");\r\n\t\t\t\t\t\t   putError(getInputRowMeta(), data.outputBuffer[j], 1, errorMessage, null, \"SalesforceDelete001\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t} \r\n\t\t\t\t\r\n\t\t\t} \r\n\t\t\t\r\n\t\t\t// reset the buffers\r\n\t\t\tdata.deleteId = new String[meta.getBatchSizeInt()];\r\n\t\t\tdata.outputBuffer = new Object[meta.getBatchSizeInt()][];\r\n\t\t\tdata.iBufferPos = 0;\r\n\t\t\t\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new KettleException(\"\\nFailed to upsert object, error message was: \\n\"+ e.getMessage());\r\n\t\t} finally {\r\n\t\t\tif(data.deleteResult!=null) data.deleteResult=null;\r\n\t\t}\r\n\r\n\t}","id":6858,"modified_method":"private void flushBuffers() throws KettleException\r\n\t{\r\n\t\t\r\n\t\ttry {\r\n\t\t\t// create the object(s) by sending the array to the web service\r\n\t\t\tdata.deleteResult = data.connection.delete(data.deleteId);\r\n\t\t\tfor (int j = 0; j < data.deleteResult.length; j++) {\r\n\t\t\t\tif (data.deleteResult[j].isSuccess()) {\r\n\r\n\t\t\t\t\tputRow(data.outputRowMeta, data.outputBuffer[j]);  // copy row to output rowset(s);\r\n\t\t\t\t\tincrementLinesOutput();\r\n\t\t\t\t\t\r\n\t\t\t\t    if (checkFeedback(getLinesInput()))\r\n\t\t\t\t    {\r\n\t\t\t\t    \tif(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceDelete.log.LineRow\",String.valueOf(getLinesInput())));\r\n\t\t\t\t    }\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// there were errors during the create call, go through the\r\n\t\t\t\t\t// errors\r\n\t\t\t\t\t// array and write them to the screen\r\n\t\t\t        boolean sendToErrorRow=false;\r\n\t\t\t\t\tString errorMessage = null;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (getStepMeta().isDoingErrorHandling())\r\n\t\t\t\t\t{\r\n\t\t\t\t         sendToErrorRow = true;\r\n\t\t\t\t         errorMessage = \"\";\r\n\t\t\t\t         for (int i = 0; i < data.deleteResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\t\t// get the next error\r\n\t\t\t\t\t\t\t\tcom.sforce.soap.partner.Error err = data.deleteResult[j].getErrors()[i];\r\n\t\t\t\t\t\t\t\terrorMessage+= BaseMessages.getString(PKG, \"SalesforceDelete.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceDelete.Found.Error\"));\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// for (int i = 0; i < data.deleteResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t//\tJust throw the first error...\r\n\t\t\t\t\t\t///\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tcom.sforce.soap.partner.Error err = data.deleteResult[j].getErrors()[0];\r\n\t\t\t\t\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SalesforceDelete.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage()));\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t// } // for error messages\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (sendToErrorRow) {\r\n\t\t\t\t\t\t   // Simply add this row to the error row\r\n\t\t\t\t\t\tif(log.isDebug()) logDebug(BaseMessages.getString(PKG, \"SalesforceDelete.PassingRowToErrorStep\"));\r\n\t\t\t\t\t\t   putError(getInputRowMeta(), data.outputBuffer[j], 1, errorMessage, null, \"SalesforceDelete001\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t} \r\n\t\t\t\t\r\n\t\t\t} \r\n\t\t\t\r\n\t\t\t// reset the buffers\r\n\t\t\tdata.deleteId = new String[meta.getBatchSizeInt()];\r\n\t\t\tdata.outputBuffer = new Object[meta.getBatchSizeInt()][];\r\n\t\t\tdata.iBufferPos = 0;\r\n\t\t\t\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SalesforceDelete.FailedToDeleted\", e.getMessage()));\r\n\t\t} finally {\r\n\t\t\tif(data.deleteResult!=null) data.deleteResult=null;\r\n\t\t}\r\n\r\n\t}","commit_id":"e40b0ebd849a47cfefbfa8b86a76565bd9f21bc9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void writeToSalesForce(Object[] rowData) throws KettleException\r\n\t{\r\n\t\ttry {\t\t\t\r\n\r\n\t\t\tif (log.isDetailed()) logDetailed(\"Called writeToSalesForce with \" + data.iBufferPos + \" out of \" + meta.getBatchSizeInt());\r\n\t\t\t\r\n\t\t\t// if there is room in the buffer\r\n\t\t\tif ( data.iBufferPos < meta.getBatchSizeInt()) {\r\n\t\t\t\t// build the XML node\r\n\t\t\t\tMessageElement[] arNode = new MessageElement[data.nrfields];\r\n\t\t\t\tint index=0;\r\n\t\t\t\tfor ( int i = 0; i < data.nrfields; i++) {\r\n\t\t\t\t\tarNode[index++] = newMessageElement( meta.getUpdateLookup()[i], rowData[data.fieldnrs[i]]);\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t//build the SObject\r\n\t\t\t\tSObject\tsobjPass = new SObject();\r\n\t\t\t\tsobjPass.set_any(arNode);\r\n\t\t\t\tsobjPass.setType(data.realModule);\r\n\t\t\t\t\r\n\t\t\t\t//Load the buffer array\r\n\t\t\t\tdata.sfBuffer[data.iBufferPos] = sobjPass;\r\n\t\t\t\tdata.outputBuffer[data.iBufferPos] = rowData;\r\n\t\t\t\tdata.iBufferPos++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif ( data.iBufferPos >= meta.getBatchSizeInt()) {\r\n\t\t\t\tif (log.isDetailed()) logDetailed(\"Calling flush buffer from writeToSalesForce\");\r\n\t\t\t\tflushBuffers();\r\n\t\t\t}\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new KettleException(\"\\nFailed in writeToSalesForce: \"+ e.getMessage());\t\r\n\t\t}\r\n\t}","id":6859,"modified_method":"private void writeToSalesForce(Object[] rowData) throws KettleException\r\n\t{\r\n\t\ttry {\t\t\t\r\n\r\n\t\t\tif (log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceInsert.WriteToSalesforce\", data.iBufferPos, meta.getBatchSizeInt()));\r\n\t\t\t\r\n\t\t\t// if there is room in the buffer\r\n\t\t\tif ( data.iBufferPos < meta.getBatchSizeInt()) {\r\n\t\t\t\t// build the XML node\r\n\t\t\t\tMessageElement[] arNode = new MessageElement[data.nrfields];\r\n\t\t\t\tint index=0;\r\n\t\t\t\tfor ( int i = 0; i < data.nrfields; i++) {\r\n\t\t\t\t\tarNode[index++] = newMessageElement( meta.getUpdateLookup()[i], rowData[data.fieldnrs[i]]);\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t//build the SObject\r\n\t\t\t\tSObject\tsobjPass = new SObject();\r\n\t\t\t\tsobjPass.set_any(arNode);\r\n\t\t\t\tsobjPass.setType(data.realModule);\r\n\t\t\t\t\r\n\t\t\t\t//Load the buffer array\r\n\t\t\t\tdata.sfBuffer[data.iBufferPos] = sobjPass;\r\n\t\t\t\tdata.outputBuffer[data.iBufferPos] = rowData;\r\n\t\t\t\tdata.iBufferPos++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif ( data.iBufferPos >= meta.getBatchSizeInt()) {\r\n\t\t\t\tif (log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceInsert.CallingFlushBuffer\"));\r\n\t\t\t\tflushBuffers();\r\n\t\t\t}\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SalesforceInsert.Error\", e.getMessage()));\t\r\n\t\t}\r\n\t}","commit_id":"e40b0ebd849a47cfefbfa8b86a76565bd9f21bc9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\r\n\t{\r\n\r\n\t \t// get one row ... This does some basic initialization of the objects, including loading the info coming in\r\n\t\tObject[] outputRowData = getRow(); \r\n\t\t\r\n\t\tif(outputRowData==null)\r\n\t\t{\r\n\t\t\tif ( data.iBufferPos > 0 ) \r\n\t\t\t{\r\n\t\t\t\tflushBuffers();\r\n\t\t\t}\r\n\t\t\tsetOutputDone();\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\t// If we haven't looked at a row before then do some basic setup.\r\n\t\tif(first)\r\n\t\t{\r\n\t\t\tfirst=false;\r\n\t\t\t\r\n\t\t\tdata.sfBuffer = new SObject[meta.getBatchSizeInt()];\r\n\t\t\tdata.outputBuffer = new Object[meta.getBatchSizeInt()][];\r\n\t\t\t \r\n\t\t\t// get total fields in the grid\r\n\t\t\tdata.nrfields = meta.getUpdateLookup().length;\r\n\t\t\t\t\r\n\t\t\t// Check if field list is filled \r\n\t\t\tif (data.nrfields==0)\r\n\t\t\t{\r\n\t\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SalesforceInsertDialog.FieldsMissing.DialogMessage\"));\r\n\t\t\t}\r\n \r\n\t\t\t// Create the output row meta-data\r\n\t        data.outputRowMeta = getInputRowMeta().clone();\r\n\t\t\tmeta.getFields(data.outputRowMeta, getStepname(), null, null, this);\r\n\t\t\t\r\n\t\t\t// Build the mapping of input position to field name\r\n\t\t\tdata.fieldnrs = new int[meta.getUpdateStream().length];\r\n\t\t\tfor (int i = 0; i < meta.getUpdateStream().length; i++)\r\n\t\t\t{\r\n\t\t\t\tdata.fieldnrs[i] = getInputRowMeta().indexOfValue(meta.getUpdateStream()[i]);\r\n\t\t\t\tif (data.fieldnrs[i] < 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tthrow new KettleException(\"Field [\" + meta.getUpdateStream()[i]+ \"] couldn't be found in the input stream!\");\r\n\t\t\t\t}\r\n\t\t\t }\r\n\t\t}\r\n\r\n\t\ttry \r\n\t\t{\t\r\n\t\t\twriteToSalesForce(outputRowData);\r\n\r\n\t\t} \r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"SalesforceInsert.log.Exception\"), e);\r\n\t\t} \r\n\t    return true; \r\n\t}","id":6860,"modified_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\r\n\t{\r\n\r\n\t \t// get one row ... This does some basic initialization of the objects, including loading the info coming in\r\n\t\tObject[] outputRowData = getRow(); \r\n\t\t\r\n\t\tif(outputRowData==null)\r\n\t\t{\r\n\t\t\tif ( data.iBufferPos > 0 ) \r\n\t\t\t{\r\n\t\t\t\tflushBuffers();\r\n\t\t\t}\r\n\t\t\tsetOutputDone();\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\t// If we haven't looked at a row before then do some basic setup.\r\n\t\tif(first)\r\n\t\t{\r\n\t\t\tfirst=false;\r\n\t\t\t\r\n\t\t\tdata.sfBuffer = new SObject[meta.getBatchSizeInt()];\r\n\t\t\tdata.outputBuffer = new Object[meta.getBatchSizeInt()][];\r\n\t\t\t \r\n\t\t\t// get total fields in the grid\r\n\t\t\tdata.nrfields = meta.getUpdateLookup().length;\r\n\t\t\t\t\r\n\t\t\t// Check if field list is filled \r\n\t\t\tif (data.nrfields==0)\r\n\t\t\t{\r\n\t\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SalesforceInsertDialog.FieldsMissing.DialogMessage\"));\r\n\t\t\t}\r\n \r\n\t\t\t// Create the output row meta-data\r\n\t        data.outputRowMeta = getInputRowMeta().clone();\r\n\t\t\tmeta.getFields(data.outputRowMeta, getStepname(), null, null, this);\r\n\t\t\t\r\n\t\t\t// Build the mapping of input position to field name\r\n\t\t\tdata.fieldnrs = new int[meta.getUpdateStream().length];\r\n\t\t\tfor (int i = 0; i < meta.getUpdateStream().length; i++)\r\n\t\t\t{\r\n\t\t\t\tdata.fieldnrs[i] = getInputRowMeta().indexOfValue(meta.getUpdateStream()[i]);\r\n\t\t\t\tif (data.fieldnrs[i] < 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SalesforceInsert.CanNotFindField\", meta.getUpdateStream()[i]));\r\n\t\t\t\t}\r\n\t\t\t }\r\n\t\t}\r\n\r\n\t\ttry \r\n\t\t{\t\r\n\t\t\twriteToSalesForce(outputRowData);\r\n\r\n\t\t} \r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"SalesforceInsert.log.Exception\"), e);\r\n\t\t} \r\n\t    return true; \r\n\t}","commit_id":"e40b0ebd849a47cfefbfa8b86a76565bd9f21bc9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void flushBuffers() throws KettleException\r\n\t{\r\n\t\t\r\n\t\ttry {\r\n\t\t\t// create the object(s) by sending the array to the web service\r\n\t\t\tdata.saveResult = data.connection.insert(data.sfBuffer);\r\n\t\t\tfor (int j = 0; j < data.saveResult.length; j++) {\r\n\t\t\t\tif (data.saveResult[j].isSuccess()) {\r\n\t\t\t\t\t// Row was inserted\r\n\t\t\t\t\tString id=data.saveResult[j].getId();\r\n\t\t\t\t\tif (log.isDetailed()) logDetailed(\"Row was inserted with id: \" + id);\r\n\r\n\t\t\t\t\t// write out the row with the SalesForce ID\r\n\t\t\t\t\tObject[] newRow = RowDataUtil.resizeArray(data.outputBuffer[j], data.outputRowMeta.size());\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(data.realSalesforceFieldName!=null) {\r\n\t\t\t\t\t\tint newIndex = getInputRowMeta().size();\r\n\t\t\t\t\t\tnewRow[newIndex++] = id;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (log.isDetailed()) logDetailed(\"The new row has an id value of : \" + newRow[0]);\r\n\t\t\t\t\t\r\n\t\t\t\t\t//putRow(data.outputRowMeta, data.outputRowMeta.cloneRow(newRow));  // copy row to output rowset(s);\r\n\t\t\t\t\tputRow(data.outputRowMeta, newRow);  // copy row to output rowset(s);\r\n\t\t\t\t\tincrementLinesOutput();\r\n\t\t\t\t\t\r\n\t\t\t\t    if (checkFeedback(getLinesInput()))\r\n\t\t\t\t    {\r\n\t\t\t\t    \tif(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceInsert.log.LineRow\",\"\"+ getLinesInput()));\r\n\t\t\t\t    }\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// there were errors during the create call, go through the\r\n\t\t\t\t\t// errors\r\n\t\t\t\t\t// array and write them to the screen\r\n\t\t\t        boolean sendToErrorRow=false;\r\n\t\t\t\t\tString errorMessage = null;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (getStepMeta().isDoingErrorHandling())\r\n\t\t\t\t\t{\r\n\t\t\t\t         sendToErrorRow = true;\r\n\t\t\t\t         errorMessage = null;\r\n\t\t\t\t         for (int i = 0; i < data.saveResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\t\t// get the next error\r\n\t\t\t\t\t\t\t\tcom.sforce.soap.partner.Error err = data.saveResult[j].getErrors()[i];\r\n\t\t\t\t\t\t\t\terrorMessage = errorMessage \r\n\t\t\t\t\t\t\t\t\t\t+ \": Errors were found on item \"\r\n\t\t\t\t\t\t\t\t\t\t+ new Integer(j).toString()\r\n\t\t\t\t\t\t\t\t\t\t+ \" Error code is: \"\r\n\t\t\t\t\t\t\t\t\t\t+ err.getStatusCode().toString()\r\n\t\t\t\t\t\t\t\t\t\t+ \" Error message: \" + err.getMessage();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(log.isDetailed()) logDetailed(\"Found error from SalesForce and raising the exception\"); \r\n\t\t\t\t\t\t//for (int i = 0; i < data.saveResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Only show the first error\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t\tcom.sforce.soap.partner.Error err = data.saveResult[j].getErrors()[0];\r\n\t\t\t\t\t\t\tthrow new KettleException(\"Errors were found on item \"\r\n\t\t\t\t\t\t\t\t\t+ new Integer(j).toString()\r\n\t\t\t\t\t\t\t\t\t+ \" Error code is: \"\r\n\t\t\t\t\t\t\t\t\t+ err.getStatusCode().toString()\r\n\t\t\t\t\t\t\t\t\t+ \" Error message: \" + err.getMessage());\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t// } // for error messages\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (sendToErrorRow) {\r\n\t\t\t\t\t\t   // Simply add this row to the error row\r\n\t\t\t\t\t\tif(log.isDetailed()) logDetailed(\"Passing row to error step\");\r\n\t\t\t\t\t\t   putError(getInputRowMeta(), data.outputBuffer[j], 1, errorMessage, null, \"SalesforceInsert001\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t} \r\n\t\t\t\t\r\n\t\t\t} \r\n\t\t\t\r\n\t\t\t// reset the buffers\r\n\t\t\tdata.sfBuffer = new SObject[meta.getBatchSizeInt()];\r\n\t\t\tdata.outputBuffer = new Object[meta.getBatchSizeInt()][];\r\n\t\t\tdata.iBufferPos = 0;\r\n\t\t\t\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new KettleException(\"\\nFailed to upsert object, error message was: \\n\"+ e.getMessage());\r\n\t\t} finally{\r\n\t\t\tif(data.saveResult!=null) data.saveResult=null;\r\n\t\t}\r\n\r\n\t}","id":6861,"modified_method":"private void flushBuffers() throws KettleException\r\n\t{\r\n\t\t\r\n\t\ttry {\r\n\t\t\t// create the object(s) by sending the array to the web service\r\n\t\t\tdata.saveResult = data.connection.insert(data.sfBuffer);\r\n\t\t\tfor (int j = 0; j < data.saveResult.length; j++) {\r\n\t\t\t\tif (data.saveResult[j].isSuccess()) {\r\n\t\t\t\t\t// Row was inserted\r\n\t\t\t\t\tString id=data.saveResult[j].getId();\r\n\t\t\t\t\tif (log.isDebug()) logDebug(\"Row was inserted with id: \" + id);\r\n\r\n\t\t\t\t\t// write out the row with the SalesForce ID\r\n\t\t\t\t\tObject[] newRow = RowDataUtil.resizeArray(data.outputBuffer[j], data.outputRowMeta.size());\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(data.realSalesforceFieldName!=null) {\r\n\t\t\t\t\t\tint newIndex = getInputRowMeta().size();\r\n\t\t\t\t\t\tnewRow[newIndex++] = id;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (log.isDetailed()) logDetailed(\"The new row has an id value of : \" + newRow[0]);\r\n\t\t\t\t\t\r\n\t\t\t\t\t//putRow(data.outputRowMeta, data.outputRowMeta.cloneRow(newRow));  // copy row to output rowset(s);\r\n\t\t\t\t\tputRow(data.outputRowMeta, newRow);  // copy row to output rowset(s);\r\n\t\t\t\t\tincrementLinesOutput();\r\n\t\t\t\t\t\r\n\t\t\t\t    if (checkFeedback(getLinesInput()))\r\n\t\t\t\t    {\r\n\t\t\t\t    \tif(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceInsert.log.LineRow\",\"\"+ getLinesInput()));\r\n\t\t\t\t    }\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// there were errors during the create call, go through the\r\n\t\t\t\t\t// errors\r\n\t\t\t\t\t// array and write them to the screen\r\n\t\t\t        boolean sendToErrorRow=false;\r\n\t\t\t\t\tString errorMessage = null;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (getStepMeta().isDoingErrorHandling())\r\n\t\t\t\t\t{\r\n\t\t\t\t         sendToErrorRow = true;\r\n\t\t\t\t         errorMessage = \"\";\r\n\t\t\t\t         for (int i = 0; i < data.saveResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\t\t// get the next error\r\n\t\t\t\t\t\t\t\tcom.sforce.soap.partner.Error err = data.saveResult[j].getErrors()[i];\r\n\t\t\t\t\t\t\t\terrorMessage+= BaseMessages.getString(PKG, \"SalesforceInsert.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(log.isDebug()) logDebug(\"Found error from SalesForce and raising the exception\"); \r\n\t\t\t\t\t\t//for (int i = 0; i < data.saveResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Only show the first error\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t\tcom.sforce.soap.partner.Error err = data.saveResult[j].getErrors()[0];\r\n\t\t\t\t\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SalesforceInsert.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage()));\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t// } // for error messages\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (sendToErrorRow) {\r\n\t\t\t\t\t\t   // Simply add this row to the error row\r\n\t\t\t\t\t\tif(log.isDetailed()) logDetailed(\"Passing row to error step\");\r\n\t\t\t\t\t\t   putError(getInputRowMeta(), data.outputBuffer[j], 1, errorMessage, null, \"SalesforceInsert001\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t} \r\n\t\t\t\t\r\n\t\t\t} \r\n\t\t\t\r\n\t\t\t// reset the buffers\r\n\t\t\tdata.sfBuffer = new SObject[meta.getBatchSizeInt()];\r\n\t\t\tdata.outputBuffer = new Object[meta.getBatchSizeInt()][];\r\n\t\t\tdata.iBufferPos = 0;\r\n\t\t\t\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new KettleException(\"\\nFailed to upsert object, error message was: \\n\"+ e.getMessage());\r\n\t\t} finally{\r\n\t\t\tif(data.saveResult!=null) data.saveResult=null;\r\n\t\t}\r\n\r\n\t}","commit_id":"e40b0ebd849a47cfefbfa8b86a76565bd9f21bc9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void flushBuffers() throws KettleException\r\n\t{\r\n\t\t\r\n\t\ttry {\r\n\t\t\t// create the object(s) by sending the array to the web service\r\n\t\t\tdata.saveResult = data.connection.update(data.sfBuffer);\r\n\t\t\tfor (int j = 0; j < data.saveResult.length; j++) {\r\n\t\t\t\tif (data.saveResult[j].isSuccess()) {\r\n\t\t\t\t\t// Row was updated\r\n\t\t\t\t\tString id=data.saveResult[j].getId();\r\n\t\t\t\t\tif (log.isDetailed()) logDetailed(\"Row updated with id: \" + id);\r\n\r\n\t\t\t\t\t// write out the row with the SalesForce ID\r\n\t\t\t\t\tObject[] newRow = RowDataUtil.resizeArray(data.outputBuffer[j], data.outputRowMeta.size());\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (log.isDetailed()) logDetailed(\"The new row has an id value of : \" + newRow[0]);\r\n\t\t\t\t\t\r\n\t\t\t\t\t//putRow(data.outputRowMeta, data.outputRowMeta.cloneRow(newRow));  // copy row to output rowset(s);\r\n\t\t\t\t\tputRow(data.outputRowMeta, newRow);  // copy row to output rowset(s);\r\n\t\t\t\t\tincrementLinesUpdated();\r\n\t\t\t\t\t\r\n\t\t\t\t    if (checkFeedback(getLinesInput()))\r\n\t\t\t\t    {\r\n\t\t\t\t    \tif(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceUpdate.log.LineRow\",\"\"+ getLinesInput()));\r\n\t\t\t\t    }\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// there were errors during the create call, go through the\r\n\t\t\t\t\t// errors\r\n\t\t\t\t\t// array and write them to the screen\r\n\t\t\t        boolean sendToErrorRow=false;\r\n\t\t\t\t\tString errorMessage = null;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (getStepMeta().isDoingErrorHandling())\r\n\t\t\t\t\t{\r\n\t\t\t\t         sendToErrorRow = true;\r\n\t\t\t\t         errorMessage = null;\r\n\t\t\t\t         for (int i = 0; i < data.saveResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\t\t// get the next error\r\n\t\t\t\t\t\t\t\tcom.sforce.soap.partner.Error err = data.saveResult[j].getErrors()[i];\r\n\t\t\t\t\t\t\t\terrorMessage = errorMessage \r\n\t\t\t\t\t\t\t\t\t\t+ \": Errors were found on item \"\r\n\t\t\t\t\t\t\t\t\t\t+ new Integer(j).toString()\r\n\t\t\t\t\t\t\t\t\t\t+ \" Error code is: \"\r\n\t\t\t\t\t\t\t\t\t\t+ err.getStatusCode().toString()\r\n\t\t\t\t\t\t\t\t\t\t+ \" Error message: \" + err.getMessage();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(log.isDetailed()) logDetailed(\"Found error from SalesForce and raising the exception\"); \r\n\t\t\t\t\t\t// for (int i = 0; i < data.saveResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Only send the first error\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t\tcom.sforce.soap.partner.Error err = data.saveResult[j].getErrors()[0];\r\n\t\t\t\t\t\t\tthrow new KettleException(\"Errors were found on item \"\r\n\t\t\t\t\t\t\t\t\t+ new Integer(j).toString()\r\n\t\t\t\t\t\t\t\t\t+ \" Error code is: \"\r\n\t\t\t\t\t\t\t\t\t+ err.getStatusCode().toString()\r\n\t\t\t\t\t\t\t\t\t+ \" Error message: \" + err.getMessage());\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t// } // for error messages\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (sendToErrorRow) {\r\n\t\t\t\t\t\t   // Simply add this row to the error row\r\n\t\t\t\t\t\tif(log.isDetailed()) logDetailed(\"Passing row to error step\");\r\n\t\t\t\t\t\t   putError(getInputRowMeta(), data.outputBuffer[j], 1, errorMessage, null, \"SalesforceUpdate001\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t} \r\n\t\t\t\t\r\n\t\t\t} \r\n\t\t\t\r\n\t\t\t// reset the buffers\r\n\t\t\tdata.sfBuffer = new SObject[meta.getBatchSizeInt()];\r\n\t\t\tdata.outputBuffer = new Object[meta.getBatchSizeInt()][];\r\n\t\t\tdata.iBufferPos = 0;\r\n\t\t\t\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new KettleException(\"\\nFailed to upsert object, error message was: \\n\"+ e.getMessage());\r\n\t\t} finally{\r\n\t\t\tif(data.saveResult!=null) data.saveResult=null;\r\n\t\t}\r\n\r\n\t}","id":6862,"modified_method":"private void flushBuffers() throws KettleException\r\n\t{\r\n\t\t\r\n\t\ttry {\r\n\t\t\t// create the object(s) by sending the array to the web service\r\n\t\t\tdata.saveResult = data.connection.update(data.sfBuffer);\r\n\t\t\tfor (int j = 0; j < data.saveResult.length; j++) {\r\n\t\t\t\tif (data.saveResult[j].isSuccess()) {\r\n\t\t\t\t\t// Row was updated\r\n\t\t\t\t\tString id=data.saveResult[j].getId();\r\n\t\t\t\t\tif (log.isDetailed()) logDetailed(\"Row updated with id: \" + id);\r\n\r\n\t\t\t\t\t// write out the row with the SalesForce ID\r\n\t\t\t\t\tObject[] newRow = RowDataUtil.resizeArray(data.outputBuffer[j], data.outputRowMeta.size());\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (log.isDetailed()) logDetailed(\"The new row has an id value of : \" + newRow[0]);\r\n\t\t\t\t\t\r\n\t\t\t\t\t//putRow(data.outputRowMeta, data.outputRowMeta.cloneRow(newRow));  // copy row to output rowset(s);\r\n\t\t\t\t\tputRow(data.outputRowMeta, newRow);  // copy row to output rowset(s);\r\n\t\t\t\t\tincrementLinesUpdated();\r\n\t\t\t\t\t\r\n\t\t\t\t    if (checkFeedback(getLinesInput()))\r\n\t\t\t\t    {\r\n\t\t\t\t    \tif(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceUpdate.log.LineRow\",\"\"+ getLinesInput()));\r\n\t\t\t\t    }\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// there were errors during the create call, go through the\r\n\t\t\t\t\t// errors\r\n\t\t\t\t\t// array and write them to the screen\r\n\t\t\t        boolean sendToErrorRow=false;\r\n\t\t\t\t\tString errorMessage = null;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (getStepMeta().isDoingErrorHandling())\r\n\t\t\t\t\t{\r\n\t\t\t\t         sendToErrorRow = true;\r\n\t\t\t\t         errorMessage = \"\";\r\n\t\t\t\t         for (int i = 0; i < data.saveResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\t\t// get the next error\r\n\t\t\t\t\t\t\t\tcom.sforce.soap.partner.Error err = data.saveResult[j].getErrors()[i];\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\terrorMessage+= BaseMessages.getString(PKG, \"SalesforceUpdate.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(log.isDetailed()) logDetailed(\"Found error from SalesForce and raising the exception\"); \r\n\t\t\t\t\t\t// for (int i = 0; i < data.saveResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Only send the first error\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t\tcom.sforce.soap.partner.Error err = data.saveResult[j].getErrors()[0];\r\n\t\t\t\t\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"SalesforceUpdate.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage()));\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t// } // for error messages\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (sendToErrorRow) {\r\n\t\t\t\t\t\t   // Simply add this row to the error row\r\n\t\t\t\t\t\tif(log.isDebug()) logDebug(\"Passing row to error step\");\r\n\t\t\t\t\t\t   putError(getInputRowMeta(), data.outputBuffer[j], 1, errorMessage, null, \"SalesforceUpdate001\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t} \r\n\t\t\t\t\r\n\t\t\t} \r\n\t\t\t\r\n\t\t\t// reset the buffers\r\n\t\t\tdata.sfBuffer = new SObject[meta.getBatchSizeInt()];\r\n\t\t\tdata.outputBuffer = new Object[meta.getBatchSizeInt()][];\r\n\t\t\tdata.iBufferPos = 0;\r\n\t\t\t\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new KettleException(\"\\nFailed to upsert object, error message was: \\n\"+ e.getMessage());\r\n\t\t} finally{\r\n\t\t\tif(data.saveResult!=null) data.saveResult=null;\r\n\t\t}\r\n\r\n\t}","commit_id":"e40b0ebd849a47cfefbfa8b86a76565bd9f21bc9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void flushBuffers() throws KettleException\r\n\t{\r\n\t\t\r\n\t\ttry {\r\n\t\t\t// create the object(s) by sending the array to the web service\r\n\t\t\tdata.upsertResult = data.connection.upsert(meta.getUpsertField(), data.sfBuffer);\r\n\t\t\tfor (int j = 0; j < data.upsertResult.length; j++) {\r\n\t\t\t\tif (data.upsertResult[j].isSuccess()) {\r\n\t\t\t\t\tString id=data.upsertResult[j].getId();\r\n\t\t\t\t\tif(data.upsertResult[j].isCreated()) {\r\n\t\t\t\t\t\tif (log.isDetailed()) logDetailed(\"An account was create with an id of: \" + id);\r\n\t\t\t\t\t}else {\r\n\t\t\t\t\t\tif (log.isDetailed()) logDetailed(\"Account with id of: \" + id + \" was updated\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// write out the row with the SalesForce ID\r\n\t\t\t\t\tObject[] newRow = RowDataUtil.resizeArray(data.outputBuffer[j], data.outputRowMeta.size());\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(data.realSalesforceFieldName!=null) {\r\n\t\t\t\t\t\tint newIndex = getInputRowMeta().size();\r\n\t\t\t\t\t\tnewRow[newIndex++] = id;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (log.isDetailed()) logDetailed(\"The new row has an id value of : \" + newRow[0]);\r\n\t\t\t\t\t\r\n\t\t\t\t\t//putRow(data.outputRowMeta, data.outputRowMeta.cloneRow(newRow));  // copy row to output rowset(s);\r\n\t\t\t\t\tputRow(data.outputRowMeta, newRow);  // copy row to output rowset(s);\r\n\t\t\t\t\tincrementLinesOutput();\r\n\t\t\t\t\t\r\n\t\t\t\t    if (checkFeedback(getLinesInput()))\r\n\t\t\t\t    {\r\n\t\t\t\t    \tif(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceUpsert.log.LineRow\",\"\"+ getLinesInput()));\r\n\t\t\t\t    }\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// there were errors during the create call, go through the\r\n\t\t\t\t\t// errors\r\n\t\t\t\t\t// array and write them to the screen\r\n\t\t\t        boolean sendToErrorRow=false;\r\n\t\t\t\t\tString errorMessage = null;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (getStepMeta().isDoingErrorHandling())\r\n\t\t\t\t\t{\r\n\t\t\t\t         sendToErrorRow = true;\r\n\t\t\t\t         errorMessage = null;\r\n\t\t\t\t         for (int i = 0; i < data.upsertResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\t\t// get the next error\r\n\t\t\t\t\t\t\t\tcom.sforce.soap.partner.Error err = data.upsertResult[j].getErrors()[i];\r\n\t\t\t\t\t\t\t\terrorMessage = errorMessage \r\n\t\t\t\t\t\t\t\t\t\t+ \": Errors were found on item \"\r\n\t\t\t\t\t\t\t\t\t\t+ new Integer(j).toString()\r\n\t\t\t\t\t\t\t\t\t\t+ \" Error code is: \"\r\n\t\t\t\t\t\t\t\t\t\t+ err.getStatusCode().toString()\r\n\t\t\t\t\t\t\t\t\t\t+ \" Error message: \" + err.getMessage();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(log.isDetailed()) logDetailed(\"Found error from SalesForce and raising the exception\"); \r\n\t\t\t\t\t\t// for (int i = 0; i < data.upsertResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Only throw the first error\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t\tcom.sforce.soap.partner.Error err = data.upsertResult[j].getErrors()[0];\r\n\t\t\t\t\t\t\tthrow new KettleException(\"Errors were found on item \"\r\n\t\t\t\t\t\t\t\t\t+ new Integer(j).toString()\r\n\t\t\t\t\t\t\t\t\t+ \" Error code is: \"\r\n\t\t\t\t\t\t\t\t\t+ err.getStatusCode().toString()\r\n\t\t\t\t\t\t\t\t\t+ \" Error message: \" + err.getMessage());\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t// } // for error messages\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (sendToErrorRow) {\r\n\t\t\t\t\t\t   // Simply add this row to the error row\r\n\t\t\t\t\t\tif(log.isDetailed()) logDetailed(\"Passing row to error step\");\r\n\t\t\t\t\t\t   putError(getInputRowMeta(), data.outputBuffer[j], 1, errorMessage, null, \"SalesforceUpsert001\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t} \r\n\t\t\t\t\r\n\t\t\t} \r\n\t\t\t\r\n\t\t\t// reset the buffers\r\n\t\t\tdata.sfBuffer = new SObject[meta.getBatchSizeInt()];\r\n\t\t\tdata.outputBuffer = new Object[meta.getBatchSizeInt()][];\r\n\t\t\tdata.iBufferPos = 0;\r\n\t\t\t\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new KettleException(\"\\nFailed to upsert object, error message was: \\n\"+ e.getMessage());\r\n\t\t} finally {\r\n\t\t\tif(data.upsertResult!=null) data.upsertResult=null;\r\n\t\t}\r\n\r\n\t}","id":6863,"modified_method":"private void flushBuffers() throws KettleException\r\n\t{\r\n\t\t\r\n\t\ttry {\r\n\t\t\t// create the object(s) by sending the array to the web service\r\n\t\t\tdata.upsertResult = data.connection.upsert(meta.getUpsertField(), data.sfBuffer);\r\n\t\t\tfor (int j = 0; j < data.upsertResult.length; j++) {\r\n\t\t\t\tif (data.upsertResult[j].isSuccess()) {\r\n\t\t\t\t\tString id=data.upsertResult[j].getId();\r\n\t\t\t\t\tif(data.upsertResult[j].isCreated()) {\r\n\t\t\t\t\t\tif (log.isDetailed()) logDetailed(\"An account was create with an id of: \" + id);\r\n\t\t\t\t\t}else {\r\n\t\t\t\t\t\tif (log.isDetailed()) logDetailed(\"Account with id of: \" + id + \" was updated\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// write out the row with the SalesForce ID\r\n\t\t\t\t\tObject[] newRow = RowDataUtil.resizeArray(data.outputBuffer[j], data.outputRowMeta.size());\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(data.realSalesforceFieldName!=null) {\r\n\t\t\t\t\t\tint newIndex = getInputRowMeta().size();\r\n\t\t\t\t\t\tnewRow[newIndex++] = id;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (log.isDetailed()) logDetailed(\"The new row has an id value of : \" + newRow[0]);\r\n\t\t\t\t\t\r\n\t\t\t\t\t//putRow(data.outputRowMeta, data.outputRowMeta.cloneRow(newRow));  // copy row to output rowset(s);\r\n\t\t\t\t\tputRow(data.outputRowMeta, newRow);  // copy row to output rowset(s);\r\n\t\t\t\t\tincrementLinesOutput();\r\n\t\t\t\t\t\r\n\t\t\t\t    if (checkFeedback(getLinesInput()))\r\n\t\t\t\t    {\r\n\t\t\t\t    \tif(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"SalesforceUpsert.log.LineRow\",\"\"+ getLinesInput()));\r\n\t\t\t\t    }\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// there were errors during the create call, go through the\r\n\t\t\t\t\t// errors\r\n\t\t\t\t\t// array and write them to the screen\r\n\t\t\t        boolean sendToErrorRow=false;\r\n\t\t\t\t\tString errorMessage = null;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (getStepMeta().isDoingErrorHandling())\r\n\t\t\t\t\t{\r\n\t\t\t\t         sendToErrorRow = true;\r\n\t\t\t\t         errorMessage = \"\";\r\n\t\t\t\t         for (int i = 0; i < data.upsertResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\t\t// get the next error\r\n\t\t\t\t\t\t\t\tcom.sforce.soap.partner.Error err = data.upsertResult[j].getErrors()[i];\r\n\t\t\t\t\t\t\t\terrorMessage+= BaseMessages.getString(PKG, \"SalesforceUpsert.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(log.isDetailed()) logDetailed(\"Found error from SalesForce and raising the exception\"); \r\n\t\t\t\t\t\t// for (int i = 0; i < data.upsertResult[j].getErrors().length; i++) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Only throw the first error\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t\tcom.sforce.soap.partner.Error err = data.upsertResult[j].getErrors()[0];\r\n\t\t\t\t\t\t\tthrow new KettleException( BaseMessages.getString(PKG, \"SalesforceUpsert.Error.FlushBuffer\", \r\n\t\t\t\t\t\t\t\t\t\t\t\tnew Integer(j), err.getStatusCode(), err.getMessage()));\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t// } // for error messages\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (sendToErrorRow) {\r\n\t\t\t\t\t\t   // Simply add this row to the error row\r\n\t\t\t\t\t\tif(log.isDebug()) logDebug(\"Passing row to error step\");\r\n\t\t\t\t\t\t   putError(getInputRowMeta(), data.outputBuffer[j], 1, errorMessage, null, \"SalesforceUpsert001\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t} \r\n\t\t\t\t\r\n\t\t\t} \r\n\t\t\t\r\n\t\t\t// reset the buffers\r\n\t\t\tdata.sfBuffer = new SObject[meta.getBatchSizeInt()];\r\n\t\t\tdata.outputBuffer = new Object[meta.getBatchSizeInt()][];\r\n\t\t\tdata.iBufferPos = 0;\r\n\t\t\t\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new KettleException(\"\\nFailed to upsert object, error message was: \\n\"+ e.getMessage());\r\n\t\t} finally {\r\n\t\t\tif(data.upsertResult!=null) data.upsertResult=null;\r\n\t\t}\r\n\r\n\t}","commit_id":"e40b0ebd849a47cfefbfa8b86a76565bd9f21bc9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.builder()\n      .setApplicationName(\"CountCountsDemo\")\n      .addFlow(CountCounts.class)\n      .addQuery(CountQuery.class)\n      .addStream(new Stream(\"text\"))\n      .addDataSet(new CounterTable(Common.tableName))\n      .create();\n  }","id":6864,"modified_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"CountCountsDemo\")\n      .setDescription(\"Application for counting counts of words\")\n      .withStreams().add(new Stream(\"text\"))\n      .withDataSets().add(new KeyValueTable(Common.tableName))\n      .withFlows().add(new CountCounts())\n      .withProcedures().add(new CountQuery())\n      .build();\n  }","commit_id":"c263c98fda71c67a37eb544945cc9119adc0a9f1","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.builder()\n      .setApplicationName(\"CountRandomDemo\")\n      .addFlow(CountRandom.class)\n      .addDataSet(new Table(\"counters\"))\n      .create();\n  }","id":6865,"modified_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"CountRandomDemo\")\n      .setDescription(\"\")\n      .noStream()\n      .withDataSets().add(new Table(\"counters\"))\n      .withFlows().add(new CountRandom())\n      .noProcedure()\n      .build();\n  }","commit_id":"c263c98fda71c67a37eb544945cc9119adc0a9f1","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.builder()\n      .setApplicationName(\"CountTokensDemo\")\n      .addFlow(CountTokens.class)\n      .addStream(new Stream(\"text\"))\n      .addDataSet(new KeyValueTable(Common.tableName))\n      .create();\n  }","id":6866,"modified_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"CountTokensDemo\")\n      .setDescription(\"\")\n      .withStreams().add(new Stream(\"text\"))\n      .withDataSets().add(new KeyValueTable(Common.tableName))\n      .withFlows().add(new CountTokens())\n      .noProcedure()\n      .build();\n  }","commit_id":"c263c98fda71c67a37eb544945cc9119adc0a9f1","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.builder()\n      .setApplicationName(\"SimpleWriteAndReadDemo\")\n      .addFlow(SimpleWriteAndRead.class)\n      .addStream(new Stream(\"text\"))\n      .addDataSet(new KeyValueTable(Common.tableName))\n      .create();\n  }","id":6867,"modified_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"SimpleWriteAndReadDemo\")\n      .setDescription(\"\")\n      .withStreams().add(new Stream(\"text\"))\n      .withDataSets().add(new KeyValueTable(Common.tableName))\n      .withFlows().add(new SimpleWriteAndRead())\n      .noProcedure()\n      .build();\n  }","commit_id":"c263c98fda71c67a37eb544945cc9119adc0a9f1","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.builder()\n      .setApplicationName(\"CountOddAndEvenDemo\")\n      .addFlow(CountOddAndEven.class)\n      .create();\n  }","id":6868,"modified_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"CountOddAndEvenDemo\")\n      .setDescription(\"\")\n      .noStream()\n      .noDataSet()\n      .withFlows().add(new CountOddAndEven())\n      .noProcedure()\n      .build();\n  }","commit_id":"c263c98fda71c67a37eb544945cc9119adc0a9f1","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.builder()\n      .setApplicationName(\"CountAndFilterWordsDemo\")\n      .addFlow(CountAndFilterWords.class)\n      .addStream(new Stream(\"text\"))\n      .addDataSet(new KeyValueTable(Common.counterTableName))\n      .create();\n  }","id":6869,"modified_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n      .setName(\"CountAndFilterWordsDemo\")\n      .setDescription(\"\")\n      .withStreams().add(new Stream(\"text\"))\n      .withDataSets().add(new KeyValueTable(Common.counterTableName))\n      .withFlows().add(new CountAndFilterWords())\n      .noProcedure()\n      .build();\n  }","commit_id":"c263c98fda71c67a37eb544945cc9119adc0a9f1","url":"https://github.com/caskdata/cdap"},{"original_method":"void tokenize(String str, String field, OutputCollector outputCollector) {\n    if (str == null) {\n      return;\n    }\n    final String delimiters = \"[ .-]\";\n    String[] tokens = str.split(delimiters);\n\n    for (String token : tokens) {\n\n      Tuple output = new TupleBuilder().\n          set(\"field\", field).\n          set(\"word\", token).\n          create();\n\n      if (Common.debug) {\n        System.out.println(this.getClass().getSimpleName() + \": Emitting tuple \" + output);\n      }\n      outputCollector.add(output);\n    }\n  }","id":6870,"modified_method":"void tokenize(String str, String field) {\n    if (str == null) {\n      return;\n    }\n    final String delimiters = \"[ .-]\";\n    String[] tokens = str.split(delimiters);\n\n    for (String token : tokens) {\n      Map<String,String> tuple = new HashMap<String,String>();\n      tuple.put(\"field\", field);\n      tuple.put(\"word\", token);\n\n      if (Common.debug) {\n        System.out.println(this.getClass().getSimpleName() + \": Emitting tuple \" + output);\n      }\n      output.emit(tuple);\n    }\n  }","commit_id":"c263c98fda71c67a37eb544945cc9119adc0a9f1","url":"https://github.com/caskdata/cdap"},{"original_method":"public void process(ProcedureRequest request, ProcedureResponder responder)\n      throws IOException {\n    responder.response(new ProcedureResponse(Code.SUCCESS, \"Success!\"));\n  }","id":6871,"modified_method":"public void process(ProcedureRequest request, ProcedureResponder responder)\n      throws IOException {\n    responder.stream(new ProcedureResponse(Code.SUCCESS, \"Success!\"));\n  }","commit_id":"c263c98fda71c67a37eb544945cc9119adc0a9f1","url":"https://github.com/caskdata/cdap"},{"original_method":"public static String generateProducer(KBase kbase) {\n        String s = \"package \" + kbase.getNamespace() + \";\\n\" +\n                   \"import java.util.Properties;\\n\" +\n                   \"import java.io.IOException;\\n\" +\n                   \"import java.io.InputStream;\\n\" +\n                   \"import javax.enterprise.inject.Produces;\\n\" +\n                   \"import javax.inject.Named;\\n\" +\n                   \"import org.drools.KnowledgeBase;\\n\" +\n                   \"import org.drools.KnowledgeBaseConfiguration;\\n\" +                   \n                   \"import org.drools.KnowledgeBaseFactory;\\n\" +\n                   \"import org.drools.builder.CompositeKnowledgeBuilder;\\n\" +\n                   \"import org.drools.builder.KnowledgeBuilder;\\n\" +\n                   \"import org.drools.builder.KnowledgeBuilderFactory;\\n\" +\n                   \"import org.drools.builder.ResourceType;\\n\" +\n                   \"import org.drools.io.ResourceFactory;\\n\" +\n                   \"public class \" + kbase.getName() + \"Producer {\\n\" +\n                   \"    @Produces \\n\" +\n                   \"    @\" + kbase.getName() + \"\\n\" +\n                   \"    public KnowledgeBase newKnowledgeBase() {\\n\" +\n                   \"        String fileStr = null;\\n\" +\n                   \"        InputStream is = null;\\n\" +\n                   \"        try {\\n\" +\n                   \"            is = getClass().getResourceAsStream( \\\"/\" + kbase.getQName() + \".files.dat\\\" );\\n\" +\n                   \"            fileStr = org.drools.core.util.StringUtils.toString( is );\\n\" +\n                   \"        } catch ( IOException e ) {\\n\" +\n                   \"            throw new RuntimeException( \\\"Unable to fine files for KnowledgeBase \" + kbase.getQName() + \"\\\" );\\n\" +\n                   \"        } finally {\\n\" +\n                   \"            if ( is != null ) {\\n\" +\n                   \"                try {\\n\" +\n                   \"                    is.close();\\n\" +\n                   \"                } catch (IOException e) {\\n\" +\n                   \"                    throw new RuntimeException( \\\"Unable to fine files for KnowledgeBase \" + kbase.getQName() + \"\\\" );\\n\" +\n                   \"                }\\n\" +\n                   \"            }\\n\" +\n                   \"        }\\n\" +\n                   \"        \\n\" +\n                   \"        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\\n\" +\n                   \"        CompositeKnowledgeBuilder ckbuilder = kbuilder.batch();\\n\" +\n                   \"        \\n\" +\n                   \"        String[] files = fileStr.split( \\\",\\\" );\\n\" +\n                   \"        if ( files.length > 0 ) {\\n\" +\n                   \"            for ( String file : files ) {\\n\" +\n                   \"                if ( file.endsWith(\\\".drl\\\" ) ) {\\n\" +\n                   \"                    ckbuilder.add( ResourceFactory.newUrlResource( getClass().getResource( \\\"/\\\" + file.trim() ) ), ResourceType.DRL );\\n\" +\n                   \"                }\\n\" +\n                   \"            }\\n\" +\n                   \"        }\\n\" +\n                   \"        ckbuilder.build();\\n\" +\n                   \"\\n\" +\n                   \"        \\n\" +\n                   \"        if ( kbuilder.hasErrors() ) {\\n\" +\n                   \"            throw new RuntimeException( \\\"Unable to compile \" + kbase.getQName() + \":\\\\n\\\" + kbuilder.getErrors() );\\n\" +\n                   \"        }\\n\" +\n                   \"        \\n\" +\n                   \"        KnowledgeBaseConfiguration kconf = KnowledgeBaseFactory.newKnowledgeBaseConfiguration();\\n\";\n        \n                   switch ( kbase.getEventProcessingMode() ) {\n                       case CLOUD:\n                           s += \"        kconf.setOption( \" + kbase.getEventProcessingMode().getClass().getName() + \".CLOUD );\\n\";                           \n                           break;\n                       case STREAM:\n                           s += \"        kconf.setOption( \" + kbase.getEventProcessingMode().getClass().getName() + \".STREAM );\\n\";\n                           break;\n                   }\n                   \n                   switch( kbase.getEqualsBehavior() ) {\n                       case EQUALITY:\n                           s += \"        kconf.setOption( \" + kbase.getEqualsBehavior().getClass().getName() + \".EQUALITY );\\n\";\n                           break;\n                       case IDENTITY:\n                           s += \"        kconf.setOption( \" + kbase.getEqualsBehavior().getClass().getName() + \".IDENTITY );\\n\";\n                           break;                           \n                   }\n                   \n                   s += \"        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase(kconf);\" +\n                   \"        kbase.addKnowledgePackages( kbuilder.getKnowledgePackages() );\\n\" +\n                   \"        return kbase; \\n\" +\n                   \"    }\\n\" +\n                   \"}\\n\";\n\n        return s;\n    }","id":6872,"modified_method":"public static String generateProducer(KBase kbase) {\n//        String s = \"package \" + kbase.getNamespace() + \";\\n\" +\n//                   \"import java.util.Properties;\\n\" +\n//                   \"import java.io.IOException;\\n\" +\n//                   \"import java.io.InputStream;\\n\" +\n//                   \"import javax.enterprise.inject.Produces;\\n\" +\n//                   \"import javax.inject.Named;\\n\" +\n//                   \"import org.drools.KnowledgeBase;\\n\" +\n//                   \"import org.drools.KnowledgeBaseConfiguration;\\n\" +\n//                   \"import org.drools.KnowledgeBaseFactory;\\n\" +\n//                   \"import org.drools.builder.CompositeKnowledgeBuilder;\\n\" +\n//                   \"import org.drools.builder.KnowledgeBuilder;\\n\" +\n//                   \"import org.drools.builder.KnowledgeBuilderFactory;\\n\" +\n//                   \"import org.drools.builder.ResourceType;\\n\" +\n//                   \"import org.drools.io.ResourceFactory;\\n\" +\n//                   \"public class \" + kbase.getName() + \"Producer {\\n\" +\n//                   \"    @Produces \\n\" +\n//                   \"    @\" + kbase.getName() + \"\\n\" +\n//                   \"    public KnowledgeBase newKnowledgeBase() {\\n\" +\n//                   \"        String fileStr = null;\\n\" +\n//                   \"        InputStream is = null;\\n\" +\n//                   \"        try {\\n\" +\n//                   \"            is = getClass().getResourceAsStream( \\\"/\" + kbase.getQName() + \".files.dat\\\" );\\n\" +\n//                   \"            fileStr = org.drools.core.util.StringUtils.toString( is );\\n\" +\n//                   \"        } catch ( IOException e ) {\\n\" +\n//                   \"            throw new RuntimeException( \\\"Unable to fine files for KnowledgeBase \" + kbase.getQName() + \"\\\" );\\n\" +\n//                   \"        } finally {\\n\" +\n//                   \"            if ( is != null ) {\\n\" +\n//                   \"                try {\\n\" +\n//                   \"                    is.close();\\n\" +\n//                   \"                } catch (IOException e) {\\n\" +\n//                   \"                    throw new RuntimeException( \\\"Unable to fine files for KnowledgeBase \" + kbase.getQName() + \"\\\" );\\n\" +\n//                   \"                }\\n\" +\n//                   \"            }\\n\" +\n//                   \"        }\\n\" +\n//                   \"        \\n\" +\n//                   \"        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\\n\" +\n//                   \"        CompositeKnowledgeBuilder ckbuilder = kbuilder.batch();\\n\" +\n//                   \"        \\n\" +\n//                   \"        String[] files = fileStr.split( \\\",\\\" );\\n\" +\n//                   \"        if ( files.length > 0 ) {\\n\" +\n//                   \"            for ( String file : files ) {\\n\" +\n//                   \"                if ( file.endsWith(\\\".drl\\\" ) ) {\\n\" +\n//                   \"                    ckbuilder.add( ResourceFactory.newUrlResource( getClass().getResource( \\\"/\\\" + file.trim() ) ), ResourceType.DRL );\\n\" +\n//                   \"                }\\n\" +\n//                   \"            }\\n\" +\n//                   \"        }\\n\" +\n//                   \"        ckbuilder.build();\\n\" +\n//                   \"\\n\" +\n//                   \"        \\n\" +\n//                   \"        if ( kbuilder.hasErrors() ) {\\n\" +\n//                   \"            throw new RuntimeException( \\\"Unable to compile \" + kbase.getQName() + \":\\\\n\\\" + kbuilder.getErrors() );\\n\" +\n//                   \"        }\\n\" +\n//                   \"        \\n\" +\n//                   \"        KnowledgeBaseConfiguration kconf = KnowledgeBaseFactory.newKnowledgeBaseConfiguration();\\n\";\n//\n//                   switch ( kbase.getEventProcessingMode() ) {\n//                       case CLOUD:\n//                           s += \"        kconf.setOption( \" + kbase.getEventProcessingMode().getClass().getName() + \".CLOUD );\\n\";\n//                           break;\n//                       case STREAM:\n//                           s += \"        kconf.setOption( \" + kbase.getEventProcessingMode().getClass().getName() + \".STREAM );\\n\";\n//                           break;\n//                   }\n//\n//                   switch( kbase.getEqualsBehavior() ) {\n//                       case EQUALITY:\n//                           s += \"        kconf.setOption( \" + kbase.getEqualsBehavior().getClass().getName() + \".EQUALITY );\\n\";\n//                           break;\n//                       case IDENTITY:\n//                           s += \"        kconf.setOption( \" + kbase.getEqualsBehavior().getClass().getName() + \".IDENTITY );\\n\";\n//                           break;\n//                   }\n//\n//                   s += \"        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase(kconf);\" +\n//                   \"        kbase.addKnowledgePackages( kbuilder.getKnowledgePackages() );\\n\" +\n//                   \"        return kbase; \\n\" +\n//                   \"    }\\n\" +\n//                   \"}\\n\";\n\n        String s = \"package \" + kbase.getNamespace() + \";\\n\" +\n                   \"import java.util.Properties;\\n\" +\n                   \"import java.io.IOException;\\n\" +\n                   \"import java.io.InputStream;\\n\" +\n                   \"import javax.enterprise.inject.Produces;\\n\" +\n                   \"import javax.inject.Named;\\n\" +\n                   \"import org.drools.KnowledgeBase;\\n\" +\n                   \"import org.drools.KnowledgeBaseConfiguration;\\n\" +\n                   \"import org.drools.KnowledgeBaseFactory;\\n\" +\n                   \"import org.drools.builder.CompositeKnowledgeBuilder;\\n\" +\n                   \"import org.drools.builder.KnowledgeBuilder;\\n\" +\n                   \"import org.drools.builder.KnowledgeBuilderFactory;\\n\" +\n                   \"import org.drools.builder.ResourceType;\\n\" +\n                   \"import org.drools.io.ResourceFactory;\\n\" +\n                   \"public class \" + kbase.getName() + \"Producer extends \"+ KBaseBuilder.class.getName() + \" {\\n\" +\n//                   \"    public \" + kbase.getName() + \"Producer() {\\n\" +\n//                   \"        setKBaseQName( \\\"\" + kbase.getQName() + \"\\\" );\\n\";\n//                   switch ( kbase.getEventProcessingMode() ) {\n//                       case CLOUD:\n//                           s += \"        setEventProcessingMode( \" + kbase.getEventProcessingMode().getClass().getName() + \".CLOUD );\\n\";\n//                           break;\n//                       case STREAM:\n//                           s += \"        setEventProcessingMode( \" + kbase.getEventProcessingMode().getClass().getName() + \".STREAM );\\n\";\n//                           break;\n//                   }\n//\n//                   switch( kbase.getEqualsBehavior() ) {\n//                       case EQUALITY:\n//                           s += \"        setEqualsBehavior( \" + kbase.getEqualsBehavior().getClass().getName() + \".EQUALITY );\\n\";\n//                           break;\n//                       case IDENTITY:\n//                           s += \"        setEqualsBehavior( \" + kbase.getEqualsBehavior().getClass().getName() + \".IDENTITY );\\n\";\n//                           break;\n//                   }\n//                   s +=\n//                   \"    } \\n\" +\n                   \"    @Produces \\n\" +\n                   \"    @\" + kbase.getName() + \"\\n\" +\n                   \"    public KnowledgeBase newKnowledgeBase() {\\n\" +\n//                   \"        return super.newKnowledgeBase(); \\n\" +\n                   \"        return \" + KBaseBuilder.class.getName() +\".fluent()\\n\" +\n                   \"                    .setKBaseQName( \\\"\" + kbase.getQName() + \"\\\" )\\n\";\n                   switch ( kbase.getEventProcessingMode() ) {\n                       case CLOUD:\n                           s += \"                    .setEventProcessingMode( \" + kbase.getEventProcessingMode().getClass().getName() + \".CLOUD )\\n\";\n                           break;\n                       case STREAM:\n                           s += \"                    .setEventProcessingMode( \" + kbase.getEventProcessingMode().getClass().getName() + \".STREAM )\\n\";\n                           break;\n                   }\n\n                   switch( kbase.getEqualsBehavior() ) {\n                       case EQUALITY:\n                           s += \"                    .setEqualsBehavior( \" + kbase.getEqualsBehavior().getClass().getName() + \".EQUALITY )\\n\";\n                           break;\n                       case IDENTITY:\n                           s += \"                    .setEqualsBehavior( \" + kbase.getEqualsBehavior().getClass().getName() + \".IDENTITY )\\n\";\n                           break;\n                   }\n                   s +=\n                   \"                    .build(getClass());\\n\" +\n                   \"    }\\n\" +\n                   \"}\\n\";\n\n        return s;\n    }","commit_id":"153287ae33acd15c38820f3d0640536f5472f1b7","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public KBaseImpl(KProjectImpl kProject,\n                     String namespace,\n                     String name) {\n        this.kProject = kProject;\n        this.namespace = namespace;\n        this.name = name;\n        this.files = new ArrayList<String>() ;\n        this.kSessions = Collections.emptyMap();\n    }","id":6873,"modified_method":"public KBaseImpl(KProjectImpl kProject,\n                     String namespace,\n                     String name) {\n        this.kProject = kProject;\n        this.namespace = namespace;\n        this.includes = new HashSet<KBase>();\n        this.name = name;\n        this.files = new ArrayList<String>();\n        this.kSessions = Collections.emptyMap();\n    }","commit_id":"153287ae33acd15c38820f3d0640536f5472f1b7","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void setListener(PropertyChangeListener listener) {\n        this.listener = listener;\n        for ( KSession ksession : kSessions.values() ) {\n            // make sure the listener is set for each ksession\n            ksession.setListener( listener );\n        }\n    }","id":6874,"modified_method":"public KBase setListener(PropertyChangeListener listener) {\n        this.listener = listener;\n        for ( KSession ksession : kSessions.values() ) {\n            // make sure the listener is set for each ksession\n            ksession.setListener( listener );\n        }\n        return this;\n    }","commit_id":"153287ae33acd15c38820f3d0640536f5472f1b7","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void setAnnotations(List<String> annotations) {\n        if ( listener != null ) {\n            listener.propertyChange( new PropertyChangeEvent( this, \"annotations\", this.annotations, annotations ) );\n        }\n        this.annotations = annotations;\n    }","id":6875,"modified_method":"public KBase setAnnotations(List<String> annotations) {\n        if ( listener != null ) {\n            listener.propertyChange( new PropertyChangeEvent( this, \"annotations\", this.annotations, annotations ) );\n        }\n        this.annotations = annotations;\n        return this;\n    }","commit_id":"153287ae33acd15c38820f3d0640536f5472f1b7","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void setEqualsBehavior(AssertBehaviorOption equalsBehaviour) {\n        if ( listener != null ) {\n            listener.propertyChange( new PropertyChangeEvent( this, \"equalsBehavior\", this.equalsBehavior, equalsBehavior ) );\n        }\n        this.equalsBehavior = equalsBehaviour;\n    }","id":6876,"modified_method":"public KBase setEqualsBehavior(AssertBehaviorOption equalsBehaviour) {\n        if ( listener != null ) {\n            listener.propertyChange( new PropertyChangeEvent( this, \"equalsBehavior\", this.equalsBehavior, equalsBehavior ) );\n        }\n        this.equalsBehavior = equalsBehaviour;\n        return this;\n    }","commit_id":"153287ae33acd15c38820f3d0640536f5472f1b7","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void setNamespace(String namespace) {\n        if ( listener != null ) {\n            listener.propertyChange( new PropertyChangeEvent( this, \"namespace\", this.namespace, namespace ) );\n        }\n        this.namespace = namespace;\n    }","id":6877,"modified_method":"public KBase setNamespace(String namespace) {\n        if ( listener != null ) {\n            listener.propertyChange( new PropertyChangeEvent( this, \"namespace\", this.namespace, namespace ) );\n        }\n        this.namespace = namespace;\n        return this;\n    }","commit_id":"153287ae33acd15c38820f3d0640536f5472f1b7","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void setName(String name) {\n        if ( listener != null ) {\n            listener.propertyChange( new PropertyChangeEvent( this, \"name\", this.name, name ) );\n        }\n        this.name = name;\n    }","id":6878,"modified_method":"public KBase setName(String name) {\n        if ( listener != null ) {\n            listener.propertyChange( new PropertyChangeEvent( this, \"name\", this.name, name ) );\n        }\n        this.name = name;\n        return this;\n    }","commit_id":"153287ae33acd15c38820f3d0640536f5472f1b7","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void setFiles(List<String> files) {\n        if ( listener != null ) {\n            listener.propertyChange( new PropertyChangeEvent( this, \"files\", this.files, files ) );\n        }\n        this.files = files;\n    }","id":6879,"modified_method":"public KBase setFiles(List<String> files) {\n        if ( listener != null ) {\n            listener.propertyChange( new PropertyChangeEvent( this, \"files\", this.files, files ) );\n        }\n        this.files = files;\n        return this;\n    }","commit_id":"153287ae33acd15c38820f3d0640536f5472f1b7","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void setEventProcessingMode(EventProcessingOption eventProcessingMode) {\n        if ( listener != null ) {\n            listener.propertyChange( new PropertyChangeEvent( this, \"eventProcessingMode\", this.eventProcessingMode, eventProcessingMode ) );\n        }\n        this.eventProcessingMode = eventProcessingMode;\n    }","id":6880,"modified_method":"public KBase setEventProcessingMode(EventProcessingOption eventProcessingMode) {\n        if ( listener != null ) {\n            listener.propertyChange( new PropertyChangeEvent( this, \"eventProcessingMode\", this.eventProcessingMode, eventProcessingMode ) );\n        }\n        this.eventProcessingMode = eventProcessingMode;\n        return this;\n    }","commit_id":"153287ae33acd15c38820f3d0640536f5472f1b7","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**  Generates qualifiers and producers for the entire KProject\n     * \n     * @param kProject\n     * @param changeLog\n     * @param fs\n     */\n    public static void commit(KProject kProject,\n                              FileSystem fs) {\n        KProjectChangeLogCommiter committer = new KProjectChangeLogCommiter( kProject, null, fs );\n        for ( KBase kBase : kProject.getKBases().values() ) {\n            committer.commitAddedKBase( kBase);\n            for ( KSession kSession : kBase.getKSessions().values() ) {\n                Folder rootFld = fs.getFolder( kProject.getKBasesPath() + \"/\" + kBase.getQName() );\n                committer.commitAddedKSession( rootFld, kBase, kSession );\n            }\n        }\n    }","id":6881,"modified_method":"/**  \n     * Generates qualifiers and producers for the entire KProject\n     * \n     * @param kProject\n     * @param fs\n     */\n    public static void commit(KProject kProject,\n                              FileSystem fs) {\n        KProjectChangeLogCommiter committer = new KProjectChangeLogCommiter( kProject, null, fs );\n        for ( KBase kBase : kProject.getKBases().values() ) {\n            committer.commitAddedKBase( kBase);\n            for ( KSession kSession : kBase.getKSessions().values() ) {\n                Folder rootFld = fs.getFolder( kProject.getKBasesPath() + \"/\" + kBase.getQName() );\n                committer.commitAddedKSession( rootFld, kBase, kSession );\n            }\n        }\n    }","commit_id":"153287ae33acd15c38820f3d0640536f5472f1b7","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void setKBasesPath(String kprojectPath) {\n        if ( listener != null ) {\n            listener.propertyChange( new PropertyChangeEvent( this, \"kBasesPath\", this.kBasesPath, kBasesPath ) );     \n        }\n        this.kBasesPath = kprojectPath;\n    }","id":6882,"modified_method":"public KProject setKBasesPath(String kprojectPath) {\n        if ( listener != null ) {\n            listener.propertyChange( new PropertyChangeEvent( this, \"kBasesPath\", this.kBasesPath, kBasesPath ) );     \n        }\n        this.kBasesPath = kprojectPath;\n        return this;\n    }","commit_id":"153287ae33acd15c38820f3d0640536f5472f1b7","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void setListener(PropertyChangeListener listener) {\n        this.listener = listener;\n        for ( KBase kbase : kBases.values() ) {\n            // make sure the listener is set for each kbase\n            kbase.setListener( listener );\n        }        \n    }","id":6883,"modified_method":"public KProject setListener(PropertyChangeListener listener) {\n        this.listener = listener;\n        for ( KBase kbase : kBases.values() ) {\n            // make sure the listener is set for each kbase\n            kbase.setListener( listener );\n        }\n        return this;\n    }","commit_id":"153287ae33acd15c38820f3d0640536f5472f1b7","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void setKProjectPath(String kprojectPath) {\n        if ( listener != null ) {\n            listener.propertyChange( new java.beans.PropertyChangeEvent( this, \"kProjectPath\", this.kProjectPath, kProjectPath ) );\n        }\n        this.kProjectPath = kprojectPath;\n    }","id":6884,"modified_method":"public KProject setKProjectPath(String kprojectPath) {\n        if ( listener != null ) {\n            listener.propertyChange( new java.beans.PropertyChangeEvent( this, \"kProjectPath\", this.kProjectPath, kProjectPath ) );\n        }\n        this.kProjectPath = kprojectPath;\n        return this;\n    }","commit_id":"153287ae33acd15c38820f3d0640536f5472f1b7","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Test\n    public void testCompileAndCDI() throws IOException,\n                       ClassNotFoundException,\n                       InterruptedException {\n        KProject kproj = new KProjectImpl();\n\n        kproj.setKProjectPath( \"src/main/resources/\" );\n        kproj.setKBasesPath( \"src/kbases\" );\n\n        List<String> files = asList( new String[]{\"org/test1/rule1.drl\", \"org/test1/rule2.drl\"} );\n\n        KBase kBase1 = kproj.newKBase( \"org.test1\", \"kBase1\" );\n        kBase1.setFiles( files );\n        kBase1.setAnnotations( asList( \"@ApplicationScoped; @Inject\" ) );\n        kBase1.setEqualsBehavior( AssertBehaviorOption.EQUALITY );\n        kBase1.setEventProcessingMode( EventProcessingOption.STREAM );\n\n        KSession ksession1 = kBase1.newKSession( \"org.test1\", \"KSession1\" );\n        ksession1.setType( \"stateless\" );\n        ksession1.setAnnotations( asList( \"@ApplicationScoped; @Inject\" ) );\n        ksession1.setClockType( ClockTypeOption.get( \"realtime\" ) );\n\n        KSession ksession2 = kBase1.newKSession( \"org.test1\", \"KSession2\" );\n        ksession2.setType( \"stateful\" );\n        ksession2.setAnnotations( asList( \"@ApplicationScoped; @Inject\" ) );\n        ksession2.setClockType( ClockTypeOption.get( \"pseudo\" ) );\n\n        files = asList( new String[]{\"org/test2/rule1.drl\", \"org/test2/rule2.drl\"} );\n        KBase kbase2 = kproj.newKBase( \"org.test2\", \"KBase2\" );\n        kbase2.setFiles( files );\n\n        kbase2.setAnnotations( asList( \"@ApplicationScoped\" ) );\n        kbase2.setEqualsBehavior( AssertBehaviorOption.IDENTITY );\n        kbase2.setEventProcessingMode( EventProcessingOption.CLOUD );\n\n        KSession ksession3 = kbase2.newKSession( \"org.test2\", \"KSession3\" );\n        ksession3.setType( \"stateful\" );\n        ksession3.setAnnotations( asList( \"@ApplicationScoped\" ) );\n        ksession3.setClockType( ClockTypeOption.get( \"pseudo\" ) );      \n        \n        //        System.out.println( kproj);\n        //        \n        //        XStream xstream = new XStream();\n        //        String string = xstream.toXML( kproj );\n        //        System.out.println( string );\n        //      \n        //      printFs(  mfs, mfs.getProjectFolder() );\n        //                \n        MemoryFileSystem mfs = new MemoryFileSystem();\n        KProjectChangeLogCommiter.commit( kproj, mfs );\n\n        String kBase1R1 = getRule( \"org.test1\", \"rule1\" );\n        String kBase1R2 = getRule( \"org.test1\", \"rule2\" );\n\n        String kbase2R1 = getRule( \"org.test2\", \"rule1\" );\n        String kbase2R2 = getRule( \"org.test2\", \"rule2\" );\n\n        String fldKB1 = kproj.getKBasesPath() + \"/\" + kBase1.getQName() + \"/\" + kBase1.getNamespace().replace( '.', '/' );\n        String fldKB2 = kproj.getKBasesPath() + \"/\" + kbase2.getQName() + \"/\" + kbase2.getNamespace().replace( '.', '/' );\n\n        mfs.getFolder( fldKB1 ).create();\n        mfs.getFolder( fldKB2 ).create();\n\n        mfs.getFile( fldKB1 + \"/rule1.drl\" ).create( new ByteArrayInputStream( kBase1R1.getBytes() ) );\n        mfs.getFile( fldKB1 + \"/rule2.drl\" ).create( new ByteArrayInputStream( kBase1R2.getBytes() ) );\n        mfs.getFile( fldKB2 + \"/rule1.drl\" ).create( new ByteArrayInputStream( kbase2R1.getBytes() ) );\n        mfs.getFile( fldKB2 + \"/rule2.drl\" ).create( new ByteArrayInputStream( kbase2R2.getBytes() ) );\n\n        MemoryFileSystem trgMfs = new MemoryFileSystem();\n        MemoryFileSystem srcMfs = mfs;\n\n        Folder fld1 = trgMfs.getFolder( \"org/drools/cdi/test\" );\n        fld1.create();\n        File fle1 = fld1.getFile( \"KProjectTestClassImpl.java\" );\n        fle1.create( new ByteArrayInputStream( generateKProjectTestClassImpl( kproj ).getBytes() ) );\n\n        List<String> inputClasses = new ArrayList<String>();\n        inputClasses.add( \"org/drools/cdi/test/KProjectTestClassImpl.java\" );\n\n        final List<String> classes = compile( kproj, srcMfs, trgMfs, inputClasses );\n\n        MemoryFileSystemClassLoader classLoader = new MemoryFileSystemClassLoader( trgMfs );\n\n        ClassLoader origCl = Thread.currentThread().getContextClassLoader();\n        try {\n            Thread.currentThread().setContextClassLoader( classLoader );\n\n            Weld weldContainer = new Weld() {\n                @Override\n                protected Deployment createDeployment(ResourceLoader resourceLoader,\n                                                      Bootstrap bootstrap) {\n                    return new TestWeldSEDeployment( resourceLoader, bootstrap, classes );\n                }\n            };\n            WeldContainer weld = weldContainer.initialize();\n            KProjectTestClass bean = weld.instance().select( KProjectTestClass.class ).get();\n\n            assertNotNull( bean.getKBase1() );\n            assertNotNull( bean.getKBase2() );\n\n            List<String> list = new ArrayList<String>();\n\n            StatelessKnowledgeSession stlsKsession = bean.getKBase1Ksession1();\n            stlsKsession.setGlobal( \"list\", list );\n            stlsKsession.execute( \"dummy\" );\n            assertEquals( 2, list.size() );\n            assertTrue( list.contains( \"org.test1:rule1\" ) );\n            assertTrue( list.contains( \"org.test1:rule2\" ) );\n\n            list.clear();\n            StatefulKnowledgeSession stflKsession = bean.getKBase1Ksession2();\n            stflKsession.setGlobal( \"list\", list );\n            stflKsession.fireAllRules();\n            assertEquals( 2, list.size() );\n            assertTrue( list.contains( \"org.test1:rule1\" ) );\n            assertTrue( list.contains( \"org.test1:rule2\" ) );\n\n            list.clear();\n            stflKsession = bean.getKBase2Ksession3();\n            stflKsession.setGlobal( \"list\", list );\n            stflKsession.fireAllRules();\n            assertEquals( 2, list.size() );\n\n            assertTrue( list.contains( \"org.test2:rule1\" ) );\n            assertTrue( list.contains( \"org.test2:rule2\" ) );\n\n            weldContainer.shutdown();\n        } finally {\n            Thread.currentThread().setContextClassLoader( origCl );\n        }\n    }","id":6885,"modified_method":"@Test\n    public void testCompileAndCDI() throws IOException,\n                       ClassNotFoundException,\n                       InterruptedException {\n        KProject kproj = new KProjectImpl();\n\n        kproj.setKProjectPath( \"src/main/resources/\" );\n        kproj.setKBasesPath( \"src/kbases\" );\n\n        List<String> files = asList( new String[]{\"org/test1/rule1.drl\", \"org/test1/rule2.drl\"} );\n\n        KBase kBase1 = kproj.newKBase( \"org.test1\", \"KBase1\" )\n                            .setFiles( files )\n                            .setAnnotations( asList( \"@ApplicationScoped; @Inject\" ) )\n                            .setEqualsBehavior( AssertBehaviorOption.EQUALITY )\n                            .setEventProcessingMode( EventProcessingOption.STREAM );\n\n        KSession ksession1 = kBase1.newKSession( \"org.test1\", \"KSession1\" )\n                                    .setType( \"stateless\" )\n                                    .setAnnotations( asList( \"@ApplicationScoped; @Inject\" ) )\n                                    .setClockType( ClockTypeOption.get( \"realtime\" ) );\n\n        KSession ksession2 = kBase1.newKSession( \"org.test1\", \"KSession2\" )\n                                   .setType( \"stateful\" )\n                                   .setAnnotations( asList( \"@ApplicationScoped; @Inject\" ) )\n                                   .setClockType( ClockTypeOption.get( \"pseudo\" ) );\n\n        files = asList( new String[]{\"org/test2/rule1.drl\", \"org/test2/rule2.drl\"} );\n        KBase kbase2 = kproj.newKBase( \"org.test2\", \"KBase2\" )\n                            .setFiles( files )\n                            .setAnnotations( asList( \"@ApplicationScoped\" ) )\n                            .setEqualsBehavior( AssertBehaviorOption.IDENTITY )\n                            .setEventProcessingMode( EventProcessingOption.CLOUD );\n\n        KSession ksession3 = kbase2.newKSession( \"org.test2\", \"KSession3\" )\n                                    .setType( \"stateful\" )\n                                    .setAnnotations( asList( \"@ApplicationScoped\" ) )\n                                    .setClockType( ClockTypeOption.get( \"pseudo\" ) );\n\n        //        \n        //        XStream xstream = new XStream();\n        //        String string = xstream.toXML( kproj );\n        //        System.out.println( string );\n        //      \n\n        //                \n        MemoryFileSystem mfs = new MemoryFileSystem();\n        KProjectChangeLogCommiter.commit( kproj, mfs );\n\n        // printFs(  mfs, mfs.getProjectFolder() );\n\n        String kBase1R1 = getRule( \"org.test1\", \"rule1\" );\n        String kBase1R2 = getRule( \"org.test1\", \"rule2\" );\n\n        String kbase2R1 = getRule( \"org.test2\", \"rule1\" );\n        String kbase2R2 = getRule( \"org.test2\", \"rule2\" );\n\n        String fldKB1 = kproj.getKBasesPath() + \"/\" + kBase1.getQName() + \"/\" + kBase1.getNamespace().replace( '.', '/' );\n        String fldKB2 = kproj.getKBasesPath() + \"/\" + kbase2.getQName() + \"/\" + kbase2.getNamespace().replace( '.', '/' );\n\n        mfs.getFolder( fldKB1 ).create();\n        mfs.getFolder( fldKB2 ).create();\n\n        mfs.getFile( fldKB1 + \"/rule1.drl\" ).create( new ByteArrayInputStream( kBase1R1.getBytes() ) );\n        mfs.getFile( fldKB1 + \"/rule2.drl\" ).create( new ByteArrayInputStream( kBase1R2.getBytes() ) );\n        mfs.getFile( fldKB2 + \"/rule1.drl\" ).create( new ByteArrayInputStream( kbase2R1.getBytes() ) );\n        mfs.getFile( fldKB2 + \"/rule2.drl\" ).create( new ByteArrayInputStream( kbase2R2.getBytes() ) );\n\n        MemoryFileSystem trgMfs = new MemoryFileSystem();\n        MemoryFileSystem srcMfs = mfs;\n\n        Folder fld1 = trgMfs.getFolder( \"org/drools/cdi/test\" );\n        fld1.create();\n        File fle1 = fld1.getFile( \"KProjectTestClassImpl.java\" );\n        fle1.create( new ByteArrayInputStream( generateKProjectTestClassImpl( kproj ).getBytes() ) );\n\n        List<String> inputClasses = new ArrayList<String>();\n        inputClasses.add( \"org/drools/cdi/test/KProjectTestClassImpl.java\" );\n\n        final List<String> classes = compile( kproj, srcMfs, trgMfs, inputClasses );\n\n        MemoryFileSystemClassLoader classLoader = new MemoryFileSystemClassLoader( trgMfs );\n\n        ClassLoader origCl = Thread.currentThread().getContextClassLoader();\n        try {\n            Thread.currentThread().setContextClassLoader( classLoader );\n\n            Weld weldContainer = new Weld() {\n                @Override\n                protected Deployment createDeployment(ResourceLoader resourceLoader,\n                                                      Bootstrap bootstrap) {\n                    return new TestWeldSEDeployment( resourceLoader, bootstrap, classes );\n                }\n            };\n            WeldContainer weld = weldContainer.initialize();\n            KProjectTestClass bean = weld.instance().select( KProjectTestClass.class ).get();\n\n            assertNotNull( bean.getKBase1() );\n            assertNotNull( bean.getKBase2() );\n\n            List<String> list = new ArrayList<String>();\n\n            StatelessKnowledgeSession stlsKsession = bean.getKBase1Ksession1();\n            stlsKsession.setGlobal( \"list\", list );\n            stlsKsession.execute( \"dummy\" );\n            assertEquals( 2, list.size() );\n            assertTrue( list.contains( \"org.test1:rule1\" ) );\n            assertTrue( list.contains( \"org.test1:rule2\" ) );\n\n            list.clear();\n            StatefulKnowledgeSession stflKsession = bean.getKBase1Ksession2();\n            stflKsession.setGlobal( \"list\", list );\n            stflKsession.fireAllRules();\n            assertEquals( 2, list.size() );\n            assertTrue( list.contains( \"org.test1:rule1\" ) );\n            assertTrue( list.contains( \"org.test1:rule2\" ) );\n\n            list.clear();\n            stflKsession = bean.getKBase2Ksession3();\n            stflKsession.setGlobal( \"list\", list );\n            stflKsession.fireAllRules();\n            assertEquals( 2, list.size() );\n\n            assertTrue( list.contains( \"org.test2:rule1\" ) );\n            assertTrue( list.contains( \"org.test2:rule2\" ) );\n\n            weldContainer.shutdown();\n        } finally {\n            Thread.currentThread().setContextClassLoader( origCl );\n        }\n    }","commit_id":"153287ae33acd15c38820f3d0640536f5472f1b7","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Test\n    public void testAddModifyRemoveKSession() throws IOException,\n                                             ClassNotFoundException,\n                                             InterruptedException,\n                                             InstantiationException,\n                                             IllegalAccessException,\n                                             SecurityException,\n                                             NoSuchMethodException,\n                                             IllegalArgumentException,\n                                             InvocationTargetException {\n        KProject kproj = new KProjectImpl();\n\n        KProjectChangeLog klog = new KProjectChangeLog();\n        kproj.setListener( klog );\n\n        kproj.setKProjectPath( \"src/main/resources/\" );\n        kproj.setKBasesPath( \"src/kbases\" );\n\n        List<String> files = asList( new String[]{} );\n\n        // create and add the KBase\n        KBase kBase1 = kproj.newKBase( \"org.test1\", \"KBase1\" );\n        kBase1.setFiles( files );\n        kBase1.setEqualsBehavior( AssertBehaviorOption.EQUALITY );\n        kBase1.setEventProcessingMode( EventProcessingOption.STREAM );\n\n        MemoryFileSystem mfs = new MemoryFileSystem();\n        KProjectChangeLogCommiter.commit( kproj, klog, mfs );\n        Folder fld = mfs.getFolder( \"src/kbases/org.test1.KBase1\" );\n        assertTrue( fld.exists() );\n\n        // Creat and add KSession\n        KSession kSession1 = kBase1.newKSession( \"org.test1\", \"KSession1\" );\n        kSession1.setType( \"stateful\" );\n        kSession1.setClockType( ClockTypeOption.get( \"realtime\" ) );\n\n        KProjectChangeLogCommiter.commit( kproj, klog, mfs );\n\n        MemoryFile mf = (MemoryFile) mfs.getFile( \"src/kbases/org.test1.KBase1/org/test1/KSession1Producer.java\" );\n        String s = new String( mfs.getBytes( mf.getPath().toPortableString() ) );\n        assertTrue( s.contains( \"newStatefulKnowledgeSession\" ) );\n        assertTrue( s.contains( \"realtime\" ) );\n\n        // Modify KSession\n        kSession1.setType( \"stateless\" );\n        kSession1.setClockType( ClockTypeOption.get( \"pseudo\" ) );\n        KProjectChangeLogCommiter.commit( kproj, klog, mfs );\n\n        mf = (MemoryFile) mfs.getFile( \"src/kbases/org.test1.KBase1/org/test1/KSession1Producer.java\" );\n        s = new String( mfs.getBytes( mf.getPath().toPortableString() ) );\n        assertTrue( s.contains( \"newStatelessKnowledgeSession\" ) );\n        assertTrue( s.contains( \"pseudo\" ) );\n\n        // Remove KSession\n        kBase1.removeKSession( \"org.test1.KSession1\" );\n        KProjectChangeLogCommiter.commit( kproj, klog, mfs );\n\n        mf = (MemoryFile) mfs.getFile( \"src/kbases/org.test1.KBase1/org/test1/KSession1Producer.java\" );\n        assertFalse( mf.exists() );\n    }","id":6886,"modified_method":"@Test\n    public void testAddModifyRemoveKSession() throws IOException,\n                                             ClassNotFoundException,\n                                             InterruptedException,\n                                             InstantiationException,\n                                             IllegalAccessException,\n                                             SecurityException,\n                                             NoSuchMethodException,\n                                             IllegalArgumentException,\n                                             InvocationTargetException {\n        KProject kproj = new KProjectImpl();\n\n        KProjectChangeLog klog = new KProjectChangeLog();\n        kproj.setListener( klog );\n\n        kproj.setKProjectPath( \"src/main/resources/\" );\n        kproj.setKBasesPath( \"src/kbases\" );\n\n        List<String> files = asList( new String[]{} );\n\n        // create and add the KBase\n        KBase kBase1 = kproj.newKBase( \"org.test1\", \"KBase1\" )\n                .setFiles( files )\n                .setAnnotations( asList( \"@ApplicationScoped; @Inject\" ) )\n                .setEqualsBehavior( AssertBehaviorOption.EQUALITY )\n                .setEventProcessingMode( EventProcessingOption.STREAM );\n\n        MemoryFileSystem mfs = new MemoryFileSystem();\n        KProjectChangeLogCommiter.commit( kproj, klog, mfs );\n        Folder fld = mfs.getFolder( \"src/kbases/org.test1.KBase1\" );\n        assertTrue( fld.exists() );\n\n        // Creat and add KSession\n        KSession kSession1 = kBase1.newKSession( \"org.test1\", \"KSession1\" )\n                                   .setType( \"stateful\" )\n                                   .setClockType( ClockTypeOption.get( \"realtime\" ) );\n\n        KProjectChangeLogCommiter.commit( kproj, klog, mfs );\n\n        MemoryFile mf = (MemoryFile) mfs.getFile( \"src/kbases/org.test1.KBase1/org/test1/KSession1Producer.java\" );\n        String s = new String( mfs.getBytes( mf.getPath().toPortableString() ) );\n        assertTrue( s.contains( \"newStatefulKnowledgeSession\" ) );\n        assertTrue( s.contains( \"realtime\" ) );\n\n        // Modify KSession\n        kSession1.setType( \"stateless\" )\n                 .setClockType( ClockTypeOption.get( \"pseudo\" ) );\n        KProjectChangeLogCommiter.commit( kproj, klog, mfs );\n\n        mf = (MemoryFile) mfs.getFile( \"src/kbases/org.test1.KBase1/org/test1/KSession1Producer.java\" );\n        s = new String( mfs.getBytes( mf.getPath().toPortableString() ) );\n        assertTrue( s.contains( \"newStatelessKnowledgeSession\" ) );\n        assertTrue( s.contains( \"pseudo\" ) );\n\n        // Remove KSession\n        kBase1.removeKSession( \"org.test1.KSession1\" );\n        KProjectChangeLogCommiter.commit( kproj, klog, mfs );\n\n        mf = (MemoryFile) mfs.getFile( \"src/kbases/org.test1.KBase1/org/test1/KSession1Producer.java\" );\n        assertFalse( mf.exists() );\n    }","commit_id":"153287ae33acd15c38820f3d0640536f5472f1b7","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Test\n    public void testAddModifyRemoveKBase() throws IOException,\n                                          ClassNotFoundException,\n                                          InterruptedException,\n                                          InstantiationException,\n                                          IllegalAccessException,\n                                          SecurityException,\n                                          NoSuchMethodException,\n                                          IllegalArgumentException,\n                                          InvocationTargetException {\n        KProject kproj = new KProjectImpl();\n\n        KProjectChangeLog klog = new KProjectChangeLog();\n        kproj.setListener( klog );\n\n        kproj.setKProjectPath( \"src/main/resources/\" );\n        kproj.setKBasesPath( \"src/kbases\" );\n\n        List<String> files = asList( new String[]{} );\n\n        // Create and add the KBase\n        KBase kBase1 = kproj.newKBase( \"org.test1\", \"KBase1\" );\n        kBase1.setFiles( files );\n        kBase1.setAnnotations( asList( \"@ApplicationScoped; @Inject\" ) );\n        kBase1.setEqualsBehavior( AssertBehaviorOption.EQUALITY );\n        kBase1.setEventProcessingMode( EventProcessingOption.STREAM );\n\n        MemoryFileSystem mfs = new MemoryFileSystem();\n        KProjectChangeLogCommiter.commit( kproj, klog, mfs );\n\n        Folder fld = mfs.getFolder( \"src/kbases/org.test1.KBase1\" );\n        assertTrue( fld.exists() );\n\n        // Modify the KBase\n        MemoryFile mf = (MemoryFile) mfs.getFile( \"src/kbases/org.test1.KBase1/org/test1/KBase1Producer.java\" );\n        String s = new String( mfs.getBytes( mf.getPath().toPortableString() ) );\n        assertTrue( s.contains( \"EventProcessingOption.STREAM\" ) );\n\n        kBase1.setEventProcessingMode( EventProcessingOption.CLOUD );\n        KProjectChangeLogCommiter.commit( kproj, klog, mfs );\n        mf = (MemoryFile) mfs.getFile( \"src/kbases/org.test1.KBase1/org/test1/KBase1Producer.java\" );\n        s = new String( mfs.getBytes( mf.getPath().toPortableString() ) );\n        assertTrue( s.contains( \"EventProcessingOption.CLOUD\" ) );\n\n        // Remove the KBase\n        kproj.removeKBase( kBase1.getQName() );\n        KProjectChangeLogCommiter.commit( kproj, klog, mfs );\n\n        fld = mfs.getFolder( \"src/kbases/org.test1.KBase1\" );\n        assertFalse( fld.exists() );\n        mf = (MemoryFile) mfs.getFile( \"src/kbases/org.test1.KBase1/org/test1/KBase1Producer.java\" );\n        assertFalse( mf.exists() );\n    }","id":6887,"modified_method":"@Test\n    public void testAddModifyRemoveKBase() throws IOException,\n                                          ClassNotFoundException,\n                                          InterruptedException,\n                                          InstantiationException,\n                                          IllegalAccessException,\n                                          SecurityException,\n                                          NoSuchMethodException,\n                                          IllegalArgumentException,\n                                          InvocationTargetException {\n        KProject kproj = new KProjectImpl();\n\n        KProjectChangeLog klog = new KProjectChangeLog();\n        kproj.setListener( klog );\n\n        kproj.setKProjectPath( \"src/main/resources/\" );\n        kproj.setKBasesPath( \"src/kbases\" );\n\n        List<String> files = asList( new String[]{} );\n\n        // Create and add the KBase\n        KBase kBase1 = kproj.newKBase( \"org.test1\", \"KBase1\" )\n                            .setFiles( files )\n                            .setAnnotations( asList( \"@ApplicationScoped; @Inject\" ) )\n                            .setEqualsBehavior( AssertBehaviorOption.EQUALITY )\n                            .setEventProcessingMode( EventProcessingOption.STREAM );\n\n        MemoryFileSystem mfs = new MemoryFileSystem();\n        KProjectChangeLogCommiter.commit( kproj, klog, mfs );\n\n        Folder fld = mfs.getFolder( \"src/kbases/org.test1.KBase1\" );\n        assertTrue( fld.exists() );\n\n        // Modify the KBase\n        MemoryFile mf = (MemoryFile) mfs.getFile( \"src/kbases/org.test1.KBase1/org/test1/KBase1Producer.java\" );\n        String s = new String( mfs.getBytes( mf.getPath().toPortableString() ) );\n        assertTrue( s.contains( \"EventProcessingOption.STREAM\" ) );\n\n        kBase1.setEventProcessingMode( EventProcessingOption.CLOUD );\n        KProjectChangeLogCommiter.commit( kproj, klog, mfs );\n        mf = (MemoryFile) mfs.getFile( \"src/kbases/org.test1.KBase1/org/test1/KBase1Producer.java\" );\n        s = new String( mfs.getBytes( mf.getPath().toPortableString() ) );\n        assertTrue( s.contains( \"EventProcessingOption.CLOUD\" ) );\n\n        // Remove the KBase\n        kproj.removeKBase( kBase1.getQName() );\n        KProjectChangeLogCommiter.commit( kproj, klog, mfs );\n\n        fld = mfs.getFolder( \"src/kbases/org.test1.KBase1\" );\n        assertFalse( fld.exists() );\n        mf = (MemoryFile) mfs.getFile( \"src/kbases/org.test1.KBase1/org/test1/KBase1Producer.java\" );\n        assertFalse( mf.exists() );\n    }","commit_id":"153287ae33acd15c38820f3d0640536f5472f1b7","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public String generateKProjectTestClassImpl(KProject kproject) {\n        String s = \"package org.drools.cdi.test;\\n\" +\n                   \"import javax.inject.Named;\\n\" +\n                   \"import javax.inject.Inject;\\n\" +\n                   \"import javax.inject.Inject;\\n\" +\n                   \"import javax.enterprise.event.Observes;\\n\" +\n                   \"import org.jboss.weld.environment.se.events.ContainerInitialized;\\n\" +\n                   \"import \" + KnowledgeBase.class.getName() + \";\\n\" +\n                   \"import \" + StatefulKnowledgeSession.class.getName() + \";\\n\" +\n                   \"import \" + StatelessKnowledgeSession.class.getName() + \";\\n\" +\n                   \"import org.test1.kBase1;\\n\" +\n                   \"import org.test1.KSession1;\\n\" +\n                   \"import org.test1.KSession2;\\n\" +\n                   \"import org.test2.KSession3;\\n\" +\n                   \"import org.test2.KBase2;\\n\" +\n\n                   \"public class KProjectTestClassImpl implements org.drools.kproject.KProjectTestClass {\\n\" +\n                   \"    private @Inject @kBase1 KnowledgeBase kBase1; \\n\" +\n                   \"    public KnowledgeBase getKBase1() {\\n\" +\n                   \"        return kBase1;\\n\" +\n                   \"    }\\n\" +\n                   \"    private @Inject @KBase2 KnowledgeBase kBase2; \\n\" +\n                   \"    public KnowledgeBase getKBase2() {\\n\" +\n                   \"        return kBase2;\\n\" +\n                   \"    }\\n\" +\n                   \"    private @Inject @KSession1 StatelessKnowledgeSession kBase1kSession1; \\n\" +\n                   \"    public StatelessKnowledgeSession getKBase1Ksession1() {\\n\" +\n                   \"        return kBase1kSession1;\\n\" +\n                   \"    }\\n\" +\n                   \"    private @Inject @KSession2 StatefulKnowledgeSession kBase1kSession2; \\n\" +\n                   \"    public StatefulKnowledgeSession getKBase1Ksession2() {\\n\" +\n                   \"        return kBase1kSession2;\\n\" +\n                   \"    }\\n\" +\n                   \"    private @Inject @KSession3 StatefulKnowledgeSession kBase2kSession3; \\n\" +\n                   \"    public StatefulKnowledgeSession getKBase2Ksession3() {\\n\" +\n                   \"        return kBase2kSession3;\\n\" +\n                   \"    }\\n\" +\n                   \"}\\n\";\n\n        return s;\n    }","id":6888,"modified_method":"public String generateKProjectTestClassImpl(KProject kproject) {\n        String s = \"package org.drools.cdi.test;\\n\" +\n                   \"import javax.inject.Named;\\n\" +\n                   \"import javax.inject.Inject;\\n\" +\n                   \"import javax.inject.Inject;\\n\" +\n                   \"import javax.enterprise.event.Observes;\\n\" +\n                   \"import org.jboss.weld.environment.se.events.ContainerInitialized;\\n\" +\n                   \"import \" + KnowledgeBase.class.getName() + \";\\n\" +\n                   \"import \" + StatefulKnowledgeSession.class.getName() + \";\\n\" +\n                   \"import \" + StatelessKnowledgeSession.class.getName() + \";\\n\" +\n                   \"import org.test1.KBase1;\\n\" +\n                   \"import org.test1.KSession1;\\n\" +\n                   \"import org.test1.KSession2;\\n\" +\n                   \"import org.test2.KSession3;\\n\" +\n                   \"import org.test2.KBase2;\\n\" +\n\n                   \"public class KProjectTestClassImpl implements org.drools.kproject.KProjectTestClass {\\n\" +\n                   \"    private @Inject @KBase1 KnowledgeBase kBase1; \\n\" +\n                   \"    public KnowledgeBase getKBase1() {\\n\" +\n                   \"        return kBase1;\\n\" +\n                   \"    }\\n\" +\n                   \"    private @Inject @KBase2 KnowledgeBase kBase2; \\n\" +\n                   \"    public KnowledgeBase getKBase2() {\\n\" +\n                   \"        return kBase2;\\n\" +\n                   \"    }\\n\" +\n                   \"    private @Inject @KSession1 StatelessKnowledgeSession kBase1kSession1; \\n\" +\n                   \"    public StatelessKnowledgeSession getKBase1Ksession1() {\\n\" +\n                   \"        return kBase1kSession1;\\n\" +\n                   \"    }\\n\" +\n                   \"    private @Inject @KSession2 StatefulKnowledgeSession kBase1kSession2; \\n\" +\n                   \"    public StatefulKnowledgeSession getKBase1Ksession2() {\\n\" +\n                   \"        return kBase1kSession2;\\n\" +\n                   \"    }\\n\" +\n                   \"    private @Inject @KSession3 StatefulKnowledgeSession kBase2kSession3; \\n\" +\n                   \"    public StatefulKnowledgeSession getKBase2Ksession3() {\\n\" +\n                   \"        return kBase2kSession3;\\n\" +\n                   \"    }\\n\" +\n                   \"}\\n\";\n\n        return s;\n    }","commit_id":"153287ae33acd15c38820f3d0640536f5472f1b7","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void setListener(PropertyChangeListener listener) {\n        this.listener = listener;\n    }","id":6889,"modified_method":"public KSession setListener(PropertyChangeListener listener) {\n        this.listener = listener;\n        return this;\n    }","commit_id":"153287ae33acd15c38820f3d0640536f5472f1b7","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void setName(String name) {\n        if ( listener != null ) {\n            listener.propertyChange( new PropertyChangeEvent( this, \"name\", this.name, name ) );\n        }\n        this.name = name;\n    }","id":6890,"modified_method":"public KSession setName(String name) {\n        if ( listener != null ) {\n            listener.propertyChange( new PropertyChangeEvent( this, \"name\", this.name, name ) );\n        }\n        this.name = name;\n        return this;\n    }","commit_id":"153287ae33acd15c38820f3d0640536f5472f1b7","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void setClockType(ClockTypeOption clockType) {\n        if ( listener != null ) {\n            listener.propertyChange( new PropertyChangeEvent( this, \"clockType\", this.clockType, clockType ) );\n        }\n        this.clockType = clockType;\n    }","id":6891,"modified_method":"public KSession setClockType(ClockTypeOption clockType) {\n        if ( listener != null ) {\n            listener.propertyChange( new PropertyChangeEvent( this, \"clockType\", this.clockType, clockType ) );\n        }\n        this.clockType = clockType;\n        return this;\n    }","commit_id":"153287ae33acd15c38820f3d0640536f5472f1b7","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void setType(String type) {\n        if ( listener != null ) {\n            listener.propertyChange( new PropertyChangeEvent( this, \"type\", this.type, type ) );\n        }\n        this.type = type;\n    }","id":6892,"modified_method":"public KSession setType(String type) {\n        if ( listener != null ) {\n            listener.propertyChange( new PropertyChangeEvent( this, \"type\", this.type, type ) );\n        }\n        this.type = type;\n        return this;\n    }","commit_id":"153287ae33acd15c38820f3d0640536f5472f1b7","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void setAnnotations(List<String> annotations) {\n        if ( listener != null ) {\n            listener.propertyChange( new PropertyChangeEvent( this, \"annotations\", this.annotations, annotations ) );\n        }\n        this.annotations = annotations;\n    }","id":6893,"modified_method":"public KSession setAnnotations(List<String> annotations) {\n        if ( listener != null ) {\n            listener.propertyChange( new PropertyChangeEvent( this, \"annotations\", this.annotations, annotations ) );\n        }\n        this.annotations = annotations;\n        return this;\n    }","commit_id":"153287ae33acd15c38820f3d0640536f5472f1b7","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void setNamespace(String namespace) {\n        if ( listener != null ) {\n            listener.propertyChange( new PropertyChangeEvent( this, \"namespace\", this.namespace, namespace ) );\n        }\n        this.namespace = namespace;\n    }","id":6894,"modified_method":"public KSession setNamespace(String namespace) {\n        if ( listener != null ) {\n            listener.propertyChange( new PropertyChangeEvent( this, \"namespace\", this.namespace, namespace ) );\n        }\n        this.namespace = namespace;\n        return this;\n    }","commit_id":"153287ae33acd15c38820f3d0640536f5472f1b7","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**A static method which displays a file chooser for the user to choose which file to save into.\n       It returns the selected file or null if the process didn't complete*/\n    public static File selectFile(String title, String fileType)\n    {\n        File picked = null;\n        JFileChooser chooser = new JFileChooser();\n        chooser.setDialogTitle(title);\n        chooser.setAcceptAllFileFilterUsed(false);\n        int compCount = chooser.getComponentCount();\n        Component jc = chooser.getComponent(2);\n        \n        \n        \n        \n        if (fileType != null)\n         chooser.setFileFilter(new VueFileFilter(fileType)); \n        \n        else\n        {\n            VueFileFilter defaultFilter = new VueFileFilter(VueFileFilter.VUE_DESCRIPTION);\n            \n            chooser.addChoosableFileFilter(defaultFilter);  \n            chooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.JPEG_DESCRIPTION));  \n            chooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.SVG_DESCRIPTION));\n            //chooser.addChoosableFileFilter(new VueFileFilter(\"pdf\"));\n            //chooser.addChoosableFileFilter(new VueFileFilter(\"html\"));\n            chooser.addChoosableFileFilter(new VueFileFilter(\"rdf\"));\n            chooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.IMAGEMAP_DESCRIPTION));\n            chooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.IMS_DESCRIPTION));\n            //chooser.addChoosableFileFilter(new VueFileFilter(\"HTML Outline\", \"htm\"));\n            \n            chooser.setFileFilter(defaultFilter); \n        }\n         \n    //    JPanel p1 = (JPanel)chooser.getComponent(2);\n      //  JPanel p2 = (JPanel)p1.getComponent(2);\n       // JPanel p3 = (JPanel)p2.getComponent(2);\n       // JComboBox box = (JComboBox)p3.getComponent(3);\n        //box.g\n       // box.setRenderer(new PaddedCellRenderer());\n        \n        if(VueUtil.isCurrentDirectoryPathSet()) \n          chooser.setCurrentDirectory(new File(VueUtil.getCurrentDirectoryPath()));  \n        \n        int option = chooser.showDialog(VUE.getDialogParent(), \"Save\");\n        \n        if (option == JFileChooser.APPROVE_OPTION) \n        {\n            picked = chooser.getSelectedFile();\n            \n            String fileName = picked.getAbsolutePath();\n            //String extension = chooser.getFileFilter().getDescription();\n              String extension = ((VueFileFilter)chooser.getFileFilter()).getExtensions()[0];  \n            //if it isn't a file name with the right extention \n            if (!fileName.endsWith(\".\" + extension)) {\n                fileName += \".\" + extension;\n                picked = new File(fileName);\n            }\n            \n            if (picked.exists()) {\n                int n = JOptionPane.showConfirmDialog(null, VueResources.getString(\"replaceFile.text\") + \" \\'\" + picked.getName() + \"\\'\", \n                        VueResources.getString(\"replaceFile.title\"), JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);\n                  \n                if (n == JOptionPane.NO_OPTION)\n                    picked = null;\n            } \n            \n            if (picked != null)\n                VueUtil.setCurrentDirectoryPath(picked.getParent());\n        }\n        \n        return picked;\n    }","id":6895,"modified_method":"/**A static method which displays a file chooser for the user to choose which file to save into.\n       It returns the selected file or null if the process didn't complete*/\n    public static File selectFile(String title, String fileType)\n    {\n        File picked = null;\n        JFileChooser chooser = new JFileChooser();\n        chooser.setDialogTitle(title);\n        chooser.setAcceptAllFileFilterUsed(false);    \n        \n        \n        \n        \n        if (fileType != null && !fileType.equals(\"export\"))\n         chooser.setFileFilter(new VueFileFilter(fileType)); \n        else if (fileType != null && fileType.equals(\"export\"))\n        {\n        \tchooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.JPEG_DESCRIPTION));  \n        \tchooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.SVG_DESCRIPTION));        \t\n        \tchooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.IMS_DESCRIPTION));\n        \tchooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.IMAGEMAP_DESCRIPTION));\n        }\n        else\n        {\n            VueFileFilter defaultFilter = new VueFileFilter(VueFileFilter.VUE_DESCRIPTION);\n            \n            chooser.addChoosableFileFilter(defaultFilter);  \n////            chooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.JPEG_DESCRIPTION));  \n////            chooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.SVG_DESCRIPTION));\n            //chooser.addChoosableFileFilter(new VueFileFilter(\"pdf\"));\n            //chooser.addChoosableFileFilter(new VueFileFilter(\"html\"));\n            chooser.addChoosableFileFilter(new VueFileFilter(\"rdf\"));\n////            chooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.IMAGEMAP_DESCRIPTION));\n////            chooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.IMS_DESCRIPTION));\n            //chooser.addChoosableFileFilter(new VueFileFilter(\"HTML Outline\", \"htm\"));\n            \n            chooser.setFileFilter(defaultFilter); \n        }\n         \n    //    JPanel p1 = (JPanel)chooser.getComponent(2);\n      //  JPanel p2 = (JPanel)p1.getComponent(2);\n       // JPanel p3 = (JPanel)p2.getComponent(2);\n       // JComboBox box = (JComboBox)p3.getComponent(3);\n        //box.g\n       // box.setRenderer(new PaddedCellRenderer());\n        \n        if(VueUtil.isCurrentDirectoryPathSet()) \n          chooser.setCurrentDirectory(new File(VueUtil.getCurrentDirectoryPath()));  \n        \n        int option = chooser.showDialog(VUE.getDialogParent(), \"Save\");\n        \n        if (option == JFileChooser.APPROVE_OPTION) \n        {\n            picked = chooser.getSelectedFile();\n            \n            String fileName = picked.getAbsolutePath();\n            //String extension = chooser.getFileFilter().getDescription();\n              String extension = ((VueFileFilter)chooser.getFileFilter()).getExtensions()[0];  \n            //if it isn't a file name with the right extention \n            if (!fileName.endsWith(\".\" + extension)) {\n                fileName += \".\" + extension;\n                picked = new File(fileName);\n            }\n            \n            if (picked.exists()) {\n                int n = JOptionPane.showConfirmDialog(null, VueResources.getString(\"replaceFile.text\") + \" \\'\" + picked.getName() + \"\\'\", \n                        VueResources.getString(\"replaceFile.title\"), JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);\n                  \n                if (n == JOptionPane.NO_OPTION)\n                    picked = null;\n            } \n            \n            if (picked != null)\n                VueUtil.setCurrentDirectoryPath(picked.getParent());\n        }\n        \n        return picked;\n    }","commit_id":"e4f985762ba20f929b4d0e473173650ef4fe33d8","url":"https://github.com/VUE/VUE"},{"original_method":"private ConnectionPool() {\n\t\ttry {\n\n\t\t\t// Properties\n\n\t\t\tClassLoader classLoader = getClass().getClassLoader();\n\n\t\t\t_props = new Properties();\n\n\t\t\t_props.load(\n\t\t\t\tclassLoader.getResourceAsStream(\"connection-pool.properties\"));\n\n\t\t\t_props.list(System.out);\n\n\t\t\t// Pooled data source\n\n\t\t\tString driverClass = _props.getProperty(\"driver.class\");\n\t\t\tString jdbcUrl = _props.getProperty(\"jdbc.url\");\n\t\t\tString user = _props.getProperty(\"user\");\n\t\t\tString password = _props.getProperty(\"password\");\n\n\t\t\tint minPoolSize = 5;\n\n\t\t\ttry {\n\t\t\t\tminPoolSize = Integer.parseInt(\n\t\t\t\t\t_props.getProperty(\"min.pool.size\"));\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tint maxPoolSize = 5;\n\n\t\t\ttry {\n\t\t\t\tmaxPoolSize = Integer.parseInt(\n\t\t\t\t\t_props.getProperty(\"max.pool.size\"));\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tint acquireIncrement = 5;\n\n\t\t\ttry {\n\t\t\t\tacquireIncrement = Integer.parseInt(\n\t\t\t\t\t_props.getProperty(\"acquire.increment\"));\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\t_cpds = new ComboPooledDataSource();\n\n\t\t\t_cpds.setDriverClass(driverClass);\n\t\t\t_cpds.setJdbcUrl(jdbcUrl);\n\t\t\t_cpds.setUser(user);\n\t\t\t_cpds.setPassword(password);\n\n\t\t\t_cpds.setMinPoolSize(minPoolSize);\n\t\t\t_cpds.setMaxPoolSize(maxPoolSize);\n\t\t\t_cpds.setAcquireIncrement(acquireIncrement);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e);\n\t\t}\n\t}","id":6896,"modified_method":"private ConnectionPool() {\n\t\ttry {\n\n\t\t\t// Properties\n\n\t\t\tClass<?> clazz = getClass();\n\n\t\t\tClassLoader classLoader = clazz.getClassLoader();\n\n\t\t\t_props = new Properties();\n\n\t\t\t_props.load(\n\t\t\t\tclassLoader.getResourceAsStream(\"connection-pool.properties\"));\n\n\t\t\t_props.list(System.out);\n\n\t\t\t// Pooled data source\n\n\t\t\tString driverClass = _props.getProperty(\"driver.class\");\n\t\t\tString jdbcUrl = _props.getProperty(\"jdbc.url\");\n\t\t\tString user = _props.getProperty(\"user\");\n\t\t\tString password = _props.getProperty(\"password\");\n\n\t\t\tint minPoolSize = 5;\n\n\t\t\ttry {\n\t\t\t\tminPoolSize = Integer.parseInt(\n\t\t\t\t\t_props.getProperty(\"min.pool.size\"));\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tint maxPoolSize = 5;\n\n\t\t\ttry {\n\t\t\t\tmaxPoolSize = Integer.parseInt(\n\t\t\t\t\t_props.getProperty(\"max.pool.size\"));\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tint acquireIncrement = 5;\n\n\t\t\ttry {\n\t\t\t\tacquireIncrement = Integer.parseInt(\n\t\t\t\t\t_props.getProperty(\"acquire.increment\"));\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\t_cpds = new ComboPooledDataSource();\n\n\t\t\t_cpds.setDriverClass(driverClass);\n\t\t\t_cpds.setJdbcUrl(jdbcUrl);\n\t\t\t_cpds.setUser(user);\n\t\t\t_cpds.setPassword(password);\n\n\t\t\t_cpds.setMinPoolSize(minPoolSize);\n\t\t\t_cpds.setMaxPoolSize(maxPoolSize);\n\t\t\t_cpds.setAcquireIncrement(acquireIncrement);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e);\n\t\t}\n\t}","commit_id":"45a1a3c3591182773557f9544d176f595bd9a9a7","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"private RBVUtil() {\n\t\tDocument document = null;\n\n\t\ttry {\n\t\t\tClassLoader classLoader = getClass().getClassLoader();\n\n\t\t\tURL url = classLoader.getResource(\n\t\t\t\t\"com/liferay/randombibleverse/dependencies/\" +\n\t\t\t\t\t\"random_bible_verse.xml\");\n\n\t\t\tdocument = SAXReaderUtil.read(url);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\t_bibles = new LinkedHashMap<>();\n\t\t_verses = new ArrayList<>();\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tElement biblesElement = rootElement.element(\"bibles\");\n\n\t\tList<Element> bibleElements = biblesElement.elements(\"bible\");\n\n\t\tfor (Element bibleElement : bibleElements) {\n\t\t\t_bibles.put(\n\t\t\t\tbibleElement.attributeValue(\"language\"),\n\t\t\t\tnew Bible(\n\t\t\t\t\tbibleElement.attributeValue(\"language\"),\n\t\t\t\t\tbibleElement.attributeValue(\"language-name\"),\n\t\t\t\t\tbibleElement.attributeValue(\"version-id\")));\n\t\t}\n\n\t\t_bibles = Collections.unmodifiableMap(_bibles);\n\n\t\tElement versesElement = rootElement.element(\"verses\");\n\n\t\tList<Element> verseElements = versesElement.elements(\"verse\");\n\n\t\tfor (Element verseElement : verseElements) {\n\t\t\t_verses.add(verseElement.attributeValue(\"location\"));\n\t\t}\n\n\t\t_verses = Collections.unmodifiableList(_verses);\n\t}","id":6897,"modified_method":"private RBVUtil() {\n\t\tDocument document = null;\n\n\t\ttry {\n\t\t\tClass<?> clazz = getClass();\n\n\t\t\tClassLoader classLoader = clazz.getClassLoader();\n\n\t\t\tURL url = classLoader.getResource(\n\t\t\t\t\"com/liferay/randombibleverse/dependencies/\" +\n\t\t\t\t\t\"random_bible_verse.xml\");\n\n\t\t\tdocument = SAXReaderUtil.read(url);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\t_bibles = new LinkedHashMap<>();\n\t\t_verses = new ArrayList<>();\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tElement biblesElement = rootElement.element(\"bibles\");\n\n\t\tList<Element> bibleElements = biblesElement.elements(\"bible\");\n\n\t\tfor (Element bibleElement : bibleElements) {\n\t\t\t_bibles.put(\n\t\t\t\tbibleElement.attributeValue(\"language\"),\n\t\t\t\tnew Bible(\n\t\t\t\t\tbibleElement.attributeValue(\"language\"),\n\t\t\t\t\tbibleElement.attributeValue(\"language-name\"),\n\t\t\t\t\tbibleElement.attributeValue(\"version-id\")));\n\t\t}\n\n\t\t_bibles = Collections.unmodifiableMap(_bibles);\n\n\t\tElement versesElement = rootElement.element(\"verses\");\n\n\t\tList<Element> verseElements = versesElement.elements(\"verse\");\n\n\t\tfor (Element verseElement : verseElements) {\n\t\t\t_verses.add(verseElement.attributeValue(\"location\"));\n\t\t}\n\n\t\t_verses = Collections.unmodifiableList(_verses);\n\t}","commit_id":"45a1a3c3591182773557f9544d176f595bd9a9a7","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic Object convert(String key) throws WebCacheException {\n\t\tString symbol = _symbol;\n\t\tdouble lastTrade = 0.0;\n\t\tdouble change = 0.0;\n\t\tdouble open = 0.0;\n\t\tdouble dayHigh = 0.0;\n\t\tdouble dayLow = 0.0;\n\t\tlong volume = 0;\n\n\t\tStocks stocks = new Stocks(\n\t\t\tsymbol, lastTrade, change, open, dayHigh, dayLow, volume);\n\n\t\ttry {\n\t\t\tString text = HttpUtil.URLtoString(\n\t\t\t\t\"http://finance.yahoo.com/d/quotes.csv?s=\" + symbol +\n\t\t\t\t\t\"&f=sl1d1t1c1ohgv&e=.csv\");\n\n\t\t\tStringTokenizer st = new StringTokenizer(text, StringPool.COMMA);\n\n\t\t\t// Skip symbol\n\n\t\t\tst.nextToken();\n\n\t\t\ttry {\n\t\t\t\tlastTrade = GetterUtil.getDouble(\n\t\t\t\t\tst.nextToken().replace('\"', ' ').trim());\n\n\t\t\t\tstocks.setLastTrade(lastTrade);\n\t\t\t}\n\t\t\tcatch (NumberFormatException nfe) {\n\t\t\t\tstocks.setLastTradeAvailable(false);\n\t\t\t}\n\n\t\t\t// Skip date and time\n\n\t\t\tst.nextToken();\n\t\t\tst.nextToken();\n\n\t\t\ttry {\n\t\t\t\tchange = GetterUtil.getDouble(\n\t\t\t\t\tst.nextToken().replace('\"', ' ').trim());\n\n\t\t\t\tstocks.setChange(change);\n\t\t\t}\n\t\t\tcatch (NumberFormatException nfe) {\n\t\t\t\tstocks.setChangeAvailable(false);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\topen = GetterUtil.getDouble(\n\t\t\t\t\tst.nextToken().replace('\"', ' ').trim());\n\n\t\t\t\tstocks.setOpen(open);\n\t\t\t}\n\t\t\tcatch (NumberFormatException nfe) {\n\t\t\t\tstocks.setOpenAvailable(false);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tdayHigh = GetterUtil.getDouble(\n\t\t\t\t\tst.nextToken().replace('\"', ' ').trim());\n\n\t\t\t\tstocks.setDayHigh(dayHigh);\n\t\t\t}\n\t\t\tcatch (NumberFormatException nfe) {\n\t\t\t\tstocks.setDayHighAvailable(false);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tdayLow = GetterUtil.getDouble(\n\t\t\t\t\tst.nextToken().replace('\"', ' ').trim());\n\n\t\t\t\tstocks.setDayLow(dayLow);\n\t\t\t}\n\t\t\tcatch (NumberFormatException nfe) {\n\t\t\t\tstocks.setDayLowAvailable(false);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tvolume = GetterUtil.getLong(\n\t\t\t\t\tst.nextToken().replace('\"', ' ').trim());\n\n\t\t\t\tstocks.setVolume(volume);\n\t\t\t}\n\t\t\tcatch (NumberFormatException nfe) {\n\t\t\t\tstocks.setVolumeAvailable(false);\n\t\t\t}\n\n\t\t\tif (!stocks.isValid()) {\n\t\t\t\tthrow new WebCacheException(symbol);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebCacheException(symbol + \" \" + e.toString());\n\t\t}\n\n\t\treturn stocks;\n\t}","id":6898,"modified_method":"@Override\n\tpublic Object convert(String key) throws WebCacheException {\n\t\tString symbol = _symbol;\n\t\tdouble lastTrade = 0.0;\n\t\tdouble change = 0.0;\n\t\tdouble open = 0.0;\n\t\tdouble dayHigh = 0.0;\n\t\tdouble dayLow = 0.0;\n\t\tlong volume = 0;\n\n\t\tStocks stocks = new Stocks(\n\t\t\tsymbol, lastTrade, change, open, dayHigh, dayLow, volume);\n\n\t\ttry {\n\t\t\tString text = HttpUtil.URLtoString(\n\t\t\t\t\"http://finance.yahoo.com/d/quotes.csv?s=\" + symbol +\n\t\t\t\t\t\"&f=sl1d1t1c1ohgv&e=.csv\");\n\n\t\t\tStringTokenizer st = new StringTokenizer(text, StringPool.COMMA);\n\n\t\t\t// Skip symbol\n\n\t\t\tst.nextToken();\n\n\t\t\ttry {\n\t\t\t\tString token = st.nextToken();\n\n\t\t\t\ttoken = token.replace('\"', ' ');\n\n\t\t\t\tlastTrade = GetterUtil.getDouble(token.trim());\n\n\t\t\t\tstocks.setLastTrade(lastTrade);\n\t\t\t}\n\t\t\tcatch (NumberFormatException nfe) {\n\t\t\t\tstocks.setLastTradeAvailable(false);\n\t\t\t}\n\n\t\t\t// Skip date and time\n\n\t\t\tst.nextToken();\n\t\t\tst.nextToken();\n\n\t\t\ttry {\n\t\t\t\tString token = st.nextToken();\n\n\t\t\t\ttoken = token.replace('\"', ' ');\n\n\t\t\t\tchange = GetterUtil.getDouble(token.trim());\n\n\t\t\t\tstocks.setChange(change);\n\t\t\t}\n\t\t\tcatch (NumberFormatException nfe) {\n\t\t\t\tstocks.setChangeAvailable(false);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tString token = st.nextToken();\n\n\t\t\t\ttoken = token.replace('\"', ' ');\n\n\t\t\t\topen = GetterUtil.getDouble(token.trim());\n\n\t\t\t\tstocks.setOpen(open);\n\t\t\t}\n\t\t\tcatch (NumberFormatException nfe) {\n\t\t\t\tstocks.setOpenAvailable(false);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tString token = st.nextToken();\n\n\t\t\t\ttoken = token.replace('\"', ' ');\n\n\t\t\t\tdayHigh = GetterUtil.getDouble(token.trim());\n\n\t\t\t\tstocks.setDayHigh(dayHigh);\n\t\t\t}\n\t\t\tcatch (NumberFormatException nfe) {\n\t\t\t\tstocks.setDayHighAvailable(false);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tString token = st.nextToken();\n\n\t\t\t\ttoken = token.replace('\"', ' ');\n\n\t\t\t\tdayLow = GetterUtil.getDouble(token.trim());\n\n\t\t\t\tstocks.setDayLow(dayLow);\n\t\t\t}\n\t\t\tcatch (NumberFormatException nfe) {\n\t\t\t\tstocks.setDayLowAvailable(false);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tString token = st.nextToken();\n\n\t\t\t\ttoken = token.replace('\"', ' ');\n\n\t\t\t\tvolume = GetterUtil.getLong(token.trim());\n\n\t\t\t\tstocks.setVolume(volume);\n\t\t\t}\n\t\t\tcatch (NumberFormatException nfe) {\n\t\t\t\tstocks.setVolumeAvailable(false);\n\t\t\t}\n\n\t\t\tif (!stocks.isValid()) {\n\t\t\t\tthrow new WebCacheException(symbol);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebCacheException(symbol + \" \" + e.toString());\n\t\t}\n\n\t\treturn stocks;\n\t}","commit_id":"45a1a3c3591182773557f9544d176f595bd9a9a7","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"private WCUtil() {\n\t\tDocument document = null;\n\n\t\ttry {\n\t\t\tClassLoader classLoader = getClass().getClassLoader();\n\n\t\t\tURL url = classLoader.getResource(\n\t\t\t\t\"com/liferay/westminstercatechism/dependencies/\" +\n\t\t\t\t\t\"westminster_catechmism.xml\");\n\n\t\t\tdocument = SAXReaderUtil.read(url);\n\t\t}\n\t\tcatch (DocumentException de) {\n\t\t\t_log.error(de, de);\n\t\t}\n\n\t\t_shorter = new ArrayList<>();\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tElement shorterElement = rootElement.element(\"shorter\");\n\n\t\tList<Element> entryElements = shorterElement.elements(\"entry\");\n\n\t\tfor (Element entryElement : entryElements) {\n\t\t\tList<String[]> proofs = new ArrayList<>();\n\n\t\t\tElement proofsElement = entryElement.element(\"proofs\");\n\n\t\t\tList<Element> scripturesElements = proofsElement.elements(\n\t\t\t\t\"scriptures\");\n\n\t\t\tfor (Element scripturesElement : scripturesElements) {\n\t\t\t\tproofs.add(\n\t\t\t\t\tStringUtil.split(\n\t\t\t\t\t\tscripturesElement.getText(), StringPool.SEMICOLON));\n\t\t\t}\n\n\t\t\t_shorter.add(\n\t\t\t\tnew WCEntry(\n\t\t\t\t\tentryElement.elementText(\"question\"),\n\t\t\t\t\tentryElement.elementText(\"answer\"),\n\t\t\t\t\tproofs.toArray(new String[0][0])));\n\t\t}\n\n\t\t_shorter = Collections.unmodifiableList(_shorter);\n\n\t\t_larger = new ArrayList<>();\n\n\t\tElement largerElement = rootElement.element(\"larger\");\n\n\t\tentryElements = largerElement.elements(\"entry\");\n\n\t\tfor (Element entry : entryElements) {\n\t\t\tList<String[]> proofs = new ArrayList<>();\n\n\t\t\tElement proofsElement = entry.element(\"proofs\");\n\n\t\t\tList<Element> scripturesElements = proofsElement.elements(\n\t\t\t\t\"scriptures\");\n\n\t\t\tfor (Element scriptures : scripturesElements) {\n\t\t\t\tproofs.add(\n\t\t\t\t\tStringUtil.split(\n\t\t\t\t\t\tscriptures.getText(), StringPool.SEMICOLON));\n\t\t\t}\n\n\t\t\t_larger.add(\n\t\t\t\tnew WCEntry(\n\t\t\t\t\tentry.elementText(\"question\"), entry.elementText(\"answer\"),\n\t\t\t\t\tproofs.toArray(new String[0][0])));\n\t\t}\n\n\t\t_larger = Collections.unmodifiableList(_larger);\n\t}","id":6899,"modified_method":"private WCUtil() {\n\t\tDocument document = null;\n\n\t\ttry {\n\t\t\tClass<?> clazz = getClass();\n\n\t\t\tClassLoader classLoader = clazz.getClassLoader();\n\n\t\t\tURL url = classLoader.getResource(\n\t\t\t\t\"com/liferay/westminstercatechism/dependencies/\" +\n\t\t\t\t\t\"westminster_catechmism.xml\");\n\n\t\t\tdocument = SAXReaderUtil.read(url);\n\t\t}\n\t\tcatch (DocumentException de) {\n\t\t\t_log.error(de, de);\n\t\t}\n\n\t\t_shorter = new ArrayList<>();\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tElement shorterElement = rootElement.element(\"shorter\");\n\n\t\tList<Element> entryElements = shorterElement.elements(\"entry\");\n\n\t\tfor (Element entryElement : entryElements) {\n\t\t\tList<String[]> proofs = new ArrayList<>();\n\n\t\t\tElement proofsElement = entryElement.element(\"proofs\");\n\n\t\t\tList<Element> scripturesElements = proofsElement.elements(\n\t\t\t\t\"scriptures\");\n\n\t\t\tfor (Element scripturesElement : scripturesElements) {\n\t\t\t\tproofs.add(\n\t\t\t\t\tStringUtil.split(\n\t\t\t\t\t\tscripturesElement.getText(), StringPool.SEMICOLON));\n\t\t\t}\n\n\t\t\t_shorter.add(\n\t\t\t\tnew WCEntry(\n\t\t\t\t\tentryElement.elementText(\"question\"),\n\t\t\t\t\tentryElement.elementText(\"answer\"),\n\t\t\t\t\tproofs.toArray(new String[0][0])));\n\t\t}\n\n\t\t_shorter = Collections.unmodifiableList(_shorter);\n\n\t\t_larger = new ArrayList<>();\n\n\t\tElement largerElement = rootElement.element(\"larger\");\n\n\t\tentryElements = largerElement.elements(\"entry\");\n\n\t\tfor (Element entry : entryElements) {\n\t\t\tList<String[]> proofs = new ArrayList<>();\n\n\t\t\tElement proofsElement = entry.element(\"proofs\");\n\n\t\t\tList<Element> scripturesElements = proofsElement.elements(\n\t\t\t\t\"scriptures\");\n\n\t\t\tfor (Element scriptures : scripturesElements) {\n\t\t\t\tproofs.add(\n\t\t\t\t\tStringUtil.split(\n\t\t\t\t\t\tscriptures.getText(), StringPool.SEMICOLON));\n\t\t\t}\n\n\t\t\t_larger.add(\n\t\t\t\tnew WCEntry(\n\t\t\t\t\tentry.elementText(\"question\"), entry.elementText(\"answer\"),\n\t\t\t\t\tproofs.toArray(new String[0][0])));\n\t\t}\n\n\t\t_larger = Collections.unmodifiableList(_larger);\n\t}","commit_id":"45a1a3c3591182773557f9544d176f595bd9a9a7","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic String toString() { \n\t\ttry {\n\t\t\tif (isSaved()) {\n\t\t\t\treturn getVersionedName() + \": \" + (isGone() ? \"GONE\" : \"\\nData:\" + data()) + \"\\n\tPublisher: \" +\n\t\t\t\t\t\tgetContentPublisher() + \"\\n\t\tPublisher KeyLocator: \" + getPublisherKeyLocator() + \"\\n\";\n\t\t\t} else if (available()) {\n\t\t\t\treturn getBaseName() + \" (unsaved): \" + data();\n\t\t\t} else {\n\t\t\t\treturn getBaseName() + \" (unsaved, no data)\";\t\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tLog.info(\"Unexpected exception retrieving object information: {0}\", e);\n\t\t\treturn getBaseName() + \": unexpected exception \" + e;\n\t\t} \t\n\t}","id":6900,"modified_method":"@Override\n\tpublic String toString() { \n\t\ttry {\n\t\t\tif (isSaved()) {\n\t\t\t\treturn getVersionedName() + \": \" + (isGone() ? \"GONE\" : \"\\nData:\" + data()) + \"\\n\tPublisher: \" +\n\t\t\t\t\t\tgetContentPublisher() + \"\\n\t\tPublisher KeyLocator: \" + getPublisherKeyLocator() + \"\\n\";\n\t\t\t} else if (available()) {\n\t\t\t\treturn getBaseName() + \" (unsaved): \" + data();\n\t\t\t} else {\n\t\t\t\treturn getBaseName() + \" (unsaved, no data)\";\t\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tif (Log.isLoggable(Log.FAC_IO, Level.INFO))\n\t\t\t\tLog.info(Log.FAC_IO, \"Unexpected exception retrieving object information: {0}\", e);\n\t\t\treturn getBaseName() + \": unexpected exception \" + e;\n\t\t} \t\n\t}","commit_id":"474dd724ad9642070a72f81312710879ffb26e10","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Update this object in the background -- asynchronously. \n\t * To use, create an object using a write constructor, setting the data field\n\t * to null. Then call updateInBackground() to retrieve the object's data asynchronously.\n\t * To wait for an update to arrive, call wait() on this object itself.\n\t * @param latestVersionKnown the name of the latest version we know of, or an unversioned\n\t *    name if no version known\n\t * @param continuousUpdates If true, updates the\n\t * object continuously to the latest version available, a single time if it is false.\n\t * @throws IOException \n\t */\n\tpublic synchronized void updateInBackground(ContentName latestVersionKnown, boolean continuousUpdates, UpdateListener listener) throws IOException {\n\n\t\tLog.info(\"updateInBackground: getting latest version after {0} in background.\", latestVersionKnown);\n\t\tcancelInterest();\n\t\tif (null != listener) {\n\t\t\taddListener(listener);\n\t\t}\n\t\t_continuousUpdates = continuousUpdates;\n\t\t_currentInterest = VersioningProfile.firstBlockLatestVersionInterest(latestVersionKnown, null);\n\t\tLog.info(\"updateInBackground: initial interest: {0}\", _currentInterest);\n\t\t_handle.expressInterest(_currentInterest, this);\n\t}","id":6901,"modified_method":"/**\n\t * Update this object in the background -- asynchronously. \n\t * To use, create an object using a write constructor, setting the data field\n\t * to null. Then call updateInBackground() to retrieve the object's data asynchronously.\n\t * To wait for an update to arrive, call wait() on this object itself.\n\t * @param latestVersionKnown the name of the latest version we know of, or an unversioned\n\t *    name if no version known\n\t * @param continuousUpdates If true, updates the\n\t * object continuously to the latest version available, a single time if it is false.\n\t * @throws IOException \n\t */\n\tpublic synchronized void updateInBackground(ContentName latestVersionKnown, boolean continuousUpdates, UpdateListener listener) throws IOException {\n\t\tif (Log.isLoggable(Log.FAC_IO, Level.INFO))\n\t\t\tLog.info(Log.FAC_IO, \"updateInBackground: getting latest version after {0} in background.\", latestVersionKnown);\n\t\tcancelInterest();\n\t\tif (null != listener) {\n\t\t\taddListener(listener);\n\t\t}\n\t\t_continuousUpdates = continuousUpdates;\n\t\t_currentInterest = VersioningProfile.firstBlockLatestVersionInterest(latestVersionKnown, null);\n\t\tif (Log.isLoggable(Log.FAC_IO, Level.INFO))\n\t\t\tLog.info(Log.FAC_IO, \"updateInBackground: initial interest: {0}\", _currentInterest);\n\t\t_handle.expressInterest(_currentInterest, this);\n\t}","commit_id":"474dd724ad9642070a72f81312710879ffb26e10","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Updates the object from a CCNInputStream or one of its subclasses. Used predominantly\n\t * by internal methods, most clients should use update() or update(long). Exposed for\n\t * special-purpose use and experimentation.\n\t * @param inputStream Stream to read object from.\n\t * @return true if an update found, false if not.\n\t * @throws ContentDecodingException if there is a problem decoding the object.\n\t * @throws IOException if there is an error setting up network backing store.\n\t */\n\tpublic synchronized boolean update(CCNInputStream inputStream) throws ContentDecodingException, IOException {\n\t\t\n\t\t// Allow subclasses to modify input stream processing prior to first read.\n\t\tsetInputStreamProperties(inputStream);\n\t\t\n\t\tTuple<ContentName, byte []> nameAndVersion = null;\n\t\ttry {\n\t\t\tif (inputStream.isGone()) {\n\t\t\t\tif (Log.isLoggable(Level.FINE))\n\t\t\t\t\tLog.fine(\"Reading from GONE stream: {0}\", inputStream.getBaseName());\n\t\t\t\t_data = null;\n\n\t\t\t\t// This will have a final version and a segment\n\t\t\t\tnameAndVersion = VersioningProfile.cutTerminalVersion(inputStream.deletionInformation().name());\n\t\t\t\t_currentPublisher = inputStream.deletionInformation().signedInfo().getPublisherKeyID();\n\t\t\t\t_currentPublisherKeyLocator = inputStream.deletionInformation().signedInfo().getKeyLocator();\n\t\t\t\t_available = true;\n\t\t\t\t_isGone = true;\n\t\t\t\t_isDirty = false;\n\t\t\t\t_lastSaved = digestContent();\t\n\t\t\t} else {\n\t\t\t\tsuper.update(inputStream);\n\n\t\t\t\tnameAndVersion = VersioningProfile.cutTerminalVersion(inputStream.getBaseName());\n\t\t\t\t_currentPublisher = inputStream.publisher();\n\t\t\t\t_currentPublisherKeyLocator = inputStream.publisherKeyLocator();\n\t\t\t\t_isGone = false;\n\t\t\t}\n\t\t\t_firstSegment = inputStream.getFirstSegment();  // preserve first segment\n\t\t} catch (NoMatchingContentFoundException nme) {\n\t\t\tif (Log.isLoggable(Level.INFO))\n\t\t\t\tLog.info(\"NoMatchingContentFoundException in update from input stream {0}, timed out before data was available.\", inputStream.getBaseName());\n\t\t\tnameAndVersion = VersioningProfile.cutTerminalVersion(inputStream.getBaseName());\n\t\t\t_baseName = nameAndVersion.first();\n\n\t\t\t// used to fire off an updateInBackground here, to hopefully get a second\n\t\t\t// chance on scooping up the content. But that seemed likely to confuse\n\t\t\t// people and leave the object in an undetermined state. So allow caller\n\t\t\t// to manage that themselves.\n\t\t\t\t\n\t\t\t// not an error state, merely a not ready state.\n\t\t\treturn false;\n\t\t} catch (LinkCycleException lce) {\n\t\t\tif (Log.isLoggable(Level.INFO))\n\t\t\t\tLog.info(\"Link cycle exception: {0}\", lce.getMessage());\n\t\t\tsetError(lce);\n\t\t\tthrow lce;\n\t\t}\n\n\t\t_baseName = nameAndVersion.first();\n\t\t_currentVersionComponent = nameAndVersion.second();\n\t\t_currentVersionName = null; // cached if used\n\t\t_dereferencedLink = inputStream.getDereferencedLink(); // gets stack of links used, if any\n\t\tclearError();\n\n\t\t// Signal readers.\n\t\tnewVersionAvailable(false);\n\t\treturn true;\n\t}","id":6902,"modified_method":"/**\n\t * Updates the object from a CCNInputStream or one of its subclasses. Used predominantly\n\t * by internal methods, most clients should use update() or update(long). Exposed for\n\t * special-purpose use and experimentation.\n\t * @param inputStream Stream to read object from.\n\t * @return true if an update found, false if not.\n\t * @throws ContentDecodingException if there is a problem decoding the object.\n\t * @throws IOException if there is an error setting up network backing store.\n\t */\n\tpublic synchronized boolean update(CCNInputStream inputStream) throws ContentDecodingException, IOException {\n\t\t\n\t\t// Allow subclasses to modify input stream processing prior to first read.\n\t\tsetInputStreamProperties(inputStream);\n\t\t\n\t\tTuple<ContentName, byte []> nameAndVersion = null;\n\t\ttry {\n\t\t\tif (inputStream.isGone()) {\n\t\t\t\tif (Log.isLoggable(Log.FAC_IO, Level.FINE))\n\t\t\t\t\tLog.fine(Log.FAC_IO, \"Reading from GONE stream: {0}\", inputStream.getBaseName());\n\t\t\t\t_data = null;\n\n\t\t\t\t// This will have a final version and a segment\n\t\t\t\tnameAndVersion = VersioningProfile.cutTerminalVersion(inputStream.deletionInformation().name());\n\t\t\t\t_currentPublisher = inputStream.deletionInformation().signedInfo().getPublisherKeyID();\n\t\t\t\t_currentPublisherKeyLocator = inputStream.deletionInformation().signedInfo().getKeyLocator();\n\t\t\t\t_available = true;\n\t\t\t\t_isGone = true;\n\t\t\t\t_isDirty = false;\n\t\t\t\t_lastSaved = digestContent();\t\n\t\t\t} else {\n\t\t\t\tsuper.update(inputStream);\n\n\t\t\t\tnameAndVersion = VersioningProfile.cutTerminalVersion(inputStream.getBaseName());\n\t\t\t\t_currentPublisher = inputStream.publisher();\n\t\t\t\t_currentPublisherKeyLocator = inputStream.publisherKeyLocator();\n\t\t\t\t_isGone = false;\n\t\t\t}\n\t\t\t_firstSegment = inputStream.getFirstSegment();  // preserve first segment\n\t\t} catch (NoMatchingContentFoundException nme) {\n\t\t\tif (Log.isLoggable(Log.FAC_IO, Level.INFO))\n\t\t\t\tLog.info(Log.FAC_IO, \"NoMatchingContentFoundException in update from input stream {0}, timed out before data was available.\", inputStream.getBaseName());\n\t\t\tnameAndVersion = VersioningProfile.cutTerminalVersion(inputStream.getBaseName());\n\t\t\t_baseName = nameAndVersion.first();\n\n\t\t\t// used to fire off an updateInBackground here, to hopefully get a second\n\t\t\t// chance on scooping up the content. But that seemed likely to confuse\n\t\t\t// people and leave the object in an undetermined state. So allow caller\n\t\t\t// to manage that themselves.\n\t\t\t\t\n\t\t\t// not an error state, merely a not ready state.\n\t\t\treturn false;\n\t\t} catch (LinkCycleException lce) {\n\t\t\tif (Log.isLoggable(Log.FAC_IO, Level.INFO))\n\t\t\t\tLog.info(Log.FAC_IO, \"Link cycle exception: {0}\", lce.getMessage());\n\t\t\tsetError(lce);\n\t\t\tthrow lce;\n\t\t}\n\n\t\t_baseName = nameAndVersion.first();\n\t\t_currentVersionComponent = nameAndVersion.second();\n\t\t_currentVersionName = null; // cached if used\n\t\t_dereferencedLink = inputStream.getDereferencedLink(); // gets stack of links used, if any\n\t\tclearError();\n\n\t\t// Signal readers.\n\t\tnewVersionAvailable(false);\n\t\treturn true;\n\t}","commit_id":"474dd724ad9642070a72f81312710879ffb26e10","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Save content to specific version. Internal form that performs actual save.\n\t * @param version If version is non-null, assume that is the desired\n\t * version. If not, set version based on current time.\n\t * @param gone Are we saving this content as gone or not.\n\t * @return return Returns true if it saved data, false if it thought data was not dirty and didn't\n\t * \t\tsave. \n\t * TODO allow freshness specification\n\t * @throws ContentEncodingException if there is an error encoding the content\n\t * @throws IOException if there is an error reading the content from the network\n\t */\n\tprotected synchronized boolean saveInternal(CCNTime version, boolean gone, Interest outstandingInterest) \n\t\t\t\tthrows ContentEncodingException, IOException {\n\n\t\tif (null == _baseName) {\n\t\t\tthrow new IllegalStateException(\"Cannot save an object without giving it a name!\");\n\t\t}\n\n\t\t// move object to this name\n\t\t// need to make sure we get back the actual name we're using,\n\t\t// even if output stream does automatic versioning\n\t\t// probably need to refactor save behavior -- right now, internalWriteObject\n\t\t// either writes the object or not; we need to only make a new name if we do\n\t\t// write the object, and figure out if that's happened. Also need to make\n\t\t// parent behavior just write, put the dirty check higher in the state.\n\n\t\tif (!gone && !isDirty()) { \n\t\t\tLog.info(\"Object not dirty. Not saving.\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!gone && (null == _data)) {\n\t\t\t// skip some of the prep steps that have side effects rather than getting this exception later from superclass\n\t\t\tthrow new InvalidObjectException(\"No data to save!\");\n\t\t}\n\n\t\t// Create the flow controller, if we haven't already.\n\t\tcreateFlowController();\n\t\t\n\t\t// This is the point at which we care if we don't have a flow controller\n\t\tif (null == _flowControl) {\n\t\t\tthrow new IOException(\"Cannot create flow controller! Specified save type is \" + _saveType + \"!\");\n\t\t}\n\n\t\t// Handle versioning ourselves to make name handling easier. VOS should respect it.\n\t\t// We might have been handed a _baseName that was versioned. For most general behavior,\n\t\t// have to treat it as a normal name and that we are supposed to put our own version\n\t\t// underneath it. To save as a specific version, need to use save(version).\n\t\tContentName name = _baseName;\n\t\tif (null != version) {\n\t\t\tname = VersioningProfile.addVersion(_baseName, version);\n\t\t} else {\n\t\t\tname = VersioningProfile.addVersion(_baseName);\n\t\t}\n\t\t// DKS if we add the versioned name, we don't handle get latest version.\n\t\t// We re-add the baseName here in case an update has changed it.\n\t\t// TODO -- perhaps disallow updates for unrelated names.\n\t\t_flowControl.addNameSpace(_baseName);\n\n\t\tif (!gone) {\n\t\t\t// CCNVersionedOutputStream will version an unversioned name. \n\t\t\t// If it gets a versioned name, will respect it. \n\t\t\t// This will call startWrite on the flow controller.\n\t\t\tCCNVersionedOutputStream cos = new CCNVersionedOutputStream(name, _keyLocator, _publisher, contentType(), _keys, _flowControl);\n\t\t\tcos.setFreshnessSeconds(_freshnessSeconds);\n\t\t\tif (null != outstandingInterest) {\n\t\t\t\tcos.addOutstandingInterest(outstandingInterest);\n\t\t\t}\n\t\t\tsave(cos); // superclass stream save. calls flush but not close on a wrapping\n\t\t\t// digest stream; want to make sure we end up with a single non-MHT signed\n\t\t\t// segment and no header on small objects\n\t\t\tcos.close();\n\t\t\t// Grab digest and segment number after close because for short objects there may not be \n\t\t\t// a segment generated until the close\n\t\t\t_firstSegment = cos.getFirstSegment();\n\t\t} else {\n\t\t\t// saving object as gone, currently this is always one empty segment so we don't use an OutputStream\n\t\t\tContentName segmentedName = SegmentationProfile.segmentName(name, SegmentationProfile.BASE_SEGMENT );\n\t\t\tbyte [] empty = new byte[0];\n\t\t\tbyte [] finalBlockID = SegmentationProfile.getSegmentNumberNameComponent(SegmentationProfile.BASE_SEGMENT);\n\t\t\tContentObject goneObject = \n\t\t\t\tContentObject.buildContentObject(segmentedName, ContentType.GONE, empty, _publisher, _keyLocator, null, finalBlockID);\n\n\t\t\t// The segmenter in the stream does an addNameSpace of the versioned name. Right now\n\t\t\t// this not only adds the prefix (ignored) but triggers the repo start write.\n\t\t\t_flowControl.addNameSpace(name);\n\t\t\t_flowControl.startWrite(name, Shape.STREAM); // Streams take care of this for the non-gone case.\n\t\t\t_flowControl.put(goneObject);\n\t\t\t_firstSegment = goneObject;\n\t\t\t_flowControl.beforeClose();\n\t\t\t_flowControl.afterClose();\n\t\t\t_lastSaved = GONE_OUTPUT;\n\t\t}\n\t\t_currentPublisher = _firstSegment.signedInfo().getPublisherKeyID(); \n\t\t_currentPublisherKeyLocator = _firstSegment.signedInfo().getKeyLocator();\n\t\t_currentVersionComponent = name.lastComponent();\n\t\t_currentVersionName = name;\n\t\tsetDirty(false);\n\t\t_available = true;\n\n\t\tnewVersionAvailable(true);\n\t\tLog.finest(\"Saved object {0} publisher {1} key locator {2}\", name, _currentPublisher, _currentPublisherKeyLocator);\n\t\treturn true;\n\t}","id":6903,"modified_method":"/**\n\t * Save content to specific version. Internal form that performs actual save.\n\t * @param version If version is non-null, assume that is the desired\n\t * version. If not, set version based on current time.\n\t * @param gone Are we saving this content as gone or not.\n\t * @return return Returns true if it saved data, false if it thought data was not dirty and didn't\n\t * \t\tsave. \n\t * TODO allow freshness specification\n\t * @throws ContentEncodingException if there is an error encoding the content\n\t * @throws IOException if there is an error reading the content from the network\n\t */\n\tprotected synchronized boolean saveInternal(CCNTime version, boolean gone, Interest outstandingInterest) \n\t\t\t\tthrows ContentEncodingException, IOException {\n\n\t\tif (null == _baseName) {\n\t\t\tthrow new IllegalStateException(\"Cannot save an object without giving it a name!\");\n\t\t}\n\n\t\t// move object to this name\n\t\t// need to make sure we get back the actual name we're using,\n\t\t// even if output stream does automatic versioning\n\t\t// probably need to refactor save behavior -- right now, internalWriteObject\n\t\t// either writes the object or not; we need to only make a new name if we do\n\t\t// write the object, and figure out if that's happened. Also need to make\n\t\t// parent behavior just write, put the dirty check higher in the state.\n\n\t\tif (!gone && !isDirty()) {\n\t\t\tif (Log.isLoggable(Log.FAC_IO, Level.INFO))\n\t\t\t\tLog.info(Log.FAC_IO, \"Object not dirty. Not saving.\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!gone && (null == _data)) {\n\t\t\t// skip some of the prep steps that have side effects rather than getting this exception later from superclass\n\t\t\tthrow new InvalidObjectException(\"No data to save!\");\n\t\t}\n\n\t\t// Create the flow controller, if we haven't already.\n\t\tcreateFlowController();\n\t\t\n\t\t// This is the point at which we care if we don't have a flow controller\n\t\tif (null == _flowControl) {\n\t\t\tthrow new IOException(\"Cannot create flow controller! Specified save type is \" + _saveType + \"!\");\n\t\t}\n\n\t\t// Handle versioning ourselves to make name handling easier. VOS should respect it.\n\t\t// We might have been handed a _baseName that was versioned. For most general behavior,\n\t\t// have to treat it as a normal name and that we are supposed to put our own version\n\t\t// underneath it. To save as a specific version, need to use save(version).\n\t\tContentName name = _baseName;\n\t\tif (null != version) {\n\t\t\tname = VersioningProfile.addVersion(_baseName, version);\n\t\t} else {\n\t\t\tname = VersioningProfile.addVersion(_baseName);\n\t\t}\n\t\t// DKS if we add the versioned name, we don't handle get latest version.\n\t\t// We re-add the baseName here in case an update has changed it.\n\t\t// TODO -- perhaps disallow updates for unrelated names.\n\t\t_flowControl.addNameSpace(_baseName);\n\n\t\tif (!gone) {\n\t\t\t// CCNVersionedOutputStream will version an unversioned name. \n\t\t\t// If it gets a versioned name, will respect it. \n\t\t\t// This will call startWrite on the flow controller.\n\t\t\tCCNVersionedOutputStream cos = new CCNVersionedOutputStream(name, _keyLocator, _publisher, contentType(), _keys, _flowControl);\n\t\t\tcos.setFreshnessSeconds(_freshnessSeconds);\n\t\t\tif (null != outstandingInterest) {\n\t\t\t\tcos.addOutstandingInterest(outstandingInterest);\n\t\t\t}\n\t\t\tsave(cos); // superclass stream save. calls flush but not close on a wrapping\n\t\t\t// digest stream; want to make sure we end up with a single non-MHT signed\n\t\t\t// segment and no header on small objects\n\t\t\tcos.close();\n\t\t\t// Grab digest and segment number after close because for short objects there may not be \n\t\t\t// a segment generated until the close\n\t\t\t_firstSegment = cos.getFirstSegment();\n\t\t} else {\n\t\t\t// saving object as gone, currently this is always one empty segment so we don't use an OutputStream\n\t\t\tContentName segmentedName = SegmentationProfile.segmentName(name, SegmentationProfile.BASE_SEGMENT );\n\t\t\tbyte [] empty = new byte[0];\n\t\t\tbyte [] finalBlockID = SegmentationProfile.getSegmentNumberNameComponent(SegmentationProfile.BASE_SEGMENT);\n\t\t\tContentObject goneObject = \n\t\t\t\tContentObject.buildContentObject(segmentedName, ContentType.GONE, empty, _publisher, _keyLocator, null, finalBlockID);\n\n\t\t\t// The segmenter in the stream does an addNameSpace of the versioned name. Right now\n\t\t\t// this not only adds the prefix (ignored) but triggers the repo start write.\n\t\t\t_flowControl.addNameSpace(name);\n\t\t\t_flowControl.startWrite(name, Shape.STREAM); // Streams take care of this for the non-gone case.\n\t\t\t_flowControl.put(goneObject);\n\t\t\t_firstSegment = goneObject;\n\t\t\t_flowControl.beforeClose();\n\t\t\t_flowControl.afterClose();\n\t\t\t_lastSaved = GONE_OUTPUT;\n\t\t}\n\t\t_currentPublisher = _firstSegment.signedInfo().getPublisherKeyID(); \n\t\t_currentPublisherKeyLocator = _firstSegment.signedInfo().getKeyLocator();\n\t\t_currentVersionComponent = name.lastComponent();\n\t\t_currentVersionName = name;\n\t\tsetDirty(false);\n\t\t_available = true;\n\n\t\tnewVersionAvailable(true);\n\t\tif (Log.isLoggable(Log.FAC_IO, Level.FINEST))\n\t\t\tLog.finest(Log.FAC_IO, \"Saved object {0} publisher {1} key locator {2}\", name, _currentPublisher, _currentPublisherKeyLocator);\n\t\treturn true;\n\t}","commit_id":"474dd724ad9642070a72f81312710879ffb26e10","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Used to signal waiters and listeners that a new version is available.\n\t * @param wasSave is a new version available because we were saved, or because\n\t *   we found a new version on the network?\n\t */\n\tprotected void newVersionAvailable(boolean wasSave) {\n\t\tif (Log.isLoggable(Level.FINER)) {\n\t\t\tLog.finer(\"newVersionAvailable: New version of object available: {0}\", getVersionedName());\n\t\t}\n\t\t// by default signal all waiters\n\t\tthis.notifyAll();\n\t\t\n\t\t// and any registered listeners\n\t\tif (null != _updateListeners) {\n\t\t\tfor (UpdateListener listener : _updateListeners) {\n\t\t\t\tlistener.newVersionAvailable(this, wasSave);\n\t\t\t}\n\t\t}\n\t}","id":6904,"modified_method":"/**\n\t * Used to signal waiters and listeners that a new version is available.\n\t * @param wasSave is a new version available because we were saved, or because\n\t *   we found a new version on the network?\n\t */\n\tprotected void newVersionAvailable(boolean wasSave) {\n\t\tif (Log.isLoggable(Log.FAC_IO, Level.FINER)) {\n\t\t\tLog.finer(Log.FAC_IO, \"newVersionAvailable: New version of object available: {0}\", getVersionedName());\n\t\t}\n\t\t// by default signal all waiters\n\t\tthis.notifyAll();\n\t\t\n\t\t// and any registered listeners\n\t\tif (null != _updateListeners) {\n\t\t\tfor (UpdateListener listener : _updateListeners) {\n\t\t\t\tlistener.newVersionAvailable(this, wasSave);\n\t\t\t}\n\t\t}\n\t}","commit_id":"474dd724ad9642070a72f81312710879ffb26e10","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Add a LinkObject to the stack we had to dereference to get here.\n\t */\n\tpublic synchronized void pushDereferencedLink(LinkObject dereferencedLink) {\n\t\tif (null == dereferencedLink) {\n\t\t\treturn;\n\t\t}\n\t\tif (null != _dereferencedLink) {\n\t\t\tif (null != dereferencedLink.getDereferencedLink()) {\n\t\t\t\tif (Log.isLoggable(Level.WARNING)) {\n\t\t\t\t\tLog.warning(\"Merging two link stacks -- {0} already has a dereferenced link from {1}. Behavior unpredictable.\",\n\t\t\t\t\t\t\tdereferencedLink.getVersionedName(), dereferencedLink.getDereferencedLink().getVersionedName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tdereferencedLink.pushDereferencedLink(_dereferencedLink);\n\t\t}\n\t\tsetDereferencedLink(dereferencedLink);\n\t}","id":6905,"modified_method":"/**\n\t * Add a LinkObject to the stack we had to dereference to get here.\n\t */\n\tpublic synchronized void pushDereferencedLink(LinkObject dereferencedLink) {\n\t\tif (null == dereferencedLink) {\n\t\t\treturn;\n\t\t}\n\t\tif (null != _dereferencedLink) {\n\t\t\tif (null != dereferencedLink.getDereferencedLink()) {\n\t\t\t\tif (Log.isLoggable(Log.FAC_IO, Level.WARNING)) {\n\t\t\t\t\tLog.warning(Log.FAC_IO, \"Merging two link stacks -- {0} already has a dereferenced link from {1}. Behavior unpredictable.\",\n\t\t\t\t\t\t\tdereferencedLink.getVersionedName(), dereferencedLink.getDereferencedLink().getVersionedName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tdereferencedLink.pushDereferencedLink(_dereferencedLink);\n\t\t}\n\t\tsetDereferencedLink(dereferencedLink);\n\t}","commit_id":"474dd724ad9642070a72f81312710879ffb26e10","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Load data into object. If name is versioned, load that version. If\n\t * name is not versioned, look for latest version. \n\t * @param name Name of object to read.\n\t * @param publisher Desired publisher, or null for any.\n\t * @throws ContentDecodingException if there is a problem decoding the object.\n\t * @throws IOException if there is an error setting up network backing store.\n\t */\n\tpublic boolean update(ContentName name, PublisherPublicKeyDigest publisher) throws ContentDecodingException, IOException {\n\t\tLog.info(\"Updating object to {0}.\", name);\n\t\tCCNVersionedInputStream is = new CCNVersionedInputStream(name, publisher, _handle);\n\t\treturn update(is);\n\t}","id":6906,"modified_method":"/**\n\t * Load data into object. If name is versioned, load that version. If\n\t * name is not versioned, look for latest version. \n\t * @param name Name of object to read.\n\t * @param publisher Desired publisher, or null for any.\n\t * @throws ContentDecodingException if there is a problem decoding the object.\n\t * @throws IOException if there is an error setting up network backing store.\n\t */\n\tpublic boolean update(ContentName name, PublisherPublicKeyDigest publisher) throws ContentDecodingException, IOException {\n\t\tif (Log.isLoggable(Log.FAC_IO, Level.INFO))\n\t\t\tLog.info(Log.FAC_IO, \"Updating object to {0}.\", name);\n\t\tCCNVersionedInputStream is = new CCNVersionedInputStream(name, publisher, _handle);\n\t\treturn update(is);\n\t}","commit_id":"474dd724ad9642070a72f81312710879ffb26e10","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * If the object has been saved or read from the network, returns the (cached) versioned\n\t * name. Otherwise returns the base name.\n\t * @return\n\t */\n\tpublic synchronized ContentName getVersionedName()  {\n\t\ttry {\n\t\t\tif (isSaved()) {\n\t\t\t\tif ((null == _currentVersionName) && (null != _currentVersionComponent)) // cache; only read lock necessary\n\t\t\t\t\t_currentVersionName =  new ContentName(_baseName, _currentVersionComponent);\n\t\t\t\treturn _currentVersionName;\n\t\t\t}\n\t\t\treturn getBaseName();\n\t\t} catch (IOException e) {\n\t\t\tif (Log.isLoggable(Level.WARNING))\n\t\t\t\tLog.warning(\"Invalid state for object {0}, cannot get current version name: {1}\", getBaseName(), e);\n\t\t\treturn getBaseName();\n\t\t}\n\t}","id":6907,"modified_method":"/**\n\t * If the object has been saved or read from the network, returns the (cached) versioned\n\t * name. Otherwise returns the base name.\n\t * @return\n\t */\n\tpublic synchronized ContentName getVersionedName()  {\n\t\ttry {\n\t\t\tif (isSaved()) {\n\t\t\t\tif ((null == _currentVersionName) && (null != _currentVersionComponent)) // cache; only read lock necessary\n\t\t\t\t\t_currentVersionName =  new ContentName(_baseName, _currentVersionComponent);\n\t\t\t\treturn _currentVersionName;\n\t\t\t}\n\t\t\treturn getBaseName();\n\t\t} catch (IOException e) {\n\t\t\tif (Log.isLoggable(Log.FAC_IO, Level.WARNING))\n\t\t\t\tLog.warning(Log.FAC_IO, \"Invalid state for object {0}, cannot get current version name: {1}\", getBaseName(), e);\n\t\t\treturn getBaseName();\n\t\t}\n\t}","commit_id":"474dd724ad9642070a72f81312710879ffb26e10","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public synchronized Interest handleContent(ContentObject co, Interest interest) {\n\t\ttry {\n\t\t\tboolean hasNewVersion = false;\n\t\t\tbyte [][] excludes = null;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tif (Log.isLoggable(Level.INFO))\n\t\t\t\t\tLog.info(\"updateInBackground: handleContent: \" + _currentInterest + \" retrieved \" + co.name());\n\t\t\t\tif (VersioningProfile.startsWithLaterVersionOf(co.name(), _currentInterest.name())) {\n\t\t\t\t\t// OK, we have something that is a later version of our desired object.\n\t\t\t\t\t// We're not sure it's actually the first content segment.\n\t\t\t\t\thasNewVersion = true;\n\t\t\t\t\t\n\t\t\t\t\tif (VersioningProfile.isVersionedFirstSegment(_currentInterest.name(), co, null)) {\n\t\t\t\t\t\tif (Log.isLoggable(Level.INFO))\n\t\t\t\t\t\t\tLog.info(\"updateInBackground: Background updating of {0}, got first segment: {1}\", getVersionedName(), co.name());\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Streams assume caller has verified. So we verify here. \n\t\t\t\t\t\t// TODO add support for settable verifiers\n\t\t\t\t\t\tif (!_verifier.verify(co)) {\n\t\t\t\t\t\t\tif (Log.isLoggable(Log.FAC_SIGNING, Level.WARNING)) {\n\t\t\t\t\t\t\t\tLog.warning(Log.FAC_SIGNING, \"CCNNetworkObject: content object received from background update did not verify! Ignoring object: {0}\", co.fullName());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thasNewVersion = false;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// TODO -- exclude this one by digest, otherwise we're going \n\t\t\t\t\t\t\t// to get it back! For now, just copy the top-level part of GLV\n\t\t\t\t\t\t\t// behavior and exclude this version component. This isn't the right\n\t\t\t\t\t\t\t// answer, malicious objects can exclude new versions. But it's not clear\n\t\t\t\t\t\t\t// if the right answer is to do full gLV here and let that machinery\n\t\t\t\t\t\t\t// handle things, pulling potentially multiple objects in a callback,\n\t\t\t\t\t\t\t// or we just have to wait for issue #100011, and the ability to selectively\n\t\t\t\t\t\t\t// exclude content digests.\n\t\t\t\t\t\t\texcludes = new byte [][]{co.name().component(_currentInterest.name().count())};\n\t\t\t\t\t\t\tif (Log.isLoggable(Level.INFO))\n\t\t\t\t\t\t\t\tLog.info(\"updateInBackground: handleContent: got content for {0} that doesn't verify ({1}), excluding bogus version {2} as temporary workaround FIX WHEN POSSIBLE\", \n\t\t\t\t\t\t\t\t\t\t_currentInterest.name(), co.fullName(), ContentName.componentPrintURI(excludes[0]));\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tupdate(co);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Have something that is not the first segment, like a repo write or a later segment. Go back\n\t\t\t\t\t\t// for first segment.\n\t\t\t\t\t\tContentName latestVersionName = co.name().cut(_currentInterest.name().count() + 1);\n\t\t\t\t\t\tLog.info(\"updateInBackground: handleContent (network object): Have version information, now querying first segment of {0}\", latestVersionName);\n\t\t\t\t\t\t// This should verify the first segment when we get it.\n\t\t\t\t\t\tupdate(latestVersionName, co.signedInfo().getPublisherKeyID());\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\texcludes = new byte [][]{co.name().component(_currentInterest.name().count() - 1)};\n\t\t\t\t\tif (Log.isLoggable(Level.INFO))\n\t\t\t\t\t\tLog.info(\"updateInBackground: handleContent: got content for {0} that doesn't match: {1}\", _currentInterest.name(), co.name());\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} catch (IOException ex) {\n\t\t\t\tif (Log.isLoggable(Level.INFO))\n\t\t\t\t\tLog.info(\"updateInBackground: Exception {0}: {1}  attempting to update based on object : {2}\", ex.getClass().getName(), ex.getMessage(), co.name());\n\t\t\t\t// alright, that one didn't work, try to go on.    \t\t\t\t\n\t\t\t} \n\n\t\t\tif (hasNewVersion) {\n\t\t\t\tif (_continuousUpdates) {\n\t\t\t\t\tif (Log.isLoggable(Level.INFO)) \n\t\t\t\t\t\tLog.info(\"updateInBackground: handleContent: got a new version, continuous updates, calling updateInBackground recursively then returning null.\");\n\t\t\t\t\tupdateInBackground(true);\n\t\t\t\t} else {\n\t\t\t\t\tif (Log.isLoggable(Level.INFO)) \n\t\t\t\t\t\tLog.info(\"updateInBackground: handleContent: got a new version, not continuous updates, returning null.\");\n\t\t\t\t\t_continuousUpdates = false;\n\t\t\t\t}\n\t\t\t\t// the updates above call newVersionAvailable\n\t\t\t\treturn null; // implicit cancel of interest\n\t\t\t} else {\n\t\t\t\tif (null != excludes) {\n\t\t\t\t\t_currentInterest.exclude().add(excludes);\n\t\t\t\t}\n\t\t\t\tif (Log.isLoggable(Level.INFO)) \n\t\t\t\t\tLog.info(\"updateInBackground: handleContent: no new version, returning new interest for expression: {0}\", _currentInterest);\n\t\t\t\treturn _currentInterest;\n\t\t\t} \n\t\t} catch (IOException ex) {\n\t\t\tif (Log.isLoggable(Level.INFO))\n\t\t\t\tLog.info(\"updateInBackground: handleContent: Exception {0}: {1}  attempting to request further updates : {2}\", ex.getClass().getName(), ex.getMessage(), _currentInterest);\n\t\t\treturn null;\n\t\t}\n\t}","id":6908,"modified_method":"public synchronized Interest handleContent(ContentObject co, Interest interest) {\n\t\ttry {\n\t\t\tboolean hasNewVersion = false;\n\t\t\tbyte [][] excludes = null;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tif (Log.isLoggable(Log.FAC_IO, Level.INFO))\n\t\t\t\t\tLog.info(Log.FAC_IO, \"updateInBackground: handleContent: \" + _currentInterest + \" retrieved \" + co.name());\n\t\t\t\tif (VersioningProfile.startsWithLaterVersionOf(co.name(), _currentInterest.name())) {\n\t\t\t\t\t// OK, we have something that is a later version of our desired object.\n\t\t\t\t\t// We're not sure it's actually the first content segment.\n\t\t\t\t\thasNewVersion = true;\n\t\t\t\t\t\n\t\t\t\t\tif (VersioningProfile.isVersionedFirstSegment(_currentInterest.name(), co, null)) {\n\t\t\t\t\t\tif (Log.isLoggable(Log.FAC_IO, Level.INFO))\n\t\t\t\t\t\t\tLog.info(Log.FAC_IO, \"updateInBackground: Background updating of {0}, got first segment: {1}\", getVersionedName(), co.name());\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Streams assume caller has verified. So we verify here. \n\t\t\t\t\t\t// TODO add support for settable verifiers\n\t\t\t\t\t\tif (!_verifier.verify(co)) {\n\t\t\t\t\t\t\tif (Log.isLoggable(Log.FAC_SIGNING, Level.WARNING)) {\n\t\t\t\t\t\t\t\tLog.warning(Log.FAC_SIGNING, \"CCNNetworkObject: content object received from background update did not verify! Ignoring object: {0}\", co.fullName());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thasNewVersion = false;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// TODO -- exclude this one by digest, otherwise we're going \n\t\t\t\t\t\t\t// to get it back! For now, just copy the top-level part of GLV\n\t\t\t\t\t\t\t// behavior and exclude this version component. This isn't the right\n\t\t\t\t\t\t\t// answer, malicious objects can exclude new versions. But it's not clear\n\t\t\t\t\t\t\t// if the right answer is to do full gLV here and let that machinery\n\t\t\t\t\t\t\t// handle things, pulling potentially multiple objects in a callback,\n\t\t\t\t\t\t\t// or we just have to wait for issue #100011, and the ability to selectively\n\t\t\t\t\t\t\t// exclude content digests.\n\t\t\t\t\t\t\texcludes = new byte [][]{co.name().component(_currentInterest.name().count())};\n\t\t\t\t\t\t\tif (Log.isLoggable(Log.FAC_IO, Level.INFO))\n\t\t\t\t\t\t\t\tLog.info(Log.FAC_IO, \"updateInBackground: handleContent: got content for {0} that doesn't verify ({1}), excluding bogus version {2} as temporary workaround FIX WHEN POSSIBLE\", \n\t\t\t\t\t\t\t\t\t\t_currentInterest.name(), co.fullName(), ContentName.componentPrintURI(excludes[0]));\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tupdate(co);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Have something that is not the first segment, like a repo write or a later segment. Go back\n\t\t\t\t\t\t// for first segment.\n\t\t\t\t\t\tContentName latestVersionName = co.name().cut(_currentInterest.name().count() + 1);\n\t\t\t\t\t\tif (Log.isLoggable(Log.FAC_IO, Level.INFO))\n\t\t\t\t\t\t\tLog.info(Log.FAC_IO, \"updateInBackground: handleContent (network object): Have version information, now querying first segment of {0}\", latestVersionName);\n\t\t\t\t\t\t// This should verify the first segment when we get it.\n\t\t\t\t\t\tupdate(latestVersionName, co.signedInfo().getPublisherKeyID());\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\texcludes = new byte [][]{co.name().component(_currentInterest.name().count() - 1)};\n\t\t\t\t\tif (Log.isLoggable(Log.FAC_IO, Level.INFO))\n\t\t\t\t\t\tLog.info(Log.FAC_IO, \"updateInBackground: handleContent: got content for {0} that doesn't match: {1}\", _currentInterest.name(), co.name());\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} catch (IOException ex) {\n\t\t\t\tif (Log.isLoggable(Log.FAC_IO, Level.INFO))\n\t\t\t\t\tLog.info(Log.FAC_IO, \"updateInBackground: Exception {0}: {1}  attempting to update based on object : {2}\", ex.getClass().getName(), ex.getMessage(), co.name());\n\t\t\t\t// alright, that one didn't work, try to go on.    \t\t\t\t\n\t\t\t} \n\n\t\t\tif (hasNewVersion) {\n\t\t\t\tif (_continuousUpdates) {\n\t\t\t\t\tif (Log.isLoggable(Log.FAC_IO, Level.INFO)) \n\t\t\t\t\t\tLog.info(Log.FAC_IO, \"updateInBackground: handleContent: got a new version, continuous updates, calling updateInBackground recursively then returning null.\");\n\t\t\t\t\tupdateInBackground(true);\n\t\t\t\t} else {\n\t\t\t\t\tif (Log.isLoggable(Log.FAC_IO, Level.INFO)) \n\t\t\t\t\t\tLog.info(Log.FAC_IO, \"updateInBackground: handleContent: got a new version, not continuous updates, returning null.\");\n\t\t\t\t\t_continuousUpdates = false;\n\t\t\t\t}\n\t\t\t\t// the updates above call newVersionAvailable\n\t\t\t\treturn null; // implicit cancel of interest\n\t\t\t} else {\n\t\t\t\tif (null != excludes) {\n\t\t\t\t\t_currentInterest.exclude().add(excludes);\n\t\t\t\t}\n\t\t\t\tif (Log.isLoggable(Log.FAC_IO, Level.INFO)) \n\t\t\t\t\tLog.info(Log.FAC_IO, \"updateInBackground: handleContent: no new version, returning new interest for expression: {0}\", _currentInterest);\n\t\t\t\treturn _currentInterest;\n\t\t\t} \n\t\t} catch (IOException ex) {\n\t\t\tif (Log.isLoggable(Log.FAC_IO, Level.INFO))\n\t\t\t\tLog.info(Log.FAC_IO, \"updateInBackground: handleContent: Exception {0}: {1}  attempting to request further updates : {2}\", ex.getClass().getName(), ex.getMessage(), _currentInterest);\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"474dd724ad9642070a72f81312710879ffb26e10","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"private boolean internalMatch(ContentName name, boolean digestIncluded,\r\n\t\t\tPublisherPublicKeyDigest resultPublisherKeyID) {\r\n\t\tif (null != maxSuffixComponents() || null != minSuffixComponents()) {\r\n\t\t\t// we know our specified name is a prefix of the result. \r\n\t\t\t// the number of additional components must be this value\r\n\t\t\tint nameCount = name.count();\r\n\t\t\tint lengthDiff = nameCount + (digestIncluded?0:1) - name().count();\r\n\n\t\t\tif (null != maxSuffixComponents() && lengthDiff > maxSuffixComponents()) {\r\n\t\t\t\t//Log.fine(\"Interest match failed: \" + lengthDiff + \" more than the \" + maxSuffixComponents() + \" components between expected \" +\r\n\t\t\t\t//\t\tname() + \" and tested \" + name);\n\t\t\t\tif(Log.isLoggable(Level.FINE))\r\n\t\t\t\t\tLog.fine(\"Interest match failed: {0} more than the {1} components between expected {2} and tested {3}\",lengthDiff, maxSuffixComponents(), name(), name);\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tif (null != minSuffixComponents() && lengthDiff < minSuffixComponents()) {\r\n\t\t\t\t//Log.fine(\"Interest match failed: \" + lengthDiff + \" less than the \" + minSuffixComponents() + \" components between expected \" +\r\n\t\t\t\t//\t\tname() + \" and tested \" + name);\n\t\t\t\tif(Log.isLoggable(Level.FINE))\n\t\t\t\t\tLog.fine(\"Interest match failed: {0} less than the {1} components between expected {2} and tested {3}\",lengthDiff, minSuffixComponents(), name(), name);\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (null != exclude()) {\n\t\t\tif (exclude().match(name.component(name().count()))) {\r\n\t\t\t\tLog.finest(\"Interest match failed. {0} has been excluded\", name);\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (null != publisherID()) {\r\n\t\t\tif (null == resultPublisherKeyID) {\r\n\t\t\t\tLog.finest(\"Interest match failed, target {0} doesn't specify a publisherID and we require a particular one.\", name);\r\n\t\t\t\treturn false; \r\n\t\t\t}\r\n\t\t\t// Should this be more general?\n\t\t\t// TODO DKS handle issuer\r\n\t\t\tLog.finest(\"Interest match handed off to trust manager for name: {0}\", name);\r\n\t\t\treturn TrustManager.getTrustManager().matchesRole(publisherID(), resultPublisherKeyID);\r\n\t\t} \r\n\t\tLog.finest(\"Interest match succeeded to name: {0}\", name);\r\n\t\treturn true;\r\n\t}","id":6909,"modified_method":"private boolean internalMatch(ContentName name, boolean digestIncluded,\r\n\t\t\tPublisherPublicKeyDigest resultPublisherKeyID) {\r\n\t\tif (null != maxSuffixComponents() || null != minSuffixComponents()) {\r\n\t\t\t// we know our specified name is a prefix of the result. \r\n\t\t\t// the number of additional components must be this value\r\n\t\t\tint nameCount = name.count();\r\n\t\t\tint lengthDiff = nameCount + (digestIncluded?0:1) - name().count();\r\n\n\t\t\tif (null != maxSuffixComponents() && lengthDiff > maxSuffixComponents()) {\r\n\t\t\t\t//Log.fine(\"Interest match failed: \" + lengthDiff + \" more than the \" + maxSuffixComponents() + \" components between expected \" +\r\n\t\t\t\t//\t\tname() + \" and tested \" + name);\n\t\t\t\tif(Log.isLoggable(Log.FAC_ENCODING, Level.FINE))\r\n\t\t\t\t\tLog.fine(Log.FAC_ENCODING, \"Interest match failed: {0} more than the {1} components between expected {2} and tested {3}\",lengthDiff, maxSuffixComponents(), name(), name);\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tif (null != minSuffixComponents() && lengthDiff < minSuffixComponents()) {\r\n\t\t\t\t//Log.fine(\"Interest match failed: \" + lengthDiff + \" less than the \" + minSuffixComponents() + \" components between expected \" +\r\n\t\t\t\t//\t\tname() + \" and tested \" + name);\n\t\t\t\tif(Log.isLoggable(Log.FAC_ENCODING, Level.FINE))\n\t\t\t\t\tLog.fine(Log.FAC_ENCODING, \"Interest match failed: {0} less than the {1} components between expected {2} and tested {3}\",lengthDiff, minSuffixComponents(), name(), name);\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (null != exclude()) {\n\t\t\tif (exclude().match(name.component(name().count()))) {\n\t\t\t\tif (Log.isLoggable(Log.FAC_ENCODING, Level.FINEST))\r\n\t\t\t\tLog.finest(Log.FAC_ENCODING, \"Interest match failed. {0} has been excluded\", name);\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (null != publisherID()) {\r\n\t\t\tif (null == resultPublisherKeyID) {\n\t\t\t\tif (Log.isLoggable(Log.FAC_ENCODING, Level.FINEST))\r\n\t\t\t\t\tLog.finest(Log.FAC_ENCODING, \"Interest match failed, target {0} doesn't specify a publisherID and we require a particular one.\", name);\r\n\t\t\t\treturn false; \r\n\t\t\t}\r\n\t\t\t// Should this be more general?\n\t\t\t// TODO DKS handle issuer\n\t\t\tif (Log.isLoggable(Log.FAC_ENCODING, Level.FINEST))\r\n\t\t\tLog.finest(Log.FAC_ENCODING, \"Interest match handed off to trust manager for name: {0}\", name);\r\n\t\t\treturn TrustManager.getTrustManager().matchesRole(publisherID(), resultPublisherKeyID);\r\n\t\t}\n\t\tif (Log.isLoggable(Log.FAC_ENCODING, Level.FINEST))\r\n\t\t\tLog.finest(Log.FAC_ENCODING, \"Interest match succeeded to name: {0}\", name);\r\n\t\treturn true;\r\n\t}","commit_id":"d8ff39f34e11ec521bcb1293276dbb45778c9c7a","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\r\n\t * Thought about encoding and decoding as flat -- no wrapping\r\n\t * declaration. But then couldn't use these solo.\r\n\t */\r\n\tpublic void decode(XMLDecoder decoder) throws ContentDecodingException {\r\n\t\tdecoder.readStartElement(getElementLabel());\r\n\r\n\t\t_name = new ContentName();\r\n\t\t_name.decode(decoder);\r\n\t\t\r\n\t\tif (decoder.peekStartElement(CCNProtocolDTags.MinSuffixComponents)) {\r\n\t\t\t_minSuffixComponents = decoder.readIntegerElement(CCNProtocolDTags.MinSuffixComponents);\r\n\t\t}\r\n\t\t\r\n\t\tif (decoder.peekStartElement(CCNProtocolDTags.MaxSuffixComponents)) {\r\n\t\t\t_maxSuffixComponents = decoder.readIntegerElement(CCNProtocolDTags.MaxSuffixComponents);\r\n\t\t}\r\n\t\t\t\t\r\n\t\tif (PublisherID.peek(decoder)) {\r\n\t\t\t_publisher = new PublisherID();\r\n\t\t\t_publisher.decode(decoder);\r\n\t\t}\r\n\r\n\t\tif (decoder.peekStartElement(CCNProtocolDTags.Exclude)) {\r\n\t\t\t_exclude = new Exclude();\r\n\t\t\t_exclude.decode(decoder);\r\n\t\t}\r\n\t\t\r\n\t\tif (decoder.peekStartElement(CCNProtocolDTags.ChildSelector)) {\r\n\t\t\t_childSelector = decoder.readIntegerElement(CCNProtocolDTags.ChildSelector);\r\n\t\t}\r\n\t\t\r\n\t\tif (decoder.peekStartElement(CCNProtocolDTags.AnswerOriginKind)) {\n\t\t\t// call setter to handle defaulting\r\n\t\t\t_answerOriginKind = decoder.readIntegerElement(CCNProtocolDTags.AnswerOriginKind);\r\n\t\t}\r\n\t\t\r\n\t\tif (decoder.peekStartElement(CCNProtocolDTags.Scope)) {\r\n\t\t\t_scope = decoder.readIntegerElement(CCNProtocolDTags.Scope);\r\n\t\t}\r\n\t\t\r\n\t\tif (decoder.peekStartElement(CCNProtocolDTags.Nonce)) {\r\n\t\t\t_nonce = decoder.readBinaryElement(CCNProtocolDTags.Nonce);\r\n\t\t}\r\n\t\t\r\n\t\ttry {\r\n\t\t\tdecoder.readEndElement();\r\n\t\t} catch (ContentDecodingException e) {\r\n\t\t\tLog.info(\"Catching exception reading Interest end element, and moving on. Waiting for schema updates...\");\r\n\t\t}\r\n\t}","id":6910,"modified_method":"/**\r\n\t * Thought about encoding and decoding as flat -- no wrapping\r\n\t * declaration. But then couldn't use these solo.\r\n\t */\r\n\tpublic void decode(XMLDecoder decoder) throws ContentDecodingException {\r\n\t\tdecoder.readStartElement(getElementLabel());\r\n\r\n\t\t_name = new ContentName();\r\n\t\t_name.decode(decoder);\r\n\t\t\r\n\t\tif (decoder.peekStartElement(CCNProtocolDTags.MinSuffixComponents)) {\r\n\t\t\t_minSuffixComponents = decoder.readIntegerElement(CCNProtocolDTags.MinSuffixComponents);\r\n\t\t}\r\n\t\t\r\n\t\tif (decoder.peekStartElement(CCNProtocolDTags.MaxSuffixComponents)) {\r\n\t\t\t_maxSuffixComponents = decoder.readIntegerElement(CCNProtocolDTags.MaxSuffixComponents);\r\n\t\t}\r\n\t\t\t\t\r\n\t\tif (PublisherID.peek(decoder)) {\r\n\t\t\t_publisher = new PublisherID();\r\n\t\t\t_publisher.decode(decoder);\r\n\t\t}\r\n\r\n\t\tif (decoder.peekStartElement(CCNProtocolDTags.Exclude)) {\r\n\t\t\t_exclude = new Exclude();\r\n\t\t\t_exclude.decode(decoder);\r\n\t\t}\r\n\t\t\r\n\t\tif (decoder.peekStartElement(CCNProtocolDTags.ChildSelector)) {\r\n\t\t\t_childSelector = decoder.readIntegerElement(CCNProtocolDTags.ChildSelector);\r\n\t\t}\r\n\t\t\r\n\t\tif (decoder.peekStartElement(CCNProtocolDTags.AnswerOriginKind)) {\n\t\t\t// call setter to handle defaulting\r\n\t\t\t_answerOriginKind = decoder.readIntegerElement(CCNProtocolDTags.AnswerOriginKind);\r\n\t\t}\r\n\t\t\r\n\t\tif (decoder.peekStartElement(CCNProtocolDTags.Scope)) {\r\n\t\t\t_scope = decoder.readIntegerElement(CCNProtocolDTags.Scope);\r\n\t\t}\r\n\t\t\r\n\t\tif (decoder.peekStartElement(CCNProtocolDTags.Nonce)) {\r\n\t\t\t_nonce = decoder.readBinaryElement(CCNProtocolDTags.Nonce);\r\n\t\t}\r\n\t\t\r\n\t\ttry {\r\n\t\t\tdecoder.readEndElement();\r\n\t\t} catch (ContentDecodingException e) {\n\t\t\tif (Log.isLoggable(Log.FAC_ENCODING, Level.INFO))\r\n\t\t\t\tLog.info(Log.FAC_ENCODING, \"Catching exception reading Interest end element, and moving on. Waiting for schema updates...\");\r\n\t\t}\r\n\t}","commit_id":"d8ff39f34e11ec521bcb1293276dbb45778c9c7a","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Get values of all matching Interests for a ContentObject.\n\t * Any ContentName entries in the table will be \n\t * ignored by this operation and any null values will be ignored.\n\t * \n\t * @param target\ttarget ContentObject\n\t * @return \t\t\tlist of all matching values\n\t */\n\tpublic List<V> getValues(ContentObject target) {\n\t\tif(Log.isLoggable(Level.FINEST))\n\t\t\tLog.finest(\"target: {0}\", target.name());\n\n\t\tList<V> result = new ArrayList<V>();\n\t\tList<Entry<V>> matches = getMatches(target);\n\t\tfor (Entry<V> entry : matches) {\n\t\t\tif (null != entry.value()) {\n\t\t\t\tresult.add(entry.value());\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":6911,"modified_method":"/**\n\t * Get values of all matching Interests for a ContentObject.\n\t * Any ContentName entries in the table will be \n\t * ignored by this operation and any null values will be ignored.\n\t * \n\t * @param target\ttarget ContentObject\n\t * @return \t\t\tlist of all matching values\n\t */\n\tpublic List<V> getValues(ContentObject target) {\n\t\tif(Log.isLoggable(Log.FAC_ENCODING, Level.FINEST))\n\t\t\tLog.finest(Log.FAC_ENCODING, \"target: {0}\", target.name());\n\n\t\tList<V> result = new ArrayList<V>();\n\t\tList<Entry<V>> matches = getMatches(target);\n\t\tfor (Entry<V> entry : matches) {\n\t\t\tif (null != entry.value()) {\n\t\t\t\tresult.add(entry.value());\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","commit_id":"d8ff39f34e11ec521bcb1293276dbb45778c9c7a","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Add a value associated with an interest to the table\n\t * \n\t * @param interest\tthe interest\n\t * @param value\t\tassociated object\n\t */\n\tpublic void add(Interest interest, V value) {\n\t\tif (null == interest) {\n\t\t\tthrow new NullPointerException(\"InterestTable may not contain null Interest\");\n\t\t}\n\t\tif (null == interest.name()) {\n\t\t\tthrow new NullPointerException(\"InterestTable may not contain Interest with null name\");\n\t\t}\n\t\tif (Log.isLoggable(Level.FINEST))\n\t\t\tLog.finest(\"adding interest {0}\", interest);\n\t\tHolder<V> holder = new InterestHolder<V>(interest, value);\n\t\tadd(holder);\n\t}","id":6912,"modified_method":"/**\n\t * Add a value associated with an interest to the table\n\t * \n\t * @param interest\tthe interest\n\t * @param value\t\tassociated object\n\t */\n\tpublic void add(Interest interest, V value) {\n\t\tif (null == interest) {\n\t\t\tthrow new NullPointerException(\"InterestTable may not contain null Interest\");\n\t\t}\n\t\tif (null == interest.name()) {\n\t\t\tthrow new NullPointerException(\"InterestTable may not contain Interest with null name\");\n\t\t}\n\t\tif (Log.isLoggable(Log.FAC_ENCODING, Level.FINEST))\n\t\t\tLog.finest(Log.FAC_ENCODING, \"adding interest {0}\", interest);\n\t\tHolder<V> holder = new InterestHolder<V>(interest, value);\n\t\tadd(holder);\n\t}","commit_id":"d8ff39f34e11ec521bcb1293276dbb45778c9c7a","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Get longest matching Interest for a ContentObject.  This is the same as \n\t * getValue() except that the Entry is returned so the matching item\n\t * may be retrieved and null value may be detected. The Entry returned will have a \n\t * non-null interest because this method matches only Interests in the table.\n\t * \n\t * @param target - desired ContentObject\n\t * @return Entry of longest match if any, null if no match\n\t */\n\tpublic Entry<V> getMatch(ContentObject target) {\n\t\tif(Log.isLoggable(Level.FINEST))\n\t\t\tLog.finest(\"target: {0}\", target.name());\n\t\tEntry<V> match = null;\n\t\tfor (LongestFirstContentName name : _contents.keySet()) {\n\t\t\tEntry<V> found = getMatchByName(name, target);\n\t\t\tif (null != found)\n\t\t\t\tmatch = found;\n\t\t}\n\t\treturn match;\n\t}","id":6913,"modified_method":"/**\n\t * Get longest matching Interest for a ContentObject.  This is the same as \n\t * getValue() except that the Entry is returned so the matching item\n\t * may be retrieved and null value may be detected. The Entry returned will have a \n\t * non-null interest because this method matches only Interests in the table.\n\t * \n\t * @param target - desired ContentObject\n\t * @return Entry of longest match if any, null if no match\n\t */\n\tpublic Entry<V> getMatch(ContentObject target) {\n\t\tif(Log.isLoggable(Log.FAC_ENCODING, Level.FINEST))\n\t\t\tLog.finest(Log.FAC_ENCODING, \"target: {0}\", target.name());\n\t\tEntry<V> match = null;\n\t\tfor (LongestFirstContentName name : _contents.keySet()) {\n\t\t\tEntry<V> found = getMatchByName(name, target);\n\t\t\tif (null != found)\n\t\t\t\tmatch = found;\n\t\t}\n\t\treturn match;\n\t}","commit_id":"d8ff39f34e11ec521bcb1293276dbb45778c9c7a","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Add a value associated with content to the table\n\t * \n\t * @param name\tname of the content\n\t * @param value\tassociated object\n\t */\n\tpublic void add(ContentName name, V value) {\n\t\tif (null == name) {\n\t\t\tthrow new NullPointerException(\"InterestTable may not contain null name\");\n\t\t}\n\t\tif (Log.isLoggable(Level.FINEST))\n\t\t\tLog.finest(\"adding name {0}\", name);\n\t\tHolder<V> holder = new NameHolder<V>(name, value);\n\t\tadd(holder);\n\t}","id":6914,"modified_method":"/**\n\t * Add a value associated with content to the table\n\t * \n\t * @param name\tname of the content\n\t * @param value\tassociated object\n\t */\n\tpublic void add(ContentName name, V value) {\n\t\tif (null == name) {\n\t\t\tthrow new NullPointerException(\"InterestTable may not contain null name\");\n\t\t}\n\t\tif (Log.isLoggable(Log.FAC_ENCODING, Level.FINEST))\n\t\t\tLog.finest(Log.FAC_ENCODING, \"adding name {0}\", name);\n\t\tHolder<V> holder = new NameHolder<V>(name, value);\n\t\tadd(holder);\n\t}","commit_id":"d8ff39f34e11ec521bcb1293276dbb45778c9c7a","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"protected Holder<V> removeMatchByName(ContentName name, ContentObject target) {\n\t\tif(Log.isLoggable(Level.FINEST))\n\t\t\tLog.finest(\"name: {0} target: {1}\", name, target.name());\n\t\tLongestFirstContentName lfcn = new LongestFirstContentName(name);\n\t\tList<Holder<V>> list = _contents.get(lfcn);\n\t\tif (null != list) {\n\t\t\tfor (Iterator<Holder<V>> holdIt = list.iterator(); holdIt.hasNext(); ) {\n\t\t\t\tHolder<V> holder = holdIt.next();\n\t\t\t\tif (null != holder.interest()) {\n\t\t\t\t\tif (holder.interest().matches(target)) {\n\t\t\t\t\t\tholdIt.remove();\n\t\t\t\t\t\tif (list.size() == 0) {\n\t\t\t\t\t\t\tsynchronized (_contents) {\n\t\t\t\t\t\t\t\t_contents.remove(lfcn);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn holder;\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","id":6915,"modified_method":"protected Holder<V> removeMatchByName(ContentName name, ContentObject target) {\n\t\tif(Log.isLoggable(Log.FAC_ENCODING, Level.FINEST))\n\t\t\tLog.finest(Log.FAC_ENCODING, \"name: {0} target: {1}\", name, target.name());\n\t\tLongestFirstContentName lfcn = new LongestFirstContentName(name);\n\t\tList<Holder<V>> list = _contents.get(lfcn);\n\t\tif (null != list) {\n\t\t\tfor (Iterator<Holder<V>> holdIt = list.iterator(); holdIt.hasNext(); ) {\n\t\t\t\tHolder<V> holder = holdIt.next();\n\t\t\t\tif (null != holder.interest()) {\n\t\t\t\t\tif (holder.interest().matches(target)) {\n\t\t\t\t\t\tholdIt.remove();\n\t\t\t\t\t\tif (list.size() == 0) {\n\t\t\t\t\t\t\tsynchronized (_contents) {\n\t\t\t\t\t\t\t\t_contents.remove(lfcn);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn holder;\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","commit_id":"d8ff39f34e11ec521bcb1293276dbb45778c9c7a","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Get values matching a target ContentName\n\t * \n\t * @param target\tthe desired ContentName\n\t * @return \t\t\tlist of values associated with this ContentName\n\t */\n\tpublic List<V> getValues(ContentName target) {\n\t\tif (Log.isLoggable(Level.FINEST))\n\t\t\tLog.finest(\"target: {0}\", target);\n\n\t\tList<V> result = new ArrayList<V>();\n\t\tList<Entry<V>> matches = getMatches(target);\n\t\tfor (Entry<V> entry : matches) {\n\t\t\tif (null != entry.value()) {\n\t\t\t\tresult.add(entry.value());\n\t\t\t} \n\t\t}\n\t\treturn result;\n\t}","id":6916,"modified_method":"/**\n\t * Get values matching a target ContentName\n\t * \n\t * @param target\tthe desired ContentName\n\t * @return \t\t\tlist of values associated with this ContentName\n\t */\n\tpublic List<V> getValues(ContentName target) {\n\t\tif (Log.isLoggable(Log.FAC_ENCODING, Level.FINEST))\n\t\t\tLog.finest(Log.FAC_ENCODING, \"target: {0}\", target);\n\n\t\tList<V> result = new ArrayList<V>();\n\t\tList<Entry<V>> matches = getMatches(target);\n\t\tfor (Entry<V> entry : matches) {\n\t\t\tif (null != entry.value()) {\n\t\t\t\tresult.add(entry.value());\n\t\t\t} \n\t\t}\n\t\treturn result;\n\t}","commit_id":"d8ff39f34e11ec521bcb1293276dbb45778c9c7a","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/** \n\t * Internal: return all the entries having exactly the specified name,\n\t * useful once you have found the matching names to collect entries from them\n\t * \n\t * @param name\n\t * @param target\n\t * @return\n\t */\n\tprotected List<Holder<V>> getAllMatchByName(ContentName name, ContentObject target) {\n\t\tif(Log.isLoggable(Level.FINEST))\n\t\t\tLog.finest(\"name: {0} target: {1}\", name, target.name());\n\t\tList<Holder<V>> matches = new ArrayList<Holder<V>>();\n\t\tList<Holder<V>> list = _contents.get(new LongestFirstContentName(name));\n\t\tif (null != list) {\n\t\t\tfor (Iterator<Holder<V>> holdIt = list.iterator(); holdIt.hasNext(); ) {\n\t\t\t\tHolder<V> holder = holdIt.next();\n\t\t\t\tif (null != holder.interest()) {\n\t\t\t\t\tif (holder.interest().matches(target)) {\n\t\t\t\t\t\tmatches.add(holder);\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t\treturn matches;\n\t}","id":6917,"modified_method":"/** \n\t * Internal: return all the entries having exactly the specified name,\n\t * useful once you have found the matching names to collect entries from them\n\t * \n\t * @param name\n\t * @param target\n\t * @return\n\t */\n\tprotected List<Holder<V>> getAllMatchByName(ContentName name, ContentObject target) {\n\t\tif(Log.isLoggable(Log.FAC_ENCODING, Level.FINEST))\n\t\t\tLog.finest(Log.FAC_ENCODING, \"name: {0} target: {1}\", name, target.name());\n\t\tList<Holder<V>> matches = new ArrayList<Holder<V>>();\n\t\tList<Holder<V>> list = _contents.get(new LongestFirstContentName(name));\n\t\tif (null != list) {\n\t\t\tfor (Iterator<Holder<V>> holdIt = list.iterator(); holdIt.hasNext(); ) {\n\t\t\t\tHolder<V> holder = holdIt.next();\n\t\t\t\tif (null != holder.interest()) {\n\t\t\t\t\tif (holder.interest().matches(target)) {\n\t\t\t\t\t\tmatches.add(holder);\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t\treturn matches;\n\t}","commit_id":"d8ff39f34e11ec521bcb1293276dbb45778c9c7a","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Get value of longest matching Interest for a ContentName, where longest is defined\n\t * as longest ContentName.  If there are multiple matches, first is returned.  \n\t * This will return a mix of ContentName and Interest entries if they exist\n\t * (and match) in the table, i.e. the Interest of an Entry may be null in some cases.\n\t * \n\t * @param target desired ContentName\n\t * @return Entry of longest match if any, null if no match\n\t */\n\tpublic V getValue(ContentName target) {\n\t\tif (Log.isLoggable(Level.FINEST))\n\t\t\tLog.finest(\"target: {0}\", target);\n\n\t\tEntry<V> match = getMatch(target);\n\t\tif (null != match) {\n\t\t\treturn match.value();\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}","id":6918,"modified_method":"/**\n\t * Get value of longest matching Interest for a ContentName, where longest is defined\n\t * as longest ContentName.  If there are multiple matches, first is returned.  \n\t * This will return a mix of ContentName and Interest entries if they exist\n\t * (and match) in the table, i.e. the Interest of an Entry may be null in some cases.\n\t * \n\t * @param target desired ContentName\n\t * @return Entry of longest match if any, null if no match\n\t */\n\tpublic V getValue(ContentName target) {\n\t\tif (Log.isLoggable(Log.FAC_ENCODING, Level.FINEST))\n\t\t\tLog.finest(Log.FAC_ENCODING, \"target: {0}\", target);\n\n\t\tEntry<V> match = getMatch(target);\n\t\tif (null != match) {\n\t\t\treturn match.value();\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"d8ff39f34e11ec521bcb1293276dbb45778c9c7a","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Remove and return the longest matching Interest for a ContentObject, where best is defined\n\t * as longest ContentName.  Any ContentName entries in the table will be \n\t * ignored by this operation, so the Entry returned will have a \n\t * non-null interest.\n\t * \n\t * @param target - desired ContentObject\n\t * @return Entry of longest match if any, null if no match\n\t */\n\tpublic Entry<V> removeMatch(ContentObject target) {\n\t\tEntry<V> match = null;\n\t\tif (null != target) {\n\t\t\tContentName matchName = null;\n\t\t\tif(Log.isLoggable(Level.FINEST))\n\t\t\t\tLog.finest(\"removeMatch: looking for match to target {0} among {1} possibilities.\", target.name(), _contents.keySet().size());\t\t\t\t\n\t\t\tfor (LongestFirstContentName name : _contents.keySet()) {\n\t\t\t\tEntry<V> found = getMatchByName(name, target);\n\t\t\t\tif (null != found) {\n\t\t\t\t\tmatch = found;\n\t\t\t\t\tmatchName = name;\n\t\t\t\t}\n\t\t\t\t// Do not remove here -- need to find best match and avoid disturbing iterator\n\t\t\t}\n\t\t\tif (null != match) {\n\t\t\t\treturn removeMatchByName(matchName, target);\n\t\t\t}\n\t\t}\n\t\treturn match;\n\t}","id":6919,"modified_method":"/**\n\t * Remove and return the longest matching Interest for a ContentObject, where best is defined\n\t * as longest ContentName.  Any ContentName entries in the table will be \n\t * ignored by this operation, so the Entry returned will have a \n\t * non-null interest.\n\t * \n\t * @param target - desired ContentObject\n\t * @return Entry of longest match if any, null if no match\n\t */\n\tpublic Entry<V> removeMatch(ContentObject target) {\n\t\tEntry<V> match = null;\n\t\tif (null != target) {\n\t\t\tContentName matchName = null;\n\t\t\tif(Log.isLoggable(Log.FAC_ENCODING, Level.FINEST))\n\t\t\t\tLog.finest(Log.FAC_ENCODING, \"removeMatch: looking for match to target {0} among {1} possibilities.\", target.name(), _contents.keySet().size());\t\t\t\t\n\t\t\tfor (LongestFirstContentName name : _contents.keySet()) {\n\t\t\t\tEntry<V> found = getMatchByName(name, target);\n\t\t\t\tif (null != found) {\n\t\t\t\t\tmatch = found;\n\t\t\t\t\tmatchName = name;\n\t\t\t\t}\n\t\t\t\t// Do not remove here -- need to find best match and avoid disturbing iterator\n\t\t\t}\n\t\t\tif (null != match) {\n\t\t\t\treturn removeMatchByName(matchName, target);\n\t\t\t}\n\t\t}\n\t\treturn match;\n\t}","commit_id":"d8ff39f34e11ec521bcb1293276dbb45778c9c7a","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Get longest matching Interest.  This method is the same as getValue()\n\t * except that the  Entry is returned so the matching item may be retrieved \n\t * and null value may be detected.\n\t * \n\t * @param target\tdesired ContentName\n\t * @return\t\t\tlongest matching entry or null if none found\n\t */\n\tpublic Entry<V> getMatch(ContentName target) {\n\t\tif (Log.isLoggable(Level.FINEST))\n\t\t\tLog.finest(\"target: {0}\", target);\n\n\t\tEntry<V> match = null;\n\t\tfor (LongestFirstContentName name : _contents.keySet()) {\n\t\t\tif (name.isPrefixOf(target)) {\n\t\t\t\tmatch = _contents.get(name).get(0);\n\t\t\t}\n\t\t}\n\t\treturn match;\n\t}","id":6920,"modified_method":"/**\n\t * Get longest matching Interest.  This method is the same as getValue()\n\t * except that the  Entry is returned so the matching item may be retrieved \n\t * and null value may be detected.\n\t * \n\t * @param target\tdesired ContentName\n\t * @return\t\t\tlongest matching entry or null if none found\n\t */\n\tpublic Entry<V> getMatch(ContentName target) {\n\t\tif (Log.isLoggable(Log.FAC_ENCODING, Level.FINEST))\n\t\t\tLog.finest(Log.FAC_ENCODING, \"target: {0}\", target);\n\n\t\tEntry<V> match = null;\n\t\tfor (LongestFirstContentName name : _contents.keySet()) {\n\t\t\tif (name.isPrefixOf(target)) {\n\t\t\t\tmatch = _contents.get(name).get(0);\n\t\t\t}\n\t\t}\n\t\treturn match;\n\t}","commit_id":"d8ff39f34e11ec521bcb1293276dbb45778c9c7a","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"protected Holder<V> getMatchByName(ContentName name, ContentObject target) {\n\t\tList<Holder<V>> list = _contents.get(new LongestFirstContentName(name));\n\t\tif (Log.isLoggable(Level.FINEST))\n\t\t\tLog.finest(\"name: {0} target: {1} possible matches: {2}\", name, target.name(), ((null == list) ? 0 : list.size()));\n\t\tif (null != list) {\n\t\t\tfor (Iterator<Holder<V>> holdIt = list.iterator(); holdIt.hasNext(); ) {\n\t\t\t\tHolder<V> holder = holdIt.next();\n\t\t\t\tif (null != holder.interest()) {\n\t\t\t\t\tif (holder.interest().matches(target)) {\n\t\t\t\t\t\treturn holder;\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","id":6921,"modified_method":"protected Holder<V> getMatchByName(ContentName name, ContentObject target) {\n\t\tList<Holder<V>> list = _contents.get(new LongestFirstContentName(name));\n\t\tif (Log.isLoggable(Log.FAC_ENCODING, Level.FINEST))\n\t\t\tLog.finest(Log.FAC_ENCODING, \"name: {0} target: {1} possible matches: {2}\", name, target.name(), ((null == list) ? 0 : list.size()));\n\t\tif (null != list) {\n\t\t\tfor (Iterator<Holder<V>> holdIt = list.iterator(); holdIt.hasNext(); ) {\n\t\t\t\tHolder<V> holder = holdIt.next();\n\t\t\t\tif (null != holder.interest()) {\n\t\t\t\t\tif (holder.interest().matches(target)) {\n\t\t\t\t\t\treturn holder;\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","commit_id":"d8ff39f34e11ec521bcb1293276dbb45778c9c7a","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Get all matching Interests for a ContentObject.\n\t * Any ContentName entries in the table will be \n\t * ignored by this operation, so every Entry returned will have a \n\t * non-null interest.  This is the same as getValues() except that \n\t * Entry objects are returned.\n\t * \n\t * @param target - desired ContentObject\n\t * @return List of matches, empty if no match\n\t */\n\tpublic List<Entry<V>> getMatches(ContentObject target) {\n\t\tif(Log.isLoggable(Level.FINEST))\n\t\t\tLog.finest(\"target object name: {0}\", target.name());\n\n\t\tList<Entry<V>> matches = new ArrayList<Entry<V>>();\n\t\tif (null != target) {\n\t\t\tfor (LongestFirstContentName name : _contents.keySet()) {\n\t\t\t\t// Name match - is there an interest match here?\n\t\t\t\tmatches.addAll(getAllMatchByName(name, target));\n\t\t\t}\n\t\t\tCollections.reverse(matches);\n\t\t}\n\t\treturn matches;\n\t}","id":6922,"modified_method":"/**\n\t * Get all matching Interests for a ContentObject.\n\t * Any ContentName entries in the table will be \n\t * ignored by this operation, so every Entry returned will have a \n\t * non-null interest.  This is the same as getValues() except that \n\t * Entry objects are returned.\n\t * \n\t * @param target - desired ContentObject\n\t * @return List of matches, empty if no match\n\t */\n\tpublic List<Entry<V>> getMatches(ContentObject target) {\n\t\tif(Log.isLoggable(Log.FAC_ENCODING, Level.FINEST))\n\t\t\tLog.finest(Log.FAC_ENCODING, \"target object name: {0}\", target.name());\n\n\t\tList<Entry<V>> matches = new ArrayList<Entry<V>>();\n\t\tif (null != target) {\n\t\t\tfor (LongestFirstContentName name : _contents.keySet()) {\n\t\t\t\t// Name match - is there an interest match here?\n\t\t\t\tmatches.addAll(getAllMatchByName(name, target));\n\t\t\t}\n\t\t\tCollections.reverse(matches);\n\t\t}\n\t\treturn matches;\n\t}","commit_id":"d8ff39f34e11ec521bcb1293276dbb45778c9c7a","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Get all matching entries for a ContentName.\n\t * This will return a mix of ContentName and Interest entries if they exist\n\t * (and match) in the table, i.e. the Interest of an Entry may be null in some cases.\n\t * \n\t * @param target desired ContentName\n\t * @return List of matches ordered from longest match to shortest, empty if no match\n\t */\n\tpublic List<Entry<V>> getMatches(ContentName target) {\n\t\tif (Log.isLoggable(Level.FINEST))\n\t\t\tLog.finest(\"target: {0}\", target);\n\n\t\tList<Entry<V>> matches = new ArrayList<Entry<V>>();\n\t\tfor (LongestFirstContentName name : _contents.keySet()) {\n\t\t\tif (name.isPrefixOf(target)) {\n\t\t\t\tmatches.addAll(_contents.get(name));\n\t\t\t}\n\t\t}\n\t\tCollections.reverse(matches);\n\t\treturn matches;\n\t}","id":6923,"modified_method":"/**\n\t * Get all matching entries for a ContentName.\n\t * This will return a mix of ContentName and Interest entries if they exist\n\t * (and match) in the table, i.e. the Interest of an Entry may be null in some cases.\n\t * \n\t * @param target desired ContentName\n\t * @return List of matches ordered from longest match to shortest, empty if no match\n\t */\n\tpublic List<Entry<V>> getMatches(ContentName target) {\n\t\tif (Log.isLoggable(Log.FAC_ENCODING, Level.FINEST))\n\t\t\tLog.finest(Log.FAC_ENCODING, \"target: {0}\", target);\n\n\t\tList<Entry<V>> matches = new ArrayList<Entry<V>>();\n\t\tfor (LongestFirstContentName name : _contents.keySet()) {\n\t\t\tif (name.isPrefixOf(target)) {\n\t\t\t\tmatches.addAll(_contents.get(name));\n\t\t\t}\n\t\t}\n\t\tCollections.reverse(matches);\n\t\treturn matches;\n\t}","commit_id":"d8ff39f34e11ec521bcb1293276dbb45778c9c7a","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"private static void hideActionFromMainMenu(@NotNull final DefaultMutableTreeNode root,\n                                             @NotNull final CustomActionsSchema schema){\n    final TreeNode mainMenu = root.getFirstChild();\n\n    for (int i = 0; i < mainMenu.getChildCount(); i++) {\n      final DefaultMutableTreeNode menuItem = (DefaultMutableTreeNode)mainMenu.getChildAt(i);\n      if (\"File\".equals(getItemId(menuItem))) {\n        final String[] fileItems = {\"ExportToHTML\", \"SaveAll\", \"Export/Import Actions\", \"Synchronize\", \"ChangeFileEncodingAction\",\n          \"Line Separators\", \"ToggleReadOnlyAttribute\"};\n        for (String item : fileItems) {\n          hideAction(schema, root, menuItem, item);\n        }\n      }\n      else if (\"Edit\".equals(getItemId(menuItem))) {\n        final String[] fileItems = {\"CopyAsPlainText\", \"CopyAsReachText\", \"CopyReference\", \"EditorPasteSimple\", \"Macros\", \"EditorToggleCase\",\n          \"TemplateParametersNavigation\", \"EscapeEntities\"};\n        for (String item : fileItems) {\n          hideAction(schema, root, menuItem, item);\n        }\n      }\n      else if (\"View\".equals(getItemId(menuItem))) {\n        final String[] fileItems = {\"QuickDefinition\", \"ExpressionTypeInfo\", \"EditorContextInfo\", \"ShowErrorDescription\",\n          \"RecentChanges\", \"CompareActions\", \"QuickChangeScheme\"};\n        for (String item : fileItems) {\n          hideAction(schema, root, menuItem, item);\n        }\n      }\n      else if (\"Navigate\".equals(getItemId(menuItem))) {\n        final String[] fileItems = {\"GotoCustomRegion\", \"JumpToLastChange\", \"JumpToNextChange\", \"SelectIn\", \"GotoTypeDeclaration\",\n        \"GotoTest\", \"GotoRelated\", \"ShowFilePath\", \"Hierarchy Actions\", \"Goto Error/Bookmark Actions\", \"GoToEditPointGroup\",\n          \"Change Navigation Actions\", \"Method Navigation Actions\"};\n        for (String item : fileItems) {\n          hideAction(schema, root, menuItem, item);\n        }\n      }\n    }\n\n    final String[] menuItems = {\"Tools\", \"VCS\", \"Refactor\", \"Code\", \"Window\", \"Run\"};\n    for (String item : menuItems) {\n      hideAction(schema, root, mainMenu, item);\n    }\n  }","id":6924,"modified_method":"private static void hideActionFromMainMenu(@NotNull final DefaultMutableTreeNode root,\n                                             @NotNull final CustomActionsSchema schema){\n    final TreeNode mainMenu = root.getFirstChild();\n\n    for (int i = 0; i < mainMenu.getChildCount(); i++) {\n      final DefaultMutableTreeNode menuItem = (DefaultMutableTreeNode)mainMenu.getChildAt(i);\n      if (\"File\".equals(getItemId(menuItem))) {\n        final HashSet<String> fileItems = ContainerUtil.newHashSet(\"TemplateProjectProperties\", \"ExportToHTML\", \"SaveAll\",\n                                                                   \"Export/Import Actions\", \"Add to Favorites\", \"Synchronize\",\n                                                                   \"ChangeFileEncodingAction\", \"Line Separators\", \"ToggleReadOnlyAttribute\");\n        hideActions(schema, root, menuItem, fileItems);\n      }\n\n      else if (\"Edit\".equals(getItemId(menuItem))) {\n        final HashSet<String>\n          editItems = ContainerUtil.newHashSet(\"CopyAsPlainText\", \"CopyAsReachText\", \"CopyReference\", \"EditorPasteSimple\", \"Macros\",\n                                               \"EditorToggleCase\", \"EditorJoinLines\", \"FillParagraph\", \"Convert Indents\",\n                                               \"TemplateParametersNavigation\", \"EscapeEntities\");\n        hideActions(schema, root, menuItem, editItems);\n      }\n      else if (\"View\".equals(getItemId(menuItem))) {\n        final HashSet<String>\n          viewItems = ContainerUtil.newHashSet(\"QuickDefinition\", \"ExpressionTypeInfo\", \"EditorContextInfo\", \"ShowErrorDescription\",\n                                               \"RecentChanges\", \"CompareActions\", \"QuickChangeScheme\");\n        hideActions(schema, root, menuItem, viewItems);\n      }\n      else if (\"Navigate\".equals(getItemId(menuItem))) {\n        final HashSet<String>\n          navigateItems = ContainerUtil.newHashSet(\"GotoCustomRegion\", \"JumpToLastChange\", \"JumpToNextChange\", \"SelectIn\", \"GotoTypeDeclaration\",\n                                                   \"GotoTest\", \"GotoRelated\", \"ShowFilePath\", \"Hierarchy Actions\", \"Bookmarks\",\n                                                   \"Goto Error/Bookmark Actions\",\"GoToEditPointGroup\",\"Change Navigation Actions\",\n                                                   \"Method Navigation Actions\");\n        hideActions(schema, root, menuItem, navigateItems);\n      }\n    }\n\n    final HashSet<String> menuItems = ContainerUtil.newHashSet(\"Tools\", \"VCS\", \"Refactor\", \"Code\", \"Window\", \"Run\");\n    hideActions(schema, root, mainMenu, menuItems);\n  }","commit_id":"4a8b5dab42f78d25c85c819eff2d212107f3b567","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void hideAction(@NotNull final CustomActionsSchema schema, @NotNull final DefaultMutableTreeNode root,\n                                 @NotNull final TreeNode actionGroup, @NotNull final String actionId) {\n    for(int i = 0; i < actionGroup.getChildCount(); i++){\n      final DefaultMutableTreeNode child = (DefaultMutableTreeNode)actionGroup.getChildAt(i);\n      final int childCount = child.getChildCount();\n      if (childCount > 0) {\n        hideAction(schema, child, child, actionId);\n      }\n      final String childId = getItemId(child);\n      if (childId != null && childId.equals(actionId)){\n        final TreePath treePath = TreeUtil.getPath(root, child);\n        final ActionUrl url = CustomizationUtil.getActionUrl(treePath, ActionUrl.DELETED);\n        schema.addAction(url);\n      }\n    }\n  }","id":6925,"modified_method":"private static void hideActions(@NotNull CustomActionsSchema schema, @NotNull DefaultMutableTreeNode root,\n                                  @NotNull final TreeNode actionGroup, Set<String> items) {\n    for(int i = 0; i < actionGroup.getChildCount(); i++){\n      final DefaultMutableTreeNode child = (DefaultMutableTreeNode)actionGroup.getChildAt(i);\n      final int childCount = child.getChildCount();\n      final String childId = getItemId(child);\n      if (childId != null && items.contains(childId)){\n        final TreePath treePath = TreeUtil.getPath(root, child);\n        final ActionUrl url = CustomizationUtil.getActionUrl(treePath, ActionUrl.DELETED);\n        schema.addAction(url);\n      }\n      else if (childCount > 0) {\n        hideActions(schema, child, child, items);\n      }\n    }\n  }","commit_id":"4a8b5dab42f78d25c85c819eff2d212107f3b567","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public S3OutputStream(String bucketName, String key, S3Service client) throws IOException {\n    mBucketName = bucketName;\n    mKey = key.substring(6 + mBucketName.length() + 1);\n    mClient = client;\n    mFile = new File(\"/tmp/\" + Math.random() * 100);\n    mLocalOutputStream = new BufferedOutputStream(new FileOutputStream(mFile));\n  }","id":6926,"modified_method":"public S3OutputStream(String bucketName, String key, S3Service client) throws IOException {\n    mBucketName = bucketName;\n    mKey = key;\n    mClient = client;\n    mFile = new File(\"/tmp/\" + Math.random() * 100);\n    mLocalOutputStream = new BufferedOutputStream(new FileOutputStream(mFile));\n  }","commit_id":"e825e582f63b483216c9af1d6a22935bc30002f9","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public boolean delete(String path, boolean recursive) throws IOException {\n    if (!recursive) {\n      return deleteInternal(path);\n    }\n\n    // Get all relevant files\n    String[] pathsToDelete = listInternal(path, true);\n    for (String pathToDelete : pathsToDelete) {\n      // If we fail to deleteInternal one file, stop\n      if (!deleteInternal(path + pathToDelete)) {\n        return false;\n      }\n    }\n    return true;\n  }","id":6927,"modified_method":"@Override\n  public boolean delete(String path, boolean recursive) throws IOException {\n    if (!recursive) {\n      if (isFolder(path) && listInternal(path, false).length != 0) {\n        return false;\n      }\n      return deleteInternal(path);\n    }\n    // Get all relevant files\n    String[] pathsToDelete = listInternal(path, true);\n    for (String pathToDelete : pathsToDelete) {\n      // If we fail to deleteInternal one file, stop\n      if (!deleteInternal(CommonUtils.concatPath(path, pathToDelete))) {\n        return false;\n      }\n    }\n    deleteInternal(path);\n    return true;\n  }","commit_id":"e825e582f63b483216c9af1d6a22935bc30002f9","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a directory flagged file with the key and folder suffix.\n   * @param key\n   * @return\n   */\n  private boolean mkdir(String key) {\n    try {\n      String keyAsFolder =\n          convertToFolderName(key).substring(SCHEME.length() + mBucketName.length() + 1);\n      S3Object obj = new S3Object(keyAsFolder);\n      obj.setDataInputStream(new ByteArrayInputStream(new byte[0]));\n      obj.setContentLength(0);\n      obj.setContentType(Mimetypes.MIMETYPE_BINARY_OCTET_STREAM);\n      mClient.putObject(mBucketName, obj);\n      return true;\n    } catch (ServiceException se) {\n      LOG.error(\"Failed to create directory: \" + key, se);\n      return false;\n    }\n  }","id":6928,"modified_method":"/**\n   * Creates a directory flagged file with the key and folder suffix.\n   * @param key\n   * @return\n   */\n  private boolean mkdir(String key) {\n    try {\n      String keyAsFolder = convertToFolderName(stripPrefix(key));\n      S3Object obj = new S3Object(keyAsFolder);\n      obj.setDataInputStream(new ByteArrayInputStream(new byte[0]));\n      obj.setContentLength(0);\n      obj.setContentType(Mimetypes.MIMETYPE_BINARY_OCTET_STREAM);\n      mClient.putObject(mBucketName, obj);\n      return true;\n    } catch (ServiceException se) {\n      LOG.error(\"Failed to create directory: \" + key, se);\n      return false;\n    }\n  }","commit_id":"e825e582f63b483216c9af1d6a22935bc30002f9","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public boolean isFile(String path) throws IOException {\n    if (exists(path)) {\n      return !isFolder(path);\n    } else {\n      throw new FileNotFoundException(path);\n    }\n  }","id":6929,"modified_method":"@Override\n  public boolean isFile(String path) throws IOException {\n    return exists(path) && !isFolder(path);\n  }","commit_id":"e825e582f63b483216c9af1d6a22935bc30002f9","url":"https://github.com/amplab/tachyon"},{"original_method":"private String[] listInternal(String path, boolean recursive) throws IOException {\n    try {\n      String separator = recursive ? \"\" : PATH_SEPARATOR;\n      path = path.substring(SCHEME.length() + mBucketName.length() + 1);\n      S3Object[] objs = mClient.listObjects(mBucketName, path, separator);\n      String[] ret = new String[objs.length];\n      for (int i = 0; i < objs.length; i ++) {\n        ret[i] = objs[i].getKey().substring(path.length());\n      }\n      return ret;\n    } catch (ServiceException se) {\n      LOG.info(\"Failed to list path \" + path);\n      return null;\n    }\n  }","id":6930,"modified_method":"private String[] listInternal(String path, boolean recursive) throws IOException {\n    try {\n      String separator = recursive ? \"\" : PATH_SEPARATOR;\n      path = stripPrefix(path);\n      path = path.endsWith(PATH_SEPARATOR) ? path : path + PATH_SEPARATOR;\n      S3Object[] objs = mClient.listObjects(mBucketName, path, separator);\n      String[] ret = new String[objs.length];\n      for (int i = 0; i < objs.length; i ++) {\n        String child = objs[i].getKey().substring(path.length());\n        child =\n            child.endsWith(FOLDER_SUFFIX) ? child.substring(0,\n                child.length() - FOLDER_SUFFIX.length()) : child;\n        ret[i] = child;\n      }\n      return ret;\n    } catch (ServiceException se) {\n      LOG.info(\"Failed to list path \" + path);\n      return null;\n    }\n  }","commit_id":"e825e582f63b483216c9af1d6a22935bc30002f9","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public boolean rename(String src, String dst) throws IOException {\n    if (!exists(src)) {\n      return false;\n    }\n    if (exists(dst)) {\n      if (!isFolder(dst)) {\n        LOG.error(\"Unable to rename \" + src + \" to \" + dst + \" because destination already \"\n            + \"exists as a file.\");\n        return false;\n      }\n      String srcName = getKeyName(src);\n      // Destination is a folder, move source into dst\n      if (!isFolder(src)) {\n        // Source is a file\n        // Copy to destination\n        if (copy(src, CommonUtils.concatPath(dst, srcName))) {\n          // Delete original\n          return deleteInternal(src);\n        } else {\n          return false;\n        }\n      }\n      // Source and Destination are folders\n      // Rename the source folder first\n      String dstFolder = CommonUtils.concatPath(dst, convertToFolderName(srcName));\n      if (!copy(convertToFolderName(src), dstFolder)) {\n        return false;\n      }\n      // Rename each child in the src folder to destination/srcfolder/child\n      String [] children = list(src);\n      String parentName = getKeyName(getParentKey(src));\n      for (String childKey : children) {\n        if (!rename(childKey, CommonUtils.concatPath(dst, parentName))) {\n          return false;\n        }\n      }\n      // Delete everything under src\n      return delete(src, true);\n    }\n    // Destination does not exist\n    if (isFolder(src)) {\n      // Rename the source folder first\n      if (!copy(convertToFolderName(src), convertToFolderName(dst))) {\n        return false;\n      }\n      // Rename each child in the src folder to destination/srcfolder/child\n      String [] children = list(src);\n      String parentName = getKeyName(getParentKey(src));\n      for (String childKey: children) {\n        if (!rename(childKey, CommonUtils.concatPath(dst, parentName))) {\n          return false;\n        }\n      }\n      // Delete everything under src\n      return delete(src, true);\n    }\n    // Source is a file and Destination does not exist\n    return copy(src, dst) && deleteInternal(src);\n  }","id":6931,"modified_method":"@Override\n  public boolean rename(String src, String dst) throws IOException {\n    if (!exists(src)) {\n      return false;\n    }\n    if (exists(dst)) {\n      if (!isFolder(dst)) {\n        LOG.error(\"Unable to rename \" + src + \" to \" + dst + \" because destination already \"\n            + \"exists as a file.\");\n        return false;\n      }\n      String srcName = getKeyName(src);\n      // Destination is a folder, move source into dst\n      if (!isFolder(src)) {\n        // Source is a file\n        // Copy to destination\n        if (copy(src, CommonUtils.concatPath(dst, srcName))) {\n          // Delete original\n          return deleteInternal(src);\n        } else {\n          return false;\n        }\n      }\n      // Source and Destination are folders\n      // Rename the source folder first\n      String dstFolder = CommonUtils.concatPath(dst, convertToFolderName(srcName));\n      if (!copy(convertToFolderName(src), dstFolder)) {\n        return false;\n      }\n      // Rename each child in the src folder to destination/srcfolder/child\n      String [] children = list(src);\n      String parentName = getKeyName(src);\n      for (String child : children) {\n        if (!rename(CommonUtils.concatPath(src, child), CommonUtils.concatPath(dst, parentName))) {\n          return false;\n        }\n      }\n      // Delete everything under src\n      return delete(src, true);\n    }\n    // Destination does not exist\n    if (isFolder(src)) {\n      // Rename the source folder first\n      if (!copy(convertToFolderName(src), convertToFolderName(dst))) {\n        return false;\n      }\n      // Rename each child in the src folder to destination/child\n      String [] children = list(src);\n      for (String child: children) {\n        if (!rename(CommonUtils.concatPath(src, child), dst)) {\n          return false;\n        }\n      }\n      // Delete everything under src\n      return delete(src, true);\n    }\n    // Source is a file and Destination does not exist\n    return copy(src, dst) && deleteInternal(src);\n  }","commit_id":"e825e582f63b483216c9af1d6a22935bc30002f9","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Checks if the key is the root.\n   * @param key\n   * @return\n   */\n  private boolean isRoot(String key) {\n    return key.equals(SCHEME + mBucketName);\n  }","id":6932,"modified_method":"/**\n   * Checks if the key is the root.\n   * @param key\n   * @return\n   */\n  private boolean isRoot(String key) {\n    return\n        key.equals(SCHEME + mBucketName) || key.equals(SCHEME + mBucketName + PATH_SEPARATOR);\n  }","commit_id":"e825e582f63b483216c9af1d6a22935bc30002f9","url":"https://github.com/amplab/tachyon"},{"original_method":"private boolean copy(String src, String dst) {\n    try {\n      src = src.substring(SCHEME.length() + mBucketName.length() + 1);\n      dst = dst.substring(SCHEME.length() + mBucketName.length() + 1);\n      LOG.info(\"Copying \" + src + \" to \" + dst);\n      S3Object obj = new S3Object(dst);\n      mClient.copyObject(mBucketName, src, mBucketName, obj, false);\n      return true;\n    } catch (ServiceException se) {\n      LOG.error(\"Failed to rename file \" + src + \" to \" + dst);\n      return false;\n    }\n  }","id":6933,"modified_method":"private boolean copy(String src, String dst) {\n    try {\n      src = stripPrefix(src);\n      dst = stripPrefix(dst);\n      LOG.info(\"Copying \" + src + \" to \" + dst);\n      S3Object obj = new S3Object(dst);\n      mClient.copyObject(mBucketName, src, mBucketName, obj, false);\n      return true;\n    } catch (ServiceException se) {\n      LOG.error(\"Failed to rename file \" + src + \" to \" + dst);\n      return false;\n    }\n  }","commit_id":"e825e582f63b483216c9af1d6a22935bc30002f9","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public boolean mkdirs(String path, boolean createParent) throws IOException {\n    if (isFolder(path)) {\n      return true;\n    }\n    if (exists(path)) {\n      LOG.error(\"Cannot create directory \" + path + \" because it is already a file.\");\n      return false;\n    }\n    if (!createParent) {\n      if (parentExists(path)) {\n        // Parent directory exists\n        return mkdir(path);\n      } else {\n        LOG.error(\"Cannot create directory \" + path + \" because parent does not exist\");\n        return false;\n      }\n    }\n    // Parent directories should be created\n    if (parentExists(path)) {\n      // Parent directory exists\n      return mkdir(path);\n    } else {\n      String parentKey = getParentKey(path);\n      // Recursively make the parent folders\n      return mkdirs(parentKey, true) && mkdir(parentKey);\n    }\n  }","id":6934,"modified_method":"@Override\n  public boolean mkdirs(String path, boolean createParent) throws IOException {\n    if (isFolder(path)) {\n      return true;\n    }\n    if (exists(path)) {\n      LOG.error(\"Cannot create directory \" + path + \" because it is already a file.\");\n      return false;\n    }\n    if (!createParent) {\n      if (parentExists(path)) {\n        // Parent directory exists\n        return mkdir(path);\n      } else {\n        LOG.error(\"Cannot create directory \" + path + \" because parent does not exist\");\n        return false;\n      }\n    }\n    // Parent directories should be created\n    if (parentExists(path)) {\n      // Parent directory exists\n      return mkdir(path);\n    } else {\n      String parentKey = getParentKey(path);\n      // Recursively make the parent folders\n      return mkdirs(parentKey, true) && mkdir(path);\n    }\n  }","commit_id":"e825e582f63b483216c9af1d6a22935bc30002f9","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public InputStream open(String path) throws IOException {\n    try {\n      path = path.substring(SCHEME.length() + mBucketName.length() + 1);\n      return mClient.getObject(mBucketName, path).getDataInputStream();\n    } catch (ServiceException se) {\n      LOG.error(\"Failed to open file: \" + path, se);\n      return null;\n    }\n  }","id":6935,"modified_method":"@Override\n  public InputStream open(String path) throws IOException {\n    try {\n      path = stripPrefix(path);\n      return mClient.getObject(mBucketName, path).getDataInputStream();\n    } catch (ServiceException se) {\n      LOG.error(\"Failed to open file: \" + path, se);\n      return null;\n    }\n  }","commit_id":"e825e582f63b483216c9af1d6a22935bc30002f9","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public OutputStream create(String path) throws IOException {\n    if (mkdirs(getParentKey(path), true)) {\n      return new S3OutputStream(mBucketName, path, mClient);\n    }\n    return null;\n  }","id":6936,"modified_method":"@Override\n  public OutputStream create(String path) throws IOException {\n    if (mkdirs(getParentKey(path), true)) {\n      return new S3OutputStream(mBucketName, stripPrefix(path), mClient);\n    }\n    return null;\n  }","commit_id":"e825e582f63b483216c9af1d6a22935bc30002f9","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Internal function to deleteInternal a key in S3\n   * @param key the key to deleteInternal\n   * @return true if successful, false if an exception is thrown\n   * @throws IOException\n   */\n  private boolean deleteInternal(String key) throws IOException {\n    try {\n      if (isFolder(key)) {\n        String keyAsFolder = convertToFolderName(key).substring(SCHEME.length()\n            + mBucketName.length() + 1);\n        mClient.deleteObject(mBucketName, keyAsFolder);\n      } else {\n        mClient.deleteObject(mBucketName, key.substring(SCHEME.length()\n            + mBucketName.length() + 1));\n      }\n    } catch (ServiceException se) {\n      LOG.error(\"Failed to delete \" + key, se);\n      return false;\n    }\n    return true;\n  }","id":6937,"modified_method":"/**\n   * Internal function to deleteInternal a key in S3\n   * @param key the key to deleteInternal\n   * @return true if successful, false if an exception is thrown\n   * @throws IOException\n   */\n  private boolean deleteInternal(String key) throws IOException {\n    try {\n      if (isFolder(key)) {\n        String keyAsFolder = convertToFolderName(stripPrefix(key));\n        mClient.deleteObject(mBucketName, keyAsFolder);\n      } else {\n        mClient.deleteObject(mBucketName, stripPrefix(key));\n      }\n    } catch (ServiceException se) {\n      LOG.error(\"Failed to delete \" + key, se);\n      return false;\n    }\n    return true;\n  }","commit_id":"e825e582f63b483216c9af1d6a22935bc30002f9","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Gets the StorageObject representing the metadata of a key. If the key does not exist as a\n   * file or folder, null is returned\n   * @param key\n   * @return StorageObject of the key, or null if the key does not exist as a file or folder.\n   */\n  private StorageObject getObjectDetails(String key) {\n    try {\n      if (isFolder(key)) {\n        String keyAsFolder = convertToFolderName(key).substring(SCHEME.length()\n            + mBucketName.length() + 1);\n        return mClient.getObjectDetails(mBucketName, keyAsFolder);\n      } else {\n        return mClient.getObjectDetails(mBucketName, key.substring(SCHEME.length()\n            + mBucketName.length() + 1));\n      }\n    } catch (ServiceException se) {\n      return null;\n    }\n  }","id":6938,"modified_method":"/**\n   * Gets the StorageObject representing the metadata of a key. If the key does not exist as a\n   * file or folder, null is returned\n   * @param key\n   * @return StorageObject of the key, or null if the key does not exist as a file or folder.\n   */\n  private StorageObject getObjectDetails(String key) {\n    try {\n      if (isFolder(key)) {\n        String keyAsFolder = convertToFolderName(stripPrefix(key));\n        return mClient.getObjectDetails(mBucketName, keyAsFolder);\n      } else {\n        return mClient.getObjectDetails(mBucketName, stripPrefix(key));\n      }\n    } catch (ServiceException se) {\n      return null;\n    }\n  }","commit_id":"e825e582f63b483216c9af1d6a22935bc30002f9","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Determines if the key is represents a folder. If false is returned, it is not guaranteed that\n   * the path exists.\n   * @param key\n   * @return S3Object containing metadata\n   * @throws IOException\n   */\n  private boolean isFolder(String key) {\n    key = key.endsWith(PATH_SEPARATOR) ? key.substring(0, key.length() - 1) : key;\n    // Root is always a folder\n    if (isRoot(key)) {\n      return true;\n    }\n    try {\n      String keyAsFolder = convertToFolderName(key).substring(SCHEME.length()\n          + mBucketName.length() + 1);\n      mClient.getObjectDetails(mBucketName, keyAsFolder);\n      // If no exception is thrown, the key exists as a folder\n      return true;\n    } catch (ServiceException se) {\n      return false;\n    }\n  }","id":6939,"modified_method":"/**\n   * Determines if the key is represents a folder. If false is returned, it is not guaranteed that\n   * the path exists.\n   * @param key\n   * @return S3Object containing metadata\n   * @throws IOException\n   */\n  private boolean isFolder(String key) {\n    key = key.endsWith(PATH_SEPARATOR) ? key.substring(0, key.length() - 1) : key;\n    // Root is always a folder\n    if (isRoot(key)) {\n      return true;\n    }\n    try {\n      String keyAsFolder = convertToFolderName(stripPrefix(key));\n      mClient.getObjectDetails(mBucketName, keyAsFolder);\n      // If no exception is thrown, the key exists as a folder\n      return true;\n    } catch (ServiceException se) {\n      return false;\n    }\n  }","commit_id":"e825e582f63b483216c9af1d6a22935bc30002f9","url":"https://github.com/amplab/tachyon"},{"original_method":"public static void main(String[] args) {\n        CLArgsParser optParser = new CLArgsParser(args, OPTIONS);\n        if (optParser.getErrorString() != null) {\n            System.err.println(\"ERROR: \" + optParser.getErrorString());\n            return;\n        }\n        Properties properties = loadProperties();\n        String user = \"admin\";\n        String passwd = null;\n        String uri = properties.getProperty(\"uri\", \"xmldb:exist://localhost:8080/exist/xmlrpc\");\n        List opt = optParser.getArguments();\n        int size = opt.size();\n        CLOption option;\n        for (int i = 0; i < size; i++) {\n            option = (CLOption) opt.get(i);\n            switch (option.getId()) {\n                case HELP_OPT:\n                    System.out.println(\"Usage: java \"\n                            + ServerShutdown.class.getName() + \" [options]\");\n                    System.out.println(CLUtil.describeOptions(OPTIONS)\n                            .toString());\n                    return;\n                case USER_OPT:\n                    user = option.getArgument();\n                    break;\n                case PASSWORD_OPT:\n                    passwd = option.getArgument();\n                    break;\n                case URI_OPT:\n                    uri = option.getArgument();\n            }\n        }\n        try {\n            // initialize database drivers\n            Class cl = Class.forName(\"org.exist.xmldb.DatabaseImpl\");\n            // create the default database\n            Database database = (Database) cl.newInstance();\n            DatabaseManager.registerDatabase(database);\n            if (!uri.endsWith(DBBroker.ROOT_COLLECTION))\n                uri = uri + DBBroker.ROOT_COLLECTION;\n            Collection root = DatabaseManager.getCollection(uri, user, passwd);\n            DatabaseInstanceManager manager = (DatabaseInstanceManager) root\n                    .getService(\"DatabaseInstanceManager\", \"1.0\");\n            System.out.println(\"Shutting down database instance at \");\n            System.out.println('\\t' + uri);\n            manager.shutdown();\n        } catch (XMLDBException e) {\n            System.err.println(\"ERROR: \" + e.getMessage());\n            e.printStackTrace();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }","id":6940,"modified_method":"public static void main(String[] args) {\n        CLArgsParser optParser = new CLArgsParser(args, OPTIONS);\n        if (optParser.getErrorString() != null) {\n            System.err.println(\"ERROR: \" + optParser.getErrorString());\n            return;\n        }\n        Properties properties = loadProperties();\n        String user = \"admin\";\n        String passwd = null;\n        String uri = properties.getProperty(\"uri\", \"xmldb:exist://localhost:8080/exist/xmlrpc\");\n        List opt = optParser.getArguments();\n        int size = opt.size();\n        CLOption option;\n        for (int i = 0; i < size; i++) {\n            option = (CLOption) opt.get(i);\n            switch (option.getId()) {\n                case HELP_OPT:\n                    System.out.println(\"Usage: java \"\n                            + ServerShutdown.class.getName() + \" [options]\");\n                    System.out.println(CLUtil.describeOptions(OPTIONS)\n                            .toString());\n                    return;\n                case USER_OPT:\n                    user = option.getArgument();\n                    break;\n                case PASSWORD_OPT:\n                    passwd = option.getArgument();\n                    break;\n                case URI_OPT:\n                    uri = option.getArgument();\n            }\n        }\n        try {\n            // initialize database drivers\n            Class cl = Class.forName(\"org.exist.xmldb.DatabaseImpl\");\n            // create the default database\n            Database database = (Database) cl.newInstance();\n            DatabaseManager.registerDatabase(database);\n            if (!uri.endsWith(DBBroker.ROOT_COLLECTION))\n                uri = uri + DBBroker.ROOT_COLLECTION;\n            Collection root = DatabaseManager.getCollection(uri, user, passwd);\n            DatabaseInstanceManager manager = (DatabaseInstanceManager) root\n                    .getService(\"DatabaseInstanceManager\", \"1.0\");\n            System.out.println(\"Shutting down database instance at \");\n            System.out.println('\\t' + uri);\n            manager.shutdown();\n\n        } catch (XMLDBException e) {\n            System.err.println(\"ERROR: \" + e.getMessage());\n\n            Throwable t = e.getCause();\n            if(t!=null && t instanceof XmlRpcException){\n                System.err.println(\"CAUSE: \"+t.getMessage());\n            } else {\n                e.printStackTrace();\n            }\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }","commit_id":"a0af0df3781ed5b8048419693c06a84fce1156bd","url":"https://github.com/eXist-db/exist"},{"original_method":"public static void main(String[] args) {\n        CLArgsParser optParser = new CLArgsParser(args, OPTIONS);\n        if (optParser.getErrorString() != null) {\n            System.err.println(\"ERROR: \" + optParser.getErrorString());\n            return;\n        }\n        Properties properties = loadProperties();\n        String user = \"admin\";\n        String passwd = null;\n        String uri = properties.getProperty(\"uri\", \"xmldb:exist://localhost:8080/exist/xmlrpc\");\n        List opt = optParser.getArguments();\n        int size = opt.size();\n        CLOption option;\n        for (int i = 0; i < size; i++) {\n            option = (CLOption) opt.get(i);\n            switch (option.getId()) {\n                case HELP_OPT:\n                    System.out.println(\"Usage: java \"\n                            + ServerShutdown.class.getName() + \" [options]\");\n                    System.out.println(CLUtil.describeOptions(OPTIONS)\n                            .toString());\n                    return;\n                case USER_OPT:\n                    user = option.getArgument();\n                    break;\n                case PASSWORD_OPT:\n                    passwd = option.getArgument();\n                    break;\n                case URI_OPT:\n                    uri = option.getArgument();\n            }\n        }\n        try {\n            // initialize database drivers\n            Class cl = Class.forName(\"org.exist.xmldb.DatabaseImpl\");\n            // create the default database\n            Database database = (Database) cl.newInstance();\n            DatabaseManager.registerDatabase(database);\n            if (!uri.endsWith(DBBroker.ROOT_COLLECTION))\n                uri = uri + DBBroker.ROOT_COLLECTION;\n            Collection root = DatabaseManager.getCollection(uri, user, passwd);\n            DatabaseInstanceManager manager = (DatabaseInstanceManager) root\n                    .getService(\"DatabaseInstanceManager\", \"1.0\");\n            System.out.println(\"Shutting down database instance at \");\n            System.out.println('\\t' + uri);\n            manager.shutdown();\n        } catch (XMLDBException e) {\n            System.err.println(\"ERROR: \" + e.getMessage());\n            e.printStackTrace();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }","id":6941,"modified_method":"public static void main(String[] args) {\n        CLArgsParser optParser = new CLArgsParser(args, OPTIONS);\n        if (optParser.getErrorString() != null) {\n            System.err.println(\"ERROR: \" + optParser.getErrorString());\n            return;\n        }\n        Properties properties = loadProperties();\n        String user = \"admin\";\n        String passwd = null;\n        String uri = properties.getProperty(\"uri\", \"xmldb:exist://localhost:8080/exist/xmlrpc\");\n        List opt = optParser.getArguments();\n        int size = opt.size();\n        CLOption option;\n        for (int i = 0; i < size; i++) {\n            option = (CLOption) opt.get(i);\n            switch (option.getId()) {\n                case HELP_OPT:\n                    System.out.println(\"Usage: java \"\n                            + ServerShutdown.class.getName() + \" [options]\");\n                    System.out.println(CLUtil.describeOptions(OPTIONS)\n                            .toString());\n                    return;\n                case USER_OPT:\n                    user = option.getArgument();\n                    break;\n                case PASSWORD_OPT:\n                    passwd = option.getArgument();\n                    break;\n                case URI_OPT:\n                    uri = option.getArgument();\n            }\n        }\n        try {\n            // initialize database drivers\n            Class cl = Class.forName(\"org.exist.xmldb.DatabaseImpl\");\n            // create the default database\n            Database database = (Database) cl.newInstance();\n            DatabaseManager.registerDatabase(database);\n            if (!uri.endsWith(DBBroker.ROOT_COLLECTION))\n                uri = uri + DBBroker.ROOT_COLLECTION;\n            Collection root = DatabaseManager.getCollection(uri, user, passwd);\n            DatabaseInstanceManager manager = (DatabaseInstanceManager) root\n                    .getService(\"DatabaseInstanceManager\", \"1.0\");\n            System.out.println(\"Shutting down database instance at \");\n            System.out.println('\\t' + uri);\n            manager.shutdown();\n\n        } catch (XMLDBException e) {\n            System.err.println(\"ERROR: \" + e.getMessage());\n\n            Throwable t = e.getCause();\n            if(t!=null && t instanceof XmlRpcException){\n                System.err.println(\"CAUSE: \"+t.getMessage());\n            } else {\n                e.printStackTrace();\n            }\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }","commit_id":"e2e366a87c246673306791cb82f840ebf84851c5","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n\t * @see org.xml.sax.ContentHandler#startElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes)\n\t */\n\tpublic void startElement(String namespaceURI, String localName, String qName, Attributes atts)\n\t\tthrows SAXException {\n\t\tif (namespaceURI.equals(NS)) {\n\t\t\tif (localName.equals(\"collection\")) {\n\t\t\t\tfinal String name = atts.getValue(\"name\");\n\t\t\t\tfinal String owner = atts.getValue(\"owner\");\n\t\t\t\tfinal String group = atts.getValue(\"group\");\n\t\t\t\tfinal String mode = atts.getValue(\"mode\");\n\t\t\t\tfinal String created = atts.getValue(\"created\");\n\n\t\t\t\t\n\t\t\t\tif (name == null)\n\t\t\t\t\tthrow new SAXException(\"collection requires a name \" + \"attribute\");\n\t\t\t\ttry {\n\t\t\t\t\tif(dialog != null)\n\t\t\t\t\t\tdialog.displayMessage(\"creating collection \" + name);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tDate date_created = null;\n\t\t\t\t\t\n\t\t\t\t\tif (created != null)\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tdate_created = (Date)(new DateTimeValue(created)).getDate();\n\t\t\t\t\t\t} catch (XPathException e2) {\n\t\t\t\t\t\t} \n\n\t\t\t\t\t \n\t\t\t\t\t\n\t\t\t\t\tcurrent = mkcol(name, date_created);\n\t\t\t\t\tUserManagementService service =\n\t\t\t\t\t\t(UserManagementService) current.getService(\"UserManagementService\", \"1.0\");\n\t\t\t\t\tUser u = new User(owner, null, group);\n\t\t\t\t\tservice.chown(u, group);\n\t\t\t\t\tservice.chmod(Integer.parseInt(mode, 8));\n\t\t\t\t} catch (XMLDBException e) {\n\t\t\t\t\tthrow new SAXException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t\tif(dialog != null)\n\t\t\t\t\tdialog.setCollection(name);\n\t\t\t} else if (localName.equals(\"subcollection\")) {\n\t\t\t\t\n\t\t\t\t String name = atts.getValue(\"filename\");\n\t\t\t\t\n\t\t\t\tif (name == null) name = atts.getValue(\"name\");\n\n\t\t\t\tfinal String fname =\n\t\t\t\t\tcontents.getParentFile().getAbsolutePath()\n\t\t\t\t\t\t+ File.separatorChar\n\t\t\t\t\t\t+ name\n\t\t\t\t\t\t+ File.separatorChar\n\t\t\t\t\t\t+ \"__contents__.xml\";\n\t\t\t\tfinal File f = new File(fname);\n\t\t\t\tif (f.exists() && f.canRead())\n\t\t\t\t\tstack.push(f);\n\t\t\t\telse\n\t\t\t\t\tSystem.err.println(f.getAbsolutePath() + \" does not exist or is not readable.\");\n\t\t\t} else if (localName.equals(\"resource\")) {\n\n\t\t\t\tString type = atts.getValue(\"type\");\n\t\t\t\tif(type == null)\n\t\t\t\t\ttype =\"XMLResource\";\n\t\t\t\tfinal String name = atts.getValue(\"name\");\n\t\t\t\tfinal String owner = atts.getValue(\"owner\");\n\t\t\t\tfinal String group = atts.getValue(\"group\");\n\t\t\t\tfinal String perms = atts.getValue(\"mode\");\n\t\t\t\t\n\t\t\t\tString filename = atts.getValue(\"filename\");\n\t\t\t\tfinal String mimetype = atts.getValue(\"mimetype\");\n\t\t\t\tfinal String created = atts.getValue(\"created\");\n\t\t\t\tfinal String modified = atts.getValue(\"modified\");\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif (filename == null) filename = name;\n\n\t\t\t\tif (name == null)\n\t\t\t\t\tthrow new SAXException(\"resource requires a name attribute\");\n\t\t\t\tfinal File f =\n\t\t\t\t\tnew File(\n\t\t\t\t\t\tcontents.getParentFile().getAbsolutePath() + File.separatorChar + filename);\n\t\t\t\ttry {\n\t\t\t\t\tif (dialog != null && current instanceof Observable) {\n\t\t\t\t\t\t((Observable) current).addObserver(dialog.getObserver());\n\t\t\t\t\t}\n\t\t\t\t\tif(dialog != null)\n\t\t\t\t\t\tdialog.setResource(name);\n\t\t\t\t\tfinal Resource res =\n\t\t\t\t\t\tcurrent.createResource(name, type);\n\t\t\t\t\tif (mimetype != null)\n\t\t\t\t\t\t((EXistResource)res).setMimeType(mimetype);\n\t\t\t\t\t\n\t\t\t\t\tres.setContent(f);\n\t\t\t\t\tif(dialog == null)\n\t\t\t\t\t\tSystem.out.println(\"restoring \" + name);\n\t\t\t\t\t\n\t\t\t\t\tDate date_created = null;\n\t\t\t\t\tDate date_modified = null;\n\t\t\t\t\t\n\t\t\t\t\tif (created != null)\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tdate_created = (Date)(new DateTimeValue(created)).getDate();\n\t\t\t\t\t\t} catch (XPathException e2) {\n                            e2.printStackTrace();\n\t\t\t\t\t\t} \n\t\t\t\t\t\n\t\t\t\t\tif (modified != null)\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tdate_modified = (Date)(new DateTimeValue(modified)).getDate();\n\t\t\t\t\t\t} catch (XPathException e2) {\n                            e2.printStackTrace();\n\t\t\t\t\t\t} \n\t\t\t\t\t\n\t\t\t\t\tcurrent.storeResource(res, date_created, date_modified);\n\t\t\t\t\tUserManagementService service =\n\t\t\t\t\t\t(UserManagementService) current.getService(\"UserManagementService\", \"1.0\");\n\t\t\t\t\tUser u = new User(owner, null, group);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tservice.chown(res, u, group);\n\t\t\t\t\t} catch (XMLDBException e1) {\n\t\t\t\t\t\tif(dialog != null)\n\t\t\t\t\t\t\tdialog.displayMessage(\"failed to change owner on document \" + name + \"; skipping ...\");\n\t\t\t\t\t}\n\t\t\t\t\tservice.chmod(res, Integer.parseInt(perms, 8));\n\t\t\t\t\tif(dialog != null)\n\t\t\t\t\t\tdialog.displayMessage(\"restored \" + name);\n\t\t\t\t} catch (XMLDBException e) {\n                    e.printStackTrace();\n\t\t\t\t\tthrow new SAXException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":6942,"modified_method":"/**\n\t * @see org.xml.sax.ContentHandler#startElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes)\n\t */\n\tpublic void startElement(String namespaceURI, String localName, String qName, Attributes atts)\n\t\tthrows SAXException {\n\t\tif (namespaceURI.equals(NS)) {\n\t\t\tif (localName.equals(\"collection\")) {\n\t\t\t\tfinal String name = atts.getValue(\"name\");\n\t\t\t\tfinal String owner = atts.getValue(\"owner\");\n\t\t\t\tfinal String group = atts.getValue(\"group\");\n\t\t\t\tfinal String mode = atts.getValue(\"mode\");\n\t\t\t\tfinal String created = atts.getValue(\"created\");\n\n\t\t\t\t\n\t\t\t\tif (name == null)\n\t\t\t\t\tthrow new SAXException(\"collection requires a name \" + \"attribute\");\n\t\t\t\ttry {\n\t\t\t\t\tif(dialog != null)\n\t\t\t\t\t\tdialog.displayMessage(\"creating collection \" + name);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tDate date_created = null;\n\t\t\t\t\t\n\t\t\t\t\tif (created != null)\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tdate_created = (Date)(new DateTimeValue(created)).getDate();\n\t\t\t\t\t\t} catch (XPathException e2) {\n\t\t\t\t\t\t} \n\n\t\t\t\t\t \n\t\t\t\t\t\n\t\t\t\t\tcurrent = mkcol(name, date_created);\n\t\t\t\t\tUserManagementService service =\n\t\t\t\t\t\t(UserManagementService) current.getService(\"UserManagementService\", \"1.0\");\n\t\t\t\t\tUser u = new User(owner, null, group);\n\t\t\t\t\tservice.chown(u, group);\n\t\t\t\t\tservice.chmod(Integer.parseInt(mode, 8));\n\t\t\t\t} catch (Exception e) {\n                    showErrorMessage(\"An unrecoverable error occurred while restoring\\ncollection '\" + name + \"'. \" +\n                            \"Aborting restore!\");\n                    e.printStackTrace();\n\t\t\t\t\tthrow new SAXException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t\tif(dialog != null)\n\t\t\t\t\tdialog.setCollection(name);\n\t\t\t} else if (localName.equals(\"subcollection\")) {\n\t\t\t\t\n\t\t\t\t String name = atts.getValue(\"filename\");\n\t\t\t\t\n\t\t\t\tif (name == null) name = atts.getValue(\"name\");\n\n\t\t\t\tfinal String fname =\n\t\t\t\t\tcontents.getParentFile().getAbsolutePath()\n\t\t\t\t\t\t+ File.separatorChar\n\t\t\t\t\t\t+ name\n\t\t\t\t\t\t+ File.separatorChar\n\t\t\t\t\t\t+ \"__contents__.xml\";\n\t\t\t\tfinal File f = new File(fname);\n\t\t\t\tif (f.exists() && f.canRead())\n\t\t\t\t\tstack.push(f);\n\t\t\t\telse\n\t\t\t\t\tSystem.err.println(f.getAbsolutePath() + \" does not exist or is not readable.\");\n\t\t\t} else if (localName.equals(\"resource\")) {\n\n\t\t\t\tString type = atts.getValue(\"type\");\n\t\t\t\tif(type == null)\n\t\t\t\t\ttype =\"XMLResource\";\n\t\t\t\tfinal String name = atts.getValue(\"name\");\n\t\t\t\tfinal String owner = atts.getValue(\"owner\");\n\t\t\t\tfinal String group = atts.getValue(\"group\");\n\t\t\t\tfinal String perms = atts.getValue(\"mode\");\n\t\t\t\t\n\t\t\t\tString filename = atts.getValue(\"filename\");\n\t\t\t\tfinal String mimetype = atts.getValue(\"mimetype\");\n\t\t\t\tfinal String created = atts.getValue(\"created\");\n\t\t\t\tfinal String modified = atts.getValue(\"modified\");\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif (filename == null) filename = name;\n\n\t\t\t\tif (name == null) {\n                    if (dialog != null)\n                        dialog.displayMessage(\"Wrong entry in backup descriptor: resource requires a name attribute.\");\n                    else\n                        System.err.println(\"Wrong entry in backup descriptor: resource requires a name attribute.\");\n                }\n\t\t\t\tfinal File f =\n\t\t\t\t\tnew File(\n\t\t\t\t\t\tcontents.getParentFile().getAbsolutePath() + File.separatorChar + filename);\n\t\t\t\ttry {\n\t\t\t\t\tif (dialog != null && current instanceof Observable) {\n\t\t\t\t\t\t((Observable) current).addObserver(dialog.getObserver());\n\t\t\t\t\t}\n\t\t\t\t\tif(dialog != null)\n\t\t\t\t\t\tdialog.setResource(name);\n\t\t\t\t\tfinal Resource res =\n\t\t\t\t\t\tcurrent.createResource(name, type);\n\t\t\t\t\tif (mimetype != null)\n\t\t\t\t\t\t((EXistResource)res).setMimeType(mimetype);\n\t\t\t\t\t\n\t\t\t\t\tres.setContent(f);\n\t\t\t\t\tif(dialog == null)\n\t\t\t\t\t\tSystem.out.println(\"Restoring \" + name);\n\t\t\t\t\t\n\t\t\t\t\tDate date_created = null;\n\t\t\t\t\tDate date_modified = null;\n\t\t\t\t\t\n\t\t\t\t\tif (created != null)\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tdate_created = (Date)(new DateTimeValue(created)).getDate();\n\t\t\t\t\t\t} catch (XPathException e2) {\n                            e2.printStackTrace();\n\t\t\t\t\t\t} \n\t\t\t\t\t\n\t\t\t\t\tif (modified != null)\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tdate_modified = (Date)(new DateTimeValue(modified)).getDate();\n\t\t\t\t\t\t} catch (XPathException e2) {\n                            e2.printStackTrace();\n\t\t\t\t\t\t} \n\t\t\t\t\t\n\t\t\t\t\tcurrent.storeResource(res, date_created, date_modified);\n\t\t\t\t\tUserManagementService service =\n\t\t\t\t\t\t(UserManagementService) current.getService(\"UserManagementService\", \"1.0\");\n\t\t\t\t\tUser u = new User(owner, null, group);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tservice.chown(res, u, group);\n\t\t\t\t\t} catch (XMLDBException e1) {\n\t\t\t\t\t\tif(dialog != null) {\n\t\t\t\t\t\t\tdialog.displayMessage(\"Failed to change owner on document '\" + name + \"'; skipping ...\");\n                        }\n\t\t\t\t\t}\n\t\t\t\t\tservice.chmod(res, Integer.parseInt(perms, 8));\n\t\t\t\t\tif(dialog != null)\n\t\t\t\t\t\tdialog.displayMessage(\"restored \" + name);\n\t\t\t\t} catch (Exception e) {\n                    if (dialog != null) { \n                            dialog.displayMessage(\"Failed to restore resource '\" + name + \"'\\nfrom file '\" +\n                                    f.getAbsolutePath() + \"'.\\nReason: \" + e.getMessage());\n                            showErrorMessage(\n                                    \"Failed to restore resource '\" + name + \"' from file: '\" +\n                                    f.getAbsolutePath() + \"'.\\n\\nReason: \" + e.getMessage()\n                            );\n                    } else {\n                        System.err.println(\"Failed to restore resource '\" + name + \"' from file '\" +\n\t\t\t\t\t        f.getAbsolutePath() + \"'\");\n                        e.printStackTrace();\n                    }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"2513c7c2a161438c05ca31304408ac36c5625786","url":"https://github.com/eXist-db/exist"},{"original_method":"public synchronized int getMasterIdForCommittedTransaction( long txId ) throws IOException\n    {\n        if ( txId == 1 )\n        {\n            return MASTER_ID_REPRESENTING_NO_MASTER;\n        }\n        \n        List<LogEntry> logEntryList = extractLogEntryList( txId );\n        for ( LogEntry entry : logEntryList )\n        {\n            if ( entry instanceof LogEntry.Commit )\n            {\n                return ((LogEntry.Commit) entry).getMasterId();\n            }\n        }\n        throw new RuntimeException( \"Unable to find commit entry in for txId[\" + \n                txId + \"]\" );// in log[\" + version + \"]\" );\n    }","id":6943,"modified_method":"public synchronized int getMasterIdForCommittedTransaction( long txId ) throws IOException\n    {\n        if ( txId == 1 )\n        {\n            return MASTER_ID_REPRESENTING_NO_MASTER;\n        }\n        \n        List<LogEntry> logEntryList = extractLogEntryList( txId ).first();\n        for ( LogEntry entry : logEntryList )\n        {\n            if ( entry instanceof LogEntry.Commit )\n            {\n                return ((LogEntry.Commit) entry).getMasterId();\n            }\n        }\n        throw new RuntimeException( \"Unable to find commit entry in for txId[\" + \n                txId + \"]\" );// in log[\" + version + \"]\" );\n    }","commit_id":"fc72340e24eef3a24c30a9ce74eed3761dc34660","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized ReadableByteChannel getPreparedTransaction( int identifier )\n            throws IOException\n    {\n        FileChannel log = (FileChannel) getLogicalLogOrMyself( logVersion, 0 );\n        List<LogEntry> logEntryList = extractPreparedTransactionFromLog( identifier, log );\n        log.close();\n        \n//        return wrapInMemoryLogEntryRepresentation( logEntryList );\n        \n        File txFile = createTempFile( \"temp-write-out\", \"-\" + identifier );\n        writeOutLogEntryList( logEntryList, txFile, false );\n        return new RandomAccessFile( txFile, \"r\" ).getChannel();\n    }","id":6944,"modified_method":"public synchronized ReadableByteChannel getPreparedTransaction( int identifier )\n            throws IOException\n    {\n        FileChannel log = (FileChannel) getLogicalLogOrMyself( logVersion, 0 );\n        List<LogEntry> logEntryList = extractPreparedTransactionFromLog( identifier, log );\n        log.close();\n        \n        return wrapInMemoryLogEntryRepresentation( logEntryList );\n        \n//        File txFile = createTempFile( \"temp-write-out\", \"-\" + identifier );\n//        writeOutLogEntryList( logEntryList, txFile, false );\n//        return new RandomAccessFile( txFile, \"r\" ).getChannel();\n    }","commit_id":"fc72340e24eef3a24c30a9ce74eed3761dc34660","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized ReadableByteChannel getCommittedTransaction( long txId )\n        throws IOException\n    {\n        String name = getExtractedTxFileName( txId );\n        File txFile = new File( name );\n        if ( txFile.exists() )\n        {\n            return new RandomAccessFile( txFile, \"r\" ).getChannel();\n        }\n        \n        List<LogEntry> logEntryList = extractLogEntryList( txId );\n        \n//        return wrapInMemoryLogEntryRepresentation( logEntryList );\n        writeOutLogEntryList( logEntryList, txFile, true );\n        return new RandomAccessFile( txFile, \"r\" ).getChannel();\n    }","id":6945,"modified_method":"public synchronized ReadableByteChannel getCommittedTransaction( long txId )\n        throws IOException\n    {\n        String name = getExtractedTxFileName( txId );\n        File txFile = new File( name );\n        if ( txFile.exists() )\n        {\n            return new RandomAccessFile( txFile, \"r\" ).getChannel();\n        }\n        \n        Pair<List<LogEntry>, Boolean> logEntryList = extractLogEntryList( txId );\n        \n        if ( logEntryList.other() )\n        {\n            // It was apparently hard to find (linear search in log(s)), perhaps\n            // a request from a slave which was way behind (more than the\n            // start-position-cache capacity). So store it cached on disk.\n            writeOutLogEntryList( logEntryList.first(), txFile, true );\n            return new RandomAccessFile( txFile, \"r\" ).getChannel();\n        }\n        else\n        {\n            // It was found easily with a start position from the start-position-cache\n            // so just make an in-memory byte representation of it and send.\n            return wrapInMemoryLogEntryRepresentation( logEntryList.first() );\n        }\n    }","commit_id":"fc72340e24eef3a24c30a9ce74eed3761dc34660","url":"https://github.com/neo4j/neo4j"},{"original_method":"private List<LogEntry> extractLogEntryList( long txId ) throws IOException\n    {\n        String name = getExtractedTxFileName( txId );\n        File txFile = new File( name );\n        List<LogEntry> logEntryList = null;\n        if ( txFile.exists() )\n        {\n            // It was already written out to file?\n            FileChannel channel = new RandomAccessFile( name, \"r\" ).getChannel();\n            logEntryList = extractTransactionFromLog( txId, -1, channel );\n            channel.close();\n            return logEntryList;\n        }\n        Pair<Long, Long> cachedInfo = this.txStartPositionCache.get( txId );\n        if ( cachedInfo != null )\n        {\n            // We have log version and start position cached\n            long version = cachedInfo.first();\n            ReadableByteChannel log = getLogicalLogOrMyself( version, cachedInfo.other() );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        else\n        {\n            // We have to look backwards in log files\n            long version = findLogContainingTxId( txId )[0];\n            if ( version == -1 )\n            {\n                throw new RuntimeException( \"txId:\" + txId + \" not found in any logical log \"\n                                            + \"(starting at \" + logVersion\n                                            + \" and searching backwards\" );\n            }\n\n            ReadableByteChannel log = getLogicalLogOrMyself( version, 0 );\n            long[] header = readAndAssertLogHeader( buffer, log, version );\n            long prevTxId = header[1];\n            assertLogCanContainTx( txId, prevTxId );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        return logEntryList;\n    }","id":6946,"modified_method":"private Pair<List<LogEntry>, Boolean> extractLogEntryList( long txId ) throws IOException\n    {\n        String name = getExtractedTxFileName( txId );\n        File txFile = new File( name );\n        List<LogEntry> logEntryList = null;\n        if ( txFile.exists() )\n        {\n            // It was already written out to file?\n            FileChannel channel = new RandomAccessFile( name, \"r\" ).getChannel();\n            logEntryList = extractTransactionFromLog( txId, -1, channel );\n            channel.close();\n            return new Pair<List<LogEntry>, Boolean>( logEntryList, false );\n        }\n        Pair<Long, Long> cachedInfo = this.txStartPositionCache.get( txId );\n        boolean foundInCache = false;\n        if ( cachedInfo != null )\n        {\n            // We have log version and start position cached\n            long version = cachedInfo.first();\n            ReadableByteChannel log = getLogicalLogOrMyself( version, cachedInfo.other() );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n            foundInCache = true;\n        }\n        else\n        {\n            // We have to look backwards in log files\n            long version = findLogContainingTxId( txId )[0];\n            if ( version == -1 )\n            {\n                throw new RuntimeException( \"txId:\" + txId + \" not found in any logical log \"\n                                            + \"(starting at \" + logVersion\n                                            + \" and searching backwards\" );\n            }\n\n            ReadableByteChannel log = getLogicalLogOrMyself( version, 0 );\n            long[] header = readAndAssertLogHeader( buffer, log, version );\n            long prevTxId = header[1];\n            assertLogCanContainTx( txId, prevTxId );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        return new Pair<List<LogEntry>, Boolean>( logEntryList, !foundInCache );\n    }","commit_id":"fc72340e24eef3a24c30a9ce74eed3761dc34660","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized int getMasterIdForCommittedTransaction( long txId ) throws IOException\n    {\n        if ( txId == 1 )\n        {\n            return MASTER_ID_REPRESENTING_NO_MASTER;\n        }\n        \n        List<LogEntry> logEntryList = extractLogEntryList( txId );\n        for ( LogEntry entry : logEntryList )\n        {\n            if ( entry instanceof LogEntry.Commit )\n            {\n                return ((LogEntry.Commit) entry).getMasterId();\n            }\n        }\n        throw new RuntimeException( \"Unable to find commit entry in for txId[\" + \n                txId + \"]\" );// in log[\" + version + \"]\" );\n    }","id":6947,"modified_method":"public synchronized int getMasterIdForCommittedTransaction( long txId ) throws IOException\n    {\n        if ( txId == 1 )\n        {\n            return MASTER_ID_REPRESENTING_NO_MASTER;\n        }\n        \n        List<LogEntry> logEntryList = extractLogEntryList( txId ).first();\n        for ( LogEntry entry : logEntryList )\n        {\n            if ( entry instanceof LogEntry.Commit )\n            {\n                return ((LogEntry.Commit) entry).getMasterId();\n            }\n        }\n        throw new RuntimeException( \"Unable to find commit entry in for txId[\" + \n                txId + \"]\" );// in log[\" + version + \"]\" );\n    }","commit_id":"c4947187b561b55367a0db34f519b917c4956147","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized ReadableByteChannel getCommittedTransaction( long txId )\n        throws IOException\n    {\n        String name = getExtractedTxFileName( txId );\n        File txFile = new File( name );\n        if ( txFile.exists() )\n        {\n            return new RandomAccessFile( txFile, \"r\" ).getChannel();\n        }\n        \n        List<LogEntry> logEntryList = extractLogEntryList( txId );\n        \n//        return wrapInMemoryLogEntryRepresentation( logEntryList );\n        writeOutLogEntryList( logEntryList, txFile, true );\n        return new RandomAccessFile( txFile, \"r\" ).getChannel();\n    }","id":6948,"modified_method":"public synchronized ReadableByteChannel getCommittedTransaction( long txId )\n        throws IOException\n    {\n        String name = getExtractedTxFileName( txId );\n        File txFile = new File( name );\n        if ( txFile.exists() )\n        {\n            return new RandomAccessFile( txFile, \"r\" ).getChannel();\n        }\n        \n        Pair<List<LogEntry>, Boolean> logEntryList = extractLogEntryList( txId );\n        \n        if ( logEntryList.other() )\n        {\n            // It was apparently hard to find (linear search in log(s)), perhaps\n            // a request from a slave which was way behind (more than the\n            // start-position-cache capacity). So store it cached on disk.\n            writeOutLogEntryList( logEntryList.first(), txFile, true );\n            return new RandomAccessFile( txFile, \"r\" ).getChannel();\n        }\n        else\n        {\n            // It was found easily with a start position from the start-position-cache\n            // so just make an in-memory byte representation of it and send.\n            return wrapInMemoryLogEntryRepresentation( logEntryList.first() );\n        }\n    }","commit_id":"c4947187b561b55367a0db34f519b917c4956147","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized ReadableByteChannel getPreparedTransaction( int identifier )\n            throws IOException\n    {\n        FileChannel log = (FileChannel) getLogicalLogOrMyself( logVersion, 0 );\n        List<LogEntry> logEntryList = extractPreparedTransactionFromLog( identifier, log );\n        log.close();\n        \n//        return wrapInMemoryLogEntryRepresentation( logEntryList );\n        \n        File txFile = createTempFile( \"temp-write-out\", \"-\" + identifier );\n        writeOutLogEntryList( logEntryList, txFile, false );\n        return new RandomAccessFile( txFile, \"r\" ).getChannel();\n    }","id":6949,"modified_method":"public synchronized ReadableByteChannel getPreparedTransaction( int identifier )\n            throws IOException\n    {\n        FileChannel log = (FileChannel) getLogicalLogOrMyself( logVersion, 0 );\n        List<LogEntry> logEntryList = extractPreparedTransactionFromLog( identifier, log );\n        log.close();\n        \n        return wrapInMemoryLogEntryRepresentation( logEntryList );\n        \n//        File txFile = createTempFile( \"temp-write-out\", \"-\" + identifier );\n//        writeOutLogEntryList( logEntryList, txFile, false );\n//        return new RandomAccessFile( txFile, \"r\" ).getChannel();\n    }","commit_id":"c4947187b561b55367a0db34f519b917c4956147","url":"https://github.com/neo4j/neo4j"},{"original_method":"private List<LogEntry> extractLogEntryList( long txId ) throws IOException\n    {\n        String name = getExtractedTxFileName( txId );\n        File txFile = new File( name );\n        List<LogEntry> logEntryList = null;\n        if ( txFile.exists() )\n        {\n            // It was already written out to file?\n            FileChannel channel = new RandomAccessFile( name, \"r\" ).getChannel();\n            logEntryList = extractTransactionFromLog( txId, -1, channel );\n            channel.close();\n            return logEntryList;\n        }\n        Pair<Long, Long> cachedInfo = this.txStartPositionCache.get( txId );\n        if ( cachedInfo != null )\n        {\n            // We have log version and start position cached\n            long version = cachedInfo.first();\n            ReadableByteChannel log = getLogicalLogOrMyself( version, cachedInfo.other() );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        else\n        {\n            // We have to look backwards in log files\n            long version = findLogContainingTxId( txId )[0];\n            if ( version == -1 )\n            {\n                throw new RuntimeException( \"txId:\" + txId + \" not found in any logical log \"\n                                            + \"(starting at \" + logVersion\n                                            + \" and searching backwards\" );\n            }\n\n            ReadableByteChannel log = getLogicalLogOrMyself( version, 0 );\n            long[] header = readAndAssertLogHeader( buffer, log, version );\n            long prevTxId = header[1];\n            assertLogCanContainTx( txId, prevTxId );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        return logEntryList;\n    }","id":6950,"modified_method":"private Pair<List<LogEntry>, Boolean> extractLogEntryList( long txId ) throws IOException\n    {\n        String name = getExtractedTxFileName( txId );\n        File txFile = new File( name );\n        List<LogEntry> logEntryList = null;\n        if ( txFile.exists() )\n        {\n            // It was already written out to file?\n            FileChannel channel = new RandomAccessFile( name, \"r\" ).getChannel();\n            logEntryList = extractTransactionFromLog( txId, -1, channel );\n            channel.close();\n            return new Pair<List<LogEntry>, Boolean>( logEntryList, false );\n        }\n        Pair<Long, Long> cachedInfo = this.txStartPositionCache.get( txId );\n        boolean foundInCache = false;\n        if ( cachedInfo != null )\n        {\n            // We have log version and start position cached\n            long version = cachedInfo.first();\n            ReadableByteChannel log = getLogicalLogOrMyself( version, cachedInfo.other() );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n            foundInCache = true;\n        }\n        else\n        {\n            // We have to look backwards in log files\n            long version = findLogContainingTxId( txId )[0];\n            if ( version == -1 )\n            {\n                throw new RuntimeException( \"txId:\" + txId + \" not found in any logical log \"\n                                            + \"(starting at \" + logVersion\n                                            + \" and searching backwards\" );\n            }\n\n            ReadableByteChannel log = getLogicalLogOrMyself( version, 0 );\n            long[] header = readAndAssertLogHeader( buffer, log, version );\n            long prevTxId = header[1];\n            assertLogCanContainTx( txId, prevTxId );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        return new Pair<List<LogEntry>, Boolean>( logEntryList, !foundInCache );\n    }","commit_id":"c4947187b561b55367a0db34f519b917c4956147","url":"https://github.com/neo4j/neo4j"},{"original_method":"private List<LogEntry> extractLogEntryList( long txId ) throws IOException\n    {\n        String name = getExtractedTxFileName( txId );\n        File txFile = new File( name );\n        List<LogEntry> logEntryList = null;\n        if ( txFile.exists() )\n        {\n            // It was already written out to file?\n            FileChannel channel = new RandomAccessFile( name, \"r\" ).getChannel();\n            logEntryList = extractTransactionFromLog( txId, -1, channel );\n            channel.close();\n            return logEntryList;\n        }\n        Pair<Long, Long> cachedInfo = this.txStartPositionCache.get( txId );\n        if ( cachedInfo != null )\n        {\n            // We have log version and start position cached\n            long version = cachedInfo.first();\n            ReadableByteChannel log = getLogicalLogOrMyself( version, cachedInfo.other() );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        else\n        {\n            // We have to look backwards in log files\n            long version = findLogContainingTxId( txId )[0];\n            if ( version == -1 )\n            {\n                throw new RuntimeException( \"txId:\" + txId + \" not found in any logical log \"\n                                            + \"(starting at \" + logVersion\n                                            + \" and searching backwards\" );\n            }\n\n            ReadableByteChannel log = getLogicalLogOrMyself( version, 0 );\n            long[] header = readAndAssertLogHeader( buffer, log, version );\n            long prevTxId = header[1];\n            assertLogCanContainTx( txId, prevTxId );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        return logEntryList;\n    }","id":6951,"modified_method":"private Pair<List<LogEntry>, Boolean> extractLogEntryList( long txId ) throws IOException\n    {\n        String name = getExtractedTxFileName( txId );\n        File txFile = new File( name );\n        List<LogEntry> logEntryList = null;\n        if ( txFile.exists() )\n        {\n            // It was already written out to file?\n            FileChannel channel = new RandomAccessFile( name, \"r\" ).getChannel();\n            logEntryList = extractTransactionFromLog( txId, -1, channel );\n            channel.close();\n            return new Pair<List<LogEntry>, Boolean>( logEntryList, false );\n        }\n        Pair<Long, Long> cachedInfo = this.txStartPositionCache.get( txId );\n        boolean foundInCache = false;\n        if ( cachedInfo != null )\n        {\n            // We have log version and start position cached\n            long version = cachedInfo.first();\n            ReadableByteChannel log = getLogicalLogOrMyself( version, cachedInfo.other() );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n            foundInCache = true;\n        }\n        else\n        {\n            // We have to look backwards in log files\n            long version = findLogContainingTxId( txId )[0];\n            if ( version == -1 )\n            {\n                throw new RuntimeException( \"txId:\" + txId + \" not found in any logical log \"\n                                            + \"(starting at \" + logVersion\n                                            + \" and searching backwards\" );\n            }\n\n            ReadableByteChannel log = getLogicalLogOrMyself( version, 0 );\n            long[] header = readAndAssertLogHeader( buffer, log, version );\n            long prevTxId = header[1];\n            assertLogCanContainTx( txId, prevTxId );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        return new Pair<List<LogEntry>, Boolean>( logEntryList, !foundInCache );\n    }","commit_id":"ced32c777486679a458fb9777c591862cf9ccd1f","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized ReadableByteChannel getPreparedTransaction( int identifier )\n            throws IOException\n    {\n        FileChannel log = (FileChannel) getLogicalLogOrMyself( logVersion, 0 );\n        List<LogEntry> logEntryList = extractPreparedTransactionFromLog( identifier, log );\n        log.close();\n        \n//        return wrapInMemoryLogEntryRepresentation( logEntryList );\n        \n        File txFile = createTempFile( \"temp-write-out\", \"-\" + identifier );\n        writeOutLogEntryList( logEntryList, txFile, false );\n        return new RandomAccessFile( txFile, \"r\" ).getChannel();\n    }","id":6952,"modified_method":"public synchronized ReadableByteChannel getPreparedTransaction( int identifier )\n            throws IOException\n    {\n        FileChannel log = (FileChannel) getLogicalLogOrMyself( logVersion, 0 );\n        List<LogEntry> logEntryList = extractPreparedTransactionFromLog( identifier, log );\n        log.close();\n        \n        return wrapInMemoryLogEntryRepresentation( logEntryList );\n        \n//        File txFile = createTempFile( \"temp-write-out\", \"-\" + identifier );\n//        writeOutLogEntryList( logEntryList, txFile, false );\n//        return new RandomAccessFile( txFile, \"r\" ).getChannel();\n    }","commit_id":"ced32c777486679a458fb9777c591862cf9ccd1f","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized ReadableByteChannel getCommittedTransaction( long txId )\n        throws IOException\n    {\n        String name = getExtractedTxFileName( txId );\n        File txFile = new File( name );\n        if ( txFile.exists() )\n        {\n            return new RandomAccessFile( txFile, \"r\" ).getChannel();\n        }\n        \n        List<LogEntry> logEntryList = extractLogEntryList( txId );\n        \n//        return wrapInMemoryLogEntryRepresentation( logEntryList );\n        writeOutLogEntryList( logEntryList, txFile, true );\n        return new RandomAccessFile( txFile, \"r\" ).getChannel();\n    }","id":6953,"modified_method":"public synchronized ReadableByteChannel getCommittedTransaction( long txId )\n        throws IOException\n    {\n        String name = getExtractedTxFileName( txId );\n        File txFile = new File( name );\n        if ( txFile.exists() )\n        {\n            return new RandomAccessFile( txFile, \"r\" ).getChannel();\n        }\n        \n        Pair<List<LogEntry>, Boolean> logEntryList = extractLogEntryList( txId );\n        \n        if ( logEntryList.other() )\n        {\n            // It was apparently hard to find (linear search in log(s)), perhaps\n            // a request from a slave which was way behind (more than the\n            // start-position-cache capacity). So store it cached on disk.\n            writeOutLogEntryList( logEntryList.first(), txFile, true );\n            return new RandomAccessFile( txFile, \"r\" ).getChannel();\n        }\n        else\n        {\n            // It was found easily with a start position from the start-position-cache\n            // so just make an in-memory byte representation of it and send.\n            return wrapInMemoryLogEntryRepresentation( logEntryList.first() );\n        }\n    }","commit_id":"ced32c777486679a458fb9777c591862cf9ccd1f","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized int getMasterIdForCommittedTransaction( long txId ) throws IOException\n    {\n        if ( txId == 1 )\n        {\n            return MASTER_ID_REPRESENTING_NO_MASTER;\n        }\n        \n        List<LogEntry> logEntryList = extractLogEntryList( txId );\n        for ( LogEntry entry : logEntryList )\n        {\n            if ( entry instanceof LogEntry.Commit )\n            {\n                return ((LogEntry.Commit) entry).getMasterId();\n            }\n        }\n        throw new RuntimeException( \"Unable to find commit entry in for txId[\" + \n                txId + \"]\" );// in log[\" + version + \"]\" );\n    }","id":6954,"modified_method":"public synchronized int getMasterIdForCommittedTransaction( long txId ) throws IOException\n    {\n        if ( txId == 1 )\n        {\n            return MASTER_ID_REPRESENTING_NO_MASTER;\n        }\n        \n        List<LogEntry> logEntryList = extractLogEntryList( txId ).first();\n        for ( LogEntry entry : logEntryList )\n        {\n            if ( entry instanceof LogEntry.Commit )\n            {\n                return ((LogEntry.Commit) entry).getMasterId();\n            }\n        }\n        throw new RuntimeException( \"Unable to find commit entry in for txId[\" + \n                txId + \"]\" );// in log[\" + version + \"]\" );\n    }","commit_id":"ced32c777486679a458fb9777c591862cf9ccd1f","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Helper method to init the smtpHost property.  This method\n     * first check is <code>er.javamail.smtpHost<\/code> is set.  If\n     * it is not set, then it looks for <code>mail.smtp.host<\/code>\n     * (standard JavaMail property) and finally the <code>WOSMTPHost<\/code> property.\n     * When a correct property is\n     * found, then it sets both properties to the found value.  If no\n     * properties are found, a RuntimeException is thrown.\n     * @throws RuntimeException if neither one of\n     * <code>er.javamail.smtpHost<\/code>, <code>mail.smtp.host<\/code> or <code>WOSMTPHost<\/code> is set.\n     */\n    protected void setupSmtpHostSafely () {\n        // Smtp host\n        String smtpHost = System.getProperty (\"er.javamail.smtpHost\");\n        if ((smtpHost == null) || (smtpHost.length () == 0)) {\n            // Try to fail back to default java config\n            smtpHost = System.getProperty (\"mail.smtp.host\");\n    \n            if ((smtpHost == null) || (smtpHost.length () == 0)) {\n                // use the standard WO host\n                smtpHost = System.getProperty (\"WOSMTPHost\");\n                if ((smtpHost == null) || (smtpHost.length () == 0)) {\n                    throw new RuntimeException (\"ERJavaMail: You must specify a SMTP host for outgoing mail with the property 'er.javamail.smtpHost'\");\n                }\n            } else\n                System.setProperty (\"er.javamail.smtpHost\", smtpHost);\n        } else\n            System.setProperty (\"mail.smtp.host\", smtpHost);\n\n        log.debug (\"er.javamail.smtpHost: \" + smtpHost);\n    }","id":6955,"modified_method":"/**\n     * Helper method to init the smtpHost property.  This method\n     * first check is <code>er.javamail.smtpHost<\/code> is set.  If\n     * it is not set, then it looks for <code>mail.smtp.host<\/code>\n     * (standard JavaMail property) and finally the <code>WOSMTPHost<\/code> property.\n     * When a correct property is\n     * found, then it sets both properties to the found value.  If no\n     * properties are found, a RuntimeException is thrown.\n     * @throws RuntimeException if neither one of\n     * <code>er.javamail.smtpHost<\/code>, <code>mail.smtp.host<\/code> or <code>WOSMTPHost<\/code> is set.\n     */\n    protected void setupSmtpHostSafely () {\n        // Smtp host\n        String smtpHost = System.getProperty (\"er.javamail.smtpHost\");\n        if ((smtpHost == null) || (smtpHost.length () == 0)) {\n            // Try to fail back to default java config\n            smtpHost = System.getProperty (\"mail.smtp.host\");\n    \n            if ((smtpHost == null) || (smtpHost.length () == 0)) {\n                // use the standard WO host\n                smtpHost = System.getProperty (\"WOSMTPHost\");\n                if ((smtpHost == null) || (smtpHost.length () == 0)) {\n                    throw new RuntimeException (\"ERJavaMail: You must specify a SMTP host for outgoing mail with the property 'er.javamail.smtpHost'\");\n                }\n            } else\n                System.setProperty (\"er.javamail.smtpHost\", smtpHost);\n        } else\n            System.setProperty (\"mail.smtp.host\", smtpHost);\n        log.debug (\"er.javamail.smtpHost: \" + smtpHost);\n\n        boolean smtpAuth = ERXProperties.booleanForKey(\"er.javamail.smtpAuth\");\n        log.debug(\"ERJavaMail will use authenticated SMTP connections.\");\n        if (smtpAuth) {\n          System.setProperty(\"mail.smtp.auth\", String.valueOf(smtpAuth));\n          String user = ERXProperties.stringForKey(\"er.javamail.smtpUser\");\n          if (user == null || user.length() == 0) {\n            throw new RuntimeException(\"You specified er.javamail.smtpAuth=true, but you didn't specify an er.javamail.smtpUser to use as the login name.\");\n          }\n          System.setProperty(\"mail.smtp.user\", user);\n          String password = ERXProperties.stringForKey(\"er.javamail.smtpPassword\");\n          if (password == null || password.length() == 0) {\n            log.warn(\"You specified er.javamail.smtpAuth=true, but you didn't set er.javamail.smtpPassword for the \" + user + \" mail user.\");\n          }\n          if (password != null) {\n            System.setProperty(\"mail.smtp.password\", password);\n          }\n        }\n    }","commit_id":"f68688c911bda4c444c02b8523f30e9d59ea7b8b","url":"https://github.com/wocommunity/wonder"},{"original_method":"/** Sends a message immediately.<br>\n        This means that the thread could be blocked if the message takes time to be delivered. */\n    public void sendMessageNow (ERMessage message) {\n        Transport transport = this._connectedTransportForSession (ERJavaMail.sharedInstance ().defaultSession ());\n\n        try {\n            this._sendMessageNow (message, transport);\n        } catch (MessagingException e) {\n            if (log.isDebugEnabled ())\n                log.debug (\"Caught exception when sending mail in a non-blocking manner.\", e);\n            throw new NSForwardException (e);\n        } finally {\n            // CHECKME (camille):\n            // Should we really close this default transport instance?\n            // I think there is no need to do so and that it should be closed\n            // when the ERMailSender is finalized\n            if (transport != null) {\n                try {\n                    transport.close ();\n                } catch (MessagingException e) {\n                    // Fatal exception ... we must at least notify the use\n                    log.error (\"Caught exception when closing transport.\", e);\n                    throw new RuntimeException (\"Unable to open nor close the messaging transport channel.\");\n                }\n            }\n        }\n    }","id":6956,"modified_method":"/** Sends a message immediately.<br>\n        This means that the thread could be blocked if the message takes time to be delivered. */\n    public void sendMessageNow (ERMessage message) {\n      Transport transport = null;\n      try {\n        transport = this._connectedTransportForSession(ERJavaMail.sharedInstance().defaultSession(), false);\n        this._sendMessageNow(message, transport);\n      }\n      catch (MessagingException e) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"Caught exception when sending mail in a non-blocking manner.\", e);\n        }\n        throw new NSForwardException(e);\n      }\n      finally {\n        // CHECKME (camille):\n        // Should we really close this default transport instance?\n        // I think there is no need to do so and that it should be closed\n        // when the ERMailSender is finalized\n        if (transport != null) {\n            try {\n                transport.close ();\n            } catch (MessagingException e) {\n                // Fatal exception ... we must at least notify the use\n                log.error (\"Caught exception when closing transport.\", e);\n                throw new RuntimeException (\"Unable to open nor close the messaging transport channel.\");\n            }\n        }\n      }\n    }","commit_id":"f68688c911bda4c444c02b8523f30e9d59ea7b8b","url":"https://github.com/wocommunity/wonder"},{"original_method":"/** Don't call this method, this is the thread run loop\n        and is automatically called. */\n    public void run () {\n        while (true) {\n            try {\n                if (threadSuspended) {\n                    synchronized (this) {\n                        while (threadSuspended)\n                            this.wait (milliSecondsWaitRunLoop);\n                    }\n                }\n            } catch (InterruptedException e) {\n                log.warn (\"ERMailSender thread has been interrupted.\");\n                threadSuspended = true;\n                return;\n            }\n\n            // If there are still messages pending ...\n            if (!messages.empty ()) {\n                Session session     = null;\n                Transport transport = null;\n                session   = ERJavaMail.sharedInstance ().newSession ();\n                transport = this._connectedTransportForSession (session);\n\n                try {\n                    if (!transport.isConnected ()) {\n                        transport.connect();\n                    }\n                } catch (MessagingException e) {\n                    // Notify error in logs\n                    log.error (\"Unable to connect transport.\", e);\n\n                    // Exit run loop\n                    throw new RuntimeException (\"Unable to connect transport.\");\n                }\n\n                while (!messages.empty ()) {\n                    ERMessage message = (ERMessage)messages.pop();\n                    try {\n                        this._sendMessageNow (message, transport);\n//                        if (useSenderDelay) {\n//                            this.wait (senderDelayMillis);\n                    //}\n                    } catch (MessagingException e) {\n                        // Here we get all the exceptions that are\n                        // not 'SendFailedException's.\n                        // All we can do is warn the admin.\n                        log.error (\"Fatal Messaging Exception. Can't send the mail.\", e);\n                    }/* catch (InterruptedException e) {\n                        log.warn (\"ERMailSender thread has been interrupted.\");\n                        threadSuspended = true;\n                        return;\n                    }*/\n                }\n\n                try {\n                    if (transport != null)\n                        transport.close ();\n                } catch (MessagingException e) /* once again ... */ {\n                    log.warn (\"Unable to close transport.  Perhaps it has already been closed?\", e);\n                }\n            }\n\n            threadSuspended = true;\n        }\n    }","id":6957,"modified_method":"/** Don't call this method, this is the thread run loop\n        and is automatically called. */\n    public void run () {\n        while (true) {\n            try {\n                if (threadSuspended) {\n                    synchronized (this) {\n                        while (threadSuspended)\n                            this.wait (milliSecondsWaitRunLoop);\n                    }\n                }\n            } catch (InterruptedException e) {\n                log.warn (\"ERMailSender thread has been interrupted.\");\n                threadSuspended = true;\n                return;\n            }\n\n            // If there are still messages pending ...\n            if (!messages.empty ()) {\n                Session session     = null;\n                Transport transport = null;\n                session   = ERJavaMail.sharedInstance ().newSession ();\n                try {\n                  transport = this._connectedTransportForSession(session, true);\n                }\n                catch (MessagingException e) {\n                  if (log.isDebugEnabled()) {\n                    log.debug(\"Caught exception when sending mail in a non-blocking manner.\", e);\n                  }\n                  throw new NSForwardException(e);\n                }\n\n                try {\n                    if (!transport.isConnected ()) {\n                        transport.connect();\n                    }\n                } catch (MessagingException e) {\n                    // Notify error in logs\n                    log.error (\"Unable to connect transport.\", e);\n\n                    // Exit run loop\n                    throw new RuntimeException (\"Unable to connect transport.\");\n                }\n\n                while (!messages.empty ()) {\n                    ERMessage message = (ERMessage)messages.pop();\n                    try {\n                        this._sendMessageNow (message, transport);\n//                        if (useSenderDelay) {\n//                            this.wait (senderDelayMillis);\n                    //}\n                    } catch (MessagingException e) {\n                        // Here we get all the exceptions that are\n                        // not 'SendFailedException's.\n                        // All we can do is warn the admin.\n                        log.error (\"Fatal Messaging Exception. Can't send the mail.\", e);\n                    }/* catch (InterruptedException e) {\n                        log.warn (\"ERMailSender thread has been interrupted.\");\n                        threadSuspended = true;\n                        return;\n                    }*/\n                }\n\n                try {\n                    if (transport != null)\n                        transport.close ();\n                } catch (MessagingException e) /* once again ... */ {\n                    log.warn (\"Unable to close transport.  Perhaps it has already been closed?\", e);\n                }\n            }\n\n            threadSuspended = true;\n        }\n    }","commit_id":"f68688c911bda4c444c02b8523f30e9d59ea7b8b","url":"https://github.com/wocommunity/wonder"},{"original_method":"/** Utility method that gets the SMTP Transport method for a session and\n        connects the Transport before returning it. */\n    protected Transport _connectedTransportForSession (javax.mail.Session session) {\n        Transport transport = null;\n        try {\n            transport = session.getTransport (\"smtp\");\n            if (!transport.isConnected())\n                transport.connect();\n        } catch (MessagingException e) {\n            log.error (\"Unable to connect to SMTP Transport. MessagingException: \"\n                       + e.getMessage (), e);\n        }\n\n        return transport;\n    }","id":6958,"modified_method":"/** Utility method that gets the SMTP Transport method for a session and\n        connects the Transport before returning it. */\n    protected Transport _connectedTransportForSession(javax.mail.Session session, boolean _throwExceptionIfConnectionFails) throws MessagingException {\n      Transport transport = null;\n      try {\n        transport = session.getTransport(\"smtp\");\n        if (!transport.isConnected()) {\n          String userName = session.getProperty(\"mail.smtp.user\");\n          String password = session.getProperty(\"mail.smtp.password\");\n          if (userName != null && password != null) {\n            transport.connect(session.getProperty(\"mail.smtp.host\"), userName, password);\n          }\n          else {\n            transport.connect();\n          }\n        }\n      }\n      catch (MessagingException e) {\n        log.error(\"Unable to connect to SMTP Transport. MessagingException: \" + e.getMessage(), e);\n        if (_throwExceptionIfConnectionFails) {\n          throw e;\n        }\n      }\n\n      return transport;\n    }","commit_id":"f68688c911bda4c444c02b8523f30e9d59ea7b8b","url":"https://github.com/wocommunity/wonder"},{"original_method":"public static void generateJmxConfig(String serviceName, String hostName, String port, Boolean runStandardVmBeans, Boolean runCompositeData, String outFile) throws AttributeNotFoundException, MBeanException {\n\tlogger.debug(\"Startup values: \\n serviceName: \" + serviceName + \"\\n hostName: \" + hostName + \"\\n port:\" + port + \"\\n runStandardVmBeans: \" + runStandardVmBeans + \"\\n runCompositeData: \" + runCompositeData);\n\t\tJMXServiceURL jmxServiceURL;\n\t\tJmxDatacollectionConfig xmlJmxDatacollectionConfig = xmlObjectFactory.createJmxDatacollectionConfig();\n\t\tJmxCollection xmlJmxCollection = xmlObjectFactory.createJmxCollection();\n\n\t\txmlJmxCollection.setName(\"JSR160-\" + serviceName);\n\t\txmlJmxCollection.setRrd(rrd);\n\t\txmlJmxDatacollectionConfig.getJmxCollection().add(xmlJmxCollection);\n\t\txmlJmxCollection.setMbeans(xmlObjectFactory.createMbeans());\n\n\t\tif (!runStandardVmBeans) {\n\t\t\tignores.addAll(standardVmBeans);\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tjmxServiceURL = new JMXServiceURL(\"service:jmx:rmi:///jndi/rmi://\" + hostName + \":\" + port + \"/jmxrmi\");\n\t\t\tJMXConnector jmxConnector = JMXConnectorFactory.connect(jmxServiceURL);\n\t\t\tjmxConnector.connect();\n\t\t\tjmxServerConnection = jmxConnector.getMBeanServerConnection();\n\t\t\tlogger.debug(\"count: \" + jmxServerConnection.getMBeanCount());\n\t\t\tfor (String domainName : jmxServerConnection.getDomains()) {\n\n\t\t\t\t// just domains that are relevant for the service\n\t\t\t\tif (!ignores.contains(domainName)) {\n\t\t\t\t\tlogger.debug(\"domain: \" + domainName);\n\n\t\t\t\t\t// for all mBeans of the actual domain\n\t\t\t\t\tfor (ObjectInstance jmxObjectInstance : jmxServerConnection.queryMBeans(new ObjectName(domainName + \":*\"), null)) {\n\t\t\t\t\t\tMbean xmlMbean = xmlObjectFactory.createMbean();\n\t\t\t\t\t\txmlMbean.setObjectname(jmxObjectInstance.getObjectName().toString());\n\t\t\t\t\t\tString typeAndOthers = StringUtils.substringAfterLast(jmxObjectInstance.getObjectName().getCanonicalName(), \"=\");\n\t\t\t\t\t\txmlMbean.setName(domainName + \".\" + typeAndOthers);\n\n\t\t\t\t\t\tlogger.debug(\"\\t\" + jmxObjectInstance.getObjectName());\n\t\t\t\t\t\tMBeanInfo jmxMbeanInfo = jmxServerConnection.getMBeanInfo(jmxObjectInstance.getObjectName());\n\t\t\t\t\t\tlogger.debug(\"--- Attributes for \" + jmxObjectInstance.getObjectName());\n\n\t\t\t\t\t\tfor (MBeanAttributeInfo jmxBeanAttributeInfo : jmxMbeanInfo.getAttributes()) {\n\n\t\t\t\t\t\t\t// process just readable and not writable mbeans\n\t\t\t\t\t\t\tif (jmxBeanAttributeInfo.isReadable() && !jmxBeanAttributeInfo.isWritable()) {\n\t\t\t\t\t\t\t\tlogger.info(\"Add Elements for mBean: '{}'\", jmxObjectInstance.getObjectName().toString());\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// just process CompositeData if activated\n\t\t\t\t\t\t\t\tif ( runCompositeData && \"javax.management.openmbean.CompositeData\".equals(jmxBeanAttributeInfo.getType())) {\n\t\t\t\t\t\t\t\t\tlogger.error(\"actual mBean: '{}'\", jmxObjectInstance.getObjectName());\n\t\t\t\t\t\t\t\t\tCompAttrib compAttrib = createCompAttrib(jmxObjectInstance, jmxBeanAttributeInfo);\n\t\t\t\t\t\t\t\t\tif (compAttrib != null) {\n\t\t\t\t\t\t\t\t\t\tlogger.debug(\"xmlMbean got CompAttrib\");\n\t\t\t\t\t\t\t\t\t\txmlMbean.getCompAttrib().add(compAttrib);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (numbers.contains(jmxBeanAttributeInfo.getType())) {\n\t\t\t\t\t\t\t\t\tAttrib xmlJmxAttribute = createAttr(jmxBeanAttributeInfo);\n\t\t\t\t\t\t\t\t\t// logger.info(\"\\tAdded attribute: '{}' with alias: '{}'\",\n\t\t\t\t\t\t\t\t\t// xmlJmxAttribute.getName(),\n\t\t\t\t\t\t\t\t\t// xmlJmxAttribute.getAlias());\n\t\t\t\t\t\t\t\t\txmlMbean.getAttrib().add(xmlJmxAttribute);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (xmlMbean.getAttrib().size() > 0 || xmlMbean.getCompAttrib().size() > 0) {\n\t\t\t\t\t\t\txmlJmxCollection.getMbeans().getMbean().add(xmlMbean);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlogger.debug(\"mbean: \" + xmlMbean.getName() + \" has no relavant attributes.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlogger.debug(\"ignored: \" + domainName);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tJAXB.marshal(xmlJmxDatacollectionConfig, new File(outFile));\n\n\t\t} catch (MalformedURLException e) {\n\t\t\tlogger.error(\"MalformedURLException '{}'\", e.getMessage());\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\tlogger.error(\"IOException '{}'\", e.getMessage());\n\t\t\te.printStackTrace();\n\t\t} catch (MalformedObjectNameException e) {\n\t\t\tlogger.error(\"MalformedObjectNameException '{}'\", e.getMessage());\n\t\t\te.printStackTrace();\n\t\t} catch (InstanceNotFoundException e) {\n\t\t\tlogger.error(\"InstanceNotFoundException '{}'\", e.getMessage());\n\t\t\te.printStackTrace();\n\t\t} catch (IntrospectionException e) {\n\t\t\tlogger.error(\"IntrospectionException '{}'\", e.getMessage());\n\t\t\te.printStackTrace();\n\t\t} catch (ReflectionException e) {\n\t\t\tlogger.error(\"ReflectionException '{}'\", e.getMessage());\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\tlogger.debug(xmlJmxDatacollectionConfig.toString());\n\n\t\tlogger.info(\"Thx for computing with us!\");\n\t}","id":6959,"modified_method":"public static void generateJmxConfig(String serviceName, String hostName, String port, String username, String password, Boolean runStandardVmBeans, Boolean runCompositeData, String outFile) throws AttributeNotFoundException, MBeanException {\n\tlogger.debug(\"Startup values: \\n serviceName: \" + serviceName + \"\\n hostName: \" + hostName + \"\\n port:\" + port + \"\\n runStandardVmBeans: \" + runStandardVmBeans + \"\\n runCompositeData: \" + runCompositeData + \"\\n username: \" + username + \"\\n password: \" + password + \"\\n\");\n\t\tJMXServiceURL jmxServiceURL;\n\t\tJmxDatacollectionConfig xmlJmxDatacollectionConfig = xmlObjectFactory.createJmxDatacollectionConfig();\n\t\tJmxCollection xmlJmxCollection = xmlObjectFactory.createJmxCollection();\n\n\t\txmlJmxCollection.setName(\"JSR160-\" + serviceName);\n\t\txmlJmxCollection.setRrd(rrd);\n\t\txmlJmxDatacollectionConfig.getJmxCollection().add(xmlJmxCollection);\n\t\txmlJmxCollection.setMbeans(xmlObjectFactory.createMbeans());\n\n\t\tif (!runStandardVmBeans) {\n\t\t\tignores.addAll(standardVmBeans);\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tjmxServiceURL = new JMXServiceURL(\"service:jmx:rmi:///jndi/rmi://\" + hostName + \":\" + port + \"/jmxrmi\");\n\t\t\tJMXConnector jmxConnector = null;\n \t\t\tif (username != null && password != null) { \n\t\t\t\tjmxConnector = JMXConnectorFactory.newJMXConnector(jmxServiceURL, null);\n \t\t\t\tHashMap<String,String[]> env = new HashMap<String,String[]>();\n \t\t\t\tString[] credentials = new String[] { username , password };\n \t\t\t\tenv.put(\"jmx.remote.credentials\", credentials);\n \t\t\t\tjmxConnector.connect(env);\n \t\t\t} else {\n\t\t\t\tjmxConnector = JMXConnectorFactory.connect(jmxServiceURL);\n \t\t\t\tjmxConnector.connect();\n \t\t\t}\n\t\t\tjmxServerConnection = jmxConnector.getMBeanServerConnection();\n\t\t\tlogger.debug(\"count: \" + jmxServerConnection.getMBeanCount());\n\t\t\tfor (String domainName : jmxServerConnection.getDomains()) {\n\n\t\t\t\t// just domains that are relevant for the service\n\t\t\t\tif (!ignores.contains(domainName)) {\n\t\t\t\t\tlogger.debug(\"domain: \" + domainName);\n\n\t\t\t\t\t// for all mBeans of the actual domain\n\t\t\t\t\tfor (ObjectInstance jmxObjectInstance : jmxServerConnection.queryMBeans(new ObjectName(domainName + \":*\"), null)) {\n\t\t\t\t\t\tMbean xmlMbean = xmlObjectFactory.createMbean();\n\t\t\t\t\t\txmlMbean.setObjectname(jmxObjectInstance.getObjectName().toString());\n\t\t\t\t\t\tString typeAndOthers = StringUtils.substringAfterLast(jmxObjectInstance.getObjectName().getCanonicalName(), \"=\");\n\t\t\t\t\t\txmlMbean.setName(domainName + \".\" + typeAndOthers);\n\n\t\t\t\t\t\tlogger.debug(\"\\t\" + jmxObjectInstance.getObjectName());\n\t\t\t\t\t\tMBeanInfo jmxMbeanInfo = jmxServerConnection.getMBeanInfo(jmxObjectInstance.getObjectName());\n\t\t\t\t\t\tlogger.debug(\"--- Attributes for \" + jmxObjectInstance.getObjectName());\n\n\t\t\t\t\t\tfor (MBeanAttributeInfo jmxBeanAttributeInfo : jmxMbeanInfo.getAttributes()) {\n\n\t\t\t\t\t\t\t// process just readable and not writable mbeans\n\t\t\t\t\t\t\tif (jmxBeanAttributeInfo.isReadable() && !jmxBeanAttributeInfo.isWritable()) {\n\t\t\t\t\t\t\t\tlogger.info(\"Add Elements for mBean: '{}'\", jmxObjectInstance.getObjectName().toString());\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// just process CompositeData if activated\n\t\t\t\t\t\t\t\tif ( runCompositeData && \"javax.management.openmbean.CompositeData\".equals(jmxBeanAttributeInfo.getType())) {\n\t\t\t\t\t\t\t\t\tlogger.error(\"actual mBean: '{}'\", jmxObjectInstance.getObjectName());\n\t\t\t\t\t\t\t\t\tCompAttrib compAttrib = createCompAttrib(jmxObjectInstance, jmxBeanAttributeInfo);\n\t\t\t\t\t\t\t\t\tif (compAttrib != null) {\n\t\t\t\t\t\t\t\t\t\tlogger.debug(\"xmlMbean got CompAttrib\");\n\t\t\t\t\t\t\t\t\t\txmlMbean.getCompAttrib().add(compAttrib);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (numbers.contains(jmxBeanAttributeInfo.getType())) {\n\t\t\t\t\t\t\t\t\tAttrib xmlJmxAttribute = createAttr(jmxBeanAttributeInfo);\n\t\t\t\t\t\t\t\t\t// logger.info(\"\\tAdded attribute: '{}' with alias: '{}'\",\n\t\t\t\t\t\t\t\t\t// xmlJmxAttribute.getName(),\n\t\t\t\t\t\t\t\t\t// xmlJmxAttribute.getAlias());\n\t\t\t\t\t\t\t\t\txmlMbean.getAttrib().add(xmlJmxAttribute);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (xmlMbean.getAttrib().size() > 0 || xmlMbean.getCompAttrib().size() > 0) {\n\t\t\t\t\t\t\txmlJmxCollection.getMbeans().getMbean().add(xmlMbean);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlogger.debug(\"mbean: \" + xmlMbean.getName() + \" has no relavant attributes.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlogger.debug(\"ignored: \" + domainName);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tJAXB.marshal(xmlJmxDatacollectionConfig, new File(outFile));\n\n\t\t} catch (MalformedURLException e) {\n\t\t\tlogger.error(\"MalformedURLException '{}'\", e.getMessage());\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\tlogger.error(\"IOException '{}'\", e.getMessage());\n\t\t\te.printStackTrace();\n\t\t} catch (MalformedObjectNameException e) {\n\t\t\tlogger.error(\"MalformedObjectNameException '{}'\", e.getMessage());\n\t\t\te.printStackTrace();\n\t\t} catch (InstanceNotFoundException e) {\n\t\t\tlogger.error(\"InstanceNotFoundException '{}'\", e.getMessage());\n\t\t\te.printStackTrace();\n\t\t} catch (IntrospectionException e) {\n\t\t\tlogger.error(\"IntrospectionException '{}'\", e.getMessage());\n\t\t\te.printStackTrace();\n\t\t} catch (ReflectionException e) {\n\t\t\tlogger.error(\"ReflectionException '{}'\", e.getMessage());\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\tlogger.debug(xmlJmxDatacollectionConfig.toString());\n\n\t\tlogger.info(\"Thx for computing with us!\");\n\t}","commit_id":"cb492c6169acbe911522c6a1a7812e1f6e0a9c6b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void doMain(String[] args) {\n\n\t\tCmdLineParser parser = new CmdLineParser(this);\n\n\t\tparser.setUsageWidth(80);\n\n\t\ttry {\n\t\t\tparser.parseArgument(args);\n\t\t\tif (jmx && graph) {\n\t\t\t\tthrow new CmdLineException(parser, \"jmx and graph is set. Just use on at a time.\");\n\t\t\t}\n\t\t\tif (!jmx && !graph) {\n\t\t\t\tthrow new CmdLineException(parser, \"set jmx or graph.\");\n\t\t\t}\n\t\t\tif (jmx && hostName != null && port != null && outFile != null) {\n\t\t\t\tJmxDatacollectionConfigGenerator.generateJmxConfig(serviceName, hostName, port, !skipDefaultVM, runCompositeData, outFile);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (graph && inputFile != null && outFile != null) {\n\t\t\t\tSnmpGraphConfigGenerator.generateGraphs(serviceName, inputFile, outFile);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthrow new CmdLineException(parser, \"no valid call found.\");\n\t\t} catch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\tSystem.err.println(\"JmxConfigGenerator [options...] arguments...\");\n\t\t\tparser.printUsage(System.err);\n\t\t\tSystem.err.println();\n\t\t\t// System.err.println(\"  Example: java -jar JmxConfigGenerator\" +\n\t\t\t// parser.printExample(ALL));\n\t\t\tSystem.err.println(\"Use a call linke:\");\n\t\t\tSystem.err.println(\"  Example generation of jmx-datacollection.xml: java -jar JmxConfigGenerator.jar -jmx -host localhost -port 7199 -out JMX-DatacollectionDummy.xml [-service cassandra] [-runCompositeData] [-skipDefaultVM]\");\n\t\t\tSystem.err.println(\"  Example generation of  snmp-graph.properties: java -jar JmxConfigGenerator.jar -graph -input test.xml -out test.properies [-service cassandra]\");\n\t\t\treturn;\n\t\t}\n\t}","id":6960,"modified_method":"public void doMain(String[] args) {\n\n\t\tCmdLineParser parser = new CmdLineParser(this);\n\n\t\tparser.setUsageWidth(80);\n\n\t\ttry {\n\t\t\tparser.parseArgument(args);\n\t\t\tif (jmx && graph) {\n\t\t\t\tthrow new CmdLineException(parser, \"jmx and graph is set. Just use on at a time.\");\n\t\t\t}\n\t\t\tif (!jmx && !graph) {\n\t\t\t\tthrow new CmdLineException(parser, \"set jmx or graph.\");\n\t\t\t}\n\t\t\tif (jmx && hostName != null && port != null && outFile != null) {\n\t\t\t\tJmxDatacollectionConfigGenerator.generateJmxConfig(serviceName, hostName, port, username, password, !skipDefaultVM, runCompositeData, outFile);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (graph && inputFile != null && outFile != null) {\n\t\t\t\tSnmpGraphConfigGenerator.generateGraphs(serviceName, inputFile, outFile);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthrow new CmdLineException(parser, \"no valid call found.\");\n\t\t} catch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\tSystem.err.println(\"JmxConfigGenerator [options...] arguments...\");\n\t\t\tparser.printUsage(System.err);\n\t\t\tSystem.err.println();\n\t\t\t// System.err.println(\"  Example: java -jar JmxConfigGenerator\" +\n\t\t\t// parser.printExample(ALL));\n\t\t\tSystem.err.println(\"Use a call linke:\");\n\t\t\tSystem.err.println(\"  Example generation of jmx-datacollection.xml: java -jar JmxConfigGenerator.jar -jmx -host localhost -port 7199 -out JMX-DatacollectionDummy.xml [-service cassandra] [-runCompositeData] [-skipDefaultVM]\");\n\t\t\tSystem.err.println(\"  Example generation of  snmp-graph.properties: java -jar JmxConfigGenerator.jar -graph -input test.xml -out test.properies [-service cassandra]\");\n\t\t\treturn;\n\t\t}\n\t}","commit_id":"cb492c6169acbe911522c6a1a7812e1f6e0a9c6b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is used to transform an event configuration mask instance\n     * into an event mask instance. This is used when the incomming event does\n     * not have a mask and the information from the configuration object is\n     * copied.\n     * \n     * @param src\n     *            The configuration source to transform.\n     * \n     * @return The transformed mask information.\n     * \n     */\n    private org.opennms.netmgt.xml.event.Mask transform(org.opennms.netmgt.xml.eventconf.Mask src) {\n        org.opennms.netmgt.xml.event.Mask dest = new org.opennms.netmgt.xml.event.Mask();\n\n        Enumeration en = src.enumerateMaskelement();\n        while (en.hasMoreElements()) {\n            org.opennms.netmgt.xml.eventconf.Maskelement confme = (org.opennms.netmgt.xml.eventconf.Maskelement) en.nextElement();\n\n            // create new mask element\n            org.opennms.netmgt.xml.event.Maskelement me = new org.opennms.netmgt.xml.event.Maskelement();\n            // set name\n            me.setMename(confme.getMename());\n            // set values\n            String[] confmevalues = confme.getMevalue();\n            for (int index = 0; index < confmevalues.length; index++) {\n                me.addMevalue(confmevalues[index]);\n            }\n\n            dest.addMaskelement(me);\n        }\n\n        return dest;\n    }","id":6961,"modified_method":"/**\n     * This method is used to transform an event configuration mask instance\n     * into an event mask instance. This is used when the incomming event does\n     * not have a mask and the information from the configuration object is\n     * copied.\n     * \n     * @param src\n     *            The configuration source to transform.\n     * \n     * @return The transformed mask information.\n     * \n     */\n    private org.opennms.netmgt.xml.event.Mask transform(org.opennms.netmgt.xml.eventconf.Mask src) {\n        org.opennms.netmgt.xml.event.Mask dest = new org.opennms.netmgt.xml.event.Mask();\n\n        Enumeration<Maskelement> en = src.enumerateMaskelement();\n        while (en.hasMoreElements()) {\n            org.opennms.netmgt.xml.eventconf.Maskelement confme = en.nextElement();\n\n            // create new mask element\n            org.opennms.netmgt.xml.event.Maskelement me = new org.opennms.netmgt.xml.event.Maskelement();\n            // set name\n            me.setMename(confme.getMename());\n            // set values\n            String[] confmevalues = confme.getMevalue();\n            for (String confmevalue : confmevalues) {\n                me.addMevalue(confmevalue);\n            }\n\n            dest.addMaskelement(me);\n        }\n\n        return dest;\n    }","commit_id":"1e788c24db46ffe642c294adca9e6addd9d4766e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Expand parms in the event operaction(s)\n     */\n    private void expandParms(Operaction[] operactions, Event event) {\n        boolean expanded = false;\n\n        for (int index = 0; index < operactions.length; index++) {\n            Operaction action = operactions[index];\n\n            String strRet = EventUtil.expandParms(action.getContent(), event);\n            if (strRet != null) {\n                action.setContent(strRet);\n                expanded = true;\n            }\n        }\n\n        if (expanded)\n            event.setOperaction(operactions);\n    }","id":6962,"modified_method":"/**\n     * Expand parms in the event operaction(s)\n     */\n    private void expandParms(Operaction[] operactions, Event event) {\n        boolean expanded = false;\n\n        for (Operaction action : operactions) {\n            String strRet = EventUtil.expandParms(action.getContent(), event);\n            if (strRet != null) {\n                action.setContent(strRet);\n                expanded = true;\n            }\n        }\n\n        if (expanded) {\n            event.setOperaction(operactions);\n        }\n    }","commit_id":"1e788c24db46ffe642c294adca9e6addd9d4766e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>\n     * This method is invoked to check and configure a received event. The event\n     * configuration manager is consulted to find the appropriate configuration\n     * that is used to expand the event. In addition, the security parameters\n     * from the configuration manager is consulted to ensure that secure files\n     * are cleared out if necessary.\n     * <\/p>\n     * \n     * <p>\n     * Any secure fields that exists in the incomming event are cleared during\n     * expansion.\n     * <\/p>\n     * \n     * @param e\n     *            The event to expand if necesary.\n     * \n     */\n    public synchronized void expandEvent(Event e) {\n        org.opennms.netmgt.xml.eventconf.Event econf = lookup(e);\n\n        if (econf != null) {\n            if (m_eventConfDao.isSecureTag(\"mask\"))\n                e.setMask(null);\n            if (e.getMask() == null && econf.getMask() != null) {\n                e.setMask(transform(econf.getMask()));\n            }\n\n            // Copy the UEI\n            //\n            if (e.getUei() == null)\n                e.setUei(econf.getUei());\n\n            // Copy the Snmp Information\n            //\n            if (e.getSnmp() == null && econf.getSnmp() != null)\n                e.setSnmp(transform(econf.getSnmp()));\n\n            // Copy the description\n            //\n            if (m_eventConfDao.isSecureTag(\"descr\"))\n                e.setDescr(null);\n            if (e.getDescr() == null && econf.getDescr() != null)\n                e.setDescr(econf.getDescr());\n\n            // Copy the log message if any\n            //\n            if (m_eventConfDao.isSecureTag(\"logmsg\"))\n                e.setLogmsg(null);\n            if (e.getLogmsg() == null && econf.getLogmsg() != null)\n                e.setLogmsg(transform(econf.getLogmsg()));\n\n            // Copy the severity\n            //\n            if (m_eventConfDao.isSecureTag(\"severity\"))\n                e.setSeverity(null);\n            if (e.getSeverity() == null && econf.getSeverity() != null)\n                e.setSeverity(econf.getSeverity());\n\n            // Set the correlation information\n            //\n            if (m_eventConfDao.isSecureTag(\"correlation\"))\n                e.setCorrelation(null);\n            if (e.getCorrelation() == null && econf.getCorrelation() != null)\n                e.setCorrelation(transform(econf.getCorrelation()));\n\n            // Copy the operator instruction\n            //\n            if (m_eventConfDao.isSecureTag(\"operinstruct\"))\n                e.setOperinstruct(null);\n            if (e.getOperinstruct() == null && econf.getOperinstruct() != null)\n                e.setOperinstruct(econf.getOperinstruct());\n\n            // Copy the auto actions.\n            //\n            if (m_eventConfDao.isSecureTag(\"autoaction\"))\n                e.removeAllAutoaction();\n            if (e.getAutoactionCount() == 0 && econf.getAutoactionCount() > 0) {\n                Enumeration eter = econf.enumerateAutoaction();\n                while (eter.hasMoreElements()) {\n                    org.opennms.netmgt.xml.eventconf.Autoaction src = (org.opennms.netmgt.xml.eventconf.Autoaction) eter.nextElement();\n                    e.addAutoaction(transform(src));\n                }\n            }\n\n            // Convert the operator actions\n            //\n            if (m_eventConfDao.isSecureTag(\"operaction\"))\n                e.removeAllOperaction();\n            if (e.getOperactionCount() == 0 && econf.getOperactionCount() > 0) {\n                Enumeration eter = econf.enumerateOperaction();\n                while (eter.hasMoreElements()) {\n                    org.opennms.netmgt.xml.eventconf.Operaction src = (org.opennms.netmgt.xml.eventconf.Operaction) eter.nextElement();\n                    e.addOperaction(transform(src));\n                }\n            }\n\n            // Convert the auto acknowledgement\n            //\n            if (m_eventConfDao.isSecureTag(\"autoacknowledge\"))\n                e.setAutoacknowledge(null);\n            if (e.getAutoacknowledge() == null && econf.getAutoacknowledge() != null)\n                e.setAutoacknowledge(transform(econf.getAutoacknowledge()));\n\n            // Convert the log group information\n            //\n            if (m_eventConfDao.isSecureTag(\"loggroup\"))\n                e.removeAllLoggroup();\n            if (e.getLoggroupCount() == 0 && econf.getLoggroupCount() > 0)\n                e.setLoggroup(econf.getLoggroup());\n\n            // Convert the trouble tickets.\n            //\n            if (m_eventConfDao.isSecureTag(\"tticket\"))\n                e.setTticket(null);\n            if (e.getTticket() == null && econf.getTticket() != null)\n                e.setTticket(transform(econf.getTticket()));\n\n            // Convert the forward entry\n            //\n            if (m_eventConfDao.isSecureTag(\"forward\"))\n                e.removeAllForward();\n            if (e.getForwardCount() == 0 && econf.getForwardCount() > 0) {\n                Enumeration eter = econf.enumerateForward();\n                while (eter.hasMoreElements()) {\n                    org.opennms.netmgt.xml.eventconf.Forward src = (org.opennms.netmgt.xml.eventconf.Forward) eter.nextElement();\n                    e.addForward(transform(src));\n                }\n            }\n\n            // Convert the script entry\n            //\n            if (m_eventConfDao.isSecureTag(\"script\"))\n                e.removeAllScript();\n            if (e.getScriptCount() == 0 && econf.getScriptCount() > 0) {\n                Enumeration eter = econf.enumerateScript();\n                while (eter.hasMoreElements()) {\n                    org.opennms.netmgt.xml.eventconf.Script src = (org.opennms.netmgt.xml.eventconf.Script) eter.nextElement();\n                    e.addScript(transform(src));\n                }\n            }\n\n            // Copy the mouse over text\n            //\n            if (m_eventConfDao.isSecureTag(\"mouseovertext\"))\n                e.setMouseovertext(null);\n            if (e.getMouseovertext() == null && econf.getMouseovertext() != null)\n                e.setMouseovertext(econf.getMouseovertext());\n\n            // Copy the reductionKey\n            // TODO:  This isSecureTag call needs some research.  \"You keep using that word.  I don't think it means what you think it means.\"\n            //        It looks to me like there should be an else here.  I could be wrong.\n            if (m_eventConfDao.isSecureTag(\"reduction-key\") && m_eventConfDao.isSecureTag(\"alarm-type\") && m_eventConfDao.isSecureTag(\"clear-uei\"))\n                e.setAlarmData(null);\n            \n            if (e.getAlarmData() == null && econf.getAlarmData() != null) {\n                AlarmData alarmData = new AlarmData();\n                alarmData.setAlarmType(econf.getAlarmData().getAlarmType());\n                alarmData.setReductionKey(econf.getAlarmData().getReductionKey());\n                alarmData.setClearUei(econf.getAlarmData().getClearUei());\n                alarmData.setAutoClean(econf.getAlarmData().getAutoClean());\n                alarmData.setX733AlarmType(econf.getAlarmData().getX733AlarmType());\n                alarmData.setX733ProbableCause(econf.getAlarmData().getX733ProbableCause());\n                alarmData.setClearKey(econf.getAlarmData().getClearKey());\n                e.setAlarmData(alarmData);\n            }\n\n        } \n        \n        Map<String, Map<String, String>> decode = new HashMap<String, Map<String,String>>();\n        if (econf.getVarbindsdecode() != null) {\n           Varbindsdecode[] vardecodeArray = econf.getVarbindsdecode();\n           for (int i=0; i<vardecodeArray.length; i++) {\n               Decode[] decodeArray = vardecodeArray[i].getDecode();\n               Map<String, String> valueMap = new HashMap<String, String>();\n               for (int j=0; j<decodeArray.length;j++) {\n                   valueMap.put(decodeArray[j].getVarbindvalue(), decodeArray[j].getVarbinddecodedstring());\n               }\n               decode.put(vardecodeArray[i].getParmid(), valueMap);\n           }\n        }// end fill of event using econf\n\n        // do the event parm expansion\n        expandParms(e, decode);\n\n    }","id":6963,"modified_method":"/**\n     * <p>\n     * This method is invoked to check and configure a received event. The event\n     * configuration manager is consulted to find the appropriate configuration\n     * that is used to expand the event. In addition, the security parameters\n     * from the configuration manager is consulted to ensure that secure files\n     * are cleared out if necessary.\n     * <\/p>\n     * \n     * <p>\n     * Any secure fields that exists in the incomming event are cleared during\n     * expansion.\n     * <\/p>\n     * \n     * @param e\n     *            The event to expand if necesary.\n     * \n     */\n    public synchronized void expandEvent(Event e) {\n        org.opennms.netmgt.xml.eventconf.Event econf = lookup(e);\n\n        if (econf != null) {\n            if (m_eventConfDao.isSecureTag(\"mask\")) {\n                e.setMask(null);\n            }\n            if (e.getMask() == null && econf.getMask() != null) {\n                e.setMask(transform(econf.getMask()));\n            }\n\n            // Copy the UEI\n            //\n            if (e.getUei() == null) {\n                e.setUei(econf.getUei());\n            }\n\n            // Copy the Snmp Information\n            //\n            if (e.getSnmp() == null && econf.getSnmp() != null) {\n                e.setSnmp(transform(econf.getSnmp()));\n            }\n\n            // Copy the description\n            //\n            if (m_eventConfDao.isSecureTag(\"descr\")) {\n                e.setDescr(null);\n            }\n            if (e.getDescr() == null && econf.getDescr() != null) {\n                e.setDescr(econf.getDescr());\n            }\n\n            // Copy the log message if any\n            //\n            if (m_eventConfDao.isSecureTag(\"logmsg\")) {\n                e.setLogmsg(null);\n            }\n            if (e.getLogmsg() == null && econf.getLogmsg() != null) {\n                e.setLogmsg(transform(econf.getLogmsg()));\n            }\n\n            // Copy the severity\n            //\n            if (m_eventConfDao.isSecureTag(\"severity\")) {\n                e.setSeverity(null);\n            }\n            if (e.getSeverity() == null && econf.getSeverity() != null) {\n                e.setSeverity(econf.getSeverity());\n            }\n\n            // Set the correlation information\n            //\n            if (m_eventConfDao.isSecureTag(\"correlation\")) {\n                e.setCorrelation(null);\n            }\n            if (e.getCorrelation() == null && econf.getCorrelation() != null) {\n                e.setCorrelation(transform(econf.getCorrelation()));\n            }\n\n            // Copy the operator instruction\n            //\n            if (m_eventConfDao.isSecureTag(\"operinstruct\")) {\n                e.setOperinstruct(null);\n            }\n            if (e.getOperinstruct() == null && econf.getOperinstruct() != null) {\n                e.setOperinstruct(econf.getOperinstruct());\n            }\n\n            // Copy the auto actions.\n            //\n            if (m_eventConfDao.isSecureTag(\"autoaction\")) {\n                e.removeAllAutoaction();\n            }\n            if (e.getAutoactionCount() == 0 && econf.getAutoactionCount() > 0) {\n                Enumeration<org.opennms.netmgt.xml.eventconf.Autoaction> eter = econf.enumerateAutoaction();\n                while (eter.hasMoreElements()) {\n                    org.opennms.netmgt.xml.eventconf.Autoaction src = eter.nextElement();\n                    e.addAutoaction(transform(src));\n                }\n            }\n\n            // Convert the operator actions\n            //\n            if (m_eventConfDao.isSecureTag(\"operaction\")) {\n                e.removeAllOperaction();\n            }\n            if (e.getOperactionCount() == 0 && econf.getOperactionCount() > 0) {\n                Enumeration<org.opennms.netmgt.xml.eventconf.Operaction> eter = econf.enumerateOperaction();\n                while (eter.hasMoreElements()) {\n                    org.opennms.netmgt.xml.eventconf.Operaction src = eter.nextElement();\n                    e.addOperaction(transform(src));\n                }\n            }\n\n            // Convert the auto acknowledgement\n            //\n            if (m_eventConfDao.isSecureTag(\"autoacknowledge\")) {\n                e.setAutoacknowledge(null);\n            }\n            if (e.getAutoacknowledge() == null && econf.getAutoacknowledge() != null) {\n                e.setAutoacknowledge(transform(econf.getAutoacknowledge()));\n            }\n\n            // Convert the log group information\n            //\n            if (m_eventConfDao.isSecureTag(\"loggroup\")) {\n                e.removeAllLoggroup();\n            }\n            if (e.getLoggroupCount() == 0 && econf.getLoggroupCount() > 0) {\n                e.setLoggroup(econf.getLoggroup());\n            }\n\n            // Convert the trouble tickets.\n            //\n            if (m_eventConfDao.isSecureTag(\"tticket\")) {\n                e.setTticket(null);\n            }\n            if (e.getTticket() == null && econf.getTticket() != null) {\n                e.setTticket(transform(econf.getTticket()));\n            }\n\n            // Convert the forward entry\n            //\n            if (m_eventConfDao.isSecureTag(\"forward\")) {\n                e.removeAllForward();\n            }\n            if (e.getForwardCount() == 0 && econf.getForwardCount() > 0) {\n                Enumeration<org.opennms.netmgt.xml.eventconf.Forward> eter = econf.enumerateForward();\n                while (eter.hasMoreElements()) {\n                    org.opennms.netmgt.xml.eventconf.Forward src = eter.nextElement();\n                    e.addForward(transform(src));\n                }\n            }\n\n            // Convert the script entry\n            //\n            if (m_eventConfDao.isSecureTag(\"script\")) {\n                e.removeAllScript();\n            }\n            if (e.getScriptCount() == 0 && econf.getScriptCount() > 0) {\n                Enumeration<org.opennms.netmgt.xml.eventconf.Script> eter = econf.enumerateScript();\n                while (eter.hasMoreElements()) {\n                    org.opennms.netmgt.xml.eventconf.Script src = eter.nextElement();\n                    e.addScript(transform(src));\n                }\n            }\n\n            // Copy the mouse over text\n            //\n            if (m_eventConfDao.isSecureTag(\"mouseovertext\")) {\n                e.setMouseovertext(null);\n            }\n            if (e.getMouseovertext() == null && econf.getMouseovertext() != null) {\n                e.setMouseovertext(econf.getMouseovertext());\n            }\n\n            // Copy the reductionKey\n            // TODO:  This isSecureTag call needs some research.  \"You keep using that word.  I don't think it means what you think it means.\"\n            //        It looks to me like there should be an else here.  I could be wrong.\n            if (m_eventConfDao.isSecureTag(\"reduction-key\") && m_eventConfDao.isSecureTag(\"alarm-type\") && m_eventConfDao.isSecureTag(\"clear-uei\")) {\n                e.setAlarmData(null);\n            }\n            \n            if (e.getAlarmData() == null && econf.getAlarmData() != null) {\n                AlarmData alarmData = new AlarmData();\n                alarmData.setAlarmType(econf.getAlarmData().getAlarmType());\n                alarmData.setReductionKey(econf.getAlarmData().getReductionKey());\n                alarmData.setClearUei(econf.getAlarmData().getClearUei());\n                alarmData.setAutoClean(econf.getAlarmData().getAutoClean());\n                alarmData.setX733AlarmType(econf.getAlarmData().getX733AlarmType());\n                alarmData.setX733ProbableCause(econf.getAlarmData().getX733ProbableCause());\n                alarmData.setClearKey(econf.getAlarmData().getClearKey());\n                e.setAlarmData(alarmData);\n            }\n\n        } \n        \n        Map<String, Map<String, String>> decode = new HashMap<String, Map<String,String>>();\n        if (econf != null && econf.getVarbindsdecode() != null) {\n           Varbindsdecode[] vardecodeArray = econf.getVarbindsdecode();\n           for (Varbindsdecode element : vardecodeArray) {\n               Decode[] decodeArray = element.getDecode();\n               Map<String, String> valueMap = new HashMap<String, String>();\n               for (Decode element2 : decodeArray) {\n                   valueMap.put(element2.getVarbindvalue(), element2.getVarbinddecodedstring());\n               }\n               decode.put(element.getParmid(), valueMap);\n           }\n        }// end fill of event using econf\n\n        // do the event parm expansion\n        expandParms(e, decode);\n\n    }","commit_id":"1e788c24db46ffe642c294adca9e6addd9d4766e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Expand parms in the event autoaction(s)\n     */\n    private void expandParms(Autoaction[] autoactions, Event event) {\n        boolean expanded = false;\n\n        for (int index = 0; index < autoactions.length; index++) {\n            Autoaction action = autoactions[index];\n\n            String strRet = EventUtil.expandParms(action.getContent(), event);\n            if (strRet != null) {\n                action.setContent(strRet);\n                expanded = true;\n            }\n        }\n\n        if (expanded)\n            event.setAutoaction(autoactions);\n    }","id":6964,"modified_method":"/**\n     * Expand parms in the event autoaction(s)\n     */\n    private void expandParms(Autoaction[] autoactions, Event event) {\n        boolean expanded = false;\n\n        for (Autoaction action : autoactions) {\n            String strRet = EventUtil.expandParms(action.getContent(), event);\n            if (strRet != null) {\n                action.setContent(strRet);\n                expanded = true;\n            }\n        }\n\n        if (expanded) {\n            event.setAutoaction(autoactions);\n        }\n    }","commit_id":"1e788c24db46ffe642c294adca9e6addd9d4766e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Expand parms in the event operaction(s)\n     */\n    private void expandParms(Operaction[] operactions, Event event) {\n        boolean expanded = false;\n\n        for (int index = 0; index < operactions.length; index++) {\n            Operaction action = operactions[index];\n\n            String strRet = EventUtil.expandParms(action.getContent(), event);\n            if (strRet != null) {\n                action.setContent(strRet);\n                expanded = true;\n            }\n        }\n\n        if (expanded)\n            event.setOperaction(operactions);\n    }","id":6965,"modified_method":"/**\n     * Expand parms in the event operaction(s)\n     */\n    private void expandParms(Operaction[] operactions, Event event) {\n        boolean expanded = false;\n\n        for (Operaction action : operactions) {\n            String strRet = EventUtil.expandParms(action.getContent(), event);\n            if (strRet != null) {\n                action.setContent(strRet);\n                expanded = true;\n            }\n        }\n\n        if (expanded) {\n            event.setOperaction(operactions);\n        }\n    }","commit_id":"ae7c88e8f80f822c69c7cb0b68ebd2587a7ef1c9","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>\n     * This method is invoked to check and configure a received event. The event\n     * configuration manager is consulted to find the appropriate configuration\n     * that is used to expand the event. In addition, the security parameters\n     * from the configuration manager is consulted to ensure that secure files\n     * are cleared out if necessary.\n     * <\/p>\n     * \n     * <p>\n     * Any secure fields that exists in the incomming event are cleared during\n     * expansion.\n     * <\/p>\n     * \n     * @param e\n     *            The event to expand if necesary.\n     * \n     */\n    public synchronized void expandEvent(Event e) {\n        org.opennms.netmgt.xml.eventconf.Event econf = lookup(e);\n\n        if (econf != null) {\n            if (m_eventConfDao.isSecureTag(\"mask\"))\n                e.setMask(null);\n            if (e.getMask() == null && econf.getMask() != null) {\n                e.setMask(transform(econf.getMask()));\n            }\n\n            // Copy the UEI\n            //\n            if (e.getUei() == null)\n                e.setUei(econf.getUei());\n\n            // Copy the Snmp Information\n            //\n            if (e.getSnmp() == null && econf.getSnmp() != null)\n                e.setSnmp(transform(econf.getSnmp()));\n\n            // Copy the description\n            //\n            if (m_eventConfDao.isSecureTag(\"descr\"))\n                e.setDescr(null);\n            if (e.getDescr() == null && econf.getDescr() != null)\n                e.setDescr(econf.getDescr());\n\n            // Copy the log message if any\n            //\n            if (m_eventConfDao.isSecureTag(\"logmsg\"))\n                e.setLogmsg(null);\n            if (e.getLogmsg() == null && econf.getLogmsg() != null)\n                e.setLogmsg(transform(econf.getLogmsg()));\n\n            // Copy the severity\n            //\n            if (m_eventConfDao.isSecureTag(\"severity\"))\n                e.setSeverity(null);\n            if (e.getSeverity() == null && econf.getSeverity() != null)\n                e.setSeverity(econf.getSeverity());\n\n            // Set the correlation information\n            //\n            if (m_eventConfDao.isSecureTag(\"correlation\"))\n                e.setCorrelation(null);\n            if (e.getCorrelation() == null && econf.getCorrelation() != null)\n                e.setCorrelation(transform(econf.getCorrelation()));\n\n            // Copy the operator instruction\n            //\n            if (m_eventConfDao.isSecureTag(\"operinstruct\"))\n                e.setOperinstruct(null);\n            if (e.getOperinstruct() == null && econf.getOperinstruct() != null)\n                e.setOperinstruct(econf.getOperinstruct());\n\n            // Copy the auto actions.\n            //\n            if (m_eventConfDao.isSecureTag(\"autoaction\"))\n                e.removeAllAutoaction();\n            if (e.getAutoactionCount() == 0 && econf.getAutoactionCount() > 0) {\n                Enumeration eter = econf.enumerateAutoaction();\n                while (eter.hasMoreElements()) {\n                    org.opennms.netmgt.xml.eventconf.Autoaction src = (org.opennms.netmgt.xml.eventconf.Autoaction) eter.nextElement();\n                    e.addAutoaction(transform(src));\n                }\n            }\n\n            // Convert the operator actions\n            //\n            if (m_eventConfDao.isSecureTag(\"operaction\"))\n                e.removeAllOperaction();\n            if (e.getOperactionCount() == 0 && econf.getOperactionCount() > 0) {\n                Enumeration eter = econf.enumerateOperaction();\n                while (eter.hasMoreElements()) {\n                    org.opennms.netmgt.xml.eventconf.Operaction src = (org.opennms.netmgt.xml.eventconf.Operaction) eter.nextElement();\n                    e.addOperaction(transform(src));\n                }\n            }\n\n            // Convert the auto acknowledgement\n            //\n            if (m_eventConfDao.isSecureTag(\"autoacknowledge\"))\n                e.setAutoacknowledge(null);\n            if (e.getAutoacknowledge() == null && econf.getAutoacknowledge() != null)\n                e.setAutoacknowledge(transform(econf.getAutoacknowledge()));\n\n            // Convert the log group information\n            //\n            if (m_eventConfDao.isSecureTag(\"loggroup\"))\n                e.removeAllLoggroup();\n            if (e.getLoggroupCount() == 0 && econf.getLoggroupCount() > 0)\n                e.setLoggroup(econf.getLoggroup());\n\n            // Convert the trouble tickets.\n            //\n            if (m_eventConfDao.isSecureTag(\"tticket\"))\n                e.setTticket(null);\n            if (e.getTticket() == null && econf.getTticket() != null)\n                e.setTticket(transform(econf.getTticket()));\n\n            // Convert the forward entry\n            //\n            if (m_eventConfDao.isSecureTag(\"forward\"))\n                e.removeAllForward();\n            if (e.getForwardCount() == 0 && econf.getForwardCount() > 0) {\n                Enumeration eter = econf.enumerateForward();\n                while (eter.hasMoreElements()) {\n                    org.opennms.netmgt.xml.eventconf.Forward src = (org.opennms.netmgt.xml.eventconf.Forward) eter.nextElement();\n                    e.addForward(transform(src));\n                }\n            }\n\n            // Convert the script entry\n            //\n            if (m_eventConfDao.isSecureTag(\"script\"))\n                e.removeAllScript();\n            if (e.getScriptCount() == 0 && econf.getScriptCount() > 0) {\n                Enumeration eter = econf.enumerateScript();\n                while (eter.hasMoreElements()) {\n                    org.opennms.netmgt.xml.eventconf.Script src = (org.opennms.netmgt.xml.eventconf.Script) eter.nextElement();\n                    e.addScript(transform(src));\n                }\n            }\n\n            // Copy the mouse over text\n            //\n            if (m_eventConfDao.isSecureTag(\"mouseovertext\"))\n                e.setMouseovertext(null);\n            if (e.getMouseovertext() == null && econf.getMouseovertext() != null)\n                e.setMouseovertext(econf.getMouseovertext());\n\n            // Copy the reductionKey\n            // TODO:  This isSecureTag call needs some research.  \"You keep using that word.  I don't think it means what you think it means.\"\n            //        It looks to me like there should be an else here.  I could be wrong.\n            if (m_eventConfDao.isSecureTag(\"reduction-key\") && m_eventConfDao.isSecureTag(\"alarm-type\") && m_eventConfDao.isSecureTag(\"clear-uei\"))\n                e.setAlarmData(null);\n            \n            if (e.getAlarmData() == null && econf.getAlarmData() != null) {\n                AlarmData alarmData = new AlarmData();\n                alarmData.setAlarmType(econf.getAlarmData().getAlarmType());\n                alarmData.setReductionKey(econf.getAlarmData().getReductionKey());\n                alarmData.setClearUei(econf.getAlarmData().getClearUei());\n                alarmData.setAutoClean(econf.getAlarmData().getAutoClean());\n                alarmData.setX733AlarmType(econf.getAlarmData().getX733AlarmType());\n                alarmData.setX733ProbableCause(econf.getAlarmData().getX733ProbableCause());\n                alarmData.setClearKey(econf.getAlarmData().getClearKey());\n                e.setAlarmData(alarmData);\n            }\n\n        } \n        \n        Map<String, Map<String, String>> decode = new HashMap<String, Map<String,String>>();\n        if (econf.getVarbindsdecode() != null) {\n           Varbindsdecode[] vardecodeArray = econf.getVarbindsdecode();\n           for (int i=0; i<vardecodeArray.length; i++) {\n               Decode[] decodeArray = vardecodeArray[i].getDecode();\n               Map<String, String> valueMap = new HashMap<String, String>();\n               for (int j=0; j<decodeArray.length;j++) {\n                   valueMap.put(decodeArray[j].getVarbindvalue(), decodeArray[j].getVarbinddecodedstring());\n               }\n               decode.put(vardecodeArray[i].getParmid(), valueMap);\n           }\n        }// end fill of event using econf\n\n        // do the event parm expansion\n        expandParms(e, decode);\n\n    }","id":6966,"modified_method":"/**\n     * <p>\n     * This method is invoked to check and configure a received event. The event\n     * configuration manager is consulted to find the appropriate configuration\n     * that is used to expand the event. In addition, the security parameters\n     * from the configuration manager is consulted to ensure that secure files\n     * are cleared out if necessary.\n     * <\/p>\n     * \n     * <p>\n     * Any secure fields that exists in the incomming event are cleared during\n     * expansion.\n     * <\/p>\n     * \n     * @param e\n     *            The event to expand if necesary.\n     * \n     */\n    public synchronized void expandEvent(Event e) {\n        org.opennms.netmgt.xml.eventconf.Event econf = lookup(e);\n\n        if (econf != null) {\n            if (m_eventConfDao.isSecureTag(\"mask\")) {\n                e.setMask(null);\n            }\n            if (e.getMask() == null && econf.getMask() != null) {\n                e.setMask(transform(econf.getMask()));\n            }\n\n            // Copy the UEI\n            //\n            if (e.getUei() == null) {\n                e.setUei(econf.getUei());\n            }\n\n            // Copy the Snmp Information\n            //\n            if (e.getSnmp() == null && econf.getSnmp() != null) {\n                e.setSnmp(transform(econf.getSnmp()));\n            }\n\n            // Copy the description\n            //\n            if (m_eventConfDao.isSecureTag(\"descr\")) {\n                e.setDescr(null);\n            }\n            if (e.getDescr() == null && econf.getDescr() != null) {\n                e.setDescr(econf.getDescr());\n            }\n\n            // Copy the log message if any\n            //\n            if (m_eventConfDao.isSecureTag(\"logmsg\")) {\n                e.setLogmsg(null);\n            }\n            if (e.getLogmsg() == null && econf.getLogmsg() != null) {\n                e.setLogmsg(transform(econf.getLogmsg()));\n            }\n\n            // Copy the severity\n            //\n            if (m_eventConfDao.isSecureTag(\"severity\")) {\n                e.setSeverity(null);\n            }\n            if (e.getSeverity() == null && econf.getSeverity() != null) {\n                e.setSeverity(econf.getSeverity());\n            }\n\n            // Set the correlation information\n            //\n            if (m_eventConfDao.isSecureTag(\"correlation\")) {\n                e.setCorrelation(null);\n            }\n            if (e.getCorrelation() == null && econf.getCorrelation() != null) {\n                e.setCorrelation(transform(econf.getCorrelation()));\n            }\n\n            // Copy the operator instruction\n            //\n            if (m_eventConfDao.isSecureTag(\"operinstruct\")) {\n                e.setOperinstruct(null);\n            }\n            if (e.getOperinstruct() == null && econf.getOperinstruct() != null) {\n                e.setOperinstruct(econf.getOperinstruct());\n            }\n\n            // Copy the auto actions.\n            //\n            if (m_eventConfDao.isSecureTag(\"autoaction\")) {\n                e.removeAllAutoaction();\n            }\n            if (e.getAutoactionCount() == 0 && econf.getAutoactionCount() > 0) {\n                Enumeration<org.opennms.netmgt.xml.eventconf.Autoaction> eter = econf.enumerateAutoaction();\n                while (eter.hasMoreElements()) {\n                    org.opennms.netmgt.xml.eventconf.Autoaction src = eter.nextElement();\n                    e.addAutoaction(transform(src));\n                }\n            }\n\n            // Convert the operator actions\n            //\n            if (m_eventConfDao.isSecureTag(\"operaction\")) {\n                e.removeAllOperaction();\n            }\n            if (e.getOperactionCount() == 0 && econf.getOperactionCount() > 0) {\n                Enumeration<org.opennms.netmgt.xml.eventconf.Operaction> eter = econf.enumerateOperaction();\n                while (eter.hasMoreElements()) {\n                    org.opennms.netmgt.xml.eventconf.Operaction src = eter.nextElement();\n                    e.addOperaction(transform(src));\n                }\n            }\n\n            // Convert the auto acknowledgement\n            //\n            if (m_eventConfDao.isSecureTag(\"autoacknowledge\")) {\n                e.setAutoacknowledge(null);\n            }\n            if (e.getAutoacknowledge() == null && econf.getAutoacknowledge() != null) {\n                e.setAutoacknowledge(transform(econf.getAutoacknowledge()));\n            }\n\n            // Convert the log group information\n            //\n            if (m_eventConfDao.isSecureTag(\"loggroup\")) {\n                e.removeAllLoggroup();\n            }\n            if (e.getLoggroupCount() == 0 && econf.getLoggroupCount() > 0) {\n                e.setLoggroup(econf.getLoggroup());\n            }\n\n            // Convert the trouble tickets.\n            //\n            if (m_eventConfDao.isSecureTag(\"tticket\")) {\n                e.setTticket(null);\n            }\n            if (e.getTticket() == null && econf.getTticket() != null) {\n                e.setTticket(transform(econf.getTticket()));\n            }\n\n            // Convert the forward entry\n            //\n            if (m_eventConfDao.isSecureTag(\"forward\")) {\n                e.removeAllForward();\n            }\n            if (e.getForwardCount() == 0 && econf.getForwardCount() > 0) {\n                Enumeration<org.opennms.netmgt.xml.eventconf.Forward> eter = econf.enumerateForward();\n                while (eter.hasMoreElements()) {\n                    org.opennms.netmgt.xml.eventconf.Forward src = eter.nextElement();\n                    e.addForward(transform(src));\n                }\n            }\n\n            // Convert the script entry\n            //\n            if (m_eventConfDao.isSecureTag(\"script\")) {\n                e.removeAllScript();\n            }\n            if (e.getScriptCount() == 0 && econf.getScriptCount() > 0) {\n                Enumeration<org.opennms.netmgt.xml.eventconf.Script> eter = econf.enumerateScript();\n                while (eter.hasMoreElements()) {\n                    org.opennms.netmgt.xml.eventconf.Script src = eter.nextElement();\n                    e.addScript(transform(src));\n                }\n            }\n\n            // Copy the mouse over text\n            //\n            if (m_eventConfDao.isSecureTag(\"mouseovertext\")) {\n                e.setMouseovertext(null);\n            }\n            if (e.getMouseovertext() == null && econf.getMouseovertext() != null) {\n                e.setMouseovertext(econf.getMouseovertext());\n            }\n\n            // Copy the reductionKey\n            // TODO:  This isSecureTag call needs some research.  \"You keep using that word.  I don't think it means what you think it means.\"\n            //        It looks to me like there should be an else here.  I could be wrong.\n            if (m_eventConfDao.isSecureTag(\"reduction-key\") && m_eventConfDao.isSecureTag(\"alarm-type\") && m_eventConfDao.isSecureTag(\"clear-uei\")) {\n                e.setAlarmData(null);\n            }\n            \n            if (e.getAlarmData() == null && econf.getAlarmData() != null) {\n                AlarmData alarmData = new AlarmData();\n                alarmData.setAlarmType(econf.getAlarmData().getAlarmType());\n                alarmData.setReductionKey(econf.getAlarmData().getReductionKey());\n                alarmData.setClearUei(econf.getAlarmData().getClearUei());\n                alarmData.setAutoClean(econf.getAlarmData().getAutoClean());\n                alarmData.setX733AlarmType(econf.getAlarmData().getX733AlarmType());\n                alarmData.setX733ProbableCause(econf.getAlarmData().getX733ProbableCause());\n                alarmData.setClearKey(econf.getAlarmData().getClearKey());\n                e.setAlarmData(alarmData);\n            }\n\n        } \n        \n        Map<String, Map<String, String>> decode = new HashMap<String, Map<String,String>>();\n        if (econf != null && econf.getVarbindsdecode() != null) {\n           Varbindsdecode[] vardecodeArray = econf.getVarbindsdecode();\n           for (Varbindsdecode element : vardecodeArray) {\n               Decode[] decodeArray = element.getDecode();\n               Map<String, String> valueMap = new HashMap<String, String>();\n               for (Decode element2 : decodeArray) {\n                   valueMap.put(element2.getVarbindvalue(), element2.getVarbinddecodedstring());\n               }\n               decode.put(element.getParmid(), valueMap);\n           }\n        }// end fill of event using econf\n\n        // do the event parm expansion\n        expandParms(e, decode);\n\n    }","commit_id":"ae7c88e8f80f822c69c7cb0b68ebd2587a7ef1c9","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Expand parms in the event autoaction(s)\n     */\n    private void expandParms(Autoaction[] autoactions, Event event) {\n        boolean expanded = false;\n\n        for (int index = 0; index < autoactions.length; index++) {\n            Autoaction action = autoactions[index];\n\n            String strRet = EventUtil.expandParms(action.getContent(), event);\n            if (strRet != null) {\n                action.setContent(strRet);\n                expanded = true;\n            }\n        }\n\n        if (expanded)\n            event.setAutoaction(autoactions);\n    }","id":6967,"modified_method":"/**\n     * Expand parms in the event autoaction(s)\n     */\n    private void expandParms(Autoaction[] autoactions, Event event) {\n        boolean expanded = false;\n\n        for (Autoaction action : autoactions) {\n            String strRet = EventUtil.expandParms(action.getContent(), event);\n            if (strRet != null) {\n                action.setContent(strRet);\n                expanded = true;\n            }\n        }\n\n        if (expanded) {\n            event.setAutoaction(autoactions);\n        }\n    }","commit_id":"ae7c88e8f80f822c69c7cb0b68ebd2587a7ef1c9","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is used to transform an event configuration mask instance\n     * into an event mask instance. This is used when the incomming event does\n     * not have a mask and the information from the configuration object is\n     * copied.\n     * \n     * @param src\n     *            The configuration source to transform.\n     * \n     * @return The transformed mask information.\n     * \n     */\n    private org.opennms.netmgt.xml.event.Mask transform(org.opennms.netmgt.xml.eventconf.Mask src) {\n        org.opennms.netmgt.xml.event.Mask dest = new org.opennms.netmgt.xml.event.Mask();\n\n        Enumeration en = src.enumerateMaskelement();\n        while (en.hasMoreElements()) {\n            org.opennms.netmgt.xml.eventconf.Maskelement confme = (org.opennms.netmgt.xml.eventconf.Maskelement) en.nextElement();\n\n            // create new mask element\n            org.opennms.netmgt.xml.event.Maskelement me = new org.opennms.netmgt.xml.event.Maskelement();\n            // set name\n            me.setMename(confme.getMename());\n            // set values\n            String[] confmevalues = confme.getMevalue();\n            for (int index = 0; index < confmevalues.length; index++) {\n                me.addMevalue(confmevalues[index]);\n            }\n\n            dest.addMaskelement(me);\n        }\n\n        return dest;\n    }","id":6968,"modified_method":"/**\n     * This method is used to transform an event configuration mask instance\n     * into an event mask instance. This is used when the incomming event does\n     * not have a mask and the information from the configuration object is\n     * copied.\n     * \n     * @param src\n     *            The configuration source to transform.\n     * \n     * @return The transformed mask information.\n     * \n     */\n    private org.opennms.netmgt.xml.event.Mask transform(org.opennms.netmgt.xml.eventconf.Mask src) {\n        org.opennms.netmgt.xml.event.Mask dest = new org.opennms.netmgt.xml.event.Mask();\n\n        Enumeration<Maskelement> en = src.enumerateMaskelement();\n        while (en.hasMoreElements()) {\n            org.opennms.netmgt.xml.eventconf.Maskelement confme = en.nextElement();\n\n            // create new mask element\n            org.opennms.netmgt.xml.event.Maskelement me = new org.opennms.netmgt.xml.event.Maskelement();\n            // set name\n            me.setMename(confme.getMename());\n            // set values\n            String[] confmevalues = confme.getMevalue();\n            for (String confmevalue : confmevalues) {\n                me.addMevalue(confmevalue);\n            }\n\n            dest.addMaskelement(me);\n        }\n\n        return dest;\n    }","commit_id":"ae7c88e8f80f822c69c7cb0b68ebd2587a7ef1c9","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Expand parms in the event operaction(s)\n     */\n    private void expandParms(Operaction[] operactions, Event event) {\n        boolean expanded = false;\n\n        for (int index = 0; index < operactions.length; index++) {\n            Operaction action = operactions[index];\n\n            String strRet = EventUtil.expandParms(action.getContent(), event);\n            if (strRet != null) {\n                action.setContent(strRet);\n                expanded = true;\n            }\n        }\n\n        if (expanded)\n            event.setOperaction(operactions);\n    }","id":6969,"modified_method":"/**\n     * Expand parms in the event operaction(s)\n     */\n    private void expandParms(Operaction[] operactions, Event event) {\n        boolean expanded = false;\n\n        for (Operaction action : operactions) {\n            String strRet = EventUtil.expandParms(action.getContent(), event);\n            if (strRet != null) {\n                action.setContent(strRet);\n                expanded = true;\n            }\n        }\n\n        if (expanded) {\n            event.setOperaction(operactions);\n        }\n    }","commit_id":"49c27d34e1ba86959255a3430a6c3ba28cebd642","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Expand parms in the event autoaction(s)\n     */\n    private void expandParms(Autoaction[] autoactions, Event event) {\n        boolean expanded = false;\n\n        for (int index = 0; index < autoactions.length; index++) {\n            Autoaction action = autoactions[index];\n\n            String strRet = EventUtil.expandParms(action.getContent(), event);\n            if (strRet != null) {\n                action.setContent(strRet);\n                expanded = true;\n            }\n        }\n\n        if (expanded)\n            event.setAutoaction(autoactions);\n    }","id":6970,"modified_method":"/**\n     * Expand parms in the event autoaction(s)\n     */\n    private void expandParms(Autoaction[] autoactions, Event event) {\n        boolean expanded = false;\n\n        for (Autoaction action : autoactions) {\n            String strRet = EventUtil.expandParms(action.getContent(), event);\n            if (strRet != null) {\n                action.setContent(strRet);\n                expanded = true;\n            }\n        }\n\n        if (expanded) {\n            event.setAutoaction(autoactions);\n        }\n    }","commit_id":"49c27d34e1ba86959255a3430a6c3ba28cebd642","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>\n     * This method is invoked to check and configure a received event. The event\n     * configuration manager is consulted to find the appropriate configuration\n     * that is used to expand the event. In addition, the security parameters\n     * from the configuration manager is consulted to ensure that secure files\n     * are cleared out if necessary.\n     * <\/p>\n     * \n     * <p>\n     * Any secure fields that exists in the incomming event are cleared during\n     * expansion.\n     * <\/p>\n     * \n     * @param e\n     *            The event to expand if necesary.\n     * \n     */\n    public synchronized void expandEvent(Event e) {\n        org.opennms.netmgt.xml.eventconf.Event econf = lookup(e);\n\n        if (econf != null) {\n            if (m_eventConfDao.isSecureTag(\"mask\"))\n                e.setMask(null);\n            if (e.getMask() == null && econf.getMask() != null) {\n                e.setMask(transform(econf.getMask()));\n            }\n\n            // Copy the UEI\n            //\n            if (e.getUei() == null)\n                e.setUei(econf.getUei());\n\n            // Copy the Snmp Information\n            //\n            if (e.getSnmp() == null && econf.getSnmp() != null)\n                e.setSnmp(transform(econf.getSnmp()));\n\n            // Copy the description\n            //\n            if (m_eventConfDao.isSecureTag(\"descr\"))\n                e.setDescr(null);\n            if (e.getDescr() == null && econf.getDescr() != null)\n                e.setDescr(econf.getDescr());\n\n            // Copy the log message if any\n            //\n            if (m_eventConfDao.isSecureTag(\"logmsg\"))\n                e.setLogmsg(null);\n            if (e.getLogmsg() == null && econf.getLogmsg() != null)\n                e.setLogmsg(transform(econf.getLogmsg()));\n\n            // Copy the severity\n            //\n            if (m_eventConfDao.isSecureTag(\"severity\"))\n                e.setSeverity(null);\n            if (e.getSeverity() == null && econf.getSeverity() != null)\n                e.setSeverity(econf.getSeverity());\n\n            // Set the correlation information\n            //\n            if (m_eventConfDao.isSecureTag(\"correlation\"))\n                e.setCorrelation(null);\n            if (e.getCorrelation() == null && econf.getCorrelation() != null)\n                e.setCorrelation(transform(econf.getCorrelation()));\n\n            // Copy the operator instruction\n            //\n            if (m_eventConfDao.isSecureTag(\"operinstruct\"))\n                e.setOperinstruct(null);\n            if (e.getOperinstruct() == null && econf.getOperinstruct() != null)\n                e.setOperinstruct(econf.getOperinstruct());\n\n            // Copy the auto actions.\n            //\n            if (m_eventConfDao.isSecureTag(\"autoaction\"))\n                e.removeAllAutoaction();\n            if (e.getAutoactionCount() == 0 && econf.getAutoactionCount() > 0) {\n                Enumeration eter = econf.enumerateAutoaction();\n                while (eter.hasMoreElements()) {\n                    org.opennms.netmgt.xml.eventconf.Autoaction src = (org.opennms.netmgt.xml.eventconf.Autoaction) eter.nextElement();\n                    e.addAutoaction(transform(src));\n                }\n            }\n\n            // Convert the operator actions\n            //\n            if (m_eventConfDao.isSecureTag(\"operaction\"))\n                e.removeAllOperaction();\n            if (e.getOperactionCount() == 0 && econf.getOperactionCount() > 0) {\n                Enumeration eter = econf.enumerateOperaction();\n                while (eter.hasMoreElements()) {\n                    org.opennms.netmgt.xml.eventconf.Operaction src = (org.opennms.netmgt.xml.eventconf.Operaction) eter.nextElement();\n                    e.addOperaction(transform(src));\n                }\n            }\n\n            // Convert the auto acknowledgement\n            //\n            if (m_eventConfDao.isSecureTag(\"autoacknowledge\"))\n                e.setAutoacknowledge(null);\n            if (e.getAutoacknowledge() == null && econf.getAutoacknowledge() != null)\n                e.setAutoacknowledge(transform(econf.getAutoacknowledge()));\n\n            // Convert the log group information\n            //\n            if (m_eventConfDao.isSecureTag(\"loggroup\"))\n                e.removeAllLoggroup();\n            if (e.getLoggroupCount() == 0 && econf.getLoggroupCount() > 0)\n                e.setLoggroup(econf.getLoggroup());\n\n            // Convert the trouble tickets.\n            //\n            if (m_eventConfDao.isSecureTag(\"tticket\"))\n                e.setTticket(null);\n            if (e.getTticket() == null && econf.getTticket() != null)\n                e.setTticket(transform(econf.getTticket()));\n\n            // Convert the forward entry\n            //\n            if (m_eventConfDao.isSecureTag(\"forward\"))\n                e.removeAllForward();\n            if (e.getForwardCount() == 0 && econf.getForwardCount() > 0) {\n                Enumeration eter = econf.enumerateForward();\n                while (eter.hasMoreElements()) {\n                    org.opennms.netmgt.xml.eventconf.Forward src = (org.opennms.netmgt.xml.eventconf.Forward) eter.nextElement();\n                    e.addForward(transform(src));\n                }\n            }\n\n            // Convert the script entry\n            //\n            if (m_eventConfDao.isSecureTag(\"script\"))\n                e.removeAllScript();\n            if (e.getScriptCount() == 0 && econf.getScriptCount() > 0) {\n                Enumeration eter = econf.enumerateScript();\n                while (eter.hasMoreElements()) {\n                    org.opennms.netmgt.xml.eventconf.Script src = (org.opennms.netmgt.xml.eventconf.Script) eter.nextElement();\n                    e.addScript(transform(src));\n                }\n            }\n\n            // Copy the mouse over text\n            //\n            if (m_eventConfDao.isSecureTag(\"mouseovertext\"))\n                e.setMouseovertext(null);\n            if (e.getMouseovertext() == null && econf.getMouseovertext() != null)\n                e.setMouseovertext(econf.getMouseovertext());\n\n            // Copy the reductionKey\n            // TODO:  This isSecureTag call needs some research.  \"You keep using that word.  I don't think it means what you think it means.\"\n            //        It looks to me like there should be an else here.  I could be wrong.\n            if (m_eventConfDao.isSecureTag(\"reduction-key\") && m_eventConfDao.isSecureTag(\"alarm-type\") && m_eventConfDao.isSecureTag(\"clear-uei\"))\n                e.setAlarmData(null);\n            \n            if (e.getAlarmData() == null && econf.getAlarmData() != null) {\n                AlarmData alarmData = new AlarmData();\n                alarmData.setAlarmType(econf.getAlarmData().getAlarmType());\n                alarmData.setReductionKey(econf.getAlarmData().getReductionKey());\n                alarmData.setClearUei(econf.getAlarmData().getClearUei());\n                alarmData.setAutoClean(econf.getAlarmData().getAutoClean());\n                alarmData.setX733AlarmType(econf.getAlarmData().getX733AlarmType());\n                alarmData.setX733ProbableCause(econf.getAlarmData().getX733ProbableCause());\n                alarmData.setClearKey(econf.getAlarmData().getClearKey());\n                e.setAlarmData(alarmData);\n            }\n\n        } \n        \n        Map<String, Map<String, String>> decode = new HashMap<String, Map<String,String>>();\n        if (econf.getVarbindsdecode() != null) {\n           Varbindsdecode[] vardecodeArray = econf.getVarbindsdecode();\n           for (int i=0; i<vardecodeArray.length; i++) {\n               Decode[] decodeArray = vardecodeArray[i].getDecode();\n               Map<String, String> valueMap = new HashMap<String, String>();\n               for (int j=0; j<decodeArray.length;j++) {\n                   valueMap.put(decodeArray[j].getVarbindvalue(), decodeArray[j].getVarbinddecodedstring());\n               }\n               decode.put(vardecodeArray[i].getParmid(), valueMap);\n           }\n        }// end fill of event using econf\n\n        // do the event parm expansion\n        expandParms(e, decode);\n\n    }","id":6971,"modified_method":"/**\n     * <p>\n     * This method is invoked to check and configure a received event. The event\n     * configuration manager is consulted to find the appropriate configuration\n     * that is used to expand the event. In addition, the security parameters\n     * from the configuration manager is consulted to ensure that secure files\n     * are cleared out if necessary.\n     * <\/p>\n     * \n     * <p>\n     * Any secure fields that exists in the incomming event are cleared during\n     * expansion.\n     * <\/p>\n     * \n     * @param e\n     *            The event to expand if necesary.\n     * \n     */\n    public synchronized void expandEvent(Event e) {\n        org.opennms.netmgt.xml.eventconf.Event econf = lookup(e);\n\n        if (econf != null) {\n            if (m_eventConfDao.isSecureTag(\"mask\")) {\n                e.setMask(null);\n            }\n            if (e.getMask() == null && econf.getMask() != null) {\n                e.setMask(transform(econf.getMask()));\n            }\n\n            // Copy the UEI\n            //\n            if (e.getUei() == null) {\n                e.setUei(econf.getUei());\n            }\n\n            // Copy the Snmp Information\n            //\n            if (e.getSnmp() == null && econf.getSnmp() != null) {\n                e.setSnmp(transform(econf.getSnmp()));\n            }\n\n            // Copy the description\n            //\n            if (m_eventConfDao.isSecureTag(\"descr\")) {\n                e.setDescr(null);\n            }\n            if (e.getDescr() == null && econf.getDescr() != null) {\n                e.setDescr(econf.getDescr());\n            }\n\n            // Copy the log message if any\n            //\n            if (m_eventConfDao.isSecureTag(\"logmsg\")) {\n                e.setLogmsg(null);\n            }\n            if (e.getLogmsg() == null && econf.getLogmsg() != null) {\n                e.setLogmsg(transform(econf.getLogmsg()));\n            }\n\n            // Copy the severity\n            //\n            if (m_eventConfDao.isSecureTag(\"severity\")) {\n                e.setSeverity(null);\n            }\n            if (e.getSeverity() == null && econf.getSeverity() != null) {\n                e.setSeverity(econf.getSeverity());\n            }\n\n            // Set the correlation information\n            //\n            if (m_eventConfDao.isSecureTag(\"correlation\")) {\n                e.setCorrelation(null);\n            }\n            if (e.getCorrelation() == null && econf.getCorrelation() != null) {\n                e.setCorrelation(transform(econf.getCorrelation()));\n            }\n\n            // Copy the operator instruction\n            //\n            if (m_eventConfDao.isSecureTag(\"operinstruct\")) {\n                e.setOperinstruct(null);\n            }\n            if (e.getOperinstruct() == null && econf.getOperinstruct() != null) {\n                e.setOperinstruct(econf.getOperinstruct());\n            }\n\n            // Copy the auto actions.\n            //\n            if (m_eventConfDao.isSecureTag(\"autoaction\")) {\n                e.removeAllAutoaction();\n            }\n            if (e.getAutoactionCount() == 0 && econf.getAutoactionCount() > 0) {\n                Enumeration<org.opennms.netmgt.xml.eventconf.Autoaction> eter = econf.enumerateAutoaction();\n                while (eter.hasMoreElements()) {\n                    org.opennms.netmgt.xml.eventconf.Autoaction src = eter.nextElement();\n                    e.addAutoaction(transform(src));\n                }\n            }\n\n            // Convert the operator actions\n            //\n            if (m_eventConfDao.isSecureTag(\"operaction\")) {\n                e.removeAllOperaction();\n            }\n            if (e.getOperactionCount() == 0 && econf.getOperactionCount() > 0) {\n                Enumeration<org.opennms.netmgt.xml.eventconf.Operaction> eter = econf.enumerateOperaction();\n                while (eter.hasMoreElements()) {\n                    org.opennms.netmgt.xml.eventconf.Operaction src = eter.nextElement();\n                    e.addOperaction(transform(src));\n                }\n            }\n\n            // Convert the auto acknowledgement\n            //\n            if (m_eventConfDao.isSecureTag(\"autoacknowledge\")) {\n                e.setAutoacknowledge(null);\n            }\n            if (e.getAutoacknowledge() == null && econf.getAutoacknowledge() != null) {\n                e.setAutoacknowledge(transform(econf.getAutoacknowledge()));\n            }\n\n            // Convert the log group information\n            //\n            if (m_eventConfDao.isSecureTag(\"loggroup\")) {\n                e.removeAllLoggroup();\n            }\n            if (e.getLoggroupCount() == 0 && econf.getLoggroupCount() > 0) {\n                e.setLoggroup(econf.getLoggroup());\n            }\n\n            // Convert the trouble tickets.\n            //\n            if (m_eventConfDao.isSecureTag(\"tticket\")) {\n                e.setTticket(null);\n            }\n            if (e.getTticket() == null && econf.getTticket() != null) {\n                e.setTticket(transform(econf.getTticket()));\n            }\n\n            // Convert the forward entry\n            //\n            if (m_eventConfDao.isSecureTag(\"forward\")) {\n                e.removeAllForward();\n            }\n            if (e.getForwardCount() == 0 && econf.getForwardCount() > 0) {\n                Enumeration<org.opennms.netmgt.xml.eventconf.Forward> eter = econf.enumerateForward();\n                while (eter.hasMoreElements()) {\n                    org.opennms.netmgt.xml.eventconf.Forward src = eter.nextElement();\n                    e.addForward(transform(src));\n                }\n            }\n\n            // Convert the script entry\n            //\n            if (m_eventConfDao.isSecureTag(\"script\")) {\n                e.removeAllScript();\n            }\n            if (e.getScriptCount() == 0 && econf.getScriptCount() > 0) {\n                Enumeration<org.opennms.netmgt.xml.eventconf.Script> eter = econf.enumerateScript();\n                while (eter.hasMoreElements()) {\n                    org.opennms.netmgt.xml.eventconf.Script src = eter.nextElement();\n                    e.addScript(transform(src));\n                }\n            }\n\n            // Copy the mouse over text\n            //\n            if (m_eventConfDao.isSecureTag(\"mouseovertext\")) {\n                e.setMouseovertext(null);\n            }\n            if (e.getMouseovertext() == null && econf.getMouseovertext() != null) {\n                e.setMouseovertext(econf.getMouseovertext());\n            }\n\n            // Copy the reductionKey\n            // TODO:  This isSecureTag call needs some research.  \"You keep using that word.  I don't think it means what you think it means.\"\n            //        It looks to me like there should be an else here.  I could be wrong.\n            if (m_eventConfDao.isSecureTag(\"reduction-key\") && m_eventConfDao.isSecureTag(\"alarm-type\") && m_eventConfDao.isSecureTag(\"clear-uei\")) {\n                e.setAlarmData(null);\n            }\n            \n            if (e.getAlarmData() == null && econf.getAlarmData() != null) {\n                AlarmData alarmData = new AlarmData();\n                alarmData.setAlarmType(econf.getAlarmData().getAlarmType());\n                alarmData.setReductionKey(econf.getAlarmData().getReductionKey());\n                alarmData.setClearUei(econf.getAlarmData().getClearUei());\n                alarmData.setAutoClean(econf.getAlarmData().getAutoClean());\n                alarmData.setX733AlarmType(econf.getAlarmData().getX733AlarmType());\n                alarmData.setX733ProbableCause(econf.getAlarmData().getX733ProbableCause());\n                alarmData.setClearKey(econf.getAlarmData().getClearKey());\n                e.setAlarmData(alarmData);\n            }\n\n        } \n        \n        Map<String, Map<String, String>> decode = new HashMap<String, Map<String,String>>();\n        if (econf != null && econf.getVarbindsdecode() != null) {\n           Varbindsdecode[] vardecodeArray = econf.getVarbindsdecode();\n           for (Varbindsdecode element : vardecodeArray) {\n               Decode[] decodeArray = element.getDecode();\n               Map<String, String> valueMap = new HashMap<String, String>();\n               for (Decode element2 : decodeArray) {\n                   valueMap.put(element2.getVarbindvalue(), element2.getVarbinddecodedstring());\n               }\n               decode.put(element.getParmid(), valueMap);\n           }\n        }// end fill of event using econf\n\n        // do the event parm expansion\n        expandParms(e, decode);\n\n    }","commit_id":"49c27d34e1ba86959255a3430a6c3ba28cebd642","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is used to transform an event configuration mask instance\n     * into an event mask instance. This is used when the incomming event does\n     * not have a mask and the information from the configuration object is\n     * copied.\n     * \n     * @param src\n     *            The configuration source to transform.\n     * \n     * @return The transformed mask information.\n     * \n     */\n    private org.opennms.netmgt.xml.event.Mask transform(org.opennms.netmgt.xml.eventconf.Mask src) {\n        org.opennms.netmgt.xml.event.Mask dest = new org.opennms.netmgt.xml.event.Mask();\n\n        Enumeration en = src.enumerateMaskelement();\n        while (en.hasMoreElements()) {\n            org.opennms.netmgt.xml.eventconf.Maskelement confme = (org.opennms.netmgt.xml.eventconf.Maskelement) en.nextElement();\n\n            // create new mask element\n            org.opennms.netmgt.xml.event.Maskelement me = new org.opennms.netmgt.xml.event.Maskelement();\n            // set name\n            me.setMename(confme.getMename());\n            // set values\n            String[] confmevalues = confme.getMevalue();\n            for (int index = 0; index < confmevalues.length; index++) {\n                me.addMevalue(confmevalues[index]);\n            }\n\n            dest.addMaskelement(me);\n        }\n\n        return dest;\n    }","id":6972,"modified_method":"/**\n     * This method is used to transform an event configuration mask instance\n     * into an event mask instance. This is used when the incomming event does\n     * not have a mask and the information from the configuration object is\n     * copied.\n     * \n     * @param src\n     *            The configuration source to transform.\n     * \n     * @return The transformed mask information.\n     * \n     */\n    private org.opennms.netmgt.xml.event.Mask transform(org.opennms.netmgt.xml.eventconf.Mask src) {\n        org.opennms.netmgt.xml.event.Mask dest = new org.opennms.netmgt.xml.event.Mask();\n\n        Enumeration<Maskelement> en = src.enumerateMaskelement();\n        while (en.hasMoreElements()) {\n            org.opennms.netmgt.xml.eventconf.Maskelement confme = en.nextElement();\n\n            // create new mask element\n            org.opennms.netmgt.xml.event.Maskelement me = new org.opennms.netmgt.xml.event.Maskelement();\n            // set name\n            me.setMename(confme.getMename());\n            // set values\n            String[] confmevalues = confme.getMevalue();\n            for (String confmevalue : confmevalues) {\n                me.addMevalue(confmevalue);\n            }\n\n            dest.addMaskelement(me);\n        }\n\n        return dest;\n    }","commit_id":"49c27d34e1ba86959255a3430a6c3ba28cebd642","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * The method that inserts the event into the database\n     * \n     * @param eventHeader\n     *            the event header\n     * @param event\n     *            the actual event to be inserted\n     */\n    public void persistAlarm(Header eventHeader, Event event) throws SQLException {\n        if (event != null) {\n            Category log = ThreadCategory.getInstance(AlarmWriter.class);\n\n            // Check value of <logmsg> attribute 'dest', if set to\n            // \"donotpersist\" then simply return, the uei is not to be\n            // persisted to the database\n            String logdest = event.getLogmsg().getDest();\n            if (logdest.equals(\"donotpersist\") || event.getAlarmData() == null) {\n                log.debug(\"AlarmWriter: uei '\" + event.getUei() + \"' marked as 'doNotPersist' or reductionKey is null.\");\n                return;\n            } else {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"AlarmWriter dbRun for : \" + event.getUei() + \" nodeid: \" + event.getNodeid() + \" ipaddr: \" + event.getInterface() + \" serviceid: \" + event.getService());\n                }\n            }\n\n            /*\n             * Try twice incase the transaction fails.  This could happen if 2 or more threads query the db\n             * at the same time and determine that insert needs to happen.  One insert will complete the other\n             * will fail.  The next time through the loop, the alarm will be reduced with an update. \n             */\n            int attempt = 1;\n            boolean notUpdated = true;\n            while (attempt <= 2 && notUpdated) {\n                try {\n                    insertOrUpdateAlarm(eventHeader, event);\n                    m_dsConn.commit();\n                    notUpdated = false;\n                } catch (SQLException e) {\n                    try {\n                        m_dsConn.rollback();\n                        m_dsConn.setAutoCommit(false);\n                    } catch (Exception e2) {\n                        log.warn(\"Rollback of transaction failed!\", e2);\n                    }\n                    if (attempt > 1) {\n                        log.warn(\"Error in attempt: \"+attempt+\" inserting alarm into the datastore\", e);\n                        throw e;\n                    } else {\n                        log.info(\"Retrying insertOrUpdate statement after first attempt: \"+ e.getMessage());\n                    }\n                }\n                attempt++;\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(\"AlarmWriter finished for : \" + event.getUei());\n        }\n    }","id":6973,"modified_method":"/**\n     * The method that inserts the event into the database\n     * \n     * @param eventHeader\n     *            the event header\n     * @param event\n     *            the actual event to be inserted\n     */\n    public void persistAlarm(Header eventHeader, Event event) throws SQLException {\n        if (event != null) {\n            // Check value of <logmsg> attribute 'dest', if set to\n            // \"donotpersist\" then simply return, the uei is not to be\n            // persisted to the database\n            String logdest = event.getLogmsg().getDest();\n            if (logdest.equals(\"donotpersist\") || event.getAlarmData() == null) {\n                log().debug(\"AlarmWriter: uei '\" + event.getUei() + \"' marked as 'doNotPersist' or reductionKey is null.\");\n                return;\n            } else {\n                if (log().isDebugEnabled()) {\n                    log().debug(\"AlarmWriter dbRun for : \" + event.getUei() + \" nodeid: \" + event.getNodeid() + \" ipaddr: \" + event.getInterface() + \" serviceid: \" + event.getService());\n                }\n            }\n\n            /*\n             * Try twice incase the transaction fails.  This could happen if 2 or more threads query the db\n             * at the same time and determine that insert needs to happen.  One insert will complete the other\n             * will fail.  The next time through the loop, the alarm will be reduced with an update. \n             */\n            int attempt = 1;\n            boolean notUpdated = true;\n            while (attempt <= 2 && notUpdated) {\n                try {\n                    insertOrUpdateAlarm(eventHeader, event);\n                    m_dsConn.commit();\n                    notUpdated = false;\n                } catch (SQLException e) {\n                    try {\n                        m_dsConn.rollback();\n                        m_dsConn.setAutoCommit(false);\n                    } catch (Exception e2) {\n                        log().warn(\"Rollback of transaction failed!\", e2);\n                    }\n                    if (attempt > 1) {\n                        log().warn(\"Error in attempt: \"+attempt+\" inserting alarm into the datastore\", e);\n                        throw e;\n                    } else {\n                        log().info(\"Retrying insertOrUpdate statement after first attempt: \"+ e.getMessage());\n                    }\n                }\n                attempt++;\n            }\n\n            if (log().isDebugEnabled()) {\n                log().debug(\"AlarmWriter finished for : \" + event.getUei());\n            }\n        }\n    }","commit_id":"7cd285fb4061095875c505fd6aa8169e68d307ec","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Constructor\n     * @param connectionFactory \n     */\n    public AlarmWriter(String getNextAlarmIdStr) throws SQLException {\n        super();\n        //\n        // prepare the SQL statement\n        //\n        m_getSvcIdStmt = m_dsConn.prepareStatement(EventdConstants.SQL_DB_SVCNAME_TO_SVCID);\n        m_getHostNameStmt = m_dsConn.prepareStatement(EventdConstants.SQL_DB_HOSTIP_TO_HOSTNAME);\n        m_getNextIdStmt = m_dsConn.prepareStatement(getNextAlarmIdStr);\n        m_insStmt = m_dsConn.prepareStatement(EventdConstants.SQL_DB_ALARM_INS_EVENT);\n        m_reductionQuery = m_dsConn.prepareStatement(EventdConstants.SQL_DB_ALARM_REDUCTION_QUERY);\n        m_upDateStmt = m_dsConn.prepareStatement(EventdConstants.SQL_DB_ALARM_UPDATE_EVENT);\n        m_updateEventStmt = m_dsConn.prepareStatement(EventdConstants.SQL_DB_UPDATE_EVENT_WITH_ALARM_ID);\n        // set the database for rollback support\n        //\n        try {\n            m_dsConn.setAutoCommit(false);\n        } catch (SQLException se) {\n            ThreadCategory.getInstance(AlarmWriter.class).warn(\"Unable to set auto commit mode\");\n        }\n    }","id":6974,"modified_method":"/**\n     * Constructor\n     * @param connectionFactory \n     */\n    public AlarmWriter() {\n        super();\n    }","commit_id":"7cd285fb4061095875c505fd6aa8169e68d307ec","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void close() {\n        try {\n            m_getSvcIdStmt.close();\n            m_getHostNameStmt.close();\n            m_getNextIdStmt.close();\n            m_insStmt.close();\n            m_reductionQuery.close();\n            m_upDateStmt.close();\n            m_updateEventStmt.close();\n        } catch (SQLException sqle) {\n            ThreadCategory.getInstance(AlarmWriter.class).warn(\"SQLException while closing prepared statements\", sqle);\n        } finally {\n            super.close();\n        }\n    }","id":6975,"modified_method":"public void close() {\n        try {\n            m_getHostNameStmt.close();\n            m_getNextIdStmt.close();\n            m_insStmt.close();\n            m_reductionQuery.close();\n            m_upDateStmt.close();\n            m_updateEventStmt.close();\n        } catch (SQLException e) {\n            log().warn(\"SQLException while closing prepared statements: \" + e, e);\n        } finally {\n            super.close();\n        }\n    }","commit_id":"7cd285fb4061095875c505fd6aa8169e68d307ec","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Process the received events. For each event, use the EventExpander to\n     * look up matching eventconf entry and load info from that match, expand\n     * event parms, add event to database and send event to appropriate\n     * listeners.\n     */\n    public void run() {\n        // check to see if the event log is hooked up\n        if (m_eventLog == null) {\n            return;\n        }\n\n        Events events = m_eventLog.getEvents();\n        if (events == null || events.getEventCount() <= 0) {\n            // no events to process\n            return;\n        }\n\n        // create an EventWriters\n        EventWriter eventWriter = null;\n        try {\n            AlarmWriter alarmWriter = null;\n            try {\n                try {\n                    eventWriter = new EventWriter(m_getNextEventIdStr);\n                    alarmWriter = new AlarmWriter(m_getNextAlarmIdStr);\n                } catch (Throwable t) {\n                    log().warn(\"Exception creating EventWriter\", t);\n                    log().warn(\"Event(s) CANNOT be inserted into the database\");\n\n                    return;\n                }\n\n                Enumeration<Event> en = events.enumerateEvent();\n                while (en.hasMoreElements()) {\n                    Event event = en.nextElement();\n\n                    if (log().isDebugEnabled()) {\n                        // print out the eui, source, and other\n                        // important aspects\n                        //\n                        String uuid = event.getUuid();\n                        log().debug(\"Event {\");\n                        log().debug(\"  uuid  = \" + (uuid != null && uuid.length() > 0 ? uuid : \"<not-set>\"));\n                        log().debug(\"  uei   = \" + event.getUei());\n                        log().debug(\"  src   = \" + event.getSource());\n                        log().debug(\"  iface = \" + event.getInterface());\n                        log().debug(\"  time  = \" + event.getTime());\n                        Parm[] parms = (event.getParms() == null ? null : event.getParms().getParm());\n                        if (parms != null) {\n                            log().debug(\"  parms {\");\n                            for (int x = 0; x < parms.length; x++) {\n                                if ((parms[x].getParmName() != null) && (parms[x].getValue().getContent() != null)) {\n                                    log().debug(\"    (\" + parms[x].getParmName().trim() + \", \" + parms[x].getValue().getContent().trim() + \")\");\n                                }\n                            }\n                            log().debug(\"  }\");\n                        }\n                        log().debug(\"}\");\n                    }\n\n                    // look up eventconf match and expand event\n                    m_eventExpander.expandEvent(event);\n                    try {\n                        // add to database\n                        eventWriter.persistEvent(m_eventLog.getHeader(), event);\n                        // send event to interested listeners\n                        EventIpcManagerFactory.getIpcManager().broadcastNow(event);\n\n                        alarmWriter.persistAlarm(m_eventLog.getHeader(), event);\n                    } catch (SQLException sqle) {\n                        log().warn(\"Unable to add event to database\", sqle);\n                    } catch (Throwable t) {\n                        log().warn(\"Unknown exception processing event\", t);\n                    }\n                }\n            } finally {\n                if (alarmWriter != null) alarmWriter.close();\n            }\n        } finally {\n            \n            // close database related stuff in the eventwriter\n            if (eventWriter != null) eventWriter.close();\n        }\n    }","id":6976,"modified_method":"/**\n     * Process the received events. For each event, use the EventExpander to\n     * look up matching eventconf entry and load info from that match, expand\n     * event parms, add event to database and send event to appropriate\n     * listeners.\n     */\n    public void run() {\n        // check to see if the event log is hooked up\n        if (m_eventLog == null) {\n            return;\n        }\n\n        Events events = m_eventLog.getEvents();\n        if (events == null || events.getEventCount() <= 0) {\n            // no events to process\n            return;\n        }\n\n        // create an EventWriters\n        EventWriter eventWriter = null;\n        try {\n            AlarmWriter alarmWriter = null;\n            try {\n                try {\n                    eventWriter = new EventWriter();\n                    eventWriter.setDataSource(m_dataSource);\n                    eventWriter.setEventdServiceManager(m_eventdServiceManager);\n                    eventWriter.setGetNextEventIdStr(m_getNextEventIdStr);\n                    eventWriter.afterPropertiesSet();\n                    \n                    alarmWriter = new AlarmWriter();\n                    alarmWriter.setDataSource(m_dataSource);\n                    alarmWriter.setEventdServiceManager(m_eventdServiceManager);\n                    alarmWriter.setGetNextAlarmIdStr(m_getNextAlarmIdStr);\n                    alarmWriter.afterPropertiesSet();\n                } catch (Throwable t) {\n                    log().warn(\"Exception creating EventWriter\", t);\n                    log().warn(\"Event(s) CANNOT be inserted into the database\");\n\n                    return;\n                }\n\n                Enumeration<Event> en = events.enumerateEvent();\n                while (en.hasMoreElements()) {\n                    Event event = en.nextElement();\n\n                    if (log().isDebugEnabled()) {\n                        // print out the eui, source, and other\n                        // important aspects\n                        //\n                        String uuid = event.getUuid();\n                        log().debug(\"Event {\");\n                        log().debug(\"  uuid  = \" + (uuid != null && uuid.length() > 0 ? uuid : \"<not-set>\"));\n                        log().debug(\"  uei   = \" + event.getUei());\n                        log().debug(\"  src   = \" + event.getSource());\n                        log().debug(\"  iface = \" + event.getInterface());\n                        log().debug(\"  time  = \" + event.getTime());\n                        Parm[] parms = (event.getParms() == null ? null : event.getParms().getParm());\n                        if (parms != null) {\n                            log().debug(\"  parms {\");\n                            for (int x = 0; x < parms.length; x++) {\n                                if ((parms[x].getParmName() != null) && (parms[x].getValue().getContent() != null)) {\n                                    log().debug(\"    (\" + parms[x].getParmName().trim() + \", \" + parms[x].getValue().getContent().trim() + \")\");\n                                }\n                            }\n                            log().debug(\"  }\");\n                        }\n                        log().debug(\"}\");\n                    }\n\n                    // look up eventconf match and expand event\n                    m_eventExpander.expandEvent(event);\n                    try {\n                        // add to database\n                        eventWriter.persistEvent(m_eventLog.getHeader(), event);\n                        // send event to interested listeners\n                        EventIpcManagerFactory.getIpcManager().broadcastNow(event);\n\n                        alarmWriter.persistAlarm(m_eventLog.getHeader(), event);\n                    } catch (SQLException sqle) {\n                        log().warn(\"Unable to add event to database\", sqle);\n                    } catch (Throwable t) {\n                        log().warn(\"Unknown exception processing event\", t);\n                    }\n                }\n            } finally {\n                if (alarmWriter != null) alarmWriter.close();\n            }\n        } finally {\n            \n            // close database related stuff in the eventwriter\n            if (eventWriter != null) eventWriter.close();\n        }\n    }","commit_id":"7cd285fb4061095875c505fd6aa8169e68d307ec","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Constructor for the eventhandler\n     * @param eventLog\n     *            events to be processed\n     * @param getNextEventId\n     *            the sql statement to get next event id from sequence\n     * @param eventExpander TODO\n     * @param connectionFactory \n     */\n    public EventHandler(Log eventLog, String getNextEventId, String getNextAlarmIdStr, EventExpander eventExpander) {\n        m_eventLog = eventLog;\n        m_getNextEventIdStr = getNextEventId;\n        m_getNextAlarmIdStr = getNextAlarmIdStr;\n        m_eventExpander = eventExpander;\n    }","id":6977,"modified_method":"/**\n     * Constructor for the eventhandler\n     * @param eventLog\n     *            events to be processed\n     * @param getNextEventId\n     *            the sql statement to get next event id from sequence\n     * @param eventExpander TODO\n     * @param dataSource TODO\n     * @param connectionFactory \n     */\n    public EventHandler(Log eventLog, String getNextEventId, String getNextAlarmIdStr, EventExpander eventExpander, EventdServiceManager eventdServiceManager, DataSource dataSource) {\n        m_eventLog = eventLog;\n        m_getNextEventIdStr = getNextEventId;\n        m_getNextAlarmIdStr = getNextAlarmIdStr;\n        m_eventExpander = eventExpander;\n        m_eventdServiceManager = eventdServiceManager;\n        m_dataSource = dataSource;\n        \n        afterPropertiesSet();\n    }","commit_id":"7cd285fb4061095875c505fd6aa8169e68d307ec","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Called by a service to send a set of events to other listeners.\n     */\n    public synchronized void sendNow(Log eventLog) {\n\n        // create a new event handler for the events and queue it to the\n        // event handler thread pool\n        try {\n            m_eventHandlerPool.getRunQueue().add(new EventHandler(eventLog, m_getNextEventIdStr, m_getNextAlarmIdStr, m_eventExpander));\n        } catch (InterruptedException iE) {\n            log().warn(\"Unable to queue event log to the event handler pool queue\", iE);\n\n            throw new UndeclaredEventException(iE);\n        } catch (FifoQueueException qE) {\n            log().warn(\"Unable to queue event log to the event handler pool queue\", qE);\n\n            throw new UndeclaredEventException(qE);\n        }\n    }","id":6978,"modified_method":"/**\n     * Called by a service to send a set of events to other listeners.\n     */\n    public synchronized void sendNow(Log eventLog) {\n\n        // create a new event handler for the events and queue it to the\n        // event handler thread pool\n        try {\n            m_eventHandlerPool.getRunQueue().add(new EventHandler(eventLog, m_getNextEventIdStr, m_getNextAlarmIdStr, m_eventExpander, m_eventdServiceManager, m_dataSource));\n        } catch (InterruptedException iE) {\n            log().warn(\"Unable to queue event log to the event handler pool queue\", iE);\n\n            throw new UndeclaredEventException(iE);\n        } catch (FifoQueueException qE) {\n            log().warn(\"Unable to queue event log to the event handler pool queue\", qE);\n\n            throw new UndeclaredEventException(qE);\n        }\n    }","commit_id":"7cd285fb4061095875c505fd6aa8169e68d307ec","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public synchronized void afterPropertiesSet() {\n        Assert.state(m_eventdConfigMgr != null, \"eventdConfigMgr not set\");\n        Assert.state(m_eventExpander != null, \"eventExpander not set\");\n        \n        m_ueiListeners = new HashMap<String, List<EventListener>>();\n        m_listeners = new ArrayList<EventListener>();\n        m_listenerThreads = new HashMap<String, ListenerThread>();\n\n        // get number of threads\n        int numReceivers = m_eventdConfigMgr.getReceivers();\n        // create handler pool\n        m_eventHandlerPool = new RunnableConsumerThreadPool(\"EventHandlerPool\", 0.6f, 1.0f, numReceivers);\n        // start pool\n        m_eventHandlerPool.start();\n        // database sequence query string\n        m_getNextEventIdStr = m_eventdConfigMgr.getGetNextEventID();\n        m_getNextAlarmIdStr = m_eventdConfigMgr.getGetNextAlarmID();\n    }","id":6979,"modified_method":"public synchronized void afterPropertiesSet() {\n        Assert.state(m_eventdConfigMgr != null, \"eventdConfigMgr not set\");\n        Assert.state(m_eventExpander != null, \"eventExpander not set\");\n        Assert.state(m_dataSource != null, \"dataSource not set\");\n        Assert.state(m_eventdServiceManager != null, \"eventdServiceManager not set\");\n        \n        m_ueiListeners = new HashMap<String, List<EventListener>>();\n        m_listeners = new ArrayList<EventListener>();\n        m_listenerThreads = new HashMap<String, ListenerThread>();\n\n        // get number of threads\n        int numReceivers = m_eventdConfigMgr.getReceivers();\n        // create handler pool\n        m_eventHandlerPool = new RunnableConsumerThreadPool(\"EventHandlerPool\", 0.6f, 1.0f, numReceivers);\n        // start pool\n        m_eventHandlerPool.start();\n        // database sequence query string\n        m_getNextEventIdStr = m_eventdConfigMgr.getGetNextEventID();\n        m_getNextAlarmIdStr = m_eventdConfigMgr.getGetNextAlarmID();\n    }","commit_id":"7cd285fb4061095875c505fd6aa8169e68d307ec","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testInit() throws Exception {\n        EventIpcManagerDefaultImpl manager = new EventIpcManagerDefaultImpl();\n        manager.setEventdConfigMgr(EventdConfigFactory.getInstance());\n        EventExpander eventExpander = new EventExpander();\n        eventExpander.setEventConfDao(EasyMock.createMock(EventConfDao.class));\n        eventExpander.afterPropertiesSet();\n        manager.setEventExpander(eventExpander);\n        manager.afterPropertiesSet();\n    }","id":6980,"modified_method":"public void testInit() throws Exception {\n        EventIpcManagerDefaultImpl manager = new EventIpcManagerDefaultImpl();\n        manager.setEventdConfigMgr(EventdConfigFactory.getInstance());\n        EventExpander eventExpander = new EventExpander();\n        eventExpander.setEventConfDao(EasyMock.createMock(EventConfDao.class));\n        eventExpander.afterPropertiesSet();\n        manager.setEventExpander(eventExpander);\n        manager.setDataSource(EasyMock.createMock(DataSource.class));\n        manager.setEventdServiceManager(EasyMock.createMock(EventdServiceManager.class));\n        manager.afterPropertiesSet();\n    }","commit_id":"7cd285fb4061095875c505fd6aa8169e68d307ec","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Constructor\n     * @param connectionFactory \n     * @param getNextEventIdStr\n     */\n    public EventWriter(String getNextEventIdStr) throws SQLException {\n        super();\n        //\n        // prepare the SQL statement\n        //\n        m_getSvcIdStmt = m_dsConn.prepareStatement(EventdConstants.SQL_DB_SVCNAME_TO_SVCID);\n        m_getHostNameStmt = m_dsConn.prepareStatement(EventdConstants.SQL_DB_HOSTIP_TO_HOSTNAME);\n        m_getNextIdStmt = m_dsConn.prepareStatement(getNextEventIdStr);\n        m_insStmt = m_dsConn.prepareStatement(EventdConstants.SQL_DB_INS_EVENT);\n        // set the database for rollback support\n        //\n        try {\n            m_dsConn.setAutoCommit(false);\n        } catch (SQLException se) {\n            ThreadCategory.getInstance(EventWriter.class).warn(\"Unable to set auto commit mode\");\n        }\n    }","id":6981,"modified_method":"public EventWriter() {\n        super();\n    }","commit_id":"7cd285fb4061095875c505fd6aa8169e68d307ec","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * The method that inserts the event into the database\n     * \n     * @param eventHeader\n     *            the event header\n     * @param event\n     *            the actual event to be inserted\n     */\n    public void persistEvent(Header eventHeader, Event event) throws SQLException {\n        if (event != null) {\n            Category log = ThreadCategory.getInstance(EventWriter.class);\n\n            // Check value of <logmsg> attribute 'dest', if set to\n            // \"donotpersist\" then simply return, the uei is not to be\n            // persisted to the database\n            String logdest = event.getLogmsg().getDest();\n            if (logdest.equals(\"donotpersist\")) {\n                log.debug(\"EventWriter: uei '\" + event.getUei() + \"' marked as 'doNotPersist'.\");\n                return;\n            } else {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"EventWriter dbRun for : \" + event.getUei() + \" nodeid: \" + event.getNodeid() + \" ipaddr: \" + event.getInterface() + \" serviceid: \" + event.getService());\n                }\n            }\n\n            try {\n                insertEvent(eventHeader, event);\n\n                // commit\n                m_dsConn.commit();\n            } catch (SQLException e) {\n                log.warn(\"Error inserting event into the datastore\", e);\n                try {\n                    m_dsConn.rollback();\n                } catch (Exception e2) {\n                    log.warn(\"Rollback of transaction failed!\", e2);\n                }\n\n                throw e;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"EventWriter finished for : \" + event.getUei());\n            }\n        }\n    }","id":6982,"modified_method":"/**\n     * The method that inserts the event into the database\n     * \n     * @param eventHeader\n     *            the event header\n     * @param event\n     *            the actual event to be inserted\n     */\n    public void persistEvent(Header eventHeader, Event event) throws SQLException {\n        if (event != null) {\n            // Check value of <logmsg> attribute 'dest', if set to\n            // \"donotpersist\" then simply return, the uei is not to be\n            // persisted to the database\n            String logdest = event.getLogmsg().getDest();\n            if (logdest.equals(\"donotpersist\")) {\n                log().debug(\"EventWriter: uei '\" + event.getUei() + \"' marked as 'doNotPersist'.\");\n                return;\n            } else {\n                if (log().isDebugEnabled()) {\n                    log().debug(\"EventWriter dbRun for : \" + event.getUei() + \" nodeid: \" + event.getNodeid() + \" ipaddr: \" + event.getInterface() + \" serviceid: \" + event.getService());\n                }\n            }\n\n            try {\n                insertEvent(eventHeader, event);\n\n                // commit\n                m_dsConn.commit();\n            } catch (SQLException e) {\n                log().warn(\"Error inserting event into the datastore\", e);\n                try {\n                    m_dsConn.rollback();\n                } catch (Exception e2) {\n                    log().warn(\"Rollback of transaction failed!\", e2);\n                }\n\n                throw e;\n            }\n\n            if (log().isDebugEnabled()) {\n                log().debug(\"EventWriter finished for : \" + event.getUei());\n            }\n        }\n    }","commit_id":"7cd285fb4061095875c505fd6aa8169e68d307ec","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void close() {\n        try {\n            m_getSvcIdStmt.close();\n            m_getHostNameStmt.close();\n            m_getNextIdStmt.close();\n            m_insStmt.close();\n        } catch (SQLException sqle) {\n            ThreadCategory.getInstance(EventWriter.class).warn(\"SQLException while closing prepared statements\", sqle);\n        } finally {\n            super.close();\n        }\n    }","id":6983,"modified_method":"public void close() {\n        try {\n            m_getHostNameStmt.close();\n            m_getNextIdStmt.close();\n            m_insStmt.close();\n        } catch (SQLException e) {\n            log().warn(\"SQLException while closing prepared statements: \" + e, e);\n        } finally {\n            super.close();\n        }\n    }","commit_id":"7cd285fb4061095875c505fd6aa8169e68d307ec","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * tests sequence of newly initialized db\n     */\n    public void testNextEventId() {\n        int nextId = getJdbcTemplate().queryForInt(\"SELECT nextval('eventsNxtId')\");\n        System.err.println(nextId);\n        \n        // an empty db should produce '1' here\n        assertEquals(1, nextId);\n    }","id":6984,"modified_method":"/**\n     * tests sequence of newly initialized db\n     */\n    public void testNextEventId() {\n        int nextId = getJdbcTemplate().queryForInt(m_eventWriter.getGetNextEventIdStr());\n        \n        // an empty db should produce '1' here\n        assertEquals(1, nextId);\n    }","commit_id":"7cd285fb4061095875c505fd6aa8169e68d307ec","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Tests writing nulls to postgres db and the db encoding.\n     * @throws SQLException\n     */\n    public void testWriteEventWithNull() throws SQLException {\n        \n        EventWriter eWriter = new EventWriter(\"SELECT nextval('eventsNxtId')\");\n        \n        try {\n            EventBuilder bldr = new EventBuilder(\"testUei\", \"testSource\");\n            bldr.setLogDest(\"logndisplay\");\n            bldr.addParam(\"test\", \"testVal\");\n            bldr.addParam(\"test2\", \"valWith\\u0000Null\\u0000\");\n\n            byte[] bytes = new byte[] { 0x07, (byte)0xD7, 0x04, 0x0A, 0x01, 0x17, 0x06, 0x00, 0x2B, 0x00, 0x00 };\n\n\n            SnmpValue snmpVal = SnmpUtils.getValueFactory().getOctetString(bytes);\n\n            assertFalse(snmpVal.isDisplayable());\n\n            bldr.addParam(\"test3\", snmpVal.toString());\n\n            String b64 = EventConstants.toString(EventConstants.XML_ENCODING_BASE64, snmpVal);\n\n            System.err.println(b64);\n\n            bldr.addParam(\"test\", b64);\n\n            System.err.println(snmpVal.toString());\n\n            eWriter.persistEvent(null, bldr.getEvent());\n\n        } finally {\n            eWriter.close();\n        }\n    }","id":6985,"modified_method":"/**\n     * Tests writing nulls to postgres db and the db encoding.\n     * @throws SQLException\n     */\n    public void testWriteEventWithNull() throws Exception {\n        EventBuilder bldr = new EventBuilder(\"testUei\", \"testSource\");\n        bldr.setLogDest(\"logndisplay\");\n        bldr.addParam(\"test\", \"testVal\");\n        bldr.addParam(\"test2\", \"valWith\\u0000Null\\u0000\");\n\n        byte[] bytes = new byte[] { 0x07, (byte)0xD7, 0x04, 0x0A, 0x01, 0x17, 0x06, 0x00, 0x2B, 0x00, 0x00 };\n\n\n        SnmpValue snmpVal = SnmpUtils.getValueFactory().getOctetString(bytes);\n\n        assertFalse(snmpVal.isDisplayable());\n\n        bldr.addParam(\"test3\", snmpVal.toString());\n\n        String b64 = EventConstants.toString(EventConstants.XML_ENCODING_BASE64, snmpVal);\n\n        bldr.addParam(\"test\", b64);\n\n        m_eventWriter.persistEvent(null, bldr.getEvent());\n    }","commit_id":"7cd285fb4061095875c505fd6aa8169e68d307ec","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        \n        DataSourceFactory.setInstance(getDataSource());\n    }","id":6986,"modified_method":"@Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        \n        JdbcEventdServiceManager eventdServiceManager = new JdbcEventdServiceManager();\n        eventdServiceManager.setDataSource(getDataSource());\n        eventdServiceManager.afterPropertiesSet();\n        \n        m_eventWriter = new EventWriter();\n        m_eventWriter.setEventdServiceManager(eventdServiceManager);\n        m_eventWriter.setDataSource(getDataSource());\n        m_eventWriter.setGetNextEventIdStr(\"SELECT nextval('eventsNxtId')\");\n        m_eventWriter.afterPropertiesSet();\n    }","commit_id":"7cd285fb4061095875c505fd6aa8169e68d307ec","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Tests writing nulls to postgres db and the db encoding.\n     * @throws SQLException\n     */\n    public void testWriteEventDescrWithNull() throws SQLException {\n        \n        EventWriter eWriter = new EventWriter(\"SELECT nextval('eventsNxtId')\");\n        \n        try {\n            EventBuilder bldr = new EventBuilder(\"testUei\", \"testSource\");\n            bldr.setLogDest(\"logndisplay\");\n        \n            bldr.setDescription(\"abc\\u0000def\");\n        \n            eWriter.persistEvent(null, bldr.getEvent());\n        \n        } finally {\n            eWriter.close();\n        }\n    }","id":6987,"modified_method":"/**\n     * Tests writing nulls to postgres db and the db encoding.\n     * @throws SQLException\n     */\n    public void testWriteEventDescrWithNull() throws Exception {\n        EventBuilder bldr = new EventBuilder(\"testUei\", \"testSource\");\n        bldr.setLogDest(\"logndisplay\");\n\n        bldr.setDescription(\"abc\\u0000def\");\n\n        m_eventWriter.persistEvent(null, bldr.getEvent());\n    }","commit_id":"7cd285fb4061095875c505fd6aa8169e68d307ec","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void onInit() {\n        Assert.state(m_dataSource != null, \"dataSource not initialized\");\n        Assert.state(m_eventConfDao != null, \"eventConfDao not initialized\");\n        \n        createBroadcastEventProcessor(m_eventIpcManager);\n\n        initializeServiceTableMap();\n\n        initializeExternalIpcReceivers();\n    }","id":6988,"modified_method":"protected void onInit() {\n        Assert.state(m_eventConfDao != null, \"property eventConfDao must be set\");\n        Assert.state(m_eventdServiceManager != null, \"property eventdServiceManager must be set\");\n        \n        createBroadcastEventProcessor(m_eventIpcManager);\n\n        m_eventdServiceManager.dataSourceSync();\n\n        initializeExternalIpcReceivers();\n    }","commit_id":"7cd285fb4061095875c505fd6aa8169e68d307ec","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void setUp() throws Exception {\n        super.setUp();\n        MockUtil.println(\"------------ Begin Test \"+getName()+\" --------------------------\");\n        MockLogAppender.setupLogging();\n        \n        if (m_runSupers) {\n        \n            createMockNetwork();\n            \n            populateDatabase();\n            \n            DataSourceFactory.setInstance(m_db);\n\n            Reader rdr = new StringReader(getSnmpConfig());\n            SnmpPeerFactory.setInstance(new SnmpPeerFactory(rdr));\n            \n            if (isStartEventd()) {\n                m_eventd = new Eventd();\n                m_eventd.setDataSource(m_db);\n                m_eventdConfigMgr = new MockEventConfigManager(ConfigurationTestUtils.getReaderForResource(this, \"/org/opennms/netmgt/mock/eventd-configuration.xml\"));\n                m_eventd.setConfigManager(m_eventdConfigMgr);\n\n                /*\n                 * Make sure we specify a full resource path since \"this\" is\n                 * the unit test class, which is most likely in another package. \n                 */\n                File configFile = ConfigurationTestUtils.getFileForResource(this, \"/org/opennms/netmgt/mock/eventconf.xml\");\n                DefaultEventConfDao eventConfDao = new DefaultEventConfDao(configFile);\n                eventConfDao.reload();\n                EventconfFactory.setInstance(eventConfDao);\n                \n                EventExpander eventExpander = new EventExpander();\n                eventExpander.setEventConfDao(eventConfDao);\n                eventExpander.afterPropertiesSet();\n                \n                m_eventdIpcMgr = new EventIpcManagerDefaultImpl();\n                m_eventdIpcMgr.setEventdConfigMgr(m_eventdConfigMgr);\n                m_eventdIpcMgr.setEventExpander(eventExpander);\n                m_eventdIpcMgr.afterPropertiesSet();\n                \n                m_eventProxy = new EventProxy() {\n\n                    public void send(Event event) throws EventProxyException {\n                        m_eventdIpcMgr.sendNow(event);\n                    }\n\n                    public void send(Log eventLog) throws EventProxyException {\n                        m_eventdIpcMgr.sendNow(eventLog);\n                    }\n                    \n                };\n                \n                EventIpcManagerFactory.setIpcManager(m_eventdIpcMgr);\n                m_eventd.setEventIpcManager(m_eventdIpcMgr);\n                m_eventd.setEventConfDao(eventConfDao);\n                m_eventd.init();\n                m_eventd.start();\n            }\n        \n        }\n        \n        m_transMgr = new DataSourceTransactionManager(DataSourceFactory.getInstance());\n\n    }","id":6989,"modified_method":"protected void setUp() throws Exception {\n        super.setUp();\n        MockUtil.println(\"------------ Begin Test \"+getName()+\" --------------------------\");\n        MockLogAppender.setupLogging();\n        \n        if (m_runSupers) {\n        \n            createMockNetwork();\n            \n            populateDatabase();\n            \n            DataSourceFactory.setInstance(m_db);\n\n            Reader rdr = new StringReader(getSnmpConfig());\n            SnmpPeerFactory.setInstance(new SnmpPeerFactory(rdr));\n            \n            if (isStartEventd()) {\n                m_eventdConfigMgr = new MockEventConfigManager(ConfigurationTestUtils.getReaderForResource(this, \"/org/opennms/netmgt/mock/eventd-configuration.xml\"));\n                \n                JdbcEventdServiceManager eventdServiceManager = new JdbcEventdServiceManager();\n                eventdServiceManager.setDataSource(m_db);\n                eventdServiceManager.afterPropertiesSet();\n\n                /*\n                 * Make sure we specify a full resource path since \"this\" is\n                 * the unit test class, which is most likely in another package. \n                 */\n                File configFile = ConfigurationTestUtils.getFileForResource(this, \"/org/opennms/netmgt/mock/eventconf.xml\");\n                DefaultEventConfDao eventConfDao = new DefaultEventConfDao(configFile);\n                eventConfDao.reload();\n                EventconfFactory.setInstance(eventConfDao);\n                \n                EventExpander eventExpander = new EventExpander();\n                eventExpander.setEventConfDao(eventConfDao);\n                eventExpander.afterPropertiesSet();\n                \n                m_eventdIpcMgr = new EventIpcManagerDefaultImpl();\n                m_eventdIpcMgr.setEventdConfigMgr(m_eventdConfigMgr);\n                m_eventdIpcMgr.setEventExpander(eventExpander);\n                m_eventdIpcMgr.setEventdServiceManager(eventdServiceManager);\n                m_eventdIpcMgr.setDataSource(m_db);\n                m_eventdIpcMgr.afterPropertiesSet();\n                \n                m_eventProxy = new EventProxy() {\n\n                    public void send(Event event) throws EventProxyException {\n                        m_eventdIpcMgr.sendNow(event);\n                    }\n\n                    public void send(Log eventLog) throws EventProxyException {\n                        m_eventdIpcMgr.sendNow(eventLog);\n                    }\n                    \n                };\n                \n                EventIpcManagerFactory.setIpcManager(m_eventdIpcMgr);\n\n                m_eventd = new Eventd();\n                m_eventd.setEventdServiceManager(eventdServiceManager);\n                m_eventd.setConfigManager(m_eventdConfigMgr);\n\n                m_eventd.setEventIpcManager(m_eventdIpcMgr);\n                m_eventd.setEventConfDao(eventConfDao);\n                m_eventd.init();\n                m_eventd.start();\n            }\n        \n        }\n        \n        m_transMgr = new DataSourceTransactionManager(DataSourceFactory.getInstance());\n\n    }","commit_id":"7cd285fb4061095875c505fd6aa8169e68d307ec","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is used to convert the service name into a service id. It\n     * first looks up the information from a service map of Eventd and if no\n     * match is found, by performing a lookup in the database. If the conversion\n     * is successful then the corresponding integer identifier will be returned\n     * to the caller.\n     * \n     * @param name\n     *            The name of the service\n     * \n     * @return The integer identifier for the service name.\n     * \n     * @exception java.sql.SQLException\n     *                Thrown if there is an error accessing the stored data or\n     *                the SQL text is malformed. This will also be thrown if the\n     *                result cannot be obtained.\n     * \n     * @see EventdConstants#SQL_DB_SVCNAME_TO_SVCID\n     * \n     */\n    private int getServiceID(String name) throws SQLException {\n        Assert.notNull(name, \"The service name must not be null\");\n\n        // ask persistd\n        int id = Eventd.getServiceID(name);\n        if (id != -1) {\n            return id;\n        }\n\n        // talk to the database and get the identifer\n        m_getSvcIdStmt.setString(1, name);\n        ResultSet rset = null;\n        try {\n            rset = m_getSvcIdStmt.executeQuery();\n            if (rset.next()) {\n                id = rset.getInt(1);\n            }\n        } catch (SQLException e) {\n            throw e;\n        } finally {\n            rset.close();\n        }\n\n        // inform persistd about the new find\n        if (id != -1) {\n            Eventd.addServiceMapping(name, id);\n        }\n\n        return id;\n    }","id":6990,"modified_method":"/**\n     * This method is used to convert the service name into a service id. It\n     * first looks up the information from a service map of Eventd and if no\n     * match is found, by performing a lookup in the database. If the conversion\n     * is successful then the corresponding integer identifier will be returned\n     * to the caller.\n     * \n     * @param name\n     *            The name of the service\n     * \n     * @return The integer identifier for the service name.\n     * \n     * @exception java.sql.SQLException\n     *                Thrown if there is an error accessing the stored data or\n     *                the SQL text is malformed. This will also be thrown if the\n     *                result cannot be obtained.\n     * \n     * @see EventdConstants#SQL_DB_SVCNAME_TO_SVCID\n     * \n     */\n    private int getServiceID(String name) throws SQLException {\n        return m_eventdServiceManager.getServiceId(name);\n    }","commit_id":"7cd285fb4061095875c505fd6aa8169e68d307ec","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Category log() {\n        return ThreadCategory.getInstance(getClass());\n    }","id":6991,"modified_method":"protected Category log() {\n        return ThreadCategory.getInstance(getClass());\n    }","commit_id":"7cd285fb4061095875c505fd6aa8169e68d307ec","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Constructor\n     * @param connectionFactory \n     */\n    public Persist() throws SQLException {\n        // Get a database connection\n        m_dsConn = DataSourceFactory.getInstance().getConnection();\n    }","id":6992,"modified_method":"public Persist() {\n    }","commit_id":"7cd285fb4061095875c505fd6aa8169e68d307ec","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Constructor\n     * @param connectionFactory \n     */\n    public AlarmWriter(String getNextAlarmIdStr) throws SQLException {\n        super();\n        //\n        // prepare the SQL statement\n        //\n        m_getSvcIdStmt = m_dsConn.prepareStatement(EventdConstants.SQL_DB_SVCNAME_TO_SVCID);\n        m_getHostNameStmt = m_dsConn.prepareStatement(EventdConstants.SQL_DB_HOSTIP_TO_HOSTNAME);\n        m_getNextIdStmt = m_dsConn.prepareStatement(getNextAlarmIdStr);\n        m_insStmt = m_dsConn.prepareStatement(EventdConstants.SQL_DB_ALARM_INS_EVENT);\n        m_reductionQuery = m_dsConn.prepareStatement(EventdConstants.SQL_DB_ALARM_REDUCTION_QUERY);\n        m_upDateStmt = m_dsConn.prepareStatement(EventdConstants.SQL_DB_ALARM_UPDATE_EVENT);\n        m_updateEventStmt = m_dsConn.prepareStatement(EventdConstants.SQL_DB_UPDATE_EVENT_WITH_ALARM_ID);\n        // set the database for rollback support\n        //\n        try {\n            m_dsConn.setAutoCommit(false);\n        } catch (SQLException se) {\n            ThreadCategory.getInstance(AlarmWriter.class).warn(\"Unable to set auto commit mode\");\n        }\n    }","id":6993,"modified_method":"/**\n     * Constructor\n     * @param connectionFactory \n     */\n    public AlarmWriter() {\n        super();\n    }","commit_id":"8187639c3f4e9349daa245b5f7f93dcbb1e2783e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * The method that inserts the event into the database\n     * \n     * @param eventHeader\n     *            the event header\n     * @param event\n     *            the actual event to be inserted\n     */\n    public void persistAlarm(Header eventHeader, Event event) throws SQLException {\n        if (event != null) {\n            Category log = ThreadCategory.getInstance(AlarmWriter.class);\n\n            // Check value of <logmsg> attribute 'dest', if set to\n            // \"donotpersist\" then simply return, the uei is not to be\n            // persisted to the database\n            String logdest = event.getLogmsg().getDest();\n            if (logdest.equals(\"donotpersist\") || event.getAlarmData() == null) {\n                log.debug(\"AlarmWriter: uei '\" + event.getUei() + \"' marked as 'doNotPersist' or reductionKey is null.\");\n                return;\n            } else {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"AlarmWriter dbRun for : \" + event.getUei() + \" nodeid: \" + event.getNodeid() + \" ipaddr: \" + event.getInterface() + \" serviceid: \" + event.getService());\n                }\n            }\n\n            /*\n             * Try twice incase the transaction fails.  This could happen if 2 or more threads query the db\n             * at the same time and determine that insert needs to happen.  One insert will complete the other\n             * will fail.  The next time through the loop, the alarm will be reduced with an update. \n             */\n            int attempt = 1;\n            boolean notUpdated = true;\n            while (attempt <= 2 && notUpdated) {\n                try {\n                    insertOrUpdateAlarm(eventHeader, event);\n                    m_dsConn.commit();\n                    notUpdated = false;\n                } catch (SQLException e) {\n                    try {\n                        m_dsConn.rollback();\n                        m_dsConn.setAutoCommit(false);\n                    } catch (Exception e2) {\n                        log.warn(\"Rollback of transaction failed!\", e2);\n                    }\n                    if (attempt > 1) {\n                        log.warn(\"Error in attempt: \"+attempt+\" inserting alarm into the datastore\", e);\n                        throw e;\n                    } else {\n                        log.info(\"Retrying insertOrUpdate statement after first attempt: \"+ e.getMessage());\n                    }\n                }\n                attempt++;\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(\"AlarmWriter finished for : \" + event.getUei());\n        }\n    }","id":6994,"modified_method":"/**\n     * The method that inserts the event into the database\n     * \n     * @param eventHeader\n     *            the event header\n     * @param event\n     *            the actual event to be inserted\n     */\n    public void persistAlarm(Header eventHeader, Event event) throws SQLException {\n        if (event != null) {\n            // Check value of <logmsg> attribute 'dest', if set to\n            // \"donotpersist\" then simply return, the uei is not to be\n            // persisted to the database\n            String logdest = event.getLogmsg().getDest();\n            if (logdest.equals(\"donotpersist\") || event.getAlarmData() == null) {\n                log().debug(\"AlarmWriter: uei '\" + event.getUei() + \"' marked as 'doNotPersist' or reductionKey is null.\");\n                return;\n            } else {\n                if (log().isDebugEnabled()) {\n                    log().debug(\"AlarmWriter dbRun for : \" + event.getUei() + \" nodeid: \" + event.getNodeid() + \" ipaddr: \" + event.getInterface() + \" serviceid: \" + event.getService());\n                }\n            }\n\n            /*\n             * Try twice incase the transaction fails.  This could happen if 2 or more threads query the db\n             * at the same time and determine that insert needs to happen.  One insert will complete the other\n             * will fail.  The next time through the loop, the alarm will be reduced with an update. \n             */\n            int attempt = 1;\n            boolean notUpdated = true;\n            while (attempt <= 2 && notUpdated) {\n                try {\n                    insertOrUpdateAlarm(eventHeader, event);\n                    m_dsConn.commit();\n                    notUpdated = false;\n                } catch (SQLException e) {\n                    try {\n                        m_dsConn.rollback();\n                        m_dsConn.setAutoCommit(false);\n                    } catch (Exception e2) {\n                        log().warn(\"Rollback of transaction failed!\", e2);\n                    }\n                    if (attempt > 1) {\n                        log().warn(\"Error in attempt: \"+attempt+\" inserting alarm into the datastore\", e);\n                        throw e;\n                    } else {\n                        log().info(\"Retrying insertOrUpdate statement after first attempt: \"+ e.getMessage());\n                    }\n                }\n                attempt++;\n            }\n\n            if (log().isDebugEnabled()) {\n                log().debug(\"AlarmWriter finished for : \" + event.getUei());\n            }\n        }\n    }","commit_id":"8187639c3f4e9349daa245b5f7f93dcbb1e2783e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void close() {\n        try {\n            m_getSvcIdStmt.close();\n            m_getHostNameStmt.close();\n            m_getNextIdStmt.close();\n            m_insStmt.close();\n            m_reductionQuery.close();\n            m_upDateStmt.close();\n            m_updateEventStmt.close();\n        } catch (SQLException sqle) {\n            ThreadCategory.getInstance(AlarmWriter.class).warn(\"SQLException while closing prepared statements\", sqle);\n        } finally {\n            super.close();\n        }\n    }","id":6995,"modified_method":"public void close() {\n        try {\n            m_getHostNameStmt.close();\n            m_getNextIdStmt.close();\n            m_insStmt.close();\n            m_reductionQuery.close();\n            m_upDateStmt.close();\n            m_updateEventStmt.close();\n        } catch (SQLException e) {\n            log().warn(\"SQLException while closing prepared statements: \" + e, e);\n        } finally {\n            super.close();\n        }\n    }","commit_id":"8187639c3f4e9349daa245b5f7f93dcbb1e2783e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Constructor for the eventhandler\n     * @param eventLog\n     *            events to be processed\n     * @param getNextEventId\n     *            the sql statement to get next event id from sequence\n     * @param eventExpander TODO\n     * @param connectionFactory \n     */\n    public EventHandler(Log eventLog, String getNextEventId, String getNextAlarmIdStr, EventExpander eventExpander) {\n        m_eventLog = eventLog;\n        m_getNextEventIdStr = getNextEventId;\n        m_getNextAlarmIdStr = getNextAlarmIdStr;\n        m_eventExpander = eventExpander;\n    }","id":6996,"modified_method":"/**\n     * Constructor for the eventhandler\n     * @param eventLog\n     *            events to be processed\n     * @param getNextEventId\n     *            the sql statement to get next event id from sequence\n     * @param eventExpander TODO\n     * @param dataSource TODO\n     * @param connectionFactory \n     */\n    public EventHandler(Log eventLog, String getNextEventId, String getNextAlarmIdStr, EventExpander eventExpander, EventdServiceManager eventdServiceManager, DataSource dataSource) {\n        m_eventLog = eventLog;\n        m_getNextEventIdStr = getNextEventId;\n        m_getNextAlarmIdStr = getNextAlarmIdStr;\n        m_eventExpander = eventExpander;\n        m_eventdServiceManager = eventdServiceManager;\n        m_dataSource = dataSource;\n        \n        afterPropertiesSet();\n    }","commit_id":"8187639c3f4e9349daa245b5f7f93dcbb1e2783e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Process the received events. For each event, use the EventExpander to\n     * look up matching eventconf entry and load info from that match, expand\n     * event parms, add event to database and send event to appropriate\n     * listeners.\n     */\n    public void run() {\n        // check to see if the event log is hooked up\n        if (m_eventLog == null) {\n            return;\n        }\n\n        Events events = m_eventLog.getEvents();\n        if (events == null || events.getEventCount() <= 0) {\n            // no events to process\n            return;\n        }\n\n        // create an EventWriters\n        EventWriter eventWriter = null;\n        try {\n            AlarmWriter alarmWriter = null;\n            try {\n                try {\n                    eventWriter = new EventWriter(m_getNextEventIdStr);\n                    alarmWriter = new AlarmWriter(m_getNextAlarmIdStr);\n                } catch (Throwable t) {\n                    log().warn(\"Exception creating EventWriter\", t);\n                    log().warn(\"Event(s) CANNOT be inserted into the database\");\n\n                    return;\n                }\n\n                Enumeration<Event> en = events.enumerateEvent();\n                while (en.hasMoreElements()) {\n                    Event event = en.nextElement();\n\n                    if (log().isDebugEnabled()) {\n                        // print out the eui, source, and other\n                        // important aspects\n                        //\n                        String uuid = event.getUuid();\n                        log().debug(\"Event {\");\n                        log().debug(\"  uuid  = \" + (uuid != null && uuid.length() > 0 ? uuid : \"<not-set>\"));\n                        log().debug(\"  uei   = \" + event.getUei());\n                        log().debug(\"  src   = \" + event.getSource());\n                        log().debug(\"  iface = \" + event.getInterface());\n                        log().debug(\"  time  = \" + event.getTime());\n                        Parm[] parms = (event.getParms() == null ? null : event.getParms().getParm());\n                        if (parms != null) {\n                            log().debug(\"  parms {\");\n                            for (int x = 0; x < parms.length; x++) {\n                                if ((parms[x].getParmName() != null) && (parms[x].getValue().getContent() != null)) {\n                                    log().debug(\"    (\" + parms[x].getParmName().trim() + \", \" + parms[x].getValue().getContent().trim() + \")\");\n                                }\n                            }\n                            log().debug(\"  }\");\n                        }\n                        log().debug(\"}\");\n                    }\n\n                    // look up eventconf match and expand event\n                    m_eventExpander.expandEvent(event);\n                    try {\n                        // add to database\n                        eventWriter.persistEvent(m_eventLog.getHeader(), event);\n                        // send event to interested listeners\n                        EventIpcManagerFactory.getIpcManager().broadcastNow(event);\n\n                        alarmWriter.persistAlarm(m_eventLog.getHeader(), event);\n                    } catch (SQLException sqle) {\n                        log().warn(\"Unable to add event to database\", sqle);\n                    } catch (Throwable t) {\n                        log().warn(\"Unknown exception processing event\", t);\n                    }\n                }\n            } finally {\n                if (alarmWriter != null) alarmWriter.close();\n            }\n        } finally {\n            \n            // close database related stuff in the eventwriter\n            if (eventWriter != null) eventWriter.close();\n        }\n    }","id":6997,"modified_method":"/**\n     * Process the received events. For each event, use the EventExpander to\n     * look up matching eventconf entry and load info from that match, expand\n     * event parms, add event to database and send event to appropriate\n     * listeners.\n     */\n    public void run() {\n        // check to see if the event log is hooked up\n        if (m_eventLog == null) {\n            return;\n        }\n\n        Events events = m_eventLog.getEvents();\n        if (events == null || events.getEventCount() <= 0) {\n            // no events to process\n            return;\n        }\n\n        // create an EventWriters\n        EventWriter eventWriter = null;\n        try {\n            AlarmWriter alarmWriter = null;\n            try {\n                try {\n                    eventWriter = new EventWriter();\n                    eventWriter.setDataSource(m_dataSource);\n                    eventWriter.setEventdServiceManager(m_eventdServiceManager);\n                    eventWriter.setGetNextEventIdStr(m_getNextEventIdStr);\n                    eventWriter.afterPropertiesSet();\n                    \n                    alarmWriter = new AlarmWriter();\n                    alarmWriter.setDataSource(m_dataSource);\n                    alarmWriter.setEventdServiceManager(m_eventdServiceManager);\n                    alarmWriter.setGetNextAlarmIdStr(m_getNextAlarmIdStr);\n                    alarmWriter.afterPropertiesSet();\n                } catch (Throwable t) {\n                    log().warn(\"Exception creating EventWriter\", t);\n                    log().warn(\"Event(s) CANNOT be inserted into the database\");\n\n                    return;\n                }\n\n                Enumeration<Event> en = events.enumerateEvent();\n                while (en.hasMoreElements()) {\n                    Event event = en.nextElement();\n\n                    if (log().isDebugEnabled()) {\n                        // print out the eui, source, and other\n                        // important aspects\n                        //\n                        String uuid = event.getUuid();\n                        log().debug(\"Event {\");\n                        log().debug(\"  uuid  = \" + (uuid != null && uuid.length() > 0 ? uuid : \"<not-set>\"));\n                        log().debug(\"  uei   = \" + event.getUei());\n                        log().debug(\"  src   = \" + event.getSource());\n                        log().debug(\"  iface = \" + event.getInterface());\n                        log().debug(\"  time  = \" + event.getTime());\n                        Parm[] parms = (event.getParms() == null ? null : event.getParms().getParm());\n                        if (parms != null) {\n                            log().debug(\"  parms {\");\n                            for (int x = 0; x < parms.length; x++) {\n                                if ((parms[x].getParmName() != null) && (parms[x].getValue().getContent() != null)) {\n                                    log().debug(\"    (\" + parms[x].getParmName().trim() + \", \" + parms[x].getValue().getContent().trim() + \")\");\n                                }\n                            }\n                            log().debug(\"  }\");\n                        }\n                        log().debug(\"}\");\n                    }\n\n                    // look up eventconf match and expand event\n                    m_eventExpander.expandEvent(event);\n                    try {\n                        // add to database\n                        eventWriter.persistEvent(m_eventLog.getHeader(), event);\n                        // send event to interested listeners\n                        EventIpcManagerFactory.getIpcManager().broadcastNow(event);\n\n                        alarmWriter.persistAlarm(m_eventLog.getHeader(), event);\n                    } catch (SQLException sqle) {\n                        log().warn(\"Unable to add event to database\", sqle);\n                    } catch (Throwable t) {\n                        log().warn(\"Unknown exception processing event\", t);\n                    }\n                }\n            } finally {\n                if (alarmWriter != null) alarmWriter.close();\n            }\n        } finally {\n            \n            // close database related stuff in the eventwriter\n            if (eventWriter != null) eventWriter.close();\n        }\n    }","commit_id":"8187639c3f4e9349daa245b5f7f93dcbb1e2783e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public synchronized void afterPropertiesSet() {\n        Assert.state(m_eventdConfigMgr != null, \"eventdConfigMgr not set\");\n        Assert.state(m_eventExpander != null, \"eventExpander not set\");\n        \n        m_ueiListeners = new HashMap<String, List<EventListener>>();\n        m_listeners = new ArrayList<EventListener>();\n        m_listenerThreads = new HashMap<String, ListenerThread>();\n\n        // get number of threads\n        int numReceivers = m_eventdConfigMgr.getReceivers();\n        // create handler pool\n        m_eventHandlerPool = new RunnableConsumerThreadPool(\"EventHandlerPool\", 0.6f, 1.0f, numReceivers);\n        // start pool\n        m_eventHandlerPool.start();\n        // database sequence query string\n        m_getNextEventIdStr = m_eventdConfigMgr.getGetNextEventID();\n        m_getNextAlarmIdStr = m_eventdConfigMgr.getGetNextAlarmID();\n    }","id":6998,"modified_method":"public synchronized void afterPropertiesSet() {\n        Assert.state(m_eventdConfigMgr != null, \"eventdConfigMgr not set\");\n        Assert.state(m_eventExpander != null, \"eventExpander not set\");\n        Assert.state(m_dataSource != null, \"dataSource not set\");\n        Assert.state(m_eventdServiceManager != null, \"eventdServiceManager not set\");\n        \n        m_ueiListeners = new HashMap<String, List<EventListener>>();\n        m_listeners = new ArrayList<EventListener>();\n        m_listenerThreads = new HashMap<String, ListenerThread>();\n\n        // get number of threads\n        int numReceivers = m_eventdConfigMgr.getReceivers();\n        // create handler pool\n        m_eventHandlerPool = new RunnableConsumerThreadPool(\"EventHandlerPool\", 0.6f, 1.0f, numReceivers);\n        // start pool\n        m_eventHandlerPool.start();\n        // database sequence query string\n        m_getNextEventIdStr = m_eventdConfigMgr.getGetNextEventID();\n        m_getNextAlarmIdStr = m_eventdConfigMgr.getGetNextAlarmID();\n    }","commit_id":"8187639c3f4e9349daa245b5f7f93dcbb1e2783e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Called by a service to send a set of events to other listeners.\n     */\n    public synchronized void sendNow(Log eventLog) {\n\n        // create a new event handler for the events and queue it to the\n        // event handler thread pool\n        try {\n            m_eventHandlerPool.getRunQueue().add(new EventHandler(eventLog, m_getNextEventIdStr, m_getNextAlarmIdStr, m_eventExpander));\n        } catch (InterruptedException iE) {\n            log().warn(\"Unable to queue event log to the event handler pool queue\", iE);\n\n            throw new UndeclaredEventException(iE);\n        } catch (FifoQueueException qE) {\n            log().warn(\"Unable to queue event log to the event handler pool queue\", qE);\n\n            throw new UndeclaredEventException(qE);\n        }\n    }","id":6999,"modified_method":"/**\n     * Called by a service to send a set of events to other listeners.\n     */\n    public synchronized void sendNow(Log eventLog) {\n\n        // create a new event handler for the events and queue it to the\n        // event handler thread pool\n        try {\n            m_eventHandlerPool.getRunQueue().add(new EventHandler(eventLog, m_getNextEventIdStr, m_getNextAlarmIdStr, m_eventExpander, m_eventdServiceManager, m_dataSource));\n        } catch (InterruptedException iE) {\n            log().warn(\"Unable to queue event log to the event handler pool queue\", iE);\n\n            throw new UndeclaredEventException(iE);\n        } catch (FifoQueueException qE) {\n            log().warn(\"Unable to queue event log to the event handler pool queue\", qE);\n\n            throw new UndeclaredEventException(qE);\n        }\n    }","commit_id":"8187639c3f4e9349daa245b5f7f93dcbb1e2783e","url":"https://github.com/OpenNMS/opennms"}]