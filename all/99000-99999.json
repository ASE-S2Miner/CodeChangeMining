[{"original_method":"protected boolean isValidForFile(Project project, Editor editor, final PsiFile file) {\n    final FileType fileType = file.getFileType();\n    if (fileType instanceof AbstractFileType) {\n      return ((AbstractFileType)fileType).getCommenter() != null;\n    }\n    return LanguageCommenters.INSTANCE.forLanguage(file.getLanguage()) != null;\n  }","id":99000,"modified_method":"protected boolean isValidForFile(Project project, Editor editor, final PsiFile file) {\n    final FileType fileType = file.getFileType();\n    if (fileType instanceof AbstractFileType) {\n      return ((AbstractFileType)fileType).getCommenter() != null;\n    }\n    return LanguageCommenters.INSTANCE.forLanguage(file.getLanguage()) != null || LanguageCommenters.INSTANCE.forLanguage(file.getViewProvider().getBaseLanguage()) != null;\n  }","commit_id":"9eae0ab2283fbbf295ad89852ab1087c064dcd4c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private Commenter findCommenter(final int line) {\n    final FileType fileType = myFile.getFileType();\n    if (fileType instanceof AbstractFileType) {\n      return ((AbstractFileType)fileType).getCommenter();\n    }\n\n    int offset = myDocument.getLineStartOffset(line);\n    offset = CharArrayUtil.shiftForward(myDocument.getCharsSequence(), offset, \" \\t\");\n    Language language = PsiUtilBase.getLanguageAtOffset(myFile, offset);\n    return LanguageCommenters.INSTANCE.forLanguage(language);\n  }","id":99001,"modified_method":"@Nullable\n  private Commenter findCommenter(final int line) {\n    final FileType fileType = myFile.getFileType();\n    if (fileType instanceof AbstractFileType) {\n      return ((AbstractFileType)fileType).getCommenter();\n    }\n\n    int offset = myDocument.getLineStartOffset(line);\n    offset = CharArrayUtil.shiftForward(myDocument.getCharsSequence(), offset, \" \\t\");\n    Language language = PsiUtilBase.getLanguageAtOffset(myFile, offset);\n    final Commenter commenter = LanguageCommenters.INSTANCE.forLanguage(language);\n    return commenter == null ? LanguageCommenters.INSTANCE.forLanguage(myFile.getViewProvider().getBaseLanguage()) : commenter;\n  }","commit_id":"9eae0ab2283fbbf295ad89852ab1087c064dcd4c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n\t * @param id\n\t *            See Component\n\t * @param model\n\t *            See Component\n\t * @param choices\n\t *            The collection of choices in the dropdown\n\t * @see wicket.Component#Component(String, IModel)\n\t */\n\tpublic AbstractChoice(final String id, IModel model, final Collection choices)\n\t{\n\t\tthis(id, model, new ChoiceRenderer(), choices);\n\t}","id":99002,"modified_method":"/**\n\t * @param id\n\t *            See Component\n\t * @param model\n\t *            See Component\n\t * @param choices\n\t *            The collection of choices in the dropdown\n\t * @see wicket.Component#Component(String, IModel)\n\t */\n\tpublic AbstractChoice(final String id, IModel model, final List choices)\n\t{\n\t\tthis(id, model, choices, new ChoiceRenderer());\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @param id\n\t *            See Component\n\t * @param renderer\n\t *            The rendering engine\n\t * @param choices\n\t *            The collection of choices in the dropdown\n\t * @see wicket.Component#Component(String)\n\t */\n\tpublic AbstractChoice(final String id, final IChoiceRenderer renderer, final Collection choices)\n\t{\n\t\tsuper(id);\n\t\tthis.choices = choices;\n\t\tthis.renderer = renderer;\n\t}","id":99003,"modified_method":"/**\n\t * @param id\n\t *            See Component\n\t * @param renderer\n\t *            The rendering engine\n\t * @param choices\n\t *            The collection of choices in the dropdown\n\t * @see wicket.Component#Component(String)\n\t */\n\tpublic AbstractChoice(final String id, final List choices,final IChoiceRenderer renderer)\n\t{\n\t\tsuper(id);\n\t\tthis.choices = choices;\n\t\tthis.renderer = renderer;\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @return The collection of object that this choice has\n\t */\n\tpublic Collection getChoices()\n\t{\n\t\treturn choices;\n\t}","id":99004,"modified_method":"/**\n\t * @return The collection of object that this choice has\n\t */\n\tpublic List getChoices()\n\t{\n\t\treturn choices;\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @param id\n\t *            See Component\n\t * @param model\n\t *            See Component\n\t * @param renderer\n\t *            The rendering engine\n\t * @param choices\n\t *            The drop down choices\n\t * @see wicket.Component#Component(String, IModel)\n\t */\n\tpublic AbstractChoice(final String id, IModel model, final IChoiceRenderer renderer,\n\t\t\tfinal Collection choices)\n\t{\n\t\tsuper(id, model);\n\t\tthis.choices = choices;\n\t\tthis.renderer = renderer;\n\t}","id":99005,"modified_method":"/**\n\t * @param id\n\t *            See Component\n\t * @param model\n\t *            See Component\n\t * @param renderer\n\t *            The rendering engine\n\t * @param choices\n\t *            The drop down choices\n\t * @see wicket.Component#Component(String, IModel)\n\t */\n\tpublic AbstractChoice(final String id, IModel model, final List choices, final IChoiceRenderer renderer)\n\t{\n\t\tsuper(id, model);\n\t\tthis.choices = choices;\n\t\tthis.renderer = renderer;\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Handle the container's body.\n\t * \n\t * @param markupStream\n\t *            The markup stream\n\t * @param openTag\n\t *            The open tag for the body\n\t * @see wicket.Component#onComponentTagBody(MarkupStream, ComponentTag)\n\t */\n\tprotected void onComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag)\n\t{\n\t\tfinal StringBuffer buffer = new StringBuffer();\n\t\tfinal Object selected = getModelObject();\n\n\t\t// Append default option\n\t\tbuffer.append(getDefaultChoice(selected));\n\n\t\tfinal Iterator it = getChoices().iterator();\n\t\tint index = 0;\n\t\twhile (it.hasNext())\n\t\t{\n\t\t\tfinal Object object = it.next();\n\t\t\tif (object != null)\n\t\t\t{\n\t\t\t\tfinal String displayValue = renderer.getDisplayValue(object);\n\t\t\t\tbuffer.append(\"\\n<option \");\n\t\t\t\tif (isSelected(object, index))\n\t\t\t\t{\n\t\t\t\t\tbuffer.append(\"selected=\\\"selected\\\"\");\n\t\t\t\t}\n\t\t\t\tbuffer.append(\"value=\\\"\");\n\t\t\t\tbuffer.append(renderer.getIdValue(object, index));\n\t\t\t\tbuffer.append(\"\\\">\");\n\t\t\t\tString display = getLocalizer().getString(getId() + \".\" + displayValue, this,\n\t\t\t\t\t\tdisplayValue);\n\t\t\t\tString escaped = Strings.escapeMarkup(display, false, true);\n\t\t\t\tbuffer.append(escaped);\n\t\t\t\tbuffer.append(\"<\/option>\");\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new IllegalArgumentException(\"Choice list has null value at index \" + index);\n\t\t\t}\n\t\t}\n\n\t\tbuffer.append(\"\\n\");\n\t\treplaceComponentTagBody(markupStream, openTag, buffer.toString());\n\t}","id":99006,"modified_method":"/**\n\t * Handle the container's body.\n\t * \n\t * @param markupStream\n\t *            The markup stream\n\t * @param openTag\n\t *            The open tag for the body\n\t * @see wicket.Component#onComponentTagBody(MarkupStream, ComponentTag)\n\t */\n\tprotected void onComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag)\n\t{\n\t\tfinal StringBuffer buffer = new StringBuffer();\n\t\tfinal Object selected = getModelObject();\n\n\t\t// Append default option\n\t\tbuffer.append(getDefaultChoice(selected));\n\n\t\tList choices = getChoices();\n\t\tfor(int index=0;index<choices.size();index++)\n\t\t{\n\t\t\t// Get next choice\n\t\t\tfinal Object choice = choices.get(index);\n\t\t\tif (choice != null)\n\t\t\t{\n\t\t\t\tfinal String displayValue = renderer.getDisplayValue(choice);\n\t\t\t\tbuffer.append(\"\\n<option \");\n\t\t\t\tif (isSelected(choice, index))\n\t\t\t\t{\n\t\t\t\t\tbuffer.append(\"selected=\\\"selected\\\"\");\n\t\t\t\t}\n\t\t\t\tbuffer.append(\"value=\\\"\");\n\t\t\t\tbuffer.append(renderer.getIdValue(choice, index));\n\t\t\t\tbuffer.append(\"\\\">\");\n\t\t\t\tString display = getLocalizer().getString(getId() + \".\" + displayValue, this,\n\t\t\t\t\t\tdisplayValue);\n\t\t\t\tString escaped = Strings.escapeMarkup(display, false, true);\n\t\t\t\tbuffer.append(escaped);\n\t\t\t\tbuffer.append(\"<\/option>\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new IllegalArgumentException(\"Choice list has null value at index \" + index);\n\t\t\t}\n\t\t}\n\n\t\tbuffer.append(\"\\n\");\n\t\treplaceComponentTagBody(markupStream, openTag, buffer.toString());\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @param id\n\t *            See Component\n\t * @param choices\n\t *            The collection of choices in the dropdown\n\t * @see wicket.Component#Component(String)\n\t */\n\tpublic AbstractChoice(final String id, final Collection choices)\n\t{\n\t\tthis(id, new ChoiceRenderer(), choices);\n\t}","id":99007,"modified_method":"/**\n\t * @param id\n\t *            See Component\n\t * @param choices\n\t *            The collection of choices in the dropdown\n\t * @see wicket.Component#Component(String)\n\t */\n\tpublic AbstractChoice(final String id, final List choices)\n\t{\n\t\tthis(id, choices,new ChoiceRenderer());\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see FormComponent#getModelValue()\n\t */\n\tpublic final String getModelValue()\n\t{\n\t\tfinal Object object = getModelObject();\n\t\tif (object != null)\n\t\t{\n\t\t\tint index = -1;\n\t\t\tCollection collection = getChoices();\n\t\t\tif (collection instanceof List)\n\t\t\t{\n\t\t\t\tindex = ((List)collection).indexOf(object);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIterator it = collection.iterator();\n\t\t\t\twhile (it.hasNext())\n\t\t\t\t{\n\t\t\t\t\tindex++;\n\t\t\t\t\tif (it.next().equals(object))\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn getChoiceRenderer().getIdValue(object, index);\n\t\t}\n\t\treturn \"-1\";\n\t}","id":99008,"modified_method":"/**\n\t * @see FormComponent#getModelValue()\n\t */\n\tpublic final String getModelValue()\n\t{\n\t\tfinal Object object = getModelObject();\n\t\tif (object != null)\n\t\t{\n\t\t\tint index = getChoices().indexOf(object);\n\t\t\treturn getChoiceRenderer().getIdValue(object, index);\n\t\t}\n\t\treturn \"-1\";\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @param id\n\t * @param renderer\n\t * @param data\n\t * @see AbstractChoice#AbstractChoice(String, IChoiceRenderer ,Collection)\n\t */\n\tpublic AbstractSingleSelectChoice(final String id, final IChoiceRenderer renderer,\n\t\t\tfinal Collection data)\n\t{\n\t\tsuper(id, renderer, data);\n\t}","id":99009,"modified_method":"/**\n\t * @param id \n\t * @param data \n\t * @param renderer \n\t * @see AbstractChoice#AbstractChoice(String, List ,IChoiceRenderer)\n\t */\n\tpublic AbstractSingleSelectChoice(final String id, final List data, final IChoiceRenderer renderer)\n\t{\n\t\tsuper(id, data,renderer);\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see AbstractChoice#AbstractChoice(String, Collection)\n\t */\n\tpublic AbstractSingleSelectChoice(final String id, final Collection choices)\n\t{\n\t\tsuper(id, choices);\n\t}","id":99010,"modified_method":"/**\n\t * @see AbstractChoice#AbstractChoice(String, List)\n\t */\n\tpublic AbstractSingleSelectChoice(final String id, final List choices)\n\t{\n\t\tsuper(id, choices);\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @param id\n\t * @param model\n\t * @param renderer\n\t * @param data\n\t * @see AbstractChoice#AbstractChoice(String, IModel, IChoiceRenderer,\n\t *      Collection)\n\t */\n\tpublic AbstractSingleSelectChoice(final String id, IModel model,\n\t\t\tfinal IChoiceRenderer renderer, final Collection data)\n\t{\n\t\tsuper(id, model, renderer, data);\n\t}","id":99011,"modified_method":"/**\n\t * @param id \n\t * @param model \n\t * @param data \n\t * @param renderer \n\t * @see AbstractChoice#AbstractChoice(String, IModel, List, IChoiceRenderer)\n\t */\n\tpublic AbstractSingleSelectChoice(final String id, IModel model, final List data, final IChoiceRenderer renderer)\n\t{\n\t\tsuper(id, model,data, renderer);\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see FormComponent#setModelValue(java.lang.String)\n\t */\n\tpublic final void setModelValue(final String value)\n\t{\n\t\tIterator it = getChoices().iterator();\n\t\tint index = -1;\n\t\twhile (it.hasNext())\n\t\t{\n\t\t\tindex++;\n\t\t\tObject object = it.next();\n\t\t\tif (getChoiceRenderer().getIdValue(object, index).equals(value))\n\t\t\t{\n\t\t\t\tsetModelObject(object);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}","id":99012,"modified_method":"/**\n\t * @see FormComponent#setModelValue(java.lang.String)\n\t */\n\tpublic final void setModelValue(final String value)\n\t{\n\t\tList choices = getChoices();\n\t\tfor(int index=0;index<choices.size();index++)\n\t\t{\n\t\t\t// Get next choice\n\t\t\tfinal Object choice = choices.get(index);\n\t\t\tif(getChoiceRenderer().getIdValue(choice, index).equals(value))\n\t\t\t{\n\t\t\t\tsetModelObject(choice);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see AbstractChoice#AbstractChoice(String, IModel, Collection)\n\t */\n\tpublic AbstractSingleSelectChoice(final String id, IModel model, final Collection data)\n\t{\n\t\tsuper(id, model, data);\n\t}","id":99013,"modified_method":"/**\n\t * @see AbstractChoice#AbstractChoice(String, IModel, List)\n\t */\n\tpublic AbstractSingleSelectChoice(final String id, IModel model, final List data)\n\t{\n\t\tsuper(id, model, data);\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, IModel, Collection)\n\t */\n\tpublic DropDownChoice(final String id, IModel model, final Collection choices)\n\t{\n\t\tsuper(id, model, choices);\n\t}","id":99014,"modified_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, IModel, List)\n\t */\n\tpublic DropDownChoice(final String id, IModel model, final List choices)\n\t{\n\t\tsuper(id, model, choices);\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, IChoiceRenderer,Collection)\n\t */\n\tpublic DropDownChoice(final String id, final IChoiceRenderer renderer, final Collection data)\n\t{\n\t\tsuper(id,renderer, data);\n\t}","id":99015,"modified_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, List,IChoiceRenderer)\n\t */\n\tpublic DropDownChoice(final String id, final List data, final IChoiceRenderer renderer)\n\t{\n\t\tsuper(id,data, renderer);\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, IModel, IChoiceRenderer, Collection)\n\t */\n\tpublic DropDownChoice(final String id, IModel model, final IChoiceRenderer renderer, final Collection data)\n\t{\n\t\tsuper(id, model,renderer, data);\n\t}","id":99016,"modified_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, IModel, List, IChoiceRenderer)\n\t */\n\tpublic DropDownChoice(final String id, IModel model, final List data, final IChoiceRenderer renderer)\n\t{\n\t\tsuper(id, model,data, renderer);\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, Collection)\n\t */\n\tpublic DropDownChoice(final String id, final Collection choices)\n\t{\n\t\tsuper(id, choices);\n\t}","id":99017,"modified_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, List)\n\t */\n\tpublic DropDownChoice(final String id, final List choices)\n\t{\n\t\tsuper(id, choices);\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @param id\n\t *\t\t\t  See Component\n\t * @param model\n\t *\t\t\t  See Component\n\t * @param renderer\n\t * \t\t\t  See AbstractChoice \n\t * @param values\n\t *\t\t\t  The collection of values in the list\n\t * @param maxRows\n\t *\t\t\t  Maximum number of rows to show\n\t * @see DropDownChoice#DropDownChoice(String, IModel, Collection)\n\t */\n\tpublic ListChoice(final String id, final IModel model, final IChoiceRenderer renderer, final Collection values, final int maxRows)\n\t{\n\t\tsuper(id, model, renderer,values);\n\t\tthis.maxRows = maxRows;\n\t}","id":99018,"modified_method":"/**\n\t * @param id\n\t *\t\t\t  See Component\n\t * @param model\n\t *\t\t\t  See Component\n\t * @param choices\n\t *\t\t\t  The collection of values in the list\n\t * @param renderer\n\t * \t\t\t  See AbstractChoice \n\t * @param maxRows\n\t *\t\t\t  Maximum number of rows to show\n\t * @see DropDownChoice#DropDownChoice(String, IModel, List)\n\t */\n\tpublic ListChoice(final String id, final IModel model, final List choices, final IChoiceRenderer renderer, final int maxRows)\n\t{\n\t\tsuper(id, model, choices,renderer);\n\t\tthis.maxRows = maxRows;\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @param id\n\t *\t\t\t  See Component\n\t * @param model\n\t *\t\t\t  See Component\n\t * @param values\n\t *\t\t\t  The collection of values in the list\n\t * @see DropDownChoice#DropDownChoice(String, IModel, Collection)\n\t */\n\tpublic ListChoice(final String id, final IModel model, final Collection values)\n\t{\n\t\tthis(id, model, values, defaultMaxRows);\n\t}","id":99019,"modified_method":"/**\n\t * @param id\n\t *\t\t\t  See Component\n\t * @param model\n\t *\t\t\t  See Component\n\t * @param choices\n\t *\t\t\t  The collection of values in the list\n\t * @see DropDownChoice#DropDownChoice(String, IModel, List)\n\t */\n\tpublic ListChoice(final String id, final IModel model, final List choices)\n\t{\n\t\tthis(id, model, choices, defaultMaxRows);\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @param id\n\t *\t\t\t  See Component\n\t * @param model\n\t *\t\t\t  See Component\n\t * @param renderer\n\t * \t\t\t  See AbstractChoice \n\t * @param values\n\t *\t\t\t  The collection of values in the list\n\t * @see DropDownChoice#DropDownChoice(String, IModel, Collection)\n\t */\n\tpublic ListChoice(final String id, final IModel model, final IChoiceRenderer renderer,final Collection values)\n\t{\n\t\tthis(id, model, renderer,values, defaultMaxRows);\n\t}","id":99020,"modified_method":"/**\n\t * @param id\n\t *\t\t\t  See Component\n\t * @param model\n\t *\t\t\t  See Component\n\t * @param choices\n\t *\t\t\t  The collection of values in the list\n\t * @param renderer\n\t * \t\t\t  See AbstractChoice \n\t * @see DropDownChoice#DropDownChoice(String, IModel, List)\n\t */\n\tpublic ListChoice(final String id, final IModel model, final List choices,final IChoiceRenderer renderer)\n\t{\n\t\tthis(id, model, choices,renderer, defaultMaxRows);\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, IChoiceRenderer,Collection)\n\t */\n\tpublic ListChoice(final String id, final IChoiceRenderer renderer,final Collection values)\n\t{\n\t\tsuper(id, renderer,values);\n\t}","id":99021,"modified_method":"/**\n\t * @param id\n\t *\t\t\t  See Component\n\t * @param choices\n\t *\t\t\t  The collection of values in the list\n\t * @param renderer\n\t * \t\t\t  See AbstractChoice \n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, List,IChoiceRenderer)\n\t */\n\tpublic ListChoice(final String id, final List choices,final IChoiceRenderer renderer)\n\t{\n\t\tsuper(id, choices,renderer);\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, Collection)\n\t */\n\tpublic ListChoice(final String id, final Collection values)\n\t{\n\t\tsuper(id, values);\n\t}","id":99022,"modified_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, List)\n\t */\n\tpublic ListChoice(final String id, final List values)\n\t{\n\t\tsuper(id, values);\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @param id\n\t *\t\t\t  See Component\n\t * @param model\n\t *\t\t\t  See Component\n\t * @param values\n\t *\t\t\t  The collection of values in the list\n\t * @param maxRows\n\t *\t\t\t  Maximum number of rows to show\n\t * @see DropDownChoice#DropDownChoice(String, IModel, Collection)\n\t */\n\tpublic ListChoice(final String id, final IModel model, final Collection values, final int maxRows)\n\t{\n\t\tsuper(id, model, values);\n\t\tthis.maxRows = maxRows;\n\t}","id":99023,"modified_method":"/**\n\t * @param id\n\t *\t\t\t  See Component\n\t * @param model\n\t *\t\t\t  See Component\n\t * @param choices\n\t *\t\t\t  The collection of values in the list\n\t * @param maxRows\n\t *\t\t\t  Maximum number of rows to show\n\t * @see DropDownChoice#DropDownChoice(String, IModel, List)\n\t */\n\tpublic ListChoice(final String id, final IModel model, final List choices, final int maxRows)\n\t{\n\t\tsuper(id, model, choices);\n\t\tthis.maxRows = maxRows;\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, IChoiceRenderer,Collection)\n\t */\n\tpublic ListMultipleChoice(final String id, final IChoiceRenderer renderer, final Collection choices)\n\t{\n\t\tsuper(id, renderer,choices);\n\t}","id":99024,"modified_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, List,IChoiceRenderer)\n\t */\n\tpublic ListMultipleChoice(final String id, final List choices, final IChoiceRenderer renderer)\n\t{\n\t\tsuper(id, choices,renderer);\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see FormComponent#updateModel()\n\t */\n\tprotected final void updateModel()\n\t{\n\t\t// Get the list of selected values\n\t\tCollection selectedValues = (Collection)getModelObject();\n\n\t\tif (selectedValues != null)\n\t\t{\n\t\t\tselectedValues.clear();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tselectedValues = new ArrayList();\n\t\t\tsetModelObject(selectedValues);\n\t\t}\n\n\t\t// Get indices selected from request\n\t\tfinal String[] ids = inputAsStringArray();\n\n\t\t// If one or more ids is selected\n\t\tif (ids != null && ids.length > 0 && !Strings.isEmpty(ids[0]))\n\t\t{\n\t\t\t// Get values that could be selected\n\t\t\tfinal Collection choices = getChoices();\n\n\t\t\t// Loop through selected indices\n\t\t\tfor (int i = 0; i < ids.length; i++)\n\t\t\t{\n\t\t\t\tIterator it = getChoices().iterator();\n\t\t\t\tint index = -1;\n\t\t\t\twhile(it.hasNext())\n\t\t\t\t{\n\t\t\t\t\tindex++;\n\t\t\t\t\tObject object = it.next();\n\t\t\t\t\tif(getChoiceRenderer().getIdValue(object, index).equals(ids[i]))\n\t\t\t\t\t{\n\t\t\t\t\t\tselectedValues.add(object);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":99025,"modified_method":"/**\n\t * @see FormComponent#updateModel()\n\t */\n\tprotected final void updateModel()\n\t{\n\t\t// Get the list of selected values\n\t\tCollection selectedValues = (Collection)getModelObject();\n\n\t\tif (selectedValues != null)\n\t\t{\n\t\t\tselectedValues.clear();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tselectedValues = new ArrayList();\n\t\t\tsetModelObject(selectedValues);\n\t\t}\n\n\t\t// Get indices selected from request\n\t\tfinal String[] ids = inputAsStringArray();\n\n\t\t// If one or more ids is selected\n\t\tif (ids != null && ids.length > 0 && !Strings.isEmpty(ids[0]))\n\t\t{\n\t\t\t// Get values that could be selected\n\t\t\tfinal List choices = getChoices();\n\n\t\t\t// Loop through selected indices\n\t\t\tfor (int i = 0; i < ids.length; i++)\n\t\t\t{\n\t\t\t\tfor(int index=0;index<choices.size();index++)\n\t\t\t\t{\n\t\t\t\t\t// Get next choice\n\t\t\t\t\tfinal Object choice = choices.get(index);\n\t\t\t\t\tif(getChoiceRenderer().getIdValue(choice, index).equals(ids[i]))\n\t\t\t\t\t{\n\t\t\t\t\t\tselectedValues.add(choice);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, IModel, IChoiceRenderer,Collection)\n\t */\n\tpublic ListMultipleChoice(final String id, IModel object, final IChoiceRenderer renderer, final Collection choices)\n\t{\n\t\tsuper(id, object, choices);\n\t}","id":99026,"modified_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, IModel, List,IChoiceRenderer)\n\t */\n\tpublic ListMultipleChoice(final String id, IModel object, final List choices, final IChoiceRenderer renderer)\n\t{\n\t\tsuper(id, object, choices);\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see FormComponent#getModelValue()\n\t */\n\tpublic final String getModelValue()\n\t{\n\t\t// Get the list of selected values\n\t\tfinal Collection selectedValues = (Collection)getModelObject();\n\t\tfinal StringBuffer buffer = new StringBuffer();\n\t\tif (selectedValues != null)\n\t\t{\n\t\t\tfinal Collection choices = getChoices();\n\t\t\tfor (final Iterator iterator = selectedValues.iterator(); iterator.hasNext();)\n\t\t\t{\n\t\t\t\tfinal Object object = iterator.next();\n\t\t\t\t\n\t\t\t\tint index = -1;\n\t\t\t\tif(choices instanceof List)\n\t\t\t\t{\n\t\t\t\t\tindex = ((List)choices).indexOf(object);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tIterator it = choices.iterator();\n\t\t\t\t\twhile(it.hasNext())\n\t\t\t\t\t{\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tif(it.next().equals(object)) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbuffer.append(getChoiceRenderer().getIdValue(object, index));\n\t\t\t\tbuffer.append(\";\");\n\t\t\t}\n\t\t}\n\t\treturn buffer.toString();\n\t}","id":99027,"modified_method":"/**\n\t * @see FormComponent#getModelValue()\n\t */\n\tpublic final String getModelValue()\n\t{\n\t\t// Get the list of selected values\n\t\tfinal Collection selectedValues = (Collection)getModelObject();\n\t\tfinal StringBuffer buffer = new StringBuffer();\n\t\tif (selectedValues != null)\n\t\t{\n\t\t\tfinal List choices = getChoices();\n\t\t\tfor (final Iterator iterator = selectedValues.iterator(); iterator.hasNext();)\n\t\t\t{\n\t\t\t\tfinal Object object = iterator.next();\n\t\t\t\t\n\t\t\t\tint index = choices.indexOf(object);\n\t\t\t\tbuffer.append(getChoiceRenderer().getIdValue(object, index));\n\t\t\t\tbuffer.append(\";\");\n\t\t\t}\n\t\t}\n\t\treturn buffer.toString();\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, IModel, Collection)\n\t */\n\tpublic ListMultipleChoice(final String id, IModel object, final Collection choices)\n\t{\n\t\tsuper(id, object, choices);\n\t}","id":99028,"modified_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, IModel, List)\n\t */\n\tpublic ListMultipleChoice(final String id, IModel object, final List choices)\n\t{\n\t\tsuper(id, object, choices);\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, Collection)\n\t */\n\tpublic ListMultipleChoice(final String id, final Collection choices)\n\t{\n\t\tsuper(id, choices);\n\t}","id":99029,"modified_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, List)\n\t */\n\tpublic ListMultipleChoice(final String id, final List choices)\n\t{\n\t\tsuper(id, choices);\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see FormComponent#setModelValue(java.lang.String)\n\t */\n\tpublic final void setModelValue(final String value)\n\t{\n\t\tCollection selectedValues = (Collection)getModelObject();\n\t\tif (selectedValues == null)\n\t\t{\n\t\t\tselectedValues = new ArrayList();\n\t\t\tsetModelObject(selectedValues);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tselectedValues.clear();\n\t\t}\n\t\tfinal Collection choices = getChoices();\n\t\tfor (final StringTokenizer tokenizer = new StringTokenizer(value, \";\"); tokenizer\n\t\t\t\t.hasMoreTokens();)\n\t\t{\n\t\t\tString selected = tokenizer.nextToken();\n\t\t\t\n\t\t\tIterator it = getChoices().iterator();\n\t\t\tint index = -1;\n\t\t\twhile(it.hasNext())\n\t\t\t{\n\t\t\t\tindex++;\n\t\t\t\tObject object = it.next();\n\t\t\t\tif(getChoiceRenderer().getIdValue(object, index).equals(selected))\n\t\t\t\t{\n\t\t\t\t\tselectedValues.add(object);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}","id":99030,"modified_method":"/**\n\t * @see FormComponent#setModelValue(java.lang.String)\n\t */\n\tpublic final void setModelValue(final String value)\n\t{\n\t\tCollection selectedValues = (Collection)getModelObject();\n\t\tif (selectedValues == null)\n\t\t{\n\t\t\tselectedValues = new ArrayList();\n\t\t\tsetModelObject(selectedValues);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tselectedValues.clear();\n\t\t}\n\t\tfinal List choices = getChoices();\n\t\tfor (final StringTokenizer tokenizer = new StringTokenizer(value, \";\"); tokenizer\n\t\t\t\t.hasMoreTokens();)\n\t\t{\n\t\t\tString selected = tokenizer.nextToken();\n\t\t\t\n\t\t\tfor(int index=0;index<choices.size();index++)\n\t\t\t{\n\t\t\t\t// Get next choice\n\t\t\t\tfinal Object choice = choices.get(index);\n\t\t\t\tif(getChoiceRenderer().getIdValue(choice, index).equals(selected))\n\t\t\t\t{\n\t\t\t\t\tselectedValues.add(choice);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, Collection)\n\t */\n\tpublic RadioChoice(final String id, final Collection choices)\n\t{\n\t\tsuper(id, choices);\n\t}","id":99031,"modified_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, List)\n\t */\n\tpublic RadioChoice(final String id, final List choices)\n\t{\n\t\tsuper(id, choices);\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.Component#onComponentTagBody(MarkupStream, ComponentTag)\n\t */\n\tprotected final void onComponentTagBody(final MarkupStream markupStream,\n\t\t\tfinal ComponentTag openTag)\n\t{\n\t\t// Buffer to hold generated body\n\t\tfinal StringBuffer buffer = new StringBuffer();\n\n\t\t// Iterate through choices\n\t\tfinal Collection choices = getChoices();\n\n\t\t// Loop through choices\n\t\tint index = -1;\n\t\tIterator it = choices.iterator();\n\t\twhile(it.hasNext())\n\t\t{\n\t\t\tindex++;\n\t\t\t// Get next choice\n\t\t\tfinal Object choice = it.next();\n\n\t\t\t// Get label for choice\n\t\t\tfinal String label = getChoiceRenderer().getDisplayValue(choice);\n\n\t\t\t// If there is a display value for the choice, then we know that the\n\t\t\t// choice is automatic in some way. If label is /null/ then we know\n\t\t\t// that the choice is a manually created radio tag at some random\n\t\t\t// location in the page markup!\n\t\t\tif (label != null)\n\t\t\t{\n\t\t\t\t// Append option suffix\n\t\t\t\tbuffer.append(getPrefix());\n\n\t\t\t\tString id = getChoiceRenderer().getIdValue(choice, index);\n\t\t\t\t// Add radio tag\n\t\t\t\tbuffer.append(\"<input name=\\\"\" + getPath() + \"\\\"\" + \" type=\\\"radio\\\"\"\n\t\t\t\t\t\t+ (isSelected(choice,index) ? \" checked\" : \"\") + \" value=\\\"\" + id\n\t\t\t\t\t\t+ \"\\\"\");\n\t\t\t\t\n\t\t\t\t// Should a roundtrip be made (have onSelectionChanged called) when the option is clicked?\n\t\t\t\tif (wantOnSelectionChangedNotifications())\n\t\t\t\t{\n\t\t\t\t\tfinal String url = urlFor(IOnChangeListener.class);\n\n\t\t\t\t\t// NOTE: do not encode the url as that would give invalid JavaScript\n\t\t\t\t\tbuffer.append(\" onclick=\\\"location.href='\" + url + \"&\" + getPath()\n\t\t\t\t\t\t\t+ \"=\" + id + \"';\\\"\");\n\t\t\t\t}\n\n\t\t\t\tbuffer.append(\">\");\n\n\t\t\t\t// Add label for radio button\n\t\t\t\tString display = getLocalizer().getString(getId() + \".\" + label, this, label);\n\t\t\t\tString escaped = Strings.escapeMarkup(display, false, true);\n\t\t\t\tbuffer.append(escaped);\n\n\t\t\t\t// Append option suffix\n\t\t\t\tbuffer.append(getSuffix());\n\t\t\t}\n\t\t}\n\n\t\t// Replace body\n\t\treplaceComponentTagBody(markupStream, openTag, buffer.toString());\n\t}","id":99032,"modified_method":"/**\n\t * @see wicket.Component#onComponentTagBody(MarkupStream, ComponentTag)\n\t */\n\tprotected final void onComponentTagBody(final MarkupStream markupStream,\n\t\t\tfinal ComponentTag openTag)\n\t{\n\t\t// Buffer to hold generated body\n\t\tfinal StringBuffer buffer = new StringBuffer();\n\n\t\t// Iterate through choices\n\t\tfinal List choices = getChoices();\n\n\t\t// Loop through choices\n\t\t\n\t\t\n\t\tfor(int index=0;index<choices.size();index++)\n\t\t{\n\t\t\t// Get next choice\n\t\t\tfinal Object choice = choices.get(index);\n\n\t\t\t// Get label for choice\n\t\t\tfinal String label = getChoiceRenderer().getDisplayValue(choice);\n\n\t\t\t// If there is a display value for the choice, then we know that the\n\t\t\t// choice is automatic in some way. If label is /null/ then we know\n\t\t\t// that the choice is a manually created radio tag at some random\n\t\t\t// location in the page markup!\n\t\t\tif (label != null)\n\t\t\t{\n\t\t\t\t// Append option suffix\n\t\t\t\tbuffer.append(getPrefix());\n\n\t\t\t\tString id = getChoiceRenderer().getIdValue(choice, index);\n\t\t\t\t// Add radio tag\n\t\t\t\tbuffer.append(\"<input name=\\\"\" + getPath() + \"\\\"\" + \" type=\\\"radio\\\"\"\n\t\t\t\t\t\t+ (isSelected(choice,index) ? \" checked\" : \"\") + \" value=\\\"\" + id\n\t\t\t\t\t\t+ \"\\\"\");\n\t\t\t\t\n\t\t\t\t// Should a roundtrip be made (have onSelectionChanged called) when the option is clicked?\n\t\t\t\tif (wantOnSelectionChangedNotifications())\n\t\t\t\t{\n\t\t\t\t\tfinal String url = urlFor(IOnChangeListener.class);\n\n\t\t\t\t\t// NOTE: do not encode the url as that would give invalid JavaScript\n\t\t\t\t\tbuffer.append(\" onclick=\\\"location.href='\" + url + \"&\" + getPath()\n\t\t\t\t\t\t\t+ \"=\" + id + \"';\\\"\");\n\t\t\t\t}\n\n\t\t\t\tbuffer.append(\">\");\n\n\t\t\t\t// Add label for radio button\n\t\t\t\tString display = getLocalizer().getString(getId() + \".\" + label, this, label);\n\t\t\t\tString escaped = Strings.escapeMarkup(display, false, true);\n\t\t\t\tbuffer.append(escaped);\n\n\t\t\t\t// Append option suffix\n\t\t\t\tbuffer.append(getSuffix());\n\t\t\t}\n\t\t}\n\n\t\t// Replace body\n\t\treplaceComponentTagBody(markupStream, openTag, buffer.toString());\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, IModel, IChoiceRenderer,Collection)\n\t */\n\tpublic RadioChoice(final String id, IModel model, final IChoiceRenderer renderer, final Collection choices)\n\t{\n\t\tsuper(id, model, renderer,choices);\n\t}","id":99033,"modified_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, IModel, List,IChoiceRenderer)\n\t */\n\tpublic RadioChoice(final String id, IModel model, final List choices, final IChoiceRenderer renderer)\n\t{\n\t\tsuper(id, model, choices,renderer);\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, IModel, Collection)\n\t */\n\tpublic RadioChoice(final String id, IModel model, final Collection choices)\n\t{\n\t\tsuper(id, model, choices);\n\t}","id":99034,"modified_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, IModel, List)\n\t */\n\tpublic RadioChoice(final String id, IModel model, final List choices)\n\t{\n\t\tsuper(id, model, choices);\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, IChoiceRenderer,Collection)\n\t */\n\tpublic RadioChoice(final String id, final IChoiceRenderer renderer, final Collection choices)\n\t{\n\t\tsuper(id,renderer,choices);\n\t}","id":99035,"modified_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, List,IChoiceRenderer)\n\t */\n\tpublic RadioChoice(final String id, final List choices, final IChoiceRenderer renderer)\n\t{\n\t\tsuper(id,choices,renderer);\n\t}","commit_id":"329ec332937494154ded75198f22e50c00cab83c","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see FormComponent#getModelValue()\n\t */\n\t@Override\n\tpublic String getModelValue()\n\t{\n\t\tfinal T object = getModelObject();\n\t\tif (object != null)\n\t\t{\n\t\t\tint index = getChoices().indexOf(object);\n\n\t\t\tif (index < 0)\n\t\t\t{\n\t\t\t\t// the model is returning a choice that is not in the available choices collection\n\n\t\t\t\tlogger.warn(\n\t\t\t\t\t\"Detected inconsistency in choice component: {}/{}. Model returned object: {}, but this object is not available in the list of selected objects.\",\n\t\t\t\t\tnew Object[] { getPage().getClass(), getPageRelativePath(), object });\n\n\t\t\t\t// pretend like nothing is selected\n\n\t\t\t\treturn \"\";\n\t\t\t}\n\n\t\t\treturn getChoiceRenderer().getIdValue(object, index);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn \"\";\n\t\t}\n\t}","id":99036,"modified_method":"/**\n\t * @see FormComponent#getModelValue()\n\t */\n\t@Override\n\tpublic String getModelValue()\n\t{\n\t\tfinal T object = getModelObject();\n\t\tif (object != null)\n\t\t{\n\t\t\tint index = -1;\n\n\t\t\tList<? extends T> choices = getChoices();\n\t\t\tfor (int i = 0; i < choices.size(); i++)\n\t\t\t{\n\t\t\t\tString otherId = getChoiceRenderer().getIdValue(choices.get(i), i);\n\t\t\t\tif (isSelected(object, i, otherId))\n\t\t\t\t{\n\t\t\t\t\tindex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (index < 0)\n\t\t\t{\n\t\t\t\t// the model is returning a choice that is not in the available choices collection\n\n\t\t\t\tlogger.warn(\n\t\t\t\t\t\"Detected inconsistency in choice component: {}/{}. Model returned object: {}, but this object is not available in the list of selected objects.\",\n\t\t\t\t\tnew Object[] { getPage().getClass(), getPageRelativePath(), object });\n\n\t\t\t\t// pretend like nothing is selected\n\n\t\t\t\treturn \"\";\n\t\t\t}\n\n\t\t\treturn getChoiceRenderer().getIdValue(object, index);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn \"\";\n\t\t}\n\t}","commit_id":"ec4687fec7c2216c7859028261b397985a85c767","url":"https://github.com/apache/wicket"},{"original_method":"@Test @Ignore(\"JH: Admitting defeat for the weekend, revisiting tomorrow, monday 4th of november\")\n    public void populatingSchemaIndicesOnMasterShouldBeBroughtOnlineOnSlavesAfterStoreCopy() throws Throwable\n    {\n        /*\n        The master has an index that is currently populating.\n        Then a slave comes online and contacts the master to get copies of the store files.\n        Because the index is still populating, it won't be copied. Instead the slave will build its own.\n        We want to observe that the slave builds an index that eventually comes online.\n         */\n\n\n        // GIVEN\n        ControlledGraphDatabaseFactory dbFactory = new ControlledGraphDatabaseFactory();\n\n        ManagedCluster cluster = clusterRule.startCluster( dbFactory );\n\n        try\n        {\n            cluster.await( allSeesAllAsAvailable() );\n\n            HighlyAvailableGraphDatabase slave = cluster.getAnySlave();\n\n            // All slaves in the cluster, except the one I care about, proceed as normal\n            proceedAsNormalWithIndexPopulationOnAllSlavesExcept( dbFactory, cluster, slave );\n\n            // A slave is offline, and has no store files\n            ClusterManager.RepairKit slaveDown = bringSlaveOfflineAndRemoveStoreFiles( cluster, slave );\n\n            // And I create an index on the master, and wait for population to start\n            HighlyAvailableGraphDatabase master = cluster.getMaster();\n            Map<Object, Node> data = createSomeData(master);\n            createIndex( master );\n            dbFactory.awaitPopulationStarted( master );\n\n\n            // WHEN the slave comes online before population has finished on the master\n            slave = slaveDown.repair();\n            cluster.await( allSeesAllAsAvailable(), 180 );\n            cluster.sync();\n\n\n            // THEN, population should finish successfully on both master and slave\n            dbFactory.triggerFinish( master );\n            dbFactory.triggerFinish( slave );\n\n            // Check master\n            IndexDefinition index;\n            try ( Transaction tx = master.beginTx())\n            {\n                index = single( master.schema().getIndexes() );\n                awaitIndexOnline( index, master, data );\n                tx.success();\n            }\n\n            // Check slave\n            try ( Transaction tx = slave.beginTx() )\n            {\n                awaitIndexOnline( index, slave, data );\n                tx.success();\n            }\n        }\n        finally\n        {\n            for ( HighlyAvailableGraphDatabase db : cluster.getAllMembers() )\n            {\n                dbFactory.triggerFinish( db );\n            }\n        }\n    }","id":99037,"modified_method":"@Test\n    public void populatingSchemaIndicesOnMasterShouldBeBroughtOnlineOnSlavesAfterStoreCopy() throws Throwable\n    {\n        /*\n        The master has an index that is currently populating.\n        Then a slave comes online and contacts the master to get copies of the store files.\n        Because the index is still populating, it won't be copied. Instead the slave will build its own.\n        We want to observe that the slave builds an index that eventually comes online.\n         */\n\n        // GIVEN\n        ControlledGraphDatabaseFactory dbFactory = new ControlledGraphDatabaseFactory( IS_MASTER );\n\n        ManagedCluster cluster = clusterRule.startCluster( dbFactory );\n\n        try\n        {\n            cluster.await( allSeesAllAsAvailable() );\n\n            HighlyAvailableGraphDatabase slave = cluster.getAnySlave();\n\n            // A slave is offline, and has no store files\n            ClusterManager.RepairKit slaveDown = bringSlaveOfflineAndRemoveStoreFiles( cluster, slave );\n\n            // And I create an index on the master, and wait for population to start\n            HighlyAvailableGraphDatabase master = cluster.getMaster();\n            Map<Object, Node> data = createSomeData(master);\n            createIndex( master );\n            dbFactory.awaitPopulationStarted( master );\n\n\n            // WHEN the slave comes online before population has finished on the master\n            slave = slaveDown.repair();\n            cluster.await( allSeesAllAsAvailable(), 180 );\n            cluster.sync();\n\n\n            // THEN, population should finish successfully on both master and slave\n            dbFactory.triggerFinish( master );\n\n            // Check master\n            IndexDefinition index;\n            try ( Transaction tx = master.beginTx())\n            {\n                index = single( master.schema().getIndexes() );\n                awaitIndexOnline( index, master, data );\n                tx.success();\n            }\n\n            // Check slave\n            try ( Transaction tx = slave.beginTx() )\n            {\n                awaitIndexOnline( index, slave, data );\n                tx.success();\n            }\n        }\n        finally\n        {\n            for ( HighlyAvailableGraphDatabase db : cluster.getAllMembers() )\n            {\n                dbFactory.triggerFinish( db );\n            }\n        }\n    }","commit_id":"426aeb51dd707f191bebab1be12c4705fb4b7d98","url":"https://github.com/neo4j/neo4j"},{"original_method":"public ControlledGraphDatabaseFactory()\n        {\n            factory = new ControllingIndexProviderFactory(perDbIndexProvider);\n        }","id":99038,"modified_method":"public ControlledGraphDatabaseFactory()\n        {\n            factory = new ControllingIndexProviderFactory(perDbIndexProvider, Predicates.<GraphDatabaseService>TRUE());\n        }","commit_id":"426aeb51dd707f191bebab1be12c4705fb4b7d98","url":"https://github.com/neo4j/neo4j"},{"original_method":"void awaitPopulationStarted( GraphDatabaseService db )\n        {\n            DoubleLatch latch = ((ControlledSchemaIndexProvider)perDbIndexProvider.get( db )).latch;\n            latch.awaitStart();\n        }","id":99039,"modified_method":"void awaitPopulationStarted( GraphDatabaseService db )\n        {\n            ControlledSchemaIndexProvider provider = (ControlledSchemaIndexProvider) perDbIndexProvider.get( db );\n            if(provider != null ) provider.latch.awaitStart();\n        }","commit_id":"426aeb51dd707f191bebab1be12c4705fb4b7d98","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        public Lifecycle newKernelExtension( SchemaIndexHaIT.IndexProviderDependencies deps ) throws Throwable\n        {\n\n            ControlledSchemaIndexProvider provider = new ControlledSchemaIndexProvider(\n                    new LuceneSchemaIndexProvider( DirectoryFactory.PERSISTENT, deps.config() ) );\n            perDbIndexProvider.put( deps.db(), provider );\n            return provider;\n        }","id":99040,"modified_method":"@Override\n        public Lifecycle newKernelExtension( SchemaIndexHaIT.IndexProviderDependencies deps ) throws Throwable\n        {\n            if(injectLatchPredicate.accept( deps.db() ))\n            {\n                ControlledSchemaIndexProvider provider = new ControlledSchemaIndexProvider(\n                        new LuceneSchemaIndexProvider( DirectoryFactory.PERSISTENT, deps.config() ) );\n                perDbIndexProvider.put( deps.db(), provider );\n                return provider;\n            }\n            else\n            {\n                return new LuceneSchemaIndexProvider( DirectoryFactory.PERSISTENT, deps.config() );\n            }\n        }","commit_id":"426aeb51dd707f191bebab1be12c4705fb4b7d98","url":"https://github.com/neo4j/neo4j"},{"original_method":"void triggerFinish( GraphDatabaseService db )\n        {\n            ControlledSchemaIndexProvider provider = (ControlledSchemaIndexProvider) perDbIndexProvider.get( db );\n            provider.latch.finish();\n        }","id":99041,"modified_method":"void triggerFinish( GraphDatabaseService db )\n        {\n            ControlledSchemaIndexProvider provider = (ControlledSchemaIndexProvider) perDbIndexProvider.get( db );\n            if(provider != null ) provider.latch.finish();\n        }","commit_id":"426aeb51dd707f191bebab1be12c4705fb4b7d98","url":"https://github.com/neo4j/neo4j"},{"original_method":"public ControllingIndexProviderFactory( Map<GraphDatabaseService, SchemaIndexProvider> perDbIndexProvider )\n        {\n            super( CONTROLLED_PROVIDER_DESCRIPTOR.getKey() );\n            this.perDbIndexProvider = perDbIndexProvider;\n        }","id":99042,"modified_method":"public ControllingIndexProviderFactory( Map<GraphDatabaseService, SchemaIndexProvider> perDbIndexProvider,\n                                                Predicate<GraphDatabaseService> injectLatchPredicate)\n        {\n            super( CONTROLLED_PROVIDER_DESCRIPTOR.getKey() );\n            this.perDbIndexProvider = perDbIndexProvider;\n            this.injectLatchPredicate = injectLatchPredicate;\n        }","commit_id":"426aeb51dd707f191bebab1be12c4705fb4b7d98","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void doResponse(final HashMap<String, Object> conProp, final RequestHeader requestHeader, final OutputStream out, final InputStream body) {\n\n        String path = null;\n        try {\n            // getting some connection properties\n            final String method = (String) conProp.get(HeaderFramework.CONNECTION_PROP_METHOD);\n            path = (String) conProp.get(HeaderFramework.CONNECTION_PROP_PATH);\n            String argsString = (String) conProp.get(HeaderFramework.CONNECTION_PROP_ARGS); // is null if no args were given\n            final String httpVersion = (String) conProp.get(HeaderFramework.CONNECTION_PROP_HTTP_VER);\n            String clientIP = (String) conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP); if (clientIP == null) clientIP = \"unknown-host\";\n\n            // check hack attacks in path\n            if (path.indexOf(\"..\") >= 0) {\n                HTTPDemon.sendRespondError(conProp,out,4,403,null,\"Access not allowed\",null);\n                return;\n            }\n\n            // url decoding of path\n            try {\n                path = URLDecoder.decode(path, \"UTF-8\");\n            } catch (final UnsupportedEncodingException e) {\n                // This should never occur\n                assert(false) : \"UnsupportedEncodingException: \" + e.getMessage();\n            }\n\n            // check against hack attacks in path\n            if (path.indexOf(\"..\") >= 0) {\n                HTTPDemon.sendRespondError(conProp,out,4,403,null,\"Access not allowed\",null);\n                return;\n            }\n\n\n            // cache settings\n            boolean nocache = path.contains(\"?\") || body != null;\n\n            // a bad patch to map the /xml/ path to /api/\n            if (path.startsWith(\"/xml/\")) {\n                path = \"/api/\" + path.substring(5);\n            }\n            // another bad patch to map the /util/ path to /api/util/ to support old yacybars\n            if (path.startsWith(\"/util/\")) {\n                path = \"/api/util/\" + path.substring(6);\n            }\n            // one more for bookmarks\n            if (path.startsWith(\"/bookmarks/\")) {\n                path = \"/api/bookmarks/\" + path.substring(11);\n            }\n\n            // these are the 5 cases where an access granted:\n            // (the alternative is that we deliver a 401 to request authorization)\n\n            // -1- the page is not protected; or\n            final boolean protectedPage = path.indexOf(\"_p.\") > 0;\n            boolean accessGranted = !protectedPage;\n\n            // -2- a password is not configured; or\n            final String adminAccountBase64MD5 = switchboard.getConfig(SwitchboardConstants.ADMIN_ACCOUNT_B64MD5, \"\");\n            if (!accessGranted) {\n                accessGranted = adminAccountBase64MD5.length() == 0;\n            }\n\n            // -3- access from localhost is granted and access comes from localhost; or\n            final String refererHost = requestHeader.refererHost();\n            if (!accessGranted) {\n                final boolean adminAccountForLocalhost = sb.getConfigBool(\"adminAccountForLocalhost\", false);\n                final boolean accessFromLocalhost = Domains.isLocalhost(clientIP) && (refererHost == null || refererHost.length() == 0 || Domains.isLocalhost(refererHost));\n                accessGranted = adminAccountForLocalhost && accessFromLocalhost;\n            }\n\n            // -4- a password is configured and access comes from localhost\n            //     and the realm-value of a http-authentify String is equal to the stored base64MD5; or\n            String realmProp = requestHeader.get(RequestHeader.AUTHORIZATION);\n            if (realmProp != null && realmProp.length() == 0) realmProp = null;\n            final String realmValue = realmProp == null ? null : realmProp.substring(6);\n            if (!accessGranted) {\n                final boolean accessFromLocalhost = Domains.isLocalhost(clientIP) && (refererHost == null || refererHost.length() == 0 || Domains.isLocalhost(refererHost));\n                accessGranted = accessFromLocalhost && realmValue != null && realmProp.length() > 6 && (adminAccountBase64MD5.equals(realmValue));\n            }\n\n            // -5- a password is configured and access comes with matching http-authentify\n            if (!accessGranted) {\n                accessGranted = realmProp != null && realmValue != null && (sb.userDB.hasAdminRight(realmProp, requestHeader.getHeaderCookies()) || adminAccountBase64MD5.equals(Digest.encodeMD5Hex(realmValue)));\n            }\n\n            // in case that we are still not granted we ask for a password\n            if (!accessGranted) {\n                Log.logInfo(\"HTTPD\", \"Wrong log-in for path '\" + path + \"' from host '\" + clientIP + \"'\");\n                final Integer attempts = serverCore.bfHost.get(clientIP);\n                if (attempts == null)\n                    serverCore.bfHost.put(clientIP, Integer.valueOf(1));\n                else\n                    serverCore.bfHost.put(clientIP, Integer.valueOf(attempts.intValue() + 1));\n\n                final ResponseHeader responseHeader = getDefaultHeaders(path);\n                responseHeader.put(RequestHeader.WWW_AUTHENTICATE,\"Basic realm=\\\"admin log-in\\\"\");\n                final servletProperties tp=new servletProperties();\n                tp.put(\"returnto\", path);\n                HTTPDemon.sendRespondError(conProp, out, 5, 401, \"Wrong Authentication\", \"\", new File(\"proxymsg/authfail.inc\"), tp, null, responseHeader);\n                return;\n            }\n\n            // Authentication successful. remove brute-force flag\n            serverCore.bfHost.remove(conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP));\n\n            // parse arguments\n            serverObjects args = new serverObjects();\n            int argc = 0;\n            if (argsString == null) {\n                // no args here, maybe a POST with multipart extension\n                final int length = requestHeader.getContentLength();\n                //System.out.println(\"HEADER: \" + requestHeader.toString()); // DEBUG\n\n                /* don't parse body in case of a POST CGI call since it has to be\n                 * handed over to the CGI script unaltered and parsed by the script\n                 */\n                if (method.equals(HeaderFramework.METHOD_POST) &&\n                        !(switchboard.getConfigBool(\"cgi.allow\", false) &&\n                        matchesSuffix(path, switchboard.getConfig(\"cgi.suffixes\", null)))\n                        ) {\n\n                    // if its a POST, it can be either multipart or as args in the body\n                    if ((requestHeader.containsKey(HeaderFramework.CONTENT_TYPE)) &&\n                            (requestHeader.get(HeaderFramework.CONTENT_TYPE).toLowerCase().startsWith(\"multipart\"))) {\n                        // parse multipart\n                        final Map<String, byte[]> files = HTTPDemon.parseMultipart(requestHeader, args, body);\n                        // integrate these files into the args\n                        if (files != null) {\n                            final Iterator<Map.Entry<String, byte[]>> fit = files.entrySet().iterator();\n                            Map.Entry<String, byte[]> entry;\n                            while (fit.hasNext()) {\n                                entry = fit.next();\n                                args.put(entry.getKey() + \"$file\", entry.getValue());\n                            }\n                        }\n                        argc = Integer.parseInt(requestHeader.get(\"ARGC\"));\n                    } else {\n                        // parse args in body\n                        argc = HTTPDemon.parseArgs(args, body, length);\n                    }\n                } else {\n                    // no args\n                    argsString = null;\n                    args = null;\n                    argc = 0;\n                }\n            } else {\n                // simple args in URL (stuff after the \"?\")\n                argc = HTTPDemon.parseArgs(args, argsString);\n            }\n\n            // check for cross site scripting - attacks in request arguments\n            if (args != null && argc > 0) {\n                // check all values for occurrences of script values\n                final Iterator<String> e = args.values().iterator(); // enumeration of values\n                String val;\n                while (e.hasNext()) {\n                    val = e.next();\n                    if ((val != null) && (val.indexOf(\"<script\") >= 0) && !path.equals(\"/Crawler_p.html\")) {\n                        // deny request\n                        HTTPDemon.sendRespondError(conProp,out,4,403,null,\"bad post values\",null);\n                        return;\n                    }\n                }\n            }\n\n            if (args != null) nocache = true;\n\n            // we are finished with parsing\n            // the result of value hand-over is in args and argc\n            if (path.length() == 0) {\n                HTTPDemon.sendRespondError(conProp,out,4,400,null,\"Bad Request\",null);\n                out.flush();\n                return;\n            }\n            File targetClass=null;\n\n            // locate the file\n            if (path.length() > 0 && path.charAt(0) != '/' && path.charAt(0) != '\\\\') path = \"/\" + path; // attach leading slash\n            if (path.endsWith(\"index.html\")) path = path.substring(0, path.length() - 10);\n\n            // a different language can be desired (by i.e. ConfigBasic.html) than the one stored in the locale.language\n            String localeSelection = switchboard.getConfig(\"locale.language\",\"default\");\n            if (args != null && (args.containsKey(\"language\"))) {\n                // TODO 9.11.06 Bost: a class with information about available languages is needed.\n                // the indexOf(\".\") is just a workaround because there from ConfigLanguage.html commes \"de.lng\" and\n                // from ConfigBasic.html comes just \"de\" in the \"language\" parameter\n                localeSelection = args.get(\"language\", localeSelection);\n                if (localeSelection.indexOf('.') != -1)\n                    localeSelection = localeSelection.substring(0, localeSelection.indexOf('.'));\n            }\n\n            File targetFile = getLocalizedFile(path, localeSelection);\n            String targetExt = (String) conProp.get(\"EXT\"); if (targetExt == null) targetExt = \"\";\n            targetClass = rewriteClassFile(new File(htDefaultPath, path));\n            if (path.endsWith(\"/\") || path.endsWith(\"\\\\\")) {\n                String testpath;\n                // look for indexForward setting\n                if (indexForward.length() > 0 && (targetFile = getOverlayedFile(path + indexForward)).exists()) {\n                    testpath = path + indexForward;\n                    targetClass = getOverlayedClass(testpath);\n                    path = testpath;\n                } else {\n                    // attach default file name(s)\n                    for (final String defaultFile : defaultFiles) {\n                        testpath = path + defaultFile;\n                        targetFile = getOverlayedFile(testpath);\n                        targetClass = getOverlayedClass(testpath);\n                        if (targetFile.exists()) {\n                            path = testpath;\n                            break;\n                        }\n                    }\n                }\n                targetFile = getLocalizedFile(path, localeSelection);\n\n                //no defaultfile, send a dirlisting\n                if (targetFile == null || !targetFile.exists() || (targetFile.exists() && targetFile.isDirectory())) {\n                    final StringBuilder aBuffer = new StringBuilder();\n                    aBuffer.append(\"<html>\\n<head>\\n<\/head>\\n<body>\\n<h1>Index of \" + path + \"<\/h1>\\n  <ul>\\n\");\n                    String[] list = targetFile.list();\n                    if (list == null) list = new String[0]; // should not occur!\n                    File f;\n                    String size;\n                    long sz;\n                    String headline, author, description, publisher;\n                    int images, links;\n                    ContentScraper scraper;\n                    for (final String element : list) {\n                        f = new File(targetFile, element);\n                        if (f.isDirectory()) {\n                            aBuffer.append(\"    <li><a href=\\\"\" + path + element + \"/\\\">\" + element + \"/<\/a><br/><\/li>\\n\");\n                        } else {\n                            if (element.endsWith(\"html\") || (element.endsWith(\"htm\"))) {\n                                scraper = ContentScraper.parseResource(f);\n                                headline = scraper.getTitle();\n                                author = scraper.getAuthor();\n                                publisher = scraper.getPublisher();\n                                description = scraper.getDescription();\n                                images = scraper.getImages().size();\n                                links = scraper.getAnchors().size();\n                            } else {\n                                headline = null;\n                                author = null;\n                                publisher = null;\n                                description = null;\n                                images = 0;\n                                links = 0;\n                            }\n                            sz = f.length();\n                            if (sz < 1024) {\n                                size = sz + \" bytes\";\n                            } else if (sz < 1024 * 1024) {\n                                size = (sz / 1024) + \" KB\";\n                            } else {\n                                size = (sz / 1024 / 1024) + \" MB\";\n                            }\n                            aBuffer.append(\"    <li>\");\n                            if (headline != null && headline.length() > 0) aBuffer.append(\"<a href=\\\"\" + element + \"\\\"><b>\" + headline + \"<\/b><\/a><br/>\");\n                            aBuffer.append(\"<a href=\\\"\" + path + element + \"\\\">\" + element + \"<\/a><br/>\");\n                            if (author != null && author.length() > 0) aBuffer.append(\"Author: \" + author + \"<br/>\");\n                            if (publisher != null && publisher.length() > 0) aBuffer.append(\"Publisher: \" + publisher + \"<br/>\");\n                            if (description != null && description.length() > 0) aBuffer.append(\"Description: \" + description + \"<br/>\");\n                            aBuffer.append(GenericFormatter.SHORT_DAY_FORMATTER.format(new Date(f.lastModified())) + \", \" + size + ((images > 0) ? \", \" + images + \" images\" : \"\") + ((links > 0) ? \", \" + links + \" links\" : \"\") + \"<br/><\/li>\\n\");\n                        }\n                    }\n                    aBuffer.append(\"  <\/ul>\\n<\/body>\\n<\/html>\\n\");\n\n                    // write the list to the client\n                    HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null, \"text/html; charset=UTF-8\", aBuffer.length(), new Date(targetFile.lastModified()), null, new ResponseHeader(), null, null, true);\n                    if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                        out.write(UTF8.getBytes(aBuffer.toString()));\n                    }\n                    return;\n                }\n            } else {\n                    //XXX: you cannot share a .png/.gif file with a name like a class in htroot.\n                    if ( !(targetFile.exists()) &&\n                            !((path.endsWith(\"png\")||path.endsWith(\"gif\") ||\n                            matchesSuffix(path, switchboard.getConfig(\"cgi.suffixes\", null)) ||\n                            path.endsWith(\".stream\")) &&\n                            targetClass!=null ) ){\n                        targetFile = new File(htDocsPath, path);\n                        targetClass = rewriteClassFile(new File(htDocsPath, path));\n                    }\n            }\n\n            // implement proxy via url (not in servlet, because we need binary access on ouputStream)\n            if (path.equals(\"/proxy.html\")) {\n            \tfinal List<Pattern> urlProxyAccess = Domains.makePatterns(sb.getConfig(\"proxyURL.access\", \"127.0.0.1\"));\n            \tif (sb.getConfigBool(\"proxyURL\", false) && Domains.matchesList(clientIP, urlProxyAccess)) {\n            \t\tdoURLProxy(args, conProp, requestHeader, out);\n            \t\treturn;\n            \t}\n            \telse {\n        \t\t\tHTTPDemon.sendRespondError(conProp,out,3,403,\"Access denied\",null,null);\n            \t}\n            }\n\n            // track all files that had been accessed so far\n            if (targetFile != null && targetFile.exists()) {\n                if (args != null && args.size() > 0) sb.setConfig(\"server.servlets.submitted\", appendPath(sb.getConfig(\"server.servlets.submitted\", \"\"), path));\n            }\n\n            //File targetClass = rewriteClassFile(targetFile);\n            //We need tp here\n            servletProperties templatePatterns = null;\n            Date targetDate;\n\n            if ((targetClass != null) && (path.endsWith(\"png\"))) {\n                // call an image-servlet to produce an on-the-fly - generated image\n                Object img = null;\n                try {\n                    requestHeader.put(HeaderFramework.CONNECTION_PROP_CLIENTIP, (String) conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP));\n                    requestHeader.put(HeaderFramework.CONNECTION_PROP_PATH, path);\n                    requestHeader.put(HeaderFramework.CONNECTION_PROP_EXT, \"png\");\n                    // in case that there are no args given, args = null or empty hashmap\n                    img = invokeServlet(targetClass, requestHeader, args);\n                } catch (final InvocationTargetException e) {\n                    theLogger.logSevere(\"INTERNAL ERROR: \" + e.toString() + \":\" +\n                    e.getMessage() +\n                    \" target exception at \" + targetClass + \": \" +\n                    e.getTargetException().toString() + \":\" +\n                    e.getTargetException().getMessage() +\n                    \"; java.awt.graphicsenv='\" + System.getProperty(\"java.awt.graphicsenv\",\"\") + \"'\");\n                    Log.logException(e);\n                    Log.logException(e.getTargetException());\n                    targetClass = null;\n                }\n                if (img == null) {\n                    // error with image generation; send file-not-found\n                    HTTPDemon.sendRespondError(conProp, out, 3, 404, \"File not Found\", null, null);\n                } else {\n                    if (img instanceof RasterPlotter) {\n                        final RasterPlotter yp = (RasterPlotter) img;\n                        // send an image to client\n                        targetDate = new Date(System.currentTimeMillis());\n                        nocache = true;\n                        final String mimeType = MimeTable.ext2mime(targetExt, \"text/html\");\n                        final ByteBuffer result = RasterPlotter.exportImage(yp.getImage(), targetExt);\n\n                        // write the array to the client\n                        HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null, mimeType, result.length(), targetDate, null, null, null, null, nocache);\n                        if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                            result.writeTo(out);\n                        }\n                    }\n                    if (img instanceof EncodedImage) {\n                        final EncodedImage yp = (EncodedImage) img;\n                        // send an image to client\n                        targetDate = new Date(System.currentTimeMillis());\n                        nocache = true;\n                        final String mimeType = MimeTable.ext2mime(targetExt, \"text/html\");\n                        final ByteBuffer result = yp.getImage();\n\n                        // write the array to the client\n                        HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null, mimeType, result.length(), targetDate, null, null, null, null, nocache);\n                        if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                            result.writeTo(out);\n                        }\n                    }\n                    /*\n                    if (img instanceof BufferedImage) {\n                        final BufferedImage i = (BufferedImage) img;\n                        // send an image to client\n                        targetDate = new Date(System.currentTimeMillis());\n                        nocache = true;\n                        final String mimeType = MimeTable.ext2mime(targetExt, \"text/html\");\n\n                        // generate an byte array from the generated image\n                        int width = i.getWidth(); if (width < 0) width = 96; // bad hack\n                        int height = i.getHeight(); if (height < 0) height = 96; // bad hack\n                        final ByteBuffer result = RasterPlotter.exportImage(i, targetExt);\n\n                        // write the array to the client\n                        HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null, mimeType, result.length(), targetDate, null, null, null, null, nocache);\n                        if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                            result.writeTo(out);\n                        }\n                    }\n                    */\n                    if (img instanceof Image) {\n                        final Image i = (Image) img;\n                        // send an image to client\n                        targetDate = new Date(System.currentTimeMillis());\n                        nocache = true;\n                        final String mimeType = MimeTable.ext2mime(targetExt, \"text/html\");\n\n                        // generate an byte array from the generated image\n                        int width = i.getWidth(null); if (width < 0) width = 96; // bad hack\n                        int height = i.getHeight(null); if (height < 0) height = 96; // bad hack\n                        final BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n                        bi.createGraphics().drawImage(i, 0, 0, width, height, null);\n                        final ByteBuffer result = RasterPlotter.exportImage(bi, targetExt);\n\n                        // write the array to the client\n                        HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null, mimeType, result.length(), targetDate, null, null, null, null, nocache);\n                        if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                            result.writeTo(out);\n                        }\n                    }\n                }\n            } else if (((switchboard.getConfigBool(\"cgi.allow\", false)) &&                                  // check if CGI execution is allowed in config\n                    (matchesSuffix(path, switchboard.getConfig(\"cgi.suffixes\", null))) &&  // \"right\" file extension?\n                    (path.substring(0, path.indexOf(targetFile.getName())).contains(\"/CGI-BIN/\") ||\n                    path.substring(0, path.indexOf(targetFile.getName())).contains(\"/cgi-bin/\")) &&         // file in right directory?\n                    targetFile.exists())\n                    ) {\n\n                String mimeType = \"text/html\";\n                int statusCode = 200;\n\n                ProcessBuilder pb;\n\n                pb = new ProcessBuilder(targetFile.getAbsolutePath());\n\n                final String fileSeparator = System.getProperty(\"file.separator\", \"/\");\n\n                // set environment variables\n                final Map<String, String> env = pb.environment();\n                env.put(\"SERVER_SOFTWARE\", getDefaultHeaders(path).get(HeaderFramework.SERVER));\n                env.put(\"SERVER_NAME\", sb.peers.mySeed().getName());\n                env.put(\"GATEWAY_INTERFACE\", \"CGI/1.1\");\n                if (httpVersion != null) {\n                    env.put(\"SERVER_PROTOCOL\", httpVersion);\n                }\n                env.put(\"SERVER_PORT\", switchboard.getConfig(\"port\", \"8090\"));\n                env.put(\"REQUEST_METHOD\", method);\n//                env.put(\"PATH_INFO\", \"\");         // TODO: implement\n//                env.put(\"PATH_TRANSLATED\", \"\");   // TODO: implement\n                env.put(\"SCRIPT_NAME\", path);\n                if (argsString != null) {\n                    env.put(\"QUERY_STRING\", argsString);\n                }\n                env.put(\"REMOTE_ADDR\", clientIP);\n//                env.put(\"AUTH_TYPE\", \"\");         // TODO: implement\n//                env.put(\"REMOTE_USER\", \"\");       // TODO: implement\n//                env.put(\"REMOTE_IDENT\", \"\");      // I don't think we need this\n                env.put(\"DOCUMENT_ROOT\", switchboard.getAppPath().getAbsolutePath() + fileSeparator + switchboard.getConfig(\"htDocsPath\", \"DATA/HTDOCS\"));\n                if (requestHeader.getContentType() != null) {\n                    env.put(\"CONTENT_TYPE\", requestHeader.getContentType());\n                }\n                if (method.equalsIgnoreCase(HeaderFramework.METHOD_POST) && body != null) {\n                    env.put(\"CONTENT_LENGTH\", Integer.toString(requestHeader.getContentLength()));\n                }\n\n                // add values from request header to environment (see: http://hoohoo.ncsa.uiuc.edu/cgi/env.html#headers)\n                for (final Map.Entry<String, String> requestHeaderEntry : requestHeader.entrySet()) {\n                    env.put(\"HTTP_\" + requestHeaderEntry.getKey().toUpperCase().replace(\"-\", \"_\"), requestHeaderEntry.getValue());\n                }\n\n                int exitValue = 0;\n                String cgiBody = null;\n\n                try {\n                    // start execution of script\n                    final Process p = pb.start();\n\n                    final OutputStream os = new BufferedOutputStream(p.getOutputStream());\n\n                    if (method.equalsIgnoreCase(HeaderFramework.METHOD_POST) && body != null) {\n                        final byte[] buffer = new byte[1024];\n                        int len = requestHeader.getContentLength();\n                        while (len > 0) {\n                            body.read(buffer);\n                            len = len - buffer.length;\n                            os.write(buffer);\n                        }\n                    }\n\n                    os.close();\n\n                    try {\n                        p.waitFor();\n                    } catch (final InterruptedException ex) {\n\n                    }\n\n                    exitValue = p.exitValue();\n\n                    final InputStream is = new BufferedInputStream(p.getInputStream());\n\n                    final StringBuilder StringBuilder = new StringBuilder(1024);\n\n                    while (is.available() > 0) {\n                        StringBuilder.append((char) is.read());\n                    }\n\n                    final String cgiReturn = StringBuilder.toString();\n                    int indexOfDelimiter = cgiReturn.indexOf(\"\\n\\n\");\n                    String[] cgiHeader = new String[0];\n                    if (indexOfDelimiter > -1) {\n                        cgiHeader = cgiReturn.substring(0, indexOfDelimiter).split(\"\\n\");\n                    }\n                    cgiBody = cgiReturn.substring(indexOfDelimiter + 1);\n\n                    String key;\n                    String value;\n                    for (final String element : cgiHeader) {\n                        indexOfDelimiter = element.indexOf(':');\n                        key = element.substring(0, indexOfDelimiter).trim();\n                        value = element.substring(indexOfDelimiter + 1).trim();\n                        conProp.put(key, value);\n                        if (key.equals(\"Cache-Control\") && value.equals(\"no-cache\")) {\n                            nocache = true;\n                        } else if (key.equals(\"Content-type\")) {\n                            mimeType = value;\n                        } else if (key.equals(\"Status\")) {\n                            if (key.length() > 2) {\n                                try {\n                                    statusCode = Integer.parseInt(value.substring(0, 3));\n                                } catch (final NumberFormatException ex) {\n                                    /* tough luck, we will just have to use 200 as default value */\n                                }\n                            }\n                        }\n                    }\n                } catch (final IOException ex) {\n                    exitValue = -1;\n                }\n\n                /* did the script return an exit value != 0 and still there is supposed to be\n                 * everything right with the HTTP status? -> change status to 500 since 200 would\n                 * be a lie\n                 */\n                if (exitValue != 0 && statusCode == 200) {\n                    statusCode = 500;\n                }\n\n                targetDate = new Date(System.currentTimeMillis());\n\n                if (exitValue == 0 || (cgiBody != null && !cgiBody.equals(\"\"))) {\n                    HTTPDemon.sendRespondHeader(conProp, out, httpVersion, statusCode, null, mimeType, cgiBody.length(), targetDate, null, null, null, null, nocache);\n                    out.write(UTF8.getBytes(cgiBody));\n                } else {\n                    HTTPDemon.sendRespondError(conProp, out, exitValue, statusCode, null, HeaderFramework.http1_1.get(Integer.toString(statusCode)), null);\n                }\n\n\n            } else if ((targetClass != null) && (path.endsWith(\".stream\"))) {\n                // call rewrite-class\n                requestHeader.put(HeaderFramework.CONNECTION_PROP_CLIENTIP, (String) conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP));\n                requestHeader.put(HeaderFramework.CONNECTION_PROP_PATH, path);\n                requestHeader.put(HeaderFramework.CONNECTION_PROP_EXT, \"stream\");\n                //requestHeader.put(httpHeader.CONNECTION_PROP_INPUTSTREAM, body);\n                //requestHeader.put(httpHeader.CONNECTION_PROP_OUTPUTSTREAM, out);\n\n                HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null);\n\n                // in case that there are no args given, args = null or empty hashmap\n                /* servletProperties tp = (servlerObjects) */ invokeServlet(targetClass, requestHeader, args);\n                forceConnectionClose(conProp);\n                return;\n            } else if (targetFile.exists() && targetFile.isFile() && targetFile.canRead()) {\n                // we have found a file that can be written to the client\n                // if this file uses templates, then we use the template\n                // re-write - method to create an result\n                String mimeType = MimeTable.ext2mime(targetExt, \"text/html\");\n                String ext = (String) conProp.get(\"EXT\"); if (ext == null) ext = \"\";\n                final boolean zipContent = requestHeader.acceptGzip() && HTTPDemon.shallTransportZipped(\".\" + ext);\n                if (path.endsWith(\"html\") ||\n                        path.endsWith(\"htm\") ||\n                        path.endsWith(\"xml\") ||\n                        path.endsWith(\"json\") ||\n                        path.endsWith(\"rdf\") ||\n                        path.endsWith(\"rss\") ||\n                        path.endsWith(\"csv\") ||\n                        path.endsWith(\"pac\") ||\n                        path.endsWith(\"src\") ||\n                        path.endsWith(\"vcf\") ||\n                        path.endsWith(\"kml\") ||\n                        path.endsWith(\"gpx\") ||\n                        path.endsWith(\"css\") ||\n                        path.endsWith(\"/\") ||\n                        path.equals(\"/robots.txt\")) {\n\n                    /*targetFile = getLocalizedFile(path);\n                    if (!(targetFile.exists())) {\n                        // try to find that file in the htDocsPath\n                        File trialFile = new File(htDocsPath, path);\n                        if (trialFile.exists()) targetFile = trialFile;\n                    }*/\n\n\n                    // call rewrite-class\n\n                    if (targetClass != null) {\n                        // CGI-class: call the class to create a property for rewriting\n                        try {\n                            requestHeader.put(HeaderFramework.CONNECTION_PROP_CLIENTIP, (String) conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP));\n                            requestHeader.put(HeaderFramework.CONNECTION_PROP_PATH, path);\n                            final int ep = path.lastIndexOf(\".\");\n                            requestHeader.put(HeaderFramework.CONNECTION_PROP_EXT, path.substring(ep + 1));\n                            // in case that there are no args given, args = null or empty hashmap\n                            final Object tmp = invokeServlet(targetClass, requestHeader, args);\n                            if (tmp == null) {\n                                // if no args given, then tp will be an empty Hashtable object (not null)\n                                templatePatterns = new servletProperties();\n                            } else if (tmp instanceof servletProperties) {\n                                templatePatterns = (servletProperties) tmp;\n                            } else {\n                                templatePatterns = new servletProperties((serverObjects) tmp);\n                            }\n                            // check if the servlets requests authentication\n                            if (templatePatterns.containsKey(servletProperties.ACTION_AUTHENTICATE)) {\n                                // handle brute-force protection\n                                if (realmProp != null) {\n                                    Log.logInfo(\"HTTPD\", \"dynamic log-in for account 'admin' in http file handler for path '\" + path + \"' from host '\" + clientIP + \"'\");\n                                    final Integer attempts = serverCore.bfHost.get(clientIP);\n                                    if (attempts == null)\n                                        serverCore.bfHost.put(clientIP, Integer.valueOf(1));\n                                    else\n                                        serverCore.bfHost.put(clientIP, Integer.valueOf(attempts.intValue() + 1));\n                                }\n                                // send authentication request to browser\n                                final ResponseHeader headers = getDefaultHeaders(path);\n                                headers.put(RequestHeader.WWW_AUTHENTICATE,\"Basic realm=\\\"\" + templatePatterns.get(servletProperties.ACTION_AUTHENTICATE, \"\") + \"\\\"\");\n                                HTTPDemon.sendRespondHeader(conProp,out,httpVersion,401,headers);\n                                return;\n                            } else if (templatePatterns.containsKey(servletProperties.ACTION_LOCATION)) {\n                                String location = templatePatterns.get(servletProperties.ACTION_LOCATION, \"\");\n                                if (location.length() == 0) location = path;\n\n                                final ResponseHeader headers = getDefaultHeaders(path);\n                                headers.setAdditionalHeaderProperties(templatePatterns.getOutgoingHeader().getAdditionalHeaderProperties()); //put the cookies into the new header TODO: can we put all headerlines, without trouble?\n                                headers.put(HeaderFramework.LOCATION,location);\n                                HTTPDemon.sendRespondHeader(conProp,out,httpVersion,302,headers);\n                                return;\n                            }\n                            // add the application version, the uptime and the client name to every rewrite table\n                            templatePatterns.put(servletProperties.PEER_STAT_VERSION, yacyBuildProperties.getVersion());\n                            templatePatterns.put(servletProperties.PEER_STAT_UPTIME, ((System.currentTimeMillis() -  serverCore.startupTime) / 1000) / 60); // uptime in minutes\n                            templatePatterns.putHTML(servletProperties.PEER_STAT_CLIENTNAME, sb.peers.mySeed().getName());\n                            templatePatterns.putHTML(servletProperties.PEER_STAT_CLIENTID, ((Switchboard) switchboard).peers.myID());\n                            templatePatterns.put(servletProperties.PEER_STAT_MYTIME, GenericFormatter.SHORT_SECOND_FORMATTER.format());\n                            final yacySeed myPeer = sb.peers.mySeed();\n                            templatePatterns.put(\"newpeer\", myPeer.getAge() >= 1 ? 0 : 1);\n                            templatePatterns.putHTML(\"newpeer_peerhash\", myPeer.hash);\n                            //System.out.println(\"respond props: \" + ((tp == null) ? \"null\" : tp.toString())); // debug\n                        } catch (final InvocationTargetException e) {\n                            if (e.getCause() instanceof InterruptedException) {\n                                throw new InterruptedException(e.getCause().getMessage());\n                            }\n\n                            theLogger.logSevere(\"INTERNAL ERROR: \" + e.toString() + \":\" +\n                                    e.getMessage() +\n                                    \" target exception at \" + targetClass + \": \" +\n                                    e.getTargetException().toString() + \":\" +\n                                    e.getTargetException().getMessage(),e);\n                            targetClass = null;\n                            throw e;\n                        }\n                        nocache = true;\n                    }\n\n                    targetDate = new Date(targetFile.lastModified());\n\n                    // rewrite the file\n                    InputStream fis = null;\n\n                    // read the file/template\n                    TemplateCacheEntry templateCacheEntry = null;\n                    final long fileSize = targetFile.length();\n                    if (useTemplateCache && fileSize <= 512 * 1024) {\n                        // read from cache\n                        SoftReference<TemplateCacheEntry> ref = templateCache.get(targetFile);\n                        if (ref != null) {\n                            templateCacheEntry = ref.get();\n                            if (templateCacheEntry == null) templateCache.remove(targetFile);\n                        }\n\n                        final Date targetFileDate = new Date(targetFile.lastModified());\n                        if (templateCacheEntry == null || targetFileDate.after(templateCacheEntry.lastModified)) {\n                            // loading the content of the template file into\n                            // a byte array\n                        templateCacheEntry = new TemplateCacheEntry();\n                            templateCacheEntry.lastModified = targetFileDate;\n                            templateCacheEntry.content = FileUtils.read(targetFile);\n\n                            // storing the content into the cache\n                            ref = new SoftReference<TemplateCacheEntry>(templateCacheEntry);\n                            if (MemoryControl.shortStatus()) templateCache.clear();\n                            templateCache.put(targetFile, ref);\n                            if (theLogger.isFinest()) theLogger.logFinest(\"Cache MISS for file \" + targetFile);\n                        } else {\n                            if (theLogger.isFinest()) theLogger.logFinest(\"Cache HIT for file \" + targetFile);\n                        }\n\n                        // creating an inputstream needed by the template\n                        // rewrite function\n                        fis = new ByteArrayInputStream(templateCacheEntry.content);\n                        templateCacheEntry = null;\n                    } else if (fileSize <= Math.min(4 * 1024 * 1204, MemoryControl.available() / 100)) {\n                        // read file completely into ram, avoid that too many files are open at the same time\n                        fis = new ByteArrayInputStream(FileUtils.read(targetFile));\n                    } else {\n                        fis = new BufferedInputStream(new FileInputStream(targetFile));\n                    }\n\n                    if (mimeType.startsWith(\"text\")) {\n                        // every text-file distributed by yacy is UTF-8\n                        if(!path.startsWith(\"/repository\")) {\n                            mimeType = mimeType + \"; charset=UTF-8\";\n                        } else {\n                            // detect charset of html-files\n                            if((path.endsWith(\"html\") || path.endsWith(\"htm\"))) {\n                                // save position\n                                fis.mark(1000);\n                                // scrape document to look up charset\n                                final ScraperInputStream htmlFilter = new ScraperInputStream(fis,\"UTF-8\",new DigestURI(\"http://localhost\"),null,false);\n                                final String charset = htmlParser.patchCharsetEncoding(htmlFilter.detectCharset());\n                                if(charset != null)\n                                    mimeType = mimeType + \"; charset=\"+charset;\n                                // reset position\n                                fis.reset();\n                            }\n                        }\n                    }\n\n                    // write the array to the client\n                    // we can do that either in standard mode (whole thing completely) or in chunked mode\n                    // since yacy clients do not understand chunked mode (yet), we use this only for communication with the administrator\n                    final boolean yacyClient = requestHeader.userAgent().startsWith(\"yacy\");\n                    final boolean chunked = !method.equals(HeaderFramework.METHOD_HEAD) && !yacyClient && httpVersion.equals(HeaderFramework.HTTP_VERSION_1_1);\n                    if (chunked) {\n                        // send page in chunks and parse SSIs\n                        final ByteBuffer o = new ByteBuffer();\n                        // apply templates\n                        TemplateEngine.writeTemplate(fis, o, templatePatterns, ASCII.getBytes(\"-UNRESOLVED_PATTERN-\"));\n                        fis.close();\n                        HTTPDemon.sendRespondHeader(conProp, out,\n                                httpVersion, 200, null, mimeType, -1,\n                                targetDate, null, (templatePatterns == null) ? new ResponseHeader() : templatePatterns.getOutgoingHeader(),\n                                null, \"chunked\", nocache);\n                        // send the content in chunked parts, see RFC 2616 section 3.6.1\n                        final ChunkedOutputStream chos = new ChunkedOutputStream(out);\n                        ServerSideIncludes.writeSSI(o, chos, realmProp, clientIP);\n                        //chos.write(result);\n                        chos.finish();\n                    } else {\n                        // send page as whole thing, SSIs are not possible\n                        final String contentEncoding = (zipContent) ? \"gzip\" : null;\n                        // apply templates\n                        final ByteBuffer o1 = new ByteBuffer();\n                        TemplateEngine.writeTemplate(fis, o1, templatePatterns, ASCII.getBytes(\"-UNRESOLVED_PATTERN-\"));\n                        fis.close();\n                        final ByteBuffer o = new ByteBuffer();\n\n                        if (zipContent) {\n                            GZIPOutputStream zippedOut = new GZIPOutputStream(o);\n                            ServerSideIncludes.writeSSI(o1, zippedOut, realmProp, clientIP);\n                            //httpTemplate.writeTemplate(fis, zippedOut, tp, \"-UNRESOLVED_PATTERN-\".getBytes(\"UTF-8\"));\n                            zippedOut.finish();\n                            zippedOut.flush();\n                            zippedOut.close();\n                            zippedOut = null;\n                        } else {\n                            ServerSideIncludes.writeSSI(o1, o, realmProp, clientIP);\n                            //httpTemplate.writeTemplate(fis, o, tp, \"-UNRESOLVED_PATTERN-\".getBytes(\"UTF-8\"));\n                        }\n                        if (method.equals(HeaderFramework.METHOD_HEAD)) {\n                            HTTPDemon.sendRespondHeader(conProp, out,\n                                    httpVersion, 200, null, mimeType, o.length(),\n                                    targetDate, null, (templatePatterns == null) ? new ResponseHeader() : templatePatterns.getOutgoingHeader(),\n                                    contentEncoding, null, nocache);\n                        } else {\n                            final byte[] result = o.getBytes(); // this interrupts streaming (bad idea!)\n                            HTTPDemon.sendRespondHeader(conProp, out,\n                                    httpVersion, 200, null, mimeType, result.length,\n                                    targetDate, null, (templatePatterns == null) ? new ResponseHeader() : templatePatterns.getOutgoingHeader(),\n                                    contentEncoding, null, nocache);\n                            FileUtils.copy(result, out);\n                        }\n                    }\n                } else { // no html\n\n                    int statusCode = 200;\n                    int rangeStartOffset = 0;\n                    final ResponseHeader header = new ResponseHeader();\n\n                    // adding the accept ranges header\n                    header.put(HeaderFramework.ACCEPT_RANGES, \"bytes\");\n\n                    // reading the files md5 hash if availabe and use it as ETAG of the resource\n                    String targetMD5 = null;\n                    final File targetMd5File = new File(targetFile + \".md5\");\n                    try {\n                        if (targetMd5File.exists()) {\n                            //String description = null;\n                            targetMD5 = UTF8.String(FileUtils.read(targetMd5File));\n                            final int pos = targetMD5.indexOf('\\n');\n                            if (pos >= 0) {\n                                //description = targetMD5.substring(pos + 1);\n                                targetMD5 = targetMD5.substring(0, pos);\n                            }\n\n                            // using the checksum as ETAG header\n                            header.put(HeaderFramework.ETAG, targetMD5);\n                        }\n                    } catch (final IOException e) {\n                        Log.logException(e);\n                    }\n\n                    if (requestHeader.containsKey(HeaderFramework.RANGE)) {\n                        final Object ifRange = requestHeader.ifRange();\n                        if ((ifRange == null)||\n                            (ifRange instanceof Date && targetFile.lastModified() == ((Date)ifRange).getTime()) ||\n                            (ifRange instanceof String && ifRange.equals(targetMD5))) {\n                            final String rangeHeaderVal = requestHeader.get(HeaderFramework.RANGE).trim();\n                            if (rangeHeaderVal.startsWith(\"bytes=\")) {\n                                final String rangesVal = rangeHeaderVal.substring(\"bytes=\".length());\n                                final String[] ranges = rangesVal.split(\",\");\n                                if ((ranges.length == 1)&&(ranges[0].endsWith(\"-\"))) {\n                                    rangeStartOffset = Integer.parseInt(ranges[0].substring(0,ranges[0].length()-1));\n                                    statusCode = 206;\n                                    header.put(HeaderFramework.CONTENT_RANGE, \"bytes \" + rangeStartOffset + \"-\" + (targetFile.length()-1) + \"/\" + targetFile.length());\n                                }\n                            }\n                        }\n                    }\n\n                    // write the file to the client\n                    targetDate = new Date(targetFile.lastModified());\n                    final long   contentLength    = (zipContent)?-1:targetFile.length()-rangeStartOffset;\n                    final String contentEncoding  = (zipContent) ? \"gzip\" : null;\n                    final String transferEncoding = (httpVersion.equals(HeaderFramework.HTTP_VERSION_1_1) && zipContent) ? \"chunked\" : null;\n                    if (!httpVersion.equals(HeaderFramework.HTTP_VERSION_1_1) && zipContent) forceConnectionClose(conProp);\n\n                    HTTPDemon.sendRespondHeader(conProp, out, httpVersion, statusCode, null, mimeType, contentLength, targetDate, null, header, contentEncoding, transferEncoding, nocache);\n\n                    if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                        ChunkedOutputStream chunkedOut = null;\n                        GZIPOutputStream zipped = null;\n                        OutputStream newOut = out;\n\n                        if (transferEncoding != null) {\n                            chunkedOut = new ChunkedOutputStream(newOut);\n                            newOut = chunkedOut;\n                        }\n                        if (contentEncoding != null) {\n                            zipped = new GZIPOutputStream(newOut);\n                            newOut = zipped;\n                        }\n\n                        FileUtils.copyRange(targetFile, newOut, rangeStartOffset);\n\n                        if (zipped != null) {\n                            zipped.flush();\n                            zipped.finish();\n                        }\n                        if (chunkedOut != null) {\n                            chunkedOut.finish();\n                        }\n\n                        // flush all\n                        try {newOut.flush();}catch (final Exception e) {}\n                    }\n                }\n            } else {\n                HTTPDemon.sendRespondError(conProp,out,3,404,\"File not Found\",null,null);\n                return;\n            }\n        } catch (final Exception e) {\n            try {\n                // error handling\n                int httpStatusCode = 400;\n                final String httpStatusText = null;\n                final StringBuilder errorMessage = new StringBuilder(2000);\n                Exception errorExc = null;\n\n                final String errorMsg = e.getMessage();\n                if (\n                        (e instanceof InterruptedException) ||\n                        ((errorMsg != null) && (errorMsg.startsWith(\"Socket closed\")) && (Thread.currentThread().isInterrupted()))\n                   ) {\n                    errorMessage.append(\"Interruption detected while processing query.\");\n                    httpStatusCode = 503;\n                } else {\n                    if ((errorMsg != null) &&\n                        (\n                           errorMsg.contains(\"Broken pipe\") ||\n                           errorMsg.contains(\"Connection reset\") ||\n                           errorMsg.contains(\"Read timed out\") ||\n                           errorMsg.contains(\"Connection timed out\") ||\n                           errorMsg.contains(\"Software caused connection abort\")\n                       )) {\n                        // client closed the connection, so we just end silently\n                        errorMessage.append(\"Client unexpectedly closed connection while processing query.\");\n                    } else {\n                        errorMessage.append(\"Unexpected error while processing query.\");\n                        httpStatusCode = 500;\n                        errorExc = e;\n                    }\n                }\n\n                errorMessage.append(\"\\nSession: \").append(Thread.currentThread().getName())\n                            .append(\"\\nQuery:   \").append(path)\n                            .append(\"\\nClient:  \").append(conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP))\n                            .append(\"\\nReason:  \").append(e.getMessage());\n\n                if (!conProp.containsKey(HeaderFramework.CONNECTION_PROP_PROXY_RESPOND_HEADER)) {\n                    // sending back an error message to the client\n                    // if we have not already send an http header\n                    HTTPDemon.sendRespondError(conProp,out, 4, httpStatusCode, httpStatusText, errorMessage.toString(), errorExc);\n                } else {\n                    // otherwise we close the connection\n                    forceConnectionClose(conProp);\n                }\n\n                // if it is an unexpected error we log it\n                if (httpStatusCode == 500) {\n                    theLogger.logWarning(errorMessage.toString(), e);\n                }\n\n            } catch (final Exception ee) {\n                forceConnectionClose(conProp);\n            }\n\n        } finally {\n            try {out.flush();}catch (final Exception e) {}\n        }\n    }","id":99043,"modified_method":"public static void doResponse(final HashMap<String, Object> conProp, final RequestHeader requestHeader, final OutputStream out, final InputStream body) {\n\n        String path = null;\n        try {\n            // getting some connection properties\n            final String method = (String) conProp.get(HeaderFramework.CONNECTION_PROP_METHOD);\n            path = (String) conProp.get(HeaderFramework.CONNECTION_PROP_PATH);\n            String argsString = (String) conProp.get(HeaderFramework.CONNECTION_PROP_ARGS); // is null if no args were given\n            final String httpVersion = (String) conProp.get(HeaderFramework.CONNECTION_PROP_HTTP_VER);\n            String clientIP = (String) conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP); if (clientIP == null) clientIP = \"unknown-host\";\n\n            // check hack attacks in path\n            if (path.indexOf(\"..\") >= 0) {\n                HTTPDemon.sendRespondError(conProp,out,4,403,null,\"Access not allowed\",null);\n                return;\n            }\n\n            // url decoding of path\n            try {\n                path = URLDecoder.decode(path, \"UTF-8\");\n            } catch (final UnsupportedEncodingException e) {\n                // This should never occur\n                assert(false) : \"UnsupportedEncodingException: \" + e.getMessage();\n            }\n\n            // check against hack attacks in path\n            if (path.indexOf(\"..\") >= 0) {\n                HTTPDemon.sendRespondError(conProp,out,4,403,null,\"Access not allowed\",null);\n                return;\n            }\n\n\n            // cache settings\n            boolean nocache = path.contains(\"?\") || body != null;\n\n            // a bad patch to map the /xml/ path to /api/\n            if (path.startsWith(\"/xml/\")) {\n                path = \"/api/\" + path.substring(5);\n            }\n            // another bad patch to map the /util/ path to /api/util/ to support old yacybars\n            if (path.startsWith(\"/util/\")) {\n                path = \"/api/util/\" + path.substring(6);\n            }\n            // one more for bookmarks\n            if (path.startsWith(\"/bookmarks/\")) {\n                path = \"/api/bookmarks/\" + path.substring(11);\n            }\n\n            // these are the 5 cases where an access granted:\n            // (the alternative is that we deliver a 401 to request authorization)\n\n            // -1- the page is not protected; or\n            final boolean protectedPage = path.indexOf(\"_p.\") > 0;\n            boolean accessGranted = !protectedPage;\n\n            // -2- a password is not configured; or\n            final String adminAccountBase64MD5 = switchboard.getConfig(SwitchboardConstants.ADMIN_ACCOUNT_B64MD5, \"\");\n            if (!accessGranted) {\n                accessGranted = adminAccountBase64MD5.length() == 0;\n            }\n\n            // -3- access from localhost is granted and access comes from localhost; or\n            final String refererHost = requestHeader.refererHost();\n            if (!accessGranted) {\n                final boolean adminAccountForLocalhost = sb.getConfigBool(\"adminAccountForLocalhost\", false);\n                final boolean accessFromLocalhost = Domains.isLocalhost(clientIP) && (refererHost == null || refererHost.length() == 0 || Domains.isLocalhost(refererHost));\n                accessGranted = adminAccountForLocalhost && accessFromLocalhost;\n            }\n\n            // -4- a password is configured and access comes from localhost\n            //     and the realm-value of a http-authentify String is equal to the stored base64MD5; or\n            String realmProp = requestHeader.get(RequestHeader.AUTHORIZATION);\n            if (realmProp != null && realmProp.length() == 0) realmProp = null;\n            final String realmValue = realmProp == null ? null : realmProp.substring(6);\n            if (!accessGranted) {\n                final boolean accessFromLocalhost = Domains.isLocalhost(clientIP) && (refererHost == null || refererHost.length() == 0 || Domains.isLocalhost(refererHost));\n                accessGranted = accessFromLocalhost && realmValue != null && realmProp.length() > 6 && (adminAccountBase64MD5.equals(realmValue));\n            }\n\n            // -5- a password is configured and access comes with matching http-authentify\n            if (!accessGranted) {\n                accessGranted = realmProp != null && realmValue != null && (sb.userDB.hasAdminRight(realmProp, requestHeader.getHeaderCookies()) || adminAccountBase64MD5.equals(Digest.encodeMD5Hex(realmValue)));\n            }\n\n            // in case that we are still not granted we ask for a password\n            if (!accessGranted) {\n                Log.logInfo(\"HTTPD\", \"Wrong log-in for path '\" + path + \"' from host '\" + clientIP + \"'\");\n                final Integer attempts = serverCore.bfHost.get(clientIP);\n                if (attempts == null)\n                    serverCore.bfHost.put(clientIP, Integer.valueOf(1));\n                else\n                    serverCore.bfHost.put(clientIP, Integer.valueOf(attempts.intValue() + 1));\n\n                final ResponseHeader responseHeader = getDefaultHeaders(path);\n                responseHeader.put(RequestHeader.WWW_AUTHENTICATE,\"Basic realm=\\\"admin log-in\\\"\");\n                final servletProperties tp=new servletProperties();\n                tp.put(\"returnto\", path);\n                HTTPDemon.sendRespondError(conProp, out, 5, 401, \"Wrong Authentication\", \"\", new File(\"proxymsg/authfail.inc\"), tp, null, responseHeader);\n                return;\n            }\n\n            // Authentication successful. remove brute-force flag\n            serverCore.bfHost.remove(conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP));\n\n            // parse arguments\n            serverObjects args = new serverObjects();\n            int argc = 0;\n            if (argsString == null) {\n                // no args here, maybe a POST with multipart extension\n                final int length = requestHeader.getContentLength();\n                //System.out.println(\"HEADER: \" + requestHeader.toString()); // DEBUG\n\n                /* don't parse body in case of a POST CGI call since it has to be\n                 * handed over to the CGI script unaltered and parsed by the script\n                 */\n                if (method.equals(HeaderFramework.METHOD_POST) &&\n                        !(switchboard.getConfigBool(\"cgi.allow\", false) &&\n                        matchesSuffix(path, switchboard.getConfig(\"cgi.suffixes\", null)))\n                        ) {\n\n                    // if its a POST, it can be either multipart or as args in the body\n                    if ((requestHeader.containsKey(HeaderFramework.CONTENT_TYPE)) &&\n                            (requestHeader.get(HeaderFramework.CONTENT_TYPE).toLowerCase().startsWith(\"multipart\"))) {\n                        // parse multipart\n                        final Map<String, byte[]> files = HTTPDemon.parseMultipart(requestHeader, args, body);\n                        // integrate these files into the args\n                        if (files != null) {\n                            final Iterator<Map.Entry<String, byte[]>> fit = files.entrySet().iterator();\n                            Map.Entry<String, byte[]> entry;\n                            while (fit.hasNext()) {\n                                entry = fit.next();\n                                args.put(entry.getKey() + \"$file\", entry.getValue());\n                            }\n                        }\n                        argc = Integer.parseInt(requestHeader.get(\"ARGC\"));\n                    } else {\n                        // parse args in body\n                        argc = HTTPDemon.parseArgs(args, body, length);\n                    }\n                } else {\n                    // no args\n                    argsString = null;\n                    args = null;\n                    argc = 0;\n                }\n            } else {\n                // simple args in URL (stuff after the \"?\")\n                argc = HTTPDemon.parseArgs(args, argsString);\n            }\n\n            // check for cross site scripting - attacks in request arguments\n            if (args != null && argc > 0) {\n                // check all values for occurrences of script values\n                final Iterator<String> e = args.values().iterator(); // enumeration of values\n                String val;\n                while (e.hasNext()) {\n                    val = e.next();\n                    if ((val != null) && (val.indexOf(\"<script\") >= 0) && !path.equals(\"/Crawler_p.html\")) {\n                        // deny request\n                        HTTPDemon.sendRespondError(conProp,out,4,403,null,\"bad post values\",null);\n                        return;\n                    }\n                }\n            }\n\n            if (args != null) nocache = true;\n\n            // we are finished with parsing\n            // the result of value hand-over is in args and argc\n            if (path.length() == 0) {\n                HTTPDemon.sendRespondError(conProp,out,4,400,null,\"Bad Request\",null);\n                out.flush();\n                return;\n            }\n            File targetClass=null;\n\n            // locate the file\n            if (path.length() > 0 && path.charAt(0) != '/' && path.charAt(0) != '\\\\') path = \"/\" + path; // attach leading slash\n            if (path.endsWith(\"index.html\")) path = path.substring(0, path.length() - 10);\n\n            // a different language can be desired (by i.e. ConfigBasic.html) than the one stored in the locale.language\n            String localeSelection = switchboard.getConfig(\"locale.language\",\"default\");\n            if (args != null && (args.containsKey(\"language\"))) {\n                // TODO 9.11.06 Bost: a class with information about available languages is needed.\n                // the indexOf(\".\") is just a workaround because there from ConfigLanguage.html commes \"de.lng\" and\n                // from ConfigBasic.html comes just \"de\" in the \"language\" parameter\n                localeSelection = args.get(\"language\", localeSelection);\n                if (localeSelection.indexOf('.') != -1)\n                    localeSelection = localeSelection.substring(0, localeSelection.indexOf('.'));\n            }\n\n            File targetFile = getLocalizedFile(path, localeSelection);\n            String targetExt = (String) conProp.get(\"EXT\"); if (targetExt == null) targetExt = \"\";\n            targetClass = rewriteClassFile(new File(htDefaultPath, path));\n            if (path.endsWith(\"/\") || path.endsWith(\"\\\\\")) {\n                String testpath;\n                // look for indexForward setting\n                if (indexForward.length() > 0 && (targetFile = getOverlayedFile(path + indexForward)).exists()) {\n                    testpath = path + indexForward;\n                    targetClass = getOverlayedClass(testpath);\n                    path = testpath;\n                } else {\n                    // attach default file name(s)\n                    for (final String defaultFile : defaultFiles) {\n                        testpath = path + defaultFile;\n                        targetFile = getOverlayedFile(testpath);\n                        targetClass = getOverlayedClass(testpath);\n                        if (targetFile.exists()) {\n                            path = testpath;\n                            break;\n                        }\n                    }\n                }\n                targetFile = getLocalizedFile(path, localeSelection);\n\n                //no defaultfile, send a dirlisting\n                if (targetFile == null || !targetFile.exists() || (targetFile.exists() && targetFile.isDirectory())) {\n                    final StringBuilder aBuffer = new StringBuilder();\n                    aBuffer.append(\"<html>\\n<head>\\n<\/head>\\n<body>\\n<h1>Index of \" + path + \"<\/h1>\\n  <ul>\\n\");\n                    String[] list = targetFile.list();\n                    if (list == null) list = new String[0]; // should not occur!\n                    File f;\n                    String size;\n                    long sz;\n                    String headline, author, description, publisher;\n                    int images, links;\n                    ContentScraper scraper;\n                    for (final String element : list) {\n                        f = new File(targetFile, element);\n                        if (f.isDirectory()) {\n                            aBuffer.append(\"    <li><a href=\\\"\" + path + element + \"/\\\">\" + element + \"/<\/a><br/><\/li>\\n\");\n                        } else {\n                            if (element.endsWith(\"html\") || (element.endsWith(\"htm\"))) {\n                                scraper = ContentScraper.parseResource(f);\n                                headline = scraper.getTitle();\n                                author = scraper.getAuthor();\n                                publisher = scraper.getPublisher();\n                                description = scraper.getDescription();\n                                images = scraper.getImages().size();\n                                links = scraper.getAnchors().size();\n                            } else {\n                                headline = null;\n                                author = null;\n                                publisher = null;\n                                description = null;\n                                images = 0;\n                                links = 0;\n                            }\n                            sz = f.length();\n                            if (sz < 1024) {\n                                size = sz + \" bytes\";\n                            } else if (sz < 1024 * 1024) {\n                                size = (sz / 1024) + \" KB\";\n                            } else {\n                                size = (sz / 1024 / 1024) + \" MB\";\n                            }\n                            aBuffer.append(\"    <li>\");\n                            if (headline != null && headline.length() > 0) aBuffer.append(\"<a href=\\\"\" + element + \"\\\"><b>\" + headline + \"<\/b><\/a><br/>\");\n                            aBuffer.append(\"<a href=\\\"\" + path + element + \"\\\">\" + element + \"<\/a><br/>\");\n                            if (author != null && author.length() > 0) aBuffer.append(\"Author: \" + author + \"<br/>\");\n                            if (publisher != null && publisher.length() > 0) aBuffer.append(\"Publisher: \" + publisher + \"<br/>\");\n                            if (description != null && description.length() > 0) aBuffer.append(\"Description: \" + description + \"<br/>\");\n                            aBuffer.append(GenericFormatter.SHORT_DAY_FORMATTER.format(new Date(f.lastModified())) + \", \" + size + ((images > 0) ? \", \" + images + \" images\" : \"\") + ((links > 0) ? \", \" + links + \" links\" : \"\") + \"<br/><\/li>\\n\");\n                        }\n                    }\n                    aBuffer.append(\"  <\/ul>\\n<\/body>\\n<\/html>\\n\");\n\n                    // write the list to the client\n                    HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null, \"text/html; charset=UTF-8\", aBuffer.length(), new Date(targetFile.lastModified()), null, new ResponseHeader(), null, null, true);\n                    if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                        out.write(UTF8.getBytes(aBuffer.toString()));\n                    }\n                    return;\n                }\n            } else {\n                    //XXX: you cannot share a .png/.gif file with a name like a class in htroot.\n                    if ( !(targetFile.exists()) &&\n                            !((path.endsWith(\"png\")||path.endsWith(\"gif\") ||\n                            matchesSuffix(path, switchboard.getConfig(\"cgi.suffixes\", null)) ||\n                            path.endsWith(\".stream\")) &&\n                            targetClass!=null ) ){\n                        targetFile = new File(htDocsPath, path);\n                        targetClass = rewriteClassFile(new File(htDocsPath, path));\n                    }\n            }\n\n            // implement proxy via url (not in servlet, because we need binary access on ouputStream)\n            if (path.equals(\"/proxy.html\")) {\n            \tfinal List<Pattern> urlProxyAccess = Domains.makePatterns(sb.getConfig(\"proxyURL.access\", \"127.0.0.1\"));\n            \tif (sb.getConfigBool(\"proxyURL\", false) && Domains.matchesList(clientIP, urlProxyAccess)) {\n            \t\tdoURLProxy(args, conProp, requestHeader, out);\n            \t\treturn;\n            \t}\n            \telse {\n        \t\t\tHTTPDemon.sendRespondError(conProp,out,3,403,\"Access denied\",null,null);\n            \t}\n            }\n\n            // track all files that had been accessed so far\n            if (targetFile != null && targetFile.exists()) {\n                if (args != null && args.size() > 0) sb.setConfig(\"server.servlets.submitted\", appendPath(sb.getConfig(\"server.servlets.submitted\", \"\"), path));\n            }\n\n            //File targetClass = rewriteClassFile(targetFile);\n            //We need tp here\n            servletProperties templatePatterns = null;\n            Date targetDate;\n\n            if ((targetClass != null) && (path.endsWith(\"png\"))) {\n                // call an image-servlet to produce an on-the-fly - generated image\n                Object img = null;\n                try {\n                    requestHeader.put(HeaderFramework.CONNECTION_PROP_CLIENTIP, (String) conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP));\n                    requestHeader.put(HeaderFramework.CONNECTION_PROP_PATH, path);\n                    requestHeader.put(HeaderFramework.CONNECTION_PROP_EXT, \"png\");\n                    // in case that there are no args given, args = null or empty hashmap\n                    img = invokeServlet(targetClass, requestHeader, args);\n                } catch (final InvocationTargetException e) {\n                    theLogger.logSevere(\"INTERNAL ERROR: \" + e.toString() + \":\" +\n                    e.getMessage() +\n                    \" target exception at \" + targetClass + \": \" +\n                    e.getTargetException().toString() + \":\" +\n                    e.getTargetException().getMessage() +\n                    \"; java.awt.graphicsenv='\" + System.getProperty(\"java.awt.graphicsenv\",\"\") + \"'\");\n                    Log.logException(e);\n                    Log.logException(e.getTargetException());\n                    targetClass = null;\n                }\n                if (img == null) {\n                    // error with image generation; send file-not-found\n                    HTTPDemon.sendRespondError(conProp, out, 3, 404, \"File not Found\", null, null);\n                } else {\n                    if (img instanceof RasterPlotter) {\n                        final RasterPlotter yp = (RasterPlotter) img;\n                        // send an image to client\n                        targetDate = new Date(System.currentTimeMillis());\n                        nocache = true;\n                        final String mimeType = MimeTable.ext2mime(targetExt, \"text/html\");\n                        final ByteBuffer result = RasterPlotter.exportImage(yp.getImage(), targetExt);\n\n                        // write the array to the client\n                        HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null, mimeType, result.length(), targetDate, null, null, null, null, nocache);\n                        if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                            result.writeTo(out);\n                        }\n                    }\n                    if (img instanceof EncodedImage) {\n                        final EncodedImage yp = (EncodedImage) img;\n                        // send an image to client\n                        targetDate = new Date(System.currentTimeMillis());\n                        nocache = true;\n                        final String mimeType = MimeTable.ext2mime(targetExt, \"text/html\");\n                        final ByteBuffer result = yp.getImage();\n\n                        // write the array to the client\n                        HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null, mimeType, result.length(), targetDate, null, null, null, null, nocache);\n                        if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                            result.writeTo(out);\n                        }\n                    }\n                    /*\n                    if (img instanceof BufferedImage) {\n                        final BufferedImage i = (BufferedImage) img;\n                        // send an image to client\n                        targetDate = new Date(System.currentTimeMillis());\n                        nocache = true;\n                        final String mimeType = MimeTable.ext2mime(targetExt, \"text/html\");\n\n                        // generate an byte array from the generated image\n                        int width = i.getWidth(); if (width < 0) width = 96; // bad hack\n                        int height = i.getHeight(); if (height < 0) height = 96; // bad hack\n                        final ByteBuffer result = RasterPlotter.exportImage(i, targetExt);\n\n                        // write the array to the client\n                        HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null, mimeType, result.length(), targetDate, null, null, null, null, nocache);\n                        if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                            result.writeTo(out);\n                        }\n                    }\n                    */\n                    if (img instanceof Image) {\n                        final Image i = (Image) img;\n                        // send an image to client\n                        targetDate = new Date(System.currentTimeMillis());\n                        nocache = true;\n                        final String mimeType = MimeTable.ext2mime(targetExt, \"text/html\");\n\n                        // generate an byte array from the generated image\n                        int width = i.getWidth(null); if (width < 0) width = 96; // bad hack\n                        int height = i.getHeight(null); if (height < 0) height = 96; // bad hack\n                        final BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n                        bi.createGraphics().drawImage(i, 0, 0, width, height, null);\n                        final ByteBuffer result = RasterPlotter.exportImage(bi, targetExt);\n\n                        // write the array to the client\n                        HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null, mimeType, result.length(), targetDate, null, null, null, null, nocache);\n                        if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                            result.writeTo(out);\n                        }\n                    }\n                }\n            } else if (((switchboard.getConfigBool(\"cgi.allow\", false)) &&                                  // check if CGI execution is allowed in config\n                    (matchesSuffix(path, switchboard.getConfig(\"cgi.suffixes\", null))) &&  // \"right\" file extension?\n                    (path.substring(0, path.indexOf(targetFile.getName())).contains(\"/CGI-BIN/\") ||\n                    path.substring(0, path.indexOf(targetFile.getName())).contains(\"/cgi-bin/\")) &&         // file in right directory?\n                    targetFile.exists())\n                    ) {\n\n                String mimeType = \"text/html\";\n                int statusCode = 200;\n\n                ProcessBuilder pb;\n\n                pb = new ProcessBuilder(targetFile.getAbsolutePath());\n\n                final String fileSeparator = System.getProperty(\"file.separator\", \"/\");\n\n                // set environment variables\n                final Map<String, String> env = pb.environment();\n                env.put(\"SERVER_SOFTWARE\", getDefaultHeaders(path).get(HeaderFramework.SERVER));\n                env.put(\"SERVER_NAME\", sb.peers.mySeed().getName());\n                env.put(\"GATEWAY_INTERFACE\", \"CGI/1.1\");\n                if (httpVersion != null) {\n                    env.put(\"SERVER_PROTOCOL\", httpVersion);\n                }\n                env.put(\"SERVER_PORT\", switchboard.getConfig(\"port\", \"8090\"));\n                env.put(\"REQUEST_METHOD\", method);\n//                env.put(\"PATH_INFO\", \"\");         // TODO: implement\n//                env.put(\"PATH_TRANSLATED\", \"\");   // TODO: implement\n                env.put(\"SCRIPT_NAME\", path);\n                if (argsString != null) {\n                    env.put(\"QUERY_STRING\", argsString);\n                }\n                env.put(\"REMOTE_ADDR\", clientIP);\n//                env.put(\"AUTH_TYPE\", \"\");         // TODO: implement\n//                env.put(\"REMOTE_USER\", \"\");       // TODO: implement\n//                env.put(\"REMOTE_IDENT\", \"\");      // I don't think we need this\n                env.put(\"DOCUMENT_ROOT\", switchboard.getAppPath().getAbsolutePath() + fileSeparator + switchboard.getConfig(\"htDocsPath\", \"DATA/HTDOCS\"));\n                if (requestHeader.getContentType() != null) {\n                    env.put(\"CONTENT_TYPE\", requestHeader.getContentType());\n                }\n                if (method.equalsIgnoreCase(HeaderFramework.METHOD_POST) && body != null) {\n                    env.put(\"CONTENT_LENGTH\", Integer.toString(requestHeader.getContentLength()));\n                }\n\n                // add values from request header to environment (see: http://hoohoo.ncsa.uiuc.edu/cgi/env.html#headers)\n                for (final Map.Entry<String, String> requestHeaderEntry : requestHeader.entrySet()) {\n                    env.put(\"HTTP_\" + requestHeaderEntry.getKey().toUpperCase().replace(\"-\", \"_\"), requestHeaderEntry.getValue());\n                }\n\n                int exitValue = 0;\n                String cgiBody = null;\n\n                try {\n                    // start execution of script\n                    final Process p = pb.start();\n\n                    final OutputStream os = new BufferedOutputStream(p.getOutputStream());\n\n                    if (method.equalsIgnoreCase(HeaderFramework.METHOD_POST) && body != null) {\n                        final byte[] buffer = new byte[1024];\n                        int len = requestHeader.getContentLength();\n                        while (len > 0) {\n                            body.read(buffer);\n                            len = len - buffer.length;\n                            os.write(buffer);\n                        }\n                    }\n\n                    os.close();\n\n                    try {\n                        p.waitFor();\n                    } catch (final InterruptedException ex) {\n\n                    }\n\n                    exitValue = p.exitValue();\n\n                    final InputStream is = new BufferedInputStream(p.getInputStream());\n\n                    final StringBuilder StringBuilder = new StringBuilder(1024);\n\n                    while (is.available() > 0) {\n                        StringBuilder.append((char) is.read());\n                    }\n\n                    final String cgiReturn = StringBuilder.toString();\n                    int indexOfDelimiter = cgiReturn.indexOf(\"\\n\\n\");\n                    String[] cgiHeader = new String[0];\n                    if (indexOfDelimiter > -1) {\n                        cgiHeader = cgiReturn.substring(0, indexOfDelimiter).split(\"\\n\");\n                    }\n                    cgiBody = cgiReturn.substring(indexOfDelimiter + 1);\n\n                    String key;\n                    String value;\n                    for (final String element : cgiHeader) {\n                        indexOfDelimiter = element.indexOf(':');\n                        key = element.substring(0, indexOfDelimiter).trim();\n                        value = element.substring(indexOfDelimiter + 1).trim();\n                        conProp.put(key, value);\n                        if (key.equals(\"Cache-Control\") && value.equals(\"no-cache\")) {\n                            nocache = true;\n                        } else if (key.equals(\"Content-type\")) {\n                            mimeType = value;\n                        } else if (key.equals(\"Status\")) {\n                            if (key.length() > 2) {\n                                try {\n                                    statusCode = Integer.parseInt(value.substring(0, 3));\n                                } catch (final NumberFormatException ex) {\n                                    /* tough luck, we will just have to use 200 as default value */\n                                }\n                            }\n                        }\n                    }\n                } catch (final IOException ex) {\n                    exitValue = -1;\n                }\n\n                /* did the script return an exit value != 0 and still there is supposed to be\n                 * everything right with the HTTP status? -> change status to 500 since 200 would\n                 * be a lie\n                 */\n                if (exitValue != 0 && statusCode == 200) {\n                    statusCode = 500;\n                }\n\n                targetDate = new Date(System.currentTimeMillis());\n\n                if (exitValue == 0 || (cgiBody != null && !cgiBody.equals(\"\"))) {\n                    HTTPDemon.sendRespondHeader(conProp, out, httpVersion, statusCode, null, mimeType, cgiBody.length(), targetDate, null, null, null, null, nocache);\n                    out.write(UTF8.getBytes(cgiBody));\n                } else {\n                    HTTPDemon.sendRespondError(conProp, out, exitValue, statusCode, null, HeaderFramework.http1_1.get(Integer.toString(statusCode)), null);\n                }\n\n\n            } else if ((targetClass != null) && (path.endsWith(\".stream\"))) {\n                // call rewrite-class\n                requestHeader.put(HeaderFramework.CONNECTION_PROP_CLIENTIP, (String) conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP));\n                requestHeader.put(HeaderFramework.CONNECTION_PROP_PATH, path);\n                requestHeader.put(HeaderFramework.CONNECTION_PROP_EXT, \"stream\");\n                //requestHeader.put(httpHeader.CONNECTION_PROP_INPUTSTREAM, body);\n                //requestHeader.put(httpHeader.CONNECTION_PROP_OUTPUTSTREAM, out);\n\n                HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null);\n\n                // in case that there are no args given, args = null or empty hashmap\n                /* servletProperties tp = (servlerObjects) */ invokeServlet(targetClass, requestHeader, args);\n                forceConnectionClose(conProp);\n                return;\n            } else if (targetFile.exists() && targetFile.isFile() && targetFile.canRead()) {\n                // we have found a file that can be written to the client\n                // if this file uses templates, then we use the template\n                // re-write - method to create an result\n                String mimeType = MimeTable.ext2mime(targetExt, \"text/html\");\n                String ext = (String) conProp.get(\"EXT\"); if (ext == null) ext = \"\";\n                final boolean zipContent = requestHeader.acceptGzip() && HTTPDemon.shallTransportZipped(\".\" + ext);\n                if (path.endsWith(\"html\") ||\n                        path.endsWith(\"htm\") ||\n                        path.endsWith(\"xml\") ||\n                        path.endsWith(\"json\") ||\n                        path.endsWith(\"rdf\") ||\n                        path.endsWith(\"rss\") ||\n                        path.endsWith(\"csv\") ||\n                        path.endsWith(\"pac\") ||\n                        path.endsWith(\"src\") ||\n                        path.endsWith(\"vcf\") ||\n                        path.endsWith(\"kml\") ||\n                        path.endsWith(\"gpx\") ||\n                        path.endsWith(\"css\") ||\n                        path.endsWith(\"/\") ||\n                        path.equals(\"/robots.txt\")) {\n\n                    /*targetFile = getLocalizedFile(path);\n                    if (!(targetFile.exists())) {\n                        // try to find that file in the htDocsPath\n                        File trialFile = new File(htDocsPath, path);\n                        if (trialFile.exists()) targetFile = trialFile;\n                    }*/\n\n\n                    // call rewrite-class\n\n                    if (targetClass != null) {\n                        // CGI-class: call the class to create a property for rewriting\n                        try {\n                            requestHeader.put(HeaderFramework.CONNECTION_PROP_CLIENTIP, (String) conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP));\n                            requestHeader.put(HeaderFramework.CONNECTION_PROP_PATH, path);\n                            final int ep = path.lastIndexOf(\".\");\n                            requestHeader.put(HeaderFramework.CONNECTION_PROP_EXT, path.substring(ep + 1));\n                            // in case that there are no args given, args = null or empty hashmap\n                            final Object tmp = invokeServlet(targetClass, requestHeader, args);\n                            if (tmp == null) {\n                                // if no args given, then tp will be an empty Hashtable object (not null)\n                                templatePatterns = new servletProperties();\n                            } else if (tmp instanceof servletProperties) {\n                                templatePatterns = (servletProperties) tmp;\n                            } else {\n                                templatePatterns = new servletProperties((serverObjects) tmp);\n                            }\n                            // check if the servlets requests authentication\n                            if (templatePatterns.containsKey(servletProperties.ACTION_AUTHENTICATE)) {\n                                // handle brute-force protection\n                                if (realmProp != null) {\n                                    Log.logInfo(\"HTTPD\", \"dynamic log-in for account 'admin' in http file handler for path '\" + path + \"' from host '\" + clientIP + \"'\");\n                                    final Integer attempts = serverCore.bfHost.get(clientIP);\n                                    if (attempts == null)\n                                        serverCore.bfHost.put(clientIP, Integer.valueOf(1));\n                                    else\n                                        serverCore.bfHost.put(clientIP, Integer.valueOf(attempts.intValue() + 1));\n                                }\n                                // send authentication request to browser\n                                final ResponseHeader headers = getDefaultHeaders(path);\n                                headers.put(RequestHeader.WWW_AUTHENTICATE,\"Basic realm=\\\"\" + templatePatterns.get(servletProperties.ACTION_AUTHENTICATE, \"\") + \"\\\"\");\n                                HTTPDemon.sendRespondHeader(conProp,out,httpVersion,401,headers);\n                                return;\n                            } else if (templatePatterns.containsKey(servletProperties.ACTION_LOCATION)) {\n                                String location = templatePatterns.get(servletProperties.ACTION_LOCATION, \"\");\n                                if (location.length() == 0) location = path;\n\n                                final ResponseHeader headers = getDefaultHeaders(path);\n                                headers.setAdditionalHeaderProperties(templatePatterns.getOutgoingHeader().getAdditionalHeaderProperties()); //put the cookies into the new header TODO: can we put all headerlines, without trouble?\n                                headers.put(HeaderFramework.LOCATION,location);\n                                HTTPDemon.sendRespondHeader(conProp,out,httpVersion,302,headers);\n                                return;\n                            }\n                            // add the application version, the uptime and the client name to every rewrite table\n                            templatePatterns.put(servletProperties.PEER_STAT_VERSION, yacyBuildProperties.getVersion());\n                            templatePatterns.put(servletProperties.PEER_STAT_UPTIME, ((System.currentTimeMillis() -  serverCore.startupTime) / 1000) / 60); // uptime in minutes\n                            templatePatterns.putHTML(servletProperties.PEER_STAT_CLIENTNAME, sb.peers.mySeed().getName());\n                            templatePatterns.putHTML(servletProperties.PEER_STAT_CLIENTID, ((Switchboard) switchboard).peers.myID());\n                            templatePatterns.put(servletProperties.PEER_STAT_MYTIME, GenericFormatter.SHORT_SECOND_FORMATTER.format());\n                            final yacySeed myPeer = sb.peers.mySeed();\n                            templatePatterns.put(\"newpeer\", myPeer.getAge() >= 1 ? 0 : 1);\n                            templatePatterns.putHTML(\"newpeer_peerhash\", myPeer.hash);\n                            //System.out.println(\"respond props: \" + ((tp == null) ? \"null\" : tp.toString())); // debug\n                        } catch (final InvocationTargetException e) {\n                            if (e.getCause() instanceof InterruptedException) {\n                                throw new InterruptedException(e.getCause().getMessage());\n                            }\n\n                            theLogger.logSevere(\"INTERNAL ERROR: \" + e.toString() + \":\" +\n                                    e.getMessage() +\n                                    \" target exception at \" + targetClass + \": \" +\n                                    e.getTargetException().toString() + \":\" +\n                                    e.getTargetException().getMessage(),e);\n                            targetClass = null;\n                            throw e;\n                        }\n                        nocache = true;\n                    }\n\n                    targetDate = new Date(targetFile.lastModified());\n                    Date expireDate = null;\n                    if (templatePatterns == null) {\n                    \t// if the file will not be changed, cache it in the browser\n                    \texpireDate = new Date(new Date().getTime() + (31l * 24 * 60 * 60 * 1000));\n                    }\n\n\n                    // rewrite the file\n                    InputStream fis = null;\n\n                    // read the file/template\n                    TemplateCacheEntry templateCacheEntry = null;\n                    final long fileSize = targetFile.length();\n                    if (useTemplateCache && fileSize <= 512 * 1024) {\n                        // read from cache\n                        SoftReference<TemplateCacheEntry> ref = templateCache.get(targetFile);\n                        if (ref != null) {\n                            templateCacheEntry = ref.get();\n                            if (templateCacheEntry == null) templateCache.remove(targetFile);\n                        }\n\n                        final Date targetFileDate = new Date(targetFile.lastModified());\n                        if (templateCacheEntry == null || targetFileDate.after(templateCacheEntry.lastModified)) {\n                            // loading the content of the template file into\n                            // a byte array\n                            templateCacheEntry = new TemplateCacheEntry();\n                            templateCacheEntry.lastModified = targetFileDate;\n                            templateCacheEntry.content = FileUtils.read(targetFile);\n\n                            // storing the content into the cache\n                            ref = new SoftReference<TemplateCacheEntry>(templateCacheEntry);\n                            if (MemoryControl.shortStatus()) templateCache.clear();\n                            templateCache.put(targetFile, ref);\n                            if (theLogger.isFinest()) theLogger.logFinest(\"Cache MISS for file \" + targetFile);\n                        } else {\n                            if (theLogger.isFinest()) theLogger.logFinest(\"Cache HIT for file \" + targetFile);\n                        }\n\n                        // creating an inputstream needed by the template\n                        // rewrite function\n                        fis = new ByteArrayInputStream(templateCacheEntry.content);\n                        templateCacheEntry = null;\n                    } else if (fileSize <= Math.min(4 * 1024 * 1204, MemoryControl.available() / 100)) {\n                        // read file completely into ram, avoid that too many files are open at the same time\n                        fis = new ByteArrayInputStream(FileUtils.read(targetFile));\n                    } else {\n                        fis = new BufferedInputStream(new FileInputStream(targetFile));\n                    }\n\n                    if (mimeType.startsWith(\"text\")) {\n                        // every text-file distributed by yacy is UTF-8\n                        if(!path.startsWith(\"/repository\")) {\n                            mimeType = mimeType + \"; charset=UTF-8\";\n                        } else {\n                            // detect charset of html-files\n                            if((path.endsWith(\"html\") || path.endsWith(\"htm\"))) {\n                                // save position\n                                fis.mark(1000);\n                                // scrape document to look up charset\n                                final ScraperInputStream htmlFilter = new ScraperInputStream(fis,\"UTF-8\",new DigestURI(\"http://localhost\"),null,false);\n                                final String charset = htmlParser.patchCharsetEncoding(htmlFilter.detectCharset());\n                                if(charset != null)\n                                    mimeType = mimeType + \"; charset=\"+charset;\n                                // reset position\n                                fis.reset();\n                            }\n                        }\n                    }\n\n                    // write the array to the client\n                    // we can do that either in standard mode (whole thing completely) or in chunked mode\n                    // since yacy clients do not understand chunked mode (yet), we use this only for communication with the administrator\n                    final boolean yacyClient = requestHeader.userAgent().startsWith(\"yacy\");\n                    final boolean chunked = !method.equals(HeaderFramework.METHOD_HEAD) && !yacyClient && httpVersion.equals(HeaderFramework.HTTP_VERSION_1_1);\n                    final String contentEncoding = (zipContent) ? \"gzip\" : null;\n                    if (chunked) {\n                        // send page in chunks and parse SSIs\n                        final ByteBuffer o = new ByteBuffer();\n                        // apply templates\n                        TemplateEngine.writeTemplate(fis, o, templatePatterns, ASCII.getBytes(\"-UNRESOLVED_PATTERN-\"));\n                        fis.close();\n                        HTTPDemon.sendRespondHeader(conProp, out,\n                                httpVersion, 200, null, mimeType, -1,\n                                targetDate, expireDate, (templatePatterns == null) ? new ResponseHeader() : templatePatterns.getOutgoingHeader(),\n                                contentEncoding, \"chunked\", nocache);\n                        // send the content in chunked parts, see RFC 2616 section 3.6.1\n                        ChunkedOutputStream chos = new ChunkedOutputStream(out);\n                        if (contentEncoding != null) {\n                        \tGZIPOutputStream zippedOutput = new GZIPOutputStream(chos);\n                            ServerSideIncludes.writeSSI(o, zippedOutput, realmProp, clientIP);\n                            zippedOutput.finish();\n                            zippedOutput.flush();\n                        } else {\n                            ServerSideIncludes.writeSSI(o, chos, realmProp, clientIP);\n                            //chos.write(result);\n                            chos.finish();\n                            chos.flush();                        \t\n                        }\n                     } else {\n                        // send page as whole thing, SSIs are not possible\n                        // apply templates\n                        final ByteBuffer o1 = new ByteBuffer();\n                        TemplateEngine.writeTemplate(fis, o1, templatePatterns, ASCII.getBytes(\"-UNRESOLVED_PATTERN-\"));\n                        fis.close();\n                        final ByteBuffer o = new ByteBuffer();\n\n                        if (zipContent) {\n                            GZIPOutputStream zippedOut = new GZIPOutputStream(o);\n                            ServerSideIncludes.writeSSI(o1, zippedOut, realmProp, clientIP);\n                            //httpTemplate.writeTemplate(fis, zippedOut, tp, \"-UNRESOLVED_PATTERN-\".getBytes(\"UTF-8\"));\n                            zippedOut.finish();\n                            zippedOut.flush();\n                            zippedOut.close();\n                            zippedOut = null;\n                        } else {\n                            ServerSideIncludes.writeSSI(o1, o, realmProp, clientIP);\n                            //httpTemplate.writeTemplate(fis, o, tp, \"-UNRESOLVED_PATTERN-\".getBytes(\"UTF-8\"));\n                        }\n                        if (method.equals(HeaderFramework.METHOD_HEAD)) {\n                            HTTPDemon.sendRespondHeader(conProp, out,\n                                    httpVersion, 200, null, mimeType, o.length(),\n                                    targetDate, expireDate, (templatePatterns == null) ? new ResponseHeader() : templatePatterns.getOutgoingHeader(),\n                                    contentEncoding, null, nocache);\n                        } else {\n                            final byte[] result = o.getBytes(); // this interrupts streaming (bad idea!)\n                            HTTPDemon.sendRespondHeader(conProp, out,\n                                    httpVersion, 200, null, mimeType, result.length,\n                                    targetDate, expireDate, (templatePatterns == null) ? new ResponseHeader() : templatePatterns.getOutgoingHeader(),\n                                    contentEncoding, null, nocache);\n                            FileUtils.copy(result, out);\n                        }\n                    }\n                } else { // no html\n\n                    int statusCode = 200;\n                    int rangeStartOffset = 0;\n                    final ResponseHeader header = new ResponseHeader();\n\n                    // adding the accept ranges header\n                    header.put(HeaderFramework.ACCEPT_RANGES, \"bytes\");\n\n                    // reading the files md5 hash if availabe and use it as ETAG of the resource\n                    String targetMD5 = null;\n                    final File targetMd5File = new File(targetFile + \".md5\");\n                    try {\n                        if (targetMd5File.exists()) {\n                            //String description = null;\n                            targetMD5 = UTF8.String(FileUtils.read(targetMd5File));\n                            final int pos = targetMD5.indexOf('\\n');\n                            if (pos >= 0) {\n                                //description = targetMD5.substring(pos + 1);\n                                targetMD5 = targetMD5.substring(0, pos);\n                            }\n\n                            // using the checksum as ETAG header\n                            header.put(HeaderFramework.ETAG, targetMD5);\n                        }\n                    } catch (final IOException e) {\n                        Log.logException(e);\n                    }\n\n                    if (requestHeader.containsKey(HeaderFramework.RANGE)) {\n                        final Object ifRange = requestHeader.ifRange();\n                        if ((ifRange == null)||\n                            (ifRange instanceof Date && targetFile.lastModified() == ((Date)ifRange).getTime()) ||\n                            (ifRange instanceof String && ifRange.equals(targetMD5))) {\n                            final String rangeHeaderVal = requestHeader.get(HeaderFramework.RANGE).trim();\n                            if (rangeHeaderVal.startsWith(\"bytes=\")) {\n                                final String rangesVal = rangeHeaderVal.substring(\"bytes=\".length());\n                                final String[] ranges = rangesVal.split(\",\");\n                                if ((ranges.length == 1)&&(ranges[0].endsWith(\"-\"))) {\n                                    rangeStartOffset = Integer.parseInt(ranges[0].substring(0,ranges[0].length()-1));\n                                    statusCode = 206;\n                                    header.put(HeaderFramework.CONTENT_RANGE, \"bytes \" + rangeStartOffset + \"-\" + (targetFile.length()-1) + \"/\" + targetFile.length());\n                                }\n                            }\n                        }\n                    }\n\n                    // write the file to the client\n                    targetDate = new Date(targetFile.lastModified());\n                    // cache file for one month in browser (but most browsers won't cache for that long)\n                    final Date expireDate = new Date(new Date().getTime() + (31l * 24 * 60 * 60 * 1000));\n                    final long   contentLength    = (zipContent)?-1:targetFile.length()-rangeStartOffset;\n                    final String contentEncoding  = (zipContent) ? \"gzip\" : null;\n                    final String transferEncoding = (httpVersion.equals(HeaderFramework.HTTP_VERSION_1_1) && zipContent) ? \"chunked\" : null;\n                    if (!httpVersion.equals(HeaderFramework.HTTP_VERSION_1_1) && zipContent) forceConnectionClose(conProp);\n\n                    HTTPDemon.sendRespondHeader(conProp, out, httpVersion, statusCode, null, mimeType, contentLength, targetDate, expireDate, header, contentEncoding, transferEncoding, nocache);\n\n                    if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                        ChunkedOutputStream chunkedOut = null;\n                        GZIPOutputStream zipped = null;\n                        OutputStream newOut = out;\n\n                        if (transferEncoding != null) {\n                            chunkedOut = new ChunkedOutputStream(newOut);\n                            newOut = chunkedOut;\n                        }\n                        if (contentEncoding != null) {\n                            zipped = new GZIPOutputStream(newOut);\n                            newOut = zipped;\n                        }\n\n                        FileUtils.copyRange(targetFile, newOut, rangeStartOffset);\n\n                        if (zipped != null) {\n                            zipped.flush();\n                            zipped.finish();\n                        }\n                        if (chunkedOut != null) {\n                            chunkedOut.finish();\n                        }\n\n                        // flush all\n                        try {newOut.flush();}catch (final Exception e) {}\n                    }\n                }\n            } else {\n                HTTPDemon.sendRespondError(conProp,out,3,404,\"File not Found\",null,null);\n                return;\n            }\n        } catch (final Exception e) {\n            try {\n                // error handling\n                int httpStatusCode = 400;\n                final String httpStatusText = null;\n                final StringBuilder errorMessage = new StringBuilder(2000);\n                Exception errorExc = null;\n\n                final String errorMsg = e.getMessage();\n                if (\n                        (e instanceof InterruptedException) ||\n                        ((errorMsg != null) && (errorMsg.startsWith(\"Socket closed\")) && (Thread.currentThread().isInterrupted()))\n                   ) {\n                    errorMessage.append(\"Interruption detected while processing query.\");\n                    httpStatusCode = 503;\n                } else {\n                    if ((errorMsg != null) &&\n                        (\n                           errorMsg.contains(\"Broken pipe\") ||\n                           errorMsg.contains(\"Connection reset\") ||\n                           errorMsg.contains(\"Read timed out\") ||\n                           errorMsg.contains(\"Connection timed out\") ||\n                           errorMsg.contains(\"Software caused connection abort\")\n                       )) {\n                        // client closed the connection, so we just end silently\n                        errorMessage.append(\"Client unexpectedly closed connection while processing query.\");\n                    } else {\n                        errorMessage.append(\"Unexpected error while processing query.\");\n                        httpStatusCode = 500;\n                        errorExc = e;\n                    }\n                }\n\n                errorMessage.append(\"\\nSession: \").append(Thread.currentThread().getName())\n                            .append(\"\\nQuery:   \").append(path)\n                            .append(\"\\nClient:  \").append(conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP))\n                            .append(\"\\nReason:  \").append(e.getMessage());\n\n                if (!conProp.containsKey(HeaderFramework.CONNECTION_PROP_PROXY_RESPOND_HEADER)) {\n                    // sending back an error message to the client\n                    // if we have not already send an http header\n                    HTTPDemon.sendRespondError(conProp,out, 4, httpStatusCode, httpStatusText, errorMessage.toString(), errorExc);\n                } else {\n                    // otherwise we close the connection\n                    forceConnectionClose(conProp);\n                }\n\n                // if it is an unexpected error we log it\n                if (httpStatusCode == 500) {\n                    theLogger.logWarning(errorMessage.toString(), e);\n                }\n\n            } catch (final Exception ee) {\n                forceConnectionClose(conProp);\n            }\n\n        } finally {\n            try {out.flush();}catch (final Exception e) {}\n        }\n    }","commit_id":"6e79675ff3f4a9dfebbc26ce88cbeeeb57986573","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public DbClient(Database db, MyBatis myBatis, DaoComponent... daoComponents) {\n    this.db = db;\n    this.myBatis = myBatis;\n\n    Map<Class, DaoComponent> map = Maps.newHashMap();\n    for (DaoComponent daoComponent : daoComponents) {\n      map.put(daoComponent.getClass(), daoComponent);\n    }\n    ruleDao = getDao(map, RuleDao.class);\n    activeRuleDao = getDao(map, ActiveRuleDao.class);\n    debtCharacteristicDao = getDao(map, CharacteristicDao.class);\n    qualityProfileDao = getDao(map, QualityProfileDao.class);\n    loadedTemplateDao = getDao(map, LoadedTemplateDao.class);\n    propertiesDao = getDao(map, PropertiesDao.class);\n    componentDao = getDao(map, ComponentDao.class);\n    resourceDao = getDao(map, ResourceDao.class);\n    measureDao = getDao(map, MeasureDao.class);\n    metricDao = getDao(map, MetricDao.class);\n    activityDao = getDao(map, ActivityDao.class);\n    authorizationDao = getDao(map, AuthorizationDao.class);\n    userDao = getDao(map, UserDao.class);\n    issueDao = getDao(map, IssueDao.class);\n  }","id":99044,"modified_method":"public DbClient(Database db, MyBatis myBatis, DaoComponent... daoComponents) {\n    this.db = db;\n    this.myBatis = myBatis;\n\n    Map<Class, DaoComponent> map = Maps.newHashMap();\n    for (DaoComponent daoComponent : daoComponents) {\n      map.put(daoComponent.getClass(), daoComponent);\n    }\n    ruleDao = getDao(map, RuleDao.class);\n    activeRuleDao = getDao(map, ActiveRuleDao.class);\n    debtCharacteristicDao = getDao(map, CharacteristicDao.class);\n    qualityProfileDao = getDao(map, QualityProfileDao.class);\n    loadedTemplateDao = getDao(map, LoadedTemplateDao.class);\n    propertiesDao = getDao(map, PropertiesDao.class);\n    componentDao = getDao(map, ComponentDao.class);\n    resourceDao = getDao(map, ResourceDao.class);\n    measureDao = getDao(map, MeasureDao.class);\n    metricDao = getDao(map, MetricDao.class);\n    activityDao = getDao(map, ActivityDao.class);\n    authorizationDao = getDao(map, AuthorizationDao.class);\n    userDao = getDao(map, UserDao.class);\n    issueDao = getDao(map, IssueDao.class);\n    issueAuthorizationDao = getDao(map, IssueAuthorizationDao.class);\n  }","commit_id":"b1c661b552fc1f76db2ed76b0c624712f2d8f3b2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void addIssueAuthorization(SearchClient searchClient, BulkRequestBuilder bulkRequestBuilder, ComponentDto project, String user, String group) {\n    Map<String, Object> permissionSource = newHashMap();\n    permissionSource.put(\"_parent\", project.key());\n    permissionSource.put(\"permission\", \"read\");\n    permissionSource.put(\"project\", project.key());\n    if (user != null) {\n      permissionSource.put(\"user\", user);\n    }\n    if (group != null) {\n      permissionSource.put(\"group\", group);\n    }\n\n    IndexRequestBuilder permissionRequestBuilder = searchClient.prepareIndex(IndexDefinition.ISSUES_PERMISSION.getIndexName(), IndexDefinition.ISSUES_PERMISSION.getIndexType())\n      .setSource(permissionSource);\n    if (bulkRequestBuilder != null) {\n      bulkRequestBuilder.add(permissionRequestBuilder);\n    } else {\n      permissionRequestBuilder.setRefresh(true).get();\n    }\n\n    Map<String, Object> projectSource = newHashMap();\n    projectSource.put(\"key\", project.key());\n\n    IndexRequestBuilder projectRequestBuilder = searchClient.prepareIndex(IndexDefinition.ISSUES_PROJECT.getIndexName(), IndexDefinition.ISSUES_PROJECT.getIndexType())\n      .setId(project.key())\n      .setSource(projectSource);\n    if (bulkRequestBuilder != null) {\n      bulkRequestBuilder.add(projectRequestBuilder);\n    } else {\n      projectRequestBuilder.setRefresh(true).get();\n    }\n  }","id":99045,"modified_method":"private IndexRequestBuilder addIssueAuthorization(final SearchClient searchClient, ComponentDto project, List<String> users, List<String> groups, boolean refresh) {\n    Map<String, Object> permissionSource = newHashMap();\n    permissionSource.put(\"_parent\", project.key());\n    permissionSource.put(\"permission\", \"read\");\n    permissionSource.put(\"project\", project.key());\n    if (users != null) {\n      permissionSource.put(\"users\", users);\n    }\n    if (groups != null) {\n      permissionSource.put(\"groups\", groups);\n    }\n\n    return searchClient.prepareIndex(IndexDefinition.ISSUES_AUTHORIZATION.getIndexName(), IndexDefinition.ISSUES_AUTHORIZATION.getIndexType())\n      .setId(project.key())\n      .setSource(permissionSource)\n      .setRefresh(refresh);\n  }","commit_id":"b1c661b552fc1f76db2ed76b0c624712f2d8f3b2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private SearchResponse searchIssueWithAuthorization(SearchClient searchClient, String user, String... groups) {\n    BoolFilterBuilder fb = FilterBuilders.boolFilter();\n\n    OrFilterBuilder or = FilterBuilders.orFilter(FilterBuilders.termFilter(\"user\", user));\n    for (String group : groups) {\n      or.add(FilterBuilders.termFilter(\"group\", group));\n    }\n    fb.must(FilterBuilders.termFilter(\"permission\", \"read\"), or).cache(true);\n    // fb.must(FilterBuilders.termFilter(\"permission\", \"read\"), or);\n\n    SearchRequestBuilder request = searchClient.prepareSearch(IndexDefinition.ISSUES.getIndexName()).setTypes(IndexDefinition.ISSUES.getIndexType())\n      .setQuery(\n        QueryBuilders.filteredQuery(\n          QueryBuilders.matchAllQuery(),\n          FilterBuilders.hasParentFilter(IndexDefinition.ISSUES_PROJECT.getIndexType(),\n            QueryBuilders.hasChildQuery(IndexDefinition.ISSUES_PERMISSION.getIndexType(),\n              QueryBuilders.filteredQuery(\n                QueryBuilders.matchAllQuery(), fb)\n            )\n            )\n          )\n      )\n      .setSize(Integer.MAX_VALUE);\n\n    return searchClient.execute(request);\n  }","id":99046,"modified_method":"private SearchResponse searchIssueWithAuthorization(SearchClient searchClient, String user, String... groups) {\n    BoolFilterBuilder fb = FilterBuilders.boolFilter();\n\n    OrFilterBuilder or = FilterBuilders.orFilter(FilterBuilders.termFilter(\"users\", user));\n    for (String group : groups) {\n      or.add(FilterBuilders.termFilter(\"groups\", group));\n    }\n    fb.must(FilterBuilders.termFilter(\"permission\", \"read\"), or).cache(true);\n    // fb.must(FilterBuilders.termFilter(\"permission\", \"read\"), or);\n\n    SearchRequestBuilder request = searchClient.prepareSearch(IndexDefinition.ISSUES.getIndexName()).setTypes(IndexDefinition.ISSUES.getIndexType())\n      .setQuery(\n        QueryBuilders.filteredQuery(\n          QueryBuilders.matchAllQuery(),\n          FilterBuilders.hasParentFilter(IndexDefinition.ISSUES_AUTHORIZATION.getIndexType(),\n            QueryBuilders.filteredQuery(\n              QueryBuilders.matchAllQuery(), fb)\n            )\n          )\n      )\n      .setSize(Integer.MAX_VALUE);\n\n    return searchClient.execute(request);\n  }","commit_id":"b1c661b552fc1f76db2ed76b0c624712f2d8f3b2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void issue_authorization_on_user() throws Exception {\n    SearchClient searchClient = tester.get(SearchClient.class);\n    createIssuePermissionIndex(searchClient);\n    createIssueProjectIndex(searchClient);\n\n    RuleDto rule = RuleTesting.newXooX1();\n    tester.get(RuleDao.class).insert(dbSession, rule);\n\n    ComponentDto project = addComponent(1L, 1L, \"SonarQube\");\n    ComponentDto file = addComponent(2L, 1L, \"IssueAction.java\");\n    addIssue(rule, project, file);\n    addIssueAuthorization(searchClient, project, \"julien\", null);\n\n    dbSession.commit();\n\n    // The issue is visible for user julien\n    assertThat(searchIssueWithAuthorization(searchClient, \"julien\", \"user\").getHits().getTotalHits()).isEqualTo(1);\n    // The issue is not visible for user simon\n    assertThat(searchIssueWithAuthorization(searchClient, \"simon\", \"user\").getHits().getTotalHits()).isEqualTo(0);\n\n//    Thread.sleep(Integer.MAX_VALUE);\n  }","id":99047,"modified_method":"@Test\n  public void issue_authorization_on_user() throws Exception {\n    SearchClient searchClient = tester.get(SearchClient.class);\n\n    RuleDto rule = RuleTesting.newXooX1();\n    tester.get(RuleDao.class).insert(dbSession, rule);\n\n    ComponentDto project = addComponent(1L, 1L, \"SonarQube\");\n    ComponentDto file = addComponent(2L, 1L, \"IssueAction.java\");\n    addIssue(rule, project, file);\n    addIssueAuthorization(searchClient, project, newArrayList(\"julien\"), null).get();\n\n    dbSession.commit();\n\n    // The issue is visible for user julien\n    assertThat(searchIssueWithAuthorization(searchClient, \"julien\", \"user\").getHits().getTotalHits()).isEqualTo(1);\n    // The issue is not visible for user simon\n    assertThat(searchIssueWithAuthorization(searchClient, \"simon\", \"user\").getHits().getTotalHits()).isEqualTo(0);\n  }","commit_id":"b1c661b552fc1f76db2ed76b0c624712f2d8f3b2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void addIssueAuthorization(SearchClient searchClient, ComponentDto project, String user, String group) {\n    addIssueAuthorization(searchClient, null, project, user, group);\n  }","id":99048,"modified_method":"private IndexRequestBuilder addIssueAuthorization(final SearchClient searchClient, ComponentDto project, List<String> users, List<String> groups) {\n    return addIssueAuthorization(searchClient, project, users, groups, true);\n  }","commit_id":"b1c661b552fc1f76db2ed76b0c624712f2d8f3b2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void issue_authorization_with_a_lot_of_issues() throws Exception {\n    SearchClient searchClient = tester.get(SearchClient.class);\n    createIssuePermissionIndex(searchClient);\n    createIssueProjectIndex(searchClient);\n\n    RuleDto rule = RuleTesting.newXooX1();\n    tester.get(RuleDao.class).insert(dbSession, rule);\n\n    int nbProject = 10;\n    int nbUser = 5;\n    int componentPerProject = 5;\n\n    Long projectId = 1L;\n    Long componentId = 1L;\n    BulkRequestBuilder bulkRequestBuilder = new BulkRequestBuilder(searchClient);\n    for (int p = 0; p < nbProject; p++) {\n      ComponentDto project = addComponent(projectId, projectId, \"Project-\" + projectId.toString());\n\n      addIssueAuthorization(searchClient, bulkRequestBuilder, project, null, \"anyone\");\n      if (p % 2 == 0) {\n        addIssueAuthorization(searchClient, bulkRequestBuilder, project, null, \"user\");\n      }\n      for (int u = 0; u < nbUser; u++) {\n        addIssueAuthorization(searchClient, bulkRequestBuilder, project, \"user-\" + u, null);\n      }\n      for (int c = 0; c < componentPerProject; c++) {\n        ComponentDto file = addComponent(componentId, projectId, \"Component-\" + componentId.toString());\n        addIssue(rule, project, file);\n        componentId++;\n      }\n      projectId++;\n\n      if (bulkRequestBuilder.numberOfActions() == nbProject) {\n        bulkRequestBuilder.get();\n        dbSession.commit();\n      }\n    }\n    bulkRequestBuilder.setRefresh(true).get();\n    dbSession.commit();\n\n    // All issues are visible by group anyone\n    assertThat(searchIssueWithAuthorization(searchClient, \"\", \"anyone\").getHits().getTotalHits()).isEqualTo(nbProject * componentPerProject);\n    // Half of issues are visible by group user\n    assertThat(searchIssueWithAuthorization(searchClient, \"\", \"user\").getHits().getTotalHits()).isEqualTo(nbProject * componentPerProject / 2);\n    // user-1 should see all issues\n    assertThat(searchIssueWithAuthorization(searchClient, \"user-1\", \"\").getHits().getTotalHits()).isEqualTo(nbProject * componentPerProject);\n\n//    Thread.sleep(Integer.MAX_VALUE);\n  }","id":99049,"modified_method":"@Test\n  public void issue_authorization_with_a_lot_of_issues() throws Exception {\n    SearchClient searchClient = tester.get(SearchClient.class);\n\n    RuleDto rule = RuleTesting.newXooX1();\n    tester.get(RuleDao.class).insert(dbSession, rule);\n\n    int nbProject = 10;\n    int nbUser = 5;\n    int componentPerProject = 5;\n\n    Long projectId = 1L;\n    Long componentId = 1L;\n\n    List<String> users = newArrayList();\n    for (int u = 0; u < nbUser; u++) {\n      users.add(\"user-\" + u);\n    }\n\n    BulkRequestBuilder bulkRequestBuilder = new BulkRequestBuilder(searchClient).setRefresh(true);\n    for (int p = 0; p < nbProject; p++) {\n      ComponentDto project = addComponent(projectId, projectId, \"Project-\" + projectId.toString());\n\n      List<String> groups = newArrayList();\n      groups.add(\"anyone\");\n      if (p % 2 == 0) {\n        groups.add(\"user\");\n      }\n\n      bulkRequestBuilder.add(addIssueAuthorization(searchClient, project, users, groups, false));\n      for (int c = 0; c < componentPerProject; c++) {\n        ComponentDto file = addComponent(componentId, projectId, \"Component-\" + componentId.toString());\n        addIssue(rule, project, file);\n        componentId++;\n      }\n      projectId++;\n\n      if (bulkRequestBuilder.numberOfActions() == nbProject) {\n        bulkRequestBuilder.get();\n        dbSession.commit();\n      }\n    }\n    bulkRequestBuilder.setRefresh(true).get();\n    dbSession.commit();\n\n    // All issues are visible by group anyone\n    assertThat(searchIssueWithAuthorization(searchClient, \"\", \"anyone\").getHits().getTotalHits()).isEqualTo(nbProject * componentPerProject);\n    // Half of issues are visible by group user\n    assertThat(searchIssueWithAuthorization(searchClient, \"\", \"user\").getHits().getTotalHits()).isEqualTo(nbProject * componentPerProject / 2);\n    // user-1 should see all issues\n    assertThat(searchIssueWithAuthorization(searchClient, \"user-1\", \"\").getHits().getTotalHits()).isEqualTo(nbProject * componentPerProject);\n\n    // Thread.sleep(Integer.MAX_VALUE);\n  }","commit_id":"b1c661b552fc1f76db2ed76b0c624712f2d8f3b2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void issue_authorization_on_group() throws Exception {\n    SearchClient searchClient = tester.get(SearchClient.class);\n    createIssuePermissionIndex(searchClient);\n    createIssueProjectIndex(searchClient);\n\n    RuleDto rule = RuleTesting.newXooX1();\n    tester.get(RuleDao.class).insert(dbSession, rule);\n\n    ComponentDto project1 = addComponent(1L, 1L, \"SonarQube :: Server\");\n    ComponentDto file1 = addComponent(2L, 1L, \"IssueAction.java\");\n    addIssue(rule, project1, file1);\n    addIssueAuthorization(searchClient, project1, null, \"user\");\n\n    ComponentDto project2 = addComponent(10L, 10L, \"SonarQube :: Core\");\n    ComponentDto file2 = addComponent(11L, 10L, \"IssueDao.java\");\n    addIssue(rule, project2, file2);\n    addIssueAuthorization(searchClient, project2, null, \"reviewer\");\n\n    ComponentDto project3 = addComponent(20L, 20L, \"SonarQube :: WS\");\n    ComponentDto file3 = addComponent(21L, 20L, \"IssueWS.java\");\n    addIssue(rule, project3, file3);\n    addIssueAuthorization(searchClient, project3, null, \"user\");\n    addIssueAuthorization(searchClient, project3, null, \"reviewer\");\n\n    dbSession.commit();\n\n    assertThat(searchIssueWithAuthorization(searchClient, \"julien\", \"user\", \"reviewer\").getHits().getTotalHits()).isEqualTo(3); // ok\n    assertThat(searchIssueWithAuthorization(searchClient, \"julien\", \"user\").getHits().getTotalHits()).isEqualTo(2); // ko -> 1\n    assertThat(searchIssueWithAuthorization(searchClient, \"julien\", \"reviewer\").getHits().getTotalHits()).isEqualTo(2); // ko -> 1\n    assertThat(searchIssueWithAuthorization(searchClient, \"julien\", \"unknown\").getHits().getTotalHits()).isEqualTo(0);\n  }","id":99050,"modified_method":"@Test\n  public void issue_authorization_on_group() throws Exception {\n    SearchClient searchClient = tester.get(SearchClient.class);\n\n    RuleDto rule = RuleTesting.newXooX1();\n    tester.get(RuleDao.class).insert(dbSession, rule);\n\n    ComponentDto project1 = addComponent(1L, 1L, \"SonarQube :: Server\");\n    ComponentDto file1 = addComponent(2L, 1L, \"IssueAction.java\");\n    addIssue(rule, project1, file1);\n    addIssueAuthorization(searchClient, project1, null, newArrayList(\"user\")).get();\n\n    ComponentDto project2 = addComponent(10L, 10L, \"SonarQube :: Core\");\n    ComponentDto file2 = addComponent(11L, 10L, \"IssueDao.java\");\n    addIssue(rule, project2, file2);\n    addIssueAuthorization(searchClient, project2, null, newArrayList(\"reviewer\")).get();\n\n    ComponentDto project3 = addComponent(20L, 20L, \"SonarQube :: WS\");\n    ComponentDto file3 = addComponent(21L, 20L, \"IssueWS.java\");\n    addIssue(rule, project3, file3);\n    addIssueAuthorization(searchClient, project3, null, newArrayList(\"user\", \"reviewer\")).get();\n\n    dbSession.commit();\n\n    assertThat(searchIssueWithAuthorization(searchClient, \"julien\", \"user\", \"reviewer\").getHits().getTotalHits()).isEqualTo(3); // ok\n    assertThat(searchIssueWithAuthorization(searchClient, \"julien\", \"user\").getHits().getTotalHits()).isEqualTo(2); // ko -> 1\n    assertThat(searchIssueWithAuthorization(searchClient, \"julien\", \"reviewer\").getHits().getTotalHits()).isEqualTo(2); // ko -> 1\n    assertThat(searchIssueWithAuthorization(searchClient, \"julien\", \"unknown\").getHits().getTotalHits()).isEqualTo(0);\n  }","commit_id":"b1c661b552fc1f76db2ed76b0c624712f2d8f3b2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private String getParentType() {\n    return IndexDefinition.ISSUES_PROJECT.getIndexType();\n  }","id":99051,"modified_method":"private String getParentType() {\n    return IndexDefinition.ISSUES_AUTHORIZATION.getIndexType();\n  }","commit_id":"b1c661b552fc1f76db2ed76b0c624712f2d8f3b2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public MyBatis start() {\n    LogFactory.useSlf4jLogging();\n\n    Configuration conf = new Configuration();\n    conf.setEnvironment(new Environment(\"production\", createTransactionFactory(), database.getDataSource()));\n    conf.setDatabaseId(database.getDialect().getId());\n    conf.setUseGeneratedKeys(true);\n    conf.setLazyLoadingEnabled(false);\n    conf.setJdbcTypeForNull(JdbcType.NULL);\n    conf.getVariables().setProperty(\"_true\", database.getDialect().getTrueSqlValue());\n    conf.getVariables().setProperty(\"_false\", database.getDialect().getFalseSqlValue());\n\n    loadAlias(conf, \"ActiveDashboard\", ActiveDashboardDto.class);\n    loadAlias(conf, \"Author\", AuthorDto.class);\n    loadAlias(conf, \"Component\", ComponentDto.class);\n    loadAlias(conf, \"AuthorizedComponent\", AuthorizedComponentDto.class);\n    loadAlias(conf, \"Dashboard\", DashboardDto.class);\n    loadAlias(conf, \"Dependency\", DependencyDto.class);\n    loadAlias(conf, \"DuplicationUnit\", DuplicationUnitDto.class);\n    loadAlias(conf, \"Graph\", GraphDto.class);\n    loadAlias(conf, \"Group\", GroupDto.class);\n    loadAlias(conf, \"GroupRole\", GroupRoleDto.class);\n    loadAlias(conf, \"GroupMembership\", GroupMembershipDto.class);\n    loadAlias(conf, \"LoadedTemplate\", LoadedTemplateDto.class);\n    loadAlias(conf, \"MeasureFilter\", MeasureFilterDto.class);\n    loadAlias(conf, \"NotificationQueue\", NotificationQueueDto.class);\n    loadAlias(conf, \"Property\", PropertyDto.class);\n    loadAlias(conf, \"PurgeableSnapshot\", PurgeableSnapshotDto.class);\n    loadAlias(conf, \"QualityGate\", QualityGateDto.class);\n    loadAlias(conf, \"QualityGateCondition\", QualityGateConditionDto.class);\n    loadAlias(conf, \"ProjectQgateAssociation\", ProjectQgateAssociationDto.class);\n    loadAlias(conf, \"Resource\", ResourceDto.class);\n    loadAlias(conf, \"ResourceIndex\", ResourceIndexDto.class);\n    loadAlias(conf, \"ResourceSnapshot\", ResourceSnapshotDto.class);\n    loadAlias(conf, \"Rule\", RuleDto.class);\n    loadAlias(conf, \"RuleParam\", RuleParamDto.class);\n    loadAlias(conf, \"Snapshot\", SnapshotDto.class);\n    loadAlias(conf, \"Semaphore\", SemaphoreDto.class);\n    loadAlias(conf, \"SchemaMigration\", SchemaMigrationDto.class);\n    loadAlias(conf, \"User\", UserDto.class);\n    loadAlias(conf, \"UserRole\", UserRoleDto.class);\n    loadAlias(conf, \"Widget\", WidgetDto.class);\n    loadAlias(conf, \"WidgetProperty\", WidgetPropertyDto.class);\n    loadAlias(conf, \"MeasureModel\", MeasureModel.class);\n    loadAlias(conf, \"Measure\", MeasureDto.class);\n    loadAlias(conf, \"Metric\", MetricDto.class);\n    loadAlias(conf, \"Issue\", IssueDto.class);\n    loadAlias(conf, \"IssueChange\", IssueChangeDto.class);\n    loadAlias(conf, \"IssueFilter\", IssueFilterDto.class);\n    loadAlias(conf, \"IssueFilterFavourite\", IssueFilterFavouriteDto.class);\n    loadAlias(conf, \"SnapshotData\", SnapshotDataDto.class);\n    loadAlias(conf, \"ActionPlanIssue\", ActionPlanDto.class);\n    loadAlias(conf, \"ActionPlanStats\", ActionPlanStatsDto.class);\n    loadAlias(conf, \"PermissionTemplate\", PermissionTemplateDto.class);\n    loadAlias(conf, \"PermissionTemplateUser\", PermissionTemplateUserDto.class);\n    loadAlias(conf, \"PermissionTemplateGroup\", PermissionTemplateGroupDto.class);\n    loadAlias(conf, \"Characteristic\", CharacteristicDto.class);\n    loadAlias(conf, \"UserWithPermission\", UserWithPermissionDto.class);\n    loadAlias(conf, \"GroupWithPermission\", GroupWithPermissionDto.class);\n    loadAlias(conf, \"QualityProfile\", QualityProfileDto.class);\n    loadAlias(conf, \"ActiveRule\", ActiveRuleDto.class);\n    loadAlias(conf, \"ActiveRuleParam\", ActiveRuleParamDto.class);\n    loadAlias(conf, \"RequirementMigration\", RequirementMigrationDto.class);\n    loadAlias(conf, \"Activity\", ActivityDto.class);\n\n    // AuthorizationMapper has to be loaded before IssueMapper because this last one used it\n    loadMapper(conf, \"org.sonar.core.user.AuthorizationMapper\");\n    // ResourceMapper has to be loaded before IssueMapper because this last one used it\n    loadMapper(conf, ResourceMapper.class);\n\n    loadMapper(conf, \"org.sonar.core.permission.PermissionMapper\");\n    Class<?>[] mappers = {ActivityMapper.class, ActiveDashboardMapper.class, AuthorMapper.class, DashboardMapper.class,\n      DependencyMapper.class, DuplicationMapper.class, GraphDtoMapper.class,\n      IssueMapper.class, IssueStatsMapper.class, IssueChangeMapper.class, IssueFilterMapper.class, IssueFilterFavouriteMapper.class,\n      LoadedTemplateMapper.class, MeasureFilterMapper.class, Migration44Mapper.class, PermissionTemplateMapper.class, PropertiesMapper.class, PurgeMapper.class,\n      ResourceKeyUpdaterMapper.class, ResourceIndexerMapper.class, ResourceSnapshotMapper.class, RoleMapper.class, RuleMapper.class,\n      SchemaMigrationMapper.class, SemaphoreMapper.class, UserMapper.class, WidgetMapper.class, WidgetPropertyMapper.class,\n      org.sonar.api.database.model.MeasureMapper.class, SnapshotDataMapper.class, SnapshotSourceMapper.class, ActionPlanMapper.class, ActionPlanStatsMapper.class,\n      NotificationQueueMapper.class, CharacteristicMapper.class,\n      GroupMembershipMapper.class, QualityProfileMapper.class, ActiveRuleMapper.class,\n      MeasureMapper.class, MetricMapper.class, QualityGateMapper.class, QualityGateConditionMapper.class, ComponentMapper.class, ProjectQgateAssociationMapper.class\n    };\n    loadMappers(conf, mappers);\n    configureLogback(mappers);\n\n    sessionFactory = new SqlSessionFactoryBuilder().build(conf);\n    return this;\n  }","id":99052,"modified_method":"public MyBatis start() {\n    LogFactory.useSlf4jLogging();\n\n    Configuration conf = new Configuration();\n    conf.setEnvironment(new Environment(\"production\", createTransactionFactory(), database.getDataSource()));\n    conf.setDatabaseId(database.getDialect().getId());\n    conf.setUseGeneratedKeys(true);\n    conf.setLazyLoadingEnabled(false);\n    conf.setJdbcTypeForNull(JdbcType.NULL);\n    conf.getVariables().setProperty(\"_true\", database.getDialect().getTrueSqlValue());\n    conf.getVariables().setProperty(\"_false\", database.getDialect().getFalseSqlValue());\n\n    loadAlias(conf, \"ActiveDashboard\", ActiveDashboardDto.class);\n    loadAlias(conf, \"Author\", AuthorDto.class);\n    loadAlias(conf, \"Component\", ComponentDto.class);\n    loadAlias(conf, \"AuthorizedComponent\", AuthorizedComponentDto.class);\n    loadAlias(conf, \"Dashboard\", DashboardDto.class);\n    loadAlias(conf, \"Dependency\", DependencyDto.class);\n    loadAlias(conf, \"DuplicationUnit\", DuplicationUnitDto.class);\n    loadAlias(conf, \"Graph\", GraphDto.class);\n    loadAlias(conf, \"Group\", GroupDto.class);\n    loadAlias(conf, \"GroupRole\", GroupRoleDto.class);\n    loadAlias(conf, \"GroupMembership\", GroupMembershipDto.class);\n    loadAlias(conf, \"LoadedTemplate\", LoadedTemplateDto.class);\n    loadAlias(conf, \"MeasureFilter\", MeasureFilterDto.class);\n    loadAlias(conf, \"NotificationQueue\", NotificationQueueDto.class);\n    loadAlias(conf, \"Property\", PropertyDto.class);\n    loadAlias(conf, \"PurgeableSnapshot\", PurgeableSnapshotDto.class);\n    loadAlias(conf, \"QualityGate\", QualityGateDto.class);\n    loadAlias(conf, \"QualityGateCondition\", QualityGateConditionDto.class);\n    loadAlias(conf, \"ProjectQgateAssociation\", ProjectQgateAssociationDto.class);\n    loadAlias(conf, \"Resource\", ResourceDto.class);\n    loadAlias(conf, \"ResourceIndex\", ResourceIndexDto.class);\n    loadAlias(conf, \"ResourceSnapshot\", ResourceSnapshotDto.class);\n    loadAlias(conf, \"Rule\", RuleDto.class);\n    loadAlias(conf, \"RuleParam\", RuleParamDto.class);\n    loadAlias(conf, \"Snapshot\", SnapshotDto.class);\n    loadAlias(conf, \"Semaphore\", SemaphoreDto.class);\n    loadAlias(conf, \"SchemaMigration\", SchemaMigrationDto.class);\n    loadAlias(conf, \"User\", UserDto.class);\n    loadAlias(conf, \"UserRole\", UserRoleDto.class);\n    loadAlias(conf, \"Widget\", WidgetDto.class);\n    loadAlias(conf, \"WidgetProperty\", WidgetPropertyDto.class);\n    loadAlias(conf, \"MeasureModel\", MeasureModel.class);\n    loadAlias(conf, \"Measure\", MeasureDto.class);\n    loadAlias(conf, \"Metric\", MetricDto.class);\n    loadAlias(conf, \"Issue\", IssueDto.class);\n    loadAlias(conf, \"IssueAuthorization\", IssueAuthorizationDto.class);\n    loadAlias(conf, \"IssueChange\", IssueChangeDto.class);\n    loadAlias(conf, \"IssueFilter\", IssueFilterDto.class);\n    loadAlias(conf, \"IssueFilterFavourite\", IssueFilterFavouriteDto.class);\n    loadAlias(conf, \"SnapshotData\", SnapshotDataDto.class);\n    loadAlias(conf, \"ActionPlanIssue\", ActionPlanDto.class);\n    loadAlias(conf, \"ActionPlanStats\", ActionPlanStatsDto.class);\n    loadAlias(conf, \"PermissionTemplate\", PermissionTemplateDto.class);\n    loadAlias(conf, \"PermissionTemplateUser\", PermissionTemplateUserDto.class);\n    loadAlias(conf, \"PermissionTemplateGroup\", PermissionTemplateGroupDto.class);\n    loadAlias(conf, \"Characteristic\", CharacteristicDto.class);\n    loadAlias(conf, \"UserWithPermission\", UserWithPermissionDto.class);\n    loadAlias(conf, \"GroupWithPermission\", GroupWithPermissionDto.class);\n    loadAlias(conf, \"QualityProfile\", QualityProfileDto.class);\n    loadAlias(conf, \"ActiveRule\", ActiveRuleDto.class);\n    loadAlias(conf, \"ActiveRuleParam\", ActiveRuleParamDto.class);\n    loadAlias(conf, \"RequirementMigration\", RequirementMigrationDto.class);\n    loadAlias(conf, \"Activity\", ActivityDto.class);\n\n    // AuthorizationMapper has to be loaded before IssueMapper because this last one used it\n    loadMapper(conf, \"org.sonar.core.user.AuthorizationMapper\");\n    // ResourceMapper has to be loaded before IssueMapper because this last one used it\n    loadMapper(conf, ResourceMapper.class);\n\n    loadMapper(conf, \"org.sonar.core.permission.PermissionMapper\");\n    Class<?>[] mappers = {ActivityMapper.class, ActiveDashboardMapper.class, AuthorMapper.class, DashboardMapper.class,\n      DependencyMapper.class, DuplicationMapper.class, GraphDtoMapper.class,\n      IssueMapper.class, IssueAuthorizationMapper.class, IssueStatsMapper.class, IssueChangeMapper.class, IssueFilterMapper.class, IssueFilterFavouriteMapper.class,\n      LoadedTemplateMapper.class, MeasureFilterMapper.class, Migration44Mapper.class, PermissionTemplateMapper.class, PropertiesMapper.class, PurgeMapper.class,\n      ResourceKeyUpdaterMapper.class, ResourceIndexerMapper.class, ResourceSnapshotMapper.class, RoleMapper.class, RuleMapper.class,\n      SchemaMigrationMapper.class, SemaphoreMapper.class, UserMapper.class, WidgetMapper.class, WidgetPropertyMapper.class,\n      org.sonar.api.database.model.MeasureMapper.class, SnapshotDataMapper.class, SnapshotSourceMapper.class, ActionPlanMapper.class, ActionPlanStatsMapper.class,\n      NotificationQueueMapper.class, CharacteristicMapper.class,\n      GroupMembershipMapper.class, QualityProfileMapper.class, ActiveRuleMapper.class,\n      MeasureMapper.class, MetricMapper.class, QualityGateMapper.class, QualityGateConditionMapper.class, ComponentMapper.class, ProjectQgateAssociationMapper.class\n    };\n    loadMappers(conf, mappers);\n    configureLogback(mappers);\n\n    sessionFactory = new SqlSessionFactoryBuilder().build(conf);\n    return this;\n  }","commit_id":"b1c661b552fc1f76db2ed76b0c624712f2d8f3b2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * All the stuff required to connect to database\n   */\n  Collection level1Components() {\n    List components = Lists.newArrayList(rootComponents);\n    components.addAll(Arrays.asList(\n      new BaseConfiguration(),\n      ServerSettings.class,\n      ServerImpl.class,\n      Logback.class,\n      Profiling.class,\n      JRubyProfiling.class,\n      EmbeddedDatabaseFactory.class,\n      DefaultDatabase.class,\n      DatabaseChecker.class,\n      MyBatis.class,\n      IndexQueue.class,\n      DatabaseServerCompatibility.class,\n      DatabaseVersion.class,\n      PurgeProfiler.class,\n      DefaultServerFileSystem.class,\n      PreviewDatabaseFactory.class,\n      SemaphoreUpdater.class,\n      SemaphoresImpl.class,\n      TempFolderCleaner.class,\n      new TempFolderProvider(),\n      System2.INSTANCE,\n      RuleDao.class,\n      IssueDao.class,\n      ActiveRuleDao.class,\n      MeasureDao.class,\n      MetricDao.class,\n      ComponentDao.class,\n      DbClient.class,\n      MeasureFilterDao.class,\n      ActivityDao.class,\n\n      // Elasticsearch\n      SearchClient.class,\n      ActivityNormalizer.class,\n      IssueNormalizer.class,\n      RuleNormalizer.class,\n      ActiveRuleNormalizer.class,\n      RuleIndex.class,\n      ActiveRuleIndex.class,\n      IssueIndex.class,\n      ActivityIndex.class,\n      IndexClient.class,\n      SearchHealth.class,\n\n      // LogService\n      ActivityService.class\n\n      ));\n    components.addAll(CorePropertyDefinitions.all());\n    components.addAll(DatabaseMigrations.CLASSES);\n    components.addAll(DaoUtils.getDaoClasses());\n    return components;\n  }","id":99053,"modified_method":"/**\n   * All the stuff required to connect to database\n   */\n  Collection level1Components() {\n    List components = Lists.newArrayList(rootComponents);\n    components.addAll(Arrays.asList(\n      new BaseConfiguration(),\n      ServerSettings.class,\n      ServerImpl.class,\n      Logback.class,\n      Profiling.class,\n      JRubyProfiling.class,\n      EmbeddedDatabaseFactory.class,\n      DefaultDatabase.class,\n      DatabaseChecker.class,\n      MyBatis.class,\n      IndexQueue.class,\n      DatabaseServerCompatibility.class,\n      DatabaseVersion.class,\n      PurgeProfiler.class,\n      DefaultServerFileSystem.class,\n      PreviewDatabaseFactory.class,\n      SemaphoreUpdater.class,\n      SemaphoresImpl.class,\n      TempFolderCleaner.class,\n      new TempFolderProvider(),\n      System2.INSTANCE,\n      RuleDao.class,\n      IssueDao.class,\n      ActiveRuleDao.class,\n      MeasureDao.class,\n      MetricDao.class,\n      ComponentDao.class,\n      DbClient.class,\n      MeasureFilterDao.class,\n      ActivityDao.class,\n\n      // Elasticsearch\n      SearchClient.class,\n      ActivityNormalizer.class,\n      IssueNormalizer.class,\n      IssueAuthorizationNormalizer.class,\n      RuleNormalizer.class,\n      ActiveRuleNormalizer.class,\n      RuleIndex.class,\n      ActiveRuleIndex.class,\n      IssueIndex.class,\n      IssueAuthorizationIndex.class,\n      ActivityIndex.class,\n      IndexClient.class,\n      SearchHealth.class,\n\n      // LogService\n      ActivityService.class\n\n      ));\n    components.addAll(CorePropertyDefinitions.all());\n    components.addAll(DatabaseMigrations.CLASSES);\n    components.addAll(DaoUtils.getDaoClasses());\n    return components;\n  }","commit_id":"b1c661b552fc1f76db2ed76b0c624712f2d8f3b2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n    public TaskClassInfo getTaskClassInfo(Class<? extends Task> type) {\n        TaskClassInfo taskClassInfo = classInfos.get(type);\n        if (taskClassInfo == null) {\n            taskClassInfo = new TaskClassInfo();\n            findTaskActions(type, taskClassInfo);\n\n            TaskClassValidator validator = new TaskClassValidator();\n            validator.attachActions(null, type);\n            taskClassInfo.setValidator(validator);\n\n            taskClassInfo.setCacheable(type.isAnnotationPresent(CacheableTask.class));\n\n            classInfos.put(type, taskClassInfo);\n        }\n        return taskClassInfo;\n    }","id":99054,"modified_method":"@Override\n    public TaskClassInfo getTaskClassInfo(Class<? extends Task> type) {\n        return classInfos.getUnchecked(type);\n    }","commit_id":"d2d424d1244dc38bf40d822d77851a31f363d9e1","url":"https://github.com/gradle/gradle"},{"original_method":"@SuppressWarnings(\"serial\")\n  private void createLoadedJobCache(Configuration conf) {\n    loadedJobCacheSize = conf.getInt(\n        JHAdminConfig.MR_HISTORY_LOADED_JOB_CACHE_SIZE,\n        JHAdminConfig.DEFAULT_MR_HISTORY_LOADED_JOB_CACHE_SIZE);\n\n    loadedJobCache = Collections.synchronizedMap(new LinkedHashMap<JobId, Job>(\n        loadedJobCacheSize + 1, 0.75f, true) {\n      @Override\n      public boolean removeEldestEntry(final Map.Entry<JobId, Job> eldest) {\n        return super.size() > loadedJobCacheSize;\n      }\n    });\n  }","id":99055,"modified_method":"@SuppressWarnings(\"serial\")\n  private void createLoadedJobCache(Configuration conf) {\n    // Set property for old \"loaded jobs\" cache\n    loadedJobCacheSize = conf.getInt(\n        JHAdminConfig.MR_HISTORY_LOADED_JOB_CACHE_SIZE,\n        JHAdminConfig.DEFAULT_MR_HISTORY_LOADED_JOB_CACHE_SIZE);\n\n    // Check property for new \"loaded tasks\" cache perform sanity checking\n    useLoadedTasksCache = false;\n    try {\n      String taskSizeString = conf\n          .get(JHAdminConfig.MR_HISTORY_LOADED_TASKS_CACHE_SIZE);\n      if (taskSizeString != null) {\n        loadedTasksCacheSize = Math.max(Integer.parseInt(taskSizeString), 1);\n        useLoadedTasksCache = true;\n      }\n    } catch (NumberFormatException nfe) {\n      LOG.error(\"The property \" +\n          JHAdminConfig.MR_HISTORY_LOADED_TASKS_CACHE_SIZE +\n          \" is not an integer value.  Please set it to a positive\" +\n          \" integer value.\");\n    }\n\n    CacheLoader<JobId, Job> loader;\n    loader = new CacheLoader<JobId, Job>() {\n      @Override\n      public Job load(JobId key) throws Exception {\n        return loadJob(key);\n      }\n    };\n\n    if (!useLoadedTasksCache) {\n      loadedJobCache = CacheBuilder.newBuilder()\n          .maximumSize(loadedJobCacheSize)\n          .initialCapacity(loadedJobCacheSize)\n          .concurrencyLevel(1)\n          .build(loader);\n    } else {\n      Weigher<JobId, Job> weightByTasks;\n      weightByTasks = new Weigher<JobId, Job>() {\n        /**\n         * Method for calculating Job weight by total task count.  If\n         * the total task count is greater than the size of the tasks\n         * cache, then cap it at the cache size.  This allows the cache\n         * to always hold one large job.\n         * @param key JobId object\n         * @param value Job object\n         * @return Weight of the job as calculated by total task count\n         */\n        @Override\n        public int weigh(JobId key, Job value) {\n          int taskCount = Math.min(loadedTasksCacheSize,\n              value.getTotalMaps() + value.getTotalReduces());\n          return taskCount;\n        }\n      };\n      // Keep concurrencyLevel at 1.  Otherwise, two problems:\n      // 1) The largest job that can be initially loaded is\n      //    cache size / 4.\n      // 2) Unit tests are not deterministic.\n      loadedJobCache = CacheBuilder.newBuilder()\n          .maximumWeight(loadedTasksCacheSize)\n          .weigher(weightByTasks)\n          .concurrencyLevel(1)\n          .build(loader);\n    }\n  }","commit_id":"0f72da7e281376f4fcbfbf3fb33f5d7fedcdb1aa","url":"https://github.com/apache/hadoop"},{"original_method":"@VisibleForTesting\n  Map<JobId, Job> getLoadedJobCache() {\n    return loadedJobCache;\n  }","id":99056,"modified_method":"@VisibleForTesting\n  Cache<JobId, Job> getLoadedJobCache() {\n    return loadedJobCache;\n  }","commit_id":"0f72da7e281376f4fcbfbf3fb33f5d7fedcdb1aa","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n  public Job getFullJob(JobId jobId) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Looking for Job \" + jobId);\n    }\n    try {\n      HistoryFileInfo fileInfo = hsManager.getFileInfo(jobId);\n      Job result = null;\n      if (fileInfo != null) {\n        result = loadedJobCache.get(jobId);\n        if (result == null) {\n          result = loadJob(fileInfo);\n        } else if(fileInfo.isDeleted()) {\n          loadedJobCache.remove(jobId);\n          result = null;\n        }\n      } else {\n        loadedJobCache.remove(jobId);\n      }\n      return result;\n    } catch (IOException e) {\n      throw new YarnRuntimeException(e);\n    }\n  }","id":99057,"modified_method":"@Override\n  public Job getFullJob(JobId jobId) {\n    Job retVal = null;\n    try {\n      retVal = loadedJobCache.getUnchecked(jobId);\n    } catch (UncheckedExecutionException e) {\n      if (e.getCause() instanceof HSFileRuntimeException) {\n        LOG.error(e.getCause().getMessage());\n        return null;\n      } else {\n        throw new YarnRuntimeException(e.getCause());\n      }\n    }\n    return retVal;\n  }","commit_id":"0f72da7e281376f4fcbfbf3fb33f5d7fedcdb1aa","url":"https://github.com/apache/hadoop"},{"original_method":"@Test\n  public void testRefreshLoadedJobCache() throws Exception {\n    HistoryFileManager historyManager = mock(HistoryFileManager.class);\n    jobHistory = spy(new JobHistory());\n    doReturn(historyManager).when(jobHistory).createHistoryFileManager();\n\n    Configuration conf = new Configuration();\n    // Set the cache size to 2\n    conf.set(JHAdminConfig.MR_HISTORY_LOADED_JOB_CACHE_SIZE, \"2\");\n    jobHistory.init(conf);\n    jobHistory.start();\n\n    CachedHistoryStorage storage = spy((CachedHistoryStorage) jobHistory\n        .getHistoryStorage());\n\n    Job[] jobs = new Job[3];\n    JobId[] jobIds = new JobId[3];\n\n    for (int i = 0; i < 3; i++) {\n      jobs[i] = mock(Job.class);\n      jobIds[i] = mock(JobId.class);\n      when(jobs[i].getID()).thenReturn(jobIds[i]);\n    }\n\n    HistoryFileInfo fileInfo = mock(HistoryFileInfo.class);\n    when(historyManager.getFileInfo(any(JobId.class))).thenReturn(fileInfo);\n    when(fileInfo.loadJob()).thenReturn(jobs[0]).thenReturn(jobs[1])\n        .thenReturn(jobs[2]);\n\n    // getFullJob will put the job in the cache if it isn't there\n    for (int i = 0; i < 3; i++) {\n      storage.getFullJob(jobs[i].getID());\n    }\n\n    Map<JobId, Job> jobCache = storage.getLoadedJobCache();\n    // job0 should have been purged since cache size is 2\n    assertFalse(jobCache.containsKey(jobs[0].getID()));\n    assertTrue(jobCache.containsKey(jobs[1].getID())\n        && jobCache.containsKey(jobs[2].getID()));\n\n    // Setting cache size to 3\n    conf.set(JHAdminConfig.MR_HISTORY_LOADED_JOB_CACHE_SIZE, \"3\");\n    doReturn(conf).when(storage).createConf();\n\n    when(fileInfo.loadJob()).thenReturn(jobs[0]).thenReturn(jobs[1])\n        .thenReturn(jobs[2]);\n\n    jobHistory.refreshLoadedJobCache();\n\n    for (int i = 0; i < 3; i++) {\n      storage.getFullJob(jobs[i].getID());\n    }\n\n    jobCache = storage.getLoadedJobCache();\n\n    // All three jobs should be in cache since its size is now 3\n    for (int i = 0; i < 3; i++) {\n      assertTrue(jobCache.containsKey(jobs[i].getID()));\n    }\n  }","id":99058,"modified_method":"@Test\n  public void testRefreshLoadedJobCache() throws Exception {\n    HistoryFileManager historyManager = mock(HistoryFileManager.class);\n    jobHistory = spy(new JobHistory());\n    doReturn(historyManager).when(jobHistory).createHistoryFileManager();\n\n    Configuration conf = new Configuration();\n    // Set the cache size to 2\n    conf.setInt(JHAdminConfig.MR_HISTORY_LOADED_JOB_CACHE_SIZE, 2);\n    jobHistory.init(conf);\n    jobHistory.start();\n\n    CachedHistoryStorage storage = spy((CachedHistoryStorage) jobHistory\n        .getHistoryStorage());\n\n    assertFalse(storage.getUseLoadedTasksCache());\n\n    Job[] jobs = new Job[3];\n    JobId[] jobIds = new JobId[3];\n\n    for (int i = 0; i < 3; i++) {\n      jobs[i] = mock(Job.class);\n      jobIds[i] = mock(JobId.class);\n      when(jobs[i].getID()).thenReturn(jobIds[i]);\n    }\n\n    HistoryFileInfo fileInfo = mock(HistoryFileInfo.class);\n    when(historyManager.getFileInfo(any(JobId.class))).thenReturn(fileInfo);\n    when(fileInfo.loadJob()).thenReturn(jobs[0]).thenReturn(jobs[1])\n        .thenReturn(jobs[2]);\n\n    // getFullJob will put the job in the cache if it isn't there\n    for (int i = 0; i < 3; i++) {\n      storage.getFullJob(jobs[i].getID());\n    }\n\n    Cache<JobId, Job> jobCache = storage.getLoadedJobCache();\n    // Verify some jobs are stored in the cache.  Hard to predict eviction\n    // in Guava version.\n    assertTrue(jobCache.size() > 0);\n\n    // Setting cache size to 3\n    conf.setInt(JHAdminConfig.MR_HISTORY_LOADED_JOB_CACHE_SIZE, 3);\n    doReturn(conf).when(storage).createConf();\n\n    when(fileInfo.loadJob()).thenReturn(jobs[0]).thenReturn(jobs[1])\n        .thenReturn(jobs[2]);\n\n    jobHistory.refreshLoadedJobCache();\n\n    for (int i = 0; i < 3; i++) {\n      storage.getFullJob(jobs[i].getID());\n    }\n\n    jobCache = storage.getLoadedJobCache();\n\n    // Verify some jobs are stored in the cache.  Hard to predict eviction\n    // in Guava version.\n    assertTrue(jobCache.size() > 0);\n  }","commit_id":"0f72da7e281376f4fcbfbf3fb33f5d7fedcdb1aa","url":"https://github.com/apache/hadoop"},{"original_method":"@POST\n  public void handleBatch(HttpRequest request, HttpResponder responder) throws IOException {\n    if (!CONTENT_TYPE_JSON.equals(request.getHeader(HttpHeaders.Names.CONTENT_TYPE))) {\n      responder.sendError(HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE, \"Only \" + CONTENT_TYPE_JSON + \" is supported.\");\n      return;\n    }\n\n    List<MetricsRequest> metricsRequests;\n    try {\n      metricsRequests = decodeRequests(request.getContent());\n    } catch (Throwable t) {\n      responder.sendError(HttpResponseStatus.BAD_REQUEST, \"Invalid request: \" + t.getMessage());\n      return;\n    }\n\n    // Pretty ugly logic now. Need to refactor\n    JsonArray output = new JsonArray();\n    for (MetricsRequest metricsRequest : metricsRequests) {\n      Object resultObj = null;\n      if (metricsRequest.getType() == MetricsRequest.Type.TIME_SERIES) {\n        TimeSeriesResponse.Builder builder = TimeSeriesResponse.builder(metricsRequest.getStartTime(),\n                                                                        metricsRequest.getEndTime());\n        // Busyness is a special case that computes from multiple timeseries.\n        if (\"process.busyness\".equals(metricsRequest.getMetricPrefix())) {\n          MetricsScanQuery scanQuery = new MetricsScanQueryBuilder()\n            .setContext(metricsRequest.getContextPrefix())\n            .setMetric(\"process.tuples.read\")\n            .build(metricsRequest.getStartTime(), metricsRequest.getEndTime());\n\n          PeekingIterator<TimeValue> tuplesReadItor = Iterators.peekingIterator(queryTimeSeries(scanQuery));\n\n          scanQuery = new MetricsScanQueryBuilder()\n            .setContext(metricsRequest.getContextPrefix())\n            .setMetric(\"process.events.processed\")\n            .build(metricsRequest.getStartTime(), metricsRequest.getEndTime());\n\n          PeekingIterator<TimeValue> eventsProcessedItor = Iterators.peekingIterator(queryTimeSeries(scanQuery));\n\n          for (int i = 0; i < metricsRequest.getCount(); i++) {\n            long resultTime = metricsRequest.getStartTime() + i;\n            int tupleRead = 0;\n            int eventProcessed = 0;\n            if (tuplesReadItor.hasNext() && tuplesReadItor.peek().getTime() == resultTime) {\n              tupleRead = tuplesReadItor.next().getValue();\n            }\n            if (eventsProcessedItor.hasNext() && eventsProcessedItor.peek().getTime() == resultTime) {\n              eventProcessed = eventsProcessedItor.next().getValue();\n            }\n            if (eventProcessed != 0) {\n              int busyness = (int) ((float) tupleRead / eventProcessed * 100);\n              builder.addData(resultTime, busyness > 100 ? 100 : busyness);\n            } else {\n              builder.addData(resultTime, 0);\n            }\n          }\n        } else {\n          MetricsScanQuery scanQuery = new MetricsScanQueryBuilder()\n            .setContext(metricsRequest.getContextPrefix())\n            .setMetric(metricsRequest.getMetricPrefix())\n            .setTag(metricsRequest.getTagPrefix())\n            .build(metricsRequest.getStartTime(), metricsRequest.getEndTime());\n\n          PeekingIterator<TimeValue> timeValueItor = Iterators.peekingIterator(queryTimeSeries(scanQuery));\n\n          for (int i = 0; i < metricsRequest.getCount(); i++) {\n            long resultTime = metricsRequest.getStartTime() + i;\n\n            if (timeValueItor.hasNext() && timeValueItor.peek().getTime() == resultTime) {\n              builder.addData(resultTime, timeValueItor.next().getValue());\n              continue;\n            }\n            builder.addData(resultTime, 0);\n          }\n        }\n        resultObj = builder.build();\n\n      } else if (metricsRequest.getType() == MetricsRequest.Type.AGGREGATE) {\n        resultObj = getAggregates(metricsRequest);\n      }\n\n      JsonObject json = new JsonObject();\n      json.addProperty(\"path\", metricsRequest.getRequestURI().toString());\n      json.add(\"result\", GSON.toJsonTree(resultObj));\n      json.add(\"error\", JsonNull.INSTANCE);\n\n      output.add(json);\n    }\n\n    responder.sendJson(HttpResponseStatus.OK, output);\n  }","id":99059,"modified_method":"@POST\n  public void handleBatch(HttpRequest request, HttpResponder responder) throws IOException {\n    if (!CONTENT_TYPE_JSON.equals(request.getHeader(HttpHeaders.Names.CONTENT_TYPE))) {\n      responder.sendError(HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE, \"Only \" + CONTENT_TYPE_JSON + \" is supported.\");\n      return;\n    }\n\n    List<MetricsRequest> metricsRequests;\n    try {\n      metricsRequests = decodeRequests(request.getContent());\n    } catch (Throwable t) {\n      responder.sendError(HttpResponseStatus.BAD_REQUEST, \"Invalid request: \" + t.getMessage());\n      return;\n    }\n\n    // Pretty ugly logic now. Need to refactor\n    JsonArray output = new JsonArray();\n    for (MetricsRequest metricsRequest : metricsRequests) {\n      Object resultObj = null;\n      if (metricsRequest.getType() == MetricsRequest.Type.TIME_SERIES) {\n        TimeSeriesResponse.Builder builder = TimeSeriesResponse.builder(metricsRequest.getStartTime(),\n                                                                        metricsRequest.getEndTime());\n\n        // Special metrics handle that requires computation from multiple time series.\n        if (\"process.busyness\".equals(metricsRequest.getMetricPrefix())) {\n          computeProcessBusyness(metricsRequest, builder);\n        } else {\n          MetricsScanQuery scanQuery = new MetricsScanQueryBuilder()\n            .setContext(metricsRequest.getContextPrefix())\n            .setMetric(metricsRequest.getMetricPrefix())\n            .setTag(metricsRequest.getTagPrefix())\n            .build(metricsRequest.getStartTime(), metricsRequest.getEndTime());\n\n          PeekingIterator<TimeValue> timeValueItor = Iterators.peekingIterator(queryTimeSeries(scanQuery));\n\n          for (int i = 0; i < metricsRequest.getCount(); i++) {\n            long resultTime = metricsRequest.getStartTime() + i;\n\n            if (timeValueItor.hasNext() && timeValueItor.peek().getTime() == resultTime) {\n              builder.addData(resultTime, timeValueItor.next().getValue());\n              continue;\n            }\n            builder.addData(resultTime, 0);\n          }\n        }\n        resultObj = builder.build();\n\n      } else if (metricsRequest.getType() == MetricsRequest.Type.AGGREGATE) {\n        // Special metrics handle that requires computation from multiple aggregates results.\n        if (\"process.events.pending\".equals(metricsRequest.getMetricPrefix())) {\n          resultObj = computeQueueLength(metricsRequest);\n        } else {\n          resultObj = getAggregates(metricsRequest);\n        }\n      }\n\n      JsonObject json = new JsonObject();\n      json.addProperty(\"path\", metricsRequest.getRequestURI().toString());\n      json.add(\"result\", GSON.toJsonTree(resultObj));\n      json.add(\"error\", JsonNull.INSTANCE);\n\n      output.add(json);\n    }\n\n    responder.sendJson(HttpResponseStatus.OK, output);\n  }","commit_id":"230ac710de133b2b7a69036efe4c59815a4c6145","url":"https://github.com/caskdata/cdap"},{"original_method":"private AggregateResponse getAggregates(MetricsRequest request) {\n    AggregatesScanner scanner = aggregatesTable.scan(request.getContextPrefix(), request.getMetricPrefix(),\n                                                     request.getRunId(), request.getTagPrefix());\n    long value = 0;\n    while (scanner.hasNext()) {\n      value += scanner.next().getValue();\n    }\n    return new AggregateResponse(value);\n  }","id":99060,"modified_method":"private AggregateResponse getAggregates(MetricsRequest request) {\n    AggregatesScanner scanner = aggregatesTable.scan(request.getContextPrefix(), request.getMetricPrefix(),\n                                                     request.getRunId(), request.getTagPrefix());\n    return new AggregateResponse(sumAll(scanner));\n  }","commit_id":"230ac710de133b2b7a69036efe4c59815a4c6145","url":"https://github.com/caskdata/cdap"},{"original_method":"private void ackMetric(byte[] queue, QueueConsumer consumer) {\n    if (consumer != null && consumer.getGroupName() != null) {\n      String metricName = getQueueMetricNames(queue).getSecond();\n      getQueueMetric(consumer.getGroupName()).meter(metricName, 1);\n    }\n  }","id":99061,"modified_method":"private void ackMetric(byte[] queue, QueueConsumer consumer, int numEntries) {\n    if (consumer != null && consumer.getGroupName() != null) {\n      String metricName = getQueueMetricNames(queue).getSecond();\n      getQueueMetric(consumer.getGroupName()).gauge(metricName, numEntries);\n    }\n  }","commit_id":"230ac710de133b2b7a69036efe4c59815a4c6145","url":"https://github.com/caskdata/cdap"},{"original_method":"private CMetrics getQueueMetric(String group) {\n    CMetrics metric = queueMetrics.get(group);\n    if (metric == null) {\n      queueMetrics.putIfAbsent(group,\n          new CMetrics(MetricType.FlowSystem, group));\n      metric = queueMetrics.get(group);\n      Log.trace(\"Created new CMetrics for group '\" + group + \"'.\");\n      // System.err.println(\"Created new CMetrics for group '\" + group + \"'.\");\n    }\n    return metric;\n  }","id":99062,"modified_method":"private MetricsCollector getQueueMetric(String group) {\n    return queueMetrics.getUnchecked(group);\n  }","commit_id":"230ac710de133b2b7a69036efe4c59815a4c6145","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void commit(OperationContext context,\n                     Transaction transaction)\n    throws OperationException {\n\n    // attempt to commit in Oracle\n    TransactionResult txResult = commitTransaction(transaction);\n    if (!txResult.isSuccess()) {\n      // make sure to emit the metric for failed commits\n      cmetric.meter(METRIC_PREFIX + \"WriteOperationBatch_FailedCommits\", 1);\n\n      // attempt to undo all the writes of the transaction\n      // (transaction is already marked as invalid in oracle)\n      attemptUndo(context, transaction, txResult.getUndos());\n\n      throw new OmidTransactionException(StatusCode.WRITE_CONFLICT,\n                                         \"Commit of transaction failed, transaction aborted\");\n    }\n    // Commit was successful.\n\n    // TODO this must go away with the new queue implementation\n    // If the transaction did a queue ack, finalize it\n    QueueFinalize finalize = txResult.getFinalize();\n    if (finalize != null) {\n      finalize.execute(queueStateProxy, getQueueTable(finalize.getQueueName()), transaction);\n    }\n\n    // emit metrics for the transaction and the queues/streams involved\n    cmetric.meter(METRIC_PREFIX + \"WriteOperationBatch_SuccessfulTransactions\", 1);\n    // for each queue operation (enqueue or ack)\n    for (Undo undo : txResult.getUndos()) {\n      if (undo instanceof QueueUndo.QueueUnenqueue) {\n        QueueUndo.QueueUnenqueue unenqueue = (QueueUndo.QueueUnenqueue) undo;\n        QueueProducer producer = unenqueue.producer;\n        enqueueMetric(unenqueue.queueName, producer);\n        if (isStream(unenqueue.queueName)) {\n          streamMetric(unenqueue.queueName, unenqueue.sumOfSizes, unenqueue.numEntries());\n        }\n      } else if (undo instanceof QueueUndo.QueueUnack) {\n        QueueUndo.QueueUnack unack = (QueueUndo.QueueUnack) undo;\n        QueueConsumer consumer = unack.consumer;\n        ackMetric(unack.queueName, consumer);\n      }\n    }\n    // done\n  }","id":99063,"modified_method":"@Override\n  public void commit(OperationContext context,\n                     Transaction transaction)\n    throws OperationException {\n\n    // attempt to commit in Oracle\n    TransactionResult txResult = commitTransaction(transaction);\n    if (!txResult.isSuccess()) {\n      // make sure to emit the metric for failed commits\n      cmetric.meter(METRIC_PREFIX + \"WriteOperationBatch_FailedCommits\", 1);\n\n      // attempt to undo all the writes of the transaction\n      // (transaction is already marked as invalid in oracle)\n      attemptUndo(context, transaction, txResult.getUndos());\n\n      throw new OmidTransactionException(StatusCode.WRITE_CONFLICT,\n                                         \"Commit of transaction failed, transaction aborted\");\n    }\n    // Commit was successful.\n\n    // TODO this must go away with the new queue implementation\n    // If the transaction did a queue ack, finalize it\n    QueueFinalize finalize = txResult.getFinalize();\n    if (finalize != null) {\n      finalize.execute(queueStateProxy, getQueueTable(finalize.getQueueName()), transaction);\n    }\n\n    // emit metrics for the transaction and the queues/streams involved\n    cmetric.meter(METRIC_PREFIX + \"WriteOperationBatch_SuccessfulTransactions\", 1);\n    // for each queue operation (enqueue or ack)\n    for (Undo undo : txResult.getUndos()) {\n      if (undo instanceof QueueUndo.QueueUnenqueue) {\n        QueueUndo.QueueUnenqueue unenqueue = (QueueUndo.QueueUnenqueue) undo;\n        QueueProducer producer = unenqueue.producer;\n        enqueueMetric(unenqueue.queueName, producer, unenqueue.numEntries());\n        if (isStream(unenqueue.queueName)) {\n          streamMetric(unenqueue.queueName, unenqueue.sumOfSizes, unenqueue.numEntries());\n        }\n      } else if (undo instanceof QueueUndo.QueueUnack) {\n        QueueUndo.QueueUnack unack = (QueueUndo.QueueUnack) undo;\n        QueueConsumer consumer = unack.consumer;\n        ackMetric(unack.queueName, consumer, unack.numEntries());\n      }\n    }\n    // done\n  }","commit_id":"230ac710de133b2b7a69036efe4c59815a4c6145","url":"https://github.com/caskdata/cdap"},{"original_method":"private ImmutablePair<String, String> getQueueMetricNames(byte[] queue) {\n    ImmutablePair<String, String> names = queueMetricNames.get(queue);\n    if (names == null) {\n      String name = new String(queue).replace(\":\", \"\");\n      queueMetricNames.putIfAbsent(queue, new ImmutablePair<String, String>\n          (\"q.enqueue.\" + name, \"q.ack.\" + name));\n      names = queueMetricNames.get(queue);\n      Log.trace(\"using metric name '\" + names.getFirst() + \"' and '\"\n          + names.getSecond() + \"' for queue '\" + new String(queue) + \"'\");\n      //System.err.println(\"using metric name '\" + names.getFirst() + \"' and '\"\n      //    + names.getSecond() + \"' for queue '\" + new String(queue) + \"'\");\n    }\n    return names;\n  }","id":99064,"modified_method":"private ImmutablePair<String, String> getQueueMetricNames(byte[] queue) {\n    ImmutablePair<String, String> names = queueMetricNames.get(queue);\n    if (names == null) {\n      String name = Bytes.toString(queue);\n      queueMetricNames.putIfAbsent(queue, new ImmutablePair<String, String>\n          (\"q.enqueue.\" + name, \"q.ack.\" + name));\n      names = queueMetricNames.get(queue);\n      Log.trace(\"using metric name '{}' and '{}' for queue '{}'\",\n                names.getFirst(), names.getSecond(), new String(queue));\n    }\n    return names;\n  }","commit_id":"230ac710de133b2b7a69036efe4c59815a4c6145","url":"https://github.com/caskdata/cdap"},{"original_method":"private void enqueueMetric(byte[] queue, QueueProducer producer) {\n    if (producer != null && producer.getProducerName() != null) {\n      String metricName = getQueueMetricNames(queue).getFirst();\n      getQueueMetric(producer.getProducerName()).meter(metricName, 1);\n    }\n  }","id":99065,"modified_method":"private void enqueueMetric(byte[] queue, QueueProducer producer, int numEntries) {\n    String metricName = getQueueMetricNames(queue).getFirst();\n    if (producer != null && producer.getProducerName() != null) {\n      getQueueMetric(producer.getProducerName()).gauge(metricName, numEntries);\n    } else {\n      // Assume it is stream if prodcuer is null. This is a bit hacky, but this is temporary as opex and metrics\n      // would works differently when rewrite of data-fabric is done.\n      getQueueMetric(STREAM_CONTEXT).gauge(metricName, numEntries);\n    }\n  }","commit_id":"230ac710de133b2b7a69036efe4c59815a4c6145","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject(optional = true)\n  void setMetricsCollectionService(MetricsCollectionService metricsCollectionService) {\n    this.streamMetrics = metricsCollectionService.getCollector(MetricsScope.REACTOR, \"-.stream\", \"0\");\n    this.dataSetMetrics = metricsCollectionService.getCollector(MetricsScope.REACTOR, \"-.dataset\", \"0\");\n  }","id":99066,"modified_method":"@Inject(optional = true)\n  void setMetricsCollectionService(MetricsCollectionService metricsCollectionService) {\n    this.metricsCollectionService = metricsCollectionService;\n    this.streamMetrics = metricsCollectionService.getCollector(MetricsScope.REACTOR, STREAM_CONTEXT, \"0\");\n    this.dataSetMetrics = metricsCollectionService.getCollector(MetricsScope.REACTOR, DATASET_CONTEXT, \"0\");\n  }","commit_id":"230ac710de133b2b7a69036efe4c59815a4c6145","url":"https://github.com/caskdata/cdap"},{"original_method":"public static String scheduleStatus(AppFabricHttpHandler httpHandler, String appId, String wflowId,\n                             String schedId) {\n    MockResponder responder = new MockResponder();\n    String uri = String.format(\"/v2/apps/%s/workflows/%s/schedules/%s/status\", appId, wflowId, schedId);\n    HttpRequest request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, uri);\n    httpHandler.getScheuleState(request, responder, appId, wflowId, schedId);\n    Preconditions.checkArgument(responder.getStatus().getCode() == 200, \" getting workflow schedules failed\");\n    Map<String, String> json = GSON.fromJson(responder.getResponseContent().toString(),\n                                             new TypeToken<Map<String, String>>() { }.getType());\n    return json.get(\"status\");\n  }","id":99067,"modified_method":"public static String scheduleStatus(AppFabricHttpHandler httpHandler, String appId, String wflowId,\n                             String schedId) {\n    MockResponder responder = new MockResponder();\n    String uri = String.format(\"/v2/apps/%s/workflows/%s/schedules/%s/status\", appId, wflowId, schedId);\n    HttpRequest request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, uri);\n    httpHandler.getScheuleState(request, responder, appId, wflowId, schedId);\n    Preconditions.checkArgument(responder.getStatus().getCode() == 200, \" getting workflow schedules failed\");\n    JsonReader jsonReader = new JsonReader(new InputStreamReader\n                                             (new ChannelBufferInputStream(ChannelBuffers.wrappedBuffer\n                                               (responder.getResponseContent())), Charsets.UTF_8));\n    Map<String, String> json = GSON.fromJson(jsonReader,\n                                             new TypeToken<Map<String, String>>() { }.getType());\n    return json.get(\"status\");\n  }","commit_id":"08803dbcd4319295fba9e7a53ee80b299f03ec18","url":"https://github.com/caskdata/cdap"},{"original_method":"public static List<String> getSchedules(AppFabricHttpHandler httpHandler, String appId, String wflowId) {\n    MockResponder responder = new MockResponder();\n    String uri = String.format(\"/v2/apps/%s/workflows/%s/schedules\", appId, wflowId);\n    HttpRequest request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, uri);\n    httpHandler.workflowSchedules(request, responder, appId, wflowId);\n    List<String> schedules = (List<String>) responder.getResponseContent();\n    Preconditions.checkArgument(responder.getStatus().getCode() == 200, \" getting workflow schedules failed\");\n    return schedules;\n  }","id":99068,"modified_method":"public static List<String> getSchedules(AppFabricHttpHandler httpHandler, String appId, String wflowId) {\n    MockResponder responder = new MockResponder();\n    String uri = String.format(\"/v2/apps/%s/workflows/%s/schedules\", appId, wflowId);\n    HttpRequest request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, uri);\n    httpHandler.workflowSchedules(request, responder, appId, wflowId);\n    JsonReader jsonReader = new JsonReader(new InputStreamReader\n                                             (new ChannelBufferInputStream(ChannelBuffers.wrappedBuffer\n                                               (responder.getResponseContent())), Charsets.UTF_8));\n    List<String> schedules = GSON.fromJson(jsonReader,\n                                             new TypeToken<List<String>>() { }.getType());\n    Preconditions.checkArgument(responder.getStatus().getCode() == 200, \" getting workflow schedules failed\");\n    return schedules;\n  }","commit_id":"08803dbcd4319295fba9e7a53ee80b299f03ec18","url":"https://github.com/caskdata/cdap"},{"original_method":"public static synchronized Injector getInjector(CConfiguration conf) {\n    if (injector == null) {\n      configuration = conf;\n      configuration.set(Constants.CFG_LOCAL_DATA_DIR, TEMP_FOLDER.newFolder(\"data\").getAbsolutePath());\n      configuration.set(Constants.AppFabric.OUTPUT_DIR, TEMP_FOLDER.newFolder(\"app\").getAbsolutePath());\n      configuration.set(Constants.AppFabric.TEMP_DIR, TEMP_FOLDER.newFolder(\"temp\").getAbsolutePath());\n      configuration.set(Constants.AppFabric.REST_PORT, Integer.toString(Networks.getRandomPort()));\n      configuration.set(Constants.AppFabric.SERVER_PORT, Integer.toString(Networks.getRandomPort()));\n      configuration.setBoolean(Constants.Dangerous.UNRECOVERABLE_RESET, true);\n      injector = Guice.createInjector(new AppFabricTestModule(configuration));\n      injector.getInstance(InMemoryTransactionManager.class).startAndWait();\n\n      LogAppenderInitializer logAppenderInitializer = injector.getInstance(LogAppenderInitializer.class);\n      logAppenderInitializer.initialize();\n    }\n    return injector;\n  }","id":99069,"modified_method":"public static synchronized Injector getInjector(CConfiguration conf) {\n    if (injector == null) {\n      configuration = conf;\n      configuration.set(Constants.CFG_LOCAL_DATA_DIR, TEMP_FOLDER.newFolder(\"data\").getAbsolutePath());\n      configuration.set(Constants.AppFabric.OUTPUT_DIR, TEMP_FOLDER.newFolder(\"app\").getAbsolutePath());\n      configuration.set(Constants.AppFabric.TEMP_DIR, TEMP_FOLDER.newFolder(\"temp\").getAbsolutePath());\n      configuration.set(Constants.AppFabric.REST_PORT, Integer.toString(Networks.getRandomPort()));\n      configuration.set(Constants.AppFabric.SERVER_PORT, Integer.toString(Networks.getRandomPort()));\n      configuration.setBoolean(Constants.Dangerous.UNRECOVERABLE_RESET, true);\n      injector = Guice.createInjector(new AppFabricTestModule(configuration));\n      injector.getInstance(InMemoryTransactionManager.class).startAndWait();\n      injector.getInstance(SchedulerService.class).startAndWait();\n\n      LogAppenderInitializer logAppenderInitializer = injector.getInstance(LogAppenderInitializer.class);\n      logAppenderInitializer.initialize();\n    }\n    return injector;\n  }","commit_id":"08803dbcd4319295fba9e7a53ee80b299f03ec18","url":"https://github.com/caskdata/cdap"},{"original_method":"public static List<RunRecord> getHistory(AppFabricHttpHandler httpHandler, String appId, String wflowId) {\n    MockResponder responder = new MockResponder();\n    String uri = String.format(\"/v2/apps/%s/workflows/%s/history\", appId, wflowId);\n    HttpRequest request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, uri);\n    httpHandler.runnableHistory(request, responder, appId, \"workflows\", wflowId);\n    Preconditions.checkArgument(responder.getStatus().getCode() == 200, \" getting workflow schedules failed\");\n    List<Map<String, String>> runList = new Gson().fromJson(responder.getResponseContent().toString(),\n                               new TypeToken<List<Map<String, String>>>() { }.getType());\n    List<RunRecord> runRecords = Lists.newArrayList();\n    for (Map<String, String> run : runList) {\n      runRecords.add(new RunRecord(run.get(\"runid\"), Long.parseLong(run.get(\"start\")),\n                                       Long.parseLong(run.get(\"end\")), run.get(\"status\")));\n    }\n    return runRecords;\n  }","id":99070,"modified_method":"public static List<RunRecord> getHistory(AppFabricHttpHandler httpHandler, String appId, String wflowId) {\n    MockResponder responder = new MockResponder();\n    String uri = String.format(\"/v2/apps/%s/workflows/%s/history\", appId, wflowId);\n    HttpRequest request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, uri);\n    httpHandler.runnableHistory(request, responder, appId, \"workflows\", wflowId);\n    Preconditions.checkArgument(responder.getStatus().getCode() == 200, \" getting workflow schedules failed\");\n    JsonReader jsonReader = new JsonReader(new InputStreamReader\n                                             (new ChannelBufferInputStream(ChannelBuffers.wrappedBuffer\n                                               (responder.getResponseContent())), Charsets.UTF_8));\n    List<Map<String, String>> runList = GSON.fromJson(jsonReader,\n                                         new TypeToken<List<Map<String, String>>>() { }.getType());\n\n    List<RunRecord> runRecords = Lists.newArrayList();\n    for (Map<String, String> run : runList) {\n      runRecords.add(new RunRecord(run.get(\"runid\"), Long.parseLong(run.get(\"start\")),\n                                       Long.parseLong(run.get(\"end\")), run.get(\"status\")));\n    }\n    return runRecords;\n  }","commit_id":"08803dbcd4319295fba9e7a53ee80b299f03ec18","url":"https://github.com/caskdata/cdap"},{"original_method":"public static String getStatus(AppFabricHttpHandler httpHandler, String appId, String flowId,\n                                 String type) {\n\n    MockResponder responder = new MockResponder();\n    String uri = String.format(\"/v2/apps/%s/%s/%s/stop\", appId, type, flowId);\n    HttpRequest request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, uri);\n    httpHandler.getStatus(request, responder, appId, type, flowId);\n    Preconditions.checkArgument(responder.getStatus().getCode() == 200, \"stop\" + \" \" + type + \"failed\");\n    Map<String, String> json = GSON.fromJson(responder.getResponseContent().toString(),\n                                             new TypeToken<Map<String, String>>() { }.getType());\n    return json.get(\"status\");\n  }","id":99071,"modified_method":"public static String getStatus(AppFabricHttpHandler httpHandler, String appId, String flowId,\n                                 String type) {\n\n    MockResponder responder = new MockResponder();\n    String uri = String.format(\"/v2/apps/%s/%s/%s/status\", appId, type, flowId);\n    HttpRequest request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, uri);\n    httpHandler.getStatus(request, responder, appId, type, flowId);\n    Preconditions.checkArgument(responder.getStatus().getCode() == 200, \"get status\" + \" \" + type + \"failed\");\n    JsonReader jsonReader = new JsonReader(new InputStreamReader\n                                          (new ChannelBufferInputStream(ChannelBuffers.wrappedBuffer\n                                          (responder.getResponseContent())), Charsets.UTF_8));\n    Map<String, String> json = GSON.fromJson(jsonReader,\n                                             new TypeToken<Map<String, String>>() { }.getType());\n    return json.get(\"status\");\n  }","commit_id":"08803dbcd4319295fba9e7a53ee80b299f03ec18","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void sendByteArray(HttpResponseStatus status, byte[] bytes, Multimap<String, String> headers) {\n    this.status = status;\n  }","id":99072,"modified_method":"@Override\n  public void sendByteArray(HttpResponseStatus status, byte[] bytes, Multimap<String, String> headers) {\n    ChannelBuffer channelBuffer = ChannelBuffers.wrappedBuffer(bytes);\n    sendContent(status, channelBuffer, \"application/octet-stream\", headers);\n  }","commit_id":"08803dbcd4319295fba9e7a53ee80b299f03ec18","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void sendJson(HttpResponseStatus status, Object object, Type type, Gson gson) {\n    this.status = status;\n    this.content = object;\n  }","id":99073,"modified_method":"@Override\n  public void sendJson(HttpResponseStatus status, Object object, Type type, Gson gson) {\n    try {\n      ChannelBuffer channelBuffer = ChannelBuffers.dynamicBuffer();\n      JsonWriter jsonWriter = new JsonWriter(new OutputStreamWriter(new ChannelBufferOutputStream(channelBuffer),\n                                                                    Charsets.UTF_8));\n      try {\n        gson.toJson(object, type, jsonWriter);\n      } finally {\n        jsonWriter.close();\n      }\n\n      sendContent(status, channelBuffer, \"application/json\", ImmutableMultimap.<String, String>of());\n    } catch (IOException e) {\n      throw Throwables.propagate(e);\n    }\n  }","commit_id":"08803dbcd4319295fba9e7a53ee80b299f03ec18","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void sendContent(HttpResponseStatus status,\n                          ChannelBuffer content, String contentType, Multimap<String, String> headers) {\n    this.status = status;\n  }","id":99074,"modified_method":"@Override\n  public void sendContent(HttpResponseStatus status,\n                          ChannelBuffer content, String contentType, Multimap<String, String> headers) {\n    if (content != null) {\n      this.content = content.array();\n    }\n    this.status = status;\n  }","commit_id":"08803dbcd4319295fba9e7a53ee80b299f03ec18","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void sendStatus(HttpResponseStatus status) {\n    this.status = status;\n  }","id":99075,"modified_method":"@Override\n  public void sendStatus(HttpResponseStatus status) {\n    sendContent(status, null, null, ImmutableMultimap.<String, String>of());\n  }","commit_id":"08803dbcd4319295fba9e7a53ee80b299f03ec18","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void sendStatus(HttpResponseStatus status, Multimap<String, String> headers) {\n    this.status = status;\n  }","id":99076,"modified_method":"@Override\n  public void sendStatus(HttpResponseStatus status, Multimap<String, String> headers) {\n    sendContent(status, null, null, headers);\n  }","commit_id":"08803dbcd4319295fba9e7a53ee80b299f03ec18","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void sendJson(HttpResponseStatus status, Object object, Type type) {\n    sendJson(status, object, type, null);\n  }","id":99077,"modified_method":"@Override\n  public void sendJson(HttpResponseStatus status, Object object, Type type) {\n    sendJson(status, object, type, gson.get());\n  }","commit_id":"08803dbcd4319295fba9e7a53ee80b299f03ec18","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void sendError(HttpResponseStatus status, String errorMessage) {\n    this.status = status;\n  }","id":99078,"modified_method":"@Override\n  public void sendError(HttpResponseStatus status, String errorMessage) {\n    Preconditions.checkArgument(!status.equals(HttpResponseStatus.OK), \"Response status cannot be OK for errors\");\n\n    ChannelBuffer errorContent = ChannelBuffers.wrappedBuffer(Charsets.UTF_8.encode(errorMessage));\n    sendContent(status, errorContent, \"text/plain; charset=utf-8\", ImmutableMultimap.<String, String>of());\n  }","commit_id":"08803dbcd4319295fba9e7a53ee80b299f03ec18","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void sendBytes(HttpResponseStatus status, ByteBuffer buffer, Multimap<String, String> headers) {\n    this.status = status;\n  }","id":99079,"modified_method":"@Override\n  public void sendBytes(HttpResponseStatus status, ByteBuffer buffer, Multimap<String, String> headers) {\n    sendContent(status, ChannelBuffers.wrappedBuffer(buffer), \"application/octet-stream\", headers);\n  }","commit_id":"08803dbcd4319295fba9e7a53ee80b299f03ec18","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void sendJson(HttpResponseStatus status, Object object) {\n    sendJson(status, object, null, null);\n  }","id":99080,"modified_method":"@Override\n  public void sendJson(HttpResponseStatus status, Object object) {\n    sendJson(status, object, object.getClass());\n  }","commit_id":"08803dbcd4319295fba9e7a53ee80b299f03ec18","url":"https://github.com/caskdata/cdap"},{"original_method":"private static <T> T findPusherValuesUpwards(final Project project, final VirtualFile dir, FilePropertyPusher<T> pusher, T moduleValue) {\n    final T value = pusher.getImmediateValue(project, dir);\n    if (value != null) return value;\n    if (moduleValue != null) return moduleValue;\n    final VirtualFile parent = dir.getParent();\n    if (parent != null) return findPusherValuesUpwards(project, parent, pusher);\n    return pusher.getDefaultValue();\n  }","id":99081,"modified_method":"private static <T> T findPusherValuesUpwards(Project project, VirtualFile dir, FilePropertyPusher<T> pusher, T moduleValue) {\n    final T value = pusher.getImmediateValue(project, dir);\n    if (value != null) return value;\n    if (moduleValue != null) return moduleValue;\n    final VirtualFile parent = dir.getParent();\n    if (parent != null) return findPusherValuesUpwards(project, parent, pusher);\n    T projectValue = pusher.getImmediateValue(project, null);\n    return projectValue != null? projectValue : pusher.getDefaultValue();\n  }","commit_id":"7e625e47cb2c80f9aaf849ee75e6e8e5a7bcb6c1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static <T> T findPusherValuesUpwards(final Project project, final VirtualFile dir, FilePropertyPusher<T> pusher) {\n    final T userValue = dir.getUserData(pusher.getFileDataKey());\n    if (userValue != null) return userValue;\n    final T value = pusher.getImmediateValue(project, dir);\n    if (value != null) return value;\n    final VirtualFile parent = dir.getParent();\n    if (parent != null) return findPusherValuesUpwards(project, parent, pusher);\n    return pusher.getDefaultValue();\n  }","id":99082,"modified_method":"private static <T> T findPusherValuesUpwards(Project project, VirtualFile dir, FilePropertyPusher<T> pusher) {\n    final T userValue = dir.getUserData(pusher.getFileDataKey());\n    if (userValue != null) return userValue;\n    final T value = pusher.getImmediateValue(project, dir);\n    if (value != null) return value;\n    final VirtualFile parent = dir.getParent();\n    if (parent != null) return findPusherValuesUpwards(project, parent, pusher);\n    T projectValue = pusher.getImmediateValue(project, null);\n    return projectValue != null ? projectValue : pusher.getDefaultValue();\n  }","commit_id":"7e625e47cb2c80f9aaf849ee75e6e8e5a7bcb6c1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testMulticastingRouterSync() throws Exception\n    {\n        Mock session = MuleTestUtils.getMockSession();\n        session.matchAndReturn(\"getService\", getTestService());\n\n        ImmutableEndpoint endpoint1 = getTestOutboundEndpoint(\"Test1Provider\", \"test://Test1Provider?synchronous=true\");\n        assertNotNull(endpoint1);\n\n        ImmutableEndpoint endpoint2 = getTestOutboundEndpoint(\"Test2Provider\", \"test://Test2Provider?synchronous=true\");\n        assertNotNull(endpoint2);\n\n        MulticastingRouter router = new MulticastingRouter();\n        RegExFilter filter = new RegExFilter(\"(.*) event\");\n        router.setFilter(filter);\n        List endpoints = new ArrayList();\n        endpoints.add(endpoint1);\n        endpoints.add(endpoint2);\n        router.setEndpoints(endpoints);\n\n        assertEquals(filter, router.getFilter());\n\n        MuleMessage message = new DefaultMuleMessage(\"test event\");\n\n        assertTrue(router.isMatch(message));\n\n        session.expectAndReturn(\"sendEvent\", C.eq(message, endpoint1), message);\n        session.expectAndReturn(\"sendEvent\", C.eq(message, endpoint2), message);\n        MuleMessage result = router.route(message, (MuleSession)session.proxy());\n        assertNotNull(result);\n        assertTrue(result instanceof MuleMessageCollection);\n        assertEquals(2, ((MuleMessageCollection)result).size());\n        session.verify();\n    }","id":99083,"modified_method":"public void testMulticastingRouterSync() throws Exception\n    {\n        Mock session = MuleTestUtils.getMockSession();\n        session.matchAndReturn(\"getService\", getTestService());\n\n        ImmutableEndpoint endpoint1 = getTestOutboundEndpoint(\"Test1Provider\", \"test://Test1Provider?synchronous=true\");\n        assertNotNull(endpoint1);\n\n        ImmutableEndpoint endpoint2 = getTestOutboundEndpoint(\"Test2Provider\", \"test://Test2Provider?synchronous=true\");\n        assertNotNull(endpoint2);\n\n        MulticastingRouter router = new MulticastingRouter();\n        RegExFilter filter = new RegExFilter(\"(.*) event\");\n        router.setFilter(filter);\n        List endpoints = new ArrayList();\n        endpoints.add(endpoint1);\n        endpoints.add(endpoint2);\n        router.setEndpoints(endpoints);\n\n        assertEquals(filter, router.getFilter());\n\n        MuleMessage message = new DefaultMuleMessage(\"test event\");\n\n        assertTrue(router.isMatch(message));\n\n        session.expectAndReturn(\"sendEvent\",  C.args(C.isA(MuleMessage.class), C.eq(endpoint1)), message);\n        session.expectAndReturn(\"sendEvent\", C.args(C.isA(MuleMessage.class), C.eq(endpoint2)), message);\n        MuleMessage result = router.route(message, (MuleSession)session.proxy());\n        assertNotNull(result);\n        assertTrue(result instanceof MuleMessageCollection);\n        assertEquals(2, ((MuleMessageCollection)result).size());\n        session.verify();\n    }","commit_id":"557d154c90910666d272c61ee5c5901f7c35ef6f","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testMulticastingRouterMixedSyncAsync() throws Exception\n    {\n        Mock session = MuleTestUtils.getMockSession();\n        session.matchAndReturn(\"getService\", getTestService());\n\n        ImmutableEndpoint endpoint1 = getTestOutboundEndpoint(\"Test1Provider\", \"test://Test1Provider?synchronous=true\");\n        assertNotNull(endpoint1);\n\n        ImmutableEndpoint endpoint2 = getTestOutboundEndpoint(\"Test2Provider\", \"test://Test2Provider?synchronous=false\");\n        assertNotNull(endpoint2);\n\n        MulticastingRouter router = new MulticastingRouter();\n        RegExFilter filter = new RegExFilter(\"(.*) event\");\n        router.setFilter(filter);\n        List endpoints = new ArrayList();\n        endpoints.add(endpoint1);\n        endpoints.add(endpoint2);\n        router.setEndpoints(endpoints);\n\n        assertEquals(filter, router.getFilter());\n\n        MuleMessage message = new DefaultMuleMessage(\"test event\");\n\n        assertTrue(router.isMatch(message));\n\n        session.expectAndReturn(\"sendEvent\", C.eq(message, endpoint1), message);\n        session.expectAndReturn(\"dispatchEvent\", C.eq(message, endpoint2), message);\n        MuleMessage result = router.route(message, (MuleSession)session.proxy());\n        assertNotNull(result);\n        assertEquals(message, result);\n        session.verify();\n    }","id":99084,"modified_method":"public void testMulticastingRouterMixedSyncAsync() throws Exception\n    {\n        Mock session = MuleTestUtils.getMockSession();\n        session.matchAndReturn(\"getService\", getTestService());\n\n        ImmutableEndpoint endpoint1 = getTestOutboundEndpoint(\"Test1Provider\", \"test://Test1Provider?synchronous=true\");\n        assertNotNull(endpoint1);\n\n        ImmutableEndpoint endpoint2 = getTestOutboundEndpoint(\"Test2Provider\", \"test://Test2Provider?synchronous=false\");\n        assertNotNull(endpoint2);\n\n        MulticastingRouter router = new MulticastingRouter();\n        RegExFilter filter = new RegExFilter(\"(.*) event\");\n        router.setFilter(filter);\n        List endpoints = new ArrayList();\n        endpoints.add(endpoint1);\n        endpoints.add(endpoint2);\n        router.setEndpoints(endpoints);\n\n        assertEquals(filter, router.getFilter());\n\n        MuleMessage message = new DefaultMuleMessage(\"test event\");\n\n        assertTrue(router.isMatch(message));\n\n        session.expectAndReturn(\"sendEvent\",  C.args(C.isA(MuleMessage.class), C.eq(endpoint1)), message);\n        session.expectAndReturn(\"dispatchEvent\", C.eq(message, endpoint2), message);\n        MuleMessage result = router.route(message, (MuleSession)session.proxy());\n        assertNotNull(result);\n        assertEquals(message, result);\n        session.verify();\n    }","commit_id":"557d154c90910666d272c61ee5c5901f7c35ef6f","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    EventData eventData = collectData(e);\n    if (eventData != null) {\n      openInBrowser(eventData.getProject(), eventData.getRepository(), eventData.getCommit().getId().asString());\n    }\n  }","id":99085,"modified_method":"@Override\n  public void actionPerformed(@NotNull AnActionEvent e) {\n    Project project = e.getRequiredData(CommonDataKeys.PROJECT);\n    VcsFullCommitDetails commit = e.getRequiredData(VcsLogDataKeys.VCS_LOG).getSelectedDetails().get(0);\n    GitRepository repository = GitUtil.getRepositoryManager(project).getRepositoryForRoot(commit.getRoot());\n    openInBrowser(project, repository, commit.getId().asString());\n  }","commit_id":"fe7f67dbf3340d8fc9c3f92a108ec6715dc60a63","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void update(AnActionEvent e) {\n    EventData eventData = collectData(e);\n    e.getPresentation().setVisible(eventData != null && GithubUtil.isRepositoryOnGitHub(eventData.getRepository()));\n    e.getPresentation().setEnabled(eventData != null);\n  }","id":99086,"modified_method":"@Override\n  public void update(@NotNull AnActionEvent e) {\n    Project project = e.getData(CommonDataKeys.PROJECT);\n    VcsLog log = e.getData(VcsLogDataKeys.VCS_LOG);\n    if (project == null || log == null) {\n      e.getPresentation().setEnabledAndVisible(false);\n      return;\n    }\n    List<VcsFullCommitDetails> commits = log.getSelectedDetails();\n    if (commits.size() != 1) {\n      e.getPresentation().setEnabledAndVisible(false);\n      return;\n    }\n    GitRepository repository = GitUtil.getRepositoryManager(project).getRepositoryForRoot(commits.get(0).getRoot());\n    e.getPresentation().setEnabledAndVisible(repository != null && GithubUtil.isRepositoryOnGitHub(repository));\n  }","commit_id":"fe7f67dbf3340d8fc9c3f92a108ec6715dc60a63","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void update(AnActionEvent e) {\n    final XDebuggerManager debuggerManager = XDebuggerManager.getInstance(getEventProject(e));\n    final XDebugSession currentSession = debuggerManager.getCurrentSession();\n    if (currentSession != null) {\n      final XDebugProcess process = currentSession.getDebugProcess();\n      e.getPresentation().setVisible(process instanceof JavaDebugProcess);\n      e.getPresentation().setEnabled(process instanceof JavaDebugProcess);\n      e.getPresentation().setText(ActionsBundle.actionText(DebuggerActions.CUSTOMIZE_VIEWS));\n    }\n  }","id":99087,"modified_method":"@Override\n  public void update(AnActionEvent e) {\n    e.getPresentation().setText(ActionsBundle.actionText(DebuggerActions.CUSTOMIZE_VIEWS));\n    Project project = getEventProject(e);\n    if (project != null) {\n      final XDebugSession currentSession = XDebuggerManager.getInstance(project).getCurrentSession();\n      if (currentSession != null) {\n        e.getPresentation().setEnabledAndVisible(currentSession.getDebugProcess() instanceof JavaDebugProcess);\n        return;\n      }\n    }\n    e.getPresentation().setEnabledAndVisible(false);\n  }","commit_id":"b7f553c54d9f492ca9f8493f160288c3689073c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(final AnActionEvent event) {\n    final Project project = event.getProject();\n    if (project == null) {\n      return;\n    }\n\n    PsiDocumentManager.getInstance(project).commitAllDocuments();\n    final Editor editor = event.getData(CommonDataKeys.EDITOR);\n\n    if (editor != null) {\n      runDartStyleOverEditor(project, editor);\n    }\n  }","id":99088,"modified_method":"@Override\n  public void actionPerformed(final AnActionEvent event) {\n    final Project project = event.getProject();\n    if (project == null) {\n      return;\n    }\n\n    PsiDocumentManager.getInstance(project).commitAllDocuments();\n    final Editor editor = event.getData(CommonDataKeys.EDITOR);\n\n    if (editor != null) {\n      runDartStyleOverEditor(project, editor);\n    }\n    else {\n      final VirtualFile[] files = CommonDataKeys.VIRTUAL_FILE_ARRAY.getData(event.getDataContext());\n      final List<VirtualFile> vFiles = getApplicableVirtualFiles(project, files);\n      runDartStyleOverVirtualFiles(project, vFiles);\n    }\n  }","commit_id":"56a77abaf961d0f54e20d1b57738ebea887068a0","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static void runDartStyleOverEditor(@NotNull final Project project, @NotNull final Editor editor) {\n    final PsiFile psiFile = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n    if (!isApplicableFile(psiFile)) return;\n\n    final Document document = editor.getDocument();\n    if (!ReadonlyStatusHandler.ensureDocumentWritable(project, document)) return;\n\n    final DartSdk sdk = DartSdk.getDartSdk(project);\n    if (sdk == null || !DartAnalysisServerService.getInstance().serverReadyForRequest(project, sdk)) return;\n\n    final Runnable runnable = new Runnable() {\n      public void run() {\n        final String path = FileUtil.toSystemDependentName(psiFile.getVirtualFile().getPath());\n        int caretOffset = editor.getCaretModel().getOffset();\n\n        DartAnalysisServerService.getInstance().updateFilesContent();\n        DartAnalysisServerService.FormatResult formatResult =\n          DartAnalysisServerService.getInstance().edit_format(path, caretOffset, 0);\n\n        if (formatResult == null) {\n          showHintLater(editor, DartBundle.message(\"dart.style.failed\"), true);\n          LOG.warn(\"Unexpected response from edit_format, formatResult is null\");\n          return;\n        }\n\n        final List<SourceEdit> edits = formatResult.getEdits();\n        if (edits == null || edits.size() == 0) {\n          showHintLater(editor, DartBundle.message(\"dart.style.already.good\"), false);\n        }\n        else if (edits.size() == 1) {\n          document.replaceString(0, document.getTextLength(), edits.get(0).getReplacement());\n          editor.getCaretModel().moveToOffset(formatResult.getOffset());\n          showHintLater(editor, DartBundle.message(\"dart.style.success\"), false);\n        }\n        else {\n          showHintLater(editor, DartBundle.message(\"dart.style.failed\"), true);\n          LOG.warn(\"Unexpected response from edit_format, formatResult.getEdits().size() = \" + edits.size());\n        }\n      }\n    };\n\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        CommandProcessor.getInstance().executeCommand(project, runnable, DartBundle.message(\"dart.style.action.name\"), null);\n      }\n    });\n  }","id":99089,"modified_method":"private static void runDartStyleOverEditor(@NotNull final Project project, @NotNull final Editor editor) {\n    final PsiFile psiFile = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n    if (!isApplicableFile(psiFile)) return;\n\n    final Document document = editor.getDocument();\n    if (!ReadonlyStatusHandler.ensureDocumentWritable(project, document)) return;\n\n    final DartSdk sdk = DartSdk.getDartSdk(project);\n    if (sdk == null || !DartAnalysisServerService.getInstance().serverReadyForRequest(project, sdk)) return;\n\n    final Runnable runnable = new Runnable() {\n      public void run() {\n        final String path = FileUtil.toSystemDependentName(psiFile.getVirtualFile().getPath());\n        int caretOffset = editor.getCaretModel().getOffset();\n\n        DartAnalysisServerService.getInstance().updateFilesContent();\n        DartAnalysisServerService.FormatResult formatResult =\n          DartAnalysisServerService.getInstance().edit_format(path, caretOffset, 0);\n\n        if (formatResult == null) {\n          showHintLater(editor, DartBundle.message(\"dart.style.hint.failed\"), true);\n          LOG.warn(\"Unexpected response from edit_format, formatResult is null\");\n          return;\n        }\n\n        final List<SourceEdit> edits = formatResult.getEdits();\n        if (edits == null || edits.size() == 0) {\n          showHintLater(editor, DartBundle.message(\"dart.style.hint.already.good\"), false);\n        }\n        else if (edits.size() == 1) {\n          document.replaceString(0, document.getTextLength(), edits.get(0).getReplacement());\n          editor.getCaretModel().moveToOffset(formatResult.getOffset());\n          showHintLater(editor, DartBundle.message(\"dart.style.hint.success\"), false);\n        }\n        else {\n          showHintLater(editor, DartBundle.message(\"dart.style.hint.failed\"), true);\n          LOG.warn(\"Unexpected response from edit_format, formatResult.getEdits().size() = \" + edits.size());\n        }\n      }\n    };\n\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        CommandProcessor.getInstance().executeCommand(project, runnable, DartBundle.message(\"dart.style.action.name\"), null);\n      }\n    });\n  }","commit_id":"56a77abaf961d0f54e20d1b57738ebea887068a0","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void update(final AnActionEvent event) {\n    final Presentation presentation = event.getPresentation();\n    final Project project = event.getProject();\n    if (project == null) {\n      presentation.setVisible(false);\n      presentation.setEnabled(false);\n      return;\n    }\n\n    final Editor editor = event.getData(CommonDataKeys.EDITOR);\n    if (editor != null) {\n      final PsiFile psiFile = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n      // visible for any Dart file, but enabled for applicable only\n      presentation.setVisible(psiFile != null && psiFile.getFileType() == DartFileType.INSTANCE);\n      presentation.setEnabled(isApplicableFile(psiFile));\n      return;\n    }\n\n    presentation.setEnabledAndVisible(false);\n  }","id":99090,"modified_method":"@Override\n  public void update(final AnActionEvent event) {\n    final Presentation presentation = event.getPresentation();\n    final Project project = event.getProject();\n    if (project == null) {\n      presentation.setEnabledAndVisible(false);\n      return;\n    }\n\n    final Editor editor = event.getData(CommonDataKeys.EDITOR);\n    if (editor != null) {\n      final PsiFile psiFile = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n      // visible for any Dart file, but enabled for applicable only\n      presentation.setVisible(psiFile != null && psiFile.getFileType() == DartFileType.INSTANCE);\n      presentation.setEnabled(isApplicableFile(psiFile));\n      return;\n    }\n\n    final VirtualFile[] files = CommonDataKeys.VIRTUAL_FILE_ARRAY.getData(event.getDataContext());\n    if (files == null) {\n      presentation.setEnabledAndVisible(false);\n      return;\n    }\n\n    final DartSdk sdk = DartSdk.getDartSdk(project);\n    if (sdk == null || !DartAnalysisServerAnnotator.isDartSDKVersionSufficient(sdk) || !mayHaveApplicableVirtualFiles(files)) {\n      presentation.setEnabledAndVisible(false);\n      return;\n    }\n\n    presentation.setEnabledAndVisible(true);\n  }","commit_id":"56a77abaf961d0f54e20d1b57738ebea887068a0","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void writeBody( FileWriter writer, String id, MojoDescriptor mojoDescriptor )\n    {\n        XMLWriter w = new PrettyPrintXMLWriter( writer );\n\n        w.startElement( \"document\" );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"properties\" );\n\n        w.startElement( \"title\" );\n\n        // TODO: need a friendly name for a plugin\n        w.writeText( mojoDescriptor.getPluginDescriptor().getArtifactId() + \" - \" + mojoDescriptor.getFullGoalName() );\n\n        w.endElement();\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"section\" );\n\n        w.addAttribute( \"name\", mojoDescriptor.getFullGoalName() );\n\n        w.startElement( \"p\" );\n\n        if ( mojoDescriptor.getDescription() != null )\n        {\n            w.writeMarkup( mojoDescriptor.getDescription() );\n        }\n        else\n        {\n            w.writeText( \"No description.\" );\n        }\n\n        w.endElement();\n\n        w.startElement( \"p\" );\n\n        w.writeText( \"Parameters for the goal: \" );\n\n        w.endElement();\n\n        writeGoalParameterTable( mojoDescriptor, w );\n\n        w.endElement();\n\n        w.endElement();\n    }","id":99091,"modified_method":"private void writeBody( FileWriter writer, MojoDescriptor mojoDescriptor )\n    {\n        XMLWriter w = new PrettyPrintXMLWriter( writer );\n\n        w.startElement( \"document\" );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"properties\" );\n\n        w.startElement( \"title\" );\n\n        // TODO: need a friendly name for a plugin\n        w.writeText( mojoDescriptor.getPluginDescriptor().getArtifactId() + \" - \" + mojoDescriptor.getFullGoalName() );\n\n        w.endElement();\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"body\" );\n\n        w.startElement( \"section\" );\n\n        w.addAttribute( \"name\", mojoDescriptor.getFullGoalName() );\n\n        w.startElement( \"p\" );\n\n        if ( mojoDescriptor.getDescription() != null )\n        {\n            w.writeMarkup( mojoDescriptor.getDescription() );\n        }\n        else\n        {\n            w.writeText( \"No description.\" );\n        }\n\n        w.endElement();\n\n        w.startElement( \"p\" );\n\n        w.writeText( \"Parameters for the goal: \" );\n\n        w.endElement();\n\n        writeGoalParameterTable( mojoDescriptor, w );\n\n        w.endElement();\n\n        w.endElement();\n    }","commit_id":"0ff8c16056a68a10f88e003b4cdfbcbcdec8d9e3","url":"https://github.com/apache/maven"},{"original_method":"private void writeGoalParameterTable( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        w.startElement( \"table\" );\n\n        w.startElement( \"tr\" );\n\n        w.startElement( \"th\" );\n\n        w.writeText( \"Parameter\" );\n\n        w.endElement();\n\n        w.startElement( \"th\" );\n\n        w.writeText( \"Type\" );\n\n        w.endElement();\n\n        w.startElement( \"th\" );\n\n        w.writeText( \"Expression\" );\n\n        w.endElement();\n\n        w.startElement( \"th\" );\n\n        w.writeText( \"Description\" );\n\n        w.endElement();\n\n        w.endElement();\n\n        List parameters = mojoDescriptor.getParameters();\n\n        for ( int i = 0; i < parameters.size(); i++ )\n        {\n            Parameter parameter = (Parameter) parameters.get( i );\n\n            w.startElement( \"tr\" );\n\n            // ----------------------------------------------------------------------\n            //\n            // ----------------------------------------------------------------------\n\n            w.startElement( \"td\" );\n\n            String paramName = parameter.getAlias();\n\n            if ( StringUtils.isEmpty( paramName ) )\n            {\n                paramName = parameter.getName();\n            }\n\n            w.startElement( \"code\" );\n\n            w.writeText( paramName );\n\n            w.endElement();\n\n            if ( !parameter.isRequired() )\n            {\n                w.writeMarkup( \" <i>(Optional)<\/i>\");\n            }\n\n            w.endElement();\n\n            // ----------------------------------------------------------------------\n            //\n            // ----------------------------------------------------------------------\n\n            w.startElement( \"td\" );\n\n            w.startElement( \"code\" );\n\n            w.writeText( parameter.getType() );\n\n            w.endElement();\n\n            w.endElement();\n\n            // ----------------------------------------------------------------------\n            //\n            // ----------------------------------------------------------------------\n\n            w.startElement( \"td\" );\n\n            w.startElement( \"code\" );\n\n            if ( StringUtils.isNotEmpty( parameter.getExpression() ) )\n            {\n                w.writeText( parameter.getExpression() );\n            }\n            else\n            {\n                w.writeText( \"-\" );\n            }\n\n            w.endElement();\n\n            w.endElement();\n\n            // ----------------------------------------------------------------------\n            //\n            // ----------------------------------------------------------------------\n\n            w.startElement( \"td\" );\n\n            if ( StringUtils.isNotEmpty( parameter.getDescription() ) )\n            {\n                w.writeMarkup( parameter.getDescription() );\n            }\n            else\n            {\n                w.writeText( \"No description.\" );\n            }\n\n            String deprecationWarning = parameter.getDeprecated();\n            if ( deprecationWarning != null )\n            {\n                w.writeMarkup( \"<br/><b>Deprecated:<\/b> \");\n                w.writeMarkup( deprecationWarning );\n                if ( deprecationWarning.length() == 0 )\n                {\n                    w.writeText( \"No reason given.\" );\n                }\n\n                w.endElement();\n            }\n\n            w.endElement();\n\n            w.endElement();\n        }\n\n        w.endElement();\n    }","id":99092,"modified_method":"private void writeGoalParameterTable( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        w.startElement( \"table\" );\n\n        w.startElement( \"tr\" );\n\n        w.startElement( \"th\" );\n\n        w.writeText( \"Parameter\" );\n\n        w.endElement();\n\n        w.startElement( \"th\" );\n\n        w.writeText( \"Type\" );\n\n        w.endElement();\n\n        w.startElement( \"th\" );\n\n        w.writeText( \"Expression\" );\n\n        w.endElement();\n\n        w.startElement( \"th\" );\n\n        w.writeText( \"Description\" );\n\n        w.endElement();\n\n        w.endElement();\n\n        List parameters = mojoDescriptor.getParameters();\n\n        for ( int i = 0; i < parameters.size(); i++ )\n        {\n            Parameter parameter = (Parameter) parameters.get( i );\n\n            w.startElement( \"tr\" );\n\n            // ----------------------------------------------------------------------\n            //\n            // ----------------------------------------------------------------------\n\n            w.startElement( \"td\" );\n\n            String paramName = parameter.getAlias();\n\n            if ( StringUtils.isEmpty( paramName ) )\n            {\n                paramName = parameter.getName();\n            }\n\n            w.startElement( \"code\" );\n\n            w.writeText( paramName );\n\n            w.endElement();\n\n            if ( !parameter.isRequired() )\n            {\n                w.writeMarkup( \" <i>(Optional)<\/i>\" );\n            }\n\n            if ( parameter.getExpression() != null && parameter.getExpression().startsWith( \"${component.\" ) )\n            {\n                w.writeMarkup( \" <i>(Discovered)<\/i>\" );\n            }\n\n            w.endElement();\n\n            // ----------------------------------------------------------------------\n            //\n            // ----------------------------------------------------------------------\n\n            w.startElement( \"td\" );\n\n            w.startElement( \"code\" );\n\n            w.addAttribute( \"title\", parameter.getType() );\n\n            int index = parameter.getType().lastIndexOf( \".\" );\n            if ( index >= 0 )\n            {\n                w.writeText( parameter.getType().substring( index + 1 ) );\n            }\n            else\n            {\n                w.writeText( parameter.getType() );\n            }\n\n            w.endElement();\n\n            w.endElement();\n\n            // ----------------------------------------------------------------------\n            //\n            // ----------------------------------------------------------------------\n\n            w.startElement( \"td\" );\n\n            w.startElement( \"code\" );\n\n            if ( StringUtils.isNotEmpty( parameter.getExpression() ) &&\n                !parameter.getExpression().startsWith( \"${component.\" ) )\n            {\n                w.writeText( parameter.getExpression() );\n            }\n            else\n            {\n                w.writeText( \"-\" );\n            }\n\n            w.endElement();\n\n            w.endElement();\n\n            // ----------------------------------------------------------------------\n            //\n            // ----------------------------------------------------------------------\n\n            w.startElement( \"td\" );\n\n            if ( StringUtils.isNotEmpty( parameter.getDescription() ) )\n            {\n                w.writeMarkup( parameter.getDescription() );\n            }\n            else\n            {\n                w.writeText( \"No description.\" );\n            }\n\n            String deprecationWarning = parameter.getDeprecated();\n            if ( deprecationWarning != null )\n            {\n                w.writeMarkup( \"<br/><b>Deprecated:<\/b> \" );\n                w.writeMarkup( deprecationWarning );\n                if ( deprecationWarning.length() == 0 )\n                {\n                    w.writeText( \"No reason given.\" );\n                }\n\n                w.endElement();\n            }\n\n            w.endElement();\n\n            w.endElement();\n        }\n\n        w.endElement();\n\n        w.endElement();\n    }","commit_id":"0ff8c16056a68a10f88e003b4cdfbcbcdec8d9e3","url":"https://github.com/apache/maven"},{"original_method":"public void execute( File destinationDirectory, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        // TODO: write an overview page\n\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n            processMojoDescriptor( descriptor, destinationDirectory );\n        }\n    }","id":99093,"modified_method":"public void execute( File destinationDirectory, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        writeOverview( destinationDirectory, pluginDescriptor );\n\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n            processMojoDescriptor( descriptor, destinationDirectory );\n        }\n    }","commit_id":"0ff8c16056a68a10f88e003b4cdfbcbcdec8d9e3","url":"https://github.com/apache/maven"},{"original_method":"protected void processMojoDescriptor( MojoDescriptor mojoDescriptor, File destinationDirectory )\n        throws IOException\n    {\n        String id = mojoDescriptor.getGoal();\n\n        FileWriter writer = null;\n        try\n        {\n            writer = new FileWriter( new File( destinationDirectory, id + \"-mojo.xml\" ) );\n\n            writeBody( writer, id, mojoDescriptor );\n\n            writer.flush();\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }","id":99094,"modified_method":"protected void processMojoDescriptor( MojoDescriptor mojoDescriptor, File destinationDirectory )\n        throws IOException\n    {\n        FileWriter writer = null;\n        try\n        {\n            writer = new FileWriter( new File( destinationDirectory, getMojoFilename( mojoDescriptor, \"xml\" ) ) );\n\n            writeBody( writer, mojoDescriptor );\n\n            writer.flush();\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }","commit_id":"0ff8c16056a68a10f88e003b4cdfbcbcdec8d9e3","url":"https://github.com/apache/maven"},{"original_method":"/**\n     * Initializes the JBoss configuration.\n     *\n     * @throws EarPluginException if the configuration is invalid\n     */\n    private void initializeJbossConfiguration()\n        throws EarPluginException\n    {\n        if ( jboss == null )\n        {\n            jbossConfiguration = null;\n        }\n        else\n        {\n            try\n            {\n                String version = jboss.getChild( JbossConfiguration.VERSION ).getValue();\n                if ( version == null )\n                {\n                    getLog().info( \"JBoss version not set, using JBoss 4 by default\" );\n                    version = JbossConfiguration.VERSION_4;\n                }\n                final String securityDomain = jboss.getChild( JbossConfiguration.SECURITY_DOMAIN ).getValue();\n                final String unauthenticatedPrincipal =\n                    jboss.getChild( JbossConfiguration.UNAUHTHENTICTED_PRINCIPAL ).getValue();\n                final String loaderRepository = jboss.getChild( JbossConfiguration.LOADER_REPOSITORY ).getValue();\n                final String jmxName = jboss.getChild( JbossConfiguration.JMX_NAME ).getValue();\n                final String moduleOrder = jboss.getChild( JbossConfiguration.MODULE_ORDER ).getValue();\n\n                final List dataSources = new ArrayList();\n                final PlexusConfiguration dataSourcesEl = jboss.getChild( JbossConfiguration.DATASOURCES );\n                if ( dataSourcesEl != null )\n                {\n\n                    final PlexusConfiguration[] dataSourcesConfig =\n                        dataSourcesEl.getChildren( JbossConfiguration.DATASOURCE );\n                    for ( int i = 0; i < dataSourcesConfig.length; i++ )\n                    {\n                        PlexusConfiguration dataSourceConfig = dataSourcesConfig[i];\n                        dataSources.add( dataSourceConfig.getValue() );\n\n                    }\n                }\n                jbossConfiguration = new JbossConfiguration( version, securityDomain, unauthenticatedPrincipal, jmxName,\n                                                             loaderRepository, moduleOrder, dataSources );\n            }\n            catch ( PlexusConfigurationException e )\n            {\n                throw new EarPluginException( \"Invalid JBoss configuration\", e );\n            }\n        }\n    }","id":99095,"modified_method":"/**\n     * Initializes the JBoss configuration.\n     *\n     * @throws EarPluginException if the configuration is invalid\n     */\n    private void initializeJbossConfiguration()\n        throws EarPluginException\n    {\n        if ( jboss == null )\n        {\n            jbossConfiguration = null;\n        }\n        else\n        {\n            try\n            {\n                String version = jboss.getChild( JbossConfiguration.VERSION ).getValue();\n                if ( version == null )\n                {\n                    getLog().info( \"JBoss version not set, using JBoss 4 by default\" );\n                    version = JbossConfiguration.VERSION_4;\n                }\n                final String securityDomain = jboss.getChild( JbossConfiguration.SECURITY_DOMAIN ).getValue();\n                final String unauthenticatedPrincipal =\n                    jboss.getChild( JbossConfiguration.UNAUHTHENTICTED_PRINCIPAL ).getValue();\n\n                final String loaderRepository = jboss.getChild( JbossConfiguration.LOADER_REPOSITORY ).getValue();\n                final String loaderRepositoryClass =\n                    jboss.getChild( JbossConfiguration.LOADER_REPOSITORY_CLASS ).getValue();\n                final String loaderRepositoryConfig =\n                    jboss.getChild( JbossConfiguration.LOADER_REPOSITORY_CONFIG ).getValue();\n                final String configParserClass = jboss.getChild( JbossConfiguration.CONFIG_PARSER_CLASS ).getValue();\n\n                final String jmxName = jboss.getChild( JbossConfiguration.JMX_NAME ).getValue();\n                final String moduleOrder = jboss.getChild( JbossConfiguration.MODULE_ORDER ).getValue();\n\n                final List dataSources = new ArrayList();\n                final PlexusConfiguration dataSourcesEl = jboss.getChild( JbossConfiguration.DATASOURCES );\n                if ( dataSourcesEl != null )\n                {\n\n                    final PlexusConfiguration[] dataSourcesConfig =\n                        dataSourcesEl.getChildren( JbossConfiguration.DATASOURCE );\n                    for ( int i = 0; i < dataSourcesConfig.length; i++ )\n                    {\n                        PlexusConfiguration dataSourceConfig = dataSourcesConfig[i];\n                        dataSources.add( dataSourceConfig.getValue() );\n\n                    }\n                }\n                final String libraryDirectory = jboss.getChild( JbossConfiguration.LIBRARY_DIRECTORY ).getValue();\n                jbossConfiguration = new JbossConfiguration( version, securityDomain, unauthenticatedPrincipal, jmxName,\n                                                             loaderRepository, moduleOrder, dataSources,\n                                                             libraryDirectory, loaderRepositoryConfig,\n                                                             loaderRepositoryClass, configParserClass );\n            }\n            catch ( PlexusConfigurationException e )\n            {\n                throw new EarPluginException( \"Invalid JBoss configuration\", e );\n            }\n        }\n    }","commit_id":"b68296b391605733a793715f9e4b419b2f86290a","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void write( File destinationFile, JbossConfiguration jbossConfiguration, List earModules )\n        throws EarPluginException\n    {\n        final Writer w = initializeWriter( destinationFile );\n\n        XMLWriter writer;\n        if ( jbossConfiguration.isJbossThreeDotTwo() )\n        {\n            writer = initializeXmlWriter( w, DOCTYPE_3_2 );\n        }\n        else if ( jbossConfiguration.isJbossFour() )\n        {\n            writer = initializeXmlWriter( w, DOCTYPE_4 );\n        }\n        else\n        {\n            writer = initializeXmlWriter( w, DOCTYPE_4_2 );\n        }\n        writer.startElement( JBOSS_APP_ELEMENT );\n\n        // If JBoss 4.2, write the jboss4.2 specific stuff\n        if ( jbossConfiguration.isJbossFourDotTwo() )\n        {\n            // module-order\n            if ( jbossConfiguration.getModuleOrder() != null )\n            {\n                writer.startElement( JbossConfiguration.MODULE_ORDER );\n                writer.writeText( jbossConfiguration.getModuleOrder() );\n                writer.endElement();\n            }\n        }\n\n        // If JBoss 4, write the jboss4 specific stuff\n        if ( jbossConfiguration.isJbossFour() || jbossConfiguration.isJbossFourDotTwo() )\n        {\n            if ( jbossConfiguration.getSecurityDomain() != null )\n            {\n                writer.startElement( JbossConfiguration.SECURITY_DOMAIN );\n                writer.writeText( jbossConfiguration.getSecurityDomain() );\n                writer.endElement();\n            }\n            if ( jbossConfiguration.getUnauthenticatedPrincipal() != null )\n            {\n                writer.startElement( JbossConfiguration.UNAUHTHENTICTED_PRINCIPAL );\n                writer.writeText( jbossConfiguration.getUnauthenticatedPrincipal() );\n                writer.endElement();\n            }\n        }\n\n        // classloader repository\n        if ( jbossConfiguration.getLoaderRepository() != null )\n        {\n            writer.startElement( JbossConfiguration.LOADER_REPOSITORY );\n            writer.writeText( jbossConfiguration.getLoaderRepository() );\n            writer.endElement();\n        }\n\n        // jmx name\n        if ( jbossConfiguration.getJmxName() != null )\n        {\n            writer.startElement( JbossConfiguration.JMX_NAME );\n            writer.writeText( jbossConfiguration.getJmxName() );\n            writer.endElement();\n        }\n\n        List dataSources = jbossConfiguration.getDataSources();\n        // Write out data source modules first\n        if ( dataSources != null )\n        {\n            final Iterator it = dataSources.iterator();\n            while ( it.hasNext() )\n            {\n                String dsPath = (String) it.next();\n                writer.startElement( MODULE_ELEMENT );\n                writer.startElement( SERVICE_ELEMENT );\n                writer.writeText( dsPath );\n                writer.endElement();\n                writer.endElement();\n            }\n        }\n\n        // Write the JBoss specific modules\n        final Iterator it = earModules.iterator();\n        while ( it.hasNext() )\n        {\n            EarModule earModule = (EarModule) it.next();\n            if ( JbossEarModule.class.isInstance( earModule ) )\n            {\n                JbossEarModule jbossEarModule = (JbossEarModule) earModule;\n                jbossEarModule.appendJbossModule( writer, jbossConfiguration.getVersion() );\n            }\n        }\n        writer.endElement();\n\n        close( w );\n    }","id":99096,"modified_method":"public void write( File destinationFile, JbossConfiguration jbossConfiguration, List earModules )\n        throws EarPluginException\n    {\n        final Writer w = initializeWriter( destinationFile );\n\n        XMLWriter writer;\n        if ( jbossConfiguration.isJbossThreeDotTwo() )\n        {\n            writer = initializeXmlWriter( w, DOCTYPE_3_2 );\n        }\n        else if ( jbossConfiguration.isJbossFour() )\n        {\n            writer = initializeXmlWriter( w, DOCTYPE_4 );\n        }\n        else if ( jbossConfiguration.isJbossFourDotTwo() )\n        {\n            writer = initializeXmlWriter( w, DOCTYPE_4_2 );\n        }\n        else\n        {\n            writer = initializeXmlWriter( w, DOCTYPE_5 );\n        }\n        writer.startElement( JBOSS_APP_ELEMENT );\n\n        // If JBoss 4.2 or 5.0, write the JBoss 4.2 and JBoss 5.0-compatible stuff\n        if ( jbossConfiguration.isJbossFourDotTwo() || jbossConfiguration.isJbossFive() )\n        {\n            // library-directory\n            if ( jbossConfiguration.getLibraryDirectory() != null )\n            {\n                writer.startElement( JbossConfiguration.LIBRARY_DIRECTORY );\n                writer.writeText ( jbossConfiguration.getLibraryDirectory() );\n                writer.endElement();\n            }\n        }\n\n        // If JBoss 4.2, write the jboss4.2 specific stuff\n        if ( jbossConfiguration.isJbossFourDotTwo() )\n        {\n            // module-order (only available in 4.2 and 4.3)\n            if ( jbossConfiguration.getModuleOrder() != null )\n            {\n                writer.startElement( JbossConfiguration.MODULE_ORDER );\n                writer.writeText( jbossConfiguration.getModuleOrder() );\n                writer.endElement();\n            }\n        }\n\n        // If JBoss 4, write the jboss4 specific stuff\n        if ( jbossConfiguration.isJbossFour() || jbossConfiguration.isJbossFourDotTwo() )\n        {\n            if ( jbossConfiguration.getSecurityDomain() != null )\n            {\n                writer.startElement( JbossConfiguration.SECURITY_DOMAIN );\n                writer.writeText( jbossConfiguration.getSecurityDomain() );\n                writer.endElement();\n            }\n            if ( jbossConfiguration.getUnauthenticatedPrincipal() != null )\n            {\n                writer.startElement( JbossConfiguration.UNAUHTHENTICTED_PRINCIPAL );\n                writer.writeText( jbossConfiguration.getUnauthenticatedPrincipal() );\n                writer.endElement();\n            }\n        }\n\n        // classloader repository\n        if ( jbossConfiguration.getLoaderRepository() != null || jbossConfiguration.getLoaderRepositoryConfig() != null)\n        {\n            writer.startElement( JbossConfiguration.LOADER_REPOSITORY );\n\n            // classloader repository class\n            if ( jbossConfiguration.getLoaderRepositoryClass() != null)\n            {\n                writer.addAttribute( JbossConfiguration.LOADER_REPOSITORY_CLASS,\n                                     jbossConfiguration.getLoaderRepositoryClass() );\n            }\n\n            // we don't need to write any text if only the loader repo configuration is changed\n            if ( jbossConfiguration.getLoaderRepository() != null )\n            {\n                writer.writeText( jbossConfiguration.getLoaderRepository() );\n            }\n\n            // classloader configuration\n            if ( jbossConfiguration.getLoaderRepositoryConfig() != null )\n            {\n                writer.startElement( JbossConfiguration.LOADER_REPOSITORY_CONFIG );\n\n                // classloader configuration parser\n                if ( jbossConfiguration.getConfigParserClass() != null)\n                {\n                    writer.addAttribute( JbossConfiguration.CONFIG_PARSER_CLASS,\n                                         jbossConfiguration.getConfigParserClass() );\n                }\n                writer.writeText( jbossConfiguration.getLoaderRepositoryConfig() );\n                writer.endElement();\n            }\n            \n            writer.endElement();\n        }\n\n        // jmx name\n        if ( jbossConfiguration.getJmxName() != null )\n        {\n            writer.startElement( JbossConfiguration.JMX_NAME );\n            writer.writeText( jbossConfiguration.getJmxName() );\n            writer.endElement();\n        }\n\n        List dataSources = jbossConfiguration.getDataSources();\n        // Write out data source modules first\n        if ( dataSources != null )\n        {\n            final Iterator it = dataSources.iterator();\n            while ( it.hasNext() )\n            {\n                String dsPath = (String) it.next();\n                writer.startElement( MODULE_ELEMENT );\n                writer.startElement( SERVICE_ELEMENT );\n                writer.writeText( dsPath );\n                writer.endElement();\n                writer.endElement();\n            }\n        }\n\n        // Write the JBoss specific modules\n        final Iterator it = earModules.iterator();\n        while ( it.hasNext() )\n        {\n            EarModule earModule = (EarModule) it.next();\n            if ( JbossEarModule.class.isInstance( earModule ) )\n            {\n                JbossEarModule jbossEarModule = (JbossEarModule) earModule;\n                jbossEarModule.appendJbossModule( writer, jbossConfiguration.getVersion() );\n            }\n        }\n        writer.endElement();\n\n        close( w );\n    }","commit_id":"b68296b391605733a793715f9e4b419b2f86290a","url":"https://github.com/apache/maven-plugins"},{"original_method":"public JbossConfiguration( String version, String securityDomain, String unauthenticatedPrincipal, String jmxName,\n                               String loaderRepository, String moduleOrder, List dataSources )\n        throws EarPluginException\n    {\n        if ( version == null )\n        {\n            throw new EarPluginException( \"jboss version could not be null.\" );\n        }\n        else\n        {\n            this.version = version;\n            if ( version.equals( JbossConfiguration.VERSION_3_2 ) )\n            {\n                this.jbossThreeDotTwo = true;\n            }\n            else if ( version.equals( JbossConfiguration.VERSION_4 ) )\n            {\n                this.jbossFour = true;\n            }\n            else if ( version.equals( JbossConfiguration.VERSION_4_2 ) )\n            {\n                this.jbossFourDotTwo = true;\n            }\n            else\n            {\n                throw new EarPluginException(\n                    \"Invalid JBoss configuration, version[\" + version + \"] is not supported.\" );\n            }\n            this.securityDomain = securityDomain;\n            this.unauthenticatedPrincipal = unauthenticatedPrincipal;\n            this.jmxName = jmxName;\n            this.loaderRepository = loaderRepository;\n            this.moduleOrder = moduleOrder;\n            this.dataSources = dataSources;\n        }\n    }","id":99097,"modified_method":"public JbossConfiguration( String version, String securityDomain, String unauthenticatedPrincipal, String jmxName,\n                               String loaderRepository, String moduleOrder, List dataSources, String libraryDirectory,\n                               String loaderRepositoryConfig, String loaderRepositoryClass, String configParserClass )\n        throws EarPluginException\n    {\n        if ( version == null )\n        {\n            throw new EarPluginException( \"jboss version could not be null.\" );\n        }\n        else\n        {\n            this.version = version;\n            if ( version.equals( JbossConfiguration.VERSION_3_2 ) )\n            {\n                this.jbossThreeDotTwo = true;\n            }\n            else if ( version.equals( JbossConfiguration.VERSION_4 ) )\n            {\n                this.jbossFour = true;\n            }\n            else if ( version.equals( JbossConfiguration.VERSION_4_2 ) )\n            {\n                this.jbossFourDotTwo = true;\n            }\n            else if ( version.equals( JbossConfiguration.VERSION_5 ) )\n            {\n                this.jbossFive = true;\n            }\n            else\n            {\n                throw new EarPluginException(\n                    \"Invalid JBoss configuration, version[\" + version + \"] is not supported.\" );\n            }\n            this.securityDomain = securityDomain;\n            this.unauthenticatedPrincipal = unauthenticatedPrincipal;\n            this.jmxName = jmxName;\n            this.loaderRepository = loaderRepository;\n            this.moduleOrder = moduleOrder;\n            this.dataSources = dataSources;\n            this.libraryDirectory = libraryDirectory;\n            this.loaderRepositoryConfig = loaderRepositoryConfig;\n            this.loaderRepositoryClass = loaderRepositoryClass;\n            this.configParserClass = configParserClass;\n        }\n    }","commit_id":"b68296b391605733a793715f9e4b419b2f86290a","url":"https://github.com/apache/maven-plugins"},{"original_method":"@Test\n    public void testSymLinkToContentWithPathPrefixCheck() throws Exception\n    {\n        File symlink = new File(_dir,\"dirlink\");\n        try\n        {\n            Files.createSymbolicLink(symlink.toPath(),new File(_dir,\".\").toPath());\n\n            _ctx.setAliases(false);\n            _ctx.addAliasCheck(new ContextHandler.ApprovePathPrefixAliases());\n            Assert.assertTrue(_ctx.getResource(\"/index.html\").exists());\n            Assert.assertTrue(_ctx.getResource(\"/dirlink/index.html\").exists());\n        }\n        finally\n        {\n            symlink.delete();\n        }\n    }","id":99098,"modified_method":"@Test\n    public void testSymLinkToContentWithPathPrefixCheck() throws Exception\n    {\n        File symlink = new File(_dir,\"dirlink\");\n        try\n        {\n        \tcreateNIOSymlink(symlink,new File(_dir,\".\"));\n\n            _ctx.setAliases(false);\n            _ctx.addAliasCheck(new ContextHandler.ApprovePathPrefixAliases());\n            Assert.assertTrue(_ctx.getResource(\"/index.html\").exists());\n            Assert.assertTrue(_ctx.getResource(\"/dirlink/index.html\").exists());\n        }\n        finally\n        {\n            symlink.delete();\n        }\n    }","commit_id":"83aa65415b5f6a4977975c991ee9bf625575eb37","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSymLinkToContent() throws Exception\n    {\n        File symlink = new File(_dir,\"link.html\");\n        try\n        {\n            Files.createSymbolicLink(symlink.toPath(),new File(_dir,\"index.html\").toPath());\n\n            _ctx.setAliases(true);\n            Assert.assertTrue(_ctx.getResource(\"/index.html\").exists());\n            Assert.assertTrue(_ctx.getResource(\"/link.html\").exists());\n            \n            _ctx.setAliases(false);\n            Assert.assertTrue(_ctx.getResource(\"/index.html\").exists());\n            Assert.assertNull(_ctx.getResource(\"/link.html\"));\n            \n        }\n        finally\n        {\n            symlink.delete();\n        }\n    }","id":99099,"modified_method":"@Test\n    public void testSymLinkToContent() throws Exception\n    {\n        File symlink = new File(_dir,\"link.html\");\n        try\n        {\n            createNIOSymlink(symlink, new File(_dir,\"index.html\"));\n\n            _ctx.setAliases(true);\n            Assert.assertTrue(_ctx.getResource(\"/index.html\").exists());\n            Assert.assertTrue(_ctx.getResource(\"/link.html\").exists());\n            \n            _ctx.setAliases(false);\n            Assert.assertTrue(_ctx.getResource(\"/index.html\").exists());\n            Assert.assertNull(_ctx.getResource(\"/link.html\"));\n            \n        }\n        finally\n        {\n            symlink.delete();\n        }\n    }","commit_id":"83aa65415b5f6a4977975c991ee9bf625575eb37","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSymLinkToContext() throws Exception\n    {\n        File symlink = new File(_tmp,\"symlink\");\n        try\n        {\n            Files.createSymbolicLink(symlink.toPath(),_dir.toPath());\n\n            _server.stop();\n            _ctx.setBaseResource(FileResource.newResource(symlink));\n            _ctx.setAliases(false);\n            _server.start();\n\n            Resource r =_ctx.getResource(\"/index.html\");\n            Assert.assertTrue(r.exists());\n        }\n        finally\n        {\n            symlink.delete();\n        }\n    }","id":99100,"modified_method":"@Test\n    public void testSymLinkToContext() throws Exception\n    {\n        File symlink = new File(_tmp,\"symlink\");\n        try\n        {\n        \tcreateNIOSymlink(symlink, _dir);\n\n            _server.stop();\n            _ctx.setBaseResource(FileResource.newResource(symlink));\n            _ctx.setAliases(false);\n            _server.start();\n\n            Resource r =_ctx.getResource(\"/index.html\");\n            Assert.assertTrue(r.exists());\n        }\n        finally\n        {\n            symlink.delete();\n        }\n    }","commit_id":"83aa65415b5f6a4977975c991ee9bf625575eb37","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSymLinkToContentWithSuffixCheck() throws Exception\n    {\n        File symlink = new File(_dir,\"link.html\");\n        try\n        {\n            Files.createSymbolicLink(symlink.toPath(),new File(_dir,\"index.html\").toPath());\n\n            _ctx.setAliases(false);\n            _ctx.addAliasCheck(new ContextHandler.ApproveSameSuffixAliases());\n            Assert.assertTrue(_ctx.getResource(\"/index.html\").exists());\n            Assert.assertTrue(_ctx.getResource(\"/link.html\").exists());\n        }\n        finally\n        {\n            symlink.delete();\n        }\n    }","id":99101,"modified_method":"@Test\n    public void testSymLinkToContentWithSuffixCheck() throws Exception\n    {\n        File symlink = new File(_dir,\"link.html\");\n        try\n        {\n        \tcreateNIOSymlink(symlink,new File(_dir,\"index.html\"));\n\n            _ctx.setAliases(false);\n            _ctx.addAliasCheck(new ContextHandler.ApproveSameSuffixAliases());\n            Assert.assertTrue(_ctx.getResource(\"/index.html\").exists());\n            Assert.assertTrue(_ctx.getResource(\"/link.html\").exists());\n        }\n        finally\n        {\n            symlink.delete();\n        }\n    }","commit_id":"83aa65415b5f6a4977975c991ee9bf625575eb37","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Before\n    public void before() throws Exception\n    {\n        _server=new Server();\n        _ctx = new ContextHandler();\n        _server.setHandler(_ctx);\n        \n        \n        _tmp = new File( System.getProperty( \"basedir\", \".\" ) + \"/target/tmp/aliastests\" ).getCanonicalFile();\n        if (_tmp.exists())\n            IO.delete(_tmp);\n        assertTrue(_tmp.mkdirs());\n        \n        File root = new File(_tmp,getClass().getName());\n        assertTrue(root.mkdir());\n\n        File webInf = new File(root,\"WEB-INF\");\n        assertTrue(webInf.mkdir());\n\n        assertTrue(new File(webInf,\"jsp\").mkdir());\n        assertTrue(new File(webInf,\"web.xml\").createNewFile());\n        assertTrue(new File(root,\"index.html\").createNewFile());\n\n        _dir=root;\n        _ctx.setBaseResource(Resource.newResource(_dir));\n        _server.start();\n    }","id":99102,"modified_method":"@Before\n    public void before() throws Exception\n    {\n        _server=new Server();\n        _ctx = new ContextHandler();\n        _server.setHandler(_ctx);\n        \n        _tmp = MavenTestingUtils.getTargetTestingDir(ContextHandlerAliasTest.class.getName()).getCanonicalFile();\n        FS.ensureEmpty(_tmp);\n        \n        File root = new File(_tmp,getClass().getName());\n        assertTrue(root.mkdir());\n\n        File webInf = new File(root,\"WEB-INF\");\n        assertTrue(webInf.mkdir());\n\n        assertTrue(new File(webInf,\"jsp\").mkdir());\n        assertTrue(new File(webInf,\"web.xml\").createNewFile());\n        assertTrue(new File(root,\"index.html\").createNewFile());\n\n        _dir=root;\n        _ctx.setBaseResource(Resource.newResource(_dir));\n        _server.start();\n    }","commit_id":"83aa65415b5f6a4977975c991ee9bf625575eb37","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGetBeanRefInvalid_nullxslash() throws Exception\n    {\n\n        URI uri = serverURI.resolve(\"/dump.jsp%00x/\");\n\n        HttpURLConnection conn = null;\n        try\n        {\n            conn = (HttpURLConnection)uri.toURL().openConnection();\n            conn.setConnectTimeout(1000);\n            conn.setReadTimeout(1000);\n            Assert.assertThat(\"Response Code\",conn.getResponseCode(),is(404));\n        }\n        finally\n        {\n            close(conn);\n        }\n    }","id":99103,"modified_method":"@Test\n    public void testGetBeanRefInvalid_nullxslash() throws Exception\n    {\n        assumeJava7();\n\n        URI uri = serverURI.resolve(\"/dump.jsp%00x/\");\n\n        HttpURLConnection conn = null;\n        try\n        {\n            conn = (HttpURLConnection)uri.toURL().openConnection();\n            conn.setConnectTimeout(1000);\n            conn.setReadTimeout(1000);\n            assertResponseOnBadRequest(conn);\n        }\n        finally\n        {\n            close(conn);\n        }\n    }","commit_id":"83aa65415b5f6a4977975c991ee9bf625575eb37","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGetBeanRefInvalid_null() throws Exception\n    {\n\n        URI uri = serverURI.resolve(\"/dump.jsp%00\");\n\n        HttpURLConnection conn = null;\n        try\n        {\n            conn = (HttpURLConnection)uri.toURL().openConnection();\n            conn.setConnectTimeout(1000);\n            conn.setReadTimeout(1000);\n            Assert.assertThat(\"Response Code\",conn.getResponseCode(),is(404));\n        }\n        finally\n        {\n            close(conn);\n        }\n    }","id":99104,"modified_method":"@Test\n    public void testGetBeanRefInvalid_null() throws Exception\n    {\n\n        URI uri = serverURI.resolve(\"/dump.jsp%00\");\n\n        HttpURLConnection conn = null;\n        try\n        {\n            conn = (HttpURLConnection)uri.toURL().openConnection();\n            conn.setConnectTimeout(1000);\n            conn.setReadTimeout(1000);\n            assertResponseOnBadRequest(conn);\n        }\n        finally\n        {\n            close(conn);\n        }\n    }","commit_id":"83aa65415b5f6a4977975c991ee9bf625575eb37","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGetBeanRefInvalid_nullx() throws Exception\n    {\n\n        URI uri = serverURI.resolve(\"/dump.jsp%00x\");\n\n        HttpURLConnection conn = null;\n        try\n        {\n            conn = (HttpURLConnection)uri.toURL().openConnection();\n            conn.setConnectTimeout(1000);\n            conn.setReadTimeout(1000);\n            Assert.assertThat(\"Response Code\",conn.getResponseCode(),is(404));\n        }\n        finally\n        {\n            close(conn);\n        }\n    }","id":99105,"modified_method":"@Test\n    public void testGetBeanRefInvalid_nullx() throws Exception\n    {\n\n        URI uri = serverURI.resolve(\"/dump.jsp%00x\");\n\n        HttpURLConnection conn = null;\n        try\n        {\n            conn = (HttpURLConnection)uri.toURL().openConnection();\n            conn.setConnectTimeout(1000);\n            conn.setReadTimeout(1000);\n            assertResponseOnBadRequest(conn);\n        }\n        finally\n        {\n            close(conn);\n        }\n    }","commit_id":"83aa65415b5f6a4977975c991ee9bf625575eb37","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGetBeanRef() throws Exception\n    {\n\n        URI uri = serverURI.resolve(\"/dump.jsp\");\n\n        HttpURLConnection conn = null;\n        try\n        {\n            conn = (HttpURLConnection)uri.toURL().openConnection();\n            conn.setConnectTimeout(5000);\n            conn.setReadTimeout(5000);\n            Assert.assertThat(conn.getResponseCode(),is(200));\n\n            // make sure that jsp actually ran, and didn't just get passed onto\n            // the default servlet to return the jsp source\n            String body = getResponseBody(conn);\n            Assert.assertThat(\"Body\",body,not(containsString(\"<%@\")));\n            Assert.assertThat(\"Body\",body,not(containsString(\"<jsp:\")));\n        }\n        finally\n        {\n            close(conn);\n        }\n    }","id":99106,"modified_method":"@Test\n    public void testGetBeanRef() throws Exception\n    {\n\n        URI uri = serverURI.resolve(\"/dump.jsp\");\n\n        HttpURLConnection conn = null;\n        try\n        {\n            conn = (HttpURLConnection)uri.toURL().openConnection();\n            conn.setConnectTimeout(5000);\n            conn.setReadTimeout(5000);\n            Assert.assertThat(conn.getResponseCode(),is(200));\n            assertProcessedByJspServlet(conn);\n        }\n        finally\n        {\n            close(conn);\n        }\n    }","commit_id":"83aa65415b5f6a4977975c991ee9bf625575eb37","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGetBeanRefInvalid_nullslash() throws Exception\n    {\n\n        URI uri = serverURI.resolve(\"/dump.jsp%00/\");\n\n        HttpURLConnection conn = null;\n        try\n        {\n            conn = (HttpURLConnection)uri.toURL().openConnection();\n            conn.setConnectTimeout(1000);\n            conn.setReadTimeout(1000);\n            Assert.assertThat(\"Response Code\",conn.getResponseCode(),is(404));\n        }\n        finally\n        {\n            close(conn);\n        }\n    }","id":99107,"modified_method":"@Test\n    public void testGetBeanRefInvalid_nullslash() throws Exception\n    {\n        assumeJava7();\n\n        URI uri = serverURI.resolve(\"/dump.jsp%00/\");\n\n        HttpURLConnection conn = null;\n        try\n        {\n            conn = (HttpURLConnection)uri.toURL().openConnection();\n            conn.setConnectTimeout(1000);\n            conn.setReadTimeout(1000);\n            assertResponseOnBadRequest(conn);\n        }\n        finally\n        {\n            close(conn);\n        }\n    }","commit_id":"83aa65415b5f6a4977975c991ee9bf625575eb37","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public boolean has(final String name, final Object key) {\r\n        final TxnRecord rec = findTxnRecord(name, key);\r\n        if (rec == null)\r\n            return false;\r\n        return true;\r\n    }","id":99108,"modified_method":"public boolean has(final String name, final Object key) {\r\n        final TxnRecord rec = findTxnRecord(name, key);\r\n        return rec != null;\r\n    }","commit_id":"2de48255dda85cea726e6fe6f98a9c2105926275","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void rollbackMap() {\r\n            MProxy mapProxy = null;\r\n            final Object proxy = FactoryImpl.getProxy(name);\r\n            if (proxy instanceof MProxy) {\r\n                mapProxy = (MProxy) proxy;\r\n            } else if (proxy instanceof CollectionProxy) {\r\n                mapProxy = ((CollectionProxy) proxy).getCProxy();\r\n            }\r\n            mapProxy.unlock(key);\r\n        }","id":99109,"modified_method":"public void rollbackMap() {\r\n            MProxy mapProxy = null;\r\n            final Object proxy = FactoryImpl.getProxy(name);\r\n            if (proxy instanceof MProxy) {\r\n                mapProxy = (MProxy) proxy;\r\n            } else if (proxy instanceof CollectionProxy) {\r\n                mapProxy = ((CollectionProxy) proxy).getCProxy();\r\n            }\r\n            if(mapProxy!=null) mapProxy.unlock(key);\r\n        }","commit_id":"2de48255dda85cea726e6fe6f98a9c2105926275","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test public void testModelLock() {\n    GBM gbm=null;\n    Frame fr=null;\n    try {\n      GBMModel.GBMParameters parms = new GBMModel.GBMParameters();\n      fr = parse_test_file(\"smalldata/gbm_test/ecology_model.csv\");\n      parms._train = fr._key;\n      fr.remove(\"Site\").remove();        // Remove unique ID\n      parms._response_column = \"Angaus\"; // Train on the outcome\n      parms._ntrees = 10;\n      parms._max_depth = 5;\n      parms._min_rows = 1;\n      parms._nbins = 20;\n      parms._learn_rate = .2f;\n      gbm = new GBM(parms);\n      gbm.trainModel();\n      try { Thread.sleep(10); } catch( Exception ignore ) { }\n\n      try {\n        fr.delete();            // Attempted delete while model-build is active\n        throw H2O.fail();       // Should toss IAE instead of reaching here\n      } catch( IllegalArgumentException ignore ) {\n      } catch( DException.DistributedException de ) {\n        assertTrue( de.getMessage().contains(\"java.lang.IllegalArgumentException\") );\n      }\n\n      GBMModel model = gbm.get();\n      Assert.assertTrue(gbm._state == Job.JobState.DONE); //HEX-1817\n      if( model != null ) model.delete();\n\n    } finally {\n      if( fr  != null ) fr .remove();\n      if( gbm != null ) gbm.remove();             // Remove GBM Job\n    }\n  }","id":99110,"modified_method":"@Test public void testModelLock() {\n    GBM gbm=null;\n    Frame fr=null;\n    try {\n      GBMModel.GBMParameters parms = new GBMModel.GBMParameters();\n      fr = parse_test_file(\"smalldata/gbm_test/ecology_model.csv\");\n      parms._train = fr._key;\n      fr.remove(\"Site\").remove();        // Remove unique ID\n      parms._response_column = \"Angaus\"; // Train on the outcome\n      parms._ntrees = 10;\n      parms._max_depth = 10;\n      parms._min_rows = 1;\n      parms._nbins = 20;\n      parms._learn_rate = .2f;\n      gbm = new GBM(parms);\n      gbm.trainModel();\n      try { Thread.sleep(50); } catch( Exception ignore ) { }\n\n      try {\n        fr.delete();            // Attempted delete while model-build is active\n        Assert.fail(\"Should toss IAE instead of reaching here\");\n      } catch( IllegalArgumentException ignore ) {\n      } catch( DException.DistributedException de ) {\n        assertTrue( de.getMessage().contains(\"java.lang.IllegalArgumentException\") );\n      }\n\n      GBMModel model = gbm.get();\n      Assert.assertTrue(gbm._state == Job.JobState.DONE); //HEX-1817\n      if( model != null ) model.delete();\n\n    } finally {\n      if( fr  != null ) fr .remove();\n      if( gbm != null ) gbm.remove();             // Remove GBM Job\n    }\n  }","commit_id":"3be08399bc5c87afad22126a541412daf1081de6","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@BeforeClass public static void stall() { stall_till_cloudsize(1); }","id":99111,"modified_method":"@BeforeClass public static void stall() { stall_till_cloudsize(5); }","commit_id":"3be08399bc5c87afad22126a541412daf1081de6","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Test public void testGBMTrainTest() {\n    GBMModel gbm = null;\n    try {\n      GBMModel.GBMParameters parms = new GBMModel.GBMParameters();\n      parms._valid = parse_test_file(\"smalldata/gbm_test/ecology_eval.csv\" )._key;\n      Frame  train = parse_test_file(\"smalldata/gbm_test/ecology_model.csv\");\n      parms._train = train._key;\n      train.remove(\"Site\").remove();     // Remove unique ID\n      parms._response_column = \"Angaus\"; // Train on the outcome\n      parms._convert_to_enum = true;\n      parms._ntrees = 5;\n      parms._max_depth = 10;\n      parms._min_rows = 10;\n      parms._nbins = 100;\n      parms._learn_rate = .2f;\n      parms._loss = Family.AUTO;\n\n      GBM job = null;\n      try {\n        job = new GBM(parms);\n        gbm = job.trainModel().get();\n      } finally {\n        if( job != null ) job.remove();\n      }\n\n      double auc = gbm._output._auc.data().AUC();\n      Assert.assertTrue(0.80 <= auc && auc < 0.83); // Sanely good model\n      ConfusionMatrix2 cmf1 = gbm._output._auc.data().CM();\n      Assert.assertArrayEquals(ar(ar(311,82),ar(32,75)),cmf1._arr);\n\n    } finally {\n      if( gbm != null ) {\n        gbm._parms._train.remove();\n        gbm._parms._valid.remove();\n        gbm.delete();\n      }\n    }\n  }","id":99112,"modified_method":"@Test public void testGBMTrainTest() {\n    GBMModel gbm = null;\n    try {\n      GBMModel.GBMParameters parms = new GBMModel.GBMParameters();\n      parms._valid = parse_test_file(\"smalldata/gbm_test/ecology_eval.csv\" )._key;\n      Frame  train = parse_test_file(\"smalldata/gbm_test/ecology_model.csv\");\n      train.remove(\"Site\").remove();     // Remove unique ID\n      DKV.put(train);                    // Update frame after hacking it\n      parms._train = train._key;\n      parms._response_column = \"Angaus\"; // Train on the outcome\n      parms._convert_to_enum = true;\n      parms._ntrees = 5;\n      parms._max_depth = 10;\n      parms._min_rows = 10;\n      parms._nbins = 100;\n      parms._learn_rate = .2f;\n      parms._loss = Family.AUTO;\n\n      GBM job = null;\n      try {\n        job = new GBM(parms);\n        gbm = job.trainModel().get();\n      } finally {\n        if( job != null ) job.remove();\n      }\n\n      double auc = gbm._output._auc.data().AUC();\n      Assert.assertTrue(0.80 <= auc && auc < 0.83); // Sanely good model\n      ConfusionMatrix2 cmf1 = gbm._output._auc.data().CM();\n      Assert.assertArrayEquals(ar(ar(311,82),ar(32,75)),cmf1._arr);\n\n    } finally {\n      if( gbm != null ) {\n        gbm._parms._train.remove();\n        gbm._parms._valid.remove();\n        gbm.delete();\n      }\n    }\n  }","commit_id":"3be08399bc5c87afad22126a541412daf1081de6","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public GBMModel.GBMOutput basicGBM(String fname, PrepData prep, boolean validation, Family family) {\n    GBMModel gbm = null;\n    Frame fr = null, fr2= null, vfr=null;\n    try {\n      fr = parse_test_file(fname);\n      int idx = prep.prep(fr); // hack frame per-test\n      water.DKV.put(fr);       // Update frame after hacking it\n\n      GBMModel.GBMParameters parms = new GBMModel.GBMParameters();\n      if( idx < 0 ) { parms._convert_to_enum = false; idx = ~idx; } else { parms._convert_to_enum = true; }\n      parms._train = fr._key;\n      parms._response_column = fr._names[idx];\n      parms._ntrees = 4;\n      parms._loss = family;\n      parms._max_depth = 4;\n      parms._min_rows = 1;\n      parms._nbins = 50;\n      parms._learn_rate = .2f;\n      parms._score_each_iteration=true;\n      if( validation ) {        // Make a validation frame thats a clone of the training data\n        vfr = new Frame(fr);\n        water.DKV.put(vfr);\n        parms._valid = vfr._key;\n      }\n\n      GBM job = null;\n      try {\n        job = new GBM(parms);\n        gbm = job.trainModel().get();\n      } finally {\n        if( job != null ) job.remove();\n      }\n\n      // Done building model; produce a score column with predictions\n      fr2 = gbm.score(fr);\n\n      Assert.assertTrue(job._state == water.Job.JobState.DONE); //HEX-1817\n      //Assert.assertTrue(gbm._output._state == Job.JobState.DONE); //HEX-1817\n      return gbm._output;\n\n    } finally {\n      if( fr  != null ) fr .remove();\n      if( fr2 != null ) fr2.remove();\n      if( vfr != null ) vfr.remove();\n      if( gbm != null ) gbm.delete();\n    }\n  }","id":99113,"modified_method":"public GBMModel.GBMOutput basicGBM(String fname, PrepData prep, boolean validation, Family family) {\n    GBMModel gbm = null;\n    Frame fr = null, fr2= null, vfr=null;\n    try {\n      fr = parse_test_file(fname);\n      int idx = prep.prep(fr); // hack frame per-test\n      DKV.put(fr);             // Update frame after hacking it\n\n      GBMModel.GBMParameters parms = new GBMModel.GBMParameters();\n      if( idx < 0 ) { parms._convert_to_enum = false; idx = ~idx; } else { parms._convert_to_enum = true; }\n      parms._train = fr._key;\n      parms._response_column = fr._names[idx];\n      parms._ntrees = 4;\n      parms._loss = family;\n      parms._max_depth = 4;\n      parms._min_rows = 1;\n      parms._nbins = 50;\n      parms._learn_rate = .2f;\n      parms._score_each_iteration=true;\n      if( validation ) {        // Make a validation frame thats a clone of the training data\n        vfr = new Frame(fr);\n        DKV.put(vfr);\n        parms._valid = vfr._key;\n      }\n\n      GBM job = null;\n      try {\n        job = new GBM(parms);\n        gbm = job.trainModel().get();\n      } finally {\n        if( job != null ) job.remove();\n      }\n\n      // Done building model; produce a score column with predictions\n      fr2 = gbm.score(fr);\n\n      Assert.assertTrue(job._state == water.Job.JobState.DONE); //HEX-1817\n      //Assert.assertTrue(gbm._output._state == Job.JobState.DONE); //HEX-1817\n      return gbm._output;\n\n    } finally {\n      if( fr  != null ) fr .remove();\n      if( fr2 != null ) fr2.remove();\n      if( vfr != null ) vfr.remove();\n      if( gbm != null ) gbm.delete();\n    }\n  }","commit_id":"3be08399bc5c87afad22126a541412daf1081de6","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/** Read-UnLock both training and validation User frames. */\n    public void unlock_frames( Job job ) { \n      train().unlock(job._key);\n      if( _valid != null && !_train.equals(_valid) )\n        valid().unlock(job._key);\n    }","id":99114,"modified_method":"/** Read-UnLock both training and validation User frames. */\n    public void unlock_frames( Job job ) {\n      Frame tr = train();\n      if( tr != null ) tr.unlock(job._key);\n      if( _valid != null && !_train.equals(_valid) )\n        valid().unlock(job._key);\n    }","commit_id":"3be08399bc5c87afad22126a541412daf1081de6","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public void receive(Message msg) {\n        Request req=(Request)msg.getObject();\n        if(log.isTraceEnabled())\n            log.trace(\"[\" + ch.getAddress() + \"] <-- [\" + msg.getSrc() + \"] \" + req);\n        switch(req.type) {\n            case GRANT_LOCK:\n            case RELEASE_LOCK:\n                handleLockRequest(req);\n                break;\n            case LOCK_GRANTED:\n                handleLockGrantedResponse(req.lock_name, req.owner, msg.getSrc());\n                break;\n            case LOCK_DENIED:\n                handleLockDeniedResponse(req.lock_name, req.owner, msg.getSrc());\n                break;\n            default:\n                log.error(\"Request of type \" + req.type + \" not known\");\n                break;\n        }\n    }","id":99115,"modified_method":"public void receive(Message msg) {\n        Request req=(Request)msg.getObject();\n        if(log.isTraceEnabled())\n            log.trace(\"[\" + ch.getAddress() + \"] <-- [\" + msg.getSrc() + \"] \" + req);\n        switch(req.type) {\n            case GRANT_LOCK:\n            case RELEASE_LOCK:\n                handleLockRequest(req);\n                break;\n            case LOCK_GRANTED:\n                handleLockGrantedResponse(req.lock_name, req.owner, msg.getSrc());\n                break;\n            case LOCK_DENIED:\n                handleLockDeniedResponse(req.lock_name, req.owner);\n                break;\n            default:\n                log.error(\"Request of type \" + req.type + \" not known\");\n                break;\n        }\n    }","commit_id":"c6eabe6ce53e8ec0ece03350291ca56d2a230e4c","url":"https://github.com/belaban/JGroups"},{"original_method":"protected void sendRequest(Address dest, Type type, String lock_name, Owner owner, long timeout, boolean is_trylock) {\n        Request req=new Request(type, lock_name, owner, timeout, is_trylock);\n        Message msg=new Message(null, null, req);\n        if(bypass_bundling)\n            msg.setFlag(Message.DONT_BUNDLE);\n        if(log.isTraceEnabled())\n            log.trace(\"[\" + ch.getAddress() + \"] --> [ALL] \" + req);\n        try {\n            ch.send(msg);\n        }\n        catch(Exception ex) {\n            log.error(\"failed sending \" + type + \" request: \" + ex);\n        }\n    }","id":99116,"modified_method":"protected void sendRequest(Address dest, Type type, String lock_name, Owner owner, long timeout, boolean is_trylock) {\n        Request req=new Request(type, lock_name, owner, timeout, is_trylock);\n        Message msg=new Message(dest, null, req);\n        if(bypass_bundling)\n            msg.setFlag(Message.DONT_BUNDLE);\n        if(log.isTraceEnabled())\n            log.trace(\"[\" + ch.getAddress() + \"] --> [ALL] \" + req);\n        try {\n            ch.send(msg);\n        }\n        catch(Exception ex) {\n            log.error(\"failed sending \" + type + \" request: \" + ex);\n        }\n    }","commit_id":"c6eabe6ce53e8ec0ece03350291ca56d2a230e4c","url":"https://github.com/belaban/JGroups"},{"original_method":"protected void handleLockDeniedResponse(String lock_name, Owner owner, Address sender) {\n         ClientLock lock=getLock(lock_name, owner, false);\n         if(lock != null)\n             lock.lockDenied();\n    }","id":99117,"modified_method":"protected void handleLockDeniedResponse(String lock_name, Owner owner) {\n         ClientLock lock=getLock(lock_name, owner, false);\n         if(lock != null)\n             lock.lockDenied();\n    }","commit_id":"c6eabe6ce53e8ec0ece03350291ca56d2a230e4c","url":"https://github.com/belaban/JGroups"},{"original_method":"protected void sendReleaseLockRequest(String lock_name, Owner owner) {\n        sendRequest(null, Type.RELEASE_LOCK, lock_name, owner, 0, false);\n    }","id":99118,"modified_method":"protected void sendReleaseLockRequest(String lock_name, Owner owner) {\n        if(coord != null)\n            sendRequest(coord, Type.RELEASE_LOCK, lock_name, owner, 0, false);\n    }","commit_id":"c6eabe6ce53e8ec0ece03350291ca56d2a230e4c","url":"https://github.com/belaban/JGroups"},{"original_method":"protected void sendGrantLockRequest(String lock_name, Owner owner, long timeout, boolean is_trylock) {\n        sendRequest(null, Type.GRANT_LOCK, lock_name, owner, timeout, is_trylock);\n    }","id":99119,"modified_method":"protected void sendGrantLockRequest(String lock_name, Owner owner, long timeout, boolean is_trylock) {\n        if(coord != null)\n            sendRequest(coord, Type.GRANT_LOCK, lock_name, owner, timeout, is_trylock);\n    }","commit_id":"c6eabe6ce53e8ec0ece03350291ca56d2a230e4c","url":"https://github.com/belaban/JGroups"},{"original_method":"public void viewAccepted(View view) {\n        super.viewAccepted(view);\n\n    }","id":99120,"modified_method":"public void viewAccepted(View view) {\n        super.viewAccepted(view);\n        if(view.size() > 0) {\n            coord=view.getMembers().firstElement();\n            is_coord=coord.equals(ch.getAddress());\n            if(log.isDebugEnabled())\n                log.debug(\"local_addr=\" + ch.getAddress() + \", coord=\" + coord + \", is_coord=\" + is_coord);\n        }\n    }","commit_id":"c6eabe6ce53e8ec0ece03350291ca56d2a230e4c","url":"https://github.com/belaban/JGroups"},{"original_method":"protected static void help() {\n        System.out.println(\"\\nLockServiceDemo [-props properties] [-name name]\\n\" +\n                             \"Valid commands:\\n\\n\" +\n                             \"lock (<lock name>)+\\n\" +\n                             \"unlock (<lock name> | \\\"ALL\\\")+\\n\" +\n                             \"trylock (<lock name>)+ [<timeout>]\\n\");\n        System.out.println(\"Example:\\nlock lock lock2 lock3\\nunlock all\\ntrylock bela michelle 300\");\n    }","id":99121,"modified_method":"protected static void help() {\n        System.out.println(\"\\nLockServiceDemo [-props properties] [-name name] [-peer]\\n\" +\n                             \"Valid commands:\\n\\n\" +\n                             \"lock (<lock name>)+\\n\" +\n                             \"unlock (<lock name> | \\\"ALL\\\")+\\n\" +\n                             \"trylock (<lock name>)+ [<timeout>]\\n\");\n        System.out.println(\"Example:\\nlock lock lock2 lock3\\nunlock all\\ntrylock bela michelle 300\");\n    }","commit_id":"c6eabe6ce53e8ec0ece03350291ca56d2a230e4c","url":"https://github.com/belaban/JGroups"},{"original_method":"public static void main(String[] args) throws ChannelException {\n        String props=null;\n        String name=null;\n        for(int i=0; i < args.length; i++) {\n            if(args[i].equals(\"-props\")) {\n                props=args[++i];\n                continue;\n            }\n            if(args[i].equals(\"-name\")) {\n                name=args[++i];\n                continue;\n            }\n            help();\n            return;\n        }\n\n        LockServiceDemo demo=new LockServiceDemo(props, name);\n        demo.start();\n    }","id":99122,"modified_method":"public static void main(String[] args) throws ChannelException {\n        String props=null;\n        String name=null;\n        boolean peer=false;\n\n        for(int i=0; i < args.length; i++) {\n            if(args[i].equals(\"-props\")) {\n                props=args[++i];\n                continue;\n            }\n            if(args[i].equals(\"-name\")) {\n                name=args[++i];\n                continue;\n            }\n            if(args[i].equals(\"-peer\")) {\n                peer=true;\n                continue;\n            }\n            help();\n            return;\n        }\n\n        LockServiceDemo demo=new LockServiceDemo(props, name);\n        demo.start(peer);\n    }","commit_id":"c6eabe6ce53e8ec0ece03350291ca56d2a230e4c","url":"https://github.com/belaban/JGroups"},{"original_method":"protected void loop() throws Exception {\n        List<String> lock_names;\n        while(ch.isConnected()) {\n            String line=Util.readStringFromStdin(\": \");\n            if(line.startsWith(\"quit\") || line.startsWith(\"exit\"))\n                break;\n\n            if(line.startsWith(\"lock\")) {\n                lock_names=parseLockNames(line.substring(\"lock\".length()).trim());\n                for(String lock_name: lock_names) {\n                    Lock lock=lock_service.getLock(lock_name);\n                    lock.lock();\n                }\n            }\n            else  if(line.startsWith(\"trylock\")) {\n                lock_names=parseLockNames(line.substring(\"trylock\".length()).trim());\n\n                String tmp=lock_names.get(lock_names.size() -1);\n                Long timeout=new Long(-1);\n                try {\n                    timeout=Long.parseLong(tmp);\n                    lock_names.remove(lock_names.size() -1);\n                }\n                catch(NumberFormatException e) {\n                }\n\n                for(String lock_name: lock_names) {\n                    Lock lock=lock_service.getLock(lock_name);\n                    boolean rc;\n                    if(timeout.longValue() < 0)\n                        rc=lock.tryLock();\n                    else\n                        rc=lock.tryLock(timeout.longValue(), TimeUnit.MILLISECONDS);\n                    if(!rc)\n                        System.err.println(\"Failed locking \\\"\" + lock_name + \"\\\"\");\n                }\n            }\n            else if(line.startsWith(\"unlock\")) {\n                lock_names=parseLockNames(line.substring(\"unlock\".length()).trim());\n                for(String lock_name: lock_names) {\n                    if(lock_name.equalsIgnoreCase(\"all\")) {\n                        lock_service.unlockAll();\n                        break;\n                    }\n                    else {\n                        Lock lock=lock_service.getLock(lock_name);\n                        lock.unlock();\n                    }\n                }\n            }\n            else if(line.startsWith(\"view\"))\n                System.out.println(\"View: \" + ch.getView());\n            else if(line.startsWith(\"help\"))\n                help();\n            printLocks();\n        }\n    }","id":99123,"modified_method":"protected void loop() throws Exception {\n        List<String> lock_names;\n        while(ch.isConnected()) {\n            String line=Util.readStringFromStdin(\": \");\n            if(line.startsWith(\"quit\") || line.startsWith(\"exit\"))\n                break;\n\n            if(line.startsWith(\"lock\")) {\n                lock_names=parseLockNames(line.substring(\"lock\".length()).trim());\n                for(String lock_name: lock_names) {\n                    Lock lock=lock_service.getLock(lock_name);\n                    lock.lock();\n                }\n            }\n            else  if(line.startsWith(\"trylock\")) {\n                lock_names=parseLockNames(line.substring(\"trylock\".length()).trim());\n\n                String tmp=lock_names.get(lock_names.size() -1);\n                Long timeout=new Long(-1);\n                try {\n                    timeout=Long.parseLong(tmp);\n                    lock_names.remove(lock_names.size() -1);\n                }\n                catch(NumberFormatException e) {\n                }\n\n                for(String lock_name: lock_names) {\n                    Lock lock=lock_service.getLock(lock_name);\n                    boolean rc;\n                    if(timeout.longValue() < 0)\n                        rc=lock.tryLock();\n                    else\n                        rc=lock.tryLock(timeout.longValue(), TimeUnit.MILLISECONDS);\n                    if(!rc)\n                        System.err.println(\"Failed locking \\\"\" + lock_name + \"\\\"\");\n                }\n            }\n            else if(line.startsWith(\"unlock\")) {\n                lock_names=parseLockNames(line.substring(\"unlock\".length()).trim());\n                for(String lock_name: lock_names) {\n                    if(lock_name.equalsIgnoreCase(\"all\")) {\n                        lock_service.unlockAll();\n                        break;\n                    }\n                    else {\n                        Lock lock=lock_service.getLock(lock_name, false);\n                        if(lock != null)\n                            lock.unlock();\n                    }\n                }\n            }\n            else if(line.startsWith(\"view\"))\n                System.out.println(\"View: \" + ch.getView());\n            else if(line.startsWith(\"help\"))\n                help();\n            printLocks();\n        }\n    }","commit_id":"c6eabe6ce53e8ec0ece03350291ca56d2a230e4c","url":"https://github.com/belaban/JGroups"},{"original_method":"@Override\n    public void install() {\n        DownloadResolver resolver = Entities.newDownloader(this);\n        List<String> urls = resolver.getTargets();\n        String saveAs = resolver.getFilename();\n        setExpandedInstallDir(getInstallDir()+\"/\"+resolver.getUnpackedDirectoryName(format(\"zookeeper-%s\", getVersion())));\n\n        List<String> commands = ImmutableList.<String> builder()\n                .addAll(BashCommands.commandsToDownloadUrlsAs(urls, saveAs))\n                .add(BashCommands.INSTALL_CURL)\n                .add(BashCommands.INSTALL_TAR)\n                 .add(\"tar xzfv \" + saveAs)\n                .build();\n\n        newScript(INSTALLING)\n                .failOnNonZeroResultCode()\n                .body.append(commands)\n                .execute();        \n    }","id":99124,"modified_method":"@Override\n    public void install() {\n        DownloadResolver resolver = Entities.newDownloader(this);\n        List<String> urls = resolver.getTargets();\n        String saveAs = resolver.getFilename();\n        setExpandedInstallDir(getInstallDir()+\"/\"+resolver.getUnpackedDirectoryName(format(\"zookeeper-%s\", getVersion())));\n\n        List<String> commands = ImmutableList.<String> builder()\n                .addAll(BashCommands.commandsToDownloadUrlsAs(urls, saveAs))\n                .add(BashCommands.INSTALL_TAR)\n                .add(\"tar xzfv \" + saveAs)\n                .build();\n\n        newScript(INSTALLING)\n                .failOnNonZeroResultCode()\n                .body.append(commands)\n                .execute();\n    }","commit_id":"a4e5c8c742a1c21a3208744520a9a79f4c70919f","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public List<ZooKeeperServerConfig> getZookeeperServers() throws ExecutionException, InterruptedException {\n      ZooKeeperEnsemble ensemble = (ZooKeeperEnsemble) entity.getParent();\n      List<ZooKeeperServerConfig> result = Lists.newArrayList();\n\n      for (Entity member : ensemble.getMembers()) {\n         ZooKeeperNode server = (ZooKeeperNode) member;\n         Integer myid = attributeWhenReady(server, ZooKeeperNode.MY_ID);\n         String hostname = attributeWhenReady(server, ZooKeeperNode.HOSTNAME);\n         Integer port = attributeWhenReady(server, ZooKeeperNode.ZOOKEEPER_PORT);\n         Integer leaderPort = attributeWhenReady(server, ZooKeeperNode.ZOOKEEPER_LEADER_PORT);\n         Integer electionPort = attributeWhenReady(server, ZooKeeperNode.ZOOKEEPER_ELECTION_PORT);\n         result.add(new ZooKeeperServerConfig(myid, hostname, port, leaderPort, electionPort));\n      }\n      return result;\n   }","id":99125,"modified_method":"public List<ZooKeeperServerConfig> getZookeeperServers() throws ExecutionException, InterruptedException {\n      ZooKeeperEnsemble ensemble = (ZooKeeperEnsemble) entity.getParent();\n      List<ZooKeeperServerConfig> result = Lists.newArrayList();\n\n      for (Entity member : ensemble.getMembers()) {\n         Integer myid = Entities.attributeSupplierWhenReady(member, ZooKeeperNode.MY_ID).get();\n         String hostname = Entities.attributeSupplierWhenReady(member, ZooKeeperNode.HOSTNAME).get();\n         Integer port = Entities.attributeSupplierWhenReady(member, ZooKeeperNode.ZOOKEEPER_PORT).get();\n         Integer leaderPort = Entities.attributeSupplierWhenReady(member, ZooKeeperNode.ZOOKEEPER_LEADER_PORT).get();\n         Integer electionPort = Entities.attributeSupplierWhenReady(member, ZooKeeperNode.ZOOKEEPER_ELECTION_PORT).get();\n         result.add(new ZooKeeperServerConfig(myid, hostname, port, leaderPort, electionPort));\n      }\n      return result;\n   }","commit_id":"a4e5c8c742a1c21a3208744520a9a79f4c70919f","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"private <T extends ListableObjectStore<? extends Serializable>> T getBaseStore(boolean persistent)\n    {\n        T baseStore;\n        if (persistent)\n        {\n            baseStore = (T) muleContext.getRegistry().lookupObject(\n                MuleProperties.OBJECT_STORE_DEFAULT_PERSISTENT_NAME);\n        }\n        else\n        {\n            baseStore = (T) muleContext.getRegistry().lookupObject(\n                MuleProperties.OBJECT_STORE_DEFAULT_IN_MEMORY_NAME);\n        }\n        return baseStore;\n    }","id":99126,"modified_method":"private <T extends ListableObjectStore<? extends Serializable>> T getBaseStore(boolean persistent)\n    {\n        T baseStore;\n        if (persistent)\n        {\n            baseStore = muleContext.getRegistry().lookupObject(\n                    this.basePersistentStoreKey);\n        }\n        else\n        {\n            baseStore = muleContext.getRegistry().lookupObject(\n                    this.baseTransientStoreKey);\n        }\n        return baseStore;\n    }","commit_id":"3be4e55eb7158db05f03d9f2671ef7b7a9a6a3ec","url":"https://github.com/mulesoft/mule"},{"original_method":"private <T extends ListableObjectStore<? extends Serializable>> T getBaseUserStore(boolean persistent)\n    {\n        T baseStore;\n        if (persistent)\n        {\n            baseStore = (T) muleContext.getRegistry().lookupObject(\n                MuleProperties.DEFAULT_USER_OBJECT_STORE_NAME);\n        }\n        else\n        {\n            baseStore = (T) muleContext.getRegistry().lookupObject(\n                MuleProperties.DEFAULT_USER_TRANSIENT_OBJECT_STORE_NAME);\n        }\n        return baseStore;\n    }","id":99127,"modified_method":"private <T extends ListableObjectStore<? extends Serializable>> T getBaseUserStore(boolean persistent)\n    {\n        T baseStore;\n        if (persistent)\n        {\n            baseStore = muleContext.getRegistry().lookupObject(\n                    this.basePersistentUserStoreKey);\n        }\n        else\n        {\n            baseStore = muleContext.getRegistry().lookupObject(\n                    this.baseTransientUserStoreKey);\n        }\n        return baseStore;\n    }","commit_id":"3be4e55eb7158db05f03d9f2671ef7b7a9a6a3ec","url":"https://github.com/mulesoft/mule"},{"original_method":"public void loadRep(Repository rep, long id_jobentry, ArrayList databases)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tsuper.loadRep(rep, id_jobentry, databases);\n\t\t\txmlfilename = rep.getJobEntryAttributeString(id_jobentry, \"xmlfilename\");\n\t\t\txslfilename = rep.getJobEntryAttributeString(id_jobentry, \"xslfilename\");\n\t\t\toutputfilename = rep.getJobEntryAttributeString(id_jobentry, \"outputfilename\");\n\t\t\tiffileexists=Const.toInt(rep.getJobEntryAttributeString(id_jobentry, \"iffileexists\"),-1);\n\t\t\t\n\n\n\n\t\t}\n\t\tcatch(KettleException dbe)\n\t\t{\n\t\t\tthrow new KettleException(\"Unable to load job entry of type 'xslt' from the repository for id_jobentry=\"+id_jobentry, dbe);\n\t\t}\n\t}","id":99128,"modified_method":"public void loadRep(Repository rep, long id_jobentry, ArrayList databases)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tsuper.loadRep(rep, id_jobentry, databases);\n\t\t\txmlfilename = rep.getJobEntryAttributeString(id_jobentry, \"xmlfilename\");\n\t\t\txslfilename = rep.getJobEntryAttributeString(id_jobentry, \"xslfilename\");\n\t\t\toutputfilename = rep.getJobEntryAttributeString(id_jobentry, \"outputfilename\");\n\t\t\tiffileexists=(int) rep.getJobEntryAttributeInteger(id_jobentry, \"iffileexists\");\n\t\t\t\n\n\n\n\t\t}\n\t\tcatch(KettleException dbe)\n\t\t{\n\t\t\tthrow new KettleException(\"Unable to load job entry of type 'xslt' from the repository for id_jobentry=\"+id_jobentry, dbe);\n\t\t}\n\t}","commit_id":"0573df515bcb9f50f5823a1d86bfc5f171bbe760","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public JobEntryInterface open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n        shell = new Shell(parent, props.getJobsDialogStyle());\n        props.setLook(shell);\n        JobDialog.setShellImage(shell, jobEntry);\n\n\t\tModifyListener lsMod = new ModifyListener()\n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t{\n\t\t\t\tjobEntry.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = jobEntry.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"JobEntryXSLT.Title\"));\n\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Name line\n\t\twlName=new Label(shell, SWT.RIGHT);\n\t\twlName.setText(Messages.getString(\"JobEntryXSLT.Name.Label\"));\n \t\tprops.setLook(wlName);\n\t\tfdlName=new FormData();\n\t\tfdlName.left = new FormAttachment(0, 0);\n\t\tfdlName.right= new FormAttachment(middle, -margin);\n\t\tfdlName.top  = new FormAttachment(0, margin);\n\t\twlName.setLayoutData(fdlName);\n\t\twName=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wName);\n\t\twName.addModifyListener(lsMod);\n\t\tfdName=new FormData();\n\t\tfdName.left = new FormAttachment(middle, 0);\n\t\tfdName.top  = new FormAttachment(0, margin);\n\t\tfdName.right= new FormAttachment(100, 0);\n\t\twName.setLayoutData(fdName);\n\n\t\t// Filename 1 line\n\t\twlxmlFilename=new Label(shell, SWT.RIGHT);\n\t\twlxmlFilename.setText(Messages.getString(\"JobEntryXSLT.xmlFilename.Label\"));\n \t\tprops.setLook(wlxmlFilename);\n\t\tfdlxmlFilename=new FormData();\n\t\tfdlxmlFilename.left = new FormAttachment(0, 0);\n\t\tfdlxmlFilename.top  = new FormAttachment(wName, margin);\n\t\tfdlxmlFilename.right= new FormAttachment(middle, -margin);\n\t\twlxmlFilename.setLayoutData(fdlxmlFilename);\n\t\twbxmlFilename=new Button(shell, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbxmlFilename);\n\t\twbxmlFilename.setText(Messages.getString(\"System.Button.Browse\"));\n\t\tfdbxmlFilename=new FormData();\n\t\tfdbxmlFilename.right= new FormAttachment(100, 0);\n\t\tfdbxmlFilename.top  = new FormAttachment(wName, 0);\n\t\twbxmlFilename.setLayoutData(fdbxmlFilename);\n\t\twxmlFilename=new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wxmlFilename);\n\t\twxmlFilename.addModifyListener(lsMod);\n\t\tfdxmlFilename=new FormData();\n\t\tfdxmlFilename.left = new FormAttachment(middle, 0);\n\t\tfdxmlFilename.top  = new FormAttachment(wName, margin);\n\t\tfdxmlFilename.right= new FormAttachment(wbxmlFilename, -margin);\n\t\twxmlFilename.setLayoutData(fdxmlFilename);\n\n\t\t// Whenever something changes, set the tooltip to the expanded version:\n\t\twxmlFilename.addModifyListener(new ModifyListener()\n\t\t\t{\n\t\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t\t{\n\t\t\t\t\twxmlFilename.setToolTipText(StringUtil.environmentSubstitute( wxmlFilename.getText() ) );\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\twbxmlFilename.addSelectionListener\n\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t\t{\n\t\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\n\t\t\t\t\tdialog.setFilterExtensions(new String[] {\"*.xml;*.XML\", \"*\"});\n\t\t\t\t\tif (wxmlFilename.getText()!=null)\n\t\t\t\t\t{\n\t\t\t\t\t\tdialog.setFileName(StringUtil.environmentSubstitute(wxmlFilename.getText()) );\n\t\t\t\t\t}\n\t\t\t\t\tdialog.setFilterNames(FILETYPES_XML);\n\t\t\t\t\tif (dialog.open()!=null)\n\t\t\t\t\t{\n\t\t\t\t\t\twxmlFilename.setText(dialog.getFilterPath()+Const.FILE_SEPARATOR+dialog.getFileName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// Filename 2 line\n\t\twlxslFilename=new Label(shell, SWT.RIGHT);\n\t\twlxslFilename.setText(Messages.getString(\"JobEntryXSLT.xslFilename.Label\"));\n \t\tprops.setLook(wlxslFilename);\n\t\tfdlxslFilename=new FormData();\n\t\tfdlxslFilename.left = new FormAttachment(0, 0);\n\t\tfdlxslFilename.top  = new FormAttachment(wxmlFilename, margin);\n\t\tfdlxslFilename.right= new FormAttachment(middle, -margin);\n\t\twlxslFilename.setLayoutData(fdlxslFilename);\n\t\twbxslFilename=new Button(shell, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbxslFilename);\n\t\twbxslFilename.setText(Messages.getString(\"System.Button.Browse\"));\n\t\tfdbxslFilename=new FormData();\n\t\tfdbxslFilename.right= new FormAttachment(100, 0);\n\t\tfdbxslFilename.top  = new FormAttachment(wxmlFilename, 0);\n\t\twbxslFilename.setLayoutData(fdbxslFilename);\n\t\twxslFilename=new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wxslFilename);\n\t\twxslFilename.addModifyListener(lsMod);\n\t\tfdxslFilename=new FormData();\n\t\tfdxslFilename.left = new FormAttachment(middle, 0);\n\t\tfdxslFilename.top  = new FormAttachment(wxmlFilename, margin);\n\t\tfdxslFilename.right= new FormAttachment(wbxslFilename, -margin);\n\t\twxslFilename.setLayoutData(fdxslFilename);\n\n\t\t// Whenever something changes, set the tooltip to the expanded version:\n\t\twxslFilename.addModifyListener(new ModifyListener()\n\t\t\t{\n\t\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t\t{\n\t\t\t\t\twxslFilename.setToolTipText(StringUtil.environmentSubstitute( wxslFilename.getText() ) );\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\twbxslFilename.addSelectionListener\n\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t\t{\n\t\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\n\t\t\t\t\tdialog.setFilterExtensions(new String[] {\"*.xsl;*.XSL\", \"*\"});\n\t\t\t\t\tif (wxslFilename.getText()!=null)\n\t\t\t\t\t{\n\t\t\t\t\t\tdialog.setFileName(StringUtil.environmentSubstitute(wxslFilename.getText()) );\n\t\t\t\t\t}\n\t\t\t\t\tdialog.setFilterNames(FILETYPES_XSL);\n\t\t\t\t\tif (dialog.open()!=null)\n\t\t\t\t\t{\n\t\t\t\t\t\twxslFilename.setText(dialog.getFilterPath()+Const.FILE_SEPARATOR+dialog.getFileName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\n\n\t\n\t\n\t\t// OutputFilename\n\t\twlOutputFilename = new Label(shell, SWT.RIGHT);\n\t\twlOutputFilename.setText(Messages.getString(\"JobEntryXSLT.OutputFilename.Label\"));\n\t\tprops.setLook(wlOutputFilename);\n\t\tfdlOutputFilename = new FormData();\n\t\tfdlOutputFilename.left = new FormAttachment(0, 0);\n\t\tfdlOutputFilename.top = new FormAttachment(wxslFilename, margin);\n\t\tfdlOutputFilename.right = new FormAttachment(middle, -margin);\n\t\twlOutputFilename.setLayoutData(fdlOutputFilename);\n\t\twOutputFilename = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wOutputFilename);\n\t\twOutputFilename.addModifyListener(lsMod);\n\t\tfdOutputFilename = new FormData();\n\t\tfdOutputFilename.left = new FormAttachment(middle, 0);\n\t\tfdOutputFilename.top = new FormAttachment(wxslFilename, margin);\n\t\tfdOutputFilename.right = new FormAttachment(100, 0);\n\t\twOutputFilename.setLayoutData(fdOutputFilename);\n\n\n\n\t\t// Whenever something changes, set the tooltip to the expanded version:\n\t\twOutputFilename.addModifyListener(new ModifyListener()\n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t{\n\t\t\t\twOutputFilename.setToolTipText(StringUtil.environmentSubstitute( wOutputFilename.getText() ) );\n\t\t\t}\n\t\t}\n\t\t\t);\n\n\t\t\n\n\t\t//IF File Exists\n\t\twlIfFileExists = new Label(shell, SWT.RIGHT);\n\t\twlIfFileExists.setText(Messages.getString(\"JobEntryXSLT.IfZipFileExists.Label\"));\n\t\tprops.setLook(wlIfFileExists);\n\t\tfdlIfFileExists = new FormData();\n\t\tfdlIfFileExists.left = new FormAttachment(0, 0);\n\t\tfdlIfFileExists.right = new FormAttachment(middle, 0);\n\t\tfdlIfFileExists.top = new FormAttachment(wOutputFilename, margin);\n\t\twlIfFileExists.setLayoutData(fdlIfFileExists);\n\t\twIfFileExists = new CCombo(shell, SWT.SINGLE | SWT.READ_ONLY | SWT.BORDER);\n\t\twIfFileExists.add(Messages.getString(\"JobEntryXSLT.Create_NewFile_IfFileExists.Label\"));\n\t\twIfFileExists.add(Messages.getString(\"JobEntryXSLT.Do_Nothing_IfFileExists.Label\"));\n\t\twIfFileExists.add(Messages.getString(\"JobEntryXSLT.Fail_IfFileExists.Label\"));\n\t\twIfFileExists.select(1); // +1: starts at -1\n\n\t\tprops.setLook(wIfFileExists);\n\t\tfdIfFileExists= new FormData();\n\t\tfdIfFileExists.left = new FormAttachment(middle, 0);\n\t\tfdIfFileExists.top = new FormAttachment(wOutputFilename, margin);\n\t\tfdIfFileExists.right = new FormAttachment(100, 0);\n\t\twIfFileExists.setLayoutData(fdIfFileExists);\n\n\t\tfdIfFileExists = new FormData();\n\t\tfdIfFileExists.left = new FormAttachment(middle, 0);\n\t\tfdIfFileExists.top = new FormAttachment(wOutputFilename, margin);\n\t\tfdIfFileExists.right = new FormAttachment(100, 0);\n\t\twIfFileExists.setLayoutData(fdIfFileExists);\n\n\n        wOK = new Button(shell, SWT.PUSH);\n        wOK.setText(Messages.getString(\"System.Button.OK\"));\n        wCancel = new Button(shell, SWT.PUSH);\n        wCancel.setText(Messages.getString(\"System.Button.Cancel\"));\n\n\t\tBaseStepDialog.positionBottomButtons(shell, new Button[] { wOK, wCancel }, margin, wIfFileExists);\n\n\t\t// Add listeners\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel(); } };\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();     } };\n\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\n\t\twName.addSelectionListener( lsDef );\n\t\twxmlFilename.addSelectionListener( lsDef );\n\t\twxslFilename.addSelectionListener( lsDef );\n\n\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\tgetData();\n\n\t\tBaseStepDialog.setSize(shell);\n\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn jobEntry;\n\t}","id":99129,"modified_method":"public JobEntryInterface open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n        shell = new Shell(parent, props.getJobsDialogStyle());\n        props.setLook(shell);\n        JobDialog.setShellImage(shell, jobEntry);\n\n\t\tModifyListener lsMod = new ModifyListener()\n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t{\n\t\t\t\tjobEntry.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = jobEntry.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"JobEntryXSLT.Title\"));\n\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Name line\n\t\twlName=new Label(shell, SWT.RIGHT);\n\t\twlName.setText(Messages.getString(\"JobEntryXSLT.Name.Label\"));\n \t\tprops.setLook(wlName);\n\t\tfdlName=new FormData();\n\t\tfdlName.left = new FormAttachment(0, 0);\n\t\tfdlName.right= new FormAttachment(middle, -margin);\n\t\tfdlName.top  = new FormAttachment(0, margin);\n\t\twlName.setLayoutData(fdlName);\n\t\twName=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wName);\n\t\twName.addModifyListener(lsMod);\n\t\tfdName=new FormData();\n\t\tfdName.left = new FormAttachment(middle, 0);\n\t\tfdName.top  = new FormAttachment(0, margin);\n\t\tfdName.right= new FormAttachment(100, 0);\n\t\twName.setLayoutData(fdName);\n\n\t\t// Filename 1 line\n\t\twlxmlFilename=new Label(shell, SWT.RIGHT);\n\t\twlxmlFilename.setText(Messages.getString(\"JobEntryXSLT.xmlFilename.Label\"));\n \t\tprops.setLook(wlxmlFilename);\n\t\tfdlxmlFilename=new FormData();\n\t\tfdlxmlFilename.left = new FormAttachment(0, 0);\n\t\tfdlxmlFilename.top  = new FormAttachment(wName, margin);\n\t\tfdlxmlFilename.right= new FormAttachment(middle, -margin);\n\t\twlxmlFilename.setLayoutData(fdlxmlFilename);\n\t\twbxmlFilename=new Button(shell, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbxmlFilename);\n\t\twbxmlFilename.setText(Messages.getString(\"System.Button.Browse\"));\n\t\tfdbxmlFilename=new FormData();\n\t\tfdbxmlFilename.right= new FormAttachment(100, 0);\n\t\tfdbxmlFilename.top  = new FormAttachment(wName, 0);\n\t\twbxmlFilename.setLayoutData(fdbxmlFilename);\n\t\twxmlFilename=new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wxmlFilename);\n\t\twxmlFilename.addModifyListener(lsMod);\n\t\tfdxmlFilename=new FormData();\n\t\tfdxmlFilename.left = new FormAttachment(middle, 0);\n\t\tfdxmlFilename.top  = new FormAttachment(wName, margin);\n\t\tfdxmlFilename.right= new FormAttachment(wbxmlFilename, -margin);\n\t\twxmlFilename.setLayoutData(fdxmlFilename);\n\n\t\t// Whenever something changes, set the tooltip to the expanded version:\n\t\twxmlFilename.addModifyListener(new ModifyListener()\n\t\t\t{\n\t\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t\t{\n\t\t\t\t\twxmlFilename.setToolTipText(StringUtil.environmentSubstitute( wxmlFilename.getText() ) );\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\twbxmlFilename.addSelectionListener\n\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t\t{\n\t\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\n\t\t\t\t\tdialog.setFilterExtensions(new String[] {\"*.xml;*.XML\", \"*\"});\n\t\t\t\t\tif (wxmlFilename.getText()!=null)\n\t\t\t\t\t{\n\t\t\t\t\t\tdialog.setFileName(StringUtil.environmentSubstitute(wxmlFilename.getText()) );\n\t\t\t\t\t}\n\t\t\t\t\tdialog.setFilterNames(FILETYPES_XML);\n\t\t\t\t\tif (dialog.open()!=null)\n\t\t\t\t\t{\n\t\t\t\t\t\twxmlFilename.setText(dialog.getFilterPath()+Const.FILE_SEPARATOR+dialog.getFileName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// Filename 2 line\n\t\twlxslFilename=new Label(shell, SWT.RIGHT);\n\t\twlxslFilename.setText(Messages.getString(\"JobEntryXSLT.xslFilename.Label\"));\n \t\tprops.setLook(wlxslFilename);\n\t\tfdlxslFilename=new FormData();\n\t\tfdlxslFilename.left = new FormAttachment(0, 0);\n\t\tfdlxslFilename.top  = new FormAttachment(wxmlFilename, margin);\n\t\tfdlxslFilename.right= new FormAttachment(middle, -margin);\n\t\twlxslFilename.setLayoutData(fdlxslFilename);\n\t\twbxslFilename=new Button(shell, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbxslFilename);\n\t\twbxslFilename.setText(Messages.getString(\"System.Button.Browse\"));\n\t\tfdbxslFilename=new FormData();\n\t\tfdbxslFilename.right= new FormAttachment(100, 0);\n\t\tfdbxslFilename.top  = new FormAttachment(wxmlFilename, 0);\n\t\twbxslFilename.setLayoutData(fdbxslFilename);\n\t\twxslFilename=new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wxslFilename);\n\t\twxslFilename.addModifyListener(lsMod);\n\t\tfdxslFilename=new FormData();\n\t\tfdxslFilename.left = new FormAttachment(middle, 0);\n\t\tfdxslFilename.top  = new FormAttachment(wxmlFilename, margin);\n\t\tfdxslFilename.right= new FormAttachment(wbxslFilename, -margin);\n\t\twxslFilename.setLayoutData(fdxslFilename);\n\n\t\t// Whenever something changes, set the tooltip to the expanded version:\n\t\twxslFilename.addModifyListener(new ModifyListener()\n\t\t\t{\n\t\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t\t{\n\t\t\t\t\twxslFilename.setToolTipText(StringUtil.environmentSubstitute( wxslFilename.getText() ) );\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\twbxslFilename.addSelectionListener\n\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t\t{\n\t\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\n\t\t\t\t\tdialog.setFilterExtensions(new String[] {\"*.xsl;*.XSL\", \"*.xslt;*.XSLT\", \"*\"});\n\t\t\t\t\tif (wxslFilename.getText()!=null)\n\t\t\t\t\t{\n\t\t\t\t\t\tdialog.setFileName(StringUtil.environmentSubstitute(wxslFilename.getText()) );\n\t\t\t\t\t}\n\t\t\t\t\tdialog.setFilterNames(FILETYPES_XSL);\n\t\t\t\t\tif (dialog.open()!=null)\n\t\t\t\t\t{\n\t\t\t\t\t\twxslFilename.setText(dialog.getFilterPath()+Const.FILE_SEPARATOR+dialog.getFileName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\n\n\t\n\t\n\t\t// OutputFilename\n\t\twlOutputFilename = new Label(shell, SWT.RIGHT);\n\t\twlOutputFilename.setText(Messages.getString(\"JobEntryXSLT.OutputFilename.Label\"));\n\t\tprops.setLook(wlOutputFilename);\n\t\tfdlOutputFilename = new FormData();\n\t\tfdlOutputFilename.left = new FormAttachment(0, 0);\n\t\tfdlOutputFilename.top = new FormAttachment(wxslFilename, margin);\n\t\tfdlOutputFilename.right = new FormAttachment(middle, -margin);\n\t\twlOutputFilename.setLayoutData(fdlOutputFilename);\n\t\twOutputFilename = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wOutputFilename);\n\t\twOutputFilename.addModifyListener(lsMod);\n\t\tfdOutputFilename = new FormData();\n\t\tfdOutputFilename.left = new FormAttachment(middle, 0);\n\t\tfdOutputFilename.top = new FormAttachment(wxslFilename, margin);\n\t\tfdOutputFilename.right = new FormAttachment(100, 0);\n\t\twOutputFilename.setLayoutData(fdOutputFilename);\n\n\n\n\t\t// Whenever something changes, set the tooltip to the expanded version:\n\t\twOutputFilename.addModifyListener(new ModifyListener()\n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t{\n\t\t\t\twOutputFilename.setToolTipText(StringUtil.environmentSubstitute( wOutputFilename.getText() ) );\n\t\t\t}\n\t\t}\n\t\t\t);\n\n\t\t\n\n\t\t//IF File Exists\n\t\twlIfFileExists = new Label(shell, SWT.RIGHT);\n\t\twlIfFileExists.setText(Messages.getString(\"JobEntryXSLT.IfZipFileExists.Label\"));\n\t\tprops.setLook(wlIfFileExists);\n\t\tfdlIfFileExists = new FormData();\n\t\tfdlIfFileExists.left = new FormAttachment(0, 0);\n\t\tfdlIfFileExists.right = new FormAttachment(middle, 0);\n\t\tfdlIfFileExists.top = new FormAttachment(wOutputFilename, margin);\n\t\twlIfFileExists.setLayoutData(fdlIfFileExists);\n\t\twIfFileExists = new CCombo(shell, SWT.SINGLE | SWT.READ_ONLY | SWT.BORDER);\n\t\twIfFileExists.add(Messages.getString(\"JobEntryXSLT.Create_NewFile_IfFileExists.Label\"));\n\t\twIfFileExists.add(Messages.getString(\"JobEntryXSLT.Do_Nothing_IfFileExists.Label\"));\n\t\twIfFileExists.add(Messages.getString(\"JobEntryXSLT.Fail_IfFileExists.Label\"));\n\t\twIfFileExists.select(1); // +1: starts at -1\n\n\t\tprops.setLook(wIfFileExists);\n\t\tfdIfFileExists= new FormData();\n\t\tfdIfFileExists.left = new FormAttachment(middle, 0);\n\t\tfdIfFileExists.top = new FormAttachment(wOutputFilename, margin);\n\t\tfdIfFileExists.right = new FormAttachment(100, 0);\n\t\twIfFileExists.setLayoutData(fdIfFileExists);\n\n\t\tfdIfFileExists = new FormData();\n\t\tfdIfFileExists.left = new FormAttachment(middle, 0);\n\t\tfdIfFileExists.top = new FormAttachment(wOutputFilename, margin);\n\t\tfdIfFileExists.right = new FormAttachment(100, 0);\n\t\twIfFileExists.setLayoutData(fdIfFileExists);\n\n\n        wOK = new Button(shell, SWT.PUSH);\n        wOK.setText(Messages.getString(\"System.Button.OK\"));\n        wCancel = new Button(shell, SWT.PUSH);\n        wCancel.setText(Messages.getString(\"System.Button.Cancel\"));\n\n\t\tBaseStepDialog.positionBottomButtons(shell, new Button[] { wOK, wCancel }, margin, wIfFileExists);\n\n\t\t// Add listeners\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel(); } };\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();     } };\n\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\n\t\twName.addSelectionListener( lsDef );\n\t\twxmlFilename.addSelectionListener( lsDef );\n\t\twxslFilename.addSelectionListener( lsDef );\n\n\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\tgetData();\n\n\t\tBaseStepDialog.setSize(shell);\n\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn jobEntry;\n\t}","commit_id":"0573df515bcb9f50f5823a1d86bfc5f171bbe760","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void loadRep(Repository rep, long id_jobentry, ArrayList databases)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tsuper.loadRep(rep, id_jobentry, databases);\n\t\t\tschemaname  = rep.getJobEntryAttributeString(id_jobentry, \"schemaname\");\n\t\t\ttablename  = rep.getJobEntryAttributeString(id_jobentry, \"tablename\");\n\t\t\tfilename  = rep.getJobEntryAttributeString(id_jobentry, \"filename\");\n\t\t\tseparator  = rep.getJobEntryAttributeString(id_jobentry, \"separator\");\n\t\t\tenclosed  = rep.getJobEntryAttributeString(id_jobentry, \"enclosed\");\n\t\t\t\n\t\t\tlinestarted  = rep.getJobEntryAttributeString(id_jobentry, \"linestarted\");\n\t\t\tlineterminated  = rep.getJobEntryAttributeString(id_jobentry, \"lineterminated\");\n\n\t\t\treplacedata = rep.getJobEntryAttributeBoolean(id_jobentry, \"replacedata\");\n\t\t\tignorelines  = rep.getJobEntryAttributeString(id_jobentry, \"ignorelines\");\n\t\t\tlistattribut  = rep.getJobEntryAttributeString(id_jobentry, \"listattribut\");\n\n\t\t\tlocalinfile=rep.getJobEntryAttributeBoolean(id_jobentry, \"localinfile\");\n\t\t\n\t\t\tprorityvalue=Const.toInt(rep.getJobEntryAttributeString(id_jobentry, \"prorityvalue\"),-1);\n\t\t\t\n\t\t\tlong id_db = rep.getJobEntryAttributeInteger(id_jobentry, \"id_database\");\n\t\t\tif (id_db>0)\n\t\t\t{\n\t\t\t\tconnection = DatabaseMeta.findDatabase(databases, id_db);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// This is were we end up in normally, the previous lines are for backward compatibility.\n\t\t\t\tconnection = DatabaseMeta.findDatabase(databases, rep.getJobEntryAttributeString(id_jobentry, \"connection\"));\n\t\t\t}\n\n\t\t}\n\t\tcatch(KettleDatabaseException dbe)\n\t\t{\n\t\t\tthrow new KettleException(\"Unable to load job entry of type 'Mysql bulk load' from the repository for id_jobentry=\"+id_jobentry, dbe);\n\t\t}\n\t}","id":99130,"modified_method":"public void loadRep(Repository rep, long id_jobentry, ArrayList databases)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tsuper.loadRep(rep, id_jobentry, databases);\n\t\t\tschemaname  = rep.getJobEntryAttributeString(id_jobentry, \"schemaname\");\n\t\t\ttablename  = rep.getJobEntryAttributeString(id_jobentry, \"tablename\");\n\t\t\tfilename  = rep.getJobEntryAttributeString(id_jobentry, \"filename\");\n\t\t\tseparator  = rep.getJobEntryAttributeString(id_jobentry, \"separator\");\n\t\t\tenclosed  = rep.getJobEntryAttributeString(id_jobentry, \"enclosed\");\n\t\t\t\n\t\t\tlinestarted  = rep.getJobEntryAttributeString(id_jobentry, \"linestarted\");\n\t\t\tlineterminated  = rep.getJobEntryAttributeString(id_jobentry, \"lineterminated\");\n\n\t\t\treplacedata = rep.getJobEntryAttributeBoolean(id_jobentry, \"replacedata\");\n\t\t\tignorelines  = rep.getJobEntryAttributeString(id_jobentry, \"ignorelines\");\n\t\t\tlistattribut  = rep.getJobEntryAttributeString(id_jobentry, \"listattribut\");\n\n\t\t\tlocalinfile=rep.getJobEntryAttributeBoolean(id_jobentry, \"localinfile\");\n\t\t\tprorityvalue=(int) rep.getJobEntryAttributeInteger(id_jobentry, \"prorityvalue\");\n\t\t\t\n\t\t\tlong id_db = rep.getJobEntryAttributeInteger(id_jobentry, \"id_database\");\n\t\t\tif (id_db>0)\n\t\t\t{\n\t\t\t\tconnection = DatabaseMeta.findDatabase(databases, id_db);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// This is were we end up in normally, the previous lines are for backward compatibility.\n\t\t\t\tconnection = DatabaseMeta.findDatabase(databases, rep.getJobEntryAttributeString(id_jobentry, \"connection\"));\n\t\t\t}\n\n\t\t}\n\t\tcatch(KettleDatabaseException dbe)\n\t\t{\n\t\t\tthrow new KettleException(\"Unable to load job entry of type 'Mysql bulk load' from the repository for id_jobentry=\"+id_jobentry, dbe);\n\t\t}\n\t}","commit_id":"aed3864a0d1c8d4c763df85bd14a2d7804649f80","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void loadRep(Repository rep, long id_jobentry, ArrayList databases)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tsuper.loadRep(rep, id_jobentry, databases);\n\t\t\tzipFilename = rep.getJobEntryAttributeString(id_jobentry, \"zipfilename\");\n\t\t\tcompressionrate=Const.toInt(rep.getJobEntryAttributeString(id_jobentry, \"compressionrate\"),-1);\n\t\t\tifzipfileexists=Const.toInt(rep.getJobEntryAttributeString(id_jobentry, \"ifzipfileexists\"),-1);\n\t\t\tafterzip=Const.toInt(rep.getJobEntryAttributeString(id_jobentry, \"afterzip\"),-1);\n\t\t\twildcard = rep.getJobEntryAttributeString(id_jobentry, \"wildcard\");\n\t\t\twildcardexclude = rep.getJobEntryAttributeString(id_jobentry, \"wildcardexclude\");\n\t\t\tsourcedirectory = rep.getJobEntryAttributeString(id_jobentry, \"sourcedirectory\");\n\t\t\tmovetodirectory = rep.getJobEntryAttributeString(id_jobentry, \"movetodirectory\");\n\t\t\n\t\t}\n\t\tcatch(KettleException dbe)\n\t\t{\n\t\t\tthrow new KettleException(\"Unable to load job entry of type 'zipfile' from the repository for id_jobentry=\"+id_jobentry, dbe);\n\t\t}\n\t}","id":99131,"modified_method":"public void loadRep(Repository rep, long id_jobentry, ArrayList databases)\n\t\tthrows KettleException\n\t{\n\t\t\n\t\ttry\r\n\t\t{\r\n\t\t\tsuper.loadRep(rep, id_jobentry, databases);\r\n\t\t\tzipFilename = rep.getJobEntryAttributeString(id_jobentry, \"zipfilename\");\r\n\t\t\tcompressionrate=(int) rep.getJobEntryAttributeInteger(id_jobentry, \"compressionrate\");\r\n\t\t\tifzipfileexists=(int) rep.getJobEntryAttributeInteger(id_jobentry, \"ifzipfileexists\");\r\n\t\t\tafterzip=(int) rep.getJobEntryAttributeInteger(id_jobentry, \"afterzip\");\r\n\t\t\twildcard = rep.getJobEntryAttributeString(id_jobentry, \"wildcard\");\r\n\t\t\twildcardexclude = rep.getJobEntryAttributeString(id_jobentry, \"wildcardexclude\");\r\n\t\t\tsourcedirectory = rep.getJobEntryAttributeString(id_jobentry, \"sourcedirectory\");\r\n\t\t\tmovetodirectory = rep.getJobEntryAttributeString(id_jobentry, \"movetodirectory\");\r\n\t\t\r\n\t\t}\n\n\n\t\tcatch(KettleException dbe)\n\t\t{\n\t\t\tthrow new KettleException(\"Unable to load job entry of type 'zipfile' from the repository for id_jobentry=\"+id_jobentry, dbe);\n\t\t}\n\t}","commit_id":"e61e23c4d7cdc022c75568ec845a0876567907a1","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void loadRep(Repository rep, long id_jobentry, ArrayList databases)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tsuper.loadRep(rep, id_jobentry, databases);\n\t\t\tschemaname  = rep.getJobEntryAttributeString(id_jobentry, \"schemaname\");\n\t\t\ttablename  = rep.getJobEntryAttributeString(id_jobentry, \"tablename\");\n\t\t\tfilename  = rep.getJobEntryAttributeString(id_jobentry, \"filename\");\n\t\t\tseparator  = rep.getJobEntryAttributeString(id_jobentry, \"separator\");\n\t\t\tenclosed  = rep.getJobEntryAttributeString(id_jobentry, \"enclosed\");\n\t\t\tlineterminated  = rep.getJobEntryAttributeString(id_jobentry, \"lineterminated\");\t\t\n\t\t\tlimitlines  = rep.getJobEntryAttributeString(id_jobentry, \"limitlines\");\n\t\t\tlistcolumn  = rep.getJobEntryAttributeString(id_jobentry, \"listcolumn\");\n\t\t\thighpriority=rep.getJobEntryAttributeBoolean(id_jobentry, \"highpriority\");\n\t\t\toptionenclosed=rep.getJobEntryAttributeBoolean(id_jobentry, \"optionenclosed\");\n\t\t\toutdumpvalue=Const.toInt(rep.getJobEntryAttributeString(id_jobentry, \"outdumpvalue\"),-1);\n\t\t\tiffileexists=Const.toInt(rep.getJobEntryAttributeString(id_jobentry, \"iffileexists\"),-1);\n\t\t\t\n\t\t\tlong id_db = rep.getJobEntryAttributeInteger(id_jobentry, \"id_database\");\n\t\t\tif (id_db>0)\n\t\t\t{\n\t\t\t\tconnection = DatabaseMeta.findDatabase(databases, id_db);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// This is were we end up in normally, the previous lines are for backward compatibility.\n\t\t\t\tconnection = DatabaseMeta.findDatabase(databases, rep.getJobEntryAttributeString(id_jobentry, \"connection\"));\n\t\t\t}\n\n\t\t}\n\t\tcatch(KettleDatabaseException dbe)\n\t\t{\n\t\t\tthrow new KettleException(\"Unable to load job entry of type 'table exists' from the repository for id_jobentry=\"+id_jobentry, dbe);\n\t\t}\n\t}","id":99132,"modified_method":"public void loadRep(Repository rep, long id_jobentry, ArrayList databases)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tsuper.loadRep(rep, id_jobentry, databases);\n\t\t\tschemaname  = rep.getJobEntryAttributeString(id_jobentry, \"schemaname\");\n\t\t\ttablename  = rep.getJobEntryAttributeString(id_jobentry, \"tablename\");\n\t\t\tfilename  = rep.getJobEntryAttributeString(id_jobentry, \"filename\");\n\t\t\tseparator  = rep.getJobEntryAttributeString(id_jobentry, \"separator\");\n\t\t\tenclosed  = rep.getJobEntryAttributeString(id_jobentry, \"enclosed\");\n\t\t\tlineterminated  = rep.getJobEntryAttributeString(id_jobentry, \"lineterminated\");\t\t\n\t\t\tlimitlines  = rep.getJobEntryAttributeString(id_jobentry, \"limitlines\");\n\t\t\tlistcolumn  = rep.getJobEntryAttributeString(id_jobentry, \"listcolumn\");\n\t\t\thighpriority=rep.getJobEntryAttributeBoolean(id_jobentry, \"highpriority\");\n\t\t\toptionenclosed=rep.getJobEntryAttributeBoolean(id_jobentry, \"optionenclosed\");\n\t\t\t\n\t\t\toutdumpvalue=(int) rep.getJobEntryAttributeInteger(id_jobentry, \"outdumpvalue\");\n\n\t\t\tiffileexists=(int) rep.getJobEntryAttributeInteger(id_jobentry, \"iffileexists\");\n\t\t\t\n\t\t\tlong id_db = rep.getJobEntryAttributeInteger(id_jobentry, \"id_database\");\n\t\t\tif (id_db>0)\n\t\t\t{\n\t\t\t\tconnection = DatabaseMeta.findDatabase(databases, id_db);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// This is were we end up in normally, the previous lines are for backward compatibility.\n\t\t\t\tconnection = DatabaseMeta.findDatabase(databases, rep.getJobEntryAttributeString(id_jobentry, \"connection\"));\n\t\t\t}\n\n\t\t}\n\t\tcatch(KettleDatabaseException dbe)\n\t\t{\n\t\t\tthrow new KettleException(\"Unable to load job entry of type 'table exists' from the repository for id_jobentry=\"+id_jobentry, dbe);\n\t\t}\n\t}","commit_id":"354f864c165d660128d0559121ced6352069b7f5","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Override\n    public String getAttribute(String local_name) throws HttpClientException {\n        NamedNodeMap attrs = element.getNode().getAttributes();\n        return ((Attr)attrs.getNamedItem(local_name)).getValue();\n    }","id":99133,"modified_method":"@Override\n    public String getAttribute(String local_name) throws HttpClientException {\n        String attrValue = null;\n        NamedNodeMap attrs = element.getNode().getAttributes();\n        Node attr = attrs.getNamedItem(local_name);\n        if(attr != null) {\n            attrValue = ((Attr)attr).getValue();\n        }\n\n        return attrValue;\n    }","commit_id":"bff03561911e59b19967313cc11d34bcc9bc255b","url":"https://github.com/eXist-db/exist"},{"original_method":"public EXistSequence(org.exist.xquery.value.Sequence sequence, XQueryContext context) throws XPathException {\n        this.sequence = sequence;\n        this.sequenceIterator = sequence.iterate();\n        this.context = context;\n    }","id":99134,"modified_method":"public EXistSequence(org.exist.xquery.value.Sequence sequence, XQueryContext context) throws XPathException {\n        this.sequence = sequence;\n        if(sequence != null) {\n            this.sequenceIterator = sequence.iterate();\n        }\n        this.context = context;\n    }","commit_id":"bff03561911e59b19967313cc11d34bcc9bc255b","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n    public void serialize(OutputStream out, Properties params) throws HttpClientException {\n        \n        \n        \n        SAXSerializer sax = (SAXSerializer) SerializerPool.getInstance().borrowObject(SAXSerializer.class);\n        params.setProperty(Serializer.GENERATE_DOC_EVENTS, \"false\");\n        \n        try {\n            SequenceIterator itSequence = sequence.iterate();\n            \n            String encoding = params.getProperty(OutputKeys.ENCODING, \"UTF-8\");\n            Writer writer = new OutputStreamWriter(out, encoding);\n            sax.setOutput(writer, params);\n            Serializer serializer = context.getBroker().getSerializer();\n            serializer.reset();\n            serializer.setProperties(params);\n            serializer.setSAXHandlers(sax, sax);\n\n            sax.startDocument();\n            \n            while(itSequence.hasNext()) {\n               NodeValue next = (NodeValue)itSequence.nextItem();\n               serializer.toSAX(next);\t\n            }\n            \n            sax.endDocument();\n            writer.close();\n        } catch(SAXException saxe) {\n            throw new HttpClientException(\"A problem occurred while serializing the node set: \" + saxe.getMessage(), saxe);\n        } catch(IOException ioe) {\n            throw new HttpClientException(\"A problem occurred while serializing the node set: \" + ioe.getMessage(), ioe);\n        } catch(XPathException xpe) {\n            throw new HttpClientException(\"A problem occurred while serializing the node set: \" + xpe.getMessage(), xpe);\n        } finally {\n            SerializerPool.getInstance().returnObject(sax);\n        }\n    }","id":99135,"modified_method":"@Override\n    public void serialize(OutputStream out, Properties params) throws HttpClientException {\n        \n        SAXSerializer sax = (SAXSerializer) SerializerPool.getInstance().borrowObject(SAXSerializer.class);\n        params.setProperty(Serializer.GENERATE_DOC_EVENTS, \"false\");\n        \n        try {\n            SequenceIterator itSequence = SequenceIterator.EMPTY_ITERATOR;\n            if(sequence != null) {\n                itSequence = sequence.iterate();\n            }\n            \n            String encoding = params.getProperty(OutputKeys.ENCODING, \"UTF-8\");\n            Writer writer = new OutputStreamWriter(out, encoding);\n            sax.setOutput(writer, params);\n            Serializer serializer = context.getBroker().getSerializer();\n            serializer.reset();\n            serializer.setProperties(params);\n            serializer.setSAXHandlers(sax, sax);\n\n            sax.startDocument();\n            \n            while(itSequence.hasNext()) {\n               NodeValue next = (NodeValue)itSequence.nextItem();\n               serializer.toSAX(next);\t\n            }\n            \n            sax.endDocument();\n            writer.close();\n        } catch(SAXException saxe) {\n            throw new HttpClientException(\"A problem occurred while serializing the node set: \" + saxe.getMessage(), saxe);\n        } catch(IOException ioe) {\n            throw new HttpClientException(\"A problem occurred while serializing the node set: \" + ioe.getMessage(), ioe);\n        } catch(XPathException xpe) {\n            throw new HttpClientException(\"A problem occurred while serializing the node set: \" + xpe.getMessage(), xpe);\n        } finally {\n            SerializerPool.getInstance().returnObject(sax);\n        }\n    }","commit_id":"bff03561911e59b19967313cc11d34bcc9bc255b","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Gets the service name of the provided endpoint reference. \n     * @param ref the endpoint reference.\n     * @return the service name.\n     */\n    public static QName getServiceName(EndpointReferenceType ref, Bus bus) {\n        MetadataType metadata = ref.getMetadata();\n        if (metadata == null) {\n            return null;\n        }\n        for (Object obj : metadata.getAny()) {\n            if (obj instanceof Element) {\n                Node node = (Element)obj;\n                if (node.getNamespaceURI().equals(JAXWSAConstants.NS_WSAW) \n                    && node.getLocalName().equals(\"ServiceName\")) {\n                    String content = node.getTextContent();\n                    String namespaceURI = node.getFirstChild().getNamespaceURI();\n                    String service = content;\n                    if (content.contains(\":\")) {\n                        namespaceURI = getNameSpaceUri(node, content, namespaceURI);\n                        if (StringUtils.isEmpty(namespaceURI)) {\n                            namespaceURI = findNamespaceHack(ref, bus);                                \n                        }\n                        service = getService(content);\n                    } else {\n                        Node nodeAttr = node.getAttributes().getNamedItem(\"xmlns\");\n                        namespaceURI = nodeAttr.getNodeValue();\n                    }\n                    \n                    return new QName(namespaceURI, service);\n                }\n            } else if (obj instanceof JAXBElement) {\n                Object val = ((JAXBElement)obj).getValue();\n                if (val instanceof ServiceNameType) {\n                    return ((ServiceNameType)val).getValue();\n                }\n            } else if (obj instanceof ServiceNameType) {\n                return ((ServiceNameType)obj).getValue();\n            }\n        }\n        return null;\n    }","id":99136,"modified_method":"/**\n     * Gets the service name of the provided endpoint reference. \n     * @param ref the endpoint reference.\n     * @return the service name.\n     */\n    public static QName getServiceName(EndpointReferenceType ref, Bus bus) {\n        MetadataType metadata = ref.getMetadata();\n        if (metadata == null) {\n            return null;\n        }\n        for (Object obj : metadata.getAny()) {\n            if (obj instanceof Element) {\n                Node node = (Element)obj;\n                if ((node.getNamespaceURI().equals(JAXWSAConstants.NS_WSAW)\n                    || node.getNamespaceURI().equals(NS_WSAW_2005))\n                    && node.getLocalName().equals(\"ServiceName\")) {\n                    String content = node.getTextContent();\n                    String namespaceURI = node.getFirstChild().getNamespaceURI();\n                    String service = content;\n                    if (content.contains(\":\")) {\n                        namespaceURI = getNameSpaceUri(node, content, namespaceURI);\n                        if (StringUtils.isEmpty(namespaceURI)) {\n                            namespaceURI = findNamespaceHack(ref, bus);                                \n                        }\n                        service = getService(content);\n                    } else {\n                        Node nodeAttr = node.getAttributes().getNamedItem(\"xmlns\");\n                        namespaceURI = nodeAttr.getNodeValue();\n                    }\n                    \n                    return new QName(namespaceURI, service);\n                }\n            } else if (obj instanceof JAXBElement) {\n                Object val = ((JAXBElement)obj).getValue();\n                if (val instanceof ServiceNameType) {\n                    return ((ServiceNameType)val).getValue();\n                }\n            } else if (obj instanceof ServiceNameType) {\n                return ((ServiceNameType)obj).getValue();\n            }\n        }\n        return null;\n    }","commit_id":"2f1f50f22571471371335173982ed6d6716523ab","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Gets the port name of the provided endpoint reference.\n     * @param ref the endpoint reference.\n     * @return the port name.\n     */\n    public static String getPortName(EndpointReferenceType ref) {\n        MetadataType metadata = ref.getMetadata();\n        if (metadata != null) {\n            for (Object obj : metadata.getAny()) {\n                if (obj instanceof Element) {\n                    Node node = (Element)obj;\n                    if (node.getNamespaceURI().equals(JAXWSAConstants.NS_WSAW)\n                        && node.getNodeName().contains(\"ServiceName\")) {\n                        return node.getAttributes().getNamedItem(\"EndpointName\").getTextContent();\n                    }\n                } else if (obj instanceof JAXBElement) {\n                    Object val = ((JAXBElement)obj).getValue();\n                    if (val instanceof ServiceNameType) {\n                        return ((ServiceNameType)val).getEndpointName();\n                    }\n                } else if (obj instanceof ServiceNameType) {\n                    return ((ServiceNameType)obj).getEndpointName();\n                }\n            }\n        }\n        return null;\n    }","id":99137,"modified_method":"/**\n     * Gets the port name of the provided endpoint reference.\n     * @param ref the endpoint reference.\n     * @return the port name.\n     */\n    public static String getPortName(EndpointReferenceType ref) {\n        MetadataType metadata = ref.getMetadata();\n        if (metadata != null) {\n            for (Object obj : metadata.getAny()) {\n                if (obj instanceof Element) {\n                    Node node = (Element)obj;\n                    if ((node.getNamespaceURI().equals(JAXWSAConstants.NS_WSAW)\n                        || node.getNamespaceURI().equals(NS_WSAW_2005))\n                        && node.getNodeName().contains(\"ServiceName\")) {\n                        Node item = node.getAttributes().getNamedItem(\"EndpointName\");\n                        return item != null ? item.getTextContent() : null;\n                    }\n                } else if (obj instanceof JAXBElement) {\n                    Object val = ((JAXBElement)obj).getValue();\n                    if (val instanceof ServiceNameType) {\n                        return ((ServiceNameType)val).getEndpointName();\n                    }\n                } else if (obj instanceof ServiceNameType) {\n                    return ((ServiceNameType)obj).getEndpointName();\n                }\n            }\n        }\n        return null;\n    }","commit_id":"2f1f50f22571471371335173982ed6d6716523ab","url":"https://github.com/apache/cxf"},{"original_method":"public static void setPortName(EndpointReferenceType ref, String portName) {\n        MetadataType metadata = ref.getMetadata();\n        if (metadata != null) {\n            for (Object obj : metadata.getAny()) {\n                if (obj instanceof JAXBElement) {\n                    Object val = ((JAXBElement)obj).getValue();\n                    if (val instanceof ServiceNameType) {\n                        ((ServiceNameType)val).setEndpointName(portName);\n                    }\n                } else if (obj instanceof ServiceNameType) {\n                    ((ServiceNameType)obj).setEndpointName(portName);\n                }\n            }\n        }\n    }","id":99138,"modified_method":"public static void setPortName(EndpointReferenceType ref, String portName) {\n        MetadataType metadata = ref.getMetadata();\n        if (metadata != null) {\n            for (Object obj : metadata.getAny()) {\n                if (obj instanceof Element) {\n                    Element node = (Element)obj;\n                    if (node.getNodeName().contains(\"ServiceName\")\n                        && (node.getNamespaceURI().equals(JAXWSAConstants.NS_WSAW)\n                        || node.getNamespaceURI().equals(NS_WSAW_2005))) {\n                        node.setAttribute(JAXWSAConstants.WSAW_ENDPOINT_NAME, portName);\n                    }\n                } else if (obj instanceof JAXBElement) {\n                    Object val = ((JAXBElement)obj).getValue();\n                    if (val instanceof ServiceNameType) {\n                        ((ServiceNameType)val).setEndpointName(portName);\n                    }\n                } else if (obj instanceof ServiceNameType) {\n                    ((ServiceNameType)obj).setEndpointName(portName);\n                }\n            }\n        }\n    }","commit_id":"2f1f50f22571471371335173982ed6d6716523ab","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testConvertToInternal() throws Exception {\n        InputStream is = getClass().getResourceAsStream(\"resources/hello_world_soap_http_infoset.xml\");\n        Document doc = XMLUtils.parse(is);\n        DOMSource erXML = new DOMSource(doc);\n        EndpointReference endpointReference = readEndpointReference(erXML);\n        \n        EndpointReferenceType ert = VersionTransformer.convertToInternal(endpointReference);\n\n        assertNotNull(ert);\n        assertEquals(\"http://localhost:8080/test\", ert.getAddress().getValue());\n        assertEquals(new QName(\"http://apache.org/hello_world_soap_http\", \"SOAPService\"), \n                               EndpointReferenceUtils.getServiceName(ert, null));\n    }","id":99139,"modified_method":"@Test\n    public void testConvertToInternal() throws Exception {\n        InputStream is = getClass().getResourceAsStream(\"resources/hello_world_soap_http_infoset.xml\");\n        Document doc = XMLUtils.parse(is);\n        DOMSource erXML = new DOMSource(doc);\n        EndpointReference endpointReference = readEndpointReference(erXML);\n        \n        EndpointReferenceType ert = VersionTransformer.convertToInternal(endpointReference);\n\n        assertNotNull(ert);\n        assertEquals(\"http://localhost:8080/test\", ert.getAddress().getValue());\n        assertEquals(new QName(\"http://apache.org/hello_world_soap_http\", \"SOAPService\"), \n                               EndpointReferenceUtils.getServiceName(ert, null));\n        \n        // VersionTransformer.convertToInternal produces metadata extensions of type \n        // DOM Element hence we're testing the relevant EndpointReferenceUtils.setPortName\n        // code path here\n        \n        List<Object> metadata = ert.getMetadata().getAny();\n        assertEquals(\"Single metadata extension expected\", 1, metadata.size());\n        assertTrue(\"Metadata extension of type DOM Element expected\", \n                   metadata.get(0) instanceof Element);\n        assertNull(\"No portName has been set yet\", EndpointReferenceUtils.getPortName(ert));\n        EndpointReferenceUtils.setPortName(ert, \"Greeter\");\n        assertEquals(\"No portName has been set\", \"Greeter\", EndpointReferenceUtils.getPortName(ert));\n    }","commit_id":"2f1f50f22571471371335173982ed6d6716523ab","url":"https://github.com/apache/cxf"},{"original_method":"public String getAttribute(String local_name) throws HttpClientException {\n        NamedNodeMap attrs = element.getNode().getAttributes();\n        return ((Attr)attrs.getNamedItem(local_name)).getValue();\n    }","id":99140,"modified_method":"public String getAttribute(String local_name) throws HttpClientException {\n        String attrValue = null;\n        NamedNodeMap attrs = element.getNode().getAttributes();\n        Node attr = attrs.getNamedItem(local_name);\n        if(attr != null) {\n            attrValue = ((Attr)attr).getValue();\n        }\n\n        return attrValue;\n    }","commit_id":"3195c64715876fa64c1f6d2aea0dbfbc4b03ec81","url":"https://github.com/eXist-db/exist"},{"original_method":"public void serialize(OutputStream out, Properties params) throws HttpClientException {\n        \n        \n        \n        SAXSerializer sax = (SAXSerializer) SerializerPool.getInstance().borrowObject(SAXSerializer.class);\n        params.setProperty(Serializer.GENERATE_DOC_EVENTS, \"false\");\n        \n        try {\n            SequenceIterator itSequence = sequence.iterate();\n            \n            String encoding = params.getProperty(OutputKeys.ENCODING, \"UTF-8\");\n            Writer writer = new OutputStreamWriter(out, encoding);\n            sax.setOutput(writer, params);\n            Serializer serializer = context.getBroker().getSerializer();\n            serializer.reset();\n            serializer.setProperties(params);\n            serializer.setSAXHandlers(sax, sax);\n\n            sax.startDocument();\n            \n            while(itSequence.hasNext()) {\n               NodeValue next = (NodeValue)itSequence.nextItem();\n               serializer.toSAX(next);\t\n            }\n            \n            sax.endDocument();\n            writer.close();\n        } catch(SAXException saxe) {\n            throw new HttpClientException(\"A problem occurred while serializing the node set: \" + saxe.getMessage(), saxe);\n        } catch(IOException ioe) {\n            throw new HttpClientException(\"A problem occurred while serializing the node set: \" + ioe.getMessage(), ioe);\n        } catch(XPathException xpe) {\n            throw new HttpClientException(\"A problem occurred while serializing the node set: \" + xpe.getMessage(), xpe);\n        } finally {\n            SerializerPool.getInstance().returnObject(sax);\n        }\n    }","id":99141,"modified_method":"public void serialize(OutputStream out, Properties params) throws HttpClientException {\n        \n        SAXSerializer sax = (SAXSerializer) SerializerPool.getInstance().borrowObject(SAXSerializer.class);\n        params.setProperty(Serializer.GENERATE_DOC_EVENTS, \"false\");\n        \n        try {\n            SequenceIterator itSequence = SequenceIterator.EMPTY_ITERATOR;\n            if(sequence != null) {\n                itSequence = sequence.iterate();\n            }\n            \n            String encoding = params.getProperty(OutputKeys.ENCODING, \"UTF-8\");\n            Writer writer = new OutputStreamWriter(out, encoding);\n            sax.setOutput(writer, params);\n            Serializer serializer = context.getBroker().getSerializer();\n            serializer.reset();\n            serializer.setProperties(params);\n            serializer.setSAXHandlers(sax, sax);\n\n            sax.startDocument();\n            \n            while(itSequence.hasNext()) {\n               NodeValue next = (NodeValue)itSequence.nextItem();\n               serializer.toSAX(next);\t\n            }\n            \n            sax.endDocument();\n            writer.close();\n        } catch(SAXException saxe) {\n            throw new HttpClientException(\"A problem occurred while serializing the node set: \" + saxe.getMessage(), saxe);\n        } catch(IOException ioe) {\n            throw new HttpClientException(\"A problem occurred while serializing the node set: \" + ioe.getMessage(), ioe);\n        } catch(XPathException xpe) {\n            throw new HttpClientException(\"A problem occurred while serializing the node set: \" + xpe.getMessage(), xpe);\n        } finally {\n            SerializerPool.getInstance().returnObject(sax);\n        }\n    }","commit_id":"3195c64715876fa64c1f6d2aea0dbfbc4b03ec81","url":"https://github.com/eXist-db/exist"},{"original_method":"public EXistSequence(org.exist.xquery.value.Sequence sequence, XQueryContext context) throws XPathException {\n        this.sequence = sequence;\n        this.sequenceIterator = sequence.iterate();\n        this.context = context;\n    }","id":99142,"modified_method":"public EXistSequence(org.exist.xquery.value.Sequence sequence, XQueryContext context) throws XPathException {\n        this.sequence = sequence;\n        if(sequence != null) {\n            this.sequenceIterator = sequence.iterate();\n        }\n        this.context = context;\n    }","commit_id":"3195c64715876fa64c1f6d2aea0dbfbc4b03ec81","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n\tpublic NoticeableFuture<Path> getFile(\n\t\tPath remoteFilePath, Path localFilePath, boolean deleteAfterFetch) {\n\n\t\treturn null;\n\t}","id":99143,"modified_method":"@Override\n\tpublic NoticeableFuture<Path> getFile(\n\t\tT t, Path remoteFilePath, Path localFilePath,\n\t\tboolean deleteAfterFetch) {\n\n\t\treturn null;\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic NoticeableFuture<Map<Path, Path>> getFiles(\n\t\tMap<Path, Path> pathMap, boolean deleteAfterFetch) {\n\n\t\tDefaultNoticeableFuture<Map<Path, Path>> defaultNoticeableFuture =\n\t\t\tnew DefaultNoticeableFuture<Map<Path, Path>>();\n\n\t\tdefaultNoticeableFuture.set(pathMap);\n\n\t\treturn defaultNoticeableFuture;\n\t}","id":99144,"modified_method":"@Override\n\tpublic NoticeableFuture<Map<Path, Path>> getFiles(\n\t\tT t, Map<Path, Path> pathMap, boolean deleteAfterFetch) {\n\n\t\tDefaultNoticeableFuture<Map<Path, Path>> defaultNoticeableFuture =\n\t\t\tnew DefaultNoticeableFuture<Map<Path, Path>>();\n\n\t\tdefaultNoticeableFuture.set(pathMap);\n\n\t\treturn defaultNoticeableFuture;\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testGetSetNettyFabricAgentStub() {\n\t\tAssert.assertNull(\n\t\t\tNettyChannelAttributes.getNettyFabricAgentStub(_embeddedChannel));\n\n\t\tNettyFabricAgentStub nettyFabricAgentStub = new NettyFabricAgentStub(\n\t\t\t_embeddedChannel, new MockRepository(),\n\t\t\tPaths.get(\"remoteRepositoryPath\"), 0, 0);\n\n\t\tNettyChannelAttributes.setNettyFabricAgentStub(\n\t\t\t_embeddedChannel, nettyFabricAgentStub);\n\n\t\tAssert.assertSame(\n\t\t\tnettyFabricAgentStub,\n\t\t\tNettyChannelAttributes.getNettyFabricAgentStub(_embeddedChannel));\n\t}","id":99145,"modified_method":"@Test\n\tpublic void testGetSetNettyFabricAgentStub() {\n\t\tAssert.assertNull(\n\t\t\tNettyChannelAttributes.getNettyFabricAgentStub(_embeddedChannel));\n\n\t\tNettyFabricAgentStub nettyFabricAgentStub = new NettyFabricAgentStub(\n\t\t\t_embeddedChannel, new MockRepository<Channel>(),\n\t\t\tPaths.get(\"remoteRepositoryPath\"), 0, 0);\n\n\t\tNettyChannelAttributes.setNettyFabricAgentStub(\n\t\t\t_embeddedChannel, nettyFabricAgentStub);\n\n\t\tAssert.assertSame(\n\t\t\tnettyFabricAgentStub,\n\t\t\tNettyChannelAttributes.getNettyFabricAgentStub(_embeddedChannel));\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testExecute() throws Exception {\n\t\tfinal NettyFabricAgentStub nettyFabricAgentStub =\n\t\t\tnew NettyFabricAgentStub(\n\t\t\t\t_embeddedChannel, new MockRepository(),\n\t\t\t\tPaths.get(\"RepositoryPath\"), 0, Long.MAX_VALUE);\n\n\t\tAtomicLong idGenerator = ReflectionTestUtil.getFieldValue(\n\t\t\tnettyFabricAgentStub, \"_idGenerator\");\n\n\t\tlong id = idGenerator.get();\n\n\t\tBuilder builder = new Builder();\n\n\t\tProcessConfig processConfig = builder.build();\n\n\t\tFile testFile1 = new File(\"TestFile1\");\n\t\tFile testFile2 = new File(\"TestFile2\");\n\t\tFile testFile3 = new File(\"TestFile3\");\n\n\t\tProcessCallable<String> processCallable = new TestProcessCallable(\n\t\t\ttestFile1, testFile2, testFile3);\n\n\t\tChannelPipeline channelPipeline = _embeddedChannel.pipeline();\n\n\t\tchannelPipeline.addLast(\n\t\t\tnew ChannelOutboundHandlerAdapter() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void write(\n\t\t\t\t\t\tChannelHandlerContext channelHandlerContext, Object obj,\n\t\t\t\t\t\tChannelPromise channelPromise)\n\t\t\t\t\tthrows Exception {\n\n\t\t\t\t\tsuper.write(channelHandlerContext, obj, channelPromise);\n\n\t\t\t\t\tif (!(obj instanceof NettyFabricWorkerConfig)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tNettyFabricWorkerConfig<?> nettyFabricWorkerConfig =\n\t\t\t\t\t\t(NettyFabricWorkerConfig<?>)obj;\n\n\t\t\t\t\tnettyFabricAgentStub.finsihStartup(\n\t\t\t\t\t\tnettyFabricWorkerConfig.getId());\n\t\t\t\t}\n\n\t\t\t}\n\t\t);\n\t\tFabricWorker<String> fabricWorker = ReflectionTestUtil.invokeBridge(\n\t\t\tnettyFabricAgentStub, \"execute\",\n\t\t\tnew Class<?>[] {ProcessConfig.class, ProcessCallable.class},\n\t\t\tprocessConfig, processCallable);\n\n\t\tQueue<Object> messages = _embeddedChannel.outboundMessages();\n\n\t\tAssert.assertEquals(1, messages.size());\n\n\t\tNettyFabricWorkerConfig<String> nettyFabricWorkerConfig =\n\t\t\t(NettyFabricWorkerConfig<String>)messages.poll();\n\n\t\tAssert.assertEquals(id, nettyFabricWorkerConfig.getId());\n\t\tAssert.assertSame(\n\t\t\tprocessConfig, nettyFabricWorkerConfig.getProcessConfig());\n\n\t\tProcessCallable<String> nettyFabricWorkerProcessCallable =\n\t\t\tnettyFabricWorkerConfig.getProcessCallable();\n\n\t\tAssert.assertNotSame(processCallable, nettyFabricWorkerProcessCallable);\n\t\tAssert.assertEquals(\n\t\t\tprocessCallable.toString(),\n\t\t\tnettyFabricWorkerProcessCallable.toString());\n\t\tAssert.assertEquals(\n\t\t\tprocessCallable.call(), nettyFabricWorkerProcessCallable.call());\n\n\t\tCollection<? extends FabricWorker<?>> fabricWorkers =\n\t\t\tnettyFabricAgentStub.getFabricWorkers();\n\n\t\tAssert.assertEquals(1, fabricWorkers.size());\n\t\tAssert.assertTrue(fabricWorkers.contains(fabricWorker));\n\n\t\tNoticeableFuture<String> noticeableFuture =\n\t\t\tfabricWorker.getProcessNoticeableFuture();\n\n\t\tAssert.assertFalse(noticeableFuture.isDone());\n\n\t\tNettyFabricWorkerStub<String> nettyFabricWorkerStub =\n\t\t\t(NettyFabricWorkerStub<String>)\n\t\t\t\tnettyFabricAgentStub.takeNettyStubFabricWorker(id);\n\n\t\tAssert.assertTrue(fabricWorkers.isEmpty());\n\n\t\tMap<Path, Path> outputPathMap = ReflectionTestUtil.getFieldValue(\n\t\t\tnettyFabricWorkerStub, \"_outputPathMap\");\n\n\t\tAssert.assertEquals(2, outputPathMap.size());\n\n\t\tPath path1 = testFile1.toPath();\n\n\t\tFile testOutput1 = ReflectionTestUtil.getFieldValue(\n\t\t\tprocessCallable, \"_testOutput1\");\n\n\t\tAssert.assertEquals(path1, outputPathMap.get(testOutput1.toPath()));\n\n\t\tPath path3 = testFile3.toPath();\n\n\t\tFile testOutput3 = ReflectionTestUtil.getFieldValue(\n\t\t\tprocessCallable, \"_testOutput3\");\n\n\t\tAssert.assertEquals(path3, outputPathMap.get(testOutput3.toPath()));\n\n\t\tnettyFabricWorkerStub.setResult(processCallable.call());\n\n\t\tAssert.assertEquals(processCallable.call(), noticeableFuture.get());\n\n\t\t// Ensure no side effect to finish an already finished startup\n\n\t\tnettyFabricAgentStub.finsihStartup(id);\n\t}","id":99146,"modified_method":"@Test\n\tpublic void testExecute() throws Exception {\n\t\tfinal NettyFabricAgentStub nettyFabricAgentStub =\n\t\t\tnew NettyFabricAgentStub(\n\t\t\t\t_embeddedChannel, new MockRepository<Channel>(),\n\t\t\t\tPaths.get(\"RepositoryPath\"), 0, Long.MAX_VALUE);\n\n\t\tAtomicLong idGenerator = ReflectionTestUtil.getFieldValue(\n\t\t\tnettyFabricAgentStub, \"_idGenerator\");\n\n\t\tlong id = idGenerator.get();\n\n\t\tBuilder builder = new Builder();\n\n\t\tProcessConfig processConfig = builder.build();\n\n\t\tFile testFile1 = new File(\"TestFile1\");\n\t\tFile testFile2 = new File(\"TestFile2\");\n\t\tFile testFile3 = new File(\"TestFile3\");\n\n\t\tProcessCallable<String> processCallable = new TestProcessCallable(\n\t\t\ttestFile1, testFile2, testFile3);\n\n\t\tChannelPipeline channelPipeline = _embeddedChannel.pipeline();\n\n\t\tchannelPipeline.addLast(\n\t\t\tnew ChannelOutboundHandlerAdapter() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void write(\n\t\t\t\t\t\tChannelHandlerContext channelHandlerContext, Object obj,\n\t\t\t\t\t\tChannelPromise channelPromise)\n\t\t\t\t\tthrows Exception {\n\n\t\t\t\t\tsuper.write(channelHandlerContext, obj, channelPromise);\n\n\t\t\t\t\tif (!(obj instanceof NettyFabricWorkerConfig)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tNettyFabricWorkerConfig<?> nettyFabricWorkerConfig =\n\t\t\t\t\t\t(NettyFabricWorkerConfig<?>)obj;\n\n\t\t\t\t\tnettyFabricAgentStub.finsihStartup(\n\t\t\t\t\t\tnettyFabricWorkerConfig.getId());\n\t\t\t\t}\n\n\t\t\t}\n\t\t);\n\t\tFabricWorker<String> fabricWorker = ReflectionTestUtil.invokeBridge(\n\t\t\tnettyFabricAgentStub, \"execute\",\n\t\t\tnew Class<?>[] {ProcessConfig.class, ProcessCallable.class},\n\t\t\tprocessConfig, processCallable);\n\n\t\tQueue<Object> messages = _embeddedChannel.outboundMessages();\n\n\t\tAssert.assertEquals(1, messages.size());\n\n\t\tNettyFabricWorkerConfig<String> nettyFabricWorkerConfig =\n\t\t\t(NettyFabricWorkerConfig<String>)messages.poll();\n\n\t\tAssert.assertEquals(id, nettyFabricWorkerConfig.getId());\n\t\tAssert.assertSame(\n\t\t\tprocessConfig, nettyFabricWorkerConfig.getProcessConfig());\n\n\t\tProcessCallable<String> nettyFabricWorkerProcessCallable =\n\t\t\tnettyFabricWorkerConfig.getProcessCallable();\n\n\t\tAssert.assertNotSame(processCallable, nettyFabricWorkerProcessCallable);\n\t\tAssert.assertEquals(\n\t\t\tprocessCallable.toString(),\n\t\t\tnettyFabricWorkerProcessCallable.toString());\n\t\tAssert.assertEquals(\n\t\t\tprocessCallable.call(), nettyFabricWorkerProcessCallable.call());\n\n\t\tCollection<? extends FabricWorker<?>> fabricWorkers =\n\t\t\tnettyFabricAgentStub.getFabricWorkers();\n\n\t\tAssert.assertEquals(1, fabricWorkers.size());\n\t\tAssert.assertTrue(fabricWorkers.contains(fabricWorker));\n\n\t\tNoticeableFuture<String> noticeableFuture =\n\t\t\tfabricWorker.getProcessNoticeableFuture();\n\n\t\tAssert.assertFalse(noticeableFuture.isDone());\n\n\t\tNettyFabricWorkerStub<String> nettyFabricWorkerStub =\n\t\t\t(NettyFabricWorkerStub<String>)\n\t\t\t\tnettyFabricAgentStub.takeNettyStubFabricWorker(id);\n\n\t\tAssert.assertTrue(fabricWorkers.isEmpty());\n\n\t\tMap<Path, Path> outputPathMap = ReflectionTestUtil.getFieldValue(\n\t\t\tnettyFabricWorkerStub, \"_outputPathMap\");\n\n\t\tAssert.assertEquals(2, outputPathMap.size());\n\n\t\tPath path1 = testFile1.toPath();\n\n\t\tFile testOutput1 = ReflectionTestUtil.getFieldValue(\n\t\t\tprocessCallable, \"_testOutput1\");\n\n\t\tAssert.assertEquals(path1, outputPathMap.get(testOutput1.toPath()));\n\n\t\tPath path3 = testFile3.toPath();\n\n\t\tFile testOutput3 = ReflectionTestUtil.getFieldValue(\n\t\t\tprocessCallable, \"_testOutput3\");\n\n\t\tAssert.assertEquals(path3, outputPathMap.get(testOutput3.toPath()));\n\n\t\tnettyFabricWorkerStub.setResult(processCallable.call());\n\n\t\tAssert.assertEquals(processCallable.call(), noticeableFuture.get());\n\n\t\t// Ensure no side effect to finish an already finished startup\n\n\t\tnettyFabricAgentStub.finsihStartup(id);\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testExecuteWithInterruption() throws Exception {\n\t\tNettyFabricAgentStub nettyFabricAgentStub =\n\t\t\tnew NettyFabricAgentStub(\n\t\t\t\t_embeddedChannel, new MockRepository(),\n\t\t\t\tPaths.get(\"RepositoryPath\"), 0, Long.MAX_VALUE);\n\n\t\tThread currentThread = Thread.currentThread();\n\n\t\tcurrentThread.interrupt();\n\n\t\tBuilder builder = new Builder();\n\n\t\tFabricWorker<String> fabricWorker =  nettyFabricAgentStub.execute(\n\t\t\tbuilder.build(), new ReturnProcessCallable<String>(\"Test result\"));\n\n\t\tNoticeableFuture<String> noticeableFuture =\n\t\t\tfabricWorker.getProcessNoticeableFuture();\n\n\t\ttry {\n\t\t\tnoticeableFuture.get();\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (ExecutionException ee) {\n\t\t\tThrowable throwable = ee.getCause();\n\n\t\t\tAssert.assertSame(InterruptedException.class, throwable.getClass());\n\t\t}\n\n\t\tCollection<? extends FabricWorker<?>> fabricWorkers =\n\t\t\tnettyFabricAgentStub.getFabricWorkers();\n\n\t\tAssert.assertTrue(fabricWorkers.isEmpty());\n\t}","id":99147,"modified_method":"@Test\n\tpublic void testExecuteWithInterruption() throws Exception {\n\t\tNettyFabricAgentStub nettyFabricAgentStub =\n\t\t\tnew NettyFabricAgentStub(\n\t\t\t\t_embeddedChannel, new MockRepository<Channel>(),\n\t\t\t\tPaths.get(\"RepositoryPath\"), 0, Long.MAX_VALUE);\n\n\t\tThread currentThread = Thread.currentThread();\n\n\t\tcurrentThread.interrupt();\n\n\t\tBuilder builder = new Builder();\n\n\t\tFabricWorker<String> fabricWorker =  nettyFabricAgentStub.execute(\n\t\t\tbuilder.build(), new ReturnProcessCallable<String>(\"Test result\"));\n\n\t\tNoticeableFuture<String> noticeableFuture =\n\t\t\tfabricWorker.getProcessNoticeableFuture();\n\n\t\ttry {\n\t\t\tnoticeableFuture.get();\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (ExecutionException ee) {\n\t\t\tThrowable throwable = ee.getCause();\n\n\t\t\tAssert.assertSame(InterruptedException.class, throwable.getClass());\n\t\t}\n\n\t\tCollection<? extends FabricWorker<?>> fabricWorkers =\n\t\t\tnettyFabricAgentStub.getFabricWorkers();\n\n\t\tAssert.assertTrue(fabricWorkers.isEmpty());\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testExecuteWithCancellation() {\n\t\tChannelPipeline channelPipeline = _embeddedChannel.pipeline();\n\n\t\tchannelPipeline.addFirst(\n\t\t\tnew ChannelOutboundHandlerAdapter() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void write(\n\t\t\t\t\tChannelHandlerContext channelHandlerContext, Object object,\n\t\t\t\t\tChannelPromise channelPromise) {\n\n\t\t\t\t\tchannelPromise.cancel(true);\n\t\t\t\t}\n\n\t\t\t});\n\n\t\ttry {\n\t\t\tNettyFabricAgentStub nettyFabricAgentStub =\n\t\t\t\tnew NettyFabricAgentStub(\n\t\t\t\t\t_embeddedChannel, new MockRepository(),\n\t\t\t\t\tPaths.get(\"RepositoryPath\"), 0, Long.MAX_VALUE);\n\n\t\t\tBuilder builder = new Builder();\n\n\t\t\tFabricWorker<String> fabricWorker =  nettyFabricAgentStub.execute(\n\t\t\t\tbuilder.build(),\n\t\t\t\tnew ReturnProcessCallable<String>(\"Test result\"));\n\n\t\t\tNoticeableFuture<String> noticeableFuture =\n\t\t\t\tfabricWorker.getProcessNoticeableFuture();\n\n\t\t\tAssert.assertTrue(noticeableFuture.isCancelled());\n\n\t\t\tCollection<? extends FabricWorker<?>> fabricWorkers =\n\t\t\t\tnettyFabricAgentStub.getFabricWorkers();\n\n\t\t\tAssert.assertTrue(fabricWorkers.isEmpty());\n\t\t}\n\t\tfinally {\n\t\t\tchannelPipeline.removeFirst();\n\t\t}\n\t}","id":99148,"modified_method":"@Test\n\tpublic void testExecuteWithCancellation() {\n\t\tChannelPipeline channelPipeline = _embeddedChannel.pipeline();\n\n\t\tchannelPipeline.addFirst(\n\t\t\tnew ChannelOutboundHandlerAdapter() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void write(\n\t\t\t\t\tChannelHandlerContext channelHandlerContext, Object object,\n\t\t\t\t\tChannelPromise channelPromise) {\n\n\t\t\t\t\tchannelPromise.cancel(true);\n\t\t\t\t}\n\n\t\t\t});\n\n\t\ttry {\n\t\t\tNettyFabricAgentStub nettyFabricAgentStub =\n\t\t\t\tnew NettyFabricAgentStub(\n\t\t\t\t\t_embeddedChannel, new MockRepository<Channel>(),\n\t\t\t\t\tPaths.get(\"RepositoryPath\"), 0, Long.MAX_VALUE);\n\n\t\t\tBuilder builder = new Builder();\n\n\t\t\tFabricWorker<String> fabricWorker =  nettyFabricAgentStub.execute(\n\t\t\t\tbuilder.build(),\n\t\t\t\tnew ReturnProcessCallable<String>(\"Test result\"));\n\n\t\t\tNoticeableFuture<String> noticeableFuture =\n\t\t\t\tfabricWorker.getProcessNoticeableFuture();\n\n\t\t\tAssert.assertTrue(noticeableFuture.isCancelled());\n\n\t\t\tCollection<? extends FabricWorker<?>> fabricWorkers =\n\t\t\t\tnettyFabricAgentStub.getFabricWorkers();\n\n\t\t\tAssert.assertTrue(fabricWorkers.isEmpty());\n\t\t}\n\t\tfinally {\n\t\t\tchannelPipeline.removeFirst();\n\t\t}\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testExecuteWithTimeout() throws InterruptedException {\n\t\tNettyFabricAgentStub nettyFabricAgentStub =\n\t\t\tnew NettyFabricAgentStub(\n\t\t\t\t_embeddedChannel, new MockRepository(),\n\t\t\t\tPaths.get(\"RepositoryPath\"), 0, 0);\n\n\t\tBuilder builder = new Builder();\n\n\t\tFabricWorker<String> fabricWorker =  nettyFabricAgentStub.execute(\n\t\t\tbuilder.build(), new ReturnProcessCallable<String>(\"Test result\"));\n\n\t\tNoticeableFuture<String> noticeableFuture =\n\t\t\tfabricWorker.getProcessNoticeableFuture();\n\n\t\ttry {\n\t\t\tnoticeableFuture.get();\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (ExecutionException ee) {\n\t\t\tThrowable throwable = ee.getCause();\n\n\t\t\tAssert.assertSame(TimeoutException.class, throwable.getClass());\n\t\t}\n\n\t\tCollection<? extends FabricWorker<?>> fabricWorkers =\n\t\t\tnettyFabricAgentStub.getFabricWorkers();\n\n\t\tAssert.assertTrue(fabricWorkers.isEmpty());\n\t}","id":99149,"modified_method":"@Test\n\tpublic void testExecuteWithTimeout() throws InterruptedException {\n\t\tNettyFabricAgentStub nettyFabricAgentStub =\n\t\t\tnew NettyFabricAgentStub(\n\t\t\t\t_embeddedChannel, new MockRepository<Channel>(),\n\t\t\t\tPaths.get(\"RepositoryPath\"), 0, 0);\n\n\t\tBuilder builder = new Builder();\n\n\t\tFabricWorker<String> fabricWorker =  nettyFabricAgentStub.execute(\n\t\t\tbuilder.build(), new ReturnProcessCallable<String>(\"Test result\"));\n\n\t\tNoticeableFuture<String> noticeableFuture =\n\t\t\tfabricWorker.getProcessNoticeableFuture();\n\n\t\ttry {\n\t\t\tnoticeableFuture.get();\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (ExecutionException ee) {\n\t\t\tThrowable throwable = ee.getCause();\n\n\t\t\tAssert.assertSame(TimeoutException.class, throwable.getClass());\n\t\t}\n\n\t\tCollection<? extends FabricWorker<?>> fabricWorkers =\n\t\t\tnettyFabricAgentStub.getFabricWorkers();\n\n\t\tAssert.assertTrue(fabricWorkers.isEmpty());\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testExecuteWithFailure() throws Exception {\n\t\tfinal Throwable throwable = new Throwable();\n\n\t\tChannelPipeline channelPipeline = _embeddedChannel.pipeline();\n\n\t\tchannelPipeline.addFirst(\n\t\t\tnew ChannelOutboundHandlerAdapter() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void write(\n\t\t\t\t\tChannelHandlerContext channelHandlerContext, Object object,\n\t\t\t\t\tChannelPromise channelPromise) {\n\n\t\t\t\t\tchannelPromise.setFailure(throwable);\n\t\t\t\t}\n\n\t\t\t});\n\n\t\ttry {\n\t\t\tNettyFabricAgentStub nettyFabricAgentStub =\n\t\t\t\tnew NettyFabricAgentStub(\n\t\t\t\t\t_embeddedChannel, new MockRepository(),\n\t\t\t\t\tPaths.get(\"RepositoryPath\"), 0, Long.MAX_VALUE);\n\n\t\t\tBuilder builder = new Builder();\n\n\t\t\tFabricWorker<String> fabricWorker =  nettyFabricAgentStub.execute(\n\t\t\t\tbuilder.build(),\n\t\t\t\tnew ReturnProcessCallable<String>(\"Test result\"));\n\n\t\t\tNoticeableFuture<String> noticeableFuture =\n\t\t\t\tfabricWorker.getProcessNoticeableFuture();\n\n\t\t\ttry {\n\t\t\t\tnoticeableFuture.get();\n\n\t\t\t\tAssert.fail();\n\t\t\t}\n\t\t\tcatch (ExecutionException ee) {\n\t\t\t\tAssert.assertSame(throwable, ee.getCause());\n\t\t\t}\n\n\t\t\tCollection<? extends FabricWorker<?>> fabricWorkers =\n\t\t\t\tnettyFabricAgentStub.getFabricWorkers();\n\n\t\t\tAssert.assertTrue(fabricWorkers.isEmpty());\n\t\t}\n\t\tfinally {\n\t\t\tchannelPipeline.removeFirst();\n\t\t}\n\t}","id":99150,"modified_method":"@Test\n\tpublic void testExecuteWithFailure() throws Exception {\n\t\tfinal Throwable throwable = new Throwable();\n\n\t\tChannelPipeline channelPipeline = _embeddedChannel.pipeline();\n\n\t\tchannelPipeline.addFirst(\n\t\t\tnew ChannelOutboundHandlerAdapter() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void write(\n\t\t\t\t\tChannelHandlerContext channelHandlerContext, Object object,\n\t\t\t\t\tChannelPromise channelPromise) {\n\n\t\t\t\t\tchannelPromise.setFailure(throwable);\n\t\t\t\t}\n\n\t\t\t});\n\n\t\ttry {\n\t\t\tNettyFabricAgentStub nettyFabricAgentStub =\n\t\t\t\tnew NettyFabricAgentStub(\n\t\t\t\t\t_embeddedChannel, new MockRepository<Channel>(),\n\t\t\t\t\tPaths.get(\"RepositoryPath\"), 0, Long.MAX_VALUE);\n\n\t\t\tBuilder builder = new Builder();\n\n\t\t\tFabricWorker<String> fabricWorker =  nettyFabricAgentStub.execute(\n\t\t\t\tbuilder.build(),\n\t\t\t\tnew ReturnProcessCallable<String>(\"Test result\"));\n\n\t\t\tNoticeableFuture<String> noticeableFuture =\n\t\t\t\tfabricWorker.getProcessNoticeableFuture();\n\n\t\t\ttry {\n\t\t\t\tnoticeableFuture.get();\n\n\t\t\t\tAssert.fail();\n\t\t\t}\n\t\t\tcatch (ExecutionException ee) {\n\t\t\t\tAssert.assertSame(throwable, ee.getCause());\n\t\t\t}\n\n\t\t\tCollection<? extends FabricWorker<?>> fabricWorkers =\n\t\t\t\tnettyFabricAgentStub.getFabricWorkers();\n\n\t\t\tAssert.assertTrue(fabricWorkers.isEmpty());\n\t\t}\n\t\tfinally {\n\t\t\tchannelPipeline.removeFirst();\n\t\t}\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testGetFabricStatus() {\n\t\tNettyFabricAgentStub nettyFabricAgentStub = new NettyFabricAgentStub(\n\t\t\t_embeddedChannel, new MockRepository(), Paths.get(\"RepositoryPath\"),\n\t\t\t0, 0);\n\n\t\tFabricStatus fabricStatus = nettyFabricAgentStub.getFabricStatus();\n\n\t\tAssert.assertSame(RemoteFabricStatus.class, fabricStatus.getClass());\n\t}","id":99151,"modified_method":"@Test\n\tpublic void testGetFabricStatus() {\n\t\tNettyFabricAgentStub nettyFabricAgentStub = new NettyFabricAgentStub(\n\t\t\t_embeddedChannel, new MockRepository<Channel>(),\n\t\t\tPaths.get(\"RepositoryPath\"), 0, 0);\n\n\t\tFabricStatus fabricStatus = nettyFabricAgentStub.getFabricStatus();\n\n\t\tAssert.assertSame(RemoteFabricStatus.class, fabricStatus.getClass());\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testHashCode() {\n\t\tNettyFabricAgentStub nettyFabricAgentStub = new NettyFabricAgentStub(\n\t\t\t_embeddedChannel, new MockRepository(), Paths.get(\"RepositoryPath\"),\n\t\t\t0, 0);\n\n\t\tAssert.assertEquals(\n\t\t\t_embeddedChannel.hashCode(), nettyFabricAgentStub.hashCode());\n\t}","id":99152,"modified_method":"@Test\n\tpublic void testHashCode() {\n\t\tNettyFabricAgentStub nettyFabricAgentStub = new NettyFabricAgentStub(\n\t\t\t_embeddedChannel, new MockRepository<Channel>(),\n\t\t\tPaths.get(\"RepositoryPath\"), 0, 0);\n\n\t\tAssert.assertEquals(\n\t\t\t_embeddedChannel.hashCode(), nettyFabricAgentStub.hashCode());\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testConstructor() {\n\t\ttry {\n\t\t\tnew NettyFabricAgentStub(null, null, null, 0, 0);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (NullPointerException npe) {\n\t\t\tAssert.assertEquals(\"Channel is null\", npe.getMessage());\n\t\t}\n\n\t\ttry {\n\t\t\tnew NettyFabricAgentStub(_embeddedChannel, null, null, 0, 0);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (NullPointerException npe) {\n\t\t\tAssert.assertEquals(\"Repository is null\", npe.getMessage());\n\t\t}\n\n\t\ttry {\n\t\t\tnew NettyFabricAgentStub(\n\t\t\t\t_embeddedChannel, new MockRepository(), null, 0, 0);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (NullPointerException npe) {\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Remote repository path is null\", npe.getMessage());\n\t\t}\n\n\t\tnew NettyFabricAgentStub(\n\t\t\t_embeddedChannel, new MockRepository(), Paths.get(\"RepositoryPath\"),\n\t\t\t0, 0);\n\t}","id":99153,"modified_method":"@Test\n\tpublic void testConstructor() {\n\t\ttry {\n\t\t\tnew NettyFabricAgentStub(null, null, null, 0, 0);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (NullPointerException npe) {\n\t\t\tAssert.assertEquals(\"Channel is null\", npe.getMessage());\n\t\t}\n\n\t\ttry {\n\t\t\tnew NettyFabricAgentStub(_embeddedChannel, null, null, 0, 0);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (NullPointerException npe) {\n\t\t\tAssert.assertEquals(\"Repository is null\", npe.getMessage());\n\t\t}\n\n\t\ttry {\n\t\t\tnew NettyFabricAgentStub(\n\t\t\t\t_embeddedChannel, new MockRepository<Channel>(), null, 0, 0);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (NullPointerException npe) {\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Remote repository path is null\", npe.getMessage());\n\t\t}\n\n\t\tnew NettyFabricAgentStub(\n\t\t\t_embeddedChannel, new MockRepository<Channel>(),\n\t\t\tPaths.get(\"RepositoryPath\"), 0, 0);\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testExecuteWithClosedChannel() {\n\t\tChannelPipeline channelPipeline = _embeddedChannel.pipeline();\n\n\t\tchannelPipeline.addFirst(\n\t\t\tnew ChannelOutboundHandlerAdapter() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void write(\n\t\t\t\t\tChannelHandlerContext channelHandlerContext, Object object,\n\t\t\t\t\tChannelPromise channelPromise) {\n\n\t\t\t\t\t_embeddedChannel.close();\n\t\t\t\t}\n\n\t\t\t});\n\n\t\ttry {\n\t\t\tNettyFabricAgentStub nettyFabricAgentStub =\n\t\t\t\tnew NettyFabricAgentStub(\n\t\t\t\t\t_embeddedChannel, new MockRepository(),\n\t\t\t\t\tPaths.get(\"RepositoryPath\"), 0, Long.MAX_VALUE);\n\n\t\t\tBuilder builder = new Builder();\n\n\t\t\tFabricWorker<String> fabricWorker =  nettyFabricAgentStub.execute(\n\t\t\t\tbuilder.build(),\n\t\t\t\tnew ReturnProcessCallable<String>(\"Test result\"));\n\n\t\t\tNoticeableFuture<String> noticeableFuture =\n\t\t\t\tfabricWorker.getProcessNoticeableFuture();\n\n\t\t\tAssert.assertTrue(noticeableFuture.isCancelled());\n\n\t\t\tCollection<? extends FabricWorker<?>> fabricWorkers =\n\t\t\t\tnettyFabricAgentStub.getFabricWorkers();\n\n\t\t\tAssert.assertTrue(fabricWorkers.isEmpty());\n\t\t}\n\t\tfinally {\n\t\t\tchannelPipeline.removeFirst();\n\t\t}\n\t}","id":99154,"modified_method":"@Test\n\tpublic void testExecuteWithClosedChannel() {\n\t\tChannelPipeline channelPipeline = _embeddedChannel.pipeline();\n\n\t\tchannelPipeline.addFirst(\n\t\t\tnew ChannelOutboundHandlerAdapter() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void write(\n\t\t\t\t\tChannelHandlerContext channelHandlerContext, Object object,\n\t\t\t\t\tChannelPromise channelPromise) {\n\n\t\t\t\t\t_embeddedChannel.close();\n\t\t\t\t}\n\n\t\t\t});\n\n\t\ttry {\n\t\t\tNettyFabricAgentStub nettyFabricAgentStub =\n\t\t\t\tnew NettyFabricAgentStub(\n\t\t\t\t\t_embeddedChannel, new MockRepository<Channel>(),\n\t\t\t\t\tPaths.get(\"RepositoryPath\"), 0, Long.MAX_VALUE);\n\n\t\t\tBuilder builder = new Builder();\n\n\t\t\tFabricWorker<String> fabricWorker =  nettyFabricAgentStub.execute(\n\t\t\t\tbuilder.build(),\n\t\t\t\tnew ReturnProcessCallable<String>(\"Test result\"));\n\n\t\t\tNoticeableFuture<String> noticeableFuture =\n\t\t\t\tfabricWorker.getProcessNoticeableFuture();\n\n\t\t\tAssert.assertTrue(noticeableFuture.isCancelled());\n\n\t\t\tCollection<? extends FabricWorker<?>> fabricWorkers =\n\t\t\t\tnettyFabricAgentStub.getFabricWorkers();\n\n\t\t\tAssert.assertTrue(fabricWorkers.isEmpty());\n\t\t}\n\t\tfinally {\n\t\t\tchannelPipeline.removeFirst();\n\t\t}\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testEquals() {\n\t\tNettyFabricAgentStub nettyFabricAgentStub = new NettyFabricAgentStub(\n\t\t\t_embeddedChannel, new MockRepository(), Paths.get(\"RepositoryPath\"),\n\t\t\t0, 0);\n\n\t\tAssert.assertTrue(nettyFabricAgentStub.equals(nettyFabricAgentStub));\n\t\tAssert.assertFalse(nettyFabricAgentStub.equals(new Object()));\n\n\t\tNettyFabricAgentStub anotherNettyFabricAgentStub =\n\t\t\tnew NettyFabricAgentStub(\n\t\t\t\tNettyTestUtil.createEmptyEmbeddedChannel(),\n\t\t\t\tnew MockRepository(), Paths.get(\"AnotherRepositoryPath\"), 0, 0);\n\n\t\tAssert.assertFalse(\n\t\t\tnettyFabricAgentStub.equals(anotherNettyFabricAgentStub));\n\n\t\tanotherNettyFabricAgentStub =\n\t\t\tnew NettyFabricAgentStub(\n\t\t\t\t_embeddedChannel, new MockRepository(),\n\t\t\t\tPaths.get(\"AnotherRepositoryPath\"), 0, 0);\n\n\t\tAssert.assertTrue(\n\t\t\tnettyFabricAgentStub.equals(anotherNettyFabricAgentStub));\n\t}","id":99155,"modified_method":"@Test\n\tpublic void testEquals() {\n\t\tNettyFabricAgentStub nettyFabricAgentStub = new NettyFabricAgentStub(\n\t\t\t_embeddedChannel, new MockRepository<Channel>(),\n\t\t\tPaths.get(\"RepositoryPath\"), 0, 0);\n\n\t\tAssert.assertTrue(nettyFabricAgentStub.equals(nettyFabricAgentStub));\n\t\tAssert.assertFalse(nettyFabricAgentStub.equals(new Object()));\n\n\t\tNettyFabricAgentStub anotherNettyFabricAgentStub =\n\t\t\tnew NettyFabricAgentStub(\n\t\t\t\tNettyTestUtil.createEmptyEmbeddedChannel(),\n\t\t\t\tnew MockRepository<Channel>(),\n\t\t\t\tPaths.get(\"AnotherRepositoryPath\"), 0, 0);\n\n\t\tAssert.assertFalse(\n\t\t\tnettyFabricAgentStub.equals(anotherNettyFabricAgentStub));\n\n\t\tanotherNettyFabricAgentStub =\n\t\t\tnew NettyFabricAgentStub(\n\t\t\t\t_embeddedChannel, new MockRepository<Channel>(),\n\t\t\t\tPaths.get(\"AnotherRepositoryPath\"), 0, 0);\n\n\t\tAssert.assertTrue(\n\t\t\tnettyFabricAgentStub.equals(anotherNettyFabricAgentStub));\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testLoadPathsMissedInputPaths() throws InterruptedException {\n\t\tfinal Map<Path, Path> mergedPaths = new HashMap<Path, Path>();\n\n\t\tPath inputPath1 = Paths.get(\"inputPaths1\");\n\t\tPath mappedInputPath1 = Paths.get(\"mappedInputPath1\");\n\t\tPath inputPath2 = Paths.get(\"inputPaths2\");\n\n\t\tmergedPaths.put(inputPath1, mappedInputPath1);\n\n\t\tNettyFabricWorkerExecutionChannelHandler\n\t\t\tnettyFabricWorkerExecutionChannelHandler =\n\t\t\t\tnew NettyFabricWorkerExecutionChannelHandler(\n\t\t\t\t\tnew MockRepository() {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic NoticeableFuture<Map<Path, Path>> getFiles(\n\t\t\t\t\t\t\tMap<Path, Path> pathMap, boolean deleteAfterFetch) {\n\n\t\t\t\t\t\t\tDefaultNoticeableFuture<Map<Path, Path>>\n\t\t\t\t\t\t\t\tdefaultNoticeableFuture =\n\t\t\t\t\t\t\t\t\tnew DefaultNoticeableFuture\n\t\t\t\t\t\t\t\t\t\t<Map<Path, Path>>();\n\n\t\t\t\t\t\t\tdefaultNoticeableFuture.set(mergedPaths);\n\n\t\t\t\t\t\t\treturn defaultNoticeableFuture;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic Path getRepositoryPath() {\n\t\t\t\t\t\t\treturn Paths.get(\"repository\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t},\n\t\t\t\t\tnew LocalFabricAgent(new EmbeddedProcessExecutor()), 0);\n\n\t\tBuilder builder = new Builder();\n\n\t\tbuilder.setBootstrapClassPath(StringPool.BLANK);\n\t\tbuilder.setRuntimeClassPath(StringPool.BLANK);\n\n\t\tProcessConfig processConfig = builder.build();\n\n\t\tProcessCallable<Serializable> processCallable =\n\t\t\tnew LoadPathProcessCallable(\n\t\t\t\tinputPath1.toFile(), inputPath2.toFile());\n\n\t\tFabricPathMappingVisitor fabricPathMappingVisitor =\n\t\t\tnew FabricPathMappingVisitor(\n\t\t\t\tInputResource.class, Paths.get(\"repository\"));\n\n\t\tObjectGraphUtil.walkObjectGraph(\n\t\t\tprocessCallable, fabricPathMappingVisitor);\n\n\t\tNoticeableFuture<LoadedPaths> noticeableFuture =\n\t\t\tnettyFabricWorkerExecutionChannelHandler.loadPaths(\n\t\t\t\tnew NettyFabricWorkerConfig<Serializable>(\n\t\t\t\t\t0, processConfig, processCallable,\n\t\t\t\t\tfabricPathMappingVisitor.getPathMap()));\n\n\t\ttry {\n\t\t\tnoticeableFuture.get();\n\t\t}\n\t\tcatch (ExecutionException ee) {\n\t\t\tThrowable throwable = ee.getCause();\n\n\t\t\tAssert.assertSame(IOException.class, throwable.getClass());\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Unable to get input paths: \" +\n\t\t\t\t\tArrays.asList(inputPath2),\n\t\t\t\tthrowable.getMessage());\n\t\t}\n\t}","id":99156,"modified_method":"@Test\n\tpublic void testLoadPathsMissedInputPaths() throws InterruptedException {\n\t\tfinal Map<Path, Path> mergedPaths = new HashMap<Path, Path>();\n\n\t\tPath inputPath1 = Paths.get(\"inputPaths1\");\n\t\tPath mappedInputPath1 = Paths.get(\"mappedInputPath1\");\n\t\tPath inputPath2 = Paths.get(\"inputPaths2\");\n\n\t\tmergedPaths.put(inputPath1, mappedInputPath1);\n\n\t\tNettyFabricWorkerExecutionChannelHandler\n\t\t\tnettyFabricWorkerExecutionChannelHandler =\n\t\t\t\tnew NettyFabricWorkerExecutionChannelHandler(\n\t\t\t\t\tnew MockRepository<Channel>() {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic NoticeableFuture<Map<Path, Path>> getFiles(\n\t\t\t\t\t\t\tChannel channel, Map<Path, Path> pathMap,\n\t\t\t\t\t\t\tboolean deleteAfterFetch) {\n\n\t\t\t\t\t\t\tDefaultNoticeableFuture<Map<Path, Path>>\n\t\t\t\t\t\t\t\tdefaultNoticeableFuture =\n\t\t\t\t\t\t\t\t\tnew DefaultNoticeableFuture\n\t\t\t\t\t\t\t\t\t\t<Map<Path, Path>>();\n\n\t\t\t\t\t\t\tdefaultNoticeableFuture.set(mergedPaths);\n\n\t\t\t\t\t\t\treturn defaultNoticeableFuture;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic Path getRepositoryPath() {\n\t\t\t\t\t\t\treturn Paths.get(\"repository\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t},\n\t\t\t\t\tnew LocalFabricAgent(new EmbeddedProcessExecutor()), 0);\n\n\t\tBuilder builder = new Builder();\n\n\t\tbuilder.setBootstrapClassPath(StringPool.BLANK);\n\t\tbuilder.setRuntimeClassPath(StringPool.BLANK);\n\n\t\tProcessConfig processConfig = builder.build();\n\n\t\tProcessCallable<Serializable> processCallable =\n\t\t\tnew LoadPathProcessCallable(\n\t\t\t\tinputPath1.toFile(), inputPath2.toFile());\n\n\t\tFabricPathMappingVisitor fabricPathMappingVisitor =\n\t\t\tnew FabricPathMappingVisitor(\n\t\t\t\tInputResource.class, Paths.get(\"repository\"));\n\n\t\tObjectGraphUtil.walkObjectGraph(\n\t\t\tprocessCallable, fabricPathMappingVisitor);\n\n\t\tNoticeableFuture<LoadedPaths> noticeableFuture =\n\t\t\tnettyFabricWorkerExecutionChannelHandler.loadPaths(\n\t\t\t\t_embeddedChannel, new NettyFabricWorkerConfig<Serializable>(\n\t\t\t\t\t0, processConfig, processCallable,\n\t\t\t\t\tfabricPathMappingVisitor.getPathMap()));\n\n\t\ttry {\n\t\t\tnoticeableFuture.get();\n\t\t}\n\t\tcatch (ExecutionException ee) {\n\t\t\tThrowable throwable = ee.getCause();\n\n\t\t\tAssert.assertSame(IOException.class, throwable.getClass());\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Unable to get input paths: \" +\n\t\t\t\t\tArrays.asList(inputPath2),\n\t\t\t\tthrowable.getMessage());\n\t\t}\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected NettyFabricWorkerStub<Serializable>\n\t\tinstallNettyFabricWorkerStub() {\n\n\t\tNettyFabricAgentStub nettyFabricAgentStub =\n\t\t\tNettyChannelAttributes.getNettyFabricAgentStub(_embeddedChannel);\n\n\t\tMap<Long, NettyFabricWorkerStub<?>> nettyFabricWorkerStubs =\n\t\t\tReflectionTestUtil.getFieldValue(\n\t\t\t\tnettyFabricAgentStub, \"_nettyFabricWorkerStubs\");\n\n\t\tNettyFabricWorkerStub<Serializable> nettyFabricWorkerStub =\n\t\t\tnew NettyFabricWorkerStub<Serializable>(\n\t\t\t\t0, _embeddedChannel, new MockRepository(),\n\t\t\t\tCollections.<Path, Path>emptyMap(), 0);\n\n\t\tnettyFabricWorkerStubs.put(0L, nettyFabricWorkerStub);\n\n\t\treturn nettyFabricWorkerStub;\n\t}","id":99157,"modified_method":"protected NettyFabricWorkerStub<Serializable>\n\t\tinstallNettyFabricWorkerStub() {\n\n\t\tNettyFabricAgentStub nettyFabricAgentStub =\n\t\t\tNettyChannelAttributes.getNettyFabricAgentStub(_embeddedChannel);\n\n\t\tMap<Long, NettyFabricWorkerStub<?>> nettyFabricWorkerStubs =\n\t\t\tReflectionTestUtil.getFieldValue(\n\t\t\t\tnettyFabricAgentStub, \"_nettyFabricWorkerStubs\");\n\n\t\tNettyFabricWorkerStub<Serializable> nettyFabricWorkerStub =\n\t\t\tnew NettyFabricWorkerStub<Serializable>(\n\t\t\t\t0, _embeddedChannel, new MockRepository<Channel>(),\n\t\t\t\tCollections.<Path, Path>emptyMap(), 0);\n\n\t\tnettyFabricWorkerStubs.put(0L, nettyFabricWorkerStub);\n\n\t\treturn nettyFabricWorkerStub;\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testLoadPaths() throws Exception {\n\t\tfinal Map<Path, Path> mergedPaths = new HashMap<Path, Path>();\n\n\t\tPath inputPath1 = Paths.get(\"inputPaths1\");\n\t\tPath mappedInputPath1 = Paths.get(\"mappedInputPath1\");\n\t\tPath inputPath2 = Paths.get(\"inputPaths2\");\n\t\tPath mappedInputPath2 = Paths.get(\"mappedInputPath2\");\n\n\t\tmergedPaths.put(inputPath1, mappedInputPath1);\n\t\tmergedPaths.put(inputPath2, mappedInputPath2);\n\n\t\tPath bootstrapPath1 = Paths.get(\"bootstrapPath1\");\n\t\tPath mappedBootstrapPath1 = Paths.get(\"mappedBootstrapPath1\");\n\t\tPath bootstrapPath2 = Paths.get(\"bootstrapPath2\");\n\t\tPath mappedBootstrapPath2 = Paths.get(\"mappedBootstrapPath2\");\n\t\tPath bootstrapPath3 = Paths.get(\"bootstrapPath3\");\n\t\tPath mappedBootstrapPath3 = Paths.get(\"mappedBootstrapPath3\");\n\n\t\tmergedPaths.put(bootstrapPath1, mappedBootstrapPath1);\n\t\tmergedPaths.put(bootstrapPath2, mappedBootstrapPath2);\n\t\tmergedPaths.put(bootstrapPath3, mappedBootstrapPath3);\n\n\t\tPath runtimePath1 = Paths.get(\"runtimePath1\");\n\t\tPath mappedRuntimePath1 = Paths.get(\"mappedRuntimePath1\");\n\t\tPath runtimePath2 = Paths.get(\"runtimePath2\");\n\t\tPath mappedRuntimePath2 = Paths.get(\"mappedRuntimePath2\");\n\t\tPath runtimePath3 = Paths.get(\"runtimePath3\");\n\t\tPath mappedRuntimePath3 = Paths.get(\"mappedRuntimePath3\");\n\n\t\tmergedPaths.put(runtimePath1, mappedRuntimePath1);\n\t\tmergedPaths.put(runtimePath2, mappedRuntimePath2);\n\t\tmergedPaths.put(runtimePath3, mappedRuntimePath3);\n\n\t\tNettyFabricWorkerExecutionChannelHandler\n\t\t\tnettyFabricWorkerExecutionChannelHandler =\n\t\t\t\tnew NettyFabricWorkerExecutionChannelHandler(\n\t\t\t\t\tnew MockRepository() {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic NoticeableFuture<Map<Path, Path>> getFiles(\n\t\t\t\t\t\t\tMap<Path, Path> pathMap, boolean deleteAfterFetch) {\n\n\t\t\t\t\t\t\tDefaultNoticeableFuture<Map<Path, Path>>\n\t\t\t\t\t\t\t\tdefaultNoticeableFuture =\n\t\t\t\t\t\t\t\t\tnew DefaultNoticeableFuture\n\t\t\t\t\t\t\t\t\t\t<Map<Path, Path>>();\n\n\t\t\t\t\t\t\tdefaultNoticeableFuture.set(mergedPaths);\n\n\t\t\t\t\t\t\treturn defaultNoticeableFuture;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic Path getRepositoryPath() {\n\t\t\t\t\t\t\treturn Paths.get(\"repository\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t},\n\t\t\t\t\tnew LocalFabricAgent(new EmbeddedProcessExecutor()), 0);\n\n\t\tBuilder builder = new Builder();\n\n\t\tbuilder.setBootstrapClassPath(\n\t\t\tbootstrapPath1 + File.pathSeparator + bootstrapPath2 +\n\t\t\t\tFile.pathSeparator + bootstrapPath3);\n\t\tbuilder.setRuntimeClassPath(\n\t\t\truntimePath1 + File.pathSeparator + runtimePath2 +\n\t\t\t\tFile.pathSeparator + runtimePath3);\n\n\t\tProcessConfig processConfig = builder.build();\n\n\t\tProcessCallable<Serializable> processCallable =\n\t\t\tnew LoadPathProcessCallable(\n\t\t\t\tinputPath1.toFile(), inputPath2.toFile());\n\n\t\tFabricPathMappingVisitor fabricPathMappingVisitor =\n\t\t\tnew FabricPathMappingVisitor(\n\t\t\t\tInputResource.class, Paths.get(\"repository\"));\n\n\t\tObjectGraphUtil.walkObjectGraph(\n\t\t\tprocessCallable, fabricPathMappingVisitor);\n\n\t\tNoticeableFuture<LoadedPaths> noticeableFuture =\n\t\t\tnettyFabricWorkerExecutionChannelHandler.loadPaths(\n\t\t\t\tnew NettyFabricWorkerConfig<Serializable>(\n\t\t\t\t\t0, processConfig, processCallable,\n\t\t\t\t\tfabricPathMappingVisitor.getPathMap()));\n\n\t\tLoadedPaths loadedPaths = noticeableFuture.get();\n\n\t\tMap<Path, Path> loadedInputPaths = loadedPaths.getInputPaths();\n\n\t\tAssert.assertEquals(2, loadedInputPaths.size());\n\t\tAssert.assertEquals(mappedInputPath1, loadedInputPaths.get(inputPath1));\n\t\tAssert.assertEquals(mappedInputPath2, loadedInputPaths.get(inputPath2));\n\n\t\tprocessConfig = loadedPaths.toProcessConfig(processConfig);\n\n\t\tAssert.assertEquals(\n\t\t\tmappedBootstrapPath1 + File.pathSeparator +\n\t\t\t\tmappedBootstrapPath2 + File.pathSeparator +\n\t\t\t\t\tmappedBootstrapPath3,\n\t\t\tprocessConfig.getBootstrapClassPath());\n\t\tAssert.assertEquals(\n\t\t\tmappedRuntimePath1 + File.pathSeparator +\n\t\t\t\tmappedRuntimePath2 + File.pathSeparator +\n\t\t\t\t\tmappedRuntimePath3,\n\t\t\tprocessConfig.getRuntimeClassPath());\n\t}","id":99158,"modified_method":"@Test\n\tpublic void testLoadPaths() throws Exception {\n\t\tfinal Map<Path, Path> mergedPaths = new HashMap<Path, Path>();\n\n\t\tPath inputPath1 = Paths.get(\"inputPaths1\");\n\t\tPath mappedInputPath1 = Paths.get(\"mappedInputPath1\");\n\t\tPath inputPath2 = Paths.get(\"inputPaths2\");\n\t\tPath mappedInputPath2 = Paths.get(\"mappedInputPath2\");\n\n\t\tmergedPaths.put(inputPath1, mappedInputPath1);\n\t\tmergedPaths.put(inputPath2, mappedInputPath2);\n\n\t\tPath bootstrapPath1 = Paths.get(\"bootstrapPath1\");\n\t\tPath mappedBootstrapPath1 = Paths.get(\"mappedBootstrapPath1\");\n\t\tPath bootstrapPath2 = Paths.get(\"bootstrapPath2\");\n\t\tPath mappedBootstrapPath2 = Paths.get(\"mappedBootstrapPath2\");\n\t\tPath bootstrapPath3 = Paths.get(\"bootstrapPath3\");\n\t\tPath mappedBootstrapPath3 = Paths.get(\"mappedBootstrapPath3\");\n\n\t\tmergedPaths.put(bootstrapPath1, mappedBootstrapPath1);\n\t\tmergedPaths.put(bootstrapPath2, mappedBootstrapPath2);\n\t\tmergedPaths.put(bootstrapPath3, mappedBootstrapPath3);\n\n\t\tPath runtimePath1 = Paths.get(\"runtimePath1\");\n\t\tPath mappedRuntimePath1 = Paths.get(\"mappedRuntimePath1\");\n\t\tPath runtimePath2 = Paths.get(\"runtimePath2\");\n\t\tPath mappedRuntimePath2 = Paths.get(\"mappedRuntimePath2\");\n\t\tPath runtimePath3 = Paths.get(\"runtimePath3\");\n\t\tPath mappedRuntimePath3 = Paths.get(\"mappedRuntimePath3\");\n\n\t\tmergedPaths.put(runtimePath1, mappedRuntimePath1);\n\t\tmergedPaths.put(runtimePath2, mappedRuntimePath2);\n\t\tmergedPaths.put(runtimePath3, mappedRuntimePath3);\n\n\t\tNettyFabricWorkerExecutionChannelHandler\n\t\t\tnettyFabricWorkerExecutionChannelHandler =\n\t\t\t\tnew NettyFabricWorkerExecutionChannelHandler(\n\t\t\t\t\tnew MockRepository<Channel>() {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic NoticeableFuture<Map<Path, Path>> getFiles(\n\t\t\t\t\t\t\tChannel channel, Map<Path, Path> pathMap,\n\t\t\t\t\t\t\tboolean deleteAfterFetch) {\n\n\t\t\t\t\t\t\tDefaultNoticeableFuture<Map<Path, Path>>\n\t\t\t\t\t\t\t\tdefaultNoticeableFuture =\n\t\t\t\t\t\t\t\t\tnew DefaultNoticeableFuture\n\t\t\t\t\t\t\t\t\t\t<Map<Path, Path>>();\n\n\t\t\t\t\t\t\tdefaultNoticeableFuture.set(mergedPaths);\n\n\t\t\t\t\t\t\treturn defaultNoticeableFuture;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic Path getRepositoryPath() {\n\t\t\t\t\t\t\treturn Paths.get(\"repository\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t},\n\t\t\t\t\tnew LocalFabricAgent(new EmbeddedProcessExecutor()), 0);\n\n\t\tBuilder builder = new Builder();\n\n\t\tbuilder.setBootstrapClassPath(\n\t\t\tbootstrapPath1 + File.pathSeparator + bootstrapPath2 +\n\t\t\t\tFile.pathSeparator + bootstrapPath3);\n\t\tbuilder.setRuntimeClassPath(\n\t\t\truntimePath1 + File.pathSeparator + runtimePath2 +\n\t\t\t\tFile.pathSeparator + runtimePath3);\n\n\t\tProcessConfig processConfig = builder.build();\n\n\t\tProcessCallable<Serializable> processCallable =\n\t\t\tnew LoadPathProcessCallable(\n\t\t\t\tinputPath1.toFile(), inputPath2.toFile());\n\n\t\tFabricPathMappingVisitor fabricPathMappingVisitor =\n\t\t\tnew FabricPathMappingVisitor(\n\t\t\t\tInputResource.class, Paths.get(\"repository\"));\n\n\t\tObjectGraphUtil.walkObjectGraph(\n\t\t\tprocessCallable, fabricPathMappingVisitor);\n\n\t\tNoticeableFuture<LoadedPaths> noticeableFuture =\n\t\t\tnettyFabricWorkerExecutionChannelHandler.loadPaths(\n\t\t\t\t_embeddedChannel, new NettyFabricWorkerConfig<Serializable>(\n\t\t\t\t\t0, processConfig, processCallable,\n\t\t\t\t\tfabricPathMappingVisitor.getPathMap()));\n\n\t\tLoadedPaths loadedPaths = noticeableFuture.get();\n\n\t\tMap<Path, Path> loadedInputPaths = loadedPaths.getInputPaths();\n\n\t\tAssert.assertEquals(2, loadedInputPaths.size());\n\t\tAssert.assertEquals(mappedInputPath1, loadedInputPaths.get(inputPath1));\n\t\tAssert.assertEquals(mappedInputPath2, loadedInputPaths.get(inputPath2));\n\n\t\tprocessConfig = loadedPaths.toProcessConfig(processConfig);\n\n\t\tAssert.assertEquals(\n\t\t\tmappedBootstrapPath1 + File.pathSeparator +\n\t\t\t\tmappedBootstrapPath2 + File.pathSeparator +\n\t\t\t\t\tmappedBootstrapPath3,\n\t\t\tprocessConfig.getBootstrapClassPath());\n\t\tAssert.assertEquals(\n\t\t\tmappedRuntimePath1 + File.pathSeparator +\n\t\t\t\tmappedRuntimePath2 + File.pathSeparator +\n\t\t\t\t\tmappedRuntimePath3,\n\t\t\tprocessConfig.getRuntimeClassPath());\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = NettyUtilAdvice.class)\n\t@NewEnv(type = NewEnv.Type.CLASSLOADER)\n\t@Test\n\tpublic void testPostFabricWorkerExecutionFutureListener() throws Exception {\n\n\t\t// Execution failure\n\n\t\tNettyFabricWorkerExecutionChannelHandler\n\t\t\tnettyFabricWorkerExecutionChannelHandler =\n\t\t\t\tnew NettyFabricWorkerExecutionChannelHandler(\n\t\t\t\t\tnew MockRepository(),\n\t\t\t\t\tnew LocalFabricAgent(new EmbeddedProcessExecutor()),\n\t\t\t\t\tLong.MAX_VALUE);\n\n\t\tPostFabricWorkerExecutionFutureListener\n\t\t\tpostFabricWorkerExecutionFutureListener =\n\t\t\t\tnettyFabricWorkerExecutionChannelHandler.\n\t\t\t\t\tnew PostFabricWorkerExecutionFutureListener(\n\t\t\t\t\t\t_embeddedChannel, null,\n\t\t\t\t\t\tcreateNettyFabricWorkerConfig());\n\n\t\tDefaultPromise<FabricWorker<Serializable>> defaultPromise =\n\t\t\tnew DefaultPromise<FabricWorker<Serializable>>(\n\t\t\t\t_embeddedChannel.eventLoop());\n\n\t\tThrowable throwable = new Throwable();\n\n\t\tdefaultPromise.setFailure(throwable);\n\n\t\tinstallNettyFabricAgentStub();\n\n\t\tNettyFabricWorkerStub<Serializable> nettyFabricWorkerStub =\n\t\t\tinstallNettyFabricWorkerStub();\n\n\t\tNoticeableFuture<Serializable> noticeableFuture =\n\t\t\tnettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\tdefaultPromise.addListener(postFabricWorkerExecutionFutureListener);\n\n\t\tinvokeRPC();\n\n\t\ttry {\n\t\t\tnoticeableFuture.get();\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (ExecutionException ee) {\n\t\t\tAssert.assertEquals(throwable, ee.getCause());\n\t\t}\n\n\t\t// Finish startup failure\n\n\t\t_embeddedChannel.close();\n\n\t\tpostFabricWorkerExecutionFutureListener =\n\t\t\tnettyFabricWorkerExecutionChannelHandler.\n\t\t\t\tnew PostFabricWorkerExecutionFutureListener(\n\t\t\t\t\t_embeddedChannel, null, createNettyFabricWorkerConfig());\n\n\t\tdefaultPromise = new DefaultPromise<FabricWorker<Serializable>>(\n\t\t\t_embeddedChannel.eventLoop());\n\n\t\tDefaultNoticeableFuture<Serializable> processNoticeableFuture =\n\t\t\tnew DefaultNoticeableFuture<Serializable>();\n\n\t\tFabricWorker<Serializable> fabricWorker =\n\t\t\tnew LocalFabricWorker<Serializable>(\n\t\t\t\tnew EmbeddedProcessChannel<Serializable>(\n\t\t\t\t\tprocessNoticeableFuture));\n\n\t\tdefaultPromise.setSuccess(fabricWorker);\n\n\t\tnettyFabricWorkerStub = installNettyFabricWorkerStub();\n\n\t\tnoticeableFuture = nettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyFabricWorkerExecutionChannelHandler.class.getName(),\n\t\t\tLevel.SEVERE);\n\n\t\ttry {\n\t\t\tdefaultPromise.addListener(postFabricWorkerExecutionFutureListener);\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertEquals(1, logRecords.size());\n\n\t\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Unable to finish fabric worker startup\",\n\t\t\t\tlogRecord.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\n\t\tAssert.assertSame(\n\t\t\tfabricWorker,\n\t\t\tNettyChannelAttributes.getFabricWorker(_embeddedChannel, 0));\n\n\t\tSet<FutureListener<Serializable>> futureListeners =\n\t\t\tReflectionTestUtil.getFieldValue(\n\t\t\t\tprocessNoticeableFuture, \"_futureListeners\");\n\n\t\tAssert.assertEquals(2, futureListeners.size());\n\n\t\tIterator<FutureListener<Serializable>> iterator =\n\t\t\tfutureListeners.iterator();\n\n\t\titerator.next();\n\n\t\tFutureListener<Serializable> futureListener = iterator.next();\n\n\t\tfutureListener = ReflectionTestUtil.getFieldValue(\n\t\t\tfutureListener, \"_futureListener\");\n\n\t\tAssert.assertSame(\n\t\t\tPostFabricWorkerFinishFutureListener.class,\n\t\t\tfutureListener.getClass());\n\t}","id":99159,"modified_method":"@AdviseWith(adviceClasses = NettyUtilAdvice.class)\n\t@NewEnv(type = NewEnv.Type.CLASSLOADER)\n\t@Test\n\tpublic void testPostFabricWorkerExecutionFutureListener() throws Exception {\n\n\t\t// Execution failure\n\n\t\tNettyFabricWorkerExecutionChannelHandler\n\t\t\tnettyFabricWorkerExecutionChannelHandler =\n\t\t\t\tnew NettyFabricWorkerExecutionChannelHandler(\n\t\t\t\t\tnew MockRepository<Channel>(),\n\t\t\t\t\tnew LocalFabricAgent(new EmbeddedProcessExecutor()),\n\t\t\t\t\tLong.MAX_VALUE);\n\n\t\tPostFabricWorkerExecutionFutureListener\n\t\t\tpostFabricWorkerExecutionFutureListener =\n\t\t\t\tnettyFabricWorkerExecutionChannelHandler.\n\t\t\t\t\tnew PostFabricWorkerExecutionFutureListener(\n\t\t\t\t\t\t_embeddedChannel, null,\n\t\t\t\t\t\tcreateNettyFabricWorkerConfig());\n\n\t\tDefaultPromise<FabricWorker<Serializable>> defaultPromise =\n\t\t\tnew DefaultPromise<FabricWorker<Serializable>>(\n\t\t\t\t_embeddedChannel.eventLoop());\n\n\t\tThrowable throwable = new Throwable();\n\n\t\tdefaultPromise.setFailure(throwable);\n\n\t\tinstallNettyFabricAgentStub();\n\n\t\tNettyFabricWorkerStub<Serializable> nettyFabricWorkerStub =\n\t\t\tinstallNettyFabricWorkerStub();\n\n\t\tNoticeableFuture<Serializable> noticeableFuture =\n\t\t\tnettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\tdefaultPromise.addListener(postFabricWorkerExecutionFutureListener);\n\n\t\tinvokeRPC();\n\n\t\ttry {\n\t\t\tnoticeableFuture.get();\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (ExecutionException ee) {\n\t\t\tAssert.assertEquals(throwable, ee.getCause());\n\t\t}\n\n\t\t// Finish startup failure\n\n\t\t_embeddedChannel.close();\n\n\t\tpostFabricWorkerExecutionFutureListener =\n\t\t\tnettyFabricWorkerExecutionChannelHandler.\n\t\t\t\tnew PostFabricWorkerExecutionFutureListener(\n\t\t\t\t\t_embeddedChannel, null, createNettyFabricWorkerConfig());\n\n\t\tdefaultPromise = new DefaultPromise<FabricWorker<Serializable>>(\n\t\t\t_embeddedChannel.eventLoop());\n\n\t\tDefaultNoticeableFuture<Serializable> processNoticeableFuture =\n\t\t\tnew DefaultNoticeableFuture<Serializable>();\n\n\t\tFabricWorker<Serializable> fabricWorker =\n\t\t\tnew LocalFabricWorker<Serializable>(\n\t\t\t\tnew EmbeddedProcessChannel<Serializable>(\n\t\t\t\t\tprocessNoticeableFuture));\n\n\t\tdefaultPromise.setSuccess(fabricWorker);\n\n\t\tnettyFabricWorkerStub = installNettyFabricWorkerStub();\n\n\t\tnoticeableFuture = nettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyFabricWorkerExecutionChannelHandler.class.getName(),\n\t\t\tLevel.SEVERE);\n\n\t\ttry {\n\t\t\tdefaultPromise.addListener(postFabricWorkerExecutionFutureListener);\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertEquals(1, logRecords.size());\n\n\t\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Unable to finish fabric worker startup\",\n\t\t\t\tlogRecord.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\n\t\tAssert.assertSame(\n\t\t\tfabricWorker,\n\t\t\tNettyChannelAttributes.getFabricWorker(_embeddedChannel, 0));\n\n\t\tSet<FutureListener<Serializable>> futureListeners =\n\t\t\tReflectionTestUtil.getFieldValue(\n\t\t\t\tprocessNoticeableFuture, \"_futureListeners\");\n\n\t\tAssert.assertEquals(2, futureListeners.size());\n\n\t\tIterator<FutureListener<Serializable>> iterator =\n\t\t\tfutureListeners.iterator();\n\n\t\titerator.next();\n\n\t\tFutureListener<Serializable> futureListener = iterator.next();\n\n\t\tfutureListener = ReflectionTestUtil.getFieldValue(\n\t\t\tfutureListener, \"_futureListener\");\n\n\t\tAssert.assertSame(\n\t\t\tPostFabricWorkerFinishFutureListener.class,\n\t\t\tfutureListener.getClass());\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testConstructor() {\n\t\ttry {\n\t\t\tnew NettyFabricWorkerExecutionChannelHandler(null, null, 0);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (NullPointerException npe) {\n\t\t\tAssert.assertEquals(\"Repository is null\", npe.getMessage());\n\t\t}\n\n\t\ttry {\n\t\t\tnew NettyFabricWorkerExecutionChannelHandler(\n\t\t\t\tnew MockRepository(), null, 0);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (NullPointerException npe) {\n\t\t\tAssert.assertEquals(\"Fabric agent is null\", npe.getMessage());\n\t\t}\n\n\t\tnew NettyFabricWorkerExecutionChannelHandler(\n\t\t\tnew MockRepository(),\n\t\t\tnew LocalFabricAgent(new EmbeddedProcessExecutor()), 0);\n\t}","id":99160,"modified_method":"@Test\n\tpublic void testConstructor() {\n\t\ttry {\n\t\t\tnew NettyFabricWorkerExecutionChannelHandler(null, null, 0);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (NullPointerException npe) {\n\t\t\tAssert.assertEquals(\"Repository is null\", npe.getMessage());\n\t\t}\n\n\t\ttry {\n\t\t\tnew NettyFabricWorkerExecutionChannelHandler(\n\t\t\t\tnew MockRepository<Channel>(), null, 0);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (NullPointerException npe) {\n\t\t\tAssert.assertEquals(\"Fabric agent is null\", npe.getMessage());\n\t\t}\n\n\t\tnew NettyFabricWorkerExecutionChannelHandler(\n\t\t\tnew MockRepository<Channel>(),\n\t\t\tnew LocalFabricAgent(new EmbeddedProcessExecutor()), 0);\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = NettyUtilAdvice.class)\n\t@NewEnv(type = NewEnv.Type.CLASSLOADER)\n\t@Test\n\tpublic void testSendResult() throws Exception {\n\n\t\t// Unable to send back fabric worker result\n\n\t\tNettyFabricWorkerExecutionChannelHandler\n\t\t\tnettyFabricWorkerExecutionChannelHandler =\n\t\t\t\tnew NettyFabricWorkerExecutionChannelHandler(\n\t\t\t\t\tnew MockRepository(),\n\t\t\t\t\tnew LocalFabricAgent(new EmbeddedProcessExecutor()),\n\t\t\t\t\tLong.MAX_VALUE);\n\n\t\tChannel channel = NettyTestUtil.createEmptyEmbeddedChannel();\n\n\t\tchannel.close();\n\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyFabricWorkerExecutionChannelHandler.class.getName(),\n\t\t\tLevel.SEVERE);\n\n\t\ttry {\n\t\t\tnettyFabricWorkerExecutionChannelHandler.sendResult(\n\t\t\t\tchannel, 0, StringPool.BLANK, null);\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertEquals(1, logRecords.size());\n\n\t\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Unable to send back fabric worker result \" +\n\t\t\t\t\t\"{id=0, result=, throwable=null}\",\n\t\t\t\tlogRecord.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\n\t\t// Send back result\n\n\t\tinstallNettyFabricAgentStub();\n\n\t\tNettyFabricWorkerStub<Serializable> nettyFabricWorkerStub =\n\t\t\tinstallNettyFabricWorkerStub();\n\n\t\tNoticeableFuture<Serializable> noticeableFuture =\n\t\t\tnettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\tnettyFabricWorkerExecutionChannelHandler.sendResult(\n\t\t\t_embeddedChannel, 0, StringPool.BLANK, null);\n\n\t\tinvokeRPC();\n\n\t\tAssert.assertEquals(StringPool.BLANK, noticeableFuture.get());\n\n\t\t// Send back exception\n\n\t\tnettyFabricWorkerStub = installNettyFabricWorkerStub();\n\n\t\tnoticeableFuture = nettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\tThrowable throwable = new Throwable();\n\n\t\tnettyFabricWorkerExecutionChannelHandler.sendResult(\n\t\t\t_embeddedChannel, 0, null, throwable);\n\n\t\tinvokeRPC();\n\n\t\ttry {\n\t\t\tnoticeableFuture.get();\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (ExecutionException ee) {\n\t\t\tAssert.assertSame(throwable, ee.getCause());\n\t\t}\n\t}","id":99161,"modified_method":"@AdviseWith(adviceClasses = NettyUtilAdvice.class)\n\t@NewEnv(type = NewEnv.Type.CLASSLOADER)\n\t@Test\n\tpublic void testSendResult() throws Exception {\n\n\t\t// Unable to send back fabric worker result\n\n\t\tNettyFabricWorkerExecutionChannelHandler\n\t\t\tnettyFabricWorkerExecutionChannelHandler =\n\t\t\t\tnew NettyFabricWorkerExecutionChannelHandler(\n\t\t\t\t\tnew MockRepository<Channel>(),\n\t\t\t\t\tnew LocalFabricAgent(new EmbeddedProcessExecutor()),\n\t\t\t\t\tLong.MAX_VALUE);\n\n\t\tChannel channel = NettyTestUtil.createEmptyEmbeddedChannel();\n\n\t\tchannel.close();\n\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyFabricWorkerExecutionChannelHandler.class.getName(),\n\t\t\tLevel.SEVERE);\n\n\t\ttry {\n\t\t\tnettyFabricWorkerExecutionChannelHandler.sendResult(\n\t\t\t\tchannel, 0, StringPool.BLANK, null);\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertEquals(1, logRecords.size());\n\n\t\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Unable to send back fabric worker result \" +\n\t\t\t\t\t\"{id=0, result=, throwable=null}\",\n\t\t\t\tlogRecord.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\n\t\t// Send back result\n\n\t\tinstallNettyFabricAgentStub();\n\n\t\tNettyFabricWorkerStub<Serializable> nettyFabricWorkerStub =\n\t\t\tinstallNettyFabricWorkerStub();\n\n\t\tNoticeableFuture<Serializable> noticeableFuture =\n\t\t\tnettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\tnettyFabricWorkerExecutionChannelHandler.sendResult(\n\t\t\t_embeddedChannel, 0, StringPool.BLANK, null);\n\n\t\tinvokeRPC();\n\n\t\tAssert.assertEquals(StringPool.BLANK, noticeableFuture.get());\n\n\t\t// Send back exception\n\n\t\tnettyFabricWorkerStub = installNettyFabricWorkerStub();\n\n\t\tnoticeableFuture = nettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\tThrowable throwable = new Throwable();\n\n\t\tnettyFabricWorkerExecutionChannelHandler.sendResult(\n\t\t\t_embeddedChannel, 0, null, throwable);\n\n\t\tinvokeRPC();\n\n\t\ttry {\n\t\t\tnoticeableFuture.get();\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (ExecutionException ee) {\n\t\t\tAssert.assertSame(throwable, ee.getCause());\n\t\t}\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected NettyFabricAgentStub installNettyFabricAgentStub() {\n\t\tNettyFabricAgentStub nettyFabricAgentStub = new NettyFabricAgentStub(\n\t\t\t_embeddedChannel, new MockRepository(),\n\t\t\tPaths.get(\"remoteRepositoryPath\"), 0, Long.MAX_VALUE);\n\n\t\tNettyChannelAttributes.setNettyFabricAgentStub(\n\t\t\t_embeddedChannel, nettyFabricAgentStub);\n\n\t\treturn nettyFabricAgentStub;\n\t}","id":99162,"modified_method":"protected NettyFabricAgentStub installNettyFabricAgentStub() {\n\t\tNettyFabricAgentStub nettyFabricAgentStub = new NettyFabricAgentStub(\n\t\t\t_embeddedChannel, new MockRepository<Channel>(),\n\t\t\tPaths.get(\"remoteRepositoryPath\"), 0, Long.MAX_VALUE);\n\n\t\tNettyChannelAttributes.setNettyFabricAgentStub(\n\t\t\t_embeddedChannel, nettyFabricAgentStub);\n\n\t\treturn nettyFabricAgentStub;\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = NettyUtilAdvice.class)\n\t@NewEnv(type = NewEnv.Type.CLASSLOADER)\n\t@Test\n\tpublic void testPostLoadPathsFutureListener() throws Exception {\n\n\t\t// Load paths failure\n\n\t\tChannelPipeline channelPipeline = _embeddedChannel.pipeline();\n\n\t\tNettyFabricWorkerExecutionChannelHandler\n\t\t\tnettyFabricWorkerExecutionChannelHandler =\n\t\t\t\tnew NettyFabricWorkerExecutionChannelHandler(\n\t\t\t\t\tnew MockRepository(),\n\t\t\t\t\tnew LocalFabricAgent(new EmbeddedProcessExecutor()),\n\t\t\t\t\tLong.MAX_VALUE);\n\n\t\tchannelPipeline.addLast(nettyFabricWorkerExecutionChannelHandler);\n\n\t\tChannelHandlerContext channelHandlerContext =\n\t\t\tchannelPipeline.lastContext();\n\n\t\tPostLoadPathsFutureListener postLoadPathsFutureListener =\n\t\t\tnettyFabricWorkerExecutionChannelHandler.\n\t\t\t\tnew PostLoadPathsFutureListener(\n\t\t\t\t\tchannelHandlerContext, createNettyFabricWorkerConfig());\n\n\t\tDefaultNoticeableFuture<LoadedPaths> defaultNoticeableFuture =\n\t\t\tnew DefaultNoticeableFuture<LoadedPaths>();\n\n\t\tThrowable throwable = new Throwable();\n\n\t\tdefaultNoticeableFuture.setException(throwable);\n\n\t\tinstallNettyFabricAgentStub();\n\n\t\tNettyFabricWorkerStub<Serializable> nettyFabricWorkerStub =\n\t\t\tinstallNettyFabricWorkerStub();\n\n\t\tNoticeableFuture<Serializable> noticeableFuture =\n\t\t\tnettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\tdefaultNoticeableFuture.addFutureListener(postLoadPathsFutureListener);\n\n\t\tinvokeRPC();\n\n\t\ttry {\n\t\t\tnoticeableFuture.get();\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (ExecutionException ee) {\n\t\t\tAssert.assertSame(throwable, ee.getCause());\n\t\t}\n\n\t\t// Loaded paths\n\n\t\tdefaultNoticeableFuture = new DefaultNoticeableFuture<LoadedPaths>();\n\n\t\tdefaultNoticeableFuture.set(\n\t\t\tnew LoadedPaths(Collections.<Path, Path>emptyMap(), null, null));\n\n\t\tnettyFabricWorkerStub = installNettyFabricWorkerStub();\n\n\t\tnoticeableFuture = nettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\tdefaultNoticeableFuture.addFutureListener(postLoadPathsFutureListener);\n\n\t\t_embeddedChannel.runPendingTasks();\n\n\t\tFabricAgent fabricAgent = ReflectionTestUtil.getFieldValue(\n\t\t\tnettyFabricWorkerExecutionChannelHandler, \"_fabricAgent\");\n\n\t\tCollection<? extends FabricWorker<?>> fabricWorkers =\n\t\t\tfabricAgent.getFabricWorkers();\n\n\t\tAssert.assertEquals(1, fabricWorkers.size());\n\t\tAssert.assertFalse(noticeableFuture.isDone());\n\t}","id":99163,"modified_method":"@AdviseWith(adviceClasses = NettyUtilAdvice.class)\n\t@NewEnv(type = NewEnv.Type.CLASSLOADER)\n\t@Test\n\tpublic void testPostLoadPathsFutureListener() throws Exception {\n\n\t\t// Load paths failure\n\n\t\tChannelPipeline channelPipeline = _embeddedChannel.pipeline();\n\n\t\tNettyFabricWorkerExecutionChannelHandler\n\t\t\tnettyFabricWorkerExecutionChannelHandler =\n\t\t\t\tnew NettyFabricWorkerExecutionChannelHandler(\n\t\t\t\t\tnew MockRepository<Channel>(),\n\t\t\t\t\tnew LocalFabricAgent(new EmbeddedProcessExecutor()),\n\t\t\t\t\tLong.MAX_VALUE);\n\n\t\tchannelPipeline.addLast(nettyFabricWorkerExecutionChannelHandler);\n\n\t\tChannelHandlerContext channelHandlerContext =\n\t\t\tchannelPipeline.lastContext();\n\n\t\tPostLoadPathsFutureListener postLoadPathsFutureListener =\n\t\t\tnettyFabricWorkerExecutionChannelHandler.\n\t\t\t\tnew PostLoadPathsFutureListener(\n\t\t\t\t\tchannelHandlerContext, createNettyFabricWorkerConfig());\n\n\t\tDefaultNoticeableFuture<LoadedPaths> defaultNoticeableFuture =\n\t\t\tnew DefaultNoticeableFuture<LoadedPaths>();\n\n\t\tThrowable throwable = new Throwable();\n\n\t\tdefaultNoticeableFuture.setException(throwable);\n\n\t\tinstallNettyFabricAgentStub();\n\n\t\tNettyFabricWorkerStub<Serializable> nettyFabricWorkerStub =\n\t\t\tinstallNettyFabricWorkerStub();\n\n\t\tNoticeableFuture<Serializable> noticeableFuture =\n\t\t\tnettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\tdefaultNoticeableFuture.addFutureListener(postLoadPathsFutureListener);\n\n\t\tinvokeRPC();\n\n\t\ttry {\n\t\t\tnoticeableFuture.get();\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (ExecutionException ee) {\n\t\t\tAssert.assertSame(throwable, ee.getCause());\n\t\t}\n\n\t\t// Loaded paths\n\n\t\tdefaultNoticeableFuture = new DefaultNoticeableFuture<LoadedPaths>();\n\n\t\tdefaultNoticeableFuture.set(\n\t\t\tnew LoadedPaths(Collections.<Path, Path>emptyMap(), null, null));\n\n\t\tnettyFabricWorkerStub = installNettyFabricWorkerStub();\n\n\t\tnoticeableFuture = nettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\tdefaultNoticeableFuture.addFutureListener(postLoadPathsFutureListener);\n\n\t\t_embeddedChannel.runPendingTasks();\n\n\t\tFabricAgent fabricAgent = ReflectionTestUtil.getFieldValue(\n\t\t\tnettyFabricWorkerExecutionChannelHandler, \"_fabricAgent\");\n\n\t\tCollection<? extends FabricWorker<?>> fabricWorkers =\n\t\t\tfabricAgent.getFabricWorkers();\n\n\t\tAssert.assertEquals(1, fabricWorkers.size());\n\t\tAssert.assertFalse(noticeableFuture.isDone());\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = NettyUtilAdvice.class)\n\t@NewEnv(type = NewEnv.Type.CLASSLOADER)\n\t@Test\n\tpublic void testPostFabricWorkerFinishFutureListener() throws Exception {\n\n\t\t// Finish with execution exception\n\n\t\tNettyFabricWorkerExecutionChannelHandler\n\t\t\tnettyFabricWorkerExecutionChannelHandler =\n\t\t\t\tnew NettyFabricWorkerExecutionChannelHandler(\n\t\t\t\t\tnew MockRepository(),\n\t\t\t\t\tnew LocalFabricAgent(new EmbeddedProcessExecutor()),\n\t\t\t\t\tLong.MAX_VALUE);\n\n\t\tPath inputPath1 = FileServerTestUtil.createEmptyFile(\n\t\t\tPaths.get(\"inputPath1\"));\n\t\tPath inputPath2 = FileServerTestUtil.createEmptyFile(\n\t\t\tPaths.get(\"inputPath2\"));\n\n\t\tMap<Path, Path> inputPaths = new HashMap<Path, Path>();\n\n\t\tinputPaths.put(inputPath1, inputPath1);\n\t\tinputPaths.put(inputPath2, inputPath2);\n\n\t\tPostFabricWorkerFinishFutureListener\n\t\t\tpostFabricWorkerFinishFutureListener =\n\t\t\t\tnettyFabricWorkerExecutionChannelHandler.\n\t\t\t\t\tnew PostFabricWorkerFinishFutureListener(\n\t\t\t\t\t\t_embeddedChannel, createNettyFabricWorkerConfig(),\n\t\t\t\t\t\tnew LoadedPaths(inputPaths, null, null));\n\n\t\tDefaultNoticeableFuture<Serializable> defaultNoticeableFuture =\n\t\t\tnew DefaultNoticeableFuture<Serializable>();\n\n\t\tThrowable throwable = new Throwable();\n\n\t\tdefaultNoticeableFuture.setException(throwable);\n\n\t\tinstallNettyFabricAgentStub();\n\n\t\tNettyFabricWorkerStub<Serializable> nettyFabricWorkerStub =\n\t\t\tinstallNettyFabricWorkerStub();\n\n\t\tNoticeableFuture<?> noticeableFuture =\n\t\t\tnettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\tdefaultNoticeableFuture.addFutureListener(\n\t\t\tpostFabricWorkerFinishFutureListener);\n\n\t\tAssert.assertTrue(Files.notExists(inputPath1));\n\t\tAssert.assertTrue(Files.notExists(inputPath2));\n\n\t\tinvokeRPC();\n\n\t\ttry {\n\t\t\tnoticeableFuture.get();\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (ExecutionException ee) {\n\t\t\tAssert.assertEquals(throwable, ee.getCause());\n\t\t}\n\n\t\t// Finish with null pointer exception\n\n\t\tnettyFabricWorkerStub = installNettyFabricWorkerStub();\n\n\t\tnoticeableFuture = nettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\tpostFabricWorkerFinishFutureListener.complete(null);\n\n\t\tinvokeRPC();\n\n\t\ttry {\n\t\t\tnoticeableFuture.get();\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (ExecutionException ee) {\n\t\t\tThrowable t = ee.getCause();\n\n\t\t\tAssert.assertSame(NullPointerException.class, t.getClass());\n\t\t}\n\n\t\t// Finish with result\n\n\t\tinputPath1 = FileServerTestUtil.createEmptyFile(\n\t\t\tPaths.get(\"inputPath1\"));\n\t\tinputPath2 = FileServerTestUtil.createEmptyFile(\n\t\t\tPaths.get(\"inputPath2\"));\n\n\t\tinputPaths = new HashMap<Path, Path>();\n\n\t\tinputPaths.put(inputPath1, inputPath1);\n\t\tinputPaths.put(inputPath2, inputPath2);\n\n\t\tpostFabricWorkerFinishFutureListener =\n\t\t\tnettyFabricWorkerExecutionChannelHandler.\n\t\t\t\tnew PostFabricWorkerFinishFutureListener(\n\t\t\t\t\t_embeddedChannel, createNettyFabricWorkerConfig(),\n\t\t\t\t\tnew LoadedPaths(inputPaths, null, null));\n\n\t\tdefaultNoticeableFuture = new DefaultNoticeableFuture<Serializable>();\n\n\t\tdefaultNoticeableFuture.set(StringPool.BLANK);\n\n\t\tnettyFabricWorkerStub = installNettyFabricWorkerStub();\n\n\t\tnoticeableFuture = nettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\tdefaultNoticeableFuture.addFutureListener(\n\t\t\tpostFabricWorkerFinishFutureListener);\n\n\t\tAssert.assertTrue(Files.notExists(inputPath1));\n\t\tAssert.assertTrue(Files.notExists(inputPath2));\n\n\t\tinvokeRPC();\n\n\t\tAssert.assertEquals(StringPool.BLANK, noticeableFuture.get());\n\t}","id":99164,"modified_method":"@AdviseWith(adviceClasses = NettyUtilAdvice.class)\n\t@NewEnv(type = NewEnv.Type.CLASSLOADER)\n\t@Test\n\tpublic void testPostFabricWorkerFinishFutureListener() throws Exception {\n\n\t\t// Finish with execution exception\n\n\t\tNettyFabricWorkerExecutionChannelHandler\n\t\t\tnettyFabricWorkerExecutionChannelHandler =\n\t\t\t\tnew NettyFabricWorkerExecutionChannelHandler(\n\t\t\t\t\tnew MockRepository<Channel>(),\n\t\t\t\t\tnew LocalFabricAgent(new EmbeddedProcessExecutor()),\n\t\t\t\t\tLong.MAX_VALUE);\n\n\t\tPath inputPath1 = FileServerTestUtil.createEmptyFile(\n\t\t\tPaths.get(\"inputPath1\"));\n\t\tPath inputPath2 = FileServerTestUtil.createEmptyFile(\n\t\t\tPaths.get(\"inputPath2\"));\n\n\t\tMap<Path, Path> inputPaths = new HashMap<Path, Path>();\n\n\t\tinputPaths.put(inputPath1, inputPath1);\n\t\tinputPaths.put(inputPath2, inputPath2);\n\n\t\tPostFabricWorkerFinishFutureListener\n\t\t\tpostFabricWorkerFinishFutureListener =\n\t\t\t\tnettyFabricWorkerExecutionChannelHandler.\n\t\t\t\t\tnew PostFabricWorkerFinishFutureListener(\n\t\t\t\t\t\t_embeddedChannel, createNettyFabricWorkerConfig(),\n\t\t\t\t\t\tnew LoadedPaths(inputPaths, null, null));\n\n\t\tDefaultNoticeableFuture<Serializable> defaultNoticeableFuture =\n\t\t\tnew DefaultNoticeableFuture<Serializable>();\n\n\t\tThrowable throwable = new Throwable();\n\n\t\tdefaultNoticeableFuture.setException(throwable);\n\n\t\tinstallNettyFabricAgentStub();\n\n\t\tNettyFabricWorkerStub<Serializable> nettyFabricWorkerStub =\n\t\t\tinstallNettyFabricWorkerStub();\n\n\t\tNoticeableFuture<?> noticeableFuture =\n\t\t\tnettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\tdefaultNoticeableFuture.addFutureListener(\n\t\t\tpostFabricWorkerFinishFutureListener);\n\n\t\tAssert.assertTrue(Files.notExists(inputPath1));\n\t\tAssert.assertTrue(Files.notExists(inputPath2));\n\n\t\tinvokeRPC();\n\n\t\ttry {\n\t\t\tnoticeableFuture.get();\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (ExecutionException ee) {\n\t\t\tAssert.assertEquals(throwable, ee.getCause());\n\t\t}\n\n\t\t// Finish with null pointer exception\n\n\t\tnettyFabricWorkerStub = installNettyFabricWorkerStub();\n\n\t\tnoticeableFuture = nettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\tpostFabricWorkerFinishFutureListener.complete(null);\n\n\t\tinvokeRPC();\n\n\t\ttry {\n\t\t\tnoticeableFuture.get();\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (ExecutionException ee) {\n\t\t\tThrowable t = ee.getCause();\n\n\t\t\tAssert.assertSame(NullPointerException.class, t.getClass());\n\t\t}\n\n\t\t// Finish with result\n\n\t\tinputPath1 = FileServerTestUtil.createEmptyFile(\n\t\t\tPaths.get(\"inputPath1\"));\n\t\tinputPath2 = FileServerTestUtil.createEmptyFile(\n\t\t\tPaths.get(\"inputPath2\"));\n\n\t\tinputPaths = new HashMap<Path, Path>();\n\n\t\tinputPaths.put(inputPath1, inputPath1);\n\t\tinputPaths.put(inputPath2, inputPath2);\n\n\t\tpostFabricWorkerFinishFutureListener =\n\t\t\tnettyFabricWorkerExecutionChannelHandler.\n\t\t\t\tnew PostFabricWorkerFinishFutureListener(\n\t\t\t\t\t_embeddedChannel, createNettyFabricWorkerConfig(),\n\t\t\t\t\tnew LoadedPaths(inputPaths, null, null));\n\n\t\tdefaultNoticeableFuture = new DefaultNoticeableFuture<Serializable>();\n\n\t\tdefaultNoticeableFuture.set(StringPool.BLANK);\n\n\t\tnettyFabricWorkerStub = installNettyFabricWorkerStub();\n\n\t\tnoticeableFuture = nettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\tdefaultNoticeableFuture.addFutureListener(\n\t\t\tpostFabricWorkerFinishFutureListener);\n\n\t\tAssert.assertTrue(Files.notExists(inputPath1));\n\t\tAssert.assertTrue(Files.notExists(inputPath2));\n\n\t\tinvokeRPC();\n\n\t\tAssert.assertEquals(StringPool.BLANK, noticeableFuture.get());\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testLoadPathsMissedRuntimePaths() throws Exception {\n\n\t\t// With log\n\n\t\tfinal Map<Path, Path> mergedPaths = new HashMap<Path, Path>();\n\n\t\tPath runtimePath1 = Paths.get(\"runtimePath1\");\n\t\tPath mappedRuntimePath1 = Paths.get(\"mappedRuntimePath1\");\n\t\tPath runtimePath2 = Paths.get(\"runtimePath2\");\n\t\tPath runtimePath3 = Paths.get(\"runtimePath3\");\n\t\tPath mappedRuntimePath3 = Paths.get(\"mappedRuntimePath3\");\n\n\t\tmergedPaths.put(runtimePath1, mappedRuntimePath1);\n\t\tmergedPaths.put(runtimePath3, mappedRuntimePath3);\n\n\t\tNettyFabricWorkerExecutionChannelHandler\n\t\t\tnettyFabricWorkerExecutionChannelHandler =\n\t\t\t\tnew NettyFabricWorkerExecutionChannelHandler(\n\t\t\t\t\tnew MockRepository() {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic NoticeableFuture<Map<Path, Path>> getFiles(\n\t\t\t\t\t\t\tMap<Path, Path> pathMap, boolean deleteAfterFetch) {\n\n\t\t\t\t\t\t\tDefaultNoticeableFuture<Map<Path, Path>>\n\t\t\t\t\t\t\t\tdefaultNoticeableFuture =\n\t\t\t\t\t\t\t\t\tnew DefaultNoticeableFuture\n\t\t\t\t\t\t\t\t\t\t<Map<Path, Path>>();\n\n\t\t\t\t\t\t\tdefaultNoticeableFuture.set(mergedPaths);\n\n\t\t\t\t\t\t\treturn defaultNoticeableFuture;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic Path getRepositoryPath() {\n\t\t\t\t\t\t\treturn Paths.get(\"repository\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t},\n\t\t\t\t\tnew LocalFabricAgent(new EmbeddedProcessExecutor()), 0);\n\n\t\tBuilder builder = new Builder();\n\n\t\tbuilder.setBootstrapClassPath(StringPool.BLANK);\n\t\tbuilder.setRuntimeClassPath(\n\t\t\truntimePath1 + File.pathSeparator + runtimePath2 +\n\t\t\t\tFile.pathSeparator + runtimePath3);\n\n\t\tProcessConfig processConfig = builder.build();\n\n\t\tProcessCallable<Serializable> processCallable =\n\t\t\tnew ReturnProcessCallable<Serializable>(null);\n\n\t\tFabricPathMappingVisitor fabricPathMappingVisitor =\n\t\t\tnew FabricPathMappingVisitor(\n\t\t\t\tInputResource.class, Paths.get(\"repository\"));\n\n\t\tObjectGraphUtil.walkObjectGraph(\n\t\t\tprocessCallable, fabricPathMappingVisitor);\n\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyFabricWorkerExecutionChannelHandler.class.getName(),\n\t\t\tLevel.WARNING);\n\n\t\ttry {\n\t\t\tNoticeableFuture<LoadedPaths> noticeableFuture =\n\t\t\t\tnettyFabricWorkerExecutionChannelHandler.loadPaths(\n\t\t\t\t\tnew NettyFabricWorkerConfig<Serializable>(\n\t\t\t\t\t\t0, processConfig, processCallable,\n\t\t\t\t\t\tfabricPathMappingVisitor.getPathMap()));\n\n\t\t\tLoadedPaths loadedPaths = noticeableFuture.get();\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertEquals(1, logRecords.size());\n\n\t\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Incomplete runtime classpath loaded, missed: \" +\n\t\t\t\t\tArrays.asList(runtimePath2),\n\t\t\t\tlogRecord.getMessage());\n\n\t\t\tMap<Path, Path> loadedInputPaths = loadedPaths.getInputPaths();\n\n\t\t\tAssert.assertTrue(loadedInputPaths.isEmpty());\n\n\t\t\tProcessConfig loadedProcessConfig = loadedPaths.toProcessConfig(\n\t\t\t\tprocessConfig);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tStringPool.BLANK, loadedProcessConfig.getBootstrapClassPath());\n\t\t\tAssert.assertEquals(\n\t\t\t\tmappedRuntimePath1 + File.pathSeparator +\n\t\t\t\t\tmappedRuntimePath3,\n\t\t\t\tloadedProcessConfig.getRuntimeClassPath());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\n\t\t// Without log\n\n\t\tcaptureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyFabricWorkerExecutionChannelHandler.class.getName(),\n\t\t\tLevel.OFF);\n\n\t\ttry {\n\t\t\tNoticeableFuture<LoadedPaths> noticeableFuture =\n\t\t\t\tnettyFabricWorkerExecutionChannelHandler.loadPaths(\n\t\t\t\t\tnew NettyFabricWorkerConfig<Serializable>(\n\t\t\t\t\t\t0, processConfig, processCallable,\n\t\t\t\t\t\tfabricPathMappingVisitor.getPathMap()));\n\n\t\t\tLoadedPaths loadedPaths = noticeableFuture.get();\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertTrue(logRecords.isEmpty());\n\n\t\t\tMap<Path, Path> loadedInputPaths = loadedPaths.getInputPaths();\n\n\t\t\tAssert.assertTrue(loadedInputPaths.isEmpty());\n\n\t\t\tProcessConfig loadedProcessConfig = loadedPaths.toProcessConfig(\n\t\t\t\tprocessConfig);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tStringPool.BLANK, loadedProcessConfig.getBootstrapClassPath());\n\t\t\tAssert.assertEquals(\n\t\t\t\tmappedRuntimePath1 + File.pathSeparator +\n\t\t\t\t\tmappedRuntimePath3,\n\t\t\t\tloadedProcessConfig.getRuntimeClassPath());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\t}","id":99165,"modified_method":"@Test\n\tpublic void testLoadPathsMissedRuntimePaths() throws Exception {\n\n\t\t// With log\n\n\t\tfinal Map<Path, Path> mergedPaths = new HashMap<Path, Path>();\n\n\t\tPath runtimePath1 = Paths.get(\"runtimePath1\");\n\t\tPath mappedRuntimePath1 = Paths.get(\"mappedRuntimePath1\");\n\t\tPath runtimePath2 = Paths.get(\"runtimePath2\");\n\t\tPath runtimePath3 = Paths.get(\"runtimePath3\");\n\t\tPath mappedRuntimePath3 = Paths.get(\"mappedRuntimePath3\");\n\n\t\tmergedPaths.put(runtimePath1, mappedRuntimePath1);\n\t\tmergedPaths.put(runtimePath3, mappedRuntimePath3);\n\n\t\tNettyFabricWorkerExecutionChannelHandler\n\t\t\tnettyFabricWorkerExecutionChannelHandler =\n\t\t\t\tnew NettyFabricWorkerExecutionChannelHandler(\n\t\t\t\t\tnew MockRepository<Channel>() {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic NoticeableFuture<Map<Path, Path>> getFiles(\n\t\t\t\t\t\t\tChannel channel, Map<Path, Path> pathMap,\n\t\t\t\t\t\t\tboolean deleteAfterFetch) {\n\n\t\t\t\t\t\t\tDefaultNoticeableFuture<Map<Path, Path>>\n\t\t\t\t\t\t\t\tdefaultNoticeableFuture =\n\t\t\t\t\t\t\t\t\tnew DefaultNoticeableFuture\n\t\t\t\t\t\t\t\t\t\t<Map<Path, Path>>();\n\n\t\t\t\t\t\t\tdefaultNoticeableFuture.set(mergedPaths);\n\n\t\t\t\t\t\t\treturn defaultNoticeableFuture;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic Path getRepositoryPath() {\n\t\t\t\t\t\t\treturn Paths.get(\"repository\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t},\n\t\t\t\t\tnew LocalFabricAgent(new EmbeddedProcessExecutor()), 0);\n\n\t\tBuilder builder = new Builder();\n\n\t\tbuilder.setBootstrapClassPath(StringPool.BLANK);\n\t\tbuilder.setRuntimeClassPath(\n\t\t\truntimePath1 + File.pathSeparator + runtimePath2 +\n\t\t\t\tFile.pathSeparator + runtimePath3);\n\n\t\tProcessConfig processConfig = builder.build();\n\n\t\tProcessCallable<Serializable> processCallable =\n\t\t\tnew ReturnProcessCallable<Serializable>(null);\n\n\t\tFabricPathMappingVisitor fabricPathMappingVisitor =\n\t\t\tnew FabricPathMappingVisitor(\n\t\t\t\tInputResource.class, Paths.get(\"repository\"));\n\n\t\tObjectGraphUtil.walkObjectGraph(\n\t\t\tprocessCallable, fabricPathMappingVisitor);\n\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyFabricWorkerExecutionChannelHandler.class.getName(),\n\t\t\tLevel.WARNING);\n\n\t\ttry {\n\t\t\tNoticeableFuture<LoadedPaths> noticeableFuture =\n\t\t\t\tnettyFabricWorkerExecutionChannelHandler.loadPaths(\n\t\t\t\t\t_embeddedChannel, new NettyFabricWorkerConfig<Serializable>(\n\t\t\t\t\t\t0, processConfig, processCallable,\n\t\t\t\t\t\tfabricPathMappingVisitor.getPathMap()));\n\n\t\t\tLoadedPaths loadedPaths = noticeableFuture.get();\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertEquals(1, logRecords.size());\n\n\t\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Incomplete runtime classpath loaded, missed: \" +\n\t\t\t\t\tArrays.asList(runtimePath2),\n\t\t\t\tlogRecord.getMessage());\n\n\t\t\tMap<Path, Path> loadedInputPaths = loadedPaths.getInputPaths();\n\n\t\t\tAssert.assertTrue(loadedInputPaths.isEmpty());\n\n\t\t\tProcessConfig loadedProcessConfig = loadedPaths.toProcessConfig(\n\t\t\t\tprocessConfig);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tStringPool.BLANK, loadedProcessConfig.getBootstrapClassPath());\n\t\t\tAssert.assertEquals(\n\t\t\t\tmappedRuntimePath1 + File.pathSeparator +\n\t\t\t\t\tmappedRuntimePath3,\n\t\t\t\tloadedProcessConfig.getRuntimeClassPath());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\n\t\t// Without log\n\n\t\tcaptureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyFabricWorkerExecutionChannelHandler.class.getName(),\n\t\t\tLevel.OFF);\n\n\t\ttry {\n\t\t\tNoticeableFuture<LoadedPaths> noticeableFuture =\n\t\t\t\tnettyFabricWorkerExecutionChannelHandler.loadPaths(\n\t\t\t\t\t_embeddedChannel, new NettyFabricWorkerConfig<Serializable>(\n\t\t\t\t\t\t0, processConfig, processCallable,\n\t\t\t\t\t\tfabricPathMappingVisitor.getPathMap()));\n\n\t\t\tLoadedPaths loadedPaths = noticeableFuture.get();\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertTrue(logRecords.isEmpty());\n\n\t\t\tMap<Path, Path> loadedInputPaths = loadedPaths.getInputPaths();\n\n\t\t\tAssert.assertTrue(loadedInputPaths.isEmpty());\n\n\t\t\tProcessConfig loadedProcessConfig = loadedPaths.toProcessConfig(\n\t\t\t\tprocessConfig);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tStringPool.BLANK, loadedProcessConfig.getBootstrapClassPath());\n\t\t\tAssert.assertEquals(\n\t\t\t\tmappedRuntimePath1 + File.pathSeparator +\n\t\t\t\t\tmappedRuntimePath3,\n\t\t\t\tloadedProcessConfig.getRuntimeClassPath());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testLoadPathsMissedBootstrapPaths() throws Exception {\n\n\t\t// With log\n\n\t\tfinal Map<Path, Path> mergedPaths = new HashMap<Path, Path>();\n\n\t\tPath bootstrapPath1 = Paths.get(\"bootstrapPath1\");\n\t\tPath mappedBootstrapPath1 = Paths.get(\"mappedBootstrapPath1\");\n\t\tPath bootstrapPath2 = Paths.get(\"bootstrapPath2\");\n\t\tPath bootstrapPath3 = Paths.get(\"bootstrapPath3\");\n\n\t\tmergedPaths.put(bootstrapPath1, mappedBootstrapPath1);\n\n\t\tNettyFabricWorkerExecutionChannelHandler\n\t\t\tnettyFabricWorkerExecutionChannelHandler =\n\t\t\t\tnew NettyFabricWorkerExecutionChannelHandler(\n\t\t\t\t\tnew MockRepository() {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic NoticeableFuture<Map<Path, Path>> getFiles(\n\t\t\t\t\t\t\tMap<Path, Path> pathMap, boolean deleteAfterFetch) {\n\n\t\t\t\t\t\t\tDefaultNoticeableFuture<Map<Path, Path>>\n\t\t\t\t\t\t\t\tdefaultNoticeableFuture =\n\t\t\t\t\t\t\t\t\tnew DefaultNoticeableFuture\n\t\t\t\t\t\t\t\t\t\t<Map<Path, Path>>();\n\n\t\t\t\t\t\t\tdefaultNoticeableFuture.set(mergedPaths);\n\n\t\t\t\t\t\t\treturn defaultNoticeableFuture;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic Path getRepositoryPath() {\n\t\t\t\t\t\t\treturn Paths.get(\"repository\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t},\n\t\t\t\t\tnew LocalFabricAgent(new EmbeddedProcessExecutor()), 0);\n\n\t\tBuilder builder = new Builder();\n\n\t\tbuilder.setBootstrapClassPath(\n\t\t\tbootstrapPath1 + File.pathSeparator + bootstrapPath2 +\n\t\t\t\tFile.pathSeparator + bootstrapPath3);\n\t\tbuilder.setRuntimeClassPath(StringPool.BLANK);\n\n\t\tProcessConfig processConfig = builder.build();\n\n\t\tProcessCallable<Serializable> processCallable =\n\t\t\tnew ReturnProcessCallable<Serializable>(null);\n\n\t\tFabricPathMappingVisitor fabricPathMappingVisitor =\n\t\t\tnew FabricPathMappingVisitor(\n\t\t\t\tInputResource.class, Paths.get(\"repository\"));\n\n\t\tObjectGraphUtil.walkObjectGraph(\n\t\t\tprocessCallable, fabricPathMappingVisitor);\n\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyFabricWorkerExecutionChannelHandler.class.getName(),\n\t\t\tLevel.WARNING);\n\n\t\ttry {\n\t\t\tNoticeableFuture<LoadedPaths> noticeableFuture =\n\t\t\t\tnettyFabricWorkerExecutionChannelHandler.loadPaths(\n\t\t\t\t\tnew NettyFabricWorkerConfig<Serializable>(\n\t\t\t\t\t\t0, processConfig, processCallable,\n\t\t\t\t\t\tfabricPathMappingVisitor.getPathMap()));\n\n\t\t\tLoadedPaths loadedPaths = noticeableFuture.get();\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertEquals(1, logRecords.size());\n\n\t\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Incomplete bootstrap classpath loaded, missed: \" +\n\t\t\t\t\tArrays.asList(bootstrapPath2, bootstrapPath3),\n\t\t\t\tlogRecord.getMessage());\n\n\t\t\tMap<Path, Path> loadedInputPaths = loadedPaths.getInputPaths();\n\n\t\t\tAssert.assertTrue(loadedInputPaths.isEmpty());\n\n\t\t\tProcessConfig loadedProcessConfig = loadedPaths.toProcessConfig(\n\t\t\t\tprocessConfig);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tmappedBootstrapPath1.toString(),\n\t\t\t\tloadedProcessConfig.getBootstrapClassPath());\n\t\t\tAssert.assertEquals(\n\t\t\t\tStringPool.BLANK, loadedProcessConfig.getRuntimeClassPath());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\n\t\t// Without log\n\n\t\tcaptureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyFabricWorkerExecutionChannelHandler.class.getName(),\n\t\t\tLevel.OFF);\n\n\t\ttry {\n\t\t\tNoticeableFuture<LoadedPaths> noticeableFuture =\n\t\t\t\tnettyFabricWorkerExecutionChannelHandler.loadPaths(\n\t\t\t\t\tnew NettyFabricWorkerConfig<Serializable>(\n\t\t\t\t\t\t0, processConfig, processCallable,\n\t\t\t\t\t\tfabricPathMappingVisitor.getPathMap()));\n\n\t\t\tLoadedPaths loadedPaths = noticeableFuture.get();\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertTrue(logRecords.isEmpty());\n\n\t\t\tMap<Path, Path> loadedInputPaths = loadedPaths.getInputPaths();\n\n\t\t\tAssert.assertTrue(loadedInputPaths.isEmpty());\n\n\t\t\tProcessConfig loadedProcessConfig = loadedPaths.toProcessConfig(\n\t\t\t\tprocessConfig);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tmappedBootstrapPath1.toString(),\n\t\t\t\tloadedProcessConfig.getBootstrapClassPath());\n\t\t\tAssert.assertEquals(\n\t\t\t\tStringPool.BLANK, loadedProcessConfig.getRuntimeClassPath());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\t}","id":99166,"modified_method":"@Test\n\tpublic void testLoadPathsMissedBootstrapPaths() throws Exception {\n\n\t\t// With log\n\n\t\tfinal Map<Path, Path> mergedPaths = new HashMap<Path, Path>();\n\n\t\tPath bootstrapPath1 = Paths.get(\"bootstrapPath1\");\n\t\tPath mappedBootstrapPath1 = Paths.get(\"mappedBootstrapPath1\");\n\t\tPath bootstrapPath2 = Paths.get(\"bootstrapPath2\");\n\t\tPath bootstrapPath3 = Paths.get(\"bootstrapPath3\");\n\n\t\tmergedPaths.put(bootstrapPath1, mappedBootstrapPath1);\n\n\t\tNettyFabricWorkerExecutionChannelHandler\n\t\t\tnettyFabricWorkerExecutionChannelHandler =\n\t\t\t\tnew NettyFabricWorkerExecutionChannelHandler(\n\t\t\t\t\tnew MockRepository<Channel>() {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic NoticeableFuture<Map<Path, Path>> getFiles(\n\t\t\t\t\t\t\tChannel channel, Map<Path, Path> pathMap,\n\t\t\t\t\t\t\tboolean deleteAfterFetch) {\n\n\t\t\t\t\t\t\tDefaultNoticeableFuture<Map<Path, Path>>\n\t\t\t\t\t\t\t\tdefaultNoticeableFuture =\n\t\t\t\t\t\t\t\t\tnew DefaultNoticeableFuture\n\t\t\t\t\t\t\t\t\t\t<Map<Path, Path>>();\n\n\t\t\t\t\t\t\tdefaultNoticeableFuture.set(mergedPaths);\n\n\t\t\t\t\t\t\treturn defaultNoticeableFuture;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic Path getRepositoryPath() {\n\t\t\t\t\t\t\treturn Paths.get(\"repository\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t},\n\t\t\t\t\tnew LocalFabricAgent(new EmbeddedProcessExecutor()), 0);\n\n\t\tBuilder builder = new Builder();\n\n\t\tbuilder.setBootstrapClassPath(\n\t\t\tbootstrapPath1 + File.pathSeparator + bootstrapPath2 +\n\t\t\t\tFile.pathSeparator + bootstrapPath3);\n\t\tbuilder.setRuntimeClassPath(StringPool.BLANK);\n\n\t\tProcessConfig processConfig = builder.build();\n\n\t\tProcessCallable<Serializable> processCallable =\n\t\t\tnew ReturnProcessCallable<Serializable>(null);\n\n\t\tFabricPathMappingVisitor fabricPathMappingVisitor =\n\t\t\tnew FabricPathMappingVisitor(\n\t\t\t\tInputResource.class, Paths.get(\"repository\"));\n\n\t\tObjectGraphUtil.walkObjectGraph(\n\t\t\tprocessCallable, fabricPathMappingVisitor);\n\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyFabricWorkerExecutionChannelHandler.class.getName(),\n\t\t\tLevel.WARNING);\n\n\t\ttry {\n\t\t\tNoticeableFuture<LoadedPaths> noticeableFuture =\n\t\t\t\tnettyFabricWorkerExecutionChannelHandler.loadPaths(\n\t\t\t\t\t_embeddedChannel, new NettyFabricWorkerConfig<Serializable>(\n\t\t\t\t\t\t0, processConfig, processCallable,\n\t\t\t\t\t\tfabricPathMappingVisitor.getPathMap()));\n\n\t\t\tLoadedPaths loadedPaths = noticeableFuture.get();\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertEquals(1, logRecords.size());\n\n\t\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Incomplete bootstrap classpath loaded, missed: \" +\n\t\t\t\t\tArrays.asList(bootstrapPath2, bootstrapPath3),\n\t\t\t\tlogRecord.getMessage());\n\n\t\t\tMap<Path, Path> loadedInputPaths = loadedPaths.getInputPaths();\n\n\t\t\tAssert.assertTrue(loadedInputPaths.isEmpty());\n\n\t\t\tProcessConfig loadedProcessConfig = loadedPaths.toProcessConfig(\n\t\t\t\tprocessConfig);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tmappedBootstrapPath1.toString(),\n\t\t\t\tloadedProcessConfig.getBootstrapClassPath());\n\t\t\tAssert.assertEquals(\n\t\t\t\tStringPool.BLANK, loadedProcessConfig.getRuntimeClassPath());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\n\t\t// Without log\n\n\t\tcaptureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyFabricWorkerExecutionChannelHandler.class.getName(),\n\t\t\tLevel.OFF);\n\n\t\ttry {\n\t\t\tNoticeableFuture<LoadedPaths> noticeableFuture =\n\t\t\t\tnettyFabricWorkerExecutionChannelHandler.loadPaths(\n\t\t\t\t\t_embeddedChannel, new NettyFabricWorkerConfig<Serializable>(\n\t\t\t\t\t\t0, processConfig, processCallable,\n\t\t\t\t\t\tfabricPathMappingVisitor.getPathMap()));\n\n\t\t\tLoadedPaths loadedPaths = noticeableFuture.get();\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertTrue(logRecords.isEmpty());\n\n\t\t\tMap<Path, Path> loadedInputPaths = loadedPaths.getInputPaths();\n\n\t\t\tAssert.assertTrue(loadedInputPaths.isEmpty());\n\n\t\t\tProcessConfig loadedProcessConfig = loadedPaths.toProcessConfig(\n\t\t\t\tprocessConfig);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tmappedBootstrapPath1.toString(),\n\t\t\t\tloadedProcessConfig.getBootstrapClassPath());\n\t\t\tAssert.assertEquals(\n\t\t\t\tStringPool.BLANK, loadedProcessConfig.getRuntimeClassPath());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testExceptionCaught() {\n\t\tNettyFabricWorkerExecutionChannelHandler\n\t\t\tnettyFabricWorkerExecutionChannelHandler =\n\t\t\t\tnew NettyFabricWorkerExecutionChannelHandler(\n\t\t\t\t\tnew MockRepository(),\n\t\t\t\t\tnew LocalFabricAgent(new EmbeddedProcessExecutor()),\n\t\t\t\t\tLong.MAX_VALUE);\n\n\t\tChannelPipeline channelPipeline = _embeddedChannel.pipeline();\n\n\t\tchannelPipeline.addFirst(nettyFabricWorkerExecutionChannelHandler);\n\n\t\tNettyFabricWorkerConfig<Serializable> nettyFabricWorkerConfig =\n\t\t\tcreateNettyFabricWorkerConfig();\n\n\t\tReflectionTestUtil.setFieldValue(\n\t\t\tnettyFabricWorkerConfig, \"_processConfig\", null);\n\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyFabricWorkerExecutionChannelHandler.class.getName(),\n\t\t\tLevel.INFO);\n\n\t\ttry {\n\t\t\tString embeddedChannelToString = _embeddedChannel.toString();\n\n\t\t\t_embeddedChannel.writeInbound(nettyFabricWorkerConfig);\n\n\t\t\tAssert.assertFalse(_embeddedChannel.isOpen());\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertEquals(2, logRecords.size());\n\n\t\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Closing \" + embeddedChannelToString + \" due to:\",\n\t\t\t\tlogRecord.getMessage());\n\n\t\t\tThrowable throwable = logRecord.getThrown();\n\n\t\t\tAssert.assertSame(NullPointerException.class, throwable.getClass());\n\n\t\t\tlogRecord = logRecords.get(1);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t_embeddedChannel + \" is closed\", logRecord.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\t}","id":99167,"modified_method":"@Test\n\tpublic void testExceptionCaught() {\n\t\tNettyFabricWorkerExecutionChannelHandler\n\t\t\tnettyFabricWorkerExecutionChannelHandler =\n\t\t\t\tnew NettyFabricWorkerExecutionChannelHandler(\n\t\t\t\t\tnew MockRepository<Channel>(),\n\t\t\t\t\tnew LocalFabricAgent(new EmbeddedProcessExecutor()),\n\t\t\t\t\tLong.MAX_VALUE);\n\n\t\tChannelPipeline channelPipeline = _embeddedChannel.pipeline();\n\n\t\tchannelPipeline.addFirst(nettyFabricWorkerExecutionChannelHandler);\n\n\t\tNettyFabricWorkerConfig<Serializable> nettyFabricWorkerConfig =\n\t\t\tcreateNettyFabricWorkerConfig();\n\n\t\tReflectionTestUtil.setFieldValue(\n\t\t\tnettyFabricWorkerConfig, \"_processConfig\", null);\n\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyFabricWorkerExecutionChannelHandler.class.getName(),\n\t\t\tLevel.INFO);\n\n\t\ttry {\n\t\t\tString embeddedChannelToString = _embeddedChannel.toString();\n\n\t\t\t_embeddedChannel.writeInbound(nettyFabricWorkerConfig);\n\n\t\t\tAssert.assertFalse(_embeddedChannel.isOpen());\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertEquals(2, logRecords.size());\n\n\t\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Closing \" + embeddedChannelToString + \" due to:\",\n\t\t\t\tlogRecord.getMessage());\n\n\t\t\tThrowable throwable = logRecord.getThrown();\n\n\t\t\tAssert.assertSame(NullPointerException.class, throwable.getClass());\n\n\t\t\tlogRecord = logRecords.get(1);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t_embeddedChannel + \" is closed\", logRecord.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = NettyUtilAdvice.class)\n\t@NewEnv(type = NewEnv.Type.CLASSLOADER)\n\t@Test\n\tpublic void testIntegration() {\n\t\tNettyFabricWorkerExecutionChannelHandler\n\t\t\tnettyFabricWorkerExecutionChannelHandler =\n\t\t\t\tnew NettyFabricWorkerExecutionChannelHandler(\n\t\t\t\t\tnew MockRepository(),\n\t\t\t\t\tnew LocalFabricAgent(new EmbeddedProcessExecutor()),\n\t\t\t\t\tLong.MAX_VALUE);\n\n\t\tChannelPipeline channelPipeline = _embeddedChannel.pipeline();\n\n\t\tchannelPipeline.addFirst(nettyFabricWorkerExecutionChannelHandler);\n\n\t\t_embeddedChannel.writeInbound(createNettyFabricWorkerConfig());\n\n\t\tFabricWorker<Serializable> fabricWorker =\n\t\t\tNettyChannelAttributes.getFabricWorker(_embeddedChannel, 0);\n\n\t\tDefaultNoticeableFuture<?> defaultNoticeableFuture =\n\t\t\t(DefaultNoticeableFuture<?>)\n\t\t\t\tfabricWorker.getProcessNoticeableFuture();\n\n\t\tdefaultNoticeableFuture.run();\n\n\t\tAssert.assertNull(\n\t\t\tNettyChannelAttributes.getFabricWorker(_embeddedChannel, 0));\n\t}","id":99168,"modified_method":"@AdviseWith(adviceClasses = NettyUtilAdvice.class)\n\t@NewEnv(type = NewEnv.Type.CLASSLOADER)\n\t@Test\n\tpublic void testIntegration() {\n\t\tNettyFabricWorkerExecutionChannelHandler\n\t\t\tnettyFabricWorkerExecutionChannelHandler =\n\t\t\t\tnew NettyFabricWorkerExecutionChannelHandler(\n\t\t\t\t\tnew MockRepository<Channel>(),\n\t\t\t\t\tnew LocalFabricAgent(new EmbeddedProcessExecutor()),\n\t\t\t\t\tLong.MAX_VALUE);\n\n\t\tChannelPipeline channelPipeline = _embeddedChannel.pipeline();\n\n\t\tchannelPipeline.addFirst(nettyFabricWorkerExecutionChannelHandler);\n\n\t\t_embeddedChannel.writeInbound(createNettyFabricWorkerConfig());\n\n\t\tFabricWorker<Serializable> fabricWorker =\n\t\t\tNettyChannelAttributes.getFabricWorker(_embeddedChannel, 0);\n\n\t\tDefaultNoticeableFuture<?> defaultNoticeableFuture =\n\t\t\t(DefaultNoticeableFuture<?>)\n\t\t\t\tfabricWorker.getProcessNoticeableFuture();\n\n\t\tdefaultNoticeableFuture.run();\n\n\t\tAssert.assertNull(\n\t\t\tNettyChannelAttributes.getFabricWorker(_embeddedChannel, 0));\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testGetFabricStatus() {\n\t\tNettyFabricWorkerStub<String> nettyFabricWorkerStub =\n\t\t\tnew NettyFabricWorkerStub<String>(\n\t\t\t\t0, NettyTestUtil.createEmptyEmbeddedChannel(),\n\t\t\t\tnew MockRepository(), Collections.<Path, Path>emptyMap(), 0);\n\n\t\tFabricStatus fabricStatus = nettyFabricWorkerStub.getFabricStatus();\n\n\t\tAssert.assertSame(RemoteFabricStatus.class, fabricStatus.getClass());\n\t}","id":99169,"modified_method":"@Test\n\tpublic void testGetFabricStatus() {\n\t\tNettyFabricWorkerStub<String> nettyFabricWorkerStub =\n\t\t\tnew NettyFabricWorkerStub<String>(\n\t\t\t\t0, NettyTestUtil.createEmptyEmbeddedChannel(),\n\t\t\t\tnew MockRepository<Channel>(),\n\t\t\t\tCollections.<Path, Path>emptyMap(), 0);\n\n\t\tFabricStatus fabricStatus = nettyFabricWorkerStub.getFabricStatus();\n\n\t\tAssert.assertSame(RemoteFabricStatus.class, fabricStatus.getClass());\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = NettyUtilAdvice.class)\n\t@NewEnv(type = NewEnv.Type.CLASSLOADER)\n\t@Test\n\tpublic void testWrite() throws Exception {\n\t\tEmbeddedChannel embeddedChannel = new EmbeddedChannel(\n\t\t\tNettyRPCChannelHandler.INSTANCE);\n\n\t\tNettyFabricWorkerStub<String> nettyFabricWorkerStub =\n\t\t\tnew NettyFabricWorkerStub<String>(\n\t\t\t\t0, embeddedChannel, new MockRepository(),\n\t\t\t\tCollections.<Path, Path>emptyMap(), 0);\n\n\t\tNettyChannelAttributes.putFabricWorker(\n\t\t\tembeddedChannel, 0,\n\t\t\tnew LocalFabricWorker<String>(\n\t\t\t\tnew EmbeddedProcessChannel<String>(\n\t\t\t\t\tnew DefaultNoticeableFuture<String>())));\n\n\t\tString result = \"Test result\";\n\n\t\tNoticeableFuture<String> noticeableFuture = nettyFabricWorkerStub.write(\n\t\t\tnew ReturnProcessCallable<String>(result));\n\n\t\tembeddedChannel.writeInbound(embeddedChannel.readOutbound());\n\t\tembeddedChannel.writeInbound(embeddedChannel.readOutbound());\n\n\t\tAssert.assertEquals(result, noticeableFuture.get());\n\t}","id":99170,"modified_method":"@AdviseWith(adviceClasses = NettyUtilAdvice.class)\n\t@NewEnv(type = NewEnv.Type.CLASSLOADER)\n\t@Test\n\tpublic void testWrite() throws Exception {\n\t\tEmbeddedChannel embeddedChannel = new EmbeddedChannel(\n\t\t\tNettyRPCChannelHandler.INSTANCE);\n\n\t\tNettyFabricWorkerStub<String> nettyFabricWorkerStub =\n\t\t\tnew NettyFabricWorkerStub<String>(\n\t\t\t\t0, embeddedChannel, new MockRepository<Channel>(),\n\t\t\t\tCollections.<Path, Path>emptyMap(), 0);\n\n\t\tNettyChannelAttributes.putFabricWorker(\n\t\t\tembeddedChannel, 0,\n\t\t\tnew LocalFabricWorker<String>(\n\t\t\t\tnew EmbeddedProcessChannel<String>(\n\t\t\t\t\tnew DefaultNoticeableFuture<String>())));\n\n\t\tString result = \"Test result\";\n\n\t\tNoticeableFuture<String> noticeableFuture = nettyFabricWorkerStub.write(\n\t\t\tnew ReturnProcessCallable<String>(result));\n\n\t\tembeddedChannel.writeInbound(embeddedChannel.readOutbound());\n\t\tembeddedChannel.writeInbound(embeddedChannel.readOutbound());\n\n\t\tAssert.assertEquals(result, noticeableFuture.get());\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testSetException() throws InterruptedException {\n\t\tNettyFabricWorkerStub<String> nettyFabricWorkerStub =\n\t\t\tnew NettyFabricWorkerStub<String>(\n\t\t\t\t0, NettyTestUtil.createEmptyEmbeddedChannel(),\n\t\t\t\tnew MockRepository(), Collections.<Path, Path>emptyMap(), 0);\n\n\t\tThrowable throwable = new Throwable();\n\n\t\tnettyFabricWorkerStub.setException(throwable);\n\n\t\tNoticeableFuture<String> noticeableFuture =\n\t\t\tnettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\ttry {\n\t\t\tnoticeableFuture.get();\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (ExecutionException ee) {\n\t\t\tAssert.assertSame(throwable, ee.getCause());\n\t\t}\n\t}","id":99171,"modified_method":"@Test\n\tpublic void testSetException() throws InterruptedException {\n\t\tNettyFabricWorkerStub<String> nettyFabricWorkerStub =\n\t\t\tnew NettyFabricWorkerStub<String>(\n\t\t\t\t0, NettyTestUtil.createEmptyEmbeddedChannel(),\n\t\t\t\tnew MockRepository<Channel>(),\n\t\t\t\tCollections.<Path, Path>emptyMap(), 0);\n\n\t\tThrowable throwable = new Throwable();\n\n\t\tnettyFabricWorkerStub.setException(throwable);\n\n\t\tNoticeableFuture<String> noticeableFuture =\n\t\t\tnettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\ttry {\n\t\t\tnoticeableFuture.get();\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (ExecutionException ee) {\n\t\t\tAssert.assertSame(throwable, ee.getCause());\n\t\t}\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testSetCancellation() throws Exception {\n\t\tNettyFabricWorkerStub<String> nettyFabricWorkerStub =\n\t\t\tnew NettyFabricWorkerStub<String>(\n\t\t\t\t0, NettyTestUtil.createEmptyEmbeddedChannel(),\n\t\t\t\tnew MockRepository(), Collections.<Path, Path>emptyMap(), 0);\n\n\t\tnettyFabricWorkerStub.setCancel();\n\n\t\tNoticeableFuture<String> noticeableFuture =\n\t\t\tnettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\tAssert.assertTrue(noticeableFuture.isCancelled());\n\t}","id":99172,"modified_method":"@Test\n\tpublic void testSetCancellation() throws Exception {\n\t\tNettyFabricWorkerStub<String> nettyFabricWorkerStub =\n\t\t\tnew NettyFabricWorkerStub<String>(\n\t\t\t\t0, NettyTestUtil.createEmptyEmbeddedChannel(),\n\t\t\t\tnew MockRepository<Channel>(),\n\t\t\t\tCollections.<Path, Path>emptyMap(), 0);\n\n\t\tnettyFabricWorkerStub.setCancel();\n\n\t\tNoticeableFuture<String> noticeableFuture =\n\t\t\tnettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\tAssert.assertTrue(noticeableFuture.isCancelled());\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testSetResult() throws Exception {\n\t\tfinal DefaultNoticeableFuture<Map<Path, Path>> defaultNoticeableFuture =\n\t\t\tnew DefaultNoticeableFuture<Map<Path, Path>>();\n\n\t\tNettyFabricWorkerStub<String> nettyFabricWorkerStub =\n\t\t\tnew NettyFabricWorkerStub<String>(\n\t\t\t\t0, NettyTestUtil.createEmptyEmbeddedChannel(),\n\t\t\t\tnew MockRepository() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic NoticeableFuture<Map<Path, Path>> getFiles(\n\t\t\t\t\t\tMap<Path, Path> pathMap, boolean deleteAfterFetch) {\n\n\t\t\t\t\t\treturn defaultNoticeableFuture;\n\t\t\t\t\t}\n\n\t\t\t\t},\n\t\t\t\tCollections.<Path, Path>emptyMap(), 0);\n\n\t\tString result = \"Test result\";\n\n\t\tnettyFabricWorkerStub.setResult(result);\n\n\t\tNoticeableFuture<String> noticeableFuture =\n\t\t\tnettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\tAssert.assertFalse(noticeableFuture.isDone());\n\n\t\tdefaultNoticeableFuture.set(Collections.<Path, Path>emptyMap());\n\n\t\tAssert.assertEquals(result, noticeableFuture.get());\n\t}","id":99173,"modified_method":"@Test\n\tpublic void testSetResult() throws Exception {\n\t\tfinal DefaultNoticeableFuture<Map<Path, Path>> defaultNoticeableFuture =\n\t\t\tnew DefaultNoticeableFuture<Map<Path, Path>>();\n\n\t\tNettyFabricWorkerStub<String> nettyFabricWorkerStub =\n\t\t\tnew NettyFabricWorkerStub<String>(\n\t\t\t\t0, NettyTestUtil.createEmptyEmbeddedChannel(),\n\t\t\t\tnew MockRepository<Channel>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic NoticeableFuture<Map<Path, Path>> getFiles(\n\t\t\t\t\t\tChannel channel, Map<Path, Path> pathMap,\n\t\t\t\t\t\tboolean deleteAfterFetch) {\n\n\t\t\t\t\t\treturn defaultNoticeableFuture;\n\t\t\t\t\t}\n\n\t\t\t\t},\n\t\t\t\tCollections.<Path, Path>emptyMap(), 0);\n\n\t\tString result = \"Test result\";\n\n\t\tnettyFabricWorkerStub.setResult(result);\n\n\t\tNoticeableFuture<String> noticeableFuture =\n\t\t\tnettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\tAssert.assertFalse(noticeableFuture.isDone());\n\n\t\tdefaultNoticeableFuture.set(Collections.<Path, Path>emptyMap());\n\n\t\tAssert.assertEquals(result, noticeableFuture.get());\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testSetResultWithException() throws InterruptedException {\n\t\tfinal DefaultNoticeableFuture<Map<Path, Path>> defaultNoticeableFuture =\n\t\t\tnew DefaultNoticeableFuture<Map<Path, Path>>();\n\n\t\tNettyFabricWorkerStub<String> nettyFabricWorkerStub =\n\t\t\tnew NettyFabricWorkerStub<String>(\n\t\t\t\t0, NettyTestUtil.createEmptyEmbeddedChannel(),\n\t\t\t\tnew MockRepository() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic NoticeableFuture<Map<Path, Path>> getFiles(\n\t\t\t\t\t\tMap<Path, Path> pathMap, boolean deleteAfterFetch) {\n\n\t\t\t\t\t\treturn defaultNoticeableFuture;\n\t\t\t\t\t}\n\n\t\t\t\t},\n\t\t\t\tCollections.<Path, Path>emptyMap(), 0);\n\n\t\tnettyFabricWorkerStub.setResult(\"Test result\");\n\n\t\tNoticeableFuture<String> noticeableFuture =\n\t\t\tnettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\tAssert.assertFalse(noticeableFuture.isDone());\n\n\t\tThrowable throwable = new Throwable();\n\n\t\tdefaultNoticeableFuture.setException(throwable);\n\n\t\ttry {\n\t\t\tdefaultNoticeableFuture.get();\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (ExecutionException ee) {\n\t\t\tAssert.assertSame(throwable, ee.getCause());\n\t\t}\n\t}","id":99174,"modified_method":"@Test\n\tpublic void testSetResultWithException() throws InterruptedException {\n\t\tfinal DefaultNoticeableFuture<Map<Path, Path>> defaultNoticeableFuture =\n\t\t\tnew DefaultNoticeableFuture<Map<Path, Path>>();\n\n\t\tNettyFabricWorkerStub<String> nettyFabricWorkerStub =\n\t\t\tnew NettyFabricWorkerStub<String>(\n\t\t\t\t0, NettyTestUtil.createEmptyEmbeddedChannel(),\n\t\t\t\tnew MockRepository<Channel>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic NoticeableFuture<Map<Path, Path>> getFiles(\n\t\t\t\t\t\tChannel channel, Map<Path, Path> pathMap,\n\t\t\t\t\t\tboolean deleteAfterFetch) {\n\n\t\t\t\t\t\treturn defaultNoticeableFuture;\n\t\t\t\t\t}\n\n\t\t\t\t},\n\t\t\t\tCollections.<Path, Path>emptyMap(), 0);\n\n\t\tnettyFabricWorkerStub.setResult(\"Test result\");\n\n\t\tNoticeableFuture<String> noticeableFuture =\n\t\t\tnettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\tAssert.assertFalse(noticeableFuture.isDone());\n\n\t\tThrowable throwable = new Throwable();\n\n\t\tdefaultNoticeableFuture.setException(throwable);\n\n\t\ttry {\n\t\t\tdefaultNoticeableFuture.get();\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (ExecutionException ee) {\n\t\t\tAssert.assertSame(throwable, ee.getCause());\n\t\t}\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testSetResultWithCancellation() {\n\t\tfinal DefaultNoticeableFuture<Map<Path, Path>> defaultNoticeableFuture =\n\t\t\tnew DefaultNoticeableFuture<Map<Path, Path>>();\n\n\t\tNettyFabricWorkerStub<String> nettyFabricWorkerStub =\n\t\t\tnew NettyFabricWorkerStub<String>(\n\t\t\t\t0, NettyTestUtil.createEmptyEmbeddedChannel(),\n\t\t\t\tnew MockRepository() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic NoticeableFuture<Map<Path, Path>> getFiles(\n\t\t\t\t\t\tMap<Path, Path> pathMap, boolean deleteAfterFetch) {\n\n\t\t\t\t\t\treturn defaultNoticeableFuture;\n\t\t\t\t\t}\n\n\t\t\t\t},\n\t\t\t\tCollections.<Path, Path>emptyMap(), 0);\n\n\t\tnettyFabricWorkerStub.setResult(\"Test result\");\n\n\t\tNoticeableFuture<String> noticeableFuture =\n\t\t\tnettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\tAssert.assertFalse(noticeableFuture.isDone());\n\t\tAssert.assertTrue(defaultNoticeableFuture.cancel(true));\n\t\tAssert.assertTrue(noticeableFuture.isCancelled());\n\t}","id":99175,"modified_method":"@Test\n\tpublic void testSetResultWithCancellation() {\n\t\tfinal DefaultNoticeableFuture<Map<Path, Path>> defaultNoticeableFuture =\n\t\t\tnew DefaultNoticeableFuture<Map<Path, Path>>();\n\n\t\tNettyFabricWorkerStub<String> nettyFabricWorkerStub =\n\t\t\tnew NettyFabricWorkerStub<String>(\n\t\t\t\t0, NettyTestUtil.createEmptyEmbeddedChannel(),\n\t\t\t\tnew MockRepository<Channel>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic NoticeableFuture<Map<Path, Path>> getFiles(\n\t\t\t\t\t\tChannel channel, Map<Path, Path> pathMap,\n\t\t\t\t\t\tboolean deleteAfterFetch) {\n\n\t\t\t\t\t\treturn defaultNoticeableFuture;\n\t\t\t\t\t}\n\n\t\t\t\t},\n\t\t\t\tCollections.<Path, Path>emptyMap(), 0);\n\n\t\tnettyFabricWorkerStub.setResult(\"Test result\");\n\n\t\tNoticeableFuture<String> noticeableFuture =\n\t\t\tnettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\tAssert.assertFalse(noticeableFuture.isDone());\n\t\tAssert.assertTrue(defaultNoticeableFuture.cancel(true));\n\t\tAssert.assertTrue(noticeableFuture.isCancelled());\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testConstructor() {\n\t\ttry {\n\t\t\tnew NettyFabricWorkerStub<String>(0, null, null, null, 0);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (NullPointerException npe) {\n\t\t\tAssert.assertEquals(\"Channel is null\", npe.getMessage());\n\t\t}\n\n\t\ttry {\n\t\t\tnew NettyFabricWorkerStub<String>(\n\t\t\t\t0, NettyTestUtil.createEmptyEmbeddedChannel(), null, null, 0);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (NullPointerException npe) {\n\t\t\tAssert.assertEquals(\"Repository is null\", npe.getMessage());\n\t\t}\n\n\t\ttry {\n\t\t\tnew NettyFabricWorkerStub<String>(\n\t\t\t\t0, NettyTestUtil.createEmptyEmbeddedChannel(),\n\t\t\t\tnew MockRepository(), null, 0);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (NullPointerException npe) {\n\t\t\tAssert.assertEquals(\"Output path map is null\", npe.getMessage());\n\t\t}\n\n\t\tChannel channel = NettyTestUtil.createEmptyEmbeddedChannel();\n\n\t\tChannelFuture channelFuture = channel.closeFuture();\n\n\t\tAssert.assertFalse(channelFuture.isDone());\n\n\t\tNettyFabricWorkerStub<String> nettyFabricWorkerStub =\n\t\t\tnew NettyFabricWorkerStub<String>(\n\t\t\t\t0, channel, new MockRepository(),\n\t\t\t\tCollections.<Path, Path>emptyMap(), 0);\n\n\t\tAssert.assertNotNull(\n\t\t\tReflectionTestUtil.getFieldValue(channelFuture, \"listeners\"));\n\n\t\tNoticeableFuture<String> noticeableFuture =\n\t\t\tnettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\tAssert.assertFalse(noticeableFuture.isDone());\n\t\tAssert.assertTrue(channelFuture.cancel(true));\n\t\tAssert.assertTrue(noticeableFuture.isCancelled());\n\t\tAssert.assertNull(\n\t\t\tReflectionTestUtil.getFieldValue(channelFuture, \"listeners\"));\n\n\t\tchannel = NettyTestUtil.createEmptyEmbeddedChannel();\n\n\t\tchannelFuture = channel.closeFuture();\n\n\t\tAssert.assertFalse(channelFuture.isDone());\n\n\t\tnettyFabricWorkerStub = new NettyFabricWorkerStub<String>(\n\t\t\t0, channel, new MockRepository(),\n\t\t\tCollections.<Path, Path>emptyMap(), 0);\n\n\t\tAssert.assertNotNull(\n\t\t\tReflectionTestUtil.getFieldValue(channelFuture, \"listeners\"));\n\n\t\tnoticeableFuture = nettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\tAssert.assertFalse(noticeableFuture.isDone());\n\t\tAssert.assertTrue(noticeableFuture.cancel(true));\n\t\tAssert.assertFalse(channelFuture.isDone());\n\t\tAssert.assertNull(\n\t\t\tReflectionTestUtil.getFieldValue(channelFuture, \"listeners\"));\n\t}","id":99176,"modified_method":"@Test\n\tpublic void testConstructor() {\n\t\ttry {\n\t\t\tnew NettyFabricWorkerStub<String>(0, null, null, null, 0);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (NullPointerException npe) {\n\t\t\tAssert.assertEquals(\"Channel is null\", npe.getMessage());\n\t\t}\n\n\t\ttry {\n\t\t\tnew NettyFabricWorkerStub<String>(\n\t\t\t\t0, NettyTestUtil.createEmptyEmbeddedChannel(), null, null, 0);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (NullPointerException npe) {\n\t\t\tAssert.assertEquals(\"Repository is null\", npe.getMessage());\n\t\t}\n\n\t\ttry {\n\t\t\tnew NettyFabricWorkerStub<String>(\n\t\t\t\t0, NettyTestUtil.createEmptyEmbeddedChannel(),\n\t\t\t\tnew MockRepository<Channel>(), null, 0);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (NullPointerException npe) {\n\t\t\tAssert.assertEquals(\"Output path map is null\", npe.getMessage());\n\t\t}\n\n\t\tChannel channel = NettyTestUtil.createEmptyEmbeddedChannel();\n\n\t\tChannelFuture channelFuture = channel.closeFuture();\n\n\t\tAssert.assertFalse(channelFuture.isDone());\n\n\t\tNettyFabricWorkerStub<String> nettyFabricWorkerStub =\n\t\t\tnew NettyFabricWorkerStub<String>(\n\t\t\t\t0, channel, new MockRepository<Channel>(),\n\t\t\t\tCollections.<Path, Path>emptyMap(), 0);\n\n\t\tAssert.assertNotNull(\n\t\t\tReflectionTestUtil.getFieldValue(channelFuture, \"listeners\"));\n\n\t\tNoticeableFuture<String> noticeableFuture =\n\t\t\tnettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\tAssert.assertFalse(noticeableFuture.isDone());\n\t\tAssert.assertTrue(channelFuture.cancel(true));\n\t\tAssert.assertTrue(noticeableFuture.isCancelled());\n\t\tAssert.assertNull(\n\t\t\tReflectionTestUtil.getFieldValue(channelFuture, \"listeners\"));\n\n\t\tchannel = NettyTestUtil.createEmptyEmbeddedChannel();\n\n\t\tchannelFuture = channel.closeFuture();\n\n\t\tAssert.assertFalse(channelFuture.isDone());\n\n\t\tnettyFabricWorkerStub = new NettyFabricWorkerStub<String>(\n\t\t\t0, channel, new MockRepository<Channel>(),\n\t\t\tCollections.<Path, Path>emptyMap(), 0);\n\n\t\tAssert.assertNotNull(\n\t\t\tReflectionTestUtil.getFieldValue(channelFuture, \"listeners\"));\n\n\t\tnoticeableFuture = nettyFabricWorkerStub.getProcessNoticeableFuture();\n\n\t\tAssert.assertFalse(noticeableFuture.isDone());\n\t\tAssert.assertTrue(noticeableFuture.cancel(true));\n\t\tAssert.assertFalse(channelFuture.isDone());\n\t\tAssert.assertNull(\n\t\t\tReflectionTestUtil.getFieldValue(channelFuture, \"listeners\"));\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@NewEnv(type = NewEnv.Type.NONE)\n\t@Test\n\tpublic void testConstructor() {\n\t\ttry {\n\t\t\tnew NettyRepository(null, null, null, Long.MAX_VALUE);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (NullPointerException npe) {\n\t\t\tAssert.assertEquals(\"Repository path is null\", npe.getMessage());\n\t\t}\n\n\t\ttry {\n\t\t\tnew NettyRepository(_repositoryPath, null, null, Long.MAX_VALUE);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (NullPointerException npe) {\n\t\t\tAssert.assertEquals(\"Channel is null\", npe.getMessage());\n\t\t}\n\n\t\ttry {\n\t\t\tnew NettyRepository(\n\t\t\t\t_repositoryPath, _embeddedChannel, null, Long.MAX_VALUE);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (NullPointerException npe) {\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Event executor group is null\", npe.getMessage());\n\t\t}\n\n\t\ttry {\n\t\t\tnew NettyRepository(\n\t\t\t\tPaths.get(\"Unknown\"), _embeddedChannel,\n\t\t\t\t_embeddedChannel.eventLoop(), Long.MAX_VALUE);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (IllegalArgumentException iae) {\n\t\t}\n\n\t\tNettyRepository repository = new NettyRepository(\n\t\t\t_repositoryPath, _embeddedChannel, _embeddedChannel.eventLoop(),\n\t\t\tLong.MAX_VALUE);\n\n\t\tAssert.assertSame(_repositoryPath, repository.getRepositoryPath());\n\t\tAssert.assertSame(_embeddedChannel, repository.channel);\n\t\tAssert.assertEquals(Long.MAX_VALUE, repository.getFileTimeout);\n\t\tAssert.assertNotNull(repository.asyncBroker);\n\t\tAssert.assertNotNull(repository.pathMap);\n\t\tAssert.assertTrue(\n\t\t\t_annotatedObjectDecoder.removeFirst() instanceof\n\t\t\t\tFileResponseChannelHandler);\n\t}","id":99177,"modified_method":"@NewEnv(type = NewEnv.Type.NONE)\n\t@Test\n\tpublic void testConstructor() {\n\t\ttry {\n\t\t\tnew NettyRepository(null, null, Long.MAX_VALUE);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (NullPointerException npe) {\n\t\t\tAssert.assertEquals(\"Repository path is null\", npe.getMessage());\n\t\t}\n\n\t\ttry {\n\t\t\tnew NettyRepository(_repositoryPath, null, Long.MAX_VALUE);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (NullPointerException npe) {\n\t\t\tAssert.assertEquals(\"Async broker is null\", npe.getMessage());\n\t\t}\n\n\t\ttry {\n\t\t\tnew NettyRepository(\n\t\t\t\tPaths.get(\"Unknown\"), new AsyncBroker<Path, FileResponse>(),\n\t\t\t\tLong.MAX_VALUE);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (IllegalArgumentException iae) {\n\t\t}\n\n\t\tAsyncBroker<Path, FileResponse> asyncBroker =\n\t\t\tnew AsyncBroker<Path, FileResponse>();\n\n\t\t_channelPipeline.addLast(\n\t\t\tnew FileResponseChannelHandler(\n\t\t\t\tasyncBroker, _embeddedChannel.eventLoop()));\n\n\t\tNettyRepository repository = new NettyRepository(\n\t\t\t_repositoryPath, asyncBroker, Long.MAX_VALUE);\n\n\t\tAssert.assertSame(_repositoryPath, repository.getRepositoryPath());\n\t\tAssert.assertSame(asyncBroker, repository.asyncBroker);\n\t\tAssert.assertEquals(Long.MAX_VALUE, repository.getFileTimeout);\n\t\tAssert.assertNotNull(repository.pathMap);\n\t\tAssert.assertTrue(\n\t\t\t_annotatedObjectDecoder.removeFirst() instanceof\n\t\t\t\tFileResponseChannelHandler);\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = NettyUtilAdvice.class)\n\t@Test\n\tpublic void testDispose() throws Exception {\n\t\tPath remoteFilePath = Paths.get(\"remoteFile\");\n\n\t\tPath tempFilePath = FileServerTestUtil.createFileWithData(\n\t\t\tPaths.get(\"tempFile\"));\n\n\t\tMap<Path, Path> pathMap =  _nettyRepository.pathMap;\n\n\t\tFileServerTestUtil.createFileWithData(tempFilePath);\n\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyRepository.class.getName(), Level.OFF);\n\n\t\ttry {\n\t\t\tNoticeableFuture<Path> noticeableFuture = _nettyRepository.getFile(\n\t\t\t\tremoteFilePath, null, false);\n\n\t\t\tFileResponse fileResponse = new FileResponse(\n\t\t\t\tremoteFilePath, System.currentTimeMillis(), 0, false);\n\n\t\t\tfileResponse.setLocalFile(tempFilePath);\n\n\t\t\t_asyncBroker.takeWithResult(remoteFilePath, fileResponse);\n\n\t\t\tPath localFilePath = noticeableFuture.get();\n\n\t\t\tAssert.assertNotNull(localFilePath);\n\t\t\tAssert.assertTrue(Files.notExists(tempFilePath));\n\t\t\tAssert.assertTrue(Files.exists(localFilePath));\n\t\t\tAssert.assertEquals(1, pathMap.size());\n\t\t\tAssert.assertSame(localFilePath, pathMap.get(remoteFilePath));\n\n\t\t\t_nettyRepository.dispose(false);\n\n\t\t\tAssert.assertTrue(Files.notExists(localFilePath));\n\t\t\tAssert.assertTrue(pathMap.isEmpty());\n\t\t\tAssert.assertTrue(Files.exists(_repositoryPath));\n\n\t\t\t_nettyRepository.dispose(true);\n\n\t\t\tAssert.assertTrue(Files.notExists(_repositoryPath));\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertTrue(logRecords.isEmpty());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\t}","id":99178,"modified_method":"@AdviseWith(adviceClasses = NettyUtilAdvice.class)\n\t@Test\n\tpublic void testDispose() throws Exception {\n\t\tPath remoteFilePath = Paths.get(\"remoteFile\");\n\n\t\tPath tempFilePath = FileServerTestUtil.createFileWithData(\n\t\t\tPaths.get(\"tempFile\"));\n\n\t\tMap<Path, Path> pathMap =  _nettyRepository.pathMap;\n\n\t\tFileServerTestUtil.createFileWithData(tempFilePath);\n\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyRepository.class.getName(), Level.OFF);\n\n\t\ttry {\n\t\t\tNoticeableFuture<Path> noticeableFuture = _nettyRepository.getFile(\n\t\t\t\t_embeddedChannel, remoteFilePath, null, false);\n\n\t\t\tFileResponse fileResponse = new FileResponse(\n\t\t\t\tremoteFilePath, System.currentTimeMillis(), 0, false);\n\n\t\t\tfileResponse.setLocalFile(tempFilePath);\n\n\t\t\t_asyncBroker.takeWithResult(remoteFilePath, fileResponse);\n\n\t\t\tPath localFilePath = noticeableFuture.get();\n\n\t\t\tAssert.assertNotNull(localFilePath);\n\t\t\tAssert.assertTrue(Files.notExists(tempFilePath));\n\t\t\tAssert.assertTrue(Files.exists(localFilePath));\n\t\t\tAssert.assertEquals(1, pathMap.size());\n\t\t\tAssert.assertSame(localFilePath, pathMap.get(remoteFilePath));\n\n\t\t\t_nettyRepository.dispose(false);\n\n\t\t\tAssert.assertTrue(Files.notExists(localFilePath));\n\t\t\tAssert.assertTrue(pathMap.isEmpty());\n\t\t\tAssert.assertTrue(Files.exists(_repositoryPath));\n\n\t\t\t_nettyRepository.dispose(true);\n\n\t\t\tAssert.assertTrue(Files.notExists(_repositoryPath));\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertTrue(logRecords.isEmpty());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = NettyUtilAdvice.class)\n\t@Test\n\tpublic void testGetFiles() throws Exception {\n\t\tMap<Path, Path> pathMap = new HashMap<Path, Path>();\n\n\t\tPath remoteFilePath1 = Paths.get(\"remoteFile1\");\n\t\tPath remoteFilePath2 = Paths.get(\"remoteFile2\");\n\t\tPath localFilePath = FileServerTestUtil.registerForCleanUp(\n\t\t\tPaths.get(\"localFile1\"));\n\n\t\tpathMap.put(remoteFilePath1, localFilePath);\n\t\tpathMap.put(remoteFilePath2, Paths.get(\"localFile2\"));\n\n\t\tNoticeableFuture<Map<Path, Path>> noticeableFuture =\n\t\t\t_nettyRepository.getFiles(pathMap, true);\n\n\t\tPath tempFilePath = FileServerTestUtil.createFileWithData(\n\t\t\tPaths.get(\"tempFile\"));\n\n\t\tFileResponse fileResponse1 = new FileResponse(\n\t\t\tremoteFilePath1, Files.size(tempFilePath), -1, false);\n\n\t\tfileResponse1.setLocalFile(tempFilePath);\n\n\t\tAssert.assertTrue(\n\t\t\t_asyncBroker.takeWithResult(remoteFilePath1, fileResponse1));\n\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyRepository.class.getName(), Level.WARNING);\n\n\t\ttry {\n\t\t\tAssert.assertTrue(\n\t\t\t\t_asyncBroker.takeWithResult(\n\t\t\t\t\tremoteFilePath2,\n\t\t\t\t\tnew FileResponse(\n\t\t\t\t\t\tremoteFilePath2, FileResponse.FILE_NOT_FOUND, -1,\n\t\t\t\t\t\tfalse)));\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertEquals(1, logRecords.size());\n\n\t\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Remote file remoteFile2 is not found\", logRecord.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\n\t\tMap<Path, Path> resultPathMap = noticeableFuture.get();\n\n\t\tAssert.assertEquals(1, resultPathMap.size());\n\t\tAssert.assertEquals(localFilePath, resultPathMap.get(remoteFilePath1));\n\t}","id":99179,"modified_method":"@AdviseWith(adviceClasses = NettyUtilAdvice.class)\n\t@Test\n\tpublic void testGetFiles() throws Exception {\n\t\tMap<Path, Path> pathMap = new HashMap<Path, Path>();\n\n\t\tPath remoteFilePath1 = Paths.get(\"remoteFile1\");\n\t\tPath remoteFilePath2 = Paths.get(\"remoteFile2\");\n\t\tPath localFilePath = FileServerTestUtil.registerForCleanUp(\n\t\t\tPaths.get(\"localFile1\"));\n\n\t\tpathMap.put(remoteFilePath1, localFilePath);\n\t\tpathMap.put(remoteFilePath2, Paths.get(\"localFile2\"));\n\n\t\tNoticeableFuture<Map<Path, Path>> noticeableFuture =\n\t\t\t_nettyRepository.getFiles(_embeddedChannel, pathMap, true);\n\n\t\tPath tempFilePath = FileServerTestUtil.createFileWithData(\n\t\t\tPaths.get(\"tempFile\"));\n\n\t\tFileResponse fileResponse1 = new FileResponse(\n\t\t\tremoteFilePath1, Files.size(tempFilePath), -1, false);\n\n\t\tfileResponse1.setLocalFile(tempFilePath);\n\n\t\tAssert.assertTrue(\n\t\t\t_asyncBroker.takeWithResult(remoteFilePath1, fileResponse1));\n\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyRepository.class.getName(), Level.WARNING);\n\n\t\ttry {\n\t\t\tAssert.assertTrue(\n\t\t\t\t_asyncBroker.takeWithResult(\n\t\t\t\t\tremoteFilePath2,\n\t\t\t\t\tnew FileResponse(\n\t\t\t\t\t\tremoteFilePath2, FileResponse.FILE_NOT_FOUND, -1,\n\t\t\t\t\t\tfalse)));\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertEquals(1, logRecords.size());\n\n\t\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Remote file remoteFile2 is not found\", logRecord.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\n\t\tMap<Path, Path> resultPathMap = noticeableFuture.get();\n\n\t\tAssert.assertEquals(1, resultPathMap.size());\n\t\tAssert.assertEquals(localFilePath, resultPathMap.get(remoteFilePath1));\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = NettyUtilAdvice.class)\n\t@Test\n\tpublic void testGetFile() throws Exception {\n\n\t\t// With log, populate cache\n\n\t\tPath remoteFilePath = Paths.get(\"remoteFile\");\n\n\t\tPath tempFilePath = FileServerTestUtil.createFileWithData(\n\t\t\tPaths.get(\"tempFile\"));\n\n\t\tMap<Path, Path> pathMap =  _nettyRepository.pathMap;\n\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyRepository.class.getName(), Level.FINEST);\n\n\t\ttry {\n\t\t\tNoticeableFuture<Path> noticeableFuture1 = _nettyRepository.getFile(\n\t\t\t\tremoteFilePath, null, false);\n\n\t\t\tNoticeableFuture<Path> noticeableFuture2 = _nettyRepository.getFile(\n\t\t\t\tremoteFilePath, null, false);\n\n\t\t\tAssert.assertNotSame(noticeableFuture1, noticeableFuture2);\n\n\t\t\tFileResponse fileResponse = new FileResponse(\n\t\t\t\tremoteFilePath, System.currentTimeMillis(), 0, false);\n\n\t\t\tfileResponse.setLocalFile(tempFilePath);\n\n\t\t\t_asyncBroker.takeWithResult(remoteFilePath, fileResponse);\n\n\t\t\tPath localFilePath = FileServerTestUtil.registerForCleanUp(\n\t\t\t\tnoticeableFuture1.get());\n\n\t\t\tAssert.assertSame(localFilePath, noticeableFuture2.get());\n\t\t\tAssert.assertSame(localFilePath, fileResponse.getLocalFile());\n\t\t\tAssert.assertNotNull(localFilePath);\n\t\t\tAssert.assertTrue(Files.notExists(tempFilePath));\n\t\t\tAssert.assertTrue(Files.exists(localFilePath));\n\t\t\tAssert.assertEquals(1, pathMap.size());\n\t\t\tAssert.assertSame(localFilePath, pathMap.get(remoteFilePath));\n\n\t\t\tFiles.delete(localFilePath);\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertEquals(4, logRecords.size());\n\n\t\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Fetching remote file \" + remoteFilePath,\n\t\t\t\tlogRecord.getMessage());\n\n\t\t\tlogRecord = logRecords.get(1);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Fetching remote file \" + remoteFilePath,\n\t\t\t\tlogRecord.getMessage());\n\n\t\t\tlogRecord = logRecords.get(2);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Fetched remote file \" + remoteFilePath + \" to \" +\n\t\t\t\t\tlocalFilePath,\n\t\t\t\tlogRecord.getMessage());\n\n\t\t\tlogRecord = logRecords.get(3);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Fetched remote file \" + remoteFilePath + \" to \" +\n\t\t\t\t\tlocalFilePath,\n\t\t\t\tlogRecord.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\n\t\t\tpathMap.clear();\n\t\t}\n\n\t\t// Without log, not populate cacge\n\n\t\tFileServerTestUtil.createFileWithData(tempFilePath);\n\n\t\tPath localFilePath1 = FileServerTestUtil.registerForCleanUp(\n\t\t\t_repositoryPath.resolve(\"localFile1\"));\n\t\tPath localFilePath2 = FileServerTestUtil.registerForCleanUp(\n\t\t\t_repositoryPath.resolve(\"localFile2\"));\n\n\t\tcaptureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyRepository.class.getName(), Level.OFF);\n\n\t\ttry {\n\t\t\tNoticeableFuture<Path> noticeableFuture1 = _nettyRepository.getFile(\n\t\t\t\tremoteFilePath, localFilePath1, false);\n\n\t\t\tNoticeableFuture<Path> noticeableFuture2 = _nettyRepository.getFile(\n\t\t\t\tremoteFilePath, localFilePath2, false);\n\n\t\t\tAssert.assertNotSame(noticeableFuture1, noticeableFuture2);\n\n\t\t\tFileResponse fileResponse = new FileResponse(\n\t\t\t\tremoteFilePath, System.currentTimeMillis(), 0, false);\n\n\t\t\tfileResponse.setLocalFile(tempFilePath);\n\n\t\t\t_asyncBroker.takeWithResult(remoteFilePath, fileResponse);\n\n\t\t\tAssert.assertSame(localFilePath1, noticeableFuture1.get());\n\t\t\tAssert.assertSame(localFilePath2, noticeableFuture2.get());\n\t\t\tAssert.assertSame(localFilePath2, fileResponse.getLocalFile());\n\t\t\tAssert.assertTrue(Files.notExists(tempFilePath));\n\t\t\tAssert.assertTrue(Files.exists(localFilePath1));\n\t\t\tAssert.assertTrue(Files.exists(localFilePath2));\n\t\t\tAssert.assertTrue(pathMap.isEmpty());\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertTrue(logRecords.isEmpty());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\t}","id":99180,"modified_method":"@AdviseWith(adviceClasses = NettyUtilAdvice.class)\n\t@Test\n\tpublic void testGetFile() throws Exception {\n\n\t\t// With log, populate cache\n\n\t\tPath remoteFilePath = Paths.get(\"remoteFile\");\n\n\t\tPath tempFilePath = FileServerTestUtil.createFileWithData(\n\t\t\tPaths.get(\"tempFile\"));\n\n\t\tMap<Path, Path> pathMap =  _nettyRepository.pathMap;\n\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyRepository.class.getName(), Level.FINEST);\n\n\t\ttry {\n\t\t\tNoticeableFuture<Path> noticeableFuture1 = _nettyRepository.getFile(\n\t\t\t\t_embeddedChannel, remoteFilePath, null, false);\n\n\t\t\tNoticeableFuture<Path> noticeableFuture2 = _nettyRepository.getFile(\n\t\t\t\t_embeddedChannel, remoteFilePath, null, false);\n\n\t\t\tAssert.assertNotSame(noticeableFuture1, noticeableFuture2);\n\n\t\t\tFileResponse fileResponse = new FileResponse(\n\t\t\t\tremoteFilePath, System.currentTimeMillis(), 0, false);\n\n\t\t\tfileResponse.setLocalFile(tempFilePath);\n\n\t\t\t_asyncBroker.takeWithResult(remoteFilePath, fileResponse);\n\n\t\t\tPath localFilePath = FileServerTestUtil.registerForCleanUp(\n\t\t\t\tnoticeableFuture1.get());\n\n\t\t\tAssert.assertSame(localFilePath, noticeableFuture2.get());\n\t\t\tAssert.assertSame(localFilePath, fileResponse.getLocalFile());\n\t\t\tAssert.assertNotNull(localFilePath);\n\t\t\tAssert.assertTrue(Files.notExists(tempFilePath));\n\t\t\tAssert.assertTrue(Files.exists(localFilePath));\n\t\t\tAssert.assertEquals(1, pathMap.size());\n\t\t\tAssert.assertSame(localFilePath, pathMap.get(remoteFilePath));\n\n\t\t\tFiles.delete(localFilePath);\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertEquals(4, logRecords.size());\n\n\t\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Fetching remote file \" + remoteFilePath,\n\t\t\t\tlogRecord.getMessage());\n\n\t\t\tlogRecord = logRecords.get(1);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Fetching remote file \" + remoteFilePath,\n\t\t\t\tlogRecord.getMessage());\n\n\t\t\tlogRecord = logRecords.get(2);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Fetched remote file \" + remoteFilePath + \" to \" +\n\t\t\t\t\tlocalFilePath,\n\t\t\t\tlogRecord.getMessage());\n\n\t\t\tlogRecord = logRecords.get(3);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Fetched remote file \" + remoteFilePath + \" to \" +\n\t\t\t\t\tlocalFilePath,\n\t\t\t\tlogRecord.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\n\t\t\tpathMap.clear();\n\t\t}\n\n\t\t// Without log, not populate cacge\n\n\t\tFileServerTestUtil.createFileWithData(tempFilePath);\n\n\t\tPath localFilePath1 = FileServerTestUtil.registerForCleanUp(\n\t\t\t_repositoryPath.resolve(\"localFile1\"));\n\t\tPath localFilePath2 = FileServerTestUtil.registerForCleanUp(\n\t\t\t_repositoryPath.resolve(\"localFile2\"));\n\n\t\tcaptureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyRepository.class.getName(), Level.OFF);\n\n\t\ttry {\n\t\t\tNoticeableFuture<Path> noticeableFuture1 = _nettyRepository.getFile(\n\t\t\t\t_embeddedChannel, remoteFilePath, localFilePath1, false);\n\n\t\t\tNoticeableFuture<Path> noticeableFuture2 = _nettyRepository.getFile(\n\t\t\t\t_embeddedChannel, remoteFilePath, localFilePath2, false);\n\n\t\t\tAssert.assertNotSame(noticeableFuture1, noticeableFuture2);\n\n\t\t\tFileResponse fileResponse = new FileResponse(\n\t\t\t\tremoteFilePath, System.currentTimeMillis(), 0, false);\n\n\t\t\tfileResponse.setLocalFile(tempFilePath);\n\n\t\t\t_asyncBroker.takeWithResult(remoteFilePath, fileResponse);\n\n\t\t\tAssert.assertSame(localFilePath1, noticeableFuture1.get());\n\t\t\tAssert.assertSame(localFilePath2, noticeableFuture2.get());\n\t\t\tAssert.assertSame(localFilePath2, fileResponse.getLocalFile());\n\t\t\tAssert.assertTrue(Files.notExists(tempFilePath));\n\t\t\tAssert.assertTrue(Files.exists(localFilePath1));\n\t\t\tAssert.assertTrue(Files.exists(localFilePath2));\n\t\t\tAssert.assertTrue(pathMap.isEmpty());\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertTrue(logRecords.isEmpty());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = NettyUtilAdvice.class)\n\t@Test\n\tpublic void testGetFileFileNotModified() throws Exception {\n\n\t\t// With log\n\n\t\tPath remoteFilePath = Paths.get(\"remoteFile\");\n\t\tPath cachedLocalFilePath = Paths.get(\"cacheLocalFile\");\n\n\t\tMap<Path, Path> pathMap =  _nettyRepository.pathMap;\n\n\t\tpathMap.put(remoteFilePath, cachedLocalFilePath);\n\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyRepository.class.getName(), Level.FINEST);\n\n\t\ttry {\n\t\t\tNoticeableFuture<Path> noticeableFuture = _nettyRepository.getFile(\n\t\t\t\tremoteFilePath, Paths.get(\"localFile\"), false, false);\n\n\t\t\t_asyncBroker.takeWithResult(\n\t\t\t\tremoteFilePath,\n\t\t\t\tnew FileResponse(\n\t\t\t\t\tremoteFilePath, FileResponse.FILE_NOT_MODIFIED, 0, false));\n\n\t\t\tAssert.assertSame(cachedLocalFilePath, noticeableFuture.get());\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertEquals(2, logRecords.size());\n\n\t\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Fetching remote file \" + remoteFilePath,\n\t\t\t\tlogRecord.getMessage());\n\n\t\t\tlogRecord = logRecords.get(1);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Remote file \" + remoteFilePath +\n\t\t\t\t\t\" is not modified, use cached local file \" +\n\t\t\t\t\t\tcachedLocalFilePath,\n\t\t\t\tlogRecord.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\n\t\t// Without log\n\n\t\tcaptureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyRepository.class.getName(), Level.OFF);\n\n\t\ttry {\n\t\t\tNoticeableFuture<Path> noticeableFuture = _nettyRepository.getFile(\n\t\t\t\tremoteFilePath, Paths.get(\"localFile\"), false, false);\n\n\t\t\t_asyncBroker.takeWithResult(\n\t\t\t\tremoteFilePath,\n\t\t\t\tnew FileResponse(\n\t\t\t\t\tremoteFilePath, FileResponse.FILE_NOT_MODIFIED, 0, false));\n\n\t\t\tAssert.assertSame(cachedLocalFilePath, noticeableFuture.get());\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertTrue(logRecords.isEmpty());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\t}","id":99181,"modified_method":"@AdviseWith(adviceClasses = NettyUtilAdvice.class)\n\t@Test\n\tpublic void testGetFileFileNotModified() throws Exception {\n\n\t\t// With log\n\n\t\tPath remoteFilePath = Paths.get(\"remoteFile\");\n\t\tPath cachedLocalFilePath = Paths.get(\"cacheLocalFile\");\n\n\t\tMap<Path, Path> pathMap =  _nettyRepository.pathMap;\n\n\t\tpathMap.put(remoteFilePath, cachedLocalFilePath);\n\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyRepository.class.getName(), Level.FINEST);\n\n\t\ttry {\n\t\t\tNoticeableFuture<Path> noticeableFuture = _nettyRepository.getFile(\n\t\t\t\t_embeddedChannel, remoteFilePath, Paths.get(\"localFile\"), false,\n\t\t\t\tfalse);\n\n\t\t\t_asyncBroker.takeWithResult(\n\t\t\t\tremoteFilePath,\n\t\t\t\tnew FileResponse(\n\t\t\t\t\tremoteFilePath, FileResponse.FILE_NOT_MODIFIED, 0, false));\n\n\t\t\tAssert.assertSame(cachedLocalFilePath, noticeableFuture.get());\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertEquals(2, logRecords.size());\n\n\t\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Fetching remote file \" + remoteFilePath,\n\t\t\t\tlogRecord.getMessage());\n\n\t\t\tlogRecord = logRecords.get(1);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Remote file \" + remoteFilePath +\n\t\t\t\t\t\" is not modified, use cached local file \" +\n\t\t\t\t\t\tcachedLocalFilePath,\n\t\t\t\tlogRecord.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\n\t\t// Without log\n\n\t\tcaptureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyRepository.class.getName(), Level.OFF);\n\n\t\ttry {\n\t\t\tNoticeableFuture<Path> noticeableFuture = _nettyRepository.getFile(\n\t\t\t\t_embeddedChannel, remoteFilePath, Paths.get(\"localFile\"), false,\n\t\t\t\tfalse);\n\n\t\t\t_asyncBroker.takeWithResult(\n\t\t\t\tremoteFilePath,\n\t\t\t\tnew FileResponse(\n\t\t\t\t\tremoteFilePath, FileResponse.FILE_NOT_MODIFIED, 0, false));\n\n\t\t\tAssert.assertSame(cachedLocalFilePath, noticeableFuture.get());\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertTrue(logRecords.isEmpty());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tNettyUtilAdvice.class, DefaultNoticeableFutureAdvice.class\n\t\t})\n\t@Test\n\tpublic void testGetFilesCovertCausedException() throws Exception {\n\t\tMap<Path, Path> pathMap = new HashMap<Path, Path>();\n\n\t\tPath remoteFilePath = Paths.get(\"remoteFile\");\n\n\t\tpathMap.put(remoteFilePath, Paths.get(\"localFile\"));\n\n\t\tNoticeableFuture<Map<Path, Path>> noticeableFuture =\n\t\t\t_nettyRepository.getFiles(pathMap, true);\n\n\t\tException exception = new Exception();\n\n\t\tDefaultNoticeableFutureAdvice.setConvertThrowable(exception);\n\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyRepository.class.getName(), Level.WARNING);\n\n\t\ttry {\n\t\t\tAssert.assertTrue(\n\t\t\t\t_asyncBroker.takeWithResult(\n\t\t\t\t\tremoteFilePath,\n\t\t\t\t\tnew FileResponse(\n\t\t\t\t\t\t_repositoryPath, FileResponse.FILE_NOT_FOUND, -1,\n\t\t\t\t\t\tfalse)));\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertEquals(1, logRecords.size());\n\n\t\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Remote file remoteFile is not found\", logRecord.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\n\t\ttry {\n\t\t\tnoticeableFuture.get();\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (ExecutionException ee) {\n\t\t\tAssert.assertSame(exception, ee.getCause());\n\t\t}\n\t}","id":99182,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tNettyUtilAdvice.class, DefaultNoticeableFutureAdvice.class\n\t\t})\n\t@Test\n\tpublic void testGetFilesCovertCausedException() throws Exception {\n\t\tMap<Path, Path> pathMap = new HashMap<Path, Path>();\n\n\t\tPath remoteFilePath = Paths.get(\"remoteFile\");\n\n\t\tpathMap.put(remoteFilePath, Paths.get(\"localFile\"));\n\n\t\tNoticeableFuture<Map<Path, Path>> noticeableFuture =\n\t\t\t_nettyRepository.getFiles(_embeddedChannel, pathMap, true);\n\n\t\tException exception = new Exception();\n\n\t\tDefaultNoticeableFutureAdvice.setConvertThrowable(exception);\n\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyRepository.class.getName(), Level.WARNING);\n\n\t\ttry {\n\t\t\tAssert.assertTrue(\n\t\t\t\t_asyncBroker.takeWithResult(\n\t\t\t\t\tremoteFilePath,\n\t\t\t\t\tnew FileResponse(\n\t\t\t\t\t\t_repositoryPath, FileResponse.FILE_NOT_FOUND, -1,\n\t\t\t\t\t\tfalse)));\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertEquals(1, logRecords.size());\n\n\t\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Remote file remoteFile is not found\", logRecord.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\n\t\ttry {\n\t\t\tnoticeableFuture.get();\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (ExecutionException ee) {\n\t\t\tAssert.assertSame(exception, ee.getCause());\n\t\t}\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Before\n\tpublic void setUp() throws IOException {\n\t\t_channelPipeline = _embeddedChannel.pipeline();\n\n\t\t_repositoryPath = Paths.get(\"repository\");\n\n\t\tFileHelperUtil.delete(_repositoryPath);\n\n\t\tFileServerTestUtil.registerForCleanUp(\n\t\t\tFiles.createDirectory(_repositoryPath));\n\n\t\t_nettyRepository = new NettyRepository(\n\t\t\t_repositoryPath, _embeddedChannel, _embeddedChannel.eventLoop(),\n\t\t\tLong.MAX_VALUE);\n\n\t\t_asyncBroker = _nettyRepository.asyncBroker;\n\t}","id":99183,"modified_method":"@Before\n\tpublic void setUp() throws IOException {\n\t\t_channelPipeline = _embeddedChannel.pipeline();\n\n\t\t_repositoryPath = Paths.get(\"repository\");\n\n\t\tFileHelperUtil.delete(_repositoryPath);\n\n\t\tFileServerTestUtil.registerForCleanUp(\n\t\t\tFiles.createDirectory(_repositoryPath));\n\n\t\tAsyncBroker<Path, FileResponse> asyncBroker =\n\t\t\tnew AsyncBroker<Path, FileResponse>();\n\n\t\t_channelPipeline.addLast(\n\t\t\tnew FileResponseChannelHandler(\n\t\t\t\tasyncBroker, _embeddedChannel.eventLoop()));\n\n\t\t_nettyRepository = new NettyRepository(\n\t\t\t_repositoryPath, asyncBroker, Long.MAX_VALUE);\n\n\t\t_asyncBroker = _nettyRepository.asyncBroker;\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@NewEnv(type = NewEnv.Type.NONE)\n\t@Test\n\tpublic void testGetFilesEmptyMap() throws Exception {\n\t\tNoticeableFuture<Map<Path, Path>> noticeableFuture =\n\t\t\t_nettyRepository.getFiles(Collections.<Path, Path>emptyMap(), true);\n\n\t\tAssert.assertSame(\n\t\t\tCollections.<Path, Path>emptyMap(), noticeableFuture.get());\n\t}","id":99184,"modified_method":"@NewEnv(type = NewEnv.Type.NONE)\n\t@Test\n\tpublic void testGetFilesEmptyMap() throws Exception {\n\t\tNoticeableFuture<Map<Path, Path>> noticeableFuture =\n\t\t\t_nettyRepository.getFiles(\n\t\t\t\t_embeddedChannel, Collections.<Path, Path>emptyMap(), true);\n\n\t\tAssert.assertSame(\n\t\t\tCollections.<Path, Path>emptyMap(), noticeableFuture.get());\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void doTestGetFileChannelFailure(\n\t\t\tfinal boolean asyncBrokerFailure, boolean logging)\n\t\tthrows InterruptedException {\n\n\t\tfinal Exception exception = new Exception();\n\n\t\tfinal Path remoteFilePath = Paths.get(\"remoteFile\");\n\n\t\t_channelPipeline.addLast(\n\t\t\tnew ChannelOutboundHandlerAdapter() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void write(\n\t\t\t\t\tChannelHandlerContext channelHandlerContext, Object message,\n\t\t\t\t\tChannelPromise channelPromise) {\n\n\t\t\t\t\tif (asyncBrokerFailure) {\n\t\t\t\t\t\t_asyncBroker.takeWithException(\n\t\t\t\t\t\t\tremoteFilePath, exception);\n\t\t\t\t\t}\n\n\t\t\t\t\tchannelPromise.setFailure(exception);\n\t\t\t\t}\n\n\t\t\t});\n\n\t\tCaptureHandler captureHandler = null;\n\n\t\tif (logging) {\n\t\t\tcaptureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\t\tNettyRepository.class.getName(), Level.ALL);\n\t\t}\n\t\telse {\n\t\t\tcaptureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\t\tNettyRepository.class.getName(), Level.OFF);\n\t\t}\n\n\t\ttry {\n\t\t\tNoticeableFuture<Path> noticeableFuture = _nettyRepository.getFile(\n\t\t\t\tremoteFilePath, Paths.get(\"localFile\"), false, false);\n\n\t\t\ttry {\n\t\t\t\tnoticeableFuture.get();\n\t\t\t}\n\t\t\tcatch (ExecutionException ee) {\n\t\t\t\tThrowable throwable = ee.getCause();\n\n\t\t\t\tif (!asyncBrokerFailure) {\n\t\t\t\t\tAssert.assertEquals(\n\t\t\t\t\t\t\"Unable to fetch remote file \" + remoteFilePath,\n\t\t\t\t\t\tthrowable.getMessage());\n\n\t\t\t\t\tthrowable = throwable.getCause();\n\t\t\t\t}\n\n\t\t\t\tAssert.assertSame(exception, throwable);\n\t\t\t}\n\n\t\t\tif (logging) {\n\t\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\t\tLogRecord logRecord = logRecords.remove(0);\n\n\t\t\t\tAssert.assertEquals(\n\t\t\t\t\t\"Fetching remote file \" + remoteFilePath,\n\t\t\t\t\tlogRecord.getMessage());\n\n\t\t\t\tif (asyncBrokerFailure) {\n\t\t\t\t\tlogRecord = logRecords.remove(0);\n\n\t\t\t\t\tAssert.assertEquals(\n\t\t\t\t\t\t\"Unable to place exception because no future exists \" +\n\t\t\t\t\t\t\t\"with ID \" + remoteFilePath,\n\t\t\t\t\t\tlogRecord.getMessage());\n\n\t\t\t\t\tThrowable throwable = logRecord.getThrown();\n\n\t\t\t\t\tAssert.assertEquals(\n\t\t\t\t\t\t\"Unable to fetch remote file \" + remoteFilePath,\n\t\t\t\t\t\tthrowable.getMessage());\n\t\t\t\t\tAssert.assertSame(exception, throwable.getCause());\n\t\t\t\t}\n\n\t\t\t\tAssert.assertTrue(logRecords.isEmpty());\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\t}","id":99185,"modified_method":"protected void doTestGetFileChannelFailure(\n\t\t\tfinal boolean asyncBrokerFailure, boolean logging)\n\t\tthrows InterruptedException {\n\n\t\tfinal Exception exception = new Exception();\n\n\t\tfinal Path remoteFilePath = Paths.get(\"remoteFile\");\n\n\t\t_channelPipeline.addLast(\n\t\t\tnew ChannelOutboundHandlerAdapter() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void write(\n\t\t\t\t\tChannelHandlerContext channelHandlerContext, Object message,\n\t\t\t\t\tChannelPromise channelPromise) {\n\n\t\t\t\t\tif (asyncBrokerFailure) {\n\t\t\t\t\t\t_asyncBroker.takeWithException(\n\t\t\t\t\t\t\tremoteFilePath, exception);\n\t\t\t\t\t}\n\n\t\t\t\t\tchannelPromise.setFailure(exception);\n\t\t\t\t}\n\n\t\t\t});\n\n\t\tCaptureHandler captureHandler = null;\n\n\t\tif (logging) {\n\t\t\tcaptureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\t\tNettyRepository.class.getName(), Level.ALL);\n\t\t}\n\t\telse {\n\t\t\tcaptureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\t\tNettyRepository.class.getName(), Level.OFF);\n\t\t}\n\n\t\ttry {\n\t\t\tNoticeableFuture<Path> noticeableFuture = _nettyRepository.getFile(\n\t\t\t\t_embeddedChannel, remoteFilePath, Paths.get(\"localFile\"), false,\n\t\t\t\tfalse);\n\n\t\t\ttry {\n\t\t\t\tnoticeableFuture.get();\n\t\t\t}\n\t\t\tcatch (ExecutionException ee) {\n\t\t\t\tThrowable throwable = ee.getCause();\n\n\t\t\t\tif (!asyncBrokerFailure) {\n\t\t\t\t\tAssert.assertEquals(\n\t\t\t\t\t\t\"Unable to fetch remote file \" + remoteFilePath,\n\t\t\t\t\t\tthrowable.getMessage());\n\n\t\t\t\t\tthrowable = throwable.getCause();\n\t\t\t\t}\n\n\t\t\t\tAssert.assertSame(exception, throwable);\n\t\t\t}\n\n\t\t\tif (logging) {\n\t\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\t\tLogRecord logRecord = logRecords.remove(0);\n\n\t\t\t\tAssert.assertEquals(\n\t\t\t\t\t\"Fetching remote file \" + remoteFilePath,\n\t\t\t\t\tlogRecord.getMessage());\n\n\t\t\t\tif (asyncBrokerFailure) {\n\t\t\t\t\tlogRecord = logRecords.remove(0);\n\n\t\t\t\t\tAssert.assertEquals(\n\t\t\t\t\t\t\"Unable to place exception because no future exists \" +\n\t\t\t\t\t\t\t\"with ID \" + remoteFilePath,\n\t\t\t\t\t\tlogRecord.getMessage());\n\n\t\t\t\t\tThrowable throwable = logRecord.getThrown();\n\n\t\t\t\t\tAssert.assertEquals(\n\t\t\t\t\t\t\"Unable to fetch remote file \" + remoteFilePath,\n\t\t\t\t\t\tthrowable.getMessage());\n\t\t\t\t\tAssert.assertSame(exception, throwable.getCause());\n\t\t\t\t}\n\n\t\t\t\tAssert.assertTrue(logRecords.isEmpty());\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = NettyUtilAdvice.class)\n\t@Test\n\tpublic void testGetFileFileNotFound() throws Exception {\n\n\t\t// With log\n\n\t\tPath remoteFilePath = Paths.get(\"remoteFile\");\n\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyRepository.class.getName(), Level.WARNING);\n\n\t\ttry {\n\t\t\tNoticeableFuture<Path> noticeableFuture = _nettyRepository.getFile(\n\t\t\t\tremoteFilePath, Paths.get(\"localFile\"), false, false);\n\n\t\t\t_asyncBroker.takeWithResult(\n\t\t\t\tremoteFilePath,\n\t\t\t\tnew FileResponse(\n\t\t\t\t\tremoteFilePath, FileResponse.FILE_NOT_FOUND, 0, false));\n\n\t\t\tAssert.assertNull(noticeableFuture.get());\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertEquals(1, logRecords.size());\n\n\t\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Remote file \" + remoteFilePath + \" is not found\",\n\t\t\t\tlogRecord.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\n\t\t// Without log\n\n\t\tcaptureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyRepository.class.getName(), Level.OFF);\n\n\t\ttry {\n\t\t\tNoticeableFuture<Path> noticeableFuture = _nettyRepository.getFile(\n\t\t\t\tremoteFilePath, Paths.get(\"localFile\"), false, false);\n\n\t\t\t_asyncBroker.takeWithResult(\n\t\t\t\tremoteFilePath,\n\t\t\t\tnew FileResponse(\n\t\t\t\t\tremoteFilePath, FileResponse.FILE_NOT_FOUND, 0, false));\n\n\t\t\tAssert.assertNull(noticeableFuture.get());\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertTrue(logRecords.isEmpty());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\t}","id":99186,"modified_method":"@AdviseWith(adviceClasses = NettyUtilAdvice.class)\n\t@Test\n\tpublic void testGetFileFileNotFound() throws Exception {\n\n\t\t// With log\n\n\t\tPath remoteFilePath = Paths.get(\"remoteFile\");\n\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyRepository.class.getName(), Level.WARNING);\n\n\t\ttry {\n\t\t\tNoticeableFuture<Path> noticeableFuture = _nettyRepository.getFile(\n\t\t\t\t_embeddedChannel, remoteFilePath, Paths.get(\"localFile\"), false,\n\t\t\t\tfalse);\n\n\t\t\t_asyncBroker.takeWithResult(\n\t\t\t\tremoteFilePath,\n\t\t\t\tnew FileResponse(\n\t\t\t\t\tremoteFilePath, FileResponse.FILE_NOT_FOUND, 0, false));\n\n\t\t\tAssert.assertNull(noticeableFuture.get());\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertEquals(1, logRecords.size());\n\n\t\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Remote file \" + remoteFilePath + \" is not found\",\n\t\t\t\tlogRecord.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\n\t\t// Without log\n\n\t\tcaptureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tNettyRepository.class.getName(), Level.OFF);\n\n\t\ttry {\n\t\t\tNoticeableFuture<Path> noticeableFuture = _nettyRepository.getFile(\n\t\t\t\t_embeddedChannel, remoteFilePath, Paths.get(\"localFile\"), false,\n\t\t\t\tfalse);\n\n\t\t\t_asyncBroker.takeWithResult(\n\t\t\t\tremoteFilePath,\n\t\t\t\tnew FileResponse(\n\t\t\t\t\tremoteFilePath, FileResponse.FILE_NOT_FOUND, 0, false));\n\n\t\t\tAssert.assertNull(noticeableFuture.get());\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tAssert.assertTrue(logRecords.isEmpty());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = NettyUtilAdvice.class)\n\t@Test\n\tpublic void testGetFileChannelCancellation() {\n\t\t_channelPipeline.addFirst(\n\t\t\tnew ChannelOutboundHandlerAdapter() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void write(\n\t\t\t\t\tChannelHandlerContext channelHandlerContext, Object object,\n\t\t\t\t\tChannelPromise channelPromise) {\n\n\t\t\t\t\tchannelPromise.cancel(true);\n\t\t\t\t}\n\n\t\t\t});\n\n\t\ttry {\n\t\t\tNoticeableFuture<Path> noticeableFuture = _nettyRepository.getFile(\n\t\t\t\tPaths.get(\"remoteFile\"), Paths.get(\"localFile\"), false, false);\n\n\t\t\tAssert.assertTrue(noticeableFuture.isDone());\n\t\t\tAssert.assertTrue(noticeableFuture.isCancelled());\n\t\t}\n\t\tfinally {\n\t\t\t_channelPipeline.removeFirst();\n\t\t}\n\t}","id":99187,"modified_method":"@AdviseWith(adviceClasses = NettyUtilAdvice.class)\n\t@Test\n\tpublic void testGetFileChannelCancellation() {\n\t\t_channelPipeline.addFirst(\n\t\t\tnew ChannelOutboundHandlerAdapter() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void write(\n\t\t\t\t\tChannelHandlerContext channelHandlerContext, Object object,\n\t\t\t\t\tChannelPromise channelPromise) {\n\n\t\t\t\t\tchannelPromise.cancel(true);\n\t\t\t\t}\n\n\t\t\t});\n\n\t\ttry {\n\t\t\tNoticeableFuture<Path> noticeableFuture = _nettyRepository.getFile(\n\t\t\t\t_embeddedChannel, Paths.get(\"remoteFile\"),\n\t\t\t\tPaths.get(\"localFile\"), false, false);\n\n\t\t\tAssert.assertTrue(noticeableFuture.isDone());\n\t\t\tAssert.assertTrue(noticeableFuture.isCancelled());\n\t\t}\n\t\tfinally {\n\t\t\t_channelPipeline.removeFirst();\n\t\t}\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = NettyUtilAdvice.class)\n\t@Test\n\tpublic void testGetFileTimeoutCancellation() {\n\t\tNettyRepository repository = new NettyRepository(\n\t\t\t_repositoryPath, _embeddedChannel, _embeddedChannel.eventLoop(), 0);\n\n\t\tNoticeableFuture<Path> noticeableFuture = repository.getFile(\n\t\t\tPaths.get(\"remoteFile\"), Paths.get(\"localFile\"), false, false);\n\n\t\tAssert.assertTrue(noticeableFuture.isDone());\n\t\tAssert.assertTrue(noticeableFuture.isCancelled());\n\t}","id":99188,"modified_method":"@AdviseWith(adviceClasses = NettyUtilAdvice.class)\n\t@Test\n\tpublic void testGetFileTimeoutCancellation() {\n\t\tAsyncBroker<Path, FileResponse> asyncBroker =\n\t\t\tnew AsyncBroker<Path, FileResponse>();\n\n\t\t_channelPipeline.addLast(\n\t\t\tnew FileResponseChannelHandler(\n\t\t\t\tasyncBroker, _embeddedChannel.eventLoop()));\n\n\t\tNettyRepository repository = new NettyRepository(\n\t\t\t_repositoryPath, asyncBroker, 0);\n\n\t\tNoticeableFuture<Path> noticeableFuture = repository.getFile(\n\t\t\t_embeddedChannel, Paths.get(\"remoteFile\"), Paths.get(\"localFile\"),\n\t\t\tfalse, false);\n\n\t\tAssert.assertTrue(noticeableFuture.isDone());\n\t\tAssert.assertTrue(noticeableFuture.isCancelled());\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = NettyUtilAdvice.class)\n\t@Test\n\tpublic void testGetFilesExecutionException() throws Exception {\n\t\tMap<Path, Path> pathMap = new HashMap<Path, Path>();\n\n\t\tPath remoteFilePath1 = Paths.get(\"remoteFile1\");\n\n\t\tpathMap.put(remoteFilePath1, Paths.get(\"requestFile1\"));\n\t\tpathMap.put(Paths.get(\"remoteFile2\"), Paths.get(\"requestFile2\"));\n\n\t\tNoticeableFuture<Map<Path, Path>> noticeableFuture =\n\t\t\t_nettyRepository.getFiles(pathMap, true);\n\n\t\tException exception = new Exception();\n\n\t\tAssert.assertTrue(\n\t\t\t_asyncBroker.takeWithException(remoteFilePath1, exception));\n\n\t\ttry {\n\t\t\tnoticeableFuture.get();\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (ExecutionException ee) {\n\t\t\tAssert.assertSame(exception, ee.getCause());\n\t\t}\n\t}","id":99189,"modified_method":"@AdviseWith(adviceClasses = NettyUtilAdvice.class)\n\t@Test\n\tpublic void testGetFilesExecutionException() throws Exception {\n\t\tMap<Path, Path> pathMap = new HashMap<Path, Path>();\n\n\t\tPath remoteFilePath1 = Paths.get(\"remoteFile1\");\n\n\t\tpathMap.put(remoteFilePath1, Paths.get(\"requestFile1\"));\n\t\tpathMap.put(Paths.get(\"remoteFile2\"), Paths.get(\"requestFile2\"));\n\n\t\tNoticeableFuture<Map<Path, Path>> noticeableFuture =\n\t\t\t_nettyRepository.getFiles(_embeddedChannel, pathMap, true);\n\n\t\tException exception = new Exception();\n\n\t\tAssert.assertTrue(\n\t\t\t_asyncBroker.takeWithException(remoteFilePath1, exception));\n\n\t\ttry {\n\t\t\tnoticeableFuture.get();\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (ExecutionException ee) {\n\t\t\tAssert.assertSame(exception, ee.getCause());\n\t\t}\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = NettyUtilAdvice.class)\n\t@Test\n\tpublic void testGetFilesCancelled() {\n\t\tMap<Path, Path> pathMap = new HashMap<Path, Path>();\n\n\t\tPath remoteFilePath1 = Paths.get(\"remoteFile1\");\n\n\t\tpathMap.put(remoteFilePath1, Paths.get(\"localFile1\"));\n\t\tpathMap.put(Paths.get(\"remoteFile2\"), Paths.get(\"requestFile2\"));\n\n\t\tNoticeableFuture<Map<Path, Path>> noticeableFuture =\n\t\t\t_nettyRepository.getFiles(pathMap, true);\n\n\t\tMap<Path, NoticeableFuture<FileResponse>> openBids =\n\t\t\t_asyncBroker.getOpenBids();\n\n\t\tNoticeableFuture<FileResponse> fileGetNoticeableFuture = openBids.get(\n\t\t\tremoteFilePath1);\n\n\t\tAssert.assertNotNull(fileGetNoticeableFuture);\n\n\t\tfileGetNoticeableFuture.cancel(true);\n\n\t\tAssert.assertTrue(noticeableFuture.isCancelled());\n\t}","id":99190,"modified_method":"@AdviseWith(adviceClasses = NettyUtilAdvice.class)\n\t@Test\n\tpublic void testGetFilesCancelled() {\n\t\tMap<Path, Path> pathMap = new HashMap<Path, Path>();\n\n\t\tPath remoteFilePath1 = Paths.get(\"remoteFile1\");\n\n\t\tpathMap.put(remoteFilePath1, Paths.get(\"localFile1\"));\n\t\tpathMap.put(Paths.get(\"remoteFile2\"), Paths.get(\"requestFile2\"));\n\n\t\tNoticeableFuture<Map<Path, Path>> noticeableFuture =\n\t\t\t_nettyRepository.getFiles(_embeddedChannel, pathMap, true);\n\n\t\tMap<Path, NoticeableFuture<FileResponse>> openBids =\n\t\t\t_asyncBroker.getOpenBids();\n\n\t\tNoticeableFuture<FileResponse> fileGetNoticeableFuture = openBids.get(\n\t\t\tremoteFilePath1);\n\n\t\tAssert.assertNotNull(fileGetNoticeableFuture);\n\n\t\tfileGetNoticeableFuture.cancel(true);\n\n\t\tAssert.assertTrue(noticeableFuture.isCancelled());\n\t}","commit_id":"bc7d1d037031558d5d93ebdc85434803ac3ec53c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n  public Iterable<SModel> getModels() {\n    Collection<SModelDescriptor> models = getManager().load(myModelRoot, (IModule) myModule);\n    return (Iterable) models;\n  }","id":99191,"modified_method":"@Override\n  public Iterable<SModel> getModels() {\n    IModelRootManager manager = getManager();\n    //model with model root manager not yet loaded - should be loaded after classes reloading\n    if (manager == null) return Collections.emptyList();\n\n    Collection<SModelDescriptor> models = manager.load(myModelRoot, (IModule) myModule);\n    return (Iterable) models;\n  }","commit_id":"99f514562954493d3ca0acd1192bfdf850f55444","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public final boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {\n    if (!file.getManager().isInProject(file)) return false;\n    final PsiElement element = getElement(editor, file);\n    return element != null && isAvailable(project, editor, element);\n  }","id":99192,"modified_method":"@Override\n  public final boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {\n    final PsiManager manager = file.getManager();\n    if (manager == null) return false;\n    if (!manager.isInProject(file)) return false;\n    final PsiElement element = getElement(editor, file);\n    return element != null && isAvailable(project, editor, element);\n  }","commit_id":"c666fc51736c43d26bd75798b5d8a709686ce4ce","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiType getType() {\n    if (isMapLiteral()) {\n      return getManager().getElementFactory().createTypeByFQClassName(\"java.util.Map\", getResolveScope());\n    }\n\n    PsiElement parent = getParent();\n    if (parent.getParent() instanceof GrVariableDeclaration) {\n      GrTypeElement typeElement = ((GrVariableDeclaration) parent.getParent()).getTypeElementGroovy();\n      if (typeElement != null) {\n        PsiType declaredType = typeElement.getType();\n        if (declaredType instanceof PsiArrayType) return declaredType;\n      }\n    }\n\n    return getManager().getElementFactory().createTypeByFQClassName(\"java.util.List\", getResolveScope());\n  }","id":99193,"modified_method":"public PsiType getType() {\n    PsiManager manager = getManager();\n    if (isMapLiteral()) {\n      return manager.getElementFactory().createTypeByFQClassName(\"java.util.Map\", getResolveScope());\n    }\n\n    PsiElement parent = getParent();\n    if (parent.getParent() instanceof GrVariableDeclaration) {\n      GrTypeElement typeElement = ((GrVariableDeclaration) parent.getParent()).getTypeElementGroovy();\n      if (typeElement != null) {\n        PsiType declaredType = typeElement.getType();\n        if (declaredType instanceof PsiArrayType) return declaredType;\n      }\n    }\n\n    PsiClass listClass = manager.findClass(\"java.util.List\", getResolveScope());\n    if (listClass != null) {\n      PsiTypeParameter[] typeParameters = listClass.getTypeParameters();\n      if (typeParameters.length == 1) {\n        GrExpression[] initializers = getInitializers();\n        PsiType initializerType = initializers.length > 0 ? initializers[0].getType() : null;\n        PsiSubstitutor substitutor = PsiSubstitutor.EMPTY.put(typeParameters[0], initializerType);\n        return manager.getElementFactory().createType(listClass, substitutor);\n      } else {\n        return manager.getElementFactory().createType(listClass);\n      }\n    }\n\n    return null;\n  }","commit_id":"277156b9aeb466527592ef4267abcb2ea550e176","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiType getType() {\n    GrExpression invoked = getInvokedExpression();\n    if (invoked instanceof GrReferenceExpression) {\n      PsiElement resolved = ((GrReferenceExpression) invoked).resolve();\n      if (resolved instanceof PsiMethod && resolved.getCopyableUserData(ResolveUtil.IS_BEING_RESOLVED) == null) {\n        PsiType returnType = ((PsiMethod) resolved).getReturnType();\n        return TypesUtil.boxPrimitiveTypeAndEraseGenerics(returnType, getManager(), getResolveScope());\n      }\n    }\n\n    return null;\n  }","id":99194,"modified_method":"public PsiType getType() {\n    GrExpression invoked = getInvokedExpression();\n    if (invoked instanceof GrReferenceExpression) {\n      GrReferenceExpression refExpr = (GrReferenceExpression) invoked;\n      PsiElement resolved = refExpr.resolve();\n      if (resolved instanceof PsiMethod && resolved.getCopyableUserData(ResolveUtil.IS_BEING_RESOLVED) == null) {\n        PsiType returnType = ((PsiMethod) resolved).getReturnType();\n        returnType = TypesUtil.boxPrimitiveType(returnType, getManager(), getResolveScope());\n        if (refExpr.getDotTokenType() != GroovyTokenTypes.mSPREAD_DOT) {\n          return returnType;\n        } else {\n          return ResolveUtil.getListTypeForSpreadOperator(refExpr, returnType);\n        }\n      }\n    }\n\n    return null;\n  }","commit_id":"277156b9aeb466527592ef4267abcb2ea550e176","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void resolveImpl(GrReferenceExpressionImpl refExpr, ResolverProcessor processor) {\n      GrExpression qualifier = refExpr.getQualifierExpression();\n      if (qualifier == null) {\n        ResolveUtil.treeWalkUp(refExpr, processor);\n        if (!processor.hasCandidates()) {\n          qualifier = getRuntimeQualifier(refExpr);\n          if (qualifier != null) {\n            processQualifier(refExpr, processor, qualifier);\n          }\n        }\n      } else {\n        if (refExpr.getDotTokenType() != GroovyTokenTypes.mSPREAD_DOT) {\n          processQualifier(refExpr, processor, qualifier);\n        } else {\n          //todo\n        }\n      }\n    }","id":99195,"modified_method":"private void resolveImpl(GrReferenceExpressionImpl refExpr, ResolverProcessor processor) {\n      GrExpression qualifier = refExpr.getQualifierExpression();\n      if (qualifier == null) {\n        ResolveUtil.treeWalkUp(refExpr, processor);\n        if (!processor.hasCandidates()) {\n          qualifier = getRuntimeQualifier(refExpr);\n          if (qualifier != null) {\n            processQualifier(refExpr, processor, qualifier);\n          }\n        }\n      } else {\n        if (refExpr.getDotTokenType() != GroovyTokenTypes.mSPREAD_DOT) {\n          processQualifier(refExpr, processor, qualifier);\n        } else {\n          processQualifierForSpreadDot(refExpr, processor, qualifier);\n        }\n      }\n    }","commit_id":"277156b9aeb466527592ef4267abcb2ea550e176","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public IElementType getDotTokenType() {\n    return findChildByType(GroovyTokenTypes.DOTS).getNode().getElementType();\n  }","id":99196,"modified_method":"@Nullable\n  public IElementType getDotTokenType() {\n    PsiElement dot = findChildByType(GroovyTokenTypes.DOTS);\n    return dot == null ? null : dot.getNode().getElementType();\n  }","commit_id":"277156b9aeb466527592ef4267abcb2ea550e176","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiType fun(GrReferenceExpressionImpl refExpr) {\n      PsiElement resolved = refExpr.resolve();\n      PsiType result = null;\n      PsiManager manager = refExpr.getManager();\n      if (resolved instanceof PsiClass) {\n        result = manager.getElementFactory().createType((PsiClass) resolved);\n      } else if (resolved instanceof PsiVariable) {\n        result = ((PsiVariable) resolved).getType();\n      } else if (resolved instanceof PsiMethod) {\n        PsiElement nameElement = refExpr.getReferenceNameElement();\n        PsiElement prev = PsiTreeUtil.skipSiblingsBackward(nameElement, PsiWhiteSpace.class);\n        if (prev != null && prev.getNode().getElementType() == GroovyTokenTypes.mMEMBER_POINTER) {\n          return manager.getElementFactory().createTypeByFQClassName(\"groovy.lang.Closure\", refExpr.getResolveScope());\n        }\n        PsiMethod method = (PsiMethod) resolved;\n        if (PropertyUtil.isSimplePropertySetter(method)) {\n          result = method.getParameterList().getParameters()[0].getType();\n        } else {\n          result = method.getReturnType();\n        }\n      } else if (resolved instanceof GrReferenceExpression) {\n        PsiElement parent = resolved.getParent();\n        if (parent instanceof GrAssignmentExpression) {\n          GrAssignmentExpression assignment = (GrAssignmentExpression) parent;\n          if (resolved.equals(assignment.getLValue())) {\n            GrExpression rValue = assignment.getRValue();\n            if (rValue != null) {\n              PsiType rType = rValue.getType();\n              if (rType != null) result = rType;\n            }\n          }\n        }\n      }\n\n      return TypesUtil.boxPrimitiveTypeAndEraseGenerics(result, manager, refExpr.getResolveScope());\n    }","id":99197,"modified_method":"public PsiType fun(GrReferenceExpressionImpl refExpr) {\n      IElementType dotType = refExpr.getDotTokenType();\n      PsiElement resolved = refExpr.resolve();\n      PsiType result = null;\n      PsiManager manager = refExpr.getManager();\n      if (resolved instanceof PsiClass) {\n        result = manager.getElementFactory().createType((PsiClass) resolved);\n      } else if (resolved instanceof PsiVariable) {\n        result = ((PsiVariable) resolved).getType();\n      } else if (resolved instanceof PsiMethod) {\n        if (dotType == GroovyTokenTypes.mMEMBER_POINTER) {\n          return manager.getElementFactory().createTypeByFQClassName(\"groovy.lang.Closure\", refExpr.getResolveScope());\n        }\n        PsiMethod method = (PsiMethod) resolved;\n        if (PropertyUtil.isSimplePropertySetter(method)) {\n          result = method.getParameterList().getParameters()[0].getType();\n        } else {\n          result = method.getReturnType();\n        }\n      } else if (resolved instanceof GrReferenceExpression) {\n        PsiElement parent = resolved.getParent();\n        if (parent instanceof GrAssignmentExpression) {\n          GrAssignmentExpression assignment = (GrAssignmentExpression) parent;\n          if (resolved.equals(assignment.getLValue())) {\n            GrExpression rValue = assignment.getRValue();\n            if (rValue != null) {\n              PsiType rType = rValue.getType();\n              if (rType != null) result = rType;\n            }\n          }\n        }\n      }\n\n      result = TypesUtil.boxPrimitiveType(result, manager, refExpr.getResolveScope());\n      if (dotType != GroovyTokenTypes.mSPREAD_DOT) {\n        return result;\n      } else {\n        return ResolveUtil.getListTypeForSpreadOperator(refExpr, result);\n      }\n    }","commit_id":"277156b9aeb466527592ef4267abcb2ea550e176","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Object[] getVariantsImpl(ResolverProcessor processor) {\n    GrExpression qualifier = getQualifierExpression();\n    if (qualifier == null) {\n      ResolveUtil.treeWalkUp(this, processor);\n      qualifier = getRuntimeQualifier(this);\n      if (qualifier != null) getVariantsFromQualifier(processor, qualifier);\n    } else {\n      if (getDotTokenType() != GroovyTokenTypes.mSPREAD_DOT) {\n        getVariantsFromQualifier(processor, qualifier);\n      } else {\n        //todo\n      }\n    }\n\n    GroovyResolveResult[] candidates = processor.getCandidates();\n    if (candidates.length == 0) return PsiNamedElement.EMPTY_ARRAY;\n    PsiElement[] elements = ResolveUtil.mapToElements(candidates);\n    String[] properties = addPretendedProperties(elements);\n    return ArrayUtil.mergeArrays(elements, properties, Object.class);\n  }","id":99198,"modified_method":"private Object[] getVariantsImpl(ResolverProcessor processor) {\n    GrExpression qualifier = getQualifierExpression();\n    if (qualifier == null) {\n      ResolveUtil.treeWalkUp(this, processor);\n      qualifier = getRuntimeQualifier(this);\n      if (qualifier != null) getVariantsFromQualifier(processor, qualifier);\n    } else {\n      if (getDotTokenType() != GroovyTokenTypes.mSPREAD_DOT) {\n        getVariantsFromQualifier(processor, qualifier);\n      } else {\n        getVariantsFromQualifierForSpreadOperator(processor, qualifier);\n      }\n    }\n\n    GroovyResolveResult[] candidates = processor.getCandidates();\n    if (candidates.length == 0) return PsiNamedElement.EMPTY_ARRAY;\n    PsiElement[] elements = ResolveUtil.mapToElements(candidates);\n    String[] properties = addPretendedProperties(elements);\n    return ArrayUtil.mergeArrays(elements, properties, Object.class);\n  }","commit_id":"277156b9aeb466527592ef4267abcb2ea550e176","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiType getType() {\n    IElementType opToken = getOperationTokenType();\n    GrExpression operand = getOperand();\n    PsiType opType = operand.getType();\n    if (opToken == GroovyTokenTypes.mBNOT) {\n      if (opType.equalsToText(\"java.lang.String\")) {\n        return getTypeByFQName(PATTERN_FQ_NAME);\n      }\n    }\n    return opType;\n  }","id":99199,"modified_method":"public PsiType getType() {\n    IElementType opToken = getOperationTokenType();\n    GrExpression operand = getOperand();\n    if (operand == null) return null;\n    PsiType opType = operand.getType();\n    if (opToken == GroovyTokenTypes.mBNOT) {\n      if (opType.equalsToText(\"java.lang.String\")) {\n        return getTypeByFQName(PATTERN_FQ_NAME);\n      }\n    }\n    return opType;\n  }","commit_id":"277156b9aeb466527592ef4267abcb2ea550e176","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean invokeImpl(final Project project, final GrExpression selectedExpr, final Editor editor) {\n\n    if (selectedExpr == null) {\n      String message = RefactoringBundle.getCannotRefactorMessage(GroovyRefactoringBundle.message(\"selected.block.should.represent.an.expression\"));\n      showErrorMessage(message, project);\n      return false;\n    }\n\n    final PsiFile file = selectedExpr.getContainingFile();\n    LOG.assertTrue(file != null, \"expr.getContainingFile() == null\");\n    final GroovyElementFactory factory = GroovyElementFactory.getInstance(project);\n\n\n    if (selectedExpr.getType() == PsiType.VOID) {\n      String message = RefactoringBundle.getCannotRefactorMessage(GroovyRefactoringBundle.message(\"selected.expression.has.void.type\"));\n      showErrorMessage(message, project);\n      return false;\n    }\n\n    // Get container element\n    final PsiElement eclosingContainer = GroovyRefactoringUtil.getEnclosingContainer(selectedExpr);\n    // TODO implement loop and fork statements as containers\n    if (eclosingContainer == null || !(eclosingContainer instanceof GroovyPsiElement)) {\n      return tempContainerNotFound(project);\n    }\n    final GroovyPsiElement tempContainer = ((GroovyPsiElement) eclosingContainer);\n    if (!isAppropriateContainer(tempContainer)) {\n      String message = RefactoringBundle.getCannotRefactorMessage(GroovyRefactoringBundle.message(\"refactoring.is.not.supported.in.the.current.context\", REFACTORING_NAME));\n      showErrorMessage(message, project);\n      return false;\n    }\n    if (!CommonRefactoringUtil.checkReadOnlyStatus(project, file)) return false;\n\n    // Find occurences\n    final PsiElement[] occurences = GroovyRefactoringUtil.getExpressionOccurences(GroovyRefactoringUtil.getUnparenthesizedExpr(selectedExpr), tempContainer);\n    // Getting settings\n    GroovyIntroduceVariableSettings settings = getSettings(project, editor, selectedExpr, selectedExpr.getType(), occurences, false, null);\n\n    if (!settings.isOK()) {\n      return false;\n    }\n\n    final String varName = settings.getEnteredName();\n    PsiType varType = settings.getSelectedType();\n    final boolean isFinal = settings.isDeclareFinal();\n    final boolean replaceAllOccurences = settings.isReplaceAllOccurrences();\n\n    // Generating varibable declaration\n    final GrVariableDeclaration varDecl = factory.createVariableDeclaration(varName,\n        GroovyRefactoringUtil.getUnparenthesizedExpr(selectedExpr), varType, isFinal);\n\n    final Runnable runnable = new Runnable() {\n      public void run() {\n        try {\n          /* insert new variable */\n          sortOccurences(occurences);\n          if (occurences.length == 0 || !(occurences[0] instanceof GrExpression)) {\n            throw new IncorrectOperationException(\"Wrong expression occurence\");\n          }\n          GrExpression firstOccurence;\n          if (replaceAllOccurences) {\n            firstOccurence = ((GrExpression) occurences[0]);\n          } else {\n            firstOccurence = selectedExpr;\n          }\n          // Replace at the place of first occurence\n          boolean alreadyDefined = replaceAloneExpression(firstOccurence, tempContainer, varDecl);\n          if (!alreadyDefined) {\n            // Insert before first occurence\n            insertVariableDefinition(tempContainer, selectedExpr, occurences, replaceAllOccurences, varDecl, factory);\n          }\n\n          //Replace other occurences\n          GrReferenceExpression refExpr = factory.createReferenceExpressionFromText(varName);\n          if (replaceAllOccurences) {\n            ArrayList<PsiElement> replaced = new ArrayList<PsiElement>();\n            for (PsiElement occurence : occurences) {\n              if (!(alreadyDefined && firstOccurence.equals(occurence))) {\n                if (occurence instanceof GrExpression) {\n                  GrExpression element = (GrExpression) occurence;\n                  // todo replace different case of replaceWithExpresssion method\n                  replaced.add(element.replaceWithExpresssion(refExpr));\n                  refExpr = factory.createReferenceExpressionFromText(varName);\n                } else {\n                  throw new IncorrectOperationException(\"Expression occurence to be replaced is not instance of GroovyPsiElement\");\n                }\n              }\n            }\n            if (editor != null) {\n              final PsiElement[] replacedOccurences = replaced.toArray(new PsiElement[replaced.size()]);\n              highlightReplacedOccurences(project, editor, replacedOccurences);\n            }\n          } else {\n            if (!alreadyDefined) {\n              selectedExpr.replaceWithExpresssion(refExpr);\n            }\n          }\n        } catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n    };\n\n    CommandProcessor.getInstance().executeCommand(\n        project,\n        new Runnable() {\n          public void run() {\n            ApplicationManager.getApplication().runWriteAction(runnable);\n          }\n        }, REFACTORING_NAME, null);\n    return true;\n\n  }","id":99200,"modified_method":"private boolean invokeImpl(final Project project, final GrExpression selectedExpr, final Editor editor) {\n\n    if (selectedExpr == null) {\n      String message = RefactoringBundle.getCannotRefactorMessage(GroovyRefactoringBundle.message(\"selected.block.should.represent.an.expression\"));\n      showErrorMessage(message, project);\n      return false;\n    }\n\n    final PsiFile file = selectedExpr.getContainingFile();\n    LOG.assertTrue(file != null, \"expr.getContainingFile() == null\");\n    final GroovyElementFactory factory = GroovyElementFactory.getInstance(project);\n\n\n    PsiType type = selectedExpr.getType();\n    if (type != null) type = TypeConversionUtil.erasure(type);\n\n    if (type == PsiType.VOID) {\n      String message = RefactoringBundle.getCannotRefactorMessage(GroovyRefactoringBundle.message(\"selected.expression.has.void.type\"));\n      showErrorMessage(message, project);\n      return false;\n    }\n\n    // Get container element\n    final PsiElement eclosingContainer = GroovyRefactoringUtil.getEnclosingContainer(selectedExpr);\n    // TODO implement loop and fork statements as containers\n    if (eclosingContainer == null || !(eclosingContainer instanceof GroovyPsiElement)) {\n      return tempContainerNotFound(project);\n    }\n    final GroovyPsiElement tempContainer = ((GroovyPsiElement) eclosingContainer);\n    if (!isAppropriateContainer(tempContainer)) {\n      String message = RefactoringBundle.getCannotRefactorMessage(GroovyRefactoringBundle.message(\"refactoring.is.not.supported.in.the.current.context\", REFACTORING_NAME));\n      showErrorMessage(message, project);\n      return false;\n    }\n    if (!CommonRefactoringUtil.checkReadOnlyStatus(project, file)) return false;\n\n    // Find occurences\n    final PsiElement[] occurences = GroovyRefactoringUtil.getExpressionOccurences(GroovyRefactoringUtil.getUnparenthesizedExpr(selectedExpr), tempContainer);\n    // Getting settings\n    GroovyIntroduceVariableSettings settings = getSettings(project, editor, selectedExpr, type, occurences, false, null);\n\n    if (!settings.isOK()) {\n      return false;\n    }\n\n    final String varName = settings.getEnteredName();\n    PsiType varType = settings.getSelectedType();\n    final boolean isFinal = settings.isDeclareFinal();\n    final boolean replaceAllOccurences = settings.isReplaceAllOccurrences();\n\n    // Generating varibable declaration\n    final GrVariableDeclaration varDecl = factory.createVariableDeclaration(varName,\n        GroovyRefactoringUtil.getUnparenthesizedExpr(selectedExpr), varType, isFinal);\n\n    final Runnable runnable = new Runnable() {\n      public void run() {\n        try {\n          /* insert new variable */\n          sortOccurences(occurences);\n          if (occurences.length == 0 || !(occurences[0] instanceof GrExpression)) {\n            throw new IncorrectOperationException(\"Wrong expression occurence\");\n          }\n          GrExpression firstOccurence;\n          if (replaceAllOccurences) {\n            firstOccurence = ((GrExpression) occurences[0]);\n          } else {\n            firstOccurence = selectedExpr;\n          }\n          // Replace at the place of first occurence\n          boolean alreadyDefined = replaceAloneExpression(firstOccurence, tempContainer, varDecl);\n          if (!alreadyDefined) {\n            // Insert before first occurence\n            insertVariableDefinition(tempContainer, selectedExpr, occurences, replaceAllOccurences, varDecl, factory);\n          }\n\n          //Replace other occurences\n          GrReferenceExpression refExpr = factory.createReferenceExpressionFromText(varName);\n          if (replaceAllOccurences) {\n            ArrayList<PsiElement> replaced = new ArrayList<PsiElement>();\n            for (PsiElement occurence : occurences) {\n              if (!(alreadyDefined && firstOccurence.equals(occurence))) {\n                if (occurence instanceof GrExpression) {\n                  GrExpression element = (GrExpression) occurence;\n                  // todo replace different case of replaceWithExpresssion method\n                  replaced.add(element.replaceWithExpresssion(refExpr));\n                  refExpr = factory.createReferenceExpressionFromText(varName);\n                } else {\n                  throw new IncorrectOperationException(\"Expression occurence to be replaced is not instance of GroovyPsiElement\");\n                }\n              }\n            }\n            if (editor != null) {\n              final PsiElement[] replacedOccurences = replaced.toArray(new PsiElement[replaced.size()]);\n              highlightReplacedOccurences(project, editor, replacedOccurences);\n            }\n          } else {\n            if (!alreadyDefined) {\n              selectedExpr.replaceWithExpresssion(refExpr);\n            }\n          }\n        } catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n    };\n\n    CommandProcessor.getInstance().executeCommand(\n        project,\n        new Runnable() {\n          public void run() {\n            ApplicationManager.getApplication().runWriteAction(runnable);\n          }\n        }, REFACTORING_NAME, null);\n    return true;\n\n  }","commit_id":"277156b9aeb466527592ef4267abcb2ea550e176","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Session information for the web application at the specified context path.\n     * Displays a profile of session lastAccessedTime listing number\n     * of sessions for each 10 minute interval up to 10 hours.\n     *\n     * @param writer Writer to render to\n     * @param path Context path of the application to list session information for\n     * @param idle Expire all sessions with idle time &ge; idle for this context\n     */\n    protected void sessions(PrintWriter writer, String path, int idle) {\n\n        if (debug >= 1) {\n            log(\"sessions: Session information for web application at '\" + path + \"'\");\n            if (idle >= 0)\n                log(\"sessions: Session expiration for \" + idle + \" minutes '\" + path + \"'\");\n        }\n\n        if ((path == null) || (!path.startsWith(\"/\") && path.equals(\"\"))) {\n            writer.println(sm.getString(\"managerServlet.invalidPath\",\n                                        RequestUtil.filter(path)));\n            return;\n        }\n        String displayPath = path;\n        if( path.equals(\"/\") )\n            path = \"\";\n        try {\n            Context context = (Context) host.findChild(path);\n            if (context == null) {\n                writer.println(sm.getString(\"managerServlet.noContext\",\n                                            RequestUtil.filter(displayPath)));\n                return;\n            }\n            int maxCount = 60;\n            int maxInactiveInterval = context.getManager().getMaxInactiveInterval()/60;\n            int histoInterval = maxInactiveInterval / maxCount;\n            if ( histoInterval * maxCount < maxInactiveInterval ) \n                histoInterval++;\n            maxCount = maxInactiveInterval / histoInterval;\n            if ( histoInterval * maxCount < maxInactiveInterval ) \n                maxCount++;\n\n            writer.println(sm.getString(\"managerServlet.sessions\", displayPath));\n            writer.println(sm.getString(\"managerServlet.sessiondefaultmax\",\n                                \"\" + maxInactiveInterval));\n            Session [] sessions = context.getManager().findSessions();\n            int [] timeout = new int[maxCount];\n            int notimeout = 0;\n            int expired = 0;\n            long now = System.currentTimeMillis();\n            for (int i = 0; i < sessions.length; i++) {\n                int time = (int)((now-sessions[i].getLastAccessedTime())/1000);\n                if (idle >= 0 && time >= idle*60) {\n                    sessions[i].expire();\n                    idle++;\n                }\n                time=time/60/histoInterval;\n                if (time < 0)\n                    notimeout++;\n                else if (time >= maxCount)\n                    timeout[maxCount-1]++;\n                else\n                    timeout[time]++;\n            }\n            if (timeout[0] > 0)\n                writer.println(sm.getString(\"managerServlet.sessiontimeout\",\n                                            \"<\" + histoInterval, \"\" + timeout[0]));\n            for (int i = 1; i < maxCount-1; i++) {\n                if (timeout[i] > 0)\n                    writer.println(sm.getString(\"managerServlet.sessiontimeout\",\n                                     \"\" + (i)*histoInterval + \" - <\" + (i+1)*histoInterval,\n                                                \"\" + timeout[i]));\n            }\n            if (timeout[maxCount-1] > 0)\n                writer.println(sm.getString(\"managerServlet.sessiontimeout\",\n                                            \">=\" + maxCount*histoInterval,\n                                            \"\" + timeout[maxCount-1]));\n            if (notimeout > 0)\n                writer.println(sm.getString(\"managerServlet.sessiontimeout\",\n                                            \"unlimited\",\"\" + notimeout));\n            if (idle >= 0)\n                writer.println(sm.getString(\"managerServlet.sessiontimeout\",\n                                            \"\" + idle,\"expired \" + expired));\n        } catch (Throwable t) {\n            log(\"ManagerServlet.sessions[\" + displayPath + \"]\", t);\n            writer.println(sm.getString(\"managerServlet.exception\",\n                                        t.toString()));\n        }\n\n    }","id":99201,"modified_method":"/**\n     * Session information for the web application at the specified context path.\n     * Displays a profile of session lastAccessedTime listing number\n     * of sessions for each 10 minute interval up to 10 hours.\n     *\n     * @param writer Writer to render to\n     * @param path Context path of the application to list session information for\n     * @param idle Expire all sessions with idle time &ge; idle for this context\n     */\n    protected void sessions(PrintWriter writer, String path, int idle) {\n\n        if (debug >= 1) {\n            log(\"sessions: Session information for web application at '\" + path + \"'\");\n            if (idle >= 0)\n                log(\"sessions: Session expiration for \" + idle + \" minutes '\" + path + \"'\");\n        }\n\n        if ((path == null) || (!path.startsWith(\"/\") && path.equals(\"\"))) {\n            writer.println(sm.getString(\"managerServlet.invalidPath\",\n                                        RequestUtil.filter(path)));\n            return;\n        }\n        String displayPath = path;\n        if( path.equals(\"/\") )\n            path = \"\";\n        try {\n            Context context = (Context) host.findChild(path);\n            if (context == null) {\n                writer.println(sm.getString(\"managerServlet.noContext\",\n                                            RequestUtil.filter(displayPath)));\n                return;\n            }\n            Manager manager = context.getManager() ;\n            if(manager == null) {\n                writer.println(sm.getString(\"managerServlet.noManager\",\n                        RequestUtil.filter(displayPath)));\n                return;               \n            }\n            int maxCount = 60;\n            int maxInactiveInterval = manager.getMaxInactiveInterval()/60;\n            int histoInterval = maxInactiveInterval / maxCount;\n            if ( histoInterval * maxCount < maxInactiveInterval ) \n                histoInterval++;\n            maxCount = maxInactiveInterval / histoInterval;\n            if ( histoInterval * maxCount < maxInactiveInterval ) \n                maxCount++;\n\n            writer.println(sm.getString(\"managerServlet.sessions\", displayPath));\n            writer.println(sm.getString(\"managerServlet.sessiondefaultmax\",\n                                \"\" + maxInactiveInterval));\n            Session [] sessions = manager.findSessions();\n            int [] timeout = new int[maxCount];\n            int notimeout = 0;\n            int expired = 0;\n            long now = System.currentTimeMillis();\n            for (int i = 0; i < sessions.length; i++) {\n                int time = (int)((now-sessions[i].getLastAccessedTimeInternal())/1000);\n                if (idle >= 0 && time >= idle*60) {\n                    sessions[i].expire();\n                    idle++;\n                }\n                time=time/60/histoInterval;\n                if (time < 0)\n                    notimeout++;\n                else if (time >= maxCount)\n                    timeout[maxCount-1]++;\n                else\n                    timeout[time]++;\n            }\n            if (timeout[0] > 0)\n                writer.println(sm.getString(\"managerServlet.sessiontimeout\",\n                                            \"<\" + histoInterval, \"\" + timeout[0]));\n            for (int i = 1; i < maxCount-1; i++) {\n                if (timeout[i] > 0)\n                    writer.println(sm.getString(\"managerServlet.sessiontimeout\",\n                                     \"\" + (i)*histoInterval + \" - <\" + (i+1)*histoInterval,\n                                                \"\" + timeout[i]));\n            }\n            if (timeout[maxCount-1] > 0)\n                writer.println(sm.getString(\"managerServlet.sessiontimeout\",\n                                            \">=\" + maxCount*histoInterval,\n                                            \"\" + timeout[maxCount-1]));\n            if (notimeout > 0)\n                writer.println(sm.getString(\"managerServlet.sessiontimeout\",\n                                            \"unlimited\",\"\" + notimeout));\n            if (idle >= 0)\n                writer.println(sm.getString(\"managerServlet.sessiontimeout\",\n                                            \"\" + idle,\"expired \" + expired));\n        } catch (Throwable t) {\n            log(\"ManagerServlet.sessions[\" + displayPath + \"]\", t);\n            writer.println(sm.getString(\"managerServlet.exception\",\n                                        t.toString()));\n        }\n\n    }","commit_id":"eec712641069e3b84d47b74ec60da12dad59688a","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Should the given session attribute be excluded? This implementation\n     * checks:\n     * <ul>\n     * <li>{@link Constants#excludedAttributeNames}<\/li>\n     * <li>{@link Manager#willAttributeDistribute(String, Object)}<\/li>\n     * <\/ul>\n     * Note: This method deliberately does not check\n     *       {@link #isAttributeDistributable(String, Object)} which is kept\n     *       separate to support the checks required in\n     *       {@link #setAttribute(String, Object, boolean)}\n     *\n     * @param name  The attribute name\n     * @param value The attribute value\n     *\n     * @return {@code true} if the attribute should be excluded from\n     *         distribution, otherwise {@code false}\n     */\n    protected boolean exclude(String name, Object value) {\n        if (Constants.excludedAttributeNames.contains(name)) {\n            return true;\n        }\n        // Last check so use a short-cut\n        return !getManager().willAttributeDistribute(name, value);\n    }","id":99202,"modified_method":"/**\n     * Should the given session attribute be excluded? This implementation\n     * checks:\n     * <ul>\n     * <li>{@link Constants#excludedAttributeNames}<\/li>\n     * <li>{@link Manager#willAttributeDistribute(String, Object)}<\/li>\n     * <\/ul>\n     * Note: This method deliberately does not check\n     *       {@link #isAttributeDistributable(String, Object)} which is kept\n     *       separate to support the checks required in\n     *       {@link #setAttribute(String, Object, boolean)}\n     *\n     * @param name  The attribute name\n     * @param value The attribute value\n     *\n     * @return {@code true} if the attribute should be excluded from\n     *         distribution, otherwise {@code false}\n     */\n    protected boolean exclude(String name, Object value) {\n        if (Constants.excludedAttributeNames.contains(name)) {\n            return true;\n        }\n\n        // Manager is required for remaining check\n        Manager manager = getManager();\n        if (manager == null) {\n            // Manager may be null during replication of new sessions in a\n            // cluster. Avoid the NPE.\n            return false;\n        }\n\n        // Last check so use a short-cut\n        return !manager.willAttributeDistribute(name, value);\n    }","commit_id":"f9593220aa1007a038f307f157fa4b3e9f35d117","url":"https://github.com/apache/tomcat"},{"original_method":"@Test\n\tpublic void testDoNotReturnSomeVisitedResources() {\n\t\tPortlet portlet = createPortletWithContextPathAndResources(\n\t\t\t\"/pluginContextPath\", \"/css/main.css\", \"/css/main1.css\");\n\n\t\tComboServletStaticURLGenerator comboServletStaticURLGenerator =\n\t\t\tnew ComboServletStaticURLGenerator();\n\n\t\tcomboServletStaticURLGenerator.setPortletResourceAccessors(\n\t\t\tPortletResourceAccessor.headerPortalCss);\n\t\tcomboServletStaticURLGenerator.setVisitedURLs(new HashSet<String>()\n\t\t\t{{add(\"/css/main.css\");}}\n\t\t);\n\t\tcomboServletStaticURLGenerator.setURLPrefix(URL_PREFIX);\n\n\t\tCollection<String> urls = comboServletStaticURLGenerator.generate(\n\t\t\tportlets(portlet));\n\n\t\tassertURLs(urls, URL_PREFIX + \"&/css/main1.css&t=0\");\n\t}","id":99203,"modified_method":"@Test\n\tpublic void testDoNotReturnSomeVisitedResources() {\n\t\tPortlet portlet = createPortletWithContextPathAndResources(\n\t\t\t\"/pluginContextPath\", \"/css/main.css\", \"/css/main1.css\");\n\n\t\tComboServletStaticURLGenerator comboServletStaticURLGenerator =\n\t\t\tnew ComboServletStaticURLGenerator();\n\n\t\tcomboServletStaticURLGenerator.setPortletResourceAccessors(\n\t\t\tPortletResourceAccessor.headerPortalCss);\n\t\tcomboServletStaticURLGenerator.setVisitedURLs(\n\t\t\tSetUtil.fromArray(new String[] {\"/css/main.css\"}));\n\n\t\tcomboServletStaticURLGenerator.setURLPrefix(URL_PREFIX);\n\n\t\tCollection<String> urls = comboServletStaticURLGenerator.generate(\n\t\t\tportlets(portlet));\n\n\t\tassertURLs(urls, URL_PREFIX + \"&/css/main1.css&t=0\");\n\t}","commit_id":"8e687b84fa4b33b24542a6402a0ea0ba60bc7e49","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testDoNotReturnVisitedResources() {\n\t\tfinal Portlet portlet = createPortletWithContextPathAndResources(\n\t\t\t\"/pluginContextPath\", \"/css/main.css\");\n\n\t\tComboServletStaticURLGenerator comboServletStaticURLGenerator =\n\t\t\tnew ComboServletStaticURLGenerator();\n\n\t\tcomboServletStaticURLGenerator.setPortletResourceAccessors(\n\t\t\tPortletResourceAccessor.headerPortalCss);\n\t\tcomboServletStaticURLGenerator.setVisitedURLs(new HashSet<String>() { {\n\t\t\tadd(\"/css/main.css\");\n\t\t}}\n\t\t);\n\t\tcomboServletStaticURLGenerator.setURLPrefix(URL_PREFIX);\n\n\t\tCollection<String> urls = comboServletStaticURLGenerator.generate(\n\t\t\tportlets(portlet));\n\n\t\tAssert.assertEquals(urls, new ArrayList<String>());\n\t}","id":99204,"modified_method":"@Test\n\tpublic void testDoNotReturnVisitedResources() {\n\t\tfinal Portlet portlet = createPortletWithContextPathAndResources(\n\t\t\t\"/pluginContextPath\", \"/css/main.css\");\n\n\t\tComboServletStaticURLGenerator comboServletStaticURLGenerator =\n\t\t\tnew ComboServletStaticURLGenerator();\n\n\t\tcomboServletStaticURLGenerator.setPortletResourceAccessors(\n\t\t\tPortletResourceAccessor.headerPortalCss);\n\t\tcomboServletStaticURLGenerator.setVisitedURLs(\n\t\t\tSetUtil.fromArray(new String[] {\"/css/main.css\"}));\n\t\tcomboServletStaticURLGenerator.setURLPrefix(URL_PREFIX);\n\n\t\tCollection<String> urls = comboServletStaticURLGenerator.generate(\n\t\t\tportlets(portlet));\n\n\t\tAssert.assertEquals(urls, new ArrayList<String>());\n\t}","commit_id":"8e687b84fa4b33b24542a6402a0ea0ba60bc7e49","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testDoNotReturnVisitedExternalResources() {\n\t\tfinal Portlet portlet = createPortletWithContextPathAndResources(\n\t\t\t\"/pluginContextPath\", \"/css/main.css\", \"/css/main1.css\",\n\t\t\t\"http://www.terminus.com/main.css\",\n\t\t\t\"http://www.terminus.com/main2.css\");\n\n\t\tComboServletStaticURLGenerator comboServletStaticURLGenerator =\n\t\t\tnew ComboServletStaticURLGenerator();\n\n\t\tcomboServletStaticURLGenerator.setPortletResourceAccessors(\n\t\t\tPortletResourceAccessor.headerPortalCss);\n\n\t\tcomboServletStaticURLGenerator.setVisitedURLs(new HashSet<String>() { {\n\t\t\tadd(\"http://www.terminus.com/main.css\");\n\t\t\tadd(\"/css/main.css\");\n\t\t}}\n\t\t);\n\t\tcomboServletStaticURLGenerator.setURLPrefix(URL_PREFIX);\n\n\t\tCollection<String> urls = comboServletStaticURLGenerator.generate(\n\t\t\tportlets(portlet));\n\n\t\tassertURLs(\n\t\t\turls, \"http://www.terminus.com/main2.css\",\n\t\t\tURL_PREFIX + \"&/css/main1.css&t=0\");\n\t}","id":99205,"modified_method":"@Test\n\tpublic void testDoNotReturnVisitedExternalResources() {\n\t\tfinal Portlet portlet = createPortletWithContextPathAndResources(\n\t\t\t\"/pluginContextPath\", \"/css/main.css\", \"/css/main1.css\",\n\t\t\t\"http://www.terminus.com/main.css\",\n\t\t\t\"http://www.terminus.com/main2.css\");\n\n\t\tComboServletStaticURLGenerator comboServletStaticURLGenerator =\n\t\t\tnew ComboServletStaticURLGenerator();\n\n\t\tcomboServletStaticURLGenerator.setPortletResourceAccessors(\n\t\t\tPortletResourceAccessor.headerPortalCss);\n\t\tcomboServletStaticURLGenerator.setVisitedURLs(\n\t\t\tSetUtil.fromArray(\n\t\t\t\tnew String[] {\n\t\t\t\t\t\"http://www.terminus.com/main.css\", \"/css/main.css\"\n\t\t\t\t}));\n\t\tcomboServletStaticURLGenerator.setURLPrefix(URL_PREFIX);\n\n\t\tCollection<String> urls = comboServletStaticURLGenerator.generate(\n\t\t\tportlets(portlet));\n\n\t\tassertURLs(\n\t\t\turls, \"http://www.terminus.com/main2.css\",\n\t\t\tURL_PREFIX + \"&/css/main1.css&t=0\");\n\t}","commit_id":"8e687b84fa4b33b24542a6402a0ea0ba60bc7e49","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void run() throws IOException {\n    System.out.println(\"Rules in LanguageTool \" + JLanguageTool.VERSION + \"<br />\");\n    System.out.println(\"Date: \" + new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date()) + \"<br /><br />\\n\");\n    for (int i = 0; i < Language.LANGUAGES.length; i++) {\n      if (Language.LANGUAGES[i] != Language.DEMO) {\n        Language lang = Language.LANGUAGES[i];\n        System.out.print(lang.getName() + \": \");\n        String xmlFile = \"rules\" + File.separator + lang.getShortName() + File.separator + \"grammar.xml\";\n        File f = new File(xmlFile);\n        if (!f.exists()) {\n          System.out.println(\"  0 XML rules<br />\");\n        } else {\n          // count XML rules:\n          String xmlRules = StringTools.readFile(xmlFile);\n          xmlRules = xmlRules.replaceAll(\"(?s)<!--.*?-->\", \"\");\n          xmlRules = xmlRules.replaceAll(\"(?s)<rules.*?>\", \"\");\n          int pos = 0;\n          int count = 0;\n          while (pos != -1) {\n            pos = xmlRules.indexOf(\"<rule\", pos+1);\n            if (pos == -1)\n              break;\n            count++;\n          }\n          if (count == 1)\n            System.out.print(\" \" + count + \" XML rule, \");\n          else\n            System.out.print(\" \" + count + \" XML rules, \");\n        }\n        // count Java rules:\n        File dir = new File(\"src/java/de/danielnaber/languagetool/rules/\" + lang.getShortName());\n        if (!dir.exists()) {\n          System.out.print(\" 0 Java rules\");\n        } else {\n          File[] javaRules = dir.listFiles(new JavaFilter());\n          int javaCount = javaRules.length-1;   // minus 1: one is always \"<Language>Rule.java\"\n          if (javaCount == 1)\n            System.out.print(\"  \" + javaCount + \" Java rule\");\n          else\n            System.out.print(\" \" + javaCount + \" Java rules\");    \n        }\n        System.out.println(\"<br />\");    \n      }\n    }\n  }","id":99206,"modified_method":"private void run() throws IOException {\n    System.out.println(\"<b>Rules in LanguageTool \" + JLanguageTool.VERSION + \"<\/b><br />\");\n    System.out.println(\"Date: \" + new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date()) + \"<br /><br />\\n\");\n    System.out.println(\"<table>\");\n    System.out.println(\"<tr>\");\n    System.out.println(\"  <th><\/th>\");\n    System.out.println(\"  <th align=\\\"right\\\">XML rules<\/th>\");\n    System.out.println(\"  <th>&nbsp;&nbsp;<\/th>\");\n    System.out.println(\"  <th align=\\\"right\\\">Java rules<\/th>\");\n    System.out.println(\"<\/tr>\");\n    for (int i = 0; i < Language.LANGUAGES.length; i++) {\n      if (Language.LANGUAGES[i] == Language.DEMO) {\n        continue;\n      }\n      Language lang = Language.LANGUAGES[i];\n      System.out.print(\"<tr>\");\n      System.out.print(\"<td>\" + lang.getName() + \"<\/td>\");\n      String xmlFile = \"rules\" + File.separator + lang.getShortName() + File.separator + \"grammar.xml\";\n      File f = new File(xmlFile);\n      if (!f.exists()) {\n        System.out.println(\"<td align=\\\"right\\\">0<\/td>\");\n      } else {\n        // count XML rules:\n        String xmlRules = StringTools.readFile(xmlFile);\n        xmlRules = xmlRules.replaceAll(\"(?s)<!--.*?-->\", \"\");\n        xmlRules = xmlRules.replaceAll(\"(?s)<rules.*?>\", \"\");\n        int pos = 0;\n        int count = 0;\n        while (pos != -1) {\n          pos = xmlRules.indexOf(\"<rule\", pos+1);\n          if (pos == -1)\n            break;\n          count++;\n        }\n        System.out.print(\"<td align=\\\"right\\\">\" + count + \"<\/td>\");\n      }\n      System.out.print(\"<td><\/td>\");\n      // count Java rules:\n      File dir = new File(\"src/java/de/danielnaber/languagetool/rules/\" + lang.getShortName());\n      if (!dir.exists()) {\n        System.out.print(\"<td align=\\\"right\\\">0<\/td>\");\n      } else {\n        File[] javaRules = dir.listFiles(new JavaFilter());\n        int javaCount = javaRules.length-1;   // minus 1: one is always \"<Language>Rule.java\"\n        System.out.print(\"<td align=\\\"right\\\">\" + javaCount + \"<\/td>\");\n      }\n      System.out.println(\"<\/tr>\");    \n    }\n    System.out.println(\"<\/table>\");    \n  }","commit_id":"3f0d9abab68c7fd0829a750dd5428ee86c9d166c","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private int keycmp(byte x[][], long xi, byte y[][], long yi) {   // TO DO - faster way closer to CPU like batches of long compare, maybe.\n    //long t0 = System.nanoTime();\n    //_timings[12] += 1;\n    byte xbatch[] = x[(int)(xi / _leftBatchSize)];\n    byte ybatch[] = y[(int)(yi / _rightBatchSize)];\n    int xoff = (int)(xi % _leftBatchSize) * _leftKeySize;\n    int yoff = (int)(yi % _rightBatchSize) * _rightKeySize;\n    byte xByte=0, yByte=0;\n    // TODO: switch to use keycmp_sameShape() for common case of all(leftFieldSizes == rightFieldSizes), although, skipping to current column will\n    //        help save repeating redundant work and saving the outer for() loop and one if() may not be worth it.\n    int i=0;\n    while (i<_numJoinCols && xByte==yByte) {    // TO DO: pass i in to start at a later key column, when known\n      int xlen = _leftFieldSizes[i];\n      int ylen = _rightFieldSizes[i];\n      if (xlen!=ylen) {\n        while (xlen>ylen && xbatch[xoff]==0) { xoff++; xlen--; }\n        while (ylen>xlen && ybatch[yoff]==0) { yoff++; ylen--; }\n        if (xlen!=ylen) {\n          //_timings[13] += (System.nanoTime() - t0)/1e9;\n          return (xlen - ylen);\n        }\n      }\n      while (xlen>0 && (xByte=xbatch[xoff])==(yByte=ybatch[yoff])) { xoff++; yoff++; xlen--; }\n      i++;\n    }\n    //_timings[13] += (System.nanoTime() - t0)/1e9;\n    return (xByte & 0xFF) - (yByte & 0xFF);\n    // Same return value as strcmp in C. <0 => xi<yi\n  }","id":99207,"modified_method":"private int keycmp(byte x[][], long xi, byte y[][], long yi) {\n    // Must be passed a left key and a right key to avoid call overhead of extra arguments.\n    // Only need left to left for equality only and that's optimized in leftKeyEqual below.\n    //long t0 = System.nanoTime();\n    //_timings[12] += 1;\n    byte xbatch[] = x[(int)(xi / _leftBatchSize)];\n    byte ybatch[] = y[(int)(yi / _rightBatchSize)];\n    int xoff = (int)(xi % _leftBatchSize) * _leftKeySize;\n    int yoff = (int)(yi % _rightBatchSize) * _rightKeySize;\n    long xval=0, yval=0;\n\n    // We don't avoid unsafe here because it's unsafe but because we want finer grain compression than 1,2,4 or 8 bytes types. In particular,\n    // a range just greater than 4bn can use 5 bytes rather than 8 bytes; a 38% RAM saving over the wire in that possibly common case.\n    // Note this is tight and almost branch free.\n    int i=0;\n    while (i<_numJoinCols && xval==yval) {    // TO DO: pass i in to start at a later key column, when known\n      int xlen = _leftFieldSizes[i];\n      int ylen = _rightFieldSizes[i];\n      xval = xbatch[xoff] & 0xFF; while (xlen>1) { xval <<= 8; xval |= xbatch[++xoff] & 0xFF; xlen--; } xoff++;\n      yval = ybatch[yoff] & 0xFF; while (ylen>1) { yval <<= 8; yval |= ybatch[++yoff] & 0xFF; ylen--; } yoff++;\n      xval = xval==0 ? Long.MIN_VALUE : xval-1+_leftColMins[i];\n      yval = yval==0 ? Long.MIN_VALUE : yval-1+_rightColMins[i];\n      i++;\n    }\n    long diff = xval-yval;  // could overflow even in long; e.g. joining to a prevailing NA, or very large gaps O(2^62)\n    if (xval>yval) {        // careful not diff>0 here due to overflow\n      return( (diff<0 | diff>Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int)diff );\n    } else {\n      return( (diff>0 | diff<Integer.MIN_VALUE+1) ? Integer.MIN_VALUE+1 : (int)diff);\n    }\n    // Same return value as strcmp in C. <0 => xi<yi.\n    // The magnitude of the difference is used for limiting staleness in a rolling join, capped at Integer.MAX|(MIN+1). roll's type is chosen to be int so staleness can't be requested over int's limit.\n  }","commit_id":"6e424ff44dfb8b23324a1e16f79766da8d6b398d","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private void bmerge_r(long lLowIn, long lUppIn, long rLowIn, long rUppIn) {\n    // TO DO: parallel each of the 256 bins\n    long lLow = lLowIn, lUpp = lUppIn, rLow = rLowIn, rUpp = rUppIn;\n    long mid, tmpLow, tmpUpp;\n    long lr = lLow + (lUpp - lLow) / 2;   // i.e. (lLow+lUpp)/2 but being robust to one day in the future someone somewhere overflowing long; e.g. 32 exabytes of 1-column ints\n    while (rLow < rUpp - 1) {\n      mid = rLow + (rUpp - rLow) / 2;\n      int cmp = keycmp(_leftKey, lr, _rightKey, mid);  // -1, 0 or 1, like strcmp\n      if (cmp < 0) {\n        rUpp = mid;\n      } else if (cmp > 0) {\n        rLow = mid;\n      } else { // rKey == lKey including NA == NA\n        // branch mid to find start and end of this group in this column\n        // TO DO?: not if mult=first|last and col<ncol-1\n        tmpLow = mid;\n        tmpUpp = mid;\n        while (tmpLow < rUpp - 1) {\n          mid = tmpLow + (rUpp - tmpLow) / 2;\n          if (keycmp(_leftKey, lr, _rightKey, mid) == 0) tmpLow = mid;\n          else rUpp = mid;\n        }\n        while (rLow < tmpUpp - 1) {\n          mid = rLow + (tmpUpp - rLow) / 2;\n          if (keycmp(_leftKey, lr, _rightKey, mid) == 0) tmpUpp = mid;\n          else rLow = mid;\n        }\n        break;\n      }\n    }\n    // rLow and rUpp now surround the group in the right table.\n\n    // The left table key may (unusually, and not recommended, but sometimes needed) be duplicated.\n    // Linear search outwards from left row. Most commonly, the first test shows this left key is unique.\n    // This saves i) re-finding the matching rows in the right for all the dup'd left and ii) recursive bounds logic gets awkward if other left rows can find the same right rows\n    // Related to 'allow.cartesian' in data.table.\n    // TO DO:  if index stores attribute that it is unique then we don't need this step. However, each of these while()s would run at most once in that case, which may not be worth optimizing.\n    tmpLow = lr + 1;\n    while (tmpLow<lUpp && keycmp(_leftKey, tmpLow, _leftKey, lr)==0) tmpLow++;\n    lUpp = tmpLow;\n    tmpUpp = lr - 1;\n    while (tmpUpp>lLow && keycmp(_leftKey, tmpUpp, _leftKey, lr)==0) tmpUpp--;\n    lLow = tmpUpp;\n    // lLow and lUpp now surround the group in the left table.  If left key is unique then lLow==lr-1 and lUpp==lr+1.\n    assert lUpp - lLow >= 2;\n\n    long len = rUpp - rLow - 1;  // if value found, rLow and rUpp surround it, unlike standard binary search where rLow falls on it\n    // TO DO - we don't need loop here :)  Why does perNodeNumRightRowsToFetch increase so much?\n    if (len > 0 || _allLeft) {\n      long t0 = System.nanoTime();\n      if (len > 1) _oneToManyMatch = true;\n      _numRowsInResult += Math.max(1,len) * (lUpp-lLow-1);   // 1 for NA row when _allLeft\n      for (long j = lLow + 1; j < lUpp; j++) {   // usually iterates once only for j=lr, but more than once if there are dup keys in left table\n        // may be a range of left dup'd join-col values, but we need to fetch each one since the left non-join columns are likely not dup'd and may be the reason for the cartesian join\n        long t00 = System.nanoTime();\n        int jb = (int)(j/_leftBatchSize);   // TODO could loop through batches rather than / and % wastefully\n        int jo = (int)(j%_leftBatchSize);\n        long globalRowNumber = _leftOrder[jb][jo];\n        _timings[17] += (System.nanoTime() - t00)/1e9;\n        t00 = System.nanoTime();\n        int chkIdx = _leftVec.elem2ChunkIdx(globalRowNumber); //binary search in espc\n        _timings[15] += (System.nanoTime() - t00)/1e9;\n        _perNodeNumLeftRowsToFetch[_leftChunkNode[chkIdx]]++;  // the key is the same within this left dup range, but still need to fetch left non-join columns\n        if (len==0) continue;  // _allLeft must be true if len==0\n        _retFirst[jb][jo] = rLow + 2;  // rLow surrounds row, so +1.  Then another +1 for 1-based row-number. 0 (default) means nomatch and saves extra set to -1 for no match.  Could be significant in large edge cases by not needing to write at all to _retFirst if it has no matches.\n        _retLen[jb][jo] = len;\n        //StringBuilder sb = new StringBuilder();\n        //sb.append(\"Left row \" + _leftOrder[jb][jo] + \" matches to \" + _retLen[jb][jo] + \" right rows: \");\n      }\n      // if we have dup'd left row, we only need to fetch the right rows once for the first dup.  Those should then be recycled locally later.\n      for (long i=0; i<len; i++) {\n        long loc = rLow+1+i;\n        //sb.append(_rightOrder[(int)(loc / _rightBatchSize)][(int)(loc % _rightBatchSize)] + \" \");\n        long t00 = System.nanoTime();\n        long globalRowNumber = _rightOrder[(int)(loc / _rightBatchSize)][(int)(loc % _rightBatchSize)];  // TODO could loop through batches rather than / and % wastefully\n        _timings[18] += (System.nanoTime() - t00)/1e9;\n        t00 = System.nanoTime();\n        int chkIdx = _rightVec.elem2ChunkIdx(globalRowNumber); //binary search in espc\n        _timings[16] += (System.nanoTime() - t00)/1e9;\n        _perNodeNumRightRowsToFetch[_rightChunkNode[chkIdx]]++;  // just count the number per node. So we can allocate arrays precisely up front, and also to return early to use in case of memory errors or other distribution problems\n      }\n      _timings[14] += (System.nanoTime() - t0)/1e9;\n    }\n    // TO DO: check assumption that retFirst and retLength are initialized to 0, for case of no match\n    // Now branch (and TO DO in parallel) to merge below and merge above\n    if (lLow > lLowIn && (rLow > rLowIn || _allLeft)) // '|| _allLeft' is needed here in H2O (but not data.table) for the _perNodeNumLeftRowsToFetch above to populate and pass the assert near the end of the compute2() above.\n      bmerge_r(lLowIn, lLow + 1, rLowIn, rLow+1);\n    if (lUpp < lUppIn && (rUpp < rUppIn || _allLeft))\n      bmerge_r(lUpp-1, lUppIn, rUpp-1, rUppIn);\n\n    // We don't feel tempted to reduce the global _ansN here and make a global frame,\n    // since we want to process each MSB l/r combo individually without allocating them all.\n    // Since recursive, no more code should be here (it would run too much)\n  }","id":99208,"modified_method":"private void bmerge_r(long lLowIn, long lUppIn, long rLowIn, long rUppIn) {\n    // TO DO: parallel each of the 256 bins\n    long lLow = lLowIn, lUpp = lUppIn, rLow = rLowIn, rUpp = rUppIn;\n    long mid, tmpLow, tmpUpp;\n    long lr = lLow + (lUpp - lLow) / 2;   // i.e. (lLow+lUpp)/2 but being robust to one day in the future someone somewhere overflowing long; e.g. 32 exabytes of 1-column ints\n    while (rLow < rUpp - 1) {\n      mid = rLow + (rUpp - rLow) / 2;\n      int cmp = keycmp(_leftKey, lr, _rightKey, mid);  // -1, 0 or 1, like strcmp\n      if (cmp < 0) {\n        rUpp = mid;\n      } else if (cmp > 0) {\n        rLow = mid;\n      } else { // rKey == lKey including NA == NA\n        // branch mid to find start and end of this group in this column\n        // TO DO?: not if mult=first|last and col<ncol-1\n        tmpLow = mid;\n        tmpUpp = mid;\n        while (tmpLow < rUpp - 1) {\n          mid = tmpLow + (rUpp - tmpLow) / 2;\n          if (keycmp(_leftKey, lr, _rightKey, mid) == 0) tmpLow = mid;\n          else rUpp = mid;\n        }\n        while (rLow < tmpUpp - 1) {\n          mid = rLow + (tmpUpp - rLow) / 2;\n          if (keycmp(_leftKey, lr, _rightKey, mid) == 0) tmpUpp = mid;\n          else rLow = mid;\n        }\n        break;\n      }\n    }\n    // rLow and rUpp now surround the group in the right table.\n\n    // The left table key may (unusually, and not recommended, but sometimes needed) be duplicated.\n    // Linear search outwards from left row. Most commonly, the first test shows this left key is unique.\n    // This saves i) re-finding the matching rows in the right for all the dup'd left and ii) recursive bounds logic gets awkward if other left rows can find the same right rows\n    // Related to 'allow.cartesian' in data.table.\n    // TO DO:  if index stores attribute that it is unique then we don't need this step. However, each of these while()s would run at most once in that case, which may not be worth optimizing.\n    tmpLow = lr + 1;\n    while (tmpLow<lUpp && leftKeyEqual(_leftKey, tmpLow, lr)) tmpLow++;  // TODO: these while's could be rolled up inside leftKeyEqual saving call overhead\n    lUpp = tmpLow;\n    tmpUpp = lr - 1;\n    while (tmpUpp>lLow && leftKeyEqual(_leftKey, tmpUpp, lr)) tmpUpp--;\n    lLow = tmpUpp;\n    // lLow and lUpp now surround the group in the left table.  If left key is unique then lLow==lr-1 and lUpp==lr+1.\n    assert lUpp - lLow >= 2;\n\n    long len = rUpp - rLow - 1;  // if value found, rLow and rUpp surround it, unlike standard binary search where rLow falls on it\n    // TO DO - we don't need loop here :)  Why does perNodeNumRightRowsToFetch increase so much?\n    if (len > 0 || _allLeft) {\n      long t0 = System.nanoTime();\n      if (len > 1) _oneToManyMatch = true;\n      _numRowsInResult += Math.max(1,len) * (lUpp-lLow-1);   // 1 for NA row when _allLeft\n      for (long j = lLow + 1; j < lUpp; j++) {   // usually iterates once only for j=lr, but more than once if there are dup keys in left table\n        // may be a range of left dup'd join-col values, but we need to fetch each one since the left non-join columns are likely not dup'd and may be the reason for the cartesian join\n        long t00 = System.nanoTime();\n        int jb = (int)(j/_leftBatchSize);   // TODO could loop through batches rather than / and % wastefully\n        int jo = (int)(j%_leftBatchSize);\n        long globalRowNumber = _leftOrder[jb][jo];\n        _timings[17] += (System.nanoTime() - t00)/1e9;\n        t00 = System.nanoTime();\n        int chkIdx = _leftVec.elem2ChunkIdx(globalRowNumber); //binary search in espc\n        _timings[15] += (System.nanoTime() - t00)/1e9;\n        _perNodeNumLeftRowsToFetch[_leftChunkNode[chkIdx]]++;  // the key is the same within this left dup range, but still need to fetch left non-join columns\n        if (len==0) continue;  // _allLeft must be true if len==0\n        _retFirst[jb][jo] = rLow + 2;  // rLow surrounds row, so +1.  Then another +1 for 1-based row-number. 0 (default) means nomatch and saves extra set to -1 for no match.  Could be significant in large edge cases by not needing to write at all to _retFirst if it has no matches.\n        _retLen[jb][jo] = len;\n        //StringBuilder sb = new StringBuilder();\n        //sb.append(\"Left row \" + _leftOrder[jb][jo] + \" matches to \" + _retLen[jb][jo] + \" right rows: \");\n      }\n      // if we have dup'd left row, we only need to fetch the right rows once for the first dup.  Those should then be recycled locally later.\n      for (long i=0; i<len; i++) {\n        long loc = rLow+1+i;\n        //sb.append(_rightOrder[(int)(loc / _rightBatchSize)][(int)(loc % _rightBatchSize)] + \" \");\n        long t00 = System.nanoTime();\n        long globalRowNumber = _rightOrder[(int)(loc / _rightBatchSize)][(int)(loc % _rightBatchSize)];  // TODO could loop through batches rather than / and % wastefully\n        _timings[18] += (System.nanoTime() - t00)/1e9;\n        t00 = System.nanoTime();\n        int chkIdx = _rightVec.elem2ChunkIdx(globalRowNumber); //binary search in espc\n        _timings[16] += (System.nanoTime() - t00)/1e9;\n        _perNodeNumRightRowsToFetch[_rightChunkNode[chkIdx]]++;  // just count the number per node. So we can allocate arrays precisely up front, and also to return early to use in case of memory errors or other distribution problems\n      }\n      _timings[14] += (System.nanoTime() - t0)/1e9;\n    }\n    // TO DO: check assumption that retFirst and retLength are initialized to 0, for case of no match\n    // Now branch (and TO DO in parallel) to merge below and merge above\n    if (lLow > lLowIn && (rLow > rLowIn || _allLeft)) // '|| _allLeft' is needed here in H2O (but not data.table) for the _perNodeNumLeftRowsToFetch above to populate and pass the assert near the end of the compute2() above.\n      bmerge_r(lLowIn, lLow + 1, rLowIn, rLow+1);\n    if (lUpp < lUppIn && (rUpp < rUppIn || _allLeft))\n      bmerge_r(lUpp-1, lUppIn, rUpp-1, rUppIn);\n\n    // We don't feel tempted to reduce the global _ansN here and make a global frame,\n    // since we want to process each MSB l/r combo individually without allocating them all.\n    // Since recursive, no more code should be here (it would run too much)\n  }","commit_id":"6e424ff44dfb8b23324a1e16f79766da8d6b398d","url":"https://github.com/h2oai/h2o-3"},{"original_method":"BinaryMerge(Frame leftFrame, Frame rightFrame, int leftMSB, int rightMSB, int leftFieldSizes[], int rightFieldSizes[], boolean allLeft) {   // In X[Y], 'left'=i and 'right'=x\n    _leftFrame = leftFrame;\n    _rightFrame = rightFrame;\n    _leftMSB = leftMSB;\n    _rightMSB = rightMSB;\n    _leftFieldSizes = leftFieldSizes;\n    _rightFieldSizes = rightFieldSizes;\n    _allLeft = allLeft;\n    _allRight = false;  // TODO: pass through\n    // TODO: set 2 Frame and 2 int[] to NULL at the end of compute2 to save some traffic back, but should be small and insignificant\n  }","id":99209,"modified_method":"BinaryMerge(Frame leftFrame, Frame rightFrame, int leftMSB, int rightMSB, int leftFieldSizes[], int rightFieldSizes[], long leftColMins[], long rightColMins[], boolean allLeft) {   // In X[Y], 'left'=i and 'right'=x\n    _leftFrame = leftFrame;\n    _rightFrame = rightFrame;\n    _leftMSB = leftMSB;\n    _rightMSB = rightMSB;\n    _leftFieldSizes = leftFieldSizes; _rightFieldSizes = rightFieldSizes;\n    _leftColMins = leftColMins; _rightColMins = rightColMins;\n    _allLeft = allLeft;\n    _allRight = false;  // TODO: pass through\n    // TODO: set 2 Frame and 2 int[] to NULL at the end of compute2 to save some traffic back, but should be small and insignificant\n  }","commit_id":"6e424ff44dfb8b23324a1e16f79766da8d6b398d","url":"https://github.com/h2oai/h2o-3"},{"original_method":"static Frame merge(final Frame leftFrame, final Frame rightFrame, final int leftCols[], final int rightCols[], boolean allLeft, int[][] id_maps) {\n\n    // each of those launches an MRTask\n    System.out.println(\"\\nCreating left index ...\");\n    long t0 = System.nanoTime();\n    RadixOrder leftIndex;\n    H2O.H2OCountedCompleter left = H2O.submitTask(leftIndex = new RadixOrder(leftFrame, /*isLeft=*/true, leftCols, null));\n    left.join(); // Running 3 consecutive times on an idle cluster showed that running left and right in parallel was\n                 // a little slower (97s) than one by one (89s).  TODO: retest in future\n    System.out.println(\"***\\n*** Creating left index took: \" + (System.nanoTime() - t0) / 1e9 + \"\\n***\\n\");\n\n    System.out.println(\"\\nCreating right index ...\");\n    t0 = System.nanoTime();\n    RadixOrder rightIndex;\n    H2O.H2OCountedCompleter right = H2O.submitTask(rightIndex = new RadixOrder(rightFrame, /*isLeft=*/false, rightCols, id_maps));\n    right.join();\n    System.out.println(\"***\\n*** Creating right index took: \" + (System.nanoTime() - t0) / 1e9 + \"\\n***\\n\");\n\n    // TODO: start merging before all indexes had been created. Use callback?\n\n    // TODO: Thomas showed this method which takes 'true' argument to H2OCountedCompleter directly.  Not sure how that\n    // relates to new of RadixOrder which itself extends H2OCountedCompleter.  That true argument isn't available that way.\n    // H2O.submitTask(new H2O.H2OCountedCompleter(true) {   // true just to bump priority and prevent deadlock (no different to speed, in theory - Thomas) in case this Merge ever called from within another counted completer\n    // @Override\n    // protected void compute2() {\n    //   RadixOrder.compute(leftFrame, /*left=*/true, leftCols);  // when RadixOrder had just a static compute() method\n    //   tryComplete();\n    // }\n\n    // Align MSB locations between the two keys\n    // If the 1st join column has range < 256 (e.g. test cases) then <=8 bits are used and there's a floor of 8 to the shift.\n    int bitShift = Math.max(8, rightIndex._biggestBit[0]) - Math.max(8, leftIndex._biggestBit[0]);\n    int leftExtent = 256, rightExtent = 1;\n    if (bitShift < 0) {\n      // The biggest keys in left table are larger than the biggest in right table\n      // Therefore those biggest ones don't have a match and we can instantly ignore them\n      // The only msb's that can match are the smallest in left table ...\n      leftExtent >>= -bitShift;\n      // and those could join to multiple msb in the right table, one-to-many ...\n      rightExtent <<= -bitShift;\n    }\n    // else if bitShift > 0\n    //   The biggest keys in right table are larger than the largest in left table\n    //   The msb values in left table need to be reduced in magnitude and will then join to the smallest of the right key's msb values\n    //   Many left msb might join to the same (smaller) right msb\n    //   Leave leftExtent at 256 and rightExtent at 1.\n    //   The positive bitShift will reduce jbase below to common right msb's,  many-to-one\n    // else bitShift == 0\n    //   We hope most common case. Common width keys (e.g. ids, codes, enums, integers, etc) both sides over similar range\n    //   Left msb will match exactly to right msb one-to-one, without any alignment needed.\n\n    // TODO we don't need to create the full index for the MSBs that we know won't match\n\n    long ansN = 0;\n    int numChunks = 0;\n    System.out.print(\"Making BinaryMerge RPC calls ... \");\n    t0 = System.nanoTime();\n    List<RPC> bmList = new ArrayList<>();\n    for (int leftMSB =0; leftMSB <leftExtent; leftMSB++) { // each of left msb values.  TO DO: go parallel\n//      long leftLen = leftIndex._MSBhist[i];\n//      if (leftLen > 0) {\n      int rightMSBBase = leftMSB >> bitShift;  // could be positive or negative, or most commonly and ideally bitShift==0\n      for (int k=0; k<rightExtent; k++) {\n        int rightMSB = rightMSBBase +k;\n//          long rightLen = rightIndex._MSBhist[j];\n//          if (rightLen > 0) {\n        //System.out.print(i + \" left \" + lenx + \" => right \" + leny);\n        // TO DO: when go distributed, move the smaller of lenx and leny to the other one's node\n        //        if 256 are distributed across 10 nodes in order with 1-25 on node 1, 26-50 on node 2 etc, then most already will be on same node.\n//        H2ONode leftNode = MoveByFirstByte.ownerOfMSB(leftMSB);\n        H2ONode rightNode = SplitByMSBLocal.ownerOfMSB(rightMSB);  // TODO: ensure that that owner has that part of the index locally.\n        //if (leftMSB!=73 || rightMSB!=73) continue;\n        //Log.info(\"Calling BinaryMerge for \" + leftMSB + \" \" + rightMSB);\n        RPC bm = new RPC<>(rightNode,\n                new BinaryMerge(leftFrame, rightFrame,\n                        leftMSB, rightMSB,\n                        //leftNode.index(), //convention - right frame is local, but left frame is potentially remote\n                        leftIndex._bytesUsed,   // field sizes for each column in the key\n                        rightIndex._bytesUsed,\n                        allLeft\n                )\n        );\n        bmList.add(bm);\n        System.out.print(rightNode.index() + \" \"); // So we can make sure distributed across nodes.\n        //System.out.println(\"Made RPC to node \" + rightNode.index() + \" for MSB\" + leftMSB + \"/\" + rightMSB);\n      }\n    }\n    System.out.println(\"... took: \" + (System.nanoTime() - t0) / 1e9);\n\n    int queueSize = Math.max(H2O.CLOUD.size() * 20, 40);  // TODO: remove and let thread pool take care of it once GC issue alleviated\n    t0 = System.nanoTime();\n    System.out.print(\"Sending BinaryMerge async RPC calls in a queue of \" + queueSize + \" ... \");\n    // need to do our own queue it seems, otherwise floods the cluster\n\n    //int nbatch = 1+ (bmList.size()-1)/queueSize;\n    //int lastSize = bmList.size() - (nbatch-1) * queueSize;\n    //int bmCount = 0, batchStart = 0;\n    int queue[] = new int[queueSize];\n    BinaryMerge bmResults[] = new BinaryMerge[bmList.size()];\n\n    //for (int b=1; b<=nbatch; b++) {      // to save flooding the cluster and RAM usage\n    //  int thisBatchSize = b==nbatch ? lastSize : queueSize;\n    int nextItem;\n    for (nextItem=0; nextItem<queueSize; nextItem++) {\n      queue[nextItem] = nextItem;\n      bmList.get(nextItem).call();  // async\n    }\n    int leftOnQueue = queueSize;\n    int waitMS = 50;  // 0.05 second for fast runs like 1E8 on 1 node\n    while (leftOnQueue > 0) {\n      try {\n        Thread.sleep(waitMS);\n      } catch(InterruptedException ex) {\n        Thread.currentThread().interrupt();\n      }\n      // System.out.println(\"Sweeping queue ...\");\n      int doneInSweep = 0;\n      for (int q=0; q<queueSize; q++) {\n        int thisBM = queue[q];\n        if (thisBM >= 0 && bmList.get(thisBM).isDone()) {\n          BinaryMerge thisbm;\n          bmResults[thisBM] = thisbm = (BinaryMerge)bmList.get(thisBM).get();\n          leftOnQueue--;\n          doneInSweep++;\n          if (thisbm._numRowsInResult > 0) {\n            System.out.print(String.format(\"%3d\",queue[q]) + \":\");\n            for (int t=0; t<20; t++) System.out.print(String.format(\"%.2f \", thisbm._timings[t]));\n            System.out.println();\n            numChunks += thisbm._chunkSizes.length;\n            ansN += thisbm._numRowsInResult;\n          }\n          queue[q] = -1;  // clear the slot\n          if (nextItem < bmList.size()) {\n            bmList.get(nextItem).call();   // call next one\n            queue[q] = nextItem++;         // put on queue so we can sweep\n            leftOnQueue++;\n          }\n        }\n      }\n      if (doneInSweep == 0) waitMS = Math.min(1000, waitMS*2);  // if last sweep caught none, then double wait time to avoid cost of sweeping\n    }\n    System.out.println(\"took: \" + (System.nanoTime() - t0) / 1e9);\n\n\n    System.out.print(\"Removing DKV keys of left and right index.  ... \");\n    // TODO: In future we won't delete but rather persist them as index on the table\n    // Explicitly deleting here (rather than Arno's cleanUp) to reveal if we're not removing keys early enough elsewhere\n    t0 = System.nanoTime();\n    for (int msb=0; msb<256; msb++) {\n      for (int isLeft=0; isLeft<2; isLeft++) {\n        Key k = getSortedOXHeaderKey(isLeft==0 ? false : true, msb);\n        SingleThreadRadixOrder.OXHeader oxheader = DKV.getGet(k);\n        DKV.remove(k);\n        if (oxheader != null) {\n          for (int b=0; b<oxheader._nBatch; ++b) {\n            k = SplitByMSBLocal.getSortedOXbatchKey(isLeft==0 ? false : true, msb, b);\n            DKV.remove(k);\n          }\n        }\n      }\n    }\n    System.out.println(\"took: \" + (System.nanoTime() - t0)/1e9);\n\n    /*System.out.println(\"Waiting for BinaryMerge RPCs to finish ... \");\n    t0 = System.nanoTime();\n    BinaryMerge bmResults[] = new BinaryMerge[bmList.size()];   // all the results were being collected on one node here?  No. bmResults are small.\n    int i=0;\n    for (RPC rpc : bmList) {\n      System.out.print(String.format(\"%4d: \", i));\n      BinaryMerge thisbm;\n      bmResults[i++] = thisbm = (BinaryMerge)rpc.get(); //block\n      for (int t=0; t<12; t++) System.out.print(String.format(\"%5.2f \", thisbm._timings[t]));\n      System.out.println();\n      if (thisbm._numRowsInResult == 0) continue;\n      numChunks += thisbm._chunkSizes.length;\n      ansN += thisbm._numRowsInResult;\n      // There is no BinaryMerge[i] = null incrementally.  No wonder it is blowing up!\n    }\n    System.out.println(\"\\nBinaryMerge RPCs took: \" + (System.nanoTime() - t0) / 1e9);\n    assert(i == bmList.size());\n*/\n    //return new Frame();\n    System.out.print(\"Allocating and populating chunk info (e.g. size and batch number) ...\");\n    t0 = System.nanoTime();\n    long chunkSizes[] = new long[numChunks];\n    int chunkLeftMSB[] = new int[numChunks];  // using too much space repeating the same value here, but, limited\n    int chunkRightMSB[] = new int[numChunks];\n    int chunkBatch[] = new int[numChunks];\n    int k = 0;\n    for (int i=0; i<bmList.size(); i++) {\n      BinaryMerge thisbm = bmResults[i];\n      if (thisbm._numRowsInResult == 0) continue;\n      int thisChunkSizes[] = thisbm._chunkSizes;\n      for (int j=0; j<thisChunkSizes.length; j++) {\n        chunkSizes[k] = thisChunkSizes[j];\n        chunkLeftMSB[k] = thisbm._leftMSB;\n        chunkRightMSB[k] = thisbm._rightMSB;\n        chunkBatch[k] = j;\n        k++;\n      }\n    }\n    System.out.println(\"took: \" + (System.nanoTime() - t0) / 1e9);\n\n    // Now we can stitch together the final frame from the raw chunks that were put into the store\n\n    System.out.print(\"Allocating and populated espc ...\");\n    t0 = System.nanoTime();\n    long espc[] = new long[chunkSizes.length+1];\n    int i=0;\n    long sum=0;\n    for (long s : chunkSizes) {\n      espc[i++] = sum;\n      sum+=s;\n    }\n    espc[espc.length-1] = sum;\n    System.out.println(\"took: \" + (System.nanoTime() - t0) / 1e9);\n    assert(sum==ansN);\n\n    System.out.print(\"Allocating dummy vecs/chunks of the final frame ...\");\n    t0 = System.nanoTime();\n    int numJoinCols = leftIndex._bytesUsed.length;\n    int numLeftCols = leftFrame.numCols();\n    int numColsInResult = numLeftCols + rightFrame.numCols() - numJoinCols ;\n    final byte[] types = new byte[numColsInResult];\n    final String[][] doms = new String[numColsInResult][];\n    final String[] names = new String[numColsInResult];\n    for (int j=0; j<numLeftCols; j++) {\n      types[j] = leftFrame.vec(j).get_type();\n      doms[j] = leftFrame.domains()[j];\n      names[j] = leftFrame.names()[j];\n    }\n    for (int j=0; j<rightFrame.numCols()-numJoinCols; j++) {\n      types[numLeftCols + j] = rightFrame.vec(j+numJoinCols).get_type();\n      doms[numLeftCols + j] = rightFrame.domains()[j+numJoinCols];\n      names[numLeftCols + j] = rightFrame.names()[j+numJoinCols];\n    }\n    Key key = Vec.newKey();\n    Vec[] vecs = new Vec(key, Vec.ESPC.rowLayout(key, espc)).makeCons(numColsInResult, 0, doms, types);\n    // to delete ... String[] names = ArrayUtils.append(leftFrame.names(), ArrayUtils.select(rightFrame.names(),  ArrayUtils.seq(numJoinCols, rightFrame.numCols() - 1)));\n    System.out.println(\"took: \" + (System.nanoTime() - t0) / 1e9);\n\n    System.out.print(\"Finally stitch together by overwriting dummies ...\");\n    t0 = System.nanoTime();\n    Frame fr = new Frame(names, vecs);\n    ChunkStitcher ff = new ChunkStitcher(/*leftFrame, rightFrame,*/ chunkSizes, chunkLeftMSB, chunkRightMSB, chunkBatch);\n    ff.doAll(fr);\n    System.out.println(\"took: \" + (System.nanoTime() - t0) / 1e9);\n\n    //Merge.cleanUp();\n    return fr;\n  }","id":99210,"modified_method":"static Frame merge(final Frame leftFrame, final Frame rightFrame, final int leftCols[], final int rightCols[], boolean allLeft, int[][] id_maps) {\n\n    // each of those launches an MRTask\n    System.out.println(\"\\nCreating left index ...\");\n    long t0 = System.nanoTime();\n    RadixOrder leftIndex;\n    H2O.H2OCountedCompleter left = H2O.submitTask(leftIndex = new RadixOrder(leftFrame, /*isLeft=*/true, leftCols, null));\n    left.join(); // Running 3 consecutive times on an idle cluster showed that running left and right in parallel was\n                 // a little slower (97s) than one by one (89s).  TODO: retest in future\n    System.out.println(\"***\\n*** Creating left index took: \" + (System.nanoTime() - t0) / 1e9 + \"\\n***\\n\");\n\n    System.out.println(\"\\nCreating right index ...\");\n    t0 = System.nanoTime();\n    RadixOrder rightIndex;\n    H2O.H2OCountedCompleter right = H2O.submitTask(rightIndex = new RadixOrder(rightFrame, /*isLeft=*/false, rightCols, id_maps));\n    right.join();\n    System.out.println(\"***\\n*** Creating right index took: \" + (System.nanoTime() - t0) / 1e9 + \"\\n***\\n\");\n\n    // TODO: start merging before all indexes had been created. Use callback?\n\n    // TODO: Thomas showed this method which takes 'true' argument to H2OCountedCompleter directly.  Not sure how that\n    // relates to new of RadixOrder which itself extends H2OCountedCompleter.  That true argument isn't available that way.\n    // H2O.submitTask(new H2O.H2OCountedCompleter(true) {   // true just to bump priority and prevent deadlock (no different to speed, in theory - Thomas) in case this Merge ever called from within another counted completer\n    // @Override\n    // protected void compute2() {\n    //   RadixOrder.compute(leftFrame, /*left=*/true, leftCols);  // when RadixOrder had just a static compute() method\n    //   tryComplete();\n    // }\n\n    // Align MSB locations between the two keys\n    // If the 1st join column has range < 256 (e.g. test cases) then <=8 bits are used and there's a floor of 8 to the shift.\n    /*int bitShift = Math.max(8, rightIndex._biggestBit[0]) - Math.max(8, leftIndex._biggestBit[0]);\n    int leftExtent = 256, rightExtent = 1;\n    if (bitShift < 0) {\n      // The biggest keys in left table are larger than the biggest in right table\n      // Therefore those biggest ones don't have a match and we can instantly ignore them\n      // The only msb's that can match are the smallest in left table ...\n      leftExtent >>= -bitShift;\n      // and those could join to multiple msb in the right table, one-to-many ...\n      rightExtent <<= -bitShift;\n    }*/\n    // else if bitShift > 0\n    //   The biggest keys in right table are larger than the largest in left table\n    //   The msb values in left table need to be reduced in magnitude and will then join to the smallest of the right key's msb values\n    //   Many left msb might join to the same (smaller) right msb\n    //   Leave leftExtent at 256 and rightExtent at 1.\n    //   The positive bitShift will reduce jbase below to common right msb's,  many-to-one\n    // else bitShift == 0\n    //   We hope most common case. Common width keys (e.g. ids, codes, enums, integers, etc) both sides over similar range\n    //   Left msb will match exactly to right msb one-to-one, without any alignment needed.\n\n    // TODO we don't need to create the full index for the MSBs that we know won't match\n\n    long ansN = 0;\n    int numChunks = 0;\n    System.out.print(\"Making BinaryMerge RPC calls ... \");\n    t0 = System.nanoTime();\n    List<RPC> bmList = new ArrayList<>();\n\n    for (int leftMSB=0; leftMSB<256; leftMSB++) { // each of left msb values. NAs (0) aren't joined currently but could be\n//      long leftLen = leftIndex._MSBhist[i];\n//      if (leftLen > 0) {\n      // int rightMSBBase = leftMSB >> bitShift;  // could be positive or negative, or most commonly and ideally bitShift==0\n      //rightFrom = (leftMSB-1) << (Math.max(8, leftIndex._biggestBit[0])-8) + leftIndex._colMin[0] - rightIndex._colMin[0];\n\n      //rightFrom >>= (Math.max(8, rightIndex._biggestBit[0])-8);\n      //rightFrom++;\n\n      for (int rightMSB=0; rightMSB<256; rightMSB++) {\n        //int rightMSB = rightMSBBase +k;\n//          long rightLen = rightIndex._MSBhist[j];\n//          if (rightLen > 0) {\n        //System.out.print(i + \" left \" + lenx + \" => right \" + leny);\n        // TO DO: when go distributed, move the smaller of lenx and leny to the other one's node\n        //        if 256 are distributed across 10 nodes in order with 1-25 on node 1, 26-50 on node 2 etc, then most already will be on same node.\n//        H2ONode leftNode = MoveByFirstByte.ownerOfMSB(leftMSB);\n\n        //if  ( ((leftMSB-1) << (Math.max(8, leftIndex._biggestBit[0])-8)) + leftIndex._colMin[0] !=\n        //      ((rightMSB-1) << (Math.max(8, rightIndex._biggestBit[0])-8)) + rightIndex._colMin[0] )\n        //  continue;\n        long tt = (leftMSB << (Math.max(8, leftIndex._biggestBit[0])-8)) + leftIndex._colMin[0] - rightIndex._colMin[0];\n        if (tt<0) continue;  // The left MSB values represent a range less than the right minimum value, so cannot match.\n        tt >>= (Math.max(8, rightIndex._biggestBit[0])-8);\n        if (tt != rightMSB) continue;  // including possibly tt greater than 256 for left values greater than the right's max\n\n        // A naive loop through 1:65536 is considered easier to read. Could get fancy and loop inner loop through relevant lower and upper bound only but trying hurt my brain too much and had too high risk of bugs.\n        // The loops are started at 1, then 1 taken off again, to remind us about NA.\n\n        H2ONode rightNode = SplitByMSBLocal.ownerOfMSB(rightMSB);  // TODO: ensure that that owner has that part of the index locally.\n        //if (leftMSB!=73 || rightMSB!=73) continue;\n        //Log.info(\"Calling BinaryMerge for \" + leftMSB + \" \" + rightMSB);\n        RPC bm = new RPC<>(rightNode,\n                new BinaryMerge(leftFrame, rightFrame,\n                        leftMSB, rightMSB,\n                        //leftNode.index(), //convention - right frame is local, but left frame is potentially remote\n                        leftIndex._bytesUsed,   // field sizes for each column in the key\n                        rightIndex._bytesUsed,\n                        leftIndex._colMin,\n                        rightIndex._colMin,\n                        allLeft\n                )\n        );\n        bmList.add(bm);\n        System.out.print(rightNode.index() + \" \"); // So we can make sure distributed across nodes.\n        //System.out.println(\"Made RPC to node \" + rightNode.index() + \" for MSB\" + leftMSB + \"/\" + rightMSB);\n      }\n    }\n    System.out.println(\"... took: \" + (System.nanoTime() - t0) / 1e9);\n\n    int queueSize = Math.max(H2O.CLOUD.size() * 20, 40);  // TODO: remove and let thread pool take care of it once GC issue alleviated\n    t0 = System.nanoTime();\n    if (queueSize > bmList.size()) {\n      System.out.println(\"Small number of MSB joins (\" + bmList.size() + \") means we won't get full parallelization benefit\");\n      queueSize = bmList.size();\n    }\n    System.out.println(\"Sending \"+bmList.size()+\" BinaryMerge async RPC calls in a queue of \" + queueSize + \" ... \");\n    // need to do our own queue it seems, otherwise floods the cluster\n\n    //int nbatch = 1+ (bmList.size()-1)/queueSize;\n    //int lastSize = bmList.size() - (nbatch-1) * queueSize;\n    //int bmCount = 0, batchStart = 0;\n    int queue[] = new int[queueSize];\n    BinaryMerge bmResults[] = new BinaryMerge[bmList.size()];\n\n    //for (int b=1; b<=nbatch; b++) {      // to save flooding the cluster and RAM usage\n    //  int thisBatchSize = b==nbatch ? lastSize : queueSize;\n    int nextItem;\n    for (nextItem=0; nextItem<queueSize; nextItem++) {\n      queue[nextItem] = nextItem;\n      bmList.get(nextItem).call();  // async\n    }\n    int leftOnQueue = queueSize;\n    int waitMS = 50;  // 0.05 second for fast runs like 1E8 on 1 node\n    while (leftOnQueue > 0) {\n      try {\n        Thread.sleep(waitMS);\n      } catch(InterruptedException ex) {\n        Thread.currentThread().interrupt();\n      }\n      // System.out.println(\"Sweeping queue ...\");\n      int doneInSweep = 0;\n      for (int q=0; q<queueSize; q++) {\n        int thisBM = queue[q];\n        if (thisBM >= 0 && bmList.get(thisBM).isDone()) {\n          BinaryMerge thisbm;\n          bmResults[thisBM] = thisbm = (BinaryMerge)bmList.get(thisBM).get();\n          leftOnQueue--;\n          doneInSweep++;\n          if (thisbm._numRowsInResult > 0) {\n            System.out.print(String.format(\"%3d\",queue[q]) + \":\");\n            for (int t=0; t<20; t++) System.out.print(String.format(\"%.2f \", thisbm._timings[t]));\n            System.out.println();\n            numChunks += thisbm._chunkSizes.length;\n            ansN += thisbm._numRowsInResult;\n          }\n          queue[q] = -1;  // clear the slot\n          if (nextItem < bmList.size()) {\n            bmList.get(nextItem).call();   // call next one\n            queue[q] = nextItem++;         // put on queue so we can sweep\n            leftOnQueue++;\n          }\n        }\n      }\n      if (doneInSweep == 0) waitMS = Math.min(1000, waitMS*2);  // if last sweep caught none, then double wait time to avoid cost of sweeping\n    }\n    System.out.println(\"took: \" + (System.nanoTime() - t0) / 1e9);\n\n\n    System.out.print(\"Removing DKV keys of left and right index.  ... \");\n    // TODO: In future we won't delete but rather persist them as index on the table\n    // Explicitly deleting here (rather than Arno's cleanUp) to reveal if we're not removing keys early enough elsewhere\n    t0 = System.nanoTime();\n    for (int msb=0; msb<256; msb++) {\n      for (int isLeft=0; isLeft<2; isLeft++) {\n        Key k = getSortedOXHeaderKey(isLeft==0 ? false : true, msb);\n        SingleThreadRadixOrder.OXHeader oxheader = DKV.getGet(k);\n        DKV.remove(k);\n        if (oxheader != null) {\n          for (int b=0; b<oxheader._nBatch; ++b) {\n            k = SplitByMSBLocal.getSortedOXbatchKey(isLeft==0 ? false : true, msb, b);\n            DKV.remove(k);\n          }\n        }\n      }\n    }\n    System.out.println(\"took: \" + (System.nanoTime() - t0)/1e9);\n\n    /*System.out.println(\"Waiting for BinaryMerge RPCs to finish ... \");\n    t0 = System.nanoTime();\n    BinaryMerge bmResults[] = new BinaryMerge[bmList.size()];   // all the results were being collected on one node here?  No. bmResults are small.\n    int i=0;\n    for (RPC rpc : bmList) {\n      System.out.print(String.format(\"%4d: \", i));\n      BinaryMerge thisbm;\n      bmResults[i++] = thisbm = (BinaryMerge)rpc.get(); //block\n      for (int t=0; t<12; t++) System.out.print(String.format(\"%5.2f \", thisbm._timings[t]));\n      System.out.println();\n      if (thisbm._numRowsInResult == 0) continue;\n      numChunks += thisbm._chunkSizes.length;\n      ansN += thisbm._numRowsInResult;\n      // There is no BinaryMerge[i] = null incrementally.  No wonder it is blowing up!\n    }\n    System.out.println(\"\\nBinaryMerge RPCs took: \" + (System.nanoTime() - t0) / 1e9);\n    assert(i == bmList.size());\n*/\n    //return new Frame();\n    System.out.print(\"Allocating and populating chunk info (e.g. size and batch number) ...\");\n    t0 = System.nanoTime();\n    long chunkSizes[] = new long[numChunks];\n    int chunkLeftMSB[] = new int[numChunks];  // using too much space repeating the same value here, but, limited\n    int chunkRightMSB[] = new int[numChunks];\n    int chunkBatch[] = new int[numChunks];\n    int k = 0;\n    for (int i=0; i<bmList.size(); i++) {\n      BinaryMerge thisbm = bmResults[i];\n      if (thisbm._numRowsInResult == 0) continue;\n      int thisChunkSizes[] = thisbm._chunkSizes;\n      for (int j=0; j<thisChunkSizes.length; j++) {\n        chunkSizes[k] = thisChunkSizes[j];\n        chunkLeftMSB[k] = thisbm._leftMSB;\n        chunkRightMSB[k] = thisbm._rightMSB;\n        chunkBatch[k] = j;\n        k++;\n      }\n    }\n    System.out.println(\"took: \" + (System.nanoTime() - t0) / 1e9);\n\n    // Now we can stitch together the final frame from the raw chunks that were put into the store\n\n    System.out.print(\"Allocating and populated espc ...\");\n    t0 = System.nanoTime();\n    long espc[] = new long[chunkSizes.length+1];\n    int i=0;\n    long sum=0;\n    for (long s : chunkSizes) {\n      espc[i++] = sum;\n      sum+=s;\n    }\n    espc[espc.length-1] = sum;\n    System.out.println(\"took: \" + (System.nanoTime() - t0) / 1e9);\n    assert(sum==ansN);\n\n    System.out.print(\"Allocating dummy vecs/chunks of the final frame ...\");\n    t0 = System.nanoTime();\n    int numJoinCols = leftIndex._bytesUsed.length;\n    int numLeftCols = leftFrame.numCols();\n    int numColsInResult = numLeftCols + rightFrame.numCols() - numJoinCols ;\n    final byte[] types = new byte[numColsInResult];\n    final String[][] doms = new String[numColsInResult][];\n    final String[] names = new String[numColsInResult];\n    for (int j=0; j<numLeftCols; j++) {\n      types[j] = leftFrame.vec(j).get_type();\n      doms[j] = leftFrame.domains()[j];\n      names[j] = leftFrame.names()[j];\n    }\n    for (int j=0; j<rightFrame.numCols()-numJoinCols; j++) {\n      types[numLeftCols + j] = rightFrame.vec(j+numJoinCols).get_type();\n      doms[numLeftCols + j] = rightFrame.domains()[j+numJoinCols];\n      names[numLeftCols + j] = rightFrame.names()[j+numJoinCols];\n    }\n    Key key = Vec.newKey();\n    Vec[] vecs = new Vec(key, Vec.ESPC.rowLayout(key, espc)).makeCons(numColsInResult, 0, doms, types);\n    // to delete ... String[] names = ArrayUtils.append(leftFrame.names(), ArrayUtils.select(rightFrame.names(),  ArrayUtils.seq(numJoinCols, rightFrame.numCols() - 1)));\n    System.out.println(\"took: \" + (System.nanoTime() - t0) / 1e9);\n\n    System.out.print(\"Finally stitch together by overwriting dummies ...\");\n    t0 = System.nanoTime();\n    Frame fr = new Frame(names, vecs);\n    ChunkStitcher ff = new ChunkStitcher(/*leftFrame, rightFrame,*/ chunkSizes, chunkLeftMSB, chunkRightMSB, chunkBatch);\n    ff.doAll(fr);\n    System.out.println(\"took: \" + (System.nanoTime() - t0) / 1e9);\n\n    //Merge.cleanUp();\n    return fr;\n  }","commit_id":"6e424ff44dfb8b23324a1e16f79766da8d6b398d","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override\n  public void compute2() {\n\n    //System.out.println(\"Calling RadixCount ...\");\n    long t0 = System.nanoTime();\n    _biggestBit = new int[_whichCols.length];   // currently only biggestBit[0] is used\n    _bytesUsed = new int[_whichCols.length];\n    //long colMin[] = new long[whichCols.length];\n    for (int i = 0; i < _whichCols.length; i++) {\n      Vec col = _DF.vec(_whichCols[i]);\n      //long range = (long) (col.max() - col.min());\n      //assert range >= 1;   // otherwise log(0)==-Inf next line\n      double numerator;\n      if (!_isLeft && col.isCategorical()) {\n        // the right's levels have been matched to the left's levels and we store the mapped values so it's that mapped range we need here (or the col.max() of the corresonding left table would be fine too, but mapped range might be less so use that for possible efficiency)\n        assert _id_maps[i] != null;\n        numerator = ArrayUtils.maxValue(_id_maps[i]);  // could use rightcol.max(), but this way if we join to a small subset of levels, we'll benefit from the small range here.\n      } else {\n        numerator = col.max();\n      }\n      _biggestBit[i] = 1 + (int) Math.floor(Math.log(numerator) / Math.log(2));   // number of bits starting from 1 easier to think about (for me)\n      _bytesUsed[i] = (int) Math.ceil(_biggestBit[i] / 8.0);\n      //colMin[i] = (long) col.min();   // TO DO: non-int/enum\n    }\n    if (_biggestBit[0] < 8) Log.warn(\"biggest bit should be >= 8 otherwise need to dip into next column (TODO)\");  // TODO: feeed back to R warnings()\n    int keySize = ArrayUtils.sum(_bytesUsed);   // The MSB is stored (seemingly wastefully on first glance) because we need it when aligning two keys in Merge()\n    int batchSize = 256*1024*1024 / Math.max(keySize, 8) / 2 ;   // 256MB is the DKV limit.  / 2 because we fit o and x together in one OXBatch.\n    // The Math.max ensures that batches of o and x are aligned, even for wide keys. To save % and / in deep iteration; e.g. in insert().\n    System.out.println(\"Time to use rollup stats to determine biggestBit: \" + (System.nanoTime() - t0) / 1e9);\n\n    t0 = System.nanoTime();\n    new RadixCount(_isLeft, _biggestBit[0], _whichCols[0], _isLeft ? null : _id_maps ).doAll(_DF.vec(_whichCols[0]));\n    System.out.println(\"Time of MSB count MRTask left local on each node (no reduce): \" + (System.nanoTime() - t0) / 1e9);\n\n    // NOT TO DO:  we do need the full allocation of x[] and o[].  We need o[] anyway.  x[] will be compressed and dense.\n    // o is the full ordering vector of the right size\n    // x is the byte key aligned with o\n    // o AND x are what bmerge() needs. Pushing x to each node as well as o avoids inter-node comms.\n\n\n    // System.out.println(\"Starting MSB hist reduce across nodes and SplitByMSBLocal MRTask ...\");\n    // Workaround for incorrectly blocking closeLocal() in MRTask is to do a double MRTask and pass a key between them to pass output\n    // from first on that node to second on that node.  // TODO: fix closeLocal() blocking issue and revert to simpler usage of closeLocal()\n    t0 = System.nanoTime();\n    Key linkTwoMRTask = Key.make();\n    SplitByMSBLocal tmp = new SplitByMSBLocal(_isLeft, _biggestBit[0], keySize, batchSize, _bytesUsed, _whichCols, linkTwoMRTask, _id_maps).doAll(_DF.vecs(_whichCols));   // postLocal needs DKV.put()\n    System.out.println(\"SplitByMSBLocal MRTask (all local per node, no network) took : \" + (System.nanoTime() - t0) / 1e9);\n    System.out.print(tmp.profString());\n\n    t0 = System.nanoTime();\n    new SendSplitMSB(linkTwoMRTask).doAllNodes();\n    System.out.println(\"SendSplitMSB across all nodes took : \" + (System.nanoTime() - t0) / 1e9);\n\n    //long nGroup[] = new long[257];   // one extra for later to make undo of cumulate easier when finding groups.  TO DO: let grouper do that and simplify here to 256\n\n    // dispatch in parallel\n    RPC[] radixOrders = new RPC[256];\n    System.out.print(\"Sending SingleThreadRadixOrder async RPC calls ... \");\n    t0 = System.nanoTime();\n    for (int i = 0; i < 256; i++) {\n      //System.out.print(i+\" \");\n      radixOrders[i] = new RPC<>(SplitByMSBLocal.ownerOfMSB(i), new SingleThreadRadixOrder(_DF, _isLeft, batchSize, keySize, /*nGroup,*/ i)).call();\n    }\n    System.out.println(\"took : \" + (System.nanoTime() - t0) / 1e9);\n\n    System.out.print(\"Waiting for RPC SingleThreadRadixOrder to finish ... \");\n    t0 = System.nanoTime();\n    int i=0;\n    for (RPC rpc : radixOrders) { //TODO: Use a queue to make this fully async\n      // System.out.print(i+\" \");\n      rpc.get();\n      //SingleThreadRadixOrder radixOrder = (SingleThreadRadixOrder)rpc.get();   // TODO: make sure all transient here\n      i++;\n    }\n    System.out.println(\"took \" + (System.nanoTime() - t0) / 1e9);\n\n    tryComplete();\n\n    // serial, do one at a time\n//    for (int i = 0; i < 256; i++) {\n//      H2ONode node = MoveByFirstByte.ownerOfMSB(i);\n//      SingleThreadRadixOrder radixOrder = new RPC<>(node, new SingleThreadRadixOrder(DF, batchSize, keySize, nGroup, i)).call().get();\n//      _o[i] = radixOrder._o;\n//      _x[i] = radixOrder._x;\n//    }\n\n    // If sum(nGroup) == nrow then the index is unique.\n    // 1) useful to know if an index is unique or not (when joining to it we know multiples can't be returned so can allocate more efficiently)\n    // 2) If all groups are size 1 there's no need to actually allocate an all-1 group size vector (perhaps user was checking for uniqueness by counting group sizes)\n    // 3) some nodes may have unique input and others may contain dups; e.g., in the case of looking for rare dups.  So only a few threads may have found dups.\n    // 4) can sweep again in parallel and cache-efficient finding the groups, and allocate known size up front to hold the group sizes.\n    // 5) can return to Flow early with the group count. User may now realise they selected wrong columns and cancel early.\n\n  }","id":99211,"modified_method":"@Override\n  public void compute2() {\n\n    //System.out.println(\"Calling RadixCount ...\");\n    long t0 = System.nanoTime();\n    _biggestBit = new int[_whichCols.length];   // currently only biggestBit[0] is used\n    _bytesUsed = new int[_whichCols.length];\n    _colMin = new long[_whichCols.length];\n    for (int i=0; i<_whichCols.length; i++) {\n      Vec col = _DF.vec(_whichCols[i]);\n      //long range = (long) (col.max() - col.min());\n      //assert range >= 1;   // otherwise log(0)==-Inf next line\n      double numerator;\n      // TODO: string & double. But we we'll only allow fixed precision double in keys, unlike data.table\n      _colMin[i] = col.isCategorical() ? 0 : (long)col.min();   // temp workaround\n      if (!_isLeft && col.isCategorical()) {\n        // the right's levels have been matched to the left's levels and we store the mapped values so it's that mapped range we need here (or the col.max() of the corresonding left table would be fine too, but mapped range might be less so use that for possible efficiency)\n        assert _id_maps[i] != null;\n        //_colMin[i] = ArrayUtils.minValue(_id_maps[i]);  // TODO: what is in _id_maps for no matches (-1?) and exclude those i.e. find the minimum >=0. Then treat -1 in _id_map as an NA when writing key\n        numerator = ArrayUtils.maxValue(_id_maps[i]) - _colMin[i] + 2;  // if we join to a small subset of levels, we'll benefit from the small range here.\n      } else {\n        //_colMin[i] = (long)col.min();\n        numerator = (long)col.max() - _colMin[i] + 2;  // +1 for bounds, another +1 for NA (if any) being stored at 0\n      }\n      _biggestBit[i] = 1 + (int) Math.floor(Math.log(numerator) / Math.log(2));   // number of bits starting from 1 easier to think about (for me)\n      _bytesUsed[i] = (int) Math.ceil(_biggestBit[i] / 8.0);\n    }\n    if (_biggestBit[0] < 8) Log.warn(\"biggest bit should be >= 8 otherwise need to dip into next column (TODO)\");  // TODO: feeed back to R warnings()\n    int keySize = ArrayUtils.sum(_bytesUsed);   // The MSB is stored (seemingly wastefully on first glance) because we need it when aligning two keys in Merge()\n    int batchSize = 256*1024*1024 / Math.max(keySize, 8) / 2 ;   // 256MB is the DKV limit.  / 2 because we fit o and x together in one OXBatch.\n    // The Math.max ensures that batches of o and x are aligned, even for wide keys. To save % and / in deep iteration; e.g. in insert().\n    System.out.println(\"Time to use rollup stats to determine biggestBit: \" + (System.nanoTime() - t0) / 1e9);\n\n    t0 = System.nanoTime();\n    new RadixCount(_isLeft, _biggestBit[0], _colMin[0], _whichCols[0], _isLeft ? null : _id_maps ).doAll(_DF.vec(_whichCols[0]));\n    System.out.println(\"Time of MSB count MRTask left local on each node (no reduce): \" + (System.nanoTime() - t0) / 1e9);\n\n    // NOT TO DO:  we do need the full allocation of x[] and o[].  We need o[] anyway.  x[] will be compressed and dense.\n    // o is the full ordering vector of the right size\n    // x is the byte key aligned with o\n    // o AND x are what bmerge() needs. Pushing x to each node as well as o avoids inter-node comms.\n\n\n    // System.out.println(\"Starting MSB hist reduce across nodes and SplitByMSBLocal MRTask ...\");\n    // Workaround for incorrectly blocking closeLocal() in MRTask is to do a double MRTask and pass a key between them to pass output\n    // from first on that node to second on that node.  // TODO: fix closeLocal() blocking issue and revert to simpler usage of closeLocal()\n    t0 = System.nanoTime();\n    Key linkTwoMRTask = Key.make();\n    SplitByMSBLocal tmp = new SplitByMSBLocal(_isLeft, _biggestBit[0], keySize, batchSize, _bytesUsed, _colMin, _whichCols, linkTwoMRTask, _id_maps).doAll(_DF.vecs(_whichCols));   // postLocal needs DKV.put()\n    System.out.println(\"SplitByMSBLocal MRTask (all local per node, no network) took : \" + (System.nanoTime() - t0) / 1e9);\n    System.out.print(tmp.profString());\n\n    t0 = System.nanoTime();\n    new SendSplitMSB(linkTwoMRTask).doAllNodes();\n    System.out.println(\"SendSplitMSB across all nodes took : \" + (System.nanoTime() - t0) / 1e9);\n\n    //long nGroup[] = new long[257];   // one extra for later to make undo of cumulate easier when finding groups.  TO DO: let grouper do that and simplify here to 256\n\n    // dispatch in parallel\n    RPC[] radixOrders = new RPC[256];\n    System.out.print(\"Sending SingleThreadRadixOrder async RPC calls ... \");\n    t0 = System.nanoTime();\n    for (int i = 0; i < 256; i++) {\n      //System.out.print(i+\" \");\n      radixOrders[i] = new RPC<>(SplitByMSBLocal.ownerOfMSB(i), new SingleThreadRadixOrder(_DF, _isLeft, batchSize, keySize, /*nGroup,*/ i)).call();\n    }\n    System.out.println(\"took : \" + (System.nanoTime() - t0) / 1e9);\n\n    System.out.print(\"Waiting for RPC SingleThreadRadixOrder to finish ... \");\n    t0 = System.nanoTime();\n    int i=0;\n    for (RPC rpc : radixOrders) { //TODO: Use a queue to make this fully async\n      // System.out.print(i+\" \");\n      rpc.get();\n      //SingleThreadRadixOrder radixOrder = (SingleThreadRadixOrder)rpc.get();   // TODO: make sure all transient here\n      i++;\n    }\n    System.out.println(\"took \" + (System.nanoTime() - t0) / 1e9);\n\n    tryComplete();\n\n    // serial, do one at a time\n//    for (int i = 0; i < 256; i++) {\n//      H2ONode node = MoveByFirstByte.ownerOfMSB(i);\n//      SingleThreadRadixOrder radixOrder = new RPC<>(node, new SingleThreadRadixOrder(DF, batchSize, keySize, nGroup, i)).call().get();\n//      _o[i] = radixOrder._o;\n//      _x[i] = radixOrder._x;\n//    }\n\n    // If sum(nGroup) == nrow then the index is unique.\n    // 1) useful to know if an index is unique or not (when joining to it we know multiples can't be returned so can allocate more efficiently)\n    // 2) If all groups are size 1 there's no need to actually allocate an all-1 group size vector (perhaps user was checking for uniqueness by counting group sizes)\n    // 3) some nodes may have unique input and others may contain dups; e.g., in the case of looking for rare dups.  So only a few threads may have found dups.\n    // 4) can sweep again in parallel and cache-efficient finding the groups, and allocate known size up front to hold the group sizes.\n    // 5) can return to Flow early with the group count. User may now realise they selected wrong columns and cancel early.\n\n  }","commit_id":"6e424ff44dfb8b23324a1e16f79766da8d6b398d","url":"https://github.com/h2oai/h2o-3"},{"original_method":"SplitByMSBLocal(boolean isLeft, int biggestBit, int keySize, int batchSize, int bytesUsed[], int[] col, Key linkTwoMRTask, int[][] id_maps) {\n    _isLeft = isLeft;\n    _biggestBit = biggestBit; _batchSize=batchSize; _bytesUsed = bytesUsed; _col = col;\n    _keySize = keySize;  // ArrayUtils.sum(_bytesUsed) -1;\n    _linkTwoMRTask = linkTwoMRTask;\n    _id_maps = id_maps;\n    //setProfile(true);\n  }","id":99212,"modified_method":"SplitByMSBLocal(boolean isLeft, int biggestBit, int keySize, int batchSize, int bytesUsed[], long colMin[], int[] col, Key linkTwoMRTask, int[][] id_maps) {\n    _isLeft = isLeft;\n    _biggestBit = biggestBit; _batchSize=batchSize; _bytesUsed=bytesUsed; _col=col; _colMin=colMin;\n    _keySize = keySize;  // ArrayUtils.sum(_bytesUsed) -1;\n    _linkTwoMRTask = linkTwoMRTask;\n    _id_maps = id_maps;\n    //setProfile(true);\n  }","commit_id":"6e424ff44dfb8b23324a1e16f79766da8d6b398d","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override public void map( Chunk chk ) {\n    long tmp[] = _counts._val[chk.cidx()] = new long[256];\n    int shift = _biggestBit-8;\n    if (shift<0) shift = 0;\n    // TO DO: assert chk instanceof integer or enum;  -- but how?  // alternatively: chk.getClass().equals(C8Chunk.class)\n    if (!_isLeft && chk.vec().isCategorical()) {   // first column (for MSB split) in an Enum. Heed the id_maps.\n      assert _id_maps[0].length > 0;\n      for (int r=0; r<chk._len; r++) {\n        tmp[(int) (_id_maps[0][(int)chk.at8(r)] >> shift & 0xFFL)]++;\n      }\n    } else {\n      for (int r=0; r<chk._len; r++) {\n        tmp[(int) (chk.at8(r) >> shift & 0xFFL)]++;  // forget the L => wrong answer with no type warning from IntelliJ\n        // TODO - use _mem directly. Hist the compressed bytes and then shift the histogram afterwards when reducing.\n      }\n    }\n  }","id":99213,"modified_method":"@Override public void map( Chunk chk ) {\n    long tmp[] = _counts._val[chk.cidx()] = new long[256];\n    int shift = _biggestBit-8;\n    if (shift<0) shift = 0;\n    // TO DO: assert chk instanceof integer or enum;  -- but how since many integers (C1,C2 etc)? // alternatively: chk.getClass().equals(C8Chunk.class)\n    if (_isLeft || !chk.vec().isCategorical()) {\n      if (chk.vec().naCnt() == 0) {\n        // There are no NA in this join column; hence branch-free loop. Most common case as should never really have NA in join columns.\n        for (int r=0; r<chk._len; r++) {\n          tmp[(int)((chk.at8(r)-_colMin+1) >> shift & 0xFFL)]++;  // forget the L => wrong answer with no type warning from IntelliJ\n          // TODO - use _mem directly. Hist the compressed bytes and then shift the histogram afterwards when reducing.\n        }\n      } else {\n        // There are some NA in the column so have to branch. TODO: warn user NA are present in join column\n        for (int r=0; r<chk._len; r++) {\n          if (chk.isNA(r)) tmp[0]++;\n          else tmp[(int)((chk.at8(r)-_colMin+1) >> shift & 0xFFL)]++;  // forget the L => wrong answer with no type warning from IntelliJ\n          // Done - we will join NA to NA as data.table does\n          // TODO: allow NA-to-NA join to be turned off. Do that in bmerge as a simple low-cost switch.\n          // Note that NA and the minimum may well both be in MSB 0 but most of the time we will not have NA in join columns\n        }\n      }\n    } else {\n      // first column (for MSB split) in an Enum\n      // map right categorical to left levels using _id_maps\n      assert _id_maps[0].length > 0;\n      assert _colMin==0;  // TODO: no longer true.  Will likely fail first time we have an enum as the first join column\n      if (chk.vec().naCnt() == 0) {\n        for (int r=0; r<chk._len; r++) {\n          tmp[(int)((_id_maps[0][(int)chk.at8(r)]+1) >> shift & 0xFFL)]++;\n        }\n      } else {\n        for (int r=0; r<chk._len; r++) {\n          if (chk.isNA(r)) tmp[0]++;\n          else tmp[(int)((_id_maps[0][(int)chk.at8(r)]+1) >> shift & 0xFFL)]++;\n        }\n      }\n    }\n  }","commit_id":"6e424ff44dfb8b23324a1e16f79766da8d6b398d","url":"https://github.com/h2oai/h2o-3"},{"original_method":"RadixCount(boolean isLeft, int biggestBit, int col, int id_maps[][]) {\n    _isLeft = isLeft;\n    _biggestBit = biggestBit;\n    _col = col;\n    _id_maps = id_maps;\n  }","id":99214,"modified_method":"RadixCount(boolean isLeft, int biggestBit, long colMin, int col, int id_maps[][]) {\n    _isLeft = isLeft;\n    _biggestBit = biggestBit;\n    _col = col;\n    _colMin = colMin;\n    _id_maps = id_maps;\n  }","commit_id":"6e424ff44dfb8b23324a1e16f79766da8d6b398d","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override public void map(Chunk chk[]) {\n    // System.out.println(\"Starting MoveByFirstByte.map() for chunk \" + chk[0].cidx());\n    long myCounts[] = _counts[chk[0].cidx()]; //cumulative offsets into o and x\n    if (myCounts == null) {\n      System.out.println(\"myCounts empty for chunk \" + chk[0].cidx());\n      return;\n    }\n\n    //int leftAlign = (8-(_biggestBit % 8)) % 8;   // only the first column is left aligned, currently. But they all could be for better splitting.\n\n    // Loop through this chunk and write the byte key and the source row into the local MSB buckets\n    long t0 = System.nanoTime();\n    for (int r=0; r<chk[0]._len; r++) {    // tight, branch free and cache efficient (surprisingly)\n      long thisx = chk[0].at8(r);  // - _colMin[0]) << leftAlign;  (don't subtract colMin because it unlikely helps compression and makes joining 2 compressed keys more difficult and expensive).\n      if (!_isLeft && _id_maps[0] != null) thisx = _id_maps[0][(int)thisx];  // TO DO: restore branch-free again, go by column and retain original compression with no .at8()\n      int shift = _biggestBit-8;   // TO DO: not needed if we stick with original compression and standardize in merge.\n      if (shift<0) shift = 0;\n      int MSBvalue = (int) (thisx >> shift & 0xFFL);\n      long target = myCounts[MSBvalue]++;\n      int batch = (int) (target / _batchSize);\n      int offset = (int) (target % _batchSize);\n      assert _o[MSBvalue] != null;\n      _o[MSBvalue][batch][offset] = (long) r + chk[0].start();    // move i and the index.\n\n      byte this_x[] = _x[MSBvalue][batch];\n      offset *= _keySize; //can't overflow because batchsize was chosen above to be maxByteSize/max(keysize,8)\n      for (int i = _bytesUsed[0] - 1; i >= 0; i--) {   // a loop because I don't believe System.arraycopy() can copy parts of (byte[])long to byte[]\n        this_x[offset + i] = (byte) (thisx & 0xFF);\n        thisx >>= 8;\n      }\n      for (int c=1; c<chk.length; c++) {  // TO DO: left align subsequent\n        offset += _bytesUsed[c-1];    // advance offset by the previous field width\n        thisx = chk[c].at8(r);        // TO DO : compress with a scale factor such as dates stored as ms since epoch / 3600000L\n        if (!_isLeft && _id_maps[c] != null) thisx = _id_maps[c][(int)thisx];  // TO DO: restore branch-free again, go by column and retain original compression with no .at8()\n        for (int i = _bytesUsed[c] - 1; i >= 0; i--) {\n          this_x[offset + i] = (byte) (thisx & 0xFF);\n          thisx >>= 8;\n        }\n      }\n    }\n    // System.out.println(System.currentTimeMillis() + \" MoveByFirstByte.map() into MSB buckets for chunk \" + chk[0].cidx() + \" took : \" + (System.nanoTime() - t0) / 1e9);\n  }","id":99215,"modified_method":"@Override public void map(Chunk chk[]) {\n    // System.out.println(\"Starting MoveByFirstByte.map() for chunk \" + chk[0].cidx());\n    long myCounts[] = _counts[chk[0].cidx()]; //cumulative offsets into o and x\n    if (myCounts == null) {\n      System.out.println(\"myCounts empty for chunk \" + chk[0].cidx());\n      return;\n    }\n\n    //int leftAlign = (8-(_biggestBit % 8)) % 8;   // only the first column is left aligned, currently. But they all could be for better splitting.\n\n    // Loop through this chunk and write the byte key and the source row number into the local MSB buckets\n    // TODO: make this branch free and write the already-compressed _mem directly.  Just need to normalize compression across all chunks.\n    // This has to loop through rows because we need the MSBValue from the first column to use on the others, by row.  Nothing to do cache\n    // efficiency, although, it will be most cache efficient (holding one page of each column's _mem, plus a page of this_x, all contiguous.  At the\n    // cost of more instructions.\n    long t0 = System.nanoTime();\n    int shift = Math.max(_biggestBit-8, 0);\n    for (int r=0; r<chk[0]._len; r++) {    // tight, branch free and cache efficient (surprisingly)\n      int MSBvalue = 0;  // default for NA\n      long thisx = 0;\n      if (!chk[0].isNA(r)) {\n        thisx = chk[0].at8(r);\n        if (!_isLeft && _id_maps[0]!=null) thisx = _id_maps[0][(int)thisx] + 1;  // TODO: restore branch-free again, go by column and retain original compression with no .at8()\n        else thisx = thisx - _colMin[0] + 1;                                     //       may not be worth that as has to be global minimum so will rarely be able to use as raw, but when we can maybe can do in bulk\n        MSBvalue = (int)(thisx >> shift & 0xFFL);   // +1 leaving 0 for NA\n      }\n      long target = myCounts[MSBvalue]++;\n      int batch = (int) (target / _batchSize);\n      int offset = (int) (target % _batchSize);\n      assert _o[MSBvalue] != null;\n      _o[MSBvalue][batch][offset] = (long) r + chk[0].start();    // move i and the index.\n\n      byte this_x[] = _x[MSBvalue][batch];\n      offset *= _keySize; //can't overflow because batchsize was chosen above to be maxByteSize/max(keysize,8)\n      for (int i = _bytesUsed[0] - 1; i >= 0; i--) {   // a loop because I don't believe System.arraycopy() can copy parts of (byte[])long to byte[]\n        this_x[offset + i] = (byte) (thisx & 0xFF);\n        thisx >>= 8;\n      }\n      for (int c=1; c<chk.length; c++) {  // TO DO: left align subsequent\n        offset += _bytesUsed[c-1];     // advance offset by the previous field width\n        if (chk[c].isNA(r)) continue;  // NA is a zero field so skip over as java initializes memory to 0 for us always\n        thisx = chk[c].at8(r);         // TODO : compress with a scale factor such as dates stored as ms since epoch / 3600000L\n        if (!_isLeft && _id_maps[c] != null) thisx = _id_maps[c][(int)thisx] + 1;\n        else thisx = thisx - _colMin[c] + 1;\n        for (int i = _bytesUsed[c] - 1; i >= 0; i--) {\n          this_x[offset + i] = (byte) (thisx & 0xFF);\n          thisx >>= 8;\n        }\n      }\n    }\n    // System.out.println(System.currentTimeMillis() + \" MoveByFirstByte.map() into MSB buckets for chunk \" + chk[0].cidx() + \" took : \" + (System.nanoTime() - t0) / 1e9);\n  }","commit_id":"6e424ff44dfb8b23324a1e16f79766da8d6b398d","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n     * Writes the given xml page by reporting the result.<p>\n     * \n     * @param page the xml page\n     * @param report if true then some output will be written to the report\n     * @throws CmsException if operation failed\n     */\n    private void writePageAndReport(CmsXmlPage page, boolean report) throws CmsException {\n\n        CmsFile file = page.getFile();\n        byte[] content = page.marshal();\n        file.setContents(content);\n        // check lock            \n        CmsLock lock = getCms().getLock(file);\n        if (lock.isNullLock() || lock.getUserId().equals(getCms().getRequestContext().currentUser().getId())) {\n            // lock the page\n            checkLock(getCms().getSitePath(file));\n            // write the file with the new content\n            getCms().writeFile(file);\n            // unlock the page\n            getCms().unlockResource(getCms().getSitePath(file));\n            if (report) {\n                m_report.print(\"\" + m_report.key(\"report.dots\") + m_report.key(\"report.ok\"), I_CmsReport.C_FORMAT_OK);\n                m_report.println(\" element \"\n                    + getParamOldElement()\n                    + \" renamed to \"\n                    + getParamNewElement()\n                    + \" successfully\", I_CmsReport.C_FORMAT_OK);\n            }\n        }\n    }","id":99216,"modified_method":"/**\n     * Writes the given xml page by reporting the result.<p>\n     * \n     * @param page the xml page\n     * @param report if true then some output will be written to the report\n     * @throws CmsException if operation failed\n     */\n    private void writePageAndReport(CmsXmlPage page, boolean report) throws CmsException {\n\n        CmsFile file = page.getFile();\n        byte[] content = page.marshal();\n        file.setContents(content);\n        // check lock            \n        CmsLock lock = getCms().getLock(file);\n        if (lock.isNullLock() || lock.getUserId().equals(getCms().getRequestContext().currentUser().getId())) {\n            // lock the page\n            checkLock(getCms().getSitePath(file));\n            // write the file with the new content\n            getCms().writeFile(file);\n            // unlock the page\n            getCms().unlockResource(getCms().getSitePath(file));\n            if (report) {\n                m_report.println(Messages.get().container(Messages.RPT_ELEM_RENAME_2, getParamOldElement(), \n                    getParamNewElement()), I_CmsReport.C_FORMAT_OK);\n            }\n        }\n    }","commit_id":"fb56d215709f27eea7e6dd0136e180a758bc4555","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Performs the main element rename operation on the filtered resources.<p>\n     * \n     * @param xmlPages the list of xml pages\n     * @param locale the locale specifying the xmlpage node to perform the operation on\n     */\n    private void performRenameOperation(List xmlPages, Locale locale) {\n\n        // partial localized (stopped due to low prio).\n        Locale userLocale = getLocale();\n        boolean removeEmptyElements = Boolean.valueOf(getParamRemoveEmptyElements()).booleanValue();\n        boolean validateNewElement = Boolean.valueOf(getParamValidateNewElement()).booleanValue();\n        // the list including at least one resource\n        if (xmlPages != null && xmlPages.size() > 0) {\n            m_report.println(Messages.get().key(\n                userLocale,\n                Messages.GUI_RENAME_LANG_1,\n                new Object[] {locale.getLanguage()}), I_CmsReport.C_FORMAT_HEADLINE);\n            // if user has not selected ALL templates, then retain pages with specified template\n            if (!C_ALL.equals(getParamTemplate())) {\n                xmlPages = getRetainedPagesWithTemplate(xmlPages);\n            }\n            int m = 0;\n            int n = xmlPages.size();\n            // loop over remained pages\n            Iterator i = xmlPages.iterator();\n            while (i.hasNext()) {\n                m++;\n                CmsXmlPage page = null;\n                try {\n                    // next file from the list\n                    CmsResource res = (CmsResource)i.next();\n                    CmsFile file;\n                    m_report.print(\n                        \"( \" + m + \" / \" + n + \" ) \" + \"processing page \" + getCms().getSitePath(res),\n                        I_CmsReport.C_FORMAT_NOTE);\n                    m_report.println(m_report.key(\"report.dots\"));\n                    try {\n                        file = getCms().readFile(getCms().getSitePath(res), CmsResourceFilter.IGNORE_EXPIRATION);\n                    } catch (CmsException e2) {\n                        if (LOG.isErrorEnabled()) {\n                            LOG.error(e2);\n                        }\n                        m_report.println(e2);\n                        continue;\n                    }\n                    // try unmarshaling to xml page\n                    try {\n                        page = CmsXmlPageFactory.unmarshal(getCms(), file);\n                    } catch (CmsXmlException e) {\n                        m_report.println(e);\n                        continue;\n                    }\n\n                    // check if the source element exists in the page\n                    if (!page.hasValue(getParamOldElement(), locale)) {\n                        m_report.println(m_report.key(\"report.dots\")\n                            + \"element \"\n                            + getParamOldElement()\n                            + \" does not exist.\", I_CmsReport.C_FORMAT_NOTE);\n                        continue;\n                    }\n\n                    // check if the target element already exists in the page\n                    if (page.hasValue(getParamNewElement(), locale)) {\n                        // the page contains already the new element with speicific content. \n                        // renaming the old will invalid the xml page\n                        m_report.println(\n                            m_report.key(\"report.dots\")\n                                + \"the page contains already the new element that includes content\",\n                            I_CmsReport.C_FORMAT_NOTE);\n                        continue;\n                    }\n\n                    if (validateNewElement) {\n                        // check if the target element is valid for the template\n                        if (!isValidElement(page, getParamNewElement())) {\n                            m_report.println(m_report.key(\"report.dots\")\n                                + \"the new element \"\n                                + getParamNewElement()\n                                + \" is not valid\", I_CmsReport.C_FORMAT_NOTE);\n                            continue;\n                        }\n                    }\n\n                    try {\n                        // rename the element from the old value to the new\n                        page.renameValue(getParamOldElement(), getParamNewElement(), locale);\n                        // write the page with the new content\n                        writePageAndReport(page, true);\n                    } catch (Throwable t) {\n                        LOG.error(t);\n                        m_report.println(t);\n                        continue;\n                    }\n\n                } catch (Throwable t) {\n                    LOG.error(t);\n                    m_report.println(t);\n                } finally {\n                    // finally do remove empty elements of the page\n                    // the remove operation is executed if the user has checked the specified checkbox and selected a template (NOT ALL)\n                    if (removeEmptyElements) {\n                        removeInValidElements(page, locale);\n                    }\n                }\n            }\n        }\n    }","id":99217,"modified_method":"/**\n     * Performs the main element rename operation on the filtered resources.<p>\n     * \n     * @param xmlPages the list of xml pages\n     * @param locale the locale specifying the xmlpage node to perform the operation on\n     */\n    private void performRenameOperation(List xmlPages, Locale locale) {\n\n        // partial localized (stopped due to low prio).\n        boolean removeEmptyElements = Boolean.valueOf(getParamRemoveEmptyElements()).booleanValue();\n        boolean validateNewElement = Boolean.valueOf(getParamValidateNewElement()).booleanValue();\n        // the list including at least one resource\n        if (xmlPages != null && xmlPages.size() > 0) {\n            m_report.println(Messages.get().container(Messages.RPT_RENAME_LANG_1, locale.getLanguage()), I_CmsReport.C_FORMAT_HEADLINE);\n            // if user has not selected ALL templates, then retain pages with specified template\n            if (!C_ALL.equals(getParamTemplate())) {\n                xmlPages = getRetainedPagesWithTemplate(xmlPages);\n            }\n            int m = 0;\n            int n = xmlPages.size();\n            // loop over remained pages\n            Iterator i = xmlPages.iterator();\n            while (i.hasNext()) {\n                m++;\n                CmsXmlPage page = null;\n                try {\n                    // next file from the list\n                    CmsResource res = (CmsResource)i.next();\n                    CmsFile file;\n                    \n                    m_report.print(org.opencms.report.Messages.get().container(org.opencms.report.Messages.RPT_SUCCESSION_2, \n                        String.valueOf(m), String.valueOf(n)), I_CmsReport.C_FORMAT_NOTE);\n                    m_report.print(Messages.get().container(Messages.RPT_PROCESSING_PAGE_0), I_CmsReport.C_FORMAT_NOTE);\n                    m_report.print(org.opencms.report.Messages.get().container(\n                        org.opencms.report.Messages.RPT_ARGUMENT_1, getCms().getSitePath(res)));\n                    m_report.println(org.opencms.report.Messages.get().container(org.opencms.report.Messages.RPT_DOTS_0));\n\n                    try {\n                        file = getCms().readFile(getCms().getSitePath(res), CmsResourceFilter.IGNORE_EXPIRATION);\n                    } catch (CmsException e2) {\n                        if (LOG.isErrorEnabled()) {\n                            LOG.error(e2);\n                        }\n                        m_report.println(e2);\n                        continue;\n                    }\n                    // try unmarshaling to xml page\n                    try {\n                        page = CmsXmlPageFactory.unmarshal(getCms(), file);\n                    } catch (CmsXmlException e) {\n                        m_report.println(e);\n                        continue;\n                    }\n\n                    // check if the source element exists in the page\n                    if (!page.hasValue(getParamOldElement(), locale)) {\n                        m_report.println(Messages.get().container(Messages.RPT_NONEXISTANT_ELEM_1), I_CmsReport.C_FORMAT_NOTE);\n                        continue;\n                    }\n\n                    // check if the target element already exists in the page\n                    if (page.hasValue(getParamNewElement(), locale)) {\n                        // the page contains already the new element with speicific content. \n                        // renaming the old will invalid the xml page\n                        m_report.println(Messages.get().container(Messages.RPT_NEW_ELEM_EXISTS_0), I_CmsReport.C_FORMAT_NOTE);\n                        continue;\n                    }\n\n                    if (validateNewElement) {\n                        // check if the target element is valid for the template\n                        if (!isValidElement(page, getParamNewElement())) {\n                              m_report.println(Messages.get().container(Messages.RPT_INVALID_ARGUMENT_1, \n                                  getParamNewElement()), I_CmsReport.C_FORMAT_NOTE);\n                            continue;\n                        }\n                    }\n\n                    try {\n                        // rename the element from the old value to the new\n                        page.renameValue(getParamOldElement(), getParamNewElement(), locale);\n                        // write the page with the new content\n                        writePageAndReport(page, true);\n                    } catch (Throwable t) {\n                        LOG.error(t);\n                        m_report.println(t);\n                        continue;\n                    }\n\n                } catch (Throwable t) {\n                    LOG.error(t);\n                    m_report.println(t);\n                } finally {\n                    // finally do remove empty elements of the page\n                    // the remove operation is executed if the user has checked the specified checkbox and selected a template (NOT ALL)\n                    if (removeEmptyElements) {\n                        removeInValidElements(page, locale);\n                    }\n                }\n            }\n        }\n    }","commit_id":"fb56d215709f27eea7e6dd0136e180a758bc4555","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Analyzes xml page and removes any element if this is not valid for the specified template and has no content.<p>\n     * \n     * @param resources a list of xml pages\n     * @param locale the locale\n     */\n    private void removeInValidElements(CmsXmlPage page, Locale locale) {\n\n        if (page == null) {\n            return;\n        }\n\n        if (C_ALL.equals(getParamTemplate())) {\n            return;\n        }\n\n        // get all elements of this page\n        List pageElements = page.getNames(locale);\n        if (pageElements != null) {\n            Iterator i = pageElements.iterator();\n            while (i.hasNext()) {\n                String currElement = (String)i.next();\n                // remove current element only is invalid and has no content \n                if (!isValidElement(currElement) && isEmptyElement(page, currElement, locale)) {\n                    page.removeValue(currElement, locale);\n                    try {\n                        writePageAndReport(page, false);\n                        m_report.println(\" \"\n                            + m_report.key(\"report.dots\")\n                            + \"invalid empty element \"\n                            + currElement\n                            + \" removed\", I_CmsReport.C_FORMAT_NOTE);\n                    } catch (CmsException e) {\n                        // ignore\n                    }\n                }\n            }\n        }\n    }","id":99218,"modified_method":"/**\n     * Analyzes xml page and removes any element if this is not valid for the specified template and has no content.<p>\n     * \n     * @param resources a list of xml pages\n     * @param locale the locale\n     */\n    private void removeInValidElements(CmsXmlPage page, Locale locale) {\n\n        if (page == null) {\n            return;\n        }\n\n        if (C_ALL.equals(getParamTemplate())) {\n            return;\n        }\n\n        // get all elements of this page\n        List pageElements = page.getNames(locale);\n        if (pageElements != null) {\n            Iterator i = pageElements.iterator();\n            while (i.hasNext()) {\n                String currElement = (String)i.next();\n                // remove current element only is invalid and has no content \n                if (!isValidElement(currElement) && isEmptyElement(page, currElement, locale)) {\n                    page.removeValue(currElement, locale);\n                    try {\n                        writePageAndReport(page, false);\n                        m_report.println(Messages.get().container(Messages.RPT_REMOVE_INVALID_EMPTY_ELEM_1, \n                            currElement), I_CmsReport.C_FORMAT_NOTE);\n                    } catch (CmsException e) {\n                        // ignore\n                    }\n                }\n            }\n        }\n    }","commit_id":"fb56d215709f27eea7e6dd0136e180a758bc4555","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Copies all  HTML files to the VFS.<p>\n     * \n     * @param startfolder startfolder the folder to start with\n     * @throws CmsException if something goes wrong\n     */\n    private void copyHtmlFiles(String startfolder) throws Exception {\n\n        try {\n            File folder = new File(startfolder);\n            // get all subresources\n            File[] subresources = folder.listFiles();\n            // now loop through all subresources \n            for (int i = 0; i < subresources.length; i++) {\n                // if the subresource is a folder, get all subresources of it as well          \n                if (subresources[i].isDirectory()) {\n                    // first, create the folder in the VFS    \n                    Hashtable properties = new Hashtable();\n                    createFolder(subresources[i].getAbsolutePath(), i, properties);\n                    // now process all rescources inside of the folder\n                    copyHtmlFiles(subresources[i].getAbsolutePath());\n                } else {\n                    // create a new file in the VFS      \n                    String vfsFileName = (String)m_fileIndex.get(subresources[i].getAbsolutePath().replace('\\\\', '/'));\n                    // check if this is an Html file, do only import and parse those\n                    int type = getFileType(vfsFileName);\n                    if (CmsResourceTypePlain.getStaticTypeId() == type) {\n                        Hashtable properties = new Hashtable();\n                        // the subresource is a file, so start the parsing process\n                        String content = new String();\n                        try {\n                            content = parseHtmlFile(subresources[i], properties);\n                        } catch (CmsException e) {\n\n                            m_report.println(\" \" + m_report.key(\"report.error\")+\" \"+ vfsFileName + \" \" + e, I_CmsReport.C_FORMAT_ERROR);\n                            m_report.println(\" \" + e, I_CmsReport.C_FORMAT_ERROR);\n\n                        }\n                        properties.put(\"template\", m_template);\n\n                        // create the file in the VFS\n                        createFile(subresources[i].getAbsolutePath(), i, content, properties);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }","id":99219,"modified_method":"/**\n     * Copies all  HTML files to the VFS.<p>\n     * \n     * @param startfolder startfolder the folder to start with\n     * @throws CmsException if something goes wrong\n     */\n    private void copyHtmlFiles(String startfolder) throws Exception {\n\n        try {\n            File folder = new File(startfolder);\n            // get all subresources\n            File[] subresources = folder.listFiles();\n            // now loop through all subresources \n            for (int i = 0; i < subresources.length; i++) {\n                // if the subresource is a folder, get all subresources of it as well          \n                if (subresources[i].isDirectory()) {\n                    // first, create the folder in the VFS    \n                    Hashtable properties = new Hashtable();\n                    createFolder(subresources[i].getAbsolutePath(), i, properties);\n                    // now process all rescources inside of the folder\n                    copyHtmlFiles(subresources[i].getAbsolutePath());\n                } else {\n                    // create a new file in the VFS      \n                    String vfsFileName = (String)m_fileIndex.get(subresources[i].getAbsolutePath().replace('\\\\', '/'));\n                    // check if this is an Html file, do only import and parse those\n                    int type = getFileType(vfsFileName);\n                    if (CmsResourceTypePlain.getStaticTypeId() == type) {\n                        Hashtable properties = new Hashtable();\n                        // the subresource is a file, so start the parsing process\n                        String content = new String();\n                        try {\n                            content = parseHtmlFile(subresources[i], properties);\n                        } catch (CmsException e) {\n                            m_report.println(e);\n                        }\n                        properties.put(\"template\", m_template);\n\n                        // create the file in the VFS\n                        createFile(subresources[i].getAbsolutePath(), i, content, properties);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            LOG.error(e);\n        }\n    }","commit_id":"fb56d215709f27eea7e6dd0136e180a758bc4555","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates new HtmlImport Object with http request parameters.<p>\n     * \n     * @param cms the current CmsJspActionElement  \n     * @param request the http servlet request\n     * @param wp reference to the workplace\n     */\n    public CmsHtmlImport(CmsJspActionElement cms, HttpServletRequest request, CmsWorkplace wp) {\n\n        this(\n            cms,\n            request.getParameter(\"inputDir\"),\n            request.getParameter(\"destinationDir\"),\n            request.getParameter(\"imageGallery\"),\n            request.getParameter(\"linkGallery\"),\n            request.getParameter(\"downloadGallery\"),\n            request.getParameter(\"template\"),\n            request.getParameter(\"element\"),\n            request.getParameter(\"locale\"),\n            request.getParameter(\"encoding\"),\n            request.getParameter(\"startPattern\"),\n            request.getParameter(\"endPattern\"),\n            request.getParameter(\"overwrite\"),\n            wp);\n    }","id":99220,"modified_method":"/**\n     * Creates new HtmlImport Object with http request parameters.<p>\n     * \n     * @param cms the current CmsJspActionElement  \n     * @param request the http servlet request\n     */\n    public CmsHtmlImport(CmsJspActionElement cms, HttpServletRequest request) {\n\n        this(\n            cms,\n            request.getParameter(\"inputDir\"),\n            request.getParameter(\"destinationDir\"),\n            request.getParameter(\"imageGallery\"),\n            request.getParameter(\"linkGallery\"),\n            request.getParameter(\"downloadGallery\"),\n            request.getParameter(\"template\"),\n            request.getParameter(\"element\"),\n            request.getParameter(\"locale\"),\n            request.getParameter(\"encoding\"),\n            request.getParameter(\"startPattern\"),\n            request.getParameter(\"endPattern\"),\n            request.getParameter(\"overwrite\"));\n    }","commit_id":"fb56d215709f27eea7e6dd0136e180a758bc4555","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Constructor, creates a new HtmlImport.<p>\n     * \n     * @param cms the current CmsJspActionElement \n     * @param inputDir the input directory in the \"real\" file system \n     * @param destinationDir the destination directory in the OpenCms VFS\n     * @param imageGallery the image gallery name\n     * @param linkGallery the external link gallery name\n     * @param downloadGallery the download gallery name\n     * @param template the template use for all pages\n     * @param element the element property use for all pages\n     * @param locale the full locale name \n     * @param encoding encoding used for importing all pages\n     * @param startPattern the start pattern definition for content extracting\n     * @param endPattern the end pattern definition for content extracting \n     * @param overwrite the overwrite mode\n     * @param wp reference to the workplace\n     */\n    public CmsHtmlImport(\n        CmsJspActionElement cms,\n        String inputDir,\n        String destinationDir,\n        String imageGallery,\n        String linkGallery,\n        String downloadGallery,\n        String template,\n        String element,\n        String locale,\n        String encoding,\n        String startPattern,\n        String endPattern,\n        String overwrite,\n        CmsWorkplace wp) {\n\n        m_wp = wp;\n        if (inputDir == null) {\n            inputDir = \"\";\n        }\n        if (destinationDir == null) {\n            destinationDir = \"/\";\n        }\n        if (imageGallery == null) {\n            imageGallery = \"\";\n        }\n        if (linkGallery == null) {\n            linkGallery = \"\";\n        }\n        if (downloadGallery == null) {\n            downloadGallery = \"\";\n        }\n        if (template == null) {\n            template = \"\";\n        }\n        if (element == null) {\n            element = \"body\";\n        }\n        if (encoding == null) {\n            encoding = \"\";\n        }\n        if (startPattern == null) {\n            startPattern = \"\";\n        }\n        if (endPattern == null) {\n            endPattern = \"\";\n        }\n        if (overwrite == null) {\n            overwrite = \"checked\";\n        }\n\n        // store all member variables\n        m_cms = cms;\n        m_cmsObject = m_cms.getCmsObject();\n        m_locale = CmsLocaleManager.getLocale(locale);\n        if (m_locale == null) {\n            m_locale = m_cms.getRequestContext().getLocale();\n        }\n        // body element should be set by html-form\n        m_inputDir = inputDir.trim();\n\n        // cut of a trailing '/' or '\\'\n        if (m_inputDir.endsWith(\"/\") || m_inputDir.endsWith(\"\\\\\")) {\n            m_inputDir = m_inputDir.substring(0, m_inputDir.length() - 1);\n        }\n\n        m_destinationDir = destinationDir.trim();\n        if (!m_destinationDir.endsWith(I_CmsConstants.C_FOLDER_SEPARATOR)) {\n            m_destinationDir += I_CmsConstants.C_FOLDER_SEPARATOR;\n        }\n\n        m_imageGallery = imageGallery.trim();\n        if (!m_imageGallery.endsWith(I_CmsConstants.C_FOLDER_SEPARATOR)) {\n            m_imageGallery += I_CmsConstants.C_FOLDER_SEPARATOR;\n        }\n        m_linkGallery = linkGallery.trim();\n        if (!m_linkGallery.endsWith(I_CmsConstants.C_FOLDER_SEPARATOR)) {\n            m_linkGallery += I_CmsConstants.C_FOLDER_SEPARATOR;\n        }\n        m_downloadGallery = downloadGallery.trim();\n        if (!m_downloadGallery.endsWith(I_CmsConstants.C_FOLDER_SEPARATOR)) {\n            m_downloadGallery += I_CmsConstants.C_FOLDER_SEPARATOR;\n        }\n\n        m_template = template;\n        m_element = element;\n        m_inputEncoding = encoding;\n\n        if (CmsStringUtil.isEmpty(m_inputEncoding)) {\n            m_inputEncoding = CmsJspLoader.C_DEFAULT_JSP_ENCODING;\n        }\n        m_startPattern = startPattern;\n        m_endPattern = endPattern;\n\n        m_overwrite = overwrite.trim();\n        if (m_overwrite.equals(\"checked\")) {\n            m_overwriteMode = true;\n        } else {\n            m_overwriteMode = false;\n        }\n\n        // create all other required member objects\n        m_fileIndex = new HashMap();\n        m_externalLinks = new HashSet();\n        m_imageInfo = new HashMap();\n        m_extensions = OpenCms.getResourceManager().getExtensionMapping();\n        m_htmlConverter = new CmsHtmlImportConverter(this, false);\n        m_baseUrl = null;\n        try {\n            m_baseUrl = new URL(\"file://\");\n        } catch (MalformedURLException e) {\n            // this won't happen\n        }\n    }","id":99221,"modified_method":"/**\n     * Constructor, creates a new HtmlImport.<p>\n     * \n     * @param cms the current CmsJspActionElement \n     * @param inputDir the input directory in the \"real\" file system \n     * @param destinationDir the destination directory in the OpenCms VFS\n     * @param imageGallery the image gallery name\n     * @param linkGallery the external link gallery name\n     * @param downloadGallery the download gallery name\n     * @param template the template use for all pages\n     * @param element the element property use for all pages\n     * @param locale the full locale name \n     * @param encoding encoding used for importing all pages\n     * @param startPattern the start pattern definition for content extracting\n     * @param endPattern the end pattern definition for content extracting \n     * @param overwrite the overwrite mode\n     */\n    public CmsHtmlImport(\n        CmsJspActionElement cms,\n        String inputDir,\n        String destinationDir,\n        String imageGallery,\n        String linkGallery,\n        String downloadGallery,\n        String template,\n        String element,\n        String locale,\n        String encoding,\n        String startPattern,\n        String endPattern,\n        String overwrite) {\n\n        if (inputDir == null) {\n            inputDir = \"\";\n        }\n        if (destinationDir == null) {\n            destinationDir = \"/\";\n        }\n        if (imageGallery == null) {\n            imageGallery = \"\";\n        }\n        if (linkGallery == null) {\n            linkGallery = \"\";\n        }\n        if (downloadGallery == null) {\n            downloadGallery = \"\";\n        }\n        if (template == null) {\n            template = \"\";\n        }\n        if (element == null) {\n            element = \"body\";\n        }\n        if (encoding == null) {\n            encoding = \"\";\n        }\n        if (startPattern == null) {\n            startPattern = \"\";\n        }\n        if (endPattern == null) {\n            endPattern = \"\";\n        }\n        if (overwrite == null) {\n            overwrite = \"checked\";\n        }\n\n        // store all member variables\n        m_cms = cms;\n        m_cmsObject = m_cms.getCmsObject();\n        m_locale = CmsLocaleManager.getLocale(locale);\n        if (m_locale == null) {\n            m_locale = m_cms.getRequestContext().getLocale();\n        }\n        // body element should be set by html-form\n        m_inputDir = inputDir.trim();\n\n        // cut of a trailing '/' or '\\'\n        if (m_inputDir.endsWith(\"/\") || m_inputDir.endsWith(\"\\\\\")) {\n            m_inputDir = m_inputDir.substring(0, m_inputDir.length() - 1);\n        }\n\n        m_destinationDir = destinationDir.trim();\n        if (!m_destinationDir.endsWith(I_CmsConstants.C_FOLDER_SEPARATOR)) {\n            m_destinationDir += I_CmsConstants.C_FOLDER_SEPARATOR;\n        }\n\n        m_imageGallery = imageGallery.trim();\n        if (!m_imageGallery.endsWith(I_CmsConstants.C_FOLDER_SEPARATOR)) {\n            m_imageGallery += I_CmsConstants.C_FOLDER_SEPARATOR;\n        }\n        m_linkGallery = linkGallery.trim();\n        if (!m_linkGallery.endsWith(I_CmsConstants.C_FOLDER_SEPARATOR)) {\n            m_linkGallery += I_CmsConstants.C_FOLDER_SEPARATOR;\n        }\n        m_downloadGallery = downloadGallery.trim();\n        if (!m_downloadGallery.endsWith(I_CmsConstants.C_FOLDER_SEPARATOR)) {\n            m_downloadGallery += I_CmsConstants.C_FOLDER_SEPARATOR;\n        }\n\n        m_template = template;\n        m_element = element;\n        m_inputEncoding = encoding;\n\n        if (CmsStringUtil.isEmpty(m_inputEncoding)) {\n            m_inputEncoding = CmsJspLoader.C_DEFAULT_JSP_ENCODING;\n        }\n        m_startPattern = startPattern;\n        m_endPattern = endPattern;\n\n        m_overwrite = overwrite.trim();\n        if (m_overwrite.equals(\"checked\")) {\n            m_overwriteMode = true;\n        } else {\n            m_overwriteMode = false;\n        }\n\n        // create all other required member objects\n        m_fileIndex = new HashMap();\n        m_externalLinks = new HashSet();\n        m_imageInfo = new HashMap();\n        m_extensions = OpenCms.getResourceManager().getExtensionMapping();\n        m_htmlConverter = new CmsHtmlImportConverter(this, false);\n        m_baseUrl = null;\n        try {\n            m_baseUrl = new URL(\"file://\");\n        } catch (MalformedURLException e) {\n            // this won't happen\n        }\n    }","commit_id":"fb56d215709f27eea7e6dd0136e180a758bc4555","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates a folder in the VFS.<p>\n     * \n     * @param foldername the complete foldername in the real file system\n     * @param position the default nav pos of this folder\n     * @param properties the file properties\n     */\n    private void createFolder(String foldername, int position, Hashtable properties) {\n\n        String vfsFolderName = (String)m_fileIndex.get(foldername.replace('\\\\', '/'));\n\n        m_report.print(m_wp.key(\"htmlimport.report.createfolder\") + vfsFolderName, I_CmsReport.C_FORMAT_NOTE);\n        m_report.print(m_report.key(\"report.dots\"));\n\n        if (vfsFolderName != null) {\n            String path = vfsFolderName.substring(0, vfsFolderName.substring(0, vfsFolderName.length() - 1)\n                .lastIndexOf(\"/\"));\n            String folder = vfsFolderName.substring(path.length(), vfsFolderName.length());\n            try {\n                // try to find a meta.properties file in the folder\n                String propertyFileName = foldername + File.separator + C_META_PROPERTIES;\n\n                boolean metaPropertiesFound = false;\n                ExtendedProperties propertyFile = new ExtendedProperties();\n                try {\n                    propertyFile.load(new FileInputStream(new File(propertyFileName)));\n                    metaPropertiesFound = true;\n                } catch (Exception e1) {\n                    // do nothing if the propertyfile could not be loaded since it is not required\n                    // that such s file does exist\n                }\n                // now copy all values from the propertyfile to the already found properties of the\n                // new folder in OpenCms\n                // only do this if we have found a meta.properties file          \n                if (metaPropertiesFound) {\n                    Enumeration enu = propertyFile.keys();\n                    String property = \"\";\n                    while (enu.hasMoreElements()) {\n                        // get property and value\n                        try {\n                            property = (String)enu.nextElement();\n                            String propertyvalue = (String)propertyFile.get(property);\n                            // copy to the properties of the OpenCms folder\n                            properties.put(property, propertyvalue);\n                        } catch (Exception e2) {\n                            // just skip this property if it could ne be read.\n                            e2.printStackTrace();\n                        }\n                    }\n\n                    // check if we have to set the navpos property.\n                    if (properties.get(I_CmsConstants.C_PROPERTY_NAVPOS) == null) {\n                        // set the position in the folder as navpos\n                        // we have to add one to the postion, since it is counted from 0\n                        properties.put(I_CmsConstants.C_PROPERTY_NAVPOS, (position + 1) + \"\");\n                    }\n                    // check if we have to set the navpos property.\n                    if (properties.get(I_CmsConstants.C_PROPERTY_NAVTEXT) == null) {\n                        // set the foldername in the folder as navtext\n                        String navtext = folder.substring(1, 2).toUpperCase()\n                            + folder.substring(2, folder.length() - 1);\n                        properties.put(I_CmsConstants.C_PROPERTY_NAVTEXT, navtext);\n                    }\n                } else {\n                    // if there was no meta.properties file, no properties should be added to the\n                    // folder\n                    properties = new Hashtable();\n                }\n                // try to read the folder, it its there we must not create it again\n                try {\n                    m_cmsObject.readFolder(path + folder);\n                    m_cmsObject.lockResource(path + folder);\n                } catch (CmsException e1) {\n                    // the folder was not there, so create it\n                    m_cmsObject.createResource(path + folder, CmsResourceTypeFolder.getStaticTypeId());\n                }\n                // create all properties and put them in an ArrayList\n                Enumeration enu = properties.keys();\n                List propertyList = new ArrayList();\n                while (enu.hasMoreElements()) {\n                    // get property and value\n                    String propertyKey = (String)enu.nextElement();\n                    String propertyVal = (String)properties.get(propertyKey);\n                    CmsProperty property = new CmsProperty(propertyKey, propertyVal, propertyVal);\n                    // create implicitly if Property doesn't exist already\n                    property.setAutoCreatePropertyDefinition(true);\n                    // add new property to the list\n                    propertyList.add(property);\n                }\n                // try to write the property Objects\n                try {\n                    m_cmsObject.writePropertyObjects(path + folder, propertyList);\n                } catch (CmsException e1) {\n                    e1.printStackTrace();\n                }\n                m_report.println(m_report.key(\"report.ok\"), I_CmsReport.C_FORMAT_OK);\n            } catch (CmsException e) {\n                m_report.println(\" \" + m_report.key(\"report.error\") + e, I_CmsReport.C_FORMAT_ERROR);\n                e.printStackTrace();\n            }\n        }\n    }","id":99222,"modified_method":"/**\n     * Creates a folder in the VFS.<p>\n     * \n     * @param foldername the complete foldername in the real file system\n     * @param position the default nav pos of this folder\n     * @param properties the file properties\n     */\n    private void createFolder(String foldername, int position, Hashtable properties) {\n\n        String vfsFolderName = (String)m_fileIndex.get(foldername.replace('\\\\', '/'));\n        \n        m_report.print(Messages.get().container(Messages.RPT_CREATE_FOLDER_0), I_CmsReport.C_FORMAT_NOTE);\n        m_report.print(org.opencms.report.Messages.get().container(org.opencms.report.Messages.RPT_ARGUMENT_1, vfsFolderName));\n        m_report.print(org.opencms.report.Messages.get().container(org.opencms.report.Messages.RPT_DOTS_0));\n\n        if (vfsFolderName != null) {\n            String path = vfsFolderName.substring(0, vfsFolderName.substring(0, vfsFolderName.length() - 1)\n                .lastIndexOf(\"/\"));\n            String folder = vfsFolderName.substring(path.length(), vfsFolderName.length());\n            try {\n                // try to find a meta.properties file in the folder\n                String propertyFileName = foldername + File.separator + C_META_PROPERTIES;\n\n                boolean metaPropertiesFound = false;\n                ExtendedProperties propertyFile = new ExtendedProperties();\n                try {\n                    propertyFile.load(new FileInputStream(new File(propertyFileName)));\n                    metaPropertiesFound = true;\n                } catch (Exception e1) {\n                    // do nothing if the propertyfile could not be loaded since it is not required\n                    // that such s file does exist\n                }\n                // now copy all values from the propertyfile to the already found properties of the\n                // new folder in OpenCms\n                // only do this if we have found a meta.properties file          \n                if (metaPropertiesFound) {\n                    Enumeration enu = propertyFile.keys();\n                    String property = \"\";\n                    while (enu.hasMoreElements()) {\n                        // get property and value\n                        try {\n                            property = (String)enu.nextElement();\n                            String propertyvalue = (String)propertyFile.get(property);\n                            // copy to the properties of the OpenCms folder\n                            properties.put(property, propertyvalue);\n                        } catch (Exception e2) {\n                            // just skip this property if it could ne be read.\n                            e2.printStackTrace();\n                        }\n                    }\n\n                    // check if we have to set the navpos property.\n                    if (properties.get(I_CmsConstants.C_PROPERTY_NAVPOS) == null) {\n                        // set the position in the folder as navpos\n                        // we have to add one to the postion, since it is counted from 0\n                        properties.put(I_CmsConstants.C_PROPERTY_NAVPOS, (position + 1) + \"\");\n                    }\n                    // check if we have to set the navpos property.\n                    if (properties.get(I_CmsConstants.C_PROPERTY_NAVTEXT) == null) {\n                        // set the foldername in the folder as navtext\n                        String navtext = folder.substring(1, 2).toUpperCase()\n                            + folder.substring(2, folder.length() - 1);\n                        properties.put(I_CmsConstants.C_PROPERTY_NAVTEXT, navtext);\n                    }\n                } else {\n                    // if there was no meta.properties file, no properties should be added to the\n                    // folder\n                    properties = new Hashtable();\n                }\n                // try to read the folder, it its there we must not create it again\n                try {\n                    m_cmsObject.readFolder(path + folder);\n                    m_cmsObject.lockResource(path + folder);\n                } catch (CmsException e1) {\n                    // the folder was not there, so create it\n                    m_cmsObject.createResource(path + folder, CmsResourceTypeFolder.getStaticTypeId());\n                }\n                // create all properties and put them in an ArrayList\n                Enumeration enu = properties.keys();\n                List propertyList = new ArrayList();\n                while (enu.hasMoreElements()) {\n                    // get property and value\n                    String propertyKey = (String)enu.nextElement();\n                    String propertyVal = (String)properties.get(propertyKey);\n                    CmsProperty property = new CmsProperty(propertyKey, propertyVal, propertyVal);\n                    // create implicitly if Property doesn't exist already\n                    property.setAutoCreatePropertyDefinition(true);\n                    // add new property to the list\n                    propertyList.add(property);\n                }\n                // try to write the property Objects\n                try {\n                    m_cmsObject.writePropertyObjects(path + folder, propertyList);\n                } catch (CmsException e1) {\n                    e1.printStackTrace();\n                }\n                m_report.println(org.opencms.report.Messages.get().container(\n                    org.opencms.report.Messages.RPT_OK_0), I_CmsReport.C_FORMAT_OK);\n            } catch (CmsException e) {\n                m_report.println(e);\n                LOG.error(e);\n            }\n        }\n    }","commit_id":"fb56d215709f27eea7e6dd0136e180a758bc4555","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Builds an index of all files to be imported and determines their new names in the OpenCms.<p>\n     * @param startfolder the folder to start with\n     */\n    private void buildIndex(String startfolder) throws Exception {\n\n        File folder = new File(startfolder);\n        // get all subresources\n\n        File[] subresources = folder.listFiles();\n        // now loop through all subresources and add them to the index list\n        for (int i = 0; i < subresources.length; i++) {\n            try {\n                String relativeFSName = subresources[i].getAbsolutePath().substring(m_inputDir.length() + 1);\n                String absoluteVFSName = getVfsName(relativeFSName, subresources[i].getName(), subresources[i].isFile());\n                m_report.print(m_wp.key(\"htmlimport.report.createindex\") + relativeFSName.replace('\\\\', '/') , I_CmsReport.C_FORMAT_NOTE);\n                m_report.print(m_report.key(\"report.dots\"));\n                m_report.print(\"-> \" + absoluteVFSName, I_CmsReport.C_FORMAT_NOTE);\n                m_report.print(m_report.key(\"report.dots\"));\n                m_fileIndex.put(subresources[i].getAbsolutePath().replace('\\\\', '/'), absoluteVFSName);\n                m_report.println(m_report.key(\"report.ok\"), I_CmsReport.C_FORMAT_OK);\n                // if the subresource is a folder, get all subresources of it as well\n                if (subresources[i].isDirectory()) {\n                    buildIndex(subresources[i].getAbsolutePath());\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n                m_report.println(\" \" + m_report.key(\"report.error\") + e, I_CmsReport.C_FORMAT_ERROR);\n            }\n        }\n    }","id":99223,"modified_method":"/**\n     * Builds an index of all files to be imported and determines their new names in the OpenCms.<p>\n     * @param startfolder the folder to start with\n     */\n    private void buildIndex(String startfolder) throws Exception {\n\n        File folder = new File(startfolder);\n        // get all subresources\n\n        File[] subresources = folder.listFiles();\n        // now loop through all subresources and add them to the index list\n        for (int i = 0; i < subresources.length; i++) {\n            try {\n                \n                String relativeFSName = subresources[i].getAbsolutePath().substring(m_inputDir.length() + 1);\n                String absoluteVFSName = getVfsName(relativeFSName, subresources[i].getName(), subresources[i].isFile());\n                m_report.print(Messages.get().container(Messages.RPT_CREATE_INDEX_0), I_CmsReport.C_FORMAT_NOTE);\n                m_report.print(org.opencms.report.Messages.get().container(org.opencms.report.Messages.RPT_ARGUMENT_1, \n                    relativeFSName.replace('\\\\', '/')));\n                m_report.print(org.opencms.report.Messages.get().container(org.opencms.report.Messages.RPT_DOTS_0));\n                m_report.print(Messages.get().container(Messages.RPT_ARROW_RIGHT_0), I_CmsReport.C_FORMAT_NOTE);\n                m_report.print(org.opencms.report.Messages.get().container(\n                    org.opencms.report.Messages.RPT_ARGUMENT_1, absoluteVFSName));\n                m_report.print(org.opencms.report.Messages.get().container(org.opencms.report.Messages.RPT_DOTS_0));\n                m_fileIndex.put(subresources[i].getAbsolutePath().replace('\\\\', '/'), absoluteVFSName);\n                // if the subresource is a folder, get all subresources of it as well\n                if (subresources[i].isDirectory()) {\n                    buildIndex(subresources[i].getAbsolutePath());\n                }\n                m_report.println(org.opencms.report.Messages.get().container(\n                    org.opencms.report.Messages.RPT_OK_0), I_CmsReport.C_FORMAT_OK);\n            } catch (Exception e) {\n                LOG.error(e);\n                m_report.println(e);\n            }\n        }\n    }","commit_id":"fb56d215709f27eea7e6dd0136e180a758bc4555","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Imports all resources from the real filesystem, stores them into the correct locations\n     * in the OpenCms VFS and modifies all links. This method is called form the JSP to start the\n     * import process.<p>\n     * @param report StringBuffer for reporting\n     * @throws Exception if something goes wrong\n     */\n    public void startImport(I_CmsReport report) throws Exception {\n\n        try {\n            m_report = report;\n            m_report.println(m_wp.key(\"htmlimport.report.start\"), I_CmsReport.C_FORMAT_HEADLINE);\n            // first build the index of all resources\n            buildIndex(m_inputDir);\n            // copy and parse all html files first. during the copy process we will collect all \n            // required data for downloads and images\n            copyHtmlFiles(m_inputDir);\n            // now copy the other files\n            copyOtherFiles(m_inputDir);\n            // finally create all the external links    \n            createExternalLinks();\n            m_report.println(m_wp.key(\"htmlimport.report.end\"), I_CmsReport.C_FORMAT_HEADLINE);\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            // clear memory\n            clear();\n        }\n\n    }","id":99224,"modified_method":"/**\n     * Imports all resources from the real filesystem, stores them into the correct locations\n     * in the OpenCms VFS and modifies all links. This method is called form the JSP to start the\n     * import process.<p>\n     * @param report StringBuffer for reporting\n     * @throws Exception if something goes wrong\n     */\n    public void startImport(I_CmsReport report) throws Exception {\n\n        try {\n            m_report = report;\n            m_report.println(Messages.get().container(Messages.RPT_HTML_IMPORT_BEGIN_0), I_CmsReport.C_FORMAT_HEADLINE);\n            \n            // first build the index of all resources\n            buildIndex(m_inputDir);\n            // copy and parse all html files first. during the copy process we will collect all \n            // required data for downloads and images\n            copyHtmlFiles(m_inputDir);\n            // now copy the other files\n            copyOtherFiles(m_inputDir);\n            // finally create all the external links    \n            createExternalLinks();\n            m_report.println(Messages.get().container(Messages.RPT_HTML_IMPORT_END_0), I_CmsReport.C_FORMAT_HEADLINE);\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            // clear memory\n            clear();\n        }\n\n    }","commit_id":"fb56d215709f27eea7e6dd0136e180a758bc4555","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates a file in the VFS.<p>\n     * \n     * @param filename the complete filename in the real file system\n     * @param position the default nav pos of this folder\n     * @param content the html content of the file\n     * @param properties the file properties\n     */\n    private void createFile(String filename, int position, String content, Hashtable properties) {\n\n        String vfsFileName = (String)m_fileIndex.get(filename.replace('\\\\', '/'));\n\n        if (vfsFileName != null) {\n            try {\n                m_report.print(m_wp.key(\"htmlimport.report.createfile\") + vfsFileName, I_CmsReport.C_FORMAT_NOTE);\n                m_report.print(m_report.key(\"report.dots\"));\n\n                // check if we have to set the navpos property.\n                if ((properties.get(I_CmsConstants.C_PROPERTY_NAVPOS) == null)\n                    && (properties.get(I_CmsConstants.C_PROPERTY_NAVTEXT) != null)) {\n                    // set the position in the folder as navpos\n                    // we have to add one to the postion, since it is counted from 0\n                    properties.put(I_CmsConstants.C_PROPERTY_NAVPOS, (position + 1) + \"\");\n                }\n\n                // create new xml page\n                CmsXmlPage page = new CmsXmlPage(m_locale, OpenCms.getSystemInfo().getDefaultEncoding());\n                page.addValue(m_element, m_locale);\n                page.setStringValue(m_cmsObject, m_element, m_locale, content);\n\n                // check links\n                CmsLinkTable linkTable = page.getLinkTable(m_element, m_locale);\n                Iterator i = linkTable.iterator();\n                while (i.hasNext()) {\n                    CmsLink link = (CmsLink)i.next();\n                    String target = link.getTarget();\n                    // do only update internal links \n                    if (target.indexOf(\"://\") == 0) {\n                        //if (!target.startsWith(\"http\") && !target.startsWith(\"mailto\")) {\n                        target = m_cmsObject.getRequestContext().getFileTranslator().translateResource(target);\n                        // update link\n                        link.updateLink(target, link.getAnchor(), link.getQuery());\n                    }\n                }\n                // marshal xml page and get the content\n                byte[] contentByteArray = page.marshal();\n                List oldProperties = new ArrayList();\n\n                if (!m_overwriteMode) {\n                    m_cmsObject.createResource(\n                        vfsFileName,\n                        CmsResourceTypeXmlPage.getStaticTypeId(),\n                        contentByteArray,\n                        new ArrayList());\n                } else {\n                    try {\n                        // try if the file is there\n                        oldProperties = m_cmsObject.readPropertyObjects(vfsFileName, false);\n                        CmsLock lock = m_cmsObject.getLock(vfsFileName);\n                        if (lock.getType() != CmsLock.C_TYPE_EXCLUSIVE) {\n                            m_cmsObject.lockResource(vfsFileName);\n                        }\n                        m_cmsObject.deleteResource(vfsFileName, I_CmsConstants.C_DELETE_OPTION_PRESERVE_SIBLINGS);\n                    } catch (CmsException e) {\n                        // the file did not exist, so we do not have to delete it                      \n                    } finally {\n                        // create the new resource\n                        m_report.print(m_wp.key(\"htmlimport.report.overwrite\"), I_CmsReport.C_FORMAT_NOTE);\n                        m_report.print(m_report.key(\"report.dots\"));\n                        m_cmsObject.createResource(\n                            vfsFileName,\n                            CmsResourceTypeXmlPage.getStaticTypeId(),\n                            contentByteArray,\n                            new ArrayList());\n                    }\n                }\n                // create all properties and put them in an ArrayList\n                Enumeration en = properties.keys();\n                List propertyList = new ArrayList();\n                while (en.hasMoreElements()) {\n                    // get property and value\n                    String propertyKey = (String)en.nextElement();\n                    String propertyVal = (String)properties.get(propertyKey);\n                    // create new Property Object\n                    CmsProperty property = new CmsProperty(propertyKey, propertyVal, propertyVal);\n                    // create implicitly if Property doesn't exist already\n                    property.setAutoCreatePropertyDefinition(true);\n                    // add new property to the list\n                    propertyList.add(property);\n                }\n                // try to write the property\n                try {\n                    m_cmsObject.writePropertyObjects(vfsFileName, propertyList);\n                    // write the old properties if available\n                    m_cmsObject.writePropertyObjects(vfsFileName, oldProperties);\n                } catch (CmsException e1) {\n                    e1.printStackTrace();\n                }\n                m_report.println(m_report.key(\"report.ok\"), I_CmsReport.C_FORMAT_OK);\n            } catch (CmsException e) {\n                m_report.println(\" \" + m_report.key(\"report.error\") + e, I_CmsReport.C_FORMAT_ERROR);\n                e.printStackTrace();\n            }\n        }\n    }","id":99225,"modified_method":"/**\n     * Creates a file in the VFS.<p>\n     * \n     * @param filename the complete filename in the real file system\n     * @param position the default nav pos of this folder\n     * @param content the html content of the file\n     * @param properties the file properties\n     */\n    private void createFile(String filename, int position, String content, Hashtable properties) {\n\n        String vfsFileName = (String)m_fileIndex.get(filename.replace('\\\\', '/'));\n\n        if (vfsFileName != null) {\n            try {\n                \n                m_report.print(Messages.get().container(Messages.RPT_CREATE_FILE_0), I_CmsReport.C_FORMAT_NOTE);\n                m_report.print(org.opencms.report.Messages.get().container(org.opencms.report.Messages.RPT_ARGUMENT_1, vfsFileName));\n                m_report.print(org.opencms.report.Messages.get().container(org.opencms.report.Messages.RPT_DOTS_0));\n\n                // check if we have to set the navpos property.\n                if ((properties.get(I_CmsConstants.C_PROPERTY_NAVPOS) == null)\n                    && (properties.get(I_CmsConstants.C_PROPERTY_NAVTEXT) != null)) {\n                    // set the position in the folder as navpos\n                    // we have to add one to the postion, since it is counted from 0\n                    properties.put(I_CmsConstants.C_PROPERTY_NAVPOS, (position + 1) + \"\");\n                }\n\n                // create new xml page\n                CmsXmlPage page = new CmsXmlPage(m_locale, OpenCms.getSystemInfo().getDefaultEncoding());\n                page.addValue(m_element, m_locale);\n                page.setStringValue(m_cmsObject, m_element, m_locale, content);\n\n                // check links\n                CmsLinkTable linkTable = page.getLinkTable(m_element, m_locale);\n                Iterator i = linkTable.iterator();\n                while (i.hasNext()) {\n                    CmsLink link = (CmsLink)i.next();\n                    String target = link.getTarget();\n                    // do only update internal links \n                    if (target.indexOf(\"://\") == 0) {\n                        //if (!target.startsWith(\"http\") && !target.startsWith(\"mailto\")) {\n                        target = m_cmsObject.getRequestContext().getFileTranslator().translateResource(target);\n                        // update link\n                        link.updateLink(target, link.getAnchor(), link.getQuery());\n                    }\n                }\n                // marshal xml page and get the content\n                byte[] contentByteArray = page.marshal();\n                List oldProperties = new ArrayList();\n\n                if (!m_overwriteMode) {\n                    m_cmsObject.createResource(\n                        vfsFileName,\n                        CmsResourceTypeXmlPage.getStaticTypeId(),\n                        contentByteArray,\n                        new ArrayList());\n                } else {\n                    try {\n                        // try if the file is there\n                        oldProperties = m_cmsObject.readPropertyObjects(vfsFileName, false);\n                        CmsLock lock = m_cmsObject.getLock(vfsFileName);\n                        if (lock.getType() != CmsLock.C_TYPE_EXCLUSIVE) {\n                            m_cmsObject.lockResource(vfsFileName);\n                        }\n                        m_cmsObject.deleteResource(vfsFileName, I_CmsConstants.C_DELETE_OPTION_PRESERVE_SIBLINGS);\n                    } catch (CmsException e) {\n                        // the file did not exist, so we do not have to delete it                      \n                    } finally {\n                        // create the new resource\n                        m_report.print(Messages.get().container(Messages.RPT_OVERWRITE_0), I_CmsReport.C_FORMAT_NOTE);\n                        m_report.print(org.opencms.report.Messages.get().container(org.opencms.report.Messages.RPT_DOTS_0));\n                        m_cmsObject.createResource(\n                            vfsFileName,\n                            CmsResourceTypeXmlPage.getStaticTypeId(),\n                            contentByteArray,\n                            new ArrayList());\n                    }\n                }\n                // create all properties and put them in an ArrayList\n                Enumeration en = properties.keys();\n                List propertyList = new ArrayList();\n                while (en.hasMoreElements()) {\n                    // get property and value\n                    String propertyKey = (String)en.nextElement();\n                    String propertyVal = (String)properties.get(propertyKey);\n                    // create new Property Object\n                    CmsProperty property = new CmsProperty(propertyKey, propertyVal, propertyVal);\n                    // create implicitly if Property doesn't exist already\n                    property.setAutoCreatePropertyDefinition(true);\n                    // add new property to the list\n                    propertyList.add(property);\n                }\n                // try to write the property\n                try {\n                    m_cmsObject.writePropertyObjects(vfsFileName, propertyList);\n                    // write the old properties if available\n                    m_cmsObject.writePropertyObjects(vfsFileName, oldProperties);\n                } catch (CmsException e1) {\n                    e1.printStackTrace();\n                }\n                m_report.println(org.opencms.report.Messages.get().container(\n                    org.opencms.report.Messages.RPT_OK_0), I_CmsReport.C_FORMAT_OK);\n            } catch (CmsException e) {\n                m_report.println(e);\n                LOG.error(e);\n            }\n        }\n    }","commit_id":"fb56d215709f27eea7e6dd0136e180a758bc4555","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Copies all files except HTML files to the VFS.<p>\n     * \n     * @param startfolder startfolder the folder to start with\n     * @throws CmsException if something goes wrong\n     */\n    private void copyOtherFiles(String startfolder) {\n\n        try {\n            File folder = new File(startfolder);\n            // get all subresources\n            File[] subresources = folder.listFiles();\n            // now loop through all subresources \n            for (int i = 0; i < subresources.length; i++) {\n                // if the subresource is a folder, get all subresources of it as well\n                if (subresources[i].isDirectory()) {\n                    copyOtherFiles(subresources[i].getAbsolutePath());\n                } else {\n                    // do not import the \"meta.properties\" file\n                    if (!subresources[i].getName().equals(C_META_PROPERTIES)) {\n                        // create a new file in the VFS      \n                        String vfsFileName = (String)m_fileIndex.get(subresources[i].getAbsolutePath().replace('\\\\', '/'));    \n                        // get the file type of the FS file\n                        int type = getFileType(vfsFileName);\n                        if (CmsResourceTypePlain.getStaticTypeId() != type) {\n                            if (isExternal(vfsFileName)) {\n                                m_report.println(m_wp.key(\"htmlimport.report.skipexternal\") + subresources[i] +\" -> \"+vfsFileName, I_CmsReport.C_FORMAT_NOTE);\n                            } else {\n                                m_report.print(m_wp.key(\"htmlimport.report.import\")+vfsFileName, I_CmsReport.C_FORMAT_NOTE);\n                                m_report.print(m_report.key(\"report.dots\"));\n                                // get the content of the FS file\n                                byte[] content = getFileBytes(subresources[i]);\n                                // get the filename from the fileIndex list\n\n                                // check if there are some image infos stored for this resource\n                                List properties = new ArrayList();\n                                String altText = (String)m_imageInfo.get(subresources[i].getAbsolutePath().replace(\n                                    '\\\\',\n                                    '/'));\n                                CmsProperty property1 = new CmsProperty(\n                                    I_CmsConstants.C_PROPERTY_DESCRIPTION,\n                                    altText,\n                                    altText);\n                                CmsProperty property2 = new CmsProperty(\n                                    I_CmsConstants.C_PROPERTY_TITLE,\n                                    altText,\n                                    altText);\n                                // add them to the title and description property\n                                if (altText != null) {\n                                    properties.add(property1);\n                                    properties.add(property2);\n                                }\n                                // create the file\n                                if (!m_overwriteMode) {\n                                    m_cmsObject.createResource(vfsFileName, type, content, properties);\n                                } else {\n                                    try {\n                                        CmsLock lock = m_cmsObject.getLock(vfsFileName);\n                                        if (lock.getType() != CmsLock.C_TYPE_EXCLUSIVE) {\n                                            m_cmsObject.lockResource(vfsFileName);\n                                        }\n                                        m_cmsObject.deleteResource(\n                                            vfsFileName,\n                                            I_CmsConstants.C_DELETE_OPTION_PRESERVE_SIBLINGS);\n                                    } catch (CmsException e) {\n                                        // the file did not exist, so create it                                     \n                                    } finally {\n                                        m_cmsObject.createResource(vfsFileName, type, content, properties);\n                                    }\n                                    m_report.print(m_wp.key(\"htmlimport.report.overwrite\"), I_CmsReport.C_FORMAT_NOTE);\n                                    m_report.print(m_report.key(\"report.dots\"));\n                                }\n                                m_report.println(m_report.key(\"report.ok\"), I_CmsReport.C_FORMAT_OK);\n                            }\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n            m_report.println(\" \" + m_report.key(\"report.error\") + e, I_CmsReport.C_FORMAT_ERROR);\n        }\n    }","id":99226,"modified_method":"/**\n     * Copies all files except HTML files to the VFS.<p>\n     * \n     * @param startfolder startfolder the folder to start with\n     * @throws CmsException if something goes wrong\n     */\n    private void copyOtherFiles(String startfolder) {\n\n        try {\n            File folder = new File(startfolder);\n            // get all subresources\n            File[] subresources = folder.listFiles();\n            // now loop through all subresources \n            for (int i = 0; i < subresources.length; i++) {\n                // if the subresource is a folder, get all subresources of it as well\n                if (subresources[i].isDirectory()) {\n                    copyOtherFiles(subresources[i].getAbsolutePath());\n                } else {\n                    // do not import the \"meta.properties\" file\n                    if (!subresources[i].getName().equals(C_META_PROPERTIES)) {\n                        // create a new file in the VFS      \n                        String vfsFileName = (String)m_fileIndex.get(subresources[i].getAbsolutePath().replace('\\\\', '/'));    \n                        // get the file type of the FS file\n                        int type = getFileType(vfsFileName);\n                        if (CmsResourceTypePlain.getStaticTypeId() != type) {\n                            \n                            if (isExternal(vfsFileName)) {\n                                \n                                m_report.print(Messages.get().container(Messages.RPT_SKIP_EXTERNAL_0), I_CmsReport.C_FORMAT_NOTE);\n                                m_report.print(org.opencms.report.Messages.get().container(\n                                    org.opencms.report.Messages.RPT_ARGUMENT_1, subresources[i]));\n                                m_report.print(org.opencms.report.Messages.get().container(\n                                    org.opencms.report.Messages.RPT_DOTS_0));\n                                m_report.print(\n                                    Messages.get().container(Messages.RPT_ARROW_RIGHT_0), I_CmsReport.C_FORMAT_NOTE);\n                                m_report.println(org.opencms.report.Messages.get().container(\n                                    org.opencms.report.Messages.RPT_ARGUMENT_1, vfsFileName));\n                            } else {\n                                \n                                m_report.print(Messages.get().container(Messages.RPT_IMPORT_0), I_CmsReport.C_FORMAT_NOTE);\n                                m_report.print(org.opencms.report.Messages.get().container(org.opencms.report.Messages.RPT_ARGUMENT_1, vfsFileName));\n                                m_report.print(org.opencms.report.Messages.get().container(org.opencms.report.Messages.RPT_DOTS_0));\n                                \n                                // get the content of the FS file\n                                byte[] content = getFileBytes(subresources[i]);\n                                // get the filename from the fileIndex list\n\n                                // check if there are some image infos stored for this resource\n                                List properties = new ArrayList();\n                                String altText = (String)m_imageInfo.get(subresources[i].getAbsolutePath().replace(\n                                    '\\\\',\n                                    '/'));\n                                CmsProperty property1 = new CmsProperty(\n                                    I_CmsConstants.C_PROPERTY_DESCRIPTION,\n                                    altText,\n                                    altText);\n                                CmsProperty property2 = new CmsProperty(\n                                    I_CmsConstants.C_PROPERTY_TITLE,\n                                    altText,\n                                    altText);\n                                // add them to the title and description property\n                                if (altText != null) {\n                                    properties.add(property1);\n                                    properties.add(property2);\n                                }\n                                // create the file\n                                if (!m_overwriteMode) {\n                                    m_cmsObject.createResource(vfsFileName, type, content, properties);\n                                } else {\n                                    try {\n                                        CmsLock lock = m_cmsObject.getLock(vfsFileName);\n                                        if (lock.getType() != CmsLock.C_TYPE_EXCLUSIVE) {\n                                            m_cmsObject.lockResource(vfsFileName);\n                                        }\n                                        m_cmsObject.deleteResource(\n                                            vfsFileName,\n                                            I_CmsConstants.C_DELETE_OPTION_PRESERVE_SIBLINGS);\n                                    } catch (CmsException e) {\n                                        // the file did not exist, so create it                                     \n                                    } finally {\n                                        m_cmsObject.createResource(vfsFileName, type, content, properties);\n                                    }\n                                    \n                                    m_report.print(Messages.get().container(Messages.RPT_OVERWRITE_0), I_CmsReport.C_FORMAT_NOTE);\n                                    m_report.print(org.opencms.report.Messages.get().container(org.opencms.report.Messages.RPT_DOTS_0));\n                                }\n                                m_report.println(org.opencms.report.Messages.get().container(\n                                    org.opencms.report.Messages.RPT_OK_0), I_CmsReport.C_FORMAT_OK);\n                            }\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n            LOG.error(e);\n            m_report.println(e);\n        }\n    }","commit_id":"fb56d215709f27eea7e6dd0136e180a758bc4555","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Reads the content of an Html file from the real file system and parses it for link\n     * transformation.<p>\n     * \n     * @param  file the filein the real file system\n     * @param properties the file properties\n     * @return the modified Html code of the file\n     * @throws CmsException if something goes wrong\n     */\n    private String parseHtmlFile(File file, Hashtable properties) throws CmsException {\n\n        String parsedHtml = \"\";\n        try {\n\n            byte[] content = getFileBytes(file);\n\n            // use the correct encoding to get the string from the file bytes\n            String contentString = new String(content, m_inputEncoding);\n            // escape the string to remove all special chars\n            contentString = CmsEncoder.escapeNonAscii(contentString);\n            // we must substitute all occurences of \"&#\", otherwiese tidy would remove them\n            contentString = substitute(contentString, \"&#\", \"{subst}\");\n            // parse the content                  \n            parsedHtml = m_htmlConverter.convertHTML(\n                file.getAbsolutePath(),\n                contentString,\n                m_startPattern,\n                m_endPattern,\n                properties);\n            // resubstidute the converted HTML code\n            parsedHtml = substitute(parsedHtml, \"{subst}\", \"&#\");\n        } catch (Exception e) {\n            if (CmsLog.LOG.isWarnEnabled()) {\n                CmsLog.LOG.warn(e.getMessage());\n            }\n            e.printStackTrace();\n            throw new CmsImportExportException(Messages.get().container(Messages.ERR_HTMLIMPORT_PARSE_1, file.getAbsolutePath()), e);\n        }\n        return parsedHtml;\n    }","id":99227,"modified_method":"/**\n     * Reads the content of an Html file from the real file system and parses it for link\n     * transformation.<p>\n     * \n     * @param  file the filein the real file system\n     * @param properties the file properties\n     * @return the modified Html code of the file\n     * @throws CmsException if something goes wrong\n     */\n    private String parseHtmlFile(File file, Hashtable properties) throws CmsException {\n\n        String parsedHtml = \"\";\n        try {\n\n            byte[] content = getFileBytes(file);\n\n            // use the correct encoding to get the string from the file bytes\n            String contentString = new String(content, m_inputEncoding);\n            // escape the string to remove all special chars\n            contentString = CmsEncoder.escapeNonAscii(contentString);\n            // we must substitute all occurences of \"&#\", otherwiese tidy would remove them\n            contentString = substitute(contentString, \"&#\", \"{subst}\");\n            // parse the content                  \n            parsedHtml = m_htmlConverter.convertHTML(\n                file.getAbsolutePath(),\n                contentString,\n                m_startPattern,\n                m_endPattern,\n                properties);\n            // resubstidute the converted HTML code\n            parsedHtml = substitute(parsedHtml, \"{subst}\", \"&#\");\n        } catch (Exception e) {\n            CmsMessageContainer message = Messages.get().container(Messages.ERR_HTMLIMPORT_PARSE_1, file.getAbsolutePath());\n            LOG.error(message.key(), e);\n            throw new CmsImportExportException(message, e);\n        }\n        return parsedHtml;\n    }","commit_id":"fb56d215709f27eea7e6dd0136e180a758bc4555","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates all external links, which were found during the HTML-page processing.<p>\n     * \n     */\n    private void createExternalLinks() {\n\n        // loop through all links\n        Iterator i = m_externalLinks.iterator();\n        while (i.hasNext()) {\n            String linkUrl = (String)i.next();\n            String filename = linkUrl.substring(linkUrl.indexOf(\"://\") + 3, linkUrl.length());\n            filename = m_cmsObject.getRequestContext().getFileTranslator()\n                .translateResource(filename.replace('/', '-'));\n\n            m_report.print(m_wp.key(\"htmlimport.report.externallink\") + filename, I_CmsReport.C_FORMAT_NOTE);\n            m_report.print(m_report.key(\"report.dots\"));\n            List properties = new ArrayList();\n            CmsProperty property1 = new CmsProperty(I_CmsConstants.C_PROPERTY_TITLE, \"Link to \" + linkUrl, \"Link to \"\n                + linkUrl);\n            properties.add(property1);\n            try {\n                m_cmsObject.createResource(m_linkGallery + filename, CmsResourceTypePointer.getStaticTypeId(), linkUrl\n                    .getBytes(), properties);\n            } catch (CmsException e) {\n                // do nothing here, an exception will be thrown if this link already exisits                \n            }\n            m_report.println(m_report.key(\"report.ok\"), I_CmsReport.C_FORMAT_OK);\n        }\n    }","id":99228,"modified_method":"/**\n     * Creates all external links, which were found during the HTML-page processing.<p>\n     * \n     */\n    private void createExternalLinks() {\n\n        // loop through all links\n        Iterator i = m_externalLinks.iterator();\n        while (i.hasNext()) {\n            String linkUrl = (String)i.next();\n            String filename = linkUrl.substring(linkUrl.indexOf(\"://\") + 3, linkUrl.length());\n            filename = m_cmsObject.getRequestContext().getFileTranslator()\n                .translateResource(filename.replace('/', '-'));\n\n            m_report.print(Messages.get().container(Messages.RPT_CREATE_EXTERNAL_LINK_0), I_CmsReport.C_FORMAT_NOTE);\n            m_report.print(org.opencms.report.Messages.get().container(org.opencms.report.Messages.RPT_ARGUMENT_1, filename));\n            m_report.print(org.opencms.report.Messages.get().container(org.opencms.report.Messages.RPT_DOTS_0));\n\n            List properties = new ArrayList();\n            CmsProperty property1 = new CmsProperty(I_CmsConstants.C_PROPERTY_TITLE, \"Link to \" + linkUrl, \"Link to \"\n                + linkUrl);\n            properties.add(property1);\n            try {\n                m_cmsObject.createResource(m_linkGallery + filename, CmsResourceTypePointer.getStaticTypeId(), linkUrl\n                    .getBytes(), properties);\n            } catch (CmsException e) {\n                // do nothing here, an exception will be thrown if this link already exisits                \n            }\n            m_report.println(org.opencms.report.Messages.get().container(\n                org.opencms.report.Messages.RPT_OK_0), I_CmsReport.C_FORMAT_OK);\n        }\n    }","commit_id":"fb56d215709f27eea7e6dd0136e180a758bc4555","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Merges those pages in the two merge folders that have the same name and are no siblings of each other yet.<p>\n     * @throws CmsException if something goes wrong\n     */\n    private void mergePages() throws CmsException {\n        int size = m_foldersEqualnames.size();\n        if (size > 0) {\n            m_report.println(m_report.key(\"report.mergepages.mergepages\") , I_CmsReport.C_FORMAT_HEADLINE);\n            String defaultLocale = CmsLocaleManager.getDefaultLocale().toString();\n            String locale2 = m_cms.readPropertyObject(getParamFolder2(), \"locale\", true).getValue(defaultLocale);                        \n                   \n            // lock the source and the target folder\n            m_report.print(m_report.key(\"report.mergepages.lock\") + getParamFolder1() , I_CmsReport.C_FORMAT_NOTE); \n            m_report.print(m_report.key(\"report.dots\"), I_CmsReport.C_FORMAT_NOTE);\n            m_cms.lockResource(getParamFolder1());\n            m_report.println(m_report.key(\"report.ok\"), I_CmsReport.C_FORMAT_OK);\n    \n            m_report.print(m_report.key(\"report.mergepages.lock\") + getParamFolder2() , I_CmsReport.C_FORMAT_NOTE); \n            m_report.print(m_report.key(\"report.dots\"), I_CmsReport.C_FORMAT_NOTE);\n            m_cms.lockResource(getParamFolder2());\n            m_report.println(m_report.key(\"report.ok\"), I_CmsReport.C_FORMAT_OK);\n            \n            // now loop through all collected resources\n            m_report.print(size + \" \"+m_report.key(\"report.mergepages.pages\"),  I_CmsReport.C_FORMAT_HEADLINE);\n            m_report.println(m_report.key(\"report.dots\"),  I_CmsReport.C_FORMAT_HEADLINE);\n            int count = 1;\n            Iterator i = m_foldersEqualnames.iterator();\n            while (i.hasNext()) {\n                String resFolder1Name = (String)i.next();\n                try {\n                    String resFolder2Name = getResourceNameInOtherFolder(resFolder1Name, getParamFolder1(), getParamFolder2());\n                    m_report.print(\"( \" + count++ + \" / \" + size + \" ) \" + m_report.key(\"report.mergepages.scanning\") + \" \" + resFolder1Name + \" <-> \" + resFolder2Name , I_CmsReport.C_FORMAT_NOTE);\n                    m_report.println(m_report.key(\"report.dots\"),  I_CmsReport.C_FORMAT_NOTE);\n \n                    // get the content of the resource in folder1  \n                    String locale = m_cms.readPropertyObject(resFolder1Name, \"locale\", true).getValue(defaultLocale);                        \n                    m_report.print(m_report.key(\"report.mergepages.readcontent\") + \" \"+ resFolder1Name + \": Locale = \"+locale, I_CmsReport.C_FORMAT_NOTE);\n                    m_report.print(m_report.key(\"report.dots\"),  I_CmsReport.C_FORMAT_NOTE);\n                    CmsResource resFolder1 = m_cms.readResource(resFolder1Name, CmsResourceFilter.IGNORE_EXPIRATION);\n                    CmsFile fileFolder1 = CmsFile.upgrade(resFolder1, m_cms);\n                    CmsXmlPage pageFolder1 = CmsXmlPageFactory.unmarshal(m_cms, fileFolder1);            \n                    m_report.println(m_report.key(\"report.ok\"), I_CmsReport.C_FORMAT_OK);\n                    \n                    // get the content of the resource in folder2\n                    locale = m_cms.readPropertyObject(resFolder2Name, \"locale\", true).getValue(defaultLocale);                                    \n                    m_report.print(m_report.key(\"report.mergepages.readcontent\") + \" \"+ resFolder2Name + \": Locale = \"+locale, I_CmsReport.C_FORMAT_NOTE);\n                    m_report.print(m_report.key(\"report.dots\"),  I_CmsReport.C_FORMAT_NOTE);\n                    CmsResource resFolder2 = m_cms.readResource(resFolder2Name, CmsResourceFilter.IGNORE_EXPIRATION);\n                    CmsFile fileFolder2 = CmsFile.upgrade(resFolder2, m_cms);\n                    CmsXmlPage pageFolder2 = CmsXmlPageFactory.unmarshal(m_cms, fileFolder2);            \n                    m_report.println(m_report.key(\"report.ok\"), I_CmsReport.C_FORMAT_OK);    \n                    \n                    // now get all the text elements from the resource in folder 2 which match the the locale of folder 2\n                    Locale loc = new Locale(locale2);\n                    List textElements2 = pageFolder2.getNames(loc);\n                    Iterator j = textElements2.iterator();\n                    while (j.hasNext()) {\n                        String textElementName = (String) j.next();\n                        m_report.print(m_report.key(\"report.mergepages.gettextelement\") + \" \"+ textElementName, I_CmsReport.C_FORMAT_NOTE);\n                        m_report.print(m_report.key(\"report.dots\"),  I_CmsReport.C_FORMAT_NOTE);\n                        // get the text element from the resource in folder 2...\n                        String textElement = pageFolder2.getValue(textElementName, loc).getStringValue(m_cms);\n                        // and set it in the resource in folder 1...\n                        // WARNING: An existing content will be overwritten!\n                        if (!pageFolder1.hasValue(textElementName, loc)) {\n                            pageFolder1.addValue(textElementName, loc);\n                        }\n                        pageFolder1.setStringValue(m_cms, textElementName, loc, textElement);                \n                        m_report.println(m_report.key(\"report.ok\"), I_CmsReport.C_FORMAT_OK);   \n                    }\n                    // the resource in folder 1 now has all text elements in both locales, so update it in the vfs          \n                    m_report.print(m_report.key(\"report.mergepages.writecontent\") + \" \"+ resFolder1Name, I_CmsReport.C_FORMAT_NOTE);\n                    m_report.print(m_report.key(\"report.dots\"),  I_CmsReport.C_FORMAT_NOTE);\n                    fileFolder1.setContents(pageFolder1.marshal());\n                    m_cms.writeFile(fileFolder1);\n                    m_report.println(m_report.key(\"report.ok\"), I_CmsReport.C_FORMAT_OK); \n                    \n                    // save all properties from the resource in folder2\n                    m_report.print(m_report.key(\"report.mergepages.saveproperties\") + \" \"+ resFolder2Name, I_CmsReport.C_FORMAT_NOTE);\n                    m_report.print(m_report.key(\"report.dots\"),  I_CmsReport.C_FORMAT_NOTE);\n                    List properties = m_cms.readPropertyObjects(resFolder2Name, false);\n                    //m_report.println(m_report.key(\"report.ok\"), I_CmsReport.C_FORMAT_OK); \n        \n                    // the next thing to do is to delete the old resource in folder 2\n                    m_report.print(m_report.key(\"report.mergepages.deletefile\") + \" \"+ resFolder2Name, I_CmsReport.C_FORMAT_NOTE);\n                    m_report.print(m_report.key(\"report.dots\"), I_CmsReport.C_FORMAT_NOTE);\n                    m_cms.deleteResource(resFolder2Name, I_CmsConstants.C_DELETE_OPTION_PRESERVE_SIBLINGS);\n                    m_report.println(m_report.key(\"report.ok\"), I_CmsReport.C_FORMAT_OK); \n                    \n                    // copy a sibling of the resource from folder 1 to folder 2 \n                    m_report.print(m_report.key(\"report.mergepages.copyfile\") + \" \"+ resFolder1Name + \" -> \" + resFolder2Name, I_CmsReport.C_FORMAT_NOTE);\n                    m_report.print(m_report.key(\"report.dots\"),  I_CmsReport.C_FORMAT_NOTE);\n                    m_cms.copyResource(resFolder1Name, resFolder2Name, I_CmsConstants.C_COPY_AS_SIBLING);\n                    //m_report.println(m_report.key(\"report.ok\"), I_CmsReport.C_FORMAT_OK);\n                    \n                    // restore the properties at the sibling in folder 2\n                    m_report.print(m_report.key(\"report.mergepages.restoreproperties\") + \" \"+ resFolder2Name, I_CmsReport.C_FORMAT_NOTE);\n                    m_report.print(m_report.key(\"report.dots\"),  I_CmsReport.C_FORMAT_NOTE);\n                    m_cms.writePropertyObjects(resFolder2Name, properties);\n                    m_report.println(m_report.key(\"report.ok\"), I_CmsReport.C_FORMAT_OK);\n                    \n                    resFolder1 = null;\n                    resFolder2 = null;\n                    fileFolder1 = null;\n                    fileFolder2 = null;\n                    pageFolder1 = null;\n                    pageFolder2 = null;\n                    \n                } catch (CmsException e) {\n                    m_report.println(e.toString(), I_CmsReport.C_FORMAT_ERROR); \n                }\n              \n            }\n            // lock the source and the target folder\n            m_report.print(m_report.key(\"report.mergepages.unlock\") + getParamFolder1() , I_CmsReport.C_FORMAT_NOTE); \n            m_report.print(m_report.key(\"report.dots\"), I_CmsReport.C_FORMAT_NOTE);\n            m_cms.unlockResource(getParamFolder1());\n            m_report.println(m_report.key(\"report.ok\"), I_CmsReport.C_FORMAT_OK);\n    \n            m_report.print(m_report.key(\"report.mergepages.unlock\") + getParamFolder2() , I_CmsReport.C_FORMAT_NOTE); \n            m_report.print(m_report.key(\"report.dots\"), I_CmsReport.C_FORMAT_NOTE);\n            m_cms.unlockResource(getParamFolder2());\n            m_report.println(m_report.key(\"report.ok\"), I_CmsReport.C_FORMAT_OK);\n            \n            m_report.print(m_report.key(\"report.dots\"),  I_CmsReport.C_FORMAT_HEADLINE);\n            m_report.println(m_report.key(\"report.mergepages.done\"), I_CmsReport.C_FORMAT_HEADLINE);\n        }\n    }","id":99229,"modified_method":"/**\n     * Merges those pages in the two merge folders that have the same name and are no siblings of each other yet.<p>\n     * @throws CmsException if something goes wrong\n     */\n    private void mergePages() throws CmsException {\n        int size = m_foldersEqualnames.size();\n        if (size > 0) {\n            \n            m_report.println(Messages.get().container(Messages.RPT_MERGE_PAGES_BEGIN_1, String.valueOf(size)) , I_CmsReport.C_FORMAT_HEADLINE);\n            String defaultLocale = CmsLocaleManager.getDefaultLocale().toString();\n            String locale2 = m_cms.readPropertyObject(getParamFolder2(), \"locale\", true).getValue(defaultLocale);                        \n                   \n            // lock the source and the target folder\n            m_report.print(Messages.get().container(Messages.RPT_LOCK_FOLDER_0), I_CmsReport.C_FORMAT_NOTE);\n            m_report.print(org.opencms.report.Messages.get().container(\n                org.opencms.report.Messages.RPT_ARGUMENT_1, getParamFolder1()));\n            m_report.print(org.opencms.report.Messages.get().container(\n                org.opencms.report.Messages.RPT_DOTS_0));\n            m_cms.lockResource(getParamFolder1());\n            m_report.println(org.opencms.report.Messages.get().container(\n                org.opencms.report.Messages.RPT_OK_0), I_CmsReport.C_FORMAT_OK);\n    \n            m_report.print(Messages.get().container(Messages.RPT_LOCK_FOLDER_0), I_CmsReport.C_FORMAT_NOTE);\n            m_report.print(org.opencms.report.Messages.get().container(\n                org.opencms.report.Messages.RPT_ARGUMENT_1, getParamFolder2()));\n            m_report.print(org.opencms.report.Messages.get().container(\n                org.opencms.report.Messages.RPT_DOTS_0));\n            m_cms.lockResource(getParamFolder2());\n            m_report.println(org.opencms.report.Messages.get().container(\n                org.opencms.report.Messages.RPT_OK_0), I_CmsReport.C_FORMAT_OK);\n            \n            // now loop through all collected resources\n            int count = 1;\n            Iterator i = m_foldersEqualnames.iterator();\n            while (i.hasNext()) {\n                String resFolder1Name = (String)i.next();\n                try {\n                    String resFolder2Name = getResourceNameInOtherFolder(resFolder1Name, getParamFolder1(), getParamFolder2());\n                    m_report.print(org.opencms.report.Messages.get().container(org.opencms.report.Messages.RPT_SUCCESSION_2, \n                        String.valueOf(count++), String.valueOf(size)), I_CmsReport.C_FORMAT_NOTE);  \n                    m_report.print(Messages.get().container(Messages.RPT_PROCESS_0), I_CmsReport.C_FORMAT_NOTE);\n                    m_report.print(org.opencms.report.Messages.get().container(org.opencms.report.Messages.RPT_ARGUMENT_1, resFolder1Name));\n                    m_report.print(Messages.get().container(Messages.RPT_DOUBLE_ARROW_0), I_CmsReport.C_FORMAT_NOTE);\n                    m_report.print(org.opencms.report.Messages.get().container(org.opencms.report.Messages.RPT_ARGUMENT_1, resFolder2Name));\n                    m_report.println(org.opencms.report.Messages.get().container(org.opencms.report.Messages.RPT_DOTS_0));\n \n                    // get the content of the resource in folder1  \n                    String locale = m_cms.readPropertyObject(resFolder1Name, \"locale\", true).getValue(defaultLocale); \n                    m_report.print(Messages.get().container(Messages.RPT_READ_CONTENT_2, resFolder1Name, locale), I_CmsReport.C_FORMAT_NOTE);\n                    CmsResource resFolder1 = m_cms.readResource(resFolder1Name, CmsResourceFilter.IGNORE_EXPIRATION);\n                    CmsFile fileFolder1 = CmsFile.upgrade(resFolder1, m_cms);\n                    CmsXmlPage pageFolder1 = CmsXmlPageFactory.unmarshal(m_cms, fileFolder1);            \n                    m_report.println(org.opencms.report.Messages.get().container(\n                        org.opencms.report.Messages.RPT_OK_0), I_CmsReport.C_FORMAT_OK);\n                    \n                    // get the content of the resource in folder2\n                    locale = m_cms.readPropertyObject(resFolder2Name, \"locale\", true).getValue(defaultLocale);                                    \n                    m_report.print(Messages.get().container(Messages.RPT_READ_CONTENT_2, resFolder2Name, locale), I_CmsReport.C_FORMAT_NOTE);\n                    CmsResource resFolder2 = m_cms.readResource(resFolder2Name, CmsResourceFilter.IGNORE_EXPIRATION);\n                    CmsFile fileFolder2 = CmsFile.upgrade(resFolder2, m_cms);\n                    CmsXmlPage pageFolder2 = CmsXmlPageFactory.unmarshal(m_cms, fileFolder2);            \n                    m_report.println(org.opencms.report.Messages.get().container(\n                        org.opencms.report.Messages.RPT_OK_0), I_CmsReport.C_FORMAT_OK);   \n                    \n                    // now get all the text elements from the resource in folder 2 which match the the locale of folder 2\n                    Locale loc = new Locale(locale2);\n                    List textElements2 = pageFolder2.getNames(loc);\n                    Iterator j = textElements2.iterator();\n                    while (j.hasNext()) {\n                        String textElementName = (String) j.next();\n                        m_report.print(Messages.get().container(Messages.RPT_PROCESS_TEXT_ELEM_1, textElementName), I_CmsReport.C_FORMAT_NOTE);\n                        // get the text element from the resource in folder 2...\n                        String textElement = pageFolder2.getValue(textElementName, loc).getStringValue(m_cms);\n                        // and set it in the resource in folder 1...\n                        // WARNING: An existing content will be overwritten!\n                        if (!pageFolder1.hasValue(textElementName, loc)) {\n                            pageFolder1.addValue(textElementName, loc);\n                        }\n                        pageFolder1.setStringValue(m_cms, textElementName, loc, textElement);                \n                        m_report.println(m_report.key(\"report.ok\"), I_CmsReport.C_FORMAT_OK);   \n                    }\n                    // the resource in folder 1 now has all text elements in both locales, so update it in the vfs  \n                    \n                    m_report.print(Messages.get().container(Messages.RPT_WRITE_CONTENT_1, resFolder1Name), I_CmsReport.C_FORMAT_NOTE);\n                    fileFolder1.setContents(pageFolder1.marshal());\n                    m_cms.writeFile(fileFolder1);\n                    m_report.println(org.opencms.report.Messages.get().container(\n                        org.opencms.report.Messages.RPT_OK_0), I_CmsReport.C_FORMAT_OK);\n                    \n                    // save all properties from the resource in folder2\n                    m_report.print(Messages.get().container(Messages.RPT_READ_PROPERTIES_1, resFolder2Name), I_CmsReport.C_FORMAT_NOTE);\n                    List properties = m_cms.readPropertyObjects(resFolder2Name, false);\n                    m_report.println(org.opencms.report.Messages.get().container(\n                        org.opencms.report.Messages.RPT_OK_0), I_CmsReport.C_FORMAT_OK);\n        \n                    // the next thing to do is to delete the old resource in folder 2\n                    m_report.print(Messages.get().container(Messages.RPT_DELETE_PAGE_1, resFolder2Name), I_CmsReport.C_FORMAT_NOTE);\n                    m_cms.deleteResource(resFolder2Name, I_CmsConstants.C_DELETE_OPTION_PRESERVE_SIBLINGS);\n                    m_report.println(org.opencms.report.Messages.get().container(\n                        org.opencms.report.Messages.RPT_OK_0), I_CmsReport.C_FORMAT_OK);\n                    \n                    // copy a sibling of the resource from folder 1 to folder 2 \n                    m_report.print(Messages.get().container(Messages.RPT_COPY_2, \n                        resFolder1Name, resFolder2Name), I_CmsReport.C_FORMAT_NOTE);\n                    m_cms.copyResource(resFolder1Name, resFolder2Name, I_CmsConstants.C_COPY_AS_SIBLING);\n                    m_report.println(org.opencms.report.Messages.get().container(\n                        org.opencms.report.Messages.RPT_OK_0), I_CmsReport.C_FORMAT_OK);\n                    \n                    // restore the properties at the sibling in folder 2\n                    m_report.print(Messages.get().container(Messages.RPT_RESORE_PROPERTIES_1, resFolder2Name), I_CmsReport.C_FORMAT_NOTE);\n                    m_cms.writePropertyObjects(resFolder2Name, properties);\n                    m_report.println(org.opencms.report.Messages.get().container(\n                        org.opencms.report.Messages.RPT_OK_0), I_CmsReport.C_FORMAT_OK);\n                    \n                    resFolder1 = null;\n                    resFolder2 = null;\n                    fileFolder1 = null;\n                    fileFolder2 = null;\n                    pageFolder1 = null;\n                    pageFolder2 = null;\n                    \n                } catch (CmsException e) {\n                    m_report.println(e.toString(), I_CmsReport.C_FORMAT_ERROR); \n                }\n              \n            }\n            // lock the source and the target folder\n            m_report.print(Messages.get().container(Messages.RPT_UNLOCK_1, getParamFolder1()), I_CmsReport.C_FORMAT_NOTE); \n            m_cms.unlockResource(getParamFolder1());\n            m_report.println(org.opencms.report.Messages.get().container(\n                org.opencms.report.Messages.RPT_OK_0), I_CmsReport.C_FORMAT_OK);\n    \n            m_report.print(Messages.get().container(Messages.RPT_UNLOCK_1, getParamFolder2()), I_CmsReport.C_FORMAT_NOTE); \n            m_cms.unlockResource(getParamFolder2());\n            m_report.println(org.opencms.report.Messages.get().container(\n                org.opencms.report.Messages.RPT_OK_0), I_CmsReport.C_FORMAT_OK);\n            \n            m_report.println(Messages.get().container(Messages.RPT_MERGE_PAGES_END_0), I_CmsReport.C_FORMAT_HEADLINE);\n        }\n    }","commit_id":"fb56d215709f27eea7e6dd0136e180a758bc4555","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates a report list of all resources in one of the collected lists.<p>\n     * \n     * @param collected the list to create the output from\n     * @param doReport flag to enable detailed report\n     */\n    private void reportList(List collected, boolean doReport) {\n        int size = collected.size();\n        // now loop through all collected resources\n        m_report.print(size + \" \"+m_report.key(\"report.mergepages.pages\"),  I_CmsReport.C_FORMAT_HEADLINE);\n        m_report.println(m_report.key(\"report.dots\"),  I_CmsReport.C_FORMAT_HEADLINE);\n        if (doReport) {\n            int count = 1;\n            \n            Iterator i = collected.iterator();\n            while (i.hasNext()) {\n                String resName = (String)i.next();\n                m_report.println(\"( \" + count++ + \" / \" + size + \" ) \" + m_report.key(\"report.mergepages.scanning\") + \" \" + resName, I_CmsReport.C_FORMAT_NOTE);            \n            }\n        }\n        m_report.print(m_report.key(\"report.dots\"),  I_CmsReport.C_FORMAT_HEADLINE);\n        m_report.println(m_report.key(\"report.mergepages.done\"), I_CmsReport.C_FORMAT_HEADLINE);\n    }","id":99230,"modified_method":"/**\n     * Creates a report list of all resources in one of the collected lists.<p>\n     * \n     * @param collected the list to create the output from\n     * @param doReport flag to enable detailed report\n     */\n    private void reportList(List collected, boolean doReport) {\n        int size = collected.size();\n        // now loop through all collected resources\n        m_report.println(Messages.get().container(Messages.RPT_NUM_PAGES_1, new Integer(size)),  I_CmsReport.C_FORMAT_HEADLINE);\n        if (doReport) {\n            int count = 1;\n            \n            Iterator i = collected.iterator();\n            while (i.hasNext()) {\n                String resName = (String)i.next();\n                m_report.print(org.opencms.report.Messages.get().container(org.opencms.report.Messages.RPT_SUCCESSION_2, \n                    String.valueOf(count++), String.valueOf(size)), I_CmsReport.C_FORMAT_NOTE);\n                m_report.println(Messages.get().container(Messages.RPT_PROCESS_1, resName), I_CmsReport.C_FORMAT_NOTE); \n            }\n        }\n        m_report.println(Messages.get().container(Messages.RPT_MERGE_PAGES_END_0), I_CmsReport.C_FORMAT_HEADLINE);\n    }","commit_id":"fb56d215709f27eea7e6dd0136e180a758bc4555","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Collect all pages in a folders  and sort them depending on the required action to do.<p>\n     * \n     * @param sourceMergeFolder the source merge folder to collect all pages from\n     * @param targetMergefolder the target merge folder to compare to\n     * @param currentFolder integer value (1 or 2) showing if the source folder is folder 1 or folder 2\n     * @throws CmsException if something goes wrong\n     */\n    private void collectFolder(String sourceMergeFolder, String targetMergefolder, int currentFolder) throws CmsException {\n        m_report.println(m_report.key(\"report.mergepages.scanfolder\") + \" \" + sourceMergeFolder , I_CmsReport.C_FORMAT_HEADLINE);\n        //get the list of all resources in the source merge folder\n        CmsResourceFilter filter = CmsResourceFilter.IGNORE_EXPIRATION.addRequireType(CmsResourceTypeXmlPage.getStaticTypeId());        \n        List folderResources = m_cms.readResources(sourceMergeFolder, filter, true);\n        Iterator i = folderResources.iterator();\n        int size = folderResources.size();\n        // now loop through all resources and check them against those in the target merge folder\n        m_report.print(size + \" \"+m_report.key(\"report.mergepages.pages\"),  I_CmsReport.C_FORMAT_HEADLINE);\n        m_report.println(m_report.key(\"report.dots\"),  I_CmsReport.C_FORMAT_HEADLINE);\n        int count = 1;\n        while (i.hasNext()) {\n            CmsResource res = (CmsResource)i.next();\n            String resName = m_cms.getSitePath(res);\n            m_report.print(\"( \" + count++ + \" / \" + size + \" ) \" + m_report.key(\"report.mergepages.scanning\") + \" \" + resName, I_CmsReport.C_FORMAT_NOTE);\n            m_report.print(m_report.key(\"report.dots\"));\n            // now analyse the page and calculate the action to do\n            int action = analyse(res, sourceMergeFolder, targetMergefolder, currentFolder);\n            // add the name of the resource to the correct list\n            switch (action) {\n                case C_FOLDER1_EXCLUSIVE:   \n                    m_folder1Exclusive.add(resName);\n                    break;\n                case C_FOLDER2_EXCLUSIVE:   \n                    m_folder2Exclusive.add(resName);\n                    break;\n                case C_FOLDERS_SIBLING:   \n                    if (!m_foldersSibling.contains(getResourceNameInOtherFolder(resName, sourceMergeFolder, targetMergefolder))) {\n                        m_foldersSibling.add(resName);\n                    }\n                    break;\n                case C_FOLDERS_EQUALNAMES:   \n                    if (!m_foldersEqualnames.contains(getResourceNameInOtherFolder(resName, sourceMergeFolder, targetMergefolder))) {                        \n                        m_foldersEqualnames.add(resName);\n                    }\n                    break;\n                case C_FOLDERS_DIFFERENTTYPES:  \n                    if (!m_foldersDifferenttypes.contains(getResourceNameInOtherFolder(resName, sourceMergeFolder, targetMergefolder))) {                                                \n                        m_foldersDifferenttypes.add(resName);\n                    }\n                    break;                    \n                default:\n                    break;\n            }                                  \n            res=null;\n            m_report.println(m_report.key(\"report.mergepages.action\" + action), I_CmsReport.C_FORMAT_OK);\n        }\n        folderResources = null;\n        m_report.print(m_report.key(\"report.dots\"),  I_CmsReport.C_FORMAT_HEADLINE);\n        m_report.println(m_report.key(\"report.mergepages.done\"), I_CmsReport.C_FORMAT_HEADLINE);\n        \n    }","id":99231,"modified_method":"/**\n     * Collect all pages in a folders and sort them depending on the required action to do.<p>\n     * \n     * @param sourceMergeFolder the source merge folder to collect all pages from\n     * @param targetMergefolder the target merge folder to compare to\n     * @param currentFolder integer value (1 or 2) showing if the source folder is folder 1 or folder 2\n     * @throws CmsException if something goes wrong\n     */\n    private void collectFolder(String sourceMergeFolder, String targetMergefolder, int currentFolder) throws CmsException {\n        \n        //get the list of all resources in the source merge folder\n        CmsResourceFilter filter = CmsResourceFilter.IGNORE_EXPIRATION.addRequireType(CmsResourceTypeXmlPage.getStaticTypeId());        \n        List folderResources = m_cms.readResources(sourceMergeFolder, filter, true);\n        Iterator i = folderResources.iterator();\n        int size = folderResources.size();\n        // now loop through all resources and check them against those in the target merge folder\n        m_report.println(Messages.get().container(Messages.RPT_SCAN_PAGES_IN_FOLDER_BEGIN_2, sourceMergeFolder, new Integer(size)), I_CmsReport.C_FORMAT_HEADLINE);\n        int count = 1;\n        while (i.hasNext()) {\n            CmsResource res = (CmsResource)i.next();\n            String resName = m_cms.getSitePath(res);\n            \n            m_report.print(org.opencms.report.Messages.get().container(org.opencms.report.Messages.RPT_SUCCESSION_2, \n                String.valueOf(count++), String.valueOf(size)), I_CmsReport.C_FORMAT_NOTE);\n            m_report.println(Messages.get().container(Messages.RPT_PROCESS_1, resName), I_CmsReport.C_FORMAT_NOTE);\n            \n            // now analyse the page and calculate the action to do\n            int action = analyse(res, sourceMergeFolder, targetMergefolder, currentFolder);\n            // add the name of the resource to the correct list\n            switch (action) {\n                case C_FOLDER1_EXCLUSIVE:   \n                    m_folder1Exclusive.add(resName);\n                    m_report.println(Messages.get().container(Messages.RPT_FOLDER1_EXCLUSIVE_0), I_CmsReport.C_FORMAT_OK);\n                    break;\n                case C_FOLDER2_EXCLUSIVE:   \n                    m_folder2Exclusive.add(resName);\n                    m_report.println(Messages.get().container(Messages.RPT_FOLDER2_EXCLUSIVE_0), I_CmsReport.C_FORMAT_OK);\n                    break;\n                case C_FOLDERS_SIBLING:   \n                    if (!m_foldersSibling.contains(getResourceNameInOtherFolder(resName, sourceMergeFolder, targetMergefolder))) {\n                        m_foldersSibling.add(resName); \n                    }\n                    m_report.println(Messages.get().container(Messages.RPT_FOLDERS_SIBLING_0), I_CmsReport.C_FORMAT_OK);\n                    break;\n                case C_FOLDERS_EQUALNAMES:   \n                    if (!m_foldersEqualnames.contains(getResourceNameInOtherFolder(resName, sourceMergeFolder, targetMergefolder))) {                        \n                        m_foldersEqualnames.add(resName);  \n                    }\n                    m_report.println(Messages.get().container(Messages.RPT_FOLDERS_EQUALNAMES_0), I_CmsReport.C_FORMAT_OK);\n                    break;\n                case C_FOLDERS_DIFFERENTTYPES:  \n                    if (!m_foldersDifferenttypes.contains(getResourceNameInOtherFolder(resName, sourceMergeFolder, targetMergefolder))) {                                                \n                        m_foldersDifferenttypes.add(resName);\n                    }\n                    m_report.println(Messages.get().container(Messages.RPT_FOLDERS_DIFFERENTTYPES_0), I_CmsReport.C_FORMAT_OK);\n                    break;                    \n                default:\n                    break;\n            }                                  \n            res=null;\n        }\n        folderResources = null;\n        m_report.println(Messages.get().container(Messages.RPT_SCAN_PAGES_IN_FOLDER_END_0), I_CmsReport.C_FORMAT_HEADLINE);\n        \n    }","commit_id":"fb56d215709f27eea7e6dd0136e180a758bc4555","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Merges the specified resources.<p>\n     * \n     * @param report the cms report\n     */\n    public void actionMerge(I_CmsReport report) {\n\n        m_report = report;\n        m_report.println(m_report.key(\"report.mergepages.headline\"), I_CmsReport.C_FORMAT_HEADLINE);\n        \n        try {\n            // collect all pages and sort them depending on their state\n            collectResources();\n            // merge all pages that can be merged\n            mergePages();\n            // cleanup\n            cleanup();\n        } catch (CmsException e) {\n            m_report.println(e.toString(), I_CmsReport.C_FORMAT_ERROR);\n        }\n        \n    }","id":99232,"modified_method":"/**\n     * Merges the specified resources.<p>\n     * \n     * @param report the cms report\n     */\n    public void actionMerge(I_CmsReport report) {\n\n        m_report = report;\n        m_report.println(Messages.get().container(Messages.RPT_MERGE_PAGES_BEGIN_0), I_CmsReport.C_FORMAT_HEADLINE);\n        \n        try {\n            // collect all pages and sort them depending on their state\n            collectResources();\n            // merge all pages that can be merged\n            mergePages();\n            // cleanup\n            cleanup();\n        } catch (CmsException e) {\n            m_report.println(e.toString(), I_CmsReport.C_FORMAT_ERROR);\n        }\n        \n    }","commit_id":"fb56d215709f27eea7e6dd0136e180a758bc4555","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Collect all pages in the folders to merge and sort them depending on the required action to do.<p>\n     * \n     * The method will create several lists. Each list contains the resource names of pages\n     * and will be used in further steps of the merging process.\n     * <ul>\n     * <li>List m_folder1Exclusive: contains all pages which are exclusivly found in folder 1<\/li>\n     * <li>List m_folder2Exclusive: contains all pages which are exclusivly found in folder 2<\/li>\n     * <li>List m_foldersSibling: contains all pages which can be found in both folders and are siblings of each other <\/li>\n     * <li>List m_foldersEqualnames: contains all pages which can be found in both folders and are no siblings of each other<\/li>\n     * <li>List m_foldersDifferenttypes: contains all pages which can be found in both folders but are of different types<\/li>\n     * <\/ul>\n     * @throws CmsException\n     */\n    private void collectResources() throws CmsException {\n        String defaultLocale = CmsLocaleManager.getDefaultLocale().toString();\n        String locale1 = m_cms.readPropertyObject(getParamFolder1(), \"locale\", true).getValue(defaultLocale);\n        String locale2 = m_cms.readPropertyObject(getParamFolder2(), \"locale\", true).getValue(defaultLocale);\n        m_report.println(m_report.key(\"report.mergepages.folder\")+ \" \" + getParamFolder1() + \": Locale = \"+locale1);\n        m_report.println(m_report.key(\"report.mergepages.folder\")+ \" \" + getParamFolder2() + \": Locale = \"+locale2);\n           \n        // collect all resources in folder 1\n        collectFolder(getParamFolder1(), getParamFolder2(), 1);\n        // collect all resources in folder 2\n        collectFolder(getParamFolder2(), getParamFolder1(), 2);\n        \n        // report the results of the collection\n        m_report.println(m_report.key(\"report.mergepages.collectionresult\") , I_CmsReport.C_FORMAT_HEADLINE);        \n        m_report.println(m_report.key(\"report.mergepages.action0\") , I_CmsReport.C_FORMAT_HEADLINE);\n        reportList(m_folder1Exclusive, false);\n        m_report.println(m_report.key(\"report.mergepages.action1\") , I_CmsReport.C_FORMAT_HEADLINE);\n        reportList(m_folder2Exclusive, false);\n        m_report.println(m_report.key(\"report.mergepages.action2\") , I_CmsReport.C_FORMAT_HEADLINE);\n        reportList(m_foldersSibling, false);\n        m_report.println(m_report.key(\"report.mergepages.action3\") , I_CmsReport.C_FORMAT_HEADLINE);\n        reportList(m_foldersEqualnames, true);  \n        m_report.println(m_report.key(\"report.mergepages.action4\") , I_CmsReport.C_FORMAT_HEADLINE);\n        reportList(m_foldersDifferenttypes, false);\n  \n    }","id":99233,"modified_method":"/**\n     * Collect all pages in the folders to merge and sort them depending on the required action to do.<p>\n     * \n     * The method will create several lists. Each list contains the resource names of pages\n     * and will be used in further steps of the merging process.\n     * <ul>\n     * <li>List m_folder1Exclusive: contains all pages which are exclusivly found in folder 1<\/li>\n     * <li>List m_folder2Exclusive: contains all pages which are exclusivly found in folder 2<\/li>\n     * <li>List m_foldersSibling: contains all pages which can be found in both folders and are siblings of each other <\/li>\n     * <li>List m_foldersEqualnames: contains all pages which can be found in both folders and are no siblings of each other<\/li>\n     * <li>List m_foldersDifferenttypes: contains all pages which can be found in both folders but are of different types<\/li>\n     * <\/ul>\n     * @throws CmsException\n     */\n    private void collectResources() throws CmsException {\n        String defaultLocale = CmsLocaleManager.getDefaultLocale().toString();\n        String locale1 = m_cms.readPropertyObject(getParamFolder1(), \"locale\", true).getValue(defaultLocale);\n        String locale2 = m_cms.readPropertyObject(getParamFolder2(), \"locale\", true).getValue(defaultLocale);\n        m_report.println(Messages.get().container(Messages.RPT_CREATE_EXTERNAL_LINK_0, \n            getParamFolder1(), locale1), I_CmsReport.C_FORMAT_NOTE);\n        m_report.println(Messages.get().container(Messages.RPT_CREATE_EXTERNAL_LINK_0, \n            getParamFolder2(), locale2), I_CmsReport.C_FORMAT_NOTE);\n           \n        // collect all resources in folder 1\n        collectFolder(getParamFolder1(), getParamFolder2(), 1);\n        // collect all resources in folder 2\n        collectFolder(getParamFolder2(), getParamFolder1(), 2);\n        \n        // report the results of the collection\n        m_report.println(Messages.get().container(Messages.RPT_SCANNING_RESULTS_0), I_CmsReport.C_FORMAT_HEADLINE); \n\n        m_report.println(Messages.get().container(Messages.RPT_FOLDER1_EXCLUSIVE_0), I_CmsReport.C_FORMAT_HEADLINE);\n        reportList(m_folder1Exclusive, false);\n        m_report.println(Messages.get().container(Messages.RPT_FOLDER2_EXCLUSIVE_0), I_CmsReport.C_FORMAT_HEADLINE);\n        reportList(m_folder2Exclusive, false);\n        m_report.println(Messages.get().container(Messages.RPT_FOLDERS_SIBLING_0), I_CmsReport.C_FORMAT_HEADLINE);\n        reportList(m_foldersSibling, false);\n        m_report.println(Messages.get().container(Messages.RPT_FOLDERS_EQUALNAMES_0), I_CmsReport.C_FORMAT_HEADLINE);\n        reportList(m_foldersEqualnames, true);  \n        m_report.println(Messages.get().container(Messages.RPT_FOLDERS_DIFFERENTTYPES_0), I_CmsReport.C_FORMAT_HEADLINE);\n        reportList(m_foldersDifferenttypes, false);\n  \n    }","commit_id":"fb56d215709f27eea7e6dd0136e180a758bc4555","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private void invalidateReferenceInCopiedNode(SReference reference) {\n    if (reference.isExternal()) return;\n    SNode outputNode = reference.getSourceNode();\n    SNode inputNode = findInputNodeById(outputNode.getSNodeId());\n    if (inputNode == null) return;\n    SReference inputReference = inputNode.getReference(reference.getRole());\n    if (inputReference == null) return;\n    outputNode.removeReference(reference);\n    ReferenceInfo_CopiedInputNode refInfo = new ReferenceInfo_CopiedInputNode(\n            inputReference.getRole(),\n            outputNode,\n            inputReference.getSourceNode(),\n            inputReference.getTargetNode());\n    // todo: probably, we can do it without checking if same Id can be found in output model.\n    // todo: probably, we can eliminate this method at all and create postponed refs while copiing model\n    PostponedReference postponedReference = new PostponedReference(\n            refInfo,\n            this);\n    outputNode.addReference(postponedReference);\n  }","id":99234,"modified_method":"private void invalidateReferenceInCopiedNode(SReference reference) {\n    if (reference.isExternal()) return;\n    SNode outputNode = reference.getSourceNode();\n    SNode inputNode = findInputNodeById(outputNode.getSNodeId());\n    if (inputNode == null) return;\n    SReference inputReference = inputNode.getReference(reference.getRole());\n    if (inputReference == null) return;\n    outputNode.removeReference(reference);\n    SNode inputTargetNode = inputReference.getTargetNode();\n    if(inputTargetNode == null) {\n      showErrorMessage(inputNode, \"bad reference '\" + inputReference.getRole() + \"' in input node \" + inputNode.getDebugText());\n      return;\n    }\n    ReferenceInfo_CopiedInputNode refInfo = new ReferenceInfo_CopiedInputNode(\n            inputReference.getRole(),\n            outputNode,\n            inputReference.getSourceNode(),\n            inputTargetNode);\n    // todo: probably, we can do it without checking if same Id can be found in output model.\n    // todo: probably, we can eliminate this method at all and create postponed refs while copiing model\n    PostponedReference postponedReference = new PostponedReference(\n            refInfo,\n            this);\n    outputNode.addReference(postponedReference);\n  }","commit_id":"2f5c8230d6c944302e9c0dd64ed3ef7e936a4a55","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * Creates cloned model, each node in target model has the same nodeId that corresponding node in source model\n   * it allows to resolve internal references much faster\n   */\n\n//  public static List<SNode> copy(List<SNode> nodes, SModel targetModel, IScope scope) {\n//    List<SNode> results = new ArrayList<SNode>();\n//    for (SNode node : nodes) {\n//      results.add(clone(node, targetModel, scope));\n//    }\n//    return results;\n//  }\n\n  static SNode clone(SNode node, SModel outputModel, IScope scope) {\n    SNode result = SModelUtil_new.instantiateConceptDeclaration(node.getConceptFqName(), outputModel, scope, false);\n    assert result != null;\n    result.setId(node.getSNodeId());\n    copyProperties(node, result);\n    for (SReference reference : node.getReferences()) {\n      SModelUID targetModelUID = reference.isExternal() ? reference.getTargetModelUID() : outputModel.getUID();\n      SReference sReference = SReference.newInstance(reference.getRole(), result, reference.getTargetNodeId(), reference.getExtResolveInfo(), targetModelUID, reference.getResolveInfo());\n      result.addReference(sReference);\n    }\n    for (SNode child : node.getChildren()) {\n      result.addChild(node.getRoleOf(child), clone(child, outputModel, scope));\n    }\n    return result;\n  }","id":99235,"modified_method":"/**\n   * Creates cloned model, each node in target model has the same nodeId that corresponding node in source model\n   * it allows to resolve internal references much faster\n   */\n  static SNode clone(SNode node, SModel outputModel, IScope scope) {\n    SNode result = SModelUtil_new.instantiateConceptDeclaration(node.getConceptFqName(), outputModel, scope, false);\n    assert result != null;\n    result.setId(node.getSNodeId());\n    copyProperties(node, result);\n    for (SReference reference : node.getReferences()) {\n      SModelUID targetModelUID = reference.isExternal() ? reference.getTargetModelUID() : outputModel.getUID();\n      if(targetModelUID == null) {\n        LOG.warning(\"broken reference '\" + reference.getRole() + \"' in \" + node.getDebugText(), node);\n        continue;\n      }\n      SReference sReference = SReference.newInstance(reference.getRole(), result, reference.getTargetNodeId(), reference.getExtResolveInfo(), targetModelUID, reference.getResolveInfo());\n      result.addReference(sReference);\n    }\n    for (SNode child : node.getChildren()) {\n      result.addChild(node.getRoleOf(child), clone(child, outputModel, scope));\n    }\n    return result;\n  }","commit_id":"c6de9c079122b4bd2d17aacbfc1e3ea24c69c435","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static void addReferences(List<? extends SNode> sourceNodes, Map<SNode, SNode> mapping, boolean copyAttributes) {\n    for (SNode node : sourceNodes) {\n      SNode target = mapping.get(node);\n\n      for (SReference ref : node.getReferences()) {\n        if (mapping.containsKey(ref.getTargetNode())) {\n          target.addReferent(ref.getRole(), mapping.get(ref.getTargetNode()));\n        } else {\n          target.addReferent(ref.getRole(), ref.getTargetNode());\n        }\n      }\n\n      List<SNode> childList = new ArrayList<SNode>();\n      for (String role : node.getChildRoles(copyAttributes)) {\n        for (SNode child : node.getChildren(role)) {\n          childList.add(child);\n        }\n      }\n      addReferences(childList, mapping, copyAttributes);\n    }\n  }","id":99236,"modified_method":"private static void addReferences(List<? extends SNode> sourceNodes, Map<SNode, SNode> mapping, boolean copyAttributes) {\n    for (SNode node : sourceNodes) {\n      SNode target = mapping.get(node);\n\n      for (SReference ref : node.getReferences()) {\n        SNode targetNode = ref.getTargetNode();\n        if (targetNode == null) {\n          LOG.warning(\"broken reference '\" + ref.getRole() + \"' in \" + node.getDebugText(), node);\n        } else if (mapping.containsKey(targetNode)) {\n          target.addReferent(ref.getRole(), mapping.get(targetNode));\n        } else {\n          target.addReferent(ref.getRole(), targetNode);\n        }\n      }\n\n      List<SNode> childList = new ArrayList<SNode>();\n      for (String role : node.getChildRoles(copyAttributes)) {\n        for (SNode child : node.getChildren(role)) {\n          childList.add(child);\n        }\n      }\n      addReferences(childList, mapping, copyAttributes);\n    }\n  }","commit_id":"c6de9c079122b4bd2d17aacbfc1e3ea24c69c435","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n    PsiElement defaultValue = descriptor.getPsiElement();\n    PyNamedParameter param = PsiTreeUtil.getParentOfType(defaultValue, PyNamedParameter.class);\n    PyFunction function = PsiTreeUtil.getParentOfType(defaultValue, PyFunction.class);\n    assert param != null;\n    String defName = param.getName();\n    if (function != null) {\n      PyElementGenerator elementGenerator = PyElementGenerator.getInstance(project);\n      PyStatementList list = function.getStatementList();\n      PyParameterList paramList = function.getParameterList();\n\n      StringBuilder str = new StringBuilder(\"def foo(\");\n      int size = paramList.getParameters().length;\n      for (int i = 0; i != size; ++i) {\n        PyParameter p = paramList.getParameters()[i];\n        if (p == param)\n          str.append(defName).append(\"=None\");\n        else\n          str.append(p.getText());\n        if (i != size-1)\n          str.append(\", \");\n      }\n      str.append(\"):\\n\\tpass\");\n      PyIfStatement ifStatement = elementGenerator.createFromText(LanguageLevel.forElement(function), PyIfStatement.class,\n                                                \"if not \" + defName + \":\\n\\t\" + defName + \" = \" + defaultValue.getText());\n\n      PyStatement firstStatement = list.getStatements()[0];\n      PyStringLiteralExpression docString = function.getDocStringExpression();\n      if (docString != null)\n        list.addAfter(ifStatement, firstStatement);\n      else\n        list.addBefore(ifStatement, firstStatement);\n      paramList.replace(elementGenerator.createFromText(LanguageLevel.forElement(defaultValue),\n                                                                 PyFunction.class, str.toString()).getParameterList());\n    }\n  }","id":99237,"modified_method":"@Override\n  public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n    PsiElement defaultValue = descriptor.getPsiElement();\n    PyNamedParameter param = PsiTreeUtil.getParentOfType(defaultValue, PyNamedParameter.class);\n    PyFunction function = PsiTreeUtil.getParentOfType(defaultValue, PyFunction.class);\n    assert param != null;\n    String defName = param.getName();\n    if (function != null) {\n      PyElementGenerator elementGenerator = PyElementGenerator.getInstance(project);\n      PyStatementList list = function.getStatementList();\n      PyParameterList paramList = function.getParameterList();\n\n      final StringBuilder functionText = new StringBuilder(\"def foo(\");\n      int size = paramList.getParameters().length;\n      for (int i = 0; i != size; ++i) {\n        PyParameter p = paramList.getParameters()[i];\n        if (p == param)\n          functionText.append(defName).append(\"=None\");\n        else\n          functionText.append(p.getText());\n        if (i != size-1)\n          functionText.append(\", \");\n      }\n      functionText.append(\"):\\n\\tif not \").append(defName).append(\":\\n\\t\\t\").append(defName).append(\" = \").append(defaultValue.getText());\n      final PyStatement[] statements = list.getStatements();\n      PyStatement firstStatement = statements.length > 0 ? statements[0] : null;\n      PyFunction newFunction = elementGenerator.createFromText(LanguageLevel.forElement(function), PyFunction.class,\n                                                               functionText.toString());\n      if (firstStatement == null) {\n        function.replace(newFunction);\n      }\n      else {\n        final PyStatement ifStatement = newFunction.getStatementList().getStatements()[0];\n        PyStringLiteralExpression docString = function.getDocStringExpression();\n        if (docString != null)\n          list.addAfter(ifStatement, firstStatement);\n        else {\n          list.addBefore(ifStatement, firstStatement);\n        }\n        paramList.replace(elementGenerator.createFromText(LanguageLevel.forElement(defaultValue),\n                                                          PyFunction.class, functionText.toString()).getParameterList());\n      }\n    }\n  }","commit_id":"b3bab6eb7985ee906df40414c5333de18ec98d8e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void applyFix(@NotNull final Project project, @NotNull final ProblemDescriptor descriptor) {\n    final PsiElement element = descriptor.getPsiElement();\n    final PyFunction problemFunction = PsiTreeUtil.getParentOfType(element, PyFunction.class);\n    if (problemFunction == null) return;\n    if (!PyUtil.deleteParameter(problemFunction, 0)) return;\n\n    PyElementGenerator generator = PyElementGenerator.getInstance(project);\n    final PyFunction function =\n      generator.createFromText(LanguageLevel.forElement(problemFunction), PyFunction.class, \"@staticmethod\\ndef foo():\\n\\tpass\");\n    final PyDecoratorList decoratorList = function.getDecoratorList();\n    assert decoratorList != null;\n    final PyDecorator[] decorators = decoratorList.getDecorators();\n    final PyDecorator decorator = decorators[0];\n    problemFunction.addBefore(decorator, problemFunction.getFirstChild());\n\n\n\n  }","id":99238,"modified_method":"public void applyFix(@NotNull final Project project, @NotNull final ProblemDescriptor descriptor) {\n    final PsiElement element = descriptor.getPsiElement();\n    final PyFunction problemFunction = PsiTreeUtil.getParentOfType(element, PyFunction.class);\n    if (problemFunction == null) return;\n    PyUtil.deleteParameter(problemFunction, 0);\n\n    final PyDecoratorList problemDecoratorList = problemFunction.getDecoratorList();\n    List<String> decoTexts = new ArrayList<String>();\n    decoTexts.add(\"@staticmethod\");\n    if (problemDecoratorList != null) {\n      final PyDecorator[] decorators = problemDecoratorList.getDecorators();\n      for (PyDecorator deco : decorators) {\n        decoTexts.add(deco.getText());\n      }\n    }\n\n    PyElementGenerator generator = PyElementGenerator.getInstance(project);\n    final PyDecoratorList decoratorList = generator.createDecoratorList(decoTexts.toArray(new String[decoTexts.size()]));\n\n    if (problemDecoratorList != null) {\n      problemDecoratorList.replace(decoratorList);\n    }\n    else {\n      problemFunction.addBefore(decoratorList, problemFunction.getFirstChild());\n    }\n  }","commit_id":"6eb69aa83a327b080cfba14d853ac93f8945cdf1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    PyLambdaExpression lambdaExpression = PsiTreeUtil.getParentOfType(file.findElementAt(editor.getCaretModel().getOffset()), PyLambdaExpression.class);\n    PyElementGenerator elementGenerator = PyElementGenerator.getInstance(project);\n    if (lambdaExpression != null) {\n      String name = \"function\";\n      PsiElement parent = lambdaExpression.getParent();\n      if (parent instanceof PyAssignmentStatement) {\n        name = ((PyAssignmentStatement)parent).getLeftHandSideExpression().getText();\n      }\n      else {\n        Application application = ApplicationManager.getApplication();\n        if (application != null && !application.isUnitTestMode()) {\n          name = Messages.showInputDialog(project, \"Enter new function name\",\n                                        \"New function name\", Messages.getQuestionIcon());\n          if (name == null) return;\n        }\n      }\n      if (name.isEmpty()) return;\n      PyExpression body = lambdaExpression.getBody();\n      PyParameter[] parameters = lambdaExpression.getParameterList().getParameters();\n      StringBuilder stringBuilder = new StringBuilder();\n      stringBuilder.append(\"def \");\n      stringBuilder.append(name);\n      stringBuilder.append(\"(\");\n      int size = parameters.length;\n      for (int i = 0; i != size; ++i) {\n        PyParameter parameter = parameters[i];\n        stringBuilder.append(parameter.getName());\n        if ( i != size - 1)\n          stringBuilder.append(\",\");\n      }\n      stringBuilder.append(\"):\\n  return \");\n      stringBuilder.append(body.getText());\n\n      PyFunction function = elementGenerator.createFromText(LanguageLevel.forElement(lambdaExpression),\n                                                            PyFunction.class, stringBuilder.toString());\n\n      PyFunction parentFunction = PsiTreeUtil.getParentOfType(lambdaExpression, PyFunction.class);\n      if (parentFunction != null) {\n        PyStatementList statements = parentFunction.getStatementList();\n        statements.addBefore(function, statements.getStatements()[0]);\n      }\n      else {\n        PyStatement statement = PsiTreeUtil.getParentOfType(lambdaExpression, PyStatement.class);\n        file.addBefore(function, statement);\n      }\n      if (parent instanceof PyAssignmentStatement) {\n        parent.delete();\n      }\n      else {\n        lambdaExpression.replace(elementGenerator.createFromText(LanguageLevel.forElement(lambdaExpression), PyExpression.class,\n                                                               name));\n      }\n    }\n  }","id":99239,"modified_method":"public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    PyLambdaExpression lambdaExpression = PsiTreeUtil.getParentOfType(file.findElementAt(editor.getCaretModel().getOffset()), PyLambdaExpression.class);\n    PyElementGenerator elementGenerator = PyElementGenerator.getInstance(project);\n    if (lambdaExpression != null) {\n      String name = \"function\";\n      PsiElement parent = lambdaExpression.getParent();\n      if (parent instanceof PyAssignmentStatement) {\n        name = ((PyAssignmentStatement)parent).getLeftHandSideExpression().getText();\n      }\n      else {\n        Application application = ApplicationManager.getApplication();\n        if (application != null && !application.isUnitTestMode()) {\n          name = Messages.showInputDialog(project, \"Enter new function name\",\n                                        \"New function name\", Messages.getQuestionIcon());\n          if (name == null) return;\n        }\n      }\n      if (name.isEmpty()) return;\n      PyExpression body = lambdaExpression.getBody();\n      PyParameter[] parameters = lambdaExpression.getParameterList().getParameters();\n      StringBuilder stringBuilder = new StringBuilder();\n      stringBuilder.append(\"def \");\n      stringBuilder.append(name);\n      stringBuilder.append(\"(\");\n      int size = parameters.length;\n      for (int i = 0; i != size; ++i) {\n        PyParameter parameter = parameters[i];\n        stringBuilder.append(parameter.getName());\n        if ( i != size - 1)\n          stringBuilder.append(\",\");\n      }\n      stringBuilder.append(\"):\\n  return \");\n      stringBuilder.append(body.getText());\n\n      PyFunction function = elementGenerator.createFromText(LanguageLevel.forElement(lambdaExpression),\n                                                            PyFunction.class, stringBuilder.toString());\n\n      PyStatement statement = PsiTreeUtil.getParentOfType(lambdaExpression, PyStatement.class);\n      if (statement != null) {\n        PsiElement parentOfStatement = statement.getParent();\n        if (parentOfStatement != null)\n          parentOfStatement.addBefore(function, statement);\n      }\n      if (parent instanceof PyAssignmentStatement) {\n        parent.delete();\n      }\n      else {\n        lambdaExpression.replace(elementGenerator.createFromText(LanguageLevel.forElement(lambdaExpression), PyExpression.class,\n                                                               name));\n      }\n    }\n  }","commit_id":"587368526441fd24aa26779d9d15130ee7548077","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitPyExpressionStatement(final PyExpressionStatement node) {\n      if (PydevConsoleRunner.isInPydevConsole(node)) {\n        return;\n      }\n      final PyExpression expression = node.getExpression();\n      if (hasEffect(expression)) return;\n\n      final PyTryPart tryPart = PsiTreeUtil.getParentOfType(node, PyTryPart.class);\n      if (tryPart != null) {\n        final PyStatementList statementList = tryPart.getStatementList();\n        if (statementList == null) {\n          return;\n        }\n        if (statementList.getStatements().length == 1 && statementList.getStatements()[0] == node) {\n          return;\n        }\n      }\n      registerProblem(expression, \"Statement seems to have no effect\", new StatementEffectIntroduceVariableQuickFix());\n    }","id":99240,"modified_method":"@Override\n    public void visitPyExpressionStatement(final PyExpressionStatement node) {\n      if (PydevConsoleRunner.isInPydevConsole(node)) {\n        return;\n      }\n      final PyExpression expression = node.getExpression();\n      if (hasEffect(expression)) return;\n\n      final PyTryPart tryPart = PsiTreeUtil.getParentOfType(node, PyTryPart.class);\n      if (tryPart != null) {\n        final PyStatementList statementList = tryPart.getStatementList();\n        if (statementList == null) {\n          return;\n        }\n        if (statementList.getStatements().length == 1 && statementList.getStatements()[0] == node) {\n          return;\n        }\n      }\n      registerProblem(expression, \"Statement seems to have no effect\", new StatementEffectIntroduceVariableQuickFix(expression));\n    }","commit_id":"587368526441fd24aa26779d9d15130ee7548077","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void registerUnresolvedReferenceProblem(PyElement node, PsiReference reference, HighlightSeverity severity) {\n      final StringBuilder description_buf = new StringBuilder(\"\"); // TODO: clear description_buf logic. maybe a flag is needed instead.\n      final String text = reference.getElement().getText();\n      final String ref_text = reference.getRangeInElement().substring(text); // text of the part we're working with\n      final PsiElement ref_element = reference.getElement();\n      final boolean ref_is_importable = SyntaxMatchers.IN_IMPORT.search(ref_element) == null && IN_GLOBAL.search(ref_element) == null;\n      final List<LocalQuickFix> actions = new ArrayList<LocalQuickFix>(2);\n      HintAction hintAction = null;\n      if (ref_text.length() <= 0) return; // empty text, nothing to highlight\n      if (reference.getElement() instanceof PyReferenceExpression) {\n        PyReferenceExpression refex = (PyReferenceExpression)reference.getElement();\n        String refname = refex.getReferencedName();\n        if (myIgnoredIdentifiers.contains(refname)) {\n          return;\n        }\n        if (refex.getQualifier() != null) {\n          System.out.println(\"refex.getQualifier() \" + refex.getQualifier().getText());\n          final PyClassType object_type = PyBuiltinCache.getInstance(node).getObjectType();\n          if ((object_type != null) && object_type.getPossibleInstanceMembers().contains(refname)) return;\n\n        }\n        else {\n          if (LanguageLevel.forElement(node).isOlderThan(LanguageLevel.PYTHON26)) {\n            if (refname.equals(\"with\")) {\n              actions.add(new UnresolvedRefAddFutureImportQuickFix(refex));\n            }\n          }\n          PyClass containedClass = PsiTreeUtil.getParentOfType(node, PyClass.class);\n          if (containedClass != null) {\n            for (PyTargetExpression target : containedClass.getInstanceAttributes()) {\n              if (Comparing.strEqual(node.getName(), target.getName())) {\n                actions.add(new UnresolvedReferenceAddSelfQuickFix(refex));\n              }\n            }\n          }\n          actions.add(new UnresolvedRefCreateFunctionQuickFix(refex));\n        }\n        // unqualified:\n        // may be module's\n        if (PyModuleType.getPossibleInstanceMembers().contains(refname)) return;\n        // may be a \"try: import ...\"; not an error not to resolve\n        if ((\n          PsiTreeUtil.getParentOfType(\n            PsiTreeUtil.getParentOfType(node, PyImportElement.class), PyTryExceptStatement.class, PyIfStatement.class\n          ) != null\n        )) {\n          severity = HighlightSeverity.INFO;\n          String errmsg = PyBundle.message(\"INSP.module.$0.not.found\", ref_text);\n          description_buf.append(errmsg);\n          // TODO: mark the node so that future references pointing to it won't result in a error, but in a warning\n        }\n      }\n      if (reference instanceof PsiReferenceEx) {\n        final String s = ((PsiReferenceEx)reference).getUnresolvedDescription();\n        if (s != null) description_buf.append(s);\n      }\n      if (description_buf.length() == 0) {\n        boolean marked_qualified = false;\n        if (reference.getElement() instanceof PyQualifiedExpression) {\n          final PyExpression qexpr = ((PyQualifiedExpression)reference.getElement()).getQualifier();\n          if (qexpr != null) {\n            PyType qtype = myTypeEvalContext.getType(qexpr);\n            if (qtype != null) {\n              if (qtype instanceof PyNoneType || qtype instanceof PyTypeReference ||\n                  (qtype instanceof PyUnionType && ((PyUnionType) qtype).isWeak())) {\n                // this almost always means that we don't know the type, so don't show an error in this case\n                return;\n              }\n              if (qtype instanceof PyClassType) {\n                PyClass cls = ((PyClassType)qtype).getPyClass();\n                if (cls != null) {\n                  if (overridesGetAttr(cls)) {\n                    return;\n                  }\n                  if (cls.findProperty(ref_text) != null) {\n                    return; // a property exists but accessor is not found; other inspections handle this\n                  }\n                  if (! PyBuiltinCache.getInstance(node).hasInBuiltins(cls)) {\n                    if (reference.getElement().getParent() instanceof PyCallExpression) {\n                      actions.add(new AddMethodQuickFix(ref_text, (PyClassType)qtype));\n                    }\n                    else actions.add(new AddFieldQuickFix(ref_text, cls, \"None\"));\n                  }\n                }\n                description_buf.append(PyBundle.message(\"INSP.unresolved.ref.$0.for.class.$1\", ref_text, qtype.getName()));\n                marked_qualified = true;\n              }\n              else if (qtype instanceof PyModuleType) {\n                PsiFile file = ((PyModuleType)qtype).getModule();\n                if (file instanceof PyFile) {\n                  actions.add(new AddFunctionQuickFix(ref_text, (PyFile)file));\n                }\n              }\n              else {\n                description_buf.append(PyBundle.message(\"INSP.cannot.find.$0.in.$1\", ref_text, qtype.getName()));\n                marked_qualified = true;\n              }\n            }\n          }\n        }\n        if (! marked_qualified) {\n          description_buf.append(PyBundle.message(\"INSP.unresolved.ref.$0\", ref_text));\n\n          // look in other imported modules for this whole name\n          if (ref_is_importable) {\n            ImportFromExistingFix importFix = PythonReferenceImporter.proposeImportFix(node, ref_text);\n            if (importFix != null) {\n              // if the context doesn't look like a function call and we only found imports of functions, suggest auto-import\n              // as a quickfix but no popup balloon (PY-2312)\n              if ((isCall(node) || !importFix.hasOnlyFunctions()) && PyCodeInsightSettings.getInstance().SHOW_IMPORT_POPUP) {\n                final AutoImportHintAction autoImportHintAction = new AutoImportHintAction(importFix);\n                actions.add(autoImportHintAction);\n                hintAction = autoImportHintAction;\n              }\n              else {\n                actions.add(importFix);\n              }\n            }\n          }\n\n          // add import hint; the rest of action will fend for itself.\n          if (ref_element != null && ref_is_importable && hintAction == null) {\n            final AddImportAction addImportAction = new AddImportAction(reference);\n            if (addImportAction.hasSomethingToImport(ref_element.getContainingFile())) {\n              actions.add(addImportAction);\n            }\n          }\n          if (ref_text.length() > 2 && Character.isUpperCase(ref_text.charAt(0)) && !Character.isUpperCase(ref_text.charAt(1)) &&\n              PsiTreeUtil.getParentOfType(ref_element, PyImportStatement.class, PyFromImportStatement.class) == null) {\n            actions.add(new CreateClassQuickFix(ref_text, reference.getElement()));\n          }\n        }\n      }\n      String description = description_buf.toString();\n      ProblemHighlightType hl_type;\n      if (severity == HighlightSeverity.WARNING) {\n        hl_type = ProblemHighlightType.GENERIC_ERROR_OR_WARNING;\n      }\n      else {\n        hl_type = ProblemHighlightType.LIKE_UNKNOWN_SYMBOL;\n      }\n\n      if (GenerateBinaryStubsFix.isApplicable(reference)) {\n        actions.add(new GenerateBinaryStubsFix(reference));\n      }\n      actions.add(new AddIgnoredIdentifierFix(ref_text));\n      addPluginQuickFixes(reference, actions);\n\n      PsiElement point = node.getLastChild(); // usually the identifier at the end of qual ref\n      if (point == null) point = node;\n      registerProblem(point, description, hl_type, null, actions.toArray(new LocalQuickFix[actions.size()]));\n    }","id":99241,"modified_method":"private void registerUnresolvedReferenceProblem(PyElement node, PsiReference reference, HighlightSeverity severity) {\n      final StringBuilder description_buf = new StringBuilder(\"\"); // TODO: clear description_buf logic. maybe a flag is needed instead.\n      final String text = reference.getElement().getText();\n      final String ref_text = reference.getRangeInElement().substring(text); // text of the part we're working with\n      final PsiElement ref_element = reference.getElement();\n      final boolean ref_is_importable = SyntaxMatchers.IN_IMPORT.search(ref_element) == null && IN_GLOBAL.search(ref_element) == null;\n      final List<LocalQuickFix> actions = new ArrayList<LocalQuickFix>(2);\n      HintAction hintAction = null;\n      if (ref_text.length() <= 0) return; // empty text, nothing to highlight\n      if (reference.getElement() instanceof PyReferenceExpression) {\n        PyReferenceExpression refex = (PyReferenceExpression)reference.getElement();\n        String refname = refex.getReferencedName();\n        if (myIgnoredIdentifiers.contains(refname)) {\n          return;\n        }\n        if (refex.getQualifier() != null) {\n          final PyClassType object_type = PyBuiltinCache.getInstance(node).getObjectType();\n          if ((object_type != null) && object_type.getPossibleInstanceMembers().contains(refname)) return;\n\n        }\n        else {\n          if (LanguageLevel.forElement(node).isOlderThan(LanguageLevel.PYTHON26)) {\n            if (refname.equals(\"with\")) {\n              actions.add(new UnresolvedRefAddFutureImportQuickFix(refex));\n            }\n          }\n          PyClass containedClass = PsiTreeUtil.getParentOfType(node, PyClass.class);\n          if (containedClass != null) {\n            for (PyTargetExpression target : containedClass.getInstanceAttributes()) {\n              if (Comparing.strEqual(node.getName(), target.getName())) {\n                actions.add(new UnresolvedReferenceAddSelfQuickFix(refex));\n              }\n            }\n          }\n          actions.add(new UnresolvedRefCreateFunctionQuickFix(refex));\n        }\n        // unqualified:\n        // may be module's\n        if (PyModuleType.getPossibleInstanceMembers().contains(refname)) return;\n        // may be a \"try: import ...\"; not an error not to resolve\n        if ((\n          PsiTreeUtil.getParentOfType(\n            PsiTreeUtil.getParentOfType(node, PyImportElement.class), PyTryExceptStatement.class, PyIfStatement.class\n          ) != null\n        )) {\n          severity = HighlightSeverity.INFO;\n          String errmsg = PyBundle.message(\"INSP.module.$0.not.found\", ref_text);\n          description_buf.append(errmsg);\n          // TODO: mark the node so that future references pointing to it won't result in a error, but in a warning\n        }\n      }\n      if (reference instanceof PsiReferenceEx) {\n        final String s = ((PsiReferenceEx)reference).getUnresolvedDescription();\n        if (s != null) description_buf.append(s);\n      }\n      if (description_buf.length() == 0) {\n        boolean marked_qualified = false;\n        if (reference.getElement() instanceof PyQualifiedExpression) {\n          final PyExpression qexpr = ((PyQualifiedExpression)reference.getElement()).getQualifier();\n          if (qexpr != null) {\n            PyType qtype = myTypeEvalContext.getType(qexpr);\n            if (qtype != null) {\n              if (qtype instanceof PyNoneType || qtype instanceof PyTypeReference ||\n                  (qtype instanceof PyUnionType && ((PyUnionType) qtype).isWeak())) {\n                // this almost always means that we don't know the type, so don't show an error in this case\n                return;\n              }\n              if (qtype instanceof PyClassType) {\n                PyClass cls = ((PyClassType)qtype).getPyClass();\n                if (cls != null) {\n                  if (overridesGetAttr(cls)) {\n                    return;\n                  }\n                  if (cls.findProperty(ref_text) != null) {\n                    return; // a property exists but accessor is not found; other inspections handle this\n                  }\n                  if (! PyBuiltinCache.getInstance(node).hasInBuiltins(cls)) {\n                    if (reference.getElement().getParent() instanceof PyCallExpression) {\n                      actions.add(new AddMethodQuickFix(ref_text, (PyClassType)qtype));\n                    }\n                    else actions.add(new AddFieldQuickFix(ref_text, cls, \"None\"));\n                  }\n                }\n                description_buf.append(PyBundle.message(\"INSP.unresolved.ref.$0.for.class.$1\", ref_text, qtype.getName()));\n                marked_qualified = true;\n              }\n              else if (qtype instanceof PyModuleType) {\n                PsiFile file = ((PyModuleType)qtype).getModule();\n                if (file instanceof PyFile) {\n                  actions.add(new AddFunctionQuickFix(ref_text, (PyFile)file));\n                }\n              }\n              else {\n                description_buf.append(PyBundle.message(\"INSP.cannot.find.$0.in.$1\", ref_text, qtype.getName()));\n                marked_qualified = true;\n              }\n            }\n          }\n        }\n        if (! marked_qualified) {\n          description_buf.append(PyBundle.message(\"INSP.unresolved.ref.$0\", ref_text));\n\n          // look in other imported modules for this whole name\n          if (ref_is_importable) {\n            ImportFromExistingFix importFix = PythonReferenceImporter.proposeImportFix(node, ref_text);\n            if (importFix != null) {\n              // if the context doesn't look like a function call and we only found imports of functions, suggest auto-import\n              // as a quickfix but no popup balloon (PY-2312)\n              if ((isCall(node) || !importFix.hasOnlyFunctions()) && PyCodeInsightSettings.getInstance().SHOW_IMPORT_POPUP) {\n                final AutoImportHintAction autoImportHintAction = new AutoImportHintAction(importFix);\n                actions.add(autoImportHintAction);\n                hintAction = autoImportHintAction;\n              }\n              else {\n                actions.add(importFix);\n              }\n            }\n          }\n\n          // add import hint; the rest of action will fend for itself.\n          if (ref_element != null && ref_is_importable && hintAction == null) {\n            final AddImportAction addImportAction = new AddImportAction(reference);\n            if (addImportAction.hasSomethingToImport(ref_element.getContainingFile())) {\n              actions.add(addImportAction);\n            }\n          }\n          if (ref_text.length() > 2 && Character.isUpperCase(ref_text.charAt(0)) && !Character.isUpperCase(ref_text.charAt(1)) &&\n              PsiTreeUtil.getParentOfType(ref_element, PyImportStatement.class, PyFromImportStatement.class) == null) {\n            actions.add(new CreateClassQuickFix(ref_text, reference.getElement()));\n          }\n        }\n      }\n      String description = description_buf.toString();\n      ProblemHighlightType hl_type;\n      if (severity == HighlightSeverity.WARNING) {\n        hl_type = ProblemHighlightType.GENERIC_ERROR_OR_WARNING;\n      }\n      else {\n        hl_type = ProblemHighlightType.LIKE_UNKNOWN_SYMBOL;\n      }\n\n      if (GenerateBinaryStubsFix.isApplicable(reference)) {\n        actions.add(new GenerateBinaryStubsFix(reference));\n      }\n      actions.add(new AddIgnoredIdentifierFix(ref_text));\n      addPluginQuickFixes(reference, actions);\n\n      PsiElement point = node.getLastChild(); // usually the identifier at the end of qual ref\n      if (point == null) point = node;\n      registerProblem(point, description, hl_type, null, actions.toArray(new LocalQuickFix[actions.size()]));\n    }","commit_id":"587368526441fd24aa26779d9d15130ee7548077","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void applyFix(@NotNull final Project project, @NotNull final ProblemDescriptor descriptor) {\n    PsiElement expression = descriptor.getPsiElement();\n    String name = \"var\";\n    if (expression != null) {\n      Application application = ApplicationManager.getApplication();\n      if (application != null && !application.isUnitTestMode()) {\n        name = Messages.showInputDialog(project, \"Enter new variable name\",\n                                        \"New variable name\", Messages.getQuestionIcon());\n        if (name == null) return;\n      }\n      if (name.isEmpty()) return;\n      PyElementGenerator elementGenerator = PyElementGenerator.getInstance(project);\n      expression.replace(elementGenerator.createFromText(LanguageLevel.forElement(expression), PyAssignmentStatement.class,\n                                                         name + \" = \" + expression.getText()));\n    }\n  }","id":99242,"modified_method":"public void applyFix(@NotNull final Project project, @NotNull final ProblemDescriptor descriptor) {\n    String name = \"var\";\n    if (myExpression != null) {\n      Application application = ApplicationManager.getApplication();\n      if (application != null && !application.isUnitTestMode()) {\n        name = Messages.showInputDialog(project, \"Enter new variable name\",\n                                        \"New variable name\", Messages.getQuestionIcon());\n        if (name == null) return;\n      }\n      if (name.isEmpty()) return;\n      PyElementGenerator elementGenerator = PyElementGenerator.getInstance(project);\n      myExpression.replace(elementGenerator.createFromText(LanguageLevel.forElement(myExpression), PyAssignmentStatement.class,\n                                                         name + \" = \" + myExpression.getText()));\n    }\n  }","commit_id":"587368526441fd24aa26779d9d15130ee7548077","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public StatementEffectIntroduceVariableQuickFix() {}","id":99243,"modified_method":"public StatementEffectIntroduceVariableQuickFix(PyExpression expression) {\n    myExpression = expression;\n  }","commit_id":"587368526441fd24aa26779d9d15130ee7548077","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n      if (!CodeInsightUtilBase.preparePsiElementForWrite(myElement)) return;\n      PyElementGenerator elementGenerator = PyElementGenerator.getInstance(project);\n      PyFunction function = elementGenerator.createFromText(LanguageLevel.forElement(myElement), PyFunction.class,\n                                                            \"def \" + myElement.getText() + \"():\\n  pass\");\n\n      PyFile file = (PyFile)myElement.getContainingFile();\n      PyFunction parentFunction = PsiTreeUtil.getParentOfType(myElement, PyFunction.class);\n      if (parentFunction != null) {\n        PyStatementList statements = parentFunction.getStatementList();\n        statements.addBefore(function, statements.getStatements()[0]);\n      }\n      else {\n        PyStatement statement = PsiTreeUtil.getParentOfType(myElement, PyStatement.class);\n        file.addBefore(function, statement);\n      }\n  }","id":99244,"modified_method":"public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n    if (!CodeInsightUtilBase.preparePsiElementForWrite(myElement)) return;\n    PyElementGenerator elementGenerator = PyElementGenerator.getInstance(project);\n    PyFunction function = elementGenerator.createFromText(LanguageLevel.forElement(myElement), PyFunction.class,\n                                                          \"def \" + myElement.getText() + \"():\\n  pass\");\n\n    PyStatement statement = PsiTreeUtil.getParentOfType(myElement, PyStatement.class);\n    if (statement != null) {\n      PsiElement parent = statement.getParent();\n      if (parent != null)\n        parent.addBefore(function, statement);\n    }\n  }","commit_id":"587368526441fd24aa26779d9d15130ee7548077","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public List<Module> commit(final Project project, ModifiableModuleModel model, ModulesProvider modulesProvider,\n                             ModifiableArtifactModel artifactModel) {\n\n    final Collection<String> unknownLibraries = new TreeSet<String>();\n    final Collection<String> unknownJdks = new TreeSet<String>();\n    final Set<String> refsToModules = new HashSet<String>();\n    final List<Module> result = new ArrayList<Module>();\n    final Map<Module, Set<String>> module2NatureNames = new HashMap<Module, Set<String>>();\n\n    try {\n      final ModifiableModuleModel moduleModel = model != null ? model : ModuleManager.getInstance(project).getModifiableModel();\n      final ModifiableRootModel[] rootModels = new ModifiableRootModel[getParameters().projectsToConvert.size()];\n      final Set<File> files = new HashSet<File>();\n      final Set<String> moduleNames = new THashSet<String>(getParameters().projectsToConvert.size());\n      for (String path : getParameters().projectsToConvert) {\n        String modulesDirectory = getParameters().converterOptions.commonModulesDirectory;\n        if (modulesDirectory == null) {\n          modulesDirectory = path;\n        }\n        final String moduleName = EclipseProjectFinder.findProjectName(path);\n        moduleNames.add(moduleName);\n        final File imlFile = new File(modulesDirectory + File.separator + moduleName + IdeaXml.IML_EXT);\n        if (imlFile.isFile()) {\n          files.add(imlFile);\n        }\n        final File emlFile = new File(modulesDirectory + File.separator + moduleName + EclipseXml.IDEA_SETTINGS_POSTFIX);\n        if (emlFile.isFile()) {\n          files.add(emlFile);\n        }\n      }\n      if (!files.isEmpty()) {\n        final int resultCode = Messages.showYesNoCancelDialog(ApplicationInfoEx.getInstanceEx().getFullApplicationName() +\n                                                              \" module files found:\\n\" +\n                                                              StringUtil.join(files,new Function<File, String>() {\n                                                                public String fun(File file) {\n                                                                  return file.getPath();\n                                                                }\n                                                              }, \"\\n\") +\n                                                              \".\\n Would you like to reuse them?\", \"Module Files Found\",\n                                                              Messages.getQuestionIcon());\n        if (resultCode != Messages.YES) {\n          if (resultCode == Messages.NO) {\n            final LocalFileSystem localFileSystem = LocalFileSystem.getInstance();\n            for (File file : files) {\n              final VirtualFile virtualFile = localFileSystem.findFileByIoFile(file);\n              if (virtualFile != null) {\n                ApplicationManager.getApplication().runWriteAction(new ThrowableComputable<Void, IOException>() {\n                  @Override\n                  public Void compute() throws IOException {\n                    virtualFile.delete(this);\n                    return null;\n                  }\n                });\n              }\n              else {\n                FileUtil.delete(file);\n              }\n            }\n          } else {\n            return result;\n          }\n        }\n      }\n      int idx = 0;\n      for (String path : getParameters().projectsToConvert) {\n        String modulesDirectory = getParameters().converterOptions.commonModulesDirectory;\n        if (modulesDirectory == null) {\n          modulesDirectory = path;\n        }\n        final Module module = moduleModel.newModule(modulesDirectory + \"/\" + EclipseProjectFinder.findProjectName(path) + IdeaXml.IML_EXT,\n                                                    StdModuleTypes.JAVA.getId());\n        result.add(module);\n        final Set<String> natures = collectNatures(path);\n\n        if (natures.size() > 0) {\n          module2NatureNames.put(module, natures);\n        }\n        final ModifiableRootModel rootModel = ModuleRootManager.getInstance(module).getModifiableModel();\n        rootModels[idx++] = rootModel;\n\n        final File classpathFile = new File(path, EclipseXml.DOT_CLASSPATH_EXT);\n        final EclipseClasspathReader classpathReader = new EclipseClasspathReader(path, project, getParameters().projectsToConvert, moduleNames);\n        classpathReader.init(rootModel);\n        if (classpathFile.exists()) {\n          Element classpathElement = JDOMUtil.load(classpathFile);\n          classpathReader.readClasspath(rootModel, unknownLibraries, unknownJdks, refsToModules,\n                                        getParameters().converterOptions.testPattern, classpathElement);\n        }\n        else {\n          EclipseClasspathReader.setOutputUrl(rootModel, path + \"/bin\");\n        }\n        ClasspathStorage.setStorageType(rootModel,\n                                        getParameters().linkConverted ? JpsEclipseClasspathSerializer.CLASSPATH_STORAGE_ID : ClassPathStorageUtil.DEFAULT_STORAGE);\n        if (model != null) {\n          ApplicationManager.getApplication().runWriteAction(new Runnable() {\n            public void run() {\n              rootModel.commit();\n            }\n          });\n        }\n      }\n      if (model == null) {\n        ApplicationManager.getApplication().runWriteAction(new Runnable() {\n          public void run() {\n            ModifiableModelCommitter.multiCommit(rootModels, moduleModel);\n          }\n        });\n      }\n    }\n    catch (Exception e) {\n      LOG.error(e);\n    }\n    scheduleNaturesImporting(project, module2NatureNames);\n    createEclipseLibrary(project, unknownLibraries, IdeaXml.ECLIPSE_LIBRARY);\n\n    StringBuilder message = new StringBuilder();\n    refsToModules.removeAll(getParameters().existingModuleNames);\n    for (String path : getParameters().projectsToConvert) {\n      final String projectName = EclipseProjectFinder.findProjectName(path);\n      if (projectName != null) {\n        refsToModules.remove(projectName);\n        getParameters().existingModuleNames.add(projectName);\n      }\n    }\n    if (!refsToModules.isEmpty()) {\n\n      message.append(\"Unknown modules detected\");\n      for (String module : refsToModules) {\n        message.append(\"\\n\").append(module);\n      }\n    }\n    if (!unknownJdks.isEmpty()) {\n      if (message.length() > 0){\n        message.append(\"\\nand jdks\");\n      } else {\n        message.append(\"Imported project refers to unknown jdks\");\n      }\n      for (String unknownJdk : unknownJdks) {\n        message.append(\"\\n\").append(unknownJdk);\n      }\n    }\n    if (!unknownLibraries.isEmpty()) {\n      final StringBuilder buf = new StringBuilder();\n      buf.append(\"<html><body>\");\n      buf.append(EclipseBundle.message(\"eclipse.import.warning.undefinded.libraries\"));\n      for (String name : unknownLibraries) {\n        buf.append(\"<br>\").append(name);\n      }\n      if (model == null) {\n        buf.append(\"<br><b>Please export Eclipse user libraries and import them now from resulted .userlibraries file<\/b>\");\n        buf.append(\"<\/body><\/html>\");\n        final FileChooserDescriptor descriptor = new FileChooserDescriptor(true, false, false, false, false, false) {\n          @Override\n          public boolean isFileSelectable(VirtualFile file) {\n            return super.isFileSelectable(file) && Comparing.strEqual(file.getExtension(), \"userlibraries\");\n          }\n        };\n        descriptor.setDescription(buf.toString());\n        descriptor.setTitle(getTitle());\n        final VirtualFile selectedFile = FileChooser.chooseFile(descriptor, project, project.getBaseDir());\n        if (selectedFile != null) {\n          ApplicationManager.getApplication().runWriteAction(new Runnable() {\n            public void run() {\n              try {\n                EclipseUserLibrariesHelper.readProjectLibrariesContent(new File(selectedFile.getPath()), project, unknownLibraries);\n              }\n              catch (Exception e) {\n                LOG.error(e);\n              }\n            }\n          });\n        }\n      }\n    }\n\n    if (message.length() > 0) {\n      Messages.showErrorDialog(project, message.toString(), getTitle());\n    }\n\n    return result;\n  }","id":99245,"modified_method":"@Override\n  public List<Module> commit(final Project project, ModifiableModuleModel model, ModulesProvider modulesProvider,\n                             ModifiableArtifactModel artifactModel) {\n\n    final Collection<String> unknownLibraries = new TreeSet<String>();\n    final Collection<String> unknownJdks = new TreeSet<String>();\n    final Set<String> refsToModules = new HashSet<String>();\n    final List<Module> result = new ArrayList<Module>();\n    final Map<Module, Set<String>> module2NatureNames = new HashMap<Module, Set<String>>();\n\n    try {\n      final ModifiableModuleModel moduleModel = model != null ? model : ModuleManager.getInstance(project).getModifiableModel();\n      final ModifiableRootModel[] rootModels = new ModifiableRootModel[getParameters().projectsToConvert.size()];\n      final Set<File> files = new HashSet<File>();\n      final Set<String> moduleNames = new THashSet<String>(getParameters().projectsToConvert.size());\n      for (String path : getParameters().projectsToConvert) {\n        String modulesDirectory = getParameters().converterOptions.commonModulesDirectory;\n        if (modulesDirectory == null) {\n          modulesDirectory = path;\n        }\n        final String moduleName = EclipseProjectFinder.findProjectName(path);\n        moduleNames.add(moduleName);\n        final File imlFile = new File(modulesDirectory + File.separator + moduleName + IdeaXml.IML_EXT);\n        if (imlFile.isFile()) {\n          files.add(imlFile);\n        }\n        final File emlFile = new File(modulesDirectory + File.separator + moduleName + EclipseXml.IDEA_SETTINGS_POSTFIX);\n        if (emlFile.isFile()) {\n          files.add(emlFile);\n        }\n      }\n      if (!files.isEmpty()) {\n        final int resultCode = Messages.showYesNoCancelDialog(ApplicationInfoEx.getInstanceEx().getFullApplicationName() +\n                                                              \" module files found:\\n\" +\n                                                              StringUtil.join(files,new Function<File, String>() {\n                                                                public String fun(File file) {\n                                                                  return file.getPath();\n                                                                }\n                                                              }, \"\\n\") +\n                                                              \".\\n Would you like to reuse them?\", \"Module Files Found\",\n                                                              Messages.getQuestionIcon());\n        if (resultCode != Messages.YES) {\n          if (resultCode == Messages.NO) {\n            final LocalFileSystem localFileSystem = LocalFileSystem.getInstance();\n            for (File file : files) {\n              final VirtualFile virtualFile = localFileSystem.findFileByIoFile(file);\n              if (virtualFile != null) {\n                ApplicationManager.getApplication().runWriteAction(new ThrowableComputable<Void, IOException>() {\n                  @Override\n                  public Void compute() throws IOException {\n                    virtualFile.delete(this);\n                    return null;\n                  }\n                });\n              }\n              else {\n                FileUtil.delete(file);\n              }\n            }\n          } else {\n            return result;\n          }\n        }\n      }\n      int idx = 0;\n      for (String path : getParameters().projectsToConvert) {\n        String modulesDirectory = getParameters().converterOptions.commonModulesDirectory;\n        if (modulesDirectory == null) {\n          modulesDirectory = path;\n        }\n        final Module module = moduleModel.newModule(modulesDirectory + \"/\" + EclipseProjectFinder.findProjectName(path) + IdeaXml.IML_EXT,\n                                                    StdModuleTypes.JAVA.getId());\n        result.add(module);\n        final Set<String> natures = collectNatures(path);\n\n        if (natures.size() > 0) {\n          module2NatureNames.put(module, natures);\n        }\n        final ModifiableRootModel rootModel = ModuleRootManager.getInstance(module).getModifiableModel();\n        rootModels[idx++] = rootModel;\n\n        final File classpathFile = new File(path, EclipseXml.DOT_CLASSPATH_EXT);\n        final EclipseClasspathReader classpathReader = new EclipseClasspathReader(path, project, getParameters().projectsToConvert, moduleNames);\n        classpathReader.init(rootModel);\n        if (classpathFile.exists()) {\n          Element classpathElement = JDOMUtil.load(classpathFile);\n          classpathReader.readClasspath(rootModel, unknownLibraries, unknownJdks, refsToModules,\n                                        getParameters().converterOptions.testPattern, classpathElement);\n        }\n        else {\n          EclipseClasspathReader.setOutputUrl(rootModel, path + \"/bin\");\n        }\n        ClasspathStorage.setStorageType(rootModel,\n                                        getParameters().linkConverted ? JpsEclipseClasspathSerializer.CLASSPATH_STORAGE_ID : ClassPathStorageUtil.DEFAULT_STORAGE);\n        if (model != null) {\n          ApplicationManager.getApplication().runWriteAction(new Runnable() {\n            public void run() {\n              rootModel.commit();\n            }\n          });\n        }\n      }\n      if (model == null) {\n        ApplicationManager.getApplication().runWriteAction(new Runnable() {\n          public void run() {\n            ModifiableModelCommitter.multiCommit(rootModels, moduleModel);\n          }\n        });\n      }\n    }\n    catch (Exception e) {\n      LOG.error(e);\n    }\n    scheduleNaturesImporting(project, module2NatureNames);\n    createEclipseLibrary(project, unknownLibraries, IdeaXml.ECLIPSE_LIBRARY);\n\n    StringBuilder message = new StringBuilder();\n    refsToModules.removeAll(getParameters().existingModuleNames);\n    for (String path : getParameters().projectsToConvert) {\n      final String projectName = EclipseProjectFinder.findProjectName(path);\n      if (projectName != null) {\n        refsToModules.remove(projectName);\n        getParameters().existingModuleNames.add(projectName);\n      }\n    }\n    if (!refsToModules.isEmpty()) {\n\n      message.append(\"Unknown modules detected\");\n      for (String module : refsToModules) {\n        message.append(\"\\n\").append(module);\n      }\n    }\n    if (!unknownJdks.isEmpty()) {\n      if (message.length() > 0){\n        message.append(\"\\nand jdks\");\n      } else {\n        message.append(\"Imported project refers to unknown jdks\");\n      }\n      for (String unknownJdk : unknownJdks) {\n        message.append(\"\\n\").append(unknownJdk);\n      }\n    }\n    if (!unknownLibraries.isEmpty()) {\n      final StringBuilder buf = new StringBuilder();\n      buf.append(\"<html><body>\");\n      buf.append(EclipseBundle.message(\"eclipse.import.warning.undefinded.libraries\"));\n      for (String name : unknownLibraries) {\n        buf.append(\"<br>\").append(name);\n      }\n      if (model == null) {\n        buf.append(\"<br><b>Please export Eclipse user libraries and import them now from resulted .userlibraries file<\/b>\");\n        buf.append(\"<\/body><\/html>\");\n        final FileChooserDescriptor descriptor = new FileChooserDescriptor(true, false, false, false, false, false) {\n          @Override\n          public boolean isFileSelectable(VirtualFile file) {\n            return super.isFileSelectable(file) && Comparing.strEqual(file.getExtension(), \"userlibraries\");\n          }\n        };\n        descriptor.setDescription(buf.toString());\n        descriptor.setTitle(getTitle());\n        final VirtualFile selectedFile = FileChooser.chooseFile(descriptor, project, project.getBaseDir());\n        if (selectedFile != null) {\n          try {\n            EclipseUserLibrariesHelper.readProjectLibrariesContent(selectedFile, project, unknownLibraries);\n          }\n          catch (Exception e) {\n            LOG.error(e);\n          }\n        }\n      }\n    }\n\n    if (message.length() > 0) {\n      Messages.showErrorDialog(project, message.toString(), getTitle());\n    }\n\n    return result;\n  }","commit_id":"689d2f56394e0dc39fa9146eddbc36b92175f4ab","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void readProjectLibrariesContent(File exportedFile, Project project, Collection<String> unknownLibraries)\n    throws IOException, JDOMException {\n    if (exportedFile.exists()) {\n      final LibraryTable libraryTable = ProjectLibraryTable.getInstance(project);\n      final Element rootElement = JDOMUtil.loadDocument(exportedFile).getRootElement();\n      for (Object o : rootElement.getChildren(\"library\")) {\n        final Element libElement = (Element)o;\n        final String libName = libElement.getAttributeValue(\"name\");\n        Library libraryByName = libraryTable.getLibraryByName(libName);\n        if (libraryByName == null) {\n          final LibraryTable.ModifiableModel model = libraryTable.getModifiableModel();\n          libraryByName = model.createLibrary(libName);\n          model.commit();\n        }\n        if (libraryByName != null) {\n          final Library.ModifiableModel model = libraryByName.getModifiableModel();\n          for (Object a : libElement.getChildren(\"archive\")) {\n            String rootPath = ((Element)a).getAttributeValue(\"path\");\n            if (rootPath.startsWith(\"/\")) { //relative to workspace root\n              rootPath = project.getBaseDir().getPath() + rootPath;\n            }\n            String url = VfsUtil.pathToUrl(rootPath);\n            final VirtualFile localFile = VirtualFileManager.getInstance().findFileByUrl(url);\n            if (localFile != null) {\n              final VirtualFile jarFile = JarFileSystem.getInstance().getJarRootForLocalFile(localFile);\n              if (jarFile != null) {\n                url = jarFile.getUrl();\n              }\n            }\n            model.addRoot(url, OrderRootType.CLASSES);\n          }\n          model.commit();\n        }\n        unknownLibraries.remove(libName);  //ignore finally found libraries\n      }\n    }\n  }","id":99246,"modified_method":"public static void readProjectLibrariesContent(@NotNull VirtualFile exportedFile, Project project, Collection<String> unknownLibraries)\n    throws IOException, JDOMException {\n    if (!exportedFile.isValid()) {\n      return;\n    }\n\n    LibraryTable libraryTable = ProjectLibraryTable.getInstance(project);\n    Element element = JDOMUtil.load(exportedFile.getInputStream());\n    AccessToken token = WriteAction.start();\n    try {\n      for (Element libElement : element.getChildren(\"library\")) {\n        String libName = libElement.getAttributeValue(\"name\");\n        Library libraryByName = libraryTable.getLibraryByName(libName);\n        if (libraryByName == null) {\n          LibraryTable.ModifiableModel model = libraryTable.getModifiableModel();\n          libraryByName = model.createLibrary(libName);\n          model.commit();\n        }\n        if (libraryByName != null) {\n          Library.ModifiableModel model = libraryByName.getModifiableModel();\n          for (Element a : libElement.getChildren(\"archive\")) {\n            String rootPath = a.getAttributeValue(\"path\");\n            // IDEA-138039 Eclipse import: Unix file system: user library gets wrong paths\n            LocalFileSystem fileSystem = LocalFileSystem.getInstance();\n            VirtualFile localFile = fileSystem.findFileByPath(rootPath);\n            if (rootPath.startsWith(\"/\") && (localFile == null || !localFile.isValid())) {\n              // relative to workspace root\n              rootPath = project.getBaseDir().getPath() + rootPath;\n              localFile = fileSystem.findFileByPath(rootPath);\n            }\n            String url = localFile == null ? VfsUtilCore.pathToUrl(rootPath) : localFile.getUrl();\n            if (localFile != null) {\n              VirtualFile jarFile = JarFileSystem.getInstance().getJarRootForLocalFile(localFile);\n              if (jarFile != null) {\n                url = jarFile.getUrl();\n              }\n            }\n            model.addRoot(url, OrderRootType.CLASSES);\n          }\n          model.commit();\n        }\n        unknownLibraries.remove(libName);  //ignore finally found libraries\n      }\n    }\n    finally {\n      token.finish();\n    }\n  }","commit_id":"689d2f56394e0dc39fa9146eddbc36b92175f4ab","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String getUrl(final String path) {\n    if (path.startsWith(\"/\")) {\n      final String relativePath = new File(myRootPath).getParent() + \"/\" + path;\n      final File file = new File(relativePath);\n      if (file.exists()) {\n        return VfsUtil.pathToUrl(relativePath);\n      }\n    }\n    final String absPath = myRootPath + \"/\" + path;\n    if (new File(absPath).exists()) return VfsUtil.pathToUrl(absPath);\n    return VfsUtil.pathToUrl(path);\n  }","id":99247,"modified_method":"private String getUrl(final String path) {\n    String url = null;\n    if (path.startsWith(\"/\")) {\n      final String relativePath = new File(myRootPath).getParent() + \"/\" + path;\n      final File file = new File(relativePath);\n      if (file.exists()) {\n        url = VfsUtil.pathToUrl(relativePath);\n      }\n    }\n    if (url == null) {\n      final String absPath = myRootPath + \"/\" + path;\n      if (new File(absPath).exists()) {\n        url = VfsUtil.pathToUrl(absPath);\n      } else {\n        url = VfsUtil.pathToUrl(path);\n      }\n    }\n    final VirtualFile localFile = VirtualFileManager.getInstance().findFileByUrl(url);\n    if (localFile != null) {\n      final VirtualFile jarFile = JarFileSystem.getInstance().getJarRootForLocalFile(localFile);\n      if (jarFile != null) {\n        url = jarFile.getUrl();\n      }\n    }\n    return url;\n  }","commit_id":"d4be55eebb67bbe50d33a51a7c0c11bc1c550f1e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void handleViewChange(Vector mbrs) {\n        Address addr;\n        if(mbrs == null) return;\n\n        if(log.isTraceEnabled()) log.trace(\"new membership: \" + mbrs);\n        members.clear();\n        members.addAll(mbrs);\n\n        synchronized(received) {\n            // add members not in membership to received hashmap (with full credits)\n            for(int i=0; i < mbrs.size(); i++) {\n                addr=(Address) mbrs.elementAt(i);\n                if(!received.containsKey(addr))\n                    received.put(addr, new Long(max_credits));\n            }\n            // remove members that left\n            for(Iterator it=received.keySet().iterator(); it.hasNext();) {\n                addr=(Address) it.next();\n                if(!mbrs.contains(addr))\n                    it.remove();\n            }\n        }\n\n        synchronized(sent) {\n            // add members not in membership to sent hashmap (with full credits)\n            for(int i=0; i < mbrs.size(); i++) {\n                addr=(Address) mbrs.elementAt(i);\n                if(!sent.containsKey(addr))\n                    sent.put(addr, new Long(max_credits));\n            }\n            // remove members that left\n            for(Iterator it=sent.keySet().iterator(); it.hasNext();) {\n                addr=(Address)it.next();\n                if(!mbrs.contains(addr))\n                    it.remove(); // modified the underlying map\n            }\n\n\n\n            // remove all creditors which are not in the new view\n            for(Iterator it=creditors.iterator(); it.hasNext();) {\n                Address creditor=(Address) it.next();\n                if(!mbrs.contains(creditor))\n                    it.remove();\n            }\n\n            if(log.isTraceEnabled()) log.trace(\"creditors are\\n\" + printCreditors());\n            if(creditors.size() == 0 && blocking.get().equals(Boolean.TRUE))\n                unblockSender();\n        }\n    }","id":99248,"modified_method":"void handleViewChange(Vector mbrs) {\n        Address addr;\n        if(mbrs == null) return;\n\n        if(log.isTraceEnabled()) log.trace(\"new membership: \" + mbrs);\n        members.clear();\n        members.addAll(mbrs);\n\n        synchronized(received) {\n            // add members not in membership to received hashmap (with full credits)\n            for(int i=0; i < mbrs.size(); i++) {\n                addr=(Address) mbrs.elementAt(i);\n                if(!received.containsKey(addr))\n                    received.put(addr, new Long(max_credits));\n            }\n            // remove members that left\n            for(Iterator it=received.keySet().iterator(); it.hasNext();) {\n                addr=(Address) it.next();\n                if(!mbrs.contains(addr))\n                    it.remove();\n            }\n        }\n\n        boolean unblock=false;\n        synchronized(sent) {\n            // add members not in membership to sent hashmap (with full credits)\n            for(int i=0; i < mbrs.size(); i++) {\n                addr=(Address) mbrs.elementAt(i);\n                if(!sent.containsKey(addr))\n                    sent.put(addr, new Long(max_credits));\n            }\n            // remove members that left\n            for(Iterator it=sent.keySet().iterator(); it.hasNext();) {\n                addr=(Address)it.next();\n                if(!mbrs.contains(addr))\n                    it.remove(); // modified the underlying map\n            }\n\n            // remove all creditors which are not in the new view\n            for(Iterator it=creditors.iterator(); it.hasNext();) {\n                Address creditor=(Address) it.next();\n                if(!mbrs.contains(creditor))\n                    it.remove();\n            }\n\n            if(log.isTraceEnabled()) log.trace(\"creditors are\\n\" + printCreditors());\n            if(creditors.size() == 0)\n                unblock=true;\n        }\n        if(unblock)\n            unblockSender();\n    }","commit_id":"bf7ee5875c9175d317efeadc8b4d0a7510bf3309","url":"https://github.com/belaban/JGroups"},{"original_method":"public void unblock() {\n        synchronized(sent) {\n            unblockSender();\n        }\n    }","id":99249,"modified_method":"public void unblock() {\n        unblockSender();\n    }","commit_id":"bf7ee5875c9175d317efeadc8b4d0a7510bf3309","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleCredit(Address sender) {\n        if(sender == null) return;\n        StringBuffer sb=null;\n\n        synchronized(sent) {\n            if(log.isTraceEnabled()) {\n                Long old_credit=(Long)sent.get(sender);\n                sb=new StringBuffer();\n                sb.append(\"received credit from \").append(sender).append(\", old credit was \").\n                        append(old_credit).append(\", new credits are \").append(max_credits).\n                        append(\".\\nCreditors before are: \").append(printCreditors());\n            }\n\n            sent.put(sender, new Long(max_credits));\n            if(creditors.size() > 0) {  // we are blocked because we expect credit from one or more members\n                removeCreditor(sender);\n                if(log.isTraceEnabled()) {\n                    sb.append(\"\\nCreditors after removal of \").append(sender).append(\" are: \").append(printCreditors());\n                    log.trace(sb.toString());\n                }\n                if(creditors.size() == 0) {\n                    unblockSender(); // triggers sent.notifyAll()...\n                }\n            }\n        }\n    }","id":99250,"modified_method":"private void handleCredit(Address sender) {\n        if(sender == null) return;\n        StringBuffer sb=null;\n        boolean unblock=false;\n\n        synchronized(sent) {\n            if(log.isTraceEnabled()) {\n                Long old_credit=(Long)sent.get(sender);\n                sb=new StringBuffer();\n                sb.append(\"received credit from \").append(sender).append(\", old credit was \").\n                        append(old_credit).append(\", new credits are \").append(max_credits).\n                        append(\".\\nCreditors before are: \").append(printCreditors());\n            }\n\n            sent.put(sender, new Long(max_credits));\n            if(creditors.size() > 0) {  // we are blocked because we expect credit from one or more members\n                removeCreditor(sender);\n                if(log.isTraceEnabled()) {\n                    sb.append(\"\\nCreditors after removal of \").append(sender).append(\" are: \").append(printCreditors());\n                    log.trace(sb.toString());\n                }\n                if(creditors.size() == 0) {\n                    unblock=true;\n                }\n            }\n        }\n        if(unblock) // moved this outside of the 'sent' synchronized block\n            unblockSender();\n    }","commit_id":"bf7ee5875c9175d317efeadc8b4d0a7510bf3309","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Checks whether enough credits are available to send message. If not, blocks until enough credits\n     * are available\n     * @param evt Guaranteed to be a Message\n     * @return\n     */\n    private void waitUntilEnoughCreditsAvailable(Message msg) {\n        boolean looping=true;\n        // not enough credits, block until replenished with credits\n        synchronized(sent) { // 'sent' is the same lock as blocking.getLock()...\n            if(decrMessage(msg) == false) {\n                if(log.isTraceEnabled())\n                    log.trace(\"blocking due to insufficient credits, creditors=\\n\" + printCreditors());\n                blocking.set(Boolean.TRUE);\n                start_blocking=System.currentTimeMillis();\n                num_blockings++;\n                while(looping) {\n                    try {\n                        blocking.waitUntilWithTimeout(Boolean.FALSE, max_block_time);  // waits on 'sent'\n                        looping=false;\n                    }\n                    catch(TimeoutException e) {\n                        if(log.isTraceEnabled())\n                            log.trace(\"timeout occurred waiting for credits; sending credit request to \" + creditors);\n                        List tmp=new ArrayList(creditors);\n                        Address mbr;\n                        for(Iterator it=tmp.iterator(); it.hasNext();) {\n                            mbr=(Address)it.next();\n                            sendCreditRequest(mbr);\n                        }\n                    }\n                }\n            }\n        }\n    }","id":99251,"modified_method":"/**\n     * Checks whether enough credits are available to send message. If not, blocks until enough credits\n     * are available\n     * @param evt Guaranteed to be a Message\n     * @return\n     */\n    private void waitUntilEnoughCreditsAvailable(Message msg) {\n        // not enough credits, block until replenished with credits\n        boolean rc;\n        synchronized(sent) { // 'sent' is the same lock as blocking.getLock()...\n            rc=decrMessage(msg);\n        }\n\n        if(rc == false) {\n            if(log.isTraceEnabled())\n                log.trace(\"blocking due to insufficient credits\");\n            blocking.set(Boolean.TRUE);\n            start_blocking=System.currentTimeMillis();\n            num_blockings++;\n            while(true) {\n                try {\n                    blocking.waitUntilWithTimeout(Boolean.FALSE, max_block_time);  // waits on 'sent'\n                    break;\n                }\n                catch(TimeoutException e) {\n                    if(log.isTraceEnabled())\n                        log.trace(\"timeout occurred waiting for credits; sending credit request to \" + creditors);\n                    List tmp=new ArrayList(creditors);\n                    Address mbr;\n                    for(Iterator it=tmp.iterator(); it.hasNext();) {\n                        mbr=(Address)it.next();\n                        sendCreditRequest(mbr);\n                    }\n                }\n            }\n        }\n    }","commit_id":"bf7ee5875c9175d317efeadc8b4d0a7510bf3309","url":"https://github.com/belaban/JGroups"},{"original_method":"public void down(final Event evt) {\n        switch(evt.getType()) {\n        case Event.VIEW_CHANGE:\n            // this has to be run in a separate thread because waitUntilEnoughCreditsAvailable() might block,\n            // and the view change could potentially unblock it\n            new Thread() {\n                public void run() {\n                    handleViewChange(((View)evt.getArg()).getMembers());\n                }\n            }.start();\n            break;\n        case Event.MSG:\n            passDown(evt); // let this one go, but block on the next message if not sufficient credit\n            // blocks until enought credits are available to send message\n            waitUntilEnoughCreditsAvailable((Message)evt.getArg());\n            return;\n        }\n        passDown(evt); // this could potentially use the lower protocol's thread which may block\n    }","id":99252,"modified_method":"public void down(final Event evt) {\n        switch(evt.getType()) {\n        case Event.VIEW_CHANGE:\n            // this has to be run in a separate thread because waitUntilEnoughCreditsAvailable() might block,\n            // and the view change could potentially unblock it\n            // doesn't work ! Because we're not even getting the VIEW event if the MSG event blocks !\n            // This was moved to receiveDownEvent() above, which is concurrent to down(MSG). bela July 29 2005\n//            new Thread() {\n//                public void run() {\n//                    handleViewChange(((View)evt.getArg()).getMembers());\n//                }\n//            }.start();\n            break;\n        case Event.MSG:\n            passDown(evt); // let this one go, but block on the next message if not sufficient credit\n            // blocks until enought credits are available to send message\n            waitUntilEnoughCreditsAvailable((Message)evt.getArg());\n            return;\n        }\n        passDown(evt); // this could potentially use the lower protocol's thread which may block\n    }","commit_id":"bf7ee5875c9175d317efeadc8b4d0a7510bf3309","url":"https://github.com/belaban/JGroups"},{"original_method":"/** If message queueing is enabled, sends queued messages and unlocks sender (if successful) */\n    private void unblockSender() {\n        // **********************************************************************\n        // always called with 'sent' lock acquired, so we don't need to sync here\n        // **********************************************************************\n        blocking.set(Boolean.FALSE);\n        printBlockTime();\n    }","id":99253,"modified_method":"/** If message queueing is enabled, sends queued messages and unlocks sender (if successful) */\n    private void unblockSender() {\n        stop_blocking=System.currentTimeMillis();\n        long diff=stop_blocking - start_blocking;\n        total_time_blocking+=diff;\n        last_blockings.add(new Long(diff));\n        stop_blocking=start_blocking=0;\n        if(log.isTraceEnabled())\n            log.trace(\"setting blocking=false, blocking time was \" + diff + \"ms\");\n        blocking.set(Boolean.FALSE);\n    }","commit_id":"bf7ee5875c9175d317efeadc8b4d0a7510bf3309","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Checks whether enough credits are available to send message. If not, blocks until enough credits\n     * are available\n     * @param evt Guaranteed to be a Message\n     * @return\n     */\n    private void waitUntilEnoughCreditsAvailable(Message msg) {\n        boolean looping=true;\n        // not enough credits, block until replenished with credits\n        synchronized(sent) { // 'sent' is the same lock as blocking.getLock()...\n            if(decrMessage(msg) == false) {\n                if(log.isTraceEnabled())\n                    log.trace(\"blocking due to insufficient credits, creditors=\\n\" + printCreditors());\n                blocking.set(Boolean.TRUE);\n                start_blocking=System.currentTimeMillis();\n                num_blockings++;\n                while(looping) {\n                    try {\n                        blocking.waitUntilWithTimeout(Boolean.FALSE, max_block_time);  // waits on 'sent'\n                        looping=false;\n                    }\n                    catch(TimeoutException e) {\n                        if(log.isTraceEnabled())\n                            log.trace(\"timeout occurred waiting for credits; sending credit request to \" + creditors);\n                        List tmp=new ArrayList(creditors);\n                        Address mbr;\n                        for(Iterator it=tmp.iterator(); it.hasNext();) {\n                            mbr=(Address)it.next();\n                            sendCreditRequest(mbr);\n                        }\n                    }\n                }\n            }\n        }\n    }","id":99254,"modified_method":"/**\n     * Checks whether enough credits are available to send message. If not, blocks until enough credits\n     * are available\n     * @param evt Guaranteed to be a Message\n     * @return\n     */\n    private void waitUntilEnoughCreditsAvailable(Message msg) {\n        // not enough credits, block until replenished with credits\n        boolean rc;\n        synchronized(sent) { // 'sent' is the same lock as blocking.getLock()...\n            rc=decrMessage(msg);\n        }\n\n        if(rc == false) {\n            if(log.isTraceEnabled())\n                log.trace(\"blocking due to insufficient credits\");\n            blocking.set(Boolean.TRUE);\n            start_blocking=System.currentTimeMillis();\n            num_blockings++;\n            while(true) {\n                try {\n                    blocking.waitUntilWithTimeout(Boolean.FALSE, max_block_time);  // waits on 'sent'\n                    break;\n                }\n                catch(TimeoutException e) {\n                    if(log.isTraceEnabled())\n                        log.trace(\"timeout occurred waiting for credits; sending credit request to \" + creditors);\n                    List tmp=new ArrayList(creditors);\n                    Address mbr;\n                    for(Iterator it=tmp.iterator(); it.hasNext();) {\n                        mbr=(Address)it.next();\n                        sendCreditRequest(mbr);\n                    }\n                }\n            }\n        }\n    }","commit_id":"e1c8699f19bd3341b0594caa032b9b5b8c69c757","url":"https://github.com/belaban/JGroups"},{"original_method":"public void unblock() {\n        synchronized(sent) {\n            unblockSender();\n        }\n    }","id":99255,"modified_method":"public void unblock() {\n        unblockSender();\n    }","commit_id":"e1c8699f19bd3341b0594caa032b9b5b8c69c757","url":"https://github.com/belaban/JGroups"},{"original_method":"public void down(final Event evt) {\n        switch(evt.getType()) {\n        case Event.VIEW_CHANGE:\n            // this has to be run in a separate thread because waitUntilEnoughCreditsAvailable() might block,\n            // and the view change could potentially unblock it\n            new Thread() {\n                public void run() {\n                    handleViewChange(((View)evt.getArg()).getMembers());\n                }\n            }.start();\n            break;\n        case Event.MSG:\n            passDown(evt); // let this one go, but block on the next message if not sufficient credit\n            // blocks until enought credits are available to send message\n            waitUntilEnoughCreditsAvailable((Message)evt.getArg());\n            return;\n        }\n        passDown(evt); // this could potentially use the lower protocol's thread which may block\n    }","id":99256,"modified_method":"public void down(final Event evt) {\n        switch(evt.getType()) {\n        case Event.VIEW_CHANGE:\n            // this has to be run in a separate thread because waitUntilEnoughCreditsAvailable() might block,\n            // and the view change could potentially unblock it\n            // doesn't work ! Because we're not even getting the VIEW event if the MSG event blocks !\n            // This was moved to receiveDownEvent() above, which is concurrent to down(MSG). bela July 29 2005\n//            new Thread() {\n//                public void run() {\n//                    handleViewChange(((View)evt.getArg()).getMembers());\n//                }\n//            }.start();\n            break;\n        case Event.MSG:\n            passDown(evt); // let this one go, but block on the next message if not sufficient credit\n            // blocks until enought credits are available to send message\n            waitUntilEnoughCreditsAvailable((Message)evt.getArg());\n            return;\n        }\n        passDown(evt); // this could potentially use the lower protocol's thread which may block\n    }","commit_id":"e1c8699f19bd3341b0594caa032b9b5b8c69c757","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleCredit(Address sender) {\n        if(sender == null) return;\n        StringBuffer sb=null;\n\n        synchronized(sent) {\n            if(log.isTraceEnabled()) {\n                Long old_credit=(Long)sent.get(sender);\n                sb=new StringBuffer();\n                sb.append(\"received credit from \").append(sender).append(\", old credit was \").\n                        append(old_credit).append(\", new credits are \").append(max_credits).\n                        append(\".\\nCreditors before are: \").append(printCreditors());\n            }\n\n            sent.put(sender, new Long(max_credits));\n            if(creditors.size() > 0) {  // we are blocked because we expect credit from one or more members\n                removeCreditor(sender);\n                if(log.isTraceEnabled()) {\n                    sb.append(\"\\nCreditors after removal of \").append(sender).append(\" are: \").append(printCreditors());\n                    log.trace(sb.toString());\n                }\n                if(creditors.size() == 0) {\n                    unblockSender(); // triggers sent.notifyAll()...\n                }\n            }\n        }\n    }","id":99257,"modified_method":"private void handleCredit(Address sender) {\n        if(sender == null) return;\n        StringBuffer sb=null;\n        boolean unblock=false;\n\n        synchronized(sent) {\n            if(log.isTraceEnabled()) {\n                Long old_credit=(Long)sent.get(sender);\n                sb=new StringBuffer();\n                sb.append(\"received credit from \").append(sender).append(\", old credit was \").\n                        append(old_credit).append(\", new credits are \").append(max_credits).\n                        append(\".\\nCreditors before are: \").append(printCreditors());\n            }\n\n            sent.put(sender, new Long(max_credits));\n            if(creditors.size() > 0) {  // we are blocked because we expect credit from one or more members\n                removeCreditor(sender);\n                if(log.isTraceEnabled()) {\n                    sb.append(\"\\nCreditors after removal of \").append(sender).append(\" are: \").append(printCreditors());\n                    log.trace(sb.toString());\n                }\n                if(creditors.size() == 0) {\n                    unblock=true;\n                }\n            }\n        }\n        if(unblock) // moved this outside of the 'sent' synchronized block\n            unblockSender();\n    }","commit_id":"e1c8699f19bd3341b0594caa032b9b5b8c69c757","url":"https://github.com/belaban/JGroups"},{"original_method":"void handleViewChange(Vector mbrs) {\n        Address addr;\n        if(mbrs == null) return;\n\n        if(log.isTraceEnabled()) log.trace(\"new membership: \" + mbrs);\n        members.clear();\n        members.addAll(mbrs);\n\n        synchronized(received) {\n            // add members not in membership to received hashmap (with full credits)\n            for(int i=0; i < mbrs.size(); i++) {\n                addr=(Address) mbrs.elementAt(i);\n                if(!received.containsKey(addr))\n                    received.put(addr, new Long(max_credits));\n            }\n            // remove members that left\n            for(Iterator it=received.keySet().iterator(); it.hasNext();) {\n                addr=(Address) it.next();\n                if(!mbrs.contains(addr))\n                    it.remove();\n            }\n        }\n\n        synchronized(sent) {\n            // add members not in membership to sent hashmap (with full credits)\n            for(int i=0; i < mbrs.size(); i++) {\n                addr=(Address) mbrs.elementAt(i);\n                if(!sent.containsKey(addr))\n                    sent.put(addr, new Long(max_credits));\n            }\n            // remove members that left\n            for(Iterator it=sent.keySet().iterator(); it.hasNext();) {\n                addr=(Address)it.next();\n                if(!mbrs.contains(addr))\n                    it.remove(); // modified the underlying map\n            }\n\n\n\n            // remove all creditors which are not in the new view\n            for(Iterator it=creditors.iterator(); it.hasNext();) {\n                Address creditor=(Address) it.next();\n                if(!mbrs.contains(creditor))\n                    it.remove();\n            }\n\n            if(log.isTraceEnabled()) log.trace(\"creditors are\\n\" + printCreditors());\n            if(creditors.size() == 0 && blocking.get().equals(Boolean.TRUE))\n                unblockSender();\n        }\n    }","id":99258,"modified_method":"void handleViewChange(Vector mbrs) {\n        Address addr;\n        if(mbrs == null) return;\n\n        if(log.isTraceEnabled()) log.trace(\"new membership: \" + mbrs);\n        members.clear();\n        members.addAll(mbrs);\n\n        synchronized(received) {\n            // add members not in membership to received hashmap (with full credits)\n            for(int i=0; i < mbrs.size(); i++) {\n                addr=(Address) mbrs.elementAt(i);\n                if(!received.containsKey(addr))\n                    received.put(addr, new Long(max_credits));\n            }\n            // remove members that left\n            for(Iterator it=received.keySet().iterator(); it.hasNext();) {\n                addr=(Address) it.next();\n                if(!mbrs.contains(addr))\n                    it.remove();\n            }\n        }\n\n        boolean unblock=false;\n        synchronized(sent) {\n            // add members not in membership to sent hashmap (with full credits)\n            for(int i=0; i < mbrs.size(); i++) {\n                addr=(Address) mbrs.elementAt(i);\n                if(!sent.containsKey(addr))\n                    sent.put(addr, new Long(max_credits));\n            }\n            // remove members that left\n            for(Iterator it=sent.keySet().iterator(); it.hasNext();) {\n                addr=(Address)it.next();\n                if(!mbrs.contains(addr))\n                    it.remove(); // modified the underlying map\n            }\n\n            // remove all creditors which are not in the new view\n            for(Iterator it=creditors.iterator(); it.hasNext();) {\n                Address creditor=(Address) it.next();\n                if(!mbrs.contains(creditor))\n                    it.remove();\n            }\n\n            if(log.isTraceEnabled()) log.trace(\"creditors are\\n\" + printCreditors());\n            if(creditors.size() == 0)\n                unblock=true;\n        }\n        if(unblock)\n            unblockSender();\n    }","commit_id":"e1c8699f19bd3341b0594caa032b9b5b8c69c757","url":"https://github.com/belaban/JGroups"},{"original_method":"/** If message queueing is enabled, sends queued messages and unlocks sender (if successful) */\n    private void unblockSender() {\n        // **********************************************************************\n        // always called with 'sent' lock acquired, so we don't need to sync here\n        // **********************************************************************\n        blocking.set(Boolean.FALSE);\n        printBlockTime();\n    }","id":99259,"modified_method":"/** If message queueing is enabled, sends queued messages and unlocks sender (if successful) */\n    private void unblockSender() {\n        stop_blocking=System.currentTimeMillis();\n        long diff=stop_blocking - start_blocking;\n        total_time_blocking+=diff;\n        last_blockings.add(new Long(diff));\n        stop_blocking=start_blocking=0;\n        if(log.isTraceEnabled())\n            log.trace(\"setting blocking=false, blocking time was \" + diff + \"ms\");\n        blocking.set(Boolean.FALSE);\n    }","commit_id":"e1c8699f19bd3341b0594caa032b9b5b8c69c757","url":"https://github.com/belaban/JGroups"},{"original_method":"public void serializeForSSTable(ColumnFamily columnFamily, DataOutput dos)\n    {\n        try\n        {\n            serializeCFInfo(columnFamily, dos);\n\n            Collection<IColumn> columns = columnFamily.getSortedColumns();\n            int count = columns.size();\n            dos.writeInt(count);\n            for (IColumn column : columns)\n                columnFamily.getColumnSerializer().serialize(column, dos);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(e);\n        }\n    }","id":99260,"modified_method":"public void serializeForSSTable(ColumnFamily columnFamily, DataOutput dos)\n    {\n        try\n        {\n            serializeCFInfo(columnFamily, dos);\n\n            Collection<IColumn> columns = columnFamily.getSortedColumns();\n            int count = columns.size();\n            dos.writeInt(count);\n\n            IColumnSerializer columnSerializer = columnFamily.getColumnSerializer();\n            for (IColumn column : columns)\n                columnSerializer.serialize(column, dos);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"17dd5cd18736a11255dad686286aa0b30ead8a42","url":"https://github.com/apache/cassandra"},{"original_method":"public void deserializeColumns(DataInput dis, ColumnFamily cf, int size, IColumnSerializer.Flag flag) throws IOException\n    {\n        for (int i = 0; i < size; ++i)\n        {\n            IColumn column = cf.getColumnSerializer().deserialize(dis, flag, (int) (System.currentTimeMillis() / 1000));\n            cf.addColumn(column);\n        }\n    }","id":99261,"modified_method":"public void deserializeColumns(DataInput dis, ColumnFamily cf, int size, IColumnSerializer.Flag flag) throws IOException\n    {\n        IColumnSerializer columnSerializer = cf.getColumnSerializer();\n        for (int i = 0; i < size; ++i)\n        {\n            IColumn column = columnSerializer.deserialize(dis, flag, (int) (System.currentTimeMillis() / 1000));\n            cf.addColumn(column);\n        }\n    }","commit_id":"17dd5cd18736a11255dad686286aa0b30ead8a42","url":"https://github.com/apache/cassandra"},{"original_method":"private SimpleBlockFetcher() throws IOException\n        {\n            int columns = file.readInt();\n            for (int i = 0; i < columns; i++)\n            {\n                IColumn column = emptyColumnFamily.getColumnSerializer().deserialize(file);\n                if (reversed)\n                    blockColumns.addFirst(column);\n                else\n                    blockColumns.addLast(column);\n\n                /* see if we can stop seeking. */\n                boolean outOfBounds = false;\n                if (!reversed && finishColumn.remaining() > 0)\n                    outOfBounds = comparator.compare(column.name(), finishColumn) >= 0;\n                else if (reversed && startColumn.remaining() > 0)\n                    outOfBounds = comparator.compare(column.name(), startColumn) >= 0;\n                if (outOfBounds)\n                    break;\n            }\n        }","id":99262,"modified_method":"private SimpleBlockFetcher() throws IOException\n        {\n            IColumnSerializer columnSerializer = emptyColumnFamily.getColumnSerializer();\n            int columns = file.readInt();\n            for (int i = 0; i < columns; i++)\n            {\n                IColumn column = columnSerializer.deserialize(file);\n                if (reversed)\n                    blockColumns.addFirst(column);\n                else\n                    blockColumns.addLast(column);\n\n                /* see if we can stop seeking. */\n                boolean outOfBounds = false;\n                if (!reversed && finishColumn.remaining() > 0)\n                    outOfBounds = comparator.compare(column.name(), finishColumn) >= 0;\n                else if (reversed && startColumn.remaining() > 0)\n                    outOfBounds = comparator.compare(column.name(), startColumn) >= 0;\n                if (outOfBounds)\n                    break;\n            }\n        }","commit_id":"17dd5cd18736a11255dad686286aa0b30ead8a42","url":"https://github.com/apache/cassandra"},{"original_method":"public boolean getNextBlock() throws IOException\n        {\n            if (curRangeIndex < 0 || curRangeIndex >= indexes.size())\n                return false;\n\n            /* seek to the correct offset to the data, and calculate the data size */\n            IndexHelper.IndexInfo curColPosition = indexes.get(curRangeIndex);\n\n            /* see if this read is really necessary. */\n            if (reversed)\n            {\n                if ((finishColumn.remaining() > 0 && comparator.compare(finishColumn, curColPosition.lastName) > 0) ||\n                    (startColumn.remaining() > 0 && comparator.compare(startColumn, curColPosition.firstName) < 0))\n                    return false;\n            }\n            else\n            {\n                if ((startColumn.remaining() > 0 && comparator.compare(startColumn, curColPosition.lastName) > 0) ||\n                    (finishColumn.remaining() > 0 && comparator.compare(finishColumn, curColPosition.firstName) < 0))\n                    return false;\n            }\n\n            boolean outOfBounds = false;\n            long positionToSeek = basePosition + curColPosition.offset;\n\n            // With new promoted indexes, our first seek in the data file will happen at that point.\n            if (file == null)\n                file = originalInput == null ? sstable.getFileDataInput(positionToSeek) : originalInput;\n\n            file.seek(positionToSeek);\n            FileMark mark = file.mark();\n            while (file.bytesPastMark(mark) < curColPosition.width && !outOfBounds)\n            {\n                IColumn column = emptyColumnFamily.getColumnSerializer().deserialize(file);\n                if (reversed)\n                    blockColumns.addFirst(column);\n                else\n                    blockColumns.addLast(column);\n\n                /* see if we can stop seeking. */\n                if (!reversed && finishColumn.remaining() > 0)\n                    outOfBounds = comparator.compare(column.name(), finishColumn) >= 0;\n                else if (reversed && startColumn.remaining() > 0)\n                    outOfBounds = comparator.compare(column.name(), startColumn) >= 0;\n            }\n\n            if (reversed)\n                curRangeIndex--;\n            else\n                curRangeIndex++;\n            return true;\n        }","id":99263,"modified_method":"public boolean getNextBlock() throws IOException\n        {\n            if (curRangeIndex < 0 || curRangeIndex >= indexes.size())\n                return false;\n\n            /* seek to the correct offset to the data, and calculate the data size */\n            IndexHelper.IndexInfo curColPosition = indexes.get(curRangeIndex);\n\n            /* see if this read is really necessary. */\n            if (reversed)\n            {\n                if ((finishColumn.remaining() > 0 && comparator.compare(finishColumn, curColPosition.lastName) > 0) ||\n                    (startColumn.remaining() > 0 && comparator.compare(startColumn, curColPosition.firstName) < 0))\n                    return false;\n            }\n            else\n            {\n                if ((startColumn.remaining() > 0 && comparator.compare(startColumn, curColPosition.lastName) > 0) ||\n                    (finishColumn.remaining() > 0 && comparator.compare(finishColumn, curColPosition.firstName) < 0))\n                    return false;\n            }\n\n            boolean outOfBounds = false;\n            long positionToSeek = basePosition + curColPosition.offset;\n\n            // With new promoted indexes, our first seek in the data file will happen at that point.\n            if (file == null)\n                file = originalInput == null ? sstable.getFileDataInput(positionToSeek) : originalInput;\n\n            IColumnSerializer columnSerializer = emptyColumnFamily.getColumnSerializer();\n            file.seek(positionToSeek);\n            FileMark mark = file.mark();\n            while (file.bytesPastMark(mark) < curColPosition.width && !outOfBounds)\n            {\n                IColumn column = columnSerializer.deserialize(file);\n                if (reversed)\n                    blockColumns.addFirst(column);\n                else\n                    blockColumns.addLast(column);\n\n                /* see if we can stop seeking. */\n                if (!reversed && finishColumn.remaining() > 0)\n                    outOfBounds = comparator.compare(column.name(), finishColumn) >= 0;\n                else if (reversed && startColumn.remaining() > 0)\n                    outOfBounds = comparator.compare(column.name(), startColumn) >= 0;\n            }\n\n            if (reversed)\n                curRangeIndex--;\n            else\n                curRangeIndex++;\n            return true;\n        }","commit_id":"17dd5cd18736a11255dad686286aa0b30ead8a42","url":"https://github.com/apache/cassandra"},{"original_method":"public long write(DataOutput out) throws IOException\n    {\n        assert !closed;\n\n        DataOutputBuffer clockOut = new DataOutputBuffer();\n        ColumnFamily.serializer().serializeCFInfo(emptyColumnFamily, clockOut);\n\n        long dataSize = clockOut.getLength() + columnSerializedSize;\n        if (logger.isDebugEnabled())\n            logger.debug(String.format(\"clock / column sizes are %s / %s\", clockOut.getLength(), columnSerializedSize));\n        assert dataSize > 0;\n        out.writeLong(dataSize);\n        out.write(clockOut.getData(), 0, clockOut.getLength());\n        out.writeInt(columnStats.columnCount);\n\n        Iterator<IColumn> iter = iterator();\n        while (iter.hasNext())\n        {\n            IColumn column = iter.next();\n            emptyColumnFamily.getColumnSerializer().serialize(column, out);\n        }\n        long secondPassColumnSize = reducer == null ? 0 : reducer.serializedSize;\n        assert secondPassColumnSize == columnSerializedSize\n               : \"originally calculated column size of \" + columnSerializedSize + \" but now it is \" + secondPassColumnSize;\n\n        close();\n        return dataSize;\n    }","id":99264,"modified_method":"public long write(DataOutput out) throws IOException\n    {\n        assert !closed;\n\n        DataOutputBuffer clockOut = new DataOutputBuffer();\n        ColumnFamily.serializer().serializeCFInfo(emptyColumnFamily, clockOut);\n\n        long dataSize = clockOut.getLength() + columnSerializedSize;\n        if (logger.isDebugEnabled())\n            logger.debug(String.format(\"clock / column sizes are %s / %s\", clockOut.getLength(), columnSerializedSize));\n        assert dataSize > 0;\n        out.writeLong(dataSize);\n        out.write(clockOut.getData(), 0, clockOut.getLength());\n        out.writeInt(columnStats.columnCount);\n\n        IColumnSerializer columnSerializer = emptyColumnFamily.getColumnSerializer();\n        Iterator<IColumn> iter = iterator();\n        while (iter.hasNext())\n        {\n            IColumn column = iter.next();\n            columnSerializer.serialize(column, out);\n        }\n        long secondPassColumnSize = reducer == null ? 0 : reducer.serializedSize;\n        assert secondPassColumnSize == columnSerializedSize\n               : \"originally calculated column size of \" + columnSerializedSize + \" but now it is \" + secondPassColumnSize;\n\n        close();\n        return dataSize;\n    }","commit_id":"17dd5cd18736a11255dad686286aa0b30ead8a42","url":"https://github.com/apache/cassandra"},{"original_method":"private void readIndexedColumns(CFMetaData metadata, FileDataInput file, SortedSet<ByteBuffer> columnNames, List<ByteBuffer> filteredColumnNames, List<IndexHelper.IndexInfo> indexList, long basePosition)\n    throws IOException\n    {\n        /* get the various column ranges we have to read */\n        AbstractType<?> comparator = metadata.comparator;\n        SortedSet<IndexHelper.IndexInfo> ranges = new TreeSet<IndexHelper.IndexInfo>(IndexHelper.getComparator(comparator, false));\n        for (ByteBuffer name : filteredColumnNames)\n        {\n            int index = IndexHelper.indexFor(name, indexList, comparator, false);\n            if (index == indexList.size())\n                continue;\n            IndexHelper.IndexInfo indexInfo = indexList.get(index);\n            if (comparator.compare(name, indexInfo.firstName) < 0)\n                continue;\n            ranges.add(indexInfo);\n        }\n\n        if (ranges.isEmpty())\n            return;\n\n        for (IndexHelper.IndexInfo indexInfo : ranges)\n        {\n            long positionToSeek = basePosition + indexInfo.offset;\n\n            // With new promoted indexes, our first seek in the data file will happen at that point.\n            if (file == null)\n                file = createFileDataInput(positionToSeek);\n\n            file.seek(positionToSeek);\n            FileMark mark = file.mark();\n            // TODO only completely deserialize columns we are interested in\n            while (file.bytesPastMark(mark) < indexInfo.width)\n            {\n                IColumn column = cf.getColumnSerializer().deserialize(file);\n                // we check vs the original Set, not the filtered List, for efficiency\n                if (columnNames.contains(column.name()))\n                {\n                    cf.addColumn(column);\n                }\n            }\n        }\n    }","id":99265,"modified_method":"private void readIndexedColumns(CFMetaData metadata, FileDataInput file, SortedSet<ByteBuffer> columnNames, List<ByteBuffer> filteredColumnNames, List<IndexHelper.IndexInfo> indexList, long basePosition)\n    throws IOException\n    {\n        /* get the various column ranges we have to read */\n        AbstractType<?> comparator = metadata.comparator;\n        SortedSet<IndexHelper.IndexInfo> ranges = new TreeSet<IndexHelper.IndexInfo>(IndexHelper.getComparator(comparator, false));\n        for (ByteBuffer name : filteredColumnNames)\n        {\n            int index = IndexHelper.indexFor(name, indexList, comparator, false);\n            if (index == indexList.size())\n                continue;\n            IndexHelper.IndexInfo indexInfo = indexList.get(index);\n            if (comparator.compare(name, indexInfo.firstName) < 0)\n                continue;\n            ranges.add(indexInfo);\n        }\n\n        if (ranges.isEmpty())\n            return;\n\n        for (IndexHelper.IndexInfo indexInfo : ranges)\n        {\n            long positionToSeek = basePosition + indexInfo.offset;\n\n            // With new promoted indexes, our first seek in the data file will happen at that point.\n            if (file == null)\n                file = createFileDataInput(positionToSeek);\n\n            IColumnSerializer columnSerializer = cf.getColumnSerializer();\n            file.seek(positionToSeek);\n            FileMark mark = file.mark();\n            // TODO only completely deserialize columns we are interested in\n            while (file.bytesPastMark(mark) < indexInfo.width)\n            {\n                IColumn column = columnSerializer.deserialize(file);\n                // we check vs the original Set, not the filtered List, for efficiency\n                if (columnNames.contains(column.name()))\n                {\n                    cf.addColumn(column);\n                }\n            }\n        }\n    }","commit_id":"17dd5cd18736a11255dad686286aa0b30ead8a42","url":"https://github.com/apache/cassandra"},{"original_method":"private void readSimpleColumns(FileDataInput file, SortedSet<ByteBuffer> columnNames, List<ByteBuffer> filteredColumnNames) throws IOException\n    {\n        int columns = file.readInt();\n        int n = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            IColumn column = cf.getColumnSerializer().deserialize(file);\n            if (columnNames.contains(column.name()))\n            {\n                cf.addColumn(column);\n                if (n++ > filteredColumnNames.size())\n                    break;\n            }\n        }\n    }","id":99266,"modified_method":"private void readSimpleColumns(FileDataInput file, SortedSet<ByteBuffer> columnNames, List<ByteBuffer> filteredColumnNames) throws IOException\n    {\n        IColumnSerializer columnSerializer = cf.getColumnSerializer();\n        int columns = file.readInt();\n        int n = 0;\n        for (int i = 0; i < columns; i++)\n        {\n            IColumn column = columnSerializer.deserialize(file);\n            if (columnNames.contains(column.name()))\n            {\n                cf.addColumn(column);\n                if (n++ > filteredColumnNames.size())\n                    break;\n            }\n        }\n    }","commit_id":"17dd5cd18736a11255dad686286aa0b30ead8a42","url":"https://github.com/apache/cassandra"},{"original_method":"public long appendFromStream(DecoratedKey key, CFMetaData metadata, long dataSize, DataInput in) throws IOException\n    {\n        long currentPosition = beforeAppend(key);\n        ByteBufferUtil.writeWithShortLength(key.key, dataFile.stream);\n        long dataStart = dataFile.getFilePointer();\n\n        // write row size\n        dataFile.stream.writeLong(dataSize);\n\n        // cf data\n        int lct = in.readInt();\n        long mfda = in.readLong();\n        DeletionInfo deletionInfo = new DeletionInfo(mfda, lct);\n        dataFile.stream.writeInt(lct);\n        dataFile.stream.writeLong(mfda);\n\n        // column size\n        int columnCount = in.readInt();\n        dataFile.stream.writeInt(columnCount);\n\n        // deserialize each column to obtain maxTimestamp and immediately serialize it.\n        long maxTimestamp = Long.MIN_VALUE;\n        StreamingHistogram tombstones = new StreamingHistogram(TOMBSTONE_HISTOGRAM_BIN_SIZE);\n        ColumnFamily cf = ColumnFamily.create(metadata, ArrayBackedSortedColumns.factory());\n        ColumnIndex.Builder columnIndexer = new ColumnIndex.Builder(cf.getComparator(), key.key, columnCount);\n        for (int i = 0; i < columnCount; i++)\n        {\n            // deserialize column with PRESERVE_SIZE because we've written the dataSize based on the\n            // data size received, so we must reserialize the exact same data\n            IColumn column = cf.getColumnSerializer().deserialize(in, IColumnSerializer.Flag.PRESERVE_SIZE, Integer.MIN_VALUE);\n            if (column instanceof CounterColumn)\n            {\n                column = ((CounterColumn) column).markDeltaToBeCleared();\n            }\n            else if (column instanceof SuperColumn)\n            {\n                SuperColumn sc = (SuperColumn) column;\n                for (IColumn subColumn : sc.getSubColumns())\n                {\n                    if (subColumn instanceof CounterColumn)\n                    {\n                        IColumn marked = ((CounterColumn) subColumn).markDeltaToBeCleared();\n                        sc.replace(subColumn, marked);\n                    }\n                }\n            }\n\n            int deletionTime = column.getLocalDeletionTime();\n            if (deletionTime < Integer.MAX_VALUE)\n            {\n                tombstones.update(deletionTime);\n            }\n            maxTimestamp = Math.max(maxTimestamp, column.maxTimestamp());\n            cf.getColumnSerializer().serialize(column, dataFile.stream);\n            columnIndexer.add(column);\n        }\n\n        assert dataSize == dataFile.getFilePointer() - (dataStart + 8)\n                : \"incorrect row data size \" + dataSize + \" written to \" + dataFile.getPath() + \"; correct is \" + (dataFile.getFilePointer() - (dataStart + 8));\n        sstableMetadataCollector.updateMaxTimestamp(maxTimestamp);\n        sstableMetadataCollector.addRowSize(dataFile.getFilePointer() - currentPosition);\n        sstableMetadataCollector.addColumnCount(columnCount);\n        sstableMetadataCollector.mergeTombstoneHistogram(tombstones);\n        afterAppend(key, currentPosition, deletionInfo, columnIndexer.build());\n        return currentPosition;\n    }","id":99267,"modified_method":"public long appendFromStream(DecoratedKey key, CFMetaData metadata, long dataSize, DataInput in) throws IOException\n    {\n        long currentPosition = beforeAppend(key);\n        ByteBufferUtil.writeWithShortLength(key.key, dataFile.stream);\n        long dataStart = dataFile.getFilePointer();\n\n        // write row size\n        dataFile.stream.writeLong(dataSize);\n\n        // cf data\n        int lct = in.readInt();\n        long mfda = in.readLong();\n        DeletionInfo deletionInfo = new DeletionInfo(mfda, lct);\n        dataFile.stream.writeInt(lct);\n        dataFile.stream.writeLong(mfda);\n\n        // column size\n        int columnCount = in.readInt();\n        dataFile.stream.writeInt(columnCount);\n\n        // deserialize each column to obtain maxTimestamp and immediately serialize it.\n        long maxTimestamp = Long.MIN_VALUE;\n        StreamingHistogram tombstones = new StreamingHistogram(TOMBSTONE_HISTOGRAM_BIN_SIZE);\n        ColumnFamily cf = ColumnFamily.create(metadata, ArrayBackedSortedColumns.factory());\n        ColumnIndex.Builder columnIndexer = new ColumnIndex.Builder(cf.getComparator(), key.key, columnCount);\n        IColumnSerializer columnSerializer = cf.getColumnSerializer();\n        for (int i = 0; i < columnCount; i++)\n        {\n            // deserialize column with PRESERVE_SIZE because we've written the dataSize based on the\n            // data size received, so we must reserialize the exact same data\n            IColumn column = columnSerializer.deserialize(in, IColumnSerializer.Flag.PRESERVE_SIZE, Integer.MIN_VALUE);\n            if (column instanceof CounterColumn)\n            {\n                column = ((CounterColumn) column).markDeltaToBeCleared();\n            }\n            else if (column instanceof SuperColumn)\n            {\n                SuperColumn sc = (SuperColumn) column;\n                for (IColumn subColumn : sc.getSubColumns())\n                {\n                    if (subColumn instanceof CounterColumn)\n                    {\n                        IColumn marked = ((CounterColumn) subColumn).markDeltaToBeCleared();\n                        sc.replace(subColumn, marked);\n                    }\n                }\n            }\n\n            int deletionTime = column.getLocalDeletionTime();\n            if (deletionTime < Integer.MAX_VALUE)\n            {\n                tombstones.update(deletionTime);\n            }\n            maxTimestamp = Math.max(maxTimestamp, column.maxTimestamp());\n            cf.getColumnSerializer().serialize(column, dataFile.stream);\n            columnIndexer.add(column);\n        }\n\n        assert dataSize == dataFile.getFilePointer() - (dataStart + 8)\n                : \"incorrect row data size \" + dataSize + \" written to \" + dataFile.getPath() + \"; correct is \" + (dataFile.getFilePointer() - (dataStart + 8));\n        sstableMetadataCollector.updateMaxTimestamp(maxTimestamp);\n        sstableMetadataCollector.addRowSize(dataFile.getFilePointer() - currentPosition);\n        sstableMetadataCollector.addColumnCount(columnCount);\n        sstableMetadataCollector.mergeTombstoneHistogram(tombstones);\n        afterAppend(key, currentPosition, deletionInfo, columnIndexer.build());\n        return currentPosition;\n    }","commit_id":"17dd5cd18736a11255dad686286aa0b30ead8a42","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n\t * Execute schema creation script, determined by the Configuration object\n\t * used for creating the SessionFactory. A replacement for Hibernate's\n\t * SchemaExport class, to be invoked on application setup.\n\t * <p>Fetch the LocalSessionFactoryBean itself rather than the exposed\n\t * SessionFactory to be able to invoke this method, e.g. via\n\t * <code>LocalSessionFactoryBean lsfb = (LocalSessionFactoryBean) ctx.getBean(\"&mySessionFactory\");<\/code>.\n\t * <p>Uses the SessionFactory that this bean generates for accessing a\n\t * JDBC connection to perform the script.\n\t * @throws DataAccessException in case of script execution errors\n\t * @see org.hibernate.cfg.Configuration#generateSchemaCreationScript\n\t * @see org.hibernate.tool.hbm2ddl.SchemaExport#create\n\t */\n\tpublic void createDatabaseSchema() throws DataAccessException {\n\t\tlogger.info(\"Creating database schema for Hibernate SessionFactory\");\n\t\tDataSource dataSource = getDataSource();\n\t\tif (dataSource != null) {\n\t\t\t// Make given DataSource available for the schema update.\n\t\t\tconfigTimeDataSourceHolder.set(dataSource);\n\t\t}\n\t\ttry {\n\t\t\tHibernateTemplate hibernateTemplate = new HibernateTemplate(getSessionFactory());\n\t\t\thibernateTemplate.execute(\n\t\t\t\tnew HibernateCallback<Object>() {\n\t\t\t\t\tpublic Object doInHibernate(Session session) throws HibernateException, SQLException {\n\t\t\t\t\t\tConnection con = session.connection();\n\t\t\t\t\t\tDialect dialect = Dialect.getDialect(getConfiguration().getProperties());\n\t\t\t\t\t\tString[] sql = getConfiguration().generateSchemaCreationScript(dialect);\n\t\t\t\t\t\texecuteSchemaScript(con, sql);\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tif (dataSource != null) {\n\t\t\t\tconfigTimeDataSourceHolder.remove();\n\t\t\t}\n\t\t}\n\t}","id":99268,"modified_method":"/**\n\t * Execute schema creation script, determined by the Configuration object\n\t * used for creating the SessionFactory. A replacement for Hibernate's\n\t * SchemaExport class, to be invoked on application setup.\n\t * <p>Fetch the LocalSessionFactoryBean itself rather than the exposed\n\t * SessionFactory to be able to invoke this method, e.g. via\n\t * <code>LocalSessionFactoryBean lsfb = (LocalSessionFactoryBean) ctx.getBean(\"&mySessionFactory\");<\/code>.\n\t * <p>Uses the SessionFactory that this bean generates for accessing a\n\t * JDBC connection to perform the script.\n\t * @throws DataAccessException in case of script execution errors\n\t * @see org.hibernate.cfg.Configuration#generateSchemaCreationScript\n\t * @see org.hibernate.tool.hbm2ddl.SchemaExport#create\n\t */\n\tpublic void createDatabaseSchema() throws DataAccessException {\n\t\tlogger.info(\"Creating database schema for Hibernate SessionFactory\");\n\t\tDataSource dataSource = getDataSource();\n\t\tif (dataSource != null) {\n\t\t\t// Make given DataSource available for the schema update.\n\t\t\tconfigTimeDataSourceHolder.set(dataSource);\n\t\t}\n\t\ttry {\n\t\t\tSessionFactory sessionFactory = getSessionFactory();\n\t\t\tfinal Dialect dialect = ((SessionFactoryImplementor) sessionFactory).getDialect();\n\t\t\tHibernateTemplate hibernateTemplate = new HibernateTemplate(sessionFactory);\n\t\t\thibernateTemplate.execute(\n\t\t\t\tnew HibernateCallback<Object>() {\n\t\t\t\t\tpublic Object doInHibernate(Session session) throws HibernateException, SQLException {\n\t\t\t\t\t\tConnection con = session.connection();\n\t\t\t\t\t\tString[] sql = getConfiguration().generateSchemaCreationScript(dialect);\n\t\t\t\t\t\texecuteSchemaScript(con, sql);\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tif (dataSource != null) {\n\t\t\t\tconfigTimeDataSourceHolder.remove();\n\t\t\t}\n\t\t}\n\t}","commit_id":"045c97f75e231b99ebeaab48b72ccb9e1e07004b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Execute schema creation script, determined by the Configuration object\n\t * used for creating the SessionFactory. A replacement for Hibernate's\n\t * SchemaValidator class, to be invoked after application startup.\n\t * <p>Fetch the LocalSessionFactoryBean itself rather than the exposed\n\t * SessionFactory to be able to invoke this method, e.g. via\n\t * <code>LocalSessionFactoryBean lsfb = (LocalSessionFactoryBean) ctx.getBean(\"&mySessionFactory\");<\/code>.\n\t * <p>Uses the SessionFactory that this bean generates for accessing a\n\t * JDBC connection to perform the script.\n\t * @throws DataAccessException in case of script execution errors\n\t * @see org.hibernate.cfg.Configuration#validateSchema\n\t * @see org.hibernate.tool.hbm2ddl.SchemaValidator\n\t */\n\tpublic void validateDatabaseSchema() throws DataAccessException {\n\t\tlogger.info(\"Validating database schema for Hibernate SessionFactory\");\n\t\tDataSource dataSource = getDataSource();\n\t\tif (dataSource != null) {\n\t\t\t// Make given DataSource available for the schema update.\n\t\t\tconfigTimeDataSourceHolder.set(dataSource);\n\t\t}\n\t\ttry {\n\t\t\tHibernateTemplate hibernateTemplate = new HibernateTemplate(getSessionFactory());\n\t\t\thibernateTemplate.setFlushMode(HibernateTemplate.FLUSH_NEVER);\n\t\t\thibernateTemplate.execute(\n\t\t\t\tnew HibernateCallback<Object>() {\n\t\t\t\t\tpublic Object doInHibernate(Session session) throws HibernateException, SQLException {\n\t\t\t\t\t\tConnection con = session.connection();\n\t\t\t\t\t\tDialect dialect = Dialect.getDialect(getConfiguration().getProperties());\n\t\t\t\t\t\tDatabaseMetadata metadata = new DatabaseMetadata(con, dialect, false);\n\t\t\t\t\t\tgetConfiguration().validateSchema(dialect, metadata);\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tif (dataSource != null) {\n\t\t\t\tconfigTimeDataSourceHolder.remove();\n\t\t\t}\n\t\t}\n\t}","id":99269,"modified_method":"/**\n\t * Execute schema creation script, determined by the Configuration object\n\t * used for creating the SessionFactory. A replacement for Hibernate's\n\t * SchemaValidator class, to be invoked after application startup.\n\t * <p>Fetch the LocalSessionFactoryBean itself rather than the exposed\n\t * SessionFactory to be able to invoke this method, e.g. via\n\t * <code>LocalSessionFactoryBean lsfb = (LocalSessionFactoryBean) ctx.getBean(\"&mySessionFactory\");<\/code>.\n\t * <p>Uses the SessionFactory that this bean generates for accessing a\n\t * JDBC connection to perform the script.\n\t * @throws DataAccessException in case of script execution errors\n\t * @see org.hibernate.cfg.Configuration#validateSchema\n\t * @see org.hibernate.tool.hbm2ddl.SchemaValidator\n\t */\n\tpublic void validateDatabaseSchema() throws DataAccessException {\n\t\tlogger.info(\"Validating database schema for Hibernate SessionFactory\");\n\t\tDataSource dataSource = getDataSource();\n\t\tif (dataSource != null) {\n\t\t\t// Make given DataSource available for the schema update.\n\t\t\tconfigTimeDataSourceHolder.set(dataSource);\n\t\t}\n\t\ttry {\n\t\t\tSessionFactory sessionFactory = getSessionFactory();\n\t\t\tfinal Dialect dialect = ((SessionFactoryImplementor) sessionFactory).getDialect();\n\t\t\tHibernateTemplate hibernateTemplate = new HibernateTemplate(sessionFactory);\n\t\t\thibernateTemplate.setFlushMode(HibernateTemplate.FLUSH_NEVER);\n\t\t\thibernateTemplate.execute(\n\t\t\t\tnew HibernateCallback<Object>() {\n\t\t\t\t\tpublic Object doInHibernate(Session session) throws HibernateException, SQLException {\n\t\t\t\t\t\tConnection con = session.connection();\n\t\t\t\t\t\tDatabaseMetadata metadata = new DatabaseMetadata(con, dialect, false);\n\t\t\t\t\t\tgetConfiguration().validateSchema(dialect, metadata);\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tif (dataSource != null) {\n\t\t\t\tconfigTimeDataSourceHolder.remove();\n\t\t\t}\n\t\t}\n\t}","commit_id":"045c97f75e231b99ebeaab48b72ccb9e1e07004b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Execute schema drop script, determined by the Configuration object\n\t * used for creating the SessionFactory. A replacement for Hibernate's\n\t * SchemaExport class, to be invoked on application setup.\n\t * <p>Fetch the LocalSessionFactoryBean itself rather than the exposed\n\t * SessionFactory to be able to invoke this method, e.g. via\n\t * <code>LocalSessionFactoryBean lsfb = (LocalSessionFactoryBean) ctx.getBean(\"&mySessionFactory\");<\/code>.\n\t * <p>Uses the SessionFactory that this bean generates for accessing a\n\t * JDBC connection to perform the script.\n\t * @throws org.springframework.dao.DataAccessException in case of script execution errors\n\t * @see org.hibernate.cfg.Configuration#generateDropSchemaScript\n\t * @see org.hibernate.tool.hbm2ddl.SchemaExport#drop\n\t */\n\tpublic void dropDatabaseSchema() throws DataAccessException {\n\t\tlogger.info(\"Dropping database schema for Hibernate SessionFactory\");\n\t\tHibernateTemplate hibernateTemplate = new HibernateTemplate(getSessionFactory());\n\t\thibernateTemplate.execute(\n\t\t\tnew HibernateCallback<Object>() {\n\t\t\t\tpublic Object doInHibernate(Session session) throws HibernateException, SQLException {\n\t\t\t\t\tConnection con = session.connection();\n\t\t\t\t\tDialect dialect = Dialect.getDialect(getConfiguration().getProperties());\n\t\t\t\t\tString[] sql = getConfiguration().generateDropSchemaScript(dialect);\n\t\t\t\t\texecuteSchemaScript(con, sql);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}","id":99270,"modified_method":"/**\n\t * Execute schema drop script, determined by the Configuration object\n\t * used for creating the SessionFactory. A replacement for Hibernate's\n\t * SchemaExport class, to be invoked on application setup.\n\t * <p>Fetch the LocalSessionFactoryBean itself rather than the exposed\n\t * SessionFactory to be able to invoke this method, e.g. via\n\t * <code>LocalSessionFactoryBean lsfb = (LocalSessionFactoryBean) ctx.getBean(\"&mySessionFactory\");<\/code>.\n\t * <p>Uses the SessionFactory that this bean generates for accessing a\n\t * JDBC connection to perform the script.\n\t * @throws org.springframework.dao.DataAccessException in case of script execution errors\n\t * @see org.hibernate.cfg.Configuration#generateDropSchemaScript\n\t * @see org.hibernate.tool.hbm2ddl.SchemaExport#drop\n\t */\n\tpublic void dropDatabaseSchema() throws DataAccessException {\n\t\tlogger.info(\"Dropping database schema for Hibernate SessionFactory\");\n\t\tSessionFactory sessionFactory = getSessionFactory();\n\t\tfinal Dialect dialect = ((SessionFactoryImplementor) sessionFactory).getDialect();\n\t\tHibernateTemplate hibernateTemplate = new HibernateTemplate(sessionFactory);\n\t\thibernateTemplate.execute(\n\t\t\tnew HibernateCallback<Object>() {\n\t\t\t\tpublic Object doInHibernate(Session session) throws HibernateException, SQLException {\n\t\t\t\t\tConnection con = session.connection();\n\t\t\t\t\tString[] sql = getConfiguration().generateDropSchemaScript(dialect);\n\t\t\t\t\texecuteSchemaScript(con, sql);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}","commit_id":"045c97f75e231b99ebeaab48b72ccb9e1e07004b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Execute schema update script, determined by the Configuration object\n\t * used for creating the SessionFactory. A replacement for Hibernate's\n\t * SchemaUpdate class, for automatically executing schema update scripts\n\t * on application startup. Can also be invoked manually.\n\t * <p>Fetch the LocalSessionFactoryBean itself rather than the exposed\n\t * SessionFactory to be able to invoke this method, e.g. via\n\t * <code>LocalSessionFactoryBean lsfb = (LocalSessionFactoryBean) ctx.getBean(\"&mySessionFactory\");<\/code>.\n\t * <p>Uses the SessionFactory that this bean generates for accessing a\n\t * JDBC connection to perform the script.\n\t * @throws DataAccessException in case of script execution errors\n\t * @see #setSchemaUpdate\n\t * @see org.hibernate.cfg.Configuration#generateSchemaUpdateScript\n\t * @see org.hibernate.tool.hbm2ddl.SchemaUpdate\n\t */\n\tpublic void updateDatabaseSchema() throws DataAccessException {\n\t\tlogger.info(\"Updating database schema for Hibernate SessionFactory\");\n\t\tDataSource dataSource = getDataSource();\n\t\tif (dataSource != null) {\n\t\t\t// Make given DataSource available for the schema update.\n\t\t\tconfigTimeDataSourceHolder.set(dataSource);\n\t\t}\n\t\ttry {\n\t\t\tHibernateTemplate hibernateTemplate = new HibernateTemplate(getSessionFactory());\n\t\t\thibernateTemplate.setFlushMode(HibernateTemplate.FLUSH_NEVER);\n\t\t\thibernateTemplate.execute(\n\t\t\t\tnew HibernateCallback<Object>() {\n\t\t\t\t\tpublic Object doInHibernate(Session session) throws HibernateException, SQLException {\n\t\t\t\t\t\tConnection con = session.connection();\n\t\t\t\t\t\tDialect dialect = Dialect.getDialect(getConfiguration().getProperties());\n\t\t\t\t\t\tDatabaseMetadata metadata = new DatabaseMetadata(con, dialect);\n\t\t\t\t\t\tString[] sql = getConfiguration().generateSchemaUpdateScript(dialect, metadata);\n\t\t\t\t\t\texecuteSchemaScript(con, sql);\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tif (dataSource != null) {\n\t\t\t\tconfigTimeDataSourceHolder.remove();\n\t\t\t}\n\t\t}\n\t}","id":99271,"modified_method":"/**\n\t * Execute schema update script, determined by the Configuration object\n\t * used for creating the SessionFactory. A replacement for Hibernate's\n\t * SchemaUpdate class, for automatically executing schema update scripts\n\t * on application startup. Can also be invoked manually.\n\t * <p>Fetch the LocalSessionFactoryBean itself rather than the exposed\n\t * SessionFactory to be able to invoke this method, e.g. via\n\t * <code>LocalSessionFactoryBean lsfb = (LocalSessionFactoryBean) ctx.getBean(\"&mySessionFactory\");<\/code>.\n\t * <p>Uses the SessionFactory that this bean generates for accessing a\n\t * JDBC connection to perform the script.\n\t * @throws DataAccessException in case of script execution errors\n\t * @see #setSchemaUpdate\n\t * @see org.hibernate.cfg.Configuration#generateSchemaUpdateScript\n\t * @see org.hibernate.tool.hbm2ddl.SchemaUpdate\n\t */\n\tpublic void updateDatabaseSchema() throws DataAccessException {\n\t\tlogger.info(\"Updating database schema for Hibernate SessionFactory\");\n\t\tDataSource dataSource = getDataSource();\n\t\tif (dataSource != null) {\n\t\t\t// Make given DataSource available for the schema update.\n\t\t\tconfigTimeDataSourceHolder.set(dataSource);\n\t\t}\n\t\ttry {\n\t\t\tSessionFactory sessionFactory = getSessionFactory();\n\t\t\tfinal Dialect dialect = ((SessionFactoryImplementor) sessionFactory).getDialect();\n\t\t\tHibernateTemplate hibernateTemplate = new HibernateTemplate(sessionFactory);\n\t\t\thibernateTemplate.setFlushMode(HibernateTemplate.FLUSH_NEVER);\n\t\t\thibernateTemplate.execute(\n\t\t\t\tnew HibernateCallback<Object>() {\n\t\t\t\t\tpublic Object doInHibernate(Session session) throws HibernateException, SQLException {\n\t\t\t\t\t\tConnection con = session.connection();\n\t\t\t\t\t\tDatabaseMetadata metadata = new DatabaseMetadata(con, dialect);\n\t\t\t\t\t\tString[] sql = getConfiguration().generateSchemaUpdateScript(dialect, metadata);\n\t\t\t\t\t\texecuteSchemaScript(con, sql);\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tif (dataSource != null) {\n\t\t\t\tconfigTimeDataSourceHolder.remove();\n\t\t\t}\n\t\t}\n\t}","commit_id":"045c97f75e231b99ebeaab48b72ccb9e1e07004b","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public OverloadResolutionResults<FunctionDescriptor> getDelegatedPropertyConventionMethod(\n            @NotNull PropertyDescriptor propertyDescriptor,\n            @NotNull JetExpression delegateExpression,\n            @NotNull JetType delegateType,\n            @NotNull BindingTrace trace,\n            @NotNull LexicalScope scope,\n            boolean isGet,\n            boolean isComplete\n    ) {\n        PropertyAccessorDescriptor accessor = isGet ? propertyDescriptor.getGetter() : propertyDescriptor.getSetter();\n        assert accessor != null : \"Delegated property should have getter/setter \" + propertyDescriptor + \" \" + delegateExpression.getText();\n\n        JetType expectedType = isComplete && isGet && !(propertyDescriptor.getType() instanceof DeferredType)\n                               ? propertyDescriptor.getType() : TypeUtils.NO_EXPECTED_TYPE;\n\n        ExpressionTypingContext context = ExpressionTypingContext.newContext(\n                trace, scope,\n                DataFlowInfo.EMPTY, expectedType);\n\n        boolean hasThis = propertyDescriptor.getExtensionReceiverParameter() != null || propertyDescriptor.getDispatchReceiverParameter() != null;\n\n        List<JetExpression> arguments = Lists.newArrayList();\n        JetPsiFactory psiFactory = JetPsiFactory(delegateExpression);\n        arguments.add(psiFactory.createExpression(hasThis ? \"this\" : \"null\"));\n        arguments.add(createExpressionForProperty(psiFactory));\n\n        if (!isGet) {\n            JetReferenceExpression fakeArgument = (JetReferenceExpression) createFakeExpressionOfType(delegateExpression.getProject(), trace,\n                                                                                                      \"fakeArgument\" + arguments.size(),\n                                                                                                      propertyDescriptor.getType());\n            arguments.add(fakeArgument);\n            List<ValueParameterDescriptor> valueParameters = accessor.getValueParameters();\n            trace.record(REFERENCE_TARGET, fakeArgument, valueParameters.get(0));\n        }\n\n        Name functionName = isGet ? GETTER_NAME : SETTER_NAME;\n        ExpressionReceiver receiver = new ExpressionReceiver(delegateExpression, delegateType);\n\n        Pair<Call, OverloadResolutionResults<FunctionDescriptor>> resolutionResult =\n                fakeCallResolver.makeAndResolveFakeCallInContext(receiver, context, arguments, functionName, delegateExpression);\n\n        OverloadResolutionResults<FunctionDescriptor> resolutionResults = resolutionResult.getSecond();\n\n        // Resolve get/set is getValue/setValue was not found. Temporary, for code migration\n        if (!resolutionResults.isSuccess() && !resolutionResults.isAmbiguity()) {\n            Name oldFunctionName = isGet ? OLD_GETTER_NAME : OLD_SETTER_NAME;\n            Pair<Call, OverloadResolutionResults<FunctionDescriptor>> additionalResolutionResult =\n                    fakeCallResolver.makeAndResolveFakeCallInContext(receiver, context, arguments, oldFunctionName, delegateExpression);\n            if (additionalResolutionResult.getSecond().isSuccess()) {\n                FunctionDescriptor resultingDescriptor = additionalResolutionResult.getSecond().getResultingDescriptor();\n                trace.report(DELEGATE_RESOLVED_TO_DEPRECATED_CONVENTION.on(\n                        delegateExpression, resultingDescriptor, delegateType, functionName.asString()));\n                trace.record(BindingContext.DELEGATED_PROPERTY_CALL, accessor, additionalResolutionResult.getFirst());\n                return additionalResolutionResult.getSecond();\n            }\n        }\n\n        trace.record(BindingContext.DELEGATED_PROPERTY_CALL, accessor, resolutionResult.getFirst());\n        return resolutionResults;\n    }","id":99272,"modified_method":"public OverloadResolutionResults<FunctionDescriptor> getDelegatedPropertyConventionMethod(\n            @NotNull PropertyDescriptor propertyDescriptor,\n            @NotNull JetExpression delegateExpression,\n            @NotNull JetType delegateType,\n            @NotNull BindingTrace trace,\n            @NotNull LexicalScope scope,\n            boolean isGet,\n            boolean isComplete\n    ) {\n        PropertyAccessorDescriptor accessor = isGet ? propertyDescriptor.getGetter() : propertyDescriptor.getSetter();\n        assert accessor != null : \"Delegated property should have getter/setter \" + propertyDescriptor + \" \" + delegateExpression.getText();\n\n        JetType expectedType = isComplete && isGet && !(propertyDescriptor.getType() instanceof DeferredType)\n                               ? propertyDescriptor.getType() : TypeUtils.NO_EXPECTED_TYPE;\n\n        ExpressionTypingContext context = ExpressionTypingContext.newContext(\n                trace, scope,\n                DataFlowInfo.EMPTY, expectedType);\n\n        boolean hasThis = propertyDescriptor.getExtensionReceiverParameter() != null || propertyDescriptor.getDispatchReceiverParameter() != null;\n\n        List<JetExpression> arguments = Lists.newArrayList();\n        JetPsiFactory psiFactory = JetPsiFactory(delegateExpression);\n        arguments.add(psiFactory.createExpression(hasThis ? \"this\" : \"null\"));\n        arguments.add(createExpressionForProperty(psiFactory));\n\n        if (!isGet) {\n            JetReferenceExpression fakeArgument = (JetReferenceExpression) createFakeExpressionOfType(delegateExpression.getProject(), trace,\n                                                                                                      \"fakeArgument\" + arguments.size(),\n                                                                                                      propertyDescriptor.getType());\n            arguments.add(fakeArgument);\n            List<ValueParameterDescriptor> valueParameters = accessor.getValueParameters();\n            trace.record(REFERENCE_TARGET, fakeArgument, valueParameters.get(0));\n        }\n\n        Name functionName = isGet ? GETTER_NAME : SETTER_NAME;\n        ExpressionReceiver receiver = new ExpressionReceiver(delegateExpression, delegateType);\n\n        Pair<Call, OverloadResolutionResults<FunctionDescriptor>> resolutionResult =\n                fakeCallResolver.makeAndResolveFakeCallInContext(receiver, context, arguments, functionName, delegateExpression);\n\n        OverloadResolutionResults<FunctionDescriptor> resolutionResults = resolutionResult.getSecond();\n\n        // Resolve get/set is getValue/setValue was not found. Temporary, for code migration\n        if (!resolutionResults.isSuccess() && !resolutionResults.isAmbiguity()) {\n            Name oldFunctionName = isGet ? OLD_GETTER_NAME : OLD_SETTER_NAME;\n            Pair<Call, OverloadResolutionResults<FunctionDescriptor>> additionalResolutionResult =\n                    fakeCallResolver.makeAndResolveFakeCallInContext(receiver, context, arguments, oldFunctionName, delegateExpression);\n            if (additionalResolutionResult.getSecond().isSuccess()) {\n                FunctionDescriptor resultingDescriptor = additionalResolutionResult.getSecond().getResultingDescriptor();\n\n                PsiElement declaration = DescriptorToSourceUtils.descriptorToDeclaration(propertyDescriptor);\n                if (declaration instanceof JetProperty) {\n                    JetProperty property = (JetProperty) declaration;\n                    JetPropertyDelegate delegate = property.getDelegate();\n                    if (delegate != null) {\n                        PsiElement byKeyword = delegate.getByKeywordNode().getPsi();\n\n                        trace.report(DELEGATE_RESOLVED_TO_DEPRECATED_CONVENTION.on(\n                                byKeyword, resultingDescriptor, delegateType, functionName.asString()));\n                    }\n                }\n\n                trace.record(BindingContext.DELEGATED_PROPERTY_CALL, accessor, additionalResolutionResult.getFirst());\n                return additionalResolutionResult.getSecond();\n            }\n        }\n\n        trace.record(BindingContext.DELEGATED_PROPERTY_CALL, accessor, resolutionResult.getFirst());\n        return resolutionResults;\n    }","commit_id":"3bb1b1adfdaefdc4ced0b11e69167167beb891d4","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void resolveDelegatedPropertyConventionMethod(\n            @NotNull PropertyDescriptor propertyDescriptor,\n            @NotNull JetExpression delegateExpression,\n            @NotNull JetType delegateType,\n            @NotNull BindingTrace trace,\n            @NotNull LexicalScope scope,\n            boolean isGet\n    ) {\n        PropertyAccessorDescriptor accessor = isGet ? propertyDescriptor.getGetter() : propertyDescriptor.getSetter();\n        assert accessor != null : \"Delegated property should have getter/setter \" + propertyDescriptor + \" \" + delegateExpression.getText();\n\n        if (trace.getBindingContext().get(DELEGATED_PROPERTY_CALL, accessor) != null) return;\n\n        OverloadResolutionResults<FunctionDescriptor> functionResults = getDelegatedPropertyConventionMethod(\n                propertyDescriptor, delegateExpression, delegateType, trace, scope, isGet, true);\n        Call call = trace.getBindingContext().get(DELEGATED_PROPERTY_CALL, accessor);\n        assert call != null : \"'getDelegatedPropertyConventionMethod' didn't record a call\";\n\n        if (!functionResults.isSuccess()) {\n            String expectedFunction = renderCall(call, trace.getBindingContext());\n            if (functionResults.isIncomplete()) {\n                trace.report(DELEGATE_SPECIAL_FUNCTION_MISSING.on(delegateExpression, expectedFunction, delegateType));\n            }\n            else if (functionResults.isSingleResult() ||\n                     functionResults.getResultCode() == OverloadResolutionResults.Code.MANY_FAILED_CANDIDATES) {\n                trace.report(DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE\n                                             .on(delegateExpression, expectedFunction, functionResults.getResultingCalls()));\n            }\n            else if (functionResults.isAmbiguity()) {\n                trace.report(DELEGATE_SPECIAL_FUNCTION_AMBIGUITY\n                                             .on(delegateExpression, expectedFunction, functionResults.getResultingCalls()));\n            }\n            else {\n                trace.report(DELEGATE_SPECIAL_FUNCTION_MISSING.on(delegateExpression, expectedFunction, delegateType));\n            }\n            return;\n        }\n\n        FunctionDescriptor resultingDescriptor = functionResults.getResultingDescriptor();\n        if (!resultingDescriptor.isOperator()) {\n            OperatorValidator.Companion.report(delegateExpression, resultingDescriptor, trace);\n        }\n\n        ResolvedCall<FunctionDescriptor> resultingCall = functionResults.getResultingCall();\n        PsiElement declaration = DescriptorToSourceUtils.descriptorToDeclaration(propertyDescriptor);\n        if (declaration instanceof JetProperty) {\n            JetProperty property = (JetProperty) declaration;\n            JetPropertyDelegate delegate = property.getDelegate();\n            if (delegate != null) {\n                PsiElement byKeyword = delegate.getByKeywordNode().getPsi();\n                symbolUsageValidator.validateCall(resultingCall, resultingCall.getResultingDescriptor(), trace, byKeyword);\n            }\n        }\n        trace.record(DELEGATED_PROPERTY_RESOLVED_CALL, accessor, resultingCall);\n    }","id":99273,"modified_method":"private void resolveDelegatedPropertyConventionMethod(\n            @NotNull PropertyDescriptor propertyDescriptor,\n            @NotNull JetExpression delegateExpression,\n            @NotNull JetType delegateType,\n            @NotNull BindingTrace trace,\n            @NotNull LexicalScope scope,\n            boolean isGet\n    ) {\n        PropertyAccessorDescriptor accessor = isGet ? propertyDescriptor.getGetter() : propertyDescriptor.getSetter();\n        assert accessor != null : \"Delegated property should have getter/setter \" + propertyDescriptor + \" \" + delegateExpression.getText();\n\n        if (trace.getBindingContext().get(DELEGATED_PROPERTY_CALL, accessor) != null) return;\n\n        OverloadResolutionResults<FunctionDescriptor> functionResults = getDelegatedPropertyConventionMethod(\n                propertyDescriptor, delegateExpression, delegateType, trace, scope, isGet, true);\n        Call call = trace.getBindingContext().get(DELEGATED_PROPERTY_CALL, accessor);\n        assert call != null : \"'getDelegatedPropertyConventionMethod' didn't record a call\";\n\n        if (!functionResults.isSuccess()) {\n            String expectedFunction = renderCall(call, trace.getBindingContext());\n            if (functionResults.isIncomplete()) {\n                trace.report(DELEGATE_SPECIAL_FUNCTION_MISSING.on(delegateExpression, expectedFunction, delegateType));\n            }\n            else if (functionResults.isSingleResult() ||\n                     functionResults.getResultCode() == OverloadResolutionResults.Code.MANY_FAILED_CANDIDATES) {\n                trace.report(DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE\n                                             .on(delegateExpression, expectedFunction, functionResults.getResultingCalls()));\n            }\n            else if (functionResults.isAmbiguity()) {\n                trace.report(DELEGATE_SPECIAL_FUNCTION_AMBIGUITY\n                                             .on(delegateExpression, expectedFunction, functionResults.getResultingCalls()));\n            }\n            else {\n                trace.report(DELEGATE_SPECIAL_FUNCTION_MISSING.on(delegateExpression, expectedFunction, delegateType));\n            }\n            return;\n        }\n\n        FunctionDescriptor resultingDescriptor = functionResults.getResultingDescriptor();\n\n        ResolvedCall<FunctionDescriptor> resultingCall = functionResults.getResultingCall();\n        PsiElement declaration = DescriptorToSourceUtils.descriptorToDeclaration(propertyDescriptor);\n        if (declaration instanceof JetProperty) {\n            JetProperty property = (JetProperty) declaration;\n            JetPropertyDelegate delegate = property.getDelegate();\n            if (delegate != null) {\n                PsiElement byKeyword = delegate.getByKeywordNode().getPsi();\n\n                if (!resultingDescriptor.isOperator()) {\n                    OperatorValidator.Companion.report(byKeyword, resultingDescriptor, trace);\n                }\n\n                symbolUsageValidator.validateCall(resultingCall, resultingCall.getResultingDescriptor(), trace, byKeyword);\n            }\n        }\n        trace.record(DELEGATED_PROPERTY_RESOLVED_CALL, accessor, resultingCall);\n    }","commit_id":"3bb1b1adfdaefdc4ced0b11e69167167beb891d4","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n\tprotected void addDDLDisplayTemplates(\n\t\t\tString ddmStructureKey, String dirName, String fileName)\n\t\tthrows Exception {\n\n\t\tDDMStructure ddmStructure = ddmStructureLocalService.getStructure(\n\t\t\tgroupId, PortalUtil.getClassNameId(DDLRecordSet.class),\n\t\t\tddmStructureKey);\n\n\t\tString resourceBasePath = buildResourcePath(\n\t\t\tresourcesDir, dirName, StringPool.SLASH, fileName);\n\n\t\tSet<String> resourcePaths = servletContext.getResourcePaths(\n\t\t\tresourceBasePath);\n\n\t\tif (resourcePaths == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (String resourcePath : resourcePaths) {\n\t\t\tURL url = servletContext.getResource(resourcePath);\n\n\t\t\tURLConnection urlConnection = url.openConnection();\n\n\t\t\tString script = StringUtil.read(urlConnection.getInputStream());\n\n\t\t\tif (Validator.isNull(script)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\taddDDMTemplate(\n\t\t\t\tgroupId, ddmStructure.getStructureId(), resourcePath,\n\t\t\t\tgetDDMTemplateLanguage(resourcePath), script,\n\t\t\t\tDDMTemplateConstants.TEMPLATE_TYPE_DISPLAY, StringPool.BLANK);\n\t\t}\n\t}","id":99274,"modified_method":"@Override\n\tprotected void addDDLDisplayTemplates(\n\t\t\tString ddmStructureKey, String dirName, String fileName)\n\t\tthrows Exception {\n\n\t\tDDMStructure ddmStructure = ddmStructureLocalService.getStructure(\n\t\t\tgroupId, PortalUtil.getClassNameId(DDLRecordSet.class),\n\t\t\tddmStructureKey);\n\n\t\tSet<String> resourcePaths = servletContext.getResourcePaths(\n\t\t\tbuildResourcePath(\n\t\t\t\tresourcesDir, dirName, StringPool.SLASH, fileName));\n\n\t\tif (resourcePaths == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (String resourcePath : resourcePaths) {\n\t\t\tURL url = servletContext.getResource(resourcePath);\n\n\t\t\tURLConnection urlConnection = url.openConnection();\n\n\t\t\tString script = StringUtil.read(urlConnection.getInputStream());\n\n\t\t\tif (Validator.isNull(script)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\taddDDMTemplate(\n\t\t\t\tgroupId, ddmStructure.getStructureId(), resourcePath,\n\t\t\t\tgetDDMTemplateLanguage(resourcePath), script,\n\t\t\t\tDDMTemplateConstants.TEMPLATE_TYPE_DISPLAY, StringPool.BLANK);\n\t\t}\n\t}","commit_id":"28ea53935141cb06c2e9ec142a7d0556845908d8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void addDDLFormTemplates(\n\t\t\tString ddmStructureKey, String dirName, String fileName)\n\t\tthrows Exception {\n\n\t\tDDMStructure ddmStructure = ddmStructureLocalService.getStructure(\n\t\t\tgroupId, PortalUtil.getClassNameId(DDLRecordSet.class),\n\t\t\tddmStructureKey);\n\n\t\tString resourceBasePath = buildResourcePath(\n\t\t\tresourcesDir, dirName, StringPool.SLASH, fileName);\n\n\t\tSet<String> resourcePaths = servletContext.getResourcePaths(\n\t\t\tresourceBasePath);\n\n\t\tif (resourcePaths == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (String resourcePath : resourcePaths) {\n\t\t\tURL url = servletContext.getResource(resourcePath);\n\n\t\t\tURLConnection urlConnection = url.openConnection();\n\n\t\t\tString script = StringUtil.read(urlConnection.getInputStream());\n\n\t\t\tif (Validator.isNull(script)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\taddDDMTemplate(\n\t\t\t\tgroupId, ddmStructure.getStructureId(), resourcePath, \"xsd\",\n\t\t\t\tscript, DDMTemplateConstants.TEMPLATE_TYPE_FORM,\n\t\t\t\tDDMTemplateConstants.TEMPLATE_MODE_CREATE);\n\t\t}\n\t}","id":99275,"modified_method":"@Override\n\tprotected void addDDLFormTemplates(\n\t\t\tString ddmStructureKey, String dirName, String fileName)\n\t\tthrows Exception {\n\n\t\tDDMStructure ddmStructure = ddmStructureLocalService.getStructure(\n\t\t\tgroupId, PortalUtil.getClassNameId(DDLRecordSet.class),\n\t\t\tddmStructureKey);\n\n\t\tSet<String> resourcePaths = servletContext.getResourcePaths(\n\t\t\tbuildResourcePath(\n\t\t\t\tresourcesDir, dirName, StringPool.SLASH, fileName));\n\n\t\tif (resourcePaths == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (String resourcePath : resourcePaths) {\n\t\t\tURL url = servletContext.getResource(resourcePath);\n\n\t\t\tURLConnection urlConnection = url.openConnection();\n\n\t\t\tString script = StringUtil.read(urlConnection.getInputStream());\n\n\t\t\tif (Validator.isNull(script)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\taddDDMTemplate(\n\t\t\t\tgroupId, ddmStructure.getStructureId(), resourcePath, \"xsd\",\n\t\t\t\tscript, DDMTemplateConstants.TEMPLATE_TYPE_FORM,\n\t\t\t\tDDMTemplateConstants.TEMPLATE_MODE_CREATE);\n\t\t}\n\t}","commit_id":"28ea53935141cb06c2e9ec142a7d0556845908d8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void addApplicationDisplayTemplate(\n\t\t\tString parentDirName, String dirName, long classNameId)\n\t\tthrows Exception {\n\n\t\tString resourceBasePath = buildResourcePath(\n\t\t\tresourcesDir, parentDirName, StringPool.SLASH, dirName);\n\n\t\tSet<String> resourcePaths = servletContext.getResourcePaths(\n\t\t\tresourceBasePath);\n\n\t\tif (resourcePaths == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (String resourcePath : resourcePaths) {\n\t\t\tURL url = servletContext.getResource(resourcePath);\n\n\t\t\tURLConnection urlConnection = url.openConnection();\n\n\t\t\tString script = StringUtil.read(urlConnection.getInputStream());\n\n\t\t\tif (Validator.isNull(script)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tFile file = new File(resourcePath);\n\n\t\t\taddApplicationDisplayTemplate(script, file, classNameId);\n\t\t}\n\t}","id":99276,"modified_method":"@Override\n\tprotected void addApplicationDisplayTemplate(\n\t\t\tString parentDirName, String dirName, long classNameId)\n\t\tthrows Exception {\n\n\t\tSet<String> resourcePaths = servletContext.getResourcePaths(\n\t\t\tbuildResourcePath(\n\t\t\t\tresourcesDir, parentDirName, StringPool.SLASH, dirName));\n\n\t\tif (resourcePaths == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (String resourcePath : resourcePaths) {\n\t\t\tURL url = servletContext.getResource(resourcePath);\n\n\t\t\tURLConnection urlConnection = url.openConnection();\n\n\t\t\tString script = StringUtil.read(urlConnection.getInputStream());\n\n\t\t\tif (Validator.isNull(script)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tFile file = new File(resourcePath);\n\n\t\t\taddApplicationDisplayTemplate(script, file, classNameId);\n\t\t}\n\t}","commit_id":"28ea53935141cb06c2e9ec142a7d0556845908d8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String buildResourcePath(String... resourcePathFragments) {\n\t\tStringBundler sb = new StringBundler(resourcePathFragments.length);\n\n\t\tfor (String resourcePathFragment : resourcePathFragments) {\n\t\t\tsb = sb.append(resourcePathFragment);\n\t\t}\n\n\t\tString path = PathUtil.toUnixPath(sb.toString());\n\n\t\tif (!path.startsWith(StringPool.SLASH)) {\n\t\t\tpath = StringPool.SLASH + path;\n\t\t}\n\n\t\treturn path;\n\t}","id":99277,"modified_method":"protected String buildResourcePath(String... resourcePathParts) {\n\t\tStringBundler sb = new StringBundler(resourcePathParts.length);\n\n\t\tfor (String resourcePathPart : resourcePathParts) {\n\t\t\tsb = sb.append(resourcePathPart);\n\t\t}\n\n\t\tString resourcePath = PathUtil.toUnixPath(sb.toString());\n\n\t\tif (!resourcePath.startsWith(StringPool.SLASH)) {\n\t\t\tresourcePath = StringPool.SLASH + resourcePath;\n\t\t}\n\n\t\treturn resourcePath;\n\t}","commit_id":"28ea53935141cb06c2e9ec142a7d0556845908d8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static String getIpAddrValue(final OperationContext operationContext, final VertexRef target) {\n        return getVertexItem(operationContext, target).getIpAddress();\n    }","id":99278,"modified_method":"protected static String getIpAddrValue(final OperationContext operationContext, final VertexRef target) {\n        Vertex vertex = getVertexItem(operationContext, target);\n        return vertex == null ? null : vertex.getIpAddress();\n    }","commit_id":"8e11989b545dcb18c0fee25d75f69bf6b5da3857","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected static Integer getNodeIdValue(final OperationContext operationContext, final VertexRef target) {\n        return getVertexItem(operationContext, target).getNodeID();\n    }","id":99279,"modified_method":"protected static Integer getNodeIdValue(final OperationContext operationContext, final VertexRef target) {\n        Vertex vertex = getVertexItem(operationContext, target);\n        return vertex == null ? null : vertex.getNodeID();\n    }","commit_id":"8e11989b545dcb18c0fee25d75f69bf6b5da3857","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected static String getLabelValue(final OperationContext operationContext, final VertexRef target) {\n        return getVertexItem(operationContext, target).getLabel();\n    }","id":99280,"modified_method":"protected static String getLabelValue(final OperationContext operationContext, final VertexRef target) {\n        Vertex vertex = getVertexItem(operationContext, target);\n        return vertex == null ? null : vertex.getLabel();\n    }","commit_id":"8e11989b545dcb18c0fee25d75f69bf6b5da3857","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public String getId() {\n        return null;\n    }","id":99281,"modified_method":"@Override\n\tpublic String getId() {\n\t\treturn getClass().getSimpleName();\n\t}","commit_id":"8e11989b545dcb18c0fee25d75f69bf6b5da3857","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public String getId() {\n        return null;\n    }","id":99282,"modified_method":"@Override\n\tpublic String getId() {\n\t\treturn getClass().getSimpleName();\n\t}","commit_id":"8e11989b545dcb18c0fee25d75f69bf6b5da3857","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public String getId() {\n        return null;\n    }","id":99283,"modified_method":"@Override\n\tpublic String getId() {\n\t\treturn getClass().getSimpleName();\n\t}","commit_id":"8e11989b545dcb18c0fee25d75f69bf6b5da3857","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public String getId() {\n        return null;\n    }","id":99284,"modified_method":"@Override\n\tpublic String getId() {\n\t\treturn getClass().getSimpleName();\n\t}","commit_id":"8e11989b545dcb18c0fee25d75f69bf6b5da3857","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public String getId() {\n        return null;\n    }","id":99285,"modified_method":"@Override\n\tpublic String getId() {\n\t\treturn getClass().getSimpleName();\n\t}","commit_id":"8e11989b545dcb18c0fee25d75f69bf6b5da3857","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public String getId() {\n        return null;\n    }","id":99286,"modified_method":"@Override\n\tpublic String getId() {\n\t\treturn getClass().getSimpleName();\n\t}","commit_id":"8e11989b545dcb18c0fee25d75f69bf6b5da3857","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public String getId() {\n        return null;\n    }","id":99287,"modified_method":"@Override\n\tpublic String getId() {\n\t\treturn getClass().getSimpleName();\n\t}","commit_id":"8e11989b545dcb18c0fee25d75f69bf6b5da3857","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public String getId() {\n        return null;\n    }","id":99288,"modified_method":"@Override\n\tpublic String getId() {\n\t\treturn getClass().getSimpleName();\n\t}","commit_id":"8e11989b545dcb18c0fee25d75f69bf6b5da3857","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    \tpublic Undoer execute(List<VertexRef> targets, OperationContext operationContext) {\n    \t\tLoggerFactory.getLogger(getClass()).debug(\"Active provider is: {}\", m_topologyProvider);\n    \t\toperationContext.getGraphContainer().setBaseTopology(m_topologyProvider);\n    \t\toperationContext.getGraphContainer().redoLayout();\n    \t\treturn null;\n    \t}","id":99289,"modified_method":"@Override\n    \tpublic Undoer execute(List<VertexRef> targets, OperationContext operationContext) {\n    \t\texecute(operationContext.getGraphContainer());\n    \t\treturn null;\n    \t}","commit_id":"8e11989b545dcb18c0fee25d75f69bf6b5da3857","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n\tpublic Hits search(SearchContext searchContext, Query query)\n\t\tthrows SearchException {\n\n\t\tStopWatch stopWatch = new StopWatch();\n\n\t\tstopWatch.start();\n\n\t\ttry {\n\t\t\tQueryResponse queryResponse = search(\n\t\t\t\tsearchContext, query, searchContext.getStart(),\n\t\t\t\tsearchContext.getEnd(), false);\n\n\t\t\tHits hits = processQueryResponse(\n\t\t\t\tqueryResponse, searchContext, query);\n\n\t\t\thits.setStart(stopWatch.getStartTime());\n\n\t\t\treturn hits;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(e, e);\n\t\t\t}\n\n\t\t\tif (!_swallowException) {\n\t\t\t\tthrow new SearchException(e.getMessage());\n\t\t\t}\n\n\t\t\treturn new HitsImpl();\n\t\t}\n\t\tfinally {\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\tstopWatch.stop();\n\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Searching \" + query.toString() + \" took \" +\n\t\t\t\t\t\tstopWatch.getTime() + \" ms\");\n\t\t\t}\n\t\t}\n\t}","id":99290,"modified_method":"@Override\n\tpublic Hits search(SearchContext searchContext, Query query)\n\t\tthrows SearchException {\n\n\t\tStopWatch stopWatch = new StopWatch();\n\n\t\tstopWatch.start();\n\n\t\ttry {\n\t\t\tint total = (int)searchCount(searchContext, query);\n\n\t\t\tint start = searchContext.getStart();\n\t\t\tint end = searchContext.getEnd();\n\n\t\t\tif ((searchContext.getStart() == QueryUtil.ALL_POS) &&\n\t\t\t\t(searchContext.getEnd() == QueryUtil.ALL_POS)) {\n\n\t\t\t\tstart = 0;\n\t\t\t\tend = total;\n\t\t\t}\n\n\t\t\tint[] startAndEnd = SearchPaginationUtil.calculateStartAndEnd(\n\t\t\t\tstart, end, total);\n\n\t\t\tstart = startAndEnd[0];\n\t\t\tend = startAndEnd[1];\n\n\t\t\tQueryResponse queryResponse = search(\n\t\t\t\tsearchContext, query, start, end, false);\n\n\t\t\tHits hits = processQueryResponse(\n\t\t\t\tqueryResponse, searchContext, query);\n\n\t\t\thits.setStart(stopWatch.getStartTime());\n\n\t\t\treturn hits;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(e, e);\n\t\t\t}\n\n\t\t\tif (!_swallowException) {\n\t\t\t\tthrow new SearchException(e.getMessage());\n\t\t\t}\n\n\t\t\treturn new HitsImpl();\n\t\t}\n\t\tfinally {\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\tstopWatch.stop();\n\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Searching \" + query.toString() + \" took \" +\n\t\t\t\t\t\tstopWatch.getTime() + \" ms\");\n\t\t\t}\n\t\t}\n\t}","commit_id":"e2313c33c9f21d4d10dbd307d8a641de6f44514e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void addPagination(SolrQuery solrQuery, int start, int end) {\n\t\tif ((start == QueryUtil.ALL_POS) && (end == QueryUtil.ALL_POS)) {\n\t\t\tsolrQuery.setRows(0);\n\t\t}\n\t\telse {\n\t\t\tsolrQuery.setRows(end - start);\n\t\t\tsolrQuery.setStart(start);\n\t\t}\n\t}","id":99291,"modified_method":"protected void addPagination(SolrQuery solrQuery, int start, int end) {\n\t\tsolrQuery.setStart(start);\n\t\tsolrQuery.setRows(end - start);\n\t}","commit_id":"e2313c33c9f21d4d10dbd307d8a641de6f44514e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected Hits processQueryResponse(\n\t\t\tQueryResponse queryResponse, SearchContext searchContext,\n\t\t\tQuery query)\n\t\tthrows Exception {\n\n\t\tlong startTime = System.currentTimeMillis();\n\n\t\tboolean allResults = false;\n\n\t\tif ((searchContext.getStart() == QueryUtil.ALL_POS) &&\n\t\t\t(searchContext.getEnd() == QueryUtil.ALL_POS)) {\n\n\t\t\tallResults = true;\n\t\t}\n\n\t\tSolrDocumentList solrDocumentList = queryResponse.getResults();\n\n\t\tlong total = solrDocumentList.getNumFound();\n\n\t\tif (allResults && (total > 0)) {\n\t\t\tqueryResponse = search(searchContext, query, 0, (int)total, false);\n\n\t\t\tsolrDocumentList = queryResponse.getResults();\n\n\t\t\ttotal = solrDocumentList.getNumFound();\n\t\t}\n\n\t\tupdateFacetCollectors(queryResponse, searchContext);\n\n\t\tHits hits = new HitsImpl();\n\n\t\tList<Document> documents = new ArrayList<Document>();\n\t\tSet<String> queryTerms = new HashSet<String>();\n\t\tList<Float> scores = new ArrayList<Float>();\n\n\t\tQueryConfig queryConfig = query.getQueryConfig();\n\t\tMap<String, Map<String, List<String>>> highlights =\n\t\t\tqueryResponse.getHighlighting();\n\n\t\tfor (SolrDocument solrDocument : solrDocumentList) {\n\t\t\tDocument document = processSolrDocument(solrDocument);\n\n\t\t\tdocuments.add(document);\n\n\t\t\taddSnippets(\n\t\t\t\tsolrDocument, document, queryConfig, queryTerms, highlights);\n\n\t\t\tfloat score = GetterUtil.getFloat(\n\t\t\t\tString.valueOf(solrDocument.getFieldValue(\"score\")));\n\n\t\t\tscores.add(score);\n\t\t}\n\n\t\thits.setDocs(documents.toArray(new Document[documents.size()]));\n\t\thits.setLength((int)total);\n\t\thits.setQuery(query);\n\t\thits.setQueryTerms(queryTerms.toArray(new String[queryTerms.size()]));\n\n\t\thits.setScores(scores.toArray(new Float[scores.size()]));\n\n\t\thits.setSearchTime(queryResponse.getQTime());\n\t\thits.setStart(startTime);\n\n\t\treturn hits;\n\t}","id":99292,"modified_method":"protected Hits processQueryResponse(\n\t\t\tQueryResponse queryResponse, SearchContext searchContext,\n\t\t\tQuery query)\n\t\tthrows Exception {\n\n\t\tlong startTime = System.currentTimeMillis();\n\n\t\tSolrDocumentList solrDocumentList = queryResponse.getResults();\n\n\t\tupdateFacetCollectors(queryResponse, searchContext);\n\n\t\tHits hits = new HitsImpl();\n\n\t\tList<Document> documents = new ArrayList<Document>();\n\t\tSet<String> queryTerms = new HashSet<String>();\n\t\tList<Float> scores = new ArrayList<Float>();\n\n\t\tQueryConfig queryConfig = query.getQueryConfig();\n\t\tMap<String, Map<String, List<String>>> highlights =\n\t\t\tqueryResponse.getHighlighting();\n\n\t\tfor (SolrDocument solrDocument : solrDocumentList) {\n\t\t\tDocument document = processSolrDocument(solrDocument);\n\n\t\t\tdocuments.add(document);\n\n\t\t\taddSnippets(\n\t\t\t\tsolrDocument, document, queryConfig, queryTerms, highlights);\n\n\t\t\tfloat score = GetterUtil.getFloat(\n\t\t\t\tString.valueOf(solrDocument.getFieldValue(\"score\")));\n\n\t\t\tscores.add(score);\n\t\t}\n\n\t\thits.setDocs(documents.toArray(new Document[documents.size()]));\n\t\thits.setLength((int)solrDocumentList.getNumFound());\n\t\thits.setQuery(query);\n\t\thits.setQueryTerms(queryTerms.toArray(new String[queryTerms.size()]));\n\n\t\thits.setScores(scores.toArray(new Float[scores.size()]));\n\n\t\thits.setSearchTime(queryResponse.getQTime());\n\t\thits.setStart(startTime);\n\n\t\treturn hits;\n\t}","commit_id":"e2313c33c9f21d4d10dbd307d8a641de6f44514e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"private void highlightRightBrace(HighlighterIterator iterator, FileType fileType) {\n    int brace1End = iterator.getEnd();\n\n    boolean matched = BraceMatchingUtil.matchBrace(myDocument.getCharsSequence(), fileType, iterator, false);\n\n    int brace2Start = iterator.atEnd() ? -1 : iterator.getStart();\n\n    highlightBraces(brace2Start, brace1End - 1, matched, false, fileType);\n  }","id":99293,"modified_method":"private void highlightRightBrace(HighlighterIterator iterator, FileType fileType) {\n    TextRange brace1 = TextRange.create(iterator.getStart(), iterator.getEnd());\n\n    boolean matched = BraceMatchingUtil.matchBrace(myDocument.getCharsSequence(), fileType, iterator, false);\n\n    TextRange brace2 = iterator.atEnd() ? null : TextRange.create(iterator.getStart(), iterator.getEnd());\n\n    highlightBraces(brace2, brace1, matched, false, fileType);\n  }","commit_id":"101c5d56a885d4ffd78efa2e858c4807577e308a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void highlightLeftBrace(HighlighterIterator iterator, boolean scopeHighlighting, FileType fileType) {\n    int brace1Start = iterator.getStart();\n    boolean matched = BraceMatchingUtil.matchBrace(myDocument.getCharsSequence(), fileType, iterator, true);\n\n    int brace2End = iterator.atEnd() ? -1 : iterator.getEnd() - 1;\n\n    highlightBraces(brace1Start, brace2End, matched, scopeHighlighting, fileType);\n  }","id":99294,"modified_method":"private void highlightLeftBrace(HighlighterIterator iterator, boolean scopeHighlighting, FileType fileType) {\n    TextRange brace1Start = TextRange.create(iterator.getStart(), iterator.getEnd());\n    boolean matched = BraceMatchingUtil.matchBrace(myDocument.getCharsSequence(), fileType, iterator, true);\n\n    TextRange brace2End = iterator.atEnd() ? null : TextRange.create(iterator.getStart(), iterator.getEnd());\n\n    highlightBraces(brace1Start, brace2End, matched, scopeHighlighting, fileType);\n  }","commit_id":"101c5d56a885d4ffd78efa2e858c4807577e308a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void highlightBraces(final int lBraceOffset, int rBraceOffset, boolean matched, boolean scopeHighlighting, FileType fileType) {\n    if (!matched && fileType == FileTypes.PLAIN_TEXT) {\n      return;\n    }\n\n    EditorColorsScheme scheme = EditorColorsManager.getInstance().getGlobalScheme();\n    final TextAttributes attributes =\n      matched ? scheme.getAttributes(CodeInsightColors.MATCHED_BRACE_ATTRIBUTES)\n              : scheme.getAttributes(CodeInsightColors.UNMATCHED_BRACE_ATTRIBUTES);\n\n    if (rBraceOffset >= 0 && !scopeHighlighting) {\n      highlightBrace(rBraceOffset, matched);\n    }\n\n    if (lBraceOffset >= 0 && !scopeHighlighting) {\n      highlightBrace(lBraceOffset, matched);\n    }\n\n    if (!myEditor.equals(FileEditorManager.getInstance(myProject).getSelectedTextEditor())) {\n      return;\n    }\n\n    if (lBraceOffset >= 0 && rBraceOffset >= 0) {\n      final int startLine = myEditor.offsetToLogicalPosition(lBraceOffset).line;\n      final int endLine = myEditor.offsetToLogicalPosition(rBraceOffset).line;\n      if (endLine - startLine > 0) {\n        final Runnable runnable = new Runnable() {\n          public void run() {\n            if (myProject.isDisposed() || myEditor.isDisposed()) return;\n            Color color = attributes.getBackgroundColor();\n            if (color == null) return;\n            color = color.darker();\n            lineMarkFragment(startLine, endLine, color);\n          }\n        };\n\n        if (!scopeHighlighting) {\n          myAlarm.addRequest(runnable, 300);\n        }\n        else {\n          runnable.run();\n        }\n      }\n      else {\n        if (!myCodeInsightSettings.HIGHLIGHT_SCOPE) {\n          removeLineMarkers();\n        }\n      }\n\n      if (!scopeHighlighting) {\n        showScopeHint(lBraceOffset, lBraceOffset + 1);\n      }\n    }\n    else {\n      if (!myCodeInsightSettings.HIGHLIGHT_SCOPE) {\n        removeLineMarkers();\n      }\n    }\n  }","id":99295,"modified_method":"private void highlightBraces(final TextRange lBrace, TextRange rBrace, boolean matched, boolean scopeHighlighting, FileType fileType) {\n    if (!matched && fileType == FileTypes.PLAIN_TEXT) {\n      return;\n    }\n\n    EditorColorsScheme scheme = EditorColorsManager.getInstance().getGlobalScheme();\n    final TextAttributes attributes =\n      matched ? scheme.getAttributes(CodeInsightColors.MATCHED_BRACE_ATTRIBUTES)\n              : scheme.getAttributes(CodeInsightColors.UNMATCHED_BRACE_ATTRIBUTES);\n\n    if (rBrace != null && !scopeHighlighting) {\n      highlightBrace(rBrace, matched);\n    }\n\n    if (lBrace != null && !scopeHighlighting) {\n      highlightBrace(lBrace, matched);\n    }\n\n    if (!myEditor.equals(FileEditorManager.getInstance(myProject).getSelectedTextEditor())) {\n      return;\n    }\n\n    if (lBrace != null && rBrace !=null) {\n      final int startLine = myEditor.offsetToLogicalPosition(lBrace.getStartOffset()).line;\n      final int endLine = myEditor.offsetToLogicalPosition(rBrace.getEndOffset()).line;\n      if (endLine - startLine > 0) {\n        final Runnable runnable = new Runnable() {\n          public void run() {\n            if (myProject.isDisposed() || myEditor.isDisposed()) return;\n            Color color = attributes.getBackgroundColor();\n            if (color == null) return;\n            color = color.darker();\n            lineMarkFragment(startLine, endLine, color);\n          }\n        };\n\n        if (!scopeHighlighting) {\n          myAlarm.addRequest(runnable, 300);\n        }\n        else {\n          runnable.run();\n        }\n      }\n      else {\n        if (!myCodeInsightSettings.HIGHLIGHT_SCOPE) {\n          removeLineMarkers();\n        }\n      }\n\n      if (!scopeHighlighting) {\n        showScopeHint(lBrace.getStartOffset(), lBrace.getEndOffset());\n      }\n    }\n    else {\n      if (!myCodeInsightSettings.HIGHLIGHT_SCOPE) {\n        removeLineMarkers();\n      }\n    }\n  }","commit_id":"101c5d56a885d4ffd78efa2e858c4807577e308a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void highlightBrace(int rBraceOffset, boolean matched) {\n    EditorColorsScheme scheme = EditorColorsManager.getInstance().getGlobalScheme();\n    final TextAttributes attributes =\n        matched ? scheme.getAttributes(CodeInsightColors.MATCHED_BRACE_ATTRIBUTES)\n        : scheme.getAttributes(CodeInsightColors.UNMATCHED_BRACE_ATTRIBUTES);\n\n\n    RangeHighlighter rbraceHighlighter =\n        myEditor.getMarkupModel().addRangeHighlighter(\n          rBraceOffset, rBraceOffset + 1, HighlighterLayer.LAST + 1, attributes, HighlighterTargetArea.EXACT_RANGE);\n    rbraceHighlighter.setGreedyToLeft(false);\n    rbraceHighlighter.setGreedyToRight(false);\n    registerHighlighter(rbraceHighlighter);\n  }","id":99296,"modified_method":"private void highlightBrace(TextRange braceRange, boolean matched) {\n    EditorColorsScheme scheme = EditorColorsManager.getInstance().getGlobalScheme();\n    final TextAttributes attributes =\n        matched ? scheme.getAttributes(CodeInsightColors.MATCHED_BRACE_ATTRIBUTES)\n        : scheme.getAttributes(CodeInsightColors.UNMATCHED_BRACE_ATTRIBUTES);\n\n\n    RangeHighlighter rbraceHighlighter =\n        myEditor.getMarkupModel().addRangeHighlighter(\n          braceRange.getStartOffset(), braceRange.getEndOffset(), HighlighterLayer.LAST + 1, attributes, HighlighterTargetArea.EXACT_RANGE);\n    rbraceHighlighter.setGreedyToLeft(false);\n    rbraceHighlighter.setGreedyToRight(false);\n    registerHighlighter(rbraceHighlighter);\n  }","commit_id":"101c5d56a885d4ffd78efa2e858c4807577e308a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Fold fromAceFold(AceFold fold)\n   {\n      return new Fold(fold.getStart(), fold.getEnd(), fold.getPlaceholder());\n   }","id":99297,"modified_method":"public static Fold fromAceFold(AceFold fold, Position offset)\n   {\n      return new Fold(\n            Position.create(fold.getStart().getRow() + offset.getRow(), fold.getStart().getColumn()),\n            Position.create(fold.getEnd().getRow() + offset.getRow(), fold.getEnd().getColumn()),\n            fold.getPlaceholder());\n   }","commit_id":"92fb360031b6095d305c86a648e832742b6ddbbd","url":"https://github.com/rstudio/rstudio"},{"original_method":"/**\n    * Puts the input ace folds, and their subfolds (recursively), into a flat\n    * list of Fold objects.\n    */\n   public static ArrayList<Fold> flatten(JsArray<AceFold> folds)\n   {\n      ArrayList<Fold> results = new ArrayList<Fold>();\n      for (int i = 0; i < folds.length(); i++)\n         collect(folds.get(i), results);\n      return results;\n   }","id":99298,"modified_method":"/**\n    * Puts the input ace folds, and their subfolds (recursively), into a flat\n    * list of Fold objects.\n    */\n   public static ArrayList<Fold> flatten(JsArray<AceFold> folds)\n   {\n      ArrayList<Fold> results = new ArrayList<Fold>();\n      for (int i = 0; i < folds.length(); i++)\n         collect(folds.get(i), results, Position.create(0, 0));\n      return results;\n   }","commit_id":"92fb360031b6095d305c86a648e832742b6ddbbd","url":"https://github.com/rstudio/rstudio"},{"original_method":"private static void collect(AceFold fold, ArrayList<Fold> results)\n   {\n      results.add(fromAceFold(fold));\n      JsArray<AceFold> subFolds = fold.getSubFolds();\n      for (int i = 0; i < subFolds.length(); i++)\n         collect(subFolds.get(i), results);\n   }","id":99299,"modified_method":"private static void collect(AceFold fold, ArrayList<Fold> results, Position parentOffset)\n   {\n      results.add(fromAceFold(fold, parentOffset));\n      JsArray<AceFold> subFolds = fold.getSubFolds();\n      for (int i = 0; i < subFolds.length(); i++)\n      {\n         AceFold subFold = subFolds.get(i);\n         Position offset = Position.create(\n               fold.getStart().getRow() + parentOffset.getRow(),\n               fold.getStart().getColumn() + parentOffset.getColumn());\n         collect(subFold, results, offset);\n      }\n   }","commit_id":"92fb360031b6095d305c86a648e832742b6ddbbd","url":"https://github.com/rstudio/rstudio"},{"original_method":"protected void nativeMouseEvent(com.jogamp.newt.event.MouseEvent nativeEvent,\n                                  int peAction) {\n    int modifiers = nativeEvent.getModifiers();\n    int peModifiers = modifiers &\n                      (InputEvent.SHIFT_MASK |\n                       InputEvent.CTRL_MASK |\n                       InputEvent.META_MASK |\n                       InputEvent.ALT_MASK);\n\n    int peButton = 0;\n    if ((modifiers & InputEvent.BUTTON1_MASK) != 0) {\n      peButton = PConstants.LEFT;\n    } else if ((modifiers & InputEvent.BUTTON2_MASK) != 0) {\n      peButton = PConstants.CENTER;\n    } else if ((modifiers & InputEvent.BUTTON3_MASK) != 0) {\n      peButton = PConstants.RIGHT;\n    }\n\n    if (PApplet.platform == PConstants.MACOSX) {\n      //if (nativeEvent.isPopupTrigger()) {\n      if ((modifiers & InputEvent.CTRL_MASK) != 0) {\n        peButton = PConstants.RIGHT;\n      }\n    }\n\n    int peCount = 0;\n    if (peAction == MouseEvent.WHEEL) {\n      peCount = nativeEvent.isShiftDown() ? (int)nativeEvent.getRotation()[0] :\n                                            (int)nativeEvent.getRotation()[1];\n    } else {\n      peCount = nativeEvent.getClickCount();\n    }\n\n    MouseEvent me = new MouseEvent(nativeEvent, nativeEvent.getWhen(),\n                                   peAction, peModifiers,\n                                   nativeEvent.getX(), nativeEvent.getY(),\n                                   peButton,\n                                   peCount);\n\n    sketch.postEvent(me);\n  }","id":99300,"modified_method":"protected void nativeMouseEvent(com.jogamp.newt.event.MouseEvent nativeEvent,\n                                  int peAction) {\n    int modifiers = nativeEvent.getModifiers();\n    int peModifiers = modifiers &\n                      (InputEvent.SHIFT_MASK |\n                       InputEvent.CTRL_MASK |\n                       InputEvent.META_MASK |\n                       InputEvent.ALT_MASK);\n\n    int peButton = 0;\n    if ((modifiers & InputEvent.BUTTON1_MASK) != 0) {\n      peButton = PConstants.LEFT;\n    } else if ((modifiers & InputEvent.BUTTON2_MASK) != 0) {\n      peButton = PConstants.CENTER;\n    } else if ((modifiers & InputEvent.BUTTON3_MASK) != 0) {\n      peButton = PConstants.RIGHT;\n    }\n\n    if (PApplet.platform == PConstants.MACOSX) {\n      //if (nativeEvent.isPopupTrigger()) {\n      if ((modifiers & InputEvent.CTRL_MASK) != 0) {\n        peButton = PConstants.RIGHT;\n      }\n    }\n\n    int peCount = 0;\n    if (peAction == MouseEvent.WHEEL) {\n      peCount = nativeEvent.isShiftDown() ? (int)nativeEvent.getRotation()[0] :\n                                            (int)nativeEvent.getRotation()[1];\n    } else {\n      peCount = nativeEvent.getClickCount();\n    }\n\n    \n    if (presentMode) {\n      if (20 < nativeEvent.getX() && nativeEvent.getX() < 20 + 100 &&\n          screenRect.height - 70 < nativeEvent.getY() && nativeEvent.getY() < screenRect.height - 20) {\n        System.err.println(\"clicked on exit button\");\n//      if (externalMessages) {\n//        System.err.println(PApplet.EXTERNAL_QUIT);\n//        System.err.flush();  // important\n//      }\n        animator.stop();\n        PSurfaceJOGL.this.sketch.exit();\n        window.destroy();\n      }\n    }\n    \n    int x = nativeEvent.getX() - (int)offsetX;\n    int y = nativeEvent.getY() - (int)offsetY;\n    \n    MouseEvent me = new MouseEvent(nativeEvent, nativeEvent.getWhen(),\n                                   peAction, peModifiers,\n                                   x, y,\n                                   peButton,\n                                   peCount);\n\n    sketch.postEvent(me);\n  }","commit_id":"6af48ecfef1dcf8dfc8baac1e3d2fd3c38358cb8","url":"https://github.com/processing/processing"},{"original_method":"public void initFrame(PApplet sketch, int backgroundColor,\n                        int deviceIndex, boolean fullScreen,\n                        boolean spanDisplays) {\n    this.sketch = sketch;\n\n    Display display = NewtFactory.createDisplay(null);\n    display.addReference();\n    Screen screen = NewtFactory.createScreen(display, 0);\n    screen.addReference();\n\n    ArrayList<MonitorDevice> monitors = new ArrayList<MonitorDevice>();\n    for (int i = 0; i < screen.getMonitorDevices().size(); i++) {\n      MonitorDevice monitor = screen.getMonitorDevices().get(i);\n      System.out.println(\"Monitor \" + monitor.getId() + \" ************\");\n      System.out.println(monitor.toString());\n      System.out.println(monitor.getViewportInWindowUnits());\n      System.out.println(monitor.getViewport());\n\n      monitors.add(monitor);\n    }\n    System.out.println(\"*******************************\");\n\n    if (deviceIndex >= 0) {  // if -1, use the default device\n      if (deviceIndex < monitors.size()) {\n        displayDevice = monitors.get(deviceIndex);\n      } else {\n        System.err.format(\"Display %d does not exist, \" +\n          \"using the default display instead.\", deviceIndex);\n        for (int i = 0; i < monitors.size(); i++) {\n          System.err.format(\"Display %d is %s\\n\", i, monitors.get(i));\n        }\n      }\n    }\n\n    if (profile == null) {\n      if (PJOGL.PROFILE == 2) {\n        try {\n          profile = GLProfile.getGL2ES1();\n        } catch (GLException ex) {\n          profile = GLProfile.getMaxFixedFunc(true);\n        }\n      } else if (PJOGL.PROFILE == 3) {\n        try {\n          profile = GLProfile.getGL2GL3();\n        } catch (GLException ex) {\n          profile = GLProfile.getMaxProgrammable(true);\n        }\n        if (!profile.isGL3()) {\n          PGraphics.showWarning(\"Requested profile GL3 but is not available, got: \" + profile);\n        }\n      } else if (PJOGL.PROFILE == 4) {\n        try {\n          profile = GLProfile.getGL4ES3();\n        } catch (GLException ex) {\n          profile = GLProfile.getMaxProgrammable(true);\n        }\n        if (!profile.isGL4()) {\n          PGraphics.showWarning(\"Requested profile GL4 but is not available, got: \" + profile);\n        }\n      } else throw new RuntimeException(PGL.UNSUPPORTED_GLPROF_ERROR);\n    }\n\n    // Setting up the desired capabilities;\n    GLCapabilities caps = new GLCapabilities(profile);\n    caps.setAlphaBits(PGL.REQUESTED_ALPHA_BITS);\n    caps.setDepthBits(PGL.REQUESTED_DEPTH_BITS);\n    caps.setStencilBits(PGL.REQUESTED_STENCIL_BITS);\n\n//    caps.setPBuffer(false);\n//    caps.setFBO(false);\n\n    pgl.reqNumSamples = graphics.quality;\n    caps.setSampleBuffers(true);\n    caps.setNumSamples(pgl.reqNumSamples);\n    caps.setBackgroundOpaque(true);\n    caps.setOnscreen(true);\n    pgl.capabilities = caps;\n    System.err.println(\"0. create window\");\n    window = GLWindow.create(screen, caps);\n\n    sketchWidth = sketch.sketchWidth();\n    sketchHeight = sketch.sketchHeight();\n\n    if (displayDevice == null) {\n      displayDevice = window.getMainMonitor();\n    }\n    int sketchX = displayDevice.getViewportInWindowUnits().getX();\n    int sketchY = displayDevice.getViewportInWindowUnits().getY();\n\n    int screenWidth = screen.getWidth();\n    int screenHeight = screen.getHeight();\n\n    screenRect = spanDisplays ? new Rectangle(0, 0, screen.getWidth(), screen.getHeight()) :\n                                new Rectangle(0, 0, displayDevice.getViewportInWindowUnits().getWidth(),\n                                                    displayDevice.getViewportInWindowUnits().getHeight());\n\n    // Sketch has already requested to be the same as the screen's\n    // width and height, so let's roll with full screen mode.\n    if (screenRect.width == sketchWidth &&\n        screenRect.height == sketchHeight) {\n      fullScreen = true;\n    }\n\n    if (fullScreen || spanDisplays) {\n      sketchWidth = screenRect.width;\n      sketchHeight = screenRect.height;\n    }\n\n//    window..setBackground(new Color(backgroundColor, true));\n    window.setPosition(sketchX, sketchY);\n    window.setSize(sketchWidth, sketchHeight);\n\n    System.out.println(\"deviceIndex: \" + deviceIndex);\n    System.out.println(displayDevice);\n    System.out.println(\"Screen res \" + screenWidth + \"x\" + screenHeight);\n\n    // This example could be useful:\n    // com.jogamp.opengl.test.junit.newt.mm.TestScreenMode01cNEWT\n    if (fullScreen) {\n      if (spanDisplays) {\n        window.setFullscreen(monitors);\n      } else {\n        window.setFullscreen(true);\n      }\n    }\n\n    float[] reqSurfacePixelScale;\n    if (graphics.is2X()) {\n       // Retina\n       reqSurfacePixelScale = new float[] { ScalableSurface.AUTOMAX_PIXELSCALE,\n                                            ScalableSurface.AUTOMAX_PIXELSCALE };\n       pgl.pixel_scale = 2;\n    } else {\n      // Non-retina\n      reqSurfacePixelScale = new float[] { ScalableSurface.IDENTITY_PIXELSCALE,\n                                           ScalableSurface.IDENTITY_PIXELSCALE };\n      pgl.pixel_scale = 1;\n    }\n    window.setSurfaceScale(reqSurfacePixelScale);\n\n    NEWTMouseListener mouseListener = new NEWTMouseListener();\n    window.addMouseListener(mouseListener);\n    NEWTKeyListener keyListener = new NEWTKeyListener();\n    window.addKeyListener(keyListener);\n    NEWTWindowListener winListener = new NEWTWindowListener();\n    window.addWindowListener(winListener);\n\n    DrawListener drawlistener = new DrawListener();\n    window.addGLEventListener(drawlistener);\n\n    System.err.println(\"0. create animator\");\n    animator = new FPSAnimator(window, 60);\n    drawException = null;\n    animator.setUncaughtExceptionHandler(new GLAnimatorControl.UncaughtExceptionHandler() {\n      @Override\n      public void uncaughtException(final GLAnimatorControl animator,\n                                    final GLAutoDrawable drawable,\n                                    final Throwable cause) {\n        synchronized (waitObject) {\n//          System.err.println(\"Caught exception: \" + cause.getMessage());\n          drawException = cause;\n          waitObject.notify();\n        }\n      }\n    });\n\n    (new Thread(new Runnable() {\n      public void run() {\n        synchronized (waitObject) {\n          try {\n            if (drawException == null) waitObject.wait();\n          } catch (InterruptedException e) {\n            e.printStackTrace();\n          }\n//          System.err.println(\"Caught exception: \" + drawException.getMessage());\n          if (drawException instanceof RuntimeException) {\n            throw (RuntimeException)drawException.getCause();\n          } else {\n            throw new RuntimeException(drawException.getCause());\n          }\n        }\n      }\n    }\n    )).start();\n\n\n    /*\n    try {\n      EventQueue.invokeAndWait(new Runnable() {\n        public void run() {\n          while (true) {\n            try {\n              if (drawException != null) {\n                if (drawException instanceof RuntimeException) {\n                  throw (RuntimeException)drawException;\n                } else {\n                  throw new RuntimeException(drawException);\n                }\n              } else {\n                Thread.sleep(100);\n              }\n            } catch (InterruptedException e) { }\n          }\n      }});\n    } catch (Exception ex) {\n    }\n*/\n\n\n    window.addWindowListener(new WindowAdapter() {\n      @Override\n      public void windowDestroyNotify(final WindowEvent e) {\n        animator.stop();\n        PSurfaceJOGL.this.sketch.exit();\n        window.destroy();\n      }\n    });\n\n\n    window.setVisible(true);\n    System.err.println(\"1. set visible\");\n    \n    /*\n    try {\n      EventQueue.invokeAndWait(new Runnable() {\n        public void run() {\n          window.setVisible(true);\n          System.err.println(\"1. set visible\");\n      }});\n    } catch (Exception ex) {\n      // error setting the window visible, should quit...\n    }\n*/\n    \n//    frame = new DummyFrame();\n//    return frame;\n  }","id":99301,"modified_method":"public void initFrame(PApplet sketch, int backgroundColor,\n                        int deviceIndex, boolean fullScreen,\n                        boolean spanDisplays) {\n    this.sketch = sketch;\n\n    Display display = NewtFactory.createDisplay(null);\n    display.addReference();\n    Screen screen = NewtFactory.createScreen(display, 0);\n    screen.addReference();\n\n    ArrayList<MonitorDevice> monitors = new ArrayList<MonitorDevice>();\n    for (int i = 0; i < screen.getMonitorDevices().size(); i++) {\n      MonitorDevice monitor = screen.getMonitorDevices().get(i);\n      System.out.println(\"Monitor \" + monitor.getId() + \" ************\");\n      System.out.println(monitor.toString());\n      System.out.println(monitor.getViewportInWindowUnits());\n      System.out.println(monitor.getViewport());\n\n      monitors.add(monitor);\n    }\n    System.out.println(\"*******************************\");\n\n    if (deviceIndex >= 0) {  // if -1, use the default device\n      if (deviceIndex < monitors.size()) {\n        displayDevice = monitors.get(deviceIndex);\n      } else {\n        System.err.format(\"Display %d does not exist, \" +\n          \"using the default display instead.\", deviceIndex);\n        for (int i = 0; i < monitors.size(); i++) {\n          System.err.format(\"Display %d is %s\\n\", i, monitors.get(i));\n        }\n      }\n    }\n\n    if (profile == null) {\n      if (PJOGL.PROFILE == 2) {\n        try {\n          profile = GLProfile.getGL2ES1();\n        } catch (GLException ex) {\n          profile = GLProfile.getMaxFixedFunc(true);\n        }\n      } else if (PJOGL.PROFILE == 3) {\n        try {\n          profile = GLProfile.getGL2GL3();\n        } catch (GLException ex) {\n          profile = GLProfile.getMaxProgrammable(true);\n        }\n        if (!profile.isGL3()) {\n          PGraphics.showWarning(\"Requested profile GL3 but is not available, got: \" + profile);\n        }\n      } else if (PJOGL.PROFILE == 4) {\n        try {\n          profile = GLProfile.getGL4ES3();\n        } catch (GLException ex) {\n          profile = GLProfile.getMaxProgrammable(true);\n        }\n        if (!profile.isGL4()) {\n          PGraphics.showWarning(\"Requested profile GL4 but is not available, got: \" + profile);\n        }\n      } else throw new RuntimeException(PGL.UNSUPPORTED_GLPROF_ERROR);\n    }\n\n    // Setting up the desired capabilities;\n    GLCapabilities caps = new GLCapabilities(profile);\n    caps.setAlphaBits(PGL.REQUESTED_ALPHA_BITS);\n    caps.setDepthBits(PGL.REQUESTED_DEPTH_BITS);\n    caps.setStencilBits(PGL.REQUESTED_STENCIL_BITS);\n\n//    caps.setPBuffer(false);\n//    caps.setFBO(false);\n\n    pgl.reqNumSamples = graphics.quality;\n    caps.setSampleBuffers(true);\n    caps.setNumSamples(pgl.reqNumSamples);\n    caps.setBackgroundOpaque(true);\n    caps.setOnscreen(true);\n    pgl.capabilities = caps;\n    System.err.println(\"0. create window\");\n    window = GLWindow.create(screen, caps);\n\n    sketchWidth = sketch.sketchWidth();\n    sketchHeight = sketch.sketchHeight();\n\n    if (displayDevice == null) {\n      displayDevice = window.getMainMonitor();\n    }\n    int sketchX = displayDevice.getViewportInWindowUnits().getX();\n    int sketchY = displayDevice.getViewportInWindowUnits().getY();\n\n    int screenWidth = screen.getWidth();\n    int screenHeight = screen.getHeight();\n\n    screenRect = spanDisplays ? new Rectangle(0, 0, screen.getWidth(), screen.getHeight()) :\n                                new Rectangle(0, 0, displayDevice.getViewportInWindowUnits().getWidth(),\n                                                    displayDevice.getViewportInWindowUnits().getHeight());\n\n    // Sketch has already requested to be the same as the screen's\n    // width and height, so let's roll with full screen mode.\n    if (screenRect.width == sketchWidth &&\n        screenRect.height == sketchHeight) {\n      fullScreen = true;\n    }\n\n//    if (fullScreen || spanDisplays) {\n    if (spanDisplays) {\n      sketchWidth = screenRect.width;\n      sketchHeight = screenRect.height;\n    }\n\n//    window..setBackground(new Color(backgroundColor, true));\n    window.setPosition(sketchX, sketchY);\n    window.setSize(sketchWidth, sketchHeight);\n\n    System.out.println(\"deviceIndex: \" + deviceIndex);\n    System.out.println(displayDevice);\n    System.out.println(\"Screen res \" + screenWidth + \"x\" + screenHeight);\n\n    // This example could be useful:\n    // com.jogamp.opengl.test.junit.newt.mm.TestScreenMode01cNEWT\n    if (fullScreen) {\n      PApplet.hideMenuBar();\n      if (spanDisplays) {\n        window.setFullscreen(monitors);\n      } else {\n        window.setFullscreen(true);\n      }\n    }\n\n    float[] reqSurfacePixelScale;\n    if (graphics.is2X()) {\n       // Retina\n       reqSurfacePixelScale = new float[] { ScalableSurface.AUTOMAX_PIXELSCALE,\n                                            ScalableSurface.AUTOMAX_PIXELSCALE };\n       pgl.pixel_scale = 2;\n    } else {\n      // Non-retina\n      reqSurfacePixelScale = new float[] { ScalableSurface.IDENTITY_PIXELSCALE,\n                                           ScalableSurface.IDENTITY_PIXELSCALE };\n      pgl.pixel_scale = 1;\n    }\n    window.setSurfaceScale(reqSurfacePixelScale);\n\n    NEWTMouseListener mouseListener = new NEWTMouseListener();\n    window.addMouseListener(mouseListener);\n    NEWTKeyListener keyListener = new NEWTKeyListener();\n    window.addKeyListener(keyListener);\n    NEWTWindowListener winListener = new NEWTWindowListener();\n    window.addWindowListener(winListener);\n\n    DrawListener drawlistener = new DrawListener();\n    window.addGLEventListener(drawlistener);\n\n    System.err.println(\"0. create animator\");\n    animator = new FPSAnimator(window, 60);\n    drawException = null;\n    animator.setUncaughtExceptionHandler(new GLAnimatorControl.UncaughtExceptionHandler() {\n      @Override\n      public void uncaughtException(final GLAnimatorControl animator,\n                                    final GLAutoDrawable drawable,\n                                    final Throwable cause) {\n        synchronized (waitObject) {\n//          System.err.println(\"Caught exception: \" + cause.getMessage());\n          drawException = cause;\n          waitObject.notify();\n        }\n      }\n    });\n\n    (new Thread(new Runnable() {\n      public void run() {\n        synchronized (waitObject) {\n          try {\n            if (drawException == null) waitObject.wait();\n          } catch (InterruptedException e) {\n            e.printStackTrace();\n          }\n//          System.err.println(\"Caught exception: \" + drawException.getMessage());\n          if (drawException instanceof RuntimeException) {\n            throw (RuntimeException)drawException.getCause();\n          } else {\n            throw new RuntimeException(drawException.getCause());\n          }\n        }\n      }\n    }\n    )).start();\n\n\n    /*\n    try {\n      EventQueue.invokeAndWait(new Runnable() {\n        public void run() {\n          while (true) {\n            try {\n              if (drawException != null) {\n                if (drawException instanceof RuntimeException) {\n                  throw (RuntimeException)drawException;\n                } else {\n                  throw new RuntimeException(drawException);\n                }\n              } else {\n                Thread.sleep(100);\n              }\n            } catch (InterruptedException e) { }\n          }\n      }});\n    } catch (Exception ex) {\n    }\n*/\n\n\n    window.addWindowListener(new WindowAdapter() {\n      @Override\n      public void windowDestroyNotify(final WindowEvent e) {\n        animator.stop();\n        PSurfaceJOGL.this.sketch.exit();\n        window.destroy();\n      }\n    });\n\n\n    window.setVisible(true);\n    System.err.println(\"1. set visible\");\n    \n    /*\n    try {\n      EventQueue.invokeAndWait(new Runnable() {\n        public void run() {\n          window.setVisible(true);\n          System.err.println(\"1. set visible\");\n      }});\n    } catch (Exception ex) {\n      // error setting the window visible, should quit...\n    }\n*/\n    \n//    frame = new DummyFrame();\n//    return frame;\n  }","commit_id":"6af48ecfef1dcf8dfc8baac1e3d2fd3c38358cb8","url":"https://github.com/processing/processing"},{"original_method":"public void placePresent(int stopColor) {\n    // TODO Auto-generated method stub\n\n  }","id":99302,"modified_method":"public void placePresent(int stopColor) {    \n    if (sketchWidth < screenRect.width || sketchHeight < screenRect.height) {\n      System.err.println(\"Present mode\");\n//    System.err.println(\"WILL USE FBO\");\n      presentMode = pgl.presentMode = true;\n      offsetX = pgl.offsetX = 0.5f * (screenRect.width - sketchWidth);\n      offsetY = pgl.offsetY = 0.5f * (screenRect.height - sketchHeight);\n      pgl.requestFBOLayer();\n    }\n  }","commit_id":"6af48ecfef1dcf8dfc8baac1e3d2fd3c38358cb8","url":"https://github.com/processing/processing"},{"original_method":"/**\n     * Creates a RotateCommand.\n     * Assign the initial object set, compute pivot point and rotation angle.\n     * Computation of pivot point is done by the same rules that are used in\n     * the \"align nodes in circle\" action.\n     */\n    public RotateCommand(Collection<OsmPrimitive> objects, EastNorth start, EastNorth end) {\n\n        this.nodes = AllNodesVisitor.getAllNodes(objects);\n        pivot = new EastNorth(0,0);\n\n        for (Node n : this.nodes) {\n            OldState os = new OldState();\n            os.latlon = new LatLon(n.getCoor());\n            os.eastNorth = n.getEastNorth();\n            os.modified = n.isModified();\n            oldState.put(n, os);\n            pivot = pivot.add(os.eastNorth.east(), os.eastNorth.north());\n        }\n        pivot = new EastNorth(pivot.east()/this.nodes.size(), pivot.north()/this.nodes.size());\n\n        rotationAngle = Math.PI/2;\n        rotateAgain(start, end);\n    }","id":99303,"modified_method":"/**\n     * Creates a RotateCommand.\n     * Assign the initial object set, compute pivot point and inital rotation angle.\n     */\n    public RotateCommand(Collection<OsmPrimitive> objects, EastNorth currentEN) {\n        super(objects);\n\n        pivot = getNodesCenter();\n\n        // We remember the very first position of the mouse for this action.\n        // Note that SelectAction will keep the same ScaleCommand when the user\n        // releases the button and presses it again with the same modifiers.\n        // The very first point of this operation is stored here.\n        startEN   = currentEN;\n\n        startAngle = getAngle(currentEN);\n        rotationAngle = 0.0;\n\n        handleEvent(currentEN);\n    }","commit_id":"298d1b14231335bbf31077da580ade82a6160fb5","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public void mouseReleased(MouseEvent e) {\n        debug(\"mouseReleased: e.getPoint()=\" + e.getPoint());\n\n        if(!mv.isActiveLayerVisible())\n            return;\n\n        restoreCursor();\n        if (mode == Mode.select) {\n            selectionManager.unregister(mv);\n\n            // Select Draw Tool if no selection has been made\n            if(getCurrentDataSet().getSelected().size() == 0 && !cancelDrawMode) {\n                Main.map.selectDrawTool(true);\n                return;\n            }\n        }\n\n        if (mode == Mode.move) {\n            if (!didMouseDrag) {\n                // only built in move mode\n                virtualWays.clear();\n                virtualNode = null;\n\n                // do nothing if the click was to short to be recognized as a drag,\n                // but the release position is farther than 10px away from the press position\n                if (mousePos.distanceSq(e.getPoint())<100) {\n                    selectPrims(cyclePrims(cycleList, e), e, true, false);\n\n                    // If the user double-clicked a node, change to draw mode\n                    Collection<OsmPrimitive> c = getCurrentDataSet().getSelected();\n                    if(e.getClickCount() >=2 && c.size() == 1 && c.iterator().next() instanceof Node) {\n                        // We need to do it like this as otherwise drawAction will see a double\n                        // click and switch back to SelectMode\n                        Main.worker.execute(new Runnable(){\n                            public void run() {\n                                Main.map.selectDrawTool(true);\n                            }\n                        });\n                        return;\n                    }\n                }\n            } else {\n                int max = Main.pref.getInteger(\"warn.move.maxelements\", 20), limit = max;\n                for (OsmPrimitive osm : getCurrentDataSet().getSelected()) {\n                    if (osm instanceof Way) {\n                        limit -= ((Way)osm).getNodes().size();\n                    }\n                    if ((limit -= 1) < 0) {\n                        break;\n                    }\n                }\n                if (limit < 0) {\n                    ExtendedDialog ed = new ExtendedDialog(\n                            Main.parent,\n                            tr(\"Move elements\"),\n                            new String[] {tr(\"Move them\"), tr(\"Undo move\")});\n                    ed.setButtonIcons(new String[] {\"reorder.png\", \"cancel.png\"});\n                    ed.setContent(tr(\"You moved more than {0} elements. \"\n                            + \"Moving a large number of elements is often an error.\\n\"\n                            + \"Really move them?\", max));\n                    ed.setCancelButton(2);\n                    ed.toggleEnable(\"movedManyElements\");\n                    ed.showDialog();\n\n                    if(ed.getValue() != 1) {\n                        Main.main.undoRedo.undo();\n                    }\n                } else {\n                    mergePrims(getCurrentDataSet().getSelectedNodes(), e);\n                }\n                getCurrentDataSet().fireSelectionChanged();\n            }\n        }\n\n        // I don't see why we need this.\n        //updateStatusLine();\n        mode = null;\n        updateStatusLine();\n    }","id":99304,"modified_method":"@Override\n    public void mouseReleased(MouseEvent e) {\n        debug(\"mouseReleased: e.getPoint()=\" + e.getPoint());\n\n        if (!mv.isActiveLayerVisible()) {\n            return;\n        }\n\n        startingDraggingPos = null;\n\n        restoreCursor();\n        if (mode == Mode.select) {\n            selectionManager.unregister(mv);\n\n            // Select Draw Tool if no selection has been made\n            if (getCurrentDataSet().getSelected().size() == 0 && !cancelDrawMode) {\n                Main.map.selectDrawTool(true);\n                return;\n            }\n        }\n\n        if (mode == Mode.move) {\n            if (!didMouseDrag) {\n                // only built in move mode\n                virtualWays.clear();\n                virtualNode = null;\n\n                // do nothing if the click was to short to be recognized as a drag,\n                // but the release position is farther than 10px away from the press position\n                if (lastMousePos.distanceSq(e.getPoint()) < 100) {\n                    selectPrims(cyclePrims(cycleList, e), e, true, false);\n\n                    // If the user double-clicked a node, change to draw mode\n                    Collection<OsmPrimitive> c = getCurrentDataSet().getSelected();\n                    if (e.getClickCount() >= 2 && c.size() == 1 && c.iterator().next() instanceof Node) {\n                        // We need to do it like this as otherwise drawAction will see a double\n                        // click and switch back to SelectMode\n                        Main.worker.execute(new Runnable() {\n\n                            public void run() {\n                                Main.map.selectDrawTool(true);\n                            }\n                        });\n                        return;\n                    }\n                }\n            } else {\n                int max = Main.pref.getInteger(\"warn.move.maxelements\", 20), limit = max;\n                for (OsmPrimitive osm : getCurrentDataSet().getSelected()) {\n                    if (osm instanceof Way) {\n                        limit -= ((Way) osm).getNodes().size();\n                    }\n                    if ((limit -= 1) < 0) {\n                        break;\n                    }\n                }\n                if (limit < 0) {\n                    ExtendedDialog ed = new ExtendedDialog(\n                            Main.parent,\n                            tr(\"Move elements\"),\n                            new String[]{tr(\"Move them\"), tr(\"Undo move\")});\n                    ed.setButtonIcons(new String[]{\"reorder.png\", \"cancel.png\"});\n                    ed.setContent(tr(\"You moved more than {0} elements. \" + \"Moving a large number of elements is often an error.\\n\" + \"Really move them?\", max));\n                    ed.setCancelButton(2);\n                    ed.toggleEnable(\"movedManyElements\");\n                    ed.showDialog();\n\n                    if (ed.getValue() != 1) {\n                        Main.main.undoRedo.undo();\n                    }\n                } else {\n                    mergePrims(getCurrentDataSet().getSelectedNodes(), e);\n                }\n                getCurrentDataSet().fireSelectionChanged();\n            }\n        }\n\n        // I don't see why we need this.\n        //updateStatusLine();\n        mode = null;\n        updateStatusLine();\n    }","commit_id":"298d1b14231335bbf31077da580ade82a6160fb5","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * If the left mouse button is pressed, move all currently selected\n     * objects (if one of them is under the mouse) or the current one under the\n     * mouse (which will become selected).\n     */\n    @Override public void mouseDragged(MouseEvent e) {\n        if(!mv.isActiveLayerVisible())\n            return;\n\n        cancelDrawMode = true;\n        if (mode == Mode.select) return;\n\n        // do not count anything as a move if it lasts less than 100 milliseconds.\n        if ((mode == Mode.move) && (System.currentTimeMillis() - mouseDownTime < initialMoveDelay)) return;\n\n        if(mode != Mode.rotate) // button is pressed in rotate mode\n            if ((e.getModifiersEx() & MouseEvent.BUTTON1_DOWN_MASK) == 0)\n                return;\n\n        if (mode == Mode.move) {\n            setCursor(Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR));\n        }\n\n        if (!initialMoveThresholdExceeded) {\n            int dxp = mousePos.x - e.getX();\n            int dyp = mousePos.y - e.getY();\n            int dp = (int) Math.sqrt(dxp*dxp+dyp*dyp);\n            if (dp < initialMoveThreshold) return;\n            initialMoveThresholdExceeded = true;\n        }\n\n        EastNorth mouseEN = mv.getEastNorth(e.getX(), e.getY());\n        EastNorth mouseStartEN = mv.getEastNorth(mousePos.x, mousePos.y);\n        double dx = mouseEN.east() - mouseStartEN.east();\n        double dy = mouseEN.north() - mouseStartEN.north();\n        if (dx == 0 && dy == 0)\n            return;\n\n        if (virtualWays.size() > 0) {\n            Collection<Command> virtualCmds = new LinkedList<Command>();\n            virtualCmds.add(new AddCommand(virtualNode));\n            for (WaySegment virtualWay : virtualWays) {\n                Way w = virtualWay.way;\n                Way wnew = new Way(w);\n                wnew.addNode(virtualWay.lowerIndex+1, virtualNode);\n                virtualCmds.add(new ChangeCommand(w, wnew));\n            }\n            virtualCmds.add(new MoveCommand(virtualNode, dx, dy));\n            String text = trn(\"Add and move a virtual new node to way\",\n                    \"Add and move a virtual new node to {0} ways\", virtualWays.size(),\n                    virtualWays.size());\n            Main.main.undoRedo.add(new SequenceCommand(text, virtualCmds));\n            getCurrentDataSet().setSelected(Collections.singleton((OsmPrimitive)virtualNode));\n            virtualWays.clear();\n            virtualNode = null;\n        } else {\n            // Currently we support moving and rotating, which do not affect relations.\n            // So don't add them in the first place to make handling easier\n            Collection<OsmPrimitive> selection = getCurrentDataSet().getSelectedNodesAndWays();\n            Collection<Node> affectedNodes = AllNodesVisitor.getAllNodes(selection);\n\n            // when rotating, having only one node makes no sense - quit silently\n            if (mode == Mode.rotate && affectedNodes.size() < 2)\n                return;\n\n            Command c = !Main.main.undoRedo.commands.isEmpty()\n            ? Main.main.undoRedo.commands.getLast() : null;\n            if (c instanceof SequenceCommand) {\n                c = ((SequenceCommand)c).getLastCommand();\n            }\n\n            if (mode == Mode.move) {\n                if (c instanceof MoveCommand && affectedNodes.equals(((MoveCommand)c).getParticipatingPrimitives())) {\n                    ((MoveCommand)c).moveAgain(dx,dy);\n                } else {\n                    Main.main.undoRedo.add(\n                            c = new MoveCommand(selection, dx, dy));\n                }\n\n                for (Node n : affectedNodes) {\n                    if (n.getCoor().isOutSideWorld()) {\n                        // Revert move\n                        ((MoveCommand) c).moveAgain(-dx, -dy);\n\n                        JOptionPane.showMessageDialog(\n                                Main.parent,\n                                tr(\"Cannot move objects outside of the world.\"),\n                                tr(\"Warning\"),\n                                JOptionPane.WARNING_MESSAGE\n\n                        );\n                        restoreCursor();\n                        return;\n                    }\n                }\n            } else if (mode == Mode.rotate) {\n                if (c instanceof RotateCommand && affectedNodes.equals(((RotateCommand)c).getRotatedNodes())) {\n                    ((RotateCommand)c).rotateAgain(mouseStartEN, mouseEN);\n                } else {\n                    Main.main.undoRedo.add(new RotateCommand(selection, mouseStartEN, mouseEN));\n                }\n            }\n        }\n\n        mv.repaint();\n        mousePos = e.getPoint();\n\n        didMouseDrag = true;\n    }","id":99305,"modified_method":"/**\n     * If the left mouse button is pressed, move all currently selected\n     * objects (if one of them is under the mouse) or the current one under the\n     * mouse (which will become selected).\n     */\n    @Override\n    public void mouseDragged(MouseEvent e) {\n        if (!mv.isActiveLayerVisible())\n            return;\n\n        cancelDrawMode = true;\n        if (mode == Mode.select)\n            return;\n\n        // do not count anything as a move if it lasts less than 100 milliseconds.\n        if ((mode == Mode.move) && (System.currentTimeMillis() - mouseDownTime < initialMoveDelay))\n            return;\n\n        if (mode != Mode.rotate && mode != Mode.scale) // button is pressed in rotate mode\n        {\n            if ((e.getModifiersEx() & MouseEvent.BUTTON1_DOWN_MASK) == 0)\n                return;\n        }\n\n        if (mode == Mode.move) {\n            setCursor(Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR));\n        }\n\n        if (startingDraggingPos == null) {\n            startingDraggingPos = new Point(e.getX(), e.getY());\n        }\n\n        if (!initialMoveThresholdExceeded) {\n            int dxp = lastMousePos.x - e.getX();\n            int dyp = lastMousePos.y - e.getY();\n            int dp = (int) Math.sqrt(dxp * dxp + dyp * dyp);\n            if (dp < initialMoveThreshold)\n                return;\n            initialMoveThresholdExceeded = true;\n        }\n\n        EastNorth currentEN = mv.getEastNorth(e.getX(), e.getY());\n        EastNorth lastEN = mv.getEastNorth(lastMousePos.x, lastMousePos.y);\n        //EastNorth startEN = mv.getEastNorth(startingDraggingPos.x, startingDraggingPos.y);\n        double dx = currentEN.east() - lastEN.east();\n        double dy = currentEN.north() - lastEN.north();\n        if (dx == 0 && dy == 0)\n            return;\n\n        if (virtualWays.size() > 0) {\n            Collection<Command> virtualCmds = new LinkedList<Command>();\n            virtualCmds.add(new AddCommand(virtualNode));\n            for (WaySegment virtualWay : virtualWays) {\n                Way w = virtualWay.way;\n                Way wnew = new Way(w);\n                wnew.addNode(virtualWay.lowerIndex + 1, virtualNode);\n                virtualCmds.add(new ChangeCommand(w, wnew));\n            }\n            virtualCmds.add(new MoveCommand(virtualNode, dx, dy));\n            String text = trn(\"Add and move a virtual new node to way\",\n                    \"Add and move a virtual new node to {0} ways\", virtualWays.size(),\n                    virtualWays.size());\n            Main.main.undoRedo.add(new SequenceCommand(text, virtualCmds));\n            getCurrentDataSet().setSelected(Collections.singleton((OsmPrimitive) virtualNode));\n            virtualWays.clear();\n            virtualNode = null;\n        } else {\n            // Currently we support only transformations which do not affect relations.\n            // So don't add them in the first place to make handling easier\n            Collection<OsmPrimitive> selection = getCurrentDataSet().getSelectedNodesAndWays();\n            Collection<Node> affectedNodes = AllNodesVisitor.getAllNodes(selection);\n\n            // for these transformations, having only one node makes no sense - quit silently\n            if (affectedNodes.size() < 2 && (mode == Mode.rotate || mode == Mode.scale))\n                return;\n\n            Command c = !Main.main.undoRedo.commands.isEmpty()\n                    ? Main.main.undoRedo.commands.getLast() : null;\n            if (c instanceof SequenceCommand) {\n                c = ((SequenceCommand) c).getLastCommand();\n            }\n\n            if (mode == Mode.move) {\n                if (c instanceof MoveCommand && affectedNodes.equals(((MoveCommand) c).getParticipatingPrimitives())) {\n                    ((MoveCommand) c).moveAgain(dx, dy);\n                } else {\n                    Main.main.undoRedo.add(\n                            c = new MoveCommand(selection, dx, dy));\n                }\n\n                for (Node n : affectedNodes) {\n                    if (n.getCoor().isOutSideWorld()) {\n                        // Revert move\n                        ((MoveCommand) c).moveAgain(-dx, -dy);\n\n                        JOptionPane.showMessageDialog(\n                                Main.parent,\n                                tr(\"Cannot move objects outside of the world.\"),\n                                tr(\"Warning\"),\n                                JOptionPane.WARNING_MESSAGE);\n                        restoreCursor();\n                        return;\n                    }\n                }\n            } else if (mode == Mode.rotate) {\n                if (c instanceof RotateCommand && affectedNodes.equals(((RotateCommand) c).getTransformedNodes())) {\n                    ((RotateCommand) c).handleEvent(currentEN);\n                } else {\n                    Main.main.undoRedo.add(new RotateCommand(selection, currentEN));\n                }\n            } else if (mode == Mode.scale) {\n                if (c instanceof ScaleCommand && affectedNodes.equals(((ScaleCommand) c).getTransformedNodes())) {\n                    ((ScaleCommand) c).handleEvent(currentEN);\n                } else {\n                    Main.main.undoRedo.add(new ScaleCommand(selection, currentEN));\n                }\n            }\n        }\n\n        mv.repaint();\n        if (mode != Mode.scale) {\n            lastMousePos = e.getPoint();\n        }\n\n        didMouseDrag = true;\n    }","commit_id":"298d1b14231335bbf31077da580ade82a6160fb5","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override public void mouseMoved(MouseEvent e) {\n        // Mac OSX simulates with  ctrl + mouse 1  the second mouse button hence no dragging events get fired.\n        //\n        if ((Main.platform instanceof PlatformHookOsx) && mode == Mode.rotate) {\n            mouseDragged(e);\n        }\n    }","id":99306,"modified_method":"@Override\n    public void mouseMoved(MouseEvent e) {\n        // Mac OSX simulates with  ctrl + mouse 1  the second mouse button hence no dragging events get fired.\n        //\n        if ((Main.platform instanceof PlatformHookOsx) && (mode == Mode.rotate || mode == Mode.scale)) {\n            mouseDragged(e);\n        }\n    }","commit_id":"298d1b14231335bbf31077da580ade82a6160fb5","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override public String getModeHelpText() {\n        if (mode == Mode.select)\n            return tr(\"Release the mouse button to select the objects in the rectangle.\");\n        else if (mode == Mode.move)\n            return tr(\"Release the mouse button to stop moving. Ctrl to merge with nearest node.\");\n        else if (mode == Mode.rotate)\n            return tr(\"Release the mouse button to stop rotating.\");\n        else\n            return tr(\"Move objects by dragging; Shift to add to selection (Ctrl to toggle); Shift-Ctrl to rotate selected; or change selection\");\n    }","id":99307,"modified_method":"@Override\n    public String getModeHelpText() {\n        if (mode == Mode.select) {\n            return tr(\"Release the mouse button to select the objects in the rectangle.\");\n        } else if (mode == Mode.move) {\n            return tr(\"Release the mouse button to stop moving. Ctrl to merge with nearest node.\");\n        } else if (mode == Mode.rotate) {\n            return tr(\"Release the mouse button to stop rotating.\");\n        } else if (mode == Mode.scale) {\n            return tr(\"Release the mouse button to stop scaling.\");\n        } else {\n            return tr(\"Move objects by dragging; Shift to add to selection (Ctrl to toggle); Shift-Ctrl to rotate selected; Alt-Ctrl to scale selected; or change selection\");\n        }\n    }","commit_id":"298d1b14231335bbf31077da580ade82a6160fb5","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Create a new SelectAction\n     * @param mapFrame The MapFrame this action belongs to.\n     */\n    public SelectAction(MapFrame mapFrame) {\n        super(tr(\"Select\"), \"move/move\", tr(\"Select, move and rotate objects\"),\n                Shortcut.registerShortcut(\"mapmode:select\", tr(\"Mode: {0}\", tr(\"Select\")), KeyEvent.VK_S, Shortcut.GROUP_EDIT),\n                mapFrame,\n                getCursor(\"normal\", \"selection\", Cursor.DEFAULT_CURSOR));\n        mv = mapFrame.mapView;\n        putValue(\"help\", \"Action/Move/Move\");\n        selectionManager = new SelectionManager(this, false, mv);\n        initialMoveDelay = Main.pref.getInteger(\"edit.initial-move-delay\",200);\n        initialMoveThreshold = Main.pref.getInteger(\"edit.initial-move-threshold\",5);\n    }","id":99308,"modified_method":"/**\n     * Create a new SelectAction\n     * @param mapFrame The MapFrame this action belongs to.\n     */\n    public SelectAction(MapFrame mapFrame) {\n        super(tr(\"Select\"), \"move/move\", tr(\"Select, move, scale and rotate objects\"),\n                Shortcut.registerShortcut(\"mapmode:select\", tr(\"Mode: {0}\", tr(\"Select\")), KeyEvent.VK_S, Shortcut.GROUP_EDIT),\n                mapFrame,\n                getCursor(\"normal\", \"selection\", Cursor.DEFAULT_CURSOR));\n        mv = mapFrame.mapView;\n        putValue(\"help\", \"Action/Move/Move\");\n        selectionManager = new SelectionManager(this, false, mv);\n        initialMoveDelay = Main.pref.getInteger(\"edit.initial-move-delay\", 200);\n        initialMoveThreshold = Main.pref.getInteger(\"edit.initial-move-threshold\", 5);\n    }","commit_id":"298d1b14231335bbf31077da580ade82a6160fb5","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Look, whether any object is selected. If not, select the nearest node.\n     * If there are no nodes in the dataset, do nothing.\n     *\n     * If the user did not press the left mouse button, do nothing.\n     *\n     * Also remember the starting position of the movement and change the mouse\n     * cursor to movement.\n     */\n    @Override public void mousePressed(MouseEvent e) {\n        debug(\"mousePressed: e.getPoint()=\" + e.getPoint());\n\n        // return early\n        if(!mv.isActiveLayerVisible()\n                || !(Boolean)this.getValue(\"active\")\n                || e.getButton() != MouseEvent.BUTTON1)\n            return;\n\n        // request focus in order to enable the expected keyboard shortcuts\n        mv.requestFocus();\n\n        boolean ctrl = (e.getModifiers() & ActionEvent.CTRL_MASK) != 0;\n        boolean shift = (e.getModifiers() & ActionEvent.SHIFT_MASK) != 0;\n\n        // We don't want to change to draw tool if the user tries to (de)select\n        // stuff but accidentally clicks in an empty area when selection is empty\n        cancelDrawMode = (shift || ctrl);\n        didMouseDrag = false;\n        initialMoveThresholdExceeded = false;\n        mouseDownTime = System.currentTimeMillis();\n        mousePos = e.getPoint();\n\n        Collection<OsmPrimitive> c = MapView.asColl(\n                mv.getNearestNodeOrWay(e.getPoint(), OsmPrimitive.isSelectablePredicate, false));\n\n        if (shift && ctrl) {\n            mode = Mode.rotate;\n\n            if (getCurrentDataSet().getSelected().isEmpty()) {\n                getCurrentDataSet().setSelected(c);\n            }\n\n            // Mode.select redraws when selectPrims is called\n            // Mode.move   redraws when mouseDragged is called\n            // Mode.rotate redraws here\n            setCursor(ImageProvider.getCursor(\"rotate\", null));\n            mv.repaint();\n        } else if (!c.isEmpty()) {\n            mode = Mode.move;\n\n            if (!cancelDrawMode && c.iterator().next() instanceof Way) {\n                setupVirtual(e);\n            }\n\n            selectPrims(cycleSetup(c, e), e, false, false);\n        } else {\n            mode = Mode.select;\n\n            oldCursor = mv.getCursor();\n            selectionManager.register(mv);\n            selectionManager.mousePressed(e);\n        }\n\n        updateStatusLine();\n    }","id":99309,"modified_method":"/**\n     * Look, whether any object is selected. If not, select the nearest node.\n     * If there are no nodes in the dataset, do nothing.\n     *\n     * If the user did not press the left mouse button, do nothing.\n     *\n     * Also remember the starting position of the movement and change the mouse\n     * cursor to movement.\n     */\n    @Override\n    public void mousePressed(MouseEvent e) {\n        debug(\"mousePressed: e.getPoint()=\" + e.getPoint());\n\n        // return early\n        if (!mv.isActiveLayerVisible() || !(Boolean) this.getValue(\"active\") || e.getButton() != MouseEvent.BUTTON1) {\n            return;\n        }\n\n        // request focus in order to enable the expected keyboard shortcuts\n        mv.requestFocus();\n\n        boolean ctrl = (e.getModifiers() & ActionEvent.CTRL_MASK) != 0;\n        boolean shift = (e.getModifiers() & ActionEvent.SHIFT_MASK) != 0;\n        boolean alt = (e.getModifiers() & ActionEvent.ALT_MASK) != 0;\n\n        // We don't want to change to draw tool if the user tries to (de)select\n        // stuff but accidentally clicks in an empty area when selection is empty\n        cancelDrawMode = (shift || ctrl);\n        didMouseDrag = false;\n        initialMoveThresholdExceeded = false;\n        mouseDownTime = System.currentTimeMillis();\n        lastMousePos = e.getPoint();\n\n        Collection<OsmPrimitive> c = MapView.asColl(\n                mv.getNearestNodeOrWay(e.getPoint(), OsmPrimitive.isSelectablePredicate, false));\n\n        if (shift && ctrl) {\n            mode = Mode.rotate;\n\n            if (getCurrentDataSet().getSelected().isEmpty()) {\n                getCurrentDataSet().setSelected(c);\n            }\n\n            // Mode.select redraws when selectPrims is called\n            // Mode.move   redraws when mouseDragged is called\n            // Mode.rotate redraws here\n            setCursor(ImageProvider.getCursor(\"rotate\", null));\n            mv.repaint();\n        } else if (alt && ctrl) {\n            mode = Mode.scale;\n\n            if (getCurrentDataSet().getSelected().isEmpty()) {\n                getCurrentDataSet().setSelected(c);\n            }\n\n            // Mode.select redraws when selectPrims is called\n            // Mode.move   redraws when mouseDragged is called\n            // Mode.scale redraws here\n            setCursor(ImageProvider.getCursor(\"scale\", null));\n            mv.repaint();\n        } else if (!c.isEmpty()) {\n            mode = Mode.move;\n\n            if (!cancelDrawMode && c.iterator().next() instanceof Way) {\n                setupVirtual(e);\n            }\n\n            selectPrims(cycleSetup(c, e), e, false, false);\n        } else {\n            mode = Mode.select;\n\n            oldCursor = mv.getCursor();\n            selectionManager.register(mv);\n            selectionManager.mousePressed(e);\n        }\n\n        updateStatusLine();\n    }","commit_id":"298d1b14231335bbf31077da580ade82a6160fb5","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Finds the intersection of two lines of infinite length.\n     * @return EastNorth null if no intersection was found, the coordinates of the intersection otherwise\n     * @throws IllegalArgumentException if a parameter is null or without valid coordinates\n     */\n    public static EastNorth getLineLineIntersection(EastNorth p1, EastNorth p2, EastNorth p3, EastNorth p4) {\n\n        CheckParameterUtil.ensureValidCoordinates(p1, \"p1\");\n        CheckParameterUtil.ensureValidCoordinates(p2, \"p2\");\n        CheckParameterUtil.ensureValidCoordinates(p3, \"p3\");\n        CheckParameterUtil.ensureValidCoordinates(p4, \"p4\");\n\n        if (!p1.isValid()) throw new IllegalArgumentException();\n\n        // Convert line from (point, point) form to ax+by=c\n        double a1 = p2.getY() - p1.getY();\n        double b1 = p1.getX() - p2.getX();\n        double c1 = p2.getX() * p1.getY() - p1.getX() * p2.getY();\n\n        double a2 = p4.getY() - p3.getY();\n        double b2 = p3.getX() - p4.getX();\n        double c2 = p4.getX() * p3.getY() - p3.getX() * p4.getY();\n\n        // Solve the equations\n        double det = a1 * b2 - a2 * b1;\n        if (det == 0)\n            return null; // Lines are parallel\n\n        return new EastNorth((b1 * c2 - b2 * c1) / det, (a2 * c1 - a1 * c2) / det);\n    }","id":99310,"modified_method":"/**\n     * Finds the intersection of two lines of infinite length.\n     * \n     * @param p1 first point on first line\n     * @param p2 second point on first line\n     * @param p3 first point on second line\n     * @param p4 second point on second line\n     * @return EastNorth null if no intersection was found, the coordinates of the intersection otherwise\n     * @throws IllegalArgumentException if a parameter is null or without valid coordinates\n     */\n    public static EastNorth getLineLineIntersection(EastNorth p1, EastNorth p2, EastNorth p3, EastNorth p4) {\n\n        CheckParameterUtil.ensureValidCoordinates(p1, \"p1\");\n        CheckParameterUtil.ensureValidCoordinates(p2, \"p2\");\n        CheckParameterUtil.ensureValidCoordinates(p3, \"p3\");\n        CheckParameterUtil.ensureValidCoordinates(p4, \"p4\");\n        \n        if (!p1.isValid()) throw new IllegalArgumentException();\n\n        // Basically, the formula from wikipedia is used:\n        //  https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection\n        // However, large numbers lead to rounding errors (see #10286).\n        // To avoid this, p1 is first substracted from each of the points:\n        //  p1' = 0\n        //  p2' = p2 - p1\n        //  p3' = p3 - p1\n        //  p4' = p4 - p1\n        // In the end, p1 is added to the intersection point of segment p1'/p2'\n        // and segment p3'/p4'.\n\n        // Convert line from (point, point) form to ax+by=c\n        double a1 = p2.getY() - p1.getY();\n        double b1 = p1.getX() - p2.getX();\n        // double c1 = 0;\n\n        double a2 = p4.getY() - p3.getY();\n        double b2 = p3.getX() - p4.getX();\n        double c2 = (p4.getX() - p1.getX()) * (p3.getY() - p1.getY()) - (p3.getX() - p1.getX()) * (p4.getY() - p1.getY());\n\n        // Solve the equations\n        double det = a1 * b2 - a2 * b1;\n        if (det == 0)\n            return null; // Lines are parallel\n\n        return new EastNorth(b1 * c2 / det + p1.getX(),  - a1 * c2 / det + p1.getY());\n    }","commit_id":"74d0f95f898e4978b0a5fe3e41c0b84f1540f0d3","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void execute(Collection<Change> changes, String commitMessage) {\n      if (! myPanel.isOkToExecute()) {\n        WaitForProgressToShow.runOrInvokeLaterAboveProgress(new Runnable() {\n          @Override\n          public void run() {\n            Messages\n              .showErrorDialog(myProject, VcsBundle.message(\"create.patch.error.title\", myPanel.getError()), CommonBundle.getErrorTitle());\n          }\n        }, ModalityState.NON_MODAL, myProject);\n        return;\n      }\n      final String fileName = myPanel.getFileName();\n      final File file = new File(fileName).getAbsoluteFile();\n      if (file.exists()) {\n        final int[] result = new int[1];\n        WaitForProgressToShow.runOrInvokeAndWaitAboveProgress(new Runnable() {\n          @Override\n          public void run() {\n            result[0] = Messages.showYesNoDialog(myProject, \"File \" + file.getName() + \" (\" + file.getParent() + \")\" +\n                                                            \" already exists.\\nDo you want to overwrite it?\",\n                                                 CommonBundle.getWarningTitle(), Messages.getWarningIcon());\n          }\n        });\n        if (Messages.NO == result[0]) return;\n      }\n      if (file.getParentFile() == null) {\n        WaitForProgressToShow.runOrInvokeLaterAboveProgress(new Runnable() {\n          @Override\n          public void run() {\n            Messages.showErrorDialog(myProject, VcsBundle.message(\"create.patch.error.title\", \"Can not write patch to specified file: \" +\n                                                                                              file.getPath()), CommonBundle.getErrorTitle());\n          }\n        }, ModalityState.NON_MODAL, myProject);\n        return;\n      }\n      myPanel.onOk();\n      myCommitContext.putUserData(BaseRevisionTextPatchEP.ourPutBaseRevisionTextKey, myPanel.isStoreTexts());\n      final List<FilePath> list = new ArrayList<FilePath>();\n      for (Change change : myPanel.getIncludedChanges()) {\n        list.add(ChangesUtil.getFilePath(change));\n      }\n      myCommitContext.putUserData(BaseRevisionTextPatchEP.ourBaseRevisionPaths, list);\n\n      int binaryCount = 0;\n      for(Change change: changes) {\n        if (ChangesUtil.isBinaryChange(change)) {\n          binaryCount++;\n        }\n      }\n      if (binaryCount == changes.size()) {\n        WaitForProgressToShow.runOrInvokeLaterAboveProgress(new Runnable() {\n          public void run() {\n            Messages.showInfoMessage(myProject, VcsBundle.message(\"create.patch.all.binary\"),\n                                     VcsBundle.message(\"create.patch.commit.action.title\"));\n          }\n        }, null, myProject);\n        return;\n      }\n      try {\n        file.getParentFile().mkdirs();\n        VcsConfiguration.getInstance(myProject).acceptLastCreatedPatchName(file.getName());\n        PATCH_PATH = file.getParent();\n        VcsApplicationSettings.getInstance().PATCH_STORAGE_LOCATION = PATCH_PATH;\n        final boolean reversePatch = myPanel.isReversePatch();\n\n        List<FilePatch> patches = IdeaTextPatchBuilder.buildPatch(myProject, changes, myProject.getBaseDir().getPresentableUrl(), reversePatch);\n        PatchWriter.writePatches(myProject, fileName, patches, myCommitContext, myPanel.getEncoding());\n        final String message;\n        if (binaryCount == 0) {\n          message = VcsBundle.message(\"create.patch.success.confirmation\", file.getPath());\n        }\n        else {\n          message = VcsBundle.message(\"create.patch.partial.success.confirmation\", file.getPath(),\n                                      binaryCount);\n        }\n        WaitForProgressToShow.runOrInvokeLaterAboveProgress(new Runnable() {\n          public void run() {\n            final VcsConfiguration configuration = VcsConfiguration.getInstance(myProject);\n            if (Boolean.TRUE.equals(configuration.SHOW_PATCH_IN_EXPLORER)) {\n              ShowFilePathAction.openFile(file);\n            } else if (Boolean.FALSE.equals(configuration.SHOW_PATCH_IN_EXPLORER)) {\n              return;\n            } else {\n              configuration.SHOW_PATCH_IN_EXPLORER =\n                ShowFilePathAction.showDialog(myProject, message, VcsBundle.message(\"create.patch.commit.action.title\"), file);\n            }\n          }\n        }, null, myProject);\n      } catch (ProcessCanceledException e) {\n        //\n      } catch (final Exception ex) {\n        LOG.info(ex);\n        WaitForProgressToShow.runOrInvokeLaterAboveProgress(new Runnable() {\n          public void run() {\n            Messages.showErrorDialog(myProject, VcsBundle.message(\"create.patch.error.title\", ex.getMessage()),\n                                     CommonBundle.getErrorTitle());\n          }\n        }, null, myProject);\n      }\n    }","id":99311,"modified_method":"public void execute(Collection<Change> changes, String commitMessage) {\n      if (! myPanel.isOkToExecute()) {\n        WaitForProgressToShow.runOrInvokeLaterAboveProgress(new Runnable() {\n          @Override\n          public void run() {\n            Messages\n              .showErrorDialog(myProject, VcsBundle.message(\"create.patch.error.title\", myPanel.getError()), CommonBundle.getErrorTitle());\n          }\n        }, ModalityState.NON_MODAL, myProject);\n        return;\n      }\n      final String fileName = myPanel.getFileName();\n      final File file = new File(fileName).getAbsoluteFile();\n      if (file.exists()) {\n        final int[] result = new int[1];\n        WaitForProgressToShow.runOrInvokeAndWaitAboveProgress(new Runnable() {\n          @Override\n          public void run() {\n            result[0] = Messages.showYesNoDialog(myProject, \"File \" + file.getName() + \" (\" + file.getParent() + \")\" +\n                                                            \" already exists.\\nDo you want to overwrite it?\",\n                                                 CommonBundle.getWarningTitle(), Messages.getWarningIcon());\n          }\n        });\n        if (Messages.NO == result[0]) return;\n      }\n      if (file.getParentFile() == null) {\n        WaitForProgressToShow.runOrInvokeLaterAboveProgress(new Runnable() {\n          @Override\n          public void run() {\n            Messages.showErrorDialog(myProject, VcsBundle.message(\"create.patch.error.title\", \"Can not write patch to specified file: \" +\n                                                                                              file.getPath()), CommonBundle.getErrorTitle());\n          }\n        }, ModalityState.NON_MODAL, myProject);\n        return;\n      }\n      myPanel.onOk();\n      boolean storeTexts = myPanel.isStoreTexts();\n      myCommitContext.putUserData(BaseRevisionTextPatchEP.ourPutBaseRevisionTextKey, storeTexts);\n      if (storeTexts) {\n        final List<FilePath> list = ContainerUtil.map(myPanel.getIncludedChanges(), ChangesUtil::getFilePath);\n        myCommitContext.putUserData(BaseRevisionTextPatchEP.ourBaseRevisionPaths, list);\n      }\n\n      int binaryCount = 0;\n      for(Change change: changes) {\n        if (ChangesUtil.isBinaryChange(change)) {\n          binaryCount++;\n        }\n      }\n      if (binaryCount == changes.size()) {\n        WaitForProgressToShow.runOrInvokeLaterAboveProgress(new Runnable() {\n          public void run() {\n            Messages.showInfoMessage(myProject, VcsBundle.message(\"create.patch.all.binary\"),\n                                     VcsBundle.message(\"create.patch.commit.action.title\"));\n          }\n        }, null, myProject);\n        return;\n      }\n      try {\n        file.getParentFile().mkdirs();\n        VcsConfiguration.getInstance(myProject).acceptLastCreatedPatchName(file.getName());\n        PATCH_PATH = file.getParent();\n        VcsApplicationSettings.getInstance().PATCH_STORAGE_LOCATION = PATCH_PATH;\n        final boolean reversePatch = myPanel.isReversePatch();\n\n        List<FilePatch> patches = IdeaTextPatchBuilder.buildPatch(myProject, changes, myProject.getBaseDir().getPresentableUrl(), reversePatch);\n        PatchWriter.writePatches(myProject, fileName, patches, myCommitContext, myPanel.getEncoding());\n        final String message;\n        if (binaryCount == 0) {\n          message = VcsBundle.message(\"create.patch.success.confirmation\", file.getPath());\n        }\n        else {\n          message = VcsBundle.message(\"create.patch.partial.success.confirmation\", file.getPath(),\n                                      binaryCount);\n        }\n        WaitForProgressToShow.runOrInvokeLaterAboveProgress(new Runnable() {\n          public void run() {\n            final VcsConfiguration configuration = VcsConfiguration.getInstance(myProject);\n            if (Boolean.TRUE.equals(configuration.SHOW_PATCH_IN_EXPLORER)) {\n              ShowFilePathAction.openFile(file);\n            } else if (Boolean.FALSE.equals(configuration.SHOW_PATCH_IN_EXPLORER)) {\n              return;\n            } else {\n              configuration.SHOW_PATCH_IN_EXPLORER =\n                ShowFilePathAction.showDialog(myProject, message, VcsBundle.message(\"create.patch.commit.action.title\"), file);\n            }\n          }\n        }, null, myProject);\n      } catch (ProcessCanceledException e) {\n        //\n      } catch (final Exception ex) {\n        LOG.info(ex);\n        WaitForProgressToShow.runOrInvokeLaterAboveProgress(new Runnable() {\n          public void run() {\n            Messages.showErrorDialog(myProject, VcsBundle.message(\"create.patch.error.title\", ex.getMessage()),\n                                     CommonBundle.getErrorTitle());\n          }\n        }, null, myProject);\n      }\n    }","commit_id":"09bfa3d62bb9417a709cfecf69a213cf2030393f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Set<Change> getBig(List<Change> changes) {\n    final Set<Change> exclude = new HashSet<Change>();\n    for (Change change : changes) {\n      ContentRevision beforeRevision = change.getBeforeRevision();\n      if (beforeRevision != null) {\n        try {\n          String content = beforeRevision.getContent();\n          if (content == null) {\n            final FilePath file = beforeRevision.getFile();\n            LOG.info(\"null content for \" + (file.getPath()) + \", is dir: \" + (file.isDirectory()));\n            continue;\n          }\n          if (content.length() > VcsConfiguration.ourMaximumFileForBaseRevisionSize) {\n            exclude.add(change);\n          }\n        }\n        catch (VcsException e) {\n          LOG.info(e);\n        }\n      }\n    }\n    return exclude;\n  }","id":99312,"modified_method":"public static Set<Change> getBig(List<Change> changes) {\n    final Set<Change> exclude = new HashSet<Change>();\n    for (Change change : changes) {\n      // try to estimate size via VF: we assume that base content hasn't been changed much\n      VirtualFile virtualFile = getVfFromChange(change);\n      if (virtualFile != null) {\n        if (isBig(virtualFile)) {\n          exclude.add(change);\n        }\n        continue;\n      }\n      // otherwise, to avoid regression we have to process context length\n      ContentRevision beforeRevision = change.getBeforeRevision();\n      if (beforeRevision != null) {\n        try {\n          String content = beforeRevision.getContent();\n          if (content == null) {\n            final FilePath file = beforeRevision.getFile();\n            LOG.info(\"null content for \" + (file.getPath()) + \", is dir: \" + (file.isDirectory()));\n            continue;\n          }\n          if (content.length() > VcsConfiguration.ourMaximumFileForBaseRevisionSize) {\n            exclude.add(change);\n          }\n        }\n        catch (VcsException e) {\n          LOG.info(e);\n        }\n      }\n    }\n    return exclude;\n  }","commit_id":"09bfa3d62bb9417a709cfecf69a213cf2030393f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void setIcon(AbstractFile file) {\n        // set name, display name, and icon\n        if (file.isDirNameFlagSet(TSK_FS_NAME_FLAG_ENUM.UNALLOC)) {\n            this.setIconBaseWithExtension(\"org/sleuthkit/autopsy/images/file-icon-deleted.png\");\n        } else {\n            this.setIconBaseWithExtension(getIconForFileType(file));\n        }\n    }","id":99313,"modified_method":"private void setIcon(AbstractFile file) {\n        // set name, display name, and icon\n        if (file.isDirNameFlagSet(TSK_FS_NAME_FLAG_ENUM.UNALLOC)) {\n            if (file.getType().equals(TSK_DB_FILES_TYPE_ENUM.CARVED)) {\n                this.setIconBaseWithExtension(\"org/sleuthkit/autopsy/images/carved-file-icon-16.png\");\n            } else {\n                this.setIconBaseWithExtension(\"org/sleuthkit/autopsy/images/file-icon-deleted.png\");\n            }\n        } else {\n            this.setIconBaseWithExtension(getIconForFileType(file));\n        }\n    }","commit_id":"360b1c020e6a35e6c2156aba3ad4f3f7581cfa50","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public LayoutFileNode(LayoutFile lf) {\n        super(lf);\n\n        this.setDisplayName(nameForLayoutFile(lf));\n        this.setIconBaseWithExtension(\"org/sleuthkit/autopsy/images/file-icon-deleted.png\");\n    }","id":99314,"modified_method":"public LayoutFileNode(LayoutFile lf) {\n        super(lf);\n\n        this.setDisplayName(nameForLayoutFile(lf));\n\n        if (lf.getType().equals(TskData.TSK_DB_FILES_TYPE_ENUM.CARVED)) {\n            this.setIconBaseWithExtension(\"org/sleuthkit/autopsy/images/carved-file-icon-16.png\");\n        } else {\n            this.setIconBaseWithExtension(\"org/sleuthkit/autopsy/images/file-icon-deleted.png\");\n        }\n    }","commit_id":"360b1c020e6a35e6c2156aba3ad4f3f7581cfa50","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public static TimeZone getTimeZone(Content c) {\n        try {\n            return TimeZone.getTimeZone(c.getImage().getTimeZone());\n        } catch (TskException ex) {\n            return TimeZone.getDefault();\n        }\n    }","id":99315,"modified_method":"public static TimeZone getTimeZone(Content c) {\n        try {\n            final Image image = c.getImage();\n            if (image != null) {\n                return TimeZone.getTimeZone(image.getTimeZone());\n            }\n            else {\n                //case such as top level VirtualDirectory\n                return TimeZone.getDefault();\n            }\n        } catch (TskException ex) {\n            return TimeZone.getDefault();\n        }\n    }","commit_id":"1af6c363fd05f589b6e18111891b0cd802ef7fd7","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public VirtualDirectoryNode(VirtualDirectory ld) {\n        super(ld);\n\n        this.setDisplayName(nameForLayoutFile(ld));\n        this.setIconBaseWithExtension(\"org/sleuthkit/autopsy/images/folder-icon-deleted.png\");\n    }","id":99316,"modified_method":"public VirtualDirectoryNode(VirtualDirectory ld) {\n        super(ld);\n\n        this.setDisplayName(nameForLayoutFile(ld));\n        \n        String name = ld.getName();\n        \n        //set icon for name, special case for some built-ins\n        if (name.equals(VirtualDirectory.NAME_UNALLOC)) {\n            this.setIconBaseWithExtension(\"org/sleuthkit/autopsy/images/folder-icon-deleted.png\");\n        }\n        else if (name.equals(VirtualDirectory.NAME_LOCAL)) {\n            this.setIconBaseWithExtension(\"org/sleuthkit/autopsy/images/folder-local-icon-16.png\");\n        }\n        else if (name.equals(VirtualDirectory.NAME_CARVED)) {\n            this.setIconBaseWithExtension(\"org/sleuthkit/autopsy/images/Folder-icon.png\"); //TODO\n        }\n        else {\n            this.setIconBaseWithExtension(\"org/sleuthkit/autopsy/images/Folder-icon.png\");\n        }\n        \n    }","commit_id":"1af6c363fd05f589b6e18111891b0cd802ef7fd7","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public JMenuItem getPopupPresenter() {\n        JMenu result = new JMenu(\"Tag File\");\n\n        JMenuItem contentItem = new JMenuItem(\"Bookmark File\");\n        contentItem.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                final TagDialog tagDialog = new TagDialog(TagDialog.Type.BOOKMARK, \"Bookmark File\", null, \"Bookmark\", false);\n                tagDialog.setVisible(true);\n                TagDialogResult inputResult = tagDialog.getResult();\n                if (inputResult.isAccept()) {\n                    Tags.createBookmark(tagFile, inputResult.getComment());\n                    refreshDirectoryTree();\n                }\n            }\n        });\n        result.add(contentItem);\n        result.addSeparator();\n\n        JMenuItem newTagItem = new JMenuItem(\"Create a new tag\");\n        newTagItem.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                String newTagName = new CreateTagDialog(new JFrame(), true).display();\n                if (newTagName != null) {\n                    //get comment\n                    final TagDialog tagDialog = new TagDialog(TagDialog.Type.TAG, \"Tag File\", null, newTagName, false);\n                    tagDialog.setVisible(true);\n                    TagDialogResult inputResult = tagDialog.getResult();\n                    if (inputResult.isAccept()) {\n                        Tags.createTag(tagFile, newTagName, inputResult.getComment());\n                        refreshDirectoryTree();\n                    }\n                }\n            }\n        });\n        result.add(newTagItem);\n        result.addSeparator();\n\n        final List<String> tagNames = Tags.getTagNames();\n        if (tagNames.isEmpty()) {\n            JMenuItem empty = new JMenuItem(\"No tags\");\n            empty.setEnabled(false);\n            result.add(empty);\n        } else {\n            for (final String tagName : tagNames) {\n                if (tagName.equals(Bookmarks.BOOKMARK_TAG_NAME)) {\n                    continue;\n                }\n                JMenuItem tagItem = new JMenuItem(tagName);\n                tagItem.addActionListener(new ActionListener() {\n                    @Override\n                    public void actionPerformed(ActionEvent e) {\n                        final TagDialog tagDialog = new TagDialog(TagDialog.Type.TAG, \"Tag File\", tagNames, tagName, true);\n                        tagDialog.setVisible(true);\n                        TagDialogResult inputResult = tagDialog.getResult();\n                        if (inputResult.isAccept()) {\n                            Tags.createTag(tagFile, inputResult.getSelectedTag(), inputResult.getComment());\n                            refreshDirectoryTree();\n                        }\n\n\n                    }\n                });\n                result.add(tagItem);\n            }\n        }\n\n        return result;\n    }","id":99317,"modified_method":"@Override\n    public JMenuItem getPopupPresenter() {\n        JMenu result = new JMenu(\"Tag Source File\");\n\n        JMenuItem contentItem = new JMenuItem(\"Bookmark Source File\");\n        contentItem.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                final TagDialog tagDialog = new TagDialog(TagDialog.Type.BOOKMARK, \"Bookmark Source File\", null, \"Bookmark\", false);\n                tagDialog.setVisible(true);\n                TagDialogResult inputResult = tagDialog.getResult();\n                if (inputResult.isAccept()) {\n                    Tags.createBookmark(tagFile, inputResult.getComment());\n                    refreshDirectoryTree();\n                }\n            }\n        });\n        result.add(contentItem);\n        result.addSeparator();\n\n        JMenuItem newTagItem = new JMenuItem(\"Create a new tag\");\n        newTagItem.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                String newTagName = new CreateTagDialog(new JFrame(), true).display();\n                if (newTagName != null) {\n                    //get comment\n                    final TagDialog tagDialog = new TagDialog(TagDialog.Type.TAG, \"Tag Source File\", null, newTagName, false);\n                    tagDialog.setVisible(true);\n                    TagDialogResult inputResult = tagDialog.getResult();\n                    if (inputResult.isAccept()) {\n                        Tags.createTag(tagFile, newTagName, inputResult.getComment());\n                        refreshDirectoryTree();\n                    }\n                }\n            }\n        });\n        result.add(newTagItem);\n        result.addSeparator();\n\n        final List<String> tagNames = Tags.getTagNames();\n        if (tagNames.isEmpty()) {\n            JMenuItem empty = new JMenuItem(\"No tags\");\n            empty.setEnabled(false);\n            result.add(empty);\n        } else {\n            for (final String tagName : tagNames) {\n                if (tagName.equals(Bookmarks.BOOKMARK_TAG_NAME)) {\n                    continue;\n                }\n                JMenuItem tagItem = new JMenuItem(tagName);\n                tagItem.addActionListener(new ActionListener() {\n                    @Override\n                    public void actionPerformed(ActionEvent e) {\n                        final TagDialog tagDialog = new TagDialog(TagDialog.Type.TAG, \"Tag Source File\", tagNames, tagName, true);\n                        tagDialog.setVisible(true);\n                        TagDialogResult inputResult = tagDialog.getResult();\n                        if (inputResult.isAccept()) {\n                            Tags.createTag(tagFile, inputResult.getSelectedTag(), inputResult.getComment());\n                            refreshDirectoryTree();\n                        }\n\n\n                    }\n                });\n                result.add(tagItem);\n            }\n        }\n\n        return result;\n    }","commit_id":"270c30ed3a930d8bb42d6df872db6bc26b88980c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public JMenuItem getPopupPresenter() {\n        JMenu result = new JMenu(\"Tag Result\");\n\n        JMenuItem contentItem = new JMenuItem(\"Bookmark Result\");\n        contentItem.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                final TagDialog tagDialog = new TagDialog(TagDialog.Type.BOOKMARK, \"Bookmark Result\", null, \"Bookmark\", false);\n                tagDialog.setVisible(true);\n                TagDialog.TagDialogResult inputResult = tagDialog.getResult();\n                if (inputResult.isAccept()) {\n                    Tags.createBookmark(tagArtifact, inputResult.getComment());\n                    refreshDirectoryTree();\n                }\n            }\n        });\n        result.add(contentItem);\n        result.addSeparator();\n\n        JMenuItem newTagItem = new JMenuItem(\"Create a new tag\");\n        newTagItem.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                String newTagName = new CreateTagDialog(new JFrame(), true).display();\n                if (newTagName != null) {\n                    //get comment and create tag\n                    final TagDialog tagDialog = new TagDialog(TagDialog.Type.TAG, \"Tag Result\", null, newTagName, false);\n                    tagDialog.setVisible(true);\n                    TagDialog.TagDialogResult inputResult = tagDialog.getResult();\n                    if (inputResult.isAccept()) {\n                        Tags.createTag(tagArtifact, newTagName, inputResult.getComment());\n                        refreshDirectoryTree();\n                    }\n\n                }\n            }\n        });\n        result.add(newTagItem);\n        result.addSeparator();\n\n        final List<String> tagNames = Tags.getTagNames();\n        if (tagNames.isEmpty()) {\n            JMenuItem empty = new JMenuItem(\"No tags\");\n            empty.setEnabled(false);\n            result.add(empty);\n        } else {\n            for (final String tagName : tagNames) {\n                if (tagName.equals(Bookmarks.BOOKMARK_TAG_NAME)) {\n                    continue;\n                }\n                JMenuItem tagItem = new JMenuItem(tagName);\n                tagItem.addActionListener(new ActionListener() {\n                    @Override\n                    public void actionPerformed(ActionEvent e) {\n                        final TagDialog tagDialog = new TagDialog(TagDialog.Type.TAG, \"Tag Result\", tagNames, tagName, true);\n                        tagDialog.setVisible(true);\n                        TagDialog.TagDialogResult inputResult = tagDialog.getResult();\n                        if (inputResult.isAccept()) {\n                            Tags.createTag(tagArtifact, inputResult.getSelectedTag(), inputResult.getComment());\n                            refreshDirectoryTree();\n                        }\n\n                    }\n                });\n                result.add(tagItem);\n            }\n        }\n\n        return result;\n    }","id":99318,"modified_method":"@Override\n    public JMenuItem getPopupPresenter() {\n        JMenu result = new JMenu(\"Tag Source Result\");\n\n        JMenuItem contentItem = new JMenuItem(\"Bookmark Source Result\");\n        contentItem.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                final TagDialog tagDialog = new TagDialog(TagDialog.Type.BOOKMARK, \"Bookmark Source Result\", null, \"Bookmark\", false);\n                tagDialog.setVisible(true);\n                TagDialog.TagDialogResult inputResult = tagDialog.getResult();\n                if (inputResult.isAccept()) {\n                    Tags.createBookmark(tagArtifact, inputResult.getComment());\n                    refreshDirectoryTree();\n                }\n            }\n        });\n        result.add(contentItem);\n        result.addSeparator();\n\n        JMenuItem newTagItem = new JMenuItem(\"Create a new tag\");\n        newTagItem.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                String newTagName = new CreateTagDialog(new JFrame(), true).display();\n                if (newTagName != null) {\n                    //get comment and create tag\n                    final TagDialog tagDialog = new TagDialog(TagDialog.Type.TAG, \"Tag Source Result\", null, newTagName, false);\n                    tagDialog.setVisible(true);\n                    TagDialog.TagDialogResult inputResult = tagDialog.getResult();\n                    if (inputResult.isAccept()) {\n                        Tags.createTag(tagArtifact, newTagName, inputResult.getComment());\n                        refreshDirectoryTree();\n                    }\n\n                }\n            }\n        });\n        result.add(newTagItem);\n        result.addSeparator();\n\n        final List<String> tagNames = Tags.getTagNames();\n        if (tagNames.isEmpty()) {\n            JMenuItem empty = new JMenuItem(\"No tags\");\n            empty.setEnabled(false);\n            result.add(empty);\n        } else {\n            for (final String tagName : tagNames) {\n                if (tagName.equals(Bookmarks.BOOKMARK_TAG_NAME)) {\n                    continue;\n                }\n                JMenuItem tagItem = new JMenuItem(tagName);\n                tagItem.addActionListener(new ActionListener() {\n                    @Override\n                    public void actionPerformed(ActionEvent e) {\n                        final TagDialog tagDialog = new TagDialog(TagDialog.Type.TAG, \"Tag Source Result\", tagNames, tagName, true);\n                        tagDialog.setVisible(true);\n                        TagDialog.TagDialogResult inputResult = tagDialog.getResult();\n                        if (inputResult.isAccept()) {\n                            Tags.createTag(tagArtifact, inputResult.getSelectedTag(), inputResult.getComment());\n                            refreshDirectoryTree();\n                        }\n\n                    }\n                });\n                result.add(tagItem);\n            }\n        }\n\n        return result;\n    }","commit_id":"270c30ed3a930d8bb42d6df872db6bc26b88980c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"TagNodeRoot(BlackboardArtifact.ARTIFACT_TYPE tagType, String tagName, List<BlackboardArtifact> artifacts) {\n            super(Children.create(new Tags.TagsChildrenNode(tagType, artifacts), true), Lookups.singleton(tagName));\n\n            super.setName(tagName);\n            super.setDisplayName(tagName + \" (\" + artifacts.size() + \")\");\n\n            this.setIconBaseWithExtension(TAG_ICON_PATH);\n        }","id":99319,"modified_method":"TagNodeRoot(BlackboardArtifact.ARTIFACT_TYPE tagType, String tagName, List<BlackboardArtifact> artifacts) {\n            super(Children.create(new Tags.TagsChildrenNode(tagType, tagName, artifacts), true), Lookups.singleton(tagName));\n\n            super.setName(tagName);\n            super.setDisplayName(tagName + \" (\" + artifacts.size() + \")\");\n\n            if (tagName.equals(BOOKMARK_TAG_NAME)) {\n                this.setIconBaseWithExtension(BOOKMARK_ICON_PATH);\n            } else {\n                this.setIconBaseWithExtension(TAG_ICON_PATH);\n            }\n        }","commit_id":"270c30ed3a930d8bb42d6df872db6bc26b88980c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private TagsChildrenNode(BlackboardArtifact.ARTIFACT_TYPE tagType, List<BlackboardArtifact> artifacts) {\n            super();\n            this.tagType = tagType;\n            this.artifacts = artifacts;\n        }","id":99320,"modified_method":"private TagsChildrenNode(BlackboardArtifact.ARTIFACT_TYPE tagType, String tagName, List<BlackboardArtifact> artifacts) {\n            super();\n            this.tagType = tagType;\n            this.tagName = tagName;\n            this.artifacts = artifacts;\n        }","commit_id":"270c30ed3a930d8bb42d6df872db6bc26b88980c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n        protected Node createNodeForKey(final BlackboardArtifact artifact) {\n            //create node with action\n            BlackboardArtifactNode tagNode = null;\n\n            //create actions here where Tag logic belongs\n            //instead of DataResultFilterNode w/visitors, which is much less pluggable and cluttered\n            if (tagType.equals(BlackboardArtifact.ARTIFACT_TYPE.TSK_TAG_ARTIFACT)) {\n                //in case of result tag, add a action by sublcassing bb art node\n                //this action will be merged with other actions set  DataResultFIlterNode\n                //otherwise in case of \n                tagNode = new BlackboardArtifactNode(artifact, TAG_ICON_PATH) {\n                    @Override\n                    public Action[] getActions(boolean bln) {\n                        //Action [] actions = super.getActions(bln); //To change body of generated methods, choose Tools | Templates.\n                        Action[] actions = new Action[1];\n                        actions[0] = new AbstractAction(\"View Source Result\") {\n                            @Override\n                            public void actionPerformed(ActionEvent e) {\n                                //open the source artifact in dir tree\n                                BlackboardArtifact sourceArt = Tags.getArtifactFromTag(artifact.getArtifactID());\n                                if (sourceArt != null) {\n                                    BlackboardResultViewer v = Lookup.getDefault().lookup(BlackboardResultViewer.class);\n                                    v.viewArtifact(sourceArt);\n                                }\n                            }\n                        };\n                        return actions;\n                    }\n                };\n            } else {\n                //for file tag, don't subclass to add the additional actions\n                tagNode = new BlackboardArtifactNode(artifact, TAG_ICON_PATH);\n            }\n\n            int artifactTypeID = artifact.getArtifactTypeID();\n            if (artifactTypeID == BlackboardArtifact.ARTIFACT_TYPE.TSK_TAG_ARTIFACT.getTypeID()) {\n                final String NO_DESCR = \"no description\";\n\n                BlackboardArtifact sourceResult = Tags.getArtifactFromTag(artifact.getArtifactID());\n                String resultType = sourceResult.getDisplayName();\n\n                NodeProperty resultTypeProp = new NodeProperty(\"Source Result Type\",\n                        \"Result Type\",\n                        NO_DESCR,\n                        resultType);\n\n\n                tagNode.addNodeProperty(resultTypeProp);\n\n            }\n            return tagNode;\n        }","id":99321,"modified_method":"@Override\n        protected Node createNodeForKey(final BlackboardArtifact artifact) {\n            //create node with action\n            BlackboardArtifactNode tagNode = null;\n\n            String iconPath;\n            if (tagName.equals(BOOKMARK_TAG_NAME)) {\n                iconPath = BOOKMARK_ICON_PATH;\n            } else {\n                iconPath = TAG_ICON_PATH;\n            }\n\n            //create actions here where Tag logic belongs\n            //instead of DataResultFilterNode w/visitors, which is much less pluggable and cluttered\n            if (tagType.equals(BlackboardArtifact.ARTIFACT_TYPE.TSK_TAG_ARTIFACT)) {\n                //in case of result tag, add a action by sublcassing bb art node\n                //this action will be merged with other actions set  DataResultFIlterNode\n                //otherwise in case of \n                tagNode = new BlackboardArtifactNode(artifact, iconPath) {\n                    @Override\n                    public Action[] getActions(boolean bln) {\n                        //Action [] actions = super.getActions(bln); //To change body of generated methods, choose Tools | Templates.\n                        Action[] actions = new Action[1];\n                        actions[0] = new AbstractAction(\"View Source Result\") {\n                            @Override\n                            public void actionPerformed(ActionEvent e) {\n                                //open the source artifact in dir tree\n                                BlackboardArtifact sourceArt = Tags.getArtifactFromTag(artifact.getArtifactID());\n                                if (sourceArt != null) {\n                                    BlackboardResultViewer v = Lookup.getDefault().lookup(BlackboardResultViewer.class);\n                                    v.viewArtifact(sourceArt);\n                                }\n                            }\n                        };\n                        return actions;\n                    }\n                };\n            } else {\n                //for file tag, don't subclass to add the additional actions\n                tagNode = new BlackboardArtifactNode(artifact, iconPath);\n            }\n\n            //add some additional node properties\n            int artifactTypeID = artifact.getArtifactTypeID();\n             final String NO_DESCR = \"no description\";\n            if (artifactTypeID == BlackboardArtifact.ARTIFACT_TYPE.TSK_TAG_ARTIFACT.getTypeID()) {\n                BlackboardArtifact sourceResult = Tags.getArtifactFromTag(artifact.getArtifactID());\n                String resultType = sourceResult.getDisplayName();\n\n                NodeProperty resultTypeProp = new NodeProperty(\"Source Result Type\",\n                        \"Result Type\",\n                        NO_DESCR,\n                        resultType);\n\n\n                tagNode.addNodeProperty(resultTypeProp);\n\n            }\n            try {\n                //add source path property\n                 final AbstractFile sourceFile = skCase.getAbstractFileById(artifact.getObjectID());\n                 final String sourcePath = sourceFile.getUniquePath();\n                 NodeProperty sourcePathProp = new NodeProperty(\"Source File Path\",\n                        \"Source File Path\",\n                        NO_DESCR,\n                        sourcePath);\n\n\n                tagNode.addNodeProperty(sourcePathProp);\n            } catch (TskCoreException ex) {\n                logger.log(Level.SEVERE, \"Error getting a file from artifact to get source file path for a tag, \", ex);\n            }\n            \n            return tagNode;\n        }","commit_id":"270c30ed3a930d8bb42d6df872db6bc26b88980c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void initData() {\n            try {\n                // Get all file and artifact tags\n\n                //init data\n                tags = new EnumMap<BlackboardArtifact.ARTIFACT_TYPE, Map<String, List<BlackboardArtifact>>>(BlackboardArtifact.ARTIFACT_TYPE.class);\n                tags.put(BlackboardArtifact.ARTIFACT_TYPE.TSK_TAG_FILE, new HashMap<String, List<BlackboardArtifact>>());\n                tags.put(BlackboardArtifact.ARTIFACT_TYPE.TSK_TAG_ARTIFACT, new HashMap<String, List<BlackboardArtifact>>());\n\n                //populate\n                for (BlackboardArtifact.ARTIFACT_TYPE artType : tags.keySet()) {\n                    final Map<String, List<BlackboardArtifact>> artTags = tags.get(artType);\n                    for (BlackboardArtifact artifact : skCase.getBlackboardArtifacts(artType)) {\n                        for (BlackboardAttribute attribute : artifact.getAttributes()) {\n                            if (attribute.getAttributeTypeID() == ATTRIBUTE_TYPE.TSK_TAG_NAME.getTypeID()) {\n                                String tagName = attribute.getValueString();\n                                if (tagName.equals(Bookmarks.BOOKMARK_TAG_NAME)) {\n                                    break; // Don't add bookmarks\n                                } else if (artTags.containsKey(tagName)) {\n                                    List<BlackboardArtifact> artifacts = artTags.get(tagName);\n                                    artifacts.add(artifact);\n                                } else {\n                                    List<BlackboardArtifact> artifacts = new ArrayList<BlackboardArtifact>();\n                                    artifacts.add(artifact);\n                                    artTags.put(tagName, artifacts);\n                                }\n                                break;\n                            }\n                        }\n                    }\n                }\n\n\n            } catch (TskCoreException ex) {\n                logger.log(Level.WARNING, \"Count not initialize tag nodes, \", ex);\n            }\n        }","id":99322,"modified_method":"private void initData() {\n            try {\n                // Get all file and artifact tags\n\n                //init data\n                tags = new EnumMap<BlackboardArtifact.ARTIFACT_TYPE, Map<String, List<BlackboardArtifact>>>(BlackboardArtifact.ARTIFACT_TYPE.class);\n                tags.put(BlackboardArtifact.ARTIFACT_TYPE.TSK_TAG_FILE, new HashMap<String, List<BlackboardArtifact>>());\n                tags.put(BlackboardArtifact.ARTIFACT_TYPE.TSK_TAG_ARTIFACT, new HashMap<String, List<BlackboardArtifact>>());\n\n                //populate\n                for (BlackboardArtifact.ARTIFACT_TYPE artType : tags.keySet()) {\n                    final Map<String, List<BlackboardArtifact>> artTags = tags.get(artType);\n                    for (BlackboardArtifact artifact : skCase.getBlackboardArtifacts(artType)) {\n                        for (BlackboardAttribute attribute : artifact.getAttributes()) {\n                            if (attribute.getAttributeTypeID() == ATTRIBUTE_TYPE.TSK_TAG_NAME.getTypeID()) {\n                                String tagName = attribute.getValueString();\n                                if (artTags.containsKey(tagName)) {\n                                    List<BlackboardArtifact> artifacts = artTags.get(tagName);\n                                    artifacts.add(artifact);\n                                } else {\n                                    List<BlackboardArtifact> artifacts = new ArrayList<BlackboardArtifact>();\n                                    artifacts.add(artifact);\n                                    artTags.put(tagName, artifacts);\n                                }\n                                break;\n                            }\n                        }\n                    }\n                }\n\n\n            } catch (TskCoreException ex) {\n                logger.log(Level.WARNING, \"Count not initialize tag nodes, \", ex);\n            }\n        }","commit_id":"270c30ed3a930d8bb42d6df872db6bc26b88980c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n        public void visit(final GroovyCodeVisitor visitor) {\n            if (visitor instanceof AsmClassGenerator) {\n                AsmClassGenerator acg = (AsmClassGenerator) visitor;\n                WriterController controller = acg.getController();\n                OperandStack os = controller.getOperandStack();\n\n                if (type.equals(ClassHelper.boolean_TYPE)) {\n                    expression.visit(visitor);\n                    os.doGroovyCast(ClassHelper.boolean_TYPE);\n                    return;\n                }\n                if (type.equals(ClassHelper.Boolean_TYPE)) {\n                    MethodVisitor mv = controller.getMethodVisitor();\n                    expression.visit(visitor);\n                    Label unbox = new Label();\n                    Label exit = new Label();\n                    // check for null\n                    mv.visitInsn(DUP);\n                    mv.visitJumpInsn(IFNONNULL, unbox);\n                    mv.visitInsn(POP);\n                    mv.visitInsn(ICONST_0);\n                    mv.visitJumpInsn(GOTO, exit);\n                    mv.visitLabel(unbox);\n                    // unbox\n                    // GROOVY-6270\n                    if (!os.getTopOperand().equals(type)) BytecodeHelper.doCast(mv, type);\n                    mv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Boolean\", \"booleanValue\", \"()Z\", false);\n                    mv.visitLabel(exit);\n                    os.replace(ClassHelper.boolean_TYPE);\n                    return;\n                }\n                ClassNode top = type;\n                if (ClassHelper.isPrimitiveType(top)) {\n                    expression.visit(visitor);\n                    // in case of null safe invocation, it is possible that what was supposed to be a primitive type\n                    // becomes the \"null\" constant, so we need to recheck\n                    top = controller.getOperandStack().getTopOperand();\n                    if (ClassHelper.isPrimitiveType(top)) {\n                        if (top.equals(ClassHelper.int_TYPE) || top.equals(ClassHelper.byte_TYPE)\n                                || top.equals(ClassHelper.short_TYPE) || top.equals(ClassHelper.char_TYPE)) {\n                            // int on stack\n                        } else if (top.equals(ClassHelper.long_TYPE)) {\n                            MethodVisitor mv = controller.getMethodVisitor();\n                            mv.visitInsn(L2I);\n                            controller.getOperandStack().replace(ClassHelper.boolean_TYPE);\n                        } else if (top.equals(ClassHelper.float_TYPE)) {\n                            MethodVisitor mv = controller.getMethodVisitor();\n                            mv.visitInsn(F2I);\n                            controller.getOperandStack().replace(ClassHelper.boolean_TYPE);\n                        } else if (top.equals(ClassHelper.double_TYPE)) {\n                            MethodVisitor mv = controller.getMethodVisitor();\n                            mv.visitInsn(D2I);\n                            controller.getOperandStack().replace(ClassHelper.boolean_TYPE);\n                        }\n                        return;\n                    }\n                }\n                List<MethodNode> asBoolean = findDGMMethodsByNameAndArguments(controller.getSourceUnit().getClassLoader(), top, \"asBoolean\", ClassNode.EMPTY_ARRAY);\n                if (asBoolean.size() == 1) {\n                    MethodNode node = asBoolean.get(0);\n                    if (node instanceof ExtensionMethodNode) {\n                        MethodNode dgmNode = ((ExtensionMethodNode) node).getExtensionMethodNode();\n                        ClassNode owner = dgmNode.getParameters()[0].getType();\n                        if (ClassHelper.OBJECT_TYPE.equals(owner)) {\n                            // we may inline a var!=null check instead of calling a helper method iff\n                            // (1) the class doesn't define an asBoolean method (already tested)\n                            // (2) no subclass defines an asBoolean method\n                            // For (2), we check that we are in one of those cases\n                            // (a) a final class\n                            // (b) a private inner class without subclass\n                            if (Modifier.isFinal(top.getModifiers())\n                                    || (top instanceof InnerClassNode\n                                    && Modifier.isPrivate(top.getModifiers())\n                                    && !isExtended(top, top.getOuterClass().getInnerClasses()))\n                                    ) {\n                                CompareToNullExpression expr = new CompareToNullExpression(\n                                        expression, false\n                                );\n                                expr.visit(acg);\n                                return;\n                            }\n                        }\n                    }\n                }\n                super.visit(visitor);\n            } else {\n                super.visit(visitor);\n            }\n        }","id":99323,"modified_method":"@Override\n        public void visit(final GroovyCodeVisitor visitor) {\n            if (visitor instanceof AsmClassGenerator) {\n                AsmClassGenerator acg = (AsmClassGenerator) visitor;\n                WriterController controller = acg.getController();\n                OperandStack os = controller.getOperandStack();\n\n                if (type.equals(ClassHelper.boolean_TYPE)) {\n                    expression.visit(visitor);\n                    os.doGroovyCast(ClassHelper.boolean_TYPE);\n                    return;\n                }\n                if (type.equals(ClassHelper.Boolean_TYPE)) {\n                    MethodVisitor mv = controller.getMethodVisitor();\n                    expression.visit(visitor);\n                    Label unbox = new Label();\n                    Label exit = new Label();\n                    // check for null\n                    mv.visitInsn(DUP);\n                    mv.visitJumpInsn(IFNONNULL, unbox);\n                    mv.visitInsn(POP);\n                    mv.visitInsn(ICONST_0);\n                    mv.visitJumpInsn(GOTO, exit);\n                    mv.visitLabel(unbox);\n                    // unbox\n                    // GROOVY-6270\n                    if (!os.getTopOperand().equals(type)) BytecodeHelper.doCast(mv, type);\n                    mv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Boolean\", \"booleanValue\", \"()Z\", false);\n                    mv.visitLabel(exit);\n                    os.replace(ClassHelper.boolean_TYPE);\n                    return;\n                }\n                ClassNode top = type;\n                if (ClassHelper.isPrimitiveType(top)) {\n                    expression.visit(visitor);\n                    // in case of null safe invocation, it is possible that what was supposed to be a primitive type\n                    // becomes the \"null\" constant, so we need to recheck\n                    top = controller.getOperandStack().getTopOperand();\n                    if (ClassHelper.isPrimitiveType(top)) {\n                        if (top.equals(ClassHelper.int_TYPE) || top.equals(ClassHelper.byte_TYPE)\n                                || top.equals(ClassHelper.short_TYPE) || top.equals(ClassHelper.char_TYPE)) {\n                            // int on stack\n                        } else if (top.equals(ClassHelper.long_TYPE)) {\n                            MethodVisitor mv = controller.getMethodVisitor();\n                            mv.visitInsn(LCONST_0);\n                            mv.visitInsn(LCMP);\n                            controller.getOperandStack().replace(ClassHelper.boolean_TYPE);\n                        } else if (top.equals(ClassHelper.float_TYPE)) {\n                            MethodVisitor mv = controller.getMethodVisitor();\n                            mv.visitInsn(F2D);\n                            mv.visitInsn(DCONST_0);\n                            mv.visitInsn(DCMPG);\n                            controller.getOperandStack().replace(ClassHelper.boolean_TYPE);\n                        } else if (top.equals(ClassHelper.double_TYPE)) {\n                            MethodVisitor mv = controller.getMethodVisitor();\n                            mv.visitInsn(DCONST_0);\n                            mv.visitInsn(DCMPG);\n                            controller.getOperandStack().replace(ClassHelper.boolean_TYPE);\n                        }\n                        return;\n                    }\n                }\n                List<MethodNode> asBoolean = findDGMMethodsByNameAndArguments(controller.getSourceUnit().getClassLoader(), top, \"asBoolean\", ClassNode.EMPTY_ARRAY);\n                if (asBoolean.size() == 1) {\n                    MethodNode node = asBoolean.get(0);\n                    if (node instanceof ExtensionMethodNode) {\n                        MethodNode dgmNode = ((ExtensionMethodNode) node).getExtensionMethodNode();\n                        ClassNode owner = dgmNode.getParameters()[0].getType();\n                        if (ClassHelper.OBJECT_TYPE.equals(owner)) {\n                            // we may inline a var!=null check instead of calling a helper method iff\n                            // (1) the class doesn't define an asBoolean method (already tested)\n                            // (2) no subclass defines an asBoolean method\n                            // For (2), we check that we are in one of those cases\n                            // (a) a final class\n                            // (b) a private inner class without subclass\n                            if (Modifier.isFinal(top.getModifiers())\n                                    || (top instanceof InnerClassNode\n                                    && Modifier.isPrivate(top.getModifiers())\n                                    && !isExtended(top, top.getOuterClass().getInnerClasses()))\n                                    ) {\n                                CompareToNullExpression expr = new CompareToNullExpression(\n                                        expression, false\n                                );\n                                expr.visit(acg);\n                                return;\n                            }\n                        }\n                    }\n                }\n                super.visit(visitor);\n            } else {\n                super.visit(visitor);\n            }\n        }","commit_id":"99f40916ffdc4d3a049cd9ae7fb37f34b8503cbb","url":"https://github.com/apache/groovy"},{"original_method":"/**\n     * convert primitive (not boolean) to boolean or byte.\n     * type needs to be a primitive type (not checked) \n     */\n    private void primitive2b(MethodVisitor mv, ClassNode type) {\n        if (type==ClassHelper.double_TYPE) {\n            mv.visitInsn(D2I);\n            mv.visitInsn(I2B);\n        } else if (type==ClassHelper.long_TYPE) {\n            mv.visitInsn(L2I);\n            mv.visitInsn(I2B);\n        } else if (type==ClassHelper.float_TYPE) {\n            mv.visitInsn(F2I);\n            mv.visitInsn(I2B);\n        } else if (type==ClassHelper.int_TYPE) {\n            mv.visitInsn(I2B);\n        } \n        // other cases can be used directly\n    }","id":99324,"modified_method":"/**\n     * convert primitive (not boolean) to boolean or byte.\n     * type needs to be a primitive type (not checked) \n     */\n    private void primitive2b(MethodVisitor mv, ClassNode type) {\n        Label trueLabel = new Label();\n        Label falseLabel = new Label();\n        // for the various types we make first a \n        // kind of conversion to int using a compare\n        // operation and then handle the result common\n        // for all cases. In case of long that is LCMP,\n        // for int nothing is to be done\n        if (type==ClassHelper.double_TYPE) {\n            mv.visitInsn(DCONST_0);\n            mv.visitInsn(DCMPL);\n        } else if (type==ClassHelper.long_TYPE) {\n            mv.visitInsn(LCONST_0);\n            mv.visitInsn(LCMP);\n        } else if (type==ClassHelper.float_TYPE) {\n            mv.visitInsn(FCONST_0);\n            mv.visitInsn(FCMPL);\n        } else if (type==ClassHelper.int_TYPE) {\n            // nothing, see comment above\n        }\n        mv.visitJumpInsn(IFEQ, falseLabel);\n        mv.visitInsn(ICONST_1);\n        mv.visitJumpInsn(GOTO, trueLabel);\n        mv.visitLabel(falseLabel);\n        mv.visitInsn(ICONST_0);\n        mv.visitLabel(trueLabel);\n        // other cases can be used directly\n    }","commit_id":"269125bd05eb7098d724570ea405f3ea3262d051","url":"https://github.com/apache/groovy"},{"original_method":"public void fireTableRowsInserted( int first, int last ) {\n\t\tif (baseModel == null)\n\t\t\treturn;\n\t\t\t\n\t\tbaseModel.fireTableRowsInserted(first, last);\n\t\tsetupMapping();\n\t}","id":99325,"modified_method":"public void fireTableRowsInserted( int first, int last ) {\n\t\tif (baseModel != null)\n\t\t\tsetupMapping();\n\t\tsuper.fireTableRowsInserted(first, last);\n\t}","commit_id":"dbd16dc541e1147f9e25fc3d8ac3188c90c4e95e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void fireTableDataChanged() {\n\t\tif (baseModel == null)\n\t\t\treturn;\n\t\t\t\n\t\tbaseModel.fireTableDataChanged();\n\t\tsetupMapping();\n\t}","id":99326,"modified_method":"public void fireTableDataChanged() {\n\t\tif (baseModel != null)\n\t\t\tsetupMapping();\n\t\tsuper.fireTableDataChanged();\n\t}","commit_id":"dbd16dc541e1147f9e25fc3d8ac3188c90c4e95e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void fireTableRowsUpdated( int first, int last ) {\n\t\tif (baseModel == null)\n\t\t\treturn;\n\t\t\t\n\t\tbaseModel.fireTableRowsUpdated(first, last);\n\t\tsetupMapping();\n\t}","id":99327,"modified_method":"public void fireTableRowsUpdated( int first, int last ) {\n\t\tif (baseModel != null)\n\t\t\tsetupMapping();\n\t\tsuper.fireTableRowsUpdated(first, last);\n\t}","commit_id":"dbd16dc541e1147f9e25fc3d8ac3188c90c4e95e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void setValueAt( Object value, int row, int col ) {\n\t\tif (baseModel == null)\n\t\t\treturn;\n\t\t\t\n\t\tbaseModel.setValueAt( value, viewToModelMapping.get(row).intValue(), col );\n\t}","id":99328,"modified_method":"public void setValueAt( Object value, int row, int col ) {\n\t\tif (baseModel == null)\n\t\t\treturn;\n\t\t\t\n\t\tbaseModel.setValueAt( value, viewToModelMapping.get(row).intValue(), col );\n\t\tfireTableDataChanged();\n\t}","commit_id":"dbd16dc541e1147f9e25fc3d8ac3188c90c4e95e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void fireTableChanged( TableModelEvent e ) {\n\t\tif (baseModel == null)\n\t\t\treturn;\n\t\t\t\n\t\tbaseModel.fireTableChanged(e);\n\t\tsetupMapping();\n\t}","id":99329,"modified_method":"public void fireTableChanged( TableModelEvent e ) {\n\t\tif (baseModel != null)\n\t\t\tsetupMapping();\n\t\tsuper.fireTableChanged(e);\n\t}","commit_id":"dbd16dc541e1147f9e25fc3d8ac3188c90c4e95e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void fireTableRowsDeleted( int first, int last ) {\n\t\tif (baseModel == null)\n\t\t\treturn;\n\t\t\t\n\t\tbaseModel.fireTableRowsDeleted(first, last);\n\t\tsetupMapping();\n\t}","id":99330,"modified_method":"public void fireTableRowsDeleted( int first, int last ) {\n\t\tif (baseModel != null)\n\t\t\tsetupMapping();\n\t\tsuper.fireTableRowsDeleted(first,last);\n\t}","commit_id":"dbd16dc541e1147f9e25fc3d8ac3188c90c4e95e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void fireTableStructureChanged() {\n\t\tif (baseModel == null)\n\t\t\treturn;\n\t\t\t\n\t\tbaseModel.fireTableStructureChanged();\n\t\tsetupMapping();\n\t}","id":99331,"modified_method":"public void fireTableStructureChanged() {\n\t\tif (baseModel != null)\n\t\t\tsetupMapping();\n\t\tsuper.fireTableStructureChanged();\n\t}","commit_id":"dbd16dc541e1147f9e25fc3d8ac3188c90c4e95e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void fireTableCellUpdated( int row, int col ) {\n\t\tif (baseModel == null)\n\t\t\treturn;\n\t\t\t\n\t\tbaseModel.fireTableCellUpdated(row, col);\n\t\tsetupMapping();\n\t}","id":99332,"modified_method":"public void fireTableCellUpdated( int row, int col ) {\n\t\tif (baseModel != null)\n\t\t\tsetupMapping();\n\t\tsuper.fireTableCellUpdated(row, col);\n\t}","commit_id":"dbd16dc541e1147f9e25fc3d8ac3188c90c4e95e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Bug(18641)\n    @Test public void display() throws Exception {\n        User.get(\"bob\");\n        HtmlPage page = j.createWebClient().goTo(\"asynchPeople\");\n        assertEquals(\"display: none;\", page.getElementById(\"status\").getAttribute(\"style\"));\n        assertNotNull(page.getElementById(\"person-bob\"));\n    }","id":99333,"modified_method":"@Bug(18641)\n    @Test public void display() throws Exception {\n        User.get(\"bob\");\n        JenkinsRule.WebClient wc = j.createWebClient();\n        HtmlPage page = wc.goTo(\"asynchPeople\");\n        assertEquals(0, wc.waitForBackgroundJavaScript(120000));\n        assertEquals(\"display: none;\", page.getElementById(\"status\").getAttribute(\"style\"));\n        assertNotNull(page.getElementById(\"person-bob\"));\n    }","commit_id":"08aaf2b9b399b71bd192e5c104c2ff63556a8e69","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Makes sure that an AJAX handler error results in a fatal problem in the unit test.\n     */\n    public void testAjaxError() throws Exception {\n        try {\n            createWebClient().goTo(\"/self/ajaxError\");\n            fail(\"should have resulted in a ScriptException\");\n        } catch (ScriptException e) {\n            if (e.getMessage().contains(\"simulated error\"))\n                return; // as expected\n            throw e;\n\n        }\n    }","id":99334,"modified_method":"/**\n     * Makes sure that an AJAX handler error results in a fatal problem in the unit test.\n     */\n    public void testAjaxError() throws Exception {\n        WebClient webClient = createWebClient();\n        WebClientUtil.ExceptionListener exceptionListener = WebClientUtil.addExceptionListener(webClient);\n        webClient.goTo(\"/self/ajaxError\");\n\n        // Check for the error.\n        ScriptException e = exceptionListener.getExpectedScriptException();\n        Assert.assertTrue(e.getMessage().contains(\"simulated error\"));\n    }","commit_id":"19cf13a512badf61e438b21fd984f7a94f5abd45","url":"https://github.com/kohsuke/hudson"},{"original_method":"public static void waitForJSExec(WebClient webClient, long timeout) {\n        webClient.waitForBackgroundJavaScript(timeout);\n    }","id":99335,"modified_method":"public static void waitForJSExec(WebClient webClient, long timeout) {\n        webClient.getJavaScriptEngine().processPostponedActions();\n        webClient.waitForBackgroundJavaScript(timeout);\n    }","commit_id":"19cf13a512badf61e438b21fd984f7a94f5abd45","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Makes sure every link works.\n     */\n    @Test\n    public void links() throws Exception {\n        HtmlPage page = j.createWebClient().goTo(\"manage\");\n        List<?> anchors = DomNodeUtil.selectNodes(page, \"id('management-links')//*[@class='link']/a[not(@onclick)]\");\n        assertTrue(anchors.size()>=8);\n        for(HtmlAnchor e : (List<HtmlAnchor>) anchors) {\n            e.click();\n        }\n    }","id":99336,"modified_method":"/**\n     * Makes sure every link works.\n     */\n    @Test\n    public void links() throws Exception {\n        WebClient wc = j.createWebClient();\n\n        for (int i=0; ; i++) {\n            HtmlPage page = wc.goTo(\"manage\");\n            List<?> anchors = DomNodeUtil.selectNodes(page, \"id('management-links')//*[@class='link']/a[not(@onclick)]\");\n            assertTrue(anchors.size()>=8);\n            if (i==anchors.size())  return; // done\n\n            ((HtmlAnchor)anchors.get(i)).click();\n        }\n    }","commit_id":"920f20fd060f0d6fed9296ad391b724c8abf6b12","url":"https://github.com/kohsuke/hudson"},{"original_method":"private OnmsOutageCollection queryOutages(final int nodeId, final String ipAddress, final String serviceName, final long start, final long end) {\n        OnmsOutageCollection onmsOutageCollection;\n\n        readLock();\n        try {\n            final CriteriaBuilder builder = new CriteriaBuilder(OnmsOutage.class);\n            builder.eq(\"node.id\", nodeId);\n\n            final Date startDate = new Date();\n            startDate.setTime(start * 1000l);\n\n            final Date endDate = new Date();\n            endDate.setTime(end * 1000l);\n\n            builder.or(Restrictions.isNull(\"ifRegainedService\"), Restrictions.and(Restrictions.gt(\"ifRegainedService\", startDate), Restrictions.le(\"ifRegainedService\", endDate)));\n\n            builder.le(\"ifLostService\", endDate);\n\n            builder.eq(\"serviceType.name\", serviceName);\n            builder.eq(\"ipInterface.ipAddress\", InetAddressUtils.addr(ipAddress));\n\n            builder.alias(\"monitoredService\", \"monitoredService\");\n            builder.alias(\"monitoredService.ipInterface\", \"ipInterface\");\n            builder.alias(\"monitoredService.ipInterface.node\", \"node\");\n            builder.alias(\"monitoredService.serviceType\", \"serviceType\");\n\n            applyQueryFilters(m_uriInfo.getQueryParameters(), builder, null);\n\n            builder.orderBy(\"id\").desc();\n\n            onmsOutageCollection = new OnmsOutageCollection(m_outageDao.findMatching(builder.toCriteria()));\n        } finally {\n            readUnlock();\n        }\n\n        return onmsOutageCollection;\n    }","id":99337,"modified_method":"private OnmsOutageCollection queryOutages(final int nodeId, final String ipAddress, final String serviceName, final long start, final long end) {\n        OnmsOutageCollection onmsOutageCollection;\n\n        readLock();\n        try {\n            final CriteriaBuilder builder = new CriteriaBuilder(OnmsOutage.class);\n            builder.eq(\"node.id\", nodeId);\n\n            final Date startDate = new Date();\n            startDate.setTime(start * 1000l);\n\n            final Date endDate = new Date();\n            endDate.setTime(end * 1000l);\n\n            builder.or(Restrictions.isNull(\"ifRegainedService\"), Restrictions.gt(\"ifRegainedService\", startDate)); \n\n            builder.le(\"ifLostService\", endDate);\n\n            builder.eq(\"serviceType.name\", serviceName);\n            builder.eq(\"ipInterface.ipAddress\", InetAddressUtils.addr(ipAddress));\n\n            builder.alias(\"monitoredService\", \"monitoredService\");\n            builder.alias(\"monitoredService.ipInterface\", \"ipInterface\");\n            builder.alias(\"monitoredService.ipInterface.node\", \"node\");\n            builder.alias(\"monitoredService.serviceType\", \"serviceType\");\n\n            applyQueryFilters(m_uriInfo.getQueryParameters(), builder, null);\n\n            builder.orderBy(\"id\").desc();\n\n            onmsOutageCollection = new OnmsOutageCollection(m_outageDao.findMatching(builder.toCriteria()));\n        } finally {\n            readUnlock();\n        }\n\n        return onmsOutageCollection;\n    }","commit_id":"4f04e02bea2b3cc2d93fc4262e3d8ac19faf4963","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private OnmsOutageCollection queryOutages(final int nodeId, final String ipAddress, final String serviceName, final long start, final long end) {\n        OnmsOutageCollection onmsOutageCollection;\n\n        readLock();\n        try {\n            final CriteriaBuilder builder = new CriteriaBuilder(OnmsOutage.class);\n            builder.eq(\"node.id\", nodeId);\n\n            final Date startDate = new Date();\n            startDate.setTime(start * 1000l);\n\n            final Date endDate = new Date();\n            endDate.setTime(end * 1000l);\n\n            builder.or(Restrictions.isNull(\"ifRegainedService\"), Restrictions.and(Restrictions.gt(\"ifRegainedService\", startDate), Restrictions.le(\"ifRegainedService\", endDate)));\n\n            builder.le(\"ifLostService\", endDate);\n\n            builder.eq(\"serviceType.name\", serviceName);\n            builder.eq(\"ipInterface.ipAddress\", InetAddressUtils.addr(ipAddress));\n\n            builder.alias(\"monitoredService\", \"monitoredService\");\n            builder.alias(\"monitoredService.ipInterface\", \"ipInterface\");\n            builder.alias(\"monitoredService.ipInterface.node\", \"node\");\n            builder.alias(\"monitoredService.serviceType\", \"serviceType\");\n\n            applyQueryFilters(m_uriInfo.getQueryParameters(), builder, null);\n\n            builder.orderBy(\"id\").desc();\n\n            onmsOutageCollection = new OnmsOutageCollection(m_outageDao.findMatching(builder.toCriteria()));\n        } finally {\n            readUnlock();\n        }\n\n        return onmsOutageCollection;\n    }","id":99338,"modified_method":"private OnmsOutageCollection queryOutages(final int nodeId, final String ipAddress, final String serviceName, final long start, final long end) {\n        OnmsOutageCollection onmsOutageCollection;\n\n        readLock();\n        try {\n            final CriteriaBuilder builder = new CriteriaBuilder(OnmsOutage.class);\n            builder.eq(\"node.id\", nodeId);\n\n            final Date startDate = new Date();\n            startDate.setTime(start * 1000l);\n\n            final Date endDate = new Date();\n            endDate.setTime(end * 1000l);\n\n            builder.or(Restrictions.isNull(\"ifRegainedService\"), Restrictions.gt(\"ifRegainedService\", startDate)); \n\n            builder.le(\"ifLostService\", endDate);\n\n            builder.eq(\"serviceType.name\", serviceName);\n            builder.eq(\"ipInterface.ipAddress\", InetAddressUtils.addr(ipAddress));\n\n            builder.alias(\"monitoredService\", \"monitoredService\");\n            builder.alias(\"monitoredService.ipInterface\", \"ipInterface\");\n            builder.alias(\"monitoredService.ipInterface.node\", \"node\");\n            builder.alias(\"monitoredService.serviceType\", \"serviceType\");\n\n            applyQueryFilters(m_uriInfo.getQueryParameters(), builder, null);\n\n            builder.orderBy(\"id\").desc();\n\n            onmsOutageCollection = new OnmsOutageCollection(m_outageDao.findMatching(builder.toCriteria()));\n        } finally {\n            readUnlock();\n        }\n\n        return onmsOutageCollection;\n    }","commit_id":"23920ebf534bcb86cb9de1a4d54dbc50b8bf2574","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private OnmsOutageCollection queryOutages(final int nodeId, final String ipAddress, final String serviceName, final long start, final long end) {\n        OnmsOutageCollection onmsOutageCollection;\n\n        readLock();\n        try {\n            final CriteriaBuilder builder = new CriteriaBuilder(OnmsOutage.class);\n            builder.eq(\"node.id\", nodeId);\n\n            final Date startDate = new Date();\n            startDate.setTime(start * 1000l);\n\n            final Date endDate = new Date();\n            endDate.setTime(end * 1000l);\n\n            builder.or(Restrictions.isNull(\"ifRegainedService\"), Restrictions.and(Restrictions.gt(\"ifRegainedService\", startDate), Restrictions.le(\"ifRegainedService\", endDate)));\n\n            builder.le(\"ifLostService\", endDate);\n\n            builder.eq(\"serviceType.name\", serviceName);\n            builder.eq(\"ipInterface.ipAddress\", InetAddressUtils.addr(ipAddress));\n\n            builder.alias(\"monitoredService\", \"monitoredService\");\n            builder.alias(\"monitoredService.ipInterface\", \"ipInterface\");\n            builder.alias(\"monitoredService.ipInterface.node\", \"node\");\n            builder.alias(\"monitoredService.serviceType\", \"serviceType\");\n\n            applyQueryFilters(m_uriInfo.getQueryParameters(), builder, null);\n\n            builder.orderBy(\"id\").desc();\n\n            onmsOutageCollection = new OnmsOutageCollection(m_outageDao.findMatching(builder.toCriteria()));\n        } finally {\n            readUnlock();\n        }\n\n        return onmsOutageCollection;\n    }","id":99339,"modified_method":"private OnmsOutageCollection queryOutages(final int nodeId, final String ipAddress, final String serviceName, final long start, final long end) {\n        OnmsOutageCollection onmsOutageCollection;\n\n        readLock();\n        try {\n            final CriteriaBuilder builder = new CriteriaBuilder(OnmsOutage.class);\n            builder.eq(\"node.id\", nodeId);\n\n            final Date startDate = new Date();\n            startDate.setTime(start * 1000l);\n\n            final Date endDate = new Date();\n            endDate.setTime(end * 1000l);\n\n            builder.or(Restrictions.isNull(\"ifRegainedService\"), Restrictions.gt(\"ifRegainedService\", startDate)); \n\n            builder.le(\"ifLostService\", endDate);\n\n            builder.eq(\"serviceType.name\", serviceName);\n            builder.eq(\"ipInterface.ipAddress\", InetAddressUtils.addr(ipAddress));\n\n            builder.alias(\"monitoredService\", \"monitoredService\");\n            builder.alias(\"monitoredService.ipInterface\", \"ipInterface\");\n            builder.alias(\"monitoredService.ipInterface.node\", \"node\");\n            builder.alias(\"monitoredService.serviceType\", \"serviceType\");\n\n            applyQueryFilters(m_uriInfo.getQueryParameters(), builder, null);\n\n            builder.orderBy(\"id\").desc();\n\n            onmsOutageCollection = new OnmsOutageCollection(m_outageDao.findMatching(builder.toCriteria()));\n        } finally {\n            readUnlock();\n        }\n\n        return onmsOutageCollection;\n    }","commit_id":"491342714a00865a2cc1c88482bc5d56ad3b05f0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void writeData(DataOutput out) throws IOException {\n        long now = System.currentTimeMillis();\n        out.writeLong(cost);\n        out.writeLong(expirationTime - now);\n        out.writeLong(lastAccessTime - now);\n        out.writeLong(lastUpdateTime - now);\n        out.writeLong(creationTime - now);\n        out.writeLong(lastStoredTime - now);\n        out.writeLong(version);\n        out.writeInt(hits);\n        out.writeUTF(name);\n        keyData.writeData(out);\n        valueData.writeData(out);\n        byte indexCount = (indexes == null) ? 0 : (byte) indexes.length;\n        out.write(indexCount);\n        for (byte i = 0; i < indexCount; i++) {\n            out.writeLong(indexes[i]);\n            out.write(indexTypes[i]);\n        }\n    }","id":99340,"modified_method":"public void writeData(DataOutput out) throws IOException {\n        long now = System.currentTimeMillis();\n        out.writeLong(cost);\n        out.writeLong(expirationTime - now);\n        out.writeLong(lastAccessTime - now);\n        out.writeLong(lastUpdateTime - now);\n        out.writeLong(creationTime - now);\n        out.writeLong(lastStoredTime - now);\n        out.writeLong(version);\n        out.writeInt(hits);\n        out.writeUTF(name);\n        keyData.writeData(out);\n        boolean valueNull = (valueData == null);\n        out.writeBoolean(valueNull);\n        if (!valueNull) {\n            valueData.writeData(out);\n        }\n        byte indexCount = (indexes == null) ? 0 : (byte) indexes.length;\n        out.write(indexCount);\n        for (byte i = 0; i < indexCount; i++) {\n            out.writeLong(indexes[i]);\n            out.write(indexTypes[i]);\n        }\n    }","commit_id":"bddafcd900ba87ad0676c724f3c1c805c7dccd49","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void readData(DataInput in) throws IOException {\n        long now = System.currentTimeMillis();\n        cost = in.readLong();\n        expirationTime = in.readLong() + now;\n        lastAccessTime = in.readLong() + now;\n        lastUpdateTime = in.readLong() + now;\n        creationTime = in.readLong() + now;\n        lastStoredTime = in.readLong() + now;\n        version = in.readLong();\n        hits = in.readInt();\n        name = in.readUTF();\n        keyData = new Data();\n        keyData.readData(in);\n        valueData = new Data();\n        valueData.readData(in);\n        byte indexCount = in.readByte();\n        if (indexCount > 0) {\n            indexes = new Long[indexCount];\n            indexTypes = new byte[indexCount];\n            for (byte i = 0; i < indexCount; i++) {\n                indexes[i] = in.readLong();\n                indexTypes[i] = in.readByte();\n            }\n        }\n    }","id":99341,"modified_method":"public void readData(DataInput in) throws IOException {\n        long now = System.currentTimeMillis();\n        cost = in.readLong();\n        expirationTime = in.readLong() + now;\n        lastAccessTime = in.readLong() + now;\n        lastUpdateTime = in.readLong() + now;\n        creationTime = in.readLong() + now;\n        lastStoredTime = in.readLong() + now;\n        version = in.readLong();\n        hits = in.readInt();\n        name = in.readUTF();\n        keyData = new Data();\n        keyData.readData(in);\n        boolean valueNull = in.readBoolean();\n        if (!valueNull) {\n            valueData = new Data();\n            valueData.readData(in);\n        }\n        byte indexCount = in.readByte();\n        if (indexCount > 0) {\n            indexes = new Long[indexCount];\n            indexTypes = new byte[indexCount];\n            for (byte i = 0; i < indexCount; i++) {\n                indexes[i] = in.readLong();\n                indexTypes[i] = in.readByte();\n            }\n        }\n    }","commit_id":"bddafcd900ba87ad0676c724f3c1c805c7dccd49","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"protected void readInternal(ObjectDataInput in) throws IOException {\n        super.readInternal(in);\n        unlockKey = in.readBoolean();\n        recordInfo = new RecordInfo();\n        recordInfo.readData(in);\n    }","id":99342,"modified_method":"protected void readInternal(ObjectDataInput in) throws IOException {\n        super.readInternal(in);\n        unlockKey = in.readBoolean();\n        boolean hasRecordInfo = in.readBoolean();\n        if (hasRecordInfo) {\n            recordInfo = new RecordInfo();\n            recordInfo.readData(in);\n        }\n    }","commit_id":"fba22e94bea211490d5a5585a8cfd0a8464f24ab","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"protected void writeInternal(ObjectDataOutput out) throws IOException {\n        super.writeInternal(out);\n        out.writeBoolean(unlockKey);\n        recordInfo.writeData(out);\n    }","id":99343,"modified_method":"protected void writeInternal(ObjectDataOutput out) throws IOException {\n        super.writeInternal(out);\n        out.writeBoolean(unlockKey);\n        if (recordInfo != null) {\n            out.writeBoolean(true);\n            recordInfo.writeData(out);\n        } else {\n            out.writeBoolean(false);\n        }\n    }","commit_id":"fba22e94bea211490d5a5585a8cfd0a8464f24ab","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    protected void readInternal(ObjectDataInput in) throws IOException {\n        backupOp = in.readObject();\n        originalCaller = new Address();\n        originalCaller.readData(in);\n        replicaVersions = new long[PartitionInfo.MAX_BACKUP_COUNT];\n        for (int i = 0; i < PartitionInfo.MAX_BACKUP_COUNT; i++) {\n            replicaVersions[i] = in.readLong();\n        }\n        sync = in.readBoolean();\n    }","id":99344,"modified_method":"@Override\n    protected void readInternal(ObjectDataInput in) throws IOException {\n        backupOp = in.readObject();\n        if (in.readBoolean()) {\n            originalCaller = new Address();\n            originalCaller.readData(in);\n        }\n        replicaVersions = new long[PartitionInfo.MAX_BACKUP_COUNT];\n        for (int i = 0; i < PartitionInfo.MAX_BACKUP_COUNT; i++) {\n            replicaVersions[i] = in.readLong();\n        }\n        sync = in.readBoolean();\n    }","commit_id":"46eb050c17e1daa0a910b584b9c9f7adfb406948","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Backup(Operation backupOp, Address originalCaller, long[] replicaVersions, boolean sync) {\n        this.backupOp = backupOp;\n        this.originalCaller = originalCaller;\n        this.sync = sync;\n        this.replicaVersions = replicaVersions;\n    }","id":99345,"modified_method":"public Backup(Operation backupOp, Address originalCaller, long[] replicaVersions, boolean sync) {\n        this.backupOp = backupOp;\n        this.originalCaller = originalCaller;\n        this.sync = sync;\n        this.replicaVersions = replicaVersions;\n        if (sync && originalCaller == null) {\n            throw new IllegalArgumentException(\"Sync backup requires original caller address!\");\n        }\n    }","commit_id":"46eb050c17e1daa0a910b584b9c9f7adfb406948","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    protected void writeInternal(ObjectDataOutput out) throws IOException {\n        out.writeObject(backupOp);\n        originalCaller.writeData(out);\n        for (int i = 0; i < PartitionInfo.MAX_BACKUP_COUNT; i++) {\n            out.writeLong(replicaVersions[i]);\n        }\n        out.writeBoolean(sync);\n    }","id":99346,"modified_method":"@Override\n    protected void writeInternal(ObjectDataOutput out) throws IOException {\n        out.writeObject(backupOp);\n        if (originalCaller != null) {\n            out.writeBoolean(true);\n            originalCaller.writeData(out);\n        } else {\n            out.writeBoolean(false);\n        }\n        for (int i = 0; i < PartitionInfo.MAX_BACKUP_COUNT; i++) {\n            out.writeLong(replicaVersions[i]);\n        }\n        out.writeBoolean(sync);\n    }","commit_id":"46eb050c17e1daa0a910b584b9c9f7adfb406948","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private int sendBackups(BackupAwareOperation backupAwareOp) throws Exception {\n        final Operation op = (Operation) backupAwareOp;\n        final int maxBackups = node.getClusterService().getSize() - 1;\n        final int syncBackupCount = backupAwareOp.getSyncBackupCount() > 0\n                ? Math.min(maxBackups, backupAwareOp.getSyncBackupCount()) : 0;\n        final int asyncBackupCount = (backupAwareOp.getAsyncBackupCount() > 0 && maxBackups > syncBackupCount)\n                ? Math.min(maxBackups - syncBackupCount, backupAwareOp.getAsyncBackupCount()) : 0;\n\n        final int totalBackupCount = syncBackupCount + asyncBackupCount;\n        if (totalBackupCount > 0) {\n            final String serviceName = op.getServiceName();\n            final int partitionId = op.getPartitionId();\n            final PartitionServiceImpl partitionService = (PartitionServiceImpl) nodeEngine.getPartitionService();\n            final long[] replicaVersions = partitionService.incrementPartitionReplicaVersions(partitionId, totalBackupCount);\n            final PartitionInfo partitionInfo = partitionService.getPartitionInfo(partitionId);\n            for (int replicaIndex = 1; replicaIndex <= totalBackupCount; replicaIndex++) {\n                final Address target = partitionInfo.getReplicaAddress(replicaIndex);\n                if (target != null) {\n                    final Operation backupOp = backupAwareOp.getBackupOperation();\n                    if (backupOp == null) {\n                        throw new IllegalArgumentException(\"Backup operation should not be null!\");\n                    }\n                    if (target.equals(node.getThisAddress())) {\n                        throw new IllegalStateException(\"Normally shouldn't happen!!\");\n                    } else {\n                        backupOp.setPartitionId(partitionId).setReplicaIndex(replicaIndex).setServiceName(serviceName);\n                        Backup backup = new Backup(backupOp, op.getCallerAddress(), replicaVersions, replicaIndex <= syncBackupCount);\n                        backup.setPartitionId(partitionId).setReplicaIndex(replicaIndex).setServiceName(serviceName)\n                                .setCallerUuid(nodeEngine.getLocalMember().getUuid());\n                        OperationAccessor.setCallId(backup, op.getCallId());\n                        send(backup, target);\n                    }\n                }\n            }\n        }\n        return syncBackupCount;\n    }","id":99347,"modified_method":"private int sendBackups(BackupAwareOperation backupAwareOp) throws Exception {\n        final Operation op = (Operation) backupAwareOp;\n        boolean returnsResponse = op.returnsResponse();\n        final int maxBackups = node.getClusterService().getSize() - 1;\n\n        int syncBackupCount = backupAwareOp.getSyncBackupCount() > 0\n                ? Math.min(maxBackups, backupAwareOp.getSyncBackupCount()) : 0;\n\n        int asyncBackupCount = (backupAwareOp.getAsyncBackupCount() > 0 && maxBackups > syncBackupCount)\n                ? Math.min(maxBackups - syncBackupCount, backupAwareOp.getAsyncBackupCount()) : 0;\n\n        if (!returnsResponse) {\n            asyncBackupCount += syncBackupCount;\n            syncBackupCount = 0;\n        }\n\n        final int totalBackupCount = syncBackupCount + asyncBackupCount;\n        if (totalBackupCount > 0) {\n            final String serviceName = op.getServiceName();\n            final int partitionId = op.getPartitionId();\n            final PartitionServiceImpl partitionService = (PartitionServiceImpl) nodeEngine.getPartitionService();\n            final long[] replicaVersions = partitionService.incrementPartitionReplicaVersions(partitionId, totalBackupCount);\n            final PartitionInfo partitionInfo = partitionService.getPartitionInfo(partitionId);\n            for (int replicaIndex = 1; replicaIndex <= totalBackupCount; replicaIndex++) {\n                final Address target = partitionInfo.getReplicaAddress(replicaIndex);\n                if (target != null) {\n                    final Operation backupOp = backupAwareOp.getBackupOperation();\n                    if (backupOp == null) {\n                        throw new IllegalArgumentException(\"Backup operation should not be null!\");\n                    }\n                    if (target.equals(node.getThisAddress())) {\n                        throw new IllegalStateException(\"Normally shouldn't happen!!\");\n                    } else {\n                        backupOp.setPartitionId(partitionId).setReplicaIndex(replicaIndex).setServiceName(serviceName);\n                        Backup backup = new Backup(backupOp, op.getCallerAddress(), replicaVersions, replicaIndex <= syncBackupCount);\n                        backup.setPartitionId(partitionId).setReplicaIndex(replicaIndex).setServiceName(serviceName)\n                                .setCallerUuid(nodeEngine.getLocalMember().getUuid());\n                        OperationAccessor.setCallId(backup, op.getCallId());\n                        send(backup, target);\n                    }\n                }\n            }\n        }\n        return syncBackupCount;\n    }","commit_id":"46eb050c17e1daa0a910b584b9c9f7adfb406948","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void readData(ObjectDataInput in) throws IOException {\n        getCount.set(in.readLong());\n        putCount.set(in.readLong());\n        removeCount.set(in.readLong());\n        numberOfOtherOperations.set(in.readLong());\n        numberOfEvents.set(in.readLong());\n        lastAccessTime.set(in.readLong());\n        lastUpdateTime.set(in.readLong());\n        hits.set(in.readLong());\n        ownedEntryCount = in.readLong();\n        backupEntryCount = in.readLong();\n        backupCount = in.readInt();\n        ownedEntryMemoryCost = in.readLong();\n        backupEntryMemoryCost = in.readLong();\n        creationTime = in.readLong();\n        lockedEntryCount = in.readLong();\n        dirtyEntryCount = in.readLong();\n        totalGetLatencies.set(in.readLong());\n        totalPutLatencies.set(in.readLong());\n        totalRemoveLatencies.set(in.readLong());\n        maxGetLatency.set(in.readLong());\n        maxPutLatency.set(in.readLong());\n        maxRemoveLatency.set(in.readLong());\n        heapCost = in.readLong();\n        nearCacheStats = new NearCacheStatsImpl();\n        nearCacheStats.readData(in);\n    }","id":99348,"modified_method":"public void readData(ObjectDataInput in) throws IOException {\n        getCount.set(in.readLong());\n        putCount.set(in.readLong());\n        removeCount.set(in.readLong());\n        numberOfOtherOperations.set(in.readLong());\n        numberOfEvents.set(in.readLong());\n        lastAccessTime.set(in.readLong());\n        lastUpdateTime.set(in.readLong());\n        hits.set(in.readLong());\n        ownedEntryCount = in.readLong();\n        backupEntryCount = in.readLong();\n        backupCount = in.readInt();\n        ownedEntryMemoryCost = in.readLong();\n        backupEntryMemoryCost = in.readLong();\n        creationTime = in.readLong();\n        lockedEntryCount = in.readLong();\n        dirtyEntryCount = in.readLong();\n        totalGetLatencies.set(in.readLong());\n        totalPutLatencies.set(in.readLong());\n        totalRemoveLatencies.set(in.readLong());\n        maxGetLatency.set(in.readLong());\n        maxPutLatency.set(in.readLong());\n        maxRemoveLatency.set(in.readLong());\n        heapCost = in.readLong();\n        boolean hasNearCache = in.readBoolean();\n        if(hasNearCache)\n        {\n            nearCacheStats = new NearCacheStatsImpl();\n            nearCacheStats.readData(in);\n        }\n    }","commit_id":"a01ed9b33b8fedb5deb6ef7c5880e1245b3266b9","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void writeData(ObjectDataOutput out) throws IOException {\n        out.writeLong(getCount.get());\n        out.writeLong(putCount.get());\n        out.writeLong(removeCount.get());\n        out.writeLong(numberOfOtherOperations.get());\n        out.writeLong(numberOfEvents.get());\n        out.writeLong(lastAccessTime.get());\n        out.writeLong(lastUpdateTime.get());\n        out.writeLong(hits.get());\n        out.writeLong(ownedEntryCount);\n        out.writeLong(backupEntryCount);\n        out.writeInt(backupCount);\n        out.writeLong(ownedEntryMemoryCost);\n        out.writeLong(backupEntryMemoryCost);\n        out.writeLong(creationTime);\n        out.writeLong(lockedEntryCount);\n        out.writeLong(dirtyEntryCount);\n        out.writeLong(totalGetLatencies.get());\n        out.writeLong(totalPutLatencies.get());\n        out.writeLong(totalRemoveLatencies.get());\n        out.writeLong(maxGetLatency.get());\n        out.writeLong(maxPutLatency.get());\n        out.writeLong(maxRemoveLatency.get());\n        out.writeLong(heapCost);\n        nearCacheStats.writeData(out);\n    }","id":99349,"modified_method":"public void writeData(ObjectDataOutput out) throws IOException {\n        out.writeLong(getCount.get());\n        out.writeLong(putCount.get());\n        out.writeLong(removeCount.get());\n        out.writeLong(numberOfOtherOperations.get());\n        out.writeLong(numberOfEvents.get());\n        out.writeLong(lastAccessTime.get());\n        out.writeLong(lastUpdateTime.get());\n        out.writeLong(hits.get());\n        out.writeLong(ownedEntryCount);\n        out.writeLong(backupEntryCount);\n        out.writeInt(backupCount);\n        out.writeLong(ownedEntryMemoryCost);\n        out.writeLong(backupEntryMemoryCost);\n        out.writeLong(creationTime);\n        out.writeLong(lockedEntryCount);\n        out.writeLong(dirtyEntryCount);\n        out.writeLong(totalGetLatencies.get());\n        out.writeLong(totalPutLatencies.get());\n        out.writeLong(totalRemoveLatencies.get());\n        out.writeLong(maxGetLatency.get());\n        out.writeLong(maxPutLatency.get());\n        out.writeLong(maxRemoveLatency.get());\n        out.writeLong(heapCost);\n        boolean hasNearCache = nearCacheStats != null;\n        out.writeBoolean(hasNearCache);\n        if(hasNearCache)\n        {\n            nearCacheStats.writeData(out);\n        }\n    }","commit_id":"a01ed9b33b8fedb5deb6ef7c5880e1245b3266b9","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private NearCacheStatsImpl createNearCacheStats() {\n        long ownedEntryCount = 0;\n        long ownedEntryMemoryCost = 0;\n        int hits = 0;\n        for (CacheRecord record : cache.values())\n        {\n            ownedEntryCount++;\n            ownedEntryMemoryCost += record.getCost();\n            hits += record.hit.get();\n        }\n        stats.setOwnedEntryCount(ownedEntryCount);\n        stats.setOwnedEntryMemoryCost(ownedEntryMemoryCost);\n        stats.setHits(hits);\n        return stats;\n    }","id":99350,"modified_method":"private NearCacheStatsImpl createNearCacheStats() {\n        long ownedEntryCount = 0;\n        long ownedEntryMemoryCost = 0;\n        long hits = 0;\n        for (CacheRecord record : cache.values())\n        {\n            ownedEntryCount++;\n            ownedEntryMemoryCost += record.getCost();\n            hits += record.hit.get();\n        }\n        stats.setOwnedEntryCount(ownedEntryCount);\n        stats.setOwnedEntryMemoryCost(ownedEntryMemoryCost);\n        stats.setHits(hits);\n        return stats;\n    }","commit_id":"a01ed9b33b8fedb5deb6ef7c5880e1245b3266b9","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void writeData(ObjectDataOutput out) throws IOException {\n        out.writeLong(ownedEntryCount);\n        out.writeLong(ownedEntryMemoryCost);\n        out.writeLong(hits.get());\n        out.writeLong(misses.get());\n        out.writeDouble(ratio);\n    }","id":99351,"modified_method":"@Override\n    public void writeData(ObjectDataOutput out) throws IOException {\n        out.writeLong(ownedEntryCount);\n        out.writeLong(ownedEntryMemoryCost);\n        out.writeLong(hits.get());\n        out.writeLong(misses.get());\n    }","commit_id":"a01ed9b33b8fedb5deb6ef7c5880e1245b3266b9","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public String toString() {\n        return \"NearCacheStatsImpl{\" +\n                \"ownedEntryCount=\" + ownedEntryCount +\n                \", ownedEntryMemoryCost=\" + ownedEntryMemoryCost +\n                \", creationTime=\" + creationTime +\n                \", hits=\" + hits +\n                \", misses=\" + misses +\n                \", ratio=\" + ratio +\n                '}';\n    }","id":99352,"modified_method":"@Override\n    public String toString() {\n        return \"NearCacheStatsImpl{\" +\n                \"ownedEntryCount=\" + ownedEntryCount +\n                \", ownedEntryMemoryCost=\" + ownedEntryMemoryCost +\n                \", creationTime=\" + creationTime +\n                \", hits=\" + hits +\n                \", misses=\" + misses +\n                \", ratio=\" + getRatio() +\n                '}';\n    }","commit_id":"a01ed9b33b8fedb5deb6ef7c5880e1245b3266b9","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void readData(ObjectDataInput in) throws IOException {\n        this.ownedEntryCount = in.readLong();\n        this.ownedEntryMemoryCost = in.readLong();\n        this.hits.set(in.readLong());\n        this.misses.set(in.readLong());\n        this.ratio = in.readDouble();\n    }","id":99353,"modified_method":"@Override\n    public void readData(ObjectDataInput in) throws IOException {\n        this.ownedEntryCount = in.readLong();\n        this.ownedEntryMemoryCost = in.readLong();\n        this.hits.set(in.readLong());\n        this.misses.set(in.readLong());\n    }","commit_id":"a01ed9b33b8fedb5deb6ef7c5880e1245b3266b9","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void handle(MappingHttpRequest httpRequest) throws AuthenticationException\n\t{\n\t\tMap<String,String> parameters = httpRequest.getParameters( );\n\t\tString verb = httpRequest.getMethod().getName();\n\t\tString addr = httpRequest.getUri();\n\n\t\tif(httpRequest.containsHeader(StorageProperties.StorageParameters.EucaSignature.toString())) {\n\t\t\t//possible internal request -- perform authentication using internal credentials\n\t\t\tString date = httpRequest.getAndRemoveHeader(SecurityParameter.Date.toString());\n\t\t\tString signature = httpRequest.getAndRemoveHeader(StorageProperties.StorageParameters.EucaSignature.toString());\n\t\t\tString certString = null;\n\t\t\tif( httpRequest.containsHeader( StorageProperties.StorageParameters.EucaCert.toString( ) ) ) {\n\t\t\t\tcertString= httpRequest.getAndRemoveHeader(StorageProperties.StorageParameters.EucaCert.toString());\n\t\t\t}\n\t\t\tString data = verb + \"\\n\" + date + \"\\n\" + addr + \"\\n\";\n\n\t\t\tSignature sig;\n\t\t\tboolean valid = false;\n\t\t\ttry {\n\t\t\t\ttry {\n\t\t\t\t\tPublicKey publicKey = SystemCredentialProvider.getCredentialProvider(Component.storage).getCertificate().getPublicKey();\n\t\t\t\t\tsig = Signature.getInstance(\"SHA1withRSA\");\n\t\t\t\t\tsig.initVerify(publicKey);\n\t\t\t\t\tsig.update(data.getBytes());\n\t\t\t\t\tvalid = sig.verify(Base64.decode(signature));\n\t\t\t\t} catch ( Exception e ) {\n\t\t\t\t\tLOG.warn (\"Authentication: certificate not found in keystore\");\n\t\t\t\t} finally {\n\t\t\t\t\tif( !valid && certString != null ) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tX509Certificate nodeCert = Hashes.getPemCert( Base64.decode( certString ) );\n\t\t\t\t\t\t\tString alias = CredentialProvider.getCertificateAlias( nodeCert );\n\t\t\t\t\t\t\tPublicKey publicKey = nodeCert.getPublicKey( );\n\t\t\t\t\t\t\tsig = Signature.getInstance( \"SHA1withRSA\" );\n\t\t\t\t\t\t\tsig.initVerify( publicKey );\n\t\t\t\t\t\t\tsig.update( data.getBytes( ) );\n\t\t\t\t\t\t\tvalid = sig.verify( Base64.decode( signature ) );\n\t\t\t\t\t\t} catch ( Exception e2 ) {\n\t\t\t\t\t\t\tLOG.warn (\"Authentication exception: \" + e2.getMessage());\n\t\t\t\t\t\t}            \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (Exception ex) {\n\t\t\t\tLOG.warn (\"Authentication exception: \" + ex.getMessage());\n\t\t\t\tex.printStackTrace();\n\t\t\t}\n\n\t\t\tif(!valid) {\n\t\t\t\tthrow new AuthenticationException( \"User authentication failed.\" );\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tUser user = CredentialProvider.getUser( \"admin\" );\n\t\t\t\tuser.setIsAdministrator(true);\n\t\t\t\thttpRequest.setUser( user );\n\t\t\t} catch (NoSuchUserException e) {\n\t\t\t\tthrow new AuthenticationException( \"User authentication failed.\" );\n\t\t\t}  \n\t\t}  else {\n\t\t\t//external user request\n\t\t\tString content_md5 = httpRequest.getAndRemoveHeader(\"Content-MD5\");\n\t\t\tcontent_md5 = content_md5 == null ? \"\" : content_md5;\n\t\t\tString content_type = httpRequest.getHeader(WalrusProperties.CONTENT_TYPE);\n\t\t\tcontent_type = content_type == null ? \"\" : content_type;\n\n\t\t\tString targetHost = httpRequest.getHeader(HttpHeaders.Names.HOST);\n\t\t\tif(targetHost.contains(\".walrus\")) {\n\t\t\t\tString bucket = targetHost.substring(0, targetHost.indexOf(\".walrus\"));\n\t\t\t\taddr = \"/\" + bucket + addr;\n\t\t\t}\n\t\t\tString[] addrStrings = addr.split(\"\\\\?\");\n\t\t\tString addrString = addrStrings[0];\n\n\t\t\tif(addrStrings.length > 1) {\n\t\t\t\tfor(WalrusProperties.SubResource subResource : WalrusProperties.SubResource.values()) {\n\t\t\t\t\tif(addr.endsWith(subResource.toString().toLowerCase())) {\n\t\t\t\t\t\taddrString += \"?\" + subResource.toString().toLowerCase();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(httpRequest.containsHeader(SecurityParameter.Authorization.toString())) {\n\t\t\t\tString date;\n\t\t\t\tString verifyDate;\n\t\t\t\tif(httpRequest.containsHeader(\"x-amz-date\")) {\n\t\t\t\t\tdate = \"\";\n\t\t\t\t\tverifyDate = httpRequest.getHeader(\"x-amz-date\");\n\t\t\t\t} else {\n\t\t\t\t\tdate =  httpRequest.getAndRemoveHeader(SecurityParameter.Date.toString());\n\t\t\t\t\tverifyDate = date;\n\t\t\t\t\tif(date == null || date.length() <= 0)\n\t\t\t\t\t\tthrow new AuthenticationException(\"User authentication failed. Date must be specified.\");\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tDate dateToVerify = DateUtil.parseDate(verifyDate);\n\t\t\t\t\tDate currentDate = new Date();\n\t\t\t\t\tif(Math.abs(currentDate.getTime() - dateToVerify.getTime()) > EXPIRATION_LIMIT)\n\t\t\t\t\t\tthrow new AuthenticationException(\"Message expired. Sorry.\");\n\t\t\t\t} catch(Exception ex) {\n\t\t\t\t\tthrow new AuthenticationException(\"Unable to parse date.\");\n\t\t\t\t}\n\t\t\t\tString data = verb + \"\\n\" + content_md5 + \"\\n\" + content_type + \"\\n\" + date + \"\\n\" +  getCanonicalizedAmzHeaders(httpRequest) + addrString;\n\n\t\t\t\tString auth_part = httpRequest.getAndRemoveHeader(SecurityParameter.Authorization.toString());\n\t\t\t\tString sigString[] = getSigInfo(auth_part);\n\t\t\t\tString signature = sigString[1];\n\t\t\t\tauthenticate(httpRequest, sigString[0], signature, data);\n\t\t\t} else if(parameters.containsKey(SecurityParameter.AWSAccessKeyId.toString())) {\n\t\t\t\t//query string authentication\n\t\t\t\tString accesskeyid = parameters.remove(SecurityParameter.AWSAccessKeyId.toString());\n\t\t\t\ttry {\n\t\t\t\t\tString signature = WalrusUtil.URLdecode(parameters.remove(SecurityParameter.Signature.toString()));\n\t\t\t\t\tif(signature == null) {\n\t\t\t\t\t\tthrow new AuthenticationException(\"User authentication failed. Null signature.\");\n\t\t\t\t\t}\n\t\t\t\t\tString expires = parameters.remove(SecurityParameter.Expires.toString());\n\t\t\t\t\tif(expires == null) {\n\t\t\t\t\t\tthrow new AuthenticationException(\"Authentication failed. Expires must be specified.\");\n\t\t\t\t\t}\n\t\t\t\t\tif(checkExpires(expires)) {\n\t\t\t\t\t\tString stringToSign = verb + \"\\n\" + content_md5 + \"\\n\" + content_type + \"\\n\" + Long.parseLong(expires) + \"\\n\" + getCanonicalizedAmzHeaders(httpRequest) + addrString;\n\t\t\t\t\t\tauthenticate(httpRequest, accesskeyid, signature, stringToSign);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new AuthenticationException(\"Cannot process request. Expired.\");\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\tthrow new AuthenticationException(\"Could not verify request \" + ex.getMessage());\n\t\t\t\t}\n\t\t\t} else{\n\t\t\t\t//anonymous request              \n\t\t\t}\n\t\t}\n\t}","id":99354,"modified_method":"public void handle(MappingHttpRequest httpRequest) throws AuthenticationException\n\t{\n\t\tMap<String,String> parameters = httpRequest.getParameters( );\n\t\tString verb = httpRequest.getMethod().getName();\n\t\tString addr = httpRequest.getUri();\n\n\t\tif(httpRequest.containsHeader(StorageProperties.StorageParameters.EucaSignature.toString())) {\n\t\t\t//possible internal request -- perform authentication using internal credentials\n\t\t\tString date = httpRequest.getAndRemoveHeader(SecurityParameter.Date.toString());\n\t\t\tString signature = httpRequest.getAndRemoveHeader(StorageProperties.StorageParameters.EucaSignature.toString());\n\t\t\tString certString = null;\n\t\t\tif( httpRequest.containsHeader( StorageProperties.StorageParameters.EucaCert.toString( ) ) ) {\n\t\t\t\tcertString= httpRequest.getAndRemoveHeader(StorageProperties.StorageParameters.EucaCert.toString());\n\t\t\t}\n\t\t\tString data = verb + \"\\n\" + date + \"\\n\" + addr + \"\\n\";\n\n\t\t\tSignature sig;\n\t\t\tboolean valid = false;\n\t\t\ttry {\n\t\t\t\ttry {\n\t\t\t\t\tPublicKey publicKey = SystemCredentialProvider.getCredentialProvider(Component.storage).getCertificate().getPublicKey();\n\t\t\t\t\tsig = Signature.getInstance(\"SHA1withRSA\");\n\t\t\t\t\tsig.initVerify(publicKey);\n\t\t\t\t\tsig.update(data.getBytes());\n\t\t\t\t\tvalid = sig.verify(Base64.decode(signature));\n\t\t\t\t} catch ( Exception e ) {\n\t\t\t\t\tLOG.warn (\"Authentication: certificate not found in keystore\");\n\t\t\t\t} finally {\n\t\t\t\t\tif( !valid && certString != null ) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tX509Certificate nodeCert = Hashes.getPemCert( Base64.decode( certString ) );\n\t\t\t\t\t\t\tString alias = CredentialProvider.getCertificateAlias( nodeCert );\n\t\t\t\t\t\t\tPublicKey publicKey = nodeCert.getPublicKey( );\n\t\t\t\t\t\t\tsig = Signature.getInstance( \"SHA1withRSA\" );\n\t\t\t\t\t\t\tsig.initVerify( publicKey );\n\t\t\t\t\t\t\tsig.update( data.getBytes( ) );\n\t\t\t\t\t\t\tvalid = sig.verify( Base64.decode( signature ) );\n\t\t\t\t\t\t} catch ( Exception e2 ) {\n\t\t\t\t\t\t\tLOG.warn (\"Authentication exception: \" + e2.getMessage());\n\t\t\t\t\t\t}            \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (Exception ex) {\n\t\t\t\tLOG.warn (\"Authentication exception: \" + ex.getMessage());\n\t\t\t\tex.printStackTrace();\n\t\t\t}\n\n\t\t\tif(!valid) {\n\t\t\t\tthrow new AuthenticationException( \"User authentication failed.\" );\n\t\t\t}\n\t\t\tString effectiveUserID = httpRequest.getAndRemoveHeader(StorageProperties.StorageParameters.EucaEffectiveUserId.toString());\n\t\t\ttry {\n\t\t\t\tUser user = null;\n\t\t\t\tif(effectiveUserID != null) {\n\t\t\t\t\tuser = CredentialProvider.getUserFromQueryId(effectiveUserID);\n\t\t\t\t} else {\n\t\t\t\t\tuser = CredentialProvider.getUser( \"admin\" );\n\t\t\t\t\tuser.setIsAdministrator(true);\n\t\t\t\t}\n\t\t\t\thttpRequest.setUser( user );\n\t\t\t} catch (NoSuchUserException e) {\n\t\t\t\tthrow new AuthenticationException( \"User authentication failed.\" );\n\t\t\t}\n\t\t}  else {\n\t\t\t//external user request\n\t\t\tString content_md5 = httpRequest.getAndRemoveHeader(\"Content-MD5\");\n\t\t\tcontent_md5 = content_md5 == null ? \"\" : content_md5;\n\t\t\tString content_type = httpRequest.getHeader(WalrusProperties.CONTENT_TYPE);\n\t\t\tcontent_type = content_type == null ? \"\" : content_type;\n\n\t\t\tString targetHost = httpRequest.getHeader(HttpHeaders.Names.HOST);\n\t\t\tif(targetHost.contains(\".walrus\")) {\n\t\t\t\tString bucket = targetHost.substring(0, targetHost.indexOf(\".walrus\"));\n\t\t\t\taddr = \"/\" + bucket + addr;\n\t\t\t}\n\t\t\tString[] addrStrings = addr.split(\"\\\\?\");\n\t\t\tString addrString = addrStrings[0];\n\n\t\t\tif(addrStrings.length > 1) {\n\t\t\t\tfor(WalrusProperties.SubResource subResource : WalrusProperties.SubResource.values()) {\n\t\t\t\t\tif(addr.endsWith(subResource.toString().toLowerCase())) {\n\t\t\t\t\t\taddrString += \"?\" + subResource.toString().toLowerCase();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(httpRequest.containsHeader(SecurityParameter.Authorization.toString())) {\n\t\t\t\tString date;\n\t\t\t\tString verifyDate;\n\t\t\t\tif(httpRequest.containsHeader(\"x-amz-date\")) {\n\t\t\t\t\tdate = \"\";\n\t\t\t\t\tverifyDate = httpRequest.getHeader(\"x-amz-date\");\n\t\t\t\t} else {\n\t\t\t\t\tdate =  httpRequest.getAndRemoveHeader(SecurityParameter.Date.toString());\n\t\t\t\t\tverifyDate = date;\n\t\t\t\t\tif(date == null || date.length() <= 0)\n\t\t\t\t\t\tthrow new AuthenticationException(\"User authentication failed. Date must be specified.\");\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tDate dateToVerify = DateUtil.parseDate(verifyDate);\n\t\t\t\t\tDate currentDate = new Date();\n\t\t\t\t\tif(Math.abs(currentDate.getTime() - dateToVerify.getTime()) > EXPIRATION_LIMIT)\n\t\t\t\t\t\tthrow new AuthenticationException(\"Message expired. Sorry.\");\n\t\t\t\t} catch(Exception ex) {\n\t\t\t\t\tthrow new AuthenticationException(\"Unable to parse date.\");\n\t\t\t\t}\n\t\t\t\tString data = verb + \"\\n\" + content_md5 + \"\\n\" + content_type + \"\\n\" + date + \"\\n\" +  getCanonicalizedAmzHeaders(httpRequest) + addrString;\n\n\t\t\t\tString auth_part = httpRequest.getAndRemoveHeader(SecurityParameter.Authorization.toString());\n\t\t\t\tString sigString[] = getSigInfo(auth_part);\n\t\t\t\tString signature = sigString[1];\n\t\t\t\tauthenticate(httpRequest, sigString[0], signature, data);\n\t\t\t} else if(parameters.containsKey(SecurityParameter.AWSAccessKeyId.toString())) {\n\t\t\t\t//query string authentication\n\t\t\t\tString accesskeyid = parameters.remove(SecurityParameter.AWSAccessKeyId.toString());\n\t\t\t\ttry {\n\t\t\t\t\tString signature = WalrusUtil.URLdecode(parameters.remove(SecurityParameter.Signature.toString()));\n\t\t\t\t\tif(signature == null) {\n\t\t\t\t\t\tthrow new AuthenticationException(\"User authentication failed. Null signature.\");\n\t\t\t\t\t}\n\t\t\t\t\tString expires = parameters.remove(SecurityParameter.Expires.toString());\n\t\t\t\t\tif(expires == null) {\n\t\t\t\t\t\tthrow new AuthenticationException(\"Authentication failed. Expires must be specified.\");\n\t\t\t\t\t}\n\t\t\t\t\tif(checkExpires(expires)) {\n\t\t\t\t\t\tString stringToSign = verb + \"\\n\" + content_md5 + \"\\n\" + content_type + \"\\n\" + Long.parseLong(expires) + \"\\n\" + getCanonicalizedAmzHeaders(httpRequest) + addrString;\n\t\t\t\t\t\tauthenticate(httpRequest, accesskeyid, signature, stringToSign);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new AuthenticationException(\"Cannot process request. Expired.\");\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\tthrow new AuthenticationException(\"Could not verify request \" + ex.getMessage());\n\t\t\t\t}\n\t\t\t} else{\n\t\t\t\t//anonymous request              \n\t\t\t}\n\t\t}\n\t}","commit_id":"fed84cdfef80e0093162d00359f59cf27d7229a6","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void handle(MappingHttpRequest httpRequest) throws AuthenticationException\n\t{\n\t\tMap<String,String> parameters = httpRequest.getParameters( );\n\t\tString verb = httpRequest.getMethod().getName();\n\t\tString addr = httpRequest.getUri();\n\n\t\tif(httpRequest.containsHeader(StorageProperties.StorageParameters.EucaSignature.toString())) {\n\t\t\t//possible internal request -- perform authentication using internal credentials\n\t\t\tString date = httpRequest.getAndRemoveHeader(SecurityParameter.Date.toString());\n\t\t\tString signature = httpRequest.getAndRemoveHeader(StorageProperties.StorageParameters.EucaSignature.toString());\n\t\t\tString certString = null;\n\t\t\tif( httpRequest.containsHeader( StorageProperties.StorageParameters.EucaCert.toString( ) ) ) {\n\t\t\t\tcertString= httpRequest.getAndRemoveHeader(StorageProperties.StorageParameters.EucaCert.toString());\n\t\t\t}\n\t\t\tString data = verb + \"\\n\" + date + \"\\n\" + addr + \"\\n\";\n\n\t\t\tSignature sig;\n\t\t\tboolean valid = false;\n\t\t\ttry {\n\t\t\t\ttry {\n\t\t\t\t\tPublicKey publicKey = SystemCredentialProvider.getCredentialProvider(Component.storage).getCertificate().getPublicKey();\n\t\t\t\t\tsig = Signature.getInstance(\"SHA1withRSA\");\n\t\t\t\t\tsig.initVerify(publicKey);\n\t\t\t\t\tsig.update(data.getBytes());\n\t\t\t\t\tvalid = sig.verify(Base64.decode(signature));\n\t\t\t\t} catch ( Exception e ) {\n\t\t\t\t\tLOG.warn (\"Authentication: certificate not found in keystore\");\n\t\t\t\t} finally {\n\t\t\t\t\tif( !valid && certString != null ) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tX509Certificate nodeCert = Hashes.getPemCert( Base64.decode( certString ) );\n\t\t\t\t\t\t\tString alias = CredentialProvider.getCertificateAlias( nodeCert );\n\t\t\t\t\t\t\tPublicKey publicKey = nodeCert.getPublicKey( );\n\t\t\t\t\t\t\tsig = Signature.getInstance( \"SHA1withRSA\" );\n\t\t\t\t\t\t\tsig.initVerify( publicKey );\n\t\t\t\t\t\t\tsig.update( data.getBytes( ) );\n\t\t\t\t\t\t\tvalid = sig.verify( Base64.decode( signature ) );\n\t\t\t\t\t\t} catch ( Exception e2 ) {\n\t\t\t\t\t\t\tLOG.warn (\"Authentication exception: \" + e2.getMessage());\n\t\t\t\t\t\t}            \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (Exception ex) {\n\t\t\t\tLOG.warn (\"Authentication exception: \" + ex.getMessage());\n\t\t\t\tex.printStackTrace();\n\t\t\t}\n\n\t\t\tif(!valid) {\n\t\t\t\tthrow new AuthenticationException( \"User authentication failed.\" );\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tUser user = CredentialProvider.getUser( \"admin\" );\n\t\t\t\tuser.setIsAdministrator(true);\n\t\t\t\thttpRequest.setUser( user );\n\t\t\t} catch (NoSuchUserException e) {\n\t\t\t\tthrow new AuthenticationException( \"User authentication failed.\" );\n\t\t\t}  \n\t\t}  else {\n\t\t\t//external user request\n\t\t\tString content_md5 = httpRequest.getAndRemoveHeader(\"Content-MD5\");\n\t\t\tcontent_md5 = content_md5 == null ? \"\" : content_md5;\n\t\t\tString content_type = httpRequest.getHeader(WalrusProperties.CONTENT_TYPE);\n\t\t\tcontent_type = content_type == null ? \"\" : content_type;\n\n\t\t\tString targetHost = httpRequest.getHeader(HttpHeaders.Names.HOST);\n\t\t\tif(targetHost.contains(\".walrus\")) {\n\t\t\t\tString bucket = targetHost.substring(0, targetHost.indexOf(\".walrus\"));\n\t\t\t\taddr = \"/\" + bucket + addr;\n\t\t\t}\n\t\t\tString[] addrStrings = addr.split(\"\\\\?\");\n\t\t\tString addrString = addrStrings[0];\n\n\t\t\tif(addrStrings.length > 1) {\n\t\t\t\tfor(WalrusProperties.SubResource subResource : WalrusProperties.SubResource.values()) {\n\t\t\t\t\tif(addr.endsWith(subResource.toString().toLowerCase())) {\n\t\t\t\t\t\taddrString += \"?\" + subResource.toString().toLowerCase();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(httpRequest.containsHeader(SecurityParameter.Authorization.toString())) {\n\t\t\t\tString date;\n\t\t\t\tString verifyDate;\n\t\t\t\tif(httpRequest.containsHeader(\"x-amz-date\")) {\n\t\t\t\t\tdate = \"\";\n\t\t\t\t\tverifyDate = httpRequest.getHeader(\"x-amz-date\");\n\t\t\t\t} else {\n\t\t\t\t\tdate =  httpRequest.getAndRemoveHeader(SecurityParameter.Date.toString());\n\t\t\t\t\tverifyDate = date;\n\t\t\t\t\tif(date == null || date.length() <= 0)\n\t\t\t\t\t\tthrow new AuthenticationException(\"User authentication failed. Date must be specified.\");\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tDate dateToVerify = DateUtil.parseDate(verifyDate);\n\t\t\t\t\tDate currentDate = new Date();\n\t\t\t\t\tif(Math.abs(currentDate.getTime() - dateToVerify.getTime()) > EXPIRATION_LIMIT)\n\t\t\t\t\t\tthrow new AuthenticationException(\"Message expired. Sorry.\");\n\t\t\t\t} catch(Exception ex) {\n\t\t\t\t\tthrow new AuthenticationException(\"Unable to parse date.\");\n\t\t\t\t}\n\t\t\t\tString data = verb + \"\\n\" + content_md5 + \"\\n\" + content_type + \"\\n\" + date + \"\\n\" +  getCanonicalizedAmzHeaders(httpRequest) + addrString;\n\n\t\t\t\tString auth_part = httpRequest.getAndRemoveHeader(SecurityParameter.Authorization.toString());\n\t\t\t\tString sigString[] = getSigInfo(auth_part);\n\t\t\t\tString signature = sigString[1];\n\t\t\t\tauthenticate(httpRequest, sigString[0], signature, data);\n\t\t\t} else if(parameters.containsKey(SecurityParameter.AWSAccessKeyId.toString())) {\n\t\t\t\t//query string authentication\n\t\t\t\tString accesskeyid = parameters.remove(SecurityParameter.AWSAccessKeyId.toString());\n\t\t\t\ttry {\n\t\t\t\t\tString signature = WalrusUtil.URLdecode(parameters.remove(SecurityParameter.Signature.toString()));\n\t\t\t\t\tif(signature == null) {\n\t\t\t\t\t\tthrow new AuthenticationException(\"User authentication failed. Null signature.\");\n\t\t\t\t\t}\n\t\t\t\t\tString expires = parameters.remove(SecurityParameter.Expires.toString());\n\t\t\t\t\tif(expires == null) {\n\t\t\t\t\t\tthrow new AuthenticationException(\"Authentication failed. Expires must be specified.\");\n\t\t\t\t\t}\n\t\t\t\t\tif(checkExpires(expires)) {\n\t\t\t\t\t\tString stringToSign = verb + \"\\n\" + content_md5 + \"\\n\" + content_type + \"\\n\" + Long.parseLong(expires) + \"\\n\" + getCanonicalizedAmzHeaders(httpRequest) + addrString;\n\t\t\t\t\t\tauthenticate(httpRequest, accesskeyid, signature, stringToSign);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new AuthenticationException(\"Cannot process request. Expired.\");\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\tthrow new AuthenticationException(\"Could not verify request \" + ex.getMessage());\n\t\t\t\t}\n\t\t\t} else{\n\t\t\t\t//anonymous request              \n\t\t\t}\n\t\t}\n\t}","id":99355,"modified_method":"public void handle(MappingHttpRequest httpRequest) throws AuthenticationException\n\t{\n\t\tMap<String,String> parameters = httpRequest.getParameters( );\n\t\tString verb = httpRequest.getMethod().getName();\n\t\tString addr = httpRequest.getUri();\n\n\t\tif(httpRequest.containsHeader(StorageProperties.StorageParameters.EucaSignature.toString())) {\n\t\t\t//possible internal request -- perform authentication using internal credentials\n\t\t\tString date = httpRequest.getAndRemoveHeader(SecurityParameter.Date.toString());\n\t\t\tString signature = httpRequest.getAndRemoveHeader(StorageProperties.StorageParameters.EucaSignature.toString());\n\t\t\tString certString = null;\n\t\t\tif( httpRequest.containsHeader( StorageProperties.StorageParameters.EucaCert.toString( ) ) ) {\n\t\t\t\tcertString= httpRequest.getAndRemoveHeader(StorageProperties.StorageParameters.EucaCert.toString());\n\t\t\t}\n\t\t\tString data = verb + \"\\n\" + date + \"\\n\" + addr + \"\\n\";\n\n\t\t\tSignature sig;\n\t\t\tboolean valid = false;\n\t\t\ttry {\n\t\t\t\ttry {\n\t\t\t\t\tPublicKey publicKey = SystemCredentialProvider.getCredentialProvider(Component.storage).getCertificate().getPublicKey();\n\t\t\t\t\tsig = Signature.getInstance(\"SHA1withRSA\");\n\t\t\t\t\tsig.initVerify(publicKey);\n\t\t\t\t\tsig.update(data.getBytes());\n\t\t\t\t\tvalid = sig.verify(Base64.decode(signature));\n\t\t\t\t} catch ( Exception e ) {\n\t\t\t\t\tLOG.warn (\"Authentication: certificate not found in keystore\");\n\t\t\t\t} finally {\n\t\t\t\t\tif( !valid && certString != null ) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tX509Certificate nodeCert = Hashes.getPemCert( Base64.decode( certString ) );\n\t\t\t\t\t\t\tString alias = CredentialProvider.getCertificateAlias( nodeCert );\n\t\t\t\t\t\t\tPublicKey publicKey = nodeCert.getPublicKey( );\n\t\t\t\t\t\t\tsig = Signature.getInstance( \"SHA1withRSA\" );\n\t\t\t\t\t\t\tsig.initVerify( publicKey );\n\t\t\t\t\t\t\tsig.update( data.getBytes( ) );\n\t\t\t\t\t\t\tvalid = sig.verify( Base64.decode( signature ) );\n\t\t\t\t\t\t} catch ( Exception e2 ) {\n\t\t\t\t\t\t\tLOG.warn (\"Authentication exception: \" + e2.getMessage());\n\t\t\t\t\t\t}            \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (Exception ex) {\n\t\t\t\tLOG.warn (\"Authentication exception: \" + ex.getMessage());\n\t\t\t\tex.printStackTrace();\n\t\t\t}\n\n\t\t\tif(!valid) {\n\t\t\t\tthrow new AuthenticationException( \"User authentication failed.\" );\n\t\t\t}\n\t\t\tString effectiveUserID = httpRequest.getAndRemoveHeader(StorageProperties.StorageParameters.EucaEffectiveUserId.toString());\n\t\t\ttry {\n\t\t\t\tUser user = null;\n\t\t\t\tif(effectiveUserID != null) {\n\t\t\t\t\tuser = CredentialProvider.getUserFromQueryId(effectiveUserID);\n\t\t\t\t} else {\n\t\t\t\t\tuser = CredentialProvider.getUser( \"admin\" );\n\t\t\t\t\tuser.setIsAdministrator(true);\n\t\t\t\t}\n\t\t\t\thttpRequest.setUser( user );\n\t\t\t} catch (NoSuchUserException e) {\n\t\t\t\tthrow new AuthenticationException( \"User authentication failed.\" );\n\t\t\t}\n\t\t}  else {\n\t\t\t//external user request\n\t\t\tString content_md5 = httpRequest.getAndRemoveHeader(\"Content-MD5\");\n\t\t\tcontent_md5 = content_md5 == null ? \"\" : content_md5;\n\t\t\tString content_type = httpRequest.getHeader(WalrusProperties.CONTENT_TYPE);\n\t\t\tcontent_type = content_type == null ? \"\" : content_type;\n\n\t\t\tString targetHost = httpRequest.getHeader(HttpHeaders.Names.HOST);\n\t\t\tif(targetHost.contains(\".walrus\")) {\n\t\t\t\tString bucket = targetHost.substring(0, targetHost.indexOf(\".walrus\"));\n\t\t\t\taddr = \"/\" + bucket + addr;\n\t\t\t}\n\t\t\tString[] addrStrings = addr.split(\"\\\\?\");\n\t\t\tString addrString = addrStrings[0];\n\n\t\t\tif(addrStrings.length > 1) {\n\t\t\t\tfor(WalrusProperties.SubResource subResource : WalrusProperties.SubResource.values()) {\n\t\t\t\t\tif(addr.endsWith(subResource.toString().toLowerCase())) {\n\t\t\t\t\t\taddrString += \"?\" + subResource.toString().toLowerCase();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(httpRequest.containsHeader(SecurityParameter.Authorization.toString())) {\n\t\t\t\tString date;\n\t\t\t\tString verifyDate;\n\t\t\t\tif(httpRequest.containsHeader(\"x-amz-date\")) {\n\t\t\t\t\tdate = \"\";\n\t\t\t\t\tverifyDate = httpRequest.getHeader(\"x-amz-date\");\n\t\t\t\t} else {\n\t\t\t\t\tdate =  httpRequest.getAndRemoveHeader(SecurityParameter.Date.toString());\n\t\t\t\t\tverifyDate = date;\n\t\t\t\t\tif(date == null || date.length() <= 0)\n\t\t\t\t\t\tthrow new AuthenticationException(\"User authentication failed. Date must be specified.\");\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tDate dateToVerify = DateUtil.parseDate(verifyDate);\n\t\t\t\t\tDate currentDate = new Date();\n\t\t\t\t\tif(Math.abs(currentDate.getTime() - dateToVerify.getTime()) > EXPIRATION_LIMIT)\n\t\t\t\t\t\tthrow new AuthenticationException(\"Message expired. Sorry.\");\n\t\t\t\t} catch(Exception ex) {\n\t\t\t\t\tthrow new AuthenticationException(\"Unable to parse date.\");\n\t\t\t\t}\n\t\t\t\tString data = verb + \"\\n\" + content_md5 + \"\\n\" + content_type + \"\\n\" + date + \"\\n\" +  getCanonicalizedAmzHeaders(httpRequest) + addrString;\n\n\t\t\t\tString auth_part = httpRequest.getAndRemoveHeader(SecurityParameter.Authorization.toString());\n\t\t\t\tString sigString[] = getSigInfo(auth_part);\n\t\t\t\tString signature = sigString[1];\n\t\t\t\tauthenticate(httpRequest, sigString[0], signature, data);\n\t\t\t} else if(parameters.containsKey(SecurityParameter.AWSAccessKeyId.toString())) {\n\t\t\t\t//query string authentication\n\t\t\t\tString accesskeyid = parameters.remove(SecurityParameter.AWSAccessKeyId.toString());\n\t\t\t\ttry {\n\t\t\t\t\tString signature = WalrusUtil.URLdecode(parameters.remove(SecurityParameter.Signature.toString()));\n\t\t\t\t\tif(signature == null) {\n\t\t\t\t\t\tthrow new AuthenticationException(\"User authentication failed. Null signature.\");\n\t\t\t\t\t}\n\t\t\t\t\tString expires = parameters.remove(SecurityParameter.Expires.toString());\n\t\t\t\t\tif(expires == null) {\n\t\t\t\t\t\tthrow new AuthenticationException(\"Authentication failed. Expires must be specified.\");\n\t\t\t\t\t}\n\t\t\t\t\tif(checkExpires(expires)) {\n\t\t\t\t\t\tString stringToSign = verb + \"\\n\" + content_md5 + \"\\n\" + content_type + \"\\n\" + Long.parseLong(expires) + \"\\n\" + getCanonicalizedAmzHeaders(httpRequest) + addrString;\n\t\t\t\t\t\tauthenticate(httpRequest, accesskeyid, signature, stringToSign);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new AuthenticationException(\"Cannot process request. Expired.\");\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\tthrow new AuthenticationException(\"Could not verify request \" + ex.getMessage());\n\t\t\t\t}\n\t\t\t} else{\n\t\t\t\t//anonymous request              \n\t\t\t}\n\t\t}\n\t}","commit_id":"c3e3215ec359df5ec230fac683363f69eb4c0712","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static boolean sakaiInfo(Properties props, String context, String placementId, ResourceLoader rb)\n   {\n\n        Site site = null;\n        try {\n\t\tsite = SiteService.getSite(context);\n        } catch (Exception e) {\n                dPrint(\"No site/page associated with Launch context=\"+context);\n                return false;\n\t}\n                \n\tUser user = UserDirectoryService.getCurrentUser();\n\n\t// Get the placement to see if we are to release information\n        ToolConfiguration placement = SiteService.findTool(placementId);\n\tProperties config = placement.getConfig();\n\n\t// Start setting the Basici LTI parameters\n\tsetProperty(props,BasicLTIConstants.RESOURCE_LINK_ID,placementId);\n        String pagetitle = toNull(getCorrectProperty(config,\"pagetitle\", placement));\n\tif ( pagetitle != null ) setProperty(props,BasicLTIConstants.RESOURCE_LINK_TITLE,pagetitle);\n        String tooltitle = toNull(getCorrectProperty(config,\"tooltitle\", placement));\n\tif ( tooltitle != null ) setProperty(props,BasicLTIConstants.RESOURCE_LINK_DESCRIPTION,tooltitle);\n\n        String releasename = toNull(getCorrectProperty(config,\"releasename\", placement));\n        String releaseemail = toNull(getCorrectProperty(config,\"releaseemail\", placement));\n\n\t// TODO: Think about anonymus\n\tif ( user != null )\n\t{\n\t\tsetProperty(props,BasicLTIConstants.USER_ID,user.getId());\n\t\tsetProperty(props,BasicLTIConstants.LAUNCH_PRESENTATION_LOCALE,rb.getLocale().toString()); \n\t\tif ( \"on\".equals(releasename) ) {\n\t\t\tsetProperty(props,BasicLTIConstants.LIS_PERSON_NAME_GIVEN,user.getFirstName());\n\t\t\tsetProperty(props,BasicLTIConstants.LIS_PERSON_NAME_FAMILY,user.getLastName());\n\t\t\tsetProperty(props,BasicLTIConstants.LIS_PERSON_NAME_FULL,user.getDisplayName());\n\t\t}\n\t\tif ( \"on\".equals(releaseemail) ) {\n\t\t\tsetProperty(props,BasicLTIConstants.LIS_PERSON_CONTACT_EMAIL_PRIMARY,user.getEmail());\n\t\t\tsetProperty(props,BasicLTIConstants.LIS_PERSON_SOURCEDID,user.getEid());\n\t\t}\n \n\t        String assignment = toNull(getCorrectProperty(config,\"assignment\", placement));\n\n\t\tString placementSecret = toNull(getCorrectProperty(config,\"placementsecret\", placement));\n                String allowOutcomes = ServerConfigurationService.getString(\n                                SakaiBLTIUtil.BASICLTI_OUTCOMES_ENABLED, null);\n                if ( ! \"true\".equals(allowOutcomes) ) allowOutcomes = null;\n\n\t        String allowSettings = toNull(getCorrectProperty(config,\"allowsettings\", placement));\n                if ( ! \"on\".equals(allowSettings) ) allowSettings = null;\n\n\t        String allowRoster = toNull(getCorrectProperty(config,\"allowroster\", placement));\n                if ( ! \"on\".equals(allowRoster) ) allowRoster = null;\n\n\t\tif ( placementSecret != null ) {\n\t\t\tString suffix = \":::\" +  user.getId() + \":::\" + placement.getId();\n\t\t\tString base_string = placementSecret + suffix;\n\t\t\tString signature = ShaUtil.sha256Hash(base_string);\n\t\t\tString result_sourcedid = signature + suffix;\n\n                \tif ( \"true\".equals(allowOutcomes) && assignment != null ) {\n\t\t\t\tsetProperty(props,\"lis_result_sourcedid\", result_sourcedid);  \n\t\n\t\t\t\t// TODO: Remove this after the switch to Basic Outcomes\n\t\t\t\tString outcome_url = ServerConfigurationService.getString(\"basiclti.consumer.ext_ims_lis_simple_outcome_url\",null);\n        \t\t\tif ( outcome_url == null ) outcome_url = getOurServerUrl() + \"/imsblis/outcomes/\";  \n\t\t\t\tsetProperty(props,\"ext_ims_lis_simple_outcome_url\", outcome_url);  \n\n\t\t\t\t// New Basic Outcomes URL\n\t\t\t\toutcome_url = ServerConfigurationService.getString(\"basiclti.consumer.ext_ims_lis_basic_outcome_url\",null);\n        \t\t\tif ( outcome_url == null ) outcome_url = getOurServerUrl() + \"/imsblis/service/\";  \n\t\t\t\tsetProperty(props,\"ext_ims_lis_basic_outcome_url\", outcome_url);  \n\t\n\t\t\t}\n\n                \tif ( \"on\".equals(allowSettings) ) {\n\t\t\t\tsetProperty(props,\"ext_ims_lti_tool_setting_id\", result_sourcedid);  \n\t\n\t\t\t\tString setting = config.getProperty(\"toolsetting\", null);\n\t\t\t\tif ( setting != null ) {\n\t\t\t\t\tsetProperty(props,\"ext_ims_lti_tool_setting\", setting);  \n\t\t\t\t}\n\t\t\t\tString service_url = ServerConfigurationService.getString(\"basiclti.consumer.ext_ims_lti_tool_setting_url\",null);\n        \t\t\tif ( service_url == null ) service_url = getOurServerUrl() + \"/imsblis/service/\";  \n\t\t\t\tsetProperty(props,\"ext_ims_lti_tool_setting_url\", service_url);  \n\t\t\t}\n\n                \tif ( \"on\".equals(allowRoster) ) {\n\t\t\t\tsetProperty(props,\"ext_ims_lis_memberships_id\", result_sourcedid);  \n\n\t\t\t\tString roster_url = ServerConfigurationService.getString(\"basiclti.consumer.ext_ims_lis_memberships_url\",null);\n        \t\t\tif ( roster_url == null ) roster_url = getOurServerUrl() + \"/imsblis/service/\";  \n\t\t\t\tsetProperty(props,\"ext_ims_lis_memberships_url\", roster_url);  \n\t\t\t}\n\t\t}\n\t}\n\n\tString theRole = \"Learner\";\n\tif ( SecurityService.isSuperUser() )\n\t{\n\t\ttheRole = \"Instructor\";\n\t}\n\telse if ( SiteService.allowUpdateSite(context) ) \n\t{\n\t\ttheRole = \"Instructor\";\n\t}\n\tsetProperty(props,\"roles\",theRole);\n\n\tif ( site != null ) {\n\t\tString context_type = site.getType();\n\t\tif ( context_type != null && context_type.toLowerCase().contains(\"course\") ){\n\t\t\tsetProperty(props,BasicLTIConstants.CONTEXT_TYPE,BasicLTIConstants.CONTEXT_TYPE_COURSE_SECTION);\n\t\t}\n\t\tsetProperty(props,BasicLTIConstants.CONTEXT_ID,site.getId());\n\t\tsetProperty(props,BasicLTIConstants.CONTEXT_LABEL,site.getTitle());\n\t\tsetProperty(props,BasicLTIConstants.CONTEXT_TITLE,site.getTitle());\n\t\tString courseRoster = getExternalRealmId(site.getId());\n\t\tif ( courseRoster != null ) \n\t\t{\n\t\t\tsetProperty(props,BasicLTIConstants.LIS_COURSE_OFFERING_SOURCEDID,courseRoster);\n\t\t}\n\t}\n\n\n        // Sakai-Unique fields - compatible with LinkTool\n        Session s = SessionManager.getCurrentSession();\n        if (s != null) {\n                String sessionid = s.getId();\n                if (sessionid != null) {\n                        sessionid = LinkToolUtil.encrypt(sessionid);\n                        setProperty(props,\"ext_sakai_session\",sessionid);\n                }\n        }\n\n\t// We pass this along in the Sakai world - it might\n\t// might be useful to the external tool\n\tString serverId = ServerConfigurationService.getServerId();\n\tsetProperty(props,\"ext_sakai_serverid\",serverId);\n        setProperty(props,\"ext_sakai_server\",getOurServerUrl());\n\n\t// Get the organizational information\n\tsetProperty(props,BasicLTIConstants.TOOL_CONSUMER_INSTANCE_GUID, \n\t\tServerConfigurationService.getString(\"basiclti.consumer_instance_guid\",null));\n\tsetProperty(props,BasicLTIConstants.TOOL_CONSUMER_INSTANCE_NAME, \n\t\tServerConfigurationService.getString(\"basiclti.consumer_instance_name\",null));\n\tsetProperty(props,BasicLTIConstants.TOOL_CONSUMER_INSTANCE_DESCRIPTION, \n\t\tServerConfigurationService.getString(\"basiclti.consumer_instance_description\",null));\n\tsetProperty(props,BasicLTIConstants.TOOL_CONSUMER_INSTANCE_CONTACT_EMAIL, \n\t\tServerConfigurationService.getString(\"basiclti.consumer_instance_contact_email\",null));\n\tsetProperty(props,BasicLTIConstants.TOOL_CONSUMER_INSTANCE_URL, \n\t\tServerConfigurationService.getString(\"basiclti.consumer_instance_url\",null));\n\tsetProperty(props,BasicLTIConstants.LAUNCH_PRESENTATION_RETURN_URL, \n\t\tServerConfigurationService.getString(\"basiclti.consumer_return_url\",null));\n\n\t// Send along the content link\n        String contentlink = toNull(getCorrectProperty(config,\"contentlink\", placement));\n\tif ( contentlink != null ) setProperty(props,\"ext_resource_link_content\",contentlink);\n\n\t// Send along the CSS URL\n\tString tool_css = ServerConfigurationService.getString(\"basiclti.consumer.launch_presentation_css_url\",null);\n        if ( tool_css == null ) tool_css = getOurServerUrl() + \"/library/skin/default/tool.css\";  \n\tsetProperty(props,BasicLTIConstants.LAUNCH_PRESENTATION_CSS_URL, tool_css);  \n\n\t// Let tools know we are coming from Sakai\n\tsetProperty(props,\"ext_lms\", \"sakai2\");  \n\treturn true;\n    }","id":99356,"modified_method":"public static boolean sakaiInfo(Properties props, String context, String placementId, ResourceLoader rb)\n   {\n\n        Site site = null;\n        try {\n\t\tsite = SiteService.getSite(context);\n        } catch (Exception e) {\n                dPrint(\"No site/page associated with Launch context=\"+context);\n                return false;\n\t}\n                \n\tUser user = UserDirectoryService.getCurrentUser();\n\n\t// Get the placement to see if we are to release information\n        ToolConfiguration placement = SiteService.findTool(placementId);\n\tProperties config = placement.getConfig();\n\n\t// Start setting the Basici LTI parameters\n\tsetProperty(props,BasicLTIConstants.RESOURCE_LINK_ID,placementId);\n        String pagetitle = toNull(getCorrectProperty(config,\"pagetitle\", placement));\n\tif ( pagetitle != null ) setProperty(props,BasicLTIConstants.RESOURCE_LINK_TITLE,pagetitle);\n        String tooltitle = toNull(getCorrectProperty(config,\"tooltitle\", placement));\n\tif ( tooltitle != null ) setProperty(props,BasicLTIConstants.RESOURCE_LINK_DESCRIPTION,tooltitle);\n\n        String releasename = toNull(getCorrectProperty(config,\"releasename\", placement));\n        String releaseemail = toNull(getCorrectProperty(config,\"releaseemail\", placement));\n\n\t// TODO: Think about anonymus\n\tif ( user != null )\n\t{\n\t\tsetProperty(props,BasicLTIConstants.USER_ID,user.getId());\n\t\tsetProperty(props,BasicLTIConstants.LAUNCH_PRESENTATION_LOCALE,rb.getLocale().toString()); \n\t\tif ( \"on\".equals(releasename) ) {\n\t\t\tsetProperty(props,BasicLTIConstants.LIS_PERSON_NAME_GIVEN,user.getFirstName());\n\t\t\tsetProperty(props,BasicLTIConstants.LIS_PERSON_NAME_FAMILY,user.getLastName());\n\t\t\tsetProperty(props,BasicLTIConstants.LIS_PERSON_NAME_FULL,user.getDisplayName());\n\t\t}\n\t\tif ( \"on\".equals(releaseemail) ) {\n\t\t\tsetProperty(props,BasicLTIConstants.LIS_PERSON_CONTACT_EMAIL_PRIMARY,user.getEmail());\n\t\t\tsetProperty(props,BasicLTIConstants.LIS_PERSON_SOURCEDID,user.getEid());\n\t\t}\n \n\t        String assignment = toNull(getCorrectProperty(config,\"assignment\", placement));\n                String allowOutcomes = ServerConfigurationService.getString(\n                                SakaiBLTIUtil.BASICLTI_OUTCOMES_ENABLED, null);\n                if ( ! \"true\".equals(allowOutcomes) ) allowOutcomes = null;\n\n\t        String allowSettings = toNull(getCorrectProperty(config,\"allowsettings\", placement));\n                if ( ! \"on\".equals(allowSettings) ) allowSettings = null;\n\n\t        String allowRoster = toNull(getCorrectProperty(config,\"allowroster\", placement));\n                if ( ! \"on\".equals(allowRoster) ) allowRoster = null;\n\n\t\tString result_sourcedid = getSourceDID(user, placement, config);\n\t\tif ( result_sourcedid != null ) {\n\n                \tif ( \"true\".equals(allowOutcomes) && assignment != null ) {\n\t\t\t\tsetProperty(props,\"lis_result_sourcedid\", result_sourcedid);  \n\t\n\t\t\t\t// TODO: Remove this after the switch to Basic Outcomes\n\t\t\t\tString outcome_url = ServerConfigurationService.getString(\"basiclti.consumer.ext_ims_lis_simple_outcome_url\",null);\n        \t\t\tif ( outcome_url == null ) outcome_url = getOurServerUrl() + \"/imsblis/outcomes/\";  \n\t\t\t\tsetProperty(props,\"ext_ims_lis_simple_outcome_url\", outcome_url);  \n\n\t\t\t\t// New Basic Outcomes URL\n\t\t\t\toutcome_url = ServerConfigurationService.getString(\"basiclti.consumer.ext_ims_lis_basic_outcome_url\",null);\n        \t\t\tif ( outcome_url == null ) outcome_url = getOurServerUrl() + \"/imsblis/service/\";  \n\t\t\t\tsetProperty(props,\"ext_ims_lis_basic_outcome_url\", outcome_url);  \n\t\n\t\t\t}\n\n                \tif ( \"on\".equals(allowSettings) ) {\n\t\t\t\tsetProperty(props,\"ext_ims_lti_tool_setting_id\", result_sourcedid);  \n\t\n\t\t\t\tString setting = config.getProperty(\"toolsetting\", null);\n\t\t\t\tif ( setting != null ) {\n\t\t\t\t\tsetProperty(props,\"ext_ims_lti_tool_setting\", setting);  \n\t\t\t\t}\n\t\t\t\tString service_url = ServerConfigurationService.getString(\"basiclti.consumer.ext_ims_lti_tool_setting_url\",null);\n        \t\t\tif ( service_url == null ) service_url = getOurServerUrl() + \"/imsblis/service/\";  \n\t\t\t\tsetProperty(props,\"ext_ims_lti_tool_setting_url\", service_url);  \n\t\t\t}\n\n                \tif ( \"on\".equals(allowRoster) ) {\n\t\t\t\tsetProperty(props,\"ext_ims_lis_memberships_id\", result_sourcedid);  \n\n\t\t\t\tString roster_url = ServerConfigurationService.getString(\"basiclti.consumer.ext_ims_lis_memberships_url\",null);\n        \t\t\tif ( roster_url == null ) roster_url = getOurServerUrl() + \"/imsblis/service/\";  \n\t\t\t\tsetProperty(props,\"ext_ims_lis_memberships_url\", roster_url);  \n\t\t\t}\n\t\t}\n\t}\n\n\tString theRole = \"Learner\";\n\tif ( SecurityService.isSuperUser() )\n\t{\n\t\ttheRole = \"Instructor\";\n\t}\n\telse if ( SiteService.allowUpdateSite(context) ) \n\t{\n\t\ttheRole = \"Instructor\";\n\t}\n\tsetProperty(props,\"roles\",theRole);\n\n\tif ( site != null ) {\n\t\tString context_type = site.getType();\n\t\tif ( context_type != null && context_type.toLowerCase().contains(\"course\") ){\n\t\t\tsetProperty(props,BasicLTIConstants.CONTEXT_TYPE,BasicLTIConstants.CONTEXT_TYPE_COURSE_SECTION);\n\t\t}\n\t\tsetProperty(props,BasicLTIConstants.CONTEXT_ID,site.getId());\n\t\tsetProperty(props,BasicLTIConstants.CONTEXT_LABEL,site.getTitle());\n\t\tsetProperty(props,BasicLTIConstants.CONTEXT_TITLE,site.getTitle());\n\t\tString courseRoster = getExternalRealmId(site.getId());\n\t\tif ( courseRoster != null ) \n\t\t{\n\t\t\tsetProperty(props,BasicLTIConstants.LIS_COURSE_OFFERING_SOURCEDID,courseRoster);\n\t\t}\n\t}\n\n\n        // Sakai-Unique fields - compatible with LinkTool\n        Session s = SessionManager.getCurrentSession();\n        if (s != null) {\n                String sessionid = s.getId();\n                if (sessionid != null) {\n                        sessionid = LinkToolUtil.encrypt(sessionid);\n                        setProperty(props,\"ext_sakai_session\",sessionid);\n                }\n        }\n\n\t// We pass this along in the Sakai world - it might\n\t// might be useful to the external tool\n\tString serverId = ServerConfigurationService.getServerId();\n\tsetProperty(props,\"ext_sakai_serverid\",serverId);\n        setProperty(props,\"ext_sakai_server\",getOurServerUrl());\n\n\t// Get the organizational information\n\tsetProperty(props,BasicLTIConstants.TOOL_CONSUMER_INSTANCE_GUID, \n\t\tServerConfigurationService.getString(\"basiclti.consumer_instance_guid\",null));\n\tsetProperty(props,BasicLTIConstants.TOOL_CONSUMER_INSTANCE_NAME, \n\t\tServerConfigurationService.getString(\"basiclti.consumer_instance_name\",null));\n\tsetProperty(props,BasicLTIConstants.TOOL_CONSUMER_INSTANCE_DESCRIPTION, \n\t\tServerConfigurationService.getString(\"basiclti.consumer_instance_description\",null));\n\tsetProperty(props,BasicLTIConstants.TOOL_CONSUMER_INSTANCE_CONTACT_EMAIL, \n\t\tServerConfigurationService.getString(\"basiclti.consumer_instance_contact_email\",null));\n\tsetProperty(props,BasicLTIConstants.TOOL_CONSUMER_INSTANCE_URL, \n\t\tServerConfigurationService.getString(\"basiclti.consumer_instance_url\",null));\n\tsetProperty(props,BasicLTIConstants.LAUNCH_PRESENTATION_RETURN_URL, \n\t\tServerConfigurationService.getString(\"basiclti.consumer_return_url\",null));\n\n\t// Send along the content link\n        String contentlink = toNull(getCorrectProperty(config,\"contentlink\", placement));\n\tif ( contentlink != null ) setProperty(props,\"ext_resource_link_content\",contentlink);\n\n\t// Send along the CSS URL\n\tString tool_css = ServerConfigurationService.getString(\"basiclti.consumer.launch_presentation_css_url\",null);\n        if ( tool_css == null ) tool_css = getOurServerUrl() + \"/library/skin/default/tool.css\";  \n\tsetProperty(props,BasicLTIConstants.LAUNCH_PRESENTATION_CSS_URL, tool_css);  \n\n\t// Let tools know we are coming from Sakai\n\tsetProperty(props,\"ext_lms\", \"sakai2\");  \n\treturn true;\n    }","commit_id":"ad5b8c8dbc972388db5584cfd05832c3b2d188a0","url":"https://github.com/sakaiproject/sakai"},{"original_method":"protected void processRoster(HttpServletRequest request, HttpServletResponse response, \n\t\tString lti_message_type, \n\t\tSite site, String siteId, ToolConfiguration placement, Properties config,\n\t\tString user_id,  Map<String, Object> theMap)\n\t\tthrows java.io.IOException\n\t{\n\t\t// Check for permission in placement\n\t\tString allowRoster = SakaiBLTIUtil.toNull(SakaiBLTIUtil.getCorrectProperty(config,\"allowroster\", placement));\n\t\tif ( ! \"on\".equals(allowRoster) ) {\n\t\t\tdoError(request, response, theMap, \"outcomes.invalid\", \"lti_message_type=\"+lti_message_type, null);\n\t\t\treturn;\n                }\n\n\t\tString releaseName = SakaiBLTIUtil.toNull(SakaiBLTIUtil.getCorrectProperty(config,\"releasename\", placement));\n\t\tString releaseEmail = SakaiBLTIUtil.toNull(SakaiBLTIUtil.getCorrectProperty(config,\"releaseemail\", placement));\n\t\tString maintainRole = site.getMaintainRole();\n\n                pushAdvisor();\n\t\tboolean success = false;\n\t\ttry { \n\t\t\tList<Map<String,String>> lm = new ArrayList<Map<String,String>>();\n\t\t\tSet<Member> members = site.getMembers();\n\t\t\tfor (Member member : members ) {\n\t\t\t\tMap<String,String> mm = new TreeMap<String,String>();\n\t\t\t\tRole role = member.getRole();\n\t\t\t\tString ims_user_id = member.getUserId();\n\t\t\t\tmm.put(\"/user_id\",ims_user_id);\n\t\t\t\tString ims_role = \"Learner\";\n\t\t\t\tif ( maintainRole != null && maintainRole.equals(role.getId())) ims_role = \"Instructor\";\n\t\t\t\tmm.put(\"/role\",ims_role);\n\t\t\t\tif ( \"on\".equals(releaseName) || \"on\".equals(releaseEmail) ) {\n\t\t\t\t\tUser user = UserDirectoryService.getUser(ims_user_id);\n\t\t\t\t\tif ( \"on\".equals(releaseName) ) {\n\t\t\t\t\t\tmm.put(\"/person_name_given\",user.getFirstName());\n\t\t\t\t\t\tmm.put(\"/person_name_family\",user.getLastName());\n\t\t\t\t\t\tmm.put(\"/person_name_full\",user.getDisplayName());\n\t\t\t\t\t}\n\t\t\t\t\tif ( \"on\".equals(releaseEmail) ) {\n\t\t\t\t\t\tmm.put(\"/person_contact_email_primary\",user.getEmail());\n\t\t\t\t\t\tmm.put(\"/person_sourcedid\",user.getEid());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlm.add(mm);\n\t\t\t}\n\t\t\ttheMap.put(\"/message_response/members/member\", lm);\n\t\t\tsuccess = true;\n                } catch (Exception e) {\n\t\t\tdoError(request, response, theMap, \"memberships.fail\", \"\", e);\n                } finally {\n                        popAdvisor();\n                }\n\n\t\tif ( ! success ) return;\n\n\t\ttheMap.put(\"/message_response/statusinfo/codemajor\", \"Success\");\n\t\ttheMap.put(\"/message_response/statusinfo/severity\", \"Status\");\n\t\ttheMap.put(\"/message_response/statusinfo/codeminor\", \"fullsuccess\");\n                String theXml = XMLMap.getXML(theMap, true);\n                PrintWriter out = response.getWriter();\n                out.println(theXml);\n\t}","id":99357,"modified_method":"protected void processRoster(HttpServletRequest request, HttpServletResponse response, \n\t\tString lti_message_type, \n\t\tSite site, String siteId, ToolConfiguration placement, Properties config,\n\t\tString user_id,  Map<String, Object> theMap)\n\t\tthrows java.io.IOException\n\t{\n\t\t// Check for permission in placement\n\t\tString allowRoster = SakaiBLTIUtil.toNull(SakaiBLTIUtil.getCorrectProperty(config,\"allowroster\", placement));\n\t\tif ( ! \"on\".equals(allowRoster) ) {\n\t\t\tdoError(request, response, theMap, \"outcomes.invalid\", \"lti_message_type=\"+lti_message_type, null);\n\t\t\treturn;\n                }\n\n\t\tString releaseName = SakaiBLTIUtil.toNull(SakaiBLTIUtil.getCorrectProperty(config,\"releasename\", placement));\n\t\tString releaseEmail = SakaiBLTIUtil.toNull(SakaiBLTIUtil.getCorrectProperty(config,\"releaseemail\", placement));\n                String assignment = SakaiBLTIUtil.toNull(SakaiBLTIUtil.getCorrectProperty(config,\"assignment\", placement));\n                String allowOutcomes = ServerConfigurationService.getString(\n                                SakaiBLTIUtil.BASICLTI_OUTCOMES_ENABLED, null);\n                if ( ! \"true\".equals(allowOutcomes) ) allowOutcomes = null;\n\n\t\tString maintainRole = site.getMaintainRole();\n\n                pushAdvisor();\n\t\tboolean success = false;\n\t\ttry { \n\t\t\tList<Map<String,String>> lm = new ArrayList<Map<String,String>>();\n\t\t\tSet<Member> members = site.getMembers();\n\t\t\tfor (Member member : members ) {\n\t\t\t\tMap<String,String> mm = new TreeMap<String,String>();\n\t\t\t\tRole role = member.getRole();\n\t\t\t\tString ims_user_id = member.getUserId();\n\t\t\t\tmm.put(\"/user_id\",ims_user_id);\n\t\t\t\tString ims_role = \"Learner\";\n\t\t\t\tif ( maintainRole != null && maintainRole.equals(role.getId())) ims_role = \"Instructor\";\n\t\t\t\tmm.put(\"/role\",ims_role);\n\t\t\t\tUser user = null;\n\t\t\t\tif ( \"true\".equals(allowOutcomes) && assignment != null ) {\n\t\t\t\t\tif ( user == null ) user = UserDirectoryService.getUser(ims_user_id);\n\t\t\t\t\tString result_sourcedid = SakaiBLTIUtil.getSourceDID(user, placement, config);\n\t\t\t\t\tif ( result_sourcedid != null ) mm.put(\"/lis_result_sourcedid\",result_sourcedid);\n\t\t\t\t}\n\n\t\t\t\tif ( \"on\".equals(releaseName) || \"on\".equals(releaseEmail) ) {\n\t\t\t\t\tif ( user == null ) user = UserDirectoryService.getUser(ims_user_id);\n\t\t\t\t\tif ( \"on\".equals(releaseName) ) {\n\t\t\t\t\t\tmm.put(\"/person_name_given\",user.getFirstName());\n\t\t\t\t\t\tmm.put(\"/person_name_family\",user.getLastName());\n\t\t\t\t\t\tmm.put(\"/person_name_full\",user.getDisplayName());\n\t\t\t\t\t}\n\t\t\t\t\tif ( \"on\".equals(releaseEmail) ) {\n\t\t\t\t\t\tmm.put(\"/person_contact_email_primary\",user.getEmail());\n\t\t\t\t\t\tmm.put(\"/person_sourcedid\",user.getEid());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlm.add(mm);\n\t\t\t}\n\t\t\ttheMap.put(\"/message_response/members/member\", lm);\n\t\t\tsuccess = true;\n                } catch (Exception e) {\n\t\t\tdoError(request, response, theMap, \"memberships.fail\", \"\", e);\n                } finally {\n                        popAdvisor();\n                }\n\n\t\tif ( ! success ) return;\n\n\t\ttheMap.put(\"/message_response/statusinfo/codemajor\", \"Success\");\n\t\ttheMap.put(\"/message_response/statusinfo/severity\", \"Status\");\n\t\ttheMap.put(\"/message_response/statusinfo/codeminor\", \"fullsuccess\");\n                String theXml = XMLMap.getXML(theMap, true);\n                PrintWriter out = response.getWriter();\n                out.println(theXml);\n\t}","commit_id":"ad5b8c8dbc972388db5584cfd05832c3b2d188a0","url":"https://github.com/sakaiproject/sakai"},{"original_method":"private void rebuildScheduler() {\n        // Register new collectors if necessary\n        Set<String> configuredCollectors = new HashSet<String>();\n        for (Collector collector : m_collectdConfigFactory.getCollectdConfig().getCollectors()) {\n            String svcName = collector.getService();\n            configuredCollectors.add(svcName);\n            if (getServiceCollector(svcName) == null) {\n                try {\n                    LOG.debug(\"rebuildScheduler: Loading collector {}, classname {}\", svcName, collector.getClassName());\n                    Class<?> cc = Class.forName(collector.getClassName());\n                    ServiceCollector sc = (ServiceCollector) cc.newInstance();\n                    sc.initialize(Collections.<String, String>emptyMap());\n                    setServiceCollector(svcName, sc);\n                } catch (Throwable t) {\n                    LOG.warn(\"rebuildScheduler: Failed to load collector {} for service {}\", collector.getClassName(), svcName, t);\n                }\n            }\n        }\n        // Removing unused collectors if necessary\n        for (String collectorName : getCollectorNames()) {\n            if (!configuredCollectors.contains(collectorName)) {\n                LOG.info(\"rebuildScheduler: removing collector for {}, it is no longer required\", collectorName);\n                m_collectors.remove(collectorName);\n            }\n        }\n        // Recreating all Collectable Services (using the nodeID list populated at the beginning)\n        Collection<Integer> nodeIds = m_nodeDao.getNodeIds();\n        m_filterDao.flushActiveIpAddressListCache();\n        for (Integer nodeId : nodeIds) {\n            unscheduleNodeAndMarkForDeletion(new Long(nodeId));\n            scheduleNode(nodeId, true);\n        }\n    }","id":99358,"modified_method":"private void rebuildScheduler() {\n        // Register new collectors if necessary\n        Set<String> configuredCollectors = new HashSet<String>();\n        for (Collector collector : m_collectdConfigFactory.getCollectdConfig().getCollectors()) {\n            String svcName = collector.getService();\n            configuredCollectors.add(svcName);\n            if (getServiceCollector(svcName) == null) {\n                try {\n                    LOG.debug(\"rebuildScheduler: Loading collector {}, classname {}\", svcName, collector.getClassName());\n                    Class<?> cc = Class.forName(collector.getClassName());\n                    ServiceCollector sc = (ServiceCollector) cc.newInstance();\n                    sc.initialize(Collections.<String, String>emptyMap());\n                    setServiceCollector(svcName, sc);\n                } catch (Throwable t) {\n                    LOG.warn(\"rebuildScheduler: Failed to load collector {} for service {}\", collector.getClassName(), svcName, t);\n                }\n            }\n        }\n        // Removing unused collectors if necessary\n        List<String> blackList = new ArrayList<String>();\n        for (String collectorName : getCollectorNames()) {\n            if (!configuredCollectors.contains(collectorName)) {\n                blackList.add(collectorName);\n            }\n        }\n        for (String collectorName : blackList) {\n            LOG.info(\"rebuildScheduler: removing collector for {}, it is no longer required\", collectorName);\n            m_collectors.remove(collectorName);\n        }\n        // Recreating all Collectable Services (using the nodeID list populated at the beginning)\n        Collection<Integer> nodeIds = m_nodeDao.getNodeIds();\n        m_filterDao.flushActiveIpAddressListCache();\n        for (Integer nodeId : nodeIds) {\n            unscheduleNodeAndMarkForDeletion(new Long(nodeId));\n            scheduleNode(nodeId, true);\n        }\n    }","commit_id":"f81e4026ac8a65f5561683f3320f5b99ead30c3b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void rebuildScheduler() {\n        // Register new collectors if necessary\n        Set<String> configuredCollectors = new HashSet<String>();\n        for (Collector collector : m_collectdConfigFactory.getCollectdConfig().getCollectors()) {\n            String svcName = collector.getService();\n            configuredCollectors.add(svcName);\n            if (getServiceCollector(svcName) == null) {\n                try {\n                    LOG.debug(\"rebuildScheduler: Loading collector {}, classname {}\", svcName, collector.getClassName());\n                    Class<?> cc = Class.forName(collector.getClassName());\n                    ServiceCollector sc = (ServiceCollector) cc.newInstance();\n                    sc.initialize(Collections.<String, String>emptyMap());\n                    setServiceCollector(svcName, sc);\n                } catch (Throwable t) {\n                    LOG.warn(\"rebuildScheduler: Failed to load collector {} for service {}\", collector.getClassName(), svcName, t);\n                }\n            }\n        }\n        // Removing unused collectors if necessary\n        for (String collectorName : getCollectorNames()) {\n            if (!configuredCollectors.contains(collectorName)) {\n                LOG.info(\"rebuildScheduler: removing collector for {}, it is no longer required\", collectorName);\n                m_collectors.remove(collectorName);\n            }\n        }\n        // Recreating all Collectable Services (using the nodeID list populated at the beginning)\n        Collection<Integer> nodeIds = m_nodeDao.getNodeIds();\n        m_filterDao.flushActiveIpAddressListCache();\n        for (Integer nodeId : nodeIds) {\n            unscheduleNodeAndMarkForDeletion(new Long(nodeId));\n            scheduleNode(nodeId, true);\n        }\n    }","id":99359,"modified_method":"private void rebuildScheduler() {\n        // Register new collectors if necessary\n        Set<String> configuredCollectors = new HashSet<String>();\n        for (Collector collector : m_collectdConfigFactory.getCollectdConfig().getCollectors()) {\n            String svcName = collector.getService();\n            configuredCollectors.add(svcName);\n            if (getServiceCollector(svcName) == null) {\n                try {\n                    LOG.debug(\"rebuildScheduler: Loading collector {}, classname {}\", svcName, collector.getClassName());\n                    Class<?> cc = Class.forName(collector.getClassName());\n                    ServiceCollector sc = (ServiceCollector) cc.newInstance();\n                    sc.initialize(Collections.<String, String>emptyMap());\n                    setServiceCollector(svcName, sc);\n                } catch (Throwable t) {\n                    LOG.warn(\"rebuildScheduler: Failed to load collector {} for service {}\", collector.getClassName(), svcName, t);\n                }\n            }\n        }\n        // Removing unused collectors if necessary\n        List<String> blackList = new ArrayList<String>();\n        for (String collectorName : getCollectorNames()) {\n            if (!configuredCollectors.contains(collectorName)) {\n                blackList.add(collectorName);\n            }\n        }\n        for (String collectorName : blackList) {\n            LOG.info(\"rebuildScheduler: removing collector for {}, it is no longer required\", collectorName);\n            m_collectors.remove(collectorName);\n        }\n        // Recreating all Collectable Services (using the nodeID list populated at the beginning)\n        Collection<Integer> nodeIds = m_nodeDao.getNodeIds();\n        m_filterDao.flushActiveIpAddressListCache();\n        for (Integer nodeId : nodeIds) {\n            unscheduleNodeAndMarkForDeletion(new Long(nodeId));\n            scheduleNode(nodeId, true);\n        }\n    }","commit_id":"883274c37a2a263e313a511894cf68efd3ca4370","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void rebuildScheduler() {\n        // Register new collectors if necessary\n        Set<String> configuredCollectors = new HashSet<String>();\n        for (Collector collector : m_collectdConfigFactory.getCollectdConfig().getCollectors()) {\n            String svcName = collector.getService();\n            configuredCollectors.add(svcName);\n            if (getServiceCollector(svcName) == null) {\n                try {\n                    LOG.debug(\"rebuildScheduler: Loading collector {}, classname {}\", svcName, collector.getClassName());\n                    Class<?> cc = Class.forName(collector.getClassName());\n                    ServiceCollector sc = (ServiceCollector) cc.newInstance();\n                    sc.initialize(Collections.<String, String>emptyMap());\n                    setServiceCollector(svcName, sc);\n                } catch (Throwable t) {\n                    LOG.warn(\"rebuildScheduler: Failed to load collector {} for service {}\", collector.getClassName(), svcName, t);\n                }\n            }\n        }\n        // Removing unused collectors if necessary\n        for (String collectorName : getCollectorNames()) {\n            if (!configuredCollectors.contains(collectorName)) {\n                LOG.info(\"rebuildScheduler: removing collector for {}, it is no longer required\", collectorName);\n                m_collectors.remove(collectorName);\n            }\n        }\n        // Recreating all Collectable Services (using the nodeID list populated at the beginning)\n        Collection<Integer> nodeIds = m_nodeDao.getNodeIds();\n        m_filterDao.flushActiveIpAddressListCache();\n        for (Integer nodeId : nodeIds) {\n            unscheduleNodeAndMarkForDeletion(new Long(nodeId));\n            scheduleNode(nodeId, true);\n        }\n    }","id":99360,"modified_method":"private void rebuildScheduler() {\n        // Register new collectors if necessary\n        Set<String> configuredCollectors = new HashSet<String>();\n        for (Collector collector : m_collectdConfigFactory.getCollectdConfig().getCollectors()) {\n            String svcName = collector.getService();\n            configuredCollectors.add(svcName);\n            if (getServiceCollector(svcName) == null) {\n                try {\n                    LOG.debug(\"rebuildScheduler: Loading collector {}, classname {}\", svcName, collector.getClassName());\n                    Class<?> cc = Class.forName(collector.getClassName());\n                    ServiceCollector sc = (ServiceCollector) cc.newInstance();\n                    sc.initialize(Collections.<String, String>emptyMap());\n                    setServiceCollector(svcName, sc);\n                } catch (Throwable t) {\n                    LOG.warn(\"rebuildScheduler: Failed to load collector {} for service {}\", collector.getClassName(), svcName, t);\n                }\n            }\n        }\n        // Removing unused collectors if necessary\n        List<String> blackList = new ArrayList<String>();\n        for (String collectorName : getCollectorNames()) {\n            if (!configuredCollectors.contains(collectorName)) {\n                blackList.add(collectorName);\n            }\n        }\n        for (String collectorName : blackList) {\n            LOG.info(\"rebuildScheduler: removing collector for {}, it is no longer required\", collectorName);\n            m_collectors.remove(collectorName);\n        }\n        // Recreating all Collectable Services (using the nodeID list populated at the beginning)\n        Collection<Integer> nodeIds = m_nodeDao.getNodeIds();\n        m_filterDao.flushActiveIpAddressListCache();\n        for (Integer nodeId : nodeIds) {\n            unscheduleNodeAndMarkForDeletion(new Long(nodeId));\n            scheduleNode(nodeId, true);\n        }\n    }","commit_id":"50d12b70bf44dcafc9de1def69563763f23f8458","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public void init(Ability source, Game game) {\n        Permanent permanent1 = null;\n        Permanent permanent2 = null;\n        \n        if (withSource) {\n            permanent1 = game.getPermanent(targetPointer.getFirst(game, source));\n            permanent2 = game.getPermanent(source.getSourceId());\n        } else {\n            for (UUID permanentId : targetPointer.getTargets(game, source)) {\n                if (permanent1 == null) {\n                    permanent1 = game.getPermanent(permanentId);\n                }\n                if (permanent2 == null) {\n                    permanent2 = game.getPermanent(permanentId);\n                }\n            }\n            if (withSecondTarget) {\n                UUID uuid = source.getTargets().get(1).getFirstTarget();\n                permanent2 = game.getPermanent(uuid);\n            }\n        }\n        if (permanent1 != null && permanent2 != null) {\n            // exchange works only for two different controllers\n            if (permanent1.getControllerId().equals(permanent2.getControllerId())) {\n                // discard effect if controller of both permanents is the same\n                discard();\n                return;\n            }\n            this.lockedControllers.put(permanent1.getId(), permanent2.getControllerId());\n            this.zoneChangeCounter.put(permanent1.getId(), permanent1.getZoneChangeCounter());\n            this.lockedControllers.put(permanent2.getId(), permanent1.getControllerId());\n            this.zoneChangeCounter.put(permanent2.getId(), permanent2.getZoneChangeCounter());            \n        } else {\n            // discard if there are less than 2 permanents\n            discard();\n        }\n    }","id":99361,"modified_method":"@Override\n    public void init(Ability source, Game game) {\n        Permanent permanent1 = null;\n        Permanent permanent2 = null;\n        \n        if (withSource) {\n            permanent1 = game.getPermanent(targetPointer.getFirst(game, source));\n            permanent2 = game.getPermanent(source.getSourceId());\n        } else {\n            for (UUID permanentId : targetPointer.getTargets(game, source)) {\n                if (permanent1 == null) {\n                    permanent1 = game.getPermanent(permanentId);\n                } else if (permanent2 == null) {\n                    permanent2 = game.getPermanent(permanentId);\n                }\n            }\n            if (withSecondTarget) {\n                UUID uuid = source.getTargets().get(1).getFirstTarget();\n                permanent2 = game.getPermanent(uuid);\n            }\n        }\n        if (permanent1 != null && permanent2 != null) {\n            // exchange works only for two different controllers\n            if (permanent1.getControllerId().equals(permanent2.getControllerId())) {\n                // discard effect if controller of both permanents is the same\n                discard();\n                return;\n            }\n            this.lockedControllers.put(permanent1.getId(), permanent2.getControllerId());\n            this.zoneChangeCounter.put(permanent1.getId(), permanent1.getZoneChangeCounter());\n            this.lockedControllers.put(permanent2.getId(), permanent1.getControllerId());\n            this.zoneChangeCounter.put(permanent2.getId(), permanent2.getZoneChangeCounter());            \n        } else {\n            // discard if there are less than 2 permanents\n            discard();\n        }\n    }","commit_id":"959d55fef2f4be46a1f0790415080b3e87f81873","url":"https://github.com/magefree/mage"},{"original_method":"public ForgebornOreads(UUID ownerId) {\r\n        super(ownerId, 98, \"Forgeborn Oreads\", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, \"{2}{R}{R}\");\r\n        this.expansionSetCode = \"JOU\";\r\n        this.subtype.add(\"Nymph\");\r\n\r\n        this.color.setRed(true);\r\n\r\n        // Constellation - Whenever Forgeborn Oreads or another enchantment enters the battlefield under your control, Forgeborn Oreads deals 1 damage to target creature or player.\r\n        Ability ability = new ConstellationAbility(new DamageTargetEffect(1));\r\n        ability.addTarget(new TargetCreatureOrPlayer(true));\r\n        this.addAbility(ability);\r\n\r\n    }","id":99362,"modified_method":"public ForgebornOreads(UUID ownerId) {\r\n        super(ownerId, 98, \"Forgeborn Oreads\", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, \"{2}{R}{R}\");\r\n        this.expansionSetCode = \"JOU\";\r\n        this.subtype.add(\"Nymph\");\r\n\r\n        this.color.setRed(true);\r\n        this.power = new MageInt(4);\r\n        this.toughness = new MageInt(2);\r\n\r\n        // Constellation - Whenever Forgeborn Oreads or another enchantment enters the battlefield under your control, Forgeborn Oreads deals 1 damage to target creature or player.\r\n        Ability ability = new ConstellationAbility(new DamageTargetEffect(1));\r\n        ability.addTarget(new TargetCreatureOrPlayer(true));\r\n        this.addAbility(ability);\r\n\r\n    }","commit_id":"959d55fef2f4be46a1f0790415080b3e87f81873","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Permanent permanent = game.getPermanent(targetPointer.getFirst(game, source));\n        if (permanent != null) {\n            if (controllingPlayerId != null) {\n                return permanent.changeControllerId(controllingPlayerId, game);\n            } else {\n                return permanent.changeControllerId(source.getControllerId(), game);\n            }\n        }\n        this.discard();\n        return false;\n    }","id":99363,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());        \n        if (controller != null) {\n            boolean targetStillExists = false;\n            for (UUID permanentId: this.getTargetPointer().getTargets(game, source)) {\n                Permanent permanent = game.getPermanent(permanentId);\n                if (permanent != null) {\n                    targetStillExists = true;\n                    if (controllingPlayerId != null) {\n                        permanent.changeControllerId(controllingPlayerId, game);                        \n                    } else {\n                        permanent.changeControllerId(source.getControllerId(), game);\n                    }\n                }                \n            }\n            if (!targetStillExists) {\n                // no valid target exists, effect can be discarded\n                this.discard();\n            }\n            return true;\n        }   \n        return false;\n    }","commit_id":"959d55fef2f4be46a1f0790415080b3e87f81873","url":"https://github.com/magefree/mage"},{"original_method":"public MarchOfTheReturned(UUID ownerId) {\r\n        super(ownerId, 96, \"March of the Returned\", Rarity.COMMON, new CardType[]{CardType.SORCERY}, \"{3}{B}\");\r\n        this.expansionSetCode = \"THS\";\r\n\r\n        this.color.setBlack(true);\r\n\r\n        // Return up to two target creature cards from your graveyard to your hand.\r\n        Effect effect = new ReturnFromGraveyardToHandTargetEffect();\r\n        effect.setText(\"Return up to two target creature cards from your graveyard to your hand\");\r\n        this.getSpellAbility().addEffect(effect);\r\n        this.getSpellAbility().addTarget(new TargetCardInYourGraveyard(0,2, new FilterCreatureCard()));\r\n    }","id":99364,"modified_method":"public MarchOfTheReturned(UUID ownerId) {\r\n        super(ownerId, 96, \"March of the Returned\", Rarity.COMMON, new CardType[]{CardType.SORCERY}, \"{3}{B}\");\r\n        this.expansionSetCode = \"THS\";\r\n\r\n        this.color.setBlack(true);\r\n\r\n        // Return up to two target creature cards from your graveyard to your hand.\r\n        this.getSpellAbility().addEffect(new ReturnFromGraveyardToHandTargetEffect());\r\n        this.getSpellAbility().addTarget(new TargetCardInYourGraveyard(0,2, new FilterCreatureCard(\"creature cards from your graveyard\")));\r\n    }","commit_id":"959d55fef2f4be46a1f0790415080b3e87f81873","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        if (this.lockedControllers != null) {\n            for (UUID permanentId : targetPointer.getTargets(game, source)) {\n                Permanent permanent = game.getPermanent(permanentId);\n                if (permanent != null) {\n                    UUID controllerId = this.lockedControllers.get(permanent.getId());\n                    if (controllerId != null) {\n                        permanent.changeControllerId(controllerId, game);\n                    }\n                }\n            }\n            if (withSource) {\n                Permanent permanent = game.getPermanent(source.getSourceId());\n                UUID controllerId = this.lockedControllers.get(permanent.getId());\n                if (controllerId != null) {\n                    permanent.changeControllerId(controllerId, game);\n                }\n            }\n            return true;\n        }\n        return false;\n    }","id":99365,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        int countChangeControl = 0;\n        if (this.lockedControllers != null) {\n            for (UUID permanentId : targetPointer.getTargets(game, source)) {\n                Permanent permanent = game.getPermanent(permanentId);\n                if (permanent != null) {\n                    UUID controllerId = this.lockedControllers.get(permanent.getId());\n                    if (controllerId != null) {\n                        if(permanent.changeControllerId(controllerId, game)) {\n                            ++countChangeControl; \n                        }\n                    }\n                }\n            }\n            if (withSource) {\n                Permanent permanent = game.getPermanent(source.getSourceId());\n                if (permanent != null) {\n                    UUID controllerId = this.lockedControllers.get(permanent.getId());\n                    if (controllerId != null) {\n                        if (permanent.changeControllerId(controllerId, game)) {\n                            ++countChangeControl;\n                        }\n                    }\n                }\n            }\n        }\n        if (countChangeControl == 2) {\n            return true;\n        }\n        return false;\n\n    }","commit_id":"9481e44ae22733c9361e1ae6a8c6d76bde2ed950","url":"https://github.com/magefree/mage"},{"original_method":"public SearchWarrant(UUID ownerId) {\r\n        super(ownerId, 161, \"Search Warrant\", Rarity.COMMON, new CardType[]{CardType.SORCERY}, \"{W}{U}\");\r\n        this.expansionSetCode = \"RTR\";\r\n\r\n        this.color.setBlue(true);\r\n        this.color.setWhite(true);\r\n\r\n        // Target player reveals his or her hand. You gain life equal to the number of cards in that player's hand.\r\n        this.getSpellAbility().addTarget(new TargetPlayer());\r\n        this.getSpellAbility().addEffect(new SearchWarrantEffect());\r\n\r\n    }","id":99366,"modified_method":"public SearchWarrant(UUID ownerId) {\r\n        super(ownerId, 193, \"Search Warrant\", Rarity.COMMON, new CardType[]{CardType.SORCERY}, \"{W}{U}\");\r\n        this.expansionSetCode = \"RTR\";\r\n\r\n        this.color.setBlue(true);\r\n        this.color.setWhite(true);\r\n\r\n        // Target player reveals his or her hand. You gain life equal to the number of cards in that player's hand.\r\n        this.getSpellAbility().addTarget(new TargetPlayer());\r\n        this.getSpellAbility().addEffect(new SearchWarrantEffect());\r\n\r\n    }","commit_id":"9481e44ae22733c9361e1ae6a8c6d76bde2ed950","url":"https://github.com/magefree/mage"},{"original_method":"/**\n   * Parse the command line arguments.\n   */\n  void parseArguments(String[] args) {\n    if (args.length == 0) {\n      usage(true);\n    }\n    if (\"--help\".equals(args[0])) {\n      usage(false);\n      help = true;\n      return;\n    } else {\n      command = args[0];\n    }\n    // go through all the arguments\n    for (int pos = 1; pos < args.length; pos++) {\n      String arg = args[pos];\n      if (\"--host\".equals(arg)) {\n        if (++pos >= args.length) {\n          usage(true);\n        }\n        hostname = args[pos];\n      } else if (\"--port\".equals(arg)) {\n        if (++pos >= args.length) {\n          usage(true);\n        }\n        try {\n          port = Integer.parseInt(args[pos]);\n        } catch (NumberFormatException e) {\n          usage(true);\n        }\n      } else if (\"--apikey\".equals(arg)) {\n        if (++pos >= args.length) {\n          usage(true);\n        }\n        apikey = args[pos];\n      } else if (\"--application\".equals(arg) || \"--app\".equals(arg)) {\n        if (++pos >= args.length) {\n          usage(true);\n        }\n        app = args[pos];\n      } else if (\"--type\".equals(arg)) {\n        if (++pos >= args.length) {\n          usage(true);\n        }\n        type = args[pos];\n      } else if (\"--id\".equals(arg)) {\n        if (++pos >= args.length) {\n          usage(true);\n        }\n        id = args[pos];\n      } else if (\"--filter\".equals(arg)) {\n        if (++pos >= args.length) {\n          usage(true);\n        }\n        filters.add(args[pos]);\n      } else if (\"--value\".equals(arg)) {\n        if (++pos >= args.length) {\n          usage(true);\n        }\n        values.add(args[pos]);\n      } else if (\"--verbose\".equals(arg)) {\n        verbose = true;\n      } else if (\"--help\".equals(arg)) {\n        help = true;\n        usage(false);\n        return;\n      } else {  // unkown argument\n        usage(true);\n      }\n    }\n  }","id":99367,"modified_method":"/**\n   * Parse the command line arguments.\n   */\n  void parseArguments(String[] args) {\n    if (args.length == 0) {\n      usage(true);\n    }\n    if (\"--help\".equals(args[0])) {\n      usage(false);\n      help = true;\n      return;\n    } else {\n      command = args[0];\n    }\n    // go through all the arguments\n    for (int pos = 1; pos < args.length; pos++) {\n      String arg = args[pos];\n      if (\"--host\".equals(arg)) {\n        if (++pos >= args.length) {\n          usage(true);\n        }\n        hostname = args[pos];\n      } else if (\"--port\".equals(arg)) {\n        if (++pos >= args.length) {\n          usage(true);\n        }\n        try {\n          port = Integer.parseInt(args[pos]);\n        } catch (NumberFormatException e) {\n          usage(true);\n        }\n      } else if (\"--token\".equals(arg)) {\n        if (++pos >= args.length) {\n          usage(true);\n        }\n        accessToken = args[pos].trim().replaceAll(\"(\\r|\\n)\", \"\");\n      } else if (\"--token-file\".equals(arg)) {\n        if (++pos >= args.length) {\n          usage(true);\n        }\n        tokenFile = args[pos];\n      } else if (\"--apikey\".equals(arg)) {\n        if (++pos >= args.length) {\n          usage(true);\n        }\n        apikey = args[pos];\n      } else if (\"--application\".equals(arg) || \"--app\".equals(arg)) {\n        if (++pos >= args.length) {\n          usage(true);\n        }\n        app = args[pos];\n      } else if (\"--type\".equals(arg)) {\n        if (++pos >= args.length) {\n          usage(true);\n        }\n        type = args[pos];\n      } else if (\"--id\".equals(arg)) {\n        if (++pos >= args.length) {\n          usage(true);\n        }\n        id = args[pos];\n      } else if (\"--filter\".equals(arg)) {\n        if (++pos >= args.length) {\n          usage(true);\n        }\n        filters.add(args[pos]);\n      } else if (\"--value\".equals(arg)) {\n        if (++pos >= args.length) {\n          usage(true);\n        }\n        values.add(args[pos]);\n      } else if (\"--verbose\".equals(arg)) {\n        verbose = true;\n      } else if (\"--help\".equals(arg)) {\n        help = true;\n        usage(false);\n        return;\n      } else {  // unkown argument\n        usage(true);\n      }\n    }\n  }","commit_id":"be6d99c5df936c2bf840d6e3e56ab96dfe6e902c","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Print the usage statement and return null (or empty string if this is not\n   * an error case). See getValue() for an explanation of the return type.\n   *\n   * @param error indicates whether this was invoked as the result of an error\n   * @throws com.continuuity.common.utils.UsageException\n   *          in case of error\n   */\n  void usage(boolean error) {\n    PrintStream out = (error ? System.err : System.out);\n    String name = \"meta-client\";\n    if (System.getProperty(\"script\") != null) {\n      name = System.getProperty(\"script\").replaceAll(\"[./]\", \"\");\n    }\n    out.println(\"Usage: \");\n    out.println(\"  \" + name + \" list [ --application <id> ] --type <name>\");\n    out.println(\"  \" + name + \" read [ --application <id> ] --type <name> --id <id>\");\n    out.println();\n    out.println(\"Additional options:\");\n    out.println(\"  --filter <name>         To specify a field to filter on\");\n    out.println(\"  --value <name>          To specify a value to filter on\");\n    out.println(\"  --host <name>           To specify the hostname to send to\");\n    out.println(\"  --port <number>         To specify the port to use\");\n    out.println(\"  --apikey <apikey>       To specify an API key for authentication\");\n    out.println(\"  --verbose               To see more verbose output\");\n    out.println(\"  --help                  To print this message\");\n    if (error) {\n      throw new UsageException();\n    }\n  }","id":99368,"modified_method":"/**\n   * Print the usage statement and return null (or empty string if this is not\n   * an error case). See getValue() for an explanation of the return type.\n   *\n   * @param error indicates whether this was invoked as the result of an error\n   * @throws com.continuuity.common.utils.UsageException\n   *          in case of error\n   */\n  void usage(boolean error) {\n    PrintStream out = (error ? System.err : System.out);\n    String name = \"meta-client\";\n    if (System.getProperty(\"script\") != null) {\n      name = System.getProperty(\"script\").replaceAll(\"[./]\", \"\");\n    }\n    out.println(\"Usage: \");\n    out.println(\"  \" + name + \" list [ --application <id> ] --type <name>\");\n    out.println(\"  \" + name + \" read [ --application <id> ] --type <name> --id <id>\");\n    out.println();\n    out.println(\"Additional options:\");\n    out.println(\"  --filter <name>         To specify a field to filter on\");\n    out.println(\"  --value <name>          To specify a value to filter on\");\n    out.println(\"  --host <name>           To specify the hostname to send to\");\n    out.println(\"  --port <number>         To specify the port to use\");\n    out.println(\"  --apikey <apikey>       To specify an API key for authentication\");\n    out.println(\"  --token <token>         To specify the access token for a secure connection\");\n    out.println(\"  --token-file <path>     Alternative to --token, to specify a file that\");\n    out.println(\"                          contains the access token for a secure connection\");\n    out.println(\"  --verbose               To see more verbose output\");\n    out.println(\"  --help                  To print this message\");\n    if (error) {\n      throw new UsageException();\n    }\n  }","commit_id":"be6d99c5df936c2bf840d6e3e56ab96dfe6e902c","url":"https://github.com/caskdata/cdap"},{"original_method":"void validateArguments(String[] args) {\n    // first parse command arguments\n    parseArguments(args);\n    if (help) {\n      return;\n    }\n\n    // first validate the command\n    if (!supportedCommands.contains(command)) {\n      usage(\"Unsupported command '\" + command + \"'.\");\n    }\n\n    if (type == null) {\n      usage(\"--type must be specified\");\n    }\n    if (\"read\".equals(command)) {\n      if (id == null) {\n        usage(\"--id must be specified\");\n      }\n      if (!filters.isEmpty()) {\n        usage(\"--filter is not allowed with read\");\n      }\n    } else {\n      if (id != null) {\n        usage(\"--id is not alllowed with list\");\n      }\n    }\n    if (filters.size() != values.size()) {\n      usage(\"number of --filter and --value does not match\");\n    }\n  }","id":99369,"modified_method":"void validateArguments(String[] args) {\n    // first parse command arguments\n    parseArguments(args);\n    if (help) {\n      return;\n    }\n\n    // first validate the command\n    if (!supportedCommands.contains(command)) {\n      usage(\"Unsupported command '\" + command + \"'.\");\n    }\n\n    // use accessToken if both file and token are provided\n    if (tokenFile != null && accessToken != null) {\n      tokenFile = null;\n    }\n\n    if (type == null) {\n      usage(\"--type must be specified\");\n    }\n    if (\"read\".equals(command)) {\n      if (id == null) {\n        usage(\"--id must be specified\");\n      }\n      if (!filters.isEmpty()) {\n        usage(\"--filter is not allowed with read\");\n      }\n    } else {\n      if (id != null) {\n        usage(\"--id is not alllowed with list\");\n      }\n    }\n    if (filters.size() != values.size()) {\n      usage(\"number of --filter and --value does not match\");\n    }\n  }","commit_id":"be6d99c5df936c2bf840d6e3e56ab96dfe6e902c","url":"https://github.com/caskdata/cdap"},{"original_method":"public String execute0(String[] args, CConfiguration config) {\n    // parse and validate arguments\n    validateArguments(args);\n    if (help) {\n      return \"\";\n    }\n\n    boolean useSsl = !forceNoSSL && (apikey != null);\n    // TODO\n    String baseUrl = \"MetaDataClient should be re-implemented towards new gateway\";\n    // = Util.findBaseUrl(config, MetaDataRestAccessor.class, null, hostname, port, useSsl);\n    if (baseUrl == null) {\n      System.err.println(\"Can't figure out the URL to send to. \" +\n                           \"Please use --host and --port to specify.\");\n      return null;\n    } else {\n      if (verbose) {\n        System.out.println(\"Using base URL: \" + baseUrl);\n      }\n    }\n\n    // prepare for HTTP\n    HttpClient client = new DefaultHttpClient();\n    HttpResponse response;\n\n    // construct the full URL and verify its well-formedness\n    try {\n      URI.create(baseUrl);\n    } catch (IllegalArgumentException e) {\n      // this can only happen if the --host, or --base are not valid for a URL\n      System.err.println(\"Invalid base URL '\" + baseUrl + \"'. Check the validity of --host or --port arguments.\");\n      return null;\n    }\n\n    String requestUri = baseUrl + type;\n    if (id != null) {\n      requestUri += \"/\" + id;\n    }\n    String sep = \"?\";\n    if (app != null) {\n      requestUri += sep + \"application=\" + app;\n      sep = \"&\";\n    }\n    while (!filters.isEmpty()) {\n      requestUri += sep + filters.removeFirst() + \"=\" + values.removeFirst();\n      sep = \"&\";\n    }\n    HttpGet get = new HttpGet(requestUri);\n    if (apikey != null) {\n      get.setHeader(Constants.Gateway.CONTINUUITY_API_KEY, apikey);\n    }\n    try {\n      response = client.execute(get);\n      client.getConnectionManager().shutdown();\n    } catch (IOException e) {\n      System.err.println(\"Error sending HTTP request: \" + e.getMessage());\n      return null;\n    }\n    if (!checkHttpStatus(response)) {\n      return null;\n    }\n    if (printResponse(response) == null) {\n      return null;\n    }\n    return \"OK.\";\n  }","id":99370,"modified_method":"public String execute0(String[] args, CConfiguration config) {\n    // parse and validate arguments\n    validateArguments(args);\n    if (help) {\n      return \"\";\n    }\n\n    if (tokenFile != null) {\n      readTokenFile();\n    }\n\n    String baseUrl = GatewayUrlGenerator.getBaseUrl(config, hostname, port, !forceNoSSL && apikey != null);\n    if (baseUrl == null) {\n      System.err.println(\"Can't figure out the URL to send to. \" +\n                         \"Please use --host and --port to specify.\");\n      return null;\n    } else {\n      if (verbose) {\n        System.out.println(\"Using base URL: \" + baseUrl);\n      }\n    }\n\n    // prepare for HTTP\n    HttpClient client = new DefaultHttpClient();\n    HttpResponse response;\n\n    // construct the full URL and verify its well-formedness\n    try {\n      URI.create(baseUrl);\n    } catch (IllegalArgumentException e) {\n      // this can only happen if the --host, or --base are not valid for a URL\n      System.err.println(\"Invalid base URL '\" + baseUrl + \"'. Check the validity of --host or --port arguments.\");\n      return null;\n    }\n\n    String requestUri = baseUrl + type;\n    if (id != null) {\n      requestUri += \"/\" + id;\n    }\n    String sep = \"?\";\n    if (app != null) {\n      requestUri += sep + \"application=\" + app;\n      sep = \"&\";\n    }\n    while (!filters.isEmpty()) {\n      requestUri += sep + filters.removeFirst() + \"=\" + values.removeFirst();\n      sep = \"&\";\n    }\n    HttpGet get = new HttpGet(requestUri);\n    if (apikey != null) {\n      get.setHeader(Constants.Gateway.CONTINUUITY_API_KEY, apikey);\n    }\n    if (accessToken != null) {\n      get.setHeader(\"Authorization\", \"Bearer \" + accessToken);\n    }\n    try {\n      response = client.execute(get);\n      if (!checkHttpStatus(response)) {\n        return null;\n      }\n      if (printResponse(response) == null) {\n        return null;\n      }\n      return \"OK.\";\n    } catch (IOException e) {\n      System.err.println(\"Error sending HTTP request: \" + e.getMessage());\n      return null;\n    } finally {\n      client.getConnectionManager().shutdown();\n    }\n\n  }","commit_id":"be6d99c5df936c2bf840d6e3e56ab96dfe6e902c","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Check whether the Http return code is positive. If not, print the error\n   * message and return false. Otherwise, if verbose is on, print the response\n   * status line.\n   *\n   * @param response the HTTP response\n   * @return whether the response indicates success\n   */\n  boolean checkHttpStatus(HttpResponse response) {\n    if (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) {\n      if (verbose) {\n        System.out.println(response.getStatusLine());\n      } else {\n        System.err.println(response.getStatusLine().getReasonPhrase());\n      }\n      return false;\n    }\n    if (verbose) {\n      System.out.println(response.getStatusLine());\n    }\n    return true;\n  }","id":99371,"modified_method":"/**\n   * Check whether the Http return code is positive. If not, print the error\n   * message and return false. Otherwise, if verbose is on, print the response\n   * status line.\n   *\n   * @param response the HTTP response\n   * @return whether the response indicates success\n   */\n  boolean checkHttpStatus(HttpResponse response) {\n    if (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) {\n      if (response.getStatusLine().getStatusCode() == HttpStatus.SC_UNAUTHORIZED) {\n        PrintStream out = (verbose ? System.out : System.err);\n        out.println(response.getStatusLine());\n        if (accessToken == null) {\n          out.println(\"No access token provided\");\n        } else {\n          Reader reader = null;\n          try {\n            reader = new InputStreamReader(response.getEntity().getContent());\n            String responseError = GSON.fromJson(reader, ErrorMessage.class).getErrorDescription();\n            if (responseError != null && !responseError.isEmpty()) {\n              out.println(responseError);\n            }\n          } catch (Exception e) {\n            out.println(\"Unknown unauthorized error\");\n          }\n        }\n        return false;\n      }\n      if (verbose) {\n        System.out.println(response.getStatusLine());\n      } else {\n        System.err.println(response.getStatusLine().getReasonPhrase());\n      }\n      return false;\n    }\n    if (verbose) {\n      System.out.println(response.getStatusLine());\n    }\n    return true;\n  }","commit_id":"be6d99c5df936c2bf840d6e3e56ab96dfe6e902c","url":"https://github.com/caskdata/cdap"},{"original_method":"private void executeInvalidateMode() {\n    URL url;\n    HttpURLConnection connection = null;\n    try {\n      url = new URL(\"http://\" + hostname + \":\" + portNumber + \"/v2/transactions/\" + txId + \"/invalidate\");\n      connection = (HttpURLConnection) url.openConnection();\n      connection.setRequestMethod(\"POST\");\n\n      System.out.println(\"About to invalidate transaction \" +\n                         txId + \" on Reactor running at \" + hostname);\n      int responseCode = connection.getResponseCode();\n      if (responseCode == 200) {\n        System.out.println(\"Transaction successfully invalidated.\");\n      } else if (responseCode == 400) {\n        System.out.println(\"Could not invalidate transaction: \" + txId + \" is not a valid tx id\");\n      } else if (responseCode == 409) {\n        System.out.println(\"Could not invalidate transaction \" + txId + \": transaction is not in progress.\");\n      } else {\n        System.out.println(\"Could not invalidate transaction. Error code: \" + responseCode);\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n    } finally {\n      if (connection != null) {\n        connection.disconnect();\n      }\n    }\n  }","id":99372,"modified_method":"private void executeInvalidateMode() {\n    URL url;\n    HttpURLConnection connection = null;\n    try {\n      url = new URL(\"http://\" + hostname + \":\" + portNumber + \"/v2/transactions/\" + txId + \"/invalidate\");\n      connection = (HttpURLConnection) url.openConnection();\n      connection.setRequestMethod(\"POST\");\n      if (accessToken != null) {\n        connection.setRequestProperty(\"Authorization\", \"Bearer \" + accessToken);\n      }\n\n      System.out.println(\"About to invalidate transaction \" +\n                          txId + \" on Reactor running at \" + hostname);\n      int responseCode = connection.getResponseCode();\n      if (responseCode == 200) {\n        System.out.println(\"Transaction successfully invalidated.\");\n      } else if (responseCode == 400) {\n        System.out.println(\"Could not invalidate transaction: \" + txId + \" is not a valid tx id\");\n      } else if (responseCode == 409) {\n        System.out.println(\"Could not invalidate transaction \" + txId + \": transaction is not in progress.\");\n      } else if (responseCode == 401) {\n        readUnauthorizedError(connection);\n      } else {\n        System.out.println(\"Could not invalidate transaction. Error code: \" + responseCode);\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n    } finally {\n      if (connection != null) {\n        connection.disconnect();\n      }\n    }\n  }","commit_id":"be6d99c5df936c2bf840d6e3e56ab96dfe6e902c","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Take a snapshot from the transaction manager of a reactor and retrieve it.\n   * @return the transaction manager snapshot just taken\n   */\n  private TransactionSnapshot takeSnapshot() {\n    URL url;\n    HttpURLConnection connection = null;\n    try {\n      url = new URL(\"http://\" + hostname + \":\" + portNumber + \"/v2/transactions/state\");\n      connection = (HttpURLConnection) url.openConnection();\n\n      System.out.println(\"About to take a snapshot of the transaction manager at \" +\n                         url.toURI() + \", timestamp is \" + System.currentTimeMillis() + \" ms\");\n      int responseCode = connection.getResponseCode();\n      if (responseCode == 200) {\n        // Retrieve and deserialize the snapshot\n        InputStream input = connection.getInputStream();\n        TransactionSnapshot snapshot;\n        try {\n          snapshot = codecProvider.decode(input);\n        } finally {\n          input.close();\n        }\n        System.out.println(\"Snapshot taken and retrieved properly, snapshot timestamp is \" +\n                           snapshot.getTimestamp() + \" ms\");\n\n        if (persistingFilename != null) {\n          // Persist the snapshot on disk for future queries and debugging\n          File outputFile = new File(persistingFilename);\n          OutputStream out = new FileOutputStream(outputFile);\n          try {\n            // todo use pipes here to avoid having everyhting in memory twice\n            codecProvider.encode(out, snapshot);\n          } finally {\n            out.close();\n          }\n          System.out.println(\"Snapshot persisted on your disk as \" + outputFile.getAbsolutePath() +\n                             \" for future queries.\");\n        } else {\n          System.out.println(\"Persist option not activated - Snapshot won't be persisted on your disk.\");\n        }\n        return snapshot;\n      } else {\n        System.out.println(\"Snapshot could not be taken. Error code: \" + responseCode);\n      }\n      return null;\n    } catch (Exception e) {\n      e.printStackTrace();\n      return null;\n    } finally {\n      if (connection != null) {\n        connection.disconnect();\n      }\n    }\n  }","id":99373,"modified_method":"/**\n   * Take a snapshot from the transaction manager of a reactor and retrieve it.\n   * @return the transaction manager snapshot just taken\n   */\n  private TransactionSnapshot takeSnapshot() {\n    URL url;\n    HttpURLConnection connection = null;\n    try {\n      url = new URL(\"http://\" + hostname + \":\" + portNumber + \"/v2/transactions/state\");\n      connection = (HttpURLConnection) url.openConnection();\n      if (accessToken != null) {\n        connection.setRequestProperty(\"Authorization\", \"Bearer \" + accessToken);\n      }\n\n      System.out.println(\"About to take a snapshot of the transaction manager at \" +\n                         url.toURI() + \", timestamp is \" + System.currentTimeMillis() + \" ms\");\n      int responseCode = connection.getResponseCode();\n      if (responseCode == 200) {\n        // Retrieve and deserialize the snapshot\n        InputStream input = connection.getInputStream();\n        TransactionSnapshot snapshot;\n        try {\n          snapshot = codecProvider.decode(input);\n        } finally {\n          input.close();\n        }\n        System.out.println(\"Snapshot taken and retrieved properly, snapshot timestamp is \" +\n                           snapshot.getTimestamp() + \" ms\");\n\n        if (persistingFilename != null) {\n          // Persist the snapshot on disk for future queries and debugging\n          File outputFile = new File(persistingFilename);\n          OutputStream out = new FileOutputStream(outputFile);\n          try {\n            // todo use pipes here to avoid having everyhting in memory twice\n            codecProvider.encode(out, snapshot);\n          } finally {\n            out.close();\n          }\n          System.out.println(\"Snapshot persisted on your disk as \" + outputFile.getAbsolutePath() +\n                             \" for future queries.\");\n        } else {\n          System.out.println(\"Persist option not activated - Snapshot won't be persisted on your disk.\");\n        }\n        return snapshot;\n      } else if (responseCode == 401) {\n        readUnauthorizedError(connection);\n      } else {\n        System.out.println(\"Snapshot could not be taken. Error code: \" + responseCode);\n      }\n      return null;\n    } catch (Exception e) {\n      e.printStackTrace();\n      return null;\n    } finally {\n      if (connection != null) {\n        connection.disconnect();\n      }\n    }\n  }","commit_id":"be6d99c5df936c2bf840d6e3e56ab96dfe6e902c","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Parse the arguments from the command line and execute the different modes.\n   * @param args command line arguments\n   * @param conf default configuration\n   * @return true if the arguments were parsed successfully and comply with the expected usage\n   */\n  private boolean parseArgsAndExecMode(String[] args, CConfiguration conf) {\n    CommandLineParser parser = new GnuParser();\n    // Check all the options of the command line\n    try {\n      CommandLine line = parser.parse(options, args);\n      if (line.hasOption(HELP_OPTION)) {\n        printUsage(false);\n        return true;\n      }\n\n      hostname = line.getOptionValue(HOST_OPTION);\n      existingFilename = line.getOptionValue(FILENAME_OPTION);\n      persistingFilename = line.hasOption(SAVE_OPTION) ? line.getOptionValue(SAVE_OPTION) : null;\n      showTxids = line.hasOption(IDS_OPTION) ? true : false;\n      txId = line.hasOption(TRANSACTION_OPTION) ? Long.valueOf(line.getOptionValue(TRANSACTION_OPTION)) : null;\n      portNumber = line.hasOption(PORT_OPTION) ? Integer.valueOf(line.getOptionValue(PORT_OPTION)) :\n                   conf.getInt(Constants.Gateway.PORT, Constants.Gateway.DEFAULT_PORT);\n      \n      switch (this.mode) {\n        case VIEW:\n          if (!line.hasOption(HOST_OPTION) && !line.hasOption(FILENAME_OPTION)) {\n            usage(\"Either specify a hostname to download a new snapshot, \" +\n                  \"or a filename of an existing snapshot.\");\n            return false;\n          }\n          // Execute mode\n          executeViewMode();\n          break;\n        case INVALIDATE:\n          if (!line.hasOption(HOST_OPTION) || !line.hasOption(TRANSACTION_OPTION)) {\n            usage(\"Specify a host name and a transaction id.\");\n            return false;\n          }\n          // Execute mode\n          executeInvalidateMode();\n          break;\n        case RESET:\n          if (!line.hasOption(HOST_OPTION)) {\n            usage(\"Specify a host name.\");\n            return false;\n          }\n          // Execute mode\n          executeResetMode();\n          break;\n        default:\n          printUsage(true);\n          return false;\n      }\n    } catch (ParseException e) {\n      printUsage(true);\n      return false;\n    }\n    return true;\n  }","id":99374,"modified_method":"/**\n   * Parse the arguments from the command line and execute the different modes.\n   * @param args command line arguments\n   * @param conf default configuration\n   * @return true if the arguments were parsed successfully and comply with the expected usage\n   */\n  private boolean parseArgsAndExecMode(String[] args, CConfiguration conf) {\n    CommandLineParser parser = new GnuParser();\n    // Check all the options of the command line\n    try {\n      CommandLine line = parser.parse(options, args);\n      if (line.hasOption(HELP_OPTION)) {\n        printUsage(false);\n        return true;\n      }\n\n      hostname = line.getOptionValue(HOST_OPTION);\n      existingFilename = line.getOptionValue(FILENAME_OPTION);\n      persistingFilename = line.hasOption(SAVE_OPTION) ? line.getOptionValue(SAVE_OPTION) : null;\n      showTxids = line.hasOption(IDS_OPTION);\n      txId = line.hasOption(TRANSACTION_OPTION) ? Long.valueOf(line.getOptionValue(TRANSACTION_OPTION)) : null;\n      accessToken = line.hasOption(TOKEN_OPTION) ? line.getOptionValue(TOKEN_OPTION).replaceAll(\"(\\r|\\n)\", \"\") : null;\n      tokenFile = line.hasOption(TOKEN_FILE_OPTION) ? line.getOptionValue(TOKEN_FILE_OPTION).replaceAll(\"(\\r|\\n)\", \"\")\n        : null;\n      portNumber = line.hasOption(PORT_OPTION) ? Integer.valueOf(line.getOptionValue(PORT_OPTION)) :\n                   conf.getInt(Constants.Gateway.PORT, Constants.Gateway.DEFAULT_PORT);\n\n      // if both tokenfile and accessToken are given, just use the access token\n      if (tokenFile != null) {\n        if (accessToken != null) {\n          tokenFile = null;\n        } else {\n          readTokenFile();\n        }\n      }\n\n      switch (this.mode) {\n        case VIEW:\n          if (!line.hasOption(HOST_OPTION) && !line.hasOption(FILENAME_OPTION)) {\n            usage(\"Either specify a hostname to download a new snapshot, \" +\n                  \"or a filename of an existing snapshot.\");\n            return false;\n          }\n          // Execute mode\n          executeViewMode();\n          break;\n        case INVALIDATE:\n          if (!line.hasOption(HOST_OPTION) || !line.hasOption(TRANSACTION_OPTION)) {\n            usage(\"Specify a host name and a transaction id.\");\n            return false;\n          }\n          // Execute mode\n          executeInvalidateMode();\n          break;\n        case RESET:\n          if (!line.hasOption(HOST_OPTION)) {\n            usage(\"Specify a host name.\");\n            return false;\n          }\n          // Execute mode\n          executeResetMode();\n          break;\n        default:\n          printUsage(true);\n          return false;\n      }\n    } catch (ParseException e) {\n      printUsage(true);\n      return false;\n    }\n    return true;\n  }","commit_id":"be6d99c5df936c2bf840d6e3e56ab96dfe6e902c","url":"https://github.com/caskdata/cdap"},{"original_method":"private void buildOptions() {\n    options = new Options();\n    options.addOption(null, HOST_OPTION, true, \"To specify the hostname of the router\");\n    options.addOption(null, FILENAME_OPTION, true, \"To specify a file to load a snapshot from in view mode. \" +\n                                                   \"If the host option is specified, filename will be ignored\");\n    options.addOption(null, SAVE_OPTION, true, \"To specify where the snapshot downloaded on hostname --host \" +\n                                               \"should be persisted on your disk when using the view mode\");\n    options.addOption(null, IDS_OPTION, false, \"To view all the transaction IDs contained in the \" +\n                                               \"snapshot when using the view mode\");\n    options.addOption(null, TRANSACTION_OPTION, true, \"To specify a transaction ID. Mandatory in invalidate mode, \" +\n                                                      \"optional in view mode\");\n    options.addOption(null, PORT_OPTION, true, \"To specify the port to use. The default value is --port \" +\n                                               Constants.Gateway.DEFAULT_PORT);\n    options.addOption(null, HELP_OPTION, false, \"To print this message\");\n  }","id":99375,"modified_method":"private void buildOptions() {\n    options = new Options();\n    options.addOption(null, HOST_OPTION, true, \"To specify the hostname of the router\");\n    options.addOption(null, FILENAME_OPTION, true, \"To specify a file to load a snapshot from in view mode. \" +\n                                                   \"If the host option is specified, filename will be ignored\");\n    options.addOption(null, SAVE_OPTION, true, \"To specify where the snapshot downloaded on hostname --host \" +\n                                               \"should be persisted on your disk when using the view mode\");\n    options.addOption(null, IDS_OPTION, false, \"To view all the transaction IDs contained in the \" +\n                                               \"snapshot when using the view mode\");\n    options.addOption(null, TRANSACTION_OPTION, true, \"To specify a transaction ID. Mandatory in invalidate mode, \" +\n                                                      \"optional in view mode\");\n    options.addOption(null, PORT_OPTION, true, \"To specify the port to use. The default value is --port \" +\n                                               Constants.Gateway.DEFAULT_PORT);\n    options.addOption(null, HELP_OPTION, false, \"To print this message\");\n    options.addOption(null, TOKEN_OPTION, true, \"To specify the access token for secure connections\");\n    options.addOption(null, TOKEN_FILE_OPTION, true, \"Alternative to --token, to specify a file that contains \" +\n                                                      \"the access token for a secure connection\");\n  }","commit_id":"be6d99c5df936c2bf840d6e3e56ab96dfe6e902c","url":"https://github.com/caskdata/cdap"},{"original_method":"private void executeResetMode() {\n    URL url;\n    HttpURLConnection connection = null;\n    try {\n      url = new URL(\"http://\" + hostname + \":\" + portNumber + \"/v2/transactions/state\");\n      connection = (HttpURLConnection) url.openConnection();\n      connection.setRequestMethod(\"POST\");\n\n      System.out.println(\"About to reset the transaction manager state for the Reactor running at \" + hostname);\n      int responseCode = connection.getResponseCode();\n      if (responseCode == 200) {\n        System.out.println(\"Transaction manager state reset successfully.\");\n      } else {\n        System.out.println(\"Could not invalidate transaction. Error code: \" + responseCode);\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n    } finally {\n      if (connection != null) {\n        connection.disconnect();\n      }\n    }\n  }","id":99376,"modified_method":"private void executeResetMode() {\n    URL url;\n    HttpURLConnection connection = null;\n    try {\n      url = new URL(\"http://\" + hostname + \":\" + portNumber + \"/v2/transactions/state\");\n      connection = (HttpURLConnection) url.openConnection();\n      connection.setRequestMethod(\"POST\");\n      if (accessToken != null) {\n        connection.setRequestProperty(\"Authorization\", \"Bearer \" + accessToken);\n      }\n\n      System.out.println(\"About to reset the transaction manager state for the Reactor running at \" + hostname);\n      int responseCode = connection.getResponseCode();\n      if (responseCode == 200) {\n        System.out.println(\"Transaction manager state reset successfully.\");\n      } else if (responseCode == 401) {\n        readUnauthorizedError(connection);\n      } else {\n        System.out.println(\"Could not invalidate transaction. Error code: \" + responseCode);\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n    } finally {\n      if (connection != null) {\n        connection.disconnect();\n      }\n    }\n  }","commit_id":"be6d99c5df936c2bf840d6e3e56ab96dfe6e902c","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Execute the configured operation\n   */\n  public void execute() throws TException, AppFabricServiceException {\n    Preconditions.checkNotNull(command, \"App client is not configured to run\");\n    Preconditions.checkNotNull(configuration, \"App client configuration is not set\");\n\n    String address = \"localhost\";\n    int port = configuration.getInt(Constants.CFG_APP_FABRIC_SERVER_PORT, Constants.DEFAULT_APP_FABRIC_SERVER_PORT);\n    TTransport transport = null;\n    TProtocol protocol = null;\n    try {\n      transport = new TFramedTransport(new TSocket(address, port));\n      protocol = new TBinaryProtocol(transport);\n      transport.open();\n      AppFabricService.Client client = new AppFabricService.Client(protocol);\n\n      if (\"help\".equals(command)) {\n        return;\n      }\n\n      if (\"deploy\".equals(command)) {\n        deploy(client, transport);\n      }\n\n      if (\"start\".equals(command)) {\n        AuthToken dummyAuthToken = new AuthToken(\"AppFabricClient\");\n        System.out.println(String.format(\"Starting application: %s processor %s\", application, processor));\n        FlowIdentifier identifier = new FlowIdentifier(\"developer\", application, processor, 1);\n        RunIdentifier runIdentifier = client.start(dummyAuthToken,\n          new FlowDescriptor(identifier, new ArrayList<String>()));\n\n        Preconditions.checkNotNull(runIdentifier, \"Problem starting the application\");\n        System.out.println(\"Started application with id: \" + runIdentifier.getId());\n        return;\n      }\n\n      if (\"stop\".equals(command)) {\n        AuthToken dummyAuthToken = new AuthToken(\"AppFabricClient\");\n        FlowIdentifier identifier = new FlowIdentifier(\"developer\", application, processor, 1);\n\n        RunIdentifier runIdentifier = client.stop(dummyAuthToken, identifier);\n        Preconditions.checkNotNull(runIdentifier, \"Problem stopping the application\");\n        System.out.println(\"Stopped application running with id: \" + runIdentifier.getId());\n      }\n\n      if (\"promote\".equals(command)) {\n        ResourceIdentifier identifier = new ResourceIdentifier(\"developer\", this.application, this.resource, 1);\n        boolean status = client.promote(new AuthToken(this.authToken), identifier, this.vpc);\n        if (status) {\n          System.out.println(\"Promoted to cloud\");\n        } else {\n          System.out.println(\"Promote to cloud failed\");\n        }\n      }\n      if (\"status\".equals(command)) {\n        AuthToken dummyAuthToken = new AuthToken(\"AppFabricClient\");\n        FlowIdentifier identifier = new FlowIdentifier(\"developer\", application, processor, 0);\n\n        FlowStatus flowStatus = client.status(dummyAuthToken, identifier);\n        Preconditions.checkNotNull(flowStatus, \"Problem getting the status the application\");\n        System.out.println(String.format(\"%s\", flowStatus.toString()));\n      }\n    } catch (Exception e) {\n      System.out.println(String.format(\"Caught Exception while running %s \", command));\n      System.out.println(String.format(\"Error: %s\", e.getMessage()));\n    } finally {\n      transport.close();\n    }\n  }","id":99377,"modified_method":"/**\n   * Execute the configured operation\n   */\n  public void execute() throws TException, AppFabricServiceException {\n    Preconditions.checkNotNull(command, \"App client is not configured to run\");\n    Preconditions.checkNotNull(configuration, \"App client configuration is not set\");\n\n    String address = \"localhost\";\n    int port = configuration.getInt(Constants.CFG_APP_FABRIC_SERVER_PORT, Constants.DEFAULT_APP_FABRIC_SERVER_PORT);\n    TTransport transport = null;\n    TProtocol protocol = null;\n    try {\n      transport = new TFramedTransport(new TSocket(address, port));\n      protocol = new TBinaryProtocol(transport);\n      transport.open();\n      AppFabricService.Client client = new AppFabricService.Client(protocol);\n\n      if (\"help\".equals(command)) {\n        return;\n      }\n\n      if (\"deploy\".equals(command)) {\n        deploy(client, transport);\n      }\n\n      if (\"start\".equals(command)) {\n        AuthToken dummyAuthToken = new AuthToken(\"AppFabricClient\");\n        FlowIdentifier identifier = null;\n        if( this.flow != null) {\n          identifier = new FlowIdentifier(\"developer\", application, this.flow, 1);\n          identifier.setType(EntityType.FLOW);\n          System.out.println(String.format(\"Starting flow %s for application %s \",this.flow, this.application));\n        }\n        else {\n          identifier = new FlowIdentifier(\"developer\", application, this.procedure, 1);\n          identifier.setType(EntityType.QUERY);\n          System.out.println(String.format(\"Starting procedure %s for application %s \",\n                                            this.procedure, this.application));\n        }\n        client.start(dummyAuthToken,new FlowDescriptor(identifier,new ArrayList<String>()));\n        System.out.println(\"Started \");\n        return;\n      }\n\n      if (\"stop\".equals(command)) {\n\n        AuthToken dummyAuthToken = new AuthToken(\"AppFabricClient\");\n        FlowIdentifier identifier = null;\n        if( this.flow != null) {\n          identifier = new FlowIdentifier(\"developer\", application, this.flow, 1);\n          identifier.setType(EntityType.FLOW);\n          System.out.println(String.format(\"Stopping flow %s for application %s \",this.flow, this.application));\n        }\n        else {\n          identifier = new FlowIdentifier(\"developer\", application, this.procedure, 1);\n          identifier.setType(EntityType.QUERY);\n          System.out.println(String.format(\"Stopping procedure %s for application %s \",\n            this.procedure, this.application));\n        }\n        client.stop(dummyAuthToken,identifier);\n        System.out.println(\"Stopped \");\n        return;\n      }\n\n      if (\"promote\".equals(command)) {\n        ResourceIdentifier identifier = new ResourceIdentifier(\"developer\", this.application, this.resource, 1);\n        boolean status = client.promote(new AuthToken(this.authToken), identifier, this.hostname);\n        if (status) {\n          System.out.println(\"Promoted to cloud\");\n        } else {\n          System.out.println(\"Promote to cloud failed\");\n        }\n      }\n      if (\"status\".equals(command)) {\n        AuthToken dummyAuthToken = new AuthToken(\"AppFabricClient\");\n        FlowIdentifier identifier = null;\n        if( this.flow != null) {\n          identifier = new FlowIdentifier(\"developer\", application, this.flow, 1);\n          identifier.setType(EntityType.FLOW);\n          System.out.println(String.format(\"Getting status for flow %s in application %s \",\n                                            this.flow, this.application));\n        }\n        else {\n          identifier = new FlowIdentifier(\"developer\", application, this.procedure, 1);\n          identifier.setType(EntityType.QUERY);\n          System.out.println(String.format(\"Getting status for procedure %s in application %s \",\n            this.flow, this.application));\n        }\n        FlowStatus flowStatus = client.status(dummyAuthToken, identifier);\n        Preconditions.checkNotNull(flowStatus, \"Problem getting the status the application\");\n        System.out.println(String.format(\"Status: %s\", flowStatus.toString()));\n      }\n    } catch (Exception e) {\n      System.out.println(String.format(\"Caught Exception while running %s \", command));\n      System.out.println(String.format(\"Error: %s\", e.getMessage()));\n    } finally {\n      transport.close();\n    }\n  }","commit_id":"5bc5e2f4d97b7c99bdbadd393846a1703d5d717a","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Configure the Client to execute commands\n   *\n   * @param configuration Instance of {@code CConfiguration}\n   * @param args          array of String arguments\n   * @return Command that will be executed\n   * @throws ParseException on errors in commnd line parsing\n   */\n  public String configure(CConfiguration configuration, String args[]) {\n\n    this.configuration = configuration;\n\n    Preconditions.checkArgument(args.length >= 1, \"Not enough arguments\");\n    boolean knownCommand = availableCommands.contains(args[0]);\n    Preconditions.checkArgument(knownCommand, \"Unknown Command specified\");\n\n    command = args[0];\n\n    CommandLineParser commandLineParser = new GnuParser();\n\n    Options options = new Options();\n    options.addOption(RESOURCE_SHORT_OPT_ARG,RESOURCE_LONG_OPT_ARG, true, \"Jar that contains the application.\");\n    options.addOption(APPLICATION_SHORT_OPT_ARG,APPLICATION_LONG_OPT_ARG, true, \"Application Id.\");\n    options.addOption(PROCESSOR_SHORT_OPT_ARG,PROCESSOR_LONG_OPT_ARG, true, \"Processor Id.\");\n    options.addOption(VPC_SHORT_OPT_ARG,VPC_LONG_OPT_ARG, true, \"Fully qualified VPC name to push the application to.\");\n    options.addOption(AUTH_TOKEN_SHORT_OPT_ARG,AUTH_TOKEN_LONG_OPT_ARG, true, \"Auth token of the account.\");\n\n    options.addOption(RESOURCE_SHORT_OPT_ARG, RESOURCE_LONG_OPT_ARG, true, \"Jar that contains the application.\");\n    options.addOption(APPLICATION_SHORT_OPT_ARG, APPLICATION_LONG_OPT_ARG, true, \"Application Id.\");\n    options.addOption(PROCESSOR_SHORT_OPT_ARG, PROCESSOR_LONG_OPT_ARG, true, \"Processor Id.\");\n    options.addOption(VPC_SHORT_OPT_ARG, VPC_LONG_OPT_ARG, true, \"Fully qualified VPC name to push\" +\n      \" the application to.\");\n    options.addOption(AUTH_TOKEN_SHORT_OPT_ARG, AUTH_TOKEN_LONG_OPT_ARG, true, \"Auth token of the account.\");\n\n\n    CommandLine commandLine = null;\n\n    try {\n      commandLine = commandLineParser.parse(options, Arrays.copyOfRange(args, 1, args.length));\n\n      if (\"help\".equals(command)) {\n        printHelp(options);\n      }\n      //Check if the appropriate args are passed in for each of the commands\n\n      if (\"deploy\".equals(command)) {\n        Preconditions.checkArgument(commandLine.hasOption(RESOURCE_LONG_OPT_ARG),\n          \"deploy command should have resource argument\");\n        this.resource = commandLine.getOptionValue(RESOURCE_LONG_OPT_ARG);\n      }\n      if (\"start\".equals(command)) {\n        Preconditions.checkArgument(commandLine.hasOption(APPLICATION_LONG_OPT_ARG), \"start command should\" +\n          \" have application argument\");\n        Preconditions.checkArgument(commandLine.hasOption(PROCESSOR_LONG_OPT_ARG), \"start command should \" +\n          \"have processor argument\");\n\n        this.application = commandLine.getOptionValue(APPLICATION_LONG_OPT_ARG);\n        this.processor = commandLine.getOptionValue(PROCESSOR_LONG_OPT_ARG);\n      }\n      if (\"stop\".equals(command)) {\n        Preconditions.checkArgument(commandLine.hasOption(APPLICATION_LONG_OPT_ARG), \"stop command should have\" +\n          \" application argument\");\n        Preconditions.checkArgument(commandLine.hasOption(PROCESSOR_LONG_OPT_ARG), \"stop command should have \" +\n          \"processor argument\");\n\n        this.application = commandLine.getOptionValue(APPLICATION_LONG_OPT_ARG);\n        this.processor = commandLine.getOptionValue(PROCESSOR_LONG_OPT_ARG);\n\n      }\n      if (\"status\".equals(command)) {\n        Preconditions.checkArgument(commandLine.hasOption(APPLICATION_LONG_OPT_ARG), \"status command should have \" +\n          \"application argument\");\n        Preconditions.checkArgument(commandLine.hasOption(PROCESSOR_LONG_OPT_ARG), \"status command should have\" +\n          \" processor argument\");\n\n        this.application = commandLine.getOptionValue(APPLICATION_LONG_OPT_ARG);\n        this.processor = commandLine.getOptionValue(PROCESSOR_LONG_OPT_ARG);\n\n      }\n      if (\"promote\".equals(command)) {\n        Preconditions.checkArgument(commandLine.hasOption(VPC_LONG_OPT_ARG), \"promote command should have\" +\n          \"vpc argument\");\n        Preconditions.checkArgument(commandLine.hasOption(AUTH_TOKEN_LONG_OPT_ARG), \"promote command should \" +\n          \"have auth token argument\");\n        Preconditions.checkArgument(commandLine.hasOption(APPLICATION_LONG_OPT_ARG), \"promote command should have\" +\n          \" application argument\");\n\n        this.vpc = commandLine.getOptionValue(VPC_LONG_OPT_ARG);\n        this.authToken = commandLine.getOptionValue(AUTH_TOKEN_LONG_OPT_ARG);\n        this.application = commandLine.getOptionValue(APPLICATION_LONG_OPT_ARG);\n      }\n    } catch (ParseException e) {\n      printHelp(options);\n    } catch (Exception e) {\n      printHelp(options);\n      throw Throwables.propagate(e);\n    }\n\n    return command;\n  }","id":99378,"modified_method":"/**\n   * Configure the Client to execute commands\n   *\n   * @param configuration Instance of {@code CConfiguration}\n   * @param args          array of String arguments\n   * @return Command that will be executed\n   * @throws ParseException on errors in commnd line parsing\n   */\n  public String configure(CConfiguration configuration, String args[]) {\n\n    this.configuration = configuration;\n    this.command = null;\n    Preconditions.checkArgument(args.length >= 1, \"Not enough arguments\");\n    boolean knownCommand = availableCommands.contains(args[0]);\n    Preconditions.checkArgument(knownCommand, \"Unknown Command specified\");\n\n    String sentCommand = args[0];\n\n    CommandLineParser commandLineParser = new GnuParser();\n\n    Options options = new Options();\n\n    options.addOption(\"a\",APPLICATION_LONG_OPT_ARG, true, \"Application Id.\");\n    options.addOption(\"r\",ARCHIVE_LONG_OPT_ARG,true, \"Archive that contains the application.\");\n    options.addOption(\"p\",PROCEDURE_LONG_OPT_ARG, true, \"Procedure Id.\");\n    options.addOption(\"h\",HOSTNAME_LONG_OPT_ARG, true, \"Hostname to push the application to.\");\n    options.addOption(\"k\",APIKEY_LONG_OPT_ARG, true, \"Apikey of the account.\");\n    options.addOption(\"f\",FLOW_LONG_OPT_ARG, true, \"Procedure Id.\");\n\n    CommandLine commandLine = null;\n\n    try {\n      commandLine = commandLineParser.parse(options, Arrays.copyOfRange(args, 1, args.length));\n\n      if (\"help\".equals(sentCommand)) {\n        printHelp(options);\n      }\n\n      //Check if the appropriate args are passed in for each of the commands\n      if (\"deploy\".equals(sentCommand)) {\n        Preconditions.checkArgument(commandLine.hasOption(ARCHIVE_LONG_OPT_ARG),\n          \"deploy command should have archive argument\");\n        this.resource = commandLine.getOptionValue(ARCHIVE_LONG_OPT_ARG);\n      }\n      if (\"start\".equals(sentCommand)) {\n        Preconditions.checkArgument(commandLine.hasOption(APPLICATION_LONG_OPT_ARG), \"status command should have \" +\n          \"application argument\");\n        Preconditions.checkArgument(commandLine.hasOption(PROCEDURE_LONG_OPT_ARG) || commandLine.hasOption(FLOW_LONG_OPT_ARG) ,\n          \"start command should have procedure or flow argument\");\n\n        this.application = commandLine.getOptionValue(APPLICATION_LONG_OPT_ARG);\n        this.procedure = commandLine.getOptionValue(PROCEDURE_LONG_OPT_ARG);\n        this.flow = commandLine.getOptionValue(FLOW_LONG_OPT_ARG);\n      }\n      if (\"stop\".equals(sentCommand)) {\n        Preconditions.checkArgument(commandLine.hasOption(APPLICATION_LONG_OPT_ARG), \"status command should have \" +\n          \"application argument\");\n        Preconditions.checkArgument(commandLine.hasOption(PROCEDURE_LONG_OPT_ARG) || commandLine.hasOption(FLOW_LONG_OPT_ARG) ,\n          \"stop command should have procedure or flow argument\");\n\n        this.application = commandLine.getOptionValue(APPLICATION_LONG_OPT_ARG);\n        this.procedure = commandLine.getOptionValue(PROCEDURE_LONG_OPT_ARG);\n        this.flow = commandLine.getOptionValue(FLOW_LONG_OPT_ARG);\n\n      }\n      if (\"status\".equals(sentCommand)) {\n        Preconditions.checkArgument(commandLine.hasOption(APPLICATION_LONG_OPT_ARG), \"status command should have \" +\n          \"application argument\");\n        Preconditions.checkArgument(commandLine.hasOption(PROCEDURE_LONG_OPT_ARG) || commandLine.hasOption(FLOW_LONG_OPT_ARG) ,\n                                    \"status command should have procedure or flow argument\");\n\n        this.application = commandLine.getOptionValue(APPLICATION_LONG_OPT_ARG);\n        this.procedure = commandLine.getOptionValue(PROCEDURE_LONG_OPT_ARG);\n        this.flow = commandLine.getOptionValue(FLOW_LONG_OPT_ARG);\n\n      }\n      if (\"promote\".equals(sentCommand)) {\n        Preconditions.checkArgument(commandLine.hasOption(HOSTNAME_LONG_OPT_ARG), \"promote command should have\" +\n          \"vpc argument\");\n        Preconditions.checkArgument(commandLine.hasOption(APIKEY_LONG_OPT_ARG), \"promote command should \" +\n          \"have auth token argument\");\n        Preconditions.checkArgument(commandLine.hasOption(APPLICATION_LONG_OPT_ARG), \"promote command should have\" +\n          \" application argument\");\n\n        this.hostname = commandLine.getOptionValue(HOSTNAME_LONG_OPT_ARG);\n        this.authToken = commandLine.getOptionValue(APIKEY_LONG_OPT_ARG);\n        this.application = commandLine.getOptionValue(APPLICATION_LONG_OPT_ARG);\n      }\n\n      command = sentCommand;\n\n    } catch (ParseException e) {\n      printHelp(options);\n    } catch (Exception e) {\n      printHelp(options);\n      throw Throwables.propagate(e);\n    }\n\n    return command;\n  }","commit_id":"5bc5e2f4d97b7c99bdbadd393846a1703d5d717a","url":"https://github.com/caskdata/cdap"},{"original_method":"private void printHelp(Options options) {\n    String command = \"AppFabricClient help|deploy|start|stop|status|promote [OPTIONS]\";\n    HelpFormatter formatter = new HelpFormatter();\n    formatter.setWidth(120);\n    formatter.printHelp(command, options);\n  }","id":99379,"modified_method":"private void printHelp(Options options) {\n    PrintStream out = System.out;\n    Copyright.print(out);\n\n    out.println(\"Usage:\");\n    out.println(\"  app-fabric-client deploy  --archive <filename>\");\n    out.println(\"  app-fabric-client start   --application <id> ( --flow <id> | --procedure <id>)\");\n    out.println(\"  app-fabric-client stop    --application <id> ( --flow <id> | --procedure <id>)\");\n    out.println(\"  app-fabric-client status  --application <id> ( --flow <id> | --procedure <id>)\");\n    out.println(\"  app-fabric-client promote --application <id> --host <hostname> --apikey <key>\");\n\n    out.println(\"Options:\");\n    out.println(\"  --archive <filename> \\t Archive containing the application.\");\n    out.println(\"  --application <id> \\t Application Id.\");\n    out.println(\"  --flow <id> \\t\\t Flow id of the application.\");\n    out.println(\"  --procedure <id> \\t Procedure of in the application.\");\n    out.println(\"  --host <hostname> \\t Hostname to push the application to.\");\n    out.println(\"  --apikey <key> \\t Apikey of the account.\");\n  }","commit_id":"5bc5e2f4d97b7c99bdbadd393846a1703d5d717a","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testOptionsParsing() throws ParseException {\n    String[] args = {\"deploy\", \"-jar\", \"jar\"};\n    AppFabricClient client = new AppFabricClient();\n    client.configure(CConfiguration.create(), args);\n    assert (client != null);\n    assertTrue(\"deploy\".equals(client.getCommand()));\n  }","id":99380,"modified_method":"@Test\n  public void testOptionsParsing() throws ParseException {\n    String[] args = {\"deploy\", \"-archive\", \"jar\"};\n    AppFabricClient client = new AppFabricClient();\n    client.configure(CConfiguration.create(), args);\n    assert (client != null);\n    assertTrue(\"deploy\".equals(client.getCommand()));\n  }","commit_id":"5bc5e2f4d97b7c99bdbadd393846a1703d5d717a","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testValidInvalidStopArgs() throws ParseException {\n    AppFabricClient client = new AppFabricClient();\n    String command = null;\n    try {\n      command = client.configure(CConfiguration.create(), new String[]{\"stop\", \"--application\", \"args\"});\n    } catch (Exception e) {\n      assert (command == null);\n    }\n    try {\n      command = client.configure(CConfiguration.create(), new String[]{\"stop\", \"--processor\", \"args\"});\n    } catch (Exception e) {\n      assert (command == null);\n    }\n  }","id":99381,"modified_method":"@Test(expected = IllegalArgumentException.class)\n  public void testValidInvalidStopArgs() throws ParseException {\n    AppFabricClient client = new AppFabricClient();\n    String command = null;\n  }","commit_id":"5bc5e2f4d97b7c99bdbadd393846a1703d5d717a","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testValidArguments() throws ParseException {\n\n    AppFabricClient client = new AppFabricClient();\n    String command = null;\n    command = client.configure(CConfiguration.create(), new String[]{\"deploy\", \"--resource\", \"jar\"});\n    assertTrue(\"deploy\".equals(command));\n\n    command = client.configure(CConfiguration.create(), new String[]{\"start\", \"--application\", \"appId\",\n      \"--processor\", \"processor\"});\n    assertTrue(\"start\".equals(command));\n\n    command = client.configure(CConfiguration.create(), new String[]{\"stop\", \"--application\", \"appId\",\n      \"--processor\", \"processor\"});\n    assertTrue(\"stop\".equals(command));\n\n    command = client.configure(CConfiguration.create(), new String[]{\"status\", \"--application\", \"appId\",\n      \"--processor\", \"processor\"});\n    assertTrue(\"status\".equals(command));\n\n    command = client.configure(CConfiguration.create(), new String[]{\"promote\", \"--vpc\", \"vpc_name\",\n      \"--authtoken\", \"Auth token\",\n      \"--application\", \"application\"});\n    assertTrue(\"promote\".equals(command));\n\n  }","id":99382,"modified_method":"@Test\n  public void testValidArguments() throws ParseException {\n\n    AppFabricClient client = new AppFabricClient();\n    String command = null;\n    command = client.configure(CConfiguration.create(), new String[]{\"deploy\", \"--archive\", \"jar\"});\n    assertTrue(\"deploy\".equals(command));\n\n    command = client.configure(CConfiguration.create(), new String[]{\"start\", \"--application\", \"appId\",\n      \"--procedure\", \"processor\"});\n    assertTrue(\"start\".equals(command));\n\n\n    command = client.configure(CConfiguration.create(), new String[]{\"start\", \"--application\", \"appId\",\n      \"--flow\", \"processor\"});\n    assertTrue(\"start\".equals(command));\n\n\n    command = client.configure(CConfiguration.create(), new String[]{\"stop\", \"--application\", \"appId\",\n      \"--procedure\", \"processor\"});\n    assertTrue(\"stop\".equals(command));\n\n    command = client.configure(CConfiguration.create(), new String[]{\"stop\", \"--application\", \"appId\",\n      \"--flow\", \"processor\"});\n    assertTrue(\"stop\".equals(command));\n\n\n    command = client.configure(CConfiguration.create(), new String[]{\"status\", \"--application\", \"appId\",\n      \"--procedure\", \"processor\"});\n    assertTrue(\"status\".equals(command));\n    command = client.configure(CConfiguration.create(), new String[]{\"status\", \"--application\", \"appId\",\n      \"--flow\", \"processor\"});\n    assertTrue(\"status\".equals(command));\n\n    command = client.configure(CConfiguration.create(), new String[]{\"promote\", \"--hostname\", \"vpc_name\",\n      \"--apikey\", \"Auth token\",\n      \"--application\", \"application\"});\n    assertTrue(\"promote\".equals(command));\n\n  }","commit_id":"5bc5e2f4d97b7c99bdbadd393846a1703d5d717a","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testValidInvalidPromoteArgs() throws ParseException {\n    AppFabricClient client = new AppFabricClient();\n    String command = null;\n    try {\n      command = client.configure(CConfiguration.create(), new String[]{\"promote\", \"--vpc\", \"vpc_name\",\n        \"--application\", \"application\"});\n      assertTrue(false); //This should not happen\n    } catch (Exception e) {\n      assert (command == null);\n    }\n    try {\n      command = client.configure(CConfiguration.create(), new String[]{\"promote\", \"--vpc\", \"vpc_name\",\n        \"--application\", \"application\"});\n      assertTrue(false); //This should not happen\n    } catch (Exception e) {\n      assert (command == null);\n    }\n    try {\n      command = client.configure(CConfiguration.create(), new String[]{\"promote\",\n        \"--authtoken\", \"Auth token\",\n        \"--application\", \"application\"});\n      assertTrue(false); //This should not happen\n    } catch (Exception e) {\n      assert (command == null);\n    }\n  }","id":99383,"modified_method":"@Test\n  public void testValidInvalidPromoteArgs() throws ParseException {\n    AppFabricClient client = new AppFabricClient();\n    String command = null;\n    command = client.configure(CConfiguration.create(), new String[]{\"promote\", \"--host\", \"hostname\",\n      \"--application\", \"application\"});\n    assert (command == null);\n  }","commit_id":"5bc5e2f4d97b7c99bdbadd393846a1703d5d717a","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testValidInvalidStatusArgs() throws ParseException {\n    AppFabricClient client = new AppFabricClient();\n    String command = null;\n    try {\n      command = client.configure(CConfiguration.create(), new String[]{\"status\", \"--application\", \"args\"});\n      assertTrue(false); //This should not happen\n    } catch (Exception e) {\n      assert (command == null);\n    }\n    try {\n      command = client.configure(CConfiguration.create(), new String[]{\"status\", \"--processor\", \"args\"});\n      assertTrue(false); //This should not happen\n    } catch (Exception e) {\n      assert (command == null);\n    }\n  }","id":99384,"modified_method":"@Test(expected = IllegalArgumentException.class)\n  public void testValidInvalidStatusArgs() throws ParseException {\n    AppFabricClient client = new AppFabricClient();\n    String command = null;\n    command = client.configure(CConfiguration.create(), new String[]{\"status\", \"--application\", \"args\"});\n }","commit_id":"5bc5e2f4d97b7c99bdbadd393846a1703d5d717a","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test(expected = IllegalArgumentException.class)\n  public void testValidInvalidDeployArgs() throws ParseException {\n    AppFabricClient client = new AppFabricClient();\n    String command = client.configure(CConfiguration.create(), new String[]{\"deploy\"});\n  }","id":99385,"modified_method":"@Test (expected = IllegalArgumentException.class)\n  public void testValidInvalidDeployArgs() throws ParseException {\n    AppFabricClient client = new AppFabricClient();\n    String command = client.configure(CConfiguration.create(), new String[]{\"deploy\"});\n    assert (command == null);\n  }","commit_id":"5bc5e2f4d97b7c99bdbadd393846a1703d5d717a","url":"https://github.com/caskdata/cdap"},{"original_method":"public static Map sendCommEventAsEmail(DispatchContext ctx, Map context) {\n        GenericDelegator delegator = ctx.getDelegator();\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        GenericValue userLogin = (GenericValue) context.get(\"userLogin\");\n        Locale locale = (Locale) context.get(\"locale\");\n                \n        String communicationEventId = (String) context.get(\"communicationEventId\");\n        \n        Map result = ServiceUtil.returnSuccess();\n        List errorMessages = new LinkedList();                   // used to keep a list of all error messages returned from sending emails to contact list\n        \n        try {\n            // find the communication event and make sure that it is actually an email\n            GenericValue communicationEvent = delegator.findByPrimaryKey(\"CommunicationEvent\", UtilMisc.toMap(\"communicationEventId\", communicationEventId));\n            if (communicationEvent == null) {\n                String errMsg = UtilProperties.getMessage(resource,\"commeventservices.communication_event_not_found_failure\", locale);\n                return ServiceUtil.returnError(errMsg + \" \" + communicationEventId);\n            }\n            if ((communicationEvent.getString(\"communicationEventTypeId\") == null) ||\n                !(communicationEvent.getString(\"communicationEventTypeId\").equals(\"EMAIL_COMMUNICATION\"))) {\n                String errMsg = UtilProperties.getMessage(resource,\"commeventservices.communication_event_must_be_email_for_email\", locale);\n                return ServiceUtil.returnError(errMsg + \" \" + communicationEventId);\n            }\n            // make sure the from contact mech is an email if it is specified\n            if ((communicationEvent.getRelatedOne(\"FromContactMech\") == null) ||\n                 (!(communicationEvent.getRelatedOne(\"FromContactMech\").getString(\"contactMechTypeId\").equals(\"EMAIL_ADDRESS\")) ||\n                 (communicationEvent.getRelatedOne(\"FromContactMech\").getString(\"infoString\") == null))) {\n                String errMsg = UtilProperties.getMessage(resource,\"commeventservices.communication_event_from_contact_mech_must_be_email\", locale);\n                return ServiceUtil.returnError(errMsg + \" \" + communicationEventId);\n            }\n                        \n            // prepare the email\n            Map sendMailParams = new HashMap();\n            sendMailParams.put(\"sendFrom\", communicationEvent.getRelatedOne(\"FromContactMech\").getString(\"infoString\"));\n            sendMailParams.put(\"subject\", communicationEvent.getString(\"subject\"));\n            sendMailParams.put(\"body\", communicationEvent.getString(\"content\"));\n            sendMailParams.put(\"contentType\", communicationEvent.getString(\"contentMimeTypeId\"));\n            sendMailParams.put(\"userLogin\", userLogin);\n            \n            // if there is no contact list, then send look for a contactMechIdTo and partyId\n            if ((communicationEvent.getString(\"contactListId\") == null) ||\n                (communicationEvent.getString(\"contactListId\").equals(\"\"))) {\n                \n                // in this case, first make sure that the to contact mech actually is an email\n                if ((communicationEvent.getRelatedOne(\"ToContactMech\") == null) || \n                        (!(communicationEvent.getRelatedOne(\"ToContactMech\").getString(\"contactMechTypeId\").equals(\"EMAIL_ADDRESS\")) ||\n                        (communicationEvent.getRelatedOne(\"ToContactMech\").getString(\"infoString\") == null))) {\n                       String errMsg = UtilProperties.getMessage(resource,\"commeventservices.communication_event_to_contact_mech_must_be_email\", locale);\n                       return ServiceUtil.returnError(errMsg + \" \" + communicationEventId);\n                   }\n                \n                sendMailParams.put(\"communicationEventId\", communicationEventId);\n                sendMailParams.put(\"sendTo\", communicationEvent.getRelatedOne(\"ToContactMech\").getString(\"infoString\"));\n                sendMailParams.put(\"partyId\", communicationEvent.getString(\"partyIdTo\"));  // who it's going to\n                \n                // send it\n                Map tmpResult = dispatcher.runSync(\"sendMail\", sendMailParams);\n                if (ServiceUtil.isError(tmpResult)) {\n                    errorMessages.add(ServiceUtil.getErrorMessage(tmpResult));\n                } else {\n                    Map completeResult = dispatcher.runSync(\"setCommEventComplete\", UtilMisc.toMap(\"communicationEventId\", communicationEventId, \"userLogin\", userLogin));                    \n                    if (ServiceUtil.isError(completeResult)) {\n                        errorMessages.add(ServiceUtil.getErrorMessage(completeResult));\n                    }\n                }\n            } else {\n\n                // Call the sendEmailToContactList service if there's a contactListId present\n                Map sendEmailToContactListContext = new HashMap();\n                sendEmailToContactListContext.put(\"contactListId\", communicationEvent.getString(\"contactListId\"));\n                sendEmailToContactListContext.put(\"communicationEventId\", communicationEventId);\n                sendEmailToContactListContext.put(\"userLogin\", userLogin);\n                try {\n                    dispatcher.runAsync(\"sendEmailToContactList\", sendEmailToContactListContext);\n                } catch( GenericServiceException e ) {\n                    String errMsg = UtilProperties.getMessage(resource, \"commeventservices.errorCallingSendEmailToContactListService\", locale);\n                    Debug.logError(e, errMsg, module);\n                    errorMessages.add(errMsg);\n                    errorMessages.addAll(e.getMessageList());\n                }\n            }\n        } catch (GenericEntityException eex) {\n            ServiceUtil.returnError(eex.getMessage());\n        } catch (GenericServiceException esx) {\n            ServiceUtil.returnError(esx.getMessage());\n        }\n        \n        // If there were errors, then the result of this service should be error with the full list of messages\n        if (errorMessages.size() > 0) {\n            result = ServiceUtil.returnError(errorMessages);\n        }\n        return result;\n    }","id":99386,"modified_method":"public static Map sendCommEventAsEmail(DispatchContext ctx, Map context) {\n        GenericDelegator delegator = ctx.getDelegator();\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        GenericValue userLogin = (GenericValue) context.get(\"userLogin\");\n        Locale locale = (Locale) context.get(\"locale\");\n                \n        String communicationEventId = (String) context.get(\"communicationEventId\");\n        \n        Map result = ServiceUtil.returnSuccess();\n        List errorMessages = new LinkedList(); // used to keep a list of all error messages returned from sending emails to contact list\n        \n        try {\n            // find the communication event and make sure that it is actually an email\n            GenericValue communicationEvent = delegator.findByPrimaryKey(\"CommunicationEvent\", UtilMisc.toMap(\"communicationEventId\", communicationEventId));\n            if (communicationEvent == null) {\n                String errMsg = UtilProperties.getMessage(resource,\"commeventservices.communication_event_not_found_failure\", locale);\n                return ServiceUtil.returnError(errMsg + \" \" + communicationEventId);\n            }\n            String communicationEventType = communicationEvent.getString(\"communicationEventTypeId\");\n            if (communicationEventType == null || !(\"EMAIL_COMMUNICATION\".equals(communicationEventType) || \"AUTO_EMAIL_COMM\".equals(communicationEventType))) {\n                String errMsg = UtilProperties.getMessage(resource,\"commeventservices.communication_event_must_be_email_for_email\", locale);\n                return ServiceUtil.returnError(errMsg + \" \" + communicationEventId);\n            }\n\n            // make sure the from contact mech is an email if it is specified\n            if ((communicationEvent.getRelatedOne(\"FromContactMech\") == null) ||\n                 (!(communicationEvent.getRelatedOne(\"FromContactMech\").getString(\"contactMechTypeId\").equals(\"EMAIL_ADDRESS\")) ||\n                 (communicationEvent.getRelatedOne(\"FromContactMech\").getString(\"infoString\") == null))) {\n                String errMsg = UtilProperties.getMessage(resource,\"commeventservices.communication_event_from_contact_mech_must_be_email\", locale);\n                return ServiceUtil.returnError(errMsg + \" \" + communicationEventId);\n            }\n\n            // prepare the email\n            Map sendMailParams = new HashMap();\n            sendMailParams.put(\"sendFrom\", communicationEvent.getRelatedOne(\"FromContactMech\").getString(\"infoString\"));\n            sendMailParams.put(\"subject\", communicationEvent.getString(\"subject\"));\n            sendMailParams.put(\"body\", communicationEvent.getString(\"content\"));\n            sendMailParams.put(\"contentType\", communicationEvent.getString(\"contentMimeTypeId\"));\n            sendMailParams.put(\"userLogin\", userLogin);\n            \n            // if there is no contact list, then send look for a contactMechIdTo and partyId\n            if ((UtilValidate.isEmpty(communicationEvent.getString(\"contactListId\")))) {\n                // send to address\n                String sendTo = communicationEvent.getString(\"toString\");\n\n                if (UtilValidate.isEmpty(sendTo)) {\n                    GenericValue toContactMech = communicationEvent.getRelatedOne(\"ToContactMech\");\n                    if (toContactMech != null && \"EMAIL_ADDRESS\".equals(toContactMech.getString(\"contactMechTypeId\"))) {\n                        sendTo = toContactMech.getString(\"infoString\");\n                    }\n                }\n                if (UtilValidate.isEmpty(sendTo)) {\n                    String errMsg = UtilProperties.getMessage(resource,\"commeventservices.communication_event_to_contact_mech_must_be_email\", locale);\n                    return ServiceUtil.returnError(errMsg + \" \" + communicationEventId);\n                }\n\n                sendMailParams.put(\"communicationEventId\", communicationEventId);\n                sendMailParams.put(\"sendTo\", sendTo);\n                sendMailParams.put(\"partyId\", communicationEvent.getString(\"partyIdTo\"));  // who it's going to\n                \n                // send it\n                Map tmpResult = dispatcher.runSync(\"sendMail\", sendMailParams);\n                if (ServiceUtil.isError(tmpResult)) {\n                    errorMessages.add(ServiceUtil.getErrorMessage(tmpResult));\n                } else {\n                    Map completeResult = dispatcher.runSync(\"setCommEventComplete\", UtilMisc.toMap(\"communicationEventId\", communicationEventId, \"userLogin\", userLogin));                    \n                    if (ServiceUtil.isError(completeResult)) {\n                        errorMessages.add(ServiceUtil.getErrorMessage(completeResult));\n                    }\n                }\n\n                // set the message ID on this communication event\n                String messageId = (String) tmpResult.get(\"messageId\");\n                communicationEvent.set(\"messageId\", messageId);\n                try {\n                    communicationEvent.store();\n                } catch (GenericEntityException e) {\n                    Debug.logError(e, module);\n                    return ServiceUtil.returnError(e.getMessage());\n                }\n            } else {\n                // Call the sendEmailToContactList service if there's a contactListId present\n                Map sendEmailToContactListContext = new HashMap();\n                sendEmailToContactListContext.put(\"contactListId\", communicationEvent.getString(\"contactListId\"));\n                sendEmailToContactListContext.put(\"communicationEventId\", communicationEventId);\n                sendEmailToContactListContext.put(\"userLogin\", userLogin);\n                try {\n                    dispatcher.runAsync(\"sendEmailToContactList\", sendEmailToContactListContext);\n                } catch( GenericServiceException e ) {\n                    String errMsg = UtilProperties.getMessage(resource, \"commeventservices.errorCallingSendEmailToContactListService\", locale);\n                    Debug.logError(e, errMsg, module);\n                    errorMessages.add(errMsg);\n                    errorMessages.addAll(e.getMessageList());\n                }\n            }\n        } catch (GenericEntityException eex) {\n            ServiceUtil.returnError(eex.getMessage());\n        } catch (GenericServiceException esx) {\n            ServiceUtil.returnError(esx.getMessage());\n        }\n        \n        // If there were errors, then the result of this service should be error with the full list of messages\n        if (errorMessages.size() > 0) {\n            result = ServiceUtil.returnError(errorMessages);\n        }\n        return result;\n    }","commit_id":"13cef57ef0c12cb69fc8f5714350a390e30350a7","url":"https://github.com/apache/ofbiz"},{"original_method":"public static Map sendCommEventAsEmail(DispatchContext ctx, Map context) {\n        GenericDelegator delegator = ctx.getDelegator();\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        GenericValue userLogin = (GenericValue) context.get(\"userLogin\");\n        Locale locale = (Locale) context.get(\"locale\");\n                \n        String communicationEventId = (String) context.get(\"communicationEventId\");\n        \n        Map result = ServiceUtil.returnSuccess();\n        List errorMessages = new LinkedList();                   // used to keep a list of all error messages returned from sending emails to contact list\n        \n        try {\n            // find the communication event and make sure that it is actually an email\n            GenericValue communicationEvent = delegator.findByPrimaryKey(\"CommunicationEvent\", UtilMisc.toMap(\"communicationEventId\", communicationEventId));\n            if (communicationEvent == null) {\n                String errMsg = UtilProperties.getMessage(resource,\"commeventservices.communication_event_not_found_failure\", locale);\n                return ServiceUtil.returnError(errMsg + \" \" + communicationEventId);\n            }\n            if ((communicationEvent.getString(\"communicationEventTypeId\") == null) ||\n                !(communicationEvent.getString(\"communicationEventTypeId\").equals(\"EMAIL_COMMUNICATION\"))) {\n                String errMsg = UtilProperties.getMessage(resource,\"commeventservices.communication_event_must_be_email_for_email\", locale);\n                return ServiceUtil.returnError(errMsg + \" \" + communicationEventId);\n            }\n            // make sure the from contact mech is an email if it is specified\n            if ((communicationEvent.getRelatedOne(\"FromContactMech\") == null) ||\n                 (!(communicationEvent.getRelatedOne(\"FromContactMech\").getString(\"contactMechTypeId\").equals(\"EMAIL_ADDRESS\")) ||\n                 (communicationEvent.getRelatedOne(\"FromContactMech\").getString(\"infoString\") == null))) {\n                String errMsg = UtilProperties.getMessage(resource,\"commeventservices.communication_event_from_contact_mech_must_be_email\", locale);\n                return ServiceUtil.returnError(errMsg + \" \" + communicationEventId);\n            }\n                        \n            // prepare the email\n            Map sendMailParams = new HashMap();\n            sendMailParams.put(\"sendFrom\", communicationEvent.getRelatedOne(\"FromContactMech\").getString(\"infoString\"));\n            sendMailParams.put(\"subject\", communicationEvent.getString(\"subject\"));\n            sendMailParams.put(\"body\", communicationEvent.getString(\"content\"));\n            sendMailParams.put(\"contentType\", communicationEvent.getString(\"contentMimeTypeId\"));\n            sendMailParams.put(\"userLogin\", userLogin);\n            \n            // if there is no contact list, then send look for a contactMechIdTo and partyId\n            if ((communicationEvent.getString(\"contactListId\") == null) ||\n                (communicationEvent.getString(\"contactListId\").equals(\"\"))) {\n                \n                // in this case, first make sure that the to contact mech actually is an email\n                if ((communicationEvent.getRelatedOne(\"ToContactMech\") == null) || \n                        (!(communicationEvent.getRelatedOne(\"ToContactMech\").getString(\"contactMechTypeId\").equals(\"EMAIL_ADDRESS\")) ||\n                        (communicationEvent.getRelatedOne(\"ToContactMech\").getString(\"infoString\") == null))) {\n                       String errMsg = UtilProperties.getMessage(resource,\"commeventservices.communication_event_to_contact_mech_must_be_email\", locale);\n                       return ServiceUtil.returnError(errMsg + \" \" + communicationEventId);\n                   }\n                \n                sendMailParams.put(\"communicationEventId\", communicationEventId);\n                sendMailParams.put(\"sendTo\", communicationEvent.getRelatedOne(\"ToContactMech\").getString(\"infoString\"));\n                sendMailParams.put(\"partyId\", communicationEvent.getString(\"partyIdTo\"));  // who it's going to\n                \n                // send it\n                Map tmpResult = dispatcher.runSync(\"sendMail\", sendMailParams);\n                if (ServiceUtil.isError(tmpResult)) {\n                    errorMessages.add(ServiceUtil.getErrorMessage(tmpResult));\n                } \n            } else {\n                // there's actually a contact list here, so we want to be sending to the entire contact list\n                GenericValue ContactList = communicationEvent.getRelatedOne(\"ContactList\");\n                List sendToParties = ContactList.getRelated(\"ContactListParty\");\n                \n                for (Iterator it = sendToParties.iterator(); it.hasNext(); ) {\n                    GenericValue nextSendToParty = (GenericValue) it.next();\n                    if ((nextSendToParty != null) && (nextSendToParty.getRelatedOne(\"PreferredContactMech\") != null)) {\n                        sendMailParams.put(\"sendTo\", nextSendToParty.getRelatedOne(\"PreferredContactMech\").getString(\"infoString\"));\n                        sendMailParams.put(\"partyId\", nextSendToParty.getString(\"partyId\"));\n                    } else {\n                        Debug.logWarning(\"Cannot find a preferred contact mech for [\" + nextSendToParty + \"]\", module);\n                    }\n                    \n                    // no communicationEventId here - we want to create a communication event for each member of the contact list\n            \n                    // could be run async as well, but that may spawn a lot of processes if there's a large list and cause problems\n                    Map tmpResult = dispatcher.runSync(\"sendMail\", sendMailParams);\n                    if (ServiceUtil.isError(tmpResult)) {\n                        errorMessages.add(ServiceUtil.getErrorMessage(tmpResult));\n                    }\n                }\n            }\n        } catch (GenericEntityException eex) {\n            ServiceUtil.returnError(eex.getMessage());\n        } catch (GenericServiceException esx) {\n            ServiceUtil.returnError(esx.getMessage());\n        }\n        \n        // if there were errors, then the result of this service should be error with the full list of messages\n        if (errorMessages.size() > 0) {\n            result = ServiceUtil.returnError(errorMessages);\n        }\n        return result;\n    }","id":99387,"modified_method":"public static Map sendCommEventAsEmail(DispatchContext ctx, Map context) {\n        GenericDelegator delegator = ctx.getDelegator();\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        GenericValue userLogin = (GenericValue) context.get(\"userLogin\");\n        Locale locale = (Locale) context.get(\"locale\");\n                \n        String communicationEventId = (String) context.get(\"communicationEventId\");\n        \n        Map result = ServiceUtil.returnSuccess();\n        List errorMessages = new LinkedList();                   // used to keep a list of all error messages returned from sending emails to contact list\n        \n        try {\n            // find the communication event and make sure that it is actually an email\n            GenericValue communicationEvent = delegator.findByPrimaryKey(\"CommunicationEvent\", UtilMisc.toMap(\"communicationEventId\", communicationEventId));\n            if (communicationEvent == null) {\n                String errMsg = UtilProperties.getMessage(resource,\"commeventservices.communication_event_not_found_failure\", locale);\n                return ServiceUtil.returnError(errMsg + \" \" + communicationEventId);\n            }\n            if ((communicationEvent.getString(\"communicationEventTypeId\") == null) ||\n                !(communicationEvent.getString(\"communicationEventTypeId\").equals(\"EMAIL_COMMUNICATION\"))) {\n                String errMsg = UtilProperties.getMessage(resource,\"commeventservices.communication_event_must_be_email_for_email\", locale);\n                return ServiceUtil.returnError(errMsg + \" \" + communicationEventId);\n            }\n            // make sure the from contact mech is an email if it is specified\n            if ((communicationEvent.getRelatedOne(\"FromContactMech\") == null) ||\n                 (!(communicationEvent.getRelatedOne(\"FromContactMech\").getString(\"contactMechTypeId\").equals(\"EMAIL_ADDRESS\")) ||\n                 (communicationEvent.getRelatedOne(\"FromContactMech\").getString(\"infoString\") == null))) {\n                String errMsg = UtilProperties.getMessage(resource,\"commeventservices.communication_event_from_contact_mech_must_be_email\", locale);\n                return ServiceUtil.returnError(errMsg + \" \" + communicationEventId);\n            }\n                        \n            // prepare the email\n            Map sendMailParams = new HashMap();\n            sendMailParams.put(\"sendFrom\", communicationEvent.getRelatedOne(\"FromContactMech\").getString(\"infoString\"));\n            sendMailParams.put(\"subject\", communicationEvent.getString(\"subject\"));\n            sendMailParams.put(\"body\", communicationEvent.getString(\"content\"));\n            sendMailParams.put(\"contentType\", communicationEvent.getString(\"contentMimeTypeId\"));\n            sendMailParams.put(\"userLogin\", userLogin);\n            \n            // if there is no contact list, then send look for a contactMechIdTo and partyId\n            if ((communicationEvent.getString(\"contactListId\") == null) ||\n                (communicationEvent.getString(\"contactListId\").equals(\"\"))) {\n                \n                // in this case, first make sure that the to contact mech actually is an email\n                if ((communicationEvent.getRelatedOne(\"ToContactMech\") == null) || \n                        (!(communicationEvent.getRelatedOne(\"ToContactMech\").getString(\"contactMechTypeId\").equals(\"EMAIL_ADDRESS\")) ||\n                        (communicationEvent.getRelatedOne(\"ToContactMech\").getString(\"infoString\") == null))) {\n                       String errMsg = UtilProperties.getMessage(resource,\"commeventservices.communication_event_to_contact_mech_must_be_email\", locale);\n                       return ServiceUtil.returnError(errMsg + \" \" + communicationEventId);\n                   }\n                \n                sendMailParams.put(\"communicationEventId\", communicationEventId);\n                sendMailParams.put(\"sendTo\", communicationEvent.getRelatedOne(\"ToContactMech\").getString(\"infoString\"));\n                sendMailParams.put(\"partyId\", communicationEvent.getString(\"partyIdTo\"));  // who it's going to\n                \n                // send it\n                Map tmpResult = dispatcher.runSync(\"sendMail\", sendMailParams);\n                if (ServiceUtil.isError(tmpResult)) {\n                    errorMessages.add(ServiceUtil.getErrorMessage(tmpResult));\n                } \n            } else {\n                // there's actually a contact list here, so we want to be sending to the entire contact list\n                GenericValue contactList = communicationEvent.getRelatedOne(\"ContactList\");\n\n                // find active, ACCEPTED parties in the contact list using a list iterator (because there can be a large number)\n                EntityConditionList conditions = new EntityConditionList( UtilMisc.toList(\n                            new EntityExpr(\"contactListId\", EntityOperator.EQUALS, contactList.get(\"contactListId\")),\n                            new EntityExpr(\"statusId\", EntityOperator.EQUALS, \"CLPT_ACCEPTED\"),\n                            new EntityExpr(\"preferredContactMechId\", EntityOperator.NOT_EQUAL, null),\n                            EntityUtil.getFilterByDateExpr()\n                            ), EntityOperator.AND);\n                List fieldsToSelect = UtilMisc.toList(\"partyId\", \"preferredContactMechId\");\n                EntityListIterator sendToPartiesIt = delegator.findListIteratorByCondition(\"ContactListParty\", conditions,  null, fieldsToSelect, null,\n                        new EntityFindOptions(true, EntityFindOptions.TYPE_SCROLL_INSENSITIVE, EntityFindOptions.CONCUR_READ_ONLY, true));\n                \n                // send an email to each contact list member\n                GenericValue nextSendToParty = null;\n                while ((nextSendToParty = (GenericValue) sendToPartiesIt.next()) != null) {\n                    GenericValue email = nextSendToParty.getRelatedOne(\"PreferredContactMech\");\n                    if (email == null) continue;\n\n                    sendMailParams.put(\"sendTo\", email.getString(\"infoString\"));\n                    sendMailParams.put(\"partyId\", nextSendToParty.getString(\"partyId\"));\n                    \n                    // no communicationEventId here - we want to create a communication event for each member of the contact list\n            \n                    // could be run async as well, but that may spawn a lot of processes if there's a large list and cause problems\n                    Map tmpResult = dispatcher.runSync(\"sendMail\", sendMailParams);\n                    if (ServiceUtil.isError(tmpResult)) {\n                        errorMessages.add(ServiceUtil.getErrorMessage(tmpResult));\n                    }\n                }\n                sendToPartiesIt.close();\n            }\n        } catch (GenericEntityException eex) {\n            ServiceUtil.returnError(eex.getMessage());\n        } catch (GenericServiceException esx) {\n            ServiceUtil.returnError(esx.getMessage());\n        }\n        \n        // if there were errors, then the result of this service should be error with the full list of messages\n        if (errorMessages.size() > 0) {\n            result = ServiceUtil.returnError(errorMessages);\n        }\n        return result;\n    }","commit_id":"fcf56e2f02519b85c9ba628b365a51b167329e8b","url":"https://github.com/apache/ofbiz"},{"original_method":"private void loadCallParams(UMOEvent event, String namespace) throws ClassNotFoundException {\n        callParameters = new HashMap();\n        Map methodCalls = (Map) event.getProperty(\"soapMethods\");\n        if (methodCalls == null) {\n            return;\n        }\n\n        Map.Entry entry;\n        SoapMethod soapMethod;\n        for (Iterator iterator = methodCalls.entrySet().iterator(); iterator.hasNext();) {\n            entry = (Map.Entry) iterator.next();\n\n            if (StringUtils.isEmpty(namespace)) {\n                if (entry.getValue() instanceof List) {\n                    soapMethod = new SoapMethod(entry.getKey().toString(), (List) entry.getValue());\n                } else {\n                    soapMethod = new SoapMethod(entry.getKey().toString(), entry.getValue().toString());\n                }\n            } else {\n                if (entry.getValue() instanceof List) {\n                    soapMethod = new SoapMethod(new QName(namespace, entry.getKey().toString()), (List) entry.getValue());\n                } else {\n                    soapMethod = new SoapMethod(new QName(namespace, entry.getKey().toString()), entry.getValue().toString());\n                }\n            }\n            callParameters.put(soapMethod.getName().getLocalPart(), soapMethod);\n        }\n    }","id":99388,"modified_method":"private void loadCallParams(UMOEvent event, String namespace) throws ClassNotFoundException {\n        Map methodCalls = (Map) event.getMessage().getProperty(\"soapMethods\");\n        if (methodCalls == null) {\n            return;\n        }\n\n        Map.Entry entry;\n        SoapMethod soapMethod;\n        callParameters = new HashMap();\n\n        for (Iterator iterator = methodCalls.entrySet().iterator(); iterator.hasNext();) {\n            entry = (Map.Entry) iterator.next();\n            if (StringUtils.isEmpty(namespace)) {\n                if (entry.getValue() instanceof List) {\n                    soapMethod = new SoapMethod(entry.getKey().toString(), (List) entry.getValue());\n                } else {\n                    soapMethod = new SoapMethod(entry.getKey().toString(), entry.getValue().toString());\n                }\n            } else {\n                if (entry.getValue() instanceof List) {\n                    soapMethod = new SoapMethod(new QName(namespace, entry.getKey().toString()), (List) entry.getValue());\n                } else {\n                    soapMethod = new SoapMethod(new QName(namespace, entry.getKey().toString()), entry.getValue().toString());\n                }\n            }\n            callParameters.put(soapMethod.getName().getLocalPart(), soapMethod);\n        }\n    }","commit_id":"f5f013129b5786417f5863d7672af030f73eb587","url":"https://github.com/mulesoft/mule"},{"original_method":"protected EngineConfiguration getClientConfig(UMOEvent event) {\n        if(clientConfig==null) {\n            //Allow the client config to be set on the endpoint\n            String config = null;\n            if(event!=null) {\n                config = event.getStringProperty(AxisConnector.AXIS_CLIENT_CONFIG_PROPERTY, null);\n            }\n            if(config!=null) {\n                clientConfig = new FileProvider(config);\n            } else {\n                clientConfig = connector.getClientProvider();\n            }\n        }\n        return clientConfig;\n    }","id":99389,"modified_method":"protected EngineConfiguration getClientConfig(UMOEvent event) {\n        if(clientConfig==null) {\n            //Allow the client config to be set on the endpoint\n            String config = null;\n            if(event!=null) {\n                config = event.getMessage().getStringProperty(AxisConnector.AXIS_CLIENT_CONFIG_PROPERTY, null);\n            }\n            if(config!=null) {\n                clientConfig = new FileProvider(config);\n            } else {\n                clientConfig = connector.getClientProvider();\n            }\n        }\n        return clientConfig;\n    }","commit_id":"f5f013129b5786417f5863d7672af030f73eb587","url":"https://github.com/mulesoft/mule"},{"original_method":"protected Call getCall(UMOEvent event, Object[] args) throws Exception {\n        UMOEndpointURI endpointUri = event.getEndpoint().getEndpointURI();\n        String method = (String) endpointUri.getParams().remove(\"method\");\n        if (method == null) {\n            throw new DispatchException(new org.mule.config.i18n.Message(\"soap\", 4),\n                    event.getMessage(),\n                    event.getEndpoint());\n        }\n\n        Service service = getService(event);\n        Call call = (Call) service.createCall();\n\n        String style = event.getMessage().getStringProperty(\"style\", null);\n        String use = event.getMessage().getStringProperty(\"use\", null);\n\n        // Note that Axis has specific rules to how these two variables are\n        // combined. This is handled for us\n        // Set style: RPC/wrapped/Doc/Message\n        if (style != null) {\n            Style s = Style.getStyle(style);\n            if (s == null) {\n                throw new IllegalArgumentException(new org.mule.config.i18n.Message(Messages.VALUE_X_IS_INVALID_FOR_X, style, \"style\").toString());\n            } else {\n                call.setOperationStyle(s);\n            }\n        }\n        // Set use: Endcoded/Literal\n        if (use != null) {\n            Use u = Use.getUse(use);\n            if (u == null) {\n                throw new IllegalArgumentException(new org.mule.config.i18n.Message(Messages.VALUE_X_IS_INVALID_FOR_X, use, \"use\").toString());\n            } else {\n                call.setOperationUse(u);\n            }\n        }\n\n        // set properties on the call from the endpoint properties\n        BeanUtils.populateWithoutFail(call, event.getEndpoint().getProperties(), false);\n        call.setTargetEndpointAddress(endpointUri.getAddress());\n\n        //Set a custome method namespace if one is set.  This will be used forthe parameters too\n        String methodNamespace = (String) event.getProperty(AxisConnector.METHOD_NAMESPACE_PROPERTY);\n        if (methodNamespace != null) {\n            call.setOperationName(new QName(methodNamespace, method));\n        } else {\n            call.setOperationName(new QName(method));\n        }\n\n        // set Mule event here so that handlers can extract info\n        call.setProperty(MuleProperties.MULE_EVENT_PROPERTY, event);\n        call.setProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, event.getEndpoint());\n        // Set timeout\n        call.setTimeout(new Integer(event.getTimeout()));\n\n        // Add User Creds\n        if (endpointUri.getUserInfo() != null) {\n            call.setUsername(endpointUri.getUsername());\n            call.setPassword(endpointUri.getPassword());\n        }\n\n        Map methodCalls = (Map) event.getProperty(\"soapMethods\");\n        if (methodCalls == null) {\n            ArrayList params = new ArrayList();\n            for (int i = 0; i < args.length; i++) {\n                if (args[i] instanceof DataHandler[]) {\n                    params.add(\"attachments;qname{DataHandler:http://xml.apache.org/xml-soap};in\");\n                    //Convert key/value pairs into the parameters\n                } else if (args[i] instanceof Map && connector.isTreatMapAsNamedParams()) {\n                    for (Iterator iterator = ((Map) args[i]).entrySet().iterator(); iterator.hasNext();) {\n                        Map.Entry entry = (Map.Entry)iterator.next();\n                        if (call.getTypeMapping().getTypeQName(entry.getValue().getClass()) != null) {\n                            QName type = call.getTypeMapping().getTypeQName(entry.getValue().getClass());\n                        params.add(\"qname{\" + entry.getKey().toString() + (methodNamespace==null ? \"\" : \":\" + methodNamespace) +\n                                \"};qname{\" + type.getPrefix() + \":\" + type.getLocalPart() + \":\" + type.getNamespaceURI() + \"};in\");\n                        } else {\n                             params.add(\"value\" + i + \";qname{\" + Types.getLocalNameFromFullName(args[i].getClass().getName()) + \":\" + Namespaces.makeNamespace(args[i].getClass().getName()) + \"};in\");\n                             params.add(\"qname{\" + entry.getKey().toString() + (methodNamespace==null ? \"\" : \":\" + methodNamespace) +\n                                \"};qname{\" + Types.getLocalNameFromFullName(args[i].getClass().getName()) + \":\" + Namespaces.makeNamespace(args[i].getClass().getName()) + \"};in\");\n                        }\n\n                    }\n                } else if (call.getTypeMapping().getTypeQName(args[i].getClass()) != null) {\n                        QName qname = call.getTypeMapping().getTypeQName(args[i].getClass());\n                        params.add(\"value\" + i + \";qname{\" + qname.getPrefix() + \":\" + qname.getLocalPart() + \":\" + qname.getNamespaceURI() + \"};in\");\n                } else {\n                        params.add(\"value\" + i + \";qname{\" + Types.getLocalNameFromFullName(args[i].getClass().getName()) + \":\" + Namespaces.makeNamespace(args[i].getClass().getName()) + \"};in\");\n                }\n            }\n\n            HashMap map = new HashMap();\n            map.put(method, params);\n            event.setProperty(\"soapMethods\", map);\n        }\n\n        setCallParams(call, event, call.getOperationName());\n\n        //Set custom soap action if set on the event or endpoint\n        String soapAction = (String) event.getProperty(AxisConnector.SOAP_ACTION_PROPERTY);\n        if (soapAction != null) {\n            soapAction = parseSoapAction(soapAction, call.getOperationName(), event);\n            call.setSOAPActionURI(soapAction);\n            call.setUseSOAPAction(Boolean.TRUE.booleanValue());\n        } else {\n            call.setSOAPActionURI(endpointUri.getAddress());\n        }\n        return call;\n    }","id":99390,"modified_method":"protected Call getCall(UMOEvent event, Object[] args) throws Exception {\n        UMOEndpointURI endpointUri = event.getEndpoint().getEndpointURI();\n        String method = (String) endpointUri.getParams().remove(\"method\");\n        if (method == null) {\n            throw new DispatchException(new org.mule.config.i18n.Message(\"soap\", 4),\n                    event.getMessage(),\n                    event.getEndpoint());\n        }\n\n        Service service = getService(event);\n        Call call = (Call) service.createCall();\n\n        String style = event.getMessage().getStringProperty(\"style\", null);\n        String use = event.getMessage().getStringProperty(\"use\", null);\n\n        // Note that Axis has specific rules to how these two variables are\n        // combined. This is handled for us\n        // Set style: RPC/wrapped/Doc/Message\n        if (style != null) {\n            Style s = Style.getStyle(style);\n            if (s == null) {\n                throw new IllegalArgumentException(new org.mule.config.i18n.Message(Messages.VALUE_X_IS_INVALID_FOR_X, style, \"style\").toString());\n            } else {\n                call.setOperationStyle(s);\n            }\n        }\n        // Set use: Endcoded/Literal\n        if (use != null) {\n            Use u = Use.getUse(use);\n            if (u == null) {\n                throw new IllegalArgumentException(new org.mule.config.i18n.Message(Messages.VALUE_X_IS_INVALID_FOR_X, use, \"use\").toString());\n            } else {\n                call.setOperationUse(u);\n            }\n        }\n\n        // set properties on the call from the endpoint properties\n        BeanUtils.populateWithoutFail(call, event.getEndpoint().getProperties(), false);\n        call.setTargetEndpointAddress(endpointUri.getAddress());\n\n        //Set a custome method namespace if one is set.  This will be used forthe parameters too\n        String methodNamespace = (String) event.getMessage().getProperty(AxisConnector.METHOD_NAMESPACE_PROPERTY);\n        if (methodNamespace != null) {\n            call.setOperationName(new QName(methodNamespace, method));\n        } else {\n            call.setOperationName(new QName(method));\n        }\n\n        // set Mule event here so that handlers can extract info\n        call.setProperty(MuleProperties.MULE_EVENT_PROPERTY, event);\n        call.setProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, event.getEndpoint());\n        // Set timeout\n        call.setTimeout(new Integer(event.getTimeout()));\n\n        // Add User Creds\n        if (endpointUri.getUserInfo() != null) {\n            call.setUsername(endpointUri.getUsername());\n            call.setPassword(endpointUri.getPassword());\n        }\n\n        Map methodCalls = (Map) event.getMessage().getProperty(\"soapMethods\");\n        if (methodCalls == null) {\n            ArrayList params = new ArrayList();\n            for (int i = 0; i < args.length; i++) {\n                if (args[i] instanceof DataHandler[]) {\n                    params.add(\"attachments;qname{DataHandler:http://xml.apache.org/xml-soap};in\");\n                    //Convert key/value pairs into the parameters\n                } else if (args[i] instanceof Map && connector.isTreatMapAsNamedParams()) {\n                    for (Iterator iterator = ((Map) args[i]).entrySet().iterator(); iterator.hasNext();) {\n                        Map.Entry entry = (Map.Entry)iterator.next();\n                        if (call.getTypeMapping().getTypeQName(entry.getValue().getClass()) != null) {\n                            QName type = call.getTypeMapping().getTypeQName(entry.getValue().getClass());\n                        params.add(\"qname{\" + entry.getKey().toString() + (methodNamespace==null ? \"\" : \":\" + methodNamespace) +\n                                \"};qname{\" + type.getPrefix() + \":\" + type.getLocalPart() + \":\" + type.getNamespaceURI() + \"};in\");\n                        } else {\n                             params.add(\"value\" + i + \";qname{\" + Types.getLocalNameFromFullName(args[i].getClass().getName()) + \":\" + Namespaces.makeNamespace(args[i].getClass().getName()) + \"};in\");\n                             params.add(\"qname{\" + entry.getKey().toString() + (methodNamespace==null ? \"\" : \":\" + methodNamespace) +\n                                \"};qname{\" + Types.getLocalNameFromFullName(args[i].getClass().getName()) + \":\" + Namespaces.makeNamespace(args[i].getClass().getName()) + \"};in\");\n                        }\n\n                    }\n                } else if (call.getTypeMapping().getTypeQName(args[i].getClass()) != null) {\n                        QName qname = call.getTypeMapping().getTypeQName(args[i].getClass());\n                        params.add(\"value\" + i + \";qname{\" + qname.getPrefix() + \":\" + qname.getLocalPart() + \":\" + qname.getNamespaceURI() + \"};in\");\n                } else {\n                        params.add(\"value\" + i + \";qname{\" + Types.getLocalNameFromFullName(args[i].getClass().getName()) + \":\" + Namespaces.makeNamespace(args[i].getClass().getName()) + \"};in\");\n                }\n            }\n\n            HashMap map = new HashMap();\n            map.put(method, params);\n            event.getMessage().setProperty(\"soapMethods\", map);\n        }\n\n        setCallParams(call, event, call.getOperationName());\n\n        //Set custom soap action if set on the event or endpoint\n        String soapAction = (String) event.getMessage().getProperty(AxisConnector.SOAP_ACTION_PROPERTY);\n        if (soapAction != null) {\n            soapAction = parseSoapAction(soapAction, call.getOperationName(), event);\n            call.setSOAPActionURI(soapAction);\n            call.setUseSOAPAction(Boolean.TRUE.booleanValue());\n        } else {\n            call.setSOAPActionURI(endpointUri.getAddress());\n        }\n        return call;\n    }","commit_id":"f5f013129b5786417f5863d7672af030f73eb587","url":"https://github.com/mulesoft/mule"},{"original_method":"private void setCallParams(Call call, UMOEvent event, QName method) throws ClassNotFoundException {\n        if (callParameters == null) {\n            loadCallParams(event, method.getNamespaceURI());\n        }\n\n        SoapMethod soapMethod;\n        soapMethod = (SoapMethod) event.removeProperty(MuleProperties.MULE_SOAP_METHOD);\n        if (soapMethod == null) {\n            soapMethod = (SoapMethod) callParameters.get(method.getLocalPart());\n        }\n        if (soapMethod != null) {\n            for (Iterator iterator = soapMethod.getNamedParameters().iterator(); iterator.hasNext();) {\n                NamedParameter parameter = (NamedParameter) iterator.next();\n                call.addParameter(parameter.getName(), parameter.getType(), parameter.getMode());\n            }\n\n            if (soapMethod.getReturnType() != null) {\n                call.setReturnType(soapMethod.getReturnType());\n            } else if (soapMethod.getReturnClass() != null) {\n                call.setReturnClass(soapMethod.getReturnClass());\n            }\n            call.setOperationName(soapMethod.getName());\n        }\n    }","id":99391,"modified_method":"private void setCallParams(Call call, UMOEvent event, QName method) throws ClassNotFoundException {\n        if (callParameters == null) {\n            loadCallParams(event, method.getNamespaceURI());\n        }\n\n        SoapMethod soapMethod;\n        soapMethod = (SoapMethod) event.getMessage().removeProperty(MuleProperties.MULE_SOAP_METHOD);\n        if (soapMethod == null) {\n            soapMethod = (SoapMethod) callParameters.get(method.getLocalPart());\n        }\n        if (soapMethod != null) {\n            for (Iterator iterator = soapMethod.getNamedParameters().iterator(); iterator.hasNext();) {\n                NamedParameter parameter = (NamedParameter) iterator.next();\n                call.addParameter(parameter.getName(), parameter.getType(), parameter.getMode());\n            }\n\n            if (soapMethod.getReturnType() != null) {\n                call.setReturnType(soapMethod.getReturnType());\n            } else if (soapMethod.getReturnClass() != null) {\n                call.setReturnClass(soapMethod.getReturnClass());\n            }\n            call.setOperationName(soapMethod.getName());\n        }\n    }","commit_id":"f5f013129b5786417f5863d7672af030f73eb587","url":"https://github.com/mulesoft/mule"},{"original_method":"protected String getWsdlUrl(UMOEvent event) {\n        return event.getStringProperty(AxisConnector.WSDL_URL_PROPERTY, StringUtils.EMPTY);\n    }","id":99392,"modified_method":"protected String getWsdlUrl(UMOEvent event) {\n        return event.getMessage().getStringProperty(AxisConnector.WSDL_URL_PROPERTY, StringUtils.EMPTY);\n    }","commit_id":"f5f013129b5786417f5863d7672af030f73eb587","url":"https://github.com/mulesoft/mule"},{"original_method":"public void doPost(UMOEventContext context, WriterMessageAdapter response) throws ServletException, IOException\n    {\n        long t0 = 0L;\n        long t1 = 0L;\n        long t2 = 0L;\n        long t3 = 0L;\n        long t4 = 0L;\n        String soapAction = null;\n        AxisEngine engine = getAxisServer();\n        if (engine == null) {\n            ServletException se = new ServletException(Messages.getMessage(\"noEngine00\"));\n            logger.debug(\"No Engine!\", se);\n            throw se;\n        }\n        MessageContext msgContext = new MessageContext(engine);\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Enter: doPost()\");\n        }\n        if (tlog.isDebugEnabled()) {\n            t0 = System.currentTimeMillis();\n        }\n        Message responseMsg = null;\n        String contentType = null;\n        try {\n            UMOEndpointURI endpointUri = getEndpoint(context);\n            populateMessageContext(msgContext, context, endpointUri);\n            if (securityProvider != null) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"securityProvider:\" + securityProvider);\n                }\n                msgContext.setProperty(\"securityProvider\", securityProvider);\n            }\n\n            Object request = context.getTransformedMessage();\n            Message requestMsg = new Message((request instanceof File) ? new FileInputStream((File) request) :\n                                             request,\n                                             false,\n                                             (String) context.getProperty(HTTPConstants.HEADER_CONTENT_TYPE),\n                                             (String) context.getProperty(HTTPConstants.HEADER_CONTENT_LOCATION));\n\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Request Message:\" + requestMsg);\n            }\n            msgContext.setRequestMessage(requestMsg);\n            msgContext.setProperty(\"transport.url\", endpointUri.toString());\n\n            soapAction = getSoapAction(context);\n            if (soapAction != null) {\n                msgContext.setUseSOAPAction(true);\n                msgContext.setSOAPActionURI(soapAction);\n            }\n            // TODO session support\n            // msgContext.setSession(new AxisHttpSession(req));\n            if (tlog.isDebugEnabled()) {\n                t1 = System.currentTimeMillis();\n            }\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Invoking Axis Engine.\");\n            }\n            engine.invoke(msgContext);\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Return from Axis Engine.\");\n            }\n            if (tlog.isDebugEnabled()) {\n                t2 = System.currentTimeMillis();\n            }\n            if (RequestContext.getExceptionPayload() instanceof Exception) {\n                throw (Exception) RequestContext.getExceptionPayload().getException();\n            }\n            // remove temporary file used for soap message with attachment\n            if (request instanceof File) {\n            \t((File) request).delete();\n            }\n            responseMsg = msgContext.getResponseMessage();\n            if (responseMsg == null) {\n                throw new Exception(Messages.getMessage(\"noResponse01\"));\n            }\n        } catch (AxisFault fault) {\n            logger.error(fault, fault);\n            processAxisFault(fault);\n            configureResponseFromAxisFault(response, fault);\n            responseMsg = msgContext.getResponseMessage();\n            if (responseMsg == null) {\n                responseMsg = new Message(fault);\n            }\n        } catch (Exception e) {\n            responseMsg = msgContext.getResponseMessage();\n            response.setProperty(HttpConnector.HTTP_STATUS_PROPERTY, \"500\");\n            responseMsg = convertExceptionToAxisFault(e, responseMsg);\n        }\n\n        contentType = responseMsg.getContentType(msgContext.getSOAPConstants());\n        if (tlog.isDebugEnabled()) {\n            t3 = System.currentTimeMillis();\n        }\n\n        sendResponse((String)context.getProperty(HttpConnector.HTTP_STATUS_PROPERTY), contentType,\n                response, responseMsg);\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Response sent.\");\n            logger.debug(\"Exit: doPost()\");\n        }\n        if (tlog.isDebugEnabled()) {\n            t4 = System.currentTimeMillis();\n            tlog.debug(\"axisServlet.doPost: \" + soapAction + \" pre=\" + (t1 - t0) + \" invoke=\" + (t2 - t1) + \" post=\"\n                    + (t3 - t2) + \" send=\" + (t4 - t3) + \" \" + msgContext.getTargetService() + \".\"\n                    + (msgContext.getOperation() != null ? msgContext.getOperation().getName() : \"\"));\n        }\n    }","id":99393,"modified_method":"public void doPost(UMOEventContext context, WriterMessageAdapter response) throws ServletException, IOException\n    {\n        long t0 = 0L;\n        long t1 = 0L;\n        long t2 = 0L;\n        long t3 = 0L;\n        long t4 = 0L;\n        String soapAction = null;\n        AxisEngine engine = getAxisServer();\n        if (engine == null) {\n            ServletException se = new ServletException(Messages.getMessage(\"noEngine00\"));\n            logger.debug(\"No Engine!\", se);\n            throw se;\n        }\n        MessageContext msgContext = new MessageContext(engine);\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Enter: doPost()\");\n        }\n        if (tlog.isDebugEnabled()) {\n            t0 = System.currentTimeMillis();\n        }\n        Message responseMsg = null;\n        String contentType = null;\n        try {\n            UMOEndpointURI endpointUri = getEndpoint(context);\n            populateMessageContext(msgContext, context, endpointUri);\n            if (securityProvider != null) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"securityProvider:\" + securityProvider);\n                }\n                msgContext.setProperty(\"securityProvider\", securityProvider);\n            }\n\n            Object request = context.getTransformedMessage();\n            Message requestMsg = new Message((request instanceof File) ? new FileInputStream((File) request) :\n                                             request,\n                                             false,\n                                             context.getMessage().getStringProperty(HTTPConstants.HEADER_CONTENT_TYPE, null),\n                                             context.getMessage().getStringProperty(HTTPConstants.HEADER_CONTENT_LOCATION, null));\n\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Request Message:\" + requestMsg);\n            }\n            msgContext.setRequestMessage(requestMsg);\n            msgContext.setProperty(\"transport.url\", endpointUri.toString());\n\n            soapAction = getSoapAction(context);\n            if (soapAction != null) {\n                msgContext.setUseSOAPAction(true);\n                msgContext.setSOAPActionURI(soapAction);\n            }\n            // TODO session support\n            // msgContext.setSession(new AxisHttpSession(req));\n            if (tlog.isDebugEnabled()) {\n                t1 = System.currentTimeMillis();\n            }\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Invoking Axis Engine.\");\n            }\n            engine.invoke(msgContext);\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Return from Axis Engine.\");\n            }\n            if (tlog.isDebugEnabled()) {\n                t2 = System.currentTimeMillis();\n            }\n            if (RequestContext.getExceptionPayload() instanceof Exception) {\n                throw (Exception) RequestContext.getExceptionPayload().getException();\n            }\n            // remove temporary file used for soap message with attachment\n            if (request instanceof File) {\n            \t((File) request).delete();\n            }\n            responseMsg = msgContext.getResponseMessage();\n            if (responseMsg == null) {\n                throw new Exception(Messages.getMessage(\"noResponse01\"));\n            }\n        } catch (AxisFault fault) {\n            logger.error(fault, fault);\n            processAxisFault(fault);\n            configureResponseFromAxisFault(response, fault);\n            responseMsg = msgContext.getResponseMessage();\n            if (responseMsg == null) {\n                responseMsg = new Message(fault);\n            }\n        } catch (Exception e) {\n            responseMsg = msgContext.getResponseMessage();\n            response.setProperty(HttpConnector.HTTP_STATUS_PROPERTY, \"500\");\n            responseMsg = convertExceptionToAxisFault(e, responseMsg);\n        }\n\n        contentType = responseMsg.getContentType(msgContext.getSOAPConstants());\n        if (tlog.isDebugEnabled()) {\n            t3 = System.currentTimeMillis();\n        }\n\n        sendResponse(context.getMessage().getStringProperty(HttpConnector.HTTP_STATUS_PROPERTY, null),\n                contentType, response, responseMsg);\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Response sent.\");\n            logger.debug(\"Exit: doPost()\");\n        }\n        if (tlog.isDebugEnabled()) {\n            t4 = System.currentTimeMillis();\n            tlog.debug(\"axisServlet.doPost: \" + soapAction + \" pre=\" + (t1 - t0) + \" invoke=\" + (t2 - t1) + \" post=\"\n                    + (t3 - t2) + \" send=\" + (t4 - t3) + \" \" + msgContext.getTargetService() + \".\"\n                    + (msgContext.getOperation() != null ? msgContext.getOperation().getName() : \"\"));\n        }\n    }","commit_id":"f5f013129b5786417f5863d7672af030f73eb587","url":"https://github.com/mulesoft/mule"},{"original_method":"private String getSoapAction(UMOEventContext context) throws AxisFault\n    {\n        String soapAction = (String) context.getProperty(\"SOAPAction\");\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Header Soap Action:\" + soapAction);\n        }\n//        if (soapAction == null) {\n//            AxisFault af = new AxisFault(\"Client.NoSOAPAction\",\n//                                         Messages.getMessage(\"noHeader00\", \"SOAPAction\"),\n//                                         null,\n//                                         null);\n//            exceptionLog.error(Messages.getMessage(\"genFault00\"), af);\n//            throw af;\n//        }\n        if (StringUtils.isEmpty(soapAction)) {\n            soapAction = context.getEndpointURI().getAddress();\n        }\n        return soapAction;\n    }","id":99394,"modified_method":"private String getSoapAction(UMOEventContext context) throws AxisFault\n    {\n        String soapAction = context.getMessage().getStringProperty(\"SOAPAction\", null);\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Header Soap Action:\" + soapAction);\n        }\n//        if (soapAction == null) {\n//            AxisFault af = new AxisFault(\"Client.NoSOAPAction\",\n//                                         Messages.getMessage(\"noHeader00\", \"SOAPAction\"),\n//                                         null,\n//                                         null);\n//            exceptionLog.error(Messages.getMessage(\"genFault00\"), af);\n//            throw af;\n//        }\n        if (StringUtils.isEmpty(soapAction)) {\n            soapAction = context.getEndpointURI().getAddress();\n        }\n        return soapAction;\n    }","commit_id":"f5f013129b5786417f5863d7672af030f73eb587","url":"https://github.com/mulesoft/mule"},{"original_method":"protected String getServiceName(UMOEventContext context, UMOEndpointURI endpointUri) throws AxisFault\n    {\n        String serviceName = endpointUri.getPath();\n        if (StringUtils.isEmpty(serviceName)) {\n            serviceName = getSoapAction(context);\n            serviceName = serviceName.replaceAll(\"\\\"\", \"\");\n            int i = serviceName.indexOf(\"/\", serviceName.indexOf(\"//\"));\n            if(i<-1) {\n                serviceName = serviceName.substring(i + 2);\n            }\n\n        }\n        // int i = serviceName.lastIndexOf(\"/\");\n        // if (i > -1) serviceName = serviceName.substring(0, i);\n\n        int i = serviceName.lastIndexOf(\"/\");\n        if (i > -1) {\n            serviceName = serviceName.substring(i);\n        }\n        i = serviceName.lastIndexOf(\"?\");\n        if (i > -1) {\n            serviceName = serviceName.substring(0, i);\n        }\n        return serviceName;\n    }","id":99395,"modified_method":"protected String getServiceName(UMOEventContext context, UMOEndpointURI endpointUri) throws AxisFault\n    {\n        String serviceName = endpointUri.getPath();\n        if (StringUtils.isEmpty(serviceName)) {\n            serviceName = getSoapAction(context);\n            serviceName = serviceName.replaceAll(\"\\\"\", \"\");\n            int i = serviceName.indexOf(\"/\", serviceName.indexOf(\"//\"));\n            if(i<-1) {\n                serviceName = serviceName.substring(i + 2);\n            }\n\n        }\n        // int i = serviceName.lastIndexOf(\"/\");\n        // if (i > -1) serviceName = serviceName.substring(0, i);\n\n        int i = serviceName.lastIndexOf('/');\n        if (i > -1) {\n            serviceName = serviceName.substring(i);\n        }\n        i = serviceName.lastIndexOf('?');\n        if (i > -1) {\n            serviceName = serviceName.substring(0, i);\n        }\n        return serviceName;\n    }","commit_id":"f5f013129b5786417f5863d7672af030f73eb587","url":"https://github.com/mulesoft/mule"},{"original_method":"private UMOEndpointURI getEndpoint(UMOEventContext context) throws MalformedEndpointException\n    {\n        String endpoint = context.getEndpointURI().getAddress();\n        String request = (String) context.getProperty(HttpConnector.HTTP_REQUEST_PROPERTY);\n        if (request != null) {\n            int i = endpoint.indexOf(\"/\", endpoint.indexOf(\"://\") + 3);\n            if (i > -1) {\n                endpoint = endpoint.substring(0, i);\n            }\n            endpoint += request;\n            return new MuleEndpointURI(endpoint);\n        }\n        return context.getEndpointURI();\n    }","id":99396,"modified_method":"private UMOEndpointURI getEndpoint(UMOEventContext context) throws MalformedEndpointException\n    {\n        String endpoint = context.getEndpointURI().getAddress();\n        String request = context.getMessage().getStringProperty(HttpConnector.HTTP_REQUEST_PROPERTY, null);\n        if (request != null) {\n            int i = endpoint.indexOf(\"/\", endpoint.indexOf(\"://\") + 3);\n            if (i > -1) {\n                endpoint = endpoint.substring(0, i);\n            }\n            endpoint += request;\n            return new MuleEndpointURI(endpoint);\n        }\n        return context.getEndpointURI();\n    }","commit_id":"f5f013129b5786417f5863d7672af030f73eb587","url":"https://github.com/mulesoft/mule"},{"original_method":"private void populateMessageContext(MessageContext msgContext, UMOEventContext context, UMOEndpointURI endpointUri)\n            throws AxisFault, ConfigurationException\n    {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"MessageContext:\" + msgContext);\n            logger.debug(\"HEADER_CONTENT_TYPE:\" + context.getProperty(HttpConstants.HEADER_CONTENT_TYPE));\n            logger.debug(\"HEADER_CONTENT_LOCATION:\" + context.getProperty(HttpConstants.HEADER_CONTENT_LOCATION));\n            logger.debug(\"Constants.MC_HOME_DIR:\" + String.valueOf(getHomeDir()));\n            logger.debug(\"Constants.MC_RELATIVE_PATH:\" + endpointUri.getPath());\n            // logger.debug(\"HTTPConstants.MC_HTTP_SERVLETLOCATION:\" +\n            // String.valueOf(getWebInfPath()));\n            // logger.debug(\"HTTPConstants.MC_HTTP_SERVLETPATHINFO:\" +\n            // req.getPathInfo());\n            logger.debug(\"HTTPConstants.HEADER_AUTHORIZATION:\" + context.getProperty(\"Authorization\"));\n            logger.debug(\"Constants.MC_REMOTE_ADDR:\" + endpointUri.getHost());\n            // logger.debug(\"configPath:\" + String.valueOf(getWebInfPath()));\n        }\n        msgContext.setTransportName(transportName);\n        msgContext.setProperty(\"home.dir\", getHomeDir());\n        msgContext.setProperty(\"path\", endpointUri.getPath());\n        msgContext.setProperty(HTTPConstants.MC_HTTP_SERVLET, this);\n        msgContext.setProperty(HTTPConstants.MC_HTTP_SERVLETLOCATION, endpointUri.getPath());\n        // determine service name\n        String serviceName = getServiceName(context, endpointUri);\n        // Validate Service path against request path\n        SOAPService service = msgContext.getAxisEngine().getConfig().getService(new QName(serviceName.substring(1)));\n\n        // Component Name is set by Mule so if its null we can skip this check\n        if (service.getOption(AxisConnector.SERVICE_PROPERTY_COMPONENT_NAME) != null) {\n            String servicePath = (String) service.getOption(\"servicePath\");\n            if(StringUtils.isEmpty(endpointUri.getPath())) {\n                if(!(\"/\" + endpointUri.getAddress()).startsWith(servicePath + serviceName)) {\n                    throw new AxisFault(\"Failed to find service: \" + \"/\" + endpointUri.getAddress());                    \n                }\n            } else if (!endpointUri.getPath().startsWith(servicePath + serviceName)) {\n                throw new AxisFault(\"Failed to find service: \" + endpointUri.getPath());\n            }\n        }\n\n        msgContext.setProperty(HTTPConstants.MC_HTTP_SERVLETPATHINFO, serviceName);\n        msgContext.setProperty(\"serviceName\", serviceName);\n\n        msgContext.setProperty(\"Authorization\", context.getProperty(\"Authorization\"));\n        msgContext.setProperty(\"remoteaddr\", endpointUri.getHost());\n        ServletEndpointContextImpl sec = new ServletEndpointContextImpl();\n        msgContext.setProperty(\"servletEndpointContext\", sec);\n        // String realpath =\n        // getServletConfig().getServletContext().getRealPath(req.getServletPath());\n        // if(realpath != null)\n        // msgContext.setProperty(\"realpath\", realpath);\n        // msgContext.setProperty(\"configPath\", getWebInfPath());\n    }","id":99397,"modified_method":"private void populateMessageContext(MessageContext msgContext, UMOEventContext context, UMOEndpointURI endpointUri)\n            throws AxisFault, ConfigurationException\n    {\n        UMOMessage msg = context.getMessage();\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"MessageContext:\" + msgContext);\n            logger.debug(\"HEADER_CONTENT_TYPE:\" + msg.getStringProperty(HttpConstants.HEADER_CONTENT_TYPE, null));\n            logger.debug(\"HEADER_CONTENT_LOCATION:\" + msg.getStringProperty(HttpConstants.HEADER_CONTENT_LOCATION, null));\n            logger.debug(\"Constants.MC_HOME_DIR:\" + String.valueOf(getHomeDir()));\n            logger.debug(\"Constants.MC_RELATIVE_PATH:\" + endpointUri.getPath());\n            // logger.debug(\"HTTPConstants.MC_HTTP_SERVLETLOCATION:\" +\n            // String.valueOf(getWebInfPath()));\n            // logger.debug(\"HTTPConstants.MC_HTTP_SERVLETPATHINFO:\" +\n            // req.getPathInfo());\n            logger.debug(\"HTTPConstants.HEADER_AUTHORIZATION:\" + msg.getStringProperty(\"Authorization\", null));\n            logger.debug(\"Constants.MC_REMOTE_ADDR:\" + endpointUri.getHost());\n            // logger.debug(\"configPath:\" + String.valueOf(getWebInfPath()));\n        }\n\n        msgContext.setTransportName(transportName);\n        msgContext.setProperty(\"home.dir\", getHomeDir());\n        msgContext.setProperty(\"path\", endpointUri.getPath());\n        msgContext.setProperty(HTTPConstants.MC_HTTP_SERVLET, this);\n        msgContext.setProperty(HTTPConstants.MC_HTTP_SERVLETLOCATION, endpointUri.getPath());\n        // determine service name\n        String serviceName = getServiceName(context, endpointUri);\n        // Validate Service path against request path\n        SOAPService service = msgContext.getAxisEngine().getConfig().getService(new QName(serviceName.substring(1)));\n\n        // Component Name is set by Mule so if its null we can skip this check\n        if (service.getOption(AxisConnector.SERVICE_PROPERTY_COMPONENT_NAME) != null) {\n            String servicePath = (String) service.getOption(\"servicePath\");\n            if(StringUtils.isEmpty(endpointUri.getPath())) {\n                if(!(\"/\" + endpointUri.getAddress()).startsWith(servicePath + serviceName)) {\n                    throw new AxisFault(\"Failed to find service: \" + \"/\" + endpointUri.getAddress());                    \n                }\n            } else if (!endpointUri.getPath().startsWith(servicePath + serviceName)) {\n                throw new AxisFault(\"Failed to find service: \" + endpointUri.getPath());\n            }\n        }\n\n        msgContext.setProperty(HTTPConstants.MC_HTTP_SERVLETPATHINFO, serviceName);\n        msgContext.setProperty(\"serviceName\", serviceName);\n\n        msgContext.setProperty(\"Authorization\", msg.getStringProperty(\"Authorization\", null));\n        msgContext.setProperty(\"remoteaddr\", endpointUri.getHost());\n        ServletEndpointContextImpl sec = new ServletEndpointContextImpl();\n        msgContext.setProperty(\"servletEndpointContext\", sec);\n        // String realpath =\n        // getServletConfig().getServletContext().getRealPath(req.getServletPath());\n        // if(realpath != null)\n        // msgContext.setProperty(\"realpath\", realpath);\n        // msgContext.setProperty(\"configPath\", getWebInfPath());\n    }","commit_id":"f5f013129b5786417f5863d7672af030f73eb587","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Passes the context to the listener\n     * \n     * @param context the context ot process\n     * @return Object this object can be anything. When the\n     *         <code>UMOLifecycleAdapter<\/code> for the component receives\n     *         this object it will first see if the Object is an\n     *         <code>UMOEvent<\/code> if not and the Object is not null a new\n     *         context will be created using the returned object as the payload.\n     *         This new context will then get published to the configured\n     *         outbound endpoint if-\n     *         <ol>\n     *         <li>One has been configured for the UMO.<\/li>\n     *         <li>the <code>setStopFurtherProcessing(true)<\/code> wasn't\n     *         called on the previous context.<\/li>\n     *         <\/ol>\n     * @throws Exception if the context fails to process properly. If exceptions\n     *             aren't handled by the implementation they will be handled by\n     *             the exceptionListener associated with the component\n     */\n    public Object onCall(UMOEventContext context) throws Exception\n    {\n        String method = (String) context.getProperty(HttpConnector.HTTP_METHOD_PROPERTY, \"POST\");\n        WriterMessageAdapter response = new WriterMessageAdapter(new StringWriter());\n        if (\"GET\".equals(method.toUpperCase())) {\n            doGet(context, response);\n        } else {\n            doPost(context, response);\n        }\n        response.getWriter().close();\n        return new MuleMessage(response);\n    }","id":99398,"modified_method":"/**\n     * Passes the context to the listener\n     * \n     * @param context the context to process\n     * @return Object this object can be anything. When the\n     *         <code>UMOLifecycleAdapter<\/code> for the component receives\n     *         this object it will first see if the Object is an\n     *         <code>UMOEvent<\/code> if not and the Object is not null a new\n     *         context will be created using the returned object as the payload.\n     *         This new context will then get published to the configured\n     *         outbound endpoint if-\n     *         <ol>\n     *         <li>One has been configured for the UMO.<\/li>\n     *         <li>the <code>setStopFurtherProcessing(true)<\/code> wasn't\n     *         called on the previous context.<\/li>\n     *         <\/ol>\n     * @throws Exception if the context fails to process properly. If exceptions\n     *             aren't handled by the implementation they will be handled by\n     *             the exceptionListener associated with the component\n     */\n    public Object onCall(UMOEventContext context) throws Exception\n    {\n        String method = context.getMessage().getStringProperty(HttpConnector.HTTP_METHOD_PROPERTY, \"POST\");\n        WriterMessageAdapter response = new WriterMessageAdapter(new StringWriter());\n        if (\"GET\".equals(method.toUpperCase())) {\n            doGet(context, response);\n        } else {\n            doPost(context, response);\n        }\n        response.getWriter().close();\n        return new MuleMessage(response);\n    }","commit_id":"f5f013129b5786417f5863d7672af030f73eb587","url":"https://github.com/mulesoft/mule"},{"original_method":"protected Service createService(UMOEvent event) throws Exception {\n        String wsdlUrl = event.getEndpoint().getEndpointURI().getAddress();\n        // Parse the wsdl\n        Parser parser = new Parser();\n        if(event.getEndpoint().getEndpointURI().getUserInfo()!=null) {\n            parser.setUsername(event.getEndpoint().getEndpointURI().getUsername());\n            parser.setPassword(event.getEndpoint().getEndpointURI().getPassword());\n        }\n        parser.run(wsdlUrl);\n        // Retrieves the defined services\n        Map map = parser.getSymbolTable().getHashMap();\n        List entries = new ArrayList();\n        for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n            Map.Entry entry = (Map.Entry) it.next();\n            Vector v = (Vector) entry.getValue();\n            for (Iterator it2 = v.iterator(); it2.hasNext();) {\n                SymTabEntry e = (SymTabEntry) it2.next();\n                if (ServiceEntry.class.isInstance(e)) {\n                    entries.add(entry.getKey());\n                }\n            }\n        }\n        // Currently, only one service should be defined\n        if (entries.size() != 1) {\n            throw new Exception(\"Need one and only one service entry, found \" + entries.size());\n        }\n        // Create the axis service\n        Service service = new Service(parser, (QName) entries.get(0));\n\n        service.setEngineConfiguration(clientConfig);\n        service.setEngine(new AxisClient(clientConfig));\n\n        //Really the Axis Client service should set this stuff\n        event.setProperty(AxisConnector.METHOD_NAMESPACE_PROPERTY, parser.getCurrentDefinition().getTargetNamespace());\n        //Todo how can we autogenerate the named params from the WSDL?\n        return service;\n    }","id":99399,"modified_method":"protected Service createService(UMOEvent event) throws Exception {\n        String wsdlUrl = event.getEndpoint().getEndpointURI().getAddress();\n        // Parse the wsdl\n        Parser parser = new Parser();\n        if(event.getEndpoint().getEndpointURI().getUserInfo()!=null) {\n            parser.setUsername(event.getEndpoint().getEndpointURI().getUsername());\n            parser.setPassword(event.getEndpoint().getEndpointURI().getPassword());\n        }\n        parser.run(wsdlUrl);\n        // Retrieves the defined services\n        Map map = parser.getSymbolTable().getHashMap();\n        List entries = new ArrayList();\n        for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n            Map.Entry entry = (Map.Entry) it.next();\n            Vector v = (Vector) entry.getValue();\n            for (Iterator it2 = v.iterator(); it2.hasNext();) {\n                SymTabEntry e = (SymTabEntry) it2.next();\n                if (ServiceEntry.class.isInstance(e)) {\n                    entries.add(entry.getKey());\n                }\n            }\n        }\n        // Currently, only one service should be defined\n        if (entries.size() != 1) {\n            throw new Exception(\"Need one and only one service entry, found \" + entries.size());\n        }\n        // Create the axis service\n        Service service = new Service(parser, (QName) entries.get(0));\n\n        service.setEngineConfiguration(clientConfig);\n        service.setEngine(new AxisClient(clientConfig));\n\n        //Really the Axis Client service should set this stuff\n        event.getMessage().setProperty(AxisConnector.METHOD_NAMESPACE_PROPERTY, parser.getCurrentDefinition().getTargetNamespace());\n        //Todo how can we autogenerate the named params from the WSDL?\n        return service;\n    }","commit_id":"f5f013129b5786417f5863d7672af030f73eb587","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Authenticates the current message if authenticate is set to true. This\n     * method will always populate the secure context in the session\n     * \n     * @param event the current message recieved\n     * @throws org.mule.umo.security.SecurityException if authentication fails\n     */\n    public void authenticateInbound(UMOEvent event) throws SecurityException, SecurityProviderNotFoundException,\n            UnknownAuthenticationTypeException\n    {\n        String header = (String) event.getProperty(HttpConstants.HEADER_AUTHORIZATION);\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Authorization header: \" + header);\n        }\n\n        if ((header != null) && header.startsWith(\"Basic \")) {\n            String base64Token = header.substring(6);\n            String token = new String(Base64.decodeBase64(base64Token.getBytes()));\n\n            String username = \"\";\n            String password = \"\";\n            int delim = token.indexOf(\":\");\n\n            if (delim != -1) {\n                username = token.substring(0, delim);\n                password = token.substring(delim + 1);\n            }\n\n            UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username,\n                                                                                                      password);\n            authRequest.setDetails(event.getProperty(MuleProperties.MULE_ENDPOINT_PROPERTY));\n\n            UMOAuthentication authResult;\n\n            UMOAuthentication umoAuthentication = new AcegiAuthenticationAdapter(authRequest);\n\n            try {\n                authResult = getSecurityManager().authenticate(umoAuthentication);\n            } catch (AuthenticationException e) {\n                // Authentication failed\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Authentication request for user: \" + username + \" failed: \" + e.toString());\n                }\n                setUnauthenticated(event);\n                throw new UnauthorisedException(new Message(Messages.AUTH_FAILED_FOR_USER_X, username), e);\n            }\n\n            // Authentication success\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Authentication success: \" + authResult.toString());\n            }\n\n            UMOSecurityContext context = getSecurityManager().createSecurityContext(authResult);\n            event.getSession().setSecurityContext(context);\n        } else if (header == null) {\n            setUnauthenticated(event);\n            throw new UnauthorisedException(event.getMessage(),\n                                            event.getSession().getSecurityContext(),\n                                            getEndpoint(),\n                                            this);\n        } else {\n            setUnauthenticated(event);\n            throw new UnsupportedAuthenticationSchemeException(new Message(\"acegi\", 1, header), event.getMessage());\n        }\n    }","id":99400,"modified_method":"/**\n     * Authenticates the current message if authenticate is set to true. This\n     * method will always populate the secure context in the session\n     * \n     * @param event the current message recieved\n     * @throws org.mule.umo.security.SecurityException if authentication fails\n     */\n    public void authenticateInbound(UMOEvent event) throws SecurityException, SecurityProviderNotFoundException,\n            UnknownAuthenticationTypeException\n    {\n        String header = event.getMessage().getStringProperty(HttpConstants.HEADER_AUTHORIZATION, null);\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Authorization header: \" + header);\n        }\n\n        if ((header != null) && header.startsWith(\"Basic \")) {\n            String base64Token = header.substring(6);\n            String token = new String(Base64.decodeBase64(base64Token.getBytes()));\n\n            String username = \"\";\n            String password = \"\";\n            int delim = token.indexOf(\":\");\n\n            if (delim != -1) {\n                username = token.substring(0, delim);\n                password = token.substring(delim + 1);\n            }\n\n            UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username,\n                                                                                                      password);\n            authRequest.setDetails(event.getMessage().getProperty(MuleProperties.MULE_ENDPOINT_PROPERTY));\n\n            UMOAuthentication authResult;\n\n            UMOAuthentication umoAuthentication = new AcegiAuthenticationAdapter(authRequest);\n\n            try {\n                authResult = getSecurityManager().authenticate(umoAuthentication);\n            } catch (AuthenticationException e) {\n                // Authentication failed\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Authentication request for user: \" + username + \" failed: \" + e.toString());\n                }\n                setUnauthenticated(event);\n                throw new UnauthorisedException(new Message(Messages.AUTH_FAILED_FOR_USER_X, username), e);\n            }\n\n            // Authentication success\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Authentication success: \" + authResult.toString());\n            }\n\n            UMOSecurityContext context = getSecurityManager().createSecurityContext(authResult);\n            event.getSession().setSecurityContext(context);\n        } else if (header == null) {\n            setUnauthenticated(event);\n            throw new UnauthorisedException(event.getMessage(),\n                                            event.getSession().getSecurityContext(),\n                                            getEndpoint(),\n                                            this);\n        } else {\n            setUnauthenticated(event);\n            throw new UnsupportedAuthenticationSchemeException(new Message(\"acegi\", 1, header), event.getMessage());\n        }\n    }","commit_id":"f5f013129b5786417f5863d7672af030f73eb587","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Authenticates the current message if authenticate is set to true. This\n     * method will always populate the secure context in the session\n     * \n     * @param event the current event being dispatched\n     * @throws org.mule.umo.security.SecurityException if authentication fails\n     */\n    public void authenticateOutbound(UMOEvent event) throws SecurityException, SecurityProviderNotFoundException\n    {\n        if (event.getSession().getSecurityContext() == null) {\n            if (isAuthenticate()) {\n                throw new UnauthorisedException(event.getMessage(),\n                                                event.getSession().getSecurityContext(),\n                                                event.getEndpoint(),\n                                                this);\n            } else {\n                return;\n            }\n        }\n        UMOAuthentication auth = event.getSession().getSecurityContext().getAuthentication();\n        if (isAuthenticate()) {\n            auth = getSecurityManager().authenticate(auth);\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Authentication success: \" + auth.toString());\n            }\n        }\n\n        StringBuffer header = new StringBuffer();\n\n        header.append(\"Basic \");\n        String token = auth.getCredentials().toString();\n        header.append(Base64.encodeBase64(token.getBytes()));\n\n        event.setProperty(HttpConstants.HEADER_AUTHORIZATION, header.toString());\n    }","id":99401,"modified_method":"/**\n     * Authenticates the current message if authenticate is set to true. This\n     * method will always populate the secure context in the session\n     * \n     * @param event the current event being dispatched\n     * @throws org.mule.umo.security.SecurityException if authentication fails\n     */\n    public void authenticateOutbound(UMOEvent event) throws SecurityException, SecurityProviderNotFoundException\n    {\n        if (event.getSession().getSecurityContext() == null) {\n            if (isAuthenticate()) {\n                throw new UnauthorisedException(event.getMessage(),\n                                                event.getSession().getSecurityContext(),\n                                                event.getEndpoint(),\n                                                this);\n            } else {\n                return;\n            }\n        }\n\n        UMOAuthentication auth = event.getSession().getSecurityContext().getAuthentication();\n        if (isAuthenticate()) {\n            auth = getSecurityManager().authenticate(auth);\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Authentication success: \" + auth.toString());\n            }\n        }\n\n        StringBuffer header = new StringBuffer(128);\n        header.append(\"Basic \");\n        String token = auth.getCredentials().toString();\n        header.append(Base64.encodeBase64(token.getBytes()));\n\n        event.getMessage().setStringProperty(HttpConstants.HEADER_AUTHORIZATION, header.toString());\n    }","commit_id":"f5f013129b5786417f5863d7672af030f73eb587","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void setUnauthenticated(UMOEvent event)\n    {\n        String realmHeader = \"Basic realm=\";\n        if (realm != null) {\n            realmHeader += \"\\\"\" + realm + \"\\\"\";\n        }\n        event.setProperty(HttpConstants.HEADER_WWW_AUTHENTICATE, realmHeader);\n        event.setIntProperty(HttpConnector.HTTP_STATUS_PROPERTY, HttpConstants.SC_UNAUTHORIZED);\n    }","id":99402,"modified_method":"protected void setUnauthenticated(UMOEvent event)\n    {\n        String realmHeader = \"Basic realm=\";\n        if (realm != null) {\n            realmHeader += \"\\\"\" + realm + \"\\\"\";\n        }\n        UMOMessage msg = event.getMessage();\n        msg.setProperty(HttpConstants.HEADER_WWW_AUTHENTICATE, realmHeader);\n        msg.setIntProperty(HttpConnector.HTTP_STATUS_PROPERTY, HttpConstants.SC_UNAUTHORIZED);\n    }","commit_id":"f5f013129b5786417f5863d7672af030f73eb587","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object transform(Object src, String encoding, UMOEventContext context) throws TransformerException\n    {\n        String endpointAddress = endpoint.getEndpointURI().getAddress();\n        SmtpConnector connector = (SmtpConnector)endpoint.getConnector();\n        String to = context.getStringProperty(MailProperties.TO_ADDRESSES_PROPERTY, endpointAddress);\n        String cc = context.getStringProperty(MailProperties.CC_ADDRESSES_PROPERTY, connector.getCcAddresses());\n        String bcc = context.getStringProperty(MailProperties.BCC_ADDRESSES_PROPERTY, connector.getBccAddresses());\n        String from = context.getStringProperty(MailProperties.FROM_ADDRESS_PROPERTY, connector.getFromAddress());\n        String replyTo = context.getStringProperty(MailProperties.REPLY_TO_ADDRESSES_PROPERTY, connector.getReplyToAddresses());\n        String subject = context.getStringProperty(MailProperties.SUBJECT_PROPERTY, connector.getSubject());\n\n        String contentType = context.getStringProperty(MailProperties.CONTENT_TYPE_PROPERTY, connector.getContentType());\n\n        Properties headers = new Properties();\n        if(connector.getCustomHeaders()!=null) {\n            headers.putAll(connector.getCustomHeaders());\n        }\n        Properties otherHeaders = (Properties)context.getProperty(MailProperties.CUSTOM_HEADERS_MAP_PROPERTY);\n        if(otherHeaders!=null) {\n            Map props = new HashMap(MuleManager.getInstance().getProperties());\n            for (Iterator iterator = context.getMessage().getPropertyNames(); iterator.hasNext();) {\n                Object o =  iterator.next();\n                props.put(o, context.getMessage().getProperty(o));\n            }\n            headers.putAll(templateParser.parse(props, otherHeaders));\n        }\n\n        if(logger.isDebugEnabled()) {\n            StringBuffer buf = new StringBuffer();\n            buf.append(\"Constucting email using:\\n\");\n            buf.append(\"To: \").append(to);\n            buf.append(\"From: \").append(from);\n            buf.append(\"CC: \").append(cc);\n            buf.append(\"BCC: \").append(bcc);\n            buf.append(\"Subject: \").append(subject);\n            buf.append(\"ReplyTo: \").append(replyTo);\n            buf.append(\"Content type: \").append(contentType);\n            buf.append(\"Payload type: \").append(src.getClass().getName());\n            buf.append(\"Custom Headers: \").append(PropertiesHelper.propertiesToString(headers, false));\n            logger.debug(buf.toString());\n        }\n\n        try {\n            Message msg = new MimeMessage((Session) endpoint.getConnector().getDispatcher(endpointAddress).getDelegateSession());\n\n            msg.setRecipients(Message.RecipientType.TO, MailUtils.stringToInternetAddresses(to));\n\n            // sent date\n            msg.setSentDate(Calendar.getInstance().getTime());\n\n            if (!StringUtils.isEmpty(from)) {\n                msg.setFrom(MailUtils.stringToInternetAddresses(from)[0]);\n            }\n\n            if (!StringUtils.isEmpty(cc)) {\n                msg.setRecipients(Message.RecipientType.CC, MailUtils.stringToInternetAddresses(cc));\n            }\n\n            if (!StringUtils.isEmpty(bcc)) {\n                msg.setRecipients(Message.RecipientType.BCC, MailUtils.stringToInternetAddresses(bcc));\n            }\n\n            if (!StringUtils.isEmpty(replyTo)) {\n                msg.setReplyTo(MailUtils.stringToInternetAddresses(replyTo));\n            }\n\n            msg.setSubject(subject);\n\n            Map.Entry entry;\n            for (Iterator iterator = headers.entrySet().iterator(); iterator.hasNext();) {\n                entry = (Map.Entry)iterator.next();\n                msg.setHeader(entry.getKey().toString(), entry.getValue().toString());\n            }\n\n            setContent(src, msg, contentType, context);\n\n            return msg;\n        } catch (Exception e) {\n            throw new TransformerException(this, e);\n        }\n    }","id":99403,"modified_method":"public Object transform(Object src, String encoding, UMOEventContext context) throws TransformerException\n    {\n        String endpointAddress = endpoint.getEndpointURI().getAddress();\n        SmtpConnector connector = (SmtpConnector)endpoint.getConnector();\n        UMOMessage eventMsg = context.getMessage();\n        String to = eventMsg.getStringProperty(MailProperties.TO_ADDRESSES_PROPERTY, endpointAddress);\n        String cc = eventMsg.getStringProperty(MailProperties.CC_ADDRESSES_PROPERTY, connector.getCcAddresses());\n        String bcc = eventMsg.getStringProperty(MailProperties.BCC_ADDRESSES_PROPERTY, connector.getBccAddresses());\n        String from = eventMsg.getStringProperty(MailProperties.FROM_ADDRESS_PROPERTY, connector.getFromAddress());\n        String replyTo = eventMsg.getStringProperty(MailProperties.REPLY_TO_ADDRESSES_PROPERTY, connector.getReplyToAddresses());\n        String subject = eventMsg.getStringProperty(MailProperties.SUBJECT_PROPERTY, connector.getSubject());\n\n        String contentType = eventMsg.getStringProperty(MailProperties.CONTENT_TYPE_PROPERTY, connector.getContentType());\n\n        Properties headers = new Properties();\n        if(connector.getCustomHeaders()!=null) {\n            headers.putAll(connector.getCustomHeaders());\n        }\n        Properties otherHeaders = (Properties)eventMsg.getProperty(MailProperties.CUSTOM_HEADERS_MAP_PROPERTY);\n        if(otherHeaders!=null) {\n            Map props = new HashMap(MuleManager.getInstance().getProperties());\n            for (Iterator iterator = context.getMessage().getPropertyNames(); iterator.hasNext();) {\n                Object o =  iterator.next();\n                props.put(o, context.getMessage().getProperty(o));\n            }\n            headers.putAll(templateParser.parse(props, otherHeaders));\n        }\n\n        if(logger.isDebugEnabled()) {\n            StringBuffer buf = new StringBuffer(256);\n            buf.append(\"Constucting email using:\\n\");\n            buf.append(\"To: \").append(to);\n            buf.append(\"From: \").append(from);\n            buf.append(\"CC: \").append(cc);\n            buf.append(\"BCC: \").append(bcc);\n            buf.append(\"Subject: \").append(subject);\n            buf.append(\"ReplyTo: \").append(replyTo);\n            buf.append(\"Content type: \").append(contentType);\n            buf.append(\"Payload type: \").append(src.getClass().getName());\n            buf.append(\"Custom Headers: \").append(PropertiesHelper.propertiesToString(headers, false));\n            logger.debug(buf.toString());\n        }\n\n        try {\n            Message msg = new MimeMessage((Session) endpoint.getConnector().getDispatcher(endpointAddress).getDelegateSession());\n\n            msg.setRecipients(Message.RecipientType.TO, MailUtils.stringToInternetAddresses(to));\n\n            // sent date\n            msg.setSentDate(Calendar.getInstance().getTime());\n\n            if (!StringUtils.isEmpty(from)) {\n                msg.setFrom(MailUtils.stringToInternetAddresses(from)[0]);\n            }\n\n            if (!StringUtils.isEmpty(cc)) {\n                msg.setRecipients(Message.RecipientType.CC, MailUtils.stringToInternetAddresses(cc));\n            }\n\n            if (!StringUtils.isEmpty(bcc)) {\n                msg.setRecipients(Message.RecipientType.BCC, MailUtils.stringToInternetAddresses(bcc));\n            }\n\n            if (!StringUtils.isEmpty(replyTo)) {\n                eventMsg.setReplyTo(MailUtils.stringToInternetAddresses(replyTo));\n            }\n\n            msg.setSubject(subject);\n\n            Map.Entry entry;\n            for (Iterator iterator = headers.entrySet().iterator(); iterator.hasNext();) {\n                entry = (Map.Entry)iterator.next();\n                msg.setHeader(entry.getKey().toString(), entry.getValue().toString());\n            }\n\n            setContent(src, msg, contentType, context);\n\n            return eventMsg;\n        } catch (Exception e) {\n            throw new TransformerException(this, e);\n        }\n    }","commit_id":"f5f013129b5786417f5863d7672af030f73eb587","url":"https://github.com/mulesoft/mule"},{"original_method":"public void doDispatch(UMOEvent event) throws Exception {\n        String endpoint = event.getEndpoint().getEndpointURI().getAddress();\n        Object data = event.getTransformedMessage();\n        String filename = (String) event.getProperty(FileConnector.PROPERTY_FILENAME);\n\n        if (filename == null) {\n            String outPattern = (String) event.getProperty(FileConnector.PROPERTY_OUTPUT_PATTERN);\n            if (outPattern == null) {\n                outPattern = connector.getOutputPattern();\n            }\n            filename = generateFilename(event, outPattern);\n        }\n\n        if (filename == null) {\n            throw new IOException(\"Filename is null\");\n        }\n\n        File file = Utility.createFile(endpoint + \"/\" + filename);\n        byte[] buf;\n        if (data instanceof byte[]) {\n            buf = (byte[]) data;\n        } else {\n            buf = data.toString().getBytes();\n        }\n\n        logger.info(\"Writing file to: \" + file.getAbsolutePath());\n        FileOutputStream fos = new FileOutputStream(file, connector.isOutputAppend());\n        try {\n            fos.write(buf);\n        } finally {\n            fos.close();\n        }\n    }","id":99404,"modified_method":"public void doDispatch(UMOEvent event) throws Exception {\n        String endpoint = event.getEndpoint().getEndpointURI().getAddress();\n        Object data = event.getTransformedMessage();\n        UMOMessage msg = event.getMessage();\n        String filename = msg.getStringProperty(FileConnector.PROPERTY_FILENAME, null);\n\n        if (filename == null) {\n            String outPattern = msg.getStringProperty(FileConnector.PROPERTY_OUTPUT_PATTERN, connector.getOutputPattern());\n            filename = generateFilename(event, outPattern);\n        }\n\n        if (filename == null) {\n            throw new IOException(\"Filename is null\");\n        }\n\n        File file = Utility.createFile(endpoint + \"/\" + filename);\n        byte[] buf;\n        if (data instanceof byte[]) {\n            buf = (byte[]) data;\n        } else {\n            buf = data.toString().getBytes();\n        }\n\n        logger.info(\"Writing file to: \" + file.getAbsolutePath());\n        FileOutputStream fos = new FileOutputStream(file, connector.isOutputAppend());\n        try {\n            fos.write(buf);\n        } finally {\n            fos.close();\n        }\n    }","commit_id":"79a096cef4d9edd693057110d1b68b4a5f5dd52f","url":"https://github.com/mulesoft/mule"},{"original_method":"public void doDispatch(UMOEvent event) throws Exception\n    {\n        FTPClient client = null;\n        final UMOEndpoint endpoint = event.getEndpoint();\n        UMOEndpointURI uri = endpoint.getEndpointURI();\n        try {\n            String filename = (String) event.getProperty(FtpConnector.PROPERTY_FILENAME);\n\n            if (filename == null) {\n                String outPattern = (String) event.getProperty(FtpConnector.PROPERTY_OUTPUT_PATTERN);\n                if (outPattern == null) {\n                    outPattern = connector.getOutputPattern();\n                }\n                filename = generateFilename(event, outPattern);\n            }\n            if (filename == null) {\n                throw new IOException(\"Filename is null\");\n            }\n\n            byte[] buf;\n            Object data = event.getTransformedMessage();\n            if (data instanceof byte[]) {\n                buf = (byte[]) data;\n            } else {\n                buf = data.toString().getBytes();\n            }\n\n            client = connector.getFtp(uri);\n            connector.enterActiveOrPassiveMode(client, endpoint.getProperties());\n            connector.setupFileType(client, endpoint.getProperties());\n            if (!client.changeWorkingDirectory(uri.getPath())) {\n                throw new IOException(\"Ftp error: \" + client.getReplyCode());\n            }\n            if (!client.storeFile(filename, new ByteArrayInputStream(buf))) {\n                throw new IOException(\"Ftp error: \" + client.getReplyCode());\n            }\n\n        } finally {\n            connector.releaseFtp(uri, client);\n        }\n    }","id":99405,"modified_method":"public void doDispatch(UMOEvent event) throws Exception\n    {\n        FTPClient client = null;\n        final UMOEndpoint endpoint = event.getEndpoint();\n        UMOEndpointURI uri = endpoint.getEndpointURI();\n        try {\n            UMOMessage msg = event.getMessage();\n            String filename = msg.getStringProperty(FtpConnector.PROPERTY_FILENAME, null);\n\n            if (filename == null) {\n                String outPattern = msg.getStringProperty(FtpConnector.PROPERTY_OUTPUT_PATTERN, connector.getOutputPattern());\n                filename = generateFilename(event, outPattern);\n            }\n\n            if (filename == null) {\n                throw new IOException(\"Filename is null\");\n            }\n\n            byte[] buf;\n            Object data = event.getTransformedMessage();\n            if (data instanceof byte[]) {\n                buf = (byte[]) data;\n            } else {\n                buf = data.toString().getBytes();\n            }\n\n            client = connector.getFtp(uri);\n            connector.enterActiveOrPassiveMode(client, endpoint.getProperties());\n            connector.setupFileType(client, endpoint.getProperties());\n            if (!client.changeWorkingDirectory(uri.getPath())) {\n                throw new IOException(\"Ftp error: \" + client.getReplyCode());\n            }\n            if (!client.storeFile(filename, new ByteArrayInputStream(buf))) {\n                throw new IOException(\"Ftp error: \" + client.getReplyCode());\n            }\n\n        } finally {\n            connector.releaseFtp(uri, client);\n        }\n    }","commit_id":"79a096cef4d9edd693057110d1b68b4a5f5dd52f","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void processCookies(UMOEvent event)\n    {\n        Cookie[] cookies = (Cookie[])event.removeProperty(HttpConnector.HTTP_COOKIES_PROPERTY);\n        if (cookies != null && cookies.length > 0) {\n            client.getParams().setCookiePolicy(\n                    CookieHelper.getCookiePolicy((String)event\n                            .removeProperty(HttpConnector.HTTP_COOKIE_SPEC_PROPERTY)));\n            client.getState().addCookies(cookies);\n        }\n    }","id":99406,"modified_method":"protected void processCookies(UMOEvent event)\n    {\n        UMOMessage msg = event.getMessage();\n        Cookie[] cookies = (Cookie[])msg.removeProperty(HttpConnector.HTTP_COOKIES_PROPERTY);\n        if (cookies != null && cookies.length > 0) {\n            String policy = (String)msg.removeProperty(HttpConnector.HTTP_COOKIE_SPEC_PROPERTY);\n            client.getParams().setCookiePolicy(CookieHelper.getCookiePolicy(policy));\n            client.getState().addCookies(cookies);\n        }\n    }","commit_id":"79a096cef4d9edd693057110d1b68b4a5f5dd52f","url":"https://github.com/mulesoft/mule"},{"original_method":"public UMOMessage receive(UMOEndpointURI endpointUri, long timeout) throws Exception\n    {\n        if (endpointUri == null) {\n            return null;\n        }\n\n        HttpMethod httpMethod = new GetMethod(endpointUri.getAddress());\n        httpMethod.setDoAuthentication(true);\n        if (endpointUri.getUserInfo() != null) {\n            // Add User Creds\n            // TODO take encodings into account\n            StringBuffer header = new StringBuffer(64);\n            header.append(\"Basic \");\n            header.append(new String(Base64.encodeBase64(endpointUri.getUserInfo().getBytes())));\n            httpMethod.addRequestHeader(HttpConstants.HEADER_AUTHORIZATION, header.toString());\n        }\n        try {\n            HttpClient client = new HttpClient();\n            client.executeMethod(httpMethod);\n\n            if (httpMethod.getStatusCode() == HttpStatus.SC_OK) {\n                return (UMOMessage)receiveTransformer.transform(httpMethod);\n            }\n            else {\n                throw new ReceiveException(\n                        new Message(\"http\", 3, httpMethod.getStatusLine().toString()), endpointUri,\n                        timeout);\n            }\n        }\n        catch (ReceiveException e) {\n            throw e;\n        }\n        catch (Exception e) {\n            throw new ReceiveException(endpointUri, timeout, e);\n        }\n        finally {\n            httpMethod.releaseConnection();\n        }\n    }","id":99407,"modified_method":"public UMOMessage receive(UMOEndpointURI endpointUri, long timeout) throws Exception\n    {\n        if (endpointUri == null) {\n            return null;\n        }\n\n        HttpMethod httpMethod = new GetMethod(endpointUri.getAddress());\n        httpMethod.setDoAuthentication(true);\n        if (endpointUri.getUserInfo() != null) {\n            // Add User Creds\n            // TODO take encodings into account\n            StringBuffer header = new StringBuffer(128);\n            header.append(\"Basic \");\n            header.append(new String(Base64.encodeBase64(endpointUri.getUserInfo().getBytes())));\n            httpMethod.addRequestHeader(HttpConstants.HEADER_AUTHORIZATION, header.toString());\n        }\n        try {\n            HttpClient client = new HttpClient();\n            client.executeMethod(httpMethod);\n\n            if (httpMethod.getStatusCode() == HttpStatus.SC_OK) {\n                return (UMOMessage)receiveTransformer.transform(httpMethod);\n            }\n            else {\n                throw new ReceiveException(\n                        new Message(\"http\", 3, httpMethod.getStatusLine().toString()), endpointUri,\n                        timeout);\n            }\n        }\n        catch (ReceiveException e) {\n            throw e;\n        }\n        catch (Exception e) {\n            throw new ReceiveException(endpointUri, timeout, e);\n        }\n        finally {\n            httpMethod.releaseConnection();\n        }\n    }","commit_id":"79a096cef4d9edd693057110d1b68b4a5f5dd52f","url":"https://github.com/mulesoft/mule"},{"original_method":"protected HttpMethod getMethod(UMOEvent event) throws TransformerException\n    {\n        String method = (String)event.getProperty(HttpConnector.HTTP_METHOD_PROPERTY,\n                HttpConstants.METHOD_POST);\n        URI uri = event.getEndpoint().getEndpointURI().getUri();\n        HttpMethod httpMethod = null;\n        Object body = event.getTransformedMessage();\n\n        if (body instanceof HttpMethod) {\n            httpMethod = (HttpMethod)body;\n        }\n        else if (HttpConstants.METHOD_GET.equalsIgnoreCase(method)) {\n            httpMethod = new GetMethod(uri.toString());\n        }\n        else {\n            PostMethod postMethod = new PostMethod(uri.toString());\n\n            if (body instanceof String) {\n                ObjectToHttpClientMethodRequest trans = new ObjectToHttpClientMethodRequest();\n                httpMethod = (HttpMethod)trans.transform(body.toString());\n            }\n            else if (body instanceof HttpMethod) {\n                httpMethod = (HttpMethod)body;\n            }\n            else if (body instanceof StreamMessageAdapter) {\n                postMethod.setRequestEntity(new StreamPayloadRequestEntity((StreamMessageAdapter)body,\n                        event));\n                postMethod.setContentChunked(true);\n                httpMethod = postMethod;\n            }\n            else {\n                byte[] buffer = event.getTransformedMessageAsBytes();\n                // TODO MULE20 add Encoding\n                postMethod.setRequestEntity(new ByteArrayRequestEntity(buffer /* event.getEncoding() */));\n                httpMethod = postMethod;\n            }\n\n        }\n        httpMethod.setDoAuthentication(true);\n        if (event.getCredentials() != null) {\n            String authScopeHost = event.getStringProperty(\"http.auth.scope.host\", null);\n            int authScopePort = event.getIntProperty(\"http.auth.scope.port\", -1);\n            String authScopeRealm = event.getStringProperty(\"http.auth.scope.realm\", null);\n            String authScopeScheme = event.getStringProperty(\"http.auth.scope.scheme\", null);\n            client.getState().setCredentials(\n                    new AuthScope(authScopeHost, authScopePort, authScopeRealm, authScopeScheme),\n                    new UsernamePasswordCredentials(event.getCredentials().getUsername(), new String(\n                            event.getCredentials().getPassword())));\n        }\n        return httpMethod;\n    }","id":99408,"modified_method":"protected HttpMethod getMethod(UMOEvent event) throws TransformerException\n    {\n        UMOMessage msg = event.getMessage();\n        String method = msg.getStringProperty(HttpConnector.HTTP_METHOD_PROPERTY,\n                HttpConstants.METHOD_POST);\n        URI uri = event.getEndpoint().getEndpointURI().getUri();\n        HttpMethod httpMethod = null;\n        Object body = event.getTransformedMessage();\n\n        if (body instanceof HttpMethod) {\n            httpMethod = (HttpMethod)body;\n        }\n        else if (HttpConstants.METHOD_GET.equalsIgnoreCase(method)) {\n            httpMethod = new GetMethod(uri.toString());\n        }\n        else {\n            PostMethod postMethod = new PostMethod(uri.toString());\n\n            if (body instanceof String) {\n                ObjectToHttpClientMethodRequest trans = new ObjectToHttpClientMethodRequest();\n                httpMethod = (HttpMethod)trans.transform(body.toString());\n            }\n            else if (body instanceof HttpMethod) {\n                httpMethod = (HttpMethod)body;\n            }\n            else if (body instanceof StreamMessageAdapter) {\n                postMethod.setRequestEntity(new StreamPayloadRequestEntity((StreamMessageAdapter)body,\n                        event));\n                postMethod.setContentChunked(true);\n                httpMethod = postMethod;\n            }\n            else {\n                byte[] buffer = event.getTransformedMessageAsBytes();\n                // TODO MULE20 add Encoding\n                postMethod.setRequestEntity(new ByteArrayRequestEntity(buffer /* event.getEncoding() */));\n                httpMethod = postMethod;\n            }\n\n        }\n        httpMethod.setDoAuthentication(true);\n        if (event.getCredentials() != null) {\n            String authScopeHost = msg.getStringProperty(\"http.auth.scope.host\", null);\n            int authScopePort = msg.getIntProperty(\"http.auth.scope.port\", -1);\n            String authScopeRealm = msg.getStringProperty(\"http.auth.scope.realm\", null);\n            String authScopeScheme = msg.getStringProperty(\"http.auth.scope.scheme\", null);\n            client.getState().setCredentials(\n                    new AuthScope(authScopeHost, authScopePort, authScopeRealm, authScopeScheme),\n                    new UsernamePasswordCredentials(event.getCredentials().getUsername(), new String(\n                            event.getCredentials().getPassword())));\n        }\n        return httpMethod;\n    }","commit_id":"79a096cef4d9edd693057110d1b68b4a5f5dd52f","url":"https://github.com/mulesoft/mule"},{"original_method":"public String getContentType()\n        {\n            return event.getStringProperty(HttpConstants.HEADER_CONTENT_TYPE, null);\n        }","id":99409,"modified_method":"public String getContentType()\n        {\n            return event.getMessage().getStringProperty(HttpConstants.HEADER_CONTENT_TYPE, null);\n        }","commit_id":"79a096cef4d9edd693057110d1b68b4a5f5dd52f","url":"https://github.com/mulesoft/mule"},{"original_method":"public EventCallback createEventCallback() {\n    \tfinal EventCallback superCallback = super.createEventCallback();\n\n    \treturn new EventCallback() {\n\t\t\tpublic void eventReceived(UMOEventContext context, Object Component) throws Exception {\n\t\t\t\tsuperCallback.eventReceived(context, Component);\n\t\t\t\tcontext.setProperty(HttpConstants.HEADER_CONTENT_TYPE, getExpectedContentType());\n\t\t\t}\n    \t};\n    }","id":99410,"modified_method":"public EventCallback createEventCallback() {\n    \tfinal EventCallback superCallback = super.createEventCallback();\n\n    \treturn new EventCallback() {\n\t\t\tpublic void eventReceived(UMOEventContext context, Object Component) throws Exception {\n\t\t\t\tsuperCallback.eventReceived(context, Component);\n\t\t\t\tcontext.getMessage().setProperty(HttpConstants.HEADER_CONTENT_TYPE, getExpectedContentType());\n\t\t\t}\n    \t};\n    }","commit_id":"79a096cef4d9edd693057110d1b68b4a5f5dd52f","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object transform(Object src, String encoding, UMOEventContext context)\n            throws TransformerException\n    {\n        String endpoint = (String)context.getProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, null);\n        if (endpoint == null) {\n            throw new TransformerException(new Message(\n                    Messages.EVENT_PROPERTY_X_NOT_SET_CANT_PROCESS_REQUEST,\n                    MuleProperties.MULE_ENDPOINT_PROPERTY), this);\n        }\n        String method = (String)context.getProperty(HttpConnector.HTTP_METHOD_PROPERTY, \"POST\");\n        try {\n            URI uri = new URI(endpoint);\n            HttpMethod httpMethod = null;\n\n            if (HttpConstants.METHOD_GET.equals(method)) {\n                httpMethod = new GetMethod(uri.toString());\n                setHeaders(httpMethod, context);\n                String paramName = (String)context.getProperty(\n                        HttpConnector.HTTP_GET_BODY_PARAM_PROPERTY,\n                        HttpConnector.DEFAULT_HTTP_GET_BODY_PARAM_PROPERTY);\n                String query = uri.getQuery();\n                if (!(src instanceof NullPayload) && !StringUtils.EMPTY.equals(src)) {\n                    if (query == null) {\n                        query = paramName + \"=\" + src.toString();\n                    }\n                    else {\n                        query += \"&\" + paramName + \"=\" + src.toString();\n                    }\n                }\n                httpMethod.setQueryString(query);\n\n            }\n            else {\n                PostMethod postMethod = new PostMethod(uri.toString());\n                setHeaders(postMethod, context);\n                String paramName = (String)context\n                        .getProperty(HttpConnector.HTTP_POST_BODY_PARAM_PROPERTY);\n                // postMethod.setRequestContentLength(PostMethod.CONTENT_LENGTH_AUTO);\n                if (paramName == null) {\n                    // Call method to manage the parameter array\n                    addParameters(uri.getQuery(), postMethod);\n                    // Dont set a POST payload if the body is a Null Payload.\n                    // This way client calls\n                    // can control if a POST body is posted explicitly\n                    if (!(context.getMessage().getPayload() instanceof NullPayload)) {\n                    \t// See if we have a MIME type set\n                    \tString mimeType = context.getStringProperty(HttpConstants.HEADER_CONTENT_TYPE, null);\n                    \t\n                        if (src instanceof String) {\n                        \t// Ensure that we strip the encoding information from the encoding type\n                        \tint parameterIndex = mimeType != null ? mimeType.indexOf(\";\") : -1;\n                        \tif (parameterIndex > 0) {\n                        \t\tmimeType = mimeType.substring(0,parameterIndex);\n                            }\n                        \tif (mimeType == null) mimeType = HttpConstants.DEFAULT_CONTENT_TYPE;\n                            if (encoding == null) encoding = MuleManager.getConfiguration().getEncoding();\n                            postMethod.setRequestEntity(new StringRequestEntity(src.toString(), mimeType, encoding));\n                        }\n                        else if (src instanceof InputStream) {\n                        \t// TODO Danger here! We don't know if the content is really text or not \n                        \tif (mimeType == null) mimeType = HttpConstants.DEFAULT_CONTENT_TYPE;\n                            postMethod.setRequestEntity(new InputStreamRequestEntity((InputStream)src, mimeType));\n                        }\n                        else {\n                        \t// TODO Danger here! We don't know if the content is really text or not \n                        \tif (mimeType == null) mimeType = HttpConstants.DEFAULT_CONTENT_TYPE;\n                            byte[] buffer = (byte[])serializableToByteArray.doTransform(src, encoding);\n                            postMethod.setRequestEntity(new ByteArrayRequestEntity(buffer, mimeType));\n                        }\n                    }\n                }\n                else {\n                    postMethod.addParameter(paramName, src.toString());\n                }\n\n                httpMethod = postMethod;\n\n            }\n\n            return httpMethod;\n        }\n        catch (Exception e) {\n            throw new TransformerException(this, e);\n        }\n    }","id":99411,"modified_method":"public Object transform(Object src, String encoding, UMOEventContext context)\n            throws TransformerException\n    {\n        UMOMessage msg = context.getMessage();\n\n        String endpoint = msg.getStringProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, null);\n        if (endpoint == null) {\n            throw new TransformerException(new Message(\n                    Messages.EVENT_PROPERTY_X_NOT_SET_CANT_PROCESS_REQUEST,\n                    MuleProperties.MULE_ENDPOINT_PROPERTY), this);\n        }\n\n        String method = msg.getStringProperty(HttpConnector.HTTP_METHOD_PROPERTY, \"POST\");\n        try {\n            URI uri = new URI(endpoint);\n            HttpMethod httpMethod = null;\n\n            if (HttpConstants.METHOD_GET.equals(method)) {\n                httpMethod = new GetMethod(uri.toString());\n                setHeaders(httpMethod, context);\n                String paramName = msg.getStringProperty(HttpConnector.HTTP_GET_BODY_PARAM_PROPERTY,\n                        HttpConnector.DEFAULT_HTTP_GET_BODY_PARAM_PROPERTY);\n                String query = uri.getQuery();\n                if (!(src instanceof NullPayload) && !StringUtils.EMPTY.equals(src)) {\n                    if (query == null) {\n                        query = paramName + \"=\" + src.toString();\n                    }\n                    else {\n                        query += \"&\" + paramName + \"=\" + src.toString();\n                    }\n                }\n                httpMethod.setQueryString(query);\n\n            }\n            else {\n                PostMethod postMethod = new PostMethod(uri.toString());\n                setHeaders(postMethod, context);\n                String paramName = msg.getStringProperty(HttpConnector.HTTP_POST_BODY_PARAM_PROPERTY, null);\n                // postMethod.setRequestContentLength(PostMethod.CONTENT_LENGTH_AUTO);\n                if (paramName == null) {\n                    // Call method to manage the parameter array\n                    addParameters(uri.getQuery(), postMethod);\n                    // Dont set a POST payload if the body is a Null Payload.\n                    // This way client calls\n                    // can control if a POST body is posted explicitly\n                    if (!(context.getMessage().getPayload() instanceof NullPayload)) {\n                    \t// See if we have a MIME type set\n                    \tString mimeType = msg.getStringProperty(HttpConstants.HEADER_CONTENT_TYPE, null);\n                    \t\n                        if (src instanceof String) {\n                        \t// Ensure that we strip the encoding information from the encoding type\n                        \tint parameterIndex = mimeType != null ? mimeType.indexOf(\";\") : -1;\n                        \tif (parameterIndex > 0) {\n                        \t\tmimeType = mimeType.substring(0, parameterIndex);\n                            }\n                        \tif (mimeType == null) mimeType = HttpConstants.DEFAULT_CONTENT_TYPE;\n                            if (encoding == null) encoding = MuleManager.getConfiguration().getEncoding();\n                            postMethod.setRequestEntity(new StringRequestEntity(src.toString(), mimeType, encoding));\n                        }\n                        else if (src instanceof InputStream) {\n                        \t// TODO Danger here! We don't know if the content is really text or not \n                        \tif (mimeType == null) mimeType = HttpConstants.DEFAULT_CONTENT_TYPE;\n                            postMethod.setRequestEntity(new InputStreamRequestEntity((InputStream)src, mimeType));\n                        }\n                        else {\n                        \t// TODO Danger here! We don't know if the content is really text or not \n                        \tif (mimeType == null) mimeType = HttpConstants.DEFAULT_CONTENT_TYPE;\n                            byte[] buffer = (byte[])serializableToByteArray.doTransform(src, encoding);\n                            postMethod.setRequestEntity(new ByteArrayRequestEntity(buffer, mimeType));\n                        }\n                    }\n                }\n                else {\n                    postMethod.addParameter(paramName, src.toString());\n                }\n\n                httpMethod = postMethod;\n\n            }\n\n            return httpMethod;\n        }\n        catch (Exception e) {\n            throw new TransformerException(this, e);\n        }\n    }","commit_id":"79a096cef4d9edd693057110d1b68b4a5f5dd52f","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object transform(Object src, String encoding, UMOEventContext context)\n            throws TransformerException\n    {\n        // Note this transformer excepts Null as we must always return a result\n        // from the Http\n        // connector if a response transformer is present\n        if (src instanceof NullPayload) {\n            src = StringUtils.EMPTY;\n        }\n\n        try {\n            HttpResponse response = null;\n            if (src instanceof HttpResponse) {\n                response = (HttpResponse)src;\n            }\n            else {\n                response = createResponse(src, encoding, context);\n            }\n\n            // Ensure there's a content type header\n            if (!response.containsHeader(HttpConstants.HEADER_CONTENT_TYPE)) {\n                response.addHeader(new Header(HttpConstants.HEADER_CONTENT_TYPE,\n                        HttpConstants.DEFAULT_CONTENT_TYPE));\n            }\n\n            // Ensure there's a content length or transfer encoding header\n            if (!response.containsHeader(HttpConstants.HEADER_CONTENT_LENGTH)\n                    && !response.containsHeader(HttpConstants.HEADER_TRANSFER_ENCODING)) {\n                InputStream content = response.getBody();\n                if (content != null) {\n                    long len = response.getContentLength();\n                    if (len < 0) {\n                        if (response.getHttpVersion().lessEquals(HttpVersion.HTTP_1_0)) {\n                            throw new IOException(\"Chunked encoding not supported for HTTP version \"\n                                    + response.getHttpVersion());\n                        }\n                        Header header = new Header(HttpConstants.HEADER_TRANSFER_ENCODING, \"chunked\");\n                        response.addHeader(header);\n                    }\n                    else {\n                        Header header = new Header(HttpConstants.HEADER_CONTENT_LENGTH, Long\n                                .toString(len));\n                        response.setHeader(header);\n                    }\n                }\n                else {\n                    Header header = new Header(HttpConstants.HEADER_CONTENT_LENGTH, \"0\");\n                    response.addHeader(header);\n                }\n            }\n\n            if (!response.containsHeader(HttpConstants.HEADER_CONNECTION)) {\n                // See if the the client explicitly handles connection\n                // persistence\n                String connHeader = context.getStringProperty(HttpConstants.HEADER_CONNECTION);\n                if (connHeader != null) {\n                    if (connHeader.equalsIgnoreCase(\"keep-alive\")) {\n                        Header header = new Header(HttpConstants.HEADER_CONNECTION, \"keep-alive\");\n                        response.addHeader(header);\n                        response.setKeepAlive(true);\n                    }\n                    if (connHeader.equalsIgnoreCase(\"close\")) {\n                        Header header = new Header(HttpConstants.HEADER_CONNECTION, \"close\");\n                        response.addHeader(header);\n                        response.setKeepAlive(false);\n                    }\n                }\n                else {\n                    // Use protocol default connection policy\n                    if (response.getHttpVersion().greaterEquals(HttpVersion.HTTP_1_1)) {\n                        response.setKeepAlive(true);\n                    }\n                    else {\n                        response.setKeepAlive(false);\n                    }\n                }\n            }\n            if (\"HEAD\".equalsIgnoreCase(context.getStringProperty(HttpConnector.HTTP_METHOD_PROPERTY))) {\n                // this is a head request, we don't want to send the actualy\n                // content\n                response.setBody(null);\n            }\n            return response;\n        }\n        catch (IOException e) {\n            throw new TransformerException(this, e);\n        }\n\n    }","id":99412,"modified_method":"public Object transform(Object src, String encoding, UMOEventContext context)\n            throws TransformerException\n    {\n        // Note this transformer excepts Null as we must always return a result\n        // from the Http\n        // connector if a response transformer is present\n        if (src instanceof NullPayload) {\n            src = StringUtils.EMPTY;\n        }\n\n        try {\n            HttpResponse response = null;\n            if (src instanceof HttpResponse) {\n                response = (HttpResponse)src;\n            }\n            else {\n                response = createResponse(src, encoding, context);\n            }\n\n            // Ensure there's a content type header\n            if (!response.containsHeader(HttpConstants.HEADER_CONTENT_TYPE)) {\n                response.addHeader(new Header(HttpConstants.HEADER_CONTENT_TYPE,\n                        HttpConstants.DEFAULT_CONTENT_TYPE));\n            }\n\n            // Ensure there's a content length or transfer encoding header\n            if (!response.containsHeader(HttpConstants.HEADER_CONTENT_LENGTH)\n                    && !response.containsHeader(HttpConstants.HEADER_TRANSFER_ENCODING)) {\n                InputStream content = response.getBody();\n                if (content != null) {\n                    long len = response.getContentLength();\n                    if (len < 0) {\n                        if (response.getHttpVersion().lessEquals(HttpVersion.HTTP_1_0)) {\n                            throw new IOException(\"Chunked encoding not supported for HTTP version \"\n                                    + response.getHttpVersion());\n                        }\n                        Header header = new Header(HttpConstants.HEADER_TRANSFER_ENCODING, \"chunked\");\n                        response.addHeader(header);\n                    }\n                    else {\n                        Header header = new Header(HttpConstants.HEADER_CONTENT_LENGTH, Long\n                                .toString(len));\n                        response.setHeader(header);\n                    }\n                }\n                else {\n                    Header header = new Header(HttpConstants.HEADER_CONTENT_LENGTH, \"0\");\n                    response.addHeader(header);\n                }\n            }\n\n            UMOMessage msg = context.getMessage();\n\n            if (!response.containsHeader(HttpConstants.HEADER_CONNECTION)) {\n                // See if the the client explicitly handles connection persistence\n                String connHeader = msg.getStringProperty(HttpConstants.HEADER_CONNECTION, null);\n                if (connHeader != null) {\n                    if (connHeader.equalsIgnoreCase(\"keep-alive\")) {\n                        Header header = new Header(HttpConstants.HEADER_CONNECTION, \"keep-alive\");\n                        response.addHeader(header);\n                        response.setKeepAlive(true);\n                    }\n                    if (connHeader.equalsIgnoreCase(\"close\")) {\n                        Header header = new Header(HttpConstants.HEADER_CONNECTION, \"close\");\n                        response.addHeader(header);\n                        response.setKeepAlive(false);\n                    }\n                }\n                else {\n                    // Use protocol default connection policy\n                    if (response.getHttpVersion().greaterEquals(HttpVersion.HTTP_1_1)) {\n                        response.setKeepAlive(true);\n                    }\n                    else {\n                        response.setKeepAlive(false);\n                    }\n                }\n            }\n            if (\"HEAD\".equalsIgnoreCase(msg.getStringProperty(HttpConnector.HTTP_METHOD_PROPERTY, null))) {\n                // this is a head request, we don't want to send the actual content\n                response.setBody(null);\n            }\n            return response;\n        }\n        catch (IOException e) {\n            throw new TransformerException(this, e);\n        }\n\n    }","commit_id":"79a096cef4d9edd693057110d1b68b4a5f5dd52f","url":"https://github.com/mulesoft/mule"},{"original_method":"protected HttpResponse createResponse(Object src, String encoding, UMOEventContext context) throws IOException, TransformerException\n    {\n        HttpResponse response = new HttpResponse();\n\n        int status = context.getIntProperty(HttpConnector.HTTP_STATUS_PROPERTY, HttpConstants.SC_OK);\n        String version = context.getStringProperty(HttpConnector.HTTP_VERSION_PROPERTY,\n                HttpConstants.HTTP11);\n        String date = format.format(new Date());\n        String contentType = context.getStringProperty(HttpConstants.HEADER_CONTENT_TYPE,\n                HttpConstants.DEFAULT_CONTENT_TYPE);\n\n        response.setStatusLine(HttpVersion.parse(version), status);\n        response.setHeader(new Header(HttpConstants.HEADER_CONTENT_TYPE, contentType));\n        response.setHeader(new Header(HttpConstants.HEADER_DATE, date));\n        response.setHeader(new Header(HttpConstants.HEADER_SERVER, server));\n        if (context.getProperty(HttpConstants.HEADER_EXPIRES) == null) {\n            response.setHeader(new Header(HttpConstants.HEADER_EXPIRES, date));\n        }\n        response.setFallbackCharset(encoding);\n\n        String headerName;\n        String value;\n        for (Iterator iterator = HttpConstants.RESPONSE_HEADER_NAMES.values().iterator(); iterator\n                .hasNext();) {\n            headerName = (String)iterator.next();\n            value = context.getStringProperty(headerName);\n            if (value != null) {\n                response.setHeader(new Header(headerName, value));\n            }\n        }\n        // Custom responseHeaderNames\n        Map customHeaders = (Map)context.getProperty(HttpConnector.HTTP_CUSTOM_HEADERS_MAP_PROPERTY);\n        if (customHeaders != null) {\n            Map.Entry entry;\n            for (Iterator iterator = customHeaders.entrySet().iterator(); iterator.hasNext();) {\n                entry = (Map.Entry)iterator.next();\n                if (entry.getValue() != null) {\n                    response\n                            .setHeader(new Header(entry.getKey().toString(), entry.getValue().toString()));\n                }\n            }\n        }\n\n        // Mule properties\n        UMOMessage m = context.getMessage();\n        String user = (String)m.getProperty(MuleProperties.MULE_USER_PROPERTY);\n        if (user != null) {\n            response\n                    .setHeader(new Header(CUSTOM_HEADER_PREFIX + MuleProperties.MULE_USER_PROPERTY, user));\n        }\n        if (m.getCorrelationId() != null) {\n            response.setHeader(new Header(CUSTOM_HEADER_PREFIX\n                    + MuleProperties.MULE_CORRELATION_ID_PROPERTY, m.getCorrelationId()));\n            response.setHeader(new Header(CUSTOM_HEADER_PREFIX\n                    + MuleProperties.MULE_CORRELATION_GROUP_SIZE_PROPERTY, String.valueOf(m\n                    .getCorrelationGroupSize())));\n            response.setHeader(new Header(CUSTOM_HEADER_PREFIX\n                    + MuleProperties.MULE_CORRELATION_SEQUENCE_PROPERTY, String.valueOf(m\n                    .getCorrelationSequence())));\n        }\n        if (m.getReplyTo() != null) {\n            response.setHeader(new Header(CUSTOM_HEADER_PREFIX + MuleProperties.MULE_REPLY_TO_PROPERTY,\n                    m.getReplyTo().toString()));\n        }\n        if (src instanceof InputStream) {\n            response.setBody((InputStream)src);\n        }\n        else if (src instanceof String) {\n            response.setBodyString(src.toString());\n        }\n        else {\n            response.setBody(new ByteArrayInputStream((byte[])serializableToByteArray.doTransform(src, encoding)));\n        }\n        return response;\n    }","id":99413,"modified_method":"protected HttpResponse createResponse(Object src, String encoding, UMOEventContext context) throws IOException, TransformerException\n    {\n        HttpResponse response = new HttpResponse();\n        UMOMessage msg = context.getMessage();\n\n        int status = msg.getIntProperty(HttpConnector.HTTP_STATUS_PROPERTY, HttpConstants.SC_OK);\n        String version = msg.getStringProperty(HttpConnector.HTTP_VERSION_PROPERTY,\n                HttpConstants.HTTP11);\n        String date = format.format(new Date());\n        String contentType = msg.getStringProperty(HttpConstants.HEADER_CONTENT_TYPE,\n                HttpConstants.DEFAULT_CONTENT_TYPE);\n\n        response.setStatusLine(HttpVersion.parse(version), status);\n        response.setHeader(new Header(HttpConstants.HEADER_CONTENT_TYPE, contentType));\n        response.setHeader(new Header(HttpConstants.HEADER_DATE, date));\n        response.setHeader(new Header(HttpConstants.HEADER_SERVER, server));\n        if (msg.getProperty(HttpConstants.HEADER_EXPIRES) == null) {\n            response.setHeader(new Header(HttpConstants.HEADER_EXPIRES, date));\n        }\n        response.setFallbackCharset(encoding);\n\n        Collection headerNames = HttpConstants.RESPONSE_HEADER_NAMES.values();\n        String headerName, value;\n        for (Iterator iterator = headerNames.iterator(); iterator.hasNext();) {\n            headerName = (String)iterator.next();\n            value = msg.getStringProperty(headerName, null);\n            if (value != null) {\n                response.setHeader(new Header(headerName, value));\n            }\n        }\n\n        // Custom responseHeaderNames\n        Map customHeaders = (Map)msg.getProperty(HttpConnector.HTTP_CUSTOM_HEADERS_MAP_PROPERTY);\n        if (customHeaders != null) {\n            Map.Entry entry;\n            for (Iterator iterator = customHeaders.entrySet().iterator(); iterator.hasNext();) {\n                entry = (Map.Entry)iterator.next();\n                if (entry.getValue() != null) {\n                    response\n                            .setHeader(new Header(entry.getKey().toString(), entry.getValue().toString()));\n                }\n            }\n        }\n\n        // Mule properties\n        UMOMessage m = context.getMessage();\n        String user = (String)m.getProperty(MuleProperties.MULE_USER_PROPERTY);\n        if (user != null) {\n            response\n                    .setHeader(new Header(CUSTOM_HEADER_PREFIX + MuleProperties.MULE_USER_PROPERTY, user));\n        }\n        if (m.getCorrelationId() != null) {\n            response.setHeader(new Header(CUSTOM_HEADER_PREFIX\n                    + MuleProperties.MULE_CORRELATION_ID_PROPERTY, m.getCorrelationId()));\n            response.setHeader(new Header(CUSTOM_HEADER_PREFIX\n                    + MuleProperties.MULE_CORRELATION_GROUP_SIZE_PROPERTY, String.valueOf(m\n                    .getCorrelationGroupSize())));\n            response.setHeader(new Header(CUSTOM_HEADER_PREFIX\n                    + MuleProperties.MULE_CORRELATION_SEQUENCE_PROPERTY, String.valueOf(m\n                    .getCorrelationSequence())));\n        }\n        if (m.getReplyTo() != null) {\n            response.setHeader(new Header(CUSTOM_HEADER_PREFIX + MuleProperties.MULE_REPLY_TO_PROPERTY,\n                    m.getReplyTo().toString()));\n        }\n        if (src instanceof InputStream) {\n            response.setBody((InputStream)src);\n        }\n        else if (src instanceof String) {\n            response.setBodyString(src.toString());\n        }\n        else {\n            response.setBody(new ByteArrayInputStream((byte[])serializableToByteArray.doTransform(src, encoding)));\n        }\n        return response;\n    }","commit_id":"79a096cef4d9edd693057110d1b68b4a5f5dd52f","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * search the stream for a match to a string\n     * @param string The string to match\n     * @return <strong>true<\/strong> is one is found, the current position\n     *         in stream is positioned after the search string, <strong>\n     *               false<\/strong> otherwise, position in stream unchanged.\n     */\n    boolean matches(String string) throws JasperException {\n        Mark mark = mark();\n        int ch = 0;\n        int i = 0;\n        do {\n            ch = nextChar();\n            if (((char) ch) != string.charAt(i++)) {\n                reset(mark);\n                return false;\n            }\n        } while (i < string.length());\n        return true;\n    }","id":99414,"modified_method":"/**\n     * search the stream for a match to a string\n     * @param string The string to match\n     * @return <strong>true<\/strong> is one is found, the current position\n     *         in stream is positioned after the search string, <strong>\n     *               false<\/strong> otherwise, position in stream unchanged.\n     */\n    boolean matches(String string) throws JasperException {\n       int len = string.length();\n       int cursor = current.cursor;\n       int streamSize = current.stream.length;\n       if (cursor + len < streamSize) { //Try to scan in memory\n           int line = current.line;\n           int col = current.col;\n           int ch;\n           int i = 0;\n           for(; i < len; i ++) {\n               ch = current.stream[i+cursor];\n               if (string.charAt(i) != ch) {\n                   return false;\n               }\n               if (ch == '\\n') {\n                  line ++;\n                  col = 0;\n               } else {\n                  col++;\n               }\n           }\n           current.update(i+cursor, line, col);\n       } else {\n           Mark mark = mark();\n           int ch = 0;\n           int i = 0;\n           do {\n               ch = nextChar();\n               if (((char) ch) != string.charAt(i++)) {\n                   setCurrent(mark);\n                   return false;\n               }\n           } while (i < len);\n       }\n       return true;\n    }","commit_id":"5fccf680b8acca734f39bda99c52574e917198d6","url":"https://github.com/apache/tomcat"},{"original_method":"String getText(Mark start, Mark stop) throws JasperException {\n        Mark oldstart = mark();\n        reset(start);\n        CharArrayWriter caw = new CharArrayWriter();\n        while (!stop.equals(mark()))\n            caw.write(nextChar());\n        caw.close();\n        reset(oldstart);\n        return caw.toString();\n    }","id":99415,"modified_method":"String getText(Mark start, Mark stop) throws JasperException {\n        Mark oldstart = mark();\n        reset(start);\n        CharArrayWriter caw = new CharArrayWriter();\n        while (!markEquals(stop)) {\n            caw.write(nextChar());\n        }\n        caw.close();\n        setCurrent(oldstart);\n        return caw.toString();\n    }","commit_id":"5fccf680b8acca734f39bda99c52574e917198d6","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Skip until the given string is matched in the stream, but ignoring\n     * chars initially escaped by a '\\'.\n     * When returned, the context is positioned past the end of the match.\n     *\n     * @param s The String to match.\n     * @return A non-null <code>Mark<\/code> instance (positioned immediately\n     *         before the search string) if found, <strong>null<\/strong>\n     *         otherwise.\n     */\n    Mark skipUntilIgnoreEsc(String limit) throws JasperException {\n        Mark ret = null;\n        int limlen = limit.length();\n        int ch;\n        int prev = 'x';        // Doesn't matter\n\n    skip:\n        for (ret = mark(), ch = nextChar() ; ch != -1 ;\n                 ret = mark(), prev = ch, ch = nextChar()) {\n            if (ch == '\\\\' && prev == '\\\\') {\n                ch = 0;                // Double \\ is not an escape char anymore\n            }\n            else if (ch == limit.charAt(0) && prev != '\\\\') {\n                for (int i = 1 ; i < limlen ; i++) {\n                    if (peekChar() == limit.charAt(i))\n                        nextChar();\n                    else\n                        continue skip;\n                }\n                return ret;\n            }\n        }\n        return null;\n    }","id":99416,"modified_method":"/**\n     * Skip until the given string is matched in the stream, but ignoring\n     * chars initially escaped by a '\\'.\n     * When returned, the context is positioned past the end of the match.\n     *\n     * @param s The String to match.\n     * @return A non-null <code>Mark<\/code> instance (positioned immediately\n     *         before the search string) if found, <strong>null<\/strong>\n     *         otherwise.\n     */\n    Mark skipUntilIgnoreEsc(String limit) throws JasperException {\n        Mark ret = mark();\n        int limlen = limit.length();\n        int ch;\n        int prev = 'x';        // Doesn't matter\n        char firstChar = limit.charAt(0);\n    skip:\n        for (ch = nextChar(ret) ; ch != -1 ; prev = ch, ch = nextChar(ret)) {\n            if (ch == '\\\\' && prev == '\\\\') {\n                ch = 0;                // Double \\ is not an escape char anymore\n            } else if (ch == firstChar && prev != '\\\\') {\n                for (int i = 1 ; i < limlen ; i++) {\n                    if (peekChar() == limit.charAt(i))\n                        nextChar();\n                    else\n                        continue skip;\n                }\n                return ret;\n            }\n        }\n        return null;\n    }","commit_id":"5fccf680b8acca734f39bda99c52574e917198d6","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Looks ahead to see if there are optional spaces followed by\n     * the given String.  If so, true is returned and those spaces and\n     * characters are skipped.  If not, false is returned and the\n     * position is restored to where we were before.\n     */\n    boolean matchesOptionalSpacesFollowedBy( String s )\n        throws JasperException\n    {\n        Mark mark = mark();\n\n        skipSpaces();\n        boolean result = matches( s );\n        if( !result ) {\n            reset( mark );\n        }\n\n        return result;\n    }","id":99417,"modified_method":"/**\n     * Looks ahead to see if there are optional spaces followed by\n     * the given String.  If so, true is returned and those spaces and\n     * characters are skipped.  If not, false is returned and the\n     * position is restored to where we were before.\n     */\n    boolean matchesOptionalSpacesFollowedBy( String s )\n        throws JasperException\n    {\n        Mark mark = mark();\n\n        skipSpaces();\n        boolean result = matches( s );\n        if( !result ) {\n            setCurrent(mark);\n        }\n\n        return result;\n    }","commit_id":"5fccf680b8acca734f39bda99c52574e917198d6","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Parse utils - Is current character a token delimiter ?\n     * Delimiters are currently defined to be =, &gt;, &lt;, \", and ' or any\n     * any space character as defined by <code>isSpace<\/code>.\n     *\n     * @return A boolean.\n     */\n    private boolean isDelimiter() throws JasperException {\n        if (! isSpace()) {\n            int ch = peekChar();\n            // Look for a single-char work delimiter:\n            if (ch == '=' || ch == '>' || ch == '\"' || ch == '\\''\n                    || ch == '/') {\n                return true;\n            }\n            // Look for an end-of-comment or end-of-tag:\n            if (ch == '-') {\n                Mark mark = mark();\n                if (((ch = nextChar()) == '>')\n                        || ((ch == '-') && (nextChar() == '>'))) {\n                    reset(mark);\n                    return true;\n                } else {\n                    reset(mark);\n                    return false;\n                }\n            }\n            return false;\n        } else {\n            return true;\n        }\n    }","id":99418,"modified_method":"/**\n     * Parse utils - Is current character a token delimiter ?\n     * Delimiters are currently defined to be =, &gt;, &lt;, \", and ' or any\n     * any space character as defined by <code>isSpace<\/code>.\n     *\n     * @return A boolean.\n     */\n    private boolean isDelimiter() throws JasperException {\n        if (! isSpace()) {\n            int ch = peekChar();\n            // Look for a single-char work delimiter:\n            if (ch == '=' || ch == '>' || ch == '\"' || ch == '\\''\n                    || ch == '/') {\n                return true;\n            }\n            // Look for an end-of-comment or end-of-tag:\n            if (ch == '-') {\n                Mark mark = mark();\n                if (((ch = nextChar()) == '>')\n                        || ((ch == '-') && (nextChar() == '>'))) {\n                    setCurrent(mark);\n                    return true;\n                } else {\n                    setCurrent(mark);\n                    return false;\n                }\n            }\n            return false;\n        } else {\n            return true;\n        }\n    }","commit_id":"5fccf680b8acca734f39bda99c52574e917198d6","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Skip until the given string is matched in the stream.\n     * When returned, the context is positioned past the end of the match.\n     *\n     * @param s The String to match.\n     * @return A non-null <code>Mark<\/code> instance (positioned immediately\n     *         before the search string) if found, <strong>null<\/strong>\n     *         otherwise.\n     */\n    Mark skipUntil(String limit) throws JasperException {\n        Mark ret = null;\n        int limlen = limit.length();\n        int ch;\n\n    skip:\n        for (ret = mark(), ch = nextChar() ; ch != -1 ;\n                 ret = mark(), ch = nextChar()) {\n            if (ch == limit.charAt(0)) {\n                Mark restart = mark();\n                for (int i = 1 ; i < limlen ; i++) {\n                    if (peekChar() == limit.charAt(i))\n                        nextChar();\n                    else {\n                        reset(restart);\n                        continue skip;\n                    }\n                }\n                return ret;\n            }\n        }\n        return null;\n    }","id":99419,"modified_method":"/**\n     * Skip until the given string is matched in the stream.\n     * When returned, the context is positioned past the end of the match.\n     *\n     * @param s The String to match.\n     * @return A non-null <code>Mark<\/code> instance (positioned immediately\n     *         before the search string) if found, <strong>null<\/strong>\n     *         otherwise.\n     */\n    Mark skipUntil(String limit) throws JasperException {\n        Mark ret = mark();\n        int limlen = limit.length();\n        char firstChar = limit.charAt(0);\n        Boolean result = null;\n        Mark restart = null;\n\n    skip:\n        while((result = indexOf(firstChar, ret)) != null) {\n           if (result.booleanValue()) {\n               if (restart != null) {\n                   restart.init(current, singleFile);\n               } else {\n                   restart = mark();\n               }\n               for (int i = 1 ; i < limlen ; i++) {\n                   if (peekChar() == limit.charAt(i)) {\n                       nextChar();\n                   } else {\n                       setCurrent(restart);\n                       continue skip;\n                   }\n               }\n               return ret;\n            }\n        }\n        return null;\n    }","commit_id":"5fccf680b8acca734f39bda99c52574e917198d6","url":"https://github.com/apache/tomcat"},{"original_method":"boolean matchesETag(String tagName) throws JasperException {\n        Mark mark = mark();\n\n        if (!matches(\"<\/\" + tagName))\n            return false;\n        skipSpaces();\n        if (nextChar() == '>')\n            return true;\n\n        reset(mark);\n        return false;\n    }","id":99420,"modified_method":"boolean matchesETag(String tagName) throws JasperException {\n        Mark mark = mark();\n\n        if (!matches(\"<\/\" + tagName))\n            return false;\n        skipSpaces();\n        if (nextChar() == '>')\n            return true;\n\n        setCurrent(mark);\n        return false;\n    }","commit_id":"5fccf680b8acca734f39bda99c52574e917198d6","url":"https://github.com/apache/tomcat"},{"original_method":"boolean matchesETagWithoutLessThan(String tagName)\n        throws JasperException\n    {\n       Mark mark = mark();\n\n       if (!matches(\"/\" + tagName))\n           return false;\n       skipSpaces();\n       if (nextChar() == '>')\n           return true;\n\n       reset(mark);\n       return false;\n    }","id":99421,"modified_method":"boolean matchesETagWithoutLessThan(String tagName)\n        throws JasperException\n    {\n       Mark mark = mark();\n\n       if (!matches(\"/\" + tagName))\n           return false;\n       skipSpaces();\n       if (nextChar() == '>')\n           return true;\n\n       setCurrent(mark);\n       return false;\n    }","commit_id":"5fccf680b8acca734f39bda99c52574e917198d6","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Constructor\n     */\n    Mark(Mark other) {\n\n        this.reader = other.reader;\n        this.ctxt = other.reader.getJspCompilationContext();\n        this.stream = other.stream;\n        this.fileId = other.fileId;\n        this.fileName = other.fileName;\n        this.cursor = other.cursor;\n        this.line = other.line;\n        this.col = other.col;\n        this.baseDir = other.baseDir;\n        this.encoding = other.encoding;\n\n        // clone includeStack without cloning contents\n        includeStack = new Stack<>();\n        for ( int i=0; i < other.includeStack.size(); i++ ) {\n            includeStack.addElement( other.includeStack.elementAt(i) );\n        }\n    }","id":99422,"modified_method":"/**\n     * Constructor\n     */\n    Mark(Mark other) {\n       init(other, false);\n    }","commit_id":"5fccf680b8acca734f39bda99c52574e917198d6","url":"https://github.com/apache/tomcat"},{"original_method":"@Nullable\n  private static PsiBuilder.Marker parsePrimaryExpressionStart(final PsiBuilder builder) {\n    IElementType tokenType = builder.getTokenType();\n\n    if (LITERALS.contains(tokenType)) {\n      final PsiBuilder.Marker literal = builder.mark();\n      builder.advanceLexer();\n      literal.done(JavaElementType.LITERAL_EXPRESSION);\n      return literal;\n    }\n    if (tokenType == JavaTokenType.LPARENTH) {\n      final PsiBuilder.Marker parenth = builder.mark();\n      builder.advanceLexer();\n\n      final PsiBuilder.Marker inner = parse(builder);\n      if (inner == null) {\n        error(builder, JavaErrorMessages.message(\"expected.expression\"));\n      }\n\n      if (!expect(builder, JavaTokenType.RPARENTH)) {\n        if (inner != null) {\n          error(builder, JavaErrorMessages.message(\"expected.rparen\"));\n        }\n      }\n\n      parenth.done(JavaElementType.PARENTH_EXPRESSION);\n      return parenth;\n    }\n    if (tokenType == JavaTokenType.LBRACE) {\n      return parseArrayInitializer(builder);\n    }\n\n    PsiBuilder.Marker annotation = null;\n    final PsiBuilder.Marker beforeAnnotation = builder.mark();\n    if (tokenType == JavaTokenType.AT) {\n      annotation = DeclarationParser.parseAnnotations(builder);\n      tokenType = builder.getTokenType();\n    }\n\n    if (tokenType == JavaTokenType.IDENTIFIER) {\n      final PsiBuilder.Marker refExpr;\n      if (annotation != null) {\n        final PsiBuilder.Marker refParam = annotation.precede();\n        refParam.doneBefore(JavaElementType.REFERENCE_PARAMETER_LIST, annotation);\n        refExpr = refParam.precede();\n      }\n      else {\n        refExpr = builder.mark();\n        builder.mark().done(JavaElementType.REFERENCE_PARAMETER_LIST);\n      }\n\n      builder.advanceLexer();\n      refExpr.done(JavaElementType.REFERENCE_EXPRESSION);\n      beforeAnnotation.drop();\n      return refExpr;\n    }\n\n    if (annotation != null) {\n      beforeAnnotation.rollbackTo();\n      tokenType = builder.getTokenType();\n    }\n    else {\n      beforeAnnotation.drop();\n    }\n\n    if (tokenType == JavaTokenType.THIS_KEYWORD) {\n      final PsiBuilder.Marker expr = builder.mark();\n      builder.mark().done(JavaElementType.REFERENCE_PARAMETER_LIST);\n      builder.advanceLexer();\n      expr.done(builder.getTokenType() != JavaTokenType.LPARENTH ? JavaElementType.THIS_EXPRESSION : JavaElementType.REFERENCE_EXPRESSION);\n      return expr;\n    }\n    if (tokenType == JavaTokenType.SUPER_KEYWORD) {\n      final PsiBuilder.Marker expr = builder.mark();\n      builder.mark().done(JavaElementType.REFERENCE_PARAMETER_LIST);\n      builder.advanceLexer();\n      expr.done(builder.getTokenType() != JavaTokenType.LPARENTH ? JavaElementType.SUPER_EXPRESSION : JavaElementType.REFERENCE_EXPRESSION);\n      return expr;\n    }\n    if (tokenType == JavaTokenType.NEW_KEYWORD) {\n      return parseNew(builder, null);\n    }\n    if (ElementType.PRIMITIVE_TYPE_BIT_SET.contains(tokenType)) {\n      return parseClassObjectAccess(builder);\n    }\n\n    return null;\n  }","id":99423,"modified_method":"@Nullable\n  private static PsiBuilder.Marker parsePrimaryExpressionStart(final PsiBuilder builder) {\n    IElementType tokenType = builder.getTokenType();\n\n    if (LITERALS.contains(tokenType)) {\n      final PsiBuilder.Marker literal = builder.mark();\n      builder.advanceLexer();\n      literal.done(JavaElementType.LITERAL_EXPRESSION);\n      return literal;\n    }\n    if (tokenType == JavaTokenType.LPARENTH) {\n      final PsiBuilder.Marker parenth = builder.mark();\n      builder.advanceLexer();\n\n      final PsiBuilder.Marker inner = parse(builder);\n      if (inner == null) {\n        error(builder, JavaErrorMessages.message(\"expected.expression\"));\n      }\n\n      if (!expect(builder, JavaTokenType.RPARENTH)) {\n        if (inner != null) {\n          error(builder, JavaErrorMessages.message(\"expected.rparen\"));\n        }\n      }\n\n      parenth.done(JavaElementType.PARENTH_EXPRESSION);\n      return parenth;\n    }\n    if (tokenType == JavaTokenType.LBRACE) {\n      return parseArrayInitializer(builder);\n    }\n\n    PsiBuilder.Marker annotation = null;\n    final PsiBuilder.Marker beforeAnnotation = builder.mark();\n    if (tokenType == JavaTokenType.AT) {\n      annotation = DeclarationParser.parseAnnotations(builder);\n      tokenType = builder.getTokenType();\n    }\n\n    if (tokenType == JavaTokenType.IDENTIFIER) {\n      final PsiBuilder.Marker refExpr;\n      if (annotation != null) {\n        final PsiBuilder.Marker refParam = annotation.precede();\n        refParam.doneBefore(JavaElementType.REFERENCE_PARAMETER_LIST, annotation);\n        refExpr = refParam.precede();\n      }\n      else {\n        refExpr = builder.mark();\n        builder.mark().done(JavaElementType.REFERENCE_PARAMETER_LIST);\n      }\n\n      builder.advanceLexer();\n      refExpr.done(JavaElementType.REFERENCE_EXPRESSION);\n      beforeAnnotation.drop();\n      return refExpr;\n    }\n\n    if (annotation != null) {\n      beforeAnnotation.rollbackTo();\n      tokenType = builder.getTokenType();\n    }\n    else {\n      beforeAnnotation.drop();\n    }\n\n    PsiBuilder.Marker expr = null;\n    if (tokenType == JavaTokenType.LT) {\n      expr = builder.mark();\n\n      if (!ReferenceParser.parseReferenceParameterList(builder, false, false)) {\n        expr.rollbackTo();\n        return null;\n      }\n\n      tokenType = builder.getTokenType();\n      if (!CONSTRUCTOR_CALL.contains(tokenType)) {\n        expr.rollbackTo();\n        return null;\n      }\n    }\n\n    if (CONSTRUCTOR_CALL.contains(tokenType)) {\n      if (expr == null) {\n        expr = builder.mark();\n        builder.mark().done(JavaElementType.REFERENCE_PARAMETER_LIST);\n      }\n      builder.advanceLexer();\n      expr.done(builder.getTokenType() == JavaTokenType.LPARENTH\n                ? JavaElementType.REFERENCE_EXPRESSION\n                : tokenType == JavaTokenType.THIS_KEYWORD\n                  ? JavaElementType.THIS_EXPRESSION\n                  : JavaElementType.SUPER_EXPRESSION);\n      return expr;\n    }\n    if (tokenType == JavaTokenType.NEW_KEYWORD) {\n      return parseNew(builder, null);\n    }\n    if (ElementType.PRIMITIVE_TYPE_BIT_SET.contains(tokenType)) {\n      return parseClassObjectAccess(builder);\n    }\n\n    return null;\n  }","commit_id":"cb1db6171b604c8d917843e9159be65b365fea84","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void work(Cache cache, Buffer targetBuffer) {\n        String cacheName = cache.getClass().getCanonicalName();\n\n        while(true) {\n            try {\n                if (!cache.isEmpty() && serverStatus.isProcessing()) {\n                    LOG.debug(\"{} contains {} messages. Trying to process them.\", cacheName, cache.size());\n\n                    while (true) {\n                        if (cache.isEmpty()) {\n                            LOG.debug(\"Read all messages from {}.\", cacheName);\n                            break;\n                        }\n\n                        if (targetBuffer.hasCapacity() && serverStatus.isProcessing()) {\n                            try {\n                                LOG.debug(\"Reading message from {}.\", cacheName);\n                                Message msg = cache.pop();\n                                targetBuffer.insertFailFast(msg, msg.getSourceInput());\n                                writtenMessages.mark();\n                            } catch (BufferOutOfCapacityException ex) {\n                                outOfCapacity.mark();\n                                LOG.debug(\"Target buffer out of capacity in {}. Breaking.\", cacheName);\n                                break;\n                            }\n                        }\n                    }\n                }\n            } catch(Exception e) {\n                LOG.error(\"Error while trying to work on MasterCache <{}>.\", cacheName, e);\n                try {\n                    Thread.sleep(1000);\n                } catch(InterruptedException ex) { /* */ }\n            }\n\n            try {\n                Thread.sleep(100);\n            } catch(InterruptedException ex) { /* */ }\n        }\n    }","id":99424,"modified_method":"private void work(Cache cache, Buffer targetBuffer) {\n        String cacheName = cache.getClass().getCanonicalName();\n\n        while(true) {\n            try {\n                if (!cache.isEmpty() && serverStatus.isProcessing()) {\n                    LOG.debug(\"{} contains {} messages. Trying to process them.\", cacheName, cache.size());\n\n                    while (true) {\n                        if (cache.isEmpty()) {\n                            LOG.debug(\"Read all messages from {}.\", cacheName);\n                            break;\n                        }\n\n                        if (targetBuffer.hasCapacity() && serverStatus.isProcessing()) {\n                            try {\n                                LOG.debug(\"Reading message from {}.\", cacheName);\n                                Message msg = cache.pop();\n                                if (msg != null) {\n                                    targetBuffer.insertFailFast(msg, msg.getSourceInput());\n                                    writtenMessages.mark();\n                                }\n                            } catch (BufferOutOfCapacityException ex) {\n                                outOfCapacity.mark();\n                                LOG.debug(\"Target buffer out of capacity in {}. Breaking.\", cacheName);\n                                break;\n                            }\n                        }\n                    }\n                }\n            } catch(Exception e) {\n                LOG.error(\"Error while trying to work on MasterCache <{}>.\", cacheName, e);\n                try {\n                    Thread.sleep(1000);\n                } catch(InterruptedException ex) { /* */ }\n            }\n\n            try {\n                Thread.sleep(100);\n            } catch(InterruptedException ex) { /* */ }\n        }\n    }","commit_id":"1bfc73651f848149156b5d77c7d1ba92c935c92f","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Inject\n  public BasicAuthenticationHandler() throws Exception {\n    super();\n\n    String[] roles = Constants.Security.BASIC_USER_ROLES;\n    Constraint constraint = new Constraint();\n    constraint.setName(Constraint.__BASIC_AUTH);\n    constraint.setRoles(roles);\n    constraint.setAuthenticate(true);\n\n    ConstraintMapping constraintMapping = new ConstraintMapping();\n    constraintMapping.setConstraint(constraint);\n    constraintMapping.setPathSpec(\"/*\");\n\n    URL realmFile = getClass().getResource(\"/realm.properties\");\n    HashLoginService loginService = new HashLoginService();\n    loginService.setConfig(realmFile.toExternalForm());\n    loginService.loadUsers();\n    this.setAuthenticator(new BasicAuthenticator());\n    this.setLoginService(loginService);\n    this.setConstraintMappings(new ConstraintMapping[]{constraintMapping});\n  }","id":99425,"modified_method":"@Inject\n  public BasicAuthenticationHandler(CConfiguration configuration) throws Exception {\n    super();\n\n    String[] roles = Constants.Security.BASIC_USER_ROLES;\n    Constraint constraint = new Constraint();\n    constraint.setName(Constraint.__BASIC_AUTH);\n    constraint.setRoles(roles);\n    constraint.setAuthenticate(true);\n\n    if (configuration.getBoolean(Constants.Security.SSL_ENABLED, false)) {\n      constraint.setDataConstraint(Constraint.DC_CONFIDENTIAL);\n    }\n\n    ConstraintMapping constraintMapping = new ConstraintMapping();\n    constraintMapping.setConstraint(constraint);\n    constraintMapping.setPathSpec(\"/*\");\n\n    URL realmFile = getClass().getResource(\"/realm.properties\");\n    HashLoginService loginService = new HashLoginService();\n    loginService.setConfig(realmFile.toExternalForm());\n    loginService.loadUsers();\n    this.setAuthenticator(new BasicAuthenticator());\n    this.setLoginService(loginService);\n    this.setConstraintMappings(new ConstraintMapping[]{constraintMapping});\n  }","commit_id":"3b0a5ade7ff9d812fb816200ad86e0c88b2c6c92","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void startUp() {\n    try {\n      server = new Server();\n\n      QueuedThreadPool threadPool = new QueuedThreadPool();\n      threadPool.setMaxThreads(maxThreads);\n      server.setThreadPool(threadPool);\n\n      ContextHandler context = new ContextHandler();\n      context.setContextPath(\"*\");\n      context.setHandler(handlers);\n\n      SelectChannelConnector connector = new SelectChannelConnector();\n      connector.setPort(port);\n      server.setConnectors(new Connector[]{connector});\n\n      server.setHandler(context);\n    } catch (Exception e) {\n      LOG.error(\"Error while starting server.\");\n      LOG.error(e.getMessage());\n    }\n  }","id":99426,"modified_method":"@Override\n  protected void startUp() {\n    try {\n      server = new Server();\n\n      QueuedThreadPool threadPool = new QueuedThreadPool();\n      threadPool.setMaxThreads(maxThreads);\n      server.setThreadPool(threadPool);\n\n      ContextHandler context = new ContextHandler();\n      context.setContextPath(\"*\");\n      context.setHandler(handlers);\n\n      SelectChannelConnector connector = new SelectChannelConnector();\n      connector.setPort(port);\n\n      if (configuration.getBoolean(Constants.Security.SSL_ENABLED, false)) {\n        SslContextFactory sslContextFactory = new SslContextFactory();\n        sslContextFactory.setKeyStorePath(\"/Users/gandu/workspace/keystore\");\n        sslContextFactory.setKeyStorePassword(\"realtime\");\n\n        SslSelectChannelConnector sslSelectChannelConnector = new SslSelectChannelConnector(sslContextFactory);\n        int confidentialPort = configuration.getInt(Constants.Security.SSL_PROTECTED_PORT);\n        sslSelectChannelConnector.setPort(port);\n//        sslSelectChannelConnector.setPort(confidentialPort);\n//        connector.setConfidentialPort(confidentialPort);\n\n        server.setConnectors(new Connector[]{sslSelectChannelConnector});\n      } else {\n        server.setConnectors(new Connector[]{connector});\n      }\n\n      server.setHandler(context);\n    } catch (Exception e) {\n      LOG.error(\"Error while starting server.\");\n      LOG.error(e.getMessage());\n    }\n  }","commit_id":"3b0a5ade7ff9d812fb816200ad86e0c88b2c6c92","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject\n  public BasicAuthenticationHandler(CConfiguration configuration) throws Exception {\n    super();\n\n    String[] roles = Constants.Security.BASIC_USER_ROLES;\n    Constraint constraint = new Constraint();\n    constraint.setName(Constraint.__BASIC_AUTH);\n    constraint.setRoles(roles);\n    constraint.setAuthenticate(true);\n\n    ConstraintMapping constraintMapping = new ConstraintMapping();\n    constraintMapping.setConstraint(constraint);\n    constraintMapping.setPathSpec(\"/*\");\n\n    URL realmFile = getClass().getResource(\"/realm.properties\");\n    HashLoginService loginService = new HashLoginService();\n    loginService.setConfig(realmFile.toExternalForm());\n    loginService.loadUsers();\n    this.setAuthenticator(new BasicAuthenticator());\n    this.setLoginService(loginService);\n    this.setConstraintMappings(new ConstraintMapping[]{constraintMapping});\n  }","id":99427,"modified_method":"@Inject\n  public BasicAuthenticationHandler(CConfiguration configuration) throws Exception {\n    super();\n\n    String[] roles = Constants.Security.BASIC_USER_ROLES;\n    Constraint constraint = new Constraint();\n    constraint.setName(Constraint.__BASIC_AUTH);\n    constraint.setRoles(roles);\n    constraint.setAuthenticate(true);\n\n    if (configuration.getBoolean(Constants.Security.SSL_ENABLED)) {\n      constraint.setDataConstraint(Constraint.DC_CONFIDENTIAL);\n    }\n\n    ConstraintMapping constraintMapping = new ConstraintMapping();\n    constraintMapping.setConstraint(constraint);\n    constraintMapping.setPathSpec(\"/*\");\n\n    URL realmFile = getClass().getResource(\"/realm.properties\");\n    HashLoginService loginService = new HashLoginService();\n    loginService.setConfig(realmFile.toExternalForm());\n    loginService.loadUsers();\n    this.setAuthenticator(new BasicAuthenticator());\n    this.setLoginService(loginService);\n    this.setConstraintMappings(new ConstraintMapping[]{constraintMapping});\n  }","commit_id":"d2e8b388a80828aaa6254e9df92355357be6d9a2","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void startUp() {\n    try {\n      server = new Server();\n\n      QueuedThreadPool threadPool = new QueuedThreadPool();\n      threadPool.setMaxThreads(maxThreads);\n      server.setThreadPool(threadPool);\n\n      ContextHandler context = new ContextHandler();\n      context.setContextPath(\"*\");\n      context.setHandler(handlers);\n\n      SelectChannelConnector connector;\n\n      if (configuration.getBoolean(Constants.Security.SSL_ENABLED, false)) {\n        SslContextFactory sslContextFactory = new SslContextFactory();\n        String keystorePath = configuration.get(Constants.Security.SSL_KEYSTORE_PATH);\n        String keyStorePassword = configuration.get(Constants.Security.SSL_KEYSTORE_PASSWORD);\n        if (keystorePath == null || keyStorePassword == null) {\n          throw Throwables.propagate(new RuntimeException(\"Keystore not configured correctly\"));\n        }\n        sslContextFactory.setKeyStorePath(keystorePath);\n        sslContextFactory.setKeyStorePassword(keyStorePassword);\n\n        connector = new SslSelectChannelConnector(sslContextFactory);\n      } else {\n        connector = new SelectChannelConnector();\n      }\n\n      connector.setPort(port);\n      server.setConnectors(new Connector[]{connector});\n      server.setHandler(context);\n    } catch (Exception e) {\n      LOG.error(\"Error while starting server.\");\n      LOG.error(e.getMessage());\n    }\n  }","id":99428,"modified_method":"@Override\n  protected void startUp() {\n    try {\n      server = new Server();\n\n      QueuedThreadPool threadPool = new QueuedThreadPool();\n      threadPool.setMaxThreads(maxThreads);\n      server.setThreadPool(threadPool);\n\n      ContextHandler context = new ContextHandler();\n      context.setContextPath(\"*\");\n      context.setHandler(handlers);\n\n      SelectChannelConnector connector = new SelectChannelConnector();\n      connector.setPort(port);\n\n      if (configuration.getBoolean(Constants.Security.SSL_ENABLED, false)) {\n        SslContextFactory sslContextFactory = new SslContextFactory();\n        String keystorePath = configuration.get(Constants.Security.SSL_KEYSTORE_PATH);\n        String keyStorePassword = configuration.get(Constants.Security.SSL_KEYSTORE_PASSWORD);\n        if (keystorePath == null || keyStorePassword == null) {\n          throw Throwables.propagate(new RuntimeException(\"Keystore not configured correctly\"));\n        }\n        sslContextFactory.setKeyStorePath(keystorePath);\n        sslContextFactory.setKeyStorePassword(keyStorePassword);\n\n        SslSelectChannelConnector sslConnector = new SslSelectChannelConnector(sslContextFactory);\n        int sslPort = configuration.getInt(Constants.Security.SSL_PORT);\n        sslConnector.setPort(sslPort);\n        connector.setConfidentialPort(sslPort);\n        server.setConnectors(new Connector[]{connector, sslConnector});\n      } else {\n        server.setConnectors(new Connector[]{connector});\n      }\n\n      server.setHandler(context);\n    } catch (Exception e) {\n      LOG.error(\"Error while starting server.\");\n      LOG.error(e.getMessage());\n    }\n  }","commit_id":"d2e8b388a80828aaa6254e9df92355357be6d9a2","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject\n  public JAASAuthenticationHandler(String loginModuleName, CConfiguration configuration) throws Exception {\n    super();\n\n    Constraint constraint = new Constraint();\n    constraint.setRoles(new String[] {\"*\"});\n    constraint.setAuthenticate(true);\n\n    ConstraintMapping constraintMapping = new ConstraintMapping();\n    constraintMapping.setConstraint(constraint);\n    constraintMapping.setPathSpec(\"/*\");\n\n    JAASLoginService jaasLoginService = new JAASLoginService();\n    jaasLoginService.setLoginModuleName(loginModuleName);\n    jaasLoginService.setConfiguration(getLoginModuleConfiguration());\n\n    this.setStrict(false);\n    this.setIdentityService(new DefaultIdentityService());\n    this.setAuthenticator(new BasicAuthenticator());\n    this.setLoginService(jaasLoginService);\n    this.setConstraintMappings(new ConstraintMapping[]{constraintMapping});\n  }","id":99429,"modified_method":"@Inject\n  public JAASAuthenticationHandler(String loginModuleName, CConfiguration configuration) throws Exception {\n    super();\n\n    Constraint constraint = new Constraint();\n    constraint.setRoles(new String[] {\"*\"});\n    constraint.setAuthenticate(true);\n\n    ConstraintMapping constraintMapping = new ConstraintMapping();\n    constraintMapping.setConstraint(constraint);\n    constraintMapping.setPathSpec(\"/*\");\n\n    if (configuration.getBoolean(Constants.Security.SSL_ENABLED)) {\n      constraint.setDataConstraint(Constraint.DC_CONFIDENTIAL);\n    }\n\n    JAASLoginService jaasLoginService = new JAASLoginService();\n    jaasLoginService.setLoginModuleName(loginModuleName);\n    jaasLoginService.setConfiguration(getLoginModuleConfiguration());\n\n    this.setStrict(false);\n    this.setIdentityService(new DefaultIdentityService());\n    this.setAuthenticator(new BasicAuthenticator());\n    this.setLoginService(jaasLoginService);\n    this.setConstraintMappings(new ConstraintMapping[]{constraintMapping});\n  }","commit_id":"d2e8b388a80828aaa6254e9df92355357be6d9a2","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Create a new Authentication handler to interface with JASPI plugins.\n   * @param configuration\n   * @throws Exception\n   */\n  @Inject\n  public JASPIAuthenticationHandler(CConfiguration configuration) throws Exception {\n    super();\n    this.configuration = configuration;\n\n    Constraint constraint = new Constraint();\n    constraint.setRoles(new String[] {\"*\"});\n    constraint.setAuthenticate(true);\n\n    ConstraintMapping constraintMapping = new ConstraintMapping();\n    constraintMapping.setConstraint(constraint);\n    constraintMapping.setPathSpec(\"/*\");\n\n    JAASLoginService loginService = new JAASLoginService();\n    loginService.setLoginModuleName(\"JASPI\");\n    loginService.setConfiguration(getLoginModuleConfiguration());\n\n    DefaultIdentityService identityService = new DefaultIdentityService();\n\n    loginService.setIdentityService(identityService);\n    JaspiAuthenticatorFactory jaspiAuthenticatorFactory = new JaspiAuthenticatorFactory();\n    jaspiAuthenticatorFactory.setLoginService(loginService);\n\n    HashMap<String, ServerAuthContext> serverAuthContextMap = new HashMap<String, ServerAuthContext>();\n    ServletCallbackHandler callbackHandler = new ServletCallbackHandler(loginService);\n    ServerAuthModule authModule = new BasicAuthModule(callbackHandler, \"JAASRealm\");\n    serverAuthContextMap.put(\"authContextID\", new ServerAuthContextImpl(Collections.singletonList(authModule)));\n\n    ServerAuthContextType serverAuthContextType = new ServerAuthContextType(\"HTTP\", \"server *\",\n                                                                            \"authContextID\",\n                                                                            new AuthModuleType<ServerAuthModule>());\n    ServerAuthConfigType serverAuthConfigType = new ServerAuthConfigType(serverAuthContextType, true);\n    ServerAuthConfig serverAuthConfig = new ServerAuthConfigImpl(serverAuthConfigType, serverAuthContextMap);\n    JaspiAuthenticator jaspiAuthenticator = new JaspiAuthenticator(serverAuthConfig, null, callbackHandler,\n                                                                   new Subject(), true, identityService);\n\n    this.setStrict(false);\n    this.setIdentityService(identityService);\n    this.setAuthenticator(jaspiAuthenticator);\n    this.setLoginService(loginService);\n\n    this.setConstraintMappings(new ConstraintMapping[]{constraintMapping});\n  }","id":99430,"modified_method":"/**\n   * Create a new Authentication handler to interface with JASPI plugins.\n   * @param configuration\n   * @throws Exception\n   */\n  @Inject\n  public JASPIAuthenticationHandler(CConfiguration configuration) throws Exception {\n    super();\n    this.configuration = configuration;\n\n    Constraint constraint = new Constraint();\n    constraint.setRoles(new String[] {\"*\"});\n    constraint.setAuthenticate(true);\n\n    if (configuration.getBoolean(Constants.Security.SSL_ENABLED)) {\n      constraint.setDataConstraint(Constraint.DC_CONFIDENTIAL);\n    }\n\n    ConstraintMapping constraintMapping = new ConstraintMapping();\n    constraintMapping.setConstraint(constraint);\n    constraintMapping.setPathSpec(\"/*\");\n\n    JAASLoginService loginService = new JAASLoginService();\n    loginService.setLoginModuleName(\"JASPI\");\n    loginService.setConfiguration(getLoginModuleConfiguration());\n\n    DefaultIdentityService identityService = new DefaultIdentityService();\n\n    loginService.setIdentityService(identityService);\n    JaspiAuthenticatorFactory jaspiAuthenticatorFactory = new JaspiAuthenticatorFactory();\n    jaspiAuthenticatorFactory.setLoginService(loginService);\n\n    HashMap<String, ServerAuthContext> serverAuthContextMap = new HashMap<String, ServerAuthContext>();\n    ServletCallbackHandler callbackHandler = new ServletCallbackHandler(loginService);\n    ServerAuthModule authModule = new BasicAuthModule(callbackHandler, \"JAASRealm\");\n    serverAuthContextMap.put(\"authContextID\", new ServerAuthContextImpl(Collections.singletonList(authModule)));\n\n    ServerAuthContextType serverAuthContextType = new ServerAuthContextType(\"HTTP\", \"server *\",\n                                                                            \"authContextID\",\n                                                                            new AuthModuleType<ServerAuthModule>());\n    ServerAuthConfigType serverAuthConfigType = new ServerAuthConfigType(serverAuthContextType, true);\n    ServerAuthConfig serverAuthConfig = new ServerAuthConfigImpl(serverAuthConfigType, serverAuthContextMap);\n    JaspiAuthenticator jaspiAuthenticator = new JaspiAuthenticator(serverAuthConfig, null, callbackHandler,\n                                                                   new Subject(), true, identityService);\n\n    this.setStrict(false);\n    this.setIdentityService(identityService);\n    this.setAuthenticator(jaspiAuthenticator);\n    this.setLoginService(loginService);\n\n    this.setConstraintMappings(new ConstraintMapping[]{constraintMapping});\n  }","commit_id":"d2e8b388a80828aaa6254e9df92355357be6d9a2","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * {@inheritDoc}\n     * @see org.jboss.as.controller.Extension#initialize(org.jboss.as.controller.ExtensionContext)\n     */\n    @Override\n    public void initialize(ExtensionContext context) {\n        // IMPORTANT: Management API version != xsd version! Not all Management API changes result in XSD changes\n        SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, MANAGEMENT_API_MAJOR_VERSION,\n                MANAGEMENT_API_MINOR_VERSION, MANAGEMENT_API_MICRO_VERSION);\n\n        ManagementResourceRegistration registration = subsystem.registerSubsystemModel(new InfinispanSubsystemRootResource());\n        registration.registerOperationHandler(GenericSubsystemDescribeHandler.DEFINITION, GenericSubsystemDescribeHandler.INSTANCE);\n\n        ManagementResourceRegistration cacheContainer = registration.registerSubModel(new CacheContainerResource());\n\n        subsystem.registerXMLElementWriter(new InfinispanSubsystemXMLWriter());\n\n        // Register the model transformers\n        TransformersSubRegistration reg = subsystem.registerModelTransformers(ModelVersion.create(1, 3), new InfinispanSubsystemTransformer_1_3());\n        TransformersSubRegistration containerReg = reg.registerSubResource(CacheContainerResource.CONTAINER_PATH);\n        InfinispanOperationTransformer_1_3 ot = new InfinispanOperationTransformer_1_3();\n        containerReg.registerSubResource(LocalCacheResource.LOCAL_CACHE_PATH).registerOperationTransformer(ADD, ot);\n        containerReg.registerSubResource(InvalidationCacheResource.INVALIDATION_CACHE_PATH).registerOperationTransformer(ADD, ot);\n        containerReg.registerSubResource(ReplicatedCacheResource.REPLICATED_CACHE_PATH).registerOperationTransformer(ADD, ot);\n        containerReg.registerSubResource(DistributedCacheResource.DISTRIBUTED_CACHE_PATH).registerOperationTransformer(ADD, ot);\n    }","id":99431,"modified_method":"/**\n     * {@inheritDoc}\n     * @see org.jboss.as.controller.Extension#initialize(org.jboss.as.controller.ExtensionContext)\n     */\n    @Override\n    public void initialize(ExtensionContext context) {\n        // IMPORTANT: Management API version != xsd version! Not all Management API changes result in XSD changes\n        SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, MANAGEMENT_API_MAJOR_VERSION,\n                MANAGEMENT_API_MINOR_VERSION, MANAGEMENT_API_MICRO_VERSION);\n\n        subsystem.registerSubsystemModel(new InfinispanSubsystemRootResource());\n\n        subsystem.registerXMLElementWriter(new InfinispanSubsystemXMLWriter());\n\n        // Register the model transformers\n        TransformersSubRegistration reg = subsystem.registerModelTransformers(ModelVersion.create(1, 3), new InfinispanSubsystemTransformer_1_3());\n        TransformersSubRegistration containerReg = reg.registerSubResource(CacheContainerResource.CONTAINER_PATH);\n        InfinispanOperationTransformer_1_3 ot = new InfinispanOperationTransformer_1_3();\n        containerReg.registerSubResource(LocalCacheResource.LOCAL_CACHE_PATH).registerOperationTransformer(ADD, ot);\n        containerReg.registerSubResource(InvalidationCacheResource.INVALIDATION_CACHE_PATH).registerOperationTransformer(ADD, ot);\n        containerReg.registerSubResource(ReplicatedCacheResource.REPLICATED_CACHE_PATH).registerOperationTransformer(ADD, ot);\n        containerReg.registerSubResource(DistributedCacheResource.DISTRIBUTED_CACHE_PATH).registerOperationTransformer(ADD, ot);\n    }","commit_id":"8be153e2f117ec6621cd3b46e1feb4c14624a83c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void registerOperations(ManagementResourceRegistration resourceRegistration) {\n        super.registerOperations(resourceRegistration);\n    }","id":99432,"modified_method":"@Override\n    public void registerOperations(ManagementResourceRegistration resourceRegistration) {\n        super.registerOperations(resourceRegistration);\n        resourceRegistration.registerOperationHandler(GenericSubsystemDescribeHandler.DEFINITION, GenericSubsystemDescribeHandler.INSTANCE);\n    }","commit_id":"8be153e2f117ec6621cd3b46e1feb4c14624a83c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void registerChildren(ManagementResourceRegistration resourceRegistration) {\n        super.registerChildren(resourceRegistration);\n    }","id":99433,"modified_method":"@Override\n    public void registerChildren(ManagementResourceRegistration resourceRegistration) {\n        resourceRegistration.registerSubModel(new CacheContainerResource());\n    }","commit_id":"8be153e2f117ec6621cd3b46e1feb4c14624a83c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void initialize(final ExtensionContext context) {\n        final SubsystemRegistration subsystem = context.registerSubsystem(Constants.SUBSYSTEM_NAME, MAJOR_VERSION, MINOR_VERSION, MICRO_VERSION);\n        final ManagementResourceRegistration subsystemRegistration = subsystem.registerSubsystemModel(AppClientSubsystemProviders.SUBSYSTEM);\n\n        // register the operations\n        // EJB3 subsystem ADD operation\n        subsystemRegistration.registerOperationHandler(ADD, AppClientSubsystemAdd.INSTANCE, AppClientSubsystemAdd.INSTANCE, false);\n        subsystem.registerXMLElementWriter(parser);\n    }","id":99434,"modified_method":"@Override\n    public void initialize(final ExtensionContext context) {\n        final SubsystemRegistration subsystem = context.registerSubsystem(Constants.SUBSYSTEM_NAME, MAJOR_VERSION, MINOR_VERSION, MICRO_VERSION);\n        subsystem.registerSubsystemModel(AppClientSubsystemResourceDefinition.INSTANCE);\n        subsystem.registerXMLElementWriter(parser);\n    }","commit_id":"c94ca0fda2234b47a0a31a9e1e7d4795e8122dc9","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void performBoottime(final OperationContext context, ModelNode operation, final ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) {\n        final String deployment = model.get(DEPLOYMENT).asString();\n        final File file = new File(model.get(FILE).asString());\n        final String hostUrl = model.hasDefined(HOST_URL) ? model.get(HOST_URL).asString() : null;\n        final String connectionPropertiesUrl = model.hasDefined(CONNECTION_PROPERTIES_URL) ? model.get(CONNECTION_PROPERTIES_URL).asString() : null;\n        final List<String> parameters = new ArrayList<String>();\n        for (ModelNode param : model.get(PARAMETERS).asList()) {\n            parameters.add(param.asString());\n        }\n\n\n\n        context.addStep(new AbstractDeploymentChainStep() {\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n                if (deployment != null && !deployment.isEmpty()) {\n                    processorTarget.addDeploymentProcessor(Constants.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_APP_CLIENT, new ApplicationClientStructureProcessor(deployment));\n                }\n                processorTarget.addDeploymentProcessor(Constants.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_APP_CLIENT_XML, new ApplicationClientParsingDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(Constants.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_APPLICATION_CLIENT_MANIFEST, new ApplicationClientManifestProcessor());\n                processorTarget.addDeploymentProcessor(Constants.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_APPLICATION_CLIENT_ACTIVE, new ActiveApplicationClientProcessor(deployment));\n                processorTarget.addDeploymentProcessor(Constants.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_APP_CLIENT_METHOD_RESOLUTION, new ApplicationClientDescriptorMethodProcessor());\n                processorTarget.addDeploymentProcessor(Constants.SUBSYSTEM_NAME, Phase.DEPENDENCIES, Phase.DEPENDENCIES_APPLICATION_CLIENT, new ApplicationClientDependencyProcessor());\n                processorTarget.addDeploymentProcessor(Constants.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_APPLICATION_CLIENT, new ApplicationClientStartProcessor(hostUrl, connectionPropertiesUrl, parameters.toArray(EMPTY_STRING)));\n\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        final ApplicationClientDeploymentService service = new ApplicationClientDeploymentService(file);\n\n        newControllers.add(\n                context.getServiceTarget().addService(ApplicationClientDeploymentService.SERVICE_NAME, service)\n                        .addDependency(Services.JBOSS_SERVER_CONTROLLER, ModelController.class, service.getControllerValue())\n                        .install());\n\n    }","id":99435,"modified_method":"protected void performBoottime(final OperationContext context, ModelNode operation, final ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final String deployment = AppClientSubsystemResourceDefinition.DEPLOYMENT.resolveModelAttribute(context, model).asString();\n        final File file = new File(AppClientSubsystemResourceDefinition.FILE.resolveModelAttribute(context, model).asString());\n        final String hostUrl = model.hasDefined(HOST_URL) ? AppClientSubsystemResourceDefinition.HOST_URL.resolveModelAttribute(context, model).asString() : null;\n        final String connectionPropertiesUrl = model.hasDefined(CONNECTION_PROPERTIES_URL) ? AppClientSubsystemResourceDefinition.CONNECTION_PROPERTIES_URL.resolveModelAttribute(context, model).asString() : null;\n        final List<String> parameters = new ArrayList<String>();\n        for (ModelNode param : AppClientSubsystemResourceDefinition.PARAMETERS.resolveModelAttribute(context, model).asList()) {\n            parameters.add(param.asString());\n        }\n\n        context.addStep(new AbstractDeploymentChainStep() {\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n                if (deployment != null && !deployment.isEmpty()) {\n                    processorTarget.addDeploymentProcessor(Constants.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_APP_CLIENT, new ApplicationClientStructureProcessor(deployment));\n                }\n                processorTarget.addDeploymentProcessor(Constants.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_APP_CLIENT_XML, new ApplicationClientParsingDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(Constants.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_APPLICATION_CLIENT_MANIFEST, new ApplicationClientManifestProcessor());\n                processorTarget.addDeploymentProcessor(Constants.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_APPLICATION_CLIENT_ACTIVE, new ActiveApplicationClientProcessor(deployment));\n                processorTarget.addDeploymentProcessor(Constants.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_APP_CLIENT_METHOD_RESOLUTION, new ApplicationClientDescriptorMethodProcessor());\n                processorTarget.addDeploymentProcessor(Constants.SUBSYSTEM_NAME, Phase.DEPENDENCIES, Phase.DEPENDENCIES_APPLICATION_CLIENT, new ApplicationClientDependencyProcessor());\n                processorTarget.addDeploymentProcessor(Constants.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_APPLICATION_CLIENT, new ApplicationClientStartProcessor(hostUrl, connectionPropertiesUrl, parameters.toArray(EMPTY_STRING)));\n\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        final ApplicationClientDeploymentService service = new ApplicationClientDeploymentService(file);\n\n        newControllers.add(\n                context.getServiceTarget().addService(ApplicationClientDeploymentService.SERVICE_NAME, service)\n                        .addDependency(Services.JBOSS_SERVER_CONTROLLER, ModelController.class, service.getControllerValue())\n                        .install());\n\n    }","commit_id":"c94ca0fda2234b47a0a31a9e1e7d4795e8122dc9","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void populateModel(ModelNode operation, ModelNode model) {\n        model.get(FILE).set(operation.get(FILE));\n        model.get(DEPLOYMENT).set(operation.get(DEPLOYMENT));\n        model.get(PARAMETERS).set(operation.get(PARAMETERS));\n        if(operation.hasDefined(HOST_URL)) {\n            model.get(HOST_URL).set(operation.get(HOST_URL));\n        }\n        if(operation.hasDefined(CONNECTION_PROPERTIES_URL)) {\n            model.get(CONNECTION_PROPERTIES_URL).set(operation.get(CONNECTION_PROPERTIES_URL));\n        }\n    }","id":99436,"modified_method":"protected void populateModel(ModelNode operation, ModelNode model) throws OperationFailedException {\n        for(SimpleAttributeDefinition attr : AppClientSubsystemResourceDefinition.ATTRIBUTES) {\n            attr.validateAndSet(operation, model);\n        }\n    }","commit_id":"c94ca0fda2234b47a0a31a9e1e7d4795e8122dc9","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public void initialize(final ExtensionContext context) {\n        JSFLogger.ROOT_LOGGER.debug(\"Activating JSF(Mojarra) Extension\");\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, MANAGEMENT_API_MAJOR_VERSION,\n                MANAGEMENT_API_MINOR_VERSION, MANAGEMENT_API_MICRO_VERSION);\n        final ManagementResourceRegistration registration = subsystem.registerSubsystemModel(JSF_SUBSYSTEM_RESOURCE);\n        registration.registerOperationHandler(GenericSubsystemDescribeHandler.DEFINITION, GenericSubsystemDescribeHandler.INSTANCE);\n        registration.registerOperationHandler(JSFImplListHandler.DEFINITION, new JSFImplListHandler());\n        subsystem.registerXMLElementWriter(PARSER);\n    }","id":99437,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public void initialize(final ExtensionContext context) {\n        JSFLogger.ROOT_LOGGER.debug(\"Activating JSF(Mojarra) Extension\");\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, MANAGEMENT_API_MAJOR_VERSION,\n                MANAGEMENT_API_MINOR_VERSION, MANAGEMENT_API_MICRO_VERSION);\n        subsystem.registerSubsystemModel(JSF_SUBSYSTEM_RESOURCE);\n        subsystem.registerXMLElementWriter(PARSER);\n    }","commit_id":"b72f8b72a6d3f1d24309582bb45ad45485c7e3fb","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n        @Override\n        public void writeContent(final XMLExtendedStreamWriter writer, final SubsystemMarshallingContext context) throws XMLStreamException {\n            context.startSubsystemElement(JSFExtension.NAMESPACE, false);\n            ModelNode defaultSlot = context.getModelNode().get(JSFResourceDefinition.DEFAULT_SLOT_ATTR_NAME);\n            if (defaultSlot.isDefined()) {\n                writer.writeAttribute(JSFResourceDefinition.DEFAULT_SLOT_ATTR_NAME, defaultSlot.asString());\n            }\n            writer.writeEndElement();\n        }","id":99438,"modified_method":"/** {@inheritDoc} */\n        @Override\n        public void writeContent(final XMLExtendedStreamWriter writer, final SubsystemMarshallingContext context) throws XMLStreamException {\n            context.startSubsystemElement(JSFExtension.NAMESPACE, false);\n            JSFResourceDefinition.DEFAULT_JSF_IMPL_SLOT.marshallAsAttribute(context.getModelNode(), writer);\n            writer.writeEndElement();\n        }","commit_id":"b72f8b72a6d3f1d24309582bb45ad45485c7e3fb","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void registerAttributes(ManagementResourceRegistration resourceRegistration) {\n        super.registerAttributes(resourceRegistration);\n        resourceRegistration.registerReadWriteAttribute(DEFAULT_JSF_IMPL_SLOT, null, new ReloadRequiredWriteAttributeHandler(DEFAULT_JSF_IMPL_SLOT));\n        resourceRegistration.registerReadOnlyAttribute(ACTIVE_JSF_IMPLS, activeJSFImplsHandler);\n    }","id":99439,"modified_method":"@Override\n    public void registerAttributes(ManagementResourceRegistration resourceRegistration) {\n        super.registerAttributes(resourceRegistration);\n        resourceRegistration.registerReadWriteAttribute(DEFAULT_JSF_IMPL_SLOT, null, new ReloadRequiredWriteAttributeHandler(DEFAULT_JSF_IMPL_SLOT));\n//        resourceRegistration.registerReadOnlyAttribute(ACTIVE_JSF_IMPLS, activeJSFImplsHandler);\n    }","commit_id":"b72f8b72a6d3f1d24309582bb45ad45485c7e3fb","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void addValueTypeDescription(final ModelNode node, final String prefix, final ResourceBundle bundle) {\n        for (AttributeDefinition valueType : valueTypes) {\n            // get the value type description of the attribute\n            final ModelNode valueTypeDesc = getValueTypeDescription(valueType, false);\n            final String p = (prefix == null || prefix.isEmpty()) ? suffix : String.format(\"%s.%s\", prefix, suffix);\n            // get the text description of the attribute\n            valueTypeDesc.get(ModelDescriptionConstants.DESCRIPTION).set(valueType.getAttributeTextDescription(bundle, p));\n            // set it as one of our value types, and return the value\n            final ModelNode childType = node.get(ModelDescriptionConstants.VALUE_TYPE, valueType.getName()).set(valueTypeDesc);\n            // if it is of type OBJECT itself (add its nested descriptions)\n            // seeing that OBJECT represents a grouping, use prefix+\".\"+suffix for naming the entries\n            if (valueType instanceof ObjectTypeAttributeDefinition) {\n               ObjectTypeAttributeDefinition.class.cast(valueType).addValueTypeDescription(childType, p, bundle);\n            }\n            // if it is of type LIST, and its value type\n            // seeing that LIST represents a grouping, use prefix+\".\"+suffix for naming the entries\n            if (valueType instanceof SimpleListAttributeDefinition) {\n                SimpleListAttributeDefinition.class.cast(valueType).addValueTypeDescription(childType, p, bundle);\n            }\n        }\n    }","id":99440,"modified_method":"protected void addValueTypeDescription(final ModelNode node, final String prefix, final ResourceBundle bundle) {\n        for (AttributeDefinition valueType : valueTypes) {\n            // get the value type description of the attribute\n            final ModelNode valueTypeDesc = getValueTypeDescription(valueType, false);\n            final String p;\n            if ((prefix == null || prefix.isEmpty()) && (suffix != null && suffix.isEmpty())) {\n                p = suffix;\n            } else if (suffix == null || suffix.isEmpty()) {\n                p = prefix;\n            } else {\n                p = String.format(\"%s.%s\", prefix, suffix);\n            }\n            // get the text description of the attribute\n            valueTypeDesc.get(ModelDescriptionConstants.DESCRIPTION).set(valueType.getAttributeTextDescription(bundle, p));\n            // set it as one of our value types, and return the value\n            final ModelNode childType = node.get(ModelDescriptionConstants.VALUE_TYPE, valueType.getName()).set(valueTypeDesc);\n            // if it is of type OBJECT itself (add its nested descriptions)\n            // seeing that OBJECT represents a grouping, use prefix+\".\"+suffix for naming the entries\n            if (valueType instanceof ObjectTypeAttributeDefinition) {\n                ObjectTypeAttributeDefinition.class.cast(valueType).addValueTypeDescription(childType, p, bundle);\n            }\n            // if it is of type LIST, and its value type\n            // seeing that LIST represents a grouping, use prefix+\".\"+suffix for naming the entries\n            if (valueType instanceof SimpleListAttributeDefinition) {\n                SimpleListAttributeDefinition.class.cast(valueType).addValueTypeDescription(childType, p, bundle);\n            }\n        }\n    }","commit_id":"c7089f89a56992c9fff5591dd2d4f3f5c0ffb287","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void initialize(ExtensionContext context) {\n        XtsAsLogger.ROOT_LOGGER.debug(\"Initializing XTS Extension\");\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, 1, 1);\n        final ManagementResourceRegistration registration = subsystem.registerSubsystemModel(XTSSubsystemProviders.SUBSYSTEM);\n        registration.registerOperationHandler(ModelDescriptionConstants.ADD, XTSSubsystemAdd.INSTANCE, XTSSubsystemProviders.SUBSYSTEM_ADD, false);\n        registration.registerOperationHandler(ModelDescriptionConstants.REMOVE, XTSSubsystemRemove.INSTANCE, XTSSubsystemProviders.SUBSYSTEM_REMOVE, false);\n        registration.registerOperationHandler(DESCRIBE, GenericSubsystemDescribeHandler.INSTANCE, GenericSubsystemDescribeHandler.INSTANCE, false, OperationEntry.EntryType.PRIVATE);\n        subsystem.registerXMLElementWriter(parser);\n    }","id":99441,"modified_method":"public void initialize(ExtensionContext context) {\n        XtsAsLogger.ROOT_LOGGER.debug(\"Initializing XTS Extension\");\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, 1, 1);\n        subsystem.registerSubsystemModel(XTSSubsystemDefinition.INSTANCE);\n        subsystem.registerXMLElementWriter(parser);\n    }","commit_id":"c7089f89a56992c9fff5591dd2d4f3f5c0ffb287","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void populateModel(ModelNode operation, ModelNode model) throws OperationFailedException {\n        ModelNode environmentNode = ENVIRONMENT.validateOperation(operation);\n        // URL.validateOperation will do a conversion to ModelType.EXPRESSION if necessary, same as what the parser does\n        // This is necessary to handle the case of the \"add\" operation being done by a mgmt client post-boot\n        ModelNode urlNode = environmentNode.isDefined() ? URL.validateOperation(environmentNode) : new ModelNode();\n        model.get(CommonAttributes.XTS_ENVIRONMENT, ModelDescriptionConstants.URL).set(urlNode);\n        // Brian Stansberry 2012/03/08: TODO get rid of this complex \"XTS_ENVIRONMENT\" attribute and for legacy\n        // compatibility only add a :read-attribute handler that can synthesize the attribute value from whatever\n        // resource structure replaces it. By \"get rid of\" I mean either make the \"url\" attribute a simple child of\n        // the subsystem, or, if there will need to be multiple structures to group sets of attributes together,\n        // create a properly addressable resource for each.\n    }","id":99442,"modified_method":"@Override\n    protected void populateModel(ModelNode operation, ModelNode model) throws OperationFailedException {\n        ENVIRONMENT_URL.validateAndSet(operation, model);\n    }","commit_id":"c7089f89a56992c9fff5591dd2d4f3f5c0ffb287","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performBoottime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final String coordinatorURL = model.get(CommonAttributes.XTS_ENVIRONMENT,ModelDescriptionConstants.URL).isDefined() ? context.resolveExpressions(model.get(CommonAttributes.XTS_ENVIRONMENT, ModelDescriptionConstants.URL)).asString() : null;\n        if (coordinatorURL != null && XtsAsLogger.ROOT_LOGGER.isDebugEnabled()) {\n            XtsAsLogger.ROOT_LOGGER.debugf(\"nodeIdentifier=%s\\n\", coordinatorURL);\n        }\n\n\n        final ServiceTarget target = context.getServiceTarget();\n\n                // TODO eventually we should add a config service which manages the XTS configuration\n                // this will allow us to include a switch enabling or disabling deployment of\n                // endpoints specific to client, coordinator or participant and then deploy\n                // and redeploy the relevant endpoints as needed/ the same switches can be used\n                // byte the XTS service to decide whether to perfomr client, coordinator or\n                // participant initialisation. we shoudl also provide config switches which\n                // decide whether to initialise classes and deploy services for AT, BA or both.\n                // for now we will just deploy all the endpoints and always do client, coordinator\n                // and participant init for both AT and BA.\n\n                // add an endpoint publisher service for each of the required endpoint contexts\n                // specifying all the relevant URL patterns and SEI classes\n\n                final ClassLoader loader = XTSService.class.getClassLoader();\n                ServiceBuilder<Context> endpointBuilder;\n                ArrayList<ServiceController<Context>> controllers = new ArrayList<ServiceController<Context>>();\n                for (ContextInfo contextInfo : contextDefinitions) {\n                    String contextName = contextInfo.contextPath;\n                    Map<String, String> map = new HashMap<String, String>();\n                    for (EndpointInfo endpointInfo : contextInfo.endpointInfo) {\n                        map.put(endpointInfo.URLPattern, endpointInfo.SEIClassname);\n                    }\n                    endpointBuilder = EndpointPublishService.createServiceBuilder(target, contextName, loader,\n                            ENDPOINT_SERVICE_HOST_NAME, map);\n\n                    controllers.add(endpointBuilder.setInitialMode(Mode.ACTIVE)\n                        .install());\n                }\n\n                // add an XTS service which depends on all the WS endpoints\n\n                final XTSManagerService xtsService = new XTSManagerService(coordinatorURL);\n\n                // this service needs to depend on the transaction recovery service\n                // because it can only initialise XTS recovery once the transaction recovery\n                // service has initialised the orb layer\n\n                ServiceBuilder<?> xtsServiceBuilder = target.addService(XTSServices.JBOSS_XTS_MAIN, xtsService);\n                xtsServiceBuilder\n                        .addDependency(TxnServices.JBOSS_TXN_ARJUNA_TRANSACTION_MANAGER);\n\n                // this service needs to depend on JBossWS Config Service to be notified of the JBoss WS config (bind address, port etc)\n                xtsServiceBuilder.addDependency(WSServices.CONFIG_SERVICE, ServerConfig.class, xtsService.getWSServerConfig());\n\n                // the service also needs to depend on the endpoint services\n                for (ServiceController<Context> controller : controllers) {\n                    xtsServiceBuilder.addDependency(controller.getName());\n                }\n\n                xtsServiceBuilder\n                        .setInitialMode(Mode.ACTIVE)\n                        .install();\n\n                // WS-AT / JTA Transaction bridge services:\n\n                final TxBridgeInboundRecoveryService txBridgeInboundRecoveryService = new TxBridgeInboundRecoveryService();\n                ServiceBuilder<?> txBridgeInboundRecoveryServiceBuilder =\n                        target.addService(XTSServices.JBOSS_XTS_TXBRIDGE_INBOUND_RECOVERY, txBridgeInboundRecoveryService);\n                txBridgeInboundRecoveryServiceBuilder.addDependency(XTSServices.JBOSS_XTS_MAIN);\n\n                txBridgeInboundRecoveryServiceBuilder.setInitialMode(Mode.ACTIVE).install();\n\n                final TxBridgeOutboundRecoveryService txBridgeOutboundRecoveryService = new TxBridgeOutboundRecoveryService();\n                ServiceBuilder<?> txBridgeOutboundRecoveryServiceBuilder =\n                        target.addService(XTSServices.JBOSS_XTS_TXBRIDGE_OUTBOUND_RECOVERY, txBridgeOutboundRecoveryService);\n                txBridgeOutboundRecoveryServiceBuilder.addDependency(XTSServices.JBOSS_XTS_MAIN);\n\n                txBridgeOutboundRecoveryServiceBuilder.setInitialMode(Mode.ACTIVE).install();\n\n    }","id":99443,"modified_method":"@Override\n    protected void performBoottime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final String coordinatorURL = ENVIRONMENT_URL.resolveModelAttribute(context, model).asString();\n        if (coordinatorURL != null && XtsAsLogger.ROOT_LOGGER.isDebugEnabled()) {\n            XtsAsLogger.ROOT_LOGGER.debugf(\"nodeIdentifier=%s\\n\", coordinatorURL);\n        }\n\n\n        final ServiceTarget target = context.getServiceTarget();\n\n        // TODO eventually we should add a config service which manages the XTS configuration\n        // this will allow us to include a switch enabling or disabling deployment of\n        // endpoints specific to client, coordinator or participant and then deploy\n        // and redeploy the relevant endpoints as needed/ the same switches can be used\n        // byte the XTS service to decide whether to perfomr client, coordinator or\n        // participant initialisation. we shoudl also provide config switches which\n        // decide whether to initialise classes and deploy services for AT, BA or both.\n        // for now we will just deploy all the endpoints and always do client, coordinator\n        // and participant init for both AT and BA.\n\n        // add an endpoint publisher service for each of the required endpoint contexts\n        // specifying all the relevant URL patterns and SEI classes\n\n        final ClassLoader loader = XTSService.class.getClassLoader();\n        ServiceBuilder<Context> endpointBuilder;\n        ArrayList<ServiceController<Context>> controllers = new ArrayList<ServiceController<Context>>();\n        for (ContextInfo contextInfo : contextDefinitions) {\n            String contextName = contextInfo.contextPath;\n            Map<String, String> map = new HashMap<String, String>();\n            for (EndpointInfo endpointInfo : contextInfo.endpointInfo) {\n                map.put(endpointInfo.URLPattern, endpointInfo.SEIClassname);\n            }\n            endpointBuilder = EndpointPublishService.createServiceBuilder(target, contextName, loader,\n                    ENDPOINT_SERVICE_HOST_NAME, map);\n\n            controllers.add(endpointBuilder.setInitialMode(Mode.ACTIVE)\n                    .install());\n        }\n\n        // add an XTS service which depends on all the WS endpoints\n\n        final XTSManagerService xtsService = new XTSManagerService(coordinatorURL);\n\n        // this service needs to depend on the transaction recovery service\n        // because it can only initialise XTS recovery once the transaction recovery\n        // service has initialised the orb layer\n\n        ServiceBuilder<?> xtsServiceBuilder = target.addService(XTSServices.JBOSS_XTS_MAIN, xtsService);\n        xtsServiceBuilder\n                .addDependency(TxnServices.JBOSS_TXN_ARJUNA_TRANSACTION_MANAGER);\n\n        // this service needs to depend on JBossWS Config Service to be notified of the JBoss WS config (bind address, port etc)\n        xtsServiceBuilder.addDependency(WSServices.CONFIG_SERVICE, ServerConfig.class, xtsService.getWSServerConfig());\n\n        // the service also needs to depend on the endpoint services\n        for (ServiceController<Context> controller : controllers) {\n            xtsServiceBuilder.addDependency(controller.getName());\n        }\n\n        xtsServiceBuilder\n                .setInitialMode(Mode.ACTIVE)\n                .install();\n\n        // WS-AT / JTA Transaction bridge services:\n\n        final TxBridgeInboundRecoveryService txBridgeInboundRecoveryService = new TxBridgeInboundRecoveryService();\n        ServiceBuilder<?> txBridgeInboundRecoveryServiceBuilder =\n                target.addService(XTSServices.JBOSS_XTS_TXBRIDGE_INBOUND_RECOVERY, txBridgeInboundRecoveryService);\n        txBridgeInboundRecoveryServiceBuilder.addDependency(XTSServices.JBOSS_XTS_MAIN);\n\n        txBridgeInboundRecoveryServiceBuilder.setInitialMode(Mode.ACTIVE).install();\n\n        final TxBridgeOutboundRecoveryService txBridgeOutboundRecoveryService = new TxBridgeOutboundRecoveryService();\n        ServiceBuilder<?> txBridgeOutboundRecoveryServiceBuilder =\n                target.addService(XTSServices.JBOSS_XTS_TXBRIDGE_OUTBOUND_RECOVERY, txBridgeOutboundRecoveryService);\n        txBridgeOutboundRecoveryServiceBuilder.addDependency(XTSServices.JBOSS_XTS_MAIN);\n\n        txBridgeOutboundRecoveryServiceBuilder.setInitialMode(Mode.ACTIVE).install();\n\n    }","commit_id":"c7089f89a56992c9fff5591dd2d4f3f5c0ffb287","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected String getSubsystemXml() throws IOException {\n        return\n            \"<subsystem xmlns=\\\"urn:jboss:domain:xts:1.0\\\">\" +\n            \"    <xts-environment url=\\\"http://localhost:8080/ws-c11/ActivationService\\\"/>\" +\n            \"<\/subsystem>\";\n    }","id":99444,"modified_method":"@Override\n    protected String getSubsystemXml() throws IOException {\n        return readResource(\"subsystem.xml\");\n    }","commit_id":"c7089f89a56992c9fff5591dd2d4f3f5c0ffb287","url":"https://github.com/wildfly/wildfly"},{"original_method":"private QueryParser getQueryParser(String indexName) {\n        QueryParser qp;\n        Analyzer analyzer = getAnalyzer(indexName);\n        if (indexName.compareTo(DOCS_INDEX_NAME) == 0) {\n            qp = new QueryParser(\"content\", analyzer);\n        } \n        else {\n            qp = new NGramQueryParser(\"name\", analyzer);\n        }\n        \n        return qp;\n    }","id":99445,"modified_method":"private QueryParser getQueryParser(String indexName) {\n        QueryParser qp;\n        Analyzer analyzer = getAnalyzer(indexName);\n        if (indexName.compareTo(BuilderFactory.DOCS_TYPE) == 0) {\n            qp = new QueryParser(\"content\", analyzer);\n        } \n        else {\n            qp = new NGramQueryParser(\"name\", analyzer);\n        }\n        \n        return qp;\n    }","commit_id":"82bbfc737faae561fc5ffcda8676521f85d9c512","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"private Analyzer getAnalyzer(String indexName) {\n        if (indexName.compareTo(DOCS_INDEX_NAME) == 0) {\n            log.debug(indexName + \" choosing StandardAnalyzer\");\n            return new StandardAnalyzer();\n        } \n        else {\n            log.debug(indexName + \" choosing PerFieldAnalyzerWrapper\");\n            PerFieldAnalyzerWrapper analyzer = new PerFieldAnalyzerWrapper(new \n                    NGramAnalyzer(min_ngram, max_ngram));\n            analyzer.addAnalyzer(\"arch\", new KeywordAnalyzer());\n            analyzer.addAnalyzer(\"version\", new KeywordAnalyzer());\n            analyzer.addAnalyzer(\"filename\", new KeywordAnalyzer());\n            analyzer.addAnalyzer(\"advisory\", new KeywordAnalyzer());\n            analyzer.addAnalyzer(\"advisoryName\", new KeywordAnalyzer());\n            analyzer.addAnalyzer(\"description\", new KeywordAnalyzer());\n            return analyzer;\n        } \n    }","id":99446,"modified_method":"private Analyzer getAnalyzer(String indexName) {\n        if (indexName.compareTo(BuilderFactory.DOCS_TYPE) == 0) {\n            log.debug(indexName + \" choosing StandardAnalyzer\");\n            return new StandardAnalyzer();\n        } \n        else if (indexName.compareTo(BuilderFactory.SERVER_TYPE) == 0) {\n            log.debug(indexName + \" choosing PerFieldAnalyzerWrapper\");\n            PerFieldAnalyzerWrapper analyzer = new PerFieldAnalyzerWrapper(new\n                    NGramAnalyzer(min_ngram, max_ngram));\n            analyzer.addAnalyzer(\"id\", new KeywordAnalyzer());\n            analyzer.addAnalyzer(\"description\", new SimpleAnalyzer());\n            analyzer.addAnalyzer(\"country\", new KeywordAnalyzer());\n            return analyzer;\n        }\n        else {\n            log.debug(indexName + \" choosing PerFieldAnalyzerWrapper\");\n            PerFieldAnalyzerWrapper analyzer = new PerFieldAnalyzerWrapper(new \n                    NGramAnalyzer(min_ngram, max_ngram));\n            analyzer.addAnalyzer(\"id\", new KeywordAnalyzer());\n            analyzer.addAnalyzer(\"arch\", new KeywordAnalyzer());\n            analyzer.addAnalyzer(\"version\", new KeywordAnalyzer());\n            analyzer.addAnalyzer(\"filename\", new KeywordAnalyzer());\n            analyzer.addAnalyzer(\"advisory\", new KeywordAnalyzer());\n            analyzer.addAnalyzer(\"advisoryName\", new KeywordAnalyzer());\n            analyzer.addAnalyzer(\"description\", new SimpleAnalyzer());\n            return analyzer;\n        } \n    }","commit_id":"82bbfc737faae561fc5ffcda8676521f85d9c512","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"private List<Result> processHits(String indexName, Hits hits) \n        throws IOException {\n        List<Result> retval = new ArrayList<Result>();\n        for (int x = 0; x < hits.length(); x++) {\n            Document doc = hits.doc(x);\n            Result pr = null;\n            if (indexName.compareTo(DOCS_INDEX_NAME) == 0) {\n                // TODO:\n                // Need to revist how the result is formed, I'm not positive\n                // using \"url\" makes sense for the Result \"id\".\n                pr = new Result(x, doc.getField(\"url\").stringValue(),\n                        doc.getField(\"title\").stringValue(),\n                        hits.score(x));\n            }\n            else {\n                pr = new Result(x,\n                        doc.getField(\"id\").stringValue(),\n                        doc.getField(\"name\").stringValue(),\n                        hits.score(x));\n            }\n            if (log.isDebugEnabled()) {\n                log.debug(\"Hit[\" + x + \"] Score = \" + hits.score(x) + \", Name = \" + \n                doc.getField(\"name\") + \", ID = \" + doc.getField(\"id\"));\n            }\n            if ((hits.score(x) < score_threshold) && (x > 10)) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Filtering out search results from \" + x + \" to \" + \n                            hits.length() + \", due to their score being below \" +\n                            \"score_threshold = \" + score_threshold);\n                }\n                break;\n            }\n            if (pr != null) {\n                retval.add(pr);\n            }\n            if (x == maxHits) {\n                break;\n            }\n        }\n        return retval;\n    }","id":99447,"modified_method":"private List<Result> processHits(String indexName, Hits hits) \n        throws IOException {\n        List<Result> retval = new ArrayList<Result>();\n        for (int x = 0; x < hits.length(); x++) {\n            Document doc = hits.doc(x);\n            Result pr = null;\n            if (indexName.compareTo(BuilderFactory.DOCS_TYPE) == 0) {\n                // TODO:\n                // Need to revist how the result is formed, I'm not positive\n                // using \"url\" makes sense for the Result \"id\".\n                pr = new Result(x, doc.getField(\"url\").stringValue(),\n                        doc.getField(\"title\").stringValue(),\n                        hits.score(x));\n            }\n            else {\n                pr = new Result(x,\n                        doc.getField(\"id\").stringValue(),\n                        doc.getField(\"name\").stringValue(),\n                        hits.score(x));\n            }\n            if (log.isDebugEnabled()) {\n                log.debug(\"Hit[\" + x + \"] Score = \" + hits.score(x) + \", Name = \" + \n                doc.getField(\"name\") + \", ID = \" + doc.getField(\"id\"));\n            }\n            if ((hits.score(x) < score_threshold) && (x > 10)) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Filtering out search results from \" + x + \" to \" + \n                            hits.length() + \", due to their score being below \" +\n                            \"score_threshold = \" + score_threshold);\n                }\n                break;\n            }\n            if (pr != null) {\n                retval.add(pr);\n            }\n            if (x == maxHits) {\n                break;\n            }\n        }\n        return retval;\n    }","commit_id":"82bbfc737faae561fc5ffcda8676521f85d9c512","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"public void StillNeedsWork_testQueryDocs()\n    \tthrows IOException, IndexingException, QueryParseException {\n    \t\n    \tConfiguration config = TestUtil.makeConfiguration();\n    \tconfig.setString(\"search.index_work_dir\", \"/usr/share/rhn/search/indexes/\");\n    \tIndexManager indexMgr = new IndexManager(config);\n    \t//\n    \t// TODO: Revisit how docs data gets injected for testing. \n    \t// Currently relying on docs data to already exist for now.\n    \t//\n    \tSystem.out.println(\"We are expecting nutch to have been run previously, \" +\n    \t\t\t\"and the index files to be copied to \"+ config.getString(\"search.index_work_dir\") +\n    \t\t\tindexMgr.DOCS_INDEX_NAME);\n    \t\n    \tString index = indexMgr.DOCS_INDEX_NAME;\n    \tString query = new String(\"redhat\");\n    \tList<Result> results = indexMgr.search(index, query);\n    \tSystem.out.println(\"Number of results returned is \" + results.size());\n    \tassertTrue(results.size() >= 1);\n    \t\n    }","id":99448,"modified_method":"public void StillNeedsWork_testQueryDocs()\n    \tthrows IOException, IndexingException, QueryParseException {\n    \t\n    \tConfiguration config = TestUtil.makeConfiguration();\n    \tconfig.setString(\"search.index_work_dir\", \"/usr/share/rhn/search/indexes/\");\n    \tIndexManager indexMgr = new IndexManager(config);\n    \t//\n    \t// TODO: Revisit how docs data gets injected for testing. \n    \t// Currently relying on docs data to already exist for now.\n    \t//\n    \tSystem.out.println(\"We are expecting nutch to have been run previously, \" +\n    \t\t\t\"and the index files to be copied to \"+ config.getString(\"search.index_work_dir\") +\n\t\t\tBuilderFactory.DOCS_TYPE);\n    \t\n\tString index = BuilderFactory.DOCS_TYPE;\n    \tString query = new String(\"redhat\");\n    \tList<Result> results = indexMgr.search(index, query);\n    \tSystem.out.println(\"Number of results returned is \" + results.size());\n    \tassertTrue(results.size() >= 1);\n    \t\n    }","commit_id":"82bbfc737faae561fc5ffcda8676521f85d9c512","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * @param databaseManager\n     * @return\n     */\n    private List<Server> getServers(DatabaseManager databaseManager) \n        throws SQLException {\n        // What was the last server id we indexed?\n        List<Server> retval = null;\n        Query<Long> query = databaseManager.getQuery(\"getLastServerId\");\n        Long sid = null;\n        try {\n            sid = query.load();\n        }\n        finally {\n            query.close();\n        }\n        if (sid == null) {\n            sid = new Long(0);\n        }\n        // When was the last time we ran the indexing of servers?\n        Query<Date> queryLast = databaseManager.getQuery(\"getLastServerIndexRun\");\n        Date indexServerLastRun = null;\n        try {\n            indexServerLastRun = queryLast.load();\n        }\n        finally {\n            queryLast.close();\n        }\n        if (indexServerLastRun == null) {\n            indexServerLastRun = new Date(0);\n        }\n        // Lookup what servers have not been indexed, or need to be reindexed.\n        Query<Server> srvrQuery = databaseManager.getQuery(\"getServersByModDateOrId\");\n        try {\n            Map params = new HashMap();\n            params.put(\"id\", sid);\n            params.put(\"modified_date\", indexServerLastRun);\n            retval = srvrQuery.loadList(params);\n        }\n        finally {\n            srvrQuery.close();\n        }\n        return retval;\n    }","id":99449,"modified_method":"/**\n     * @param databaseManager\n     * @return\n     */\n    private List<Server> getServers(DatabaseManager databaseManager) \n        throws SQLException {\n        // What was the last server id we indexed?\n        List<Server> retval = null;\n        Query<Long> query = databaseManager.getQuery(\"getLastServerId\");\n        Long sid = null;\n        try {\n            sid = query.load();\n        }\n        finally {\n            query.close();\n        }\n        if (sid == null) {\n            sid = new Long(0);\n        }\n        // When was the last time we ran the indexing of servers?\n        Query<Date> queryLast = databaseManager.getQuery(\"getLastServerIndexRun\");\n        Date indexServerLastRun = null;\n        try {\n            indexServerLastRun = queryLast.load();\n        }\n        finally {\n            queryLast.close();\n        }\n        if (indexServerLastRun == null) {\n            indexServerLastRun = new Date(0);\n        }\n        // Lookup what servers have not been indexed, or need to be reindexed.\n        Query<Server> srvrQuery = databaseManager.getQuery(\"getServersByModDateOrId\");\n        try {\n            Map params = new HashMap();\n            params.put(\"id\", sid);\n            params.put(\"last_modified\", indexServerLastRun);\n            retval = srvrQuery.loadList(params);\n        }\n        finally {\n            srvrQuery.close();\n        }\n        return retval;\n    }","commit_id":"82bbfc737faae561fc5ffcda8676521f85d9c512","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * @param indexManager\n     * @param current\n     */\n    private void indexServer(IndexManager indexManager, Server srvr)\n        throws IndexingException {\n\n        Map<String, String> attrs = new HashMap<String, String>();\n        /*\n         * activity:\n         * days since last check-in\n         * days since first registered\n         * details:\n         * name/description\n         * ID\n         * custom info\n         * snapshot tag\n         * packages:\n         * installed packages\n         * needed packages\n         * dmi info:\n         * system\n         * BIOS\n         * asset tag\n         * location:\n         * address\n         * building\n         * room\n         * rack\n         * hardware devices:\n         * description\n         * driver\n         * device id\n         * vendor id\n         * network info:\n         * hostname\n         * ip address\n         * hardware:\n         * cpu model\n         * cpu mhz less than\n         * cpu mhz greater than\n         * ram less than\n         * ram greater than\n         */\n        attrs.put(\"id\", new Long(srvr.getId()).toString());\n        attrs.put(\"name\", srvr.getName());\n        attrs.put(\"description\", srvr.getDescription());\n        attrs.put(\"info\", srvr.getInfo());\n        log.info(\"Indexing package: \" + srvr.getId() + \": \" + attrs.toString());\n        DocumentBuilder pdb = new ServerDocumentBuilder();\n        Document doc = pdb.buildDocument(new Long(srvr.getId()), attrs);\n        indexManager.addToIndex(\"server\", doc);\n    }","id":99450,"modified_method":"/**\n     * @param indexManager\n     * @param current\n     */\n    private void indexServer(IndexManager indexManager, Server srvr)\n        throws IndexingException {\n\n        Map<String, String> attrs = new HashMap<String, String>();\n        /*\n         * activity:\n         * days since last check-in\n         * days since first registered\n         * details:\n         * name/description\n         * ID\n         * custom info\n         * snapshot tag\n         * packages:\n         * installed packages\n         * needed packages\n         * dmi info:\n         * system\n         * BIOS\n         * asset tag\n\n         * hardware devices:\n         * description\n         * driver\n         * device id\n         * vendor id\n         * network info:\n         * hostname\n         * ip address\n         * hardware:\n         * cpu model\n         * cpu mhz less than\n         * cpu mhz greater than\n         * ram less than\n         * ram greater than\n         */\n        attrs.put(\"id\", new Long(srvr.getId()).toString());\n        attrs.put(\"name\", srvr.getName());\n        attrs.put(\"description\", srvr.getDescription());\n        attrs.put(\"info\", srvr.getInfo());\n        attrs.put(\"machine\", srvr.getMachine());\n        attrs.put(\"rack\", srvr.getRack());\n        attrs.put(\"room\", srvr.getRoom());\n        attrs.put(\"building\", srvr.getBuilding());\n        attrs.put(\"address1\", srvr.getAddress1());\n        attrs.put(\"address2\", srvr.getAddress2());\n        attrs.put(\"city\", srvr.getCity());\n        attrs.put(\"state\", srvr.getState());\n        attrs.put(\"country\", srvr.getCountry());\n        attrs.put(\"hostname\", srvr.getHostname());\n        attrs.put(\"ipaddr\", srvr.getIpaddr());\n\n\n        log.info(\"Indexing package: \" + srvr.getId() + \": \" + attrs.toString());\n        DocumentBuilder pdb = new ServerDocumentBuilder();\n        Document doc = pdb.buildDocument(new Long(srvr.getId()), attrs);\n        indexManager.addToIndex(\"server\", doc);\n    }","commit_id":"82bbfc737faae561fc5ffcda8676521f85d9c512","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public void execute(JobExecutionContext ctx)\n        throws JobExecutionException {\n        JobDataMap jobData = ctx.getJobDetail().getJobDataMap();\n        DatabaseManager databaseManager =\n            (DatabaseManager)jobData.get(\"databaseManager\");\n        IndexManager indexManager =\n            (IndexManager)jobData.get(\"indexManager\");\n\n        try {\n              \n            List<Server> servers = getServers(databaseManager);\n            int count = 0;\n            log.info(\"found [\" + servers.size() + \"] packages to index\");\n            for (Iterator<Server> iter = servers.iterator(); iter.hasNext();) {\n                Server current = iter.next();\n                indexServer(indexManager, current);\n                count++;\n                if (count == 10 || !iter.hasNext()) {\n                    if (System.getProperties().get(\"isTesting\") == null) {\n                        updateLastServerId(databaseManager, current.getId());\n                    }\n                    count = 0;\n                }\n            }\n        }\n        catch (SQLException e) {\n            throw new JobExecutionException(e);\n        }\n        catch (IndexingException e) {\n            throw new JobExecutionException(e);\n        }\n    }","id":99451,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public void execute(JobExecutionContext ctx)\n        throws JobExecutionException {\n        JobDataMap jobData = ctx.getJobDetail().getJobDataMap();\n        DatabaseManager databaseManager =\n            (DatabaseManager)jobData.get(\"databaseManager\");\n        IndexManager indexManager =\n            (IndexManager)jobData.get(\"indexManager\");\n\n        try {\n              \n            List<Server> servers = getServers(databaseManager);\n            int count = 0;\n            log.info(\"found [\" + servers.size() + \"] systems to index\");\n            for (Iterator<Server> iter = servers.iterator(); iter.hasNext();) {\n                Server current = iter.next();\n                indexServer(indexManager, current);\n                count++;\n                if (count == 10 || !iter.hasNext()) {\n                    if (System.getProperties().get(\"isTesting\") == null) {\n                        updateLastServerId(databaseManager, current.getId());\n                    }\n                    count = 0;\n                }\n            }\n        }\n        catch (SQLException e) {\n            throw new JobExecutionException(e);\n        }\n        catch (IndexingException e) {\n            throw new JobExecutionException(e);\n        }\n    }","commit_id":"82bbfc737faae561fc5ffcda8676521f85d9c512","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"public void testBuilderDocument() {\n        DocumentBuilder db = BuilderFactory.getBuilder(BuilderFactory.SERVER_TYPE);\n        assertTrue(db instanceof ServerDocumentBuilder);\n        Document doc = db.buildDocument(new Long(10), null);\n        assertNull(doc);\n    }","id":99452,"modified_method":"public void testBuilderDocument() {\n        Map<String, String> metadata = new HashMap<String, String>();\n        metadata.put(\"name\", \"Name\");\n        metadata.put(\"description\", \"Description\");\n        metadata.put(\"info\", \"Info\");\n\n        DocumentBuilder db = BuilderFactory.getBuilder(BuilderFactory.SERVER_TYPE);\n        assertTrue(db instanceof ServerDocumentBuilder);\n        Document doc = db.buildDocument(new Long(10), metadata);\n\n        assertNotNull(doc);\n        assertEquals(doc.getField(\"id\").stringValue(), new Long(10).toString());\n        assertEquals(doc.getField(\"name\").stringValue(), \"Name\");\n        assertEquals(doc.getField(\"description\").stringValue(), \"Description\");\n        assertEquals(doc.getField(\"info\").stringValue(), \"Info\");\n    }","commit_id":"82bbfc737faae561fc5ffcda8676521f85d9c512","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"public void init() throws Exception\n  {\n    LOG.info(\"init()\");\n    try {\n       loadInitialDefaultPermissionType();\n    }\n    catch (Exception e) {\n       LOG.warn(\"Error loading initial default permissions\", e);\n    }\n  }","id":99453,"modified_method":"public void init() throws Exception\n  {\n\t  LOG.info(\"init()\");           \n\t  try {\n\t  \t//  run ddl \n\t\t  if (autoDdl.booleanValue()){\n\t\t\t  try\n\t\t\t  {                        \n\t\t\t\t  sqlService.ddl(this.getClass().getClassLoader(), \"mfr\");\n\t\t\t  }       \n\t\t\t  catch (Throwable t)\n\t\t\t  {\n\t\t\t\t  LOG.warn(this + \".init(): \", t);\n\t\t\t  }\n\t\t  }\n\t\t  loadInitialDefaultPermissionType();\n\t  }\n\t  catch (Exception e) {\n\t\t  LOG.warn(\"Error loading initial default permissions\", e);\n\t  }\n  }","commit_id":"a52164bc060d8b85aeeb0734466e15dc023859b1","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public PermissionLevel getDefaultContributorPermissionLevel(){\n\n\t  if (LOG.isDebugEnabled()){\n\t\t  LOG.debug(\"getDefaultContributorPermissionLevel executing\");\n\t  }\n\n\t  String typeUuid = typeManager.getContributorLevelType();\n\n\t  if (typeUuid == null) {      \n\t\t  throw new IllegalStateException(\"type cannot be null\");\n\t  }\t\t\n\t  PermissionLevel level = getDefaultPermissionLevel(typeUuid);\n\n\t  if(level == null)\n\t  {\n\t\t  PermissionsMask mask = new PermissionsMask();                \n\t\t  mask.put(PermissionLevel.NEW_FORUM, new Boolean(false)); \n\t\t  mask.put(PermissionLevel.NEW_TOPIC, new Boolean(false));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE, new Boolean(true));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE_TO_RESPONSE, new Boolean(true));\n\t\t  mask.put(PermissionLevel.MOVE_POSTING, new Boolean(false));\n\t\t  mask.put(PermissionLevel.CHANGE_SETTINGS,new Boolean(false));\n\t\t  mask.put(PermissionLevel.POST_TO_GRADEBOOK, new Boolean(false));\n\t\t  mask.put(PermissionLevel.READ, new Boolean(true));\n\t\t  mask.put(PermissionLevel.MARK_AS_READ,new Boolean(true));\n\t\t  mask.put(PermissionLevel.MODERATE_POSTINGS, new Boolean(false));\n\t\t  mask.put(PermissionLevel.DELETE_OWN, new Boolean(false));\n\t\t  mask.put(PermissionLevel.DELETE_ANY, new Boolean(false));\n\t\t  mask.put(PermissionLevel.REVISE_OWN, new Boolean(false));\n\t\t  mask.put(PermissionLevel.REVISE_ANY, new Boolean(false));\n\t\t  \n\t\t  // we need to add the default permission level to MFR_PERMISSION_LEVEL_T for future use\n\t\t  PermissionLevel newLevel = createDefaultPermissionLevel(PermissionLevelManager.PERMISSION_LEVEL_NAME_CONTRIBUTOR, typeUuid, mask, \"00000000-0000-0000-0000-444444444444\");\n\t\t  savePermissionLevel(newLevel);\n\t\t  \n\t\t  return newLevel;\n\n\t  }\n\t  else\n\t\t  return level;\t\n  }","id":99454,"modified_method":"public PermissionLevel getDefaultContributorPermissionLevel(){\n\n\t  if (LOG.isDebugEnabled()){\n\t\t  LOG.debug(\"getDefaultContributorPermissionLevel executing\");\n\t  }\n\n\t  String typeUuid = typeManager.getContributorLevelType();\n\n\t  if (typeUuid == null) {      \n\t\t  throw new IllegalStateException(\"type cannot be null\");\n\t  }\t\t\n\t  PermissionLevel level = getDefaultPermissionLevel(typeUuid);\n\n\t  if(level == null)\n\t  {\n\t\t  PermissionsMask mask = new PermissionsMask();                \n\t\t  mask.put(PermissionLevel.NEW_FORUM, new Boolean(false)); \n\t\t  mask.put(PermissionLevel.NEW_TOPIC, new Boolean(false));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE, new Boolean(true));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE_TO_RESPONSE, new Boolean(true));\n\t\t  mask.put(PermissionLevel.MOVE_POSTING, new Boolean(false));\n\t\t  mask.put(PermissionLevel.CHANGE_SETTINGS,new Boolean(false));\n\t\t  mask.put(PermissionLevel.POST_TO_GRADEBOOK, new Boolean(false));\n\t\t  mask.put(PermissionLevel.READ, new Boolean(true));\n\t\t  mask.put(PermissionLevel.MARK_AS_READ,new Boolean(true));\n\t\t  mask.put(PermissionLevel.MODERATE_POSTINGS, new Boolean(false));\n\t\t  mask.put(PermissionLevel.DELETE_OWN, new Boolean(false));\n\t\t  mask.put(PermissionLevel.DELETE_ANY, new Boolean(false));\n\t\t  mask.put(PermissionLevel.REVISE_OWN, new Boolean(false));\n\t\t  mask.put(PermissionLevel.REVISE_ANY, new Boolean(false));\n\t\t  \n\t\t  return createPermissionLevel(PermissionLevelManager.PERMISSION_LEVEL_NAME_CONTRIBUTOR, typeUuid, mask);\n\t  }\n\t  else\n\t\t  return level;\t\n  }","commit_id":"a52164bc060d8b85aeeb0734466e15dc023859b1","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public PermissionLevel getDefaultOwnerPermissionLevel(){\n\n\t  if (LOG.isDebugEnabled()){\n\t\t  LOG.debug(\"getDefaultOwnerPermissionLevel executing\");\n\t  }\n\n\t  String typeUuid = typeManager.getOwnerLevelType();\n\n\t  if (typeUuid == null) {      \n\t\t  throw new IllegalStateException(\"type cannot be null\");\n\t  }\t\t\n\t  PermissionLevel level = getDefaultPermissionLevel(typeUuid);\n\n\t  if(level == null)\n\t  {    \n\t\t  PermissionsMask mask = new PermissionsMask();                \n\t\t  mask.put(PermissionLevel.NEW_FORUM, new Boolean(true)); \n\t\t  mask.put(PermissionLevel.NEW_TOPIC, new Boolean(true));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE, new Boolean(true));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE_TO_RESPONSE, new Boolean(true));\n\t\t  mask.put(PermissionLevel.MOVE_POSTING, new Boolean(true));\n\t\t  mask.put(PermissionLevel.CHANGE_SETTINGS,new Boolean(true));\n\t\t  mask.put(PermissionLevel.POST_TO_GRADEBOOK, new Boolean(true));\n\t\t  mask.put(PermissionLevel.READ, new Boolean(true));\n\t\t  mask.put(PermissionLevel.MARK_AS_READ,new Boolean(true));\n\t\t  mask.put(PermissionLevel.MODERATE_POSTINGS, new Boolean(true));\n\t\t  mask.put(PermissionLevel.DELETE_OWN, new Boolean(false));\n\t\t  mask.put(PermissionLevel.DELETE_ANY, new Boolean(true));\n\t\t  mask.put(PermissionLevel.REVISE_OWN, new Boolean(false));\n\t\t  mask.put(PermissionLevel.REVISE_ANY, new Boolean(true));\n\n\t\t  // we need to add the default permission level to MFR_PERMISSION_LEVEL_T for future use\n\t\t  PermissionLevel newLevel = createDefaultPermissionLevel(PermissionLevelManager.PERMISSION_LEVEL_NAME_OWNER, typeUuid, mask, \"00000000-0000-0000-0000-111111111111\");\n\t\t  savePermissionLevel(newLevel);\n\n\t\t  return newLevel;\n\t  }\n\t  else\n\t\t  return level;\n  }","id":99455,"modified_method":"public PermissionLevel getDefaultOwnerPermissionLevel(){\n\n\t  if (LOG.isDebugEnabled()){\n\t\t  LOG.debug(\"getDefaultOwnerPermissionLevel executing\");\n\t  }\n\n\t  String typeUuid = typeManager.getOwnerLevelType();\n\n\t  if (typeUuid == null) {      \n\t\t  throw new IllegalStateException(\"type cannot be null\");\n\t  }\t\t\n\t  PermissionLevel level = getDefaultPermissionLevel(typeUuid);\n\n\t  if(level == null)\n\t  {    \n\t\t  PermissionsMask mask = new PermissionsMask();                \n\t\t  mask.put(PermissionLevel.NEW_FORUM, new Boolean(true)); \n\t\t  mask.put(PermissionLevel.NEW_TOPIC, new Boolean(true));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE, new Boolean(true));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE_TO_RESPONSE, new Boolean(true));\n\t\t  mask.put(PermissionLevel.MOVE_POSTING, new Boolean(true));\n\t\t  mask.put(PermissionLevel.CHANGE_SETTINGS,new Boolean(true));\n\t\t  mask.put(PermissionLevel.POST_TO_GRADEBOOK, new Boolean(true));\n\t\t  mask.put(PermissionLevel.READ, new Boolean(true));\n\t\t  mask.put(PermissionLevel.MARK_AS_READ,new Boolean(true));\n\t\t  mask.put(PermissionLevel.MODERATE_POSTINGS, new Boolean(true));\n\t\t  mask.put(PermissionLevel.DELETE_OWN, new Boolean(false));\n\t\t  mask.put(PermissionLevel.DELETE_ANY, new Boolean(true));\n\t\t  mask.put(PermissionLevel.REVISE_OWN, new Boolean(false));\n\t\t  mask.put(PermissionLevel.REVISE_ANY, new Boolean(true));\n\n\t\t  return createPermissionLevel(PermissionLevelManager.PERMISSION_LEVEL_NAME_OWNER, typeUuid, mask);\n\t  }\n\t  else\n\t\t  return level;\n  }","commit_id":"a52164bc060d8b85aeeb0734466e15dc023859b1","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Populates the permission level data for the case when the default permission levels\n\t * are being created, not the custom levels\n\t * @param name\n\t * @param typeUuid\n\t * @param mask\n\t * @param uuid\n\t * @return\n\t */\n\tprivate PermissionLevel createDefaultPermissionLevel(String name, String typeUuid, PermissionsMask mask, String uuid)\n\t{\n\t\tif (LOG.isDebugEnabled()){\n\t\t\tLOG.debug(\"createPermissionLevel executing(\" + name + \",\" + typeUuid + \",\" + mask + \")\");\n\t\t}\n\t\t\n\t\tif (name == null || typeUuid == null || mask == null || uuid == null) {      \n\t\t\tthrow new IllegalArgumentException(\"Null Argument\");\n\t\t}\n\t\t\t\t\t\t\t\t\n\t\tPermissionLevel newPermissionLevel = new PermissionLevelImpl();\n\t\tDate now = new Date();\n\t\tnewPermissionLevel.setName(name);\n\t\tnewPermissionLevel.setUuid(uuid);\n\t\tnewPermissionLevel.setCreated(now);\n\t\tnewPermissionLevel.setCreatedBy(\"admin\");\n\t\tnewPermissionLevel.setModified(now);\n\t\tnewPermissionLevel.setModifiedBy(\"admin\");\n\t\tnewPermissionLevel.setTypeUuid(typeUuid);\n\t\t\t\n\t\t// set permission properties using reflection\n\t\tfor (Iterator i = mask.keySet().iterator(); i.hasNext();){\n\t\t\tString key = (String) i.next();\n\t\t\tBoolean value = (Boolean) mask.get(key);\n\t\t\ttry{\n\t\t\t  PropertyUtils.setSimpleProperty(newPermissionLevel, key, value);\n\t\t\t}\n\t\t\tcatch (Exception e){\n\t\t\t\tthrow new Error(e);\n\t\t\t}\n\t\t}\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\n\t\treturn newPermissionLevel;\t\t\n\t}","id":99456,"modified_method":"/**\n\t * Populates the permission level data for the case when the default permission levels\n\t * are being created, not the custom levels\n\t * @param name\n\t * @param typeUuid\n\t * @param mask\n\t * @param uuid\n\t * @return\n\t */\n\tprivate PermissionLevel createDefaultPermissionLevel(String name, String typeUuid, PermissionsMask mask)\n\t{\n\t\tif (LOG.isDebugEnabled()){\n\t\t\tLOG.debug(\"createDefaultPermissionLevel executing(\" + name + \",\" + typeUuid + \",\" + mask + \")\");\n\t\t}\n\t\t\n\t\tif (name == null || typeUuid == null || mask == null) {      \n\t\t\tthrow new IllegalArgumentException(\"Null Argument\");\n\t\t}\n\t\t\t\t\t\t\t\t\n\t\tPermissionLevel newPermissionLevel = new PermissionLevelImpl();\n\t\tDate now = new Date();\n\t\tnewPermissionLevel.setName(name);\n\t\tnewPermissionLevel.setUuid(idManager.createUuid());\n\t\tnewPermissionLevel.setCreated(now);\n\t\tnewPermissionLevel.setCreatedBy(\"admin\");\n\t\tnewPermissionLevel.setModified(now);\n\t\tnewPermissionLevel.setModifiedBy(\"admin\");\n\t\tnewPermissionLevel.setTypeUuid(typeUuid);\n\t\t\t\n\t\t// set permission properties using reflection\n\t\tfor (Iterator i = mask.keySet().iterator(); i.hasNext();){\n\t\t\tString key = (String) i.next();\n\t\t\tBoolean value = (Boolean) mask.get(key);\n\t\t\ttry{\n\t\t\t  PropertyUtils.setSimpleProperty(newPermissionLevel, key, value);\n\t\t\t}\n\t\t\tcatch (Exception e){\n\t\t\t\tthrow new Error(e);\n\t\t\t}\n\t\t}\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\n\t\treturn newPermissionLevel;\t\t\n\t}","commit_id":"a52164bc060d8b85aeeb0734466e15dc023859b1","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public PermissionLevel getDefaultNoneditingAuthorPermissionLevel(){\n\n\t  if (LOG.isDebugEnabled()){\n\t\t  LOG.debug(\"getDefaultNoneditingAuthorPermissionLevel executing\");\n\t  }\n\n\t  String typeUuid = typeManager.getNoneditingAuthorLevelType();\n\n\t  if (typeUuid == null) {      \n\t\t  throw new IllegalStateException(\"type cannot be null\");\n\t  }\t\t\n\t  PermissionLevel level = getDefaultPermissionLevel(typeUuid);\n\n\t  if(level == null)\n\t  {\n\t\t  PermissionsMask mask = new PermissionsMask();                \n\t\t  mask.put(PermissionLevel.NEW_FORUM, new Boolean(true)); \n\t\t  mask.put(PermissionLevel.NEW_TOPIC, new Boolean(true));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE, new Boolean(true));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE_TO_RESPONSE, new Boolean(true));\n\t\t  mask.put(PermissionLevel.MOVE_POSTING, new Boolean(false));\n\t\t  mask.put(PermissionLevel.CHANGE_SETTINGS,new Boolean(true));\n\t\t  mask.put(PermissionLevel.POST_TO_GRADEBOOK, new Boolean(true));\n\t\t  mask.put(PermissionLevel.READ, new Boolean(true));\n\t\t  mask.put(PermissionLevel.MARK_AS_READ,new Boolean(true));\n\t\t  mask.put(PermissionLevel.MODERATE_POSTINGS, new Boolean(false));\n\t\t  mask.put(PermissionLevel.DELETE_OWN, new Boolean(false));\n\t\t  mask.put(PermissionLevel.DELETE_ANY, new Boolean(false));\n\t\t  mask.put(PermissionLevel.REVISE_OWN, new Boolean(true));\n\t\t  mask.put(PermissionLevel.REVISE_ANY, new Boolean(false));\n\n\t\t  // we need to add the default permission level to MFR_PERMISSION_LEVEL_T for future use\n\t\t  PermissionLevel newLevel = createDefaultPermissionLevel(PermissionLevelManager.PERMISSION_LEVEL_NAME_NONEDITING_AUTHOR, typeUuid, mask, \"00000000-0000-0000-0000-333333333333\");\n\t\t  savePermissionLevel(newLevel);\n\n\t\t  return newLevel;\n\t  }\n\t  else\n\t\t  return level;\n  }","id":99457,"modified_method":"public PermissionLevel getDefaultNoneditingAuthorPermissionLevel(){\n\n\t  if (LOG.isDebugEnabled()){\n\t\t  LOG.debug(\"getDefaultNoneditingAuthorPermissionLevel executing\");\n\t  }\n\n\t  String typeUuid = typeManager.getNoneditingAuthorLevelType();\n\n\t  if (typeUuid == null) {      \n\t\t  throw new IllegalStateException(\"type cannot be null\");\n\t  }\t\t\n\t  PermissionLevel level = getDefaultPermissionLevel(typeUuid);\n\n\t  if(level == null)\n\t  {\n\t\t  PermissionsMask mask = new PermissionsMask();                \n\t\t  mask.put(PermissionLevel.NEW_FORUM, new Boolean(true)); \n\t\t  mask.put(PermissionLevel.NEW_TOPIC, new Boolean(true));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE, new Boolean(true));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE_TO_RESPONSE, new Boolean(true));\n\t\t  mask.put(PermissionLevel.MOVE_POSTING, new Boolean(false));\n\t\t  mask.put(PermissionLevel.CHANGE_SETTINGS,new Boolean(true));\n\t\t  mask.put(PermissionLevel.POST_TO_GRADEBOOK, new Boolean(true));\n\t\t  mask.put(PermissionLevel.READ, new Boolean(true));\n\t\t  mask.put(PermissionLevel.MARK_AS_READ,new Boolean(true));\n\t\t  mask.put(PermissionLevel.MODERATE_POSTINGS, new Boolean(false));\n\t\t  mask.put(PermissionLevel.DELETE_OWN, new Boolean(false));\n\t\t  mask.put(PermissionLevel.DELETE_ANY, new Boolean(false));\n\t\t  mask.put(PermissionLevel.REVISE_OWN, new Boolean(true));\n\t\t  mask.put(PermissionLevel.REVISE_ANY, new Boolean(false));\n\n\t\t  return createPermissionLevel(PermissionLevelManager.PERMISSION_LEVEL_NAME_NONEDITING_AUTHOR, typeUuid, mask);\n\t  }\n\t  else\n\t\t  return level;\n  }","commit_id":"a52164bc060d8b85aeeb0734466e15dc023859b1","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public PermissionLevel getDefaultAuthorPermissionLevel(){\n\n\t  if (LOG.isDebugEnabled()){\n\t\t  LOG.debug(\"getDefaultAuthorPermissionLevel executing\");\n\t  }\n\n\t  String typeUuid = typeManager.getAuthorLevelType();\n\n\t  if (typeUuid == null) {      \n\t\t  throw new IllegalStateException(\"type cannot be null\");\n\t  }\t\t\n\t  PermissionLevel level = getDefaultPermissionLevel(typeUuid);\n\n\t  if(level == null)\n\t  {\n\n\t\t  PermissionsMask mask = new PermissionsMask();                \n\t\t  mask.put(PermissionLevel.NEW_FORUM, new Boolean(true)); \n\t\t  mask.put(PermissionLevel.NEW_TOPIC, new Boolean(true));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE, new Boolean(true));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE_TO_RESPONSE, new Boolean(true));\n\t\t  mask.put(PermissionLevel.MOVE_POSTING, new Boolean(true));\n\t\t  mask.put(PermissionLevel.CHANGE_SETTINGS,new Boolean(true));\n\t\t  mask.put(PermissionLevel.POST_TO_GRADEBOOK, new Boolean(true));\n\t\t  mask.put(PermissionLevel.READ, new Boolean(true));\n\t\t  mask.put(PermissionLevel.MARK_AS_READ,new Boolean(true));\n\t\t  mask.put(PermissionLevel.MODERATE_POSTINGS, new Boolean(false));\n\t\t  mask.put(PermissionLevel.DELETE_OWN, new Boolean(true));\n\t\t  mask.put(PermissionLevel.DELETE_ANY, new Boolean(false));\n\t\t  mask.put(PermissionLevel.REVISE_OWN, new Boolean(true));\n\t\t  mask.put(PermissionLevel.REVISE_ANY, new Boolean(false));\n\n\t\t  // we need to add the default permission level to MFR_PERMISSION_LEVEL_T for future use\n\t\t  PermissionLevel newLevel = createDefaultPermissionLevel(PermissionLevelManager.PERMISSION_LEVEL_NAME_AUTHOR, typeUuid, mask, \"00000000-0000-0000-0000-222222222222\");\n\t\t  savePermissionLevel(newLevel);\n\n\t\t  return newLevel;\n\t  }\n\t  else\n\t\t  return level;\n  }","id":99458,"modified_method":"public PermissionLevel getDefaultAuthorPermissionLevel(){\n\n\t  if (LOG.isDebugEnabled()){\n\t\t  LOG.debug(\"getDefaultAuthorPermissionLevel executing\");\n\t  }\n\n\t  String typeUuid = typeManager.getAuthorLevelType();\n\n\t  if (typeUuid == null) {      \n\t\t  throw new IllegalStateException(\"type cannot be null\");\n\t  }\t\t\n\t  PermissionLevel level = getDefaultPermissionLevel(typeUuid);\n\n\t  if(level == null)\n\t  {\n\n\t\t  PermissionsMask mask = new PermissionsMask();                \n\t\t  mask.put(PermissionLevel.NEW_FORUM, new Boolean(true)); \n\t\t  mask.put(PermissionLevel.NEW_TOPIC, new Boolean(true));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE, new Boolean(true));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE_TO_RESPONSE, new Boolean(true));\n\t\t  mask.put(PermissionLevel.MOVE_POSTING, new Boolean(true));\n\t\t  mask.put(PermissionLevel.CHANGE_SETTINGS,new Boolean(true));\n\t\t  mask.put(PermissionLevel.POST_TO_GRADEBOOK, new Boolean(true));\n\t\t  mask.put(PermissionLevel.READ, new Boolean(true));\n\t\t  mask.put(PermissionLevel.MARK_AS_READ,new Boolean(true));\n\t\t  mask.put(PermissionLevel.MODERATE_POSTINGS, new Boolean(false));\n\t\t  mask.put(PermissionLevel.DELETE_OWN, new Boolean(true));\n\t\t  mask.put(PermissionLevel.DELETE_ANY, new Boolean(false));\n\t\t  mask.put(PermissionLevel.REVISE_OWN, new Boolean(true));\n\t\t  mask.put(PermissionLevel.REVISE_ANY, new Boolean(false));\n\n\t\t  return createPermissionLevel(PermissionLevelManager.PERMISSION_LEVEL_NAME_AUTHOR, typeUuid, mask);\n\t  }\n\t  else\n\t\t  return level;\n  }","commit_id":"a52164bc060d8b85aeeb0734466e15dc023859b1","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public PermissionLevel getDefaultNonePermissionLevel(){\n\n\t  if (LOG.isDebugEnabled()){\n\t\t  LOG.debug(\"getDefaultNonePermissionLevel executing\");\n\t  }\n\n\t  String typeUuid = typeManager.getNoneLevelType();\n\n\t  if (typeUuid == null) {      \n\t\t  throw new IllegalStateException(\"type cannot be null\");\n\t  }\t\t\n\t  PermissionLevel level = getDefaultPermissionLevel(typeUuid);\n\n\t  if(level == null)\n\t  {    \n\t\t  PermissionsMask mask = new PermissionsMask();                \n\t\t  mask.put(PermissionLevel.NEW_FORUM, new Boolean(false)); \n\t\t  mask.put(PermissionLevel.NEW_TOPIC, new Boolean(false));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE, new Boolean(false));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE_TO_RESPONSE, new Boolean(false));\n\t\t  mask.put(PermissionLevel.MOVE_POSTING, new Boolean(false));\n\t\t  mask.put(PermissionLevel.CHANGE_SETTINGS,new Boolean(false));\n\t\t  mask.put(PermissionLevel.POST_TO_GRADEBOOK, new Boolean(false));\n\t\t  mask.put(PermissionLevel.READ, new Boolean(false));\n\t\t  mask.put(PermissionLevel.MARK_AS_READ,new Boolean(false));\n\t\t  mask.put(PermissionLevel.MODERATE_POSTINGS, new Boolean(false));\n\t\t  mask.put(PermissionLevel.DELETE_OWN, new Boolean(false));\n\t\t  mask.put(PermissionLevel.DELETE_ANY, new Boolean(false));\n\t\t  mask.put(PermissionLevel.REVISE_OWN, new Boolean(false));\n\t\t  mask.put(PermissionLevel.REVISE_ANY, new Boolean(false));\n\n\t\t  // we need to add the default permission level to MFR_PERMISSION_LEVEL_T for future use\n\t\t  PermissionLevel newLevel = createDefaultPermissionLevel(PermissionLevelManager.PERMISSION_LEVEL_NAME_NONE, typeUuid, mask, \"00000000-0000-0000-0000-666666666666\");\n\t\t  savePermissionLevel(newLevel);\n\t\t  \n\t\t  return newLevel;\n\t  }\n\t  else\n\t\t  return level;\n  }","id":99459,"modified_method":"public PermissionLevel getDefaultNonePermissionLevel(){\n\n\t  if (LOG.isDebugEnabled()){\n\t\t  LOG.debug(\"getDefaultNonePermissionLevel executing\");\n\t  }\n\n\t  String typeUuid = typeManager.getNoneLevelType();\n\n\t  if (typeUuid == null) {      \n\t\t  throw new IllegalStateException(\"type cannot be null\");\n\t  }\t\t\n\t  PermissionLevel level = getDefaultPermissionLevel(typeUuid);\n\n\t  if(level == null)\n\t  {    \n\t\t  PermissionsMask mask = new PermissionsMask();                \n\t\t  mask.put(PermissionLevel.NEW_FORUM, new Boolean(false)); \n\t\t  mask.put(PermissionLevel.NEW_TOPIC, new Boolean(false));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE, new Boolean(false));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE_TO_RESPONSE, new Boolean(false));\n\t\t  mask.put(PermissionLevel.MOVE_POSTING, new Boolean(false));\n\t\t  mask.put(PermissionLevel.CHANGE_SETTINGS,new Boolean(false));\n\t\t  mask.put(PermissionLevel.POST_TO_GRADEBOOK, new Boolean(false));\n\t\t  mask.put(PermissionLevel.READ, new Boolean(false));\n\t\t  mask.put(PermissionLevel.MARK_AS_READ,new Boolean(false));\n\t\t  mask.put(PermissionLevel.MODERATE_POSTINGS, new Boolean(false));\n\t\t  mask.put(PermissionLevel.DELETE_OWN, new Boolean(false));\n\t\t  mask.put(PermissionLevel.DELETE_ANY, new Boolean(false));\n\t\t  mask.put(PermissionLevel.REVISE_OWN, new Boolean(false));\n\t\t  mask.put(PermissionLevel.REVISE_ANY, new Boolean(false));\n\n\t\t  return createPermissionLevel(PermissionLevelManager.PERMISSION_LEVEL_NAME_NONE, typeUuid, mask);\n\t  }\n\t  else\n\t\t  return level;\n  }","commit_id":"a52164bc060d8b85aeeb0734466e15dc023859b1","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public PermissionLevel getDefaultReviewerPermissionLevel(){\n\n\t  if (LOG.isDebugEnabled()){\n\t\t  LOG.debug(\"getDefaultReviewerPermissionLevel executing\");\n\t  }\n\n\t  String typeUuid = typeManager.getReviewerLevelType();\n\n\t  if (typeUuid == null) {      \n\t\t  throw new IllegalStateException(\"type cannot be null\");\n\t  }\t\t\n\t  PermissionLevel level = getDefaultPermissionLevel(typeUuid);\n\n\t  if(level == null)\n\t  {\n\t\t  PermissionsMask mask = new PermissionsMask();                \n\t\t  mask.put(PermissionLevel.NEW_FORUM, new Boolean(false)); \n\t\t  mask.put(PermissionLevel.NEW_TOPIC, new Boolean(false));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE, new Boolean(false));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE_TO_RESPONSE, new Boolean(false));\n\t\t  mask.put(PermissionLevel.MOVE_POSTING, new Boolean(false));\n\t\t  mask.put(PermissionLevel.CHANGE_SETTINGS,new Boolean(false));\n\t\t  mask.put(PermissionLevel.POST_TO_GRADEBOOK, new Boolean(false));\n\t\t  mask.put(PermissionLevel.READ, new Boolean(true));\n\t\t  mask.put(PermissionLevel.MARK_AS_READ,new Boolean(true));\n\t\t  mask.put(PermissionLevel.MODERATE_POSTINGS, new Boolean(false));\n\t\t  mask.put(PermissionLevel.DELETE_OWN, new Boolean(false));\n\t\t  mask.put(PermissionLevel.DELETE_ANY, new Boolean(false));\n\t\t  mask.put(PermissionLevel.REVISE_OWN, new Boolean(false));\n\t\t  mask.put(PermissionLevel.REVISE_ANY, new Boolean(false));\n\n\t\t  // we need to add the default permission level to MFR_PERMISSION_LEVEL_T for future use\n\t\t  PermissionLevel newLevel = createDefaultPermissionLevel(PermissionLevelManager.PERMISSION_LEVEL_NAME_REVIEWER, typeUuid, mask, \"00000000-0000-0000-0000-555555555555\");\n\t\t  savePermissionLevel(newLevel);\n\t\t  \n\t\t  return newLevel;\n\t  }\n\t  else\n\t\t  return level;\n\n  }","id":99460,"modified_method":"public PermissionLevel getDefaultReviewerPermissionLevel(){\n\n\t  if (LOG.isDebugEnabled()){\n\t\t  LOG.debug(\"getDefaultReviewerPermissionLevel executing\");\n\t  }\n\n\t  String typeUuid = typeManager.getReviewerLevelType();\n\n\t  if (typeUuid == null) {      \n\t\t  throw new IllegalStateException(\"type cannot be null\");\n\t  }\t\t\n\t  PermissionLevel level = getDefaultPermissionLevel(typeUuid);\n\n\t  if(level == null)\n\t  {\n\t\t  PermissionsMask mask = new PermissionsMask();                \n\t\t  mask.put(PermissionLevel.NEW_FORUM, new Boolean(false)); \n\t\t  mask.put(PermissionLevel.NEW_TOPIC, new Boolean(false));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE, new Boolean(false));\n\t\t  mask.put(PermissionLevel.NEW_RESPONSE_TO_RESPONSE, new Boolean(false));\n\t\t  mask.put(PermissionLevel.MOVE_POSTING, new Boolean(false));\n\t\t  mask.put(PermissionLevel.CHANGE_SETTINGS,new Boolean(false));\n\t\t  mask.put(PermissionLevel.POST_TO_GRADEBOOK, new Boolean(false));\n\t\t  mask.put(PermissionLevel.READ, new Boolean(true));\n\t\t  mask.put(PermissionLevel.MARK_AS_READ,new Boolean(true));\n\t\t  mask.put(PermissionLevel.MODERATE_POSTINGS, new Boolean(false));\n\t\t  mask.put(PermissionLevel.DELETE_OWN, new Boolean(false));\n\t\t  mask.put(PermissionLevel.DELETE_ANY, new Boolean(false));\n\t\t  mask.put(PermissionLevel.REVISE_OWN, new Boolean(false));\n\t\t  mask.put(PermissionLevel.REVISE_ANY, new Boolean(false));\n\n\t\t  return createPermissionLevel(PermissionLevelManager.PERMISSION_LEVEL_NAME_REVIEWER, typeUuid, mask);\n\t  }\n\t  else\n\t\t  return level;\n\n  }","commit_id":"a52164bc060d8b85aeeb0734466e15dc023859b1","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testPutRemoveConsistencyMultithreaded() throws Exception {\n        final int range = 10000;\n\n        final int iterCnt = iterationCount();\n\n        final AtomicInteger iters = new AtomicInteger();\n\n        multithreadedAsync(new Callable<Object>() {\n            @Override public Object call() throws Exception {\n                Random rnd = new Random();\n\n                while (true) {\n                    int i = iters.getAndIncrement();\n\n                    if (i >= iterCnt)\n                        break;\n\n                    int g = rnd.nextInt(gridCount());\n\n                    Ignite ignite = grid(g);\n\n                    IgniteCache<Object, Object> cache = ignite.cache(null);\n\n                    int k = rnd.nextInt(range);\n\n                    boolean rmv = rnd.nextBoolean();\n\n                    if (!rmv)\n                        cache.put(k, Thread.currentThread().getId());\n                    else\n                        cache.remove(k);\n\n                    if (i > 0 && i % 5000 == 0)\n                        info(\"Completed: \" + i);\n                }\n\n                return null;\n            }\n        }, THREAD_CNT).get();\n\n        int present = 0;\n        int absent = 0;\n\n        Affinity<Integer> aff = ignite(0).affinity(null);\n\n        boolean invalidVal = false;\n\n        for (int i = 0; i < range; i++) {\n            Long firstVal = null;\n\n            for (int g = 0; g < gridCount(); g++) {\n                Ignite ignite = grid(g);\n\n                Long val = (Long)ignite.cache(null).localPeek(i, CachePeekMode.ONHEAP);\n\n                if (firstVal == null && val != null)\n                    firstVal = val;\n\n                if (val != null) {\n                    if (!firstVal.equals(val)) {\n                        invalidVal = true;\n\n                        boolean primary = aff.isPrimary(ignite.cluster().localNode(), i);\n                        boolean backup = aff.isBackup(ignite.cluster().localNode(), i);\n\n                        log.error(\"Invalid value detected [val=\" + val +\n                            \", firstVal=\" + firstVal +\n                            \", node=\" + g +\n                            \", primary=\" + primary +\n                            \", backup=\" + backup + ']');\n                    }\n                }\n            }\n\n            if (firstVal == null)\n                absent++;\n            else\n                present++;\n        }\n\n        assertFalse(\"Inconsistent value found.\", invalidVal);\n\n        info(\"Finished check [present=\" + present + \", absent=\" + absent + ']');\n\n        info(\"Checking keySet consistency\");\n\n        for (int g = 0; g < gridCount(); g++)\n            checkKeySet(grid(g));\n    }","id":99461,"modified_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testPutRemoveConsistencyMultithreaded() throws Exception {\n        final int range = 10000;\n\n        final int iterCnt = iterationCount();\n\n        final AtomicInteger iters = new AtomicInteger();\n\n        multithreadedAsync(new Callable<Object>() {\n            @Override public Object call() throws Exception {\n                Random rnd = new Random();\n\n                while (true) {\n                    int i = iters.getAndIncrement();\n\n                    if (i >= iterCnt)\n                        break;\n\n                    int g = rnd.nextInt(gridCount());\n\n                    Ignite ignite = grid(g);\n\n                    IgniteCache<Object, Object> cache = ignite.cache(null);\n\n                    int k = rnd.nextInt(range);\n\n                    boolean rmv = rnd.nextBoolean();\n\n                    if (!rmv)\n                        cache.put(k, Thread.currentThread().getId());\n                    else\n                        cache.remove(k);\n\n                    if (i > 0 && i % 5000 == 0)\n                        info(\"Completed: \" + i);\n                }\n\n                return null;\n            }\n        }, THREAD_CNT).get();\n\n        int present = 0;\n        int absent = 0;\n\n        Affinity<Integer> aff = ignite(0).affinity(null);\n\n        boolean invalidVal = false;\n\n        for (int i = 0; i < range; i++) {\n            Long firstVal = null;\n\n            for (int g = 0; g < gridCount(); g++) {\n                Ignite ignite = grid(g);\n\n                Long val = (Long)ignite.cache(null).localPeek(i, CachePeekMode.ONHEAP);\n\n                if (firstVal == null && val != null)\n                    firstVal = val;\n\n                if (val != null) {\n                    if (!firstVal.equals(val)) {\n                        invalidVal = true;\n\n                        boolean primary = aff.isPrimary(ignite.cluster().localNode(), i);\n                        boolean backup = aff.isBackup(ignite.cluster().localNode(), i);\n\n                        log.error(\"Invalid value detected [key=\" + i +\n                            \", val=\" + val +\n                            \", firstVal=\" + firstVal +\n                            \", node=\" + g +\n                            \", primary=\" + primary +\n                            \", backup=\" + backup + ']');\n                    }\n                }\n            }\n\n            if (firstVal == null)\n                absent++;\n            else\n                present++;\n        }\n\n        assertFalse(\"Inconsistent value found.\", invalidVal);\n\n        info(\"Finished check [present=\" + present + \", absent=\" + absent + ']');\n\n        info(\"Checking keySet consistency\");\n\n        for (int g = 0; g < gridCount(); g++)\n            checkKeySet(grid(g));\n    }","commit_id":"f860b80adf61574d789fe045cfa69325f2e26be4","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override protected IgniteConfiguration getConfiguration(String gridName) throws Exception {\n        IgniteConfiguration cfg = super.getConfiguration(gridName);\n\n        if (cache && !client) {\n            CacheConfiguration ccfg = new CacheConfiguration();\n\n            ccfg.setCacheMode(CacheMode.PARTITIONED);\n            ccfg.setBackups(1);\n            ccfg.setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL);\n\n            ccfg.setNearConfiguration(null);\n\n            if (aff == 0)\n                ccfg.setAffinity(new RendezvousAffinityFunction(false, PARTS));\n            else\n                ccfg.setAffinity(new FairAffinityFunction(PARTS));\n\n            cfg.setCacheConfiguration(ccfg);\n        }\n\n        return cfg;\n    }","id":99462,"modified_method":"/** {@inheritDoc} */\n    @Override protected IgniteConfiguration getConfiguration(String gridName) throws Exception {\n        IgniteConfiguration cfg = super.getConfiguration(gridName);\n\n        ((TcpDiscoverySpi)cfg.getDiscoverySpi()).setIpFinder(ipFinder);\n\n        if (cache) {\n            CacheConfiguration ccfg = new CacheConfiguration();\n\n            ccfg.setCacheMode(CacheMode.PARTITIONED);\n            ccfg.setBackups(1);\n            ccfg.setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL);\n\n            ccfg.setNearConfiguration(null);\n\n            if (aff == 0)\n                ccfg.setAffinity(new RendezvousAffinityFunction(false, PARTS));\n            else\n                ccfg.setAffinity(new FairAffinityFunction(PARTS));\n\n            cfg.setCacheConfiguration(ccfg);\n        }\n        else\n            cfg.setClientMode(true);\n\n        return cfg;\n    }","commit_id":"f860b80adf61574d789fe045cfa69325f2e26be4","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @throws Exception If failed.\n     */\n    private void checkAffinity() throws Exception {\n        Affinity<Object> aff = ((IgniteKernal)grid(0)).getCache(null).affinity();\n\n        for (Ignite grid : Ignition.allGrids()) {\n            try {\n                if (grid.cluster().localNode().id().equals(grid(0).localNode().id()))\n                    continue;\n\n                Affinity<Object> checkAff = ((IgniteKernal)grid).getCache(null).affinity();\n\n                for (int p = 0; p < PARTS; p++)\n                    assertEquals(aff.mapPartitionToPrimaryAndBackups(p), checkAff.mapPartitionToPrimaryAndBackups(p));\n            }\n            catch (IllegalArgumentException ignored) {\n                // Skip the node without cache.\n            }\n        }\n    }","id":99463,"modified_method":"/**\n     * @param topVer Topology version.\n     * @throws Exception If failed.\n     */\n    private void checkAffinity(long topVer) throws Exception {\n        awaitTopology(topVer);\n\n        Affinity<Object> aff = ((IgniteKernal)grid(0)).getCache(null).affinity();\n\n        for (Ignite grid : Ignition.allGrids()) {\n            try {\n                if (grid.cluster().localNode().id().equals(grid(0).localNode().id()))\n                    continue;\n\n                Affinity<Object> checkAff = ((IgniteKernal)grid).getCache(null).affinity();\n\n                for (int p = 0; p < PARTS; p++)\n                    assertEquals(aff.mapPartitionToPrimaryAndBackups(p), checkAff.mapPartitionToPrimaryAndBackups(p));\n            }\n            catch (IllegalArgumentException ignored) {\n                // Skip the node without cache.\n            }\n        }\n    }","commit_id":"f860b80adf61574d789fe045cfa69325f2e26be4","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @throws Exception If failed.\n     */\n    private void checkAffinityFunction() throws Exception {\n        cache = true;\n\n        startGrids(3);\n\n        try {\n            checkAffinity();\n\n            client = true;\n\n            startGrid(3);\n\n            checkAffinity();\n\n            startGrid(4);\n\n            checkAffinity();\n\n            cache = false;\n\n            startGrid(5);\n\n            checkAffinity();\n\n            stopGrid(5);\n\n            checkAffinity();\n\n            stopGrid(4);\n\n            checkAffinity();\n\n            stopGrid(3);\n\n            checkAffinity();\n        }\n        finally {\n            stopAllGrids();\n        }\n    }","id":99464,"modified_method":"/**\n     * @throws Exception If failed.\n     */\n    private void checkAffinityFunction() throws Exception {\n        cache = true;\n\n        startGrids(3);\n\n        long topVer = 3;\n\n        try {\n            checkAffinity(topVer++);\n\n            cache = false;\n\n            final Ignite ignite3 = startGrid(3);\n\n            GridTestUtils.assertThrows(log, new Callable<Object>() {\n                @Override public Object call() throws Exception {\n                    ((IgniteKernal)ignite3).getCache(null);\n\n                    return null;\n                }\n            }, IllegalArgumentException.class, null);\n\n            assertNotNull(ignite3.cache(null)); // Start client cache.\n\n            ((IgniteKernal)ignite3).getCache(null);\n\n            checkAffinity(topVer++);\n\n            final Ignite ignite4 = startGrid(4);\n\n            GridTestUtils.assertThrows(log, new Callable<Object>() {\n                @Override public Object call() throws Exception {\n                    ((IgniteKernal)ignite4).getCache(null);\n\n                    return null;\n                }\n            }, IllegalArgumentException.class, null);\n\n            assertNotNull(ignite4.cache(null)); // Start client cache.\n\n            ((IgniteKernal)ignite4).getCache(null);\n\n            checkAffinity(topVer++);\n\n            final Ignite ignite5 = startGrid(5); // Node without cache.\n\n            GridTestUtils.assertThrows(log, new Callable<Object>() {\n                @Override public Object call() throws Exception {\n                    ((IgniteKernal)ignite5).getCache(null);\n\n                    return null;\n                }\n            }, IllegalArgumentException.class, null);\n\n            checkAffinity(topVer++);\n\n            stopGrid(5);\n\n            checkAffinity(topVer++);\n\n            stopGrid(4);\n\n            checkAffinity(topVer++);\n\n            stopGrid(3);\n\n            checkAffinity(topVer);\n        }\n        finally {\n            stopAllGrids();\n        }\n    }","commit_id":"f860b80adf61574d789fe045cfa69325f2e26be4","url":"https://github.com/apache/ignite"},{"original_method":"@NotNull\n  private static GeneralCommandLine sudoCommand(@NotNull GeneralCommandLine commandLine, @NotNull String prompt) throws ExecutionException, IOException {\n    if (SystemInfo.isUnix && \"root\".equals(System.getenv(\"USER\"))) {\n      return commandLine;\n    }\n\n    List<String> command = ContainerUtil.newArrayList();\n    command.add(commandLine.getExePath());\n    command.addAll(commandLine.getParametersList().getList());\n\n    GeneralCommandLine sudoCommandLine;\n    if (SystemInfo.isMac) {\n      String escapedCommandLine = StringUtil.join(command, new Function<String, String>() {\n        @Override\n        public String fun(String s) {\n          return escapeAppleScriptArgument(s);\n        }\n      }, \" & \\\" \\\" & \");\n      String escapedScript = \"tell current application\\n\" +\n                             \"   activate\\n\" +\n                             \"   do shell script \" + escapedCommandLine + \" with administrator privileges without altering line endings\\n\" +\n                             \"end tell\";\n      sudoCommandLine = new GeneralCommandLine(getOsascriptPath(), \"-e\", escapedScript);\n    }\n    else if (hasGkSudo.getValue()) {\n      List<String> sudoCommand = ContainerUtil.newArrayList();\n      sudoCommand.addAll(Arrays.asList(\"gksudo\", \"--message\", prompt, \"--\"));\n      sudoCommand.addAll(command);\n      sudoCommandLine = new GeneralCommandLine(sudoCommand);\n    }\n    else if (hasKdeSudo.getValue()) {\n      List<String> sudoCommand = ContainerUtil.newArrayList();\n      sudoCommand.addAll(Arrays.asList(\"kdesudo\", \"--comment\", prompt, \"--\"));\n      sudoCommand.addAll(command);\n      sudoCommandLine = new GeneralCommandLine(sudoCommand);\n    }\n    else if (hasPkExec.getValue()) {\n      command.add(0, \"pkexec\");\n      command.add(1, \"env\");\n      int i = 2;\n      for (Map.Entry<String, String> entry : commandLine.getEnvironment().entrySet()) {\n        command.add(i++, entry.getKey() + \"=\" + escapeUnixShellArgument(entry.getValue()));\n      }\n      sudoCommandLine = new GeneralCommandLine(command);\n    }\n    else if (SystemInfo.isUnix && hasTerminalApp()) {\n      String escapedCommandLine = StringUtil.join(command, new Function<String, String>() {\n        @Override\n        public String fun(String s) {\n          return escapeUnixShellArgument(s);\n        }\n      }, \" \");\n      File script = createTempExecutableScript(\n        \"sudo\", \".sh\",\n        \"#!/bin/sh\\n\" +\n        \"echo \" + escapeUnixShellArgument(prompt) + \"\\n\" +\n        \"echo\\n\" +\n        \"sudo -- \" + escapedCommandLine + \"\\n\" +\n        \"STATUS=$?\\n\" +\n        \"echo\\n\" +\n        \"read -p \\\"Press Enter to close this window...\\\" TEMP\\n\" +\n        \"exit $STATUS\\n\");\n      sudoCommandLine = new GeneralCommandLine(getTerminalCommand(\"Install\", script.getAbsolutePath()));\n    }\n    else {\n      throw new UnsupportedSystemException();\n    }\n\n    return sudoCommandLine\n      .withWorkDirectory(commandLine.getWorkDirectory())\n      .withEnvironment(commandLine.getEnvironment())\n      .withParentEnvironmentType(commandLine.getParentEnvironmentType())\n      .withRedirectErrorStream(commandLine.isRedirectErrorStream());\n  }","id":99465,"modified_method":"@NotNull\n  private static GeneralCommandLine sudoCommand(@NotNull GeneralCommandLine commandLine, @NotNull String prompt) throws ExecutionException, IOException {\n    if (SystemInfo.isUnix && \"root\".equals(System.getenv(\"USER\"))) {\n      return commandLine;\n    }\n\n    List<String> command = ContainerUtil.newArrayList();\n    command.add(commandLine.getExePath());\n    command.addAll(commandLine.getParametersList().getList());\n\n    GeneralCommandLine sudoCommandLine;\n    if (SystemInfo.isMac) {\n      String escapedCommandLine = StringUtil.join(command, new Function<String, String>() {\n        @Override\n        public String fun(String s) {\n          return escapeAppleScriptArgument(s);\n        }\n      }, \" & \\\" \\\" & \");\n      String escapedScript = \"tell current application\\n\" +\n                             \"   activate\\n\" +\n                             \"   do shell script \" + escapedCommandLine + \" with administrator privileges without altering line endings\\n\" +\n                             \"end tell\";\n      sudoCommandLine = new GeneralCommandLine(getOsascriptPath(), \"-e\", escapedScript);\n    }\n    else if (hasGkSudo.getValue()) {\n      List<String> sudoCommand = ContainerUtil.newArrayList();\n      sudoCommand.addAll(Arrays.asList(\"gksudo\", \"--message\", prompt, \"--\"));\n      sudoCommand.addAll(command);\n      sudoCommandLine = new GeneralCommandLine(sudoCommand);\n    }\n    else if (hasKdeSudo.getValue()) {\n      List<String> sudoCommand = ContainerUtil.newArrayList();\n      sudoCommand.addAll(Arrays.asList(\"kdesudo\", \"--comment\", prompt, \"--\"));\n      sudoCommand.addAll(command);\n      sudoCommandLine = new GeneralCommandLine(sudoCommand);\n    }\n    else if (hasPkExec.getValue()) {\n      command.add(0, \"pkexec\");\n\n      //workaround for RUBY-16963\n      String homeDirectory = commandLine.getEnvironment().get(\"HOME\");\n      if (hasSh.getValue() && homeDirectory != null) {\n        String escapedCommandLine = StringUtil.join(command, new Function<String, String>() {\n          @Override\n          public String fun(String s) {\n            return escapeUnixShellArgument(s);\n          }\n        }, \" \");\n\n        File exportHomeScript = createTempExecutableScript(\"pkexec-homeDirectory\", \".sh\",\n                                                           \"#!/bin/sh\\n\" +\n                                                           \"HOME=\" + escapeUnixShellArgument(homeDirectory) + \" \" + escapedCommandLine);\n        command.add(1, \"sh\");\n        command.add(2, exportHomeScript.getAbsolutePath());\n      }\n\n      sudoCommandLine = new GeneralCommandLine(command);\n    }\n    else if (SystemInfo.isUnix && hasTerminalApp()) {\n      String escapedCommandLine = StringUtil.join(command, new Function<String, String>() {\n        @Override\n        public String fun(String s) {\n          return escapeUnixShellArgument(s);\n        }\n      }, \" \");\n      File script = createTempExecutableScript(\n        \"sudo\", \".sh\",\n        \"#!/bin/sh\\n\" +\n        \"echo \" + escapeUnixShellArgument(prompt) + \"\\n\" +\n        \"echo\\n\" +\n        \"sudo -- \" + escapedCommandLine + \"\\n\" +\n        \"STATUS=$?\\n\" +\n        \"echo\\n\" +\n        \"read -p \\\"Press Enter to close this window...\\\" TEMP\\n\" +\n        \"exit $STATUS\\n\");\n      sudoCommandLine = new GeneralCommandLine(getTerminalCommand(\"Install\", script.getAbsolutePath()));\n    }\n    else {\n      throw new UnsupportedSystemException();\n    }\n\n    return sudoCommandLine\n      .withWorkDirectory(commandLine.getWorkDirectory())\n      .withEnvironment(commandLine.getEnvironment())\n      .withParentEnvironmentType(commandLine.getParentEnvironmentType())\n      .withRedirectErrorStream(commandLine.isRedirectErrorStream());\n  }","commit_id":"94ca6d4083a47cd4f88bcac2a2a7cacc82d8da19","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GradleHandle start() {\n        if (execHandle != null) {\n            throw new IllegalStateException(\"you have already called start() on this handle\");\n        }\n\n        AbstractExecHandleBuilder execBuilder = execHandleFactory.create();\n        execBuilder.setStandardOutput(new CloseShieldOutputStream(new TeeOutputStream(System.out, standardOutput)));\n        execBuilder.setErrorOutput(new CloseShieldOutputStream(new TeeOutputStream(System.err, errorOutput)));\n        execHandle = execBuilder.build();\n\n        System.out.println(\"Starting build with: \" + execHandle.getCommand() + \" \" + Joiner.on(\" \").join(execHandle.getArguments()));\n        System.out.println(\"Working directory: \" + execHandle.getDirectory());\n        System.out.println(\"Environment vars:\");\n        for (Map.Entry<String, String> entry : execHandle.getEnvironment().entrySet()) {\n            System.out.println(String.format(\"    %s: %s\", entry.getKey(), entry.getValue()));\n        }\n\n        execHandle.start();\n\n        return this;\n    }","id":99466,"modified_method":"public GradleHandle start() {\n        if (execHandle != null) {\n            throw new IllegalStateException(\"you have already called start() on this handle\");\n        }\n\n        AbstractExecHandleBuilder execBuilder = execHandleFactory.create();\n        execBuilder.setStandardOutput(new CloseShieldOutputStream(new TeeOutputStream(System.out, standardOutput)));\n        execBuilder.setErrorOutput(new CloseShieldOutputStream(new TeeOutputStream(System.err, errorOutput)));\n        execHandle = execBuilder.build();\n\n        System.out.println(\"Starting build with: \" + execHandle.getCommand() + \" \" + Joiner.on(\" \").join(execHandle.getArguments()));\n        System.out.println(\"Working directory: \" + execHandle.getDirectory());\n        System.out.println(\"Environment vars:\");\n        System.out.println(String.format(\"    JAVA_HOME: %s\", execHandle.getEnvironment().get(\"JAVA_HOME\")));\n        System.out.println(String.format(\"    GRADLE_HOME: %s\", execHandle.getEnvironment().get(\"GRADLE_HOME\")));\n        System.out.println(String.format(\"    GRADLE_USER_HOME: %s\", execHandle.getEnvironment().get(\"GRADLE_USER_HOME\")));\n        System.out.println(String.format(\"    JAVA_OPTS: %s\", execHandle.getEnvironment().get(\"JAVA_OPTS\")));\n        System.out.println(String.format(\"    GRADLE_OPTS: %s\", execHandle.getEnvironment().get(\"GRADLE_OPTS\")));\n\n        execHandle.start();\n\n        return this;\n    }","commit_id":"4ed75d789b87d5c0efdd2994762e11e15364a1ed","url":"https://github.com/gradle/gradle"},{"original_method":"InProcessGradleExecuter(GradleDistribution distribution, TestDirectoryProvider testDirectoryProvider) {\n        super(distribution, testDirectoryProvider);\n    }","id":99467,"modified_method":"public InProcessGradleExecuter(GradleDistribution distribution, TestDirectoryProvider testDirectoryProvider) {\n        super(distribution, testDirectoryProvider);\n    }","commit_id":"4ed75d789b87d5c0efdd2994762e11e15364a1ed","url":"https://github.com/gradle/gradle"},{"original_method":"private static String serializeRow(IteratingRow row) throws IOException\n    {\n        ColumnFamily cf = row.getColumnFamily();\n        AbstractType comparator = cf.getComparator();\n        StringBuilder json = new StringBuilder(asKey(row.getKey().key));\n        \n        if (cf.isSuper())\n        {\n            json.append(\"{ \");\n\n            Iterator<IColumn> iter = cf.getSortedColumns().iterator();\n            while (iter.hasNext())\n            {\n                IColumn column = iter.next();\n                json.append(asKey(comparator.getString(column.name())));\n                json.append(serializeColumns(column.getSubColumns(), comparator));\n                if (iter.hasNext())\n                    json.append(\", \");\n            }\n            \n            json.append(\" }\");\n        }\n        else\n        {\n            json.append(serializeColumns(cf.getSortedColumns(), comparator));\n        }\n     \n        return json.toString();\n    }","id":99468,"modified_method":"private static String serializeRow(IteratingRow row) throws IOException\n    {\n        ColumnFamily cf = row.getColumnFamily();\n        AbstractType comparator = cf.getComparator();\n        StringBuilder json = new StringBuilder(asKey(row.getKey().key));\n        \n        if (cf.isSuper())\n        {\n            json.append(\"{ \");\n\n            Iterator<IColumn> iter = cf.getSortedColumns().iterator();\n            while (iter.hasNext())\n            {\n                IColumn column = iter.next();\n                json.append(asKey(comparator.getString(column.name())));\n                json.append(\"{\");\n                json.append(asKey(\"deletedAt\"));\n                json.append(column.getMarkedForDeleteAt());\n                json.append(\", \");\n                json.append(asKey(\"subColumns\"));\n                json.append(serializeColumns(column.getSubColumns(), comparator));\n                json.append(\"}\");\n                if (iter.hasNext())\n                    json.append(\", \");\n            }\n            \n            json.append(\"}\");\n        }\n        else\n        {\n            json.append(serializeColumns(cf.getSortedColumns(), comparator));\n        }\n     \n        return json.toString();\n    }","commit_id":"36edc09be8479803b9cfe4fa9700ecc1c95f1f78","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Export an SSTable and write the resulting JSON to a PrintStream.\n     * \n     * @param ssTableFile the SSTable to export\n     * @param outs PrintStream to write the output to\n     * @throws IOException on failure to read/write input/output\n     */\n    public static void export(String ssTableFile, PrintStream outs) throws IOException\n    {\n        SSTableReader reader = SSTableReader.open(ssTableFile);\n        SSTableScanner scanner = reader.getScanner();\n        \n        outs.println(\"{\");\n        \n        while(scanner.hasNext())\n        {\n            IteratingRow row = scanner.next();\n            try\n            {\n                String jsonOut = serializeRow(row);\n                outs.print(\"  \" + jsonOut);\n                if (scanner.hasNext())\n                    outs.println(\",\");\n                else\n                    outs.println();\n            }\n            catch (IOException ioexcep)\n            {\n                System.err.println(\"WARNING: Corrupt row \" + row.getKey().key + \" (skipping).\");\n                continue;\n            }\n            catch (OutOfMemoryError oom)\n            {\n                System.err.println(\"ERROR: Out of memory deserializing row \" + row.getKey().key);\n                continue;\n            }\n        }\n        \n        outs.println(\"}\");\n        outs.flush();\n    }","id":99469,"modified_method":"/**\n     * Export an SSTable and write the resulting JSON to a PrintStream.\n     * \n     * @param ssTableFile the SSTable to export\n     * @param outs PrintStream to write the output to\n     * @throws IOException on failure to read/write input/output\n     */\n    public static void export(String ssTableFile, PrintStream outs) throws IOException\n    {\n        SSTableReader reader = SSTableReader.open(ssTableFile);\n        export(reader, outs);\n    }","commit_id":"36edc09be8479803b9cfe4fa9700ecc1c95f1f78","url":"https://github.com/apache/cassandra"},{"original_method":"private static String serializeColumns(Collection<IColumn> cols, AbstractType comp)\n    {\n        StringBuilder json = new StringBuilder(\"{\");\n        \n        Iterator<IColumn> iter = cols.iterator();\n        while (iter.hasNext())\n        {\n            IColumn column = iter.next();\n            json.append(asKey(comp.getString(column.name())));\n            json.append(quote(FBUtilities.bytesToHex(column.value())));\n            if (iter.hasNext())\n                json.append(\", \");\n        }\n        \n        json.append(\" }\");\n        \n        return json.toString();\n    }","id":99470,"modified_method":"private static String serializeColumns(Collection<IColumn> cols, AbstractType comp)\n    {\n        StringBuilder json = new StringBuilder(\"[\");\n        \n        Iterator<IColumn> iter = cols.iterator();\n        while (iter.hasNext())\n        {\n            json.append(\"[\");\n            IColumn column = iter.next();\n            json.append(quote(comp.getString(column.name())));\n            json.append(\", \");\n            json.append(quote(FBUtilities.bytesToHex(column.value())));\n            json.append(\", \");\n            json.append(column.timestamp());\n            json.append(\", \");\n            json.append(column.isMarkedForDelete());\n            json.append(\"]\");\n            if (iter.hasNext())\n                json.append(\", \");\n        }\n        \n        json.append(\"]\");\n        \n        return json.toString();\n    }","commit_id":"36edc09be8479803b9cfe4fa9700ecc1c95f1f78","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Add super columns to a column family.\n     * \n     * @param row the super columns associated with a row\n     * @param cfamily the column family to add columns to\n     */\n    private static void addToSuperCF(JSONObject row, ColumnFamily cfamily)\n    {\n        // Super columns\n        for (Map.Entry<String, JSONObject> entry : (Set<Map.Entry<String, JSONObject>>)row.entrySet())\n        {\n            byte[] superName = entry.getKey().getBytes();\n            \n            // Sub-columns\n            for (Map.Entry<String, String> col : (Set<Map.Entry<String, String>>)entry.getValue().entrySet())\n            {\n                QueryPath path = new QueryPath(cfamily.name(), superName, col.getKey().getBytes());\n                byte[] value = FBUtilities.hexToBytes(col.getValue());\n                cfamily.addColumn(path, value, System.currentTimeMillis());\n            }\n        }\n    }","id":99471,"modified_method":"/**\n     * Add super columns to a column family.\n     * \n     * @param row the super columns associated with a row\n     * @param cfamily the column family to add columns to\n     */\n    private static void addToSuperCF(JSONObject row, ColumnFamily cfamily)\n    {\n        // Super columns\n        for (Map.Entry<String, JSONObject> entry : (Set<Map.Entry<String, JSONObject>>)row.entrySet())\n        {\n            byte[] superName = entry.getKey().getBytes();\n            long deletedAt = (Long)entry.getValue().get(\"deletedAt\");\n            JSONArray subColumns = (JSONArray)entry.getValue().get(\"subColumns\");\n            \n            // Add sub-columns\n            for (Object c : subColumns)\n            {\n                JsonColumn col = new JsonColumn(c);\n                QueryPath path = new QueryPath(cfamily.name(), superName, col.name.getBytes());\n                cfamily.addColumn(path, FBUtilities.hexToBytes(col.value), col.timestamp, col.isDeleted);\n            }\n            \n            SuperColumn superColumn = (SuperColumn)cfamily.getColumn(superName);\n            superColumn.markForDeleteAt((int)System.currentTimeMillis(), deletedAt);\n        }\n    }","commit_id":"36edc09be8479803b9cfe4fa9700ecc1c95f1f78","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Convert a JSON formatted file to an SSTable.\n     * \n     * @param jsonFile the file containing JSON formatted data\n     * @param keyspace keyspace the data belongs to\n     * @param cf column family the data belongs to\n     * @param ssTablePath file to write the SSTable to\n     * @throws IOException for errors reading/writing input/output\n     * @throws ParseException for errors encountered parsing JSON input\n     */\n    private static void importJson(String jsonFile, String keyspace, String cf, String ssTablePath)\n    throws IOException, ParseException\n    {\n        ColumnFamily cfamily = ColumnFamily.create(keyspace, cf);\n        String cfType = cfamily.type();    // Super or Standard\n        IPartitioner<?> partitioner = DatabaseDescriptor.getPartitioner();\n        DataOutputBuffer dob = new DataOutputBuffer();\n        \n        try\n        {\n            JSONObject json = (JSONObject)JSONValue.parse(new FileReader(jsonFile));\n            SSTableWriter writer = new SSTableWriter(ssTablePath, json.size(), partitioner);\n            List<DecoratedKey<?>> decoratedKeys = new ArrayList<DecoratedKey<?>>();\n            \n            for (String key : (Set<String>)json.keySet())\n                decoratedKeys.add(partitioner.decorateKey(key));\n            Collections.sort(decoratedKeys);\n\n            for (DecoratedKey<?> rowKey : decoratedKeys)\n            {\n                JSONObject value = (JSONObject)json.get(rowKey.key);\n                \n                if (cfType.equals(\"Super\"))\n                    addToSuperCF(value, cfamily);\n                else\n                    addToStandardCF(value, cfamily);\n                           \n                ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);\n                writer.append(rowKey, dob);\n                dob.reset();\n                cfamily.clear();\n            }\n            \n            writer.closeAndOpenReader(0);\n        }\n        catch (ClassCastException cce)\n        {\n            //throw cce;\n            throw new RuntimeException(\"Invalid JSON input, or incorrect column family\");\n        }\n    }","id":99472,"modified_method":"/**\n     * Convert a JSON formatted file to an SSTable.\n     * \n     * @param jsonFile the file containing JSON formatted data\n     * @param keyspace keyspace the data belongs to\n     * @param cf column family the data belongs to\n     * @param ssTablePath file to write the SSTable to\n     * @throws IOException for errors reading/writing input/output\n     * @throws ParseException for errors encountered parsing JSON input\n     */\n    public static void importJson(String jsonFile, String keyspace, String cf, String ssTablePath)\n    throws IOException, ParseException\n    {\n        ColumnFamily cfamily = ColumnFamily.create(keyspace, cf);\n        String cfType = cfamily.type();    // Super or Standard\n        IPartitioner<?> partitioner = DatabaseDescriptor.getPartitioner();\n        DataOutputBuffer dob = new DataOutputBuffer();\n        \n        try\n        {\n            JSONObject json = (JSONObject)JSONValue.parse(new FileReader(jsonFile));\n            \n            // FIXME: see http://code.google.com/p/json-simple/issues/detail?id=13\n            if (json == null)\n                throw new RuntimeException(\"Error parsing JSON input!\");\n            \n            SSTableWriter writer = new SSTableWriter(ssTablePath, json.size(), partitioner);\n            List<DecoratedKey<?>> decoratedKeys = new ArrayList<DecoratedKey<?>>();\n            \n            for (String key : (Set<String>)json.keySet())\n                decoratedKeys.add(partitioner.decorateKey(key));\n            Collections.sort(decoratedKeys);\n\n            for (DecoratedKey<?> rowKey : decoratedKeys)\n            {\n                if (cfType.equals(\"Super\"))\n                    addToSuperCF((JSONObject)json.get(rowKey.key), cfamily);\n                else\n                    addToStandardCF((JSONArray)json.get(rowKey.key), cfamily);\n                           \n                ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);\n                writer.append(rowKey, dob);\n                dob.reset();\n                cfamily.clear();\n            }\n            \n            writer.closeAndOpenReader(0);\n        }\n        catch (ClassCastException cce)\n        {\n            throw new RuntimeException(\"Invalid JSON input, or incorrect column family.\", cce);\n        }\n    }","commit_id":"36edc09be8479803b9cfe4fa9700ecc1c95f1f78","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Add columns to a column family.\n     * \n     * @param row the columns associated with a row\n     * @param cfamily the column family to add columns to\n     */\n    private static void addToStandardCF(JSONObject row, ColumnFamily cfamily)\n    {\n        for (Map.Entry<String, String> col : (Set<Map.Entry<String, String>>) row.entrySet())\n        {\n            QueryPath path = new QueryPath(cfamily.name(), null, col.getKey().getBytes());\n            byte[] value = FBUtilities.hexToBytes(col.getValue());\n            cfamily.addColumn(path, value, System.currentTimeMillis());\n        }\n    }","id":99473,"modified_method":"/**\n     * Add columns to a column family.\n     * \n     * @param row the columns associated with a row\n     * @param cfamily the column family to add columns to\n     */\n    private static void addToStandardCF(JSONArray row, ColumnFamily cfamily)\n    {\n        for (Object c : row)\n        {\n            JsonColumn col = new JsonColumn(c);  \n            QueryPath path = new QueryPath(cfamily.name(), null, col.name.getBytes());\n            cfamily.addColumn(path, FBUtilities.hexToBytes(col.value), col.timestamp, col.isDeleted);\n        }\n    }","commit_id":"36edc09be8479803b9cfe4fa9700ecc1c95f1f78","url":"https://github.com/apache/cassandra"},{"original_method":"CacheManager( ManagementData management, NodeManager nodeManager, Cache<?> cache )\n                throws NotCompliantMBeanException\n        {\n            super( management, cache.getName() );\n            this.nodeManager = nodeManager;\n            this.cache = cache;\n        }","id":99474,"modified_method":"CacheManager( ManagementData management, NodeManager nodeManager, Cache cache )\n                throws NotCompliantMBeanException\n        {\n            super( management, cache.getName() );\n            this.nodeManager = nodeManager;\n            this.cache = cache;\n        }","commit_id":"1c62ddac048d8aafefda478405cd1246052c0d99","url":"https://github.com/neo4j/neo4j"},{"original_method":"MemoryMappingImpl( ManagementData management, boolean isMxBean )\n        {\n            super( management, isMxBean );\n            this.datasource = KernelBean.getNeoDataSource( management.getKernelData() );\n        }","id":99475,"modified_method":"MemoryMappingImpl( ManagementData management, boolean isMxBean )\n        {\n            super( management, isMxBean );\n            this.datasource = management.getKernelData().graphDatabase().getXaDataSourceManager().getNeoStoreDataSource();\n        }","commit_id":"1c62ddac048d8aafefda478405cd1246052c0d99","url":"https://github.com/neo4j/neo4j"},{"original_method":"MemoryMappingImpl( ManagementData management ) throws NotCompliantMBeanException\n        {\n            super( management );\n            this.datasource = KernelBean.getNeoDataSource( management.getKernelData() );\n        }","id":99476,"modified_method":"MemoryMappingImpl( ManagementData management ) throws NotCompliantMBeanException\n        {\n            super( management );\n            this.datasource = management.getKernelData().graphDatabase().getXaDataSourceManager().getNeoStoreDataSource();\n        }","commit_id":"1c62ddac048d8aafefda478405cd1246052c0d99","url":"https://github.com/neo4j/neo4j"},{"original_method":"StoreFileImpl( ManagementData management ) throws NotCompliantMBeanException\n        {\n            super( management );\n            NeoStoreXaDataSource nioneodb = KernelBean.getNeoDataSource( management.getKernelData() );\n            File path;\n            try\n            {\n                path = new File( nioneodb.getStoreDir() ).getCanonicalFile().getAbsoluteFile();\n            }\n            catch ( IOException e )\n            {\n                path = new File( nioneodb.getStoreDir() ).getAbsoluteFile();\n            }\n            this.storePath = path;\n        }","id":99477,"modified_method":"StoreFileImpl( ManagementData management ) throws NotCompliantMBeanException\n        {\n            super( management );\n            NeoStoreXaDataSource nioneodb = management.getKernelData().graphDatabase().getXaDataSourceManager().getNeoStoreDataSource();\n            File path;\n            try\n            {\n                path = new File( nioneodb.getStoreDir() ).getCanonicalFile().getAbsoluteFile();\n            }\n            catch ( IOException e )\n            {\n                path = new File( nioneodb.getStoreDir() ).getAbsoluteFile();\n            }\n            this.storePath = path;\n        }","commit_id":"1c62ddac048d8aafefda478405cd1246052c0d99","url":"https://github.com/neo4j/neo4j"},{"original_method":"CacheManager( ManagementData management, NodeManager nodeManager, Cache<?> cache )\n                throws NotCompliantMBeanException\n        {\n            super( management, cache.getName() );\n            this.nodeManager = nodeManager;\n            this.cache = cache;\n        }","id":99478,"modified_method":"CacheManager( ManagementData management, NodeManager nodeManager, Cache cache )\n                throws NotCompliantMBeanException\n        {\n            super( management, cache.getName() );\n            this.nodeManager = nodeManager;\n            this.cache = cache;\n        }","commit_id":"991cb59f54a493d66fe6f3577f4d067ff4018c24","url":"https://github.com/neo4j/neo4j"},{"original_method":"MemoryMappingImpl( ManagementData management ) throws NotCompliantMBeanException\n        {\n            super( management );\n            this.datasource = KernelBean.getNeoDataSource( management.getKernelData() );\n        }","id":99479,"modified_method":"MemoryMappingImpl( ManagementData management ) throws NotCompliantMBeanException\n        {\n            super( management );\n            this.datasource = management.getKernelData().graphDatabase().getXaDataSourceManager().getNeoStoreDataSource();\n        }","commit_id":"991cb59f54a493d66fe6f3577f4d067ff4018c24","url":"https://github.com/neo4j/neo4j"},{"original_method":"MemoryMappingImpl( ManagementData management, boolean isMxBean )\n        {\n            super( management, isMxBean );\n            this.datasource = KernelBean.getNeoDataSource( management.getKernelData() );\n        }","id":99480,"modified_method":"MemoryMappingImpl( ManagementData management, boolean isMxBean )\n        {\n            super( management, isMxBean );\n            this.datasource = management.getKernelData().graphDatabase().getXaDataSourceManager().getNeoStoreDataSource();\n        }","commit_id":"991cb59f54a493d66fe6f3577f4d067ff4018c24","url":"https://github.com/neo4j/neo4j"},{"original_method":"StoreFileImpl( ManagementData management ) throws NotCompliantMBeanException\n        {\n            super( management );\n            NeoStoreXaDataSource nioneodb = KernelBean.getNeoDataSource( management.getKernelData() );\n            File path;\n            try\n            {\n                path = new File( nioneodb.getStoreDir() ).getCanonicalFile().getAbsoluteFile();\n            }\n            catch ( IOException e )\n            {\n                path = new File( nioneodb.getStoreDir() ).getAbsoluteFile();\n            }\n            this.storePath = path;\n        }","id":99481,"modified_method":"StoreFileImpl( ManagementData management ) throws NotCompliantMBeanException\n        {\n            super( management );\n            NeoStoreXaDataSource nioneodb = management.getKernelData().graphDatabase().getXaDataSourceManager().getNeoStoreDataSource();\n            File path;\n            try\n            {\n                path = new File( nioneodb.getStoreDir() ).getCanonicalFile().getAbsoluteFile();\n            }\n            catch ( IOException e )\n            {\n                path = new File( nioneodb.getStoreDir() ).getAbsoluteFile();\n            }\n            this.storePath = path;\n        }","commit_id":"991cb59f54a493d66fe6f3577f4d067ff4018c24","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void run(PipelineContext context, FunctionContext functionContext, Document instance) {\n        String[] ids = nodeset.split(\" \");\n        Integer id = new Integer(ids[Integer.parseInt(at) - 1]);\n        Node nodeToRemove = (Node) ((InstanceData) instance.getRootElement().getData()).getIdToNodeMap().get(id);\n        nodeToRemove.getParent().remove(nodeToRemove);\n    }","id":99482,"modified_method":"public void run(PipelineContext context, FunctionContext functionContext, String encryptionPassword, Document instance) {\n        String[] ids = nodeset.split(\" \");\n        if (XFormsUtils.isNameEncryptionEnabled())\n            at = SecureUtils.decrypt(context, encryptionPassword, at);\n        String id = ids[Integer.parseInt(at) - 1];\n        if (XFormsUtils.isNameEncryptionEnabled())\n            id = SecureUtils.decrypt(context, encryptionPassword, id);\n        Node nodeToRemove = (Node) ((InstanceData) instance.getRootElement().getData())\n                .getIdToNodeMap().get(new Integer(id));\n        nodeToRemove.getParent().remove(nodeToRemove);\n    }","commit_id":"a2b9e23d71884e4a88d7cfbd6af5553f2114f590","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void start(XFormsElementContext context, String uri, String localname, String qname, Attributes attributes) throws SAXException {\n        isFirstGroup = context.getParentElement(0) == null;\n        super.start(context, uri, localname, qname, attributes);\n    }","id":99483,"modified_method":"public void start(XFormsElementContext context, String uri, String localname, String qname, Attributes attributes) throws SAXException {\n        isFirstGroup = context.getParentElement(0) == null;\n        super.start(context, uri, localname, qname, attributes);\n\n        if (XFormsUtils.isHiddenEncryptionEnabled() || XFormsUtils.isNameEncryptionEnabled()) {\n            // Generate hidden field with random key encrypted with server key\n            String serverPassword = OXFProperties.instance().getPropertySet().getString(Constants.XFORMS_PASSWORD);\n            String encryptedRandomKey = SecureUtils.encrypt(context.getPipelineContext(),\n                    serverPassword, context.getEncryptionPassword());\n            sendHiddenElement(context, \"$key\", encryptedRandomKey);\n        }\n    }","commit_id":"a2b9e23d71884e4a88d7cfbd6af5553f2114f590","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void end(XFormsElementContext context, String uri, String localname, String qname) throws SAXException {\n        if (isFirstGroup) {\n            // Encode instance in a string and put in hidden field\n            final String instanceString = XFormsUtils.instanceToString(context.getInstance());\n            AttributesImpl attributes = new AttributesImpl();\n            attributes.addAttribute(Constants.XXFORMS_NAMESPACE_URI, \"name\",\n                    Constants.XXFORMS_PREFIX + \":name\", \"CDATA\", \"$instance\");\n            attributes.addAttribute(Constants.XXFORMS_NAMESPACE_URI, \"value\",\n                    Constants.XXFORMS_PREFIX + \":value\", \"CDATA\", instanceString);\n            String elementLocalName = \"hidden\";\n            String elementQName = Constants.XXFORMS_PREFIX + \":\" + elementLocalName;\n            context.getContentHandler().startElement(Constants.XXFORMS_NAMESPACE_URI,\n                    elementLocalName, elementQName, attributes);\n            context.getContentHandler().endElement(Constants.XXFORMS_NAMESPACE_URI,\n                    elementLocalName, elementQName);\n        }\n\n        // Close form\n        super.end(context, uri, localname, qname);\n    }","id":99484,"modified_method":"public void end(XFormsElementContext context, String uri, String localname, String qname) throws SAXException {\n        if (isFirstGroup) {\n            // Encode instance in a string and put in hidden field\n            String instanceString = XFormsUtils.instanceToString(context.getPipelineContext(),\n                    context.getEncryptionPassword(), context.getInstance());\n            sendHiddenElement(context, \"$instance\", instanceString);\n        }\n\n        // Close form\n        super.end(context, uri, localname, qname);\n    }","commit_id":"a2b9e23d71884e4a88d7cfbd6af5553f2114f590","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void run(PipelineContext context, FunctionContext functionContext, Document instance) {\n\n        String[] ids = nodeset.split(\" \");\n        Map idToNodeMap = ((InstanceData) instance.getRootElement().getData()).getIdToNodeMap();\n\n        // Get element to duplicate (last one in the nodeset)\n        final Element elementToDuplicate;\n        {\n            if (ids.length == 0)\n                throw new OXFException(\"nodeset attribute in insert action must return a non-empty nodeset\");\n            Object lastNode = idToNodeMap.get(new Integer(ids[ids.length - 1]));\n            if (!(lastNode instanceof Element))\n                throw new OXFException(\"last node in nodeset attribute from insert action must must be an element\");\n            elementToDuplicate = (Element) lastNode;\n        }\n\n        // Determine where to insert the duplicated element\n        int atValue;\n        atValue = Integer.parseInt(at) - 1;\n        if (atValue < 0) atValue = 0;\n        if (atValue >= ids.length) atValue = ids.length - 1;\n\n        // Get element at \"at\" position\n        final Element atElement;\n        {\n            Object atNode = idToNodeMap.get(new Integer(ids[atValue]));\n            if (!(atNode instanceof Element))\n                throw new OXFException(\"node pointed by 'at' position in nodeset attribute from\"\n                        + \" insert action must must be an element\");\n            atElement = (Element) atNode;\n        }\n\n\n        // Locate position of atElement (element pointed by \"at\") among his siblings\n        int atElementIndex = 0;\n        List atElementSiblings = atElement.getParent().elements();\n        {\n            boolean found = false;\n            for (Iterator i = atElementSiblings.iterator(); i.hasNext();) {\n                if (i.next() == atElement) {\n                    found = true;\n                    break;\n                }\n                atElementIndex++;\n            }\n            if (!found)\n                throw new OXFException(\"Nodeset defined by '\" + nodeset + \"' is not homogeneous\");\n        }\n\n        // Actually do the insertion\n        atElementSiblings.add(POSITION_BEFORE.equals(position) ? atElementIndex : atElementIndex + 1,\n                elementToDuplicate.clone());\n    }","id":99485,"modified_method":"public void run(PipelineContext context, FunctionContext functionContext, String encryptionPassword, Document instance) {\n\n        String[] ids = nodeset.split(\" \");\n        Map idToNodeMap = ((InstanceData) instance.getRootElement().getData()).getIdToNodeMap();\n\n        // Get element to duplicate (last one in the nodeset)\n        final Element elementToDuplicate;\n        {\n            if (ids.length == 0)\n                throw new OXFException(\"nodeset attribute in insert action must return a non-empty nodeset\");\n            Object lastNode = idToNodeMap.get(new Integer(ids[ids.length - 1]));\n            if (!(lastNode instanceof Element))\n                throw new OXFException(\"last node in nodeset attribute from insert action must must be an element\");\n            elementToDuplicate = (Element) lastNode;\n        }\n\n        // Determine where to insert the duplicated element\n        if (XFormsUtils.isNameEncryptionEnabled())\n            at = SecureUtils.decrypt(context, encryptionPassword, at);\n        int atValue = Integer.parseInt(at) - 1;\n        if (atValue < 0) atValue = 0;\n        if (atValue >= ids.length) atValue = ids.length - 1;\n\n        // Get element at \"at\" position\n        final Element atElement;\n        {\n            String id = ids[atValue];\n            if (XFormsUtils.isNameEncryptionEnabled())\n                id = SecureUtils.decrypt(context, encryptionPassword, id);\n            Object atNode = idToNodeMap.get(new Integer(id));\n            if (!(atNode instanceof Element))\n                throw new OXFException(\"node pointed by 'at' position in nodeset attribute from\"\n                        + \" insert action must must be an element\");\n            atElement = (Element) atNode;\n        }\n\n\n        // Locate position of atElement (element pointed by \"at\") among his siblings\n        int atElementIndex = 0;\n        List atElementSiblings = atElement.getParent().elements();\n        {\n            boolean found = false;\n            for (Iterator i = atElementSiblings.iterator(); i.hasNext();) {\n                if (i.next() == atElement) {\n                    found = true;\n                    break;\n                }\n                atElementIndex++;\n            }\n            if (!found)\n                throw new OXFException(\"Nodeset defined by '\" + nodeset + \"' is not homogeneous\");\n        }\n\n        // Actually do the insertion\n        atElementSiblings.add(POSITION_BEFORE.equals(position) ? atElementIndex : atElementIndex + 1,\n                elementToDuplicate.clone());\n    }","commit_id":"a2b9e23d71884e4a88d7cfbd6af5553f2114f590","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public ProcessorOutput createOutput(String name) {\n        ProcessorOutput output = new ProcessorImpl.ProcessorOutputImpl(getClass(), name) {\n            public void readImpl(PipelineContext pipelineContext, final ContentHandler contentHandler) {\n                try {\n                    Element filterElement = readInputAsDOM4J(pipelineContext, INPUT_FILTER).getRootElement();\n                    Document instance = DocumentHelper.createDocument\n                            (readInputAsDOM4J(pipelineContext, INPUT_INSTANCE).getRootElement().createCopy());\n                    DocumentWrapper instanceWrapper = new DocumentWrapper(instance,\n                            ((LocationData) instance.getRootElement().getData()).getSystemID());\n\n                    // Mark all nodes referenced by XPath expressions\n                    final Set markedNodes = new HashSet();\n                    for (Iterator i = filterElement.elements().iterator(); i.hasNext();) {\n                        Element paramElement = (Element) i.next();\n                        Attribute refAttribute = paramElement.attribute(\"ref\");\n                        String excludeRef = refAttribute.getValue();\n                        PooledXPathExpression xpath = XPathCache.getXPathExpression(pipelineContext,\n                                instanceWrapper.wrap(instance), excludeRef,\n                                XMLUtils.getNamespaceContext(paramElement));\n                        try {\n                            markedNodes.add(xpath.evaluateSingle());\n                        } finally {\n                            if (xpath != null) xpath.returnToPool();\n                        }\n                    }\n\n                    // See if all nodes are marked\n                    final boolean[] allMarked = { true };\n                    instance.accept(new VisitorSupport() {\n                        public void visit(Element node) {\n                            super.visit(node);\n                            if (node.elements().size() == 0 && !markedNodes.contains(node))\n                                allMarked[0] = false;\n                        }\n\n                        public void visit(Attribute node) {\n                            super.visit(node);\n                            if (!markedNodes.contains(node))\n                                allMarked[0] = false;\n                        }\n                    });\n\n                    // Output as SAX\n                    contentHandler.startDocument();\n                    contentHandler.startElement(\"\", PARAMETERS_ELEMENT, PARAMETERS_ELEMENT, XMLUtils.EMPTY_ATTRIBUTES);\n                    if (!allMarked[0]) {\n                        outputParameter(\"$instance\", XFormsUtils.instanceToString(instance), contentHandler);\n                    }\n                    contentHandler.endElement(\"\", PARAMETERS_ELEMENT, PARAMETERS_ELEMENT);\n                    contentHandler.endDocument();\n\n                } catch (Exception e) {\n                    throw new OXFException(e);\n                }\n            }\n        };\n        addOutput(OUTPUT_DATA, output);\n        return output;\n    }","id":99486,"modified_method":"public ProcessorOutput createOutput(String name) {\n        ProcessorOutput output = new ProcessorImpl.ProcessorOutputImpl(getClass(), name) {\n            public void readImpl(PipelineContext pipelineContext, final ContentHandler contentHandler) {\n                try {\n                    Element filterElement = readInputAsDOM4J(pipelineContext, INPUT_FILTER).getRootElement();\n                    Document instance = DocumentHelper.createDocument\n                            (readInputAsDOM4J(pipelineContext, INPUT_INSTANCE).getRootElement().createCopy());\n                    DocumentWrapper instanceWrapper = new DocumentWrapper(instance,\n                            ((LocationData) instance.getRootElement().getData()).getSystemID());\n\n                    // Mark all nodes referenced by XPath expressions\n                    final Set markedNodes = new HashSet();\n                    for (Iterator i = filterElement.elements().iterator(); i.hasNext();) {\n                        Element paramElement = (Element) i.next();\n                        Attribute refAttribute = paramElement.attribute(\"ref\");\n                        String excludeRef = refAttribute.getValue();\n                        PooledXPathExpression xpath = XPathCache.getXPathExpression(pipelineContext,\n                                instanceWrapper.wrap(instance), excludeRef,\n                                XMLUtils.getNamespaceContext(paramElement));\n                        try {\n                            markedNodes.add(xpath.evaluateSingle());\n                        } finally {\n                            if (xpath != null) xpath.returnToPool();\n                        }\n                    }\n\n                    // See if all nodes are marked\n                    final boolean[] allMarked = { true };\n                    instance.accept(new VisitorSupport() {\n                        public void visit(Element node) {\n                            super.visit(node);\n                            if (node.elements().size() == 0 && !markedNodes.contains(node))\n                                allMarked[0] = false;\n                        }\n\n                        public void visit(Attribute node) {\n                            super.visit(node);\n                            if (!markedNodes.contains(node))\n                                allMarked[0] = false;\n                        }\n                    });\n\n                    // Output as SAX\n                    contentHandler.startDocument();\n                    contentHandler.startElement(\"\", PARAMETERS_ELEMENT, PARAMETERS_ELEMENT, XMLUtils.EMPTY_ATTRIBUTES);\n                    if (!allMarked[0]) {\n                        String key = null;\n                        if (XFormsUtils.isHiddenEncryptionEnabled() || XFormsUtils.isNameEncryptionEnabled()) {\n                            key = SecureUtils.generateRandomPassword();\n                            String serverPassword = OXFProperties.instance().getPropertySet().getString(Constants.XFORMS_PASSWORD);\n                            outputParameter(\"$key\", SecureUtils.encrypt(pipelineContext, serverPassword, key), contentHandler);\n                        }\n                        outputParameter(\"$instance\", XFormsUtils.instanceToString(pipelineContext, key, instance), contentHandler);\n                    }\n                    contentHandler.endElement(\"\", PARAMETERS_ELEMENT, PARAMETERS_ELEMENT);\n                    contentHandler.endDocument();\n\n                } catch (Exception e) {\n                    throw new OXFException(e);\n                }\n            }\n        };\n        addOutput(OUTPUT_DATA, output);\n        return output;\n    }","commit_id":"a2b9e23d71884e4a88d7cfbd6af5553f2114f590","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public ContentHandler getContentHandlerForRequest() {\n        // NOTE: We do this \"by hand\" as the apache digester has problems including namespace\n        // handling and value whitespace trimming.\n\n        return new ContentHandlerAdapter() {\n            private Stack elementNameStack = new Stack();\n            private boolean recording = false;\n            private String recordingName;\n            private StringBuffer recordingValue;\n            private Attributes recordingAttributes;\n\n\n            public void characters(char ch[], int start, int length) {\n                if (recording)\n                    recordingValue.append(ch, start, length);\n            }\n\n            public void startElement(String namespaceURI, String localName, String qName, Attributes atts) {\n                if (isChildOfParameter()) {\n                    recording = true;\n                    recordingName = localName;\n                    recordingValue = new StringBuffer();\n                    recordingAttributes = new AttributesImpl(atts);\n                }\n                elementNameStack.add(localName);\n            }\n\n            public void endElement(String namespaceURI, String localName, String qName) {\n                elementNameStack.pop();\n                if (isChildOfParameter()) {\n                    String value = recordingValue.toString();\n                    if (recordingName.equals(\"name\"))\n                        name(value);\n                    else if (recordingName.equals(\"value\"))\n                        value(value, recordingAttributes.getValue(XMLUtils.XSI_NAMESPACE, \"type\"));\n                    else if (recordingName.equals(\"filename\"))\n                        filename(value);\n                    else if (recordingName.equals(\"content-type\"))\n                        contentType(value);\n                    else if (recordingName.equals(\"content-length\"))\n                        contentLength(value);\n                }\n            }\n\n            private boolean isChildOfParameter() {\n                int size = elementNameStack.size();\n                return size == 3 && elementNameStack.elementAt(size - 1).equals(\"parameter\")\n                    && elementNameStack.elementAt(size - 2).equals(\"parameters\")\n                    && elementNameStack.elementAt(size - 3).equals(\"request\");\n            }\n\n            private String name;\n            private String fileName;\n            private String filenameName;\n            private String mediatypeName;\n            private String sizeName;\n\n            private void name(String name) {\n                // We know that name always come before all the other elements within a parameter,\n                // including the value element\n                this.name = name;\n\n                if (name.startsWith(\"$upload^\")) {\n                    // Handle the case of the upload element\n\n                    // Split encoded name\n                    String s = name.substring(\"$upload^\".length());\n                    fileName = s.substring(0, s.indexOf('-'));\n                    s = s.substring(s.indexOf('-') + 1);\n                    filenameName = s.substring(0, s.indexOf('-'));\n                    s = s.substring(s.indexOf('-') + 1);\n                    mediatypeName = s.substring(0, s.indexOf('-'));\n                    s = s.substring(s.indexOf('-') + 1);\n                    sizeName = s;\n                }\n            }\n\n            /**\n             * Handle request parameter\n             */\n            private void value(String value, String type) {\n                try {\n                    if (\"$instance\".equals(name)) {\n\n                        // Un-base64, uncompress to get XML as text\n                        final String xmlText;\n                        {\n                            ByteArrayInputStream compressedData = new ByteArrayInputStream(Base64.decode(value));\n                            StringBuffer xml = new StringBuffer();\n                            byte[] buffer = new byte[1024];\n                            GZIPInputStream gzipInputStream = new GZIPInputStream(compressedData);\n                            int size;\n                            while ((size = gzipInputStream.read(buffer)) != -1)\n                                xml.append(new String(buffer, 0, size));\n                            xmlText = xml.toString();\n                        }\n\n                        // Parse XML and store as instance\n                        LocationSAXContentHandler saxContentHandler = new LocationSAXContentHandler();\n                        XMLUtils.stringToSAX(xmlText, null, saxContentHandler, false);\n                        instance = saxContentHandler.getDocument();\n\n                    } else if (name.startsWith(\"$upload^\")) {\n                        // Store file in instance\n                        addValue(fileName, value, type);\n                    } else if (name.startsWith(\"$action^\") || name.startsWith(\"$actionImg^\")) {\n\n                        // Image submit. If .y: ignore. If .x: remove .x at the end of name.\n                        if (name.startsWith(\"$actionImg^\")) {\n                            if (name.endsWith(\".y\")) return;\n                            name = name.substring(0, name.length() - 2);\n                        }\n\n                        // Separate different action, e.g.: $action^action1&action_2\n                        StringTokenizer actionsTokenizer = new StringTokenizer(name.substring(name.indexOf('^') + 1), \"&\");\n                        while (actionsTokenizer.hasMoreTokens()) {\n\n                            // Parse an action string, e.g.: name&param1Name&param1Value&param2Name&param2Value\n                            String actionString = URLDecoder.decode(actionsTokenizer.nextToken(), NetUtils.DEFAULT_URL_ENCODING);\n                            String[] keyValue = new String[2];\n                            String actionName = null;\n                            Map actionParameters = new HashMap();\n                            while (actionString.length() > 0) {\n                                for (int i = 0; i < 2; i++) {\n                                    int firstDelimiter = actionString.indexOf('&');\n                                    keyValue[i] = firstDelimiter == -1 ? actionString\n                                            : actionString.substring(0, firstDelimiter);\n                                    actionString = firstDelimiter == -1 ? \"\"\n                                            : actionString.substring(firstDelimiter + 1);\n                                    if (actionName == null) break;\n                                }\n                                if (actionName == null) {\n                                    actionName = keyValue[0];\n                                } else {\n                                    // We used to do URLDecoder.decode(keyValue[1], NetUtils.DEFAULT_URL_ENCODING) but this was once too many times\n                                    actionParameters.put(keyValue[0], keyValue[1]);\n                                }\n                            }\n\n                            // Create action object\n                            Class actionClass = (Class) actionClasses.get(actionName);\n                            if  (actionClass == null)\n                                throw new OXFException(\"Cannot find implementation for action '\" + actionName + \"'\");\n                            Action action = (Action) actionClass.newInstance();\n                            action.setParameters(actionParameters);\n                            actions.add(action);\n                        }\n                    } else if (name.startsWith(\"$node^\")) {\n                        addValue(name, value, type);\n                    }\n                } catch (InstantiationException e) {\n                    throw new OXFException(e);\n                } catch (IllegalAccessException e) {\n                    throw new OXFException(e);\n                } catch (UnsupportedEncodingException e) {\n                    throw new OXFException(e);\n                } catch (IOException e) {\n                    throw new OXFException(e);\n                }\n            }\n\n            private void filename(String filename) {\n                if (name.startsWith(\"$upload^\") && filenameName.length() > 0) {\n                    addValue(filenameName, filename, null);\n                }\n            }\n\n            private void contentType(String contentType) {\n                if (name.startsWith(\"$upload^\") && mediatypeName.length() > 0) {\n                    addValue(mediatypeName, contentType, null);\n                }\n            }\n\n            private void contentLength(String contentLength) {\n                if (name.startsWith(\"$upload^\") && sizeName.length() > 0) {\n                    addValue(sizeName, contentLength, null);\n                }\n            }\n        };\n    }","id":99487,"modified_method":"public ContentHandler getContentHandlerForRequest() {\n        // NOTE: We do this \"by hand\" as the apache digester has problems including namespace\n        // handling and value whitespace trimming.\n\n        return new ContentHandlerAdapter() {\n            private Stack elementNameStack = new Stack();\n            private boolean recording = false;\n            private String recordingName;\n            private StringBuffer recordingValue;\n            private Attributes recordingAttributes;\n\n\n            public void characters(char ch[], int start, int length) {\n                if (recording)\n                    recordingValue.append(ch, start, length);\n            }\n\n            public void startElement(String namespaceURI, String localName, String qName, Attributes atts) {\n                if (isChildOfParameter()) {\n                    recording = true;\n                    recordingName = localName;\n                    recordingValue = new StringBuffer();\n                    recordingAttributes = new AttributesImpl(atts);\n                }\n                elementNameStack.add(localName);\n            }\n\n            public void endElement(String namespaceURI, String localName, String qName) {\n                elementNameStack.pop();\n                if (isChildOfParameter()) {\n                    String value = recordingValue.toString();\n                    if (recordingName.equals(\"name\"))\n                        name(value);\n                    else if (recordingName.equals(\"value\"))\n                        value(value, recordingAttributes.getValue(XMLUtils.XSI_NAMESPACE, \"type\"));\n                    else if (recordingName.equals(\"filename\"))\n                        filename(value);\n                    else if (recordingName.equals(\"content-type\"))\n                        contentType(value);\n                    else if (recordingName.equals(\"content-length\"))\n                        contentLength(value);\n                }\n            }\n\n            private boolean isChildOfParameter() {\n                int size = elementNameStack.size();\n                return size == 3 && elementNameStack.elementAt(size - 1).equals(\"parameter\")\n                    && elementNameStack.elementAt(size - 2).equals(\"parameters\")\n                    && elementNameStack.elementAt(size - 3).equals(\"request\");\n            }\n\n            private String name;\n            private String fileName;\n            private String filenameName;\n            private String mediatypeName;\n            private String sizeName;\n\n            private void name(String name) {\n                // We know that name always come before all the other elements within a parameter,\n                // including the value element\n                this.name = name;\n\n                if (name.startsWith(\"$upload^\")) {\n                    // Handle the case of the upload element\n\n                    // Split encoded name\n                    String s = name.substring(\"$upload^\".length());\n                    fileName = s.substring(0, s.indexOf('-'));\n                    s = s.substring(s.indexOf('-') + 1);\n                    filenameName = s.substring(0, s.indexOf('-'));\n                    s = s.substring(s.indexOf('-') + 1);\n                    mediatypeName = s.substring(0, s.indexOf('-'));\n                    s = s.substring(s.indexOf('-') + 1);\n                    sizeName = s;\n                }\n            }\n\n            /**\n             * Handle request parameter\n             */\n            private void value(String value, String type) {\n                try {\n                    if (\"$key\".equals(name)) {\n                        String serverPassword = OXFProperties.instance().getPropertySet().getString(Constants.XFORMS_PASSWORD);\n                        encryptionPassword = SecureUtils.decrypt(pipelineContext, serverPassword, value);\n                    } else if (\"$instance\".equals(name)) {\n\n                        // Un-base64, uncompress to get XML as text\n                        String xmlText;\n                        {\n                            String compressed = value;\n                            if (XFormsUtils.isHiddenEncryptionEnabled())\n                                compressed = SecureUtils.decrypt(pipelineContext, encryptionPassword, compressed);\n                            ByteArrayInputStream compressedData = new ByteArrayInputStream(Base64.decode(compressed));\n                            StringBuffer xml = new StringBuffer();\n                            byte[] buffer = new byte[1024];\n                            GZIPInputStream gzipInputStream = new GZIPInputStream(compressedData);\n                            int size;\n                            while ((size = gzipInputStream.read(buffer)) != -1)\n                                xml.append(new String(buffer, 0, size));\n                            xmlText = xml.toString();\n                        }\n\n                        // Parse XML and store as instance\n                        LocationSAXContentHandler saxContentHandler = new LocationSAXContentHandler();\n                        XMLUtils.stringToSAX(xmlText, null, saxContentHandler, false);\n                        instance = saxContentHandler.getDocument();\n\n                    } else if (name.startsWith(\"$upload^\")) {\n                        // Store file in instance\n                        addValue(fileName, value, type);\n                    } else if (name.startsWith(\"$action^\") || name.startsWith(\"$actionImg^\")) {\n\n                        // Image submit. If .y: ignore. If .x: remove .x at the end of name.\n                        if (name.startsWith(\"$actionImg^\")) {\n                            if (name.endsWith(\".y\")) return;\n                            name = name.substring(0, name.length() - 2);\n                        }\n\n                        // Separate different action, e.g.: $action^action1&action_2\n                        StringTokenizer actionsTokenizer = new StringTokenizer(name.substring(name.indexOf('^') + 1), \"&\");\n                        while (actionsTokenizer.hasMoreTokens()) {\n\n                            // Parse an action string, e.g.: name&param1Name&param1Value&param2Name&param2Value\n                            String actionString = URLDecoder.decode(actionsTokenizer.nextToken(), NetUtils.DEFAULT_URL_ENCODING);\n                            String[] keyValue = new String[2];\n                            String actionName = null;\n                            Map actionParameters = new HashMap();\n                            while (actionString.length() > 0) {\n                                for (int i = 0; i < 2; i++) {\n                                    int firstDelimiter = actionString.indexOf('&');\n                                    keyValue[i] = firstDelimiter == -1 ? actionString\n                                            : actionString.substring(0, firstDelimiter);\n                                    actionString = firstDelimiter == -1 ? \"\"\n                                            : actionString.substring(firstDelimiter + 1);\n                                    if (actionName == null) break;\n                                }\n                                if (actionName == null) {\n                                    actionName = keyValue[0];\n                                } else {\n                                    // We used to do URLDecoder.decode(keyValue[1], NetUtils.DEFAULT_URL_ENCODING) but this was once too many times\n                                    actionParameters.put(keyValue[0], keyValue[1]);\n                                }\n                            }\n\n                            // Create action object\n                            Class actionClass = (Class) actionClasses.get(actionName);\n                            if  (actionClass == null)\n                                throw new OXFException(\"Cannot find implementation for action '\" + actionName + \"'\");\n                            Action action = (Action) actionClass.newInstance();\n                            action.setParameters(actionParameters);\n                            actions.add(action);\n                        }\n                    } else if (name.startsWith(\"$node^\")) {\n                        addValue(name, value, type);\n                    }\n                } catch (InstantiationException e) {\n                    throw new OXFException(e);\n                } catch (IllegalAccessException e) {\n                    throw new OXFException(e);\n                } catch (UnsupportedEncodingException e) {\n                    throw new OXFException(e);\n                } catch (IOException e) {\n                    throw new OXFException(e);\n                }\n            }\n\n            private void filename(String filename) {\n                if (name.startsWith(\"$upload^\") && filenameName.length() > 0) {\n                    addValue(filenameName, filename, null);\n                }\n            }\n\n            private void contentType(String contentType) {\n                if (name.startsWith(\"$upload^\") && mediatypeName.length() > 0) {\n                    addValue(mediatypeName, contentType, null);\n                }\n            }\n\n            private void contentLength(String contentLength) {\n                if (name.startsWith(\"$upload^\") && sizeName.length() > 0) {\n                    addValue(sizeName, contentLength, null);\n                }\n            }\n\n            /**\n             * Adds (id -> value) in idToValue. If there is already a value for this id,\n             * concatenates the two values by adding a space.\n             *\n             * Also store the value type in idToType if present.\n             */\n            private void addValue(String name, String value, String type) {\n                String idString = name.substring(\"$node^\".length());\n                if (XFormsUtils.isNameEncryptionEnabled())\n                    idString = SecureUtils.decrypt(pipelineContext, encryptionPassword, idString);\n                Integer idObject = new Integer(idString);\n                String currentValue = (String) idToValue.get(idObject);\n                idToValue.put(idObject,\n                        currentValue == null || \"\".equals(currentValue) ? value :\n                        \"\".equals(value) ? currentValue : currentValue + ' ' + value);\n                if (type != null)\n                    idToType.put(idObject, type);\n            }\n        };\n    }","commit_id":"a2b9e23d71884e4a88d7cfbd6af5553f2114f590","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private void encrypt() {\n        try {\n            FileOutputStream archiveFile = new FileOutputStream(archiveName);\n\n            ZipOutputStream zip = new ZipOutputStream(new CipherOutputStream(archiveFile,\n                    SecureUtils.getEncryptingCipher(SecureResourceManagerImpl.getPassword())));\n            File rr = new File(resourceRoot);\n            archiveAndEncrypt(rr, zip);\n            zip.finish();\n            zip.close();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }","id":99488,"modified_method":"private void encrypt() {\n        try {\n            FileOutputStream archiveFile = new FileOutputStream(archiveName);\n\n            ZipOutputStream zip = new ZipOutputStream(new CipherOutputStream(archiveFile,\n                    SecureUtils.getEncryptingCipher(SecureResourceManagerImpl.getPassword(), true)));\n            File rr = new File(resourceRoot);\n            archiveAndEncrypt(rr, zip);\n            zip.finish();\n            zip.close();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"a2b9e23d71884e4a88d7cfbd6af5553f2114f590","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private void view() {\n        try {\n            FileInputStream archiveFile = new FileInputStream(archiveName);\n            ZipInputStream zip = new ZipInputStream(new CipherInputStream\n                    (archiveFile, SecureUtils.getDecryptingCipher(SecureResourceManagerImpl.getPassword())));\n            ZipEntry ze;\n            while ((ze = zip.getNextEntry()) != null) {\n                System.out.println(\"entry: \" + ze.getName());\n\n            }\n            zip.close();\n\n\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n\n    }","id":99489,"modified_method":"private void view() {\n        try {\n            FileInputStream archiveFile = new FileInputStream(archiveName);\n            ZipInputStream zip = new ZipInputStream(new CipherInputStream\n                    (archiveFile, SecureUtils.getDecryptingCipher(SecureResourceManagerImpl.getPassword(), true)));\n            ZipEntry ze;\n            while ((ze = zip.getNextEntry()) != null) {\n                System.out.println(\"entry: \" + ze.getName());\n\n            }\n            zip.close();\n\n\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n\n    }","commit_id":"a2b9e23d71884e4a88d7cfbd6af5553f2114f590","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private void init(File archive) {\n        try {\n            resources = new HashMap();\n            FileInputStream archiveFile = new FileInputStream(archive);\n            ZipInputStream zip = new ZipInputStream(new CipherInputStream(archiveFile, \n                    SecureUtils.getDecryptingCipher(password)));\n\n            ZipEntry ze;\n            while ((ze = zip.getNextEntry()) != null) {\n                byte[] buff = new byte[1024];\n                int l;\n                ByteArrayOutputStream bos = new ByteArrayOutputStream();\n                while ((l = zip.read(buff)) != -1)\n                    bos.write(buff, 0, l);\n                bos.close();\n\n                resources.put(ze.getName(), new Value(new ByteArrayInputStream(bos.toByteArray()), bos.size()));\n            }\n            zip.close();\n        } catch (Exception e) {\n            throw new OXFException(e);\n        }\n    }","id":99490,"modified_method":"private void init(File archive) {\n        try {\n            resources = new HashMap();\n            FileInputStream archiveFile = new FileInputStream(archive);\n            ZipInputStream zip = new ZipInputStream(new CipherInputStream(archiveFile, \n                    SecureUtils.getDecryptingCipher(password, true)));\n\n            ZipEntry ze;\n            while ((ze = zip.getNextEntry()) != null) {\n                byte[] buff = new byte[1024];\n                int l;\n                ByteArrayOutputStream bos = new ByteArrayOutputStream();\n                while ((l = zip.read(buff)) != -1)\n                    bos.write(buff, 0, l);\n                bos.close();\n\n                resources.put(ze.getName(), new Value(new ByteArrayInputStream(bos.toByteArray()), bos.size()));\n            }\n            zip.close();\n        } catch (Exception e) {\n            throw new OXFException(e);\n        }\n    }","commit_id":"a2b9e23d71884e4a88d7cfbd6af5553f2114f590","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static Cipher getEncryptingCipher(String password) {\n        try {\n            synchronized(passwordToEncryptionCipher) {\n                Cipher cipher = (Cipher) passwordToEncryptionCipher.get(password);\n                if (cipher == null) {\n                    cipher = Cipher.getInstance(CIPHER_TYPE);\n                    cipher.init(Cipher.ENCRYPT_MODE, getSecretKey(password), pbeParamSpec);\n                    passwordToEncryptionCipher.put(password, cipher);\n                }\n                return cipher;\n            }\n        } catch (NoSuchAlgorithmException e) {\n            throw new OXFException(e);\n        } catch (NoSuchPaddingException e) {\n            throw new OXFException(e);\n        } catch (InvalidKeyException e) {\n            throw new OXFException(e);\n        } catch (InvalidAlgorithmParameterException e) {\n            throw new OXFException(e);\n        }\n    }","id":99491,"modified_method":"public static Cipher getEncryptingCipher(String password, boolean cacheCipher) {\n        try {\n            Cipher cipher;\n            if (cacheCipher) {\n                synchronized(passwordToEncryptionCipher) {\n                    cipher = (Cipher) passwordToEncryptionCipher.get(password);\n                    if (cipher == null) {\n                        cipher = Cipher.getInstance(CIPHER_TYPE);\n                        cipher.init(Cipher.ENCRYPT_MODE, getSecretKey(password), pbeParamSpec);\n                        passwordToEncryptionCipher.put(password, cipher);\n                    }\n                }\n            } else {\n                cipher = Cipher.getInstance(CIPHER_TYPE);\n                cipher.init(Cipher.ENCRYPT_MODE, getSecretKey(password), pbeParamSpec);\n            }\n            return cipher;\n        } catch (NoSuchAlgorithmException e) {\n            throw new OXFException(e);\n        } catch (NoSuchPaddingException e) {\n            throw new OXFException(e);\n        } catch (InvalidKeyException e) {\n            throw new OXFException(e);\n        } catch (InvalidAlgorithmParameterException e) {\n            throw new OXFException(e);\n        }\n    }","commit_id":"a2b9e23d71884e4a88d7cfbd6af5553f2114f590","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static Cipher getDecryptingCipher(String password) {\n        try {\n            synchronized(passwordToDecryptionCipher) {\n                Cipher cipher = (Cipher) passwordToDecryptionCipher.get(password);\n                if (cipher == null) {\n                    cipher = Cipher.getInstance(CIPHER_TYPE);\n                    cipher.init(Cipher.DECRYPT_MODE, getSecretKey(password), pbeParamSpec);\n                    passwordToDecryptionCipher.put(password, cipher);\n                }\n                return cipher;\n            }\n        } catch (NoSuchAlgorithmException e) {\n            throw new OXFException(e);\n        } catch (NoSuchPaddingException e) {\n            throw new OXFException(e);\n        } catch (InvalidKeyException e) {\n            throw new OXFException(e);\n        } catch (InvalidAlgorithmParameterException e) {\n            throw new OXFException(e);\n        }\n    }","id":99492,"modified_method":"public static Cipher getDecryptingCipher(String password, boolean cacheCipher) {\n        try {\n            Cipher cipher;\n            if (cacheCipher) {\n                synchronized(passwordToDecryptionCipher) {\n                    cipher = (Cipher) passwordToDecryptionCipher.get(password);\n                    if (cipher == null) {\n                        cipher = Cipher.getInstance(CIPHER_TYPE);\n                        cipher.init(Cipher.DECRYPT_MODE, getSecretKey(password), pbeParamSpec);\n                        passwordToDecryptionCipher.put(password, cipher);\n                    }\n                }\n            } else {\n                cipher = Cipher.getInstance(CIPHER_TYPE);\n                cipher.init(Cipher.DECRYPT_MODE, getSecretKey(password), pbeParamSpec);\n            }\n            return cipher;\n        } catch (NoSuchAlgorithmException e) {\n            throw new OXFException(e);\n        } catch (NoSuchPaddingException e) {\n            throw new OXFException(e);\n        } catch (InvalidKeyException e) {\n            throw new OXFException(e);\n        } catch (InvalidAlgorithmParameterException e) {\n            throw new OXFException(e);\n        }\n    }","commit_id":"a2b9e23d71884e4a88d7cfbd6af5553f2114f590","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void run(PipelineContext context, FunctionContext functionContext, Document instance) {\n        setValue.run(context, functionContext, instance);\n    }","id":99493,"modified_method":"public void run(PipelineContext context, FunctionContext functionContext, String encryptionPassword, Document instance) {\n        setValue.run(context, functionContext, encryptionPassword, instance);\n    }","commit_id":"a2b9e23d71884e4a88d7cfbd6af5553f2114f590","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void run(PipelineContext context, FunctionContext functionContext, Document instance) {\n    }","id":99494,"modified_method":"public void run(PipelineContext context, FunctionContext functionContext, String encryptionPassword, Document instance) {\n    }","commit_id":"a2b9e23d71884e4a88d7cfbd6af5553f2114f590","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void run(PipelineContext context, FunctionContext functionContext, Document instance) {\n\n        // Fill the instance\n        String[] ids = nodeset.split(\" \");\n        try {\n            Integer id = new Integer(Integer.parseInt(ids[0]));\n            Node node = (Node) ((InstanceData) instance.getRootElement().getData()).getIdToNodeMap().get(id);\n            String newValue = value != null ? value\n                    : content == null ? \"\" : content;\n            XFormsUtils.fillNode(node, newValue);\n        } catch (NumberFormatException e) {\n            throw new OXFException(\"Invalid node-id in setvalue action\", e);\n        }\n    }","id":99495,"modified_method":"public void run(PipelineContext context, FunctionContext functionContext, String encryptionPassword, Document instance) {\n\n        // Fill the instance\n        String[] ids = nodeset.split(\" \");\n        try {\n            String id = ids[0];\n            if (XFormsUtils.isNameEncryptionEnabled())\n                id = SecureUtils.decrypt(context, encryptionPassword, id);\n            Integer idInteger = new Integer(Integer.parseInt(id));\n            Node node = (Node) ((InstanceData) instance.getRootElement().getData()).getIdToNodeMap().get(idInteger);\n            String newValue = value != null ? value : content == null ? \"\" : content;\n            XFormsUtils.fillNode(node, newValue);\n        } catch (NumberFormatException e) {\n            throw new OXFException(\"Invalid node-id in setvalue action\", e);\n        }\n    }","commit_id":"a2b9e23d71884e4a88d7cfbd6af5553f2114f590","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void start(XFormsElementContext context, String uri, String localname,\n                      String qname, Attributes attributes) throws SAXException {\n        final AttributesImpl newAttributes = new AttributesImpl(attributes);\n        Map prefixToURI = context.getCurrentPrefixToURIMap();\n\n        if ((\"if\".equals(localname) || \"when\".equals(localname)) && Constants.XXFORMS_NAMESPACE_URI.equals(uri)) {\n            String test = attributes.getValue(\"test\");\n            PooledXPathExpression expr = XPathCache.getXPathExpression(context.getPipelineContext(),\n                    context.getDocumentWrapper().wrap(context.getCurrentSingleNode()),\n                    \"boolean(\" + test + \")\", prefixToURI, context.getRepeatIdToIndex());\n            try {\n                Boolean value = (Boolean) expr.evaluateSingle();\n                addExtensionAttribute(newAttributes, \"value\", Boolean.toString(value.booleanValue()));\n            } catch (XPathException e) {\n                throw new OXFException(e);\n            } finally {\n                if (expr != null)\n                    expr.returnToPool();\n            }\n        } else if (context.getParentElement(0) instanceof Itemset\n                && (\"copy\".equals(localname) || \"label\".equals(localname))) {\n            // Pass information about the \"ref\" on the element to the parent \"itemset\"\n            Itemset itemset = (Itemset) context.getParentElement(0);\n            if (\"copy\".equals(localname)) {\n                itemset.setCopyRef(attributes.getValue(\"ref\"), prefixToURI);\n            } else {\n                itemset.setLabelRef(attributes.getValue(\"ref\"), prefixToURI);\n            }\n        } else {\n            // Add annotations about referenced element\n            boolean bindPresent = attributes.getIndex(\"\", \"bind\") != -1;\n            boolean refPresent = attributes.getIndex(\"\", \"ref\") != -1;\n            boolean nodesetPresent = attributes.getIndex(\"\", \"nodeset\") != -1;\n            boolean positionPresent = attributes.getIndex(Constants.XXFORMS_NAMESPACE_URI, \"position\") != -1;\n            if (refPresent || bindPresent || nodesetPresent || positionPresent) {\n                InstanceData currentNodeInstanceData = XFormsUtils.getInstanceData(context.getCurrentSingleNode());\n                addExtensionAttribute(newAttributes, Constants.XXFORMS_READONLY_ATTRIBUTE_NAME,\n                        Boolean.toString(currentNodeInstanceData.getReadonly().get()));\n                addExtensionAttribute(newAttributes, Constants.XXFORMS_RELEVANT_ATTRIBUTE_NAME,\n                        Boolean.toString(currentNodeInstanceData.getRelevant().get()));\n                addExtensionAttribute(newAttributes, Constants.XXFORMS_REQUIRED_ATTRIBUTE_NAME,\n                        Boolean.toString(currentNodeInstanceData.getRequired().get()));\n                addExtensionAttribute(newAttributes, Constants.XXFORMS_VALID_ATTRIBUTE_NAME,\n                        Boolean.toString(currentNodeInstanceData.getValid().get()));\n                if (currentNodeInstanceData.getInvalidBindIds() != null)\n                    addExtensionAttribute(newAttributes, Constants.XXFORMS_INVALID_BIND_IDS_ATTRIBUTE_NAME, currentNodeInstanceData.getInvalidBindIds());\n                if (DATA_CONTROLS.containsKey(localname)) {\n                    currentNodeInstanceData.setGenerated(true);\n                    addExtensionAttribute(newAttributes, \"name\", \"$node^\" + Integer.toString(currentNodeInstanceData.getId()));\n                    addExtensionAttribute(newAttributes, \"value\", context.getRefValue());\n                } else  if (ACTION_CONTROLS.containsKey(localname)) {\n                    addExtensionAttribute(newAttributes, \"value\", context.getRefValue());\n                }\n\n                if(!positionPresent) {\n                    // Get ids of node\n                    StringBuffer ids = new StringBuffer();\n                    boolean first = true;\n                    for (Iterator i = context.getCurrentNodeset().iterator(); i.hasNext();) {\n                        Node node = (Node) i.next();\n                        if (!first) ids.append(' '); else first = false;\n                        ids.append(XFormsUtils.getInstanceData(node).getId());\n                    }\n                    addExtensionAttribute(newAttributes, Constants.XXFORMS_NODE_IDS_ATTRIBUTE_NAME, ids.toString());\n\n                }\n            }\n\n            if (attributes.getIndex(\"\", \"at\") != -1) {\n                // Evaluate \"at\" as a number\n                NodeInfo contextNode = context.getDocumentWrapper().wrap(context.getCurrentSingleNode());\n                PooledXPathExpression expr = XPathCache.getXPathExpression(context.getPipelineContext(),\n                        contextNode,\n                        \"round(\" + attributes.getValue(\"at\") + \")\",\n                        context.getCurrentPrefixToURIMap(),\n                        null,\n                        context.getFunctionLibrary());\n                try {\n                    Object at = expr.evaluateSingle();\n                    if (!(at instanceof Number))\n                        throw new ValidationException(\"'at' expression must return a number\",\n                                new LocationData(context.getLocator()));\n                    addExtensionAttribute(newAttributes, \"at-value\", at.toString());\n                } catch (XPathException e) {\n                    throw new OXFException(e);\n                } finally {\n                    if (expr != null)\n                        expr.returnToPool();\n                }\n            }\n            if (attributes.getIndex(\"\", \"value\") != -1) {\n                // Evaluate \"value\" as a string\n                PooledXPathExpression expr = XPathCache.getXPathExpression(context.getPipelineContext(),\n                        context.getDocumentWrapper().wrap(context.getCurrentSingleNode()),\n                        \"string(\" + attributes.getValue(\"value\") + \")\",\n                        context.getCurrentPrefixToURIMap(),\n                        null,\n                        context.getFunctionLibrary());\n                try {\n                    Object value = expr.evaluateSingle();\n                    if (!(value instanceof String))\n                        throw new ValidationException(\"'value' expression must return a string\",\n                                new LocationData(context.getLocator()));\n\n                    addExtensionAttribute(newAttributes, \"value-value\", (String) value);\n                } catch (XPathException e) {\n                    throw new OXFException(e);\n                } finally {\n                    if(expr != null)\n                        expr.returnToPool();\n                }\n            }\n            // Linking attribute: load content to xxforms:src-value\n            if(attributes.getIndex(\"\", \"src\") != -1 && LINKING_CONTROLS.containsKey(localname)) {\n                try {\n                    String src = attributes.getValue(\"src\");\n                    // TODO: We don't support relative URL here because the locator is often null after an XSL transformation\n                    URL url = URLFactory.createURL(src);\n\n                    // Load file into buffer\n                    InputStreamReader stream = new InputStreamReader(url.openStream());\n                    StringBuffer value = new StringBuffer();\n                    char[] buff = new char[BUFFER_SIZE];\n                    int c = 0;\n                    while( (c = stream.read(buff, 0, BUFFER_SIZE-1)) != -1)\n                        value.append(buff);\n\n                    addExtensionAttribute(newAttributes, \"src-value\", value.toString());\n                } catch (MalformedURLException e) {\n                    throw new OXFException(e);\n                } catch (IOException ioe) {\n                    throw new OXFException(ioe);\n                }\n            }\n        }\n        context.getContentHandler().startElement(uri, localname, qname, newAttributes);\n    }","id":99496,"modified_method":"public void start(XFormsElementContext context, String uri, String localname,\n                      String qname, Attributes attributes) throws SAXException {\n        final AttributesImpl newAttributes = new AttributesImpl(attributes);\n        Map prefixToURI = context.getCurrentPrefixToURIMap();\n\n        if ((\"if\".equals(localname) || \"when\".equals(localname)) && Constants.XXFORMS_NAMESPACE_URI.equals(uri)) {\n            String test = attributes.getValue(\"test\");\n            PooledXPathExpression expr = XPathCache.getXPathExpression(context.getPipelineContext(),\n                    context.getDocumentWrapper().wrap(context.getCurrentSingleNode()),\n                    \"boolean(\" + test + \")\", prefixToURI, context.getRepeatIdToIndex());\n            try {\n                Boolean value = (Boolean) expr.evaluateSingle();\n                addExtensionAttribute(newAttributes, \"value\", Boolean.toString(value.booleanValue()));\n            } catch (XPathException e) {\n                throw new OXFException(e);\n            } finally {\n                if (expr != null)\n                    expr.returnToPool();\n            }\n        } else if (context.getParentElement(0) instanceof Itemset\n                && (\"copy\".equals(localname) || \"label\".equals(localname))) {\n            // Pass information about the \"ref\" on the element to the parent \"itemset\"\n            Itemset itemset = (Itemset) context.getParentElement(0);\n            if (\"copy\".equals(localname)) {\n                itemset.setCopyRef(attributes.getValue(\"ref\"), prefixToURI);\n            } else {\n                itemset.setLabelRef(attributes.getValue(\"ref\"), prefixToURI);\n            }\n        } else {\n            // Add annotations about referenced element\n            boolean bindPresent = attributes.getIndex(\"\", \"bind\") != -1;\n            boolean refPresent = attributes.getIndex(\"\", \"ref\") != -1;\n            boolean nodesetPresent = attributes.getIndex(\"\", \"nodeset\") != -1;\n            boolean positionPresent = attributes.getIndex(Constants.XXFORMS_NAMESPACE_URI, \"position\") != -1;\n            if (refPresent || bindPresent || nodesetPresent || positionPresent) {\n                InstanceData currentNodeInstanceData = XFormsUtils.getInstanceData(context.getCurrentSingleNode());\n                addExtensionAttribute(newAttributes, Constants.XXFORMS_READONLY_ATTRIBUTE_NAME,\n                        Boolean.toString(currentNodeInstanceData.getReadonly().get()));\n                addExtensionAttribute(newAttributes, Constants.XXFORMS_RELEVANT_ATTRIBUTE_NAME,\n                        Boolean.toString(currentNodeInstanceData.getRelevant().get()));\n                addExtensionAttribute(newAttributes, Constants.XXFORMS_REQUIRED_ATTRIBUTE_NAME,\n                        Boolean.toString(currentNodeInstanceData.getRequired().get()));\n                addExtensionAttribute(newAttributes, Constants.XXFORMS_VALID_ATTRIBUTE_NAME,\n                        Boolean.toString(currentNodeInstanceData.getValid().get()));\n                if (currentNodeInstanceData.getInvalidBindIds() != null)\n                    addExtensionAttribute(newAttributes, Constants.XXFORMS_INVALID_BIND_IDS_ATTRIBUTE_NAME, currentNodeInstanceData.getInvalidBindIds());\n                if (DATA_CONTROLS.containsKey(localname)) {\n                    currentNodeInstanceData.setGenerated(true);\n                    String id = Integer.toString(currentNodeInstanceData.getId());\n                    if (XFormsUtils.isNameEncryptionEnabled())\n                        id = SecureUtils.encrypt(context.getPipelineContext(), context.getEncryptionPassword(), id);\n                    addExtensionAttribute(newAttributes, \"name\", \"$node^\" + id);\n                    addExtensionAttribute(newAttributes, \"value\", context.getRefValue());\n                } else  if (ACTION_CONTROLS.containsKey(localname)) {\n                    addExtensionAttribute(newAttributes, \"value\", context.getRefValue());\n                }\n\n                if(!positionPresent) {\n                    // Get ids of node\n                    StringBuffer ids = new StringBuffer();\n                    boolean first = true;\n                    for (Iterator i = context.getCurrentNodeset().iterator(); i.hasNext();) {\n                        Node node = (Node) i.next();\n                        if (!first) ids.append(' '); else first = false;\n                        String id = Integer.toString(XFormsUtils.getInstanceData(node).getId());\n                        if (XFormsUtils.isNameEncryptionEnabled())\n                            id = SecureUtils.encrypt(context.getPipelineContext(), context.getEncryptionPassword(), id);\n                        ids.append(id);\n                    }\n                    addExtensionAttribute(newAttributes, Constants.XXFORMS_NODE_IDS_ATTRIBUTE_NAME, ids.toString());\n\n                }\n            }\n\n            if (attributes.getIndex(\"\", \"at\") != -1) {\n                // Evaluate \"at\" as a number\n                NodeInfo contextNode = context.getDocumentWrapper().wrap(context.getCurrentSingleNode());\n                PooledXPathExpression expr = XPathCache.getXPathExpression(context.getPipelineContext(),\n                        contextNode,\n                        \"round(\" + attributes.getValue(\"at\") + \")\",\n                        context.getCurrentPrefixToURIMap(),\n                        null,\n                        context.getFunctionLibrary());\n                try {\n                    Object at = expr.evaluateSingle();\n                    if (!(at instanceof Number))\n                        throw new ValidationException(\"'at' expression must return a number\",\n                                new LocationData(context.getLocator()));\n                    String atString = at.toString();\n                    if (XFormsUtils.isNameEncryptionEnabled())\n                        atString = SecureUtils.encrypt(context.getPipelineContext(),\n                                context.getEncryptionPassword(), atString);\n                    addExtensionAttribute(newAttributes, \"at-value\", atString);\n                } catch (XPathException e) {\n                    throw new OXFException(e);\n                } finally {\n                    if (expr != null)\n                        expr.returnToPool();\n                }\n            }\n            if (attributes.getIndex(\"\", \"value\") != -1) {\n                // Evaluate \"value\" as a string\n                PooledXPathExpression expr = XPathCache.getXPathExpression(context.getPipelineContext(),\n                        context.getDocumentWrapper().wrap(context.getCurrentSingleNode()),\n                        \"string(\" + attributes.getValue(\"value\") + \")\",\n                        context.getCurrentPrefixToURIMap(),\n                        null,\n                        context.getFunctionLibrary());\n                try {\n                    Object value = expr.evaluateSingle();\n                    if (!(value instanceof String))\n                        throw new ValidationException(\"'value' expression must return a string\",\n                                new LocationData(context.getLocator()));\n\n                    addExtensionAttribute(newAttributes, \"value-value\", (String) value);\n                } catch (XPathException e) {\n                    throw new OXFException(e);\n                } finally {\n                    if(expr != null)\n                        expr.returnToPool();\n                }\n            }\n            // Linking attribute: load content to xxforms:src-value\n            if(attributes.getIndex(\"\", \"src\") != -1 && LINKING_CONTROLS.containsKey(localname)) {\n                try {\n                    String src = attributes.getValue(\"src\");\n                    URL url = URLFactory.createURL(src);\n\n                    // Load file into buffer\n                    InputStreamReader stream = new InputStreamReader(url.openStream());\n                    StringBuffer value = new StringBuffer();\n                    char[] buff = new char[BUFFER_SIZE];\n                    int c = 0;\n                    while( (c = stream.read(buff, 0, BUFFER_SIZE-1)) != -1)\n                        value.append(buff, 0, c);\n\n                    addExtensionAttribute(newAttributes, \"src-value\", value.toString());\n                } catch (MalformedURLException e) {\n                    throw new OXFException(e);\n                } catch (IOException ioe) {\n                    throw new OXFException(ioe);\n                }\n            }\n        }\n        context.getContentHandler().startElement(uri, localname, qname, newAttributes);\n    }","commit_id":"a2b9e23d71884e4a88d7cfbd6af5553f2114f590","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public XFormsElementContext(PipelineContext pipelineContext, ContentHandler contentHandler, Model model, Document instance) {\n        this.pipelineContext = pipelineContext;\n        this.contentHandler = contentHandler;\n        this.model = model;\n        this.instance = instance;\n        this.documentWrapper = new DocumentWrapper(instance, null);\n    }","id":99497,"modified_method":"public XFormsElementContext(PipelineContext pipelineContext, ContentHandler contentHandler,\n                                Model model, Document instance) {\n        this.pipelineContext = pipelineContext;\n        this.contentHandler = contentHandler;\n        this.model = model;\n        this.instance = instance;\n        this.documentWrapper = new DocumentWrapper(instance, null);\n        this.encryptionPassword = SecureUtils.generateRandomPassword();\n    }","commit_id":"a2b9e23d71884e4a88d7cfbd6af5553f2114f590","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public ProcessorOutput createOutput(String name) {\n        ProcessorOutput output = new ProcessorImpl.CacheableTransformerOutputImpl(getClass(), name) {\n            public void readImpl(final PipelineContext pipelineContext, ContentHandler contentHandler) {\n\n                // Extract information from XForms model\n                Model model = (Model) readCacheInputAsObject(pipelineContext, getInputByName(INPUT_MODEL), new CacheableInputReader(){\n                    public Object read(PipelineContext context, ProcessorInput input) {\n                        Model model = new Model(pipelineContext, readInputAsDOM4J(context, input));\n                        return model;\n                    }\n                });\n\n                // Extract parameters from request\n                RequestParameters requestParameters = (RequestParameters) readCacheInputAsObject(pipelineContext,  getInputByName(INPUT_REQUEST), new CacheableInputReader(){\n                    public Object read(PipelineContext context, ProcessorInput input) {\n                        RequestParameters requestParameters = new RequestParameters();\n                        readInputAsSAX(context, input, requestParameters.getContentHandlerForRequest());\n                        return requestParameters;\n                    }\n                });\n\n                // Try to get instance document from context\n                Instance instance = Instance.createInstanceFromContext(pipelineContext);\n\n                if (instance == null) {\n                    // Get instance from XForms model or from request\n                    instance = new Instance(pipelineContext, requestParameters.getInstance() != null\n                            ? requestParameters.getInstance() : model.getInitialInstance());\n\n                    // Fill-out instance from request\n                    XFormsUtils.setInitialDecoration(instance.getDocument());\n                    int[] ids = requestParameters.getIds();\n                    for (int i = 0; i < ids.length; i++) {\n                        int id = ids[i];\n                        instance.setValueForId(id, requestParameters.getValue(id), requestParameters.getType(id));\n                    }\n\n                    // Fill-out instance from path info\n                    {\n                        final List groupElements = readCacheInputAsDOM4J\n                                (pipelineContext, INPUT_MATCHER_RESULT).getRootElement().elements(\"group\");\n                        final List paramElements = readCacheInputAsDOM4J\n                                (pipelineContext, INPUT_FILTER).getRootElement().elements(\"param\");\n                        if (groupElements.size() != paramElements.size())\n                            throw new OXFException(\"Number of parameters does not match number of groups in path expression\");\n                        for (Iterator paramIterator = paramElements.iterator(),\n                                groupIterator = groupElements.iterator(); paramIterator.hasNext();) {\n                            Element paramElement = (Element) paramIterator.next();\n                            Element groupElement = (Element) groupIterator.next();\n                            String value = groupElement.getStringValue();\n                            if (!\"\".equals(value))\n                                instance.setValueForParam(pipelineContext, paramElement.attributeValue(\"ref\"),\n                                        XMLUtils.getNamespaceContext(paramElement), value);\n                        }\n                    }\n\n                    if (logger.isDebugEnabled())\n                        logger.debug(\"1) Instance recontructed from request:\\n\"\n                                + XMLUtils.domToString(instance.getDocument()));\n\n                    // Run actions\n                    Action[] actions = requestParameters.getActions();\n                    for (int i = 0; i < actions.length; i++) {\n                        Action action = actions[i];\n                        action.run(pipelineContext, new ActionFunctionContext(), instance.getDocument());\n                    }\n                    if (logger.isDebugEnabled())\n                        logger.debug(\"2) Instance with actions applied:\\n\"\n                                + XMLUtils.domToString(instance.getDocument()));\n\n                    // Run model item properties\n                    model.applyInputOutputBinds(instance.getDocument());\n                    if (logger.isDebugEnabled())\n                        logger.debug(\"3) Instance with model item properties applied:\\n\"\n                                + XMLUtils.domToString(instance.getDocument()));\n                }\n\n                // Schema-validate if necessary\n                Boolean enabled = getPropertySet().getBoolean(XFORMS_VALIDATION_FLAG, true);\n                if (enabled != null && enabled.booleanValue() && model.getSchema() != null) {\n\n                    Processor validator = new XFormsValidationProcessor(model.getSchema());\n                    Processor resourceGenerator = PipelineUtils.createURLGenerator(model.getSchema());\n                    PipelineUtils.connect(resourceGenerator, ProcessorImpl.OUTPUT_DATA, validator, XFormsValidationProcessor.INPUT_SCHEMA);\n                    PipelineUtils.connect(XFormsValidationProcessor.DECORATION_CONFIG, ProcessorImpl.OUTPUT_DATA,\n                            validator, ProcessorImpl.INPUT_CONFIG);\n                    DOMGenerator domGenerator = new DOMGenerator(instance.getDocument());\n                    PipelineUtils.connect(domGenerator, ProcessorImpl.OUTPUT_DATA, validator, ProcessorImpl.INPUT_DATA);\n                    ProcessorOutput validationOutput = validator.createOutput(ProcessorImpl.OUTPUT_DATA);\n                    validationOutput.read(pipelineContext, contentHandler);\n                } else {\n                    // Just output instance\n                    instance.read(contentHandler);\n                }\n            }\n        };\n        addOutput(name, output);\n        return output;\n    }","id":99498,"modified_method":"public ProcessorOutput createOutput(String name) {\n        ProcessorOutput output = new ProcessorImpl.CacheableTransformerOutputImpl(getClass(), name) {\n            public void readImpl(final PipelineContext pipelineContext, ContentHandler contentHandler) {\n\n                // Extract information from XForms model\n                Model model = (Model) readCacheInputAsObject(pipelineContext, getInputByName(INPUT_MODEL), new CacheableInputReader(){\n                    public Object read(PipelineContext context, ProcessorInput input) {\n                        Model model = new Model(pipelineContext, readInputAsDOM4J(context, input));\n                        return model;\n                    }\n                });\n\n                // Extract parameters from request\n                RequestParameters requestParameters = (RequestParameters) readCacheInputAsObject(pipelineContext,  getInputByName(INPUT_REQUEST), new CacheableInputReader(){\n                    public Object read(PipelineContext context, ProcessorInput input) {\n                        Document request = readInputAsDOM4J(context, input);\n                        RequestParameters requestParameters = new RequestParameters(pipelineContext);\n                        readInputAsSAX(context, input, requestParameters.getContentHandlerForRequest());\n                        return requestParameters;\n                    }\n                });\n\n                // Try to get instance document from context\n                Instance instance = Instance.createInstanceFromContext(pipelineContext);\n\n                if (instance == null) {\n                    // Get instance from XForms model or from request\n                    instance = new Instance(pipelineContext, requestParameters.getInstance() != null\n                            ? requestParameters.getInstance() : model.getInitialInstance());\n\n                    // Fill-out instance from request\n                    XFormsUtils.setInitialDecoration(instance.getDocument());\n                    int[] ids = requestParameters.getIds();\n                    for (int i = 0; i < ids.length; i++) {\n                        int id = ids[i];\n                        instance.setValueForId(id, requestParameters.getValue(id), requestParameters.getType(id));\n                    }\n\n                    // Fill-out instance from path info\n                    {\n                        final List groupElements = readCacheInputAsDOM4J\n                                (pipelineContext, INPUT_MATCHER_RESULT).getRootElement().elements(\"group\");\n                        final List paramElements = readCacheInputAsDOM4J\n                                (pipelineContext, INPUT_FILTER).getRootElement().elements(\"param\");\n                        if (groupElements.size() != paramElements.size())\n                            throw new OXFException(\"Number of parameters does not match number of groups in path expression\");\n                        for (Iterator paramIterator = paramElements.iterator(),\n                                groupIterator = groupElements.iterator(); paramIterator.hasNext();) {\n                            Element paramElement = (Element) paramIterator.next();\n                            Element groupElement = (Element) groupIterator.next();\n                            String value = groupElement.getStringValue();\n                            if (!\"\".equals(value))\n                                instance.setValueForParam(pipelineContext, paramElement.attributeValue(\"ref\"),\n                                        XMLUtils.getNamespaceContext(paramElement), value);\n                        }\n                    }\n\n                    if (logger.isDebugEnabled())\n                        logger.debug(\"1) Instance recontructed from request:\\n\"\n                                + XMLUtils.domToString(instance.getDocument()));\n\n                    // Run actions\n                    Action[] actions = requestParameters.getActions();\n                    for (int i = 0; i < actions.length; i++) {\n                        Action action = actions[i];\n                        action.run(pipelineContext, new ActionFunctionContext(),\n                                requestParameters.getEncryptionPassword(), instance.getDocument());\n                    }\n                    if (logger.isDebugEnabled())\n                        logger.debug(\"2) Instance with actions applied:\\n\"\n                                + XMLUtils.domToString(instance.getDocument()));\n\n                    // Run model item properties\n                    model.applyInputOutputBinds(instance.getDocument());\n                    if (logger.isDebugEnabled())\n                        logger.debug(\"3) Instance with model item properties applied:\\n\"\n                                + XMLUtils.domToString(instance.getDocument()));\n                }\n\n                // Schema-validate if necessary\n                Boolean enabled = getPropertySet().getBoolean(XFORMS_VALIDATION_FLAG, true);\n                if (enabled != null && enabled.booleanValue() && model.getSchema() != null) {\n\n                    Processor validator = new XFormsValidationProcessor(model.getSchema());\n                    Processor resourceGenerator = PipelineUtils.createURLGenerator(model.getSchema());\n                    PipelineUtils.connect(resourceGenerator, ProcessorImpl.OUTPUT_DATA, validator, XFormsValidationProcessor.INPUT_SCHEMA);\n                    PipelineUtils.connect(XFormsValidationProcessor.DECORATION_CONFIG, ProcessorImpl.OUTPUT_DATA,\n                            validator, ProcessorImpl.INPUT_CONFIG);\n                    DOMGenerator domGenerator = new DOMGenerator(instance.getDocument());\n                    PipelineUtils.connect(domGenerator, ProcessorImpl.OUTPUT_DATA, validator, ProcessorImpl.INPUT_DATA);\n                    ProcessorOutput validationOutput = validator.createOutput(ProcessorImpl.OUTPUT_DATA);\n                    validationOutput.read(pipelineContext, contentHandler);\n                } else {\n                    // Just output instance\n                    instance.read(contentHandler);\n                }\n            }\n        };\n        addOutput(name, output);\n        return output;\n    }","commit_id":"a2b9e23d71884e4a88d7cfbd6af5553f2114f590","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static String encrypt(String text) {\n        try {\n            final Cipher cipher = SecureUtils.getEncryptingCipher\n                (OXFProperties.instance().getPropertySet().getString(Constants.XFORMS_PASSWORD));\n            return Base64.encode(cipher.doFinal(text.toString().getBytes())).trim();\n        } catch (IllegalBlockSizeException e) {\n            throw new OXFException(e);\n        } catch (BadPaddingException e) {\n            throw new OXFException(e);\n        }\n    }","id":99499,"modified_method":"public static String instanceToString(PipelineContext pipelineContext, String password, Document instance) {\n        try {\n            ByteArrayOutputStream gzipByteArray = new ByteArrayOutputStream();\n            GZIPOutputStream gzipOutputStream = null;\n            gzipOutputStream = new GZIPOutputStream(gzipByteArray);\n            gzipOutputStream.write(XMLUtils.domToString(instance).getBytes());\n            gzipOutputStream.close();\n            String compressed = Base64.encode(gzipByteArray.toByteArray());\n            return XFormsUtils.isHiddenEncryptionEnabled()\n                ? SecureUtils.encrypt(pipelineContext, password, compressed)\n                : compressed;\n        } catch (IOException e) {\n            throw new OXFException(e);\n        }\n    }","commit_id":"a2b9e23d71884e4a88d7cfbd6af5553f2114f590","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public RewritableImportSection parse(XtextResource resource) {\n\t\t\tRewritableImportSection rewritableImportSection = new RewritableImportSection(\n\t\t\t\t\tresource,\n\t\t\t\t\timportsConfiguration,\n\t\t\t\t\timportsConfiguration.getImportSection(resource), \n\t\t\t\t\twhitespaceInformationProvider.getLineSeparatorInformation(resource.getURI()).getLineSeparator(), \n\t\t\t\t\tregionUtil);\n\t\t\treturn rewritableImportSection;\n\t\t}","id":99500,"modified_method":"public RewritableImportSection parse(XtextResource resource) {\n\t\t\tRewritableImportSection rewritableImportSection = new RewritableImportSection(\n\t\t\t\t\tresource,\n\t\t\t\t\timportsConfiguration,\n\t\t\t\t\timportsConfiguration.getImportSection(resource), \n\t\t\t\t\twhitespaceInformationProvider.getLineSeparatorInformation(resource.getURI()).getLineSeparator(), \n\t\t\t\t\tregionUtil, \n\t\t\t\t\tnameValueConverter);\n\t\t\treturn rewritableImportSection;\n\t\t}","commit_id":"6cc6360fa9be593c7db55b02e61ff15b62544624","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void appendImport(StringBuilder builder, XImportDeclaration newImportDeclaration) {\n\t\tbuilder.append(\"import \");\n\t\tif (newImportDeclaration.isStatic()) {\n\t\t\tbuilder.append(\"static \");\n\t\t\tif (newImportDeclaration.isExtension()) {\n\t\t\t\tbuilder.append(\"extension \");\n\t\t\t}\n\t\t}\n\t\tbuilder.append(newImportDeclaration.getImportedTypeName());\n\t\tif (newImportDeclaration.isStatic())\n\t\t\tbuilder.append(\".*\");\n\t\tbuilder.append(lineSeparator);\n\t}","id":99501,"modified_method":"protected void appendImport(StringBuilder builder, XImportDeclaration newImportDeclaration) {\n\t\tbuilder.append(\"import \");\n\t\tif (newImportDeclaration.isStatic()) {\n\t\t\tbuilder.append(\"static \");\n\t\t\tif (newImportDeclaration.isExtension()) {\n\t\t\t\tbuilder.append(\"extension \");\n\t\t\t}\n\t\t}\n\t\tString escapedTypeName = nameValueConverter.toString(newImportDeclaration.getImportedTypeName());\n\t\tbuilder.append(escapedTypeName);\n\t\tif (newImportDeclaration.isStatic())\n\t\t\tbuilder.append(\".*\");\n\t\tbuilder.append(lineSeparator);\n\t}","commit_id":"6cc6360fa9be593c7db55b02e61ff15b62544624","url":"https://github.com/eclipse/xtext"},{"original_method":"public RewritableImportSection createNewEmpty(XtextResource resource) {\n\t\t\tRewritableImportSection rewritableImportSection = new RewritableImportSection(\n\t\t\t\t\tresource,\n\t\t\t\t\timportsConfiguration,\n\t\t\t\t\tnull,\n\t\t\t\t\twhitespaceInformationProvider.getLineSeparatorInformation(resource.getURI()).getLineSeparator(), \n\t\t\t\t\tregionUtil);\n\t\t\trewritableImportSection.setSort(true);\n\t\t\treturn rewritableImportSection;\n\t\t}","id":99502,"modified_method":"public RewritableImportSection createNewEmpty(XtextResource resource) {\n\t\t\tRewritableImportSection rewritableImportSection = new RewritableImportSection(\n\t\t\t\t\tresource,\n\t\t\t\t\timportsConfiguration,\n\t\t\t\t\tnull,\n\t\t\t\t\twhitespaceInformationProvider.getLineSeparatorInformation(resource.getURI()).getLineSeparator(), \n\t\t\t\t\tregionUtil,\n\t\t\t\t\tnameValueConverter);\n\t\t\trewritableImportSection.setSort(true);\n\t\t\treturn rewritableImportSection;\n\t\t}","commit_id":"6cc6360fa9be593c7db55b02e61ff15b62544624","url":"https://github.com/eclipse/xtext"},{"original_method":"public RewritableImportSection(XtextResource resource, IImportsConfiguration importsConfiguration, \n\t\t\tXImportSection originalImportSection, String lineSeparator, ImportSectionRegionUtil regionUtil) {\n\t\tthis.resource = resource;\n\t\tthis.lineSeparator = lineSeparator;\n\t\tthis.regionUtil = regionUtil;\n\t\tthis.implicitlyImportedPackages = importsConfiguration.getImplicitlyImportedPackages(resource);\n\t\tif (originalImportSection != null) {\n\t\t\tfor (XImportDeclaration originalImportDeclaration : originalImportSection.getImportDeclarations()) {\n\t\t\t\tthis.originalImportDeclarations.add(originalImportDeclaration);\n\t\t\t\tif (originalImportDeclaration.isStatic()) {\n\t\t\t\t\tif (originalImportDeclaration.isExtension())\n\t\t\t\t\t\tstaticExtensionImports.add(originalImportDeclaration.getImportedType());\n\t\t\t\t\telse\n\t\t\t\t\t\tstaticImports.add(originalImportDeclaration.getImportedType());\n\t\t\t\t} else if(originalImportDeclaration.getImportedType() != null) {\n\t\t\t\t\tplainImports.put(originalImportDeclaration.getImportedType().getSimpleName(),\n\t\t\t\t\t\t\toriginalImportDeclaration.getImportedType());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":99503,"modified_method":"public RewritableImportSection(XtextResource resource, IImportsConfiguration importsConfiguration, \n\t\t\tXImportSection originalImportSection, String lineSeparator, ImportSectionRegionUtil regionUtil,\n\t\t\tIValueConverter<String> nameConverter) {\n\t\tthis.resource = resource;\n\t\tthis.lineSeparator = lineSeparator;\n\t\tthis.regionUtil = regionUtil;\n\t\tthis.nameValueConverter = nameConverter;\n\t\tthis.implicitlyImportedPackages = importsConfiguration.getImplicitlyImportedPackages(resource);\n\t\tif (originalImportSection != null) {\n\t\t\tfor (XImportDeclaration originalImportDeclaration : originalImportSection.getImportDeclarations()) {\n\t\t\t\tthis.originalImportDeclarations.add(originalImportDeclaration);\n\t\t\t\tif (originalImportDeclaration.isStatic()) {\n\t\t\t\t\tif (originalImportDeclaration.isExtension())\n\t\t\t\t\t\tstaticExtensionImports.add(originalImportDeclaration.getImportedType());\n\t\t\t\t\telse\n\t\t\t\t\t\tstaticImports.add(originalImportDeclaration.getImportedType());\n\t\t\t\t} else if(originalImportDeclaration.getImportedType() != null) {\n\t\t\t\t\tplainImports.put(originalImportDeclaration.getImportedType().getSimpleName(),\n\t\t\t\t\t\t\toriginalImportDeclaration.getImportedType());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"6cc6360fa9be593c7db55b02e61ff15b62544624","url":"https://github.com/eclipse/xtext"},{"original_method":"private Hashable initHelper(Token left, Token right, byte depth, byte max)\n    {\n        if (depth == max)\n            // we've reached the leaves\n            return new Leaf();\n        Token midpoint = partitioner.midpoint(left, right);\n\n        Hashable lchild = midpoint.equals(left) ? new Leaf() : initHelper(left, midpoint, inc(depth), max);\n        Hashable rchild =  midpoint.equals(right) ? new Leaf() : initHelper(midpoint, right, inc(depth), max);\n        return new Inner(midpoint, lchild, rchild);\n    }","id":99504,"modified_method":"private Hashable initHelper(Token left, Token right, byte depth, byte max)\n    {\n        if (depth == max)\n            // we've reached the leaves\n            return new Leaf();\n        Token midpoint = partitioner.midpoint(left, right);\n\n        if (midpoint.equals(left) || midpoint.equals(right))\n            return new Leaf();\n\n        Hashable lchild =  initHelper(left, midpoint, inc(depth), max);\n        Hashable rchild =  initHelper(midpoint, right, inc(depth), max);\n        return new Inner(midpoint, lchild, rchild);\n    }","commit_id":"203e2c2d9071fe003794d20cb92915d2e56b46c9","url":"https://github.com/apache/cassandra"},{"original_method":"private Hashable initHelper(Token left, Token right, byte depth, byte max)\n    {\n        if (depth == max)\n            // we've reached the leaves\n            return new Leaf();\n        Token midpoint = partitioner.midpoint(left, right);\n\n        Hashable lchild = midpoint.equals(left) ? new Leaf() : initHelper(left, midpoint, inc(depth), max);\n        Hashable rchild =  midpoint.equals(right) ? new Leaf() : initHelper(midpoint, right, inc(depth), max);\n        return new Inner(midpoint, lchild, rchild);\n    }","id":99505,"modified_method":"private Hashable initHelper(Token left, Token right, byte depth, byte max)\n    {\n        if (depth == max)\n            // we've reached the leaves\n            return new Leaf();\n        Token midpoint = partitioner.midpoint(left, right);\n\n        if (midpoint.equals(left) || midpoint.equals(right))\n            return new Leaf();\n\n        Hashable lchild =  initHelper(left, midpoint, inc(depth), max);\n        Hashable rchild =  initHelper(midpoint, right, inc(depth), max);\n        return new Inner(midpoint, lchild, rchild);\n    }","commit_id":"21bc3c217ecea552f0226b8b492d774a95ed7bc9","url":"https://github.com/apache/cassandra"},{"original_method":"public String getLinkForResource(OnmsResource resource) {\n        try {\n            return \"element/nodeList.htm?listInterfaces=true&ifAlias=\" + URLEncoder.encode(resource.getName(), \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"URLEncoder.encode complained about UTF-8.  My opinion about that is: WTF? \" + e, e);\n        }\n    }","id":99506,"modified_method":"public String getLinkForResource(OnmsResource resource) {\n        // Need a search for hosts in a domain. The present nodeList capability won't support it.\n        // Just return null for now\n        //try {\n        //    return \"element/nodeList.htm?listInterfaces=true&domain=\" + URLEncoder.encode(resource.getName(), \"UTF-8\");\n        //} catch (UnsupportedEncodingException e) {\n        //    throw new IllegalStateException(\"URLEncoder.encode complained about UTF-8.  My opinion about that is: WTF? \" + e, e);\n        //}\n        return null;\n    }","commit_id":"447e06e884d504946979023e9a7f75fd83fc2179","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public List<OnmsResource> getResourcesForDomain(String domain) {\n        ArrayList<OnmsResource> resources =\n            new ArrayList<OnmsResource>();\n\n        List<String> ifaces = getQueryableInterfacesForDomain(domain);\n        for (String iface : ifaces) {\n            resources.add(getResourceByDomainAndInterface(domain, iface));\n        }\n\n        return resources;\n    }","id":99507,"modified_method":"public List<OnmsResource> getResourcesForDomain(String domain) {\n        ArrayList<OnmsResource> resources =\n            new ArrayList<OnmsResource>();\n\n        List<String> ifaces = getQueryableInterfacesForDomain(domain);\n        for (String iface : ifaces) {\n            OnmsResource resource = getResourceByDomainAndInterface(domain, iface); \n            resource.setLink(\"element/nodeList.htm?listInterfaces=true&ifAlias=\" + iface);\n            resources.add(resource);\n        }\n\n        return resources;\n    }","commit_id":"447e06e884d504946979023e9a7f75fd83fc2179","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String getLinkForResource(OnmsResource resource) {\n        try {\n            return \"element/nodeList.htm?listInterfaces=true&ifAlias=\" + URLEncoder.encode(resource.getName(), \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"URLEncoder.encode complained about UTF-8.  My opinion about that is: WTF? \" + e, e);\n        }\n    }","id":99508,"modified_method":"public String getLinkForResource(OnmsResource resource) {\n        // Need a search for hosts in a domain. The present nodeList capability won't support it.\n        // Just return null for now\n        //try {\n        //    return \"element/nodeList.htm?listInterfaces=true&domain=\" + URLEncoder.encode(resource.getName(), \"UTF-8\");\n        //} catch (UnsupportedEncodingException e) {\n        //    throw new IllegalStateException(\"URLEncoder.encode complained about UTF-8.  My opinion about that is: WTF? \" + e, e);\n        //}\n        return null;\n    }","commit_id":"dfbcc97142fecaea1bfaa755e655a2b408498656","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public List<OnmsResource> getResourcesForDomain(String domain) {\n        ArrayList<OnmsResource> resources =\n            new ArrayList<OnmsResource>();\n\n        List<String> ifaces = getQueryableInterfacesForDomain(domain);\n        for (String iface : ifaces) {\n            resources.add(getResourceByDomainAndInterface(domain, iface));\n        }\n\n        return resources;\n    }","id":99509,"modified_method":"public List<OnmsResource> getResourcesForDomain(String domain) {\n        ArrayList<OnmsResource> resources =\n            new ArrayList<OnmsResource>();\n\n        List<String> ifaces = getQueryableInterfacesForDomain(domain);\n        for (String iface : ifaces) {\n            OnmsResource resource = getResourceByDomainAndInterface(domain, iface); \n            resource.setLink(\"element/nodeList.htm?listInterfaces=true&ifAlias=\" + iface);\n            resources.add(resource);\n        }\n\n        return resources;\n    }","commit_id":"dfbcc97142fecaea1bfaa755e655a2b408498656","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String getLinkForResource(OnmsResource resource) {\n        try {\n            return \"element/nodeList.htm?listInterfaces=true&ifAlias=\" + URLEncoder.encode(resource.getName(), \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"URLEncoder.encode complained about UTF-8.  My opinion about that is: WTF? \" + e, e);\n        }\n    }","id":99510,"modified_method":"public String getLinkForResource(OnmsResource resource) {\n        // Need a search for hosts in a domain. The present nodeList capability won't support it.\n        // Just return null for now\n        //try {\n        //    return \"element/nodeList.htm?listInterfaces=true&domain=\" + URLEncoder.encode(resource.getName(), \"UTF-8\");\n        //} catch (UnsupportedEncodingException e) {\n        //    throw new IllegalStateException(\"URLEncoder.encode complained about UTF-8.  My opinion about that is: WTF? \" + e, e);\n        //}\n        return null;\n    }","commit_id":"c4ceb92818a8089aeb37718d24fd125ca6728d9f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public List<OnmsResource> getResourcesForDomain(String domain) {\n        ArrayList<OnmsResource> resources =\n            new ArrayList<OnmsResource>();\n\n        List<String> ifaces = getQueryableInterfacesForDomain(domain);\n        for (String iface : ifaces) {\n            resources.add(getResourceByDomainAndInterface(domain, iface));\n        }\n\n        return resources;\n    }","id":99511,"modified_method":"public List<OnmsResource> getResourcesForDomain(String domain) {\n        ArrayList<OnmsResource> resources =\n            new ArrayList<OnmsResource>();\n\n        List<String> ifaces = getQueryableInterfacesForDomain(domain);\n        for (String iface : ifaces) {\n            OnmsResource resource = getResourceByDomainAndInterface(domain, iface); \n            resource.setLink(\"element/nodeList.htm?listInterfaces=true&ifAlias=\" + iface);\n            resources.add(resource);\n        }\n\n        return resources;\n    }","commit_id":"c4ceb92818a8089aeb37718d24fd125ca6728d9f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public boolean validateCriticalHeaders() {\n        return JwsUtils.validateCriticalHeaders(getJweHeaders());\n    }","id":99512,"modified_method":"public boolean validateCriticalHeaders() {\n        return JweUtils.validateCriticalHeaders(getJweHeaders());\n    }","commit_id":"a4ed944b94e173828255f989a7ced0da64ef707c","url":"https://github.com/apache/cxf"},{"original_method":"public static KeyDecryptionAlgorithm getKeyDecryptionAlgorithm(JsonWebKey jwk, String defaultAlgorithm) {\n        String keyEncryptionAlgo = jwk.getAlgorithm() == null ? defaultAlgorithm : jwk.getAlgorithm();\n        KeyDecryptionAlgorithm keyDecryptionProvider = null;\n        if (JsonWebKey.KEY_TYPE_RSA.equals(jwk.getKeyType())) {\n            keyDecryptionProvider = new RSAOaepKeyDecryptionAlgorithm(JwkUtils.toRSAPrivateKey(jwk), \n                                                                      keyEncryptionAlgo);\n        } else if (JsonWebKey.KEY_TYPE_OCTET.equals(jwk.getKeyType())) {\n            SecretKey key = JwkUtils.toSecretKey(jwk);\n            if (Algorithm.isAesKeyWrap(jwk.getAlgorithm())) {\n                keyDecryptionProvider = new AesWrapKeyDecryptionAlgorithm(key, keyEncryptionAlgo);\n            } else if (Algorithm.isAesGcmKeyWrap(jwk.getAlgorithm())) {\n                keyDecryptionProvider = new AesGcmWrapKeyDecryptionAlgorithm(key, keyEncryptionAlgo);\n            } \n        } else {\n            // TODO: support elliptic curve keys\n        }\n        return keyDecryptionProvider;\n    }","id":99513,"modified_method":"public static KeyDecryptionAlgorithm getKeyDecryptionAlgorithm(JsonWebKey jwk, String defaultAlgorithm) {\n        String keyEncryptionAlgo = jwk.getAlgorithm() == null ? defaultAlgorithm : jwk.getAlgorithm();\n        KeyDecryptionAlgorithm keyDecryptionProvider = null;\n        if (JsonWebKey.KEY_TYPE_RSA.equals(jwk.getKeyType())) {\n            keyDecryptionProvider = getRSAKeyDecryptionAlgorithm(JwkUtils.toRSAPrivateKey(jwk), \n                                                                 keyEncryptionAlgo);\n        } else if (JsonWebKey.KEY_TYPE_OCTET.equals(jwk.getKeyType())) {\n            keyDecryptionProvider = getSecretKeyDecryptionAlgorithm(JwkUtils.toSecretKey(jwk),\n                                            keyEncryptionAlgo);\n        } else {\n            // TODO: support elliptic curve keys\n        }\n        return keyDecryptionProvider;\n    }","commit_id":"a4ed944b94e173828255f989a7ced0da64ef707c","url":"https://github.com/apache/cxf"},{"original_method":"public static JweDecryptionProvider loadDecryptionProvider(String propLoc, Message m) {\n        KeyDecryptionAlgorithm keyDecryptionProvider = null;\n        Properties props = null;\n        try {\n            props = ResourceUtils.loadProperties(propLoc, m.getExchange().getBus());\n        } catch (Exception ex) {\n            throw new SecurityException(ex);\n        }    \n        String contentEncryptionAlgo = props.getProperty(JSON_WEB_ENCRYPTION_CEK_ALGO_PROP);\n        SecretKey ctDecryptionKey = null;\n        if (JwkUtils.JWK_KEY_STORE_TYPE.equals(props.get(KeyManagementUtils.RSSEC_KEY_STORE_TYPE))) {\n            JsonWebKey jwk = JwkUtils.loadJsonWebKey(m, props, JsonWebKey.KEY_OPER_ENCRYPT);\n            String keyEncryptionAlgo = getKeyEncryptionAlgo(props, jwk.getAlgorithm());\n            if (\"direct\".equals(keyEncryptionAlgo)) {\n                contentEncryptionAlgo = getContentEncryptionAlgo(props, contentEncryptionAlgo);\n                ctDecryptionKey = JweUtils.getContentDecryptionSecretKey(jwk, contentEncryptionAlgo);\n            } else {\n                keyDecryptionProvider = JweUtils.getKeyDecryptionAlgorithm(jwk, keyEncryptionAlgo);\n            }\n        } else {\n            keyDecryptionProvider = new RSAOaepKeyDecryptionAlgorithm(\n                (RSAPrivateKey)KeyManagementUtils.loadPrivateKey(\n                    m, props, KeyManagementUtils.RSSEC_DECRYPT_KEY_PSWD_PROVIDER));\n        }\n        if (keyDecryptionProvider == null && ctDecryptionKey == null) {\n            throw new SecurityException();\n        }\n        if (keyDecryptionProvider != null) {\n            if (Algorithm.isAesCbcHmac(contentEncryptionAlgo)) { \n                return new AesCbcHmacJweDecryption(keyDecryptionProvider, contentEncryptionAlgo);\n            } else {\n                return new WrappedKeyJweDecryption(keyDecryptionProvider, \n                                                   new AesGcmContentDecryptionAlgorithm(contentEncryptionAlgo));\n            }\n        } else {\n            return new DirectKeyJweDecryption(ctDecryptionKey, \n                                              new AesGcmContentDecryptionAlgorithm(contentEncryptionAlgo));\n        }\n    }","id":99514,"modified_method":"public static JweDecryptionProvider loadDecryptionProvider(String propLoc, Message m) {\n        KeyDecryptionAlgorithm keyDecryptionProvider = null;\n        Properties props = null;\n        try {\n            props = ResourceUtils.loadProperties(propLoc, m.getExchange().getBus());\n        } catch (Exception ex) {\n            throw new SecurityException(ex);\n        }    \n        String contentEncryptionAlgo = props.getProperty(JSON_WEB_ENCRYPTION_CEK_ALGO_PROP);\n        SecretKey ctDecryptionKey = null;\n        String keyEncryptionAlgo = getKeyEncryptionAlgo(props, null);\n        if (JwkUtils.JWK_KEY_STORE_TYPE.equals(props.get(KeyManagementUtils.RSSEC_KEY_STORE_TYPE))) {\n            JsonWebKey jwk = JwkUtils.loadJsonWebKey(m, props, JsonWebKey.KEY_OPER_ENCRYPT);\n            keyEncryptionAlgo = getKeyEncryptionAlgo(props, jwk.getAlgorithm());\n            if (\"direct\".equals(keyEncryptionAlgo)) {\n                contentEncryptionAlgo = getContentEncryptionAlgo(props, contentEncryptionAlgo);\n                ctDecryptionKey = getContentDecryptionSecretKey(jwk, contentEncryptionAlgo);\n            } else {\n                keyDecryptionProvider = getKeyDecryptionAlgorithm(jwk, keyEncryptionAlgo);\n            }\n        } else {\n            keyDecryptionProvider = getRSAKeyDecryptionAlgorithm(\n                (RSAPrivateKey)KeyManagementUtils.loadPrivateKey(\n                    m, props, KeyManagementUtils.RSSEC_DECRYPT_KEY_PSWD_PROVIDER), keyEncryptionAlgo);\n        }\n        return createJweDecryptionProvider(keyDecryptionProvider, ctDecryptionKey, contentEncryptionAlgo);\n    }","commit_id":"a4ed944b94e173828255f989a7ced0da64ef707c","url":"https://github.com/apache/cxf"},{"original_method":"public static KeyEncryptionAlgorithm getKeyEncryptionAlgorithm(JsonWebKey jwk, String defaultAlgorithm) {\n        String keyEncryptionAlgo = jwk.getAlgorithm() == null ? defaultAlgorithm : jwk.getAlgorithm();\n        KeyEncryptionAlgorithm keyEncryptionProvider = null;\n        if (JsonWebKey.KEY_TYPE_RSA.equals(jwk.getKeyType())) {\n            keyEncryptionProvider = new RSAOaepKeyEncryptionAlgorithm(JwkUtils.toRSAPublicKey(jwk), \n                                                                      keyEncryptionAlgo);\n        } else if (JsonWebKey.KEY_TYPE_OCTET.equals(jwk.getKeyType())) {\n            SecretKey key = JwkUtils.toSecretKey(jwk);\n            if (Algorithm.isAesKeyWrap(keyEncryptionAlgo)) {\n                keyEncryptionProvider = new AesWrapKeyEncryptionAlgorithm(key, keyEncryptionAlgo);\n            } else if (Algorithm.isAesGcmKeyWrap(keyEncryptionAlgo)) {\n                keyEncryptionProvider = new AesGcmWrapKeyEncryptionAlgorithm(key, keyEncryptionAlgo);\n            }\n        } else {\n            // TODO: support elliptic curve keys\n        }\n        return keyEncryptionProvider;\n    }","id":99515,"modified_method":"public static KeyEncryptionAlgorithm getKeyEncryptionAlgorithm(JsonWebKey jwk, String defaultAlgorithm) {\n        String keyEncryptionAlgo = jwk.getAlgorithm() == null ? defaultAlgorithm : jwk.getAlgorithm();\n        KeyEncryptionAlgorithm keyEncryptionProvider = null;\n        if (JsonWebKey.KEY_TYPE_RSA.equals(jwk.getKeyType())) {\n            keyEncryptionProvider = getRSAKeyEncryptionAlgorithm(JwkUtils.toRSAPublicKey(jwk), \n                                                                 keyEncryptionAlgo);\n        } else if (JsonWebKey.KEY_TYPE_OCTET.equals(jwk.getKeyType())) {\n            keyEncryptionProvider = getSecretKeyEncryptionAlgorithm(JwkUtils.toSecretKey(jwk), \n                                                                    keyEncryptionAlgo);\n        } else {\n            // TODO: support elliptic curve keys\n        }\n        return keyEncryptionProvider;\n    }","commit_id":"a4ed944b94e173828255f989a7ced0da64ef707c","url":"https://github.com/apache/cxf"},{"original_method":"public static ContentEncryptionAlgorithm getContentEncryptionAlgorithm(JsonWebKey jwk, String defaultAlgorithm) {\n        String ctEncryptionAlgo = jwk.getAlgorithm() == null ? defaultAlgorithm : jwk.getAlgorithm();\n        ContentEncryptionAlgorithm contentEncryptionProvider = null;\n        if (JsonWebKey.KEY_TYPE_OCTET.equals(jwk.getKeyType())) {\n            SecretKey key = JwkUtils.toSecretKey(jwk);\n            if (Algorithm.isAesGcm(ctEncryptionAlgo)) {\n                contentEncryptionProvider = new AesGcmContentEncryptionAlgorithm(key, null, ctEncryptionAlgo);\n            }\n        }\n        return contentEncryptionProvider;\n    }","id":99516,"modified_method":"public static ContentEncryptionAlgorithm getContentEncryptionAlgorithm(JsonWebKey jwk, String defaultAlgorithm) {\n        String ctEncryptionAlgo = jwk.getAlgorithm() == null ? defaultAlgorithm : jwk.getAlgorithm();\n        ContentEncryptionAlgorithm contentEncryptionProvider = null;\n        if (JsonWebKey.KEY_TYPE_OCTET.equals(jwk.getKeyType())) {\n            return getContentEncryptionAlgorithm(JwkUtils.toSecretKey(jwk),\n                                                 ctEncryptionAlgo);\n        }\n        return contentEncryptionProvider;\n    }","commit_id":"a4ed944b94e173828255f989a7ced0da64ef707c","url":"https://github.com/apache/cxf"},{"original_method":"public static boolean validatecriticalheaders(JoseHeaders headers) {\n        //TODO: Validate JWE specific constraints\n        return JoseUtils.validateCriticalHeaders(headers);\n    }","id":99517,"modified_method":"public static boolean validateCriticalHeaders(JoseHeaders headers) {\n        //TODO: Validate JWE specific constraints\n        return JoseUtils.validateCriticalHeaders(headers);\n    }","commit_id":"a4ed944b94e173828255f989a7ced0da64ef707c","url":"https://github.com/apache/cxf"},{"original_method":"public static JweEncryptionProvider loadEncryptionProvider(String propLoc, Message m) {\n        KeyEncryptionAlgorithm keyEncryptionProvider = null;\n        String keyEncryptionAlgo = null;\n        Properties props = null;\n        try {\n            props = ResourceUtils.loadProperties(propLoc, m.getExchange().getBus());\n        } catch (Exception ex) {\n            throw new SecurityException(ex);\n        }\n        \n        String contentEncryptionAlgo = props.getProperty(JSON_WEB_ENCRYPTION_CEK_ALGO_PROP);\n        ContentEncryptionAlgorithm ctEncryptionProvider = null;\n        if (JwkUtils.JWK_KEY_STORE_TYPE.equals(props.get(KeyManagementUtils.RSSEC_KEY_STORE_TYPE))) {\n            JsonWebKey jwk = JwkUtils.loadJsonWebKey(m, props, JsonWebKey.KEY_OPER_ENCRYPT);\n            keyEncryptionAlgo = getKeyEncryptionAlgo(props, jwk.getAlgorithm());\n            if (\"direct\".equals(keyEncryptionAlgo)) {\n                contentEncryptionAlgo = getContentEncryptionAlgo(props, jwk.getAlgorithm());\n                ctEncryptionProvider = JweUtils.getContentEncryptionAlgorithm(jwk, contentEncryptionAlgo);\n            } else {\n                keyEncryptionProvider = JweUtils.getKeyEncryptionAlgorithm(jwk, keyEncryptionAlgo);\n            }\n            \n        } else {\n            keyEncryptionProvider = new RSAOaepKeyEncryptionAlgorithm(\n                (RSAPublicKey)KeyManagementUtils.loadPublicKey(m, props), \n                getKeyEncryptionAlgo(props, keyEncryptionAlgo));\n        }\n        if (keyEncryptionProvider == null && ctEncryptionProvider == null) {\n            throw new SecurityException();\n        }\n        \n        \n        JweHeaders headers = new JweHeaders(getKeyEncryptionAlgo(props, keyEncryptionAlgo), \n                                            contentEncryptionAlgo);\n        String compression = props.getProperty(JSON_WEB_ENCRYPTION_ZIP_ALGO_PROP);\n        if (compression != null) {\n            headers.setZipAlgorithm(compression);\n        }\n        if (keyEncryptionProvider != null) {\n            if (Algorithm.isAesCbcHmac(contentEncryptionAlgo)) { \n                return new AesCbcHmacJweEncryption(contentEncryptionAlgo, keyEncryptionProvider);\n            } else {\n                return new WrappedKeyJweEncryption(headers, \n                                                   keyEncryptionProvider,\n                                                   new AesGcmContentEncryptionAlgorithm(contentEncryptionAlgo));\n            }\n        } else {\n            return new DirectKeyJweEncryption(ctEncryptionProvider);\n        }\n    }","id":99518,"modified_method":"public static JweEncryptionProvider loadEncryptionProvider(String propLoc, Message m) {\n        KeyEncryptionAlgorithm keyEncryptionProvider = null;\n        String keyEncryptionAlgo = null;\n        Properties props = null;\n        try {\n            props = ResourceUtils.loadProperties(propLoc, m.getExchange().getBus());\n        } catch (Exception ex) {\n            throw new SecurityException(ex);\n        }\n        \n        String contentEncryptionAlgo = props.getProperty(JSON_WEB_ENCRYPTION_CEK_ALGO_PROP);\n        ContentEncryptionAlgorithm ctEncryptionProvider = null;\n        if (JwkUtils.JWK_KEY_STORE_TYPE.equals(props.get(KeyManagementUtils.RSSEC_KEY_STORE_TYPE))) {\n            JsonWebKey jwk = JwkUtils.loadJsonWebKey(m, props, JsonWebKey.KEY_OPER_ENCRYPT);\n            keyEncryptionAlgo = getKeyEncryptionAlgo(props, jwk.getAlgorithm());\n            if (\"direct\".equals(keyEncryptionAlgo)) {\n                contentEncryptionAlgo = getContentEncryptionAlgo(props, jwk.getAlgorithm());\n                ctEncryptionProvider = getContentEncryptionAlgorithm(jwk, contentEncryptionAlgo);\n            } else {\n                keyEncryptionProvider = getKeyEncryptionAlgorithm(jwk, keyEncryptionAlgo);\n            }\n            \n        } else {\n            keyEncryptionProvider = getRSAKeyEncryptionAlgorithm(\n                (RSAPublicKey)KeyManagementUtils.loadPublicKey(m, props), \n                getKeyEncryptionAlgo(props, keyEncryptionAlgo));\n        }\n        return createJweEncryptionProvider(keyEncryptionProvider, \n                                    ctEncryptionProvider, \n                                    contentEncryptionAlgo,\n                                    props.getProperty(JSON_WEB_ENCRYPTION_ZIP_ALGO_PROP));\n    }","commit_id":"a4ed944b94e173828255f989a7ced0da64ef707c","url":"https://github.com/apache/cxf"},{"original_method":"private static JsonWebKey prepareRSAJwk(BigInteger modulus) {\n        JsonWebKey jwk = new JsonWebKey();\n        jwk.setKeyType(JsonWebKey.KEY_TYPE_RSA);\n        String encodedModulus = Base64UrlUtility.encode(modulus.toByteArray());\n        jwk.setProperty(JsonWebKey.RSA_MODULUS, encodedModulus);\n        return jwk;\n    }","id":99519,"modified_method":"private static JsonWebKey prepareRSAJwk(BigInteger modulus, String algo) {\n        if (!Algorithm.isRsa(algo)) {\n            throw new SecurityException(\"Invalid algorithm\");\n        }\n        JsonWebKey jwk = new JsonWebKey();\n        jwk.setKeyType(JsonWebKey.KEY_TYPE_RSA);\n        jwk.setAlgorithm(algo);\n        String encodedModulus = Base64UrlUtility.encode(modulus.toByteArray());\n        jwk.setProperty(JsonWebKey.RSA_MODULUS, encodedModulus);\n        return jwk;\n    }","commit_id":"a4ed944b94e173828255f989a7ced0da64ef707c","url":"https://github.com/apache/cxf"},{"original_method":"public static JsonWebKey fromSecretKey(SecretKey secretKey) {\n        JsonWebKey jwk = new JsonWebKey();\n        jwk.setKeyType(JsonWebKey.KEY_TYPE_OCTET);\n        String encodedSecretKey = Base64UrlUtility.encode(secretKey.getEncoded());\n        jwk.setProperty(JsonWebKey.OCTET_KEY_VALUE, encodedSecretKey);\n        return jwk;\n    }","id":99520,"modified_method":"public static JsonWebKey fromSecretKey(SecretKey secretKey, String algo) {\n        if (!Algorithm.isOctet(algo)) {\n            throw new SecurityException(\"Invalid algorithm\");\n        }\n        JsonWebKey jwk = new JsonWebKey();\n        jwk.setKeyType(JsonWebKey.KEY_TYPE_OCTET);\n        jwk.setAlgorithm(algo);\n        String encodedSecretKey = Base64UrlUtility.encode(secretKey.getEncoded());\n        jwk.setProperty(JsonWebKey.OCTET_KEY_VALUE, encodedSecretKey);\n        return jwk;\n    }","commit_id":"a4ed944b94e173828255f989a7ced0da64ef707c","url":"https://github.com/apache/cxf"},{"original_method":"public static JsonWebKey fromRSAPrivateKey(RSAPrivateKey pk) {\n        JsonWebKey jwk = prepareRSAJwk(pk.getModulus());\n        String encodedPrivateExponent = Base64UrlUtility.encode(pk.getPrivateExponent().toByteArray());\n        jwk.setProperty(JsonWebKey.RSA_PRIVATE_EXP, encodedPrivateExponent);\n        return jwk;\n    }","id":99521,"modified_method":"public static JsonWebKey fromRSAPrivateKey(RSAPrivateKey pk, String algo) {\n        JsonWebKey jwk = prepareRSAJwk(pk.getModulus(), algo);\n        String encodedPrivateExponent = Base64UrlUtility.encode(pk.getPrivateExponent().toByteArray());\n        jwk.setProperty(JsonWebKey.RSA_PRIVATE_EXP, encodedPrivateExponent);\n        return jwk;\n    }","commit_id":"a4ed944b94e173828255f989a7ced0da64ef707c","url":"https://github.com/apache/cxf"},{"original_method":"public static JsonWebKey fromRSAPublicKey(RSAPublicKey pk) {\n        JsonWebKey jwk = prepareRSAJwk(pk.getModulus());\n        String encodedPublicExponent = Base64UrlUtility.encode(pk.getPublicExponent().toByteArray());\n        jwk.setProperty(JsonWebKey.RSA_PUBLIC_EXP, encodedPublicExponent);\n        return jwk;\n    }","id":99522,"modified_method":"public static JsonWebKey fromRSAPublicKey(RSAPublicKey pk, String algo) {\n        JsonWebKey jwk = prepareRSAJwk(pk.getModulus(), algo);\n        String encodedPublicExponent = Base64UrlUtility.encode(pk.getPublicExponent().toByteArray());\n        jwk.setProperty(JsonWebKey.RSA_PUBLIC_EXP, encodedPublicExponent);\n        return jwk;\n    }","commit_id":"a4ed944b94e173828255f989a7ced0da64ef707c","url":"https://github.com/apache/cxf"},{"original_method":"public static String encryptJwkSet(JsonWebKeys jwkSet, JweEncryptionProvider jwe, JwkReaderWriter writer) {\n        return jwe.encrypt(stringToBytes(writer.jwkSetToJson(jwkSet)), \"jwk-set+json\");\n    }","id":99523,"modified_method":"public static String encryptJwkSet(JsonWebKeys jwkSet, JweEncryptionProvider jwe, JwkReaderWriter writer) {\n        return jwe.encrypt(StringUtils.toBytesUTF8(writer.jwkSetToJson(jwkSet)), \"jwk-set+json\");\n    }","commit_id":"a4ed944b94e173828255f989a7ced0da64ef707c","url":"https://github.com/apache/cxf"},{"original_method":"public static String encryptJwkKey(JsonWebKey jwkKey, JweEncryptionProvider jwe, JwkReaderWriter writer) {\n        return jwe.encrypt(stringToBytes(writer.jwkToJson(jwkKey)), \"jwk+json\");\n    }","id":99524,"modified_method":"public static String encryptJwkKey(JsonWebKey jwkKey, JweEncryptionProvider jwe, JwkReaderWriter writer) {\n        return jwe.encrypt(StringUtils.toBytesUTF8(writer.jwkToJson(jwkKey)), \"jwk+json\");\n    }","commit_id":"a4ed944b94e173828255f989a7ced0da64ef707c","url":"https://github.com/apache/cxf"},{"original_method":"/** No listeners will be updated until releaseChanges is called.  Multiple\n     * overlapping holds are okay. */\n    public synchronized void holdChanges() {\n        mHoldingChanges = true;\n    }","id":99525,"modified_method":"/** No listeners will be updated until releaseChanges is called.  Multiple\n     * overlapping holds are okay. */\n    public synchronized void holdChanges() {\n        if (DEBUG.RESOURCE) out(\"holding changes\");\n        mHoldingChanges = true;\n    }","commit_id":"ca51e8de0cb5b261982442611029cf198a985436","url":"https://github.com/VUE/VUE"},{"original_method":"private void reload() {\n            mEntries = new Entry[size()];\n            Iterator i = entrySet().iterator();\n            int ei = 0;\n            while (i.hasNext()) {\n                Map.Entry e = (Map.Entry) i.next();\n                boolean priority = false;\n                if (\"title\".equalsIgnoreCase((String)e.getKey()))\n                    priority = true;\n                mEntries[ei++] = new Entry(e, priority);\n            }\n            \n            Arrays.sort(mEntries);\n\n            /*\n            mEntries = (Map.Entry[]) PropertyMap.this.entrySet().toArray(new Map.Entry[size()]);\n            Arrays.sort(mEntries, new Comparator() {\n                    public int compare(Object o1, Object o2) {\n                        String k1 = (String) ((Map.Entry)o1).getKey();\n                        String k2 = (String) ((Map.Entry)o2).getKey();\n                        return k1.compareTo(k2);\n                    }});\n            */\n            if (DEBUG.RESOURCE) System.out.println(\"RsrcProps: model loaded \" + Arrays.asList(mEntries));\n            fireTableDataChanged();\n            notifyListeners();\n        }","id":99526,"modified_method":"private void reload() {\n            mEntries = new Entry[size()];\n            if (DEBUG.RESOURCE) out(\"SortedMapModel: reload \" + mEntries.length + \" items\");\n            Iterator i = entrySet().iterator();\n            int ei = 0;\n            while (i.hasNext()) {\n                Map.Entry e = (Map.Entry) i.next();\n                boolean priority = false;\n                if (\"title\".equalsIgnoreCase((String)e.getKey()))\n                    priority = true;\n                mEntries[ei++] = new Entry(e, priority);\n            }\n            \n            Arrays.sort(mEntries);\n\n            /*\n            mEntries = (Map.Entry[]) PropertyMap.this.entrySet().toArray(new Map.Entry[size()]);\n            Arrays.sort(mEntries, new Comparator() {\n                    public int compare(Object o1, Object o2) {\n                        String k1 = (String) ((Map.Entry)o1).getKey();\n                        String k2 = (String) ((Map.Entry)o2).getKey();\n                        return k1.compareTo(k2);\n                    }});\n            */\n            if (DEBUG.RESOURCE) {\n                out(\"loaded \" + mEntries.length + \" entries\");\n                if (DEBUG.META)\n                    out(\"model loaded \" + Arrays.asList(mEntries));\n            }\n            fireTableDataChanged();\n            notifyListeners();\n        }","commit_id":"ca51e8de0cb5b261982442611029cf198a985436","url":"https://github.com/VUE/VUE"},{"original_method":"/**\n     * If any changes made since holdChanges, listeners will be notified.\n     * It is crucial this is called at some point after holdChanges,\n     * or listeners may never get updated. Tho ideally only one call to\n     * this per holdChanges is made, Extra calls to this are okay \n     * -- it will at worst degrade update performance with rapid updates.\n     */\n    public synchronized void releaseChanges() {\n        mHoldingChanges = false;\n        if (mChanges > 0 && mTableModel != null) {\n            if (DEBUG.RESOURCE) System.out.println(\"RsrcProps: releasing changes \" + mChanges);\n            mTableModel.reload();\n        }\n        mChanges = 0;\n    }","id":99527,"modified_method":"/**\n     * If any changes made since holdChanges, listeners will be notified.\n     * It is crucial this is called at some point after holdChanges,\n     * or listeners may never get updated. Tho ideally only one call to\n     * this per holdChanges is made, Extra calls to this are okay \n     * -- it will at worst degrade update performance with rapid updates.\n     */\n    public synchronized void releaseChanges() {\n        mHoldingChanges = false;\n        if (mChanges > 0 && mTableModel != null) {\n            if (DEBUG.RESOURCE) out(\"releasing changes \" + mChanges);\n            mTableModel.reload();\n        }\n        if (DEBUG.RESOURCE) out(\"released changes \" + mChanges);\n        mChanges = 0;\n    }","commit_id":"ca51e8de0cb5b261982442611029cf198a985436","url":"https://github.com/VUE/VUE"},{"original_method":"SortedMapModel() { reload(); }","id":99528,"modified_method":"SortedMapModel() {\n            if (DEBUG.RESOURCE) out(\"new SortedMapModel\");\n            reload();\n        }","commit_id":"ca51e8de0cb5b261982442611029cf198a985436","url":"https://github.com/VUE/VUE"},{"original_method":"static Resource createResource(org.osid.repository.Asset asset,\n                                       org.osid.repository.Repository repository,\n                                       org.osid.OsidContext context)\n            throws org.osid.repository.RepositoryException\n        {\n            Resource r = new Osid2AssetResource(asset, context);\n            if (DEBUG.DR) r.addProperty(\"@_Repository\", repository.getDisplayName());\n            return r;\n        }","id":99529,"modified_method":"static Resource createResource(org.osid.repository.Asset asset,\n                                       org.osid.repository.Repository repository,\n                                       org.osid.OsidContext context)\n            throws org.osid.repository.RepositoryException\n        {\n            Resource r = new Osid2AssetResource(asset, context);\n            if (DEBUG.DR) r.addProperty(\"~Repository\", repository.getDisplayName());\n            return r;\n        }","commit_id":"668e65139c8a2208e4ac2f7193e281e1e2696bb7","url":"https://github.com/VUE/VUE"},{"original_method":"public static void saveDataSourceViewer() {\n        if (dataSourceList == null) {\n            System.err.println(\"DataSourceViewer: No dataSourceList to save.\");\n            return;\n        }\n        int size = dataSourceList.getModel().getSize();\n        File f  = new File(VueUtil.getDefaultUserFolder().getAbsolutePath()+File.separatorChar+VueResources.getString(\"save.datasources\"));\n        Vector sDataSources = new Vector();\n        for (int i = 0; i<size; i++) {\n            Object item = dataSourceList.getModel().getElementAt(i);\n            if (DEBUG.DR) System.out.println(\"saveDataSourceViewer: item \" + i + \" is \" + item.getClass().getName() + \"[\" + item + \"] of \" + size);\n            if (item instanceof DataSource) {\n                sDataSources.add((DataSource)item);\n            } else {\n                if (DEBUG.DR) System.out.println(\"\\tskipped item of \" + item.getClass());\n            }\n        }\n        try {\n            if (DEBUG.DR) System.out.println(\"saveDataSourceViewer: creating new SaveDataSourceViewer\");\n            SaveDataSourceViewer sViewer= new SaveDataSourceViewer(sDataSources);\n            if (DEBUG.DR) System.out.println(\"saveDataSourceViewer: marshallMap: saving \" + sViewer + \" to \" + f);\n            marshallMap(f,sViewer);\n        } catch (Throwable t) {\n            t.printStackTrace();\n        }\n    }","id":99530,"modified_method":"public static void saveDataSourceViewer() {\n        if (dataSourceList == null) {\n            System.err.println(\"DataSourceViewer: No dataSourceList to save.\");\n            return;\n        }\n        int size = dataSourceList.getModel().getSize();\n        File f  = new File(VueUtil.getDefaultUserFolder().getAbsolutePath()+File.separatorChar+VueResources.getString(\"save.datasources\"));\n        Vector sDataSources = new Vector();\n        if (DEBUG.DR) out(\"saveDataSourceViewer: found \" + size + \" dataSources: scanning for local's to save...\");\n        for (int i = 0; i<size; i++) {\n            Object item = dataSourceList.getModel().getElementAt(i);\n            if (DEBUG.DR) System.err.print(\"\\tsaveDataSourceViewer: item \" + i + \" is \" + tufts.Util.tag(item) + \"[\" + item + \"]...\");\n            if (item instanceof DataSource) {\n                sDataSources.add((DataSource)item);\n                if (DEBUG.DR) System.err.println(\"saving\");\n            } else {\n                if (DEBUG.DR) System.err.println(\"skipping\");\n            }\n        }\n        try {\n            if (DEBUG.DR) out(\"saveDataSourceViewer: creating new SaveDataSourceViewer\");\n            SaveDataSourceViewer sViewer= new SaveDataSourceViewer(sDataSources);\n            if (DEBUG.DR) out(\"saveDataSourceViewer: marshallMap: saving \" + sViewer + \" to \" + f);\n            marshallMap(f,sViewer);\n            if (DEBUG.DR) out(\"saveDataSourceViewer: saved\");\n        } catch (Throwable t) {\n            t.printStackTrace();\n        }\n    }","commit_id":"668e65139c8a2208e4ac2f7193e281e1e2696bb7","url":"https://github.com/VUE/VUE"},{"original_method":"public  static void marshallMap(File file,SaveDataSourceViewer dataSourceViewer) {\n        Marshaller marshaller = null;\n        Mapping mapping = new Mapping();\n        \n        try {\n            FileWriter writer = new FileWriter(file);\n            marshaller = new Marshaller(writer);\n            if (DEBUG.DR) System.out.println(\"DataSourceViewer.marshallMap: loading mapping \" + XML_MAPPING_DEFAULT);\n            mapping.loadMapping(XML_MAPPING_DEFAULT);\n            marshaller.setMapping(mapping);\n            if (DEBUG.DR) System.out.println(\"DataSourceViewer.marshallMap: marshalling \" + dataSourceViewer + \" to \" + file + \"...\");\n            marshaller.marshal(dataSourceViewer);\n            if (DEBUG.DR) System.out.println(\"DataSourceViewer.marshallMap: done marshalling.\");\n            writer.flush();\n            writer.close();\n        } catch (Throwable t) {\n            t.printStackTrace();\n            System.err.println(\"DRBrowser.marshallMap \" + t.getMessage());\n        }\n    }","id":99531,"modified_method":"public  static void marshallMap(File file,SaveDataSourceViewer dataSourceViewer) {\n        Marshaller marshaller = null;\n        //Mapping mapping = new Mapping();\n        \n        try {\n            FileWriter writer = new FileWriter(file);\n            marshaller = new Marshaller(writer);\n            //if (DEBUG.DR) out(\"marshallMap: loading mapping \" + XML_MAPPING_DEFAULT);\n            //mapping.loadMapping(XML_MAPPING_DEFAULT);\n            marshaller.setMapping(tufts.vue.action.ActionUtil.getDefaultMapping());\n            if (DEBUG.DR) out(\"marshallMap: marshalling \" + dataSourceViewer + \" to \" + file + \"...\");\n            marshaller.marshal(dataSourceViewer);\n            if (DEBUG.DR) out(\"marshallMap: done marshalling.\");\n            writer.flush();\n            writer.close();\n        } catch (Throwable t) {\n            t.printStackTrace();\n            System.err.println(\"DRBrowser.marshallMap \" + t.getMessage());\n        }\n    }","commit_id":"668e65139c8a2208e4ac2f7193e281e1e2696bb7","url":"https://github.com/VUE/VUE"},{"original_method":"public  SaveDataSourceViewer unMarshallMap(File file) throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.mapping.MappingException, org.exolab.castor.xml.ValidationException{\n        Unmarshaller unmarshaller = null;\n        SaveDataSourceViewer sviewer = null;\n        Mapping mapping = new Mapping();\n        unmarshaller = new Unmarshaller();\n        mapping.loadMapping(XML_MAPPING_DEFAULT);\n        unmarshaller.setMapping(mapping);\n        FileReader reader = new FileReader(file);\n        sviewer = (SaveDataSourceViewer) unmarshaller.unmarshal(new InputSource(reader));\n        reader.close();\n        return sviewer;\n    }","id":99532,"modified_method":"public  SaveDataSourceViewer unMarshallMap(File file) throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.mapping.MappingException, org.exolab.castor.xml.ValidationException{\n        Unmarshaller unmarshaller = tufts.vue.action.ActionUtil.getDefaultUnmarshaller(file.toString());\n        SaveDataSourceViewer sviewer = null;\n        //Mapping mapping = new Mapping();\n        //unmarshaller = new Unmarshaller();\n        //mapping.loadMapping(XML_MAPPING_DEFAULT);\n        //unmarshaller.setMapping(mapping);\n        FileReader reader = new FileReader(file);\n        sviewer = (SaveDataSourceViewer) unmarshaller.unmarshal(new InputSource(reader));\n        reader.close();\n        return sviewer;\n    }","commit_id":"668e65139c8a2208e4ac2f7193e281e1e2696bb7","url":"https://github.com/VUE/VUE"},{"original_method":"public  SaveVueJTree unMarshallFavorites(File file) {\n        Unmarshaller unmarshaller = null;\n        SaveVueJTree sTree = null;\n        try {\n            unmarshaller = new Unmarshaller(ActionUtil.getDefaultMapping());\n            FileReader reader = new FileReader(file);\n            sTree= (SaveVueJTree) unmarshaller.unmarshal(new InputSource(reader));\n            reader.close();\n        } catch (Exception e) {\n            // e.printStackTrace();\n            //System.err.println(\"FavoritesWindow.unmarshallFavorites: \" + e);\n            sTree = null;\n        }\n        return sTree;\n    }","id":99533,"modified_method":"public  SaveVueJTree unMarshallFavorites(File file) {\n        Unmarshaller unmarshaller = null;\n        SaveVueJTree sTree = null;\n        try {\n            //unmarshaller = new Unmarshaller(ActionUtil.getDefaultMapping());\n            unmarshaller = ActionUtil.getDefaultUnmarshaller(file.toString());\n            FileReader reader = new FileReader(file);\n            sTree= (SaveVueJTree) unmarshaller.unmarshal(new InputSource(reader));\n            reader.close();\n        } catch (Exception e) {\n            // e.printStackTrace();\n            //System.err.println(\"FavoritesWindow.unmarshallFavorites: \" + e);\n            sTree = null;\n        }\n        return sTree;\n    }","commit_id":"668e65139c8a2208e4ac2f7193e281e1e2696bb7","url":"https://github.com/VUE/VUE"},{"original_method":"public  static void marshall(File file,VueDataSourceManager dsm) {\n//        System.out.println(\"Marshalling: file -\"+ file.getAbsolutePath());\n        Marshaller marshaller = null;\n        Mapping mapping = new Mapping();\n        \n        try {\n            FileWriter writer = new FileWriter(file);\n            marshaller = new Marshaller(writer);\n            mapping.loadMapping(XML_MAPPING_DEFAULT);\n            marshaller.setMapping(mapping);\n            marshaller.marshal(dsm);\n            writer.flush();\n            writer.close();\n        } catch (Throwable t) {\n            t.printStackTrace();\n            System.err.println(\"VueDataSourceManager.marshall \" + t.getMessage());\n        }\n    }","id":99534,"modified_method":"public  static void marshall(File file,VueDataSourceManager dsm) {\n//        System.out.println(\"Marshalling: file -\"+ file.getAbsolutePath());\n        Marshaller marshaller = null;\n        //Mapping mapping = new Mapping();\n        Mapping mapping = tufts.vue.action.ActionUtil.getDefaultMapping();\n        \n        try {\n            FileWriter writer = new FileWriter(file);\n            marshaller = new Marshaller(writer);\n            //mapping.loadMapping(XML_MAPPING_DEFAULT);\n            marshaller.setMapping(mapping);\n            marshaller.marshal(dsm);\n            writer.flush();\n            writer.close();\n        } catch (Throwable t) {\n            t.printStackTrace();\n            System.err.println(\"VueDataSourceManager.marshall \" + t.getMessage());\n        }\n    }","commit_id":"668e65139c8a2208e4ac2f7193e281e1e2696bb7","url":"https://github.com/VUE/VUE"},{"original_method":"public static  VueDataSourceManager unMarshall(File file) throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.mapping.MappingException, org.exolab.castor.xml.ValidationException {\n//        System.out.println(\"UnMarshalling: file -\"+ file.getAbsolutePath());\n        Unmarshaller unmarshaller = null;\n        VueDataSourceManager dsm = null;\n        Mapping mapping = new Mapping();\n        unmarshaller = new Unmarshaller();\n        unmarshaller.setIgnoreExtraElements(true);\n        mapping.loadMapping(XML_MAPPING_DEFAULT);\n        unmarshaller.setMapping(mapping);\n        FileReader reader = new FileReader(file);\n        dsm = (VueDataSourceManager) unmarshaller.unmarshal(new InputSource(reader));\n        reader.close();\n        return dsm;\n    }","id":99535,"modified_method":"public static  VueDataSourceManager unMarshall(File file) throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.mapping.MappingException, org.exolab.castor.xml.ValidationException {\n//        System.out.println(\"UnMarshalling: file -\"+ file.getAbsolutePath());\n        \n        Unmarshaller unmarshaller = tufts.vue.action.ActionUtil.getDefaultUnmarshaller(file.toString());\n        /*\n        Unmarshaller unmarshaller = null;\n        Mapping mapping = new Mapping();\n        unmarshaller = new Unmarshaller();\n        unmarshaller.setIgnoreExtraElements(true);\n        mapping.loadMapping(XML_MAPPING_DEFAULT);\n        unmarshaller.setMapping(mapping);\n        */\n        FileReader reader = new FileReader(file);\n        VueDataSourceManager dsm = (VueDataSourceManager) unmarshaller.unmarshal(new InputSource(reader));\n        reader.close();\n        return dsm;\n    }","commit_id":"668e65139c8a2208e4ac2f7193e281e1e2696bb7","url":"https://github.com/VUE/VUE"},{"original_method":"private synchronized void performSearchAndDisplayResults()\n        throws org.osid.repository.RepositoryException,\n               org.osid.shared.SharedException\n    {\n        final String dockTitle = \"Search Results for \\\"\" + queryEditor.getSearchDisplayName() + \"\\\"\";\n\n        if (resultSetDockWindow != null) {\n            resultSetDockWindow.setTitle(dockTitle);\n\n            if (SearchingLabel == null) {\n                SearchingLabel = new JLabel(\"Searching...\", JLabel.CENTER);                \n                SearchingLabel.setOpaque(false);\n            }\n\n            if (false&&UseSingleScrollPane)\n                resultSetTreeJSP.setViewportView(SearchingLabel);\n            else\n                resultSetDockWindow.setContent(SearchingLabel);\n        }\n        \n        final WidgetStack resultsStack = new WidgetStack();\n\n        // get our search results\n\t\tjava.io.Serializable searchCriteria = queryEditor.getCriteria();\n        if (DEBUG.DR) out(\"Searching criteria [\" + searchCriteria + \"]...\");\n        org.osid.shared.Properties searchProperties = queryEditor.getProperties();\n\t\t\t\t\n\t\tedu.tufts.vue.fsm.ResultSetManager resultSetManager\n            = federatedSearchManager.getResultSetManager(searchCriteria,\n                                                         searchType,\n                                                         searchProperties);\t\t\n\t\tif (DEBUG.DR) out(\"got result set manager \" + resultSetManager);\n\t\t\n\t\t/*\n\t\t\tStore our results since we will fill a panel with each repository's results and one with all.\n\t\t\tWe can't get the iterator contents again, without re-doing the search.\n\t\t\t\n\t\t\tWe know the repositories we searched.  Some may have returned results, others may not.  We will\n\t\t\tmake a vector for each set of results with a parallel vector of repository ids.\n\t\t */\n\t\tjava.util.Vector resultVector = new java.util.Vector();\n\t\tjava.util.Vector repositoryIdStringVector = new java.util.Vector();\n        java.util.Vector repositoryDisplayNameVector = new java.util.Vector();\n\t\tjava.util.Vector allResultVector = new java.util.Vector();\n\t\t\n        org.osid.repository.Repository[] repositories = sourcesAndTypesManager.getRepositoriesToSearch();\n\t\tint numRepositories = repositories.length;\n\t\tfor (int i=0; i < numRepositories; i++) {\n\t\t\trepositoryIdStringVector.addElement(repositories[i].getId().getIdString());\n            repositoryDisplayNameVector.addElement(repositories[i].getDisplayName());\n\t\t\tresultVector.addElement(new java.util.Vector());\n\t\t}\n\t\t\n\t\torg.osid.repository.AssetIterator assetIterator = resultSetManager.getAssets();\n\t\twhile (assetIterator.hasNextAsset()) {\n\t\t\torg.osid.repository.Asset nextAsset = assetIterator.nextAsset();\n\t\t\tString repositoryIdString = nextAsset.getRepository().getIdString();\n\t\t\tint index = repositoryIdStringVector.indexOf(repositoryIdString);\n\t\t\tjava.util.Vector v = (java.util.Vector)resultVector.elementAt(index);\n\n\t\t\tOsid2AssetResource resource = new Osid2AssetResource(nextAsset, this.context);\t\t\t\n\t\t\tv.addElement(resource);\n\t\t\tallResultVector.addElement(resource);\n\t\t}\n\t\t\n\t\t// fill our results stack with individual results and aggregate results\t\t\n\t\t//JPanel repositorySpecificResults[] = new JPanel[numRepositories];\n\t\t//VueDragTree resultSetTrees[] = new VueDragTree[numRepositories];\n\t\t//ResourceList resultSetLists[] = new ResourceList[numRepositories];\n                \n                for (int i = 0; i < numRepositories; i++) {\t\t\t\n                    java.util.Vector v = (java.util.Vector)resultVector.elementAt(i);\n                    String name = (String)repositoryDisplayNameVector.elementAt(i);\n\n                    if (v.size() == 0) {\n                        resultsStack.addPane(name, new JLabel(\"  No results\"), 0f);\n                        continue;\n                    }\n\n                    name += \" (\" + v.size() + \")\";\n\n                    JComponent resultSet = new ResourceList(v.iterator());\n                    \n                    if (UseSingleScrollPane) {\n                        resultsStack.addPane(name, resultSet);\n                    } else {\n                        resultsStack.addPane(name, new JScrollPane(resultSet));\n                    }\n                }\n\n        // Do this on AWT thread to make sure we\n        // don't collide with anything going on there.\n        \n        GUI.invokeAfterAWT(new Runnable() {\n                public void run() {\n                    displaySearchResults(resultsStack, dockTitle);\n                }\n            });\n    }","id":99536,"modified_method":"private synchronized void performSearchAndDisplayResults()\n        throws org.osid.repository.RepositoryException,\n               org.osid.shared.SharedException\n    {\n        //final String dockTitle = \"Search Results for \\\"\" + queryEditor.getSearchDisplayName() + \"\\\"\";\n        final String searchString = \"\\\"\" + queryEditor.getSearchDisplayName() + \"\\\"\";\n\n        /*\n          Store our results since we will fill a panel with each repository's results and one with all.\n          We can't get the iterator contents again, without re-doing the search.\n          \n          We know the repositories we searched.  Some may have returned results, others may not.  We will\n          make a vector for each set of results with a parallel vector of repository ids.\n        */\n\n        final java.util.List resultList = new java.util.ArrayList();\n        final java.util.List repositoryIdStringList = new java.util.ArrayList();\n        final java.util.List repositoryDisplayNameList = new java.util.ArrayList();\n        //final java.util.Vector allResultList = new java.util.Vector();\n\t\t\n        org.osid.repository.Repository[] repositories = sourcesAndTypesManager.getRepositoriesToSearch();\n\n        final WidgetStack resultsStack = new WidgetStack(\"searchResults \" + searchString);\n        final Widget[] resultPanes = new Widget[repositories.length];\n\n        for (int i = 0; i < repositories.length; i++) {\n            org.osid.repository.Repository r = repositories[i];\n            if (DEBUG.DR) out(\"to search: \" + r.getDisplayName() + \" \\t\" + r);\n            repositoryIdStringList.add(r.getId().getIdString());\n            repositoryDisplayNameList.add(r.getDisplayName());\n            resultList.add(new java.util.ArrayList());\n\n            resultPanes[i] = new Widget(\"Searching \" + r.getDisplayName());\n            resultPanes[i].add(new StatusLabel(\"Searching for \" + searchString + \" ...\", true));\n            resultsStack.addPane(resultPanes[i], 0f);\n        }\n\n        DRB.searchPane.add(resultsStack, DRBrowser.SEARCH_RESULT);\n\n        /*\n        if (SearchingLabel == null) {\n            SearchingLabel = new JLabel(\"Searching...\", JLabel.CENTER);                \n            SearchingLabel.setOpaque(false);\n        }\n\n        DRB.searchPane.add(SearchingLabel, DRBrowser.SEARCH_RESULT);\n\n        if (resultSetDockWindow != null) {\n            resultSetDockWindow.setTitle(dockTitle);\n\n            if (false&&UseSingleScrollPane)\n                resultSetTreeJSP.setViewportView(SearchingLabel);\n            else\n                resultSetDockWindow.setContent(SearchingLabel);\n        }\n        */\n        \n\n        // get our search results\n        java.io.Serializable searchCriteria = queryEditor.getCriteria();\n        if (DEBUG.DR) {\n            out(\"Searching criteria [\" + searchCriteria + \"] in selected repositories. SearchProps=\" + queryEditor.getProperties());\n        }\n        org.osid.shared.Properties searchProperties = queryEditor.getProperties();\n\t\t\t\t\n        edu.tufts.vue.fsm.ResultSetManager resultSetManager\n            = federatedSearchManager.getResultSetManager(searchCriteria,\n                                                         searchType,\n                                                         searchProperties);\t\t\n        if (DEBUG.DR) out(\"got result set manager \" + resultSetManager);\n        \n\t\t\n        org.osid.repository.AssetIterator assetIterator = resultSetManager.getAssets();\n        while (assetIterator.hasNextAsset()) {\n            org.osid.repository.Asset nextAsset = assetIterator.nextAsset();\n            String repositoryIdString = nextAsset.getRepository().getIdString();\n            int index = repositoryIdStringList.indexOf(repositoryIdString);\n            java.util.List v = (java.util.List) resultList.get(index);\n\n            Osid2AssetResource resource = new Osid2AssetResource(nextAsset, this.context);\t\t\t\n            v.add(resource);\n            //allResultList.addElement(resource);\n        }\n\n        // Display the results in the result panes\n\t\t\n        for (int i = 0; i < repositories.length; i++) {\t\t\t\n            java.util.List v = (java.util.List) resultList.get(i);\n            String name = \"Results: \" + (String) repositoryDisplayNameList.get(i);\n            if (DEBUG.DR) out(name + \": \" + v.size() + \" results\");\n                    \n            if (v.size() > 0) name += \" (\" + v.size() + \")\";\n\n            resultPanes[i].setTitle(name);\n            resultPanes[i].removeAll();\n\n            if (v.size() == 0) {\n                //resultsStack.addPane(name, new JLabel(\"  No results\"), 0f);\n                resultPanes[i].add(new StatusLabel(\"No results for \" + searchString, false));\n            } else {\n                resultPanes[i].add(new ResourceList(v.iterator()));\n            }\n\n            /*\n            JComponent resultSet = new ResourceList(v.iterator());\n            if (UseSingleScrollPane) {\n                resultsStack.addPane(name, resultSet);\n            } else {\n                resultsStack.addPane(name, new JScrollPane(resultSet));\n            }\n            */\n        }\n\n    }","commit_id":"b6ca7393f16790f5bb42cf71e870a4e6ff3b4bea","url":"https://github.com/VUE/VUE"},{"original_method":"public void searchPerformed(edu.tufts.vue.fsm.event.SearchEvent se)\n    {\n        new Thread(\"VUE-Search\") {\n            public void run() {\n                if (DEBUG.DR || DEBUG.THREAD) out(\"search thread kicked off\");\n                try {\n                    performSearchAndDisplayResults();\n                } catch (Throwable t) {\n                    tufts.Util.printStackTrace(t);\n                    if (DEBUG.Enabled)\n                        VueUtil.alert(\"Search Error\", t);\n                    else\n                        VueUtil.alert(t.getMessage(), \"Search Error\");\n                } finally {\n                    queryEditor.refresh();\n                }\n            }\n        }.start();\n    }","id":99537,"modified_method":"public void searchPerformed(edu.tufts.vue.fsm.event.SearchEvent se)\n    {\n        if (DEBUG.DR) {\n            System.out.println(\"\\n\");\n            out(\"Search includes:\");\n            edu.tufts.vue.dsm.DataSource dataSources[] = dataSourceManager.getDataSources();\n            for (int i = 0; i < dataSources.length; i++) {\n                edu.tufts.vue.dsm.DataSource ds = dataSources[i];\n                System.out.print(\"\\t\");\n                if (ds.isIncludedInSearch()) {\n                    System.out.print(\"+ \");\n                } else {\n                    System.out.print(\"- \");\n                }\n                System.out.println(ds.getProviderDisplayName() + \" \\t\" + ds);\n            }\n        }\n\n\n        new Thread(\"VUE-Search\") {\n            public void run() {\n                if (DEBUG.DR || DEBUG.THREAD) out(\"search thread kicked off\");\n                try {\n                    performSearchAndDisplayResults();\n                } catch (Throwable t) {\n                    tufts.Util.printStackTrace(t);\n                    if (DEBUG.Enabled)\n                        VueUtil.alert(\"Search Error\", t);\n                    else\n                        VueUtil.alert(t.getMessage(), \"Search Error\");\n                } finally {\n                    queryEditor.refresh();\n                }\n            }\n        }.start();\n    }","commit_id":"b6ca7393f16790f5bb42cf71e870a4e6ff3b4bea","url":"https://github.com/VUE/VUE"},{"original_method":"public DataSourceViewer(DRBrowser drBrowser)\n    {\n        setLayout(new BorderLayout());\n        this.DRB = drBrowser;\n\t\t\t\t\n        dataSourceList = new DataSourceList(this);\n        dataSourceList.addKeyListener(this);\n                \n        dataSourceManager = edu.tufts.vue.dsm.impl.VueDataSourceManager.getInstance();\n        edu.tufts.vue.dsm.DataSource dataSources[] = dataSourceManager.getDataSources();\n        for (int i=0; i < dataSources.length; i++) {\n            dataSourceList.getContents().addElement(dataSources[i]);\n        }\n        loadDefaultDataSources();\n\t\t\t\t\n        federatedSearchManager = edu.tufts.vue.fsm.impl.VueFederatedSearchManager.getInstance();\t\t\n        sourcesAndTypesManager = edu.tufts.vue.fsm.impl.VueSourcesAndTypesManager.getInstance();\n        queryEditor = federatedSearchManager.getQueryEditorForType(new edu.tufts.vue.util.Type(\"mit.edu\",\"search\",\"keyword\"));\n        queryEditor.addSearchListener(this);\n\n        if (false) {\n            ((JPanel)queryEditor).setSize(new Dimension(100,90));\n            ((JPanel)queryEditor).setPreferredSize(new Dimension(100,90));\n            ((JPanel)queryEditor).setMinimumSize(new Dimension(100,90));\n        }\n\n        DRB.searchPane.removeAll();\n        DRB.searchPane.add((JPanel) queryEditor);\n        DRB.searchPane.revalidate();\n        DRB.searchPane.repaint();\n\t\t\n        // WORKING: stop using this preview panel?\n        //this.previewPanel = previewDockWindow.getWidgetPanel();\n\n        initResultSetDockWindow();\n\t\t\n        dataSourceList.clearSelection();\n\t\t\n        setPopup();\n        // WORKING: commented out\n        //librariesDockWindow.setVisible(true); // try to make menu appear\n        dataSourceList.addListSelectionListener(new ListSelectionListener() {\n                public void valueChanged(ListSelectionEvent e) {\t\t\t\t\n                    Object o = ((JList)e.getSource()).getSelectedValue();\n                    if (o !=null) {\n                        // for the moment, we are doing double work to keep old data sources\n                        if (o instanceof tufts.vue.DataSource) {\n                            DataSource ds = (DataSource)o;\n                            DataSourceViewer.this.setActiveDataSource(ds);\n                        } else if (o instanceof edu.tufts.vue.dsm.DataSource) {\n                            edu.tufts.vue.dsm.DataSource ds = (edu.tufts.vue.dsm.DataSource)o;\n                            DataSourceViewer.this.setActiveDataSource(ds);\n\t\t\t\t\t\t\trefreshEditInfo(ds);\n                        }\n                        else\n                            {\n                                int index = ((JList)e.getSource()).getSelectedIndex();\n                                o = dataSourceList.getContents().getElementAt(index-1);\n                                if (o instanceof tufts.vue.DataSource) {\n                                    DataSource ds = (DataSource)o;\n                                    DataSourceViewer.this.setActiveDataSource(ds);\n                                } else if (o instanceof edu.tufts.vue.dsm.DataSource) {\n                                    edu.tufts.vue.dsm.DataSource ds = (edu.tufts.vue.dsm.DataSource)o;\n                                    DataSourceViewer.this.setActiveDataSource(ds);\n\t\t\t\t\t\t\t\t\trefreshEditInfo(ds);\n                                }\n                            }\n                    }\n\t\t\t\t\trefreshMenuActions();\n\t\t\t\t}}\n            );\n\n        dataSourceList.addMouseListener(new MouseAdapter() {\n                public void mouseClicked(MouseEvent e) {\n                    Point pt = e.getPoint();\n                    // see if we are far enough over to the left to be on the checkbox\n                    if ( (activeDataSource instanceof edu.tufts.vue.dsm.DataSource) && (pt.x <= 40) ) {\n                        int index = dataSourceList.locationToIndex(pt);\n                        edu.tufts.vue.dsm.DataSource ds = (edu.tufts.vue.dsm.DataSource)dataSourceList.getModel().getElementAt(index);\n                        boolean included = !ds.isIncludedInSearch();\n                        ds.setIncludedInSearch(included);\n                        if (DEBUG.DR) out(\"DataSource \" + ds + \" [\" + ds.getProviderDisplayName() + \"] inclusion: \" + included); \n                        //ds.setIncludedInSearch(!ds.isIncludedInSearch());\n                        dataSourceManager.save();\n                        dataSourceList.repaint();\n                        queryEditor.refresh();\n                    }\n                    //                if(e.getButton() == e.BUTTON3) {\n                    //                    popup.show(e.getComponent(), e.getX(), e.getY());\n                    //                }\n                }\n            });\n\n\t\tJScrollPane dataJSP = new JScrollPane(dataSourceList);\n\t\tdataJSP.setMinimumSize(new Dimension(100,100));\n\t\tadd(dataJSP);\n    }","id":99538,"modified_method":"public DataSourceViewer(DRBrowser drBrowser)\n    {\n        setLayout(new BorderLayout());\n        this.DRB = drBrowser;\n\t\t\t\t\n        dataSourceList = new DataSourceList(this);\n        dataSourceList.addKeyListener(this);\n                \n        dataSourceManager = edu.tufts.vue.dsm.impl.VueDataSourceManager.getInstance();\n        edu.tufts.vue.dsm.DataSource dataSources[] = dataSourceManager.getDataSources();\n        for (int i=0; i < dataSources.length; i++) {\n            dataSourceList.getContents().addElement(dataSources[i]);\n        }\n        loadDefaultDataSources();\n\t\t\t\t\n        federatedSearchManager = edu.tufts.vue.fsm.impl.VueFederatedSearchManager.getInstance();\t\t\n        sourcesAndTypesManager = edu.tufts.vue.fsm.impl.VueSourcesAndTypesManager.getInstance();\n        queryEditor = federatedSearchManager.getQueryEditorForType(new edu.tufts.vue.util.Type(\"mit.edu\",\"search\",\"keyword\"));\n        queryEditor.addSearchListener(this);\n\n        DRB.searchPane.removeAll();\n        DRB.searchPane.add((JPanel) queryEditor, DRBrowser.SEARCH_EDITOR);\n        DRB.searchPane.revalidate();\n        DRB.searchPane.repaint();\n\t\t\n        // WORKING: stop using this preview panel?\n        //this.previewPanel = previewDockWindow.getWidgetPanel();\n\n        //resultSetDockWindow = DRB.searchDock;\n\t\t\n        dataSourceList.clearSelection();\n\t\t\n        setPopup();\n        // WORKING: commented out\n        //librariesDockWindow.setVisible(true); // try to make menu appear\n        dataSourceList.addListSelectionListener(new ListSelectionListener() {\n                public void valueChanged(ListSelectionEvent e) {\t\t\t\t\n                    Object o = ((JList)e.getSource()).getSelectedValue();\n                    if (o !=null) {\n                        // for the moment, we are doing double work to keep old data sources\n                        if (o instanceof tufts.vue.DataSource) {\n                            DataSource ds = (DataSource)o;\n                            DataSourceViewer.this.setActiveDataSource(ds);\n                        } else if (o instanceof edu.tufts.vue.dsm.DataSource) {\n                            edu.tufts.vue.dsm.DataSource ds = (edu.tufts.vue.dsm.DataSource)o;\n                            DataSourceViewer.this.setActiveDataSource(ds);\n\t\t\t\t\t\t\trefreshEditInfo(ds);\n                        }\n                        else\n                            {\n                                int index = ((JList)e.getSource()).getSelectedIndex();\n                                o = dataSourceList.getContents().getElementAt(index-1);\n                                if (o instanceof tufts.vue.DataSource) {\n                                    DataSource ds = (DataSource)o;\n                                    DataSourceViewer.this.setActiveDataSource(ds);\n                                } else if (o instanceof edu.tufts.vue.dsm.DataSource) {\n                                    edu.tufts.vue.dsm.DataSource ds = (edu.tufts.vue.dsm.DataSource)o;\n                                    DataSourceViewer.this.setActiveDataSource(ds);\n\t\t\t\t\t\t\t\t\trefreshEditInfo(ds);\n                                }\n                            }\n                    }\n\t\t\t\t\trefreshMenuActions();\n\t\t\t\t}}\n            );\n\n        dataSourceList.addMouseListener(new MouseAdapter() {\n                public void mouseClicked(MouseEvent e) {\n                    Point pt = e.getPoint();\n                    // see if we are far enough over to the left to be on the checkbox\n                    if ( (activeDataSource instanceof edu.tufts.vue.dsm.DataSource) && (pt.x <= 40) ) {\n                        int index = dataSourceList.locationToIndex(pt);\n                        edu.tufts.vue.dsm.DataSource ds = (edu.tufts.vue.dsm.DataSource)dataSourceList.getModel().getElementAt(index);\n                        boolean included = !ds.isIncludedInSearch();\n                        ds.setIncludedInSearch(included);\n                        if (DEBUG.DR) out(\"DataSource \" + ds + \" [\" + ds.getProviderDisplayName() + \"] inclusion: \" + included); \n                        //ds.setIncludedInSearch(!ds.isIncludedInSearch());\n                        dataSourceManager.save();\n                        dataSourceList.repaint();\n                        queryEditor.refresh();\n                    }\n                    //                if(e.getButton() == e.BUTTON3) {\n                    //                    popup.show(e.getComponent(), e.getX(), e.getY());\n                    //                }\n                }\n            });\n\n        if (false) {\n            JScrollPane dataJSP = new JScrollPane(dataSourceList);\n            dataJSP.setMinimumSize(new Dimension(100,100));\n            add(dataJSP);\n        } else {\n            add(dataSourceList);\n        }\n            \n    }","commit_id":"b6ca7393f16790f5bb42cf71e870a4e6ff3b4bea","url":"https://github.com/VUE/VUE"},{"original_method":"public void setActiveDataSource(edu.tufts.vue.dsm.DataSource ds)\n    {        \n        this.activeDataSource = ds;\n        \n        //        refreshDataSourcePanel(ds);\n        \n        dataSourceList.setSelectedValue(ds,true);\n        \n        DRB.browsePane.setHidden(true);\n        DRB.searchPane.setExpanded(true);\n    }","id":99539,"modified_method":"public void setActiveDataSource(edu.tufts.vue.dsm.DataSource ds)\n    {        \n        this.activeDataSource = ds;\n        \n        //        refreshDataSourcePanel(ds);\n        \n        dataSourceList.setSelectedValue(ds,true);\n        \n        Widget.setHidden(DRB.browsePane, true);\n        Widget.setExpanded(DRB.searchPane, true);\n    }","commit_id":"b6ca7393f16790f5bb42cf71e870a4e6ff3b4bea","url":"https://github.com/VUE/VUE"},{"original_method":"public void setActiveDataSource(DataSource ds){\n\n        System.out.println(\"SET ACTIVE DATA SOURCE \" + ds);\n        \n        this.activeDataSource = ds;\n        \n        //        refreshDataSourcePanel(ds);\n        \n        dataSourceList.setSelectedValue(ds,true);\n        \n        DRB.searchPane.setExpanded(false);\n        if (ds instanceof LocalFileDataSource) {\n            DRB.browsePane.setHidden(false);\n            DRB.browsePane.setExpanded(true);\n            //DRB.savedResourcesPane.setExpanded(false);\n        } else if (ds instanceof FavoritesDataSource) {\n            //DRB.savedResourcesPane.setExpanded(true);\n            DRB.browsePane.setHidden(false);\n            DRB.browsePane.setExpanded(true);\n        }\n        \n    }","id":99540,"modified_method":"public void setActiveDataSource(DataSource ds){\n\n        if (DEBUG.DR) out(\"SET ACTIVE DATA SOURCE \" + ds);\n        \n        this.activeDataSource = ds;\n        \n        //        refreshDataSourcePanel(ds);\n        \n        dataSourceList.setSelectedValue(ds,true);\n        \n        Widget.setExpanded(DRB.searchPane, false);\n        //Widget.setHidden(DRB.searchPane, true);\n        \n        if (ds instanceof LocalFileDataSource) {\n            Widget.setExpanded(DRB.browsePane, true);\n            //Widget.setHidden(DRB.browsePane, false);\n            //Widget.setExpanded(DRB.browsePane, true);\n            //DRB.savedResourcesPane.setExpanded(false);\n        } else if (ds instanceof FavoritesDataSource) {\n            //DRB.savedResourcesPane.setExpanded(true);\n            Widget.setExpanded(DRB.browsePane, true);\n            //Widget.setHidden(DRB.browsePane, false);\n            //Widget.setExpanded(DRB.browsePane, true);\n        } else\n            Widget.setHidden(DRB.browsePane, true);\n        \n    }","commit_id":"b6ca7393f16790f5bb42cf71e870a4e6ff3b4bea","url":"https://github.com/VUE/VUE"},{"original_method":"private void out(Object o) {\n        System.err.println(\"DSV: \" + (o==null?\"null\":o.toString()));\n    }","id":99541,"modified_method":"private void out(Object o) {\n        System.err.println(\"DSV \" \n                           + new Long(System.currentTimeMillis()).toString().substring(8)\n                           + \" [\" + Thread.currentThread().getName() + \"] \"\n                           + (o==null?\"null\":o.toString()));\n    }","commit_id":"b6ca7393f16790f5bb42cf71e870a4e6ff3b4bea","url":"https://github.com/VUE/VUE"},{"original_method":"public void close() throws IOException {\n\n        // Write the iPOJO header (including manipulation metadata)\n        StringBuilder builder = new StringBuilder();\n\n        if (m_includeEmbedComponents) {\n            // Incorporate metadata of embed dependencies (if any)\n            for (Jar jar : m_analyzer.getClasspath()) {\n                try {\n                    Manifest manifest = jar.getManifest();\n                    Attributes main = manifest.getMainAttributes();\n                    String components = Manifests.getComponents(main);\n                    if (components != null) {\n                        m_reporter.progress(\"Merging components from %s\", jar.getName());\n                        builder.append(components);\n                    }\n                } catch (Exception e) {\n                    m_reporter.warning(\"Cannot open MANIFEST of %s\", jar.getName());\n                }\n            }\n        }\n\n        for (Element metadata : m_metadata) {\n            builder.append(m_renderer.render(metadata));\n        }\n\n        if (builder.length() != 0) {\n            m_analyzer.setProperty(\"IPOJO-Components\", builder.toString());\n        }\n\n        // Add some mandatory imported packages\n        Map<String, String> version = new TreeMap<String, String>();\n        version.put(\"version\", Constants.getPackageImportClause());\n\n        if (m_analyzer.getReferred().get(\"org.apache.felix.ipojo\") == null) {\n            m_analyzer.getReferred().put(\"org.apache.felix.ipojo\", version);\n        }\n        if (m_analyzer.getReferred().get(\"org.apache.felix.ipojo.architecture\") == null) {\n            m_analyzer.getReferred().put(\"org.apache.felix.ipojo.architecture\", version);\n        }\n        if (m_analyzer.getReferred().get(\"org.osgi.service.cm\") == null) {\n            Map<String, String> cm = new TreeMap<String, String>();\n            cm.put(\"version\", \"1.2\");\n            m_analyzer.getReferred().put(\"org.osgi.service.cm\", cm);\n        }\n        if (m_analyzer.getReferred().get(\"org.osgi.service.log\") == null) {\n            Map<String, String> log = new TreeMap<String, String>();\n            log.put(\"version\", \"1.3\");\n            m_analyzer.getReferred().put(\"org.osgi.service.log\", log);\n        }\n\n\n    }","id":99542,"modified_method":"public void close() throws IOException {\n\n        // Write the iPOJO header (including manipulation metadata)\n        StringBuilder builder = new StringBuilder();\n\n        if (m_includeEmbedComponents) {\n            // Incorporate metadata of embed dependencies (if any)\n            for (Jar jar : m_analyzer.getClasspath()) {\n                try {\n                    Manifest manifest = jar.getManifest();\n                    Attributes main = manifest.getMainAttributes();\n                    String components = Manifests.getComponents(main);\n                    if (components != null) {\n                        m_reporter.trace(\"Merging components from %s\", jar.getName());\n                        builder.append(components);\n                    }\n                } catch (Exception e) {\n                    m_reporter.warning(\"Cannot open MANIFEST of %s\", jar.getName());\n                }\n            }\n        }\n\n        for (Element metadata : m_metadata) {\n            builder.append(m_renderer.render(metadata));\n        }\n\n        if (builder.length() != 0) {\n            m_analyzer.setProperty(\"IPOJO-Components\", builder.toString());\n        }\n\n        // Add some mandatory imported packages\n        Attrs version = new Attrs();\n        version.put(\"version:Version\", Constants.getPackageImportClause());\n\n        if (!m_analyzer.getReferred().containsFQN(\"org.apache.felix.ipojo\")) {\n            m_analyzer.getReferred().put(m_analyzer.getPackageRef(\"org.apache.felix.ipojo\"),\n                                         version);\n        }\n        if (!m_analyzer.getReferred().containsFQN(\"org.apache.felix.ipojo.architecture\")) {\n            m_analyzer.getReferred().put(m_analyzer.getPackageRef(\"org.apache.felix.ipojo.architecture\"),\n                                         version);\n        }\n        if (!m_analyzer.getReferred().containsFQN(\"org.osgi.service.cm\")) {\n            Attrs cm = new Attrs();\n            cm.put(\"version:Version\", \"1.2\");\n            m_analyzer.getReferred().put(m_analyzer.getPackageRef(\"org.osgi.service.cm\"),\n                                         cm);\n        }\n        if (!m_analyzer.getReferred().containsFQN(\"org.osgi.service.log\")) {\n            Attrs log = new Attrs();\n            log.put(\"version:Version\", \"1.3\");\n            m_analyzer.getReferred().put(m_analyzer.getPackageRef(\"org.osgi.service.log\"),\n                                         log);\n        }\n\n\n    }","commit_id":"1735ea57beabcc40701a7a76f59b8bf77c296fa0","url":"https://github.com/apache/felix"},{"original_method":"public void writeMetadata(Element metadata) {\n        m_metadata.add(metadata);\n\n        // Find referred packages and add them into Bnd\n        for (String referred : Metadatas.findReferredPackages(metadata)) {\n            if (m_analyzer.getReferred().get(referred) == null) {\n                // The given package is not referred ATM\n                m_analyzer.getReferred().put(referred, new HashMap<String, String>());\n            }\n        }\n\n        // IPOJO-Components will be written during the close method.\n    }","id":99543,"modified_method":"public void writeMetadata(Element metadata) {\n        m_metadata.add(metadata);\n\n        // Find referred packages and add them into Bnd\n        for (String referred : Metadatas.findReferredPackages(metadata)) {\n            if (!m_analyzer.getReferred().containsFQN(referred)) {\n                // The given package is not referred ATM\n                m_analyzer.getReferred().put(m_analyzer.getPackageRef(referred),\n                                             new Attrs());\n            }\n        }\n\n        // IPOJO-Components will be written during the close method.\n    }","commit_id":"1735ea57beabcc40701a7a76f59b8bf77c296fa0","url":"https://github.com/apache/felix"},{"original_method":"private Collection<Clazz> filter(Collection<Clazz> classes) throws Exception {\n        Set<Clazz> manipulable = new HashSet<Clazz>();\n        for (Clazz clazz : classes) {\n\n            // If it is i the main jar, simply use it\n            if (m_analyzer.getJar().getResource(clazz.getPath()) != null) {\n                manipulable.add(clazz);\n                continue;\n            }\n\n            if (m_includeEmbedComponents) {\n                // Otherwise ...\n                // Try to see if it is in an embed dependencies\n                Jar jar = findJar(clazz.getPath());\n                if (jar == null) {\n                    m_reporter.error(\"Resource for class %s not found in classpath\", clazz.getFQN());\n                    continue;\n                }\n\n                // Is it a Bundle ?\n                if (jar.getBsn() != null) {\n                    // OSGi Bundle case\n\n                    // Check if the bundle was manipulated before\n                    Attributes attr = jar.getManifest().getMainAttributes();\n                    if (Manifests.getComponents(attr) != null) {\n                        // Bundle has been previously manipulated\n                        // TODO We should ignore the resource since it was already manipulated\n                        // TODO But we should also merge its IPOJO-Components header\n                    } else {\n                        // Bundle was not manipulated\n                        manipulable.add(clazz);\n                    }\n\n                } else  {\n                    // Simple Jar file with iPOJO annotations\n                    m_reporter.warning(\"Class %s found in a non-Bundle archive %s\", clazz.getFQN(), jar.getName());\n                    continue;\n                }\n            } else {\n                m_reporter.warning(\"Embed components are excluded, Component %s will not be manipulated\", clazz.getFQN());\n            }\n        }\n        return manipulable;\n    }","id":99544,"modified_method":"private Collection<Clazz> filter(Collection<Clazz> classes) throws Exception {\n        Set<Clazz> manipulable = new HashSet<Clazz>();\n        for (Clazz clazz : classes) {\n\n            // If it is i the main jar, simply use it\n            if (m_analyzer.getJar().getResource(clazz.getAbsolutePath()) != null) {\n                manipulable.add(clazz);\n                continue;\n            }\n\n            if (m_includeEmbedComponents) {\n                // Otherwise ...\n                // Try to see if it is in an embed dependencies\n                Jar jar = findJar(clazz.getAbsolutePath());\n                if (jar == null) {\n                    m_reporter.error(\"Resource for class %s not found in classpath\", clazz.getFQN());\n                    continue;\n                }\n\n                // Is it a Bundle ?\n                if (jar.getBsn() != null) {\n                    // OSGi Bundle case\n\n                    // Check if the bundle was manipulated before\n                    Attributes attr = jar.getManifest().getMainAttributes();\n                    if (Manifests.getComponents(attr) != null) {\n                        // Bundle has been previously manipulated\n                        // TODO We should ignore the resource since it was already manipulated\n                        // TODO But we should also merge its IPOJO-Components header\n                    } else {\n                        // Bundle was not manipulated\n                        manipulable.add(clazz);\n                    }\n\n                } else  {\n                    // Simple Jar file with iPOJO annotations\n                    m_reporter.warning(\"Class %s found in a non-Bundle archive %s\", clazz.getFQN(), jar.getName());\n                    continue;\n                }\n            } else {\n                m_reporter.warning(\"Embed components are excluded, Component %s will not be manipulated\", clazz.getFQN());\n            }\n        }\n        return manipulable;\n    }","commit_id":"1735ea57beabcc40701a7a76f59b8bf77c296fa0","url":"https://github.com/apache/felix"},{"original_method":"public void accept(ResourceVisitor visitor) {\n\n        try {\n            // Collect all annotated classes\n            Collection<Clazz> classes = m_analyzer.getClasses(\"\",\n                    Clazz.QUERY.CLASSANNOTATIONS.name());\n\n            classes = filter(classes);\n\n            // Iterates over discovered resources\n            for (Clazz clazz : classes) {\n                visitor.visit(clazz.getPath());\n            }\n        } catch (Exception e) {\n            m_reporter.error(\"Cannot find iPOJO annotated types: \" + e.getMessage());\n        }\n    }","id":99545,"modified_method":"public void accept(ResourceVisitor visitor) {\n\n        try {\n            // Collect all annotated classes\n            Collection<Clazz> classes = m_analyzer.getClasses(\"\",\n                    Clazz.QUERY.CLASSANNOTATIONS.name());\n\n            classes = filter(classes);\n\n            // Iterates over discovered resources\n            for (Clazz clazz : classes) {\n                visitor.visit(clazz.getAbsolutePath());\n            }\n        } catch (Exception e) {\n            m_reporter.error(\"Cannot find iPOJO annotated types: \" + e.getMessage());\n        }\n    }","commit_id":"1735ea57beabcc40701a7a76f59b8bf77c296fa0","url":"https://github.com/apache/felix"},{"original_method":"public void testAnalysisWithLocallyDefinedComponentAndEmbedResource() throws Exception {\n        PojoizationPlugin plugin = new PojoizationPlugin();\n\n        Map<String, String> props = new HashMap<String, String>();\n        props.put(\"include-embed-bundles\", \"true\");\n        String path = EmptyComponent.class.getName().replace('.', '/').concat(\".class\");\n\n        Resource resource2 = new URLResource(getClass().getResource(\"/metadata-test-component.xml\"));\n        doReturn(dot).when(analyzer).getJar();\n        doReturn(resource2).when(dot).getResource(eq(\"META-INF/metadata.xml\"));\n\n        Collection<Clazz> classes = new ArrayList<Clazz>();\n        Resource typeResource = new URLResource(getClass().getResource(\"EmptyComponent.class\"));\n        Clazz clazz = new Clazz(path, typeResource);\n        clazz.parseClassFile();\n        classes.add(clazz);\n        doReturn(classes).when(analyzer).getClasses(Matchers.<String[]>anyVararg());\n\n        Resource resource = new URLResource(getClass().getResource(\"/EMBED-MANIFEST-EMPTY.MF\"));\n        doReturn(resource).when(embed).getResource(eq(\"META-INF/MANIFEST.MF\"));\n        doReturn(typeResource).when(embed).getResource(path);\n        doReturn(\"aaa\").when(embed).getBsn();\n\n        analyzer.setClasspath(new Jar[] {embed});\n\n        plugin.setReporter(reporter);\n        plugin.setProperties(props);\n\n        plugin.analyzeJar(analyzer);\n\n        assertContains(\"component { $classname=\\\"org.apache.felix.ipojo.bnd.EmptyComponent\\\" manipulation { method { $name=\\\"$init\\\" }}}\",\n                analyzer.getProperty(\"IPOJO-Components\"));\n        verify(dot).putResource(eq(path), any(Resource.class));\n    }","id":99546,"modified_method":"public void testAnalysisWithLocallyDefinedComponentAndEmbedResource() throws Exception {\n        PojoizationPlugin plugin = new PojoizationPlugin();\n\n        Map<String, String> props = new HashMap<String, String>();\n        props.put(\"include-embed-bundles\", \"true\");\n        String path = EmptyComponent.class.getName().replace('.', '/').concat(\".class\");\n\n        Resource resource2 = new URLResource(getClass().getResource(\"/metadata-test-component.xml\"));\n        doReturn(dot).when(analyzer).getJar();\n        doReturn(resource2).when(dot).getResource(eq(\"META-INF/metadata.xml\"));\n\n        Collection<Clazz> classes = new ArrayList<Clazz>();\n        Resource typeResource = new URLResource(getClass().getResource(\"EmptyComponent.class\"));\n        Clazz clazz = new Clazz(analyzer, path, typeResource);\n        clazz.parseClassFile();\n        classes.add(clazz);\n        doReturn(classes).when(analyzer).getClasses(Matchers.<String[]>anyVararg());\n\n        Resource resource = new URLResource(getClass().getResource(\"/EMBED-MANIFEST-EMPTY.MF\"));\n        doReturn(resource).when(embed).getResource(eq(\"META-INF/MANIFEST.MF\"));\n        doReturn(typeResource).when(embed).getResource(path);\n        doReturn(\"aaa\").when(embed).getBsn();\n\n        analyzer.setClasspath(new Jar[] {embed});\n\n        plugin.setReporter(reporter);\n        plugin.setProperties(props);\n\n        plugin.analyzeJar(analyzer);\n\n        assertContains(\"component { $classname=\\\"org.apache.felix.ipojo.bnd.EmptyComponent\\\" manipulation { method { $name=\\\"$init\\\" }}}\",\n                analyzer.getProperty(\"IPOJO-Components\"));\n        verify(dot).putResource(eq(path), any(Resource.class));\n    }","commit_id":"1735ea57beabcc40701a7a76f59b8bf77c296fa0","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    public void info(String message, Object... args) {\n        m_reporter.progress(message, args);\n    }","id":99547,"modified_method":"@Override\n    public void info(String message, Object... args) {\n        m_reporter.trace(message, args);\n    }","commit_id":"1735ea57beabcc40701a7a76f59b8bf77c296fa0","url":"https://github.com/apache/felix"},{"original_method":"public BndReporter(aQute.libg.reporter.Reporter reporter) {\n        m_reporter = reporter;\n    }","id":99548,"modified_method":"public BndReporter(Reporter reporter) {\n        m_reporter = reporter;\n    }","commit_id":"1735ea57beabcc40701a7a76f59b8bf77c296fa0","url":"https://github.com/apache/felix"},{"original_method":"public boolean analyzeJar(Analyzer analyzer) throws Exception {\n\n        long start = System.currentTimeMillis();\n\n        // Wraps the Bnd Reporter\n        BndReporter reporter = new BndReporter(this.m_reporter);\n\n        // Build ResourceStore\n        BndJarResourceStore store = new BndJarResourceStore(analyzer, this.m_reporter);\n        store.setIncludeEmbedComponents(m_includeEmbedBundles);\n\n        CompositeMetadataProvider provider = buildMetadataProvider(analyzer, reporter, store);\n\n        // Quick exit\n        CacheableMetadataProvider cache = new CacheableMetadataProvider(provider);\n        if (cache.getMetadatas().isEmpty() && !hasEmbedComponents(analyzer)) {\n            return false;\n        }\n\n        manipulateComponents(reporter, store, cache);\n\n        int nbComponents = findElements(cache.getMetadatas(), \"component\").size();\n        int nbHandlers = findElements(cache.getMetadatas(), \"handler\").size();\n        this.m_reporter.progress(\"iPOJO manipulation performed performed in %s ms (%d components, %d handlers).\",\n                               (System.currentTimeMillis() - start),\n                               nbComponents,\n                               nbHandlers);\n\n        // Return true if a new run should be performed after the analyze\n        return false;\n    }","id":99549,"modified_method":"public boolean analyzeJar(Analyzer analyzer) throws Exception {\n\n        long start = System.currentTimeMillis();\n\n        // Wraps the Bnd Reporter\n        BndReporter reporter = new BndReporter(this.m_reporter);\n\n        // Build ResourceStore\n        BndJarResourceStore store = new BndJarResourceStore(analyzer, this.m_reporter);\n        store.setIncludeEmbedComponents(m_includeEmbedBundles);\n\n        CompositeMetadataProvider provider = buildMetadataProvider(analyzer, reporter, store);\n\n        // Quick exit\n        CacheableMetadataProvider cache = new CacheableMetadataProvider(provider);\n        if (cache.getMetadatas().isEmpty() && !hasEmbedComponents(analyzer)) {\n            return false;\n        }\n\n        manipulateComponents(reporter, store, cache);\n\n        int nbComponents = findElements(cache.getMetadatas(), \"component\").size();\n        int nbHandlers = findElements(cache.getMetadatas(), \"handler\").size();\n        this.m_reporter.trace(\"iPOJO manipulation performed performed in %s ms (%d components, %d handlers).\",\n                               (System.currentTimeMillis() - start),\n                               nbComponents,\n                               nbHandlers);\n\n        // Return true if a new run should be performed after the analyze\n        return false;\n    }","commit_id":"1735ea57beabcc40701a7a76f59b8bf77c296fa0","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        MageObject sourceObject = game.getObject(source.getSourceId());\n        if (controller != null && sourceObject != null) {\n            CardsImpl toReveal = new CardsImpl();\n            boolean nonLandFound = false;\n            Card nonLandCard = null;\n\n            while (nonLandFound && controller.getLibrary().size() > 0) {\n                nonLandCard = controller.getLibrary().removeFromTop(game);\n                toReveal.add(nonLandCard);\n                nonLandFound = nonLandCard.getCardType().contains(CardType.LAND);\n            }\n            // reveal cards\n            if (!toReveal.isEmpty()) {\n                controller.revealCards(sourceObject.getIdName(), toReveal, game);\n            }\n            // the nonland card\n            if (nonLandCard != null) {\n                Permanent targetCreature = game.getPermanent(this.getTargetPointer().getFirst(game, source));\n                if (targetCreature != null) {\n                    targetCreature.damage(nonLandCard.getManaCost().convertedManaCost(), source.getSourceId(), game, false, true);\n                } else {\n                    Player targetPlayer = game.getPlayer(this.getTargetPointer().getFirst(game, source));\n                    if (targetPlayer != null) {\n                        targetPlayer.damage(nonLandCard.getManaCost().convertedManaCost(), source.getSourceId(), game, false, true);\n                    }\n                }\n            }\n            // put the cards on the bottom of the library in any order\n            return controller.putCardsOnBottomOfLibrary(toReveal, game, source, true);\n        }\n        return false;\n    }","id":99550,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        MageObject sourceObject = game.getObject(source.getSourceId());\n        if (controller != null && sourceObject != null) {\n            CardsImpl toReveal = new CardsImpl();\n            Card nonLandCard = null;\n\n            while (nonLandCard == null && controller.getLibrary().size() > 0) {\n                Card card = controller.getLibrary().removeFromTop(game);\n                toReveal.add(card);\n                if (!card.getCardType().contains(CardType.LAND)) {\n                    nonLandCard = card;\n                }\n            }\n            // reveal cards\n            if (!toReveal.isEmpty()) {\n                controller.revealCards(sourceObject.getIdName(), toReveal, game);\n            }\n            // the nonland card\n            if (nonLandCard != null) {\n                Permanent targetCreature = game.getPermanent(this.getTargetPointer().getFirst(game, source));\n                if (targetCreature != null) {\n                    targetCreature.damage(nonLandCard.getManaCost().convertedManaCost(), source.getSourceId(), game, false, true);\n                } else {\n                    Player targetPlayer = game.getPlayer(this.getTargetPointer().getFirst(game, source));\n                    if (targetPlayer != null) {\n                        targetPlayer.damage(nonLandCard.getManaCost().convertedManaCost(), source.getSourceId(), game, false, true);\n                    }\n                }\n            }\n            // put the cards on the bottom of the library in any order\n            return controller.putCardsOnBottomOfLibrary(toReveal, game, source, true);\n        }\n        return false;\n    }","commit_id":"99d33eb7716e6c6eb0946565a7585d516b09e0f4","url":"https://github.com/magefree/mage"},{"original_method":"public ErraticMutationEffect() {\r\n        super(Outcome.DrawCard);\r\n        this.staticText = \"Choose target creature. Reveal cards from the top of your library until you reveal a nonland card. That creature gets +X/-X until end of turn, where X is that card's converted mana cost. Put all cards revealed this way on the bottom of your library in any order\";\r\n    }","id":99551,"modified_method":"public ErraticMutationEffect() {\r\n        super(Outcome.UnboostCreature);\r\n        this.staticText = \"Choose target creature. Reveal cards from the top of your library until you reveal a nonland card. That creature gets +X/-X until end of turn, where X is that card's converted mana cost. Put all cards revealed this way on the bottom of your library in any order\";\r\n    }","commit_id":"99d33eb7716e6c6eb0946565a7585d516b09e0f4","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player player = game.getPlayer(source.getControllerId());\r\n        if (player != null && player.getLibrary().size() > 0) {\r\n            CardsImpl cards = new CardsImpl();\r\n            Library library = player.getLibrary();\r\n            Card card = null;\r\n            do {\r\n                card = library.removeFromTop(game);\r\n                if (card != null) {\r\n                    cards.add(card);\r\n                }\r\n            } while (library.size() > 0 && card != null && card.getCardType().contains(CardType.LAND));\r\n            // reveal cards\r\n            if (!cards.isEmpty()) {\r\n                player.revealCards(\"Erratic Mutation\", cards, game);\r\n            }\r\n            // the nonland card\r\n            int boostValue = card.getManaCost().convertedManaCost();\r\n            // unboost target\r\n            ContinuousEffect effect = new BoostTargetEffect(boostValue, boostValue * -1, Duration.EndOfTurn);\r\n            effect.setTargetPointer(new FixedTarget(this.getTargetPointer().getFirst(game, source)));\r\n            game.addEffect(effect, source);\r\n            // put the cards on the bottom of the library in any order\r\n            return player.putCardsOnBottomOfLibrary(cards, game, source, true);\r\n        }\r\n        return false;\r\n    }","id":99552,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        MageObject sourceObject = game.getObject(source.getSourceId());\r\n        if (controller != null && sourceObject != null) {\r\n            CardsImpl toReveal = new CardsImpl();\r\n            Card nonLandCard = null;\r\n\r\n            while (nonLandCard == null && controller.getLibrary().size() > 0) {\r\n                Card card = controller.getLibrary().removeFromTop(game);\r\n                toReveal.add(card);\r\n                if (!card.getCardType().contains(CardType.LAND)) {\r\n                    nonLandCard = card;\r\n                }\r\n            }\r\n            // reveal cards\r\n            if (!toReveal.isEmpty()) {\r\n                controller.revealCards(sourceObject.getIdName(), toReveal, game);\r\n            }\r\n            // the nonland card\r\n            if (nonLandCard != null) {\r\n                int boostValue = nonLandCard.getManaCost().convertedManaCost();\r\n                // unboost target\r\n                ContinuousEffect effect = new BoostTargetEffect(boostValue, -boostValue, Duration.EndOfTurn);\r\n                effect.setTargetPointer(new FixedTarget(this.getTargetPointer().getFirst(game, source)));\r\n                game.addEffect(effect, source);\r\n            }\r\n            // put the cards on the bottom of the library in any order\r\n            return controller.putCardsOnBottomOfLibrary(toReveal, game, source, true);\r\n        }\r\n        return false;\r\n    }","commit_id":"99d33eb7716e6c6eb0946565a7585d516b09e0f4","url":"https://github.com/magefree/mage"},{"original_method":"private boolean checkSpell(Spell spell, Game game) {\r\n        if (spell != null &&\r\n            (spell.getCardType().contains(CardType.INSTANT) || spell.getCardType().contains(CardType.SORCERY))) {\r\n            UUID targetGolem = null;\r\n            SpellAbility sa = spell.getSpellAbility();\r\n            for (Effect effect : sa.getEffects()) {\r\n                for (UUID target : effect.getTargetPointer().getTargets(game, sa)) {\r\n                    Permanent permanent = game.getPermanent(target);\r\n                    if (permanent != null) {\r\n                        if (!permanent.hasSubtype(\"Golem\")) {\r\n                            return false;\r\n                        }\r\n                        if (targetGolem == null) {\r\n                            targetGolem = target;\r\n                        } else {\r\n                            // If a spell has multiple targets, but it's targeting the same Golem with all of them, Precursor Golem's last ability will trigger\r\n                            if (!targetGolem.equals(target)) {\r\n                                return false;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            getEffects().get(0).setTargetPointer(new FixedTarget(spell.getId()));\r\n            getEffects().get(0).setValue(\"targetedGolem\", targetGolem);\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":99553,"modified_method":"private boolean checkSpell(Spell spell, Game game) {\r\n        if (spell != null &&\r\n            (spell.getCardType().contains(CardType.INSTANT) || spell.getCardType().contains(CardType.SORCERY))) {\r\n            UUID targetGolem = null;\r\n            SpellAbility sa = spell.getSpellAbility();\r\n            for (Effect effect : sa.getEffects()) {\r\n                for (UUID target : effect.getTargetPointer().getTargets(game, sa)) {\r\n                    Permanent permanent = game.getPermanent(target);\r\n                    if (permanent != null) {\r\n                        if (!permanent.hasSubtype(\"Golem\")) {\r\n                            return false;\r\n                        }\r\n                        if (targetGolem == null) {\r\n                            targetGolem = target;\r\n                        } else {\r\n                            // If a spell has multiple targets, but it's targeting the same Golem with all of them, Precursor Golem's last ability will trigger\r\n                            if (!targetGolem.equals(target)) {\r\n                                return false;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (targetGolem != null) {\r\n                getEffects().get(0).setTargetPointer(new FixedTarget(spell.getId()));\r\n                getEffects().get(0).setValue(\"targetedGolem\", targetGolem);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"580aaba45de07f2ae29a6f71ee552d5adfa47b6c","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Card card = game.getCard(this.getTargetPointer().getFirst(game, source));\n        Player controller = game.getPlayer(source.getControllerId());\n        if (controller != null && card != null) {\n            if (controller.moveCards(card, Zone.BATTLEFIELD, source, game)) {\n                Permanent creature = game.getPermanent(card.getId());\n                if (creature != null) {\n                    // gains haste\n                    ContinuousEffect effect = new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.EndOfTurn);\n                    effect.setTargetPointer(new FixedTarget(creature, game));\n                    game.addEffect(effect, source);\n                    // Exile at begin of next end step\n                    ExileTargetEffect exileEffect = new ExileTargetEffect(null, null, Zone.BATTLEFIELD);\n                    exileEffect.setTargetPointer(new FixedTarget(creature, game));\n                    DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(exileEffect);\n                    delayedAbility.setSourceId(source.getSourceId());\n                    delayedAbility.setControllerId(source.getControllerId());\n                    delayedAbility.setSourceObject(source.getSourceObject(game), game);\n                    game.addDelayedTriggeredAbility(delayedAbility);\n                }\n            }\n            return true;\n        }\n        return false;\n    }","id":99554,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Card card = game.getCard(this.getTargetPointer().getFirst(game, source));\n        Player controller = game.getPlayer(source.getControllerId());\n        if (controller != null && card != null) {\n            if (controller.moveCards(card, Zone.BATTLEFIELD, source, game)) {\n                Permanent creature = game.getPermanent(card.getId());\n                if (creature != null) {\n                    // gains haste\n                    ContinuousEffect effect = new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.EndOfTurn);\n                    effect.setTargetPointer(new FixedTarget(creature, game));\n                    game.addEffect(effect, source);\n                    // Exile at begin of next end step\n                    ExileTargetEffect exileEffect = new ExileTargetEffect(null, null, Zone.BATTLEFIELD);\n                    exileEffect.setTargetPointer(new FixedTarget(creature, game));\n                    DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(exileEffect);\n                    game.addDelayedTriggeredAbility(delayedAbility, source);\n                }\n            }\n            return true;\n        }\n        return false;\n    }","commit_id":"62a85fafc616ef640a102590048b3ceb15858d43","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public void adjustTargets(Ability ability, Game game) {\n        ability.getTargets().clear();\n        int xValue = ability.getManaCostsToPay().getX();\n        FilterCard filter = new FilterCreatureCard(\"creature card with converted mana cost \" + xValue +  \" or less from your graveyard\");\n        filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.LessThan, xValue + 1));\n        ability.getTargets().add(new TargetCardInYourGraveyard(filter));\n    }","id":99555,"modified_method":"@Override\n    public void adjustTargets(Ability ability, Game game) {\n        if (ability.getAbilityType().equals(AbilityType.SPELL)) { // otherwise the target is also added to the delayed triggered ability\n            ability.getTargets().clear();\n            int xValue = ability.getManaCostsToPay().getX();\n            FilterCard filter = new FilterCreatureCard(\"creature card with converted mana cost \" + xValue + \" or less from your graveyard\");\n            filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.LessThan, xValue + 1));\n            ability.getTargets().add(new TargetCardInYourGraveyard(filter));\n        }\n    }","commit_id":"62a85fafc616ef640a102590048b3ceb15858d43","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Card card = game.getCard(source.getFirstTarget());\n        \n        if (card != null) {\n            Player player = game.getPlayer(card.getOwnerId());\n            if (player == null) {\n                return false;\n            }\n            card.putOntoBattlefield(game, Zone.GRAVEYARD, source.getSourceId(), source.getControllerId());\n\n            ContinuousEffect effect = new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.Custom);\n            effect.setTargetPointer(new FixedTarget(card.getId()));\n            game.addEffect(effect, source);\n            \n            ExileTargetEffect exileEffect = new ExileTargetEffect();\n            exileEffect.setTargetPointer(new FixedTarget(card.getId()));\n            DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(exileEffect);\n            delayedAbility.setSourceId(source.getSourceId());\n            delayedAbility.setControllerId(source.getControllerId());\n            delayedAbility.setSourceObject(source.getSourceObject(game), game);\n            game.addDelayedTriggeredAbility(delayedAbility);\n\n            return true;\n        }\n\n        return false;\n    }","id":99556,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Card card = game.getCard(source.getFirstTarget());\n\n        if (card != null) {\n            Player cardOwner = game.getPlayer(card.getOwnerId());\n            if (cardOwner == null) {\n                return false;\n            }\n\n            if (cardOwner.moveCards(card, Zone.BATTLEFIELD, source, game)) {\n                Permanent permanent = game.getPermanent(card.getId());\n                if (permanent != null) {\n                    ContinuousEffect effect = new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.Custom);\n                    effect.setTargetPointer(new FixedTarget(permanent, game));\n                    game.addEffect(effect, source);\n                    ExileTargetEffect exileEffect = new ExileTargetEffect(null, null, Zone.BATTLEFIELD);\n                    exileEffect.setTargetPointer(new FixedTarget(permanent, game));\n                    game.addDelayedTriggeredAbility(new AtTheBeginOfNextEndStepDelayedTriggeredAbility(exileEffect), source);\n                }\n            }\n            return true;\n        }\n\n        return false;\n    }","commit_id":"62a85fafc616ef640a102590048b3ceb15858d43","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Permanent permanent = game.getPermanentOrLKIBattlefield(source.getFirstTarget());\n        if (permanent != null) {\n            PutTokenOntoBattlefieldCopyTargetEffect effect = new PutTokenOntoBattlefieldCopyTargetEffect(null, CardType.ENCHANTMENT, true);\n            effect.setTargetPointer(getTargetPointer());\n            if (effect.apply(game, source) && effect.getAddedPermanent() != null) {\n                ExileTargetEffect exileEffect = new ExileTargetEffect();\n                exileEffect.setTargetPointer(new FixedTarget(effect.getAddedPermanent().getId()));\n                DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(exileEffect);\n                delayedAbility.setSourceId(source.getSourceId());\n                delayedAbility.setControllerId(source.getControllerId());\n                delayedAbility.setSourceObject(source.getSourceObject(game), game);\n                game.addDelayedTriggeredAbility(delayedAbility);\n\n                return true;\n            }\n        }\n\n        return false;\n    }","id":99557,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Permanent permanent = game.getPermanentOrLKIBattlefield(source.getFirstTarget());\n        if (permanent != null) {\n            PutTokenOntoBattlefieldCopyTargetEffect effect = new PutTokenOntoBattlefieldCopyTargetEffect(null, CardType.ENCHANTMENT, true);\n            effect.setTargetPointer(getTargetPointer());\n            if (effect.apply(game, source)) {\n                for (Permanent tokenPermanent : effect.getAddedPermanent()) {\n                    ExileTargetEffect exileEffect = new ExileTargetEffect();\n                    exileEffect.setTargetPointer(new FixedTarget(tokenPermanent, game));\n                    DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(exileEffect);\n                    delayedAbility.setSourceId(source.getSourceId());\n                    delayedAbility.setControllerId(source.getControllerId());\n                    delayedAbility.setSourceObject(source.getSourceObject(game), game);\n                    game.addDelayedTriggeredAbility(delayedAbility);\n                }\n                return true;\n            }\n        }\n\n        return false;\n    }","commit_id":"cc9384089784169305fc30c54b213bc1e71a5c79","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            CreateTokenEffect effect = new CreateTokenEffect(new FeralLightningElementalToken(), 3);\r\n            effect.apply(game, source);\r\n            for (UUID tokenId : effect.getLastAddedTokenIds()) {\r\n                ExileTargetEffect exileEffect = new ExileTargetEffect(null,\"\",Zone.BATTLEFIELD);\r\n                exileEffect.setTargetPointer(new FixedTarget(tokenId));\r\n                DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(exileEffect);\r\n                delayedAbility.setSourceId(source.getSourceId());\r\n                delayedAbility.setControllerId(source.getControllerId());\r\n                delayedAbility.setSourceObject(source.getSourceObject(game), game);\r\n                game.addDelayedTriggeredAbility(delayedAbility);\r\n            }\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }","id":99558,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            CreateTokenEffect effect = new CreateTokenEffect(new FeralLightningElementalToken(), 3);\r\n            effect.apply(game, source);\r\n            for (UUID tokenId : effect.getLastAddedTokenIds()) {\r\n                Permanent tokenPermanent = game.getPermanent(tokenId);\r\n                if (tokenPermanent != null) {\r\n                    ExileTargetEffect exileEffect = new ExileTargetEffect(null, \"\", Zone.BATTLEFIELD);\r\n                    exileEffect.setTargetPointer(new FixedTarget(tokenPermanent, game));\r\n                    DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(exileEffect);\r\n                    delayedAbility.setSourceId(source.getSourceId());\r\n                    delayedAbility.setControllerId(source.getControllerId());\r\n                    delayedAbility.setSourceObject(source.getSourceObject(game), game);\r\n                    game.addDelayedTriggeredAbility(delayedAbility);\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }","commit_id":"cc9384089784169305fc30c54b213bc1e71a5c79","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        Permanent permanent = game.getPermanentOrLKIBattlefield(getTargetPointer().getFirst(game, source));\r\n        if (controller != null && permanent != null) {\r\n            EmptyToken token = new EmptyToken();\r\n            CardUtil.copyTo(token).from(permanent);\r\n            token.putOntoBattlefield(1, game, source.getSourceId(), source.getControllerId(), true, true);\r\n            Effect effect = new ExileTargetEffect();\r\n            effect.setTargetPointer(new FixedTarget(token.getLastAddedToken()));\r\n            new CreateDelayedTriggeredAbilityEffect(new AtTheEndOfCombatDelayedTriggeredAbility(effect), false).apply(game, source);\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":99559,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        Permanent permanent = game.getPermanentOrLKIBattlefield(getTargetPointer().getFirst(game, source));\r\n        if (controller != null && permanent != null) {\r\n            EmptyToken token = new EmptyToken();\r\n            CardUtil.copyTo(token).from(permanent);\r\n            token.putOntoBattlefield(1, game, source.getSourceId(), source.getControllerId(), true, true);\r\n            for (UUID tokenId : token.getLastAddedTokenIds()) { // by cards like Doubling Season multiple tokens can be added to the battlefield\r\n                Permanent tokenPermanent = game.getPermanent(tokenId);\r\n                if (tokenPermanent != null) {\r\n                    Effect effect = new ExileTargetEffect();\r\n                    effect.setTargetPointer(new FixedTarget(tokenPermanent, game));\r\n                    new CreateDelayedTriggeredAbilityEffect(new AtTheEndOfCombatDelayedTriggeredAbility(effect), false).apply(game, source);\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"cc9384089784169305fc30c54b213bc1e71a5c79","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Permanent permanent = game.getPermanentOrLKIBattlefield(getTargetPointer().getFirst(game, source));\n        if (permanent != null) {\n            PutTokenOntoBattlefieldCopyTargetEffect effect = new PutTokenOntoBattlefieldCopyTargetEffect(null, null, true);\n            effect.setTargetPointer(getTargetPointer());\n            if (effect.apply(game, source) && effect.getAddedPermanent() != null) {\n                ExileTargetEffect exileEffect = new ExileTargetEffect();\n                exileEffect.setTargetPointer(new FixedTarget(effect.getAddedPermanent().getId()));\n                DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(exileEffect);\n                delayedAbility.setSourceId(source.getSourceId());\n                delayedAbility.setControllerId(source.getControllerId());\n                delayedAbility.setSourceObject(source.getSourceObject(game), game);\n                game.addDelayedTriggeredAbility(delayedAbility);\n\n                return true;\n            }\n        }\n\n        return false;\n    }","id":99560,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Permanent permanent = game.getPermanentOrLKIBattlefield(getTargetPointer().getFirst(game, source));\n        if (permanent != null) {\n            PutTokenOntoBattlefieldCopyTargetEffect effect = new PutTokenOntoBattlefieldCopyTargetEffect(null, null, true);\n            effect.setTargetPointer(getTargetPointer());\n            if (effect.apply(game, source)) {\n                for (Permanent tokenPermanent : effect.getAddedPermanent()) {\n                    ExileTargetEffect exileEffect = new ExileTargetEffect();\n                    exileEffect.setTargetPointer(new FixedTarget(tokenPermanent, game));\n                    DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(exileEffect);\n                    delayedAbility.setSourceId(source.getSourceId());\n                    delayedAbility.setControllerId(source.getControllerId());\n                    delayedAbility.setSourceObject(source.getSourceObject(game), game);\n                    game.addDelayedTriggeredAbility(delayedAbility);\n                }\n                return true;\n            }\n        }\n\n        return false;\n    }","commit_id":"cc9384089784169305fc30c54b213bc1e71a5c79","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        if (new HelmOfKaldraCondition().apply(game, source)) {\r\n            CreateTokenEffect effect = new CreateTokenEffect(new KaldraToken());\r\n            effect.apply(game, source);\r\n            UUID kaldraId = effect.getLastAddedTokenId();\r\n            Permanent kaldra = game.getPermanent(kaldraId);\r\n            if (kaldra != null) {\r\n                // Attach helm to the token\r\n                for (Permanent kaldrasHelm : game.getBattlefield().getAllActivePermanents(HelmOfKaldra.filterHelm, source.getControllerId(), game)) {\r\n                    kaldra.addAttachment(kaldrasHelm.getId(), game);\r\n                    break;\r\n                }\r\n                // Attach shield to the token\r\n                for (Permanent kaldrasShield : game.getBattlefield().getAllActivePermanents(HelmOfKaldra.filterShield, source.getControllerId(), game)) {\r\n                    kaldra.addAttachment(kaldrasShield.getId(), game);\r\n                    break;\r\n                }\r\n                // Attach sword to the token\r\n                for (Permanent kaldrasSword : game.getBattlefield().getAllActivePermanents(HelmOfKaldra.filterSword, source.getControllerId(), game)) {\r\n                    kaldra.addAttachment(kaldrasSword.getId(), game);\r\n                    break;\r\n                }\r\n\r\n            }\r\n        }\r\n        return false;\r\n    }","id":99561,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        if (new HelmOfKaldraCondition().apply(game, source)) {\r\n            CreateTokenEffect effect = new CreateTokenEffect(new KaldraToken());\r\n            effect.apply(game, source);\r\n            for (UUID tokenId : effect.getLastAddedTokenIds()) {\r\n                Permanent kaldra = game.getPermanent(tokenId);\r\n                if (kaldra != null) {\r\n                    // Attach helm to the token\r\n                    for (Permanent kaldrasHelm : game.getBattlefield().getAllActivePermanents(HelmOfKaldra.filterHelm, source.getControllerId(), game)) {\r\n                        kaldra.addAttachment(kaldrasHelm.getId(), game);\r\n                        break;\r\n                    }\r\n                    // Attach shield to the token\r\n                    for (Permanent kaldrasShield : game.getBattlefield().getAllActivePermanents(HelmOfKaldra.filterShield, source.getControllerId(), game)) {\r\n                        kaldra.addAttachment(kaldrasShield.getId(), game);\r\n                        break;\r\n                    }\r\n                    // Attach sword to the token\r\n                    for (Permanent kaldrasSword : game.getBattlefield().getAllActivePermanents(HelmOfKaldra.filterSword, source.getControllerId(), game)) {\r\n                        kaldra.addAttachment(kaldrasSword.getId(), game);\r\n                        break;\r\n                    }\r\n\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"cc9384089784169305fc30c54b213bc1e71a5c79","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        if (game.getBattlefield().count(HelmOfKaldra.filterHelm, source.getSourceId(), source.getControllerId(), game) < 1) {\r\n            return false;\r\n        }\r\n        if (game.getBattlefield().count(HelmOfKaldra.filterShield, source.getSourceId(), source.getControllerId(), game) < 1) {\r\n            return false;\r\n        }\r\n        if (game.getBattlefield().count(HelmOfKaldra.filterShield, source.getSourceId(), source.getControllerId(), game) < 1) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }","id":99562,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        if (game.getBattlefield().count(HelmOfKaldra.filterHelm, source.getSourceId(), source.getControllerId(), game) < 1) {\r\n            return false;\r\n        }\r\n        if (game.getBattlefield().count(HelmOfKaldra.filterShield, source.getSourceId(), source.getControllerId(), game) < 1) {\r\n            return false;\r\n        }\r\n        return game.getBattlefield().count(HelmOfKaldra.filterShield, source.getSourceId(), source.getControllerId(), game) >= 1;\r\n    }","commit_id":"cc9384089784169305fc30c54b213bc1e71a5c79","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Permanent permanent = game.getPermanent(source.getSourceId());\r\n        if (permanent == null) {\r\n            return false;\r\n        }\r\n\r\n        if (permanent.getImprinted().size() > 0) {\r\n            Card card = game.getCard(permanent.getImprinted().get(0));\r\n            if (card != null) {\r\n                EmptyToken token = new EmptyToken();\r\n                CardUtil.copyTo(token).from(card);\r\n\r\n                token.addAbility(HasteAbility.getInstance());\r\n                token.putOntoBattlefield(1, game, source.getSourceId(), source.getControllerId());\r\n\r\n                ExileTargetEffect exileEffect = new ExileTargetEffect();\r\n                exileEffect.setTargetPointer(new FixedTarget(token.getLastAddedToken()));\r\n                DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(exileEffect);\r\n                delayedAbility.setSourceId(source.getSourceId());\r\n                delayedAbility.setControllerId(source.getControllerId());\r\n                delayedAbility.setSourceObject(source.getSourceObject(game), game);\r\n                game.addDelayedTriggeredAbility(delayedAbility);\r\n\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }","id":99563,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Permanent permanent = game.getPermanent(source.getSourceId());\r\n        if (permanent == null) {\r\n            return false;\r\n        }\r\n\r\n        if (permanent.getImprinted().size() > 0) {\r\n            Card card = game.getCard(permanent.getImprinted().get(0));\r\n            if (card != null) {\r\n                EmptyToken token = new EmptyToken();\r\n                CardUtil.copyTo(token).from(card);\r\n\r\n                token.addAbility(HasteAbility.getInstance());\r\n                token.putOntoBattlefield(1, game, source.getSourceId(), source.getControllerId());\r\n\r\n                for (UUID tokenId : token.getLastAddedTokenIds()) { // by cards like Doubling Season multiple tokens can be added to the battlefield\r\n                    Permanent tokenPermanent = game.getPermanent(tokenId);\r\n                    if (tokenPermanent != null) {\r\n                        ExileTargetEffect exileEffect = new ExileTargetEffect();\r\n                        exileEffect.setTargetPointer(new FixedTarget(tokenPermanent, game));\r\n                        DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(exileEffect);\r\n                        delayedAbility.setSourceId(source.getSourceId());\r\n                        delayedAbility.setControllerId(source.getControllerId());\r\n                        delayedAbility.setSourceObject(source.getSourceObject(game), game);\r\n                        game.addDelayedTriggeredAbility(delayedAbility);\r\n                    }\r\n                }\r\n\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }","commit_id":"cc9384089784169305fc30c54b213bc1e71a5c79","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Permanent enchantment = game.getPermanentOrLKIBattlefield(source.getSourceId());\r\n        if (enchantment == null || enchantment.getAttachedTo() == null) {\r\n            return false;\r\n        }\r\n        Permanent enchanted = game.getPermanentOrLKIBattlefield(enchantment.getAttachedTo());\r\n        if (enchanted != null) {\r\n            EmptyToken token = new EmptyToken();\r\n            CardUtil.copyTo(token).from(enchanted);\r\n\r\n            token.putOntoBattlefield(1, game, source.getSourceId(), source.getControllerId());\r\n\r\n            ExileTargetEffect exileEffect = new ExileTargetEffect();\r\n            exileEffect.setTargetPointer(new FixedTarget(token.getLastAddedToken()));\r\n            DelayedTriggeredAbility delayedAbility = new AtTheEndOfCombatDelayedTriggeredAbility(exileEffect);\r\n            delayedAbility.setSourceId(source.getSourceId());\r\n            delayedAbility.setControllerId(source.getControllerId());\r\n            delayedAbility.setSourceObject(source.getSourceObject(game), game);\r\n            game.addDelayedTriggeredAbility(delayedAbility);\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":99564,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Permanent enchantment = game.getPermanentOrLKIBattlefield(source.getSourceId());\r\n        if (enchantment == null || enchantment.getAttachedTo() == null) {\r\n            return false;\r\n        }\r\n        Permanent enchanted = game.getPermanentOrLKIBattlefield(enchantment.getAttachedTo());\r\n        if (enchanted != null) {\r\n            EmptyToken token = new EmptyToken();\r\n            CardUtil.copyTo(token).from(enchanted);\r\n\r\n            token.putOntoBattlefield(1, game, source.getSourceId(), source.getControllerId());\r\n\r\n            for (UUID tokenId : token.getLastAddedTokenIds()) { // by cards like Doubling Season multiple tokens can be added to the battlefield\r\n                Permanent tokenPermanent = game.getPermanent(tokenId);\r\n                if (tokenPermanent != null) {\r\n                    ExileTargetEffect exileEffect = new ExileTargetEffect();\r\n                    exileEffect.setTargetPointer(new FixedTarget(tokenPermanent, game));\r\n                    DelayedTriggeredAbility delayedAbility = new AtTheEndOfCombatDelayedTriggeredAbility(exileEffect);\r\n                    delayedAbility.setSourceId(source.getSourceId());\r\n                    delayedAbility.setControllerId(source.getControllerId());\r\n                    delayedAbility.setSourceObject(source.getSourceObject(game), game);\r\n                    game.addDelayedTriggeredAbility(delayedAbility);\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"cc9384089784169305fc30c54b213bc1e71a5c79","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Permanent permanent = game.getPermanentOrLKIBattlefield(getTargetPointer().getFirst(game, source));\r\n        if (permanent != null) {\r\n            // handle copies of copies\r\n            Permanent copyFromPermanent = permanent;\r\n            ApplyToPermanent applier = new EmptyApplyToPermanent();\r\n            for (Effect effect : game.getState().getContinuousEffects().getLayeredEffects(game)) {\r\n                if (effect instanceof CopyEffect) {\r\n                    CopyEffect copyEffect = (CopyEffect) effect;\r\n                    // there is another copy effect that our targetPermanent copies stats from\r\n                    if (copyEffect.getSourceId().equals(permanent.getId())) {\r\n                        MageObject object = ((CopyEffect) effect).getTarget();\r\n                        if (object instanceof Permanent) {\r\n                            copyFromPermanent = (Permanent) object;\r\n                            if (copyEffect.getApplier() != null) {\r\n                                applier = copyEffect.getApplier();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            EmptyToken token = new EmptyToken();\r\n            CardUtil.copyTo(token).from(copyFromPermanent); // needed so that entersBattlefied triggered abilities see the attributes (e.g. Master Biomancer)\r\n            if (additionalCardType != null && !token.getCardType().contains(additionalCardType)) {\r\n                token.getCardType().add(additionalCardType);\r\n            }\r\n            if (gainsHaste) {\r\n                token.addAbility(HasteAbility.getInstance());\r\n            }\r\n            token.putOntoBattlefield(1, game, source.getSourceId(), playerId == null ? source.getControllerId() : playerId);\r\n            addedTokenPermanent = game.getPermanent(token.getLastAddedToken());\r\n            if (addedTokenPermanent != null) {\r\n                game.copyPermanent(copyFromPermanent, addedTokenPermanent, source, applier);\r\n                if (additionalCardType != null) {\r\n                    ContinuousEffect effect = new AddCardTypeTargetEffect(additionalCardType, Duration.Custom);\r\n                    effect.setTargetPointer(new FixedTarget(addedTokenPermanent.getId()));\r\n                    game.addEffect(effect, source);\r\n                }\r\n                if (gainsHaste) {\r\n                    ContinuousEffect effect = new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.Custom);\r\n                    effect.setTargetPointer(new FixedTarget(addedTokenPermanent.getId()));\r\n                    game.addEffect(effect, source);\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","id":99565,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Permanent permanent = game.getPermanentOrLKIBattlefield(getTargetPointer().getFirst(game, source));\r\n        if (permanent != null) {\r\n            // handle copies of copies\r\n            Permanent copyFromPermanent = permanent;\r\n            ApplyToPermanent applier = new EmptyApplyToPermanent();\r\n            for (Effect effect : game.getState().getContinuousEffects().getLayeredEffects(game)) {\r\n                if (effect instanceof CopyEffect) {\r\n                    CopyEffect copyEffect = (CopyEffect) effect;\r\n                    // there is another copy effect that our targetPermanent copies stats from\r\n                    if (copyEffect.getSourceId().equals(permanent.getId())) {\r\n                        MageObject object = ((CopyEffect) effect).getTarget();\r\n                        if (object instanceof Permanent) {\r\n                            copyFromPermanent = (Permanent) object;\r\n                            if (copyEffect.getApplier() != null) {\r\n                                applier = copyEffect.getApplier();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            EmptyToken token = new EmptyToken();\r\n            CardUtil.copyTo(token).from(copyFromPermanent); // needed so that entersBattlefied triggered abilities see the attributes (e.g. Master Biomancer)\r\n            if (additionalCardType != null && !token.getCardType().contains(additionalCardType)) {\r\n                token.getCardType().add(additionalCardType);\r\n            }\r\n            if (gainsHaste) {\r\n                token.addAbility(HasteAbility.getInstance());\r\n            }\r\n            token.putOntoBattlefield(1, game, source.getSourceId(), playerId == null ? source.getControllerId() : playerId);\r\n            for (UUID tokenId : token.getLastAddedTokenIds()) { // by cards like Doubling Season multiple tokens can be added to the battlefield\r\n                Permanent tokenPermanent = game.getPermanent(tokenId);\r\n                if (tokenPermanent != null) {\r\n                    addedTokenPermanents.add(tokenPermanent);\r\n                    game.copyPermanent(copyFromPermanent, tokenPermanent, source, applier);\r\n                    if (additionalCardType != null) {\r\n                        ContinuousEffect effect = new AddCardTypeTargetEffect(additionalCardType, Duration.Custom);\r\n                        effect.setTargetPointer(new FixedTarget(tokenPermanent, game));\r\n                        game.addEffect(effect, source);\r\n                    }\r\n                    if (gainsHaste) {\r\n                        ContinuousEffect effect = new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.Custom);\r\n                        effect.setTargetPointer(new FixedTarget(tokenPermanent, game));\r\n                        game.addEffect(effect, source);\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"cc9384089784169305fc30c54b213bc1e71a5c79","url":"https://github.com/magefree/mage"},{"original_method":"public Permanent getAddedPermanent() {\r\n        return addedTokenPermanent;\r\n    }","id":99566,"modified_method":"public List<Permanent> getAddedPermanent() {\r\n        return addedTokenPermanents;\r\n    }","commit_id":"cc9384089784169305fc30c54b213bc1e71a5c79","url":"https://github.com/magefree/mage"},{"original_method":"public PutTokenOntoBattlefieldCopyTargetEffect() {\r\n        super(Outcome.PutCreatureInPlay);\r\n        this.playerId = null;\r\n        this.additionalCardType = null;\r\n        this.addedTokenPermanent = null;\r\n    }","id":99567,"modified_method":"public PutTokenOntoBattlefieldCopyTargetEffect() {\r\n        super(Outcome.PutCreatureInPlay);\r\n        this.playerId = null;\r\n        this.additionalCardType = null;\r\n        this.addedTokenPermanents = new ArrayList<>();\r\n    }","commit_id":"cc9384089784169305fc30c54b213bc1e71a5c79","url":"https://github.com/magefree/mage"},{"original_method":"public PutTokenOntoBattlefieldCopyTargetEffect(UUID playerId, CardType additionalCardType, boolean gainsHaste) {\r\n        super(Outcome.PutCreatureInPlay);\r\n        this.playerId = playerId;\r\n        this.additionalCardType = additionalCardType;\r\n        this.gainsHaste = gainsHaste;\r\n        this.addedTokenPermanent = null;\r\n    }","id":99568,"modified_method":"public PutTokenOntoBattlefieldCopyTargetEffect(UUID playerId, CardType additionalCardType, boolean gainsHaste) {\r\n        super(Outcome.PutCreatureInPlay);\r\n        this.playerId = playerId;\r\n        this.additionalCardType = additionalCardType;\r\n        this.gainsHaste = gainsHaste;\r\n        this.addedTokenPermanents = new ArrayList<>();\r\n    }","commit_id":"cc9384089784169305fc30c54b213bc1e71a5c79","url":"https://github.com/magefree/mage"},{"original_method":"public PutTokenOntoBattlefieldCopyTargetEffect(final PutTokenOntoBattlefieldCopyTargetEffect effect) {\r\n        super(effect);\r\n        this.playerId = effect.playerId;\r\n        this.additionalCardType = effect.additionalCardType;\r\n        this.gainsHaste = effect.gainsHaste;\r\n        this.addedTokenPermanent = effect.addedTokenPermanent;\r\n    }","id":99569,"modified_method":"public PutTokenOntoBattlefieldCopyTargetEffect(final PutTokenOntoBattlefieldCopyTargetEffect effect) {\r\n        super(effect);\r\n        this.playerId = effect.playerId;\r\n        this.additionalCardType = effect.additionalCardType;\r\n        this.gainsHaste = effect.gainsHaste;\r\n        this.addedTokenPermanents.addAll(effect.addedTokenPermanents);\r\n    }","commit_id":"cc9384089784169305fc30c54b213bc1e71a5c79","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Card card = game.getCard(source.getFirstTarget());\n        Player controller = game.getPlayer(source.getControllerId());\n        if (controller != null && card != null) {\n            if (controller.moveCardToExileWithInfo(card, null, \"\", source.getSourceId(), game, Zone.GRAVEYARD, true)) {\n                EmptyToken token = new EmptyToken();\n                CardUtil.copyTo(token).from(card);\n\n                if (!token.hasSubtype(\"Spirit\")) {\n                    token.getSubtype().add(\"Spirit\");\n                }                \n                token.putOntoBattlefield(1, game, source.getSourceId(), source.getControllerId());\n\n                ExileTargetEffect exileEffect = new ExileTargetEffect();\n                exileEffect.setTargetPointer(new FixedTarget(token.getLastAddedToken()));\n                DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(exileEffect);\n                delayedAbility.setSourceId(source.getSourceId());\n                delayedAbility.setControllerId(source.getControllerId());\n                delayedAbility.setSourceObject(source.getSourceObject(game), game);\n                game.addDelayedTriggeredAbility(delayedAbility);\n            }\n\n            return true;\n        }\n\n        return false;\n    }","id":99570,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Card card = game.getCard(source.getFirstTarget());\n        Player controller = game.getPlayer(source.getControllerId());\n        if (controller != null && card != null) {\n            if (controller.moveCardToExileWithInfo(card, null, \"\", source.getSourceId(), game, Zone.GRAVEYARD, true)) {\n                EmptyToken token = new EmptyToken();\n                CardUtil.copyTo(token).from(card);\n\n                if (!token.hasSubtype(\"Spirit\")) {\n                    token.getSubtype().add(\"Spirit\");\n                }\n                token.putOntoBattlefield(1, game, source.getSourceId(), source.getControllerId());\n                for (UUID tokenId : token.getLastAddedTokenIds()) { // by cards like Doubling Season multiple tokens can be added to the battlefield\n                    Permanent tokenPermanent = game.getPermanent(tokenId);\n                    if (tokenPermanent != null) {\n                        ExileTargetEffect exileEffect = new ExileTargetEffect();\n                        exileEffect.setTargetPointer(new FixedTarget(tokenPermanent, game));\n                        DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(exileEffect);\n                        delayedAbility.setSourceId(source.getSourceId());\n                        delayedAbility.setControllerId(source.getControllerId());\n                        delayedAbility.setSourceObject(source.getSourceObject(game), game);\n                        game.addDelayedTriggeredAbility(delayedAbility);\n                    }\n                }\n            }\n\n            return true;\n        }\n\n        return false;\n    }","commit_id":"cc9384089784169305fc30c54b213bc1e71a5c79","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        CreateTokenEffect effect =  new CreateTokenEffect(new TatsumaDragonToken());\r\n        effect.apply(game, source);\r\n        FixedTarget fixedTarget = new FixedTarget(effect.getLastAddedTokenId());\r\n        DelayedTriggeredAbility delayedAbility = new TatsumaTheDragonsFangTriggeredAbility(fixedTarget);\r\n        delayedAbility.setSourceId(source.getSourceId());\r\n        delayedAbility.setControllerId(source.getControllerId());\r\n        delayedAbility.setSourceObject(source.getSourceObject(game), game);\r\n        game.addDelayedTriggeredAbility(delayedAbility);\r\n\r\n        return true;\r\n    }","id":99571,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        CreateTokenEffect effect = new CreateTokenEffect(new TatsumaDragonToken());\r\n        effect.apply(game, source);\r\n        for (UUID tokenId : effect.getLastAddedTokenIds()) { // by cards like Doubling Season multiple tokens can be added to the battlefield\r\n            Permanent tokenPermanent = game.getPermanent(tokenId);\r\n            if (tokenPermanent != null) {\r\n                FixedTarget fixedTarget = new FixedTarget(tokenPermanent, game);\r\n                Effect returnEffect = new ReturnToBattlefieldUnderOwnerControlTargetEffect();\r\n                returnEffect.setTargetPointer(new FixedTarget(source.getSourceId(), game.getState().getZoneChangeCounter(source.getSourceId())));\r\n                DelayedTriggeredAbility delayedAbility = new TatsumaTheDragonsFangTriggeredAbility(fixedTarget, returnEffect);\r\n                delayedAbility.setSourceId(source.getSourceId());\r\n                delayedAbility.setControllerId(source.getControllerId());\r\n                delayedAbility.setSourceObject(source.getSourceObject(game), game);\r\n                game.addDelayedTriggeredAbility(delayedAbility);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }","commit_id":"cc9384089784169305fc30c54b213bc1e71a5c79","url":"https://github.com/magefree/mage"},{"original_method":"public TatsumaTheDragonsFangTriggeredAbility(FixedTarget fixedTarget) {\r\n        super(new ReturnToBattlefieldUnderYourControlSourceEffect(), Duration.OneUse);\r\n        this.fixedTarget = fixedTarget;\r\n    }","id":99572,"modified_method":"public TatsumaTheDragonsFangTriggeredAbility(FixedTarget fixedTarget, Effect effect) {\r\n        super(effect, Duration.OneUse);\r\n        this.fixedTarget = fixedTarget;\r\n    }","commit_id":"cc9384089784169305fc30c54b213bc1e71a5c79","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic boolean isCached() {\n\t\treturn _cached;\n\t}","id":99573,"modified_method":"@Override\n\tpublic Boolean isCached() {\n\t\treturn true;\n\t}","commit_id":"56c52faac3b1453f76018eafabc378730315e05f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void setCached(boolean cached) {\n\t\t_cached = cached;\n\t}","id":99574,"modified_method":"@Override\n\tpublic void setCached(Boolean cached) {\n\t\t_cached = cached;\n\t}","commit_id":"56c52faac3b1453f76018eafabc378730315e05f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic FilterBuilder translate(\n\t\tBooleanFilter booleanFilter,\n\t\tFilterVisitor<FilterBuilder> filterVisitor) {\n\n\t\tBoolFilterBuilder boolFilterBuilder = FilterBuilders.boolFilter();\n\n\t\tboolFilterBuilder.cache(booleanFilter.isCached());\n\n\t\tfor (BooleanClause<Filter> booleanClause :\n\t\t\t\tbooleanFilter.getMustBooleanClauses()) {\n\n\t\t\tFilterBuilder filterBuilder = translate(\n\t\t\t\tbooleanClause, filterVisitor);\n\n\t\t\tboolFilterBuilder.must(filterBuilder);\n\t\t}\n\n\t\tfor (BooleanClause<Filter> booleanClause :\n\t\t\t\tbooleanFilter.getMustNotBooleanClauses()) {\n\n\t\t\tFilterBuilder filterBuilder = translate(\n\t\t\t\tbooleanClause, filterVisitor);\n\n\t\t\tboolFilterBuilder.mustNot(filterBuilder);\n\t\t}\n\n\t\tfor (BooleanClause<Filter> booleanClause :\n\t\t\t\tbooleanFilter.getShouldBooleanClauses()) {\n\n\t\t\tFilterBuilder filterBuilder = translate(\n\t\t\t\tbooleanClause, filterVisitor);\n\n\t\t\tboolFilterBuilder.should(filterBuilder);\n\t\t}\n\n\t\treturn boolFilterBuilder;\n\t}","id":99575,"modified_method":"@Override\n\tpublic FilterBuilder translate(\n\t\tBooleanFilter booleanFilter,\n\t\tFilterVisitor<FilterBuilder> filterVisitor) {\n\n\t\tBoolFilterBuilder boolFilterBuilder = FilterBuilders.boolFilter();\n\n\t\tif (booleanFilter.isCached() != null) {\n\t\t\tboolFilterBuilder.cache(booleanFilter.isCached());\n\t\t}\n\n\t\tfor (BooleanClause<Filter> booleanClause :\n\t\t\t\tbooleanFilter.getMustBooleanClauses()) {\n\n\t\t\tFilterBuilder filterBuilder = translate(\n\t\t\t\tbooleanClause, filterVisitor);\n\n\t\t\tboolFilterBuilder.must(filterBuilder);\n\t\t}\n\n\t\tfor (BooleanClause<Filter> booleanClause :\n\t\t\t\tbooleanFilter.getMustNotBooleanClauses()) {\n\n\t\t\tFilterBuilder filterBuilder = translate(\n\t\t\t\tbooleanClause, filterVisitor);\n\n\t\t\tboolFilterBuilder.mustNot(filterBuilder);\n\t\t}\n\n\t\tfor (BooleanClause<Filter> booleanClause :\n\t\t\t\tbooleanFilter.getShouldBooleanClauses()) {\n\n\t\t\tFilterBuilder filterBuilder = translate(\n\t\t\t\tbooleanClause, filterVisitor);\n\n\t\t\tboolFilterBuilder.should(filterBuilder);\n\t\t}\n\n\t\treturn boolFilterBuilder;\n\t}","commit_id":"56c52faac3b1453f76018eafabc378730315e05f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic FilterBuilder translate(DateRangeTermFilter dateRangeTermFilter) {\n\t\tRangeFilterBuilder rangeFilterBuilder = FilterBuilders.rangeFilter(\n\t\t\tdateRangeTermFilter.getField());\n\n\t\trangeFilterBuilder.cache(dateRangeTermFilter.isCached());\n\n\t\tFormat format = FastDateFormatFactoryUtil.getSimpleDateFormat(\n\t\t\tdateRangeTermFilter.getDateFormat(),\n\t\t\tdateRangeTermFilter.getTimeZone());\n\n\t\ttry {\n\t\t\trangeFilterBuilder.from(\n\t\t\t\tformat.parseObject(dateRangeTermFilter.getLowerBound()));\n\t\t\trangeFilterBuilder.includeLower(\n\t\t\t\tdateRangeTermFilter.isIncludesLower());\n\t\t\trangeFilterBuilder.includeUpper(\n\t\t\t\tdateRangeTermFilter.isIncludesUpper());\n\t\t\trangeFilterBuilder.to(\n\t\t\t\tformat.parseObject(dateRangeTermFilter.getUpperBound()));\n\t\t}\n\t\tcatch (ParseException e) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"Invalid date range \" + dateRangeTermFilter, e);\n\t\t}\n\n\t\treturn rangeFilterBuilder;\n\t}","id":99576,"modified_method":"@Override\n\tpublic FilterBuilder translate(DateRangeTermFilter dateRangeTermFilter) {\n\t\tRangeFilterBuilder rangeFilterBuilder = FilterBuilders.rangeFilter(\n\t\t\tdateRangeTermFilter.getField());\n\n\t\tif (dateRangeTermFilter.isCached() != null) {\n\t\t\trangeFilterBuilder.cache(dateRangeTermFilter.isCached());\n\t\t}\n\n\t\tFormat format = FastDateFormatFactoryUtil.getSimpleDateFormat(\n\t\t\tdateRangeTermFilter.getDateFormat(),\n\t\t\tdateRangeTermFilter.getTimeZone());\n\n\t\ttry {\n\t\t\trangeFilterBuilder.from(\n\t\t\t\tformat.parseObject(dateRangeTermFilter.getLowerBound()));\n\t\t\trangeFilterBuilder.includeLower(\n\t\t\t\tdateRangeTermFilter.isIncludesLower());\n\t\t\trangeFilterBuilder.includeUpper(\n\t\t\t\tdateRangeTermFilter.isIncludesUpper());\n\t\t\trangeFilterBuilder.to(\n\t\t\t\tformat.parseObject(dateRangeTermFilter.getUpperBound()));\n\t\t}\n\t\tcatch (ParseException e) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"Invalid date range \" + dateRangeTermFilter, e);\n\t\t}\n\n\t\treturn rangeFilterBuilder;\n\t}","commit_id":"56c52faac3b1453f76018eafabc378730315e05f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic FilterBuilder translate(GeoBoundingBoxFilter geoBoundingBoxFilter) {\n\t\tGeoBoundingBoxFilterBuilder geoBoundingBoxFilterBuilder =\n\t\t\tFilterBuilders.geoBoundingBoxFilter(\n\t\t\t\tgeoBoundingBoxFilter.getField());\n\n\t\tGeoLocationPoint bottomRightGeoLocationPoint =\n\t\t\tgeoBoundingBoxFilter.getBottomRightGeoLocationPoint();\n\n\t\tGeoPoint bottomRightGeoPoint = new GeoPoint(\n\t\t\tbottomRightGeoLocationPoint.getLatitude(),\n\t\t\tbottomRightGeoLocationPoint.getLongitude());\n\n\t\tgeoBoundingBoxFilterBuilder.bottomRight(bottomRightGeoPoint);\n\n\t\tgeoBoundingBoxFilterBuilder.cache(geoBoundingBoxFilter.isCached());\n\n\t\tGeoLocationPoint topLeftGeoLocationPoint =\n\t\t\tgeoBoundingBoxFilter.getTopLeftGeoLocationPoint();\n\n\t\tGeoPoint topLeftGeoPoint = new GeoPoint(\n\t\t\ttopLeftGeoLocationPoint.getLatitude(),\n\t\t\ttopLeftGeoLocationPoint.getLongitude());\n\n\t\tgeoBoundingBoxFilterBuilder.topLeft(topLeftGeoPoint);\n\n\t\treturn geoBoundingBoxFilterBuilder;\n\t}","id":99577,"modified_method":"@Override\n\tpublic FilterBuilder translate(GeoBoundingBoxFilter geoBoundingBoxFilter) {\n\t\tGeoBoundingBoxFilterBuilder geoBoundingBoxFilterBuilder =\n\t\t\tFilterBuilders.geoBoundingBoxFilter(\n\t\t\t\tgeoBoundingBoxFilter.getField());\n\n\t\tGeoLocationPoint bottomRightGeoLocationPoint =\n\t\t\tgeoBoundingBoxFilter.getBottomRightGeoLocationPoint();\n\n\t\tGeoPoint bottomRightGeoPoint = new GeoPoint(\n\t\t\tbottomRightGeoLocationPoint.getLatitude(),\n\t\t\tbottomRightGeoLocationPoint.getLongitude());\n\n\t\tgeoBoundingBoxFilterBuilder.bottomRight(bottomRightGeoPoint);\n\n\t\tif (geoBoundingBoxFilter.isCached() != null) {\n\t\t\tgeoBoundingBoxFilterBuilder.cache(geoBoundingBoxFilter.isCached());\n\t\t}\n\n\t\tGeoLocationPoint topLeftGeoLocationPoint =\n\t\t\tgeoBoundingBoxFilter.getTopLeftGeoLocationPoint();\n\n\t\tGeoPoint topLeftGeoPoint = new GeoPoint(\n\t\t\ttopLeftGeoLocationPoint.getLatitude(),\n\t\t\ttopLeftGeoLocationPoint.getLongitude());\n\n\t\tgeoBoundingBoxFilterBuilder.topLeft(topLeftGeoPoint);\n\n\t\treturn geoBoundingBoxFilterBuilder;\n\t}","commit_id":"56c52faac3b1453f76018eafabc378730315e05f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic FilterBuilder translate(GeoDistanceFilter geoDistanceFilter) {\n\t\tGeoDistanceFilterBuilder geoDistanceFilterBuilder =\n\t\t\tFilterBuilders.geoDistanceFilter(geoDistanceFilter.getField());\n\n\t\tgeoDistanceFilterBuilder.cache(geoDistanceFilter.isCached());\n\t\tgeoDistanceFilterBuilder.distance(\n\t\t\tString.valueOf(geoDistanceFilter.getGeoDistance()));\n\n\t\tGeoLocationPoint pinGeoLocationPoint =\n\t\t\tgeoDistanceFilter.getPinGeoLocationPoint();\n\n\t\tgeoDistanceFilterBuilder.point(\n\t\t\tpinGeoLocationPoint.getLatitude(),\n\t\t\tpinGeoLocationPoint.getLongitude());\n\n\t\treturn geoDistanceFilterBuilder;\n\t}","id":99578,"modified_method":"@Override\n\tpublic FilterBuilder translate(GeoDistanceFilter geoDistanceFilter) {\n\t\tGeoDistanceFilterBuilder geoDistanceFilterBuilder =\n\t\t\tFilterBuilders.geoDistanceFilter(geoDistanceFilter.getField());\n\n\t\tif (geoDistanceFilter.isCached() != null) {\n\t\t\tgeoDistanceFilterBuilder.cache(geoDistanceFilter.isCached());\n\t\t}\n\n\t\tgeoDistanceFilterBuilder.distance(\n\t\t\tString.valueOf(geoDistanceFilter.getGeoDistance()));\n\n\t\tGeoLocationPoint pinGeoLocationPoint =\n\t\t\tgeoDistanceFilter.getPinGeoLocationPoint();\n\n\t\tgeoDistanceFilterBuilder.point(\n\t\t\tpinGeoLocationPoint.getLatitude(),\n\t\t\tpinGeoLocationPoint.getLongitude());\n\n\t\treturn geoDistanceFilterBuilder;\n\t}","commit_id":"56c52faac3b1453f76018eafabc378730315e05f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic FilterBuilder translate(\n\t\tGeoDistanceRangeFilter geoDistanceRangeFilter) {\n\n\t\tGeoDistanceRangeFilterBuilder geoDistanceRangeFilterBuilder =\n\t\t\tFilterBuilders.geoDistanceRangeFilter(\n\t\t\t\tgeoDistanceRangeFilter.getField());\n\n\t\tgeoDistanceRangeFilterBuilder.cache(geoDistanceRangeFilter.isCached());\n\t\tgeoDistanceRangeFilterBuilder.from(\n\t\t\tString.valueOf(geoDistanceRangeFilter.getLowerBoundGeoDistance()));\n\t\tgeoDistanceRangeFilterBuilder.includeLower(\n\t\t\tgeoDistanceRangeFilter.isIncludesLower());\n\t\tgeoDistanceRangeFilterBuilder.includeUpper(\n\t\t\tgeoDistanceRangeFilter.isIncludesUpper());\n\n\t\tGeoLocationPoint pinGeoLocationPoint =\n\t\t\tgeoDistanceRangeFilter.getPinGeoLocationPoint();\n\n\t\tgeoDistanceRangeFilterBuilder.point(\n\t\t\tpinGeoLocationPoint.getLatitude(),\n\t\t\tpinGeoLocationPoint.getLongitude());\n\n\t\tgeoDistanceRangeFilterBuilder.to(\n\t\t\tString.valueOf(geoDistanceRangeFilter.getUpperBoundGeoDistance()));\n\n\t\treturn geoDistanceRangeFilterBuilder;\n\t}","id":99579,"modified_method":"@Override\n\tpublic FilterBuilder translate(\n\t\tGeoDistanceRangeFilter geoDistanceRangeFilter) {\n\n\t\tGeoDistanceRangeFilterBuilder geoDistanceRangeFilterBuilder =\n\t\t\tFilterBuilders.geoDistanceRangeFilter(\n\t\t\t\tgeoDistanceRangeFilter.getField());\n\n\t\tif (geoDistanceRangeFilter.isCached() != null) {\n\t\t\tgeoDistanceRangeFilterBuilder.cache(\n\t\t\t\tgeoDistanceRangeFilter.isCached());\n\t\t}\n\n\t\tgeoDistanceRangeFilterBuilder.from(\n\t\t\tString.valueOf(geoDistanceRangeFilter.getLowerBoundGeoDistance()));\n\t\tgeoDistanceRangeFilterBuilder.includeLower(\n\t\t\tgeoDistanceRangeFilter.isIncludesLower());\n\t\tgeoDistanceRangeFilterBuilder.includeUpper(\n\t\t\tgeoDistanceRangeFilter.isIncludesUpper());\n\n\t\tGeoLocationPoint pinGeoLocationPoint =\n\t\t\tgeoDistanceRangeFilter.getPinGeoLocationPoint();\n\n\t\tgeoDistanceRangeFilterBuilder.point(\n\t\t\tpinGeoLocationPoint.getLatitude(),\n\t\t\tpinGeoLocationPoint.getLongitude());\n\n\t\tgeoDistanceRangeFilterBuilder.to(\n\t\t\tString.valueOf(geoDistanceRangeFilter.getUpperBoundGeoDistance()));\n\n\t\treturn geoDistanceRangeFilterBuilder;\n\t}","commit_id":"56c52faac3b1453f76018eafabc378730315e05f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic FilterBuilder translate(GeoPolygonFilter geoPolygonFilter) {\n\t\tGeoPolygonFilterBuilder geoPolygonFilterBuilder =\n\t\t\tFilterBuilders.geoPolygonFilter(geoPolygonFilter.getField());\n\n\t\tfor (GeoLocationPoint geoLocationPoint :\n\t\t\t\tgeoPolygonFilter.getGeoLocationPoints()) {\n\n\t\t\tgeoPolygonFilterBuilder.addPoint(\n\t\t\t\tgeoLocationPoint.getLatitude(),\n\t\t\t\tgeoLocationPoint.getLongitude());\n\t\t}\n\n\t\tgeoPolygonFilterBuilder.cache(geoPolygonFilter.isCached());\n\n\t\treturn geoPolygonFilterBuilder;\n\t}","id":99580,"modified_method":"@Override\n\tpublic FilterBuilder translate(GeoPolygonFilter geoPolygonFilter) {\n\t\tGeoPolygonFilterBuilder geoPolygonFilterBuilder =\n\t\t\tFilterBuilders.geoPolygonFilter(geoPolygonFilter.getField());\n\n\t\tfor (GeoLocationPoint geoLocationPoint :\n\t\t\t\tgeoPolygonFilter.getGeoLocationPoints()) {\n\n\t\t\tgeoPolygonFilterBuilder.addPoint(\n\t\t\t\tgeoLocationPoint.getLatitude(),\n\t\t\t\tgeoLocationPoint.getLongitude());\n\t\t}\n\n\t\tif (geoPolygonFilter.isCached() != null) {\n\t\t\tgeoPolygonFilterBuilder.cache(geoPolygonFilter.isCached());\n\t\t}\n\n\t\treturn geoPolygonFilterBuilder;\n\t}","commit_id":"56c52faac3b1453f76018eafabc378730315e05f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Reference(unbind = \"-\")\n\tpublic void setQueryTranslator(\n\t\tQueryTranslator<QueryBuilder> queryTranslator) {\n\n\t\t_queryTranslator = queryTranslator;\n\t}","id":99581,"modified_method":"@Reference(unbind = \"-\")\n\tprotected void setQueryTranslator(\n\t\tQueryTranslator<QueryBuilder> queryTranslator) {\n\n\t\t_queryTranslator = queryTranslator;\n\t}","commit_id":"56c52faac3b1453f76018eafabc378730315e05f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic FilterBuilder translate(QueryFilter queryFilter) {\n\t\tQueryBuilder queryBuilder = _queryTranslator.translate(\n\t\t\tqueryFilter.getQuery(), null);\n\n\t\tQueryFilterBuilder queryFilterBuilder = FilterBuilders.queryFilter(\n\t\t\tqueryBuilder);\n\n\t\tqueryFilterBuilder.cache(queryFilter.isCached());\n\n\t\treturn queryFilterBuilder;\n\t}","id":99582,"modified_method":"@Override\n\tpublic FilterBuilder translate(QueryFilter queryFilter) {\n\t\tQueryBuilder queryBuilder = _queryTranslator.translate(\n\t\t\tqueryFilter.getQuery(), null);\n\n\t\tQueryFilterBuilder queryFilterBuilder = FilterBuilders.queryFilter(\n\t\t\tqueryBuilder);\n\n\t\tif (queryFilter.isCached() != null) {\n\t\t\tqueryFilterBuilder.cache(queryFilter.isCached());\n\t\t}\n\n\t\treturn queryFilterBuilder;\n\t}","commit_id":"56c52faac3b1453f76018eafabc378730315e05f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic FilterBuilder translate(RangeTermFilter rangeTermFilter) {\n\t\tRangeFilterBuilder rangeFilterBuilder = FilterBuilders.rangeFilter(\n\t\t\trangeTermFilter.getField());\n\n\t\trangeFilterBuilder.cache(rangeTermFilter.isCached());\n\t\trangeFilterBuilder.from(rangeTermFilter.getLowerBound());\n\t\trangeFilterBuilder.includeLower(rangeTermFilter.isIncludesLower());\n\t\trangeFilterBuilder.includeUpper(rangeTermFilter.isIncludesUpper());\n\t\trangeFilterBuilder.to(rangeTermFilter.getUpperBound());\n\n\t\treturn rangeFilterBuilder;\n\t}","id":99583,"modified_method":"@Override\n\tpublic FilterBuilder translate(RangeTermFilter rangeTermFilter) {\n\t\tRangeFilterBuilder rangeFilterBuilder = FilterBuilders.rangeFilter(\n\t\t\trangeTermFilter.getField());\n\n\t\tif (rangeTermFilter.isCached() != null) {\n\t\t\trangeFilterBuilder.cache(rangeTermFilter.isCached());\n\t\t}\n\n\t\trangeFilterBuilder.from(rangeTermFilter.getLowerBound());\n\t\trangeFilterBuilder.includeLower(rangeTermFilter.isIncludesLower());\n\t\trangeFilterBuilder.includeUpper(rangeTermFilter.isIncludesUpper());\n\t\trangeFilterBuilder.to(rangeTermFilter.getUpperBound());\n\n\t\treturn rangeFilterBuilder;\n\t}","commit_id":"56c52faac3b1453f76018eafabc378730315e05f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic FilterBuilder translate(TermFilter termFilter) {\n\t\tFilterBuilder filterBuilder = null;\n\n\t\tString field = termFilter.getField();\n\t\tString value = termFilter.getValue();\n\n\t\tif ((_queryPreProcessConfiguration != null) &&\n\t\t\t_queryPreProcessConfiguration.isSubstringSearchAlways(field)) {\n\n\t\t\tWildcardQueryBuilder wildcardQueryBuilder =\n\t\t\t\ttoCaseInsensitiveSubstringQuery(field, value);\n\n\t\t\tQueryFilterBuilder queryFilterBuilder = FilterBuilders.queryFilter(\n\t\t\t\twildcardQueryBuilder);\n\n\t\t\tqueryFilterBuilder.cache(termFilter.isCached());\n\n\t\t\tfilterBuilder = queryFilterBuilder;\n\t\t}\n\t\telse {\n\t\t\tTermFilterBuilder termFilterBuilder = FilterBuilders.termFilter(\n\t\t\t\tfield, value);\n\n\t\t\ttermFilterBuilder.cache(termFilter.isCached());\n\n\t\t\tfilterBuilder = termFilterBuilder;\n\t\t}\n\n\t\treturn filterBuilder;\n\t}","id":99584,"modified_method":"@Override\n\tpublic FilterBuilder translate(TermFilter termFilter) {\n\t\tFilterBuilder filterBuilder = null;\n\n\t\tString field = termFilter.getField();\n\t\tString value = termFilter.getValue();\n\n\t\tif ((_queryPreProcessConfiguration != null) &&\n\t\t\t_queryPreProcessConfiguration.isSubstringSearchAlways(field)) {\n\n\t\t\tWildcardQueryBuilder wildcardQueryBuilder =\n\t\t\t\ttoCaseInsensitiveSubstringQuery(field, value);\n\n\t\t\tQueryFilterBuilder queryFilterBuilder = FilterBuilders.queryFilter(\n\t\t\t\twildcardQueryBuilder);\n\n\t\t\tif (termFilter.isCached() != null) {\n\t\t\t\tqueryFilterBuilder.cache(termFilter.isCached());\n\t\t\t}\n\n\t\t\tfilterBuilder = queryFilterBuilder;\n\t\t}\n\t\telse {\n\t\t\tTermFilterBuilder termFilterBuilder = FilterBuilders.termFilter(\n\t\t\t\tfield, value);\n\n\t\t\tif (termFilter.isCached() != null) {\n\t\t\t\ttermFilterBuilder.cache(termFilter.isCached());\n\t\t\t}\n\n\t\t\tfilterBuilder = termFilterBuilder;\n\t\t}\n\n\t\treturn filterBuilder;\n\t}","commit_id":"56c52faac3b1453f76018eafabc378730315e05f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action doUpdate method failed. Action:\" + \"AddLanguageImport\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","id":99585,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action doUpdate method failed. Action:\" + \"AddLanguageImport\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"442651f64393c49bd54f65b5be1195bcd25e932f","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"project\", event.getData(PlatformDataKeys.PROJECT));\n    if (MapSequence.fromMap(_params).get(\"project\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"module\", event.getData(MPSCommonDataKeys.CONTEXT_MODULE));\n    if (MapSequence.fromMap(_params).get(\"module\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"model\", event.getData(MPSCommonDataKeys.CONTEXT_MODEL));\n    if (MapSequence.fromMap(_params).get(\"model\") == null) {\n      return false;\n    }\n    if (!(MapSequence.fromMap(_params).get(\"model\") instanceof EditableSModel) || ((EditableSModel) MapSequence.fromMap(_params).get(\"model\")).isReadOnly()) {\n      return false;\n    }\n    return true;\n  }","id":99586,"modified_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"project\", event.getData(PlatformDataKeys.PROJECT));\n    if (MapSequence.fromMap(_params).get(\"project\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"module\", event.getData(MPSCommonDataKeys.CONTEXT_MODULE));\n    if (MapSequence.fromMap(_params).get(\"module\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"model\", event.getData(MPSCommonDataKeys.CONTEXT_MODEL));\n    return true;\n  }","commit_id":"442651f64393c49bd54f65b5be1195bcd25e932f","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void navigate(boolean requestFocus) {\n      assert !ModelAccess.instance().canRead();\n\n      final Set<SModuleReference> importCandidates = new HashSet<SModuleReference>();\n      ModelAccess.instance().runWriteAction(new Runnable() {\n        @Override\n        public void run() {\n          Language lang = ModuleRepositoryFacade.getInstance().getModule(getModuleReference(), Language.class);\n\n          HashSet<Language> langs = new HashSet<Language>(LanguageDependenciesManager.getAllExtendedLanguages(lang));\n          langs.remove(lang);\n          // todo: ! ?\n          //this is added in language implicitly, so we don't show this import\n          langs.remove(BootstrapLanguages.coreLanguage());\n\n          for (Language l : langs) {\n            Collection<SModuleReference> impLangs = ((jetbrains.mps.smodel.SModelInternal) myModel).getModelDepsManager().getAllImportedLanguages();\n            if (impLangs.contains(l.getModuleReference())) continue;\n            importCandidates.add(l.getModuleReference());\n          }\n        }\n      });\n\n      final Set<SModuleReference> toImport = new HashSet<SModuleReference>();\n\n      if (!importCandidates.isEmpty()) {\n        Set<SModuleReference> modules = chooseModulesToImport(myProject, importCandidates);\n        if (modules != null) {\n          toImport.addAll(modules);\n        }\n      }\n\n      toImport.add(getModuleReference());\n\n      ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n        @Override\n        public void run() {\n          boolean reload = false;\n          for (SModuleReference ref : toImport) {\n            if (((AbstractModule) myContextModule).getScope().getLanguage(ref) == null) {\n              ((AbstractModule) myContextModule).addUsedLanguage((SModuleReference) ref);\n              reload = true;\n            }\n            ((jetbrains.mps.smodel.SModelInternal) myModel).addLanguage((SModuleReference) ref);\n          }\n          if (reload) {\n            ClassLoaderManager.getInstance().unloadClasses(Arrays.asList(myContextModule), new EmptyProgressMonitor());\n            ClassLoaderManager.getInstance().loadAllPossibleClasses(new EmptyProgressMonitor());\n          }\n        }\n      });\n    }","id":99587,"modified_method":"@Override\n    public void navigate(boolean requestFocus) {\n      assert !ModelAccess.instance().canRead();\n\n      final Set<SModuleReference> importCandidates = new HashSet<SModuleReference>();\n      ModelAccess.instance().runWriteAction(new Runnable() {\n        @Override\n        public void run() {\n          Language lang = ModuleRepositoryFacade.getInstance().getModule(getModuleReference(), Language.class);\n\n          HashSet<Language> langs = new HashSet<Language>(LanguageDependenciesManager.getAllExtendedLanguages(lang));\n          langs.remove(lang);\n          // todo: ! ?\n          //this is added in language implicitly, so we don't show this import\n          langs.remove(BootstrapLanguages.coreLanguage());\n\n          for (Language l : langs) {\n            if(myModel != null) {\n              Collection<SModuleReference> impLangs = ((jetbrains.mps.smodel.SModelInternal) myModel).getModelDepsManager().getAllImportedLanguages();\n              if (impLangs.contains(l.getModuleReference())) continue;\n            }\n            importCandidates.add(l.getModuleReference());\n          }\n        }\n      });\n\n      final Set<SModuleReference> toImport = new HashSet<SModuleReference>();\n\n      if (!importCandidates.isEmpty()) {\n        Set<SModuleReference> modules = chooseModulesToImport(myProject, importCandidates);\n        if (modules != null) {\n          toImport.addAll(modules);\n        }\n      }\n\n      toImport.add(getModuleReference());\n\n      ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n        @Override\n        public void run() {\n          boolean reload = false;\n          for (SModuleReference ref : toImport) {\n            if(myContextModule instanceof DevKit) {\n              ((DevKit) myContextModule).getModuleDescriptor().getExportedLanguages().add(ref);\n              ((DevKit) myContextModule).setChanged();\n            } else if (((AbstractModule) myContextModule).getScope().getLanguage(ref) == null) {\n              ((AbstractModule) myContextModule).addUsedLanguage((SModuleReference) ref);\n              reload = true;\n            }\n            if(myModel != null)\n              ((jetbrains.mps.smodel.SModelInternal) myModel).addLanguage((SModuleReference) ref);\n          }\n          if (reload) {\n            ClassLoaderManager.getInstance().unloadClasses(Arrays.asList(myContextModule), new EmptyProgressMonitor());\n            ClassLoaderManager.getInstance().loadAllPossibleClasses(new EmptyProgressMonitor());\n          }\n        }\n      });\n    }","commit_id":"442651f64393c49bd54f65b5be1195bcd25e932f","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"project\", event.getData(CommonDataKeys.PROJECT));\n    if (MapSequence.fromMap(_params).get(\"project\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"context\", event.getData(MPSCommonDataKeys.OPERATION_CONTEXT));\n    if (MapSequence.fromMap(_params).get(\"context\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"node\", event.getData(MPSCommonDataKeys.NODE));\n    if (MapSequence.fromMap(_params).get(\"node\") == null) {\n      return false;\n    }\n    return true;\n  }","id":99588,"modified_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"project\", event.getData(CommonDataKeys.PROJECT));\n    if (MapSequence.fromMap(_params).get(\"project\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"mpsProject\", event.getData(MPSCommonDataKeys.MPS_PROJECT));\n    if (MapSequence.fromMap(_params).get(\"mpsProject\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"context\", event.getData(MPSCommonDataKeys.OPERATION_CONTEXT));\n    if (MapSequence.fromMap(_params).get(\"context\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"node\", event.getData(MPSCommonDataKeys.NODE));\n    if (MapSequence.fromMap(_params).get(\"node\") == null) {\n      return false;\n    }\n    return true;\n  }","commit_id":"88a5f0ffb46ade528e928fa4b338e00d58de7062","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action doUpdate method failed. Action:\" + \"ShowInLogicalView\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","id":99589,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action doUpdate method failed. Action:\" + \"ShowInLogicalView\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"88a5f0ffb46ade528e928fa4b338e00d58de7062","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ShowInLogicalView_Action() {\n    super(\"Show Node in Logical View\", \"\", ICON);\n    this.setIsAlwaysVisible(true);\n    this.setExecuteOutsideCommand(false);\n  }","id":99590,"modified_method":"public ShowInLogicalView_Action() {\n    super(\"Show Node in Logical View\", \"\", ICON);\n    this.setIsAlwaysVisible(false);\n    this.setExecuteOutsideCommand(false);\n  }","commit_id":"88a5f0ffb46ade528e928fa4b338e00d58de7062","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"PasteAsJavaClass\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","id":99591,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"PasteAsJavaClass\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"5c0d70b935295737e601531577157cdb00e87397","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"PasteAsJavaMethods\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","id":99592,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"PasteAsJavaMethods\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"5c0d70b935295737e601531577157cdb00e87397","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"PasteAsJavaStatements\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","id":99593,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"PasteAsJavaStatements\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"5c0d70b935295737e601531577157cdb00e87397","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action doUpdate method failed. Action:\" + \"ModuleProperties\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","id":99594,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action doUpdate method failed. Action:\" + \"ModuleProperties\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"49634e6ace16bdae0592981f9ce4db8af5d3e495","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"node\", event.getData(MPSCommonDataKeys.TREE_NODE));\n    if (MapSequence.fromMap(_params).get(\"node\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"group\", event.getData(MPSEditorDataKeys.EDITOR_CREATE_GROUP));\n    return true;\n  }","id":99595,"modified_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"node\", event.getData(MPSCommonDataKeys.TREE_NODE));\n    MapSequence.fromMap(_params).put(\"group\", event.getData(MPSEditorDataKeys.EDITOR_CREATE_GROUP));\n    return true;\n  }","commit_id":"cf24cec51d43bf5f877a5c07cdeb31c0a2b458f5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public NewElement_Action() {\n    super(\"New...\", \"\", ICON);\n    this.setIsAlwaysVisible(true);\n    this.setExecuteOutsideCommand(true);\n    this.addPlace(null);\n  }","id":99596,"modified_method":"public NewElement_Action() {\n    super(\"New...\", \"\", ICON);\n    this.setIsAlwaysVisible(false);\n    this.setExecuteOutsideCommand(true);\n    this.addPlace(null);\n  }","commit_id":"cf24cec51d43bf5f877a5c07cdeb31c0a2b458f5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action doUpdate method failed. Action:\" + \"NewElement\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","id":99597,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action doUpdate method failed. Action:\" + \"NewElement\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"cf24cec51d43bf5f877a5c07cdeb31c0a2b458f5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"NewLibrary\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","id":99598,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"NewLibrary\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"3b467ca24763913969dac26805d474d9ca9f4276","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"GoToConceptDeclaration\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","id":99599,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"GoToConceptDeclaration\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"322d2e4a94d0dafbff3dd33b17cc68caaca03786","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"AnalyzeModuleDependencies\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","id":99600,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"AnalyzeModuleDependencies\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"e7c925b15d844857caea0aad5bd74d952036dc3d","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"myModules\", event.getData(MPSDataKeys.MODULES));\n    if (MapSequence.fromMap(_params).get(\"myModules\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"myProject\", event.getData(MPSDataKeys.PROJECT));\n    if (MapSequence.fromMap(_params).get(\"myProject\") == null) {\n      return false;\n    }\n    return true;\n  }","id":99601,"modified_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"modules\", event.getData(MPSDataKeys.MODULES));\n    if (MapSequence.fromMap(_params).get(\"modules\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"project\", event.getData(MPSDataKeys.PROJECT));\n    if (MapSequence.fromMap(_params).get(\"project\") == null) {\n      return false;\n    }\n    return true;\n  }","commit_id":"e7c925b15d844857caea0aad5bd74d952036dc3d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      ModuleDependenies_Tool tool = ((Project) MapSequence.fromMap(_params).get(\"myProject\")).getComponent(ProjectPluginManager.class).getTool(ModuleDependenies_Tool.class);\n      tool.setModules(((List<IModule>) MapSequence.fromMap(_params).get(\"myModules\")));\n      tool.openToolLater(true);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"AnalyzeModuleDependencies\", t);\n      }\n    }\n  }","id":99602,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      ModuleDependenies_Tool tool = ((Project) MapSequence.fromMap(_params).get(\"project\")).getComponent(ProjectPluginManager.class).getTool(ModuleDependenies_Tool.class);\n      tool.setModules(((List<IModule>) MapSequence.fromMap(_params).get(\"modules\")));\n      tool.openToolLater(true);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"AnalyzeModuleDependencies\", t);\n      }\n    }\n  }","commit_id":"e7c925b15d844857caea0aad5bd74d952036dc3d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action doUpdate method failed. Action:\" + \"ShowGenerationPlan\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","id":99603,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action doUpdate method failed. Action:\" + \"ShowGenerationPlan\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"4c93a7bec45bfd8b5fa0a40f980e6a555a574895","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void createGroups() {\n    // actions w/o parameters \n    addAction(new AddLanguageImport_Action());\n    addAction(new AddMissingImportsInProject_Action());\n    addAction(new AddMissingImports_Action());\n    addAction(new AddModelImportByRoot_Action());\n    addAction(new AddModelImport_Action());\n    addAction(new AddModuleToProject_Action());\n    addAction(new AddToNewFavoritesList_Action());\n    addAction(new AnalyzeClasspath_Action());\n    addAction(new CloneModel_Action());\n    addAction(new CloneRoot_Action());\n    addAction(new CollapseAll_Action());\n    addAction(new Collapse_Action());\n    addAction(new CopyModelName_Action());\n    addAction(new CopyModuleName_Action());\n    addAction(new CopyNodeName_Action());\n    addAction(new CopyNodeReference_Action());\n    addAction(new CopyNode_Action());\n    addAction(new CreateAspect_Action());\n    addAction(new CutNode_Action());\n    addAction(new DeleteFavoritesList_Action());\n    addAction(new DeleteModels_Action());\n    addAction(new DeleteModules_Action());\n    addAction(new DeleteNode_Action());\n    addAction(new DeletePropertyAction_Action());\n    addAction(new DeleteReferenceAction_Action());\n    addAction(new EditNode_Action());\n    addAction(new ExpandAll_Action());\n    addAction(new ExpandNode_Action());\n    addAction(new Expand_Action());\n    addAction(new FastFindNodeUsages_Action());\n    addAction(new FindNext_Action());\n    addAction(new FindPrevious_Action());\n    addAction(new FindSpecificNodeUsages_Action());\n    addAction(new Find_Action());\n    addAction(new FoldSelection_Action());\n    addAction(new GoByCurrentReference_Action());\n    addAction(new GoToNodeById_Action());\n    addAction(new GoToNode_Action());\n    addAction(new GoToRule_Action());\n    addAction(new HighlightInstances_Action());\n    addAction(new HighlightUsages_Action());\n    addAction(new MPSProjectPaths_Action());\n    addAction(new ModelProperties_Action());\n    addAction(new ModuleProperties_Action());\n    addAction(new MoveFileOrDirectory_Action());\n    addAction(new NewDirectory_Action());\n    addAction(new NewFile_Action());\n    addAction(new NewModel_Action());\n    addAction(new NewRuntimeModule_Action());\n    addAction(new NewSubModel_Action());\n    addAction(new NewSubTestModel_Action());\n    addAction(new OptimizeModelImports_Action());\n    addAction(new OptimizeModuleImports_Action());\n    addAction(new OptimizeProjectImports_Action());\n    addAction(new PasteNode_Action());\n    addAction(new QuickCreate_Action());\n    addAction(new RemoveAllBookmarks_Action());\n    addAction(new RemoveFromFavorites_Action());\n    addAction(new RemoveModuleFromProject_Action());\n    addAction(new RemoveTransientModels_Action());\n    addAction(new RenameFavoritesList_Action());\n    addAction(new RenameFileOrDirectory_Action());\n    addAction(new RenameModel_Action());\n    addAction(new RenameNamespace_Action());\n    addAction(new RenamePackage_Action());\n    addAction(new RenameSolution_Action());\n    addAction(new RevertMemoryChanges_Action());\n    addAction(new SetBookmarkNoNumber_Action());\n    addAction(new SetModuleFolder_Action());\n    addAction(new SetNodePackage_Action());\n    addAction(new ShowBookmarksDialog_Action());\n    addAction(new ShowBookmarks_Action());\n    addAction(new ShowClassInHierarchy_Action());\n    addAction(new ShowConceptInHierarchy_Action());\n    addAction(new ShowErrorMessage_Action());\n    addAction(new ShowImplementations_Action());\n    addAction(new ShowInLogicalView_Action());\n    addAction(new ShowModuleDependencies_Action());\n    addAction(new ShowNodeInInspector_Action());\n    addAction(new ShowNodeInfo_Action());\n    addAction(new ShowParameters_Action());\n    addAction(new ShowStructure_Action());\n    // groups \n    addGroup(new AbstractFileActions_ActionGroup());\n    addGroup(new AddToFavoritesGroup_ActionGroup());\n    addGroup(new Analyze_ActionGroup());\n    addGroup(new Bookmarks_ActionGroup());\n    addGroup(new Build_ActionGroup());\n    addGroup(new Code_ActionGroup());\n    addGroup(new CommonModuleActions_ActionGroup());\n    addGroup(new CreateRootNode_ActionGroup());\n    addGroup(new DebugActions_ActionGroup());\n    addGroup(new DevkitActions_ActionGroup());\n    addGroup(new Edit_ActionGroup());\n    addGroup(new EditorInternal_ActionGroup());\n    addGroup(new EditorLeftPanelMenu_ActionGroup());\n    addGroup(new EditorPopup_ActionGroup());\n    addGroup(new EditorTabActions_ActionGroup());\n    addGroup(new FavoritesPopupWrapper_ActionGroup());\n    addGroup(new FavoritesPopup_ActionGroup());\n    addGroup(new Favorites_ActionGroup());\n    addGroup(new FileActions_ActionGroup());\n    addGroup(new FileSystemNewActions_ActionGroup());\n    addGroup(new FindUsages_ActionGroup());\n    addGroup(new FolderActions_ActionGroup());\n    addGroup(new Folding_ActionGroup());\n    addGroup(new GeneratorActions_ActionGroup());\n    addGroup(new GeneratorNewActions_ActionGroup());\n    addGroup(new GoByReference_ActionGroup());\n    addGroup(new GoToEditorPopupAddition_ActionGroup());\n    addGroup(new Goto_ActionGroup());\n    addGroup(new JUnitTestCaseActions_ActionGroup());\n    addGroup(new JUnitTestMethodActions_ActionGroup());\n    addGroup(new LanguageActions_ActionGroup());\n    addGroup(new LanguageNewActions_ActionGroup());\n    addGroup(new LibraryActions_ActionGroup());\n    addGroup(new ModelActionsInternal_ActionGroup());\n    addGroup(new ModelActions_ActionGroup());\n    addGroup(new ModelNewActions_ActionGroup());\n    addGroup(new ModelRefactoring_ActionGroup());\n    addGroup(new ModuleActions_ActionGroup());\n    addGroup(new NamespaceActions_ActionGroup());\n    addGroup(new NamespaceInternalActions_ActionGroup());\n    addGroup(new NamespaceMakeActions_ActionGroup());\n    addGroup(new NodeActionsInternal_ActionGroup());\n    addGroup(new NodeActions_ActionGroup());\n    addGroup(new PackageActions_ActionGroup());\n    addGroup(new PackageNewActions_ActionGroup());\n    addGroup(new ProjectActions_ActionGroup());\n    addGroup(new ProjectNewActions_ActionGroup());\n    addGroup(new PropertyNodeActions_ActionGroup());\n    addGroup(new ReferenceNodeActions_ActionGroup());\n    addGroup(new RuntimeFolderActions_ActionGroup());\n    addGroup(new Search_ActionGroup());\n    addGroup(new SolutionActions_ActionGroup());\n    addGroup(new SolutionNewActions_ActionGroup());\n    addGroup(new SolutionRefactoring_ActionGroup());\n    addGroup(new ToolsInternal_ActionGroup());\n    addGroup(new Tools_ActionGroup());\n    addGroup(new TransientModulesActions_ActionGroup());\n    addGroup(new View_ActionGroup());\n  }","id":99604,"modified_method":"public void createGroups() {\n    // actions w/o parameters \n    addAction(new AddLanguageImport_Action());\n    addAction(new AddMissingImportsInProject_Action());\n    addAction(new AddMissingImports_Action());\n    addAction(new AddModelImportByRoot_Action());\n    addAction(new AddModelImport_Action());\n    addAction(new AddModuleToProject_Action());\n    addAction(new AddToNewFavoritesList_Action());\n    addAction(new AnalyzeClasspath_Action());\n    addAction(new CloneModel_Action());\n    addAction(new CloneRoot_Action());\n    addAction(new CollapseAll_Action());\n    addAction(new Collapse_Action());\n    addAction(new CopyModelName_Action());\n    addAction(new CopyModuleName_Action());\n    addAction(new CopyNodeName_Action());\n    addAction(new CopyNodeReference_Action());\n    addAction(new CopyNode_Action());\n    addAction(new CreateAspect_Action());\n    addAction(new CutNode_Action());\n    addAction(new DeleteFavoritesList_Action());\n    addAction(new DeleteModels_Action());\n    addAction(new DeleteModules_Action());\n    addAction(new DeleteNode_Action());\n    addAction(new DeletePropertyAction_Action());\n    addAction(new DeleteReferenceAction_Action());\n    addAction(new EditNode_Action());\n    addAction(new ExpandAll_Action());\n    addAction(new ExpandNode_Action());\n    addAction(new Expand_Action());\n    addAction(new FastFindNodeUsages_Action());\n    addAction(new FindNext_Action());\n    addAction(new FindPrevious_Action());\n    addAction(new FindSpecificNodeUsages_Action());\n    addAction(new Find_Action());\n    addAction(new FoldSelection_Action());\n    addAction(new GoByCurrentReference_Action());\n    addAction(new GoToNodeById_Action());\n    addAction(new GoToNode_Action());\n    addAction(new GoToRule_Action());\n    addAction(new HighlightInstances_Action());\n    addAction(new HighlightUsages_Action());\n    addAction(new MPSProjectPaths_Action());\n    addAction(new ModelProperties_Action());\n    addAction(new ModuleProperties_Action());\n    addAction(new MoveFileOrDirectory_Action());\n    addAction(new NewDirectory_Action());\n    addAction(new NewFile_Action());\n    addAction(new NewLibrary_Action());\n    addAction(new NewModel_Action());\n    addAction(new NewRuntimeModule_Action());\n    addAction(new NewSolution_Action());\n    addAction(new NewSubModel_Action());\n    addAction(new NewSubTestModel_Action());\n    addAction(new OptimizeModelImports_Action());\n    addAction(new OptimizeModuleImports_Action());\n    addAction(new OptimizeProjectImports_Action());\n    addAction(new PasteNode_Action());\n    addAction(new QuickCreate_Action());\n    addAction(new RemoveAllBookmarks_Action());\n    addAction(new RemoveFromFavorites_Action());\n    addAction(new RemoveModuleFromProject_Action());\n    addAction(new RemoveTransientModels_Action());\n    addAction(new RenameFavoritesList_Action());\n    addAction(new RenameFileOrDirectory_Action());\n    addAction(new RenameModel_Action());\n    addAction(new RenameNamespace_Action());\n    addAction(new RenamePackage_Action());\n    addAction(new RenameSolution_Action());\n    addAction(new RevertMemoryChanges_Action());\n    addAction(new SetBookmarkNoNumber_Action());\n    addAction(new SetModuleFolder_Action());\n    addAction(new SetNodePackage_Action());\n    addAction(new ShowBookmarksDialog_Action());\n    addAction(new ShowBookmarks_Action());\n    addAction(new ShowClassInHierarchy_Action());\n    addAction(new ShowConceptInHierarchy_Action());\n    addAction(new ShowErrorMessage_Action());\n    addAction(new ShowImplementations_Action());\n    addAction(new ShowInLogicalView_Action());\n    addAction(new ShowModuleDependencies_Action());\n    addAction(new ShowNodeInInspector_Action());\n    addAction(new ShowNodeInfo_Action());\n    addAction(new ShowParameters_Action());\n    addAction(new ShowStructure_Action());\n    // groups \n    addGroup(new AbstractFileActions_ActionGroup());\n    addGroup(new AddToFavoritesGroup_ActionGroup());\n    addGroup(new Analyze_ActionGroup());\n    addGroup(new Bookmarks_ActionGroup());\n    addGroup(new Build_ActionGroup());\n    addGroup(new Code_ActionGroup());\n    addGroup(new CommonModuleActions_ActionGroup());\n    addGroup(new CreateRootNode_ActionGroup());\n    addGroup(new DebugActions_ActionGroup());\n    addGroup(new DevkitActions_ActionGroup());\n    addGroup(new Edit_ActionGroup());\n    addGroup(new EditorInternal_ActionGroup());\n    addGroup(new EditorLeftPanelMenu_ActionGroup());\n    addGroup(new EditorPopup_ActionGroup());\n    addGroup(new EditorTabActions_ActionGroup());\n    addGroup(new FavoritesPopupWrapper_ActionGroup());\n    addGroup(new FavoritesPopup_ActionGroup());\n    addGroup(new Favorites_ActionGroup());\n    addGroup(new FileActions_ActionGroup());\n    addGroup(new FileSystemNewActions_ActionGroup());\n    addGroup(new FindUsages_ActionGroup());\n    addGroup(new FolderActions_ActionGroup());\n    addGroup(new Folding_ActionGroup());\n    addGroup(new GeneratorActions_ActionGroup());\n    addGroup(new GeneratorNewActions_ActionGroup());\n    addGroup(new GoByReference_ActionGroup());\n    addGroup(new GoToEditorPopupAddition_ActionGroup());\n    addGroup(new Goto_ActionGroup());\n    addGroup(new JUnitTestCaseActions_ActionGroup());\n    addGroup(new JUnitTestMethodActions_ActionGroup());\n    addGroup(new LanguageActions_ActionGroup());\n    addGroup(new LanguageNewActions_ActionGroup());\n    addGroup(new LibraryActions_ActionGroup());\n    addGroup(new ModelActionsInternal_ActionGroup());\n    addGroup(new ModelActions_ActionGroup());\n    addGroup(new ModelNewActions_ActionGroup());\n    addGroup(new ModelRefactoring_ActionGroup());\n    addGroup(new ModuleActions_ActionGroup());\n    addGroup(new NamespaceActions_ActionGroup());\n    addGroup(new NamespaceInternalActions_ActionGroup());\n    addGroup(new NamespaceMakeActions_ActionGroup());\n    addGroup(new NodeActionsInternal_ActionGroup());\n    addGroup(new NodeActions_ActionGroup());\n    addGroup(new PackageActions_ActionGroup());\n    addGroup(new PackageNewActions_ActionGroup());\n    addGroup(new ProjectActions_ActionGroup());\n    addGroup(new ProjectNewActions_ActionGroup());\n    addGroup(new PropertyNodeActions_ActionGroup());\n    addGroup(new ReferenceNodeActions_ActionGroup());\n    addGroup(new RuntimeFolderActions_ActionGroup());\n    addGroup(new Search_ActionGroup());\n    addGroup(new SolutionActions_ActionGroup());\n    addGroup(new SolutionNewActions_ActionGroup());\n    addGroup(new SolutionRefactoring_ActionGroup());\n    addGroup(new ToolsInternal_ActionGroup());\n    addGroup(new Tools_ActionGroup());\n    addGroup(new TransientModulesActions_ActionGroup());\n    addGroup(new View_ActionGroup());\n  }","commit_id":"00dcf01b3e5678a9450e3dec10b7d6ef232d13ce","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void createGroups() {\n    // actions w/o parameters \n    addAction(new AddAccessoryModel_Action());\n    addAction(new CellProperties_Action());\n    addAction(new DeleteGenerator_Action());\n    addAction(new GoToConceptDeclaration_Action());\n    addAction(new GoToEditorDeclaration_Action());\n    addAction(new GoToRules_Action());\n    addAction(new GoToUsageInMappingConfig_Action());\n    addAction(new HighlightCellDependencies_Action());\n    addAction(new InstallIDEAPlugin_Action());\n    addAction(new LanguageHierarchy_Action());\n    addAction(new LanguagePaths_Action());\n    addAction(new NewAccessoryModel_Action());\n    addAction(new NewDevKit_Action());\n    addAction(new NewGenerator_Action());\n    addAction(new PrintNodeID_Action());\n    addAction(new ReloadAll_Action());\n    addAction(new RenameLanguage_Action());\n    addAction(new ShowCellInExplorer_Action());\n    addAction(new ShowGenerationTrace_Action());\n    addAction(new ShowGenerationTraceback_Action());\n    addAction(new ShowModelRepository_Action());\n    addAction(new ShowModuleRepository_Action());\n    addAction(new ShowNodeInExplorer_Action());\n    addAction(new ShowTypeSystemTraceIncremental_Action());\n    addAction(new ShowTypeSystemTrace_Action());\n    addAction(new TestNodePath_Action());\n    // groups \n    addGroup(new AccessoriesGroupActions_ActionGroup());\n    addGroup(new DevKitTools_ActionGroup());\n    addGroup(new EditorInternalEx_ActionGroup());\n    addGroup(new GenerateEditorPopup_ActionGroup());\n    addGroup(new GenerationTraceActions_ActionGroup());\n    addGroup(new GeneratorActions_Delete_ActionGroup());\n    addGroup(new GotoConceptAspect_ActionGroup());\n    addGroup(new LanguageActionsEx_ActionGroup());\n    addGroup(new LanguageNewActionsEx_ActionGroup());\n    addGroup(new LanguageNewCustomPartActions_ActionGroup());\n    addGroup(new LanguageNewGenerator_ActionGroup());\n    addGroup(new LanguageRefactoring_ActionGroup());\n    addGroup(new ProjectNewActionsEx_ActionGroup());\n    addGroup(new RepositoryToolsGroup_ActionGroup());\n    addGroup(new ShowNodeIn_ActionGroup());\n    addGroup(new TraceActions_ActionGroup());\n  }","id":99605,"modified_method":"public void createGroups() {\n    // actions w/o parameters \n    addAction(new AddAccessoryModel_Action());\n    addAction(new CellProperties_Action());\n    addAction(new DeleteGenerator_Action());\n    addAction(new GoToConceptDeclaration_Action());\n    addAction(new GoToEditorDeclaration_Action());\n    addAction(new GoToRules_Action());\n    addAction(new GoToUsageInMappingConfig_Action());\n    addAction(new HighlightCellDependencies_Action());\n    addAction(new InstallIDEAPlugin_Action());\n    addAction(new LanguageHierarchy_Action());\n    addAction(new LanguagePaths_Action());\n    addAction(new NewAccessoryModel_Action());\n    addAction(new NewDevKit_Action());\n    addAction(new NewGenerator_Action());\n    addAction(new NewLanguage_Action());\n    addAction(new PrintNodeID_Action());\n    addAction(new ReloadAll_Action());\n    addAction(new RenameLanguage_Action());\n    addAction(new ShowCellInExplorer_Action());\n    addAction(new ShowGenerationTrace_Action());\n    addAction(new ShowGenerationTraceback_Action());\n    addAction(new ShowModelRepository_Action());\n    addAction(new ShowModuleRepository_Action());\n    addAction(new ShowNodeInExplorer_Action());\n    addAction(new ShowTypeSystemTraceIncremental_Action());\n    addAction(new ShowTypeSystemTrace_Action());\n    addAction(new TestNodePath_Action());\n    // groups \n    addGroup(new AccessoriesGroupActions_ActionGroup());\n    addGroup(new DevKitTools_ActionGroup());\n    addGroup(new EditorInternalEx_ActionGroup());\n    addGroup(new GenerateEditorPopup_ActionGroup());\n    addGroup(new GenerationTraceActions_ActionGroup());\n    addGroup(new GeneratorActions_Delete_ActionGroup());\n    addGroup(new GotoConceptAspect_ActionGroup());\n    addGroup(new LanguageActionsEx_ActionGroup());\n    addGroup(new LanguageNewActionsEx_ActionGroup());\n    addGroup(new LanguageNewCustomPartActions_ActionGroup());\n    addGroup(new LanguageNewGenerator_ActionGroup());\n    addGroup(new LanguageRefactoring_ActionGroup());\n    addGroup(new ProjectNewActionsEx_ActionGroup());\n    addGroup(new RepositoryToolsGroup_ActionGroup());\n    addGroup(new ShowNodeIn_ActionGroup());\n    addGroup(new TraceActions_ActionGroup());\n  }","commit_id":"00dcf01b3e5678a9450e3dec10b7d6ef232d13ce","url":"https://github.com/JetBrains/MPS"},{"original_method":"public DefaultActionGroup createNewGroup() {\n    boolean hasModulesUnder = hasModulesUnder();\n    boolean hasModelsUnder = hasModelsUnder();\n\n    if (!hasModelsUnder && !hasModulesUnder) return null;\n\n    DefaultActionGroup newGroup = new DefaultActionGroup(\"New\", true);\n\n    if (hasModulesUnder) {\n      newGroup.add(new NewSolution_Action(myName));\n      // FIXME\n      //newGroup.add(new NewLanguage_Action(myName));\n    }\n    if (hasModelsUnder && hasModulesUnder) {\n      newGroup.addSeparator();\n    }\n    if (hasModelsUnder) {\n      newGroup.add(new NewModel_Action() {\n        protected String getNamespace() {\n          return NamespaceTextNode.this.getNamespace();\n        }\n      });\n    }\n    return newGroup;\n  }","id":99606,"modified_method":"public DefaultActionGroup createNewGroup() {\n    boolean hasModulesUnder = hasModulesUnder();\n    boolean hasModelsUnder = hasModelsUnder();\n\n    if (!hasModelsUnder && !hasModulesUnder) return null;\n\n    DefaultActionGroup newGroup = new DefaultActionGroup(\"New\", true);\n\n    if (hasModulesUnder) {\n      newGroup.add(new NewSolution_Action());\n      // FIXME\n      //newGroup.add(new NewLanguage_Action(myName));\n    }\n    if (hasModelsUnder && hasModulesUnder) {\n      newGroup.addSeparator();\n    }\n    if (hasModelsUnder) {\n      newGroup.add(new NewModel_Action() {\n        protected String getNamespace() {\n          return NamespaceTextNode.this.getNamespace();\n        }\n      });\n    }\n    return newGroup;\n  }","commit_id":"00dcf01b3e5678a9450e3dec10b7d6ef232d13ce","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"frame\", event.getData(MPSDataKeys.FRAME));\n    if (MapSequence.fromMap(_params).get(\"frame\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"project\", event.getData(MPSDataKeys.MPS_PROJECT));\n    if (MapSequence.fromMap(_params).get(\"project\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"ideaProject\", event.getData(MPSDataKeys.PROJECT));\n    if (MapSequence.fromMap(_params).get(\"ideaProject\") == null) {\n      return false;\n    }\n    return true;\n  }","id":99607,"modified_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"frame\", event.getData(MPSDataKeys.FRAME));\n    if (MapSequence.fromMap(_params).get(\"frame\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"project\", event.getData(MPSDataKeys.MPS_PROJECT));\n    if (MapSequence.fromMap(_params).get(\"project\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"ideaProject\", event.getData(MPSDataKeys.PROJECT));\n    if (MapSequence.fromMap(_params).get(\"ideaProject\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"namespace\", event.getData(MPSDataKeys.NAMESPACE));\n    return true;\n  }","commit_id":"00dcf01b3e5678a9450e3dec10b7d6ef232d13ce","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"NewDevKit\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","id":99608,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"NewDevKit\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"00dcf01b3e5678a9450e3dec10b7d6ef232d13ce","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      NewLanguageDialog dialog = new NewLanguageDialog(((Frame) MapSequence.fromMap(_params).get(\"frame\")));\n      dialog.setProject(((MPSProject) MapSequence.fromMap(_params).get(\"project\")));\n      dialog.showDialog();\n      Language l = dialog.getResult();\n      if (l == null) {\n        return;\n      }\n      ((MPSProject) MapSequence.fromMap(_params).get(\"project\")).setFolderFor(l, NewLanguage_Action.this.folder);\n      ProjectPane projectPane = ProjectPane.getInstance(((Project) MapSequence.fromMap(_params).get(\"ideaProject\")));\n      projectPane.rebuildTree();\n      projectPane.selectModule(l, false);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"NewLanguage\", t);\n      }\n    }\n  }","id":99609,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      NewLanguageDialog dialog = new NewLanguageDialog(((Frame) MapSequence.fromMap(_params).get(\"frame\")));\n      dialog.setProject(((MPSProject) MapSequence.fromMap(_params).get(\"project\")));\n      dialog.showDialog();\n      Language l = dialog.getResult();\n      if (l == null) {\n        return;\n      }\n      ((MPSProject) MapSequence.fromMap(_params).get(\"project\")).setFolderFor(l, (((String) MapSequence.fromMap(_params).get(\"namespace\")) == null ?\n        \"\" :\n        ((String) MapSequence.fromMap(_params).get(\"namespace\"))\n      ));\n      ProjectPane projectPane = ProjectPane.getInstance(((Project) MapSequence.fromMap(_params).get(\"ideaProject\")));\n      projectPane.rebuildTree();\n      projectPane.selectModule(l, false);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"NewLanguage\", t);\n      }\n    }\n  }","commit_id":"00dcf01b3e5678a9450e3dec10b7d6ef232d13ce","url":"https://github.com/JetBrains/MPS"},{"original_method":"public NewLanguage_Action(String folder_par) {\n    super(\"Language\", \"\", ICON);\n    this.folder = folder_par;\n    this.setIsAlwaysVisible(false);\n    this.setExecuteOutsideCommand(true);\n  }","id":99610,"modified_method":"public NewLanguage_Action() {\n    super(\"Language\", \"\", ICON);\n    this.setIsAlwaysVisible(false);\n    this.setExecuteOutsideCommand(true);\n  }","commit_id":"00dcf01b3e5678a9450e3dec10b7d6ef232d13ce","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"project\", event.getData(MPSDataKeys.MPS_PROJECT));\n    if (MapSequence.fromMap(_params).get(\"project\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"ideaProject\", event.getData(MPSDataKeys.PROJECT));\n    if (MapSequence.fromMap(_params).get(\"ideaProject\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"frame\", event.getData(MPSDataKeys.FRAME));\n    if (MapSequence.fromMap(_params).get(\"frame\") == null) {\n      return false;\n    }\n    return true;\n  }","id":99611,"modified_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"project\", event.getData(MPSDataKeys.MPS_PROJECT));\n    if (MapSequence.fromMap(_params).get(\"project\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"ideaProject\", event.getData(MPSDataKeys.PROJECT));\n    if (MapSequence.fromMap(_params).get(\"ideaProject\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"frame\", event.getData(MPSDataKeys.FRAME));\n    if (MapSequence.fromMap(_params).get(\"frame\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"namespace\", event.getData(MPSDataKeys.NAMESPACE));\n    return true;\n  }","commit_id":"00dcf01b3e5678a9450e3dec10b7d6ef232d13ce","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      NewLibDialog dialog = new NewLibDialog(((Frame) MapSequence.fromMap(_params).get(\"frame\")));\n      dialog.setProject(((MPSProject) MapSequence.fromMap(_params).get(\"project\")));\n      dialog.showDialog();\n      final Library s = dialog.getResult();\n      if (s == null) {\n        return;\n      }\n      ModelAccess.instance().runWriteAction(new Runnable() {\n        public void run() {\n          ((MPSProject) MapSequence.fromMap(_params).get(\"project\")).setFolderFor(s, NewLibrary_Action.this.folder);\n        }\n      });\n      ProjectPane projectPane = ProjectPane.getInstance(((Project) MapSequence.fromMap(_params).get(\"ideaProject\")));\n      projectPane.rebuildTree();\n      projectPane.selectModule(s, false);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"NewLibrary\", t);\n      }\n    }\n  }","id":99612,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      NewLibDialog dialog = new NewLibDialog(((Frame) MapSequence.fromMap(_params).get(\"frame\")));\n      dialog.setProject(((MPSProject) MapSequence.fromMap(_params).get(\"project\")));\n      dialog.showDialog();\n      final Library s = dialog.getResult();\n      if (s == null) {\n        return;\n      }\n      ModelAccess.instance().runWriteAction(new Runnable() {\n        public void run() {\n          ((MPSProject) MapSequence.fromMap(_params).get(\"project\")).setFolderFor(s, (((String) MapSequence.fromMap(_params).get(\"namespace\")) == null ?\n            \"\" :\n            ((String) MapSequence.fromMap(_params).get(\"namespace\"))\n          ));\n        }\n      });\n      ProjectPane projectPane = ProjectPane.getInstance(((Project) MapSequence.fromMap(_params).get(\"ideaProject\")));\n      projectPane.rebuildTree();\n      projectPane.selectModule(s, false);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"NewLibrary\", t);\n      }\n    }\n  }","commit_id":"00dcf01b3e5678a9450e3dec10b7d6ef232d13ce","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"project\", event.getData(MPSDataKeys.MPS_PROJECT));\n    if (MapSequence.fromMap(_params).get(\"project\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"ideaProject\", event.getData(MPSDataKeys.PROJECT));\n    if (MapSequence.fromMap(_params).get(\"ideaProject\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"frame\", event.getData(MPSDataKeys.FRAME));\n    if (MapSequence.fromMap(_params).get(\"frame\") == null) {\n      return false;\n    }\n    return true;\n  }","id":99613,"modified_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"project\", event.getData(MPSDataKeys.MPS_PROJECT));\n    if (MapSequence.fromMap(_params).get(\"project\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"ideaProject\", event.getData(MPSDataKeys.PROJECT));\n    if (MapSequence.fromMap(_params).get(\"ideaProject\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"frame\", event.getData(MPSDataKeys.FRAME));\n    if (MapSequence.fromMap(_params).get(\"frame\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"namespace\", event.getData(MPSDataKeys.NAMESPACE));\n    if (MapSequence.fromMap(_params).get(\"namespace\") == null) {\n      return false;\n    }\n    return true;\n  }","commit_id":"00dcf01b3e5678a9450e3dec10b7d6ef232d13ce","url":"https://github.com/JetBrains/MPS"},{"original_method":"public NewLibrary_Action(String folder_par) {\n    super(\"Library\", \"\", ICON);\n    this.folder = folder_par;\n    this.setIsAlwaysVisible(false);\n    this.setExecuteOutsideCommand(true);\n  }","id":99614,"modified_method":"public NewLibrary_Action() {\n    super(\"Library\", \"\", ICON);\n    this.setIsAlwaysVisible(false);\n    this.setExecuteOutsideCommand(true);\n  }","commit_id":"00dcf01b3e5678a9450e3dec10b7d6ef232d13ce","url":"https://github.com/JetBrains/MPS"},{"original_method":"public NewSolution_Action(String folder_par) {\n    super(\"Solution\", \"\", ICON);\n    this.folder = folder_par;\n    this.setIsAlwaysVisible(false);\n    this.setExecuteOutsideCommand(true);\n  }","id":99615,"modified_method":"public NewSolution_Action() {\n    super(\"Solution\", \"\", ICON);\n    this.setIsAlwaysVisible(false);\n    this.setExecuteOutsideCommand(true);\n  }","commit_id":"00dcf01b3e5678a9450e3dec10b7d6ef232d13ce","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"project\", event.getData(MPSDataKeys.MPS_PROJECT));\n    if (MapSequence.fromMap(_params).get(\"project\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"ideaProject\", event.getData(MPSDataKeys.PROJECT));\n    if (MapSequence.fromMap(_params).get(\"ideaProject\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"frame\", event.getData(MPSDataKeys.FRAME));\n    if (MapSequence.fromMap(_params).get(\"frame\") == null) {\n      return false;\n    }\n    return true;\n  }","id":99616,"modified_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"project\", event.getData(MPSDataKeys.MPS_PROJECT));\n    if (MapSequence.fromMap(_params).get(\"project\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"ideaProject\", event.getData(MPSDataKeys.PROJECT));\n    if (MapSequence.fromMap(_params).get(\"ideaProject\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"frame\", event.getData(MPSDataKeys.FRAME));\n    if (MapSequence.fromMap(_params).get(\"frame\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"namespace\", event.getData(MPSDataKeys.NAMESPACE));\n    if (MapSequence.fromMap(_params).get(\"namespace\") == null) {\n      return false;\n    }\n    return true;\n  }","commit_id":"00dcf01b3e5678a9450e3dec10b7d6ef232d13ce","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      NewSolutionDialog dialog = new NewSolutionDialog(((Frame) MapSequence.fromMap(_params).get(\"frame\")));\n      dialog.setProject(((MPSProject) MapSequence.fromMap(_params).get(\"project\")));\n      dialog.showDialog();\n      final Solution s = dialog.getResult();\n      if (s == null) {\n        return;\n      }\n      ModelAccess.instance().runWriteAction(new Runnable() {\n        public void run() {\n          ((MPSProject) MapSequence.fromMap(_params).get(\"project\")).setFolderFor(s, NewSolution_Action.this.folder);\n        }\n      });\n      ProjectPane projectPane = ProjectPane.getInstance(((Project) MapSequence.fromMap(_params).get(\"ideaProject\")));\n      projectPane.rebuildTree();\n      projectPane.selectModule(s, false);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"NewSolution\", t);\n      }\n    }\n  }","id":99617,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      NewSolutionDialog dialog = new NewSolutionDialog(((Frame) MapSequence.fromMap(_params).get(\"frame\")));\n      dialog.setProject(((MPSProject) MapSequence.fromMap(_params).get(\"project\")));\n      dialog.showDialog();\n      final Solution s = dialog.getResult();\n      if (s == null) {\n        return;\n      }\n      ModelAccess.instance().runWriteAction(new Runnable() {\n        public void run() {\n          ((MPSProject) MapSequence.fromMap(_params).get(\"project\")).setFolderFor(s, (((String) MapSequence.fromMap(_params).get(\"namespace\")) == null ?\n            \"\" :\n            ((String) MapSequence.fromMap(_params).get(\"namespace\"))\n          ));\n        }\n      });\n      ProjectPane projectPane = ProjectPane.getInstance(((Project) MapSequence.fromMap(_params).get(\"ideaProject\")));\n      projectPane.rebuildTree();\n      projectPane.selectModule(s, false);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"NewSolution\", t);\n      }\n    }\n  }","commit_id":"00dcf01b3e5678a9450e3dec10b7d6ef232d13ce","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ProjectNewActionsEx_ActionGroup() {\n    super(\"New\", ID);\n    this.setIsInternal(false);\n    this.setPopup(false);\n    try {\n      ProjectNewActionsEx_ActionGroup.this.addParameterizedAction(new NewLanguage_Action(\"\"), PluginId.getId(\"jetbrains.mps.ide.mpsdevkit\"), \"\");\n      ProjectNewActionsEx_ActionGroup.this.addAction(\"jetbrains.mps.ide.devkit.actions.NewDevKit_Action\");\n    } catch (Throwable t) {\n      LOG.error(\"User group error\", t);\n    }\n  }","id":99618,"modified_method":"public ProjectNewActionsEx_ActionGroup() {\n    super(\"New\", ID);\n    this.setIsInternal(false);\n    this.setPopup(false);\n    try {\n      ProjectNewActionsEx_ActionGroup.this.addAction(\"jetbrains.mps.ide.devkit.actions.NewLanguage_Action\");\n      ProjectNewActionsEx_ActionGroup.this.addAction(\"jetbrains.mps.ide.devkit.actions.NewDevKit_Action\");\n    } catch (Throwable t) {\n      LOG.error(\"User group error\", t);\n    }\n  }","commit_id":"00dcf01b3e5678a9450e3dec10b7d6ef232d13ce","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ProjectNewActions_ActionGroup() {\n    super(\"New\", ID);\n    this.setIsInternal(false);\n    this.setPopup(true);\n    try {\n      ProjectNewActions_ActionGroup.this.addParameterizedAction(new NewSolution_Action(\"\"), PluginId.getId(\"jetbrains.mps.ide\"), \"\");\n      ProjectNewActions_ActionGroup.this.addParameterizedAction(new NewLibrary_Action(\"\"), PluginId.getId(\"jetbrains.mps.ide\"), \"\");\n      {\n        LabelledAnchor action = new LabelledAnchor(ProjectNewActions_ActionGroup.LABEL_ID_end);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ProjectNewActions_ActionGroup.this.addAction(action);\n      }\n    } catch (Throwable t) {\n      LOG.error(\"User group error\", t);\n    }\n  }","id":99619,"modified_method":"public ProjectNewActions_ActionGroup() {\n    super(\"New\", ID);\n    this.setIsInternal(false);\n    this.setPopup(true);\n    try {\n      ProjectNewActions_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.NewSolution_Action\");\n      ProjectNewActions_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.NewLibrary_Action\");\n      {\n        LabelledAnchor action = new LabelledAnchor(ProjectNewActions_ActionGroup.LABEL_ID_end);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ProjectNewActions_ActionGroup.this.addAction(action);\n      }\n    } catch (Throwable t) {\n      LOG.error(\"User group error\", t);\n    }\n  }","commit_id":"00dcf01b3e5678a9450e3dec10b7d6ef232d13ce","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"ReplacementQueryAction\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","id":99620,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"ReplacementQueryAction\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"16fd5f25a461d43e6f9fefef51c77c8b2fdeb255","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final EditorCell selectedCell = ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).getSelectedCell();\n      int x = selectedCell.getX();\n      int y = selectedCell.getY();\n      if (selectedCell instanceof EditorCell_Label) {\n        y += ((EditorCell_Label) selectedCell).getHeight();\n      }\n      final DataContext dataContext = DataManager.getInstance().getDataContext(((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).getNodeEditorComponent(), x, y);\n      final Wrappers._T<ListPopup> popup = new Wrappers._T<ListPopup>(null);\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          ActionGroup group = ((ActionGroup) ActionManager.getInstance().getAction(\"jetbrains.mps.lang.intentions.plugin.GenerationIntentions_ActionGroup\"));\n          group.update(event);\n          if (group.getChildren(event).length == 0) {\n            return;\n          }\n          popup.value = JBPopupFactory.getInstance().createActionGroupPopup(\"Generate\", group, dataContext, JBPopupFactory.ActionSelectionAid.NUMBERING, false);\n        }\n      });\n      if (popup.value == null) {\n        return;\n      }\n\n      RelativePoint relativePoint = new RelativePoint(((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).getNodeEditorComponent(), new Point(x, y));\n      popup.value.show(relativePoint);\n    } catch (Throwable t) {\n      LOG.error(\"User's action execute method failed. Action:\" + \"ShowGenerationIntentions\", t);\n    }\n  }","id":99621,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final EditorCell selectedCell = ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).getSelectedCell();\n      int x = selectedCell.getX();\n      int y = selectedCell.getY();\n      if (selectedCell instanceof EditorCell_Label) {\n        y += ((EditorCell_Label) selectedCell).getHeight();\n      }\n      final Wrappers._T<ListPopup> popup = new Wrappers._T<ListPopup>(null);\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          ActionGroup group = ((ActionGroup) ActionManager.getInstance().getAction(\"jetbrains.mps.lang.intentions.plugin.GenerationIntentions_ActionGroup\"));\n          group.update(event);\n          if (group.getChildren(event).length == 0) {\n            return;\n          }\n          popup.value = JBPopupFactory.getInstance().createActionGroupPopup(\"Generate\", group, event.getDataContext(), JBPopupFactory.ActionSelectionAid.NUMBERING, false);\n        }\n      });\n      if (popup.value == null) {\n        return;\n      }\n\n      RelativePoint relativePoint = new RelativePoint(((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).getNodeEditorComponent(), new Point(x, y));\n      popup.value.show(relativePoint);\n    } catch (Throwable t) {\n      LOG.error(\"User's action execute method failed. Action:\" + \"ShowGenerationIntentions\", t);\n    }\n  }","commit_id":"fd10b8d721d20f855f77a8fc2355c05fc1c91963","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ShowGenerationIntentions_Action() {\n    super(\"Generate...\", \"\", ICON);\n    this.setIsAlwaysVisible(false);\n    this.setExecuteOutsideCommand(true);\n  }","id":99622,"modified_method":"public ShowGenerationIntentions_Action() {\n    super(\"Generate...\", \"\", ICON);\n    this.setIsAlwaysVisible(true);\n    this.setExecuteOutsideCommand(true);\n  }","commit_id":"fd10b8d721d20f855f77a8fc2355c05fc1c91963","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      LOG.error(\"User's action doUpdate method failed. Action:\" + \"ShowGenerationIntentions\", t);\n      this.disable(event.getPresentation());\n    }\n  }","id":99623,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      LOG.error(\"User's action doUpdate method failed. Action:\" + \"ShowGenerationIntentions\", t);\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"fd10b8d721d20f855f77a8fc2355c05fc1c91963","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isApplicable(AnActionEvent event, final Map<String, Object> _params) {\n    return ShowSurroundWithIntentions_Action.this.getAnchorCell(_params) != null;\n  }","id":99624,"modified_method":"public boolean isApplicable(AnActionEvent event, final Map<String, Object> _params) {\n    if (ShowSurroundWithIntentions_Action.this.getAnchorCell(_params) == null) {\n      return false;\n    }\n    ActionGroup group = ((ActionGroup) ActionManager.getInstance().getAction(\"jetbrains.mps.lang.intentions.plugin.SurroundWithIntentions_ActionGroup\"));\n    group.update(event);\n    return group.getChildren(event).length != 0;\n  }","commit_id":"fd10b8d721d20f855f77a8fc2355c05fc1c91963","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ShowSurroundWithIntentions_Action() {\n    super(\"Surround with...\", \"\", ICON);\n    this.setIsAlwaysVisible(false);\n    this.setExecuteOutsideCommand(true);\n  }","id":99625,"modified_method":"public ShowSurroundWithIntentions_Action() {\n    super(\"Surround with...\", \"\", ICON);\n    this.setIsAlwaysVisible(true);\n    this.setExecuteOutsideCommand(true);\n  }","commit_id":"fd10b8d721d20f855f77a8fc2355c05fc1c91963","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final EditorCell selectedCell = ShowSurroundWithIntentions_Action.this.getAnchorCell(_params);\n      int x = selectedCell.getX();\n      int y = selectedCell.getY();\n      y += selectedCell.getHeight();\n      final DataContext dataContext = DataManager.getInstance().getDataContext(((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).getNodeEditorComponent(), x, y);\n      final Wrappers._T<ListPopup> popup = new Wrappers._T<ListPopup>(null);\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          ActionGroup group = ((ActionGroup) ActionManager.getInstance().getAction(\"jetbrains.mps.lang.intentions.plugin.SurroundWithIntentions_ActionGroup\"));\n          group.update(event);\n          if (group.getChildren(event).length == 0) {\n            return;\n          }\n          popup.value = JBPopupFactory.getInstance().createActionGroupPopup(\"Surround with\", group, dataContext, JBPopupFactory.ActionSelectionAid.ALPHA_NUMBERING, false);\n        }\n      });\n      if (popup.value == null) {\n        return;\n      }\n\n      RelativePoint relativePoint = new RelativePoint(((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).getNodeEditorComponent(), new Point(x, y));\n      popup.value.show(relativePoint);\n    } catch (Throwable t) {\n      LOG.error(\"User's action execute method failed. Action:\" + \"ShowSurroundWithIntentions\", t);\n    }\n  }","id":99626,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final EditorCell selectedCell = ShowSurroundWithIntentions_Action.this.getAnchorCell(_params);\n      int x = selectedCell.getX();\n      int y = selectedCell.getY();\n      y += selectedCell.getHeight();\n      final Wrappers._T<ListPopup> popup = new Wrappers._T<ListPopup>(null);\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          ActionGroup group = ((ActionGroup) ActionManager.getInstance().getAction(\"jetbrains.mps.lang.intentions.plugin.SurroundWithIntentions_ActionGroup\"));\n          group.update(event);\n          if (group.getChildren(event).length == 0) {\n            return;\n          }\n          popup.value = JBPopupFactory.getInstance().createActionGroupPopup(\"Surround with\", group, event.getDataContext(), JBPopupFactory.ActionSelectionAid.ALPHA_NUMBERING, false);\n        }\n      });\n      if (popup.value == null) {\n        return;\n      }\n\n      RelativePoint relativePoint = new RelativePoint(((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).getNodeEditorComponent(), new Point(x, y));\n      popup.value.show(relativePoint);\n    } catch (Throwable t) {\n      LOG.error(\"User's action execute method failed. Action:\" + \"ShowSurroundWithIntentions\", t);\n    }\n  }","commit_id":"fd10b8d721d20f855f77a8fc2355c05fc1c91963","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final EditorCell selectedCell = ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).getSelectedCell();\n      int x = selectedCell.getX();\n      int y = selectedCell.getY();\n      if (selectedCell instanceof EditorCell_Label) {\n        y += ((EditorCell_Label) selectedCell).getHeight();\n      }\n      final DataContext dataContext = DataManager.getInstance().getDataContext(((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).getNodeEditorComponent(), x, y);\n      final Wrappers._T<ListPopup> popup = new Wrappers._T<ListPopup>(null);\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          ActionGroup group = ((ActionGroup) ActionManager.getInstance().getAction(\"jetbrains.mps.ide.devkit.actions.SurroundWithIntentions_ActionGroup\"));\n          group.update(event);\n          if (group.getChildren(event).length == 0) {\n            return;\n          }\n          popup.value = JBPopupFactory.getInstance().createActionGroupPopup(\"Surround with\", group, dataContext, JBPopupFactory.ActionSelectionAid.ALPHA_NUMBERING, false);\n        }\n      });\n      if (popup.value == null) {\n        return;\n      }\n\n      RelativePoint relativePoint = new RelativePoint(((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).getNodeEditorComponent(), new Point(x, y));\n      popup.value.show(relativePoint);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"SurroundWithIntentions\", t);\n      }\n    }\n  }","id":99627,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final EditorCell selectedCell = SurroundWithIntentions_Action.this.getAnchorCell(_params);\n      int x = selectedCell.getX();\n      int y = selectedCell.getY();\n      y += selectedCell.getHeight();\n      final DataContext dataContext = DataManager.getInstance().getDataContext(((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).getNodeEditorComponent(), x, y);\n      final Wrappers._T<ListPopup> popup = new Wrappers._T<ListPopup>(null);\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          ActionGroup group = ((ActionGroup) ActionManager.getInstance().getAction(\"jetbrains.mps.ide.devkit.actions.SurroundWithIntentions_ActionGroup\"));\n          group.update(event);\n          if (group.getChildren(event).length == 0) {\n            return;\n          }\n          popup.value = JBPopupFactory.getInstance().createActionGroupPopup(\"Surround with\", group, dataContext, JBPopupFactory.ActionSelectionAid.ALPHA_NUMBERING, false);\n        }\n      });\n      if (popup.value == null) {\n        return;\n      }\n\n      RelativePoint relativePoint = new RelativePoint(((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).getNodeEditorComponent(), new Point(x, y));\n      popup.value.show(relativePoint);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"SurroundWithIntentions\", t);\n      }\n    }\n  }","commit_id":"e1d21a730e50cbb8c3ea89775b72996578b4209f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"SurroundWithIntentions\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","id":99628,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"SurroundWithIntentions\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"e1d21a730e50cbb8c3ea89775b72996578b4209f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public AnAction getAction(JComponent shortcutComponent) {\n    AnAction action = new MyAddAction();\n    KeyboardShortcut shortcut = new KeyboardShortcut(KeyStroke.getKeyStroke(\"INSERT\"), null);\n    action.registerCustomShortcutSet(new CustomShortcutSet(shortcut), SwingUtilities.getRootPane(shortcutComponent));\n    return action;\n  }","id":99629,"modified_method":"public AnAction getAction() {\n    return new MyAddAction();\n  }","commit_id":"72b1fd9bd056bc44b23e2fd4d81170b757151400","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(AnActionEvent event) {\n    removeAll();\n\n    SModelDescriptor modelDescriptor = event.getData(MPSDataKeys.CONTEXT_MODEL);\n    if (modelDescriptor == null) {\n      setEnabledState(event.getPresentation(), false);\n      return;\n    }\n\n    IScope scope = event.getData(MPSDataKeys.SCOPE);\n    IOperationContext context = event.getData(MPSDataKeys.OPERATION_CONTEXT);\n    Integer selectedItemsCount = event.getData(MPSDataKeys.LOGICAL_VIEW_SELECTION_SIZE);\n    TreeNode treeNode = event.getData(MPSDataKeys.LOGICAL_VIEW_NODE);\n\n    boolean isStubModel = SModelStereotype.isStubModelStereotype(modelDescriptor.getStereotype());\n    boolean singleItemSelected = selectedItemsCount != null && selectedItemsCount == 1;\n    if (scope == null || context == null || isStubModel || !singleItemSelected) {\n      setEnabledState(event.getPresentation(), false);\n      return;\n    }\n\n    setEnabledState(event.getPresentation(), true);\n\n    if (!(treeNode instanceof PackageNode)) {\n      myPackage = null;\n    } else {\n      final PackageNode node = (PackageNode) treeNode;\n      myPackage = node.getPackage();\n    }\n\n    List<Language> modelLanguages = SModelOperations.getLanguages(modelDescriptor.getSModel(), scope);\n    if (modelLanguages.size() == 0) {\n      add(ActionManager.getInstance().getAction(AddLanguageImport_Action.class.getName()));\n    }\n\n    LanguageAspect aspect = Language.getModelAspect(modelDescriptor);\n    if (aspect != null) {\n      ModuleReference ref = aspect.getMainLanguage();\n      Language lang = scope.getLanguage(ref);\n      modelLanguages.remove(lang);\n\n      for (SNode conceptDeclaration : lang.getConceptDeclarations()) {\n        if (ModelConstraintsManager.canBeRoot(context, NameUtil.nodeFQName(conceptDeclaration), modelDescriptor.getSModel())) {\n          add(new NewRootNodeAction(new SNodePointer(conceptDeclaration), modelDescriptor));\n        }\n      }\n\n      addSeparator();\n    }\n\n\n    Collections.sort(modelLanguages, new ToStringComparator());\n\n    List<Language> languagesWithRoots = new ArrayList<Language>();\n    for (final Language language : modelLanguages) {\n      for (SNode conceptDeclaration : language.getConceptDeclarations()) {\n        if (ModelConstraintsManager.canBeRoot(context, NameUtil.nodeFQName(conceptDeclaration), modelDescriptor.getSModel())) {\n          languagesWithRoots.add(language);\n          break;\n        }\n      }\n    }\n\n    boolean plain = myPlain || (languagesWithRoots.size() == 1 && aspect == null);\n\n    for (final Language language : languagesWithRoots) {\n      String name = language.getModuleFqName();\n      Icon icon = IconManager.getIconForNamespace(language.getModuleFqName());\n      BaseGroup langRootsGroup;\n\n      if (!plain) {\n        langRootsGroup = new BaseGroup(name, name, icon);\n        langRootsGroup.setPopup(true);\n      } else {\n        langRootsGroup = this;\n      }\n\n      for (SNode conceptDeclaration : language.getConceptDeclarations()) {\n        if (ModelConstraintsManager.getInstance().canBeRoot(context, NameUtil.nodeFQName(conceptDeclaration), modelDescriptor.getSModel())) {\n          langRootsGroup.add(new NewRootNodeAction(new SNodePointer(conceptDeclaration), modelDescriptor));\n        }\n      }\n      if (!plain) {\n        this.add(langRootsGroup);\n      } else {\n        this.addSeparator();\n      }\n    }\n  }","id":99630,"modified_method":"public void doUpdate(AnActionEvent event) {\n    removeAll();\n\n    SModelDescriptor modelDescriptor = event.getData(MPSDataKeys.CONTEXT_MODEL);\n    if (modelDescriptor == null) {\n      setEnabledState(event.getPresentation(), false);\n      return;\n    }\n\n    IScope scope = event.getData(MPSDataKeys.SCOPE);\n    IOperationContext context = event.getData(MPSDataKeys.OPERATION_CONTEXT);\n\n    boolean isStubModel = SModelStereotype.isStubModelStereotype(modelDescriptor.getStereotype());\n    if (scope == null || context == null || isStubModel) {\n      setEnabledState(event.getPresentation(), false);\n      return;\n    }\n\n    boolean inEditor = event.getData(MPSDataKeys.LOGICAL_VIEW_SELECTION_SIZE) == null;\n\n    if (!inEditor) {\n      Integer selectedItemsCount = event.getData(MPSDataKeys.LOGICAL_VIEW_SELECTION_SIZE);\n      boolean singleItemSelected = selectedItemsCount != null && selectedItemsCount == 1;\n\n      if (!singleItemSelected) {\n        setEnabledState(event.getPresentation(), false);\n        return;\n      }\n\n      TreeNode treeNode = event.getData(MPSDataKeys.LOGICAL_VIEW_NODE);\n\n      if (!(treeNode instanceof PackageNode)) {\n        myPackage = null;\n      } else {\n        final PackageNode node = (PackageNode) treeNode;\n        myPackage = node.getPackage();\n      }\n    } else{\n      SNode node = event.getData(MPSDataKeys.NODE);\n      myPackage = null;\n      if (node!=null){\n        SNode root = node.getContainingRoot();\n        if (root!=null){\n          myPackage = root.getProperty(SNodeUtil.property_BaseConcept_virtualPackage);\n        }\n      }\n    }\n\n    setEnabledState(event.getPresentation(), true);\n\n    List<Language> modelLanguages = SModelOperations.getLanguages(modelDescriptor.getSModel(), scope);\n    if (modelLanguages.size() == 0) {\n      add(ActionManager.getInstance().getAction(AddLanguageImport_Action.class.getName()));\n    }\n\n    LanguageAspect aspect = Language.getModelAspect(modelDescriptor);\n    if (aspect != null) {\n      ModuleReference ref = aspect.getMainLanguage();\n      Language lang = scope.getLanguage(ref);\n      modelLanguages.remove(lang);\n\n      for (SNode conceptDeclaration : lang.getConceptDeclarations()) {\n        if (ModelConstraintsManager.canBeRoot(context, NameUtil.nodeFQName(conceptDeclaration), modelDescriptor.getSModel())) {\n          add(new NewRootNodeAction(new SNodePointer(conceptDeclaration), modelDescriptor));\n        }\n      }\n\n      addSeparator();\n    }\n\n    Collections.sort(modelLanguages, new ToStringComparator());\n\n    List<Language> languagesWithRoots = new ArrayList<Language>();\n    for (final Language language : modelLanguages) {\n      for (SNode conceptDeclaration : language.getConceptDeclarations()) {\n        if (ModelConstraintsManager.canBeRoot(context, NameUtil.nodeFQName(conceptDeclaration), modelDescriptor.getSModel())) {\n          languagesWithRoots.add(language);\n          break;\n        }\n      }\n    }\n\n    boolean plain = myPlain || (languagesWithRoots.size() == 1 && aspect == null);\n\n    for (final Language language : languagesWithRoots) {\n      String name = language.getModuleFqName();\n      Icon icon = IconManager.getIconForNamespace(language.getModuleFqName());\n      BaseGroup langRootsGroup;\n\n      if (!plain) {\n        langRootsGroup = new BaseGroup(name, name, icon);\n        langRootsGroup.setPopup(true);\n      } else {\n        langRootsGroup = this;\n      }\n\n      for (SNode conceptDeclaration : language.getConceptDeclarations()) {\n        if (ModelConstraintsManager.getInstance().canBeRoot(context, NameUtil.nodeFQName(conceptDeclaration), modelDescriptor.getSModel())) {\n          langRootsGroup.add(new NewRootNodeAction(new SNodePointer(conceptDeclaration), modelDescriptor));\n        }\n      }\n      if (!plain) {\n        this.add(langRootsGroup);\n      } else {\n        this.addSeparator();\n      }\n    }\n  }","commit_id":"72b1fd9bd056bc44b23e2fd4d81170b757151400","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"QuickCreate\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","id":99631,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"QuickCreate\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"72b1fd9bd056bc44b23e2fd4d81170b757151400","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final Wrappers._T<ListPopup> popup = new Wrappers._T<ListPopup>(null);\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          ActionGroup group = ((MPSTreeNode) ((TreeNode) MapSequence.fromMap(_params).get(\"node\"))).getQuickCreateGroup(event.getInputEvent().isControlDown());\n          if (group != null) {\n            Presentation pres = new Presentation();\n            AnActionEvent e = new AnActionEvent(event.getInputEvent(), event.getDataContext(), ActionPlaces.UNKNOWN, pres, ActionManager.getInstance(), 0);\n            ActionUtils.updateGroup(group, e);\n            popup.value = JBPopupFactory.getInstance().createActionGroupPopup(\"New\", group, event.getDataContext(), JBPopupFactory.ActionSelectionAid.SPEEDSEARCH, false);\n          }\n        }\n      });\n      if (popup.value == null) {\n        return;\n      }\n      popup.value.showInBestPositionFor(event.getDataContext());\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"QuickCreate\", t);\n      }\n    }\n  }","id":99632,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final Wrappers._T<ListPopup> popup = new Wrappers._T<ListPopup>(null);\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          ActionGroup group;\n          boolean controlDown = event.getInputEvent().isControlDown();\n\n          if (((TreeNode) MapSequence.fromMap(_params).get(\"node\")) != null) {\n            group = ((MPSTreeNode) ((TreeNode) MapSequence.fromMap(_params).get(\"node\"))).getQuickCreateGroup(controlDown);\n          } else {\n            group = new CreateRootNodeGroup(controlDown);\n          }\n          if (group != null) {\n            Presentation pres = new Presentation();\n            AnActionEvent e = new AnActionEvent(event.getInputEvent(), event.getDataContext(), ActionPlaces.UNKNOWN, pres, ActionManager.getInstance(), 0);\n            ActionUtils.updateGroup(group, e);\n            popup.value = JBPopupFactory.getInstance().createActionGroupPopup(\"New\", group, event.getDataContext(), JBPopupFactory.ActionSelectionAid.SPEEDSEARCH, false);\n          }\n        }\n      });\n      if (popup.value == null) {\n        return;\n      }\n      popup.value.showInBestPositionFor(event.getDataContext());\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"QuickCreate\", t);\n      }\n    }\n  }","commit_id":"72b1fd9bd056bc44b23e2fd4d81170b757151400","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"node\", event.getData(MPSDataKeys.LOGICAL_VIEW_NODE));\n    if (MapSequence.fromMap(_params).get(\"node\") == null) {\n      return false;\n    }\n    return true;\n  }","id":99633,"modified_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"node\", event.getData(MPSDataKeys.LOGICAL_VIEW_NODE));\n    MapSequence.fromMap(_params).put(\"model\", event.getData(MPSDataKeys.CONTEXT_MODEL));\n    return true;\n  }","commit_id":"72b1fd9bd056bc44b23e2fd4d81170b757151400","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void updateTabs() {\n    myRealTabs.clear();\n    myTabRemovalListener.clearAspects();\n\n    ArrayList<EditorTabDescriptor> tabs = new ArrayList<EditorTabDescriptor>(myPossibleTabs);\n    Collections.sort(tabs, new EditorTabComparator());\n\n    for (EditorTabDescriptor d : tabs) {\n      List<SNode> nodes = d.getNodes(myBaseNode.getNode());\n      if (nodes.isEmpty()) continue;\n\n      for (SNode node : nodes) {\n        myTabRemovalListener.aspectAdded(node.getContainingRoot());\n      }\n\n      final EditorTab tab = new EditorTab(this, myRealTabs.size(), d, myBaseNode);\n      myRealTabs.add(tab);\n    }\n\n    DefaultActionGroup group = new DefaultActionGroup();\n    group.add(myAddButton.getAction(this));\n    for (EditorTab tab : myRealTabs) {\n      group.add(tab.getAction(myShortcutComponent));\n    }\n    if (myToolbar != null) {\n      remove(myToolbar);\n    }\n    ActionToolbar actionToolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, group, true);\n    actionToolbar.setLayoutPolicy(ActionToolbar.WRAP_LAYOUT_POLICY);\n    myToolbar = actionToolbar.getComponent();\n    add(myToolbar, BorderLayout.CENTER);\n  }","id":99634,"modified_method":"private void updateTabs() {\n    myRealTabs.clear();\n    myTabRemovalListener.clearAspects();\n\n    ArrayList<EditorTabDescriptor> tabs = new ArrayList<EditorTabDescriptor>(myPossibleTabs);\n    Collections.sort(tabs, new EditorTabComparator());\n\n    for (EditorTabDescriptor d : tabs) {\n      List<SNode> nodes = d.getNodes(myBaseNode.getNode());\n      if (nodes.isEmpty()) continue;\n\n      for (SNode node : nodes) {\n        myTabRemovalListener.aspectAdded(node.getContainingRoot());\n      }\n\n      final EditorTab tab = new EditorTab(this, myRealTabs.size(), d, myBaseNode);\n      myRealTabs.add(tab);\n    }\n\n    DefaultActionGroup group = new DefaultActionGroup();\n    group.add(myAddButton.getAction());\n    for (EditorTab tab : myRealTabs) {\n      group.add(tab.getAction(myShortcutComponent));\n    }\n    if (myToolbar != null) {\n      remove(myToolbar);\n    }\n    ActionToolbar actionToolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, group, true);\n    actionToolbar.setLayoutPolicy(ActionToolbar.WRAP_LAYOUT_POLICY);\n    myToolbar = actionToolbar.getComponent();\n    add(myToolbar, BorderLayout.CENTER);\n  }","commit_id":"72b1fd9bd056bc44b23e2fd4d81170b757151400","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  public Object getData(@NonNls String id) {\n    DependencyTreeNode current = as_9bg0dz_a0a0a11(getCurrentNode(), DependencyTreeNode.class);\n    if (current == null) {\n      return null;\n    }\n    if (id.equals(MPSDataKeys.OPERATION_CONTEXT.getName())) {\n      return current.getOperationContext();\n    }\n    if (id.equals(MPSDataKeys.MODULE.getName())) {\n      return current.getModule();\n    }\n    if (id.equals(MPSDataKeys.CONTEXT_MODULE.getName()) && current.getLink().linktype == DependencyUtil.LinkType.Depends) {\n      DependencyTreeNode node = as_9bg0dz_a0a0a4a11(current.getParent(), DependencyTreeNode.class);\n      return check_9bg0dz_a1a4a11(node);\n    }\n    return null;\n  }","id":99635,"modified_method":"@Nullable\n  public Object getData(@NonNls String id) {\n    DependencyTreeNode current = as_9bg0dz_a0a0a11(getCurrentNode(), DependencyTreeNode.class);\n    if (id.equals(MPSDataKeys.LOGICAL_VIEW_NODE.getName())) {\n      return current;\n    }\n    if (id.equals(MPSDataKeys.OPERATION_CONTEXT.getName())) {\n      return check_9bg0dz_a0a2a11(current);\n    }\n    if (id.equals(MPSDataKeys.MODULE.getName())) {\n      return check_9bg0dz_a0a3a11(current);\n    }\n    return null;\n  }","commit_id":"7e9e4e1b5cd37a3e76e428cb43459fc002822d34","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static IModule check_9bg0dz_a1a4a11(DependencyTreeNode checkedDotOperand) {\n    if (null != checkedDotOperand) {\n      return checkedDotOperand.getModule();\n    }\n    return null;\n  }","id":99636,"modified_method":"private static IOperationContext check_9bg0dz_a0a2a11(DependencyTreeNode checkedDotOperand) {\n    if (null != checkedDotOperand) {\n      return checkedDotOperand.getOperationContext();\n    }\n    return null;\n  }","commit_id":"7e9e4e1b5cd37a3e76e428cb43459fc002822d34","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  protected JPopupMenu createPopupMenu(MPSTreeNode treeNode) {\n    TreePath[] selection = getSelectionPaths();\n    if (selection != null && selection.length > 1) {\n      return null;\n    }\n    ModuleDependencyNode current = as_he3vmc_a0a2a11(getCurrentNode(), ModuleDependencyNode.class);\n    if (current == null || ListSequence.fromList(current.getModules()).count() != 1) {\n      return null;\n    }\n\n    DefaultActionGroup group = ActionUtils.groupFromActions(((BaseAction) ActionManager.getInstance().getAction(\"jetbrains.mps.ide.actions.ShowModuleDependencyLoop_Action\")), ((BaseAction) ActionManager.getInstance().getAction(\"jetbrains.mps.ide.actions.ModuleProperties_Action\")));\n    return ActionManager.getInstance().createActionPopupMenu(ActionPlaces.UNKNOWN, group).getComponent();\n  }","id":99637,"modified_method":"@Override\n  protected JPopupMenu createPopupMenu(MPSTreeNode treeNode) {\n    DefaultActionGroup group = ActionUtils.groupFromActions(((BaseAction) ActionManager.getInstance().getAction(\"jetbrains.mps.ide.actions.ShowModuleDependencyLoop_Action\")), ((BaseAction) ActionManager.getInstance().getAction(\"jetbrains.mps.ide.actions.ModuleProperties_Action\")));\n    return ActionManager.getInstance().createActionPopupMenu(ActionPlaces.UNKNOWN, group).getComponent();\n  }","commit_id":"7e9e4e1b5cd37a3e76e428cb43459fc002822d34","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  public Object getData(@NonNls String id) {\n    ModuleDependencyNode current = as_he3vmc_a0a0a21(getCurrentNode(), ModuleDependencyNode.class);\n    if (current == null) {\n      return null;\n    }\n\n    if (id.equals(MPSDataKeys.OPERATION_CONTEXT.getName())) {\n      return current.getOperationContext();\n    }\n    if (id.equals(MPSDataKeys.MODULE.getName())) {\n      return ListSequence.fromList(current.getModules()).first();\n    }\n    if (id.equals(MPSDataKeys.LOGICAL_VIEW_NODE.getName())) {\n      return current;\n    }\n    return null;\n  }","id":99638,"modified_method":"@Nullable\n  public Object getData(@NonNls String id) {\n    ModuleDependencyNode current = as_he3vmc_a0a0a21(getCurrentNode(), ModuleDependencyNode.class);\n    if (id.equals(MPSDataKeys.LOGICAL_VIEW_NODE.getName())) {\n      return current;\n    }\n    if (id.equals(MPSDataKeys.OPERATION_CONTEXT.getName())) {\n      return check_he3vmc_a0a2a21(current);\n    }\n    if (id.equals(MPSDataKeys.MODULE.getName())) {\n      List<IModule> modules = check_he3vmc_a0a0d0m(current);\n      TreePath[] selection = getSelectionPaths();\n      if (ListSequence.fromList(modules).count() != 1 || (selection != null && selection.length > 1)) {\n        return null;\n      }\n      return ListSequence.fromList(modules).first();\n    }\n    return null;\n  }","commit_id":"7e9e4e1b5cd37a3e76e428cb43459fc002822d34","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"to\", event.getData(MPSDataKeys.MODULE));\n    if (MapSequence.fromMap(_params).get(\"to\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"from\", event.getData(MPSDataKeys.CONTEXT_MODULE));\n    if (MapSequence.fromMap(_params).get(\"from\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"mpsProject\", event.getData(MPSDataKeys.MPS_PROJECT));\n    MapSequence.fromMap(_params).put(\"project\", event.getData(MPSDataKeys.PROJECT));\n    return true;\n  }","id":99639,"modified_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"node\", event.getData(MPSDataKeys.LOGICAL_VIEW_NODE));\n    if (MapSequence.fromMap(_params).get(\"node\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"mpsProject\", event.getData(MPSDataKeys.MPS_PROJECT));\n    MapSequence.fromMap(_params).put(\"project\", event.getData(MPSDataKeys.PROJECT));\n    return true;\n  }","commit_id":"7e9e4e1b5cd37a3e76e428cb43459fc002822d34","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"SafeDeleteModuleDependency\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","id":99640,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"SafeDeleteModuleDependency\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"7e9e4e1b5cd37a3e76e428cb43459fc002822d34","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void removeDependency(final Map<String, Object> _params) {\n    final ModuleDescriptor descriptor = ((IModule) MapSequence.fromMap(_params).get(\"from\")).getModuleDescriptor();\n    List<Dependency> dependencies = descriptor.getDependencies();\n    ListSequence.fromList(dependencies).removeWhere(new IWhereFilter<Dependency>() {\n      public boolean accept(Dependency it) {\n        return it.getModuleRef().equals(((IModule) MapSequence.fromMap(_params).get(\"to\")).getModuleReference());\n      }\n    });\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      public void run() {\n        ((IModule) MapSequence.fromMap(_params).get(\"from\")).setModuleDescriptor(descriptor, false);\n        ((IModule) MapSequence.fromMap(_params).get(\"from\")).save();\n      }\n    });\n    ModuleDependenies_Tool tool = ((Project) MapSequence.fromMap(_params).get(\"project\")).getComponent(ProjectPluginManager.class).getTool(ModuleDependenies_Tool.class);\n    tool.resetAll();\n  }","id":99641,"modified_method":"private void removeDependency(final IModule from, final IModule to, final Map<String, Object> _params) {\n    final ModuleDescriptor descriptor = from.getModuleDescriptor();\n    List<Dependency> dependencies = descriptor.getDependencies();\n    ListSequence.fromList(dependencies).removeWhere(new IWhereFilter<Dependency>() {\n      public boolean accept(Dependency it) {\n        return it.getModuleRef().equals(to.getModuleReference());\n      }\n    });\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      public void run() {\n        // <node> \n        from.save();\n      }\n    });\n    ((Project) MapSequence.fromMap(_params).get(\"project\")).getComponent(ProjectPluginManager.class).getTool(ModuleDependenies_Tool.class).resetAll();\n  }","commit_id":"7e9e4e1b5cd37a3e76e428cb43459fc002822d34","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      SearchResults results = DependenciesUtil.analyzeDependencies(((IModule) MapSequence.fromMap(_params).get(\"from\")), ((IModule) MapSequence.fromMap(_params).get(\"to\")), ((Project) MapSequence.fromMap(_params).get(\"project\")), ((MPSProject) MapSequence.fromMap(_params).get(\"mpsProject\")), false);\n      if (results.getSearchResults().isEmpty()) {\n        SafeDeleteModuleDependency_Action.this.removeDependency(_params);\n      } else {\n        int res = Messages.showDialog(\"Can't safe delete dependency\", \"Safe delete impossible\", new String[]{\"View dependencies\", \"Delete anyway\", \"Cancel\"}, 0, null);\n        if (res == 1) {\n          SafeDeleteModuleDependency_Action.this.removeDependency(_params);\n        } else if (res == 0) {\n          ((Project) MapSequence.fromMap(_params).get(\"project\")).getComponent(ProjectPluginManager.class).getTool(AnalyzeDependencies_Tool.class).openToolLater(true);\n        }\n      }\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"SafeDeleteModuleDependency\", t);\n      }\n    }\n  }","id":99642,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      IModule from = check_bai5av_a0a0a(as_iuftgz_a0a0a0a0d(((TreeNode) MapSequence.fromMap(_params).get(\"node\")).getParent(), DependencyTreeNode.class));\n      IModule to = check_bai5av_a0b0a(as_iuftgz_a0a0b0a0d(((TreeNode) MapSequence.fromMap(_params).get(\"node\")), DependencyTreeNode.class));\n      SearchResults results = DependenciesUtil.analyzeDependencies(from, to, ((Project) MapSequence.fromMap(_params).get(\"project\")), ((MPSProject) MapSequence.fromMap(_params).get(\"mpsProject\")), false);\n      if (!(results.getSearchResults().isEmpty())) {\n        int res = Messages.showDialog(\"Can't safe delete dependency\", \"Safe delete impossible\", new String[]{\"View dependencies\", \"Delete anyway\", \"Cancel\"}, 0, null);\n        if (res == 0) {\n          ((Project) MapSequence.fromMap(_params).get(\"project\")).getComponent(ProjectPluginManager.class).getTool(AnalyzeDependencies_Tool.class).openToolLater(true);\n        }\n        if (res != 1) {\n          return;\n        }\n      }\n      SafeDeleteModuleDependency_Action.this.removeDependency(from, to, _params);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"SafeDeleteModuleDependency\", t);\n      }\n    }\n  }","commit_id":"7e9e4e1b5cd37a3e76e428cb43459fc002822d34","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"to\", event.getData(MPSDataKeys.MODULE));\n    if (MapSequence.fromMap(_params).get(\"to\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"from\", event.getData(MPSDataKeys.CONTEXT_MODULE));\n    if (MapSequence.fromMap(_params).get(\"from\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"mpsProject\", event.getData(MPSDataKeys.MPS_PROJECT));\n    MapSequence.fromMap(_params).put(\"project\", event.getData(MPSDataKeys.PROJECT));\n    return true;\n  }","id":99643,"modified_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"node\", event.getData(MPSDataKeys.LOGICAL_VIEW_NODE));\n    if (MapSequence.fromMap(_params).get(\"node\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"mpsProject\", event.getData(MPSDataKeys.MPS_PROJECT));\n    MapSequence.fromMap(_params).put(\"project\", event.getData(MPSDataKeys.PROJECT));\n    return true;\n  }","commit_id":"7e9e4e1b5cd37a3e76e428cb43459fc002822d34","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"ShowInDependenciesViewer\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","id":99644,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"ShowInDependenciesViewer\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"7e9e4e1b5cd37a3e76e428cb43459fc002822d34","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      DependenciesUtil.analyzeDependencies(((IModule) MapSequence.fromMap(_params).get(\"from\")), ((IModule) MapSequence.fromMap(_params).get(\"to\")), ((Project) MapSequence.fromMap(_params).get(\"project\")), ((MPSProject) MapSequence.fromMap(_params).get(\"mpsProject\")), true);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"ShowInDependenciesViewer\", t);\n      }\n    }\n  }","id":99645,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      IModule from = check_hezs1a_a0a0a(as_nkoo1o_a0a0a0a0d(((TreeNode) MapSequence.fromMap(_params).get(\"node\")).getParent(), DependencyTreeNode.class));\n      IModule to = check_hezs1a_a0b0a(as_nkoo1o_a0a0b0a0d(((TreeNode) MapSequence.fromMap(_params).get(\"node\")), DependencyTreeNode.class));\n      DependenciesUtil.analyzeDependencies(from, to, ((Project) MapSequence.fromMap(_params).get(\"project\")), ((MPSProject) MapSequence.fromMap(_params).get(\"mpsProject\")), true);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"ShowInDependenciesViewer\", t);\n      }\n    }\n  }","commit_id":"7e9e4e1b5cd37a3e76e428cb43459fc002822d34","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"PasteAsJavaClass\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","id":99646,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"PasteAsJavaClass\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"374a0ad078bea64ebff01d4f265d295f60623d13","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"PasteAsJavaMethods\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","id":99647,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"PasteAsJavaMethods\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"374a0ad078bea64ebff01d4f265d295f60623d13","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"PasteAsJavaStatements\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","id":99648,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"PasteAsJavaStatements\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"374a0ad078bea64ebff01d4f265d295f60623d13","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"AnalyzeStacktrace\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","id":99649,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"AnalyzeStacktrace\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"5e74a13df251da92987ba99524d88c010ff7148f","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void showPopupMenu(MouseEvent evt) {\n    if (myList.getSelectedValue() == null) return;\n\n    DefaultActionGroup group = createActionGroup();\n\n    JPopupMenu menu = ActionManager.getInstance().createActionPopupMenu(ActionPlaces.UNKNOWN, group).getComponent();\n    menu.show(myList, evt.getX(), evt.getY());\n  }","id":99650,"modified_method":"private void showPopupMenu(MouseEvent evt) {\n    if (myList.getSelectedValue() == null) return;\n\n    DefaultActionGroup group = createActionGroup();\n\n    JPopupMenu menu = ActionManager.getInstance().createActionPopupMenu(MPSActionPlaces.MPS_MESSAGES_POPUP, group).getComponent();\n    menu.show(myList, evt.getX(), evt.getY());\n  }","commit_id":"5e74a13df251da92987ba99524d88c010ff7148f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"OptimizeModelImports\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","id":99651,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"OptimizeModelImports\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"426a730b3d790216487579be3b25bd28cd6c4a7f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void visitXmlTagChildRemoved(final XmlTagChildRemoved xmlTagChildRemoved) {\n    final AntElement element = getAntParent(xmlTagChildRemoved.getTag());\n    if (element != null) {\n      element.clearCaches();\n    }\n  }","id":99652,"modified_method":"public void visitXmlTagChildRemoved(final XmlTagChildRemoved xmlTagChildRemoved) {\n    clearParentCaches(xmlTagChildRemoved.getTag());\n  }","commit_id":"e036fb7b717a429d2380f8ca01fc4b129055ed89","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitXmlElementChanged(final XmlElementChanged xmlElementChanged) {\n    final AntElement element = getAntParent(xmlElementChanged.getElement());\n    if (element != null) {\n      element.clearCaches();\n    }\n  }","id":99653,"modified_method":"public void visitXmlElementChanged(final XmlElementChanged xmlElementChanged) {\n    clearParentCaches(xmlElementChanged.getElement());\n  }","commit_id":"e036fb7b717a429d2380f8ca01fc4b129055ed89","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitXmlAttributeSet(final XmlAttributeSet xmlAttributeSet) {\n    final AntElement element = getAntParent(xmlAttributeSet.getTag());\n    if (element != null) {\n      element.clearCaches();\n    }\n  }","id":99654,"modified_method":"public void visitXmlAttributeSet(final XmlAttributeSet xmlAttributeSet) {\n    clearParentCaches(xmlAttributeSet.getTag());\n  }","commit_id":"e036fb7b717a429d2380f8ca01fc4b129055ed89","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static AntElement getAntParent(final XmlElement el) {\n    final TextRange textRange = el.getTextRange();\n    final AntFile antFile = (AntFile)el.getContainingFile().getViewProvider().getPsi(AntSupport.getLanguage());\n    if (antFile == null) return null;\n    AntElement antElement = (AntElement)antFile.findElementAt(textRange.getStartOffset());\n    while (!(antElement instanceof AntFile) &&\n           (antElement.getTextLength() < textRange.getLength() || antElement instanceof AntOuterProjectElement)) {\n      antElement = antElement.getAntParent();\n    }\n    return antElement;\n  }","id":99655,"modified_method":"@Nullable\n  private static void clearParentCaches(final XmlElement el) {\n    final TextRange textRange = el.getTextRange();\n    final AntFile antFile =\n      (AntFile)el.getContainingFile().getViewProvider().getPsi(AntSupport.getLanguage());\n    if (antFile == null) return;\n    AntElement antElement = (AntElement)antFile.findElementAt(textRange.getStartOffset());\n    while (!(antElement instanceof AntFile) && (antElement.getTextLength() < textRange.getLength() ||\n                                                antElement instanceof AntOuterProjectElement)) {\n      antElement = antElement.getAntParent();\n    }\n    antElement.clearCaches();\n    AntMacroDef macrodef = PsiTreeUtil.getParentOfType(antElement, AntMacroDef.class);\n    if (macrodef != null) {\n      macrodef.clearCaches();\n    }\n  }","commit_id":"e036fb7b717a429d2380f8ca01fc4b129055ed89","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitXmlTextChanged(final XmlTextChanged xmlTextChanged) {\n    final AntElement element = getAntParent(xmlTextChanged.getText());\n    if (element != null) {\n      element.clearCaches();\n    }\n  }","id":99656,"modified_method":"public void visitXmlTextChanged(final XmlTextChanged xmlTextChanged) {\n    clearParentCaches(xmlTextChanged.getText());\n  }","commit_id":"e036fb7b717a429d2380f8ca01fc4b129055ed89","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitXmlTagChildChanged(final XmlTagChildChanged xmlTagChildChanged) {\n    final AntElement element = getAntParent(xmlTagChildChanged.getTag());\n    if (element != null) {\n      element.clearCaches();\n    }\n  }","id":99657,"modified_method":"public void visitXmlTagChildChanged(final XmlTagChildChanged xmlTagChildChanged) {\n    clearParentCaches(xmlTagChildChanged.getTag());\n  }","commit_id":"e036fb7b717a429d2380f8ca01fc4b129055ed89","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitXmlTagNameChanged(final XmlTagNameChanged xmlTagNameChanged) {\n    final AntElement element = getAntParent(xmlTagNameChanged.getTag());\n    if (element != null) {\n      element.clearCaches();\n    }\n  }","id":99658,"modified_method":"public void visitXmlTagNameChanged(final XmlTagNameChanged xmlTagNameChanged) {\n    clearParentCaches(xmlTagNameChanged.getTag());\n  }","commit_id":"e036fb7b717a429d2380f8ca01fc4b129055ed89","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitXmlTagChildAdd(final XmlTagChildAdd xmlTagChildAdd) {\n    final AntElement element = getAntParent(xmlTagChildAdd.getTag());\n    if (element != null) {\n      element.clearCaches();\n    }\n  }","id":99659,"modified_method":"public void visitXmlTagChildAdd(final XmlTagChildAdd xmlTagChildAdd) {\n    clearParentCaches(xmlTagChildAdd.getTag());\n  }","commit_id":"e036fb7b717a429d2380f8ca01fc4b129055ed89","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void instantiate() {\n    if (ourAntTypeToKnownAntElementCreatorMap == null) {\n      ourAntTypeToKnownAntElementCreatorMap = new HashMap<String, AntElementCreator>();\n      final AntElementCreator targetCreator = new AntElementCreator() {\n        public AntElement create(final AntElement parent, final XmlTag tag) {\n          return new AntTargetImpl(parent, tag);\n        }\n      };\n      ourAntTypeToKnownAntElementCreatorMap.put(Target.class.getName(), targetCreator);\n      ourAntTypeToKnownAntElementCreatorMap.put(Ant.TargetElement.class.getName(), targetCreator);\n      ourAntTypeToKnownAntElementCreatorMap.put(Property.class.getName(), new AntElementCreator() {\n        public AntElement create(final AntElement parent, final XmlTag tag) {\n          return new AntPropertyImpl(parent, tag,\n                                     parent.getAntFile().getBaseTypeDefinition(Property.class.getName()));\n        }\n      });\n      ourAntTypeToKnownAntElementCreatorMap.put(CallTarget.class.getName(), new AntElementCreator() {\n        public AntElement create(final AntElement parent, final XmlTag tag) {\n          return new AntCallImpl(parent, tag,\n                                 parent.getAntFile().getBaseTypeDefinition(CallTarget.class.getName()));\n        }\n      });\n      ourAntTypeToKnownAntElementCreatorMap.put(Taskdef.class.getName(), new AntElementCreator() {\n        public AntElement create(final AntElement parent, final XmlTag tag) {\n          return new AntTypeDefImpl(parent, tag,\n                                    parent.getAntFile().getBaseTypeDefinition(Taskdef.class.getName()));\n        }\n      });\n      ourAntTypeToKnownAntElementCreatorMap.put(Typedef.class.getName(), new AntElementCreator() {\n        public AntElement create(final AntElement parent, final XmlTag tag) {\n          return new AntTypeDefImpl(parent, tag,\n                                    parent.getAntFile().getBaseTypeDefinition(Typedef.class.getName()));\n        }\n      });\n      ourAntTypeToKnownAntElementCreatorMap.put(MacroDef.class.getName(), new AntElementCreator() {\n        public AntElement create(final AntElement parent, final XmlTag tag) {\n          return new AntMacroDefImpl(parent, tag,\n                                     parent.getAntFile().getBaseTypeDefinition(MacroDef.class.getName()));\n        }\n      });\n    }\n  }","id":99660,"modified_method":"private static void instantiate() {\n    if (ourAntTypeToKnownAntElementCreatorMap == null) {\n      ourAntTypeToKnownAntElementCreatorMap = new HashMap<String, AntElementCreator>();\n      final AntElementCreator targetCreator = new AntElementCreator() {\n        public AntElement create(final AntElement parent, final XmlTag tag) {\n          return new AntTargetImpl(parent, tag);\n        }\n      };\n      ourAntTypeToKnownAntElementCreatorMap.put(Target.class.getName(), targetCreator);\n      ourAntTypeToKnownAntElementCreatorMap.put(Ant.TargetElement.class.getName(), targetCreator);\n      ourAntTypeToKnownAntElementCreatorMap.put(Property.class.getName(), new AntElementCreator() {\n        public AntElement create(final AntElement parent, final XmlTag tag) {\n          return new AntPropertyImpl(parent, tag,\n                                     parent.getAntFile().getBaseTypeDefinition(Property.class.getName()));\n        }\n      });\n      ourAntTypeToKnownAntElementCreatorMap.put(CallTarget.class.getName(), new AntElementCreator() {\n        public AntElement create(final AntElement parent, final XmlTag tag) {\n          return new AntCallImpl(parent, tag,\n                                 parent.getAntFile().getBaseTypeDefinition(CallTarget.class.getName()));\n        }\n      });\n      ourAntTypeToKnownAntElementCreatorMap.put(Taskdef.class.getName(), new AntElementCreator() {\n        public AntElement create(final AntElement parent, final XmlTag tag) {\n          return new AntTypeDefImpl(parent, tag,\n                                    parent.getAntFile().getBaseTypeDefinition(Taskdef.class.getName()));\n        }\n      });\n      ourAntTypeToKnownAntElementCreatorMap.put(Typedef.class.getName(), new AntElementCreator() {\n        public AntElement create(final AntElement parent, final XmlTag tag) {\n          return new AntTypeDefImpl(parent, tag,\n                                    parent.getAntFile().getBaseTypeDefinition(Typedef.class.getName()));\n        }\n      });\n      ourAntTypeToKnownAntElementCreatorMap.put(MacroDef.class.getName(), new AntElementCreator() {\n        public AntElement create(final AntElement parent, final XmlTag tag) {\n          return new AntMacroDefImpl(parent, tag,\n                                     parent.getAntFile().getBaseTypeDefinition(MacroDef.class.getName()));\n        }\n      });\n      ourAntTypeToKnownAntElementCreatorMap\n        .put(MacroDef.NestedSequential.class.getName(), new AntElementCreator() {\n          public AntElement create(final AntElement parent, final XmlTag tag) {\n            return new AntAllTasksContainerImpl(parent, tag, parent.getAntFile().getBaseTypeDefinition(\n              MacroDef.NestedSequential.class.getName()));\n          }\n        });\n      ourAntTypeToKnownAntElementCreatorMap.put(Sequential.class.getName(), new AntElementCreator() {\n        public AntElement create(final AntElement parent, final XmlTag tag) {\n          return new AntAllTasksContainerImpl(parent, tag, parent.getAntFile().getBaseTypeDefinition(\n            Sequential.class.getName()));\n        }\n      });\n      ourAntTypeToKnownAntElementCreatorMap.put(Parallel.class.getName(), new AntElementCreator() {\n        public AntElement create(final AntElement parent, final XmlTag tag) {\n          return new AntAllTasksContainerImpl(parent, tag, parent.getAntFile().getBaseTypeDefinition(\n            Parallel.class.getName()));\n        }\n      });\n    }\n  }","commit_id":"e036fb7b717a429d2380f8ca01fc4b129055ed89","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement handleElementRename(String newElementName) throws IncorrectOperationException {\n    final AntStructuredElement element = getElement();\n    if (!(element instanceof AntTask)) {\n      final AntTypeDefinition typeDef = element.getTypeDefinition();\n      if (typeDef != null) {\n        final AntStructuredElement definingElement = (AntStructuredElement)typeDef.getDefiningElement();\n        if (definingElement != null && definingElement.getParent()instanceof AntMacroDef &&\n            \"element\".equals(definingElement.getSourceElement().getName())) {\n          // renaming macrodef's nested element\n          element.getSourceElement().setName(newElementName);\n        }\n      }\n    }\n    else {\n      AntTask task = (AntTask)element;\n      if (task.isMacroDefined()) {\n        final XmlAttribute attr = getAttribute();\n        if (attr == null) {\n          // renaming macrodef itself\n          task.getSourceElement().setName(newElementName);\n        }\n        else {\n          // renaming macrodef's attribute\n          attr.setName(newElementName);\n        }\n      }\n    }\n    return element;\n  }","id":99661,"modified_method":"public PsiElement handleElementRename(String newElementName) throws IncorrectOperationException {\n    final AntStructuredElement element = getElement();\n    final AntTypeDefinition typeDef = element.getTypeDefinition();\n    if (typeDef == null) return element;\n\n    if (!(element instanceof AntTask)) {\n      final AntStructuredElement definingElement = (AntStructuredElement)typeDef.getDefiningElement();\n      if (definingElement != null && definingElement.getParent()instanceof AntMacroDef &&\n          \"element\".equals(definingElement.getSourceElement().getName())) {\n        // renaming macrodef's nested element\n        element.getSourceElement().setName(newElementName);\n      }\n    }\n    else {\n      AntTask task = (AntTask)element;\n      if (task.isMacroDefined()) {\n        final XmlAttribute attr = getAttribute();\n        if (attr == null) {\n          // renaming macrodef itself\n          task.getSourceElement().setName(newElementName);\n        }\n        else {\n          attr.setName(newElementName);\n        }\n      }\n    }\n    element.subtreeChanged();\n    return element;\n  }","commit_id":"e036fb7b717a429d2380f8ca01fc4b129055ed89","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement resolve() {\n    final AntStructuredElement element = getElement();\n    final AntTypeDefinition elementDef = element.getTypeDefinition();\n    if (elementDef != null) {\n      if (!(element instanceof AntTask)) {\n        final PsiElement nestedMacroElement = elementDef.getDefiningElement();\n        return (nestedMacroElement == null) ? findClass(elementDef, element) : nestedMacroElement;\n      }\n      AntTask task = (AntTask)element;\n      if (task.isMacroDefined()) {\n        final PsiElement macrodef = elementDef.getDefiningElement();\n        final XmlAttribute attr = getAttribute();\n        if (attr != null) {\n          for (PsiElement child : macrodef.getChildren()) {\n            if (child instanceof AntStructuredElement &&\n                attr.getName().equals(((AntStructuredElement)child).getName())) {\n              return child;\n            }\n          }\n        }\n        return macrodef;\n      }\n      return findClass(elementDef, element);\n    }\n    return null;\n  }","id":99662,"modified_method":"public PsiElement resolve() {\n    if (myResolvedElement != null) return myResolvedElement;\n    final AntStructuredElement element = getElement();\n    final AntTypeDefinition elementDef = element.getTypeDefinition();\n    if (elementDef != null) {\n      if (!(element instanceof AntTask)) {\n        final PsiElement nestedMacroElement = elementDef.getDefiningElement();\n        return myResolvedElement =\n          (nestedMacroElement == null) ? findClass(elementDef, element) : nestedMacroElement;\n      }\n      AntTask task = (AntTask)element;\n      if (task.isMacroDefined()) {\n        final PsiElement macrodef = elementDef.getDefiningElement();\n        final XmlAttribute attr = getAttribute();\n        if (attr != null) {\n          for (PsiElement child : macrodef.getChildren()) {\n            if (child instanceof AntStructuredElement &&\n                attr.getName().equals(((AntStructuredElement)child).getName())) {\n              return myResolvedElement = child;\n            }\n          }\n        }\n        return myResolvedElement = macrodef;\n      }\n      return myResolvedElement = findClass(elementDef, element);\n    }\n    return null;\n  }","commit_id":"e036fb7b717a429d2380f8ca01fc4b129055ed89","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public AntTypeDefinition getBaseTypeDefinition(final String className) {\n    if (myTypeDefinitions != null) return myTypeDefinitions.get(className);\n    myTypeDefinitions = new HashMap<String, AntTypeDefinition>();\n    myAntProject = new Project();\n    myAntProject.init();\n\n    // first, create task definitons\n    updateTypeDefinitions(myAntProject.getTaskDefinitions(), true);\n    // second, create definitions of data types\n    updateTypeDefinitions(myAntProject.getDataTypeDefinitions(), false);\n\n    // sequential and parallel can have all tasks as nested elements\n    final AntTypeDefinition sequentialDef = myTypeDefinitions.get(Sequential.class.getName());\n    if (sequentialDef != null) {\n      setNestedElementsAsAllTasks(sequentialDef);\n    }\n    final AntTypeDefinition parallelDef = myTypeDefinitions.get(Parallel.class.getName());\n    if (parallelDef != null) {\n      setNestedElementsAsAllTasks(parallelDef);\n    }\n    return myTypeDefinitions.get(className);\n  }","id":99663,"modified_method":"@Nullable\n  public AntTypeDefinition getBaseTypeDefinition(final String className) {\n    if (myTypeDefinitions != null) return myTypeDefinitions.get(className);\n    myTypeDefinitions = new HashMap<String, AntTypeDefinition>();\n    myAntProject = new Project();\n    myAntProject.init();\n\n    // first, create task definitons\n    updateTypeDefinitions(myAntProject.getTaskDefinitions(), true);\n    // second, create definitions of data types\n    updateTypeDefinitions(myAntProject.getDataTypeDefinitions(), false);\n\n    return myTypeDefinitions.get(className);\n  }","commit_id":"e036fb7b717a429d2380f8ca01fc4b129055ed89","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * @throws Exception If failed.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public void testGeoMultithreaded() throws Exception {\n        final IgniteCache<Integer, EnemyCamp> cache1 = grid(0).cache(null);\n        final IgniteCache<Integer, EnemyCamp> cache2 = grid(1).cache(null);\n        final IgniteCache<Integer, EnemyCamp> cache3 = grid(2).cache(null);\n\n        final String[] points = new String[CNT];\n\n        WKTReader r = new WKTReader();\n\n        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n\n        for (int idx = 0; idx < CNT; idx++) {\n            int x = rnd.nextInt(1, 100);\n            int y = rnd.nextInt(1, 100);\n\n            cache1.put(idx, new EnemyCamp(r.read(\"POINT(\" + x + \" \" + y + \")\"), Integer.toString(idx)));\n\n            points[idx] = Integer.toString(idx);\n        }\n\n        Thread.sleep(200);\n\n        final AtomicBoolean stop = new AtomicBoolean();\n        final AtomicReference<Exception> err = new AtomicReference<>();\n\n        IgniteInternalFuture<?> putFut = GridTestUtils.runMultiThreadedAsync(new Callable<Void>() {\n            @Override public Void call() throws Exception {\n                WKTReader r = new WKTReader();\n\n                ThreadLocalRandom rnd = ThreadLocalRandom.current();\n\n                while (!stop.get()) {\n                    int cacheIdx = rnd.nextInt(0, 3);\n\n                    IgniteCache<Integer, EnemyCamp> cache = cacheIdx == 0 ? cache1 : cacheIdx == 1 ? cache2 : cache3;\n\n                    int idx = rnd.nextInt(CNT);\n                    int x = rnd.nextInt(1, 100);\n                    int y = rnd.nextInt(1, 100);\n\n                    cache.put(idx, new EnemyCamp(r.read(\"POINT(\" + x + \" \" + y + \")\"), Integer.toString(idx)));\n\n                    U.sleep(50);\n                }\n\n                return null;\n            }\n        }, Runtime.getRuntime().availableProcessors(), \"put-thread\");\n\n        IgniteInternalFuture<?> qryFut = GridTestUtils.runMultiThreadedAsync(new Callable<Void>() {\n            @Override public Void call() throws Exception {\n                WKTReader r = new WKTReader();\n\n                ThreadLocalRandom rnd = ThreadLocalRandom.current();\n\n                while (!stop.get()) {\n                    try {\n                        int cacheIdx = rnd.nextInt(0, 3);\n\n                        IgniteCache<Integer, EnemyCamp> cache = cacheIdx == 0 ? cache1 : cacheIdx == 1 ? cache2 : cache3;\n\n                        SqlQuery<Integer, EnemyCamp> qry = new SqlQuery<>(EnemyCamp.class, \"coords && ?\");\n\n                        Collection<Cache.Entry<Integer, EnemyCamp>> res = cache.query(qry.setArgs(\n                            r.read(\"POLYGON((0 0, 0 100, 100 100, 100 0, 0 0))\"))).getAll();\n\n                        checkPoints(res, points);\n\n                        U.sleep(5);\n                    }\n                    catch (Exception e) {\n                        err.set(e);\n\n                        stop.set(true);\n\n                        break;\n                    }\n                }\n\n                return null;\n            }\n        }, 4, \"qry-thread\");\n\n        U.sleep(60000L);\n\n        stop.set(true);\n\n        putFut.get();\n        qryFut.get();\n\n        Exception err0 = err.get();\n\n        if (err0 != null)\n            throw err0;\n    }","id":99664,"modified_method":"/**\n     * @throws Exception If failed.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public void testGeoMultithreaded() throws Exception {\n        final GridCacheAdapter<Integer, EnemyCamp> cache1 = ((IgniteKernal)grid(0)).internalCache(null);\n        final GridCacheAdapter<Integer, EnemyCamp> cache2 = ((IgniteKernal)grid(1)).internalCache(null);\n        final GridCacheAdapter<Integer, EnemyCamp> cache3 = ((IgniteKernal)grid(2)).internalCache(null);\n\n        final String[] points = new String[CNT];\n\n        WKTReader r = new WKTReader();\n\n        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n\n        for (int idx = 0; idx < CNT; idx++) {\n            int x = rnd.nextInt(1, 100);\n            int y = rnd.nextInt(1, 100);\n\n            cache1.put(idx, new EnemyCamp(r.read(\"POINT(\" + x + \" \" + y + \")\"), Integer.toString(idx)));\n\n            points[idx] = Integer.toString(idx);\n        }\n\n        Thread.sleep(200);\n\n        final AtomicBoolean stop = new AtomicBoolean();\n        final AtomicReference<Exception> err = new AtomicReference<>();\n\n        IgniteInternalFuture<?> putFut = GridTestUtils.runMultiThreadedAsync(new Callable<Void>() {\n            @Override public Void call() throws Exception {\n                WKTReader r = new WKTReader();\n\n                ThreadLocalRandom rnd = ThreadLocalRandom.current();\n\n                while (!stop.get()) {\n                    int cacheIdx = rnd.nextInt(0, 3);\n\n                    GridCache<Integer, EnemyCamp> cache = cacheIdx == 0 ? cache1 : cacheIdx == 1 ? cache2 : cache3;\n\n                    int idx = rnd.nextInt(CNT);\n                    int x = rnd.nextInt(1, 100);\n                    int y = rnd.nextInt(1, 100);\n\n                    cache.put(idx, new EnemyCamp(r.read(\"POINT(\" + x + \" \" + y + \")\"), Integer.toString(idx)));\n\n                    U.sleep(50);\n                }\n\n                return null;\n            }\n        }, Runtime.getRuntime().availableProcessors(), \"put-thread\");\n\n        IgniteInternalFuture<?> qryFut = GridTestUtils.runMultiThreadedAsync(new Callable<Void>() {\n            @Override public Void call() throws Exception {\n                WKTReader r = new WKTReader();\n\n                ThreadLocalRandom rnd = ThreadLocalRandom.current();\n\n                while (!stop.get()) {\n                    try {\n                        int cacheIdx = rnd.nextInt(0, 3);\n\n                        GridCache<Integer, EnemyCamp> cache = cacheIdx == 0 ? cache1 : cacheIdx == 1 ? cache2 : cache3;\n\n                        CacheQuery<Map.Entry<Integer, EnemyCamp>> qry = cache.queries().createSqlQuery(\n                            EnemyCamp.class, \"coords && ?\");\n\n                        Collection<Map.Entry<Integer, EnemyCamp>> res = qry.execute(\n                            r.read(\"POLYGON((0 0, 0 100, 100 100, 100 0, 0 0))\")).get();\n\n                        checkPoints(res, points);\n\n                        U.sleep(5);\n                    }\n                    catch (Exception e) {\n                        err.set(e);\n\n                        stop.set(true);\n\n                        break;\n                    }\n                }\n\n                return null;\n            }\n        }, 4, \"qry-thread\");\n\n        U.sleep(60000L);\n\n        stop.set(true);\n\n        putFut.get();\n        qryFut.get();\n\n        Exception err0 = err.get();\n\n        if (err0 != null)\n            throw err0;\n    }","commit_id":"d4400c48db4a7b9fc348ebe874a89a026009cdce","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Check whether result contains all required points.\n     *\n     * @param res Result.\n     * @param points Expected points.\n     */\n    private void checkPoints( Collection<Cache.Entry<Integer, EnemyCamp>> res, String... points) {\n        Set<String> set = new HashSet<>(Arrays.asList(points));\n\n        assertEquals(set.size(), res.size());\n\n        for (Cache.Entry<Integer, EnemyCamp> e : res)\n            assertTrue(set.remove(e.getValue().name));\n    }","id":99665,"modified_method":"/**\n     * Check whether result contains all required points.\n     *\n     * @param res Result.\n     * @param points Expected points.\n     */\n    private void checkPoints( Collection<Map.Entry<Integer, EnemyCamp>> res, String... points) {\n        Set<String> set = new HashSet<>(Arrays.asList(points));\n\n        assertEquals(set.size(), res.size());\n\n        for (Map.Entry<Integer, EnemyCamp> e : res)\n            assertTrue(set.remove(e.getValue().name));\n    }","commit_id":"d4400c48db4a7b9fc348ebe874a89a026009cdce","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @throws Exception If failed.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public void testGeo() throws Exception {\n        IgniteCache<Integer, EnemyCamp> cache = grid(0).cache(null);\n\n        WKTReader r = new WKTReader();\n\n        cache.put(0, new EnemyCamp(r.read(\"POINT(25 75)\"), \"A\"));\n        cache.put(1, new EnemyCamp(r.read(\"POINT(70 70)\"), \"B\"));\n        cache.put(2, new EnemyCamp(r.read(\"POINT(70 30)\"), \"C\"));\n        cache.put(3, new EnemyCamp(r.read(\"POINT(75 25)\"), \"D\"));\n\n        SqlQuery<Integer, EnemyCamp> query = new SqlQuery(EnemyCamp.class, \"coords && ?\");\n\n        Geometry geom = r.read(\"POLYGON((5 70, 5 80, 30 80, 30 70, 5 70))\");\n\n        query.setArgs(geom);\n\n        QueryCursor<Cache.Entry<Integer, EnemyCamp>> cursor = cache.query(query);\n\n        Collection<Cache.Entry<Integer, EnemyCamp>> res = cursor.getAll();\n\n        checkPoints(res, \"A\");\n\n        res = cache.query(\n            query.setArgs(r.read(\"POLYGON((10 5, 10 35, 70 30, 75 25, 10 5))\"))).getAll();\n\n        checkPoints(res, \"C\", \"D\");\n\n        // Move B to the first polygon.\n        cache.put(1, new EnemyCamp(r.read(\"POINT(20 75)\"), \"B\"));\n\n        res = cache.query(\n            query.setArgs(r.read(\"POLYGON((5 70, 5 80, 30 80, 30 70, 5 70))\"))).getAll();\n\n        checkPoints(res, \"A\", \"B\");\n\n        // Move B to the second polygon.\n        cache.put(1, new EnemyCamp(r.read(\"POINT(30 30)\"), \"B\"));\n\n        res = cache.query(\n            query.setArgs(r.read(\"POLYGON((10 5, 10 35, 70 30, 75 25, 10 5))\"))).getAll();\n\n        checkPoints(res, \"B\", \"C\", \"D\");\n\n        // Remove B.\n        cache.remove(1);\n\n        res = cache.query(\n            query.setArgs(r.read(\"POLYGON((5 70, 5 80, 30 80, 30 70, 5 70))\"))).getAll();\n\n        checkPoints(res, \"A\");\n\n        res = cache.query(\n            query.setArgs(r.read(\"POLYGON((10 5, 10 35, 70 30, 75 25, 10 5))\"))).getAll();\n\n        checkPoints(res, \"C\", \"D\");\n\n        // Check explaint request.\n        assertTrue(F.first(cache.query(new SqlFieldsQuery(\"explain select * from EnemyCamp \" +\n            \"where coords && 'POINT(25 75)'\")).getAll()).get(0).toString().contains(\"coords_idx\"));\n    }","id":99666,"modified_method":"/**\n     * @throws Exception If failed.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public void testGeo() throws Exception {\n        GridCacheAdapter<Integer, EnemyCamp> cache = ((IgniteKernal)grid(0)).internalCache(null);\n\n        WKTReader r = new WKTReader();\n\n        cache.put(0, new EnemyCamp(r.read(\"POINT(25 75)\"), \"A\"));\n        cache.put(1, new EnemyCamp(r.read(\"POINT(70 70)\"), \"B\"));\n        cache.put(2, new EnemyCamp(r.read(\"POINT(70 30)\"), \"C\"));\n        cache.put(3, new EnemyCamp(r.read(\"POINT(75 25)\"), \"D\"));\n\n        CacheQuery<Map.Entry<Integer, EnemyCamp>> qry = cache.queries().createSqlQuery(EnemyCamp.class,\n            \"coords && ?\");\n\n        Collection<Map.Entry<Integer, EnemyCamp>> res = qry.execute(r.read(\"POLYGON((5 70, 5 80, 30 80, 30 70, 5 70))\"))\n            .get();\n\n        checkPoints(res, \"A\");\n\n        res = qry.execute(r.read(\"POLYGON((10 5, 10 35, 70 30, 75 25, 10 5))\")).get();\n\n        checkPoints(res, \"C\", \"D\");\n\n        // Move B to the first polygon.\n        cache.put(1, new EnemyCamp(r.read(\"POINT(20 75)\"), \"B\"));\n\n        res = qry.execute(r.read(\"POLYGON((5 70, 5 80, 30 80, 30 70, 5 70))\")).get();\n\n        checkPoints(res, \"A\", \"B\");\n\n        // Move B to the second polygon.\n        cache.put(1, new EnemyCamp(r.read(\"POINT(30 30)\"), \"B\"));\n\n        res = qry.execute(r.read(\"POLYGON((10 5, 10 35, 70 30, 75 25, 10 5))\")).get();\n\n        checkPoints(res, \"B\", \"C\", \"D\");\n\n        // Remove B.\n        cache.remove(1, CU.empty0());\n\n        res = qry.execute(r.read(\"POLYGON((5 70, 5 80, 30 80, 30 70, 5 70))\")).get();\n\n        checkPoints(res, \"A\");\n\n        res = qry.execute(r.read(\"POLYGON((10 5, 10 35, 70 30, 75 25, 10 5))\")).get();\n\n        checkPoints(res, \"C\", \"D\");\n\n        // Check explaint request.\n        assertTrue(F.first(cache.queries().createSqlFieldsQuery(\"explain select * from EnemyCamp \" +\n            \"where coords && 'POINT(25 75)'\").execute().get()).get(0).toString().contains(\"coords_idx\"));\n    }","commit_id":"d4400c48db4a7b9fc348ebe874a89a026009cdce","url":"https://github.com/apache/ignite"},{"original_method":"protected void invokeAction(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows IOException, PortletException {\n\n\t\tLiferayPortletRequest portletRequest =\n\t\t\t(LiferayPortletRequest)actionRequest;\n\t\tLiferayPortletResponse portletResponse =\n\t\t\t(LiferayPortletResponse)actionResponse;\n\n\t\tList<ActionFilter> actionFilters =\n\t\t\t_actionFiltersMap.get(_getPortletId(portletResponse));\n\n\t\tinvoke(\n\t\t\tportletRequest, portletResponse, PortletRequest.ACTION_PHASE,\n\t\t\tactionFilters);\n\t}","id":99667,"modified_method":"protected void invokeAction(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows IOException, PortletException {\n\n\t\tLiferayPortletRequest portletRequest =\n\t\t\t(LiferayPortletRequest)actionRequest;\n\t\tLiferayPortletResponse portletResponse =\n\t\t\t(LiferayPortletResponse)actionResponse;\n\n\t\tString portletId = _getPortletId(portletResponse);\n\n\t\tList<ActionFilter> actionFilters = _actionFiltersMap.get(portletId);\n\n\t\tinvoke(\n\t\t\tportletRequest, portletResponse, PortletRequest.ACTION_PHASE,\n\t\t\tactionFilters);\n\t}","commit_id":"80077a01db2ce9f62091ce6d359a682980d758ce","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void prepare(\n\t\t\tcom.liferay.portal.model.Portlet portletModel, Portlet portlet,\n\t\t\tPortletConfig portletConfig, PortletContext portletContext,\n\t\t\tboolean facesPortlet, boolean strutsPortlet,\n\t\t\tboolean strutsBridgePortlet)\n\t\tthrows PortletException {\n\n \t\t// From prepare\n\n\t\t_portletModel = portletModel;\n\t\t_portlet = portlet;\n\t\t_portletContextImpl = (PortletContextImpl)portletContext;\n\t\t_facesPortlet = facesPortlet;\n\t\t_strutsPortlet = strutsPortlet;\n\t\t_strutsBridgePortlet = strutsBridgePortlet;\n\t\t_expCache = portletModel.getExpCache();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Create instance cache wrapper for \" +\n\t\t\t\t\t_portletContextImpl.getPortlet().getPortletId());\n\t\t}\n\n\t\t// From init\n\n\t\t_portletConfigImpl = (PortletConfigImpl)portletConfig;\n\n\t\t_portletId = _portletConfigImpl.getPortletId();\n\t\tsetPortletFilters();\n\t}","id":99668,"modified_method":"public void prepare(\n\t\t\tcom.liferay.portal.model.Portlet portletModel, Portlet portlet,\n\t\t\tPortletConfig portletConfig, PortletContext portletContext,\n\t\t\tboolean facesPortlet, boolean strutsPortlet,\n\t\t\tboolean strutsBridgePortlet)\n\t\tthrows PortletException {\n\n \t\t// From prepare\n\n\t\t_portletModel = portletModel;\n\t\t_portlet = portlet;\n\t\t_portletId = _portletModel.getPortletId();\n\t\t_portletContextImpl = (PortletContextImpl)portletContext;\n\t\t_facesPortlet = facesPortlet;\n\t\t_strutsPortlet = strutsPortlet;\n\t\t_strutsBridgePortlet = strutsBridgePortlet;\n\t\t_expCache = portletModel.getExpCache();\n\t\tsetPortletFilters();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Create instance cache wrapper for \" +\n\t\t\t\t\t_portletContextImpl.getPortlet().getPortletId());\n\t\t}\n\n\t\t// From init\n\n\t\t_portletConfigImpl = (PortletConfigImpl)portletConfig;\n\t}","commit_id":"772889f894e6dfffc2e3cbb47cecea203fca2cce","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private String _getPortletId(LiferayPortletResponse portletResponse) {\n\t\tString portletId =\n\t\t\t((PortletResponseImpl)portletResponse).getPortlet().getPortletId();\n\n\t\treturn portletId;\n\t}","id":99669,"modified_method":"private String _getPortletId(LiferayPortletResponse portletResponse) {\n\t\tPortletResponseImpl portletResponseImpl =\n\t\t\t(PortletResponseImpl)portletResponse;\n\n\t\tcom.liferay.portal.model.Portlet portlet =\n\t\t\tportletResponseImpl.getPortlet();\n\n\t\treturn portlet.getPortletId();\n\t}","commit_id":"772889f894e6dfffc2e3cbb47cecea203fca2cce","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void prepare(\n\t\t\tcom.liferay.portal.model.Portlet portletModel, Portlet portlet,\n\t\t\tPortletContext portletContext)\n\t\tthrows PortletException {\n\n\t\t_portletModel = portletModel;\n\t\t_portlet = portlet;\n\t\t_portletContextImpl = (PortletContextImpl)portletContext;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Create root cache wrapper for \" +\n\t\t\t\t\t_portletContextImpl.getPortlet().getPortletId());\n\t\t}\n\n\t\tif (portletModel.isRemote()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (ClassUtil.isSubclass(\n\t\t\t\t_portlet.getClass(), PortletDeployer.JSF_MYFACES) ||\n\t\t\tClassUtil.isSubclass(\n\t\t\t\t_portlet.getClass(), PortletDeployer.JSF_SUN)) {\n\n\t\t\t_facesPortlet = true;\n\t\t}\n\n\t\t_strutsPortlet = ClassUtil.isSubclass(\n\t\t\tportlet.getClass(), StrutsPortlet.class);\n\t\t_strutsBridgePortlet = ClassUtil.isSubclass(\n\t\t\tportlet.getClass(),\n\t\t\t\"org.apache.portals.bridges.struts.StrutsPortlet\");\n\t\t_expCache = portletModel.getExpCache();\n\t\t_portletId = _portletModel.getPortletId();\n\t\tsetPortletFilters();\n\t}","id":99670,"modified_method":"public void prepare(\n\t\t\tcom.liferay.portal.model.Portlet portletModel, Portlet portlet,\n\t\t\tPortletContext portletContext)\n\t\tthrows PortletException {\n\n\t\t_portletModel = portletModel;\n\t\t_portletId = _portletModel.getPortletId();\n\t\t_portlet = portlet;\n\t\t_portletContextImpl = (PortletContextImpl)portletContext;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Create root cache wrapper for \" +\n\t\t\t\t\t_portletContextImpl.getPortlet().getPortletId());\n\t\t}\n\n\t\tif (portletModel.isRemote()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (ClassUtil.isSubclass(\n\t\t\t\t_portlet.getClass(), PortletDeployer.JSF_MYFACES) ||\n\t\t\tClassUtil.isSubclass(\n\t\t\t\t_portlet.getClass(), PortletDeployer.JSF_SUN)) {\n\n\t\t\t_facesPortlet = true;\n\t\t}\n\n\t\t_strutsPortlet = ClassUtil.isSubclass(\n\t\t\tportlet.getClass(), StrutsPortlet.class);\n\t\t_strutsBridgePortlet = ClassUtil.isSubclass(\n\t\t\tportlet.getClass(),\n\t\t\t\"org.apache.portals.bridges.struts.StrutsPortlet\");\n\t\t_expCache = portletModel.getExpCache();\n\t\tsetPortletFilters();\n\t}","commit_id":"772889f894e6dfffc2e3cbb47cecea203fca2cce","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void invokeAction(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows IOException, PortletException {\n\n\t\tLiferayPortletRequest portletRequest =\n\t\t\t(LiferayPortletRequest)actionRequest;\n\t\tLiferayPortletResponse portletResponse =\n\t\t\t(LiferayPortletResponse)actionResponse;\n\n\t\tList<ActionFilter> actionFilters =\n\t\t\t_allActionFilters.get(_getPortletId(portletResponse));\n\n\t\tinvoke(\n\t\t\tportletRequest, portletResponse, PortletRequest.ACTION_PHASE,\n\t\t\tactionFilters);\n\t}","id":99671,"modified_method":"protected void invokeAction(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows IOException, PortletException {\n\n\t\tLiferayPortletRequest portletRequest =\n\t\t\t(LiferayPortletRequest)actionRequest;\n\t\tLiferayPortletResponse portletResponse =\n\t\t\t(LiferayPortletResponse)actionResponse;\n\n\t\tList<ActionFilter> actionFilters =\n\t\t\t_actionFiltersMap.get(_getPortletId(portletResponse));\n\n\t\tinvoke(\n\t\t\tportletRequest, portletResponse, PortletRequest.ACTION_PHASE,\n\t\t\tactionFilters);\n\t}","commit_id":"772889f894e6dfffc2e3cbb47cecea203fca2cce","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void init(PortletConfig portletConfig) throws PortletException {\n\t\t_portletConfigImpl = (PortletConfigImpl)portletConfig;\n\n\t\t_portletId = _portletConfigImpl.getPortletId();\n\n\t\tClassLoader contextClassLoader =\n\t\t\tThread.currentThread().getContextClassLoader();\n\n\t\tClassLoader portletClassLoader = getPortletClassLoader();\n\n\t\ttry {\n\t\t\tif (portletClassLoader != null) {\n\t\t\t\tThread.currentThread().setContextClassLoader(\n\t\t\t\t\tportletClassLoader);\n\t\t\t}\n\n\t\t\t_portlet.init(portletConfig);\n\t\t}\n\t\tfinally {\n\t\t\tif (portletClassLoader != null) {\n\t\t\t\tThread.currentThread().setContextClassLoader(\n\t\t\t\t\tcontextClassLoader);\n\t\t\t}\n\t\t}\n\n\t\t_destroyable = true;\n\t}","id":99672,"modified_method":"public void init(PortletConfig portletConfig) throws PortletException {\n\t\t_portletConfigImpl = (PortletConfigImpl)portletConfig;\n\n\t\tClassLoader contextClassLoader =\n\t\t\tThread.currentThread().getContextClassLoader();\n\n\t\tClassLoader portletClassLoader = getPortletClassLoader();\n\n\t\ttry {\n\t\t\tif (portletClassLoader != null) {\n\t\t\t\tThread.currentThread().setContextClassLoader(\n\t\t\t\t\tportletClassLoader);\n\t\t\t}\n\n\t\t\t_portlet.init(portletConfig);\n\t\t}\n\t\tfinally {\n\t\t\tif (portletClassLoader != null) {\n\t\t\t\tThread.currentThread().setContextClassLoader(\n\t\t\t\t\tcontextClassLoader);\n\t\t\t}\n\t\t}\n\n\t\t_destroyable = true;\n\t}","commit_id":"772889f894e6dfffc2e3cbb47cecea203fca2cce","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void setPortletFilters() throws PortletException {\n\t\tremovePortletFilters();\n\n\t\tMap<String, com.liferay.portal.model.PortletFilter> portletFilters =\n\t\t\t_portletModel.getPortletFilters();\n\n\t\tfor (Map.Entry<String, com.liferay.portal.model.PortletFilter> entry :\n\t\t\t\tportletFilters.entrySet()) {\n\n\t\t\tcom.liferay.portal.model.PortletFilter portletFilterModel =\n\t\t\t\tentry.getValue();\n\n\t\t\tPortletFilter portletFilter = PortletFilterFactory.create(\n\t\t\t\tportletFilterModel, _portletContextImpl);\n\n\t\t\tSet<String> lifecycles = portletFilterModel.getLifecycles();\n\n\t\t\tif (lifecycles.contains(PortletRequest.ACTION_PHASE)) {\n\t\t\t\tList<ActionFilter> actionFilters =\n\t\t\t\t\t_allActionFilters.get(_portletId);\n\n\t\t\t\tif (actionFilters == null) {\n\t\t\t\t\tactionFilters = new ArrayList<ActionFilter>();\n\t\t\t\t}\n\n\t\t\t\tactionFilters.add((ActionFilter)portletFilter);\n\t\t\t\t_allActionFilters.put(_portletId, actionFilters);\n\t\t\t}\n\n\t\t\tif (lifecycles.contains(PortletRequest.EVENT_PHASE)) {\n\t\t\t\tList<EventFilter> eventFilters =\n\t\t\t\t\t_allEventFilters.get(_portletId);\n\n\t\t\t\tif (eventFilters == null) {\n\t\t\t\t\teventFilters = new ArrayList<EventFilter>();\n\t\t\t\t}\n\n\t\t\t\teventFilters.add((EventFilter)portletFilter);\n\t\t\t\t_allEventFilters.put(_portletId, eventFilters);\n\t\t\t}\n\n\t\t\tif (lifecycles.contains(PortletRequest.RENDER_PHASE)) {\n\t\t\t\tList<RenderFilter> renderFilters =\n\t\t\t\t\t_allRenderFilters.get(_portletId);\n\n\t\t\t\tif (renderFilters == null) {\n\t\t\t\t\trenderFilters = new ArrayList<RenderFilter>();\n\t\t\t\t}\n\n\t\t\t\trenderFilters.add((RenderFilter)portletFilter);\n\t\t\t\t_allRenderFilters.put(_portletId, renderFilters);\n\t\t\t}\n\n\t\t\tif (lifecycles.contains(PortletRequest.RESOURCE_PHASE)) {\n\t\t\t\tList<ResourceFilter> resourceFilters =\n\t\t\t\t\t_allResourceFilters.get(_portletId);\n\n\t\t\t\tif (resourceFilters == null) {\n\t\t\t\t\tresourceFilters = new ArrayList<ResourceFilter>();\n\t\t\t\t}\n\n\t\t\t\tresourceFilters.add((ResourceFilter)portletFilter);\n\t\t\t\t_allResourceFilters.put(_portletId, resourceFilters);\n\t\t\t}\n\t\t}\n\t}","id":99673,"modified_method":"public void setPortletFilters() throws PortletException {\n\t\tremovePortletFilters();\n\n\t\tMap<String, com.liferay.portal.model.PortletFilter> portletFilters =\n\t\t\t_portletModel.getPortletFilters();\n\n\t\tfor (Map.Entry<String, com.liferay.portal.model.PortletFilter> entry :\n\t\t\t\tportletFilters.entrySet()) {\n\n\t\t\tcom.liferay.portal.model.PortletFilter portletFilterModel =\n\t\t\t\tentry.getValue();\n\n\t\t\tPortletFilter portletFilter = PortletFilterFactory.create(\n\t\t\t\tportletFilterModel, _portletContextImpl);\n\n\t\t\tSet<String> lifecycles = portletFilterModel.getLifecycles();\n\n\t\t\tif (lifecycles.contains(PortletRequest.ACTION_PHASE)) {\n\t\t\t\tList<ActionFilter> actionFilters = _actionFiltersMap.get(\n\t\t\t\t\t_portletId);\n\n\t\t\t\tif (actionFilters == null) {\n\t\t\t\t\tactionFilters = new ArrayList<ActionFilter>();\n\t\t\t\t}\n\n\t\t\t\tactionFilters.add((ActionFilter)portletFilter);\n\n\t\t\t\t_actionFiltersMap.put(_portletId, actionFilters);\n\t\t\t}\n\n\t\t\tif (lifecycles.contains(PortletRequest.EVENT_PHASE)) {\n\t\t\t\tList<EventFilter> eventFilters = _eventFiltersMap.get(\n\t\t\t\t\t_portletId);\n\n\t\t\t\tif (eventFilters == null) {\n\t\t\t\t\teventFilters = new ArrayList<EventFilter>();\n\t\t\t\t}\n\n\t\t\t\teventFilters.add((EventFilter)portletFilter);\n\n\t\t\t\t_eventFiltersMap.put(_portletId, eventFilters);\n\t\t\t}\n\n\t\t\tif (lifecycles.contains(PortletRequest.RENDER_PHASE)) {\n\t\t\t\tList<RenderFilter> renderFilters = _renderFiltersMap.get(\n\t\t\t\t\t_portletId);\n\n\t\t\t\tif (renderFilters == null) {\n\t\t\t\t\trenderFilters = new ArrayList<RenderFilter>();\n\t\t\t\t}\n\n\t\t\t\trenderFilters.add((RenderFilter)portletFilter);\n\n\t\t\t\t_renderFiltersMap.put(_portletId, renderFilters);\n\t\t\t}\n\n\t\t\tif (lifecycles.contains(PortletRequest.RESOURCE_PHASE)) {\n\t\t\t\tList<ResourceFilter> resourceFilters = _resourceFiltersMap.get(\n\t\t\t\t\t_portletId);\n\n\t\t\t\tif (resourceFilters == null) {\n\t\t\t\t\tresourceFilters = new ArrayList<ResourceFilter>();\n\t\t\t\t}\n\n\t\t\t\tresourceFilters.add((ResourceFilter)portletFilter);\n\n\t\t\t\t_resourceFiltersMap.put(_portletId, resourceFilters);\n\t\t\t}\n\t\t}\n\t}","commit_id":"772889f894e6dfffc2e3cbb47cecea203fca2cce","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void invokeEvent(\n\t\t\tEventRequest eventRequest, EventResponse eventResponse)\n\t\tthrows IOException, PortletException {\n\n\t\tLiferayPortletRequest portletRequest =\n\t\t\t(LiferayPortletRequest)eventRequest;\n\t\tLiferayPortletResponse portletResponse =\n\t\t\t(LiferayPortletResponse)eventResponse;\n\n\t\tList<EventFilter> eventFilters =\n\t\t\t_allEventFilters.get(_getPortletId(portletResponse));\n\n\t\tinvoke(\n\t\t\tportletRequest, portletResponse, PortletRequest.EVENT_PHASE,\n\t\t\teventFilters);\n\t}","id":99674,"modified_method":"protected void invokeEvent(\n\t\t\tEventRequest eventRequest, EventResponse eventResponse)\n\t\tthrows IOException, PortletException {\n\n\t\tLiferayPortletRequest portletRequest =\n\t\t\t(LiferayPortletRequest)eventRequest;\n\t\tLiferayPortletResponse portletResponse =\n\t\t\t(LiferayPortletResponse)eventResponse;\n\n\t\tString portletId = _getPortletId(portletResponse);\n\n\t\tList<EventFilter> eventFilters = _eventFiltersMap.get(portletId);\n\n\t\tinvoke(\n\t\t\tportletRequest, portletResponse, PortletRequest.EVENT_PHASE,\n\t\t\teventFilters);\n\t}","commit_id":"772889f894e6dfffc2e3cbb47cecea203fca2cce","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void removePortletFilters() {\n\t\t_allActionFilters.remove(_portletId);\n\t\t_allEventFilters.remove(_portletId);\n\t\t_allRenderFilters.remove(_portletId);\n\t\t_allResourceFilters.remove(_portletId);\n\t}","id":99675,"modified_method":"protected void removePortletFilters() {\n\t\t_actionFiltersMap.remove(_portletId);\n\t\t_eventFiltersMap.remove(_portletId);\n\t\t_renderFiltersMap.remove(_portletId);\n\t\t_resourceFiltersMap.remove(_portletId);\n\t}","commit_id":"772889f894e6dfffc2e3cbb47cecea203fca2cce","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void invokeResource(\n\t\t\tResourceRequest resourceRequest, ResourceResponse resourceResponse)\n\t\tthrows IOException, PortletException {\n\n\t\tLiferayPortletRequest portletRequest =\n\t\t\t(LiferayPortletRequest)resourceRequest;\n\t\tLiferayPortletResponse portletResponse =\n\t\t\t(LiferayPortletResponse)resourceResponse;\n\n\t\tList<ResourceFilter> resourceFilters =\n\t\t\t_allResourceFilters.get(_getPortletId(portletResponse));\n\n\t\tinvoke(\n\t\t\tportletRequest, portletResponse, PortletRequest.RESOURCE_PHASE,\n\t\t\tresourceFilters);\n\t}","id":99676,"modified_method":"protected void invokeResource(\n\t\t\tResourceRequest resourceRequest, ResourceResponse resourceResponse)\n\t\tthrows IOException, PortletException {\n\n\t\tLiferayPortletRequest portletRequest =\n\t\t\t(LiferayPortletRequest)resourceRequest;\n\t\tLiferayPortletResponse portletResponse =\n\t\t\t(LiferayPortletResponse)resourceResponse;\n\n\t\tString portletId = _getPortletId(portletResponse);\n\n\t\tList<ResourceFilter> resourceFilters = _resourceFiltersMap.get(\n\t\t\tportletId);\n\n\t\tinvoke(\n\t\t\tportletRequest, portletResponse, PortletRequest.RESOURCE_PHASE,\n\t\t\tresourceFilters);\n\t}","commit_id":"772889f894e6dfffc2e3cbb47cecea203fca2cce","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String invokeRender(\n\t\t\tRenderRequest renderRequest, RenderResponse renderResponse)\n\t\tthrows IOException, PortletException {\n\n\t\tLiferayPortletRequest portletRequest =\n\t\t\t(LiferayPortletRequest)renderRequest;\n\t\tLiferayPortletResponse portletResponse =\n\t\t\t(LiferayPortletResponse)renderResponse;\n\n\t\tList<RenderFilter> renderFilters =\n\t\t\t_allRenderFilters.get(_getPortletId(portletResponse));\n\n\t\tinvoke(\n\t\t\tportletRequest, portletResponse, PortletRequest.RENDER_PHASE,\n\t\t\trenderFilters);\n\n\t\tRenderResponseImpl renderResponseImpl =\n\t\t\t(RenderResponseImpl)renderResponse;\n\n\t\treturn renderResponseImpl.getTitle();\n\t}","id":99677,"modified_method":"protected String invokeRender(\n\t\t\tRenderRequest renderRequest, RenderResponse renderResponse)\n\t\tthrows IOException, PortletException {\n\n\t\tLiferayPortletRequest portletRequest =\n\t\t\t(LiferayPortletRequest)renderRequest;\n\t\tLiferayPortletResponse portletResponse =\n\t\t\t(LiferayPortletResponse)renderResponse;\n\n\t\tString portletId = _getPortletId(portletResponse);\n\n\t\tList<RenderFilter> renderFilters = _renderFiltersMap.get(portletId);\n\n\t\tinvoke(\n\t\t\tportletRequest, portletResponse, PortletRequest.RENDER_PHASE,\n\t\t\trenderFilters);\n\n\t\tRenderResponseImpl renderResponseImpl =\n\t\t\t(RenderResponseImpl)renderResponse;\n\n\t\treturn renderResponseImpl.getTitle();\n\t}","commit_id":"772889f894e6dfffc2e3cbb47cecea203fca2cce","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n    final DebuggerContextImpl debuggerContext = getDebuggerContext(e.getDataContext());\n\n    if(debuggerContext == null) return;\n\n    final DebuggerSession session = debuggerContext.getDebuggerSession();\n    if(session == null) return;\n    final MainWatchPanel watchPanel = DebuggerPanelsManager.getInstance(debuggerContext.getProject()).getWatchPanel();\n\n    if(watchPanel == null) return;\n\n    final DebuggerTreeNodeImpl[] selectedNodes = getSelectedNodes(e.getDataContext());\n\n    if(selectedNodes != null && selectedNodes.length > 0) {\n      debuggerContext.getDebugProcess().getManagerThread().invokeLater(new DebuggerContextCommandImpl(debuggerContext) {\n        public void threadAction() {\n          for (int idx = 0; idx < selectedNodes.length; idx++) {\n            DebuggerTreeNodeImpl node = selectedNodes[idx];\n            final NodeDescriptorImpl descriptor = node.getDescriptor();\n            final TextWithImports expression = DebuggerTreeNodeExpression.createEvaluationText(node, debuggerContext);\n            if (expression != null) {\n              DebuggerInvocationUtil.invokeLater(session.getProject(), new Runnable() {\n                public void run() {\n                  NodeDescriptorImpl watchDescriptor = watchPanel.getWatchTree().addWatch(expression).getDescriptor();\n                  watchDescriptor.displayAs(descriptor);\n                }\n              });\n            }\n          }\n        }\n\n        protected void commandCancelled() {\n          DebuggerInvocationUtil.invokeLater(debuggerContext.getProject(), new Runnable() {\n            public void run() {\n              for (int idx = 0; idx < selectedNodes.length; idx++) {\n                DebuggerTreeNodeImpl node = selectedNodes[idx];\n                final NodeDescriptorImpl descriptor = node.getDescriptor();\n\n                if(descriptor instanceof WatchItemDescriptor) {\n\n                  final TextWithImports expression = ((WatchItemDescriptor) descriptor).getEvaluationText();\n                  if(expression != null) {\n                    NodeDescriptorImpl watchDescriptor = watchPanel.getWatchTree().addWatch(expression).getDescriptor();\n                    watchDescriptor.displayAs(descriptor);\n                  }\n                }\n              }\n            }\n          });\n        }\n      });\n    } else {\n      final Editor          editor  = (Editor)e.getDataContext().getData(DataConstants.EDITOR);\n\n      TextWithImports editorText = DebuggerUtilsEx.getEditorText(editor);\n\n      if(editorText != null) {\n        watchPanel.getWatchTree().addWatch(editorText);\n      }\n    }\n  }","id":99678,"modified_method":"public void actionPerformed(AnActionEvent e) {\n    final DebuggerContextImpl debuggerContext = getDebuggerContext(e.getDataContext());\n\n    if(debuggerContext == null) return;\n\n    final DebuggerSession session = debuggerContext.getDebuggerSession();\n    if(session == null) {\n      return;\n    }\n    final MainWatchPanel watchPanel = DebuggerPanelsManager.getInstance(debuggerContext.getProject()).getWatchPanel();\n\n    if(watchPanel == null) {\n      return;\n    }\n\n    final DebuggerTreeNodeImpl[] selectedNodes = getSelectedNodes(e.getDataContext());\n\n    if(selectedNodes != null && selectedNodes.length > 0) {\n      debuggerContext.getDebugProcess().getManagerThread().invokeLater(new AddToWatchesCommand(debuggerContext, selectedNodes, watchPanel));\n    }\n    else {\n      final Editor editor  = (Editor)e.getDataContext().getData(DataConstants.EDITOR);\n      final TextWithImports editorText = DebuggerUtilsEx.getEditorText(editor);\n      if(editorText != null) {\n        doAddWatch(watchPanel, editorText, null);\n      }\n    }\n  }","commit_id":"ca2d0610552ea399a503936a7ee0b89f54e60c4e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public RunContentDescriptor attachVirtualMachine(RunProfile runProfile,\n                                                   JavaProgramRunner runner,\n                                                   RunProfileState state,\n                                                   RunContentDescriptor reuseContent,\n                                                   RemoteConnection remoteConnection,\n                                                   boolean pollConnection) throws ExecutionException {\n    DebuggerSession debuggerSession = DebuggerManagerEx.getInstanceEx(myProject).attachVirtualMachine(runProfile.getName(), state, remoteConnection, pollConnection);\n\n    DebuggerSessionTab sessionTab = new DebuggerSessionTab(myProject);\n    RunContentDescriptor runContentDescriptor = sessionTab.attachToSession(\n        debuggerSession,\n        runner,\n        runProfile,\n        state.getRunnerSettings(),\n        state.getConfigurationSettings());\n\n    mySessionTabs.put(runContentDescriptor.getProcessHandler(), sessionTab);\n    return runContentDescriptor;\n  }","id":99679,"modified_method":"public RunContentDescriptor attachVirtualMachine(RunProfile runProfile,\n                                                   JavaProgramRunner runner,\n                                                   RunProfileState state,\n                                                   RunContentDescriptor reuseContent,\n                                                   RemoteConnection remoteConnection,\n                                                   boolean pollConnection) throws ExecutionException {\n    DebuggerSession debuggerSession = DebuggerManagerEx.getInstanceEx(myProject).attachVirtualMachine(runProfile.getName(), state, remoteConnection, pollConnection);\n\n    final DebuggerSessionTab sessionTab = new DebuggerSessionTab(myProject);\n    RunContentDescriptor runContentDescriptor = sessionTab.attachToSession(\n        debuggerSession,\n        runner,\n        runProfile,\n        state.getRunnerSettings(),\n        state.getConfigurationSettings()\n      );\n    if (reuseContent != null) {\n      final ProcessHandler prevHandler = reuseContent.getProcessHandler();\n      if (prevHandler != null) {\n        final DebuggerSessionTab prevSession = mySessionTabs.get(prevHandler);\n        if (prevSession != null) {\n          sessionTab.reuse(prevSession);\n        }\n      }\n    }\n    mySessionTabs.put(runContentDescriptor.getProcessHandler(), sessionTab);\n    return runContentDescriptor;\n  }","commit_id":"ca2d0610552ea399a503936a7ee0b89f54e60c4e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DebuggerTreeNodeImpl addWatch(TextWithImports text) {\n    LOG.assertTrue(SwingUtilities.isEventDispatchThread());\n    final DebuggerTreeNodeImpl root = (DebuggerTreeNodeImpl) getModel().getRoot();\n    DebuggerTreeNodeImpl node = DebuggerTreeNodeImpl.createNodeNoUpdate(this, new WatchItemDescriptor(getProject(), text, myAllowBreakpoints));\n    root.add(node);\n\n    treeChanged();\n    getSelectionModel().setSelectionPath(new TreePath(node.getPath()));\n\n    node.calcValue();\n\n    return node;\n  }","id":99680,"modified_method":"public DebuggerTreeNodeImpl addWatch(TextWithImports text) {\n    LOG.assertTrue(SwingUtilities.isEventDispatchThread());\n    final DebuggerTreeNodeImpl root = (DebuggerTreeNodeImpl) getModel().getRoot();\n    DebuggerTreeNodeImpl node = DebuggerTreeNodeImpl.createNodeNoUpdate(this, new WatchItemDescriptor(getProject(), text, myAllowBreakpoints));\n    root.add(node);\n\n    treeChanged();\n    getSelectionModel().setSelectionPath(new TreePath(node.getPath()));\n\n    return node;\n  }","commit_id":"ca2d0610552ea399a503936a7ee0b89f54e60c4e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DebuggerTreeNodeImpl addWatch(WatchItemDescriptor descriptor) {\n    LOG.assertTrue(SwingUtilities.isEventDispatchThread());\n    final DebuggerTreeNodeImpl root = (DebuggerTreeNodeImpl) getModel().getRoot();\n    WatchItemDescriptor watchDescriptor = new WatchItemDescriptor(getProject(), descriptor.getEvaluationText(), myAllowBreakpoints);\n    watchDescriptor.displayAs(descriptor);\n\n    final DebuggerTreeNodeImpl node = DebuggerTreeNodeImpl.createNodeNoUpdate(this, watchDescriptor);\n    root.add(node);\n\n    treeChanged();\n    getSelectionModel().setSelectionPath(new TreePath(node.getPath()));\n\n    node.calcValue();\n\n    return node;\n  }","id":99681,"modified_method":"public DebuggerTreeNodeImpl addWatch(WatchItemDescriptor descriptor) {\n    LOG.assertTrue(SwingUtilities.isEventDispatchThread());\n    final DebuggerTreeNodeImpl root = (DebuggerTreeNodeImpl) getModel().getRoot();\n    WatchItemDescriptor watchDescriptor = new WatchItemDescriptor(getProject(), descriptor.getEvaluationText(), myAllowBreakpoints);\n    watchDescriptor.displayAs(descriptor);\n\n    final DebuggerTreeNodeImpl node = DebuggerTreeNodeImpl.createNodeNoUpdate(this, watchDescriptor);\n    root.add(node);\n\n    treeChanged();\n    getSelectionModel().setSelectionPath(new TreePath(node.getPath()));\n\n    //node.calcValue();\n\n    return node;\n  }","commit_id":"ca2d0610552ea399a503936a7ee0b89f54e60c4e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private SourcePosition calcPosition(final ValueDescriptor descriptor, final DebugProcessImpl debugProcess)\n    throws ClassNotLoadedException, AbsentInformationException {\n    Value value = descriptor.getValue();\n    if(value != null) {\n      Type type = value.type();\n      if(type != null) {\n        if(type instanceof ArrayType) {\n          type = ((ArrayType)type).componentType();\n        }\n\n        if(type instanceof ClassType) {\n          try {\n            List<Location> locations = ((ClassType)type).allLineLocations();\n            if(locations.size() > 0) {\n              final Location location = locations.get(0);\n              return ApplicationManager.getApplication().runReadAction(new Computable<SourcePosition>() {\n                public SourcePosition compute() {\n                  return debugProcess.getPositionManager().getSourcePosition(location);\n                }\n              });\n            }\n          }\n          catch (AbsentInformationException e) {\n            LOG.debug(e);\n          }\n        }\n      }\n    }\n\n    return null;\n  }","id":99682,"modified_method":"private SourcePosition calcPosition(final ValueDescriptor descriptor, final DebugProcessImpl debugProcess) throws ClassNotLoadedException {\n    final Value value = descriptor.getValue();\n    if(value == null) {\n      return null;\n    }\n\n    Type type = value.type();\n    if(type == null) {\n      return null;\n    }\n\n    try {\n      if(type instanceof ArrayType) {\n        type = ((ArrayType)type).componentType();\n      }\n      if(type instanceof ClassType) {\n        final List<Location> locations = ((ClassType)type).allLineLocations();\n        if(locations.size() > 0) {\n          final Location location = locations.get(0);\n          return ApplicationManager.getApplication().runReadAction(new Computable<SourcePosition>() {\n            public SourcePosition compute() {\n              return debugProcess.getPositionManager().getSourcePosition(location);\n            }\n          });\n        }\n      }\n    }\n    catch (ClassNotPreparedException e) {\n      LOG.debug(e);\n    }\n    catch (AbsentInformationException e) {\n      LOG.debug(e);\n    }\n    return null;\n  }","commit_id":"4736d61a6242445b0b9f4bab50326a9a06863029","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n    DebuggerTreeNodeImpl selectedNode = getSelectedNode(e.getDataContext());\n    if(selectedNode == null) {\n      return;\n    }\n\n    final NodeDescriptorImpl descriptor = selectedNode.getDescriptor();\n    if(!(descriptor instanceof ValueDescriptor)) {\n      return;\n    }\n\n    DebuggerContextImpl debuggerContext = getDebuggerContext(e.getDataContext());\n    final DebugProcessImpl debugProcess = debuggerContext.getDebugProcess();\n    if(debugProcess == null) {\n      return;\n    }\n\n    debugProcess.getManagerThread().invokeLater(new SuspendContextCommandImpl(debuggerContext.getSuspendContext()) {\n      public void contextAction() throws Exception {\n        final SourcePosition sourcePosition = calcPosition((ValueDescriptor)descriptor, debugProcess);\n        if (sourcePosition != null) {\n          sourcePosition.navigate(true);\n        }\n      }\n    });\n  }","id":99683,"modified_method":"public void actionPerformed(AnActionEvent e) {\n    DebuggerTreeNodeImpl selectedNode = getSelectedNode(e.getDataContext());\n    if(selectedNode == null) {\n      return;\n    }\n\n    final NodeDescriptorImpl descriptor = selectedNode.getDescriptor();\n    if(!(descriptor instanceof ValueDescriptor)) {\n      return;\n    }\n\n    DebuggerContextImpl debuggerContext = getDebuggerContext(e.getDataContext());\n    final DebugProcessImpl debugProcess = debuggerContext.getDebugProcess();\n    if(debugProcess == null) {\n      return;\n    }\n\n    debugProcess.getManagerThread().invokeLater(new NavigateCommand(debuggerContext, (ValueDescriptor)descriptor, debugProcess, e));\n  }","commit_id":"4736d61a6242445b0b9f4bab50326a9a06863029","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void update(final AnActionEvent e) {\n    if(!isFirstStart(e)) return;\n\n    DebuggerContextImpl debuggerContext = getDebuggerContext(e.getDataContext());\n    final DebugProcessImpl debugProcess = debuggerContext.getDebugProcess();\n    if(debugProcess == null) {\n      e.getPresentation().setVisible(false);\n      return;\n    }\n\n    DebuggerTreeNodeImpl selectedNode = getSelectedNode(e.getDataContext());\n    if(selectedNode == null) {\n      e.getPresentation().setVisible(false);\n      return;\n    }\n\n    final NodeDescriptorImpl descriptor = selectedNode.getDescriptor();\n\n    if(!(descriptor instanceof ValueDescriptor)) {\n      e.getPresentation().setVisible(false);\n      return;\n    }\n\n    e.getPresentation().setVisible(true);\n    e.getPresentation().setEnabled(true);\n\n    debugProcess.getManagerThread().invokeLater(new SuspendContextCommandImpl(debuggerContext.getSuspendContext()) {\n      public void contextAction() throws Exception {\n        SourcePosition sourcePosition = calcPosition((ValueDescriptor)descriptor, debugProcess);\n        if(sourcePosition != null) {\n          enableAction(e, true);\n        }\n      }\n    });\n  }","id":99684,"modified_method":"public void update(final AnActionEvent e) {\n    if(!isFirstStart(e)) {\n      return;\n    }\n\n    final DebuggerContextImpl debuggerContext = getDebuggerContext(e.getDataContext());\n    final DebugProcessImpl debugProcess = debuggerContext.getDebugProcess();\n    if(debugProcess == null) {\n      e.getPresentation().setVisible(false);\n      return;\n    }\n\n    DebuggerTreeNodeImpl selectedNode = getSelectedNode(e.getDataContext());\n    if(selectedNode == null) {\n      e.getPresentation().setVisible(false);\n      return;\n    }\n\n    final NodeDescriptorImpl descriptor = selectedNode.getDescriptor();\n    if (descriptor instanceof ValueDescriptor) {\n      debugProcess.getManagerThread().invokeLater(new EnableCommand(debuggerContext, (ValueDescriptor)descriptor, debugProcess, e));\n    }\n    else {\n      e.getPresentation().setVisible(false);\n    }\n  }","commit_id":"4736d61a6242445b0b9f4bab50326a9a06863029","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected Extension createExtension(Document extensionDocument, String version)\n    {\n        com.xpn.xwiki.api.Object extensionObject = getExtensionObject(extensionDocument);\n\n        if (extensionObject == null) {\n            throw new WebApplicationException(Status.NOT_FOUND);\n        }\n\n        com.xpn.xwiki.api.Object extensionVersionObject = getExtensionVersionObject(extensionDocument, version);\n\n        if (extensionVersionObject == null) {\n            throw new WebApplicationException(Status.NOT_FOUND);\n        }\n\n        Extension extension = new Extension();\n        extension.setId((String) getValue(extensionObject, \"id\"));\n        extension.setVersion((String) getValue(extensionVersionObject, \"version\"));\n        extension.setType((String) getValue(extensionObject, \"type\"));\n\n        extension.setAuthor((String) getValue(extensionObject, \"author\"));\n        extension.setDescription((String) getValue(extensionObject, \"description\"));\n        extension.setName((String) getValue(extensionObject, \"name\"));\n        extension.setWebsite((String) getValue(extensionObject, \"website\"));\n\n        // TODO: set dependencies\n\n        return extension;\n    }","id":99685,"modified_method":"protected Extension createExtension(Document extensionDocument, String version)\n    {\n        com.xpn.xwiki.api.Object extensionObject = getExtensionObject(extensionDocument);\n\n        if (extensionObject == null) {\n            throw new WebApplicationException(Status.NOT_FOUND);\n        }\n\n        com.xpn.xwiki.api.Object extensionVersionObject = getExtensionVersionObject(extensionDocument, version);\n\n        if (extensionVersionObject == null) {\n            throw new WebApplicationException(Status.NOT_FOUND);\n        }\n\n        Extension extension = this.objectFactory.createExtension();\n        extension.setId((String) getValue(extensionObject, \"id\"));\n        extension.setVersion((String) getValue(extensionVersionObject, \"version\"));\n        extension.setType((String) getValue(extensionObject, \"type\"));\n\n        extension.setAuthor((String) getValue(extensionObject, \"author\"));\n        extension.setDescription((String) getValue(extensionObject, \"description\"));\n        extension.setName((String) getValue(extensionObject, \"name\"));\n        extension.setWebsite((String) getValue(extensionObject, \"website\"));\n\n        // TODO: set dependencies\n\n        return extension;\n    }","commit_id":"3b24bf2ca01495a1ffd128c06b97514b343d0537","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public AbstractExtensionRepository(ExtensionRepositoryId id)\n    {\n        this.id = id;\n    }","id":99686,"modified_method":"public AbstractExtensionRepository(ExtensionRepositoryId id)\n    {\n        this.id = new ExtensionRepositoryId(id.getId(), id.getType(), id.getURI());\n    }","commit_id":"3b24bf2ca01495a1ffd128c06b97514b343d0537","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void testDownload() throws ExtensionException, IOException\n    {\n        Extension artifact = this.repositoryManager.resolve(this.extensionId);\n\n        File file = new File(\"target/downloaded/\" + this.extensionId.getId() + \".ext\");\n\n        if (file.exists()) {\n            file.delete();\n        }\n\n        artifact.download(file);\n\n        Assert.assertTrue(\"File has not been downloaded\", file.exists());\n\n        Assert.assertEquals(\"content\", FileUtils.readFileToString(file));\n    }","id":99687,"modified_method":"@Test\n    public void testDownload() throws ExtensionException, IOException\n    {\n        Extension artifact = this.repositoryManager.resolve(this.extensionId);\n\n        File file = new File(\"target/downloaded/\" + this.extensionId.getId() + \".\" + artifact.getType());\n\n        if (file.exists()) {\n            file.delete();\n        }\n\n        artifact.download(file);\n\n        Assert.assertTrue(\"File has not been downloaded\", file.exists());\n\n        Assert.assertEquals(\"content\", FileUtils.readFileToString(file));\n    }","commit_id":"3b24bf2ca01495a1ffd128c06b97514b343d0537","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public Extension resolve(ExtensionId extensionId) throws ResolveException\n    {\n        Extension artifact = null;\n\n        for (ExtensionRepository repository : this.repositories.values()) {\n            try {\n                artifact = repository.resolve(extensionId);\n\n                return artifact;\n            } catch (ResolveException e) {\n                getLogger().debug(\n                    \"Could not find extension [\" + extensionId + \"] in repository [\" + repository.getId() + \"]\");\n            }\n        }\n\n        throw new ResolveException(\"Could not find extension [\" + extensionId + \"]\");\n    }","id":99688,"modified_method":"public Extension resolve(ExtensionId extensionId) throws ResolveException\n    {\n        Extension artifact = null;\n\n        for (ExtensionRepository repository : this.repositories.values()) {\n            try {\n                artifact = repository.resolve(extensionId);\n\n                return artifact;\n            } catch (ResolveException e) {\n                getLogger().debug(\n                    \"Could not find extension [\" + extensionId + \"] in repository [\" + repository.getId() + \"]\", e);\n            }\n        }\n\n        throw new ResolveException(\"Could not find extension [\" + extensionId + \"]\");\n    }","commit_id":"3b24bf2ca01495a1ffd128c06b97514b343d0537","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public InputStream getRESTResourceAsStream(UriBuilder builder, Object... values) throws ResolveException,\n        IOException\n    {\n        String url;\n        try {\n            url = builder.build(values).toString();\n        } catch (Exception e) {\n            throw new ResolveException(\"Failed to build REST URL\", e);\n        }\n\n        HttpClient httpClient = createClient();\n\n        GetMethod getMethod = new GetMethod(url.toString());\n        getMethod.addRequestHeader(\"Accept\", MediaType.APPLICATION_XML.toString());\n        try {\n            httpClient.executeMethod(getMethod);\n        } catch (Exception e) {\n            throw new ResolveException(\"Failed to request\", e);\n        }\n\n        if (getMethod.getStatusCode() != HttpStatus.SC_OK) {\n            throw new ResolveException(\"Invalid answer fo the server when requesting\");\n        }\n\n        return getMethod.getResponseBodyAsStream();\n    }","id":99689,"modified_method":"public InputStream getRESTResourceAsStream(UriBuilder builder, Object... values) throws ResolveException,\n        IOException\n    {\n        String url;\n        try {\n            url = builder.build(values).toString();\n        } catch (Exception e) {\n            throw new ResolveException(\"Failed to build REST URL\", e);\n        }\n\n        HttpClient httpClient = createClient();\n\n        GetMethod getMethod = new GetMethod(url.toString());\n        getMethod.addRequestHeader(\"Accept\", MediaType.APPLICATION_XML.toString());\n        try {\n            httpClient.executeMethod(getMethod);\n        } catch (Exception e) {\n            throw new ResolveException(\"Failed to request\", e);\n        }\n\n        if (getMethod.getStatusCode() != HttpStatus.SC_OK) {\n            throw new ResolveException(\"Invalid answer (\" + getMethod.getStatusCode()\n                + \") fo the server when requesting\");\n        }\n\n        return getMethod.getResponseBodyAsStream();\n    }","commit_id":"3b24bf2ca01495a1ffd128c06b97514b343d0537","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public XWikiExtensionRepository(ExtensionRepositoryId repositoryId,\n        XWikiExtensionRepositoryFactory repositoryFactory) throws Exception\n    {\n        super(repositoryId);\n\n        this.repositoryFactory = repositoryFactory;\n\n        // Uri builders\n        this.extensionUriBuider = createUriBuilder(\"/extension/{extensionId}/{extensionVersion}\");\n        this.extensionFileUriBuider = createUriBuilder(\"/extension/{extensionId}/{extensionVersion}/file\");\n    }","id":99690,"modified_method":"public XWikiExtensionRepository(ExtensionRepositoryId repositoryId,\n        XWikiExtensionRepositoryFactory repositoryFactory) throws Exception\n    {\n        super(repositoryId.getURI().getPath().endsWith(\"/\") ? new ExtensionRepositoryId(repositoryId.getId(),\n            repositoryId.getType(), new URI(StringUtils.chop(repositoryId.getURI().toString()))) : repositoryId);\n\n        this.repositoryFactory = repositoryFactory;\n\n        // Uri builders\n        this.extensionUriBuider = createUriBuilder(\"/extension/{extensionId}/{extensionVersion}\");\n        this.extensionFileUriBuider = createUriBuilder(\"/extension/{extensionId}/{extensionVersion}/file\");\n    }","commit_id":"3b24bf2ca01495a1ffd128c06b97514b343d0537","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public Extension resolve(ExtensionId extensionId) throws ResolveException\n    {\n        try {\n            return (XWikiExtension) this.repositoryFactory.getUnmarshaller().unmarshal(\n                getRESTResourceAsStream(this.extensionUriBuider, extensionId.getId(), extensionId.getVersion()));\n        } catch (Exception e) {\n            throw new ResolveException(\"Failed to create extension object for extension [\" + extensionId + \"]\", e);\n        }\n    }","id":99691,"modified_method":"public Extension resolve(ExtensionId extensionId) throws ResolveException\n    {\n        try {\n            return new XWikiExtension(\n                this,\n                (org.xwiki.extension.repository.xwiki.model.jaxb.Extension) this.repositoryFactory\n                    .getUnmarshaller()\n                    .unmarshal(\n                        getRESTResourceAsStream(this.extensionUriBuider, extensionId.getId(), extensionId.getVersion())));\n        } catch (Exception e) {\n            throw new ResolveException(\"Failed to create extension object for extension [\" + extensionId + \"]\", e);\n        }\n    }","commit_id":"3b24bf2ca01495a1ffd128c06b97514b343d0537","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public static void main (String[] argv) {\r\n\t\tnew JoglApplication(new com.badlogic.gdx.tests.TextureDataTest(), \"Debug Test\", 480, 320, false);\r\n\t}","id":99692,"modified_method":"public static void main (String[] argv) {\r\n\t\tnew JoglApplication(new com.badlogic.gdx.tests.AnimationTest(), \"Debug Test\", 480, 320, false);\r\n\t}","commit_id":"893466e120e16638847491ebf92efffa03ff2b70","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\r\n\t * Draws a rectangle with the top left corner at x,y having the width and height of the region.\r\n\t */\r\n\tpublic void draw (TextureRegion region, float x, float y) {\r\n\t\tdraw(region, x, y, region.getRegionWidth(), region.getRegionHeight());\r\n\t}","id":99693,"modified_method":"/**\r\n\t * Draws a rectangle with the top left corner at x,y having the width and height of the region.\r\n\t */\r\n\tpublic void draw (TextureRegion region, float x, float y) {\r\n\t\tdraw(region, x, y, Math.abs(region.getRegionWidth()), Math.abs(region.getRegionHeight()));\r\n\t}","commit_id":"893466e120e16638847491ebf92efffa03ff2b70","url":"https://github.com/libgdx/libgdx"},{"original_method":"public Button (String name, TextureRegion unpressedRegion, TextureRegion pressedRegion) {\r\n\t\tsuper(name);\r\n\t\twidth = unpressedRegion.getRegionWidth();\r\n\t\theight = unpressedRegion.getRegionHeight();\r\n\t\toriginX = width / 2.0f;\r\n\t\toriginY = height / 2.0f;\r\n\t\tthis.unpressedRegion = new TextureRegion(unpressedRegion);\r\n\t\tthis.pressedRegion = new TextureRegion(pressedRegion);\r\n\t}","id":99694,"modified_method":"public Button (String name, TextureRegion unpressedRegion, TextureRegion pressedRegion) {\r\n\t\tsuper(name);\r\n\t\twidth = Math.abs(unpressedRegion.getRegionWidth());\r\n\t\theight = Math.abs(unpressedRegion.getRegionHeight());\r\n\t\toriginX = width / 2.0f;\r\n\t\toriginY = height / 2.0f;\r\n\t\tthis.unpressedRegion = new TextureRegion(unpressedRegion);\r\n\t\tthis.pressedRegion = new TextureRegion(pressedRegion);\r\n\t}","commit_id":"13002896c09237a9f3f3ca8ce889f0867d5b6ead","url":"https://github.com/libgdx/libgdx"},{"original_method":"public FastImage (String name, TextureRegion region) {\r\n\t\tsuper(name);\r\n\t\twidth = region.getRegionWidth();\r\n\t\theight = region.getRegionHeight();\r\n\t\toriginX = width / 2.0f;\r\n\t\toriginY = height / 2.0f;\r\n\t\tthis.region = new TextureRegion(region);\r\n\t}","id":99695,"modified_method":"public FastImage (String name, TextureRegion region) {\r\n\t\tsuper(name);\r\n\t\twidth = Math.abs(region.getRegionWidth());\r\n\t\theight = Math.abs(region.getRegionHeight());\r\n\t\toriginX = width / 2.0f;\r\n\t\toriginY = height / 2.0f;\r\n\t\tthis.region = new TextureRegion(region);\r\n\t}","commit_id":"13002896c09237a9f3f3ca8ce889f0867d5b6ead","url":"https://github.com/libgdx/libgdx"},{"original_method":"public Image (String name, TextureRegion region) {\r\n\t\tsuper(name);\r\n\t\twidth = region.getRegionWidth();\r\n\t\theight = region.getRegionHeight();\r\n\t\toriginX = width / 2.0f;\r\n\t\toriginY = height / 2.0f;\r\n\t\tthis.region = new TextureRegion(region);\r\n\t}","id":99696,"modified_method":"public Image (String name, TextureRegion region) {\r\n\t\tsuper(name);\r\n\t\twidth = Math.abs(region.getRegionWidth());\r\n\t\theight = Math.abs(region.getRegionHeight());\r\n\t\toriginX = width / 2.0f;\r\n\t\toriginY = height / 2.0f;\r\n\t\tthis.region = new TextureRegion(region);\r\n\t}","commit_id":"13002896c09237a9f3f3ca8ce889f0867d5b6ead","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void setRegion (TextureRegion region) {\r\n\t\tthis.region = region;\r\n\t\tsetMinWidth(region.getRegionWidth());\r\n\t\tsetMinHeight(region.getRegionHeight());\r\n\t}","id":99697,"modified_method":"public void setRegion (TextureRegion region) {\r\n\t\tthis.region = region;\r\n\t\tsetMinWidth(Math.abs(region.getRegionWidth()));\r\n\t\tsetMinHeight(Math.abs(region.getRegionHeight()));\r\n\t}","commit_id":"81a8759dc3abf210d27c1d7e17ec2842d0ebd285","url":"https://github.com/libgdx/libgdx"},{"original_method":"public float getPrefHeight () {\r\n\t\tif (region != null) return region.getRegionHeight();\r\n\t\tif (patch != null) return patch.getTotalHeight();\r\n\t\treturn 0;\r\n\t}","id":99698,"modified_method":"public float getPrefHeight () {\r\n\t\tif (region != null) return Math.abs(region.getRegionHeight());\r\n\t\tif (patch != null) return patch.getTotalHeight();\r\n\t\treturn 0;\r\n\t}","commit_id":"279fb95e5cf45641559deefe1fcbb4884a409930","url":"https://github.com/libgdx/libgdx"},{"original_method":"public float getPrefWidth () {\r\n\t\tif (region != null) return region.getRegionWidth();\r\n\t\tif (patch != null) return patch.getTotalWidth();\r\n\t\treturn 0;\r\n\t}","id":99699,"modified_method":"public float getPrefWidth () {\r\n\t\tif (region != null) return Math.abs(region.getRegionWidth());\r\n\t\tif (patch != null) return patch.getTotalWidth();\r\n\t\treturn 0;\r\n\t}","commit_id":"279fb95e5cf45641559deefe1fcbb4884a409930","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void layout () {\r\n\t\tfloat regionWidth, regionHeight;\r\n\t\tif (patch != null) {\r\n\t\t\tregionWidth = patch.getTotalWidth();\r\n\t\t\tregionHeight = patch.getTotalHeight();\r\n\t\t} else if (region != null) {\r\n\t\t\tregionWidth = region.getRegionWidth();\r\n\t\t\tregionHeight = region.getRegionHeight();\r\n\t\t} else\r\n\t\t\treturn;\r\n\r\n\t\tfloat width = getWidth();\r\n\t\tfloat height = getHeight();\r\n\r\n\t\tVector2 size = scaling.apply(regionWidth, regionHeight, width, height);\r\n\t\timageWidth = size.x;\r\n\t\timageHeight = size.y;\r\n\r\n\t\tif ((align & Align.LEFT) != 0)\r\n\t\t\timageX = 0;\r\n\t\telse if ((align & Align.RIGHT) != 0)\r\n\t\t\timageX = (int)(width - imageWidth);\r\n\t\telse\r\n\t\t\timageX = (int)(width / 2 - imageWidth / 2);\r\n\r\n\t\tif ((align & Align.TOP) != 0)\r\n\t\t\timageY = (int)(height - imageHeight);\r\n\t\telse if ((align & Align.BOTTOM) != 0)\r\n\t\t\timageY = 0;\r\n\t\telse\r\n\t\t\timageY = (int)(height / 2 - imageHeight / 2);\r\n\t}","id":99700,"modified_method":"public void layout () {\r\n\t\tfloat regionWidth, regionHeight;\r\n\t\tif (patch != null) {\r\n\t\t\tregionWidth = patch.getTotalWidth();\r\n\t\t\tregionHeight = patch.getTotalHeight();\r\n\t\t} else if (region != null) {\r\n\t\t\tregionWidth = Math.abs(region.getRegionWidth());\r\n\t\t\tregionHeight = Math.abs(region.getRegionHeight());\r\n\t\t} else\r\n\t\t\treturn;\r\n\r\n\t\tfloat width = getWidth();\r\n\t\tfloat height = getHeight();\r\n\r\n\t\tVector2 size = scaling.apply(regionWidth, regionHeight, width, height);\r\n\t\timageWidth = size.x;\r\n\t\timageHeight = size.y;\r\n\r\n\t\tif ((align & Align.LEFT) != 0)\r\n\t\t\timageX = 0;\r\n\t\telse if ((align & Align.RIGHT) != 0)\r\n\t\t\timageX = (int)(width - imageWidth);\r\n\t\telse\r\n\t\t\timageX = (int)(width / 2 - imageWidth / 2);\r\n\r\n\t\tif ((align & Align.TOP) != 0)\r\n\t\t\timageY = (int)(height - imageHeight);\r\n\t\telse if ((align & Align.BOTTOM) != 0)\r\n\t\t\timageY = 0;\r\n\t\telse\r\n\t\t\timageY = (int)(height / 2 - imageHeight / 2);\r\n\t}","commit_id":"279fb95e5cf45641559deefe1fcbb4884a409930","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** @param region May be null. */\r\n\tpublic void setRegion (TextureRegion region) {\r\n\t\tif (region != null) {\r\n\t\t\tif (this.region == region) return;\r\n\t\t\tif (getPrefWidth() != region.getRegionWidth() || getPrefHeight() != region.getRegionHeight()) invalidateHierarchy();\r\n\t\t} else {\r\n\t\t\tif (getPrefWidth() != 0 || getPrefHeight() != 0) invalidateHierarchy();\r\n\t\t}\r\n\t\tthis.region = region;\r\n\t\tpatch = null;\r\n\t}","id":99701,"modified_method":"/** @param region May be null. */\r\n\tpublic void setRegion (TextureRegion region) {\r\n\t\tif (region != null) {\r\n\t\t\tif (this.region == region) return;\r\n\t\t\tif (getPrefWidth() != Math.abs(region.getRegionWidth()) || getPrefHeight() != Math.abs(region.getRegionHeight()))\r\n\t\t\t\tinvalidateHierarchy();\r\n\t\t} else {\r\n\t\t\tif (getPrefWidth() != 0 || getPrefHeight() != 0) invalidateHierarchy();\r\n\t\t}\r\n\t\tthis.region = region;\r\n\t\tpatch = null;\r\n\t}","commit_id":"279fb95e5cf45641559deefe1fcbb4884a409930","url":"https://github.com/libgdx/libgdx"},{"original_method":"public Result substringTest(int start, int end, String string) {\n        try {\n            if (start < 0 || end <= 0 || string.isEmpty()) {\n                return badRequest();\n            }\n\n            return ok(Json.toJson(substringTest.test(start, end, string)));\n        } catch (IOException e) {\n            return internalServerError(\"io exception\");\n        } catch (APIException e) {\n            return internalServerError(\"api exception \" + e);\n        }\n    }","id":99702,"modified_method":"public Result substringTest() {\n        final JsonNode json = request().body().asJson();\n        final SubstringTestRequest request = Json.fromJson(json, SubstringTestRequest.class);\n        try {\n            if (request.start < 0 || request.end <= 0 || request.string.isEmpty()) {\n                return badRequest();\n            }\n\n            return ok(Json.toJson(substringTest.test(request)));\n        } catch (IOException e) {\n            return internalServerError(\"io exception\");\n        } catch (APIException e) {\n            return internalServerError(\"api exception \" + e);\n        }\n    }","commit_id":"be3e35e75dc7525e91e6c79acd9b05a1afacb1bc","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public Result splitAndIndexTest(String splitBy, int index, String string) {\n        try {\n            if (splitBy.isEmpty() || index < 0 || string.isEmpty()) {\n                return badRequest();\n            }\n\n            return ok(Json.toJson(splitAndIndexTest.test(splitBy, index, string)));\n        } catch (IOException e) {\n            return internalServerError(\"io exception\");\n        } catch (APIException e) {\n            return internalServerError(\"api exception \" + e);\n        }\n    }","id":99703,"modified_method":"public Result splitAndIndexTest() {\n        final JsonNode json = request().body().asJson();\n        final SplitAndIndexTestRequest request = Json.fromJson(json, SplitAndIndexTestRequest.class);\n\n        try {\n            if (request.splitBy.isEmpty() || request.index < 0 || request.string.isEmpty()) {\n                return badRequest();\n            }\n\n            return ok(Json.toJson(splitAndIndexTest.test(request)));\n        } catch (IOException e) {\n            return internalServerError(\"io exception\");\n        } catch (APIException e) {\n            return internalServerError(\"api exception \" + e);\n        }\n    }","commit_id":"be3e35e75dc7525e91e6c79acd9b05a1afacb1bc","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public Result regexTest(String regex, String string) {\n        try {\n            if (regex.isEmpty() || string.isEmpty()) {\n                return badRequest();\n            }\n\n            return ok(Json.toJson(regexTest.test(regex, string)));\n        } catch (IOException e) {\n            return internalServerError(\"io exception\");\n        } catch (APIException e) {\n            return internalServerError(\"api exception \" + e);\n        }\n    }","id":99704,"modified_method":"public Result regexTest() {\n        final JsonNode json = request().body().asJson();\n        final RegexTestRequest request = Json.fromJson(json, RegexTestRequest.class);\n\n        try {\n            if (request.regex.isEmpty() || request.string.isEmpty()) {\n                return badRequest();\n            }\n\n            return ok(Json.toJson(regexTest.test(request)));\n        } catch (IOException e) {\n            return internalServerError(\"io exception\");\n        } catch (APIException e) {\n            return internalServerError(\"api exception \" + e);\n        }\n    }","commit_id":"be3e35e75dc7525e91e6c79acd9b05a1afacb1bc","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public Result grokTest(String pattern, String string) {\n        if (pattern.isEmpty() || string.isEmpty()) {\n            return badRequest();\n        }\n\n        try {\n            return ok(Json.toJson(grokTest.test(pattern, string)));\n        } catch (IOException e) {\n            return internalServerError(\"io exception\");\n        } catch (APIException e) {\n            if (e.getHttpCode() == 422) {\n                return status(422);\n            }\n            return internalServerError(\"api exception \" + e);\n        }\n    }","id":99705,"modified_method":"public Result grokTest() {\n        final JsonNode json = request().body().asJson();\n        final GrokTestRequest request = Json.fromJson(json, GrokTestRequest.class);\n\n        if (request.pattern.isEmpty() || request.string.isEmpty()) {\n            return badRequest();\n        }\n\n        try {\n            return ok(Json.toJson(grokTest.test(request)));\n        } catch (IOException e) {\n            return internalServerError(\"io exception\");\n        } catch (APIException e) {\n            if (e.getHttpCode() == 422) {\n                return status(422);\n            }\n            return internalServerError(\"api exception \" + e);\n        }\n    }","commit_id":"be3e35e75dc7525e91e6c79acd9b05a1afacb1bc","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private void doMergingOfReplicas(HRegionInfo mergedHri, final HRegionInfo hri_a,\n      final HRegionInfo hri_b) {\n    // Close replicas for the original unmerged regions. create/assign new replicas\n    // for the merged parent.\n    List<HRegionInfo> unmergedRegions = new ArrayList<HRegionInfo>();\n    unmergedRegions.add(hri_a);\n    unmergedRegions.add(hri_b);\n    Map<ServerName, List<HRegionInfo>> map = regionStates.getRegionAssignments(unmergedRegions);\n    Collection<List<HRegionInfo>> c = map.values();\n    for (List<HRegionInfo> l : c) {\n      for (HRegionInfo h : l) {\n        if (!RegionReplicaUtil.isDefaultReplica(h)) {\n          LOG.debug(\"Unassigning un-merged replica \" + h);\n          unassign(h);\n        }\n      }\n    }\n    int numReplicas = 1;\n    try {\n      numReplicas = ((MasterServices)server).getTableDescriptors().get(mergedHri.getTable()).\n          getRegionReplication();\n    } catch (IOException e) {\n      LOG.warn(\"Couldn't get the replication attribute of the table \" + mergedHri.getTable() +\n          \" due to \" + e.getMessage() + \". The assignment of replicas for the merged region \" +\n          \"will not be done\");\n    }\n    List<HRegionInfo> regions = new ArrayList<HRegionInfo>();\n    for (int i = 1; i < numReplicas; i++) {\n      regions.add(RegionReplicaUtil.getRegionInfoForReplica(mergedHri, i));\n    }\n    try {\n      assign(regions);\n    } catch (IOException ioe) {\n      LOG.warn(\"Couldn't assign all replica(s) of region \" + mergedHri + \" because of \" +\n                ioe.getMessage());\n    } catch (InterruptedException ie) {\n      LOG.warn(\"Couldn't assign all replica(s) of region \" + mergedHri+ \" because of \" +\n                ie.getMessage());\n    }\n  }","id":99706,"modified_method":"private void doMergingOfReplicas(HRegionInfo mergedHri, final HRegionInfo hri_a,\n      final HRegionInfo hri_b) {\n    // Close replicas for the original unmerged regions. create/assign new replicas\n    // for the merged parent.\n    List<HRegionInfo> unmergedRegions = new ArrayList<HRegionInfo>();\n    unmergedRegions.add(hri_a);\n    unmergedRegions.add(hri_b);\n    Map<ServerName, List<HRegionInfo>> map = regionStates.getRegionAssignments(unmergedRegions);\n    Collection<List<HRegionInfo>> c = map.values();\n    for (List<HRegionInfo> l : c) {\n      for (HRegionInfo h : l) {\n        if (!RegionReplicaUtil.isDefaultReplica(h)) {\n          LOG.debug(\"Unassigning un-merged replica \" + h);\n          unassign(h);\n        }\n      }\n    }\n    int numReplicas = getNumReplicas(server, mergedHri.getTable());\n    List<HRegionInfo> regions = new ArrayList<HRegionInfo>();\n    for (int i = 1; i < numReplicas; i++) {\n      regions.add(RegionReplicaUtil.getRegionInfoForReplica(mergedHri, i));\n    }\n    try {\n      assign(regions);\n    } catch (IOException ioe) {\n      LOG.warn(\"Couldn't assign all replica(s) of region \" + mergedHri + \" because of \" +\n                ioe.getMessage());\n    } catch (InterruptedException ie) {\n      LOG.warn(\"Couldn't assign all replica(s) of region \" + mergedHri+ \" because of \" +\n                ie.getMessage());\n    }\n  }","commit_id":"7e6f562754715a8d23755e10a35117633b3a7e9a","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Rebuild the list of user regions and assignment information.\n   * Updates regionstates with findings as we go through list of regions.\n   * @return set of servers not online that hosted some regions according to a scan of hbase:meta\n   * @throws IOException\n   */\n  Set<ServerName> rebuildUserRegions() throws\n          IOException, KeeperException {\n    Set<TableName> disabledOrEnablingTables = tableStateManager.getTablesInStates(\n            TableState.State.DISABLED, TableState.State.ENABLING);\n\n    Set<TableName> disabledOrDisablingOrEnabling = tableStateManager.getTablesInStates(\n            TableState.State.DISABLED,\n            TableState.State.DISABLING,\n            TableState.State.ENABLING);\n\n    // Region assignment from META\n    List<Result> results = MetaTableAccessor.fullScanRegions(server.getConnection());\n    // Get any new but slow to checkin region server that joined the cluster\n    Set<ServerName> onlineServers = serverManager.getOnlineServers().keySet();\n    // Set of offline servers to be returned\n    Set<ServerName> offlineServers = new HashSet<ServerName>();\n    // Iterate regions in META\n    for (Result result : results) {\n      if (result == null && LOG.isDebugEnabled()){\n        LOG.debug(\"null result from meta - ignoring but this is strange.\");\n        continue;\n      }\n      // keep a track of replicas to close. These were the replicas of the originally\n      // unmerged regions. The master might have closed them before but it mightn't\n      // maybe because it crashed.\n      PairOfSameType<HRegionInfo> p = MetaTableAccessor.getMergeRegions(result);\n      if (p.getFirst() != null && p.getSecond() != null) {\n        int numReplicas = ((MasterServices)server).getTableDescriptors().get(p.getFirst().\n            getTable()).getRegionReplication();\n        for (HRegionInfo merge : p) {\n          for (int i = 1; i < numReplicas; i++) {\n            replicasToClose.add(RegionReplicaUtil.getRegionInfoForReplica(merge, i));\n          }\n        }\n      }\n      RegionLocations rl =  MetaTableAccessor.getRegionLocations(result);\n      if (rl == null) {\n        continue;\n      }\n      HRegionLocation[] locations = rl.getRegionLocations();\n      if (locations == null) {\n        continue;\n      }\n      for (HRegionLocation hrl : locations) {\n        if (hrl == null) continue;\n        HRegionInfo regionInfo = hrl.getRegionInfo();\n        if (regionInfo == null) continue;\n        int replicaId = regionInfo.getReplicaId();\n        State state = RegionStateStore.getRegionState(result, replicaId);\n        // keep a track of replicas to close. These were the replicas of the split parents\n        // from the previous life of the master. The master should have closed them before\n        // but it couldn't maybe because it crashed\n        if (replicaId == 0 && state.equals(State.SPLIT)) {\n          for (HRegionLocation h : locations) {\n            replicasToClose.add(h.getRegionInfo());\n          }\n        }\n        ServerName lastHost = hrl.getServerName();\n        ServerName regionLocation = RegionStateStore.getRegionServer(result, replicaId);\n        regionStates.createRegionState(regionInfo, state, regionLocation, lastHost);\n        if (!regionStates.isRegionInState(regionInfo, State.OPEN)) {\n          // Region is not open (either offline or in transition), skip\n          continue;\n        }\n        TableName tableName = regionInfo.getTable();\n        if (!onlineServers.contains(regionLocation)) {\n          // Region is located on a server that isn't online\n          offlineServers.add(regionLocation);\n        } else if (!disabledOrEnablingTables.contains(tableName)) {\n          // Region is being served and on an active server\n          // add only if region not in disabled or enabling table\n          regionStates.regionOnline(regionInfo, regionLocation);\n          balancer.regionOnline(regionInfo, regionLocation);\n        }\n        // need to enable the table if not disabled or disabling or enabling\n        // this will be used in rolling restarts\n        if (!disabledOrDisablingOrEnabling.contains(tableName)\n          && !getTableStateManager().isTableState(tableName,\n                TableState.State.ENABLED)) {\n          setEnabledTable(tableName);\n        }\n      }\n    }\n    return offlineServers;\n  }","id":99707,"modified_method":"/**\n   * Rebuild the list of user regions and assignment information.\n   * Updates regionstates with findings as we go through list of regions.\n   * @return set of servers not online that hosted some regions according to a scan of hbase:meta\n   * @throws IOException\n   */\n  Set<ServerName> rebuildUserRegions() throws\n          IOException, KeeperException {\n    Set<TableName> disabledOrEnablingTables = tableStateManager.getTablesInStates(\n            TableState.State.DISABLED, TableState.State.ENABLING);\n\n    Set<TableName> disabledOrDisablingOrEnabling = tableStateManager.getTablesInStates(\n            TableState.State.DISABLED,\n            TableState.State.DISABLING,\n            TableState.State.ENABLING);\n\n    // Region assignment from META\n    List<Result> results = MetaTableAccessor.fullScanRegions(server.getConnection());\n    // Get any new but slow to checkin region server that joined the cluster\n    Set<ServerName> onlineServers = serverManager.getOnlineServers().keySet();\n    // Set of offline servers to be returned\n    Set<ServerName> offlineServers = new HashSet<ServerName>();\n    // Iterate regions in META\n    for (Result result : results) {\n      if (result == null && LOG.isDebugEnabled()){\n        LOG.debug(\"null result from meta - ignoring but this is strange.\");\n        continue;\n      }\n      // keep a track of replicas to close. These were the replicas of the originally\n      // unmerged regions. The master might have closed them before but it mightn't\n      // maybe because it crashed.\n      PairOfSameType<HRegionInfo> p = MetaTableAccessor.getMergeRegions(result);\n      if (p.getFirst() != null && p.getSecond() != null) {\n        int numReplicas = getNumReplicas(server, p.getFirst().getTable());\n        for (HRegionInfo merge : p) {\n          for (int i = 1; i < numReplicas; i++) {\n            replicasToClose.add(RegionReplicaUtil.getRegionInfoForReplica(merge, i));\n          }\n        }\n      }\n      RegionLocations rl =  MetaTableAccessor.getRegionLocations(result);\n      if (rl == null) {\n        continue;\n      }\n      HRegionLocation[] locations = rl.getRegionLocations();\n      if (locations == null) {\n        continue;\n      }\n      for (HRegionLocation hrl : locations) {\n        if (hrl == null) continue;\n        HRegionInfo regionInfo = hrl.getRegionInfo();\n        if (regionInfo == null) continue;\n        int replicaId = regionInfo.getReplicaId();\n        State state = RegionStateStore.getRegionState(result, replicaId);\n        // keep a track of replicas to close. These were the replicas of the split parents\n        // from the previous life of the master. The master should have closed them before\n        // but it couldn't maybe because it crashed\n        if (replicaId == 0 && state.equals(State.SPLIT)) {\n          for (HRegionLocation h : locations) {\n            replicasToClose.add(h.getRegionInfo());\n          }\n        }\n        ServerName lastHost = hrl.getServerName();\n        ServerName regionLocation = RegionStateStore.getRegionServer(result, replicaId);\n        regionStates.createRegionState(regionInfo, state, regionLocation, lastHost);\n        if (!regionStates.isRegionInState(regionInfo, State.OPEN)) {\n          // Region is not open (either offline or in transition), skip\n          continue;\n        }\n        TableName tableName = regionInfo.getTable();\n        if (!onlineServers.contains(regionLocation)) {\n          // Region is located on a server that isn't online\n          offlineServers.add(regionLocation);\n        } else if (!disabledOrEnablingTables.contains(tableName)) {\n          // Region is being served and on an active server\n          // add only if region not in disabled or enabling table\n          regionStates.regionOnline(regionInfo, regionLocation);\n          balancer.regionOnline(regionInfo, regionLocation);\n        }\n        // need to enable the table if not disabled or disabling or enabling\n        // this will be used in rolling restarts\n        if (!disabledOrDisablingOrEnabling.contains(tableName)\n          && !getTableStateManager().isTableState(tableName,\n                TableState.State.ENABLED)) {\n          setEnabledTable(tableName);\n        }\n      }\n    }\n    return offlineServers;\n  }","commit_id":"7e6f562754715a8d23755e10a35117633b3a7e9a","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Get a list of replica regions that are:\n   * not recorded in meta yet. We might not have recorded the locations\n   * for the replicas since the replicas may not have been online yet, master restarted\n   * in the middle of assigning, ZK erased, etc.\n   * @param regionsRecordedInMeta the list of regions we know are recorded in meta\n   * either as a default, or, as the location of a replica\n   * @param master\n   * @return list of replica regions\n   * @throws IOException\n   */\n  public static List<HRegionInfo> replicaRegionsNotRecordedInMeta(\n      Set<HRegionInfo> regionsRecordedInMeta, MasterServices master)throws IOException {\n    List<HRegionInfo> regionsNotRecordedInMeta = new ArrayList<HRegionInfo>();\n    for (HRegionInfo hri : regionsRecordedInMeta) {\n      TableName table = hri.getTable();\n      HTableDescriptor htd = master.getTableDescriptors().get(table);\n      // look at the HTD for the replica count. That's the source of truth\n      int desiredRegionReplication = htd.getRegionReplication();\n      for (int i = 0; i < desiredRegionReplication; i++) {\n        HRegionInfo replica = RegionReplicaUtil.getRegionInfoForReplica(hri, i);\n        if (regionsRecordedInMeta.contains(replica)) continue;\n        regionsNotRecordedInMeta.add(replica);\n      }\n    }\n    return regionsNotRecordedInMeta;\n  }","id":99708,"modified_method":"/**\n   * Get a list of replica regions that are:\n   * not recorded in meta yet. We might not have recorded the locations\n   * for the replicas since the replicas may not have been online yet, master restarted\n   * in the middle of assigning, ZK erased, etc.\n   * @param regionsRecordedInMeta the list of regions we know are recorded in meta\n   * either as a default, or, as the location of a replica\n   * @param master\n   * @return list of replica regions\n   * @throws IOException\n   */\n  public static List<HRegionInfo> replicaRegionsNotRecordedInMeta(\n      Set<HRegionInfo> regionsRecordedInMeta, MasterServices master)throws IOException {\n    List<HRegionInfo> regionsNotRecordedInMeta = new ArrayList<HRegionInfo>();\n    for (HRegionInfo hri : regionsRecordedInMeta) {\n      TableName table = hri.getTable();\n      if(master.getTableDescriptors().get(table) == null)\n        continue;\n      int  desiredRegionReplication = getNumReplicas(master, table);\n      for (int i = 0; i < desiredRegionReplication; i++) {\n        HRegionInfo replica = RegionReplicaUtil.getRegionInfoForReplica(hri, i);\n        if (regionsRecordedInMeta.contains(replica)) continue;\n        regionsNotRecordedInMeta.add(replica);\n      }\n    }\n    return regionsNotRecordedInMeta;\n  }","commit_id":"7e6f562754715a8d23755e10a35117633b3a7e9a","url":"https://github.com/apache/hbase"},{"original_method":"private void doSplittingOfReplicas(final HRegionInfo parentHri, final HRegionInfo hri_a,\n      final HRegionInfo hri_b) {\n    // create new regions for the replica, and assign them to match with the\n    // current replica assignments. If replica1 of parent is assigned to RS1,\n    // the replica1s of daughters will be on the same machine\n    int numReplicas = 1;\n    try {\n      numReplicas = ((MasterServices)server).getTableDescriptors().get(parentHri.getTable()).\n          getRegionReplication();\n    } catch (IOException e) {\n      LOG.warn(\"Couldn't get the replication attribute of the table \" + parentHri.getTable() +\n          \" due to \" + e.getMessage() + \". The assignment of daughter replicas \" +\n          \"replicas will not be done\");\n    }\n    // unassign the old replicas\n    List<HRegionInfo> parentRegion = new ArrayList<HRegionInfo>();\n    parentRegion.add(parentHri);\n    Map<ServerName, List<HRegionInfo>> currentAssign =\n        regionStates.getRegionAssignments(parentRegion);\n    Collection<List<HRegionInfo>> c = currentAssign.values();\n    for (List<HRegionInfo> l : c) {\n      for (HRegionInfo h : l) {\n        if (!RegionReplicaUtil.isDefaultReplica(h)) {\n          LOG.debug(\"Unassigning parent's replica \" + h);\n          unassign(h);\n        }\n      }\n    }\n    // assign daughter replicas\n    Map<HRegionInfo, ServerName> map = new HashMap<HRegionInfo, ServerName>();\n    for (int i = 1; i < numReplicas; i++) {\n      prepareDaughterReplicaForAssignment(hri_a, parentHri, i, map);\n      prepareDaughterReplicaForAssignment(hri_b, parentHri, i, map);\n    }\n    try {\n      assign(map);\n    } catch (IOException e) {\n      LOG.warn(\"Caught exception \" + e + \" while trying to assign replica(s) of daughter(s)\");\n    } catch (InterruptedException e) {\n      LOG.warn(\"Caught exception \" + e + \" while trying to assign replica(s) of daughter(s)\");\n    }\n  }","id":99709,"modified_method":"private void doSplittingOfReplicas(final HRegionInfo parentHri, final HRegionInfo hri_a,\n      final HRegionInfo hri_b) {\n    // create new regions for the replica, and assign them to match with the\n    // current replica assignments. If replica1 of parent is assigned to RS1,\n    // the replica1s of daughters will be on the same machine\n    int numReplicas = getNumReplicas(server, parentHri.getTable());\n    // unassign the old replicas\n    List<HRegionInfo> parentRegion = new ArrayList<HRegionInfo>();\n    parentRegion.add(parentHri);\n    Map<ServerName, List<HRegionInfo>> currentAssign =\n        regionStates.getRegionAssignments(parentRegion);\n    Collection<List<HRegionInfo>> c = currentAssign.values();\n    for (List<HRegionInfo> l : c) {\n      for (HRegionInfo h : l) {\n        if (!RegionReplicaUtil.isDefaultReplica(h)) {\n          LOG.debug(\"Unassigning parent's replica \" + h);\n          unassign(h);\n        }\n      }\n    }\n    // assign daughter replicas\n    Map<HRegionInfo, ServerName> map = new HashMap<HRegionInfo, ServerName>();\n    for (int i = 1; i < numReplicas; i++) {\n      prepareDaughterReplicaForAssignment(hri_a, parentHri, i, map);\n      prepareDaughterReplicaForAssignment(hri_b, parentHri, i, map);\n    }\n    try {\n      assign(map);\n    } catch (IOException e) {\n      LOG.warn(\"Caught exception \" + e + \" while trying to assign replica(s) of daughter(s)\");\n    } catch (InterruptedException e) {\n      LOG.warn(\"Caught exception \" + e + \" while trying to assign replica(s) of daughter(s)\");\n    }\n  }","commit_id":"7e6f562754715a8d23755e10a35117633b3a7e9a","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Set a range of bits, expanding the size if necessary. <br/>\n   * NOTE: <code>s < e<\/code> must be true!\n   * @param s index of the first bit to set\n   * @param e index of the last bit to set + 1 (to be in conformance with\n   *          {@link java.util.BitSet})\n   */\n  public void set(final int s, final int e) {\n    final int startWord = s >>> WORD_POWER;\n    final int endWord = e - 1 >>> WORD_POWER;\n\n    if(endWord >= words.length) expandTo(endWord + 1);\n\n    final long startMask = WORD_MASK << s;\n    // 64 - (e % 64) = 64 - (e & 63) = -e, due to wrap\n    final long endMask = WORD_MASK >>> -e;\n\n    if(startWord == endWord) {\n      words[startWord] |= startMask & endMask;\n    } else {\n      words[startWord] |= startMask;\n      for(int i = startWord + 1; i < endWord; i++) words[i] = WORD_MASK;\n      words[endWord] |= endMask;\n    }\n    if(e > last) last = e;\n  }","id":99710,"modified_method":"/**\n   * Set a range of bits, expanding the size if necessary. <br/>\n   * NOTE: <code>s < e<\/code> must be true!\n   * @param s index of the first bit to set\n   * @param e index of the last bit to set + 1 (to be in conformance with\n   *          {@link java.util.BitSet})\n   */\n  public void set(final int s, final int e) {\n    final int startWord = s >>> WORD_POWER;\n    final int endWord = e - 1 >>> WORD_POWER;\n\n    if(endWord >= words.length) expandTo(endWord + 1);\n\n    final long startMask = WORD_MASK << s;\n    // 64 - (e % 64) = 64 - (e & 63) = -e, due to wrap\n    final long endMask = WORD_MASK >>> -e;\n\n    if(startWord == endWord) {\n      words[startWord] |= startMask & endMask;\n    } else {\n      words[startWord] |= startMask;\n      for(int i = startWord + 1; i < endWord; i++) words[i] = WORD_MASK;\n      words[endWord] |= endMask;\n    }\n    if(e >= length) length = e + 1L;\n  }","commit_id":"1843301b01c82919e60cbccbbb2d2729e5f03746","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Get the next bit set to 0, starting from the i<sup>th<\/sup> bit.\n   * @param i index from which to start the search (inclusive)\n   * @return index of the next clear bit; -1 if there is no set bit after the\n   *         i<sup>th<\/sup> bit\n   */\n  public long nextClearBit(final long i) {\n    // calculate the index of the word in the array: i div 2^6 = i >> 6\n    int wordIndex = (int) (i >>> WORD_POWER);\n    // invert the word and skip the first i bits:\n    long word = ~words[wordIndex] & WORD_MASK << i;\n\n    if(word != 0) {\n      return ((long) wordIndex << WORD_POWER) + numberOfTrailingZeros(word);\n    }\n\n    while(++wordIndex < words.length) {\n      if((word = ~words[wordIndex]) != 0) {\n        return ((long) wordIndex << WORD_POWER) + numberOfTrailingZeros(word);\n      }\n    }\n\n    // wordIndex * 2^6:\n    return -1L;\n  }","id":99711,"modified_method":"/**\n   * Get the next bit set to 0, starting from the i<sup>th<\/sup> bit.\n   * @param i index from which to start the search (inclusive)\n   * @return index of the next clear bit after the i<sup>th<\/sup> bit\n   */\n  public long nextClearBit(final long i) {\n    // calculate the index of the word in the array: i div 2^6 = i >> 6\n    int wordIndex = (int) (i >>> WORD_POWER);\n    // invert the word and skip the first i bits:\n    long word = ~words[wordIndex] & WORD_MASK << i;\n\n    if(word != 0) {\n      return ((long) wordIndex << WORD_POWER) + numberOfTrailingZeros(word);\n    }\n\n    while(++wordIndex < words.length) {\n      if((word = ~words[wordIndex]) != 0) {\n        return ((long) wordIndex << WORD_POWER) + numberOfTrailingZeros(word);\n      }\n    }\n\n    // wordIndex * 2^6:\n    return wordIndex << WORD_POWER;\n  }","commit_id":"1843301b01c82919e60cbccbbb2d2729e5f03746","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Initialize the bit array with the specified backing array.\n   * @param a array with bits\n   * @param l last used bit\n   */\n  public void setWords(final long[] a, final long l) {\n    words = a;\n    last = l;\n  }","id":99712,"modified_method":"/**\n   * Initialize the bit array with the specified backing array.\n   * @param a array with bits\n   * @param l number of used bits\n   */\n  public void setWords(final long[] a, final long l) {\n    words = a;\n    length = l;\n  }","commit_id":"1843301b01c82919e60cbccbbb2d2729e5f03746","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Get the next bit set to 0, starting from the i<sup>th<\/sup> bit.\n   * @param i index from which to start the search (inclusive)\n   * @return index of the next clear bit; -1 if there is no set bit after the\n   *         i<sup>th<\/sup> bit\n   */\n  public int nextClearBit(final int i) {\n    // calculate the index of the word in the array: i div 2^6 = i >> 6\n    int wordIndex = i >>> WORD_POWER;\n    // invert the word and skip the first i bits:\n    long word = ~words[wordIndex] & WORD_MASK << i;\n\n    if(word != 0) {\n      return (wordIndex << WORD_POWER) + numberOfTrailingZeros(word);\n    }\n\n    while(++wordIndex < words.length) {\n      if((word = ~words[wordIndex]) != 0) {\n        return wordIndex << WORD_POWER + numberOfTrailingZeros(word);\n      }\n    }\n\n    // wordIndex * 2^6:\n    return -1;\n  }","id":99713,"modified_method":"/**\n   * Get the next bit set to 0, starting from the i<sup>th<\/sup> bit.\n   * @param i index from which to start the search (inclusive)\n   * @return index of the next clear bit after the i<sup>th<\/sup> bit\n   */\n  public int nextClearBit(final int i) {\n    // calculate the index of the word in the array: i div 2^6 = i >> 6\n    int wordIndex = i >>> WORD_POWER;\n    // invert the word and skip the first i bits:\n    long word = ~words[wordIndex] & WORD_MASK << i;\n\n    if(word != 0) {\n      return (wordIndex << WORD_POWER) + numberOfTrailingZeros(word);\n    }\n\n    while(++wordIndex < words.length) {\n      if((word = ~words[wordIndex]) != 0) {\n        return (wordIndex << WORD_POWER) + numberOfTrailingZeros(word);\n      }\n    }\n\n    // wordIndex * 2^6:\n    return wordIndex << WORD_POWER;\n  }","commit_id":"1843301b01c82919e60cbccbbb2d2729e5f03746","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Set the i<sup>th<\/sup> bit to 1.\n   * @param i index of the bit\n   */\n  public void set(final int i) {\n    // calculate the index of the word in the array: i div 2^6 = i >> 6\n    final int wordIndex = i >>> WORD_POWER;\n    if(wordIndex >= words.length) expandTo(wordIndex + 1);\n    words[wordIndex] |= 1L << i;\n    if(i > last) last = i;\n  }","id":99714,"modified_method":"/**\n   * Set the i<sup>th<\/sup> bit to 1.\n   * @param i index of the bit\n   */\n  public void set(final int i) {\n    // calculate the index of the word in the array: i div 2^6 = i >> 6\n    final int wordIndex = i >>> WORD_POWER;\n    if(wordIndex >= words.length) expandTo(wordIndex + 1);\n    words[wordIndex] |= 1L << i;\n    if(i >= length) length = i + 1L;\n  }","commit_id":"1843301b01c82919e60cbccbbb2d2729e5f03746","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Get the next n clear bits, starting from the i<sup>th<\/sup> bit.\n   * @param i index from which to start the search (inclusive)\n   * @param n number of clear bits.\n   * @return a list of clear bits\n   */\n  public int[] nextClearBits(final int i, final int n) {\n    final int[] t = new int[n];\n    t[0] = nextClearBit(i);\n    for(int k = 1; k < n; k++)\n      if((t[k] = nextClearBit(t[k - 1] + 1)) >= last) {\n        final int[] r = new int[k];\n        System.arraycopy(t, 0, r, 0, k);\n        return r;\n      }\n    return t;\n  }","id":99715,"modified_method":"/**\n   * Get the next n clear bits, starting from the i<sup>th<\/sup> bit.\n   * @param i index from which to start the search (inclusive)\n   * @param n number of clear bits.\n   * @return a list of clear bits\n   */\n  public int[] nextClearBits(final int i, final int n) {\n    final int[] t = new int[n];\n\n    int cnt = 0;\n    int prev = i;\n\n    // try to find n clear bits:\n    while(cnt < n) {\n      final int b = nextClearBit(prev);\n      if(b >= 0 && b < length) prev = (t[cnt++] = b) + 1;\n      else break;\n    }\n\n    if(cnt == n) return t;\n\n    // if needed, create a result array with length == number of found bits:\n    final int[] r = new int[cnt];\n    System.arraycopy(t, 0, r, 0, cnt);\n    return r;\n  }","commit_id":"1843301b01c82919e60cbccbbb2d2729e5f03746","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Set the i<sup>th<\/sup> bit to 1.\n   * @param i index of the bit\n   */\n  public void set(final long i) {\n    // calculate the index of the word in the array: i div 2^6 = i >> 6\n    final int wordIndex = (int) (i >>> WORD_POWER);\n    if(wordIndex >= words.length) expandTo(wordIndex + 1);\n    words[wordIndex] |= 1L << i;\n    if(i > last) last = i;\n  }","id":99716,"modified_method":"/**\n   * Set the i<sup>th<\/sup> bit to 1.\n   * @param i index of the bit\n   */\n  public void set(final long i) {\n    // calculate the index of the word in the array: i div 2^6 = i >> 6\n    final int wordIndex = (int) (i >>> WORD_POWER);\n    if(wordIndex >= words.length) expandTo(wordIndex + 1);\n    words[wordIndex] |= 1L << i;\n    if(i >= length) length = i + 1L;\n  }","commit_id":"1843301b01c82919e60cbccbbb2d2729e5f03746","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Set a range of bits, expanding the size if necessary. <br/>\n   * NOTE: <code>s < e<\/code> must be true!\n   * @param s index of the first bit to set\n   * @param e index of the last bit to set + 1 (to be in conformance with\n   *          {@link java.util.BitSet})\n   */\n  public void set(final long s, final long e) {\n    final int startWord = (int) (s >>> WORD_POWER);\n    final int endWord = (int) (e - 1L >>> WORD_POWER);\n\n    if(endWord >= words.length) expandTo(endWord + 1);\n\n    final long startMask = WORD_MASK << s;\n    // 64 - (e % 64) = 64 - (e & 63) = -e, due to wrap\n    final long endMask = WORD_MASK >>> -e;\n\n    if(startWord == endWord) {\n      words[startWord] |= startMask & endMask;\n    } else {\n      words[startWord] |= startMask;\n      for(int i = startWord + 1; i < endWord; i++) words[i] = WORD_MASK;\n      words[endWord] |= endMask;\n    }\n    if(e > last) last = e;\n  }","id":99717,"modified_method":"/**\n   * Set a range of bits, expanding the size if necessary. <br/>\n   * NOTE: <code>s < e<\/code> must be true!\n   * @param s index of the first bit to set\n   * @param e index of the last bit to set + 1 (to be in conformance with\n   *          {@link java.util.BitSet})\n   */\n  public void set(final long s, final long e) {\n    final int startWord = (int) (s >>> WORD_POWER);\n    final int endWord = (int) (e - 1L >>> WORD_POWER);\n\n    if(endWord >= words.length) expandTo(endWord + 1);\n\n    final long startMask = WORD_MASK << s;\n    // 64 - (e % 64) = 64 - (e & 63) = -e, due to wrap\n    final long endMask = WORD_MASK >>> -e;\n\n    if(startWord == endWord) {\n      words[startWord] |= startMask & endMask;\n    } else {\n      words[startWord] |= startMask;\n      for(int i = startWord + 1; i < endWord; i++) words[i] = WORD_MASK;\n      words[endWord] |= endMask;\n    }\n    if(e >= length) length = e + 1L;\n  }","commit_id":"1843301b01c82919e60cbccbbb2d2729e5f03746","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Get the next n clear bits, starting from the i<sup>th<\/sup> bit.\n   * @param i index from which to start the search (inclusive)\n   * @param n number of clear bits.\n   * @return a list of clear bits\n   */\n  public long[] nextClearBits(final long i, final int n) {\n    final long[] t = new long[n];\n    t[0] = nextClearBit(i);\n    for(int k = 0; k < n; k++)\n      if((t[k] = nextClearBit(t[k - 1] + 1L)) >= last) {\n        final long[] r = new long[k];\n        System.arraycopy(t, 0, r, 0, k);\n        return r;\n      }\n    return t;\n  }","id":99718,"modified_method":"/**\n   * Get the next n clear bits, starting from the i<sup>th<\/sup> bit.\n   * @param i index from which to start the search (inclusive)\n   * @param n number of clear bits.\n   * @return a list of clear bits\n   */\n  public long[] nextClearBits(final long i, final int n) {\n    final long[] t = new long[n];\n\n    int cnt = 0;\n    long prev = i;\n\n    // try to find n clear bits:\n    while(cnt < n) {\n      final long b = nextClearBit(prev);\n      if(b >= 0 && b < length) prev = (t[cnt++] = b) + 1L;\n      else break;\n    }\n\n    if(cnt == n) return t;\n\n    // if needed, create a result array with length == number of found bits:\n    final long[] r = new long[cnt];\n    System.arraycopy(t, 0, r, 0, cnt);\n    return r;\n  }","commit_id":"1843301b01c82919e60cbccbbb2d2729e5f03746","url":"https://github.com/BaseXdb/basex"},{"original_method":"private void processJFKMessage3(byte[] payload, int inputOffset, PeerNode pn,Peer replyTo, boolean oldOpennetPeer, boolean unknownInitiator, int setupType, int negType)\n\t{\n\t\tfinal long t1 = System.currentTimeMillis();\n\t\tint modulusLength = getModulusLength(negType);\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(3) message, processing it - \"+pn);\n\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) { throw new RuntimeException(e); }\n\n\t\tfinal int expectedLength =\n\t\t\tNONCE_SIZE*2 + // Ni, Nr\n\t\t\tmodulusLength*2 + // g^i, g^r\n\t\t\tHASH_LENGTH + // authenticator\n\t\t\tHASH_LENGTH + // HMAC of the cyphertext\n\t\t\t(c.getBlockSize() >> 3) + // IV\n\t\t\tHASH_LENGTH + // it's at least a signature\n\t\t\t8 +\t      // a bootid\n\t\t\t8 + // packet tracker ID\n\t\t\t1;\t      // znoderefI* is at least 1 byte long\n\n\t\tif(payload.length < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn+\": \"+payload.length+\" after decryption in JFK(3), should be \"+(expectedLength + 3));\n\t\t\treturn;\n\t\t}\n\n\t\t// Ni\n\t\tbyte[] nonceInitiator = Arrays.copyOfRange(payload, inputOffset, inputOffset+NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\tif(logMINOR) Logger.minor(this, \"We are receiving Ni : \" + HexUtil.bytesToHex(nonceInitiator));\n\t\t// Before negtype 9 we didn't hash it!\n\t\tbyte[] nonceInitiatorHashed = (negType > 8 ? SHA256.digest(nonceInitiator) : nonceInitiator);\n\t\t    \n\t\t// Nr\n\t\tbyte[] nonceResponder = Arrays.copyOfRange(payload, inputOffset, inputOffset+NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\t// g^i\n\t\tbyte[] initiatorExponential = Arrays.copyOfRange(payload, inputOffset, inputOffset+modulusLength);\n\t\tinputOffset += modulusLength;\n\t\t// g^r\n\t\tbyte[] responderExponential = Arrays.copyOfRange(payload, inputOffset, inputOffset+modulusLength);\n\t\tinputOffset += modulusLength;\n\n\t\tbyte[] authenticator = Arrays.copyOfRange(payload, inputOffset, inputOffset+HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\n\t\t// We *WANT* to check the hmac before we do the lookup on the hashmap\n\t\t// @see https://bugs.freenetproject.org/view.php?id=1604\n\t\tif(!HMAC.verifyWithSHA256(getTransientKey(), assembleJFKAuthenticator(responderExponential, initiatorExponential, nonceResponder, nonceInitiatorHashed, replyTo.getAddress().getAddress()) , authenticator)) {\n\t\t\tif(shouldLogErrorInHandshake(t1)) {\n\t\t\t    if(logMINOR) Logger.minor(this, \"We received the following HMAC : \" + HexUtil.bytesToHex(authenticator));\n\t\t\t    if(logMINOR) Logger.minor(this, \"We have Ni' : \" + HexUtil.bytesToHex(nonceInitiatorHashed));\n\t\t\t\tLogger.normal(this, \"The HMAC doesn't match; let's discard the packet (either we rekeyed or we are victim of forgery) - JFK3 - \"+pn);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t// Check try to find the authenticator in the cache.\n\t\t// If authenticator is already present, indicates duplicate/replayed message3\n\t\t// Now simply transmit the corresponding message4\n\t\tObject message4 = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tmessage4 = authenticatorCache.get(new ByteArrayWrapper(authenticator));\n\t\t}\n\t\tif(message4 != null) {\n\t\t\tLogger.normal(this, \"We replayed a message from the cache (shouldn't happen often) - \"+pn);\n\t\t\t// We are replaying a JFK(4).\n\t\t\t// Therefore if it is anon-initiator it is encrypted with our setup key.\n\t\t\tif(unknownInitiator) {\n\t\t\t\tsendAnonAuthPacket(1,negType,3,setupType, (byte[]) message4, null, replyTo, crypto.anonSetupCipher);\n\t\t\t} else {\n\t\t\t\tsendAuthPacket(1, negType, 3, (byte[]) message4, pn, replyTo);\n\t\t\t}\n\t\t\treturn;\n\t\t} else {\n\t\t\tif(logDEBUG) Logger.debug(this, \"No message4 found for \"+HexUtil.bytesToHex(authenticator)+\" responderExponential \"+Fields.hashCode(responderExponential)+\" initiatorExponential \"+Fields.hashCode(initiatorExponential)+\" nonceResponder \"+Fields.hashCode(nonceResponder)+\" nonceInitiator \"+Fields.hashCode(nonceInitiatorHashed)+\" address \"+HexUtil.bytesToHex(replyTo.getAddress().getAddress()));\n\t\t}\n\n\t\tbyte[] hmac = Arrays.copyOfRange(payload, inputOffset, inputOffset+HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\n\t\tbyte[] computedExponential;\n\t\tif(negType < 8) { // Legacy DH\n\t\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1, initiatorExponential);\n\t\t\tNativeBigInteger _ourExponential = new NativeBigInteger(1, responderExponential);\n\n\t\t\tDiffieHellmanLightContext ctx = findContextByExponential(_ourExponential);\n\t\t\tif(ctx == null) {\n\t\t\t\tLogger.error(this, \"WTF? the HMAC verified but we don't know about that exponential! SHOULDN'T HAPPEN! - JFK3 - \"+pn);\n\t\t\t\t// Possible this is a replay or severely delayed? We don't keep every exponential we ever use.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcomputedExponential = ctx.getHMACKey(_hisExponential);\n        } else {\n            ECPublicKey initiatorKey = ECDH.getPublicKey(initiatorExponential, ecdhCurveToUse);\n            ECPublicKey responderKey = ECDH.getPublicKey(responderExponential, ecdhCurveToUse);\n            ECDHLightContext ctx = findECDHContextByPubKey(responderKey);\n            if (ctx == null) {\n                Logger.error(this, \"WTF? the HMAC verified but we don't know about that exponential! SHOULDN'T HAPPEN! - JFK3 - \"+pn);\n                // Possible this is a replay or severely delayed? We don't keep\n                // every exponential we ever use.\n                return;\n            }\n            computedExponential = ctx.getHMACKey(initiatorKey).getEncoded();\n        }\n\t\tif(logDEBUG) Logger.debug(this, \"The shared Master secret is : \"+HexUtil.bytesToHex(computedExponential) +\" for \" + pn);\n\t\t\n\t\t/* 0 is the outgoing key for the initiator, 7 for the responder */\n\t\tbyte[] outgoingKey = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"7\");\n\t\tbyte[] incommingKey = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"0\");\n\t\tbyte[] Ke = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"1\");\n\t\tbyte[] Ka = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"2\");\n\n\t\tbyte[] hmacKey = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"3\");\n\t\tbyte[] ivKey = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"4\");\n\t\tbyte[] ivNonce = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"5\");\n\n\t\t/* Bytes  1-4:  Initial sequence number for the initiator\n\t\t * Bytes  5-8:  Initial sequence number for the responder\n\t\t * Bytes  9-12: Initial message id for the initiator\n\t\t * Bytes 13-16: Initial message id for the responder\n\t\t * Note that we are the responder */\n\t\tbyte[] sharedData = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"6\");\n\t\tint theirInitialSeqNum = ((sharedData[0] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[1] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[2] & 0xFF) << 8)\n\t\t\t\t| (sharedData[3] & 0xFF);\n\t\tint ourInitialSeqNum = ((sharedData[4] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[5] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[6] & 0xFF) << 8)\n\t\t\t\t| (sharedData[7] & 0xFF);\n\t\tint theirInitialMsgID, ourInitialMsgID;\n\t\tif(negType >= 7) {\n\t\t\ttheirInitialMsgID =\n\t\t\t\tunknownInitiator ? getInitialMessageID(crypto.myIdentity) :\n\t\t\t\t\tgetInitialMessageID(pn.identity, crypto.myIdentity);\n\t\t\tourInitialMsgID =\n\t\t\t\tunknownInitiator ? getInitialMessageID(crypto.myIdentity) :\n\t\t\t\t\tgetInitialMessageID(crypto.myIdentity, pn.identity);\n\t\t} else {\n\t\t\ttheirInitialMsgID= ((sharedData[8] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[9] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[10] & 0xFF) << 8)\n\t\t\t\t| (sharedData[11] & 0xFF);\n\t\t\tourInitialMsgID= ((sharedData[12] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[13] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[14] & 0xFF) << 8)\n\t\t\t\t| (sharedData[15] & 0xFF);\n\t\t}\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Their initial message ID: \"+theirInitialMsgID+\" ours \"+ourInitialMsgID);\n\n\t\tc.initialize(Ke);\n\t\tint ivLength = PCFBMode.lengthIV(c);\n\t\tint decypheredPayloadOffset = 0;\n\t\t// We compute the HMAC of (\"I\"+cyphertext) : the cyphertext includes the IV!\n\t\tbyte[] decypheredPayload = Arrays.copyOf(JFK_PREFIX_INITIATOR, JFK_PREFIX_INITIATOR.length + payload.length - inputOffset);\n\t\tdecypheredPayloadOffset += JFK_PREFIX_INITIATOR.length;\n\t\tSystem.arraycopy(payload, inputOffset, decypheredPayload, decypheredPayloadOffset, decypheredPayload.length-decypheredPayloadOffset);\n\t\tif(!HMAC.verifyWithSHA256(Ka, decypheredPayload, hmac)) {\n\t\t\tLogger.error(this, \"The inner-HMAC doesn't match; let's discard the packet JFK(3) - \"+pn);\n\t\t\treturn;\n\t\t}\n\n\t\tfinal PCFBMode pk = PCFBMode.create(c, decypheredPayload, decypheredPayloadOffset);\n\t\t// Get the IV\n\t\tdecypheredPayloadOffset += ivLength;\n\t\t// Decrypt the payload\n\t\tpk.blockDecipher(decypheredPayload, decypheredPayloadOffset, decypheredPayload.length-decypheredPayloadOffset);\n\t\t/*\n\t\t * DecipheredData Format:\n\t\t * Signature\n\t\t * Node Data (starting with BootID)\n\t\t */\n\t\tint sigLength = getSignatureLength(negType);\n\t\tbyte[] sig = new byte[sigLength];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, sig, 0, sigLength);\n\t\tdecypheredPayloadOffset += sigLength;\n\t\tbyte[] data = new byte[decypheredPayload.length - decypheredPayloadOffset];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, data, 0, decypheredPayload.length - decypheredPayloadOffset);\n\t\tint ptr = 0;\n\t\tlong trackerID;\n\t\ttrackerID = Fields.bytesToLong(data, ptr);\n\t\tif(trackerID < 0) trackerID = -1;\n\t\tptr += 8;\n\t\tlong bootID = Fields.bytesToLong(data, ptr);\n\t\tptr += 8;\n\t\tbyte[] hisRef = Arrays.copyOfRange(data, ptr, data.length);\n\n\t\t// construct the peernode\n\t\tif(unknownInitiator) {\n\t\t\tpn = getPeerNodeFromUnknownInitiator(hisRef, setupType, pn, replyTo);\n\t\t}\n\t\tif(pn == null) {\n\t\t\tif(unknownInitiator) {\n\t\t\t\t// Reject\n\t\t\t\tLogger.normal(this, \"Rejecting... unable to construct PeerNode\");\n\t\t\t} else {\n\t\t\t\tLogger.error(this, \"PeerNode is null and unknownInitiator is false!\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// verify the signature\n\t\tbyte[] toVerify = assembleDHParams(nonceInitiatorHashed, nonceResponder, initiatorExponential, responderExponential, crypto.myIdentity, data);\n\t\tif(negType < 9) {\n\t\t    byte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\t    System.arraycopy(sig, 0, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n            byte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n            System.arraycopy(sig, Node.SIGNATURE_PARAMETER_LENGTH, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\t    DSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t\t    if(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, SHA256.digest(toVerify)), false)) {\n\t\t        Logger.error(this, \"The signature verification has failed!! JFK(3) - \"+pn.getPeer());\n\t\t        return;\n\t\t    }\n\t\t} else {\n\t\t    if(!ECDSA.verify(Curves.P256, pn.peerECDSAPubKey, sig, toVerify)) {\n\t              Logger.error(this, \"The ECDSA signature verification has failed!! JFK(3) - \"+pn.getPeer());\n\t                return;\n\t\t    }\n\t\t}\n\n\t\t// At this point we know it's from the peer, so we can report a packet received.\n\t\tpn.receivedPacket(true, false);\n\n\t\tBlockCipher outgoingCipher = null;\n\t\tBlockCipher incommingCipher = null;\n\t\tBlockCipher ivCipher = null;\n\t\ttry {\n\t\t\toutgoingCipher = new Rijndael(256, 256);\n\t\t\tincommingCipher = new Rijndael(256, 256);\n\t\t\tivCipher = new Rijndael(256, 256);\n\t\t} catch (UnsupportedCipherException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\toutgoingCipher.initialize(outgoingKey);\n\t\tincommingCipher.initialize(incommingKey);\n\t\tivCipher.initialize(ivKey);\n\n\t\t// Promote if necessary\n\t\tboolean dontWant = false;\n\t\tif(oldOpennetPeer) {\n\t\t\tOpennetManager opennet = node.getOpennet();\n\t\t\tif(opennet == null) {\n\t\t\t\tLogger.normal(this, \"Dumping incoming old-opennet peer as opennet just turned off: \"+pn+\".\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/* When an old-opennet-peer connects, add it at the top of the LRU, so that it isn't\n\t\t\t * immediately dropped when there is no droppable peer to drop. If it was dropped\n\t\t\t * from the bottom of the LRU list, we would not have added it to the LRU; so it was\n\t\t\t * somewhere in the middle. */\n\t\t\tif(!opennet.wantPeer(pn, false, false, true, ConnectionType.RECONNECT)) {\n\t\t\t\tLogger.normal(this, \"No longer want peer \"+pn+\" - dumping it after connecting\");\n\t\t\t\tdontWant = true;\n\t\t\t\topennet.purgeOldOpennetPeer(pn);\n\t\t\t}\n\t\t\t// wantPeer will call node.peers.addPeer(), we don't have to.\n\t\t}\n\t\tif((!dontWant) && !crypto.allowConnection(pn, replyTo.getFreenetAddress())) {\n\t\t\tif(pn instanceof DarknetPeerNode) {\n\t\t\t\tLogger.error(this, \"Dropping peer \"+pn+\" because don't want connection due to others on the same IP address!\");\n\t\t\t\tSystem.out.println(\"Disconnecting permanently from your friend \\\"\"+((DarknetPeerNode)pn).getName()+\"\\\" because other peers are using the same IP address!\");\n\t\t\t}\n\t\t\tLogger.normal(this, \"Rejecting connection because already have something with the same IP\");\n\t\t\tdontWant = true;\n\t\t}\n\n\t\tlong newTrackerID = pn.completedHandshake(\n\t\t\t\tbootID, hisRef, 0, hisRef.length, outgoingCipher, outgoingKey, incommingCipher,\n\t\t\t\tincommingKey, replyTo, true, negType, trackerID, false, false, hmacKey, ivCipher,\n\t\t\t\tivNonce, ourInitialSeqNum, theirInitialSeqNum, ourInitialMsgID, theirInitialMsgID);\n\n\t\tif(newTrackerID > 0) {\n\n\t\t\t// Send reply\n\t\t\tsendJFKMessage4(1, negType, 3, nonceInitiatorHashed, nonceResponder,initiatorExponential, responderExponential,\n\t\t\t\t\tc, Ke, Ka, authenticator, hisRef, pn, replyTo, unknownInitiator, setupType, newTrackerID, newTrackerID == trackerID);\n\n\t\t\tif(dontWant) {\n\t\t\t\tnode.peers.disconnectAndRemove(pn, true, true, true); // Let it connect then tell it to remove it.\n\t\t\t} else {\n\t\t\t\tpn.maybeSendInitialMessages();\n\t\t\t}\n\t\t} else {\n\t\t\tLogger.error(this, \"Handshake failure! with \"+pn.getPeer());\n\t\t\t// Don't send the JFK(4). We have not successfully connected.\n\t\t}\n\n\t\tfinal long t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500) {\n\t\t\tLogger.error(this,\"Message3 Processing packet for \"+pn.getPeer()+\" took \"+TimeUtil.formatTime(t2-t1, 3, true));\n\t\t}\n\t}","id":99719,"modified_method":"private void processJFKMessage3(byte[] payload, int inputOffset, PeerNode pn,Peer replyTo, boolean oldOpennetPeer, boolean unknownInitiator, int setupType, int negType)\n\t{\n\t\tfinal long t1 = System.currentTimeMillis();\n\t\tint modulusLength = getModulusLength(negType);\n\t\tint nonceSize = getNonceSize(negType);\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(3) message, processing it - \"+pn);\n\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) { throw new RuntimeException(e); }\n\n\t\tfinal int expectedLength =\n\t\t\tnonceSize*2 + // Ni, Nr\n\t\t\tmodulusLength*2 + // g^i, g^r\n\t\t\tHASH_LENGTH + // authenticator\n\t\t\tHASH_LENGTH + // HMAC of the cyphertext\n\t\t\t(c.getBlockSize() >> 3) + // IV\n\t\t\tHASH_LENGTH + // it's at least a signature\n\t\t\t8 +\t      // a bootid\n\t\t\t8 + // packet tracker ID\n\t\t\t1;\t      // znoderefI* is at least 1 byte long\n\n\t\tif(payload.length < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn+\": \"+payload.length+\" after decryption in JFK(3), should be \"+(expectedLength + 3));\n\t\t\treturn;\n\t\t}\n\n\t\t// Ni\n\t\tbyte[] nonceInitiator = new byte[nonceSize];\n\t\tSystem.arraycopy(payload, inputOffset, nonceInitiator, 0, nonceSize);\n\t\tinputOffset += nonceSize;\n\t\tif(logMINOR) Logger.minor(this, \"We are receiving Ni : \" + HexUtil.bytesToHex(nonceInitiator));\n\t\t// Before negtype 9 we didn't hash it!\n\t\tbyte[] nonceInitiatorHashed = (negType > 8 ? SHA256.digest(nonceInitiator) : nonceInitiator);\n\t\t    \n\t\t// Nr\n\t\tbyte[] nonceResponder = new byte[nonceSize];\n\t\tSystem.arraycopy(payload, inputOffset, nonceResponder, 0, nonceSize);\n\t\tinputOffset += nonceSize;\n\t\t// g^i\n\t\tbyte[] initiatorExponential = Arrays.copyOfRange(payload, inputOffset, inputOffset+modulusLength);\n\t\tinputOffset += modulusLength;\n\t\t// g^r\n\t\tbyte[] responderExponential = Arrays.copyOfRange(payload, inputOffset, inputOffset+modulusLength);\n\t\tinputOffset += modulusLength;\n\n\t\tbyte[] authenticator = Arrays.copyOfRange(payload, inputOffset, inputOffset+HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\n\t\t// We *WANT* to check the hmac before we do the lookup on the hashmap\n\t\t// @see https://bugs.freenetproject.org/view.php?id=1604\n\t\tif(!HMAC.verifyWithSHA256(getTransientKey(), assembleJFKAuthenticator(responderExponential, initiatorExponential, nonceResponder, nonceInitiatorHashed, replyTo.getAddress().getAddress()) , authenticator)) {\n\t\t\tif(shouldLogErrorInHandshake(t1)) {\n\t\t\t    if(logMINOR) Logger.minor(this, \"We received the following HMAC : \" + HexUtil.bytesToHex(authenticator));\n\t\t\t    if(logMINOR) Logger.minor(this, \"We have Ni' : \" + HexUtil.bytesToHex(nonceInitiatorHashed));\n\t\t\t\tLogger.normal(this, \"The HMAC doesn't match; let's discard the packet (either we rekeyed or we are victim of forgery) - JFK3 - \"+pn);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t// Check try to find the authenticator in the cache.\n\t\t// If authenticator is already present, indicates duplicate/replayed message3\n\t\t// Now simply transmit the corresponding message4\n\t\tObject message4 = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tmessage4 = authenticatorCache.get(new ByteArrayWrapper(authenticator));\n\t\t}\n\t\tif(message4 != null) {\n\t\t\tLogger.normal(this, \"We replayed a message from the cache (shouldn't happen often) - \"+pn);\n\t\t\t// We are replaying a JFK(4).\n\t\t\t// Therefore if it is anon-initiator it is encrypted with our setup key.\n\t\t\tif(unknownInitiator) {\n\t\t\t\tsendAnonAuthPacket(1,negType,3,setupType, (byte[]) message4, null, replyTo, crypto.anonSetupCipher);\n\t\t\t} else {\n\t\t\t\tsendAuthPacket(1, negType, 3, (byte[]) message4, pn, replyTo);\n\t\t\t}\n\t\t\treturn;\n\t\t} else {\n\t\t\tif(logDEBUG) Logger.debug(this, \"No message4 found for \"+HexUtil.bytesToHex(authenticator)+\" responderExponential \"+Fields.hashCode(responderExponential)+\" initiatorExponential \"+Fields.hashCode(initiatorExponential)+\" nonceResponder \"+Fields.hashCode(nonceResponder)+\" nonceInitiator \"+Fields.hashCode(nonceInitiatorHashed)+\" address \"+HexUtil.bytesToHex(replyTo.getAddress().getAddress()));\n\t\t}\n\n\t\tbyte[] hmac = Arrays.copyOfRange(payload, inputOffset, inputOffset+HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\n\t\tbyte[] computedExponential;\n\t\tif(negType < 8) { // Legacy DH\n\t\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1, initiatorExponential);\n\t\t\tNativeBigInteger _ourExponential = new NativeBigInteger(1, responderExponential);\n\n\t\t\tDiffieHellmanLightContext ctx = findContextByExponential(_ourExponential);\n\t\t\tif(ctx == null) {\n\t\t\t\tLogger.error(this, \"WTF? the HMAC verified but we don't know about that exponential! SHOULDN'T HAPPEN! - JFK3 - \"+pn);\n\t\t\t\t// Possible this is a replay or severely delayed? We don't keep every exponential we ever use.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcomputedExponential = ctx.getHMACKey(_hisExponential);\n        } else {\n            ECPublicKey initiatorKey = ECDH.getPublicKey(initiatorExponential, ecdhCurveToUse);\n            ECPublicKey responderKey = ECDH.getPublicKey(responderExponential, ecdhCurveToUse);\n            ECDHLightContext ctx = findECDHContextByPubKey(responderKey);\n            if (ctx == null) {\n                Logger.error(this, \"WTF? the HMAC verified but we don't know about that exponential! SHOULDN'T HAPPEN! - JFK3 - \"+pn);\n                // Possible this is a replay or severely delayed? We don't keep\n                // every exponential we ever use.\n                return;\n            }\n            computedExponential = ctx.getHMACKey(initiatorKey).getEncoded();\n        }\n\t\tif(logDEBUG) Logger.debug(this, \"The shared Master secret is : \"+HexUtil.bytesToHex(computedExponential) +\" for \" + pn);\n\t\t\n\t\t/* 0 is the outgoing key for the initiator, 7 for the responder */\n\t\tbyte[] outgoingKey = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"7\");\n\t\tbyte[] incommingKey = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"0\");\n\t\tbyte[] Ke = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"1\");\n\t\tbyte[] Ka = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"2\");\n\n\t\tbyte[] hmacKey = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"3\");\n\t\tbyte[] ivKey = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"4\");\n\t\tbyte[] ivNonce = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"5\");\n\n\t\t/* Bytes  1-4:  Initial sequence number for the initiator\n\t\t * Bytes  5-8:  Initial sequence number for the responder\n\t\t * Bytes  9-12: Initial message id for the initiator\n\t\t * Bytes 13-16: Initial message id for the responder\n\t\t * Note that we are the responder */\n\t\tbyte[] sharedData = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"6\");\n\t\tint theirInitialSeqNum = ((sharedData[0] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[1] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[2] & 0xFF) << 8)\n\t\t\t\t| (sharedData[3] & 0xFF);\n\t\tint ourInitialSeqNum = ((sharedData[4] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[5] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[6] & 0xFF) << 8)\n\t\t\t\t| (sharedData[7] & 0xFF);\n\t\tint theirInitialMsgID, ourInitialMsgID;\n\t\tif(negType >= 7) {\n\t\t\ttheirInitialMsgID =\n\t\t\t\tunknownInitiator ? getInitialMessageID(crypto.myIdentity) :\n\t\t\t\t\tgetInitialMessageID(pn.identity, crypto.myIdentity);\n\t\t\tourInitialMsgID =\n\t\t\t\tunknownInitiator ? getInitialMessageID(crypto.myIdentity) :\n\t\t\t\t\tgetInitialMessageID(crypto.myIdentity, pn.identity);\n\t\t} else {\n\t\t\ttheirInitialMsgID= ((sharedData[8] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[9] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[10] & 0xFF) << 8)\n\t\t\t\t| (sharedData[11] & 0xFF);\n\t\t\tourInitialMsgID= ((sharedData[12] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[13] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[14] & 0xFF) << 8)\n\t\t\t\t| (sharedData[15] & 0xFF);\n\t\t}\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Their initial message ID: \"+theirInitialMsgID+\" ours \"+ourInitialMsgID);\n\n\t\tc.initialize(Ke);\n\t\tint ivLength = PCFBMode.lengthIV(c);\n\t\tint decypheredPayloadOffset = 0;\n\t\t// We compute the HMAC of (\"I\"+cyphertext) : the cyphertext includes the IV!\n\t\tbyte[] decypheredPayload = Arrays.copyOf(JFK_PREFIX_INITIATOR, JFK_PREFIX_INITIATOR.length + payload.length - inputOffset);\n\t\tdecypheredPayloadOffset += JFK_PREFIX_INITIATOR.length;\n\t\tSystem.arraycopy(payload, inputOffset, decypheredPayload, decypheredPayloadOffset, decypheredPayload.length-decypheredPayloadOffset);\n\t\tif(!HMAC.verifyWithSHA256(Ka, decypheredPayload, hmac)) {\n\t\t\tLogger.error(this, \"The inner-HMAC doesn't match; let's discard the packet JFK(3) - \"+pn);\n\t\t\treturn;\n\t\t}\n\n\t\tfinal PCFBMode pk = PCFBMode.create(c, decypheredPayload, decypheredPayloadOffset);\n\t\t// Get the IV\n\t\tdecypheredPayloadOffset += ivLength;\n\t\t// Decrypt the payload\n\t\tpk.blockDecipher(decypheredPayload, decypheredPayloadOffset, decypheredPayload.length-decypheredPayloadOffset);\n\t\t/*\n\t\t * DecipheredData Format:\n\t\t * Signature\n\t\t * Node Data (starting with BootID)\n\t\t */\n\t\tint sigLength = getSignatureLength(negType);\n\t\tbyte[] sig = new byte[sigLength];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, sig, 0, sigLength);\n\t\tdecypheredPayloadOffset += sigLength;\n\t\tbyte[] data = new byte[decypheredPayload.length - decypheredPayloadOffset];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, data, 0, decypheredPayload.length - decypheredPayloadOffset);\n\t\tint ptr = 0;\n\t\tlong trackerID;\n\t\ttrackerID = Fields.bytesToLong(data, ptr);\n\t\tif(trackerID < 0) trackerID = -1;\n\t\tptr += 8;\n\t\tlong bootID = Fields.bytesToLong(data, ptr);\n\t\tptr += 8;\n\t\tbyte[] hisRef = Arrays.copyOfRange(data, ptr, data.length);\n\n\t\t// construct the peernode\n\t\tif(unknownInitiator) {\n\t\t\tpn = getPeerNodeFromUnknownInitiator(hisRef, setupType, pn, replyTo);\n\t\t}\n\t\tif(pn == null) {\n\t\t\tif(unknownInitiator) {\n\t\t\t\t// Reject\n\t\t\t\tLogger.normal(this, \"Rejecting... unable to construct PeerNode\");\n\t\t\t} else {\n\t\t\t\tLogger.error(this, \"PeerNode is null and unknownInitiator is false!\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// verify the signature\n\t\tbyte[] toVerify = assembleDHParams(nonceInitiatorHashed, nonceResponder, initiatorExponential, responderExponential, crypto.myIdentity, data);\n\t\tif(negType < 9) {\n\t\t    byte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\t    System.arraycopy(sig, 0, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n            byte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n            System.arraycopy(sig, Node.SIGNATURE_PARAMETER_LENGTH, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\t    DSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t\t    if(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, SHA256.digest(toVerify)), false)) {\n\t\t        Logger.error(this, \"The signature verification has failed!! JFK(3) - \"+pn.getPeer());\n\t\t        return;\n\t\t    }\n\t\t} else {\n\t\t    if(!ECDSA.verify(Curves.P256, pn.peerECDSAPubKey, sig, toVerify)) {\n\t              Logger.error(this, \"The ECDSA signature verification has failed!! JFK(3) - \"+pn.getPeer());\n\t                return;\n\t\t    }\n\t\t}\n\n\t\t// At this point we know it's from the peer, so we can report a packet received.\n\t\tpn.receivedPacket(true, false);\n\n\t\tBlockCipher outgoingCipher = null;\n\t\tBlockCipher incommingCipher = null;\n\t\tBlockCipher ivCipher = null;\n\t\ttry {\n\t\t\toutgoingCipher = new Rijndael(256, 256);\n\t\t\tincommingCipher = new Rijndael(256, 256);\n\t\t\tivCipher = new Rijndael(256, 256);\n\t\t} catch (UnsupportedCipherException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\toutgoingCipher.initialize(outgoingKey);\n\t\tincommingCipher.initialize(incommingKey);\n\t\tivCipher.initialize(ivKey);\n\n\t\t// Promote if necessary\n\t\tboolean dontWant = false;\n\t\tif(oldOpennetPeer) {\n\t\t\tOpennetManager opennet = node.getOpennet();\n\t\t\tif(opennet == null) {\n\t\t\t\tLogger.normal(this, \"Dumping incoming old-opennet peer as opennet just turned off: \"+pn+\".\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/* When an old-opennet-peer connects, add it at the top of the LRU, so that it isn't\n\t\t\t * immediately dropped when there is no droppable peer to drop. If it was dropped\n\t\t\t * from the bottom of the LRU list, we would not have added it to the LRU; so it was\n\t\t\t * somewhere in the middle. */\n\t\t\tif(!opennet.wantPeer(pn, false, false, true, ConnectionType.RECONNECT)) {\n\t\t\t\tLogger.normal(this, \"No longer want peer \"+pn+\" - dumping it after connecting\");\n\t\t\t\tdontWant = true;\n\t\t\t\topennet.purgeOldOpennetPeer(pn);\n\t\t\t}\n\t\t\t// wantPeer will call node.peers.addPeer(), we don't have to.\n\t\t}\n\t\tif((!dontWant) && !crypto.allowConnection(pn, replyTo.getFreenetAddress())) {\n\t\t\tif(pn instanceof DarknetPeerNode) {\n\t\t\t\tLogger.error(this, \"Dropping peer \"+pn+\" because don't want connection due to others on the same IP address!\");\n\t\t\t\tSystem.out.println(\"Disconnecting permanently from your friend \\\"\"+((DarknetPeerNode)pn).getName()+\"\\\" because other peers are using the same IP address!\");\n\t\t\t}\n\t\t\tLogger.normal(this, \"Rejecting connection because already have something with the same IP\");\n\t\t\tdontWant = true;\n\t\t}\n\n\t\tlong newTrackerID = pn.completedHandshake(\n\t\t\t\tbootID, hisRef, 0, hisRef.length, outgoingCipher, outgoingKey, incommingCipher,\n\t\t\t\tincommingKey, replyTo, true, negType, trackerID, false, false, hmacKey, ivCipher,\n\t\t\t\tivNonce, ourInitialSeqNum, theirInitialSeqNum, ourInitialMsgID, theirInitialMsgID);\n\n\t\tif(newTrackerID > 0) {\n\n\t\t\t// Send reply\n\t\t\tsendJFKMessage4(1, negType, 3, nonceInitiatorHashed, nonceResponder,initiatorExponential, responderExponential,\n\t\t\t\t\tc, Ke, Ka, authenticator, hisRef, pn, replyTo, unknownInitiator, setupType, newTrackerID, newTrackerID == trackerID);\n\n\t\t\tif(dontWant) {\n\t\t\t\tnode.peers.disconnectAndRemove(pn, true, true, true); // Let it connect then tell it to remove it.\n\t\t\t} else {\n\t\t\t\tpn.maybeSendInitialMessages();\n\t\t\t}\n\t\t} else {\n\t\t\tLogger.error(this, \"Handshake failure! with \"+pn.getPeer());\n\t\t\t// Don't send the JFK(4). We have not successfully connected.\n\t\t}\n\n\t\tfinal long t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500) {\n\t\t\tLogger.error(this,\"Message3 Processing packet for \"+pn.getPeer()+\" took \"+TimeUtil.formatTime(t2-t1, 3, true));\n\t\t}\n\t}","commit_id":"3017e0ebd8985e53ee4f5fc40efcf2ba92c0b55c","url":"https://github.com/freenet/fred"},{"original_method":"private byte[] computeJFKSharedKey(byte[] exponential, byte[] nI, byte[] nR, String what) {\n\t\tassert(\"0\".equals(what) || \"1\".equals(what) || \"2\".equals(what) || \"3\".equals(what)\n\t\t\t\t|| \"4\".equals(what) || \"5\".equals(what) || \"6\".equals(what) || \"7\".equals(what));\n\t\tbyte[] number = null;\n\t\ttry {\n\t\t\tnumber = what.getBytes(\"UTF-8\");\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\tthrow new Error(\"Impossible: JVM doesn't support UTF-8: \" + e, e);\n\t\t}\n\n\t\tbyte[] toHash = new byte[NONCE_SIZE * 2 + number.length];\n\t\tint offset = 0;\n\t\tSystem.arraycopy(nI, 0, toHash, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\tSystem.arraycopy(nR, 0, toHash, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\tSystem.arraycopy(number, 0, toHash, offset, number.length);\n\n\t\treturn HMAC.macWithSHA256(exponential, toHash, HASH_LENGTH);\n\t}","id":99720,"modified_method":"private byte[] computeJFKSharedKey(byte[] exponential, byte[] nI, byte[] nR, String what) {\n\t\tassert(\"0\".equals(what) || \"1\".equals(what) || \"2\".equals(what) || \"3\".equals(what)\n\t\t\t\t|| \"4\".equals(what) || \"5\".equals(what) || \"6\".equals(what) || \"7\".equals(what));\n\t\tbyte[] number = null;\n\t\ttry {\n\t\t\tnumber = what.getBytes(\"UTF-8\");\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\tthrow new Error(\"Impossible: JVM doesn't support UTF-8: \" + e, e);\n\t\t}\n\n\t\tbyte[] toHash = new byte[nI.length + nR.length + number.length];\n\t\tint offset = 0;\n\t\tSystem.arraycopy(nI, 0, toHash, offset, nI.length);\n\t\toffset += nI.length;\n\t\tSystem.arraycopy(nR, 0, toHash, offset, nR.length);\n\t\toffset += nR.length;\n\t\tSystem.arraycopy(number, 0, toHash, offset, number.length);\n\n\t\treturn HMAC.macWithSHA256(exponential, toHash, HASH_LENGTH);\n\t}","commit_id":"3017e0ebd8985e53ee4f5fc40efcf2ba92c0b55c","url":"https://github.com/freenet/fred"},{"original_method":"private void sendJFKMessage2(byte[] nonceInitator, byte[] hisExponential, PeerNode pn, Peer replyTo, boolean unknownInitiator, int setupType, int negType) throws NoContextsException {\n\t\tif(logMINOR) Logger.minor(this, \"Sending a JFK(2) message to \"+pn);\n\t\tint modulusLength = getModulusLength(negType);\n\n\t\t// g^r\n\t    DiffieHellmanLightContext dhLctx = getLightDiffieHellmanContext();\n\t    ECDHLightContext ecdhLctx = getECDHLightContext();\n\t\t    \n\t\t// Nr\n\t\tbyte[] myNonce = new byte[NONCE_SIZE];\n\t\tnode.random.nextBytes(myNonce);\n\t    byte[] myExponential = (negType < 8 ? dhLctx : ecdhLctx).getPublicKeyNetworkFormat();\n\t    byte[] sig = (negType < 9 ? dhLctx.dsaSig : ecdhLctx.ecdsaSig);\n\t    if(sig.length != getSignatureLength(negType))\n\t        throw new IllegalStateException(\"This shouldn't happen: please report! We are attempting to send \"+sig.length+\" bytes of signature in JFK2! \"+pn.getPeer());\n\t    byte[] authenticator = HMAC.macWithSHA256(getTransientKey(),assembleJFKAuthenticator(myExponential, hisExponential, myNonce, nonceInitator, replyTo.getAddress().getAddress()), HASH_LENGTH);\n\t\tif(logMINOR) Logger.minor(this, \"We are using the following HMAC : \" + HexUtil.bytesToHex(authenticator));\n        if(logMINOR) Logger.minor(this, \"We have Ni' : \" + HexUtil.bytesToHex(nonceInitator));\n\t\tbyte[] message2 = new byte[nonceInitator.length + NONCE_SIZE+modulusLength+\n\t\t                           sig.length+\n\t\t                           HASH_LENGTH];\n\n\t\tint offset = 0;\n\t\tSystem.arraycopy(nonceInitator, 0, message2, offset, nonceInitator.length);\n\t\toffset += nonceInitator.length;\n\t\tSystem.arraycopy(myNonce, 0, message2, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\tSystem.arraycopy(myExponential, 0, message2, offset, modulusLength);\n\t\toffset += modulusLength;\n\n\t    System.arraycopy(sig, 0, message2, offset, sig.length);\n\t    offset += sig.length;\n\t\t\n\t\tSystem.arraycopy(authenticator, 0, message2, offset, HASH_LENGTH);\n\n\t\tif(unknownInitiator) {\n\t\t\tsendAnonAuthPacket(1,negType,1,setupType,message2,pn,replyTo,crypto.anonSetupCipher);\n\t\t} else {\n\t\t\tsendAuthPacket(1,negType,1,message2,pn,replyTo);\n\t\t}\n\t}","id":99721,"modified_method":"private void sendJFKMessage2(byte[] nonceInitator, byte[] hisExponential, PeerNode pn, Peer replyTo, boolean unknownInitiator, int setupType, int negType) throws NoContextsException {\n\t\tif(logMINOR) Logger.minor(this, \"Sending a JFK(2) message to \"+pn);\n\t\tint modulusLength = getModulusLength(negType);\n\t\tint nonceSize = getNonceSize(negType);\n\t\t// g^r\n\t    DiffieHellmanLightContext dhLctx = getLightDiffieHellmanContext();\n\t    ECDHLightContext ecdhLctx = getECDHLightContext();\n\t\t    \n\t\t// Nr\n\t\tbyte[] myNonce = new byte[nonceSize];\n\t\tnode.random.nextBytes(myNonce);\n\t    byte[] myExponential = (negType < 8 ? dhLctx : ecdhLctx).getPublicKeyNetworkFormat();\n\t    byte[] sig = (negType < 9 ? dhLctx.dsaSig : ecdhLctx.ecdsaSig);\n\t    if(sig.length != getSignatureLength(negType))\n\t        throw new IllegalStateException(\"This shouldn't happen: please report! We are attempting to send \"+sig.length+\" bytes of signature in JFK2! \"+pn.getPeer());\n\t    byte[] authenticator = HMAC.macWithSHA256(getTransientKey(),assembleJFKAuthenticator(myExponential, hisExponential, myNonce, nonceInitator, replyTo.getAddress().getAddress()), HASH_LENGTH);\n\t\tif(logMINOR) Logger.minor(this, \"We are using the following HMAC : \" + HexUtil.bytesToHex(authenticator));\n        if(logMINOR) Logger.minor(this, \"We have Ni' : \" + HexUtil.bytesToHex(nonceInitator));\n\t\tbyte[] message2 = new byte[nonceInitator.length + nonceSize+modulusLength+\n\t\t                           sig.length+\n\t\t                           HASH_LENGTH];\n\n\t\tint offset = 0;\n\t\tSystem.arraycopy(nonceInitator, 0, message2, offset, nonceInitator.length);\n\t\toffset += nonceInitator.length;\n\t\tSystem.arraycopy(myNonce, 0, message2, offset, myNonce.length);\n\t\toffset += myNonce.length;\n\t\tSystem.arraycopy(myExponential, 0, message2, offset, modulusLength);\n\t\toffset += modulusLength;\n\n\t    System.arraycopy(sig, 0, message2, offset, sig.length);\n\t    offset += sig.length;\n\t\t\n\t\tSystem.arraycopy(authenticator, 0, message2, offset, HASH_LENGTH);\n\n\t\tif(unknownInitiator) {\n\t\t\tsendAnonAuthPacket(1,negType,1,setupType,message2,pn,replyTo,crypto.anonSetupCipher);\n\t\t} else {\n\t\t\tsendAuthPacket(1,negType,1,message2,pn,replyTo);\n\t\t}\n\t}","commit_id":"3017e0ebd8985e53ee4f5fc40efcf2ba92c0b55c","url":"https://github.com/freenet/fred"},{"original_method":"private void processJFKMessage1(byte[] payload,int offset,PeerNode pn,Peer replyTo, boolean unknownInitiator, int setupType, int negType)\n\t{\n\t\tlong t1=System.currentTimeMillis();\n\t\tint modulusLength = getModulusLength(negType);\n\t\t// Pre negtype 9 we were sending Ni as opposed to Ni'\n\t\tint nonceSize = (negType > 8 ? SHA256.getDigestLength() : NONCE_SIZE);\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(1) message, processing it - \"+pn);\n\t\t// FIXME: follow the spec and send IDr' ?\n\t\tif(payload.length < nonceSize + modulusLength + 3 + (unknownInitiator ? NodeCrypto.IDENTITY_LENGTH : 0)) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn+\": \"+payload.length+\" after decryption in JFK(1), should be \"+(NONCE_SIZE + modulusLength));\n\t\t\treturn;\n\t\t}\n\t\t// get Ni\n\t\tbyte[] nonceInitiator = new byte[nonceSize]; \n\t\tSystem.arraycopy(payload, offset, nonceInitiator, 0, nonceSize);\n\t\toffset += nonceSize;\n\n\t\t// get g^i\n\t\tbyte[] hisExponential = Arrays.copyOfRange(payload, offset, offset + modulusLength);\n\t\tif(unknownInitiator) {\n\t\t\t// Check IDr'\n\t\t\toffset += modulusLength;\n\t\t\tbyte[] expectedIdentityHash = Arrays.copyOfRange(payload, offset, offset + NodeCrypto.IDENTITY_LENGTH);\n\t\t\tif(!Arrays.equals(expectedIdentityHash, crypto.identityHash)) {\n\t\t\t\tLogger.error(this, \"Invalid unknown-initiator JFK(1), IDr' is \"+HexUtil.bytesToHex(expectedIdentityHash)+\" should be \"+HexUtil.bytesToHex(crypto.identityHash));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(throttleRekey(pn, replyTo)) return;\n\t\t   \n\n\t\tif(negType >= 8 || DiffieHellman.checkDHExponentialValidity(this.getClass(), new NativeBigInteger(1,hisExponential))) {\n\t\t\t// JFK protects us from weak key attacks on ECDH, so we don't need to check.\n\t\t    try {\n\t\t    \tsendJFKMessage2(nonceInitiator, hisExponential, pn, replyTo, unknownInitiator, setupType, negType);\n\t\t    } catch (NoContextsException e) {\n\t\t    \thandleNoContextsException(e, NoContextsException.CONTEXT.REPLYING);\n\t\t    \treturn;\n\t\t    }\n\t\t} else {\n\t\t    Logger.error(this, \"We can't accept the exponential \"+pn+\" sent us!! REDFLAG: IT CAN'T HAPPEN UNLESS AGAINST AN ACTIVE ATTACKER!!\");\n\t\t}\n\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500) {\n\t\t\tLogger.error(this,\"Message1 timeout error:Processing packet for \"+pn);\n\t\t}\n\t}","id":99722,"modified_method":"private void processJFKMessage1(byte[] payload,int offset,PeerNode pn,Peer replyTo, boolean unknownInitiator, int setupType, int negType)\n\t{\n\t\tlong t1=System.currentTimeMillis();\n\t\tint modulusLength = getModulusLength(negType);\n\t\t// Pre negtype 9 we were sending Ni as opposed to Ni'\n\t\tint nonceSize = (negType < 9 ? getNonceSize(negType) : HASH_LENGTH);\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(1) message, processing it - \"+pn);\n\t\t// FIXME: follow the spec and send IDr' ?\n\t\tif(payload.length < nonceSize + modulusLength + 3 + (unknownInitiator ? NodeCrypto.IDENTITY_LENGTH : 0)) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn+\": \"+payload.length+\" after decryption in JFK(1), should be \"+(nonceSize + modulusLength));\n\t\t\treturn;\n\t\t}\n\t\t// get Ni'\n\t\tbyte[] nonceInitiator = new byte[nonceSize]; \n\t\tSystem.arraycopy(payload, offset, nonceInitiator, 0, nonceSize);\n\t\toffset += nonceSize;\n\n\t\t// get g^i\n\t\tbyte[] hisExponential = Arrays.copyOfRange(payload, offset, offset + modulusLength);\n\t\tif(unknownInitiator) {\n\t\t\t// Check IDr'\n\t\t\toffset += modulusLength;\n\t\t\tbyte[] expectedIdentityHash = Arrays.copyOfRange(payload, offset, offset + NodeCrypto.IDENTITY_LENGTH);\n\t\t\tif(!Arrays.equals(expectedIdentityHash, crypto.identityHash)) {\n\t\t\t\tLogger.error(this, \"Invalid unknown-initiator JFK(1), IDr' is \"+HexUtil.bytesToHex(expectedIdentityHash)+\" should be \"+HexUtil.bytesToHex(crypto.identityHash));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(throttleRekey(pn, replyTo)) return;\n\t\t   \n\n\t\tif(negType >= 8 || DiffieHellman.checkDHExponentialValidity(this.getClass(), new NativeBigInteger(1,hisExponential))) {\n\t\t\t// JFK protects us from weak key attacks on ECDH, so we don't need to check.\n\t\t    try {\n\t\t    \tsendJFKMessage2(nonceInitiator, hisExponential, pn, replyTo, unknownInitiator, setupType, negType);\n\t\t    } catch (NoContextsException e) {\n\t\t    \thandleNoContextsException(e, NoContextsException.CONTEXT.REPLYING);\n\t\t    \treturn;\n\t\t    }\n\t\t} else {\n\t\t    Logger.error(this, \"We can't accept the exponential \"+pn+\" sent us!! REDFLAG: IT CAN'T HAPPEN UNLESS AGAINST AN ACTIVE ATTACKER!!\");\n\t\t}\n\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500) {\n\t\t\tLogger.error(this,\"Message1 timeout error:Processing packet for \"+pn);\n\t\t}\n\t}","commit_id":"3017e0ebd8985e53ee4f5fc40efcf2ba92c0b55c","url":"https://github.com/freenet/fred"},{"original_method":"private void sendJFKMessage1(PeerNode pn, Peer replyTo, boolean unknownInitiator, int setupType, int negType) throws NoContextsException {\n\t\tif(logMINOR) Logger.minor(this, \"Sending a JFK(1) message to \"+replyTo+\" for \"+pn.getPeer());\n\t\tfinal long now = System.currentTimeMillis();\n\t\tint modulusLength = getModulusLength(negType);\n        // Pre negtype 9 we were sending Ni as opposed to Ni'\n        int nonceSize = (negType > 8 ? SHA256.getDigestLength() : NONCE_SIZE);\n\t\t\n\t\tKeyAgreementSchemeContext ctx = pn.getKeyAgreementSchemeContext();\n\t\tif(negType < 8) { // Legacy DH\n\t\t    if((ctx == null) || !(ctx instanceof DiffieHellmanLightContext) || ((pn.jfkContextLifetime + DH_GENERATION_INTERVAL*DH_CONTEXT_BUFFER_SIZE) < now)) {\n\t\t\t    pn.jfkContextLifetime = now;\n\t\t\t    pn.setKeyAgreementSchemeContext(ctx = getLightDiffieHellmanContext());\n\t\t    }\n\t\t} else {\n            if((ctx == null) || !(ctx instanceof ECDHLightContext) || ((pn.jfkContextLifetime + DH_GENERATION_INTERVAL*DH_CONTEXT_BUFFER_SIZE) < now)) {\n                pn.jfkContextLifetime = now;\n                pn.setKeyAgreementSchemeContext(ctx = getECDHLightContext());\n            }\n\t\t}\n\t\t\n\t\tint offset = 0;\n\t\tbyte[] nonce = new byte[NONCE_SIZE];\n\t\tbyte[] myExponential = ctx.getPublicKeyNetworkFormat();\n\t\tnode.random.nextBytes(nonce);\n\n\t\tsynchronized (pn) {\n\t\t\tpn.jfkNoncesSent.add(nonce);\n\t\t\tif(pn.jfkNoncesSent.size() > MAX_NONCES_PER_PEER)\n\t\t\t\tpn.jfkNoncesSent.removeFirst();\n\t\t}\n\n\t\tbyte[] message1 = new byte[nonceSize+modulusLength+(unknownInitiator ? NodeCrypto.IDENTITY_LENGTH : 0)];\n\n\t\tSystem.arraycopy((negType > 8 ? SHA256.digest(nonce) : nonce), 0, message1, offset, nonceSize);\n\t\toffset += nonceSize;\n\t\tSystem.arraycopy(myExponential, 0, message1, offset, modulusLength);\n\n\t\tif(unknownInitiator) {\n\t\t\toffset += modulusLength;\n\t\t\tSystem.arraycopy(pn.identityHash, 0, message1, offset, pn.identityHash.length);\n\t\t\tsendAnonAuthPacket(1,negType,0,setupType,message1,pn,replyTo,pn.anonymousInitiatorSetupCipher);\n\t\t} else {\n\t\t\tsendAuthPacket(1,negType,0,message1,pn,replyTo);\n\t\t}\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-now)>500) {\n\t\t\tLogger.error(this,\"Message1 timeout error:Sending packet for \"+pn.getPeer());\n\t\t}\n\t}","id":99723,"modified_method":"private void sendJFKMessage1(PeerNode pn, Peer replyTo, boolean unknownInitiator, int setupType, int negType) throws NoContextsException {\n\t\tif(logMINOR) Logger.minor(this, \"Sending a JFK(1) message to \"+replyTo+\" for \"+pn.getPeer());\n\t\tfinal long now = System.currentTimeMillis();\n\t\tint modulusLength = getModulusLength(negType);\n        // Pre negtype 9 we were sending Ni as opposed to Ni'\n        int nonceSize = getNonceSize(negType);\n\t\t\n\t\tKeyAgreementSchemeContext ctx = pn.getKeyAgreementSchemeContext();\n\t\tif(negType < 8) { // Legacy DH\n\t\t    if((ctx == null) || !(ctx instanceof DiffieHellmanLightContext) || ((pn.jfkContextLifetime + DH_GENERATION_INTERVAL*DH_CONTEXT_BUFFER_SIZE) < now)) {\n\t\t\t    pn.jfkContextLifetime = now;\n\t\t\t    pn.setKeyAgreementSchemeContext(ctx = getLightDiffieHellmanContext());\n\t\t    }\n\t\t} else {\n            if((ctx == null) || !(ctx instanceof ECDHLightContext) || ((pn.jfkContextLifetime + DH_GENERATION_INTERVAL*DH_CONTEXT_BUFFER_SIZE) < now)) {\n                pn.jfkContextLifetime = now;\n                pn.setKeyAgreementSchemeContext(ctx = getECDHLightContext());\n            }\n\t\t}\n\t\t\n\t\tint offset = 0;\n\t\tbyte[] nonce = new byte[nonceSize];\n\t\tbyte[] myExponential = ctx.getPublicKeyNetworkFormat();\n\t\tnode.random.nextBytes(nonce);\n\n\t\tsynchronized (pn) {\n\t\t\tpn.jfkNoncesSent.add(nonce);\n\t\t\tif(pn.jfkNoncesSent.size() > MAX_NONCES_PER_PEER)\n\t\t\t\tpn.jfkNoncesSent.removeFirst();\n\t\t}\n\n\t\tint nonceSizeHashed = (negType > 8 ? HASH_LENGTH : nonceSize);\n\t\tbyte[] message1 = new byte[nonceSizeHashed+modulusLength+(unknownInitiator ? NodeCrypto.IDENTITY_LENGTH : 0)];\n\n\t\tSystem.arraycopy((negType > 8 ? SHA256.digest(nonce) : nonce), 0, message1, offset, nonceSizeHashed);\n\t\toffset += nonceSizeHashed;\n\t\tSystem.arraycopy(myExponential, 0, message1, offset, modulusLength);\n\n\t\tif(unknownInitiator) {\n\t\t\toffset += modulusLength;\n\t\t\tSystem.arraycopy(pn.identityHash, 0, message1, offset, pn.identityHash.length);\n\t\t\tsendAnonAuthPacket(1,negType,0,setupType,message1,pn,replyTo,pn.anonymousInitiatorSetupCipher);\n\t\t} else {\n\t\t\tsendAuthPacket(1,negType,0,message1,pn,replyTo);\n\t\t}\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-now)>500) {\n\t\t\tLogger.error(this,\"Message1 timeout error:Sending packet for \"+pn.getPeer());\n\t\t}\n\t}","commit_id":"3017e0ebd8985e53ee4f5fc40efcf2ba92c0b55c","url":"https://github.com/freenet/fred"},{"original_method":"private void processJFKMessage2(byte[] payload,int inputOffset,PeerNode pn,Peer replyTo, boolean unknownInitiator, int setupType, int negType)\n\t{\n\t\tlong t1=System.currentTimeMillis();\n\t\tint modulusLength = getModulusLength(negType);\n\t\t// Pre negtype 9 we were sending Ni as opposed to Ni'\n\t\tint nonceSize = (negType > 8 ? SHA256.getDigestLength() : NONCE_SIZE);\n\t\t\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(2) message, processing it - \"+pn.getPeer());\n\t\t// FIXME: follow the spec and send IDr' ?\n\t\tint expectedLength = nonceSize + NONCE_SIZE + modulusLength + HASH_LENGTH*2;\n\t\tif(payload.length < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn.getPeer()+\": \"+payload.length+\" after decryption in JFK(2), should be \"+(expectedLength + 3));\n\t\t\treturn;\n\t\t}\n\n\t\tbyte[] nonceInitiator = new byte[nonceSize];\n\t\tSystem.arraycopy(payload, inputOffset, nonceInitiator, 0, nonceSize);\n\t\tinputOffset += nonceSize;\n\t\tbyte[] nonceResponder = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceResponder, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\n\t\tbyte[] hisExponential = Arrays.copyOfRange(payload, inputOffset, inputOffset+modulusLength);\n\t\tinputOffset += modulusLength;\n\n\t\tint sigLength = getSignatureLength(negType);\n\t\tbyte[] sig = new byte[sigLength];\n\t\tSystem.arraycopy(payload, inputOffset, sig, 0, sigLength);\n\t\tinputOffset += sigLength;\n\n\t\tbyte[] authenticator = Arrays.copyOfRange(payload, inputOffset, inputOffset + HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\n\t\t// Check try to find the authenticator in the cache.\n\t\t// If authenticator is already present, indicates duplicate/replayed message2\n\t\t// Now simply transmit the corresponding message3\n\t\tObject message3 = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tmessage3 = authenticatorCache.get(new ByteArrayWrapper(authenticator));\n\t\t}\n\t\tif(message3 != null) {\n\t\t\tLogger.normal(this, \"We replayed a message from the cache (shouldn't happen often) - \"+pn.getPeer());\n\t\t\tsendAuthPacket(1, negType, 3, (byte[]) message3, pn, replyTo);\n\t\t\treturn;\n\t\t}\n\n\t\t// sanity check\n\t\tbyte[] myNi = null;\n\t\tsynchronized (pn) {\n\t\t\tfor(byte[] buf : pn.jfkNoncesSent) {\n\t\t\t\tif(Arrays.equals((negType > 8 ?  SHA256.digest(buf) : buf), nonceInitiator))\n\t\t\t\t\tmyNi = buf;\n\t\t\t}\n\t\t}\n\t\t// We don't except such a message;\n\t\tif(myNi == null) {\n\t\t\tif(shouldLogErrorInHandshake(t1)) {\n\t\t\t\tLogger.normal(this, \"We received an unexpected JFK(2) message from \"+pn.getPeer()+\" (time since added: \"+pn.timeSinceAddedOrRestarted()+\" time last receive:\"+pn.lastReceivedPacketTime()+')');\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif(negType < 8) { // legacy DH\n\t\t    NativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\t\t    if(!DiffieHellman.checkDHExponentialValidity(this.getClass(), _hisExponential)) {\n\t\t        Logger.error(this, \"We can't accept the exponential \"+pn.getPeer()+\" sent us!! REDFLAG: IT CAN'T HAPPEN UNLESS AGAINST AN ACTIVE ATTACKER!!\");\n\t\t        return;\n\t\t    }\n\t\t\t// JFK protects us from weak key attacks on ECDH, so we don't need to check.\n\t\t}\n\n\t\tif(negType < 9) {\n\t\t    // Verify the DSA signature\n\t\t    byte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\t    byte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\t    System.arraycopy(sig, 0, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\t    System.arraycopy(sig, Node.SIGNATURE_PARAMETER_LENGTH, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\t    DSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t\t    // At that point we don't know if it's \"him\"; let's check it out\n\t\t    byte[] locallyExpectedExponentials =  assembleDHParams(hisExponential, pn.peerCryptoGroup);\n\n\t\t    if(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, SHA256.digest(locallyExpectedExponentials)), false)) {\n\t\t        Logger.error(this, \"The signature verification has failed in JFK(2)!! \"+pn.getPeer());\n\t\t        return;\n\t\t    }\n\t\t} else {\n\t\t    // Verify the ECDSA signature ; We are assuming that it's the curve we expect\n\t\t    if(!ECDSA.verify(Curves.P256, pn.peerECDSAPubKey, sig, hisExponential)) {\n\t              Logger.error(this, \"The ECDSA signature verification has failed in JFK(2)!! \"+pn.getPeer());\n\t              return;\n\t\t    }\n\t\t}\n\n\t\t// At this point we know it's from the peer, so we can report a packet received.\n\t\tpn.receivedPacket(true, false);\n\n\t\tsendJFKMessage3(1, negType, 3, myNi, nonceResponder, hisExponential, authenticator, pn, replyTo, unknownInitiator, setupType);\n\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500) {\n\t\t\tLogger.error(this,\"Message2 timeout error:Processing packet for \"+pn.getPeer());\n\t\t}\n\t}","id":99724,"modified_method":"private void processJFKMessage2(byte[] payload,int inputOffset,PeerNode pn,Peer replyTo, boolean unknownInitiator, int setupType, int negType)\n\t{\n\t\tlong t1=System.currentTimeMillis();\n\t\tint modulusLength = getModulusLength(negType);\n\t\t// Pre negtype 9 we were sending Ni as opposed to Ni'\n\t\tint nonceSize = getNonceSize(negType);\n\t\tint nonceSizeHashed = (negType > 8 ? HASH_LENGTH : nonceSize);\n\t\t\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(2) message, processing it - \"+pn.getPeer());\n\t\t// FIXME: follow the spec and send IDr' ?\n\t\tint expectedLength = nonceSizeHashed + nonceSize + modulusLength + HASH_LENGTH*2;\n\t\tif(payload.length < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn.getPeer()+\": \"+payload.length+\" after decryption in JFK(2), should be \"+(expectedLength + 3));\n\t\t\treturn;\n\t\t}\n\n\t\tbyte[] nonceInitiator = new byte[nonceSizeHashed];\n\t\tSystem.arraycopy(payload, inputOffset, nonceInitiator, 0, nonceSizeHashed);\n\t\tinputOffset += nonceSizeHashed;\n\t\tbyte[] nonceResponder = new byte[nonceSize];\n\t\tSystem.arraycopy(payload, inputOffset, nonceResponder, 0, nonceSize);\n\t\tinputOffset += nonceSize;\n\n\t\tbyte[] hisExponential = Arrays.copyOfRange(payload, inputOffset, inputOffset+modulusLength);\n\t\tinputOffset += modulusLength;\n\n\t\tint sigLength = getSignatureLength(negType);\n\t\tbyte[] sig = new byte[sigLength];\n\t\tSystem.arraycopy(payload, inputOffset, sig, 0, sigLength);\n\t\tinputOffset += sigLength;\n\n\t\tbyte[] authenticator = Arrays.copyOfRange(payload, inputOffset, inputOffset + HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\n\t\t// Check try to find the authenticator in the cache.\n\t\t// If authenticator is already present, indicates duplicate/replayed message2\n\t\t// Now simply transmit the corresponding message3\n\t\tObject message3 = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tmessage3 = authenticatorCache.get(new ByteArrayWrapper(authenticator));\n\t\t}\n\t\tif(message3 != null) {\n\t\t\tLogger.normal(this, \"We replayed a message from the cache (shouldn't happen often) - \"+pn.getPeer());\n\t\t\tsendAuthPacket(1, negType, 3, (byte[]) message3, pn, replyTo);\n\t\t\treturn;\n\t\t}\n\n\t\t// sanity check\n\t\tbyte[] myNi = null;\n\t\tsynchronized (pn) {\n\t\t\tfor(byte[] buf : pn.jfkNoncesSent) {\n\t\t\t\tif(Arrays.equals((negType > 8 ?  SHA256.digest(buf) : buf), nonceInitiator))\n\t\t\t\t\tmyNi = buf;\n\t\t\t}\n\t\t}\n\t\t// We don't except such a message;\n\t\tif(myNi == null) {\n\t\t\tif(shouldLogErrorInHandshake(t1)) {\n\t\t\t\tLogger.normal(this, \"We received an unexpected JFK(2) message from \"+pn.getPeer()+\" (time since added: \"+pn.timeSinceAddedOrRestarted()+\" time last receive:\"+pn.lastReceivedPacketTime()+')');\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif(negType < 8) { // legacy DH\n\t\t    NativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\t\t    if(!DiffieHellman.checkDHExponentialValidity(this.getClass(), _hisExponential)) {\n\t\t        Logger.error(this, \"We can't accept the exponential \"+pn.getPeer()+\" sent us!! REDFLAG: IT CAN'T HAPPEN UNLESS AGAINST AN ACTIVE ATTACKER!!\");\n\t\t        return;\n\t\t    }\n\t\t\t// JFK protects us from weak key attacks on ECDH, so we don't need to check.\n\t\t}\n\n\t\tif(negType < 9) {\n\t\t    // Verify the DSA signature\n\t\t    byte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\t    byte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\t    System.arraycopy(sig, 0, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\t    System.arraycopy(sig, Node.SIGNATURE_PARAMETER_LENGTH, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\t    DSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t\t    // At that point we don't know if it's \"him\"; let's check it out\n\t\t    byte[] locallyExpectedExponentials =  assembleDHParams(hisExponential, pn.peerCryptoGroup);\n\n\t\t    if(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, SHA256.digest(locallyExpectedExponentials)), false)) {\n\t\t        Logger.error(this, \"The signature verification has failed in JFK(2)!! \"+pn.getPeer());\n\t\t        return;\n\t\t    }\n\t\t} else {\n\t\t    // Verify the ECDSA signature ; We are assuming that it's the curve we expect\n\t\t    if(!ECDSA.verify(Curves.P256, pn.peerECDSAPubKey, sig, hisExponential)) {\n\t              Logger.error(this, \"The ECDSA signature verification has failed in JFK(2)!! \"+pn.getPeer());\n\t              return;\n\t\t    }\n\t\t}\n\n\t\t// At this point we know it's from the peer, so we can report a packet received.\n\t\tpn.receivedPacket(true, false);\n\n\t\tsendJFKMessage3(1, negType, 3, myNi, nonceResponder, hisExponential, authenticator, pn, replyTo, unknownInitiator, setupType);\n\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500) {\n\t\t\tLogger.error(this,\"Message2 timeout error:Processing packet for \"+pn.getPeer());\n\t\t}\n\t}","commit_id":"3017e0ebd8985e53ee4f5fc40efcf2ba92c0b55c","url":"https://github.com/freenet/fred"},{"original_method":"private void sendJFKMessage3(int version,final int negType,int phase,byte[] nonceInitiator,byte[] nonceResponder,byte[] hisExponential, byte[] authenticator, final PeerNode pn, final Peer replyTo, final boolean unknownInitiator, final int setupType)\n\t{\n\t\tif(logMINOR) Logger.minor(this, \"Sending a JFK(3) message to \"+pn.getPeer());\n\t\tint modulusLength = getModulusLength(negType);\n\t\tint signLength = getSignatureLength(negType);\n        // Pre negtype 9 we were sending Ni as opposed to Ni'\n        byte[] nonceInitiatorHashed = (negType > 8 ? SHA256.digest(nonceInitiator) : nonceInitiator);\n        \n\t\tlong t1=System.currentTimeMillis();\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) { throw new RuntimeException(e); }\n\t\tKeyAgreementSchemeContext ctx = pn.getKeyAgreementSchemeContext();\n\t\tif(ctx == null) return;\n\t\tbyte[] ourExponential = ctx.getPublicKeyNetworkFormat();\n\t\tpn.jfkMyRef = unknownInitiator ? crypto.myCompressedHeavySetupRef() : crypto.myCompressedSetupRef();\n\t\tbyte[] data = new byte[8 + 8 + pn.jfkMyRef.length];\n\t\tint ptr = 0;\n\t\tlong trackerID;\n\t\ttrackerID = pn.getReusableTrackerID();\n\t\tSystem.arraycopy(Fields.longToBytes(trackerID), 0, data, ptr, 8);\n\t\tptr += 8;\n\t\tif(logMINOR) Logger.minor(this, \"Sending tracker ID \"+trackerID+\" in JFK(3)\");\n\t\tSystem.arraycopy(Fields.longToBytes(pn.getOutgoingBootID()), 0, data, ptr, 8);\n\t\tptr += 8;\n\t\tSystem.arraycopy(pn.jfkMyRef, 0, data, ptr, pn.jfkMyRef.length);\n\t\tfinal byte[] message3 = new byte[NONCE_SIZE*2 + // nI, nR\n\t\t                           modulusLength*2 + // g^i, g^r\n\t\t                           HASH_LENGTH + // authenticator\n\t\t                           HASH_LENGTH + // HMAC(cyphertext)\n\t\t                           (c.getBlockSize() >> 3) + // IV\n\t\t                           signLength + // Signature\n\t\t                           data.length]; // The bootid+noderef\n\t\tint offset = 0;\n\t\t// Ni\n\t\tSystem.arraycopy(nonceInitiator, 0, message3, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\tif(logMINOR) Logger.minor(this, \"We are sending Ni : \" + HexUtil.bytesToHex(nonceInitiator));\n\t\t// Nr\n\t\tSystem.arraycopy(nonceResponder, 0, message3, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\t// g^i\n\t\tSystem.arraycopy(ourExponential, 0,message3, offset, ourExponential.length);\n\t\toffset += ourExponential.length;\n\t\t// g^r\n\t\tSystem.arraycopy(hisExponential, 0,message3, offset, hisExponential.length);\n\t\toffset += hisExponential.length;\n\n\t\t// Authenticator\n\t\tSystem.arraycopy(authenticator, 0, message3, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\t/*\n\t\t * Digital Signature of the message with the private key belonging to the initiator/responder\n\t\t * It is assumed to be non-message recovering\n\t\t */\n\t\t// save parameters so that we can verify message4\n\t\tbyte[] toSign = assembleDHParams(nonceInitiatorHashed, nonceResponder, ourExponential, hisExponential, pn.identity, data);\n\t\tpn.setJFKBuffer(toSign);\n\t\tbyte[] sig = (negType < 9 ? crypto.sign(SHA256.digest(toSign)) : crypto.ecdsaSign(toSign));\n\n\t\tbyte[] computedExponential;\n\t\tif (negType < 8 ) { // Legacy DH\n\t\t    NativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\t\t    computedExponential= ((DiffieHellmanLightContext)ctx).getHMACKey(_hisExponential);\n\t\t}else {\n\t\t    computedExponential = ((ECDHLightContext)ctx).getHMACKey(ECDH.getPublicKey(hisExponential, ecdhCurveToUse)).getEncoded();\n\t\t}\n\t\tif(logDEBUG) Logger.debug(this, \"The shared Master secret is : \"+HexUtil.bytesToHex(computedExponential)+ \" for \" + pn);\n\t\t/* 0 is the outgoing key for the initiator, 7 for the responder */\n\t\tpn.outgoingKey = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"0\");\n\t\tpn.incommingKey = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"7\");\n\t\tpn.jfkKe = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"1\");\n\t\tpn.jfkKa = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"2\");\n\n\t\tpn.hmacKey = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"3\");\n\t\tpn.ivKey = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"4\");\n\t\tpn.ivNonce = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"5\");\n\n\t\t/* Bytes  1-4:  Initial sequence number for the initiator\n\t\t * Bytes  5-8:  Initial sequence number for the responder\n\t\t * Bytes  9-12: Initial message id for the initiator\n\t\t * Bytes 13-16: Initial message id for the responder\n\t\t * Note that we are the initiator */\n\t\tbyte[] sharedData = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"6\");\n\t\tpn.ourInitialSeqNum = ((sharedData[0] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[1] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[2] & 0xFF) << 8)\n\t\t\t\t| (sharedData[3] & 0xFF);\n\t\tpn.theirInitialSeqNum = ((sharedData[4] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[5] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[6] & 0xFF) << 8)\n\t\t\t\t| (sharedData[7] & 0xFF);\n\t\tif(negType >= 7) {\n\t\t\tpn.theirInitialMsgID =\n\t\t\t\tunknownInitiator ? getInitialMessageID(pn.identity) :\n\t\t\t\t\tgetInitialMessageID(pn.identity, crypto.myIdentity);\n\t\t\tpn.ourInitialMsgID =\n\t\t\t\tunknownInitiator ? getInitialMessageID(pn.identity) :\n\t\t\t\t\tgetInitialMessageID(crypto.myIdentity, pn.identity);\n\t\t} else {\n\t\t\tpn.ourInitialMsgID= ((sharedData[8] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[9] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[10] & 0xFF) << 8)\n\t\t\t\t| (sharedData[11] & 0xFF);\n\t\t\tpn.theirInitialMsgID= ((sharedData[12] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[13] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[14] & 0xFF) << 8)\n\t\t\t\t| (sharedData[15] & 0xFF);\n\t\t}\n\t\t\t\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Their initial message ID: \"+pn.theirInitialMsgID+\" ours \"+pn.ourInitialMsgID);\n\n\n\t\tc.initialize(pn.jfkKe);\n\t\tint ivLength = PCFBMode.lengthIV(c);\n\t\tbyte[] iv = new byte[ivLength];\n\t\tnode.random.nextBytes(iv);\n\t\tPCFBMode pcfb = PCFBMode.create(c, iv);\n\t\tint cleartextOffset = 0;\n\t\tbyte[] cleartext = new byte[JFK_PREFIX_INITIATOR.length + ivLength + sig.length + data.length];\n\t\tSystem.arraycopy(JFK_PREFIX_INITIATOR, 0, cleartext, cleartextOffset, JFK_PREFIX_INITIATOR.length);\n\t\tcleartextOffset += JFK_PREFIX_INITIATOR.length;\n\t\tSystem.arraycopy(iv, 0, cleartext, cleartextOffset, ivLength);\n\t\tcleartextOffset += ivLength;\n\t\tSystem.arraycopy(sig, 0, cleartext, cleartextOffset, sig.length);\n\t\tcleartextOffset += sig.length;\n\t\tSystem.arraycopy(data, 0, cleartext, cleartextOffset, data.length);\n\t\tcleartextOffset += data.length;\n\n\t\tint cleartextToEncypherOffset = JFK_PREFIX_INITIATOR.length + ivLength;\n\t\tpcfb.blockEncipher(cleartext, cleartextToEncypherOffset, cleartext.length-cleartextToEncypherOffset);\n\n\t\t// We compute the HMAC of (prefix + cyphertext) Includes the IV!\n\t\tbyte[] hmac = HMAC.macWithSHA256(pn.jfkKa, cleartext, HASH_LENGTH);\n\n\t\t// copy stuffs back to the message\n\t\tSystem.arraycopy(hmac, 0, message3, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\tSystem.arraycopy(iv, 0, message3, offset, ivLength);\n\t\toffset += ivLength;\n\t\tSystem.arraycopy(cleartext, cleartextToEncypherOffset, message3, offset, cleartext.length-cleartextToEncypherOffset);\n\n\t\t// cache the message\n\t\tsynchronized (authenticatorCache) {\n\t\t\tif(!maybeResetTransientKey())\n\t\t\t\tauthenticatorCache.put(new ByteArrayWrapper(authenticator),message3);\n\t\t}\n\t\tfinal long timeSent = System.currentTimeMillis();\n\t\tif(unknownInitiator) {\n\t\t\tsendAnonAuthPacket(1, negType, 2, setupType, message3, pn, replyTo, pn.anonymousInitiatorSetupCipher);\n\t\t} else {\n\t\t\tsendAuthPacket(1, negType, 2, message3, pn, replyTo);\n\t\t}\n\n\t\t/* Re-send the packet after 5sec if we don't get any reply */\n\t\tnode.getTicker().queueTimedJob(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tif(pn.timeLastConnectionCompleted() < timeSent) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Resending JFK(3) to \"+pn+\" for \"+node.getDarknetPortNumber());\n\t\t\t\t\tif(unknownInitiator) {\n\t\t\t\t\t\tsendAnonAuthPacket(1, negType, 2, setupType, message3, pn, replyTo, pn.anonymousInitiatorSetupCipher);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsendAuthPacket(1, negType, 2, message3, pn, replyTo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}, 5*1000);\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message3 timeout error:Sending packet for \"+pn.getPeer());\n\t}","id":99725,"modified_method":"private void sendJFKMessage3(int version,final int negType,int phase,byte[] nonceInitiator,byte[] nonceResponder,byte[] hisExponential, byte[] authenticator, final PeerNode pn, final Peer replyTo, final boolean unknownInitiator, final int setupType)\n\t{\n\t\tif(logMINOR) Logger.minor(this, \"Sending a JFK(3) message to \"+pn.getPeer());\n\t\tint modulusLength = getModulusLength(negType);\n\t\tint signLength = getSignatureLength(negType);\n\t\tint nonceSize = getNonceSize(negType);\n        // Pre negtype 9 we were sending Ni as opposed to Ni'\n        byte[] nonceInitiatorHashed = (negType > 8 ? SHA256.digest(nonceInitiator) : nonceInitiator);\n        \n\t\tlong t1=System.currentTimeMillis();\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) { throw new RuntimeException(e); }\n\t\tKeyAgreementSchemeContext ctx = pn.getKeyAgreementSchemeContext();\n\t\tif(ctx == null) return;\n\t\tbyte[] ourExponential = ctx.getPublicKeyNetworkFormat();\n\t\tpn.jfkMyRef = unknownInitiator ? crypto.myCompressedHeavySetupRef() : crypto.myCompressedSetupRef();\n\t\tbyte[] data = new byte[8 + 8 + pn.jfkMyRef.length];\n\t\tint ptr = 0;\n\t\tlong trackerID;\n\t\ttrackerID = pn.getReusableTrackerID();\n\t\tSystem.arraycopy(Fields.longToBytes(trackerID), 0, data, ptr, 8);\n\t\tptr += 8;\n\t\tif(logMINOR) Logger.minor(this, \"Sending tracker ID \"+trackerID+\" in JFK(3)\");\n\t\tSystem.arraycopy(Fields.longToBytes(pn.getOutgoingBootID()), 0, data, ptr, 8);\n\t\tptr += 8;\n\t\tSystem.arraycopy(pn.jfkMyRef, 0, data, ptr, pn.jfkMyRef.length);\n\t\tfinal byte[] message3 = new byte[nonceSize*2 + // nI, nR\n\t\t                           modulusLength*2 + // g^i, g^r\n\t\t                           HASH_LENGTH + // authenticator\n\t\t                           HASH_LENGTH + // HMAC(cyphertext)\n\t\t                           (c.getBlockSize() >> 3) + // IV\n\t\t                           signLength + // Signature\n\t\t                           data.length]; // The bootid+noderef\n\t\tint offset = 0;\n\t\t// Ni\n\t\tSystem.arraycopy(nonceInitiator, 0, message3, offset, nonceSize);\n\t\toffset += nonceSize;\n\t\tif(logMINOR) Logger.minor(this, \"We are sending Ni : \" + HexUtil.bytesToHex(nonceInitiator));\n\t\t// Nr\n\t\tSystem.arraycopy(nonceResponder, 0, message3, offset, nonceSize);\n\t\toffset += nonceSize;\n\t\t// g^i\n\t\tSystem.arraycopy(ourExponential, 0,message3, offset, ourExponential.length);\n\t\toffset += ourExponential.length;\n\t\t// g^r\n\t\tSystem.arraycopy(hisExponential, 0,message3, offset, hisExponential.length);\n\t\toffset += hisExponential.length;\n\n\t\t// Authenticator\n\t\tSystem.arraycopy(authenticator, 0, message3, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\t/*\n\t\t * Digital Signature of the message with the private key belonging to the initiator/responder\n\t\t * It is assumed to be non-message recovering\n\t\t */\n\t\t// save parameters so that we can verify message4\n\t\tbyte[] toSign = assembleDHParams(nonceInitiatorHashed, nonceResponder, ourExponential, hisExponential, pn.identity, data);\n\t\tpn.setJFKBuffer(toSign);\n\t\tbyte[] sig = (negType < 9 ? crypto.sign(SHA256.digest(toSign)) : crypto.ecdsaSign(toSign));\n\n\t\tbyte[] computedExponential;\n\t\tif (negType < 8 ) { // Legacy DH\n\t\t    NativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\t\t    computedExponential= ((DiffieHellmanLightContext)ctx).getHMACKey(_hisExponential);\n\t\t}else {\n\t\t    computedExponential = ((ECDHLightContext)ctx).getHMACKey(ECDH.getPublicKey(hisExponential, ecdhCurveToUse)).getEncoded();\n\t\t}\n\t\tif(logDEBUG) Logger.debug(this, \"The shared Master secret is : \"+HexUtil.bytesToHex(computedExponential)+ \" for \" + pn);\n\t\t/* 0 is the outgoing key for the initiator, 7 for the responder */\n\t\tpn.outgoingKey = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"0\");\n\t\tpn.incommingKey = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"7\");\n\t\tpn.jfkKe = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"1\");\n\t\tpn.jfkKa = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"2\");\n\n\t\tpn.hmacKey = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"3\");\n\t\tpn.ivKey = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"4\");\n\t\tpn.ivNonce = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"5\");\n\n\t\t/* Bytes  1-4:  Initial sequence number for the initiator\n\t\t * Bytes  5-8:  Initial sequence number for the responder\n\t\t * Bytes  9-12: Initial message id for the initiator\n\t\t * Bytes 13-16: Initial message id for the responder\n\t\t * Note that we are the initiator */\n\t\tbyte[] sharedData = computeJFKSharedKey(computedExponential, nonceInitiatorHashed, nonceResponder, \"6\");\n\t\tpn.ourInitialSeqNum = ((sharedData[0] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[1] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[2] & 0xFF) << 8)\n\t\t\t\t| (sharedData[3] & 0xFF);\n\t\tpn.theirInitialSeqNum = ((sharedData[4] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[5] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[6] & 0xFF) << 8)\n\t\t\t\t| (sharedData[7] & 0xFF);\n\t\tif(negType >= 7) {\n\t\t\tpn.theirInitialMsgID =\n\t\t\t\tunknownInitiator ? getInitialMessageID(pn.identity) :\n\t\t\t\t\tgetInitialMessageID(pn.identity, crypto.myIdentity);\n\t\t\tpn.ourInitialMsgID =\n\t\t\t\tunknownInitiator ? getInitialMessageID(pn.identity) :\n\t\t\t\t\tgetInitialMessageID(crypto.myIdentity, pn.identity);\n\t\t} else {\n\t\t\tpn.ourInitialMsgID= ((sharedData[8] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[9] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[10] & 0xFF) << 8)\n\t\t\t\t| (sharedData[11] & 0xFF);\n\t\t\tpn.theirInitialMsgID= ((sharedData[12] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[13] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[14] & 0xFF) << 8)\n\t\t\t\t| (sharedData[15] & 0xFF);\n\t\t}\n\t\t\t\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Their initial message ID: \"+pn.theirInitialMsgID+\" ours \"+pn.ourInitialMsgID);\n\n\n\t\tc.initialize(pn.jfkKe);\n\t\tint ivLength = PCFBMode.lengthIV(c);\n\t\tbyte[] iv = new byte[ivLength];\n\t\tnode.random.nextBytes(iv);\n\t\tPCFBMode pcfb = PCFBMode.create(c, iv);\n\t\tint cleartextOffset = 0;\n\t\tbyte[] cleartext = new byte[JFK_PREFIX_INITIATOR.length + ivLength + sig.length + data.length];\n\t\tSystem.arraycopy(JFK_PREFIX_INITIATOR, 0, cleartext, cleartextOffset, JFK_PREFIX_INITIATOR.length);\n\t\tcleartextOffset += JFK_PREFIX_INITIATOR.length;\n\t\tSystem.arraycopy(iv, 0, cleartext, cleartextOffset, ivLength);\n\t\tcleartextOffset += ivLength;\n\t\tSystem.arraycopy(sig, 0, cleartext, cleartextOffset, sig.length);\n\t\tcleartextOffset += sig.length;\n\t\tSystem.arraycopy(data, 0, cleartext, cleartextOffset, data.length);\n\t\tcleartextOffset += data.length;\n\n\t\tint cleartextToEncypherOffset = JFK_PREFIX_INITIATOR.length + ivLength;\n\t\tpcfb.blockEncipher(cleartext, cleartextToEncypherOffset, cleartext.length-cleartextToEncypherOffset);\n\n\t\t// We compute the HMAC of (prefix + cyphertext) Includes the IV!\n\t\tbyte[] hmac = HMAC.macWithSHA256(pn.jfkKa, cleartext, HASH_LENGTH);\n\n\t\t// copy stuffs back to the message\n\t\tSystem.arraycopy(hmac, 0, message3, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\tSystem.arraycopy(iv, 0, message3, offset, ivLength);\n\t\toffset += ivLength;\n\t\tSystem.arraycopy(cleartext, cleartextToEncypherOffset, message3, offset, cleartext.length-cleartextToEncypherOffset);\n\n\t\t// cache the message\n\t\tsynchronized (authenticatorCache) {\n\t\t\tif(!maybeResetTransientKey())\n\t\t\t\tauthenticatorCache.put(new ByteArrayWrapper(authenticator),message3);\n\t\t}\n\t\tfinal long timeSent = System.currentTimeMillis();\n\t\tif(unknownInitiator) {\n\t\t\tsendAnonAuthPacket(1, negType, 2, setupType, message3, pn, replyTo, pn.anonymousInitiatorSetupCipher);\n\t\t} else {\n\t\t\tsendAuthPacket(1, negType, 2, message3, pn, replyTo);\n\t\t}\n\n\t\t/* Re-send the packet after 5sec if we don't get any reply */\n\t\tnode.getTicker().queueTimedJob(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tif(pn.timeLastConnectionCompleted() < timeSent) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Resending JFK(3) to \"+pn+\" for \"+node.getDarknetPortNumber());\n\t\t\t\t\tif(unknownInitiator) {\n\t\t\t\t\t\tsendAnonAuthPacket(1, negType, 2, setupType, message3, pn, replyTo, pn.anonymousInitiatorSetupCipher);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsendAuthPacket(1, negType, 2, message3, pn, replyTo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}, 5*1000);\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message3 timeout error:Sending packet for \"+pn.getPeer());\n\t}","commit_id":"3017e0ebd8985e53ee4f5fc40efcf2ba92c0b55c","url":"https://github.com/freenet/fred"},{"original_method":"private boolean processJFKMessage4(byte[] payload, int inputOffset, PeerNode pn, Peer replyTo, boolean oldOpennetPeer, boolean unknownInitiator, int setupType, int negType)\n\t{\n\t\tfinal long t1 = System.currentTimeMillis();\n\t\tint modulusLength = getModulusLength(negType);\n\t\tint signLength = getSignatureLength(negType);\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(4) message, processing it - \"+pn.getPeer());\n\t\tif(pn.jfkMyRef == null) {\n\t\t\tString error = \"Got a JFK(4) message but no pn.jfkMyRef for \"+pn;\n\t\t\tif(node.getUptime() < 60*1000) {\n\t\t\t\tLogger.minor(this, error);\n\t\t\t} else {\n\t\t\t\tLogger.error(this, error);\n\t\t\t}\n\t\t}\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) { throw new RuntimeException(e); }\n\n\t\tfinal int expectedLength =\n\t\t\tHASH_LENGTH + // HMAC of the cyphertext\n\t\t\t(c.getBlockSize() >> 3) + // IV\n\t\t\tsignLength + // the signature\n\t\t\t9 + // ID of packet tracker, plus boolean byte\n\t\t\t8+ // bootID\n\t\t\t1; // znoderefR\n\n\t\tif(payload.length - inputOffset < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn.getPeer()+\": \"+payload.length+\" after decryption in JFK(4), should be \"+(expectedLength + 3));\n\t\t\treturn false;\n\t\t}\n\t\tbyte[] jfkBuffer = pn.getJFKBuffer();\n\t\tif(jfkBuffer == null) {\n\t\t\tLogger.normal(this, \"We have already handled this message... might be a replay or a bug - \"+pn);\n\t\t\treturn false;\n\t\t}\n\n\t\tbyte[] hmac = Arrays.copyOfRange(payload, inputOffset, inputOffset+HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\n\t\tc.initialize(pn.jfkKe);\n\t\tint ivLength = PCFBMode.lengthIV(c);\n\t\tint decypheredPayloadOffset = 0;\n\t\t// We compute the HMAC of (\"R\"+cyphertext) : the cyphertext includes the IV!\n\t\tbyte[] decypheredPayload = Arrays.copyOf(JFK_PREFIX_RESPONDER, JFK_PREFIX_RESPONDER.length + payload.length - inputOffset);\n\t\tdecypheredPayloadOffset += JFK_PREFIX_RESPONDER.length;\n\t\tSystem.arraycopy(payload, inputOffset, decypheredPayload, decypheredPayloadOffset, payload.length-inputOffset);\n\t\tif(!HMAC.verifyWithSHA256(pn.jfkKa, decypheredPayload, hmac)) {\n\t\t\tLogger.normal(this, \"The digest-HMAC doesn't match; let's discard the packet - \"+pn.getPeer());\n\t\t\treturn false;\n\t\t}\n\n\t\t// Try to find the HMAC in the cache:\n\t\t// If it is already present it indicates duplicate/replayed message4 and we can discard\n\t\t// If it's not, we can add it with a timestamp\n\t\tbyte[] message4Timestamp = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tByteArrayWrapper hmacBAW = new ByteArrayWrapper(hmac);\n\t\t\tmessage4Timestamp = authenticatorCache.get(hmacBAW);\n\t\t\tif(message4Timestamp == null) { // normal behaviour\n\t\t\t\tauthenticatorCache.put(hmacBAW, Fields.longToBytes(t1));\n\t\t\t}\n\t\t}\n\t\tif(message4Timestamp != null) {\n\t\t\tLogger.normal(this, \"We got a replayed message4 (first handled at \"+TimeUtil.formatTime(t1-Fields.bytesToLong(message4Timestamp))+\") from - \"+pn);\n\t\t\treturn true;\n\t\t}\n\n\t\t// Get the IV\n\t\tfinal PCFBMode pk = PCFBMode.create(c, decypheredPayload, decypheredPayloadOffset);\n\t\tdecypheredPayloadOffset += ivLength;\n\t\t// Decrypt the payload\n\t\tpk.blockDecipher(decypheredPayload, decypheredPayloadOffset, decypheredPayload.length - decypheredPayloadOffset);\n\t\t/*\n\t\t * DecipheredData Format:\n\t\t * Signature-r,s\n\t\t * bootID, znoderef\n\t\t */\n        byte[] sig = new byte[signLength];\n        System.arraycopy(decypheredPayload, decypheredPayloadOffset, sig, 0, signLength);\n        decypheredPayloadOffset += signLength;\n\t\tbyte[] data = new byte[decypheredPayload.length - decypheredPayloadOffset];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, data, 0, decypheredPayload.length - decypheredPayloadOffset);\n\t\tint ptr = 0;\n\t\tlong trackerID;\n\t\tboolean reusedTracker;\n\t\ttrackerID = Fields.bytesToLong(data, ptr);\n\t\tptr += 8;\n\t\treusedTracker = data[ptr++] != 0;\n\t\tlong bootID = Fields.bytesToLong(data, ptr);\n\t\tptr += 8;\n\t\tbyte[] hisRef = Arrays.copyOfRange(data, ptr, data.length);\n\n\t\t// verify the signature\n\t\tint dataLen = hisRef.length + 8 + 9;\n\t\tint nonceSize = (negType > 8 ? SHA256.getDigestLength() : NONCE_SIZE);\n\t\tbyte[] locallyGeneratedText = new byte[nonceSize + NONCE_SIZE + modulusLength * 2 + crypto.myIdentity.length + dataLen + pn.jfkMyRef.length];\n\t\tint bufferOffset = nonceSize + NONCE_SIZE + modulusLength*2;\n\t\tSystem.arraycopy(jfkBuffer, 0, locallyGeneratedText, 0, bufferOffset);\n\t\tbyte[] identity = crypto.getIdentity(unknownInitiator);\n\t\tSystem.arraycopy(identity, 0, locallyGeneratedText, bufferOffset, identity.length);\n\t\tbufferOffset += identity.length;\n\t\t// bootID\n\t\tSystem.arraycopy(data, 0, locallyGeneratedText, bufferOffset, dataLen);\n\t\tbufferOffset += dataLen;\n\t\tSystem.arraycopy(pn.jfkMyRef, 0, locallyGeneratedText, bufferOffset, pn.jfkMyRef.length);\n\t    if(negType < 9) { // DSA sig     \n\t        byte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t        System.arraycopy(sig, 0, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t        byte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t        System.arraycopy(sig, Node.SIGNATURE_PARAMETER_LENGTH, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t        DSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t        byte[] messageHash = SHA256.digest(locallyGeneratedText);\n\t        if(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, messageHash), false)) {\n\t            String error = \"The signature verification has failed!! JFK(4) -\"+pn.getPeer()+\" message hash \"+HexUtil.bytesToHex(messageHash)+\" length \"+locallyGeneratedText.length+\" hisRef \"+hisRef.length+\" hash \"+Fields.hashCode(hisRef)+\" myRef \"+pn.jfkMyRef.length+\" hash \"+Fields.hashCode(pn.jfkMyRef)+\" boot ID \"+bootID;\n\t            Logger.error(this, error);\n\t            return true;\n\t        }\n\t    } else { // ECDSA sig\n\t        if(!ECDSA.verify(Curves.P256, pn.peerECDSAPubKey, sig, locallyGeneratedText)) {\n\t            Logger.error(this, \"The ECDSA signature verification has failed!! JFK(4) - \"+pn.getPeer()+\" length \"+locallyGeneratedText.length+\" hisRef \"+hisRef.length+\" hash \"+Fields.hashCode(hisRef)+\" myRef \"+pn.jfkMyRef.length+\" hash \"+Fields.hashCode(pn.jfkMyRef)+\" boot ID \"+bootID);\n\t            return true;\n\t        }\n\t    }\n\n\t\t// Received a packet\n\t\tpn.receivedPacket(true, false);\n\n\t\t// Promote if necessary\n\t\tboolean dontWant = false;\n\t\tif(oldOpennetPeer) {\n\t\t\tOpennetManager opennet = node.getOpennet();\n\t\t\tif(opennet == null) {\n\t\t\t\tLogger.normal(this, \"Dumping incoming old-opennet peer as opennet just turned off: \"+pn+\".\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t/* When an old-opennet-peer connects, add it at the top of the LRU, so that it isn't\n\t\t\t * immediately dropped when there is no droppable peer to drop. If it was dropped\n\t\t\t * from the bottom of the LRU list, we would not have added it to the LRU; so it was\n\t\t\t * somewhere in the middle. */\n\t\t\tif(!opennet.wantPeer(pn, false, false, true, ConnectionType.RECONNECT)) {\n\t\t\t\tLogger.normal(this, \"No longer want peer \"+pn+\" - dumping it after connecting\");\n\t\t\t\tdontWant = true;\n\t\t\t\topennet.purgeOldOpennetPeer(pn);\n\t\t\t}\n\t\t\t// wantPeer will call node.peers.addPeer(), we don't have to.\n\t\t}\n\t\tif((!dontWant) && !crypto.allowConnection(pn, replyTo.getFreenetAddress())) {\n\t\t\tLogger.normal(this, \"Rejecting connection because already have something with the same IP\");\n\t\t\tdontWant = true;\n\t\t}\n\n\t\t// We change the key\n\t\tBlockCipher ivCipher = null;\n\t\tBlockCipher outgoingCipher = null;\n\t\tBlockCipher incommingCipher = null;\n\t\ttry {\n\t\t\tivCipher = new Rijndael(256, 256);\n\t\t\toutgoingCipher = new Rijndael(256, 256);\n\t\t\tincommingCipher = new Rijndael(256, 256);\n\t\t} catch (UnsupportedCipherException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\n\t\toutgoingCipher.initialize(pn.outgoingKey);\n\t\tincommingCipher.initialize(pn.incommingKey);\n\t\tivCipher.initialize(pn.ivKey);\n\n\t\tlong newTrackerID = pn.completedHandshake(\n\t\t\t\tbootID, hisRef, 0, hisRef.length, outgoingCipher, pn.outgoingKey, incommingCipher,\n\t\t\t\tpn.incommingKey, replyTo, false, negType, trackerID, true, reusedTracker, pn.hmacKey,\n\t\t\t\tivCipher, pn.ivNonce, pn.ourInitialSeqNum, pn.theirInitialSeqNum, pn.ourInitialMsgID,\n\t\t\t\tpn.theirInitialMsgID);\n\t\tif(newTrackerID >= 0) {\n\t\t\tif(dontWant) {\n\t\t\t\tnode.peers.disconnectAndRemove(pn, true, true, true);\n\t\t\t} else {\n\t\t\t\tpn.maybeSendInitialMessages();\n\t\t\t}\n\t\t} else {\n\t\t\tLogger.error(this, \"Handshake failed!\");\n\t\t}\n\n\t\t// cleanup\n\t\t// FIXME: maybe we should copy zeros/garbage into it before leaving it to the GC\n\t\tpn.setJFKBuffer(null);\n\t\tpn.jfkKa = null;\n\t\tpn.jfkKe = null;\n\t\tpn.outgoingKey = null;\n\t\tpn.incommingKey = null;\n\t\tpn.hmacKey = null;\n\t\tpn.ivKey = null;\n\t\tpn.ivNonce = null;\n\t\tpn.ourInitialSeqNum = 0;\n\t\tpn.theirInitialSeqNum = 0;\n\t\tpn.ourInitialMsgID = 0;\n\t\tpn.theirInitialMsgID = 0;\n\t\t// We want to clear it here so that new handshake requests\n\t\t// will be sent with a different DH pair\n\t\tpn.setKeyAgreementSchemeContext(null);\n\t\tsynchronized (pn) {\n\t\t\t// FIXME TRUE MULTI-HOMING: winner-takes-all, kill all other connection attempts since we can't deal with multiple active connections\n\t\t\t// Also avoids leaking\n\t\t\tpn.jfkNoncesSent.clear();\n\t\t}\n\n\t\tfinal long t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message4 timeout error:Processing packet from \"+pn.getPeer());\n\t\treturn true;\n\t}","id":99726,"modified_method":"private boolean processJFKMessage4(byte[] payload, int inputOffset, PeerNode pn, Peer replyTo, boolean oldOpennetPeer, boolean unknownInitiator, int setupType, int negType)\n\t{\n\t\tfinal long t1 = System.currentTimeMillis();\n\t\tint modulusLength = getModulusLength(negType);\n\t\tint signLength = getSignatureLength(negType);\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(4) message, processing it - \"+pn.getPeer());\n\t\tif(pn.jfkMyRef == null) {\n\t\t\tString error = \"Got a JFK(4) message but no pn.jfkMyRef for \"+pn;\n\t\t\tif(node.getUptime() < 60*1000) {\n\t\t\t\tLogger.minor(this, error);\n\t\t\t} else {\n\t\t\t\tLogger.error(this, error);\n\t\t\t}\n\t\t}\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) { throw new RuntimeException(e); }\n\n\t\tfinal int expectedLength =\n\t\t\tHASH_LENGTH + // HMAC of the cyphertext\n\t\t\t(c.getBlockSize() >> 3) + // IV\n\t\t\tsignLength + // the signature\n\t\t\t9 + // ID of packet tracker, plus boolean byte\n\t\t\t8+ // bootID\n\t\t\t1; // znoderefR\n\n\t\tif(payload.length - inputOffset < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn.getPeer()+\": \"+payload.length+\" after decryption in JFK(4), should be \"+(expectedLength + 3));\n\t\t\treturn false;\n\t\t}\n\t\tbyte[] jfkBuffer = pn.getJFKBuffer();\n\t\tif(jfkBuffer == null) {\n\t\t\tLogger.normal(this, \"We have already handled this message... might be a replay or a bug - \"+pn);\n\t\t\treturn false;\n\t\t}\n\n\t\tbyte[] hmac = Arrays.copyOfRange(payload, inputOffset, inputOffset+HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\n\t\tc.initialize(pn.jfkKe);\n\t\tint ivLength = PCFBMode.lengthIV(c);\n\t\tint decypheredPayloadOffset = 0;\n\t\t// We compute the HMAC of (\"R\"+cyphertext) : the cyphertext includes the IV!\n\t\tbyte[] decypheredPayload = Arrays.copyOf(JFK_PREFIX_RESPONDER, JFK_PREFIX_RESPONDER.length + payload.length - inputOffset);\n\t\tdecypheredPayloadOffset += JFK_PREFIX_RESPONDER.length;\n\t\tSystem.arraycopy(payload, inputOffset, decypheredPayload, decypheredPayloadOffset, payload.length-inputOffset);\n\t\tif(!HMAC.verifyWithSHA256(pn.jfkKa, decypheredPayload, hmac)) {\n\t\t\tLogger.normal(this, \"The digest-HMAC doesn't match; let's discard the packet - \"+pn.getPeer());\n\t\t\treturn false;\n\t\t}\n\n\t\t// Try to find the HMAC in the cache:\n\t\t// If it is already present it indicates duplicate/replayed message4 and we can discard\n\t\t// If it's not, we can add it with a timestamp\n\t\tbyte[] message4Timestamp = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tByteArrayWrapper hmacBAW = new ByteArrayWrapper(hmac);\n\t\t\tmessage4Timestamp = authenticatorCache.get(hmacBAW);\n\t\t\tif(message4Timestamp == null) { // normal behaviour\n\t\t\t\tauthenticatorCache.put(hmacBAW, Fields.longToBytes(t1));\n\t\t\t}\n\t\t}\n\t\tif(message4Timestamp != null) {\n\t\t\tLogger.normal(this, \"We got a replayed message4 (first handled at \"+TimeUtil.formatTime(t1-Fields.bytesToLong(message4Timestamp))+\") from - \"+pn);\n\t\t\treturn true;\n\t\t}\n\n\t\t// Get the IV\n\t\tfinal PCFBMode pk = PCFBMode.create(c, decypheredPayload, decypheredPayloadOffset);\n\t\tdecypheredPayloadOffset += ivLength;\n\t\t// Decrypt the payload\n\t\tpk.blockDecipher(decypheredPayload, decypheredPayloadOffset, decypheredPayload.length - decypheredPayloadOffset);\n\t\t/*\n\t\t * DecipheredData Format:\n\t\t * Signature-r,s\n\t\t * bootID, znoderef\n\t\t */\n        byte[] sig = new byte[signLength];\n        System.arraycopy(decypheredPayload, decypheredPayloadOffset, sig, 0, signLength);\n        decypheredPayloadOffset += signLength;\n\t\tbyte[] data = new byte[decypheredPayload.length - decypheredPayloadOffset];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, data, 0, decypheredPayload.length - decypheredPayloadOffset);\n\t\tint ptr = 0;\n\t\tlong trackerID;\n\t\tboolean reusedTracker;\n\t\ttrackerID = Fields.bytesToLong(data, ptr);\n\t\tptr += 8;\n\t\treusedTracker = data[ptr++] != 0;\n\t\tlong bootID = Fields.bytesToLong(data, ptr);\n\t\tptr += 8;\n\t\tbyte[] hisRef = Arrays.copyOfRange(data, ptr, data.length);\n\n\t\t// verify the signature\n\t\tint dataLen = hisRef.length + 8 + 9;\n\t\tint nonceSize = getNonceSize(negType);\n\t\tint nonceSizeHashed = (negType > 8 ? HASH_LENGTH : nonceSize);\n\t\tbyte[] locallyGeneratedText = new byte[nonceSizeHashed + nonceSize + modulusLength * 2 + crypto.myIdentity.length + dataLen + pn.jfkMyRef.length];\n\t\tint bufferOffset = nonceSizeHashed + nonceSize + modulusLength*2;\n\t\tSystem.arraycopy(jfkBuffer, 0, locallyGeneratedText, 0, bufferOffset);\n\t\tbyte[] identity = crypto.getIdentity(unknownInitiator);\n\t\tSystem.arraycopy(identity, 0, locallyGeneratedText, bufferOffset, identity.length);\n\t\tbufferOffset += identity.length;\n\t\t// bootID\n\t\tSystem.arraycopy(data, 0, locallyGeneratedText, bufferOffset, dataLen);\n\t\tbufferOffset += dataLen;\n\t\tSystem.arraycopy(pn.jfkMyRef, 0, locallyGeneratedText, bufferOffset, pn.jfkMyRef.length);\n\t    if(negType < 9) { // DSA sig     \n\t        byte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t        System.arraycopy(sig, 0, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t        byte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t        System.arraycopy(sig, Node.SIGNATURE_PARAMETER_LENGTH, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t        DSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t        byte[] messageHash = SHA256.digest(locallyGeneratedText);\n\t        if(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, messageHash), false)) {\n\t            String error = \"The signature verification has failed!! JFK(4) -\"+pn.getPeer()+\" message hash \"+HexUtil.bytesToHex(messageHash)+\" length \"+locallyGeneratedText.length+\" hisRef \"+hisRef.length+\" hash \"+Fields.hashCode(hisRef)+\" myRef \"+pn.jfkMyRef.length+\" hash \"+Fields.hashCode(pn.jfkMyRef)+\" boot ID \"+bootID;\n\t            Logger.error(this, error);\n\t            return true;\n\t        }\n\t    } else { // ECDSA sig\n\t        if(!ECDSA.verify(Curves.P256, pn.peerECDSAPubKey, sig, locallyGeneratedText)) {\n\t            Logger.error(this, \"The ECDSA signature verification has failed!! JFK(4) - \"+pn.getPeer()+\" length \"+locallyGeneratedText.length+\" hisRef \"+hisRef.length+\" hash \"+Fields.hashCode(hisRef)+\" myRef \"+pn.jfkMyRef.length+\" hash \"+Fields.hashCode(pn.jfkMyRef)+\" boot ID \"+bootID);\n\t            return true;\n\t        }\n\t    }\n\n\t\t// Received a packet\n\t\tpn.receivedPacket(true, false);\n\n\t\t// Promote if necessary\n\t\tboolean dontWant = false;\n\t\tif(oldOpennetPeer) {\n\t\t\tOpennetManager opennet = node.getOpennet();\n\t\t\tif(opennet == null) {\n\t\t\t\tLogger.normal(this, \"Dumping incoming old-opennet peer as opennet just turned off: \"+pn+\".\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t/* When an old-opennet-peer connects, add it at the top of the LRU, so that it isn't\n\t\t\t * immediately dropped when there is no droppable peer to drop. If it was dropped\n\t\t\t * from the bottom of the LRU list, we would not have added it to the LRU; so it was\n\t\t\t * somewhere in the middle. */\n\t\t\tif(!opennet.wantPeer(pn, false, false, true, ConnectionType.RECONNECT)) {\n\t\t\t\tLogger.normal(this, \"No longer want peer \"+pn+\" - dumping it after connecting\");\n\t\t\t\tdontWant = true;\n\t\t\t\topennet.purgeOldOpennetPeer(pn);\n\t\t\t}\n\t\t\t// wantPeer will call node.peers.addPeer(), we don't have to.\n\t\t}\n\t\tif((!dontWant) && !crypto.allowConnection(pn, replyTo.getFreenetAddress())) {\n\t\t\tLogger.normal(this, \"Rejecting connection because already have something with the same IP\");\n\t\t\tdontWant = true;\n\t\t}\n\n\t\t// We change the key\n\t\tBlockCipher ivCipher = null;\n\t\tBlockCipher outgoingCipher = null;\n\t\tBlockCipher incommingCipher = null;\n\t\ttry {\n\t\t\tivCipher = new Rijndael(256, 256);\n\t\t\toutgoingCipher = new Rijndael(256, 256);\n\t\t\tincommingCipher = new Rijndael(256, 256);\n\t\t} catch (UnsupportedCipherException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\n\t\toutgoingCipher.initialize(pn.outgoingKey);\n\t\tincommingCipher.initialize(pn.incommingKey);\n\t\tivCipher.initialize(pn.ivKey);\n\n\t\tlong newTrackerID = pn.completedHandshake(\n\t\t\t\tbootID, hisRef, 0, hisRef.length, outgoingCipher, pn.outgoingKey, incommingCipher,\n\t\t\t\tpn.incommingKey, replyTo, false, negType, trackerID, true, reusedTracker, pn.hmacKey,\n\t\t\t\tivCipher, pn.ivNonce, pn.ourInitialSeqNum, pn.theirInitialSeqNum, pn.ourInitialMsgID,\n\t\t\t\tpn.theirInitialMsgID);\n\t\tif(newTrackerID >= 0) {\n\t\t\tif(dontWant) {\n\t\t\t\tnode.peers.disconnectAndRemove(pn, true, true, true);\n\t\t\t} else {\n\t\t\t\tpn.maybeSendInitialMessages();\n\t\t\t}\n\t\t} else {\n\t\t\tLogger.error(this, \"Handshake failed!\");\n\t\t}\n\n\t\t// cleanup\n\t\t// FIXME: maybe we should copy zeros/garbage into it before leaving it to the GC\n\t\tpn.setJFKBuffer(null);\n\t\tpn.jfkKa = null;\n\t\tpn.jfkKe = null;\n\t\tpn.outgoingKey = null;\n\t\tpn.incommingKey = null;\n\t\tpn.hmacKey = null;\n\t\tpn.ivKey = null;\n\t\tpn.ivNonce = null;\n\t\tpn.ourInitialSeqNum = 0;\n\t\tpn.theirInitialSeqNum = 0;\n\t\tpn.ourInitialMsgID = 0;\n\t\tpn.theirInitialMsgID = 0;\n\t\t// We want to clear it here so that new handshake requests\n\t\t// will be sent with a different DH pair\n\t\tpn.setKeyAgreementSchemeContext(null);\n\t\tsynchronized (pn) {\n\t\t\t// FIXME TRUE MULTI-HOMING: winner-takes-all, kill all other connection attempts since we can't deal with multiple active connections\n\t\t\t// Also avoids leaking\n\t\t\tpn.jfkNoncesSent.clear();\n\t\t}\n\n\t\tfinal long t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message4 timeout error:Processing packet from \"+pn.getPeer());\n\t\treturn true;\n\t}","commit_id":"3017e0ebd8985e53ee4f5fc40efcf2ba92c0b55c","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n  public void describeTo(Description description) {\n    description.appendText(\"a dataType with type = \" + type.getName() + \", mimeType= \" + mimeType + \", encoding=\" + encoding);\n  }","id":99727,"modified_method":"@Override\n  public void describeTo(Description description) {\n    description\n        .appendText(\"a dataType with type = \").appendValue(type.getName())\n        .appendText(\", mimeType = \").appendValue(mimeType)\n        .appendText(\", encoding = \").appendValue(encoding);\n  }","commit_id":"a7a88329a31d9400a238446ba040372576c87ffb","url":"https://github.com/mulesoft/mule"},{"original_method":"private void verifyRequest(String flowName) throws Exception {\n    assertThat(IOUtils.toString((InputStream) runFlow(flowName).getMessage().getPayload().getValue()), is(DEFAULT_RESPONSE));\n  }","id":99728,"modified_method":"private void verifyRequest(String flowName) throws Exception {\n    assertThat(runFlow(flowName).getMessage(), hasPayload(equalTo((DEFAULT_RESPONSE))));\n  }","commit_id":"a7a88329a31d9400a238446ba040372576c87ffb","url":"https://github.com/mulesoft/mule"},{"original_method":"private void testWithPath(String path) throws Exception {\n    Event response = flowRunner(\"requestFlow\").withFlowVariable(\"requestPath\", path).run();\n    Serializable attributes = response.getMessage().getAttributes();\n    assertThat(attributes, instanceOf(HttpResponseAttributes.class));\n    assertThat(((MultiPartPayload) response.getMessage().getPayload().getValue()).getParts(), hasSize(1));\n  }","id":99729,"modified_method":"private void testWithPath(String path) throws Exception {\n    Event response = flowRunner(\"requestFlow\").withFlowVariable(\"requestPath\", path).run();\n    Serializable attributes = response.getMessage().getAttributes();\n    assertThat(attributes, instanceOf(HttpResponseAttributes.class));\n    assertThat(((MultiPartPayload) response.getMessage().getPayload().getValue()), hasSize(1));\n  }","commit_id":"a7a88329a31d9400a238446ba040372576c87ffb","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n  public void filePartSetsContentDispositionWithFileName() throws Exception {\n    File file = new File(IOUtils.getResourceAsUrl(TEST_FILE_NAME, getClass()).getPath());\n    addPartToSend(TEST_PART_NAME, file);\n\n    flowRunner(\"requestFlow\").withPayload(TEST_MESSAGE).withFlowVariable(PARTS, partsToSend).run();\n\n    Part part = getPart(TEST_PART_NAME);\n    assertFormDataContentDisposition(part, TEST_PART_NAME, TEST_FILE_NAME.substring(5));\n  }","id":99730,"modified_method":"@Test\n  public void filePartSetsContentDispositionWithFileName() throws Exception {\n    File file = new File(IOUtils.getResourceAsUrl(TEST_FILE_NAME, getClass()).getPath());\n    PartAttributes partAttributes = new PartAttributes(TEST_PART_NAME, TEST_FILE_NAME.substring(5), file.length(), emptyMap());\n    addPartToSend(new FileInputStream(file), partAttributes);\n\n    flowRunner(\"requestFlow\").withPayload(getPayload()).run();\n\n    Part part = getPart(TEST_PART_NAME);\n    assertFormDataContentDisposition(part, TEST_PART_NAME, TEST_FILE_NAME.substring(5));\n  }","commit_id":"a7a88329a31d9400a238446ba040372576c87ffb","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n  public void byteArrayPartSetsContentDispositionWithFileName() throws Exception {\n    addPartToSend(TEST_PART_NAME, TEST_MESSAGE.getBytes(), TEXT, TEST_FILE_NAME);\n\n    flowRunner(\"requestFlow\").withPayload(TEST_MESSAGE).withFlowVariable(PARTS, partsToSend).run();\n\n    Part part = getPart(TEST_PART_NAME);\n    assertFormDataContentDisposition(part, TEST_PART_NAME, TEST_FILE_NAME);\n  }","id":99731,"modified_method":"@Test\n  public void byteArrayPartSetsContentDispositionWithFileName() throws Exception {\n    PartAttributes partAttributes = new PartAttributes(TEST_PART_NAME, TEST_FILE_NAME, TEST_MESSAGE.length(), emptyMap());\n    addPartToSend(TEST_MESSAGE.getBytes(), TEXT, partAttributes);\n\n    flowRunner(\"requestFlow\").withPayload(getPayload()).run();\n\n    Part part = getPart(TEST_PART_NAME);\n    assertFormDataContentDisposition(part, TEST_PART_NAME, TEST_FILE_NAME);\n  }","commit_id":"a7a88329a31d9400a238446ba040372576c87ffb","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n  public void partsCustomContentType() throws Exception {\n    addPartToSend(\"part1\", \"Contents 1\", TEXT);\n    addPartToSend(\"part2\", \"Contents 2\", HTML);\n\n    flowRunner(\"requestFlow\").withPayload(TEST_MESSAGE).withFlowVariable(PARTS, partsToSend)\n        .withMediaType(MediaType.parse(\"multipart/form-data2\")).run();\n\n    assertThat(requestContentType, startsWith(\"multipart/form-data2; boundary=\"));\n    assertThat(parts.size(), equalTo(2));\n\n    assertPart(\"part1\", TEXT, \"Contents 1\");\n    assertPart(\"part2\", HTML, \"Contents 2\");\n  }","id":99732,"modified_method":"@Test\n  public void partsCustomContentType() throws Exception {\n    String content1 = \"Contents 1\";\n    PartAttributes part1Attributes = new PartAttributes(\"part1\", null, content1.length(), emptyMap());\n    addPartToSend(content1, TEXT, part1Attributes);\n    String content2 = \"Contents 2\";\n    PartAttributes part2Attributes = new PartAttributes(\"part2\", null, content2.length(), emptyMap());\n    addPartToSend(content2, HTML, part2Attributes);\n\n    flowRunner(\"requestFlow\").withPayload(getPayload())\n        .withMediaType(MediaType.parse(\"multipart/form-data2\")).run();\n\n    assertThat(requestContentType, startsWith(\"multipart/form-data2; boundary=\"));\n    assertThat(parts.size(), equalTo(2));\n\n    assertPart(\"part1\", TEXT, content1);\n    assertPart(\"part2\", HTML, content2);\n  }","commit_id":"a7a88329a31d9400a238446ba040372576c87ffb","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n  public void stringPartSetsContentDispositionWithoutFileName() throws Exception {\n    addPartToSend(TEST_PART_NAME, TEST_MESSAGE, TEXT);\n\n    flowRunner(\"requestFlow\").withPayload(TEST_MESSAGE).withFlowVariable(PARTS, partsToSend).run();\n\n    Part part = getPart(TEST_PART_NAME);\n    assertFormDataContentDisposition(part, TEST_PART_NAME, null);\n  }","id":99733,"modified_method":"@Test\n  public void stringPartSetsContentDispositionWithoutFileName() throws Exception {\n    addPartToSend(TEST_MESSAGE, TEXT, new PartAttributes(TEST_PART_NAME));\n\n    flowRunner(\"requestFlow\").withPayload(getPayload()).run();\n\n    Part part = getPart(TEST_PART_NAME);\n    assertFormDataContentDisposition(part, TEST_PART_NAME, null);\n  }","commit_id":"a7a88329a31d9400a238446ba040372576c87ffb","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n  public void partsAreSent() throws Exception {\n    flowRunner(\"requestPartFlow\").withPayload(TEST_MESSAGE).run();\n\n    assertThat(requestContentType, startsWith(\"multipart/form-data; boundary=\"));\n    assertThat(parts.size(), equalTo(2));\n\n    assertPart(\"part1\", TEXT, \"content 1\");\n    assertPart(\"part2\", TEXT, \"content 2\");\n    assertFormDataContentDisposition(getPart(\"part2\"), \"part2\", \"myPart.txt\");\n  }","id":99734,"modified_method":"@Test\n  public void partsAreSent() throws Exception {\n    String content1 = \"content 1\";\n    PartAttributes part1Attributes = new PartAttributes(\"part1\", null, content1.length(), emptyMap());\n    addPartToSend(content1, TEXT, part1Attributes);\n    String content2 = \"content 2\";\n    PartAttributes part2Attributes = new PartAttributes(\"part2\", \"myPart.txt\", content2.length(), emptyMap());\n    addPartToSend(content2.getBytes(), TEXT, part2Attributes);\n    flowRunner(\"requestPartFlow\").withPayload(getPayload()).run();\n\n    assertThat(requestContentType, startsWith(\"multipart/form-data; boundary=\"));\n    assertThat(parts.size(), equalTo(2));\n\n    assertPart(\"part1\", TEXT, content1);\n    assertPart(\"part2\", TEXT, content2);\n    assertFormDataContentDisposition(getPart(\"part2\"), \"part2\", \"myPart.txt\");\n  }","commit_id":"a7a88329a31d9400a238446ba040372576c87ffb","url":"https://github.com/mulesoft/mule"},{"original_method":"private void addPartToSend(String name, Object content) throws Exception {\n    addPartToSend(name, content, null, null);\n  }","id":99735,"modified_method":"private void addPartToSend(Object content, PartAttributes partAttributes) {\n    partsToSend.add(builder().payload(content).attributes(partAttributes).build());\n  }","commit_id":"a7a88329a31d9400a238446ba040372576c87ffb","url":"https://github.com/mulesoft/mule"},{"original_method":"private void addPartToSend(String name, Object content, MediaType contentType, String fileName) throws Exception {\n    partsToSend.add(new HttpPart(name, content, contentType, fileName));\n  }","id":99736,"modified_method":"private void addPartToSend(Object content, MediaType contentType, PartAttributes attributes) throws Exception {\n    partsToSend.add(builder().payload(content).attributes(attributes).mediaType(contentType).build());\n  }","commit_id":"a7a88329a31d9400a238446ba040372576c87ffb","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n  public void sendingAttachmentBiggerThanAsyncWriteQueueSizeWorksOverHttps() throws Exception {\n    // Grizzly defines the maxAsyncWriteQueueSize as 4 times the sendBufferSize\n    // (org.glassfish.grizzly.nio.transport.TCPNIOConnection).\n    int maxAsyncWriteQueueSize = Integer.valueOf(sendBufferSize.getValue()) * 4;\n    // Set a part bigger than the queue size.\n    addPartToSend(TEST_PART_NAME, new byte[maxAsyncWriteQueueSize * 2], TEXT);\n\n    Event response = flowRunner(\"requestFlowTls\").withPayload(TEST_MESSAGE).withFlowVariable(PARTS, partsToSend).run();\n\n    assertThat((HttpResponseAttributes) response.getMessage().getAttributes(), hasStatusCode(OK.getStatusCode()));\n  }","id":99737,"modified_method":"@Test\n  public void sendingAttachmentBiggerThanAsyncWriteQueueSizeWorksOverHttps() throws Exception {\n    // Grizzly defines the maxAsyncWriteQueueSize as 4 times the sendBufferSize\n    // (org.glassfish.grizzly.nio.transport.TCPNIOConnection).\n    int maxAsyncWriteQueueSize = Integer.valueOf(sendBufferSize.getValue()) * 4;\n    // Set a part bigger than the queue size.\n    addPartToSend(new byte[maxAsyncWriteQueueSize * 2], TEXT, new PartAttributes(TEST_PART_NAME));\n\n    Event response = flowRunner(\"requestFlowTls\").withPayload(TEST_MESSAGE).withFlowVariable(PARTS, partsToSend).run();\n\n    assertThat((HttpResponseAttributes) response.getMessage().getAttributes(), hasStatusCode(OK.getStatusCode()));\n  }","commit_id":"a7a88329a31d9400a238446ba040372576c87ffb","url":"https://github.com/mulesoft/mule"},{"original_method":"private void testHeaders(String flowName, String expectedResponse) throws Exception {\n    InternalMessage response = flowRunner(flowName).run().getMessage();\n    assertThat(response.getPayload().getValue(), is(expectedResponse));\n  }","id":99738,"modified_method":"private void testHeaders(String flowName, String expectedResponse) throws Exception {\n    InternalMessage response = flowRunner(flowName).run().getMessage();\n    assertThat(response, hasPayload(equalTo(expectedResponse)));\n  }","commit_id":"a7a88329a31d9400a238446ba040372576c87ffb","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n  public void responseBodyToCustomTarget() throws Exception {\n    Event event = flowRunner(\"customTargetFlow\").withPayload(TEST_MESSAGE).run();\n    InternalMessage customTarget = (InternalMessage) event.getVariable(\"customTarget\").getValue();\n    assertThat(customTarget, notNullValue());\n    assertThat(IOUtils.toString((InputStream) customTarget.getPayload().getValue()), equalTo(DEFAULT_RESPONSE));\n    assertThat(getPayloadAsString(event.getMessage()), equalTo(TEST_MESSAGE));\n  }","id":99739,"modified_method":"@Test\n  public void responseBodyToCustomTarget() throws Exception {\n    Event event = flowRunner(\"customTargetFlow\").withPayload(TEST_MESSAGE).run();\n    InternalMessage customTarget = (InternalMessage) event.getVariable(\"customTarget\").getValue();\n    assertThat(customTarget, notNullValue());\n    assertThat(customTarget, hasPayload(equalTo(DEFAULT_RESPONSE)));\n    assertThat(getPayloadAsString(event.getMessage()), equalTo(TEST_MESSAGE));\n  }","commit_id":"a7a88329a31d9400a238446ba040372576c87ffb","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n  public void handlesRequest() throws Exception {\n    Event response = flowRunner(\"testFlowHttps\").withPayload(TEST_PAYLOAD).run();\n    assertThat(IOUtils.toString((InputStream) response.getMessage().getPayload().getValue()), is(DEFAULT_RESPONSE));\n  }","id":99740,"modified_method":"@Test\n  public void handlesRequest() throws Exception {\n    Event response = flowRunner(\"testFlowHttps\").withPayload(TEST_PAYLOAD).run();\n    assertThat(response.getMessage(), hasPayload(equalTo((DEFAULT_RESPONSE))));\n  }","commit_id":"a7a88329a31d9400a238446ba040372576c87ffb","url":"https://github.com/mulesoft/mule"},{"original_method":"private HttpEntity createRequestEntityFromPayload(HttpRequestBuilder requestBuilder, Event muleEvent,\n                                                    Map<String, DataHandler> parts, MuleContext muleContext)\n      throws MessagingException {\n    Object payload = muleEvent.getMessage().getPayload().getValue();\n\n    if (!parts.isEmpty()) {\n      try {\n        return new MultipartHttpEntity(HttpPartDataSource.createFrom(parts));\n      } catch (IOException e) {\n        throw new MessagingException(muleEvent, e);\n      }\n    }\n\n    if (doStreaming(requestBuilder, muleEvent)) {\n\n      if (payload instanceof InputStream) {\n        return new InputStreamHttpEntity((InputStream) payload);\n      } else {\n        try {\n          return new InputStreamHttpEntity(new ByteArrayInputStream(muleEvent.getMessageAsBytes(muleContext)));\n        } catch (Exception e) {\n          throw new MessagingException(muleEvent, e);\n        }\n      }\n\n    } else {\n      String contentType = requestBuilder.getHeaders().get(CONTENT_TYPE);\n\n      if (contentType == null || contentType.startsWith(APPLICATION_X_WWW_FORM_URLENCODED.toRfcString())\n          || contentType.startsWith(APPLICATION_JAVA)) {\n        if (muleEvent.getMessage().getPayload().getValue() instanceof Map) {\n          String body = HttpParser.encodeString(muleEvent.getMessage().getPayload().getDataType().getMediaType().getCharset()\n              .orElse(getDefaultEncoding(muleContext)), (Map) payload);\n          requestBuilder.addHeader(CONTENT_TYPE, APPLICATION_X_WWW_FORM_URLENCODED.toRfcString());\n          return new ByteArrayHttpEntity(body.getBytes());\n        }\n      }\n\n      try {\n        return new ByteArrayHttpEntity(muleEvent.getMessageAsBytes(muleContext));\n      } catch (Exception e) {\n        throw new MessagingException(muleEvent, e);\n      }\n    }\n  }","id":99741,"modified_method":"private HttpEntity createRequestEntityFromPayload(HttpRequestBuilder requestBuilder, Event muleEvent,\n                                                    MuleContext muleContext)\n      throws MessagingException {\n    Object payload = muleEvent.getMessage().getPayload().getValue();\n\n    if (payload instanceof MultiPartPayload) {\n      try {\n        Transformer objectToByteArray = muleContext.getRegistry().lookupTransformer(OBJECT, BYTE_ARRAY);\n        return new MultipartHttpEntity(HttpPartDataSource.createFrom((MultiPartPayload) payload, objectToByteArray));\n      } catch (Exception e) {\n        throw new MessagingException(muleEvent, e);\n      }\n    }\n\n    if (doStreaming(requestBuilder, muleEvent)) {\n\n      if (payload instanceof InputStream) {\n        return new InputStreamHttpEntity((InputStream) payload);\n      } else {\n        try {\n          return new InputStreamHttpEntity(new ByteArrayInputStream(muleEvent.getMessageAsBytes(muleContext)));\n        } catch (Exception e) {\n          throw new MessagingException(muleEvent, e);\n        }\n      }\n\n    } else {\n      String contentType = requestBuilder.getHeaders().get(CONTENT_TYPE);\n\n      if (contentType == null || contentType.startsWith(APPLICATION_X_WWW_FORM_URLENCODED.toRfcString())\n          || contentType.startsWith(APPLICATION_JAVA)) {\n        if (muleEvent.getMessage().getPayload().getValue() instanceof Map) {\n          String body = HttpParser.encodeString(muleEvent.getMessage().getPayload().getDataType().getMediaType().getCharset()\n              .orElse(getDefaultEncoding(muleContext)), (Map) payload);\n          requestBuilder.addHeader(CONTENT_TYPE, APPLICATION_X_WWW_FORM_URLENCODED.toRfcString());\n          return new ByteArrayHttpEntity(body.getBytes());\n        }\n      }\n\n      try {\n        return new ByteArrayHttpEntity(muleEvent.getMessageAsBytes(muleContext));\n      } catch (Exception e) {\n        throw new MessagingException(muleEvent, e);\n      }\n    }\n  }","commit_id":"a7a88329a31d9400a238446ba040372576c87ffb","url":"https://github.com/mulesoft/mule"},{"original_method":"private HttpEntity createRequestEntity(HttpRequestBuilder requestBuilder, Event muleEvent, String resolvedMethod,\n                                         Map<String, DataHandler> parts, MuleContext muleContext)\n      throws MessagingException {\n    HttpEntity entity;\n\n    if (!StringUtils.isEmpty(this.source) && !(DEFAULT_PAYLOAD_EXPRESSION.equals(this.source))) {\n      Object newPayload = this.source;\n      muleEvent =\n          Event.builder(muleEvent).message(InternalMessage.builder(muleEvent.getMessage()).payload(newPayload).build()).build();\n    }\n\n    if (isEmptyBody(muleEvent, resolvedMethod, parts)) {\n      entity = new EmptyHttpEntity();\n    } else {\n      entity = createRequestEntityFromPayload(requestBuilder, muleEvent, parts, muleContext);\n    }\n\n    return entity;\n  }","id":99742,"modified_method":"private HttpEntity createRequestEntity(HttpRequestBuilder requestBuilder, Event muleEvent, String resolvedMethod,\n                                         MuleContext muleContext)\n      throws MessagingException {\n    HttpEntity entity;\n\n    if (!StringUtils.isEmpty(this.source) && !(DEFAULT_PAYLOAD_EXPRESSION.equals(this.source))) {\n      Object newPayload = this.source;\n      muleEvent =\n          Event.builder(muleEvent).message(InternalMessage.builder(muleEvent.getMessage()).payload(newPayload).build()).build();\n    }\n\n    if (isEmptyBody(muleEvent, resolvedMethod)) {\n      entity = new EmptyHttpEntity();\n    } else {\n      entity = createRequestEntityFromPayload(requestBuilder, muleEvent, muleContext);\n    }\n\n    return entity;\n  }","commit_id":"a7a88329a31d9400a238446ba040372576c87ffb","url":"https://github.com/mulesoft/mule"},{"original_method":"private boolean isEmptyBody(Event event, String method, Map<String, DataHandler> parts) {\n    boolean emptyBody;\n\n    // TODO MULE-9986 Use multi-part payload\n    if (event.getMessage().getPayload().getValue() == null && parts.isEmpty()) {\n      emptyBody = true;\n    } else {\n      emptyBody = DEFAULT_EMPTY_BODY_METHODS.contains(method);\n\n      if (sendBodyMode != HttpSendBodyMode.AUTO) {\n        emptyBody = (sendBodyMode == HttpSendBodyMode.NEVER);\n      }\n    }\n\n    return emptyBody;\n  }","id":99743,"modified_method":"private boolean isEmptyBody(Event event, String method) {\n    boolean emptyBody;\n\n    // TODO MULE-9986 Use multi-part payload\n    if (event.getMessage().getPayload().getValue() == null) {\n      emptyBody = true;\n    } else {\n      emptyBody = DEFAULT_EMPTY_BODY_METHODS.contains(method);\n\n      if (sendBodyMode != HttpSendBodyMode.AUTO) {\n        emptyBody = (sendBodyMode == HttpSendBodyMode.NEVER);\n      }\n    }\n\n    return emptyBody;\n  }","commit_id":"a7a88329a31d9400a238446ba040372576c87ffb","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n   * Creates an {@HttpRequest}.\n   *\n   * @param event The {@link Event} that should be used to set the {@link HttpRequest} content.\n   * @param requestBuilder The generic {@link HttpRequesterRequestBuilder} from the request component that should be used to\n   *        create the {@link HttpRequest}.\n   * @param authentication The {@link HttpAuthentication} that should be used to create the {@link HttpRequest}.\n   * @param muleContext the Mule node.\n   * @return an {@HttpRequest} configured based on the parameters.\n   * @throws MuleException if the request creation fails.\n   */\n  public HttpRequest create(Event event, HttpRequesterRequestBuilder requestBuilder, HttpAuthentication authentication,\n                            MuleContext muleContext)\n      throws MuleException {\n    HttpRequestBuilder builder = new HttpRequestBuilder();\n\n    builder.setUri(this.uri);\n    builder.setMethod(this.method);\n    builder.setHeaders(toParameterMap(requestBuilder.getHeaders()));\n    builder.setQueryParams(toParameterMap(requestBuilder.getQueryParams()));\n\n    if (!builder.getHeaders().containsKey(CONTENT_TYPE)) {\n      DataType dataType = event.getMessage().getPayload().getDataType();\n      if (!MediaType.ANY.matches(dataType.getMediaType())) {\n        builder.addHeader(CONTENT_TYPE, dataType.getMediaType().toRfcString());\n      }\n    }\n\n    if (config.isEnableCookies()) {\n      try {\n        Map<String, List<String>> headers =\n            config.getCookieManager().get(URI.create(uri), Collections.<String, List<String>>emptyMap());\n        List<String> cookies = headers.get(COOKIE);\n        if (cookies != null) {\n          for (String cookie : cookies) {\n            builder.addHeader(COOKIE, cookie);\n          }\n        }\n      } catch (IOException e) {\n        logger.warn(\"Error reading cookies for URI \" + uri, e);\n      }\n\n    }\n\n    builder.setEntity(createRequestEntity(builder, event, this.method, requestBuilder.getParts(), muleContext));\n\n    if (authentication != null) {\n      authentication.authenticate(event, builder);\n    }\n\n    return builder.build();\n  }","id":99744,"modified_method":"/**\n   * Creates an {@HttpRequest}.\n   *\n   * @param event The {@link Event} that should be used to set the {@link HttpRequest} content.\n   * @param requestBuilder The generic {@link HttpRequesterRequestBuilder} from the request component that should be used to\n   *        create the {@link HttpRequest}.\n   * @param authentication The {@link HttpAuthentication} that should be used to create the {@link HttpRequest}.\n   * @param muleContext the Mule node.\n   * @return an {@HttpRequest} configured based on the parameters.\n   * @throws MuleException if the request creation fails.\n   */\n  public HttpRequest create(Event event, HttpRequesterRequestBuilder requestBuilder, HttpAuthentication authentication,\n                            MuleContext muleContext)\n      throws MuleException {\n    HttpRequestBuilder builder = new HttpRequestBuilder();\n\n    builder.setUri(this.uri);\n    builder.setMethod(this.method);\n    builder.setHeaders(toParameterMap(requestBuilder.getHeaders()));\n    builder.setQueryParams(toParameterMap(requestBuilder.getQueryParams()));\n\n    if (!builder.getHeaders().containsKey(CONTENT_TYPE)) {\n      DataType dataType = event.getMessage().getPayload().getDataType();\n      if (!MediaType.ANY.matches(dataType.getMediaType())) {\n        builder.addHeader(CONTENT_TYPE, dataType.getMediaType().toRfcString());\n      }\n    }\n\n    if (config.isEnableCookies()) {\n      try {\n        Map<String, List<String>> headers =\n            config.getCookieManager().get(URI.create(uri), Collections.<String, List<String>>emptyMap());\n        List<String> cookies = headers.get(COOKIE);\n        if (cookies != null) {\n          for (String cookie : cookies) {\n            builder.addHeader(COOKIE, cookie);\n          }\n        }\n      } catch (IOException e) {\n        logger.warn(\"Error reading cookies for URI \" + uri, e);\n      }\n\n    }\n\n    builder.setEntity(createRequestEntity(builder, event, this.method, muleContext));\n\n    if (authentication != null) {\n      authentication.authenticate(event, builder);\n    }\n\n    return builder.build();\n  }","commit_id":"a7a88329a31d9400a238446ba040372576c87ffb","url":"https://github.com/mulesoft/mule"},{"original_method":"private HttpEntity createMultipartEntity(Event event, String contentType, Map<String, DataHandler> parts)\n      throws MessagingException {\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"Message contains attachments. Ignoring payload and trying to generate multipart response.\");\n    }\n\n    final MultipartHttpEntity multipartEntity;\n    try {\n      multipartEntity = new MultipartHttpEntity(HttpPartDataSource.createFrom(parts));\n      return new ByteArrayHttpEntity(HttpMultipartEncoder.createMultipartContent(multipartEntity, contentType));\n    } catch (Exception e) {\n      throw new MessagingException(I18nMessageFactory.createStaticMessage(\"Error creating multipart HTTP entity.\"),\n                                   event.getMessage(), muleContext, e);\n    }\n  }","id":99745,"modified_method":"private HttpEntity createMultipartEntity(Event event, String contentType, MultiPartPayload partPayload)\n      throws MessagingException {\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"Message contains attachments. Ignoring payload and trying to generate multipart response.\");\n    }\n\n    final MultipartHttpEntity multipartEntity;\n    try {\n      Transformer objectToByteArray = muleContext.getRegistry().lookupTransformer(OBJECT, BYTE_ARRAY);\n      multipartEntity = new MultipartHttpEntity(HttpPartDataSource.createFrom(partPayload, objectToByteArray));\n      return new ByteArrayHttpEntity(HttpMultipartEncoder.createMultipartContent(multipartEntity, contentType));\n    } catch (Exception e) {\n      throw new MessagingException(I18nMessageFactory.createStaticMessage(\"Error creating multipart HTTP entity.\"),\n                                   event.getMessage(), muleContext, e);\n    }\n  }","commit_id":"a7a88329a31d9400a238446ba040372576c87ffb","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n   * Creates an {@HttpResponse}.\n   *\n   * @param event The {@link Event} that should be used to set the {@link HttpResponse} content.\n   * @param responseBuilder The {@link HttpResponseBuilder} that should be modified if necessary and used to build the\n   *        {@link HttpResponse}.\n   * @param listenerResponseBuilder The generic {@HttpListenerResponseBuilder} configured for this listener.\n   * @param supportsTransferEncoding boolean that determines whether the HTTP protocol of the response supports streaming.\n   * @return an {@HttpResponse} configured based on the parameters.\n   * @throws MessagingException if the response creation fails.\n   */\n  public HttpResponse create(Event event, HttpResponseBuilder responseBuilder,\n                             HttpListenerResponseBuilder listenerResponseBuilder, boolean supportsTransferEncoding)\n      throws MessagingException {\n    Map<String, String> headers = listenerResponseBuilder.getHeaders(event);\n\n    final HttpResponseHeaderBuilder httpResponseHeaderBuilder = new HttpResponseHeaderBuilder();\n\n    for (String name : headers.keySet()) {\n      // For now, only support single headers\n      if (TRANSFER_ENCODING.equals(name) && !supportsTransferEncoding) {\n        logger\n            .debug(\"Client HTTP version is lower than 1.1 so the unsupported 'Transfer-Encoding' header has been removed and 'Content-Length' will be sent instead.\");\n      } else {\n        httpResponseHeaderBuilder.addHeader(name, headers.get(name));\n      }\n    }\n\n    if (httpResponseHeaderBuilder.getContentType() == null) {\n      DataType dataType = event.getMessage().getPayload().getDataType();\n      if (!MediaType.ANY.matches(dataType.getMediaType())) {\n        httpResponseHeaderBuilder.addHeader(CONTENT_TYPE, dataType.getMediaType().toString());\n      }\n    }\n\n    final String configuredContentType = httpResponseHeaderBuilder.getContentType();\n    final String existingTransferEncoding = httpResponseHeaderBuilder.getTransferEncoding();\n    final String existingContentLength = httpResponseHeaderBuilder.getContentLength();\n\n    HttpEntity httpEntity;\n\n    Map<String, DataHandler> parts = listenerResponseBuilder.getParts(event);\n\n    if (!parts.isEmpty()) {\n      if (configuredContentType == null) {\n        httpResponseHeaderBuilder.addContentType(createMultipartFormDataContentType());\n      } else if (!configuredContentType.startsWith(MULTIPART)) {\n        warnNoMultipartContentTypeButMultipartEntity(httpResponseHeaderBuilder.getContentType());\n      }\n      httpEntity = createMultipartEntity(event, httpResponseHeaderBuilder.getContentType(), parts);\n      resolveEncoding(httpResponseHeaderBuilder, existingTransferEncoding, existingContentLength, supportsTransferEncoding,\n                      (ByteArrayHttpEntity) httpEntity);\n    } else {\n      final Object payload = event.getMessage().getPayload().getValue();\n      if (payload == null) {\n        setupContentLengthEncoding(httpResponseHeaderBuilder, 0);\n        httpEntity = new EmptyHttpEntity();\n      } else if (payload instanceof Map) {\n        if (configuredContentType == null) {\n          httpResponseHeaderBuilder.addContentType(HttpHeaders.Values.APPLICATION_X_WWW_FORM_URLENCODED.toRfcString());\n        } else if (!configuredContentType.startsWith(HttpHeaders.Values.APPLICATION_X_WWW_FORM_URLENCODED.toRfcString())) {\n          warnMapPayloadButNoUrlEncodedContentType(httpResponseHeaderBuilder.getContentType());\n        }\n        httpEntity = createUrlEncodedEntity(event, (Map) payload);\n        if (responseStreaming == ALWAYS && supportsTransferEncoding) {\n          setupChunkedEncoding(httpResponseHeaderBuilder);\n        } else {\n          if (httpEntity instanceof EmptyHttpEntity) {\n            setupContentLengthEncoding(httpResponseHeaderBuilder, 0);\n          } else {\n            ByteArrayHttpEntity byteArrayHttpEntity = (ByteArrayHttpEntity) httpEntity;\n            setupContentLengthEncoding(httpResponseHeaderBuilder, byteArrayHttpEntity.getContent().length);\n          }\n        }\n      } else if (payload instanceof InputStream) {\n        if (responseStreaming == ALWAYS || (responseStreaming == AUTO && existingContentLength == null)) {\n          if (supportsTransferEncoding) {\n            setupChunkedEncoding(httpResponseHeaderBuilder);\n          }\n          httpEntity = new InputStreamHttpEntity((InputStream) payload);\n        } else {\n          ByteArrayHttpEntity byteArrayHttpEntity = new ByteArrayHttpEntity(IOUtils.toByteArray(((InputStream) payload)));\n          setupContentLengthEncoding(httpResponseHeaderBuilder, byteArrayHttpEntity.getContent().length);\n          httpEntity = byteArrayHttpEntity;\n        }\n      } else {\n        try {\n          ByteArrayHttpEntity byteArrayHttpEntity = new ByteArrayHttpEntity(event.getMessageAsBytes(muleContext));\n          resolveEncoding(httpResponseHeaderBuilder, existingTransferEncoding, existingContentLength, supportsTransferEncoding,\n                          byteArrayHttpEntity);\n          httpEntity = byteArrayHttpEntity;\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n    }\n\n    Collection<String> headerNames = httpResponseHeaderBuilder.getHeaderNames();\n    for (String headerName : headerNames) {\n      Collection<String> values = httpResponseHeaderBuilder.getHeader(headerName);\n      for (String value : values) {\n        responseBuilder.addHeader(headerName, value);\n      }\n    }\n\n    Integer statusCode = listenerResponseBuilder.getStatusCode(event);\n    if (statusCode != null) {\n      responseBuilder.setStatusCode(statusCode);\n    }\n    String reasonPhrase = resolveReasonPhrase(listenerResponseBuilder.getReasonPhrase(event), statusCode);\n    if (reasonPhrase != null) {\n      responseBuilder.setReasonPhrase(reasonPhrase);\n    }\n    responseBuilder.setEntity(httpEntity);\n    return responseBuilder.build();\n  }","id":99746,"modified_method":"/**\n   * Creates an {@HttpResponse}.\n   *\n   * @param event The {@link Event} that should be used to set the {@link HttpResponse} content.\n   * @param responseBuilder The {@link HttpResponseBuilder} that should be modified if necessary and used to build the\n   *        {@link HttpResponse}.\n   * @param listenerResponseBuilder The generic {@HttpListenerResponseBuilder} configured for this listener.\n   * @param supportsTransferEncoding boolean that determines whether the HTTP protocol of the response supports streaming.\n   * @return an {@HttpResponse} configured based on the parameters.\n   * @throws MessagingException if the response creation fails.\n   */\n  public HttpResponse create(Event event, HttpResponseBuilder responseBuilder,\n                             HttpListenerResponseBuilder listenerResponseBuilder, boolean supportsTransferEncoding)\n      throws MessagingException {\n    Map<String, String> headers = listenerResponseBuilder.getHeaders(event);\n\n    final HttpResponseHeaderBuilder httpResponseHeaderBuilder = new HttpResponseHeaderBuilder();\n\n    for (String name : headers.keySet()) {\n      // For now, only support single headers\n      if (TRANSFER_ENCODING.equals(name) && !supportsTransferEncoding) {\n        logger\n            .debug(\"Client HTTP version is lower than 1.1 so the unsupported 'Transfer-Encoding' header has been removed and 'Content-Length' will be sent instead.\");\n      } else {\n        httpResponseHeaderBuilder.addHeader(name, headers.get(name));\n      }\n    }\n\n    if (httpResponseHeaderBuilder.getContentType() == null) {\n      DataType dataType = event.getMessage().getPayload().getDataType();\n      if (!MediaType.ANY.matches(dataType.getMediaType())) {\n        httpResponseHeaderBuilder.addHeader(CONTENT_TYPE, dataType.getMediaType().toString());\n      }\n    }\n\n    final String configuredContentType = httpResponseHeaderBuilder.getContentType();\n    final String existingTransferEncoding = httpResponseHeaderBuilder.getTransferEncoding();\n    final String existingContentLength = httpResponseHeaderBuilder.getContentLength();\n\n    HttpEntity httpEntity;\n    final Object payload = event.getMessage().getPayload().getValue();\n\n    if (payload == null) {\n      setupContentLengthEncoding(httpResponseHeaderBuilder, 0);\n      httpEntity = new EmptyHttpEntity();\n    } else if (payload instanceof Map) {\n      if (configuredContentType == null) {\n        httpResponseHeaderBuilder.addContentType(HttpHeaders.Values.APPLICATION_X_WWW_FORM_URLENCODED.toRfcString());\n      } else if (!configuredContentType.startsWith(HttpHeaders.Values.APPLICATION_X_WWW_FORM_URLENCODED.toRfcString())) {\n        warnMapPayloadButNoUrlEncodedContentType(httpResponseHeaderBuilder.getContentType());\n      }\n      httpEntity = createUrlEncodedEntity(event, (Map) payload);\n      if (responseStreaming == ALWAYS && supportsTransferEncoding) {\n        setupChunkedEncoding(httpResponseHeaderBuilder);\n      } else {\n        if (httpEntity instanceof EmptyHttpEntity) {\n          setupContentLengthEncoding(httpResponseHeaderBuilder, 0);\n        } else {\n          ByteArrayHttpEntity byteArrayHttpEntity = (ByteArrayHttpEntity) httpEntity;\n          setupContentLengthEncoding(httpResponseHeaderBuilder, byteArrayHttpEntity.getContent().length);\n        }\n      }\n    } else if (payload instanceof MultiPartPayload) {\n      if (configuredContentType == null) {\n        httpResponseHeaderBuilder.addContentType(createMultipartFormDataContentType());\n      } else if (!configuredContentType.startsWith(MULTIPART)) {\n        warnNoMultipartContentTypeButMultipartEntity(httpResponseHeaderBuilder.getContentType());\n      }\n      httpEntity = createMultipartEntity(event, httpResponseHeaderBuilder.getContentType(), (MultiPartPayload) payload);\n      resolveEncoding(httpResponseHeaderBuilder, existingTransferEncoding, existingContentLength, supportsTransferEncoding,\n                      (ByteArrayHttpEntity) httpEntity);\n    } else if (payload instanceof InputStream) {\n      if (responseStreaming == ALWAYS || (responseStreaming == AUTO && existingContentLength == null)) {\n        if (supportsTransferEncoding) {\n          setupChunkedEncoding(httpResponseHeaderBuilder);\n        }\n        httpEntity = new InputStreamHttpEntity((InputStream) payload);\n      } else {\n        ByteArrayHttpEntity byteArrayHttpEntity = new ByteArrayHttpEntity(IOUtils.toByteArray(((InputStream) payload)));\n        setupContentLengthEncoding(httpResponseHeaderBuilder, byteArrayHttpEntity.getContent().length);\n        httpEntity = byteArrayHttpEntity;\n      }\n    } else {\n      try {\n        ByteArrayHttpEntity byteArrayHttpEntity = new ByteArrayHttpEntity(event.getMessageAsBytes(muleContext));\n        resolveEncoding(httpResponseHeaderBuilder, existingTransferEncoding, existingContentLength, supportsTransferEncoding,\n                        byteArrayHttpEntity);\n        httpEntity = byteArrayHttpEntity;\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    Collection<String> headerNames = httpResponseHeaderBuilder.getHeaderNames();\n    for (String headerName : headerNames) {\n      Collection<String> values = httpResponseHeaderBuilder.getHeader(headerName);\n      for (String value : values) {\n        responseBuilder.addHeader(headerName, value);\n      }\n    }\n\n    Integer statusCode = listenerResponseBuilder.getStatusCode(event);\n    if (statusCode != null) {\n      responseBuilder.setStatusCode(statusCode);\n    }\n    String reasonPhrase = resolveReasonPhrase(listenerResponseBuilder.getReasonPhrase(event), statusCode);\n    if (reasonPhrase != null) {\n      responseBuilder.setReasonPhrase(reasonPhrase);\n    }\n    responseBuilder.setEntity(httpEntity);\n    return responseBuilder.build();\n  }","commit_id":"a7a88329a31d9400a238446ba040372576c87ffb","url":"https://github.com/mulesoft/mule"},{"original_method":"public void startTest(Test test) {\r\n        TestDescriptorInternal testInternal;\r\n        synchronized (lock) {\r\n            testInternal = convert(idGenerator.generateId(), test);\r\n            TestDescriptorInternal oldTest = executing.put(test, testInternal);\r\n            assert oldTest == null;\r\n        }\r\n        long startTime = timeProvider.getCurrentTime();\r\n        resultProcessor.started(testInternal, new TestStartEvent(startTime));\r\n    }","id":99747,"modified_method":"public void startTest(Test test) {\r\n        TestDescriptorInternal descriptor = convert(idGenerator.generateId(), test);\r\n        doStartTest(test, descriptor);\r\n    }","commit_id":"bceecc0068b833daf8e3bc866f7ddaa5917c7c12","url":"https://github.com/gradle/gradle"},{"original_method":"public void addError(Test test, Throwable throwable) {\r\n        TestDescriptorInternal testInternal;\r\n        synchronized (lock) {\r\n            testInternal = executing.get(test);\r\n            assert testInternal != null;\r\n        }\r\n        resultProcessor.failure(testInternal.getId(), throwable);\r\n    }","id":99748,"modified_method":"public void addError(Test test, Throwable throwable) {\r\n        TestDescriptorInternal testInternal;\r\n        synchronized (lock) {\r\n            testInternal = executing.get(test);\r\n        }\r\n        boolean needEndEvent = false;\r\n        if (testInternal == null) {\r\n            // this happens when @AfterClass fails, for example. Synthesise a start and end events\r\n            assert test instanceof TestSuite;\r\n            TestSuite suite = (TestSuite) test;\r\n            needEndEvent = true;\r\n            testInternal = new DefaultTestMethodDescriptor(idGenerator.generateId(), suite.getName(), \"classMethod\");\r\n            doStartTest(test, testInternal);\r\n        }\r\n        resultProcessor.failure(testInternal.getId(), throwable);\r\n\r\n        if (needEndEvent) {\r\n            endTest(test);\r\n        }\r\n    }","commit_id":"bceecc0068b833daf8e3bc866f7ddaa5917c7c12","url":"https://github.com/gradle/gradle"},{"original_method":"public void output(Object testId, TestOutputEvent event) {\n        System.out.println(String.format(\"%s OUTPUT %s %s [%s]\", prefix, testId, event.getDestination(),\n                event.getMessage()));\n        processor.output(testId, event);\n    }","id":99749,"modified_method":"public void output(Object testId, TestOutputEvent event) {\n        LOGGER.lifecycle(\"{} OUTPUT {} {} [{}]\", prefix, testId, event.getDestination(), event.getMessage());\n        processor.output(testId, event);\n    }","commit_id":"bceecc0068b833daf8e3bc866f7ddaa5917c7c12","url":"https://github.com/gradle/gradle"},{"original_method":"public void completed(Object testId, TestCompleteEvent event) {\n        System.out.println(String.format(\"%s COMPLETED %s %s\", prefix, testId, event.getResultType()));\n        processor.completed(testId, event);\n    }","id":99750,"modified_method":"public void completed(Object testId, TestCompleteEvent event) {\n        LOGGER.lifecycle(\"{} COMPLETED {} {}\", prefix, testId, event.getResultType());\n        processor.completed(testId, event);\n    }","commit_id":"bceecc0068b833daf8e3bc866f7ddaa5917c7c12","url":"https://github.com/gradle/gradle"},{"original_method":"public void started(TestDescriptorInternal test, TestStartEvent event) {\n        System.out.println(String.format(\"%s START %s %s\", prefix, test.getId(), test));\n        processor.started(test, event);\n    }","id":99751,"modified_method":"public void started(TestDescriptorInternal test, TestStartEvent event) {\n        LOGGER.lifecycle(\"{} START {} {}\", prefix, test.getId(), test);\n        processor.started(test, event);\n    }","commit_id":"bceecc0068b833daf8e3bc866f7ddaa5917c7c12","url":"https://github.com/gradle/gradle"},{"original_method":"public void failure(Object testId, Throwable result) {\n        System.out.println(String.format(\"%s FAILED %s\", prefix, testId));\n        processor.failure(testId, result);\n    }","id":99752,"modified_method":"public void failure(Object testId, Throwable result) {\n        LOGGER.lifecycle(\"{} FAILED {}\", prefix, testId);\n        processor.failure(testId, result);\n    }","commit_id":"bceecc0068b833daf8e3bc866f7ddaa5917c7c12","url":"https://github.com/gradle/gradle"},{"original_method":"static void initializePersistence() {\n    PersistIce.initialize();\n    PersistNFS.initialize();\n    if( OPT_ARGS.hdfs!=null ) Hdfs.initialize();\n    if( OPT_ARGS.aws_credentials != null ) {\n      try {\n        PersistS3.getClient();\n      } catch( IllegalArgumentException iae ) { }\n    }\n  }","id":99753,"modified_method":"static void initializePersistence() {\n    PersistIce.initialize();\n    PersistNFS.initialize();\n    PersistHdfs.initialize();\n    if( H2O.OPT_ARGS.hdfs != null || H2O.OPT_ARGS.hdfs_config != null ) {\n      PersistHdfs.initialize();\n    }\n    if( OPT_ARGS.aws_credentials != null ) {\n      try {\n        PersistS3.getClient();\n      } catch( IllegalArgumentException iae ) { }\n    }\n  }","commit_id":"3edb38294674db29029d9d3a6ae8686837148512","url":"https://github.com/h2oai/h2o-2"},{"original_method":"static Key getKeyForPathString_impl(String str) {\n    assert str.indexOf(H2O.OPT_ARGS.hdfs)==0 : str;\n    return Key.make(KEY_PREFIX+str.substring(HDFS_LEN));\n  }","id":99754,"modified_method":"static Key getKeyForPathString_impl(String str) {\n    return Key.make(KEY_PREFIX+str);\n  }","commit_id":"3edb38294674db29029d9d3a6ae8686837148512","url":"https://github.com/h2oai/h2o-2"},{"original_method":"private static int addFolder(Path p) {\n    int num=0;\n    try {\n      for( FileStatus fs : _fs.listStatus(p) ) {\n        Path pfs = fs.getPath();\n        if( fs.isDir() ) {\n          num += addFolder(pfs);\n        } else {\n          num++;\n          Key k = getKeyForPathString(pfs.toString());\n          long size = fs.getLen();\n          Value val = null;\n          if( pfs.getName().endsWith(\".hex\") ) { // Hex file?\n            FSDataInputStream s = _fs.open(pfs);\n            int sz = (int)Math.min(1L<<20,size); // Read up to the 1st meg\n            byte [] mem = MemoryManager.malloc1(sz);\n            s.readFully(mem);\n            // Convert to a ValueArray (hope it fits in 1Meg!)\n            ValueArray ary = new ValueArray(k,size,Value.HDFS).read(new AutoBuffer(mem));\n            ary._persist = Value.HDFS|Value.ON_dsk;\n            val = ary.value();\n          } else if( size >= 2*ValueArray.CHUNK_SZ ) {\n            val = new ValueArray(k,size,Value.HDFS).value(); // ValueArray byte wrapper over a large file\n          } else {\n            val = new Value(k,(int)size,Value.HDFS); // Plain Value\n          }\n          val.setdsk();\n          H2O.putIfAbsent_raw(k,val);\n        }\n      }\n    } catch( IOException e ) {\n      System.err.println(\"[hdfs] Unable to list the folder \" + p.toString()+\" : \"+e);\n    }\n    return num;\n  }","id":99755,"modified_method":"public static void addFolder(Path p, JsonArray succeeded, JsonArray failed) throws IOException {\n    FileSystem fs = FileSystem.get(p.toUri(), CONF);\n    addFolder(fs, p, succeeded, failed);\n  }","commit_id":"3edb38294674db29029d9d3a6ae8686837148512","url":"https://github.com/h2oai/h2o-2"},{"original_method":"static void initialize() {}","id":99756,"modified_method":"public static void initialize() { }","commit_id":"3edb38294674db29029d9d3a6ae8686837148512","url":"https://github.com/h2oai/h2o-2"},{"original_method":"static public String appendChunk( Key key, Value val ) {\n    String res = null;\n    FSDataOutputStream s = null;\n    try {\n      s = _fs.append(getPathForKey(key));\n      System.err.println(\"[hdfs] append=\"+val.get().length);\n      s.write(val.get());\n    } catch( IOException e ) {\n      res = e.getMessage(); // Just the exception message, throwing the stack trace away\n    } finally {\n      if( s != null )\n        try { s.close(); } catch( IOException e ) { }\n    }\n    return res;\n  }","id":99757,"modified_method":"static public String appendChunk( Key key, Value val ) {\n    String res = null;\n    FSDataOutputStream s = null;\n    try {\n      Path p = getPathForKey(key);\n      FileSystem fs = FileSystem.get(p.toUri(), CONF);\n      s = fs.append(p);\n      System.err.println(\"[hdfs] append=\"+val.get().length);\n      s.write(val.get());\n    } catch( IOException e ) {\n      res = e.getMessage(); // Just the exception message, throwing the stack trace away\n    } finally {\n      Closeables.closeQuietly(s);\n    }\n    return res;\n  }","commit_id":"3edb38294674db29029d9d3a6ae8686837148512","url":"https://github.com/h2oai/h2o-2"},{"original_method":"static public Value lazyArrayChunk( Key key ) {\n    Key arykey = ValueArray.getArrayKey(key);  // From the base file key\n    long off = ValueArray.getChunkOffset(key); // The offset\n    long size = 0;\n    try {\n      size = _fs.getFileStatus(getPathForKey(arykey)).getLen();\n    } catch( IOException e ) {\n      System.err.println(e);\n      return null;\n    }\n    long rem = size-off;        // Remainder to be read\n    if( arykey.toString().endsWith(\".hex\") ) { // Hex file?\n      int value_len = DKV.get(arykey).get().length;  // How long is the ValueArray header?\n      rem -= value_len;\n    }\n    // the last chunk can be fat, so it got packed into the earlier chunk\n    if( rem < ValueArray.CHUNK_SZ && off > 0 ) return null;\n    int sz = (rem >= ValueArray.CHUNK_SZ*2) ? (int)ValueArray.CHUNK_SZ : (int)rem;\n    Value val = new Value(key,sz,Value.HDFS);\n    val.setdsk(); // But its already on disk.\n    return val;\n  }","id":99758,"modified_method":"static public Value lazyArrayChunk( Key key ) {\n    Key arykey = ValueArray.getArrayKey(key);  // From the base file key\n    long off = ValueArray.getChunkOffset(key); // The offset\n    long size = 0;\n    try {\n      Path p = getPathForKey(arykey);\n      FileSystem fs = FileSystem.get(p.toUri(), CONF);\n      size = fs.getFileStatus(p).getLen();\n    } catch( IOException e ) {\n      System.err.println(e);\n      return null;\n    }\n    long rem = size-off;        // Remainder to be read\n    if( arykey.toString().endsWith(\".hex\") ) { // Hex file?\n      int value_len = DKV.get(arykey).get().length;  // How long is the ValueArray header?\n      rem -= value_len;\n    }\n    // the last chunk can be fat, so it got packed into the earlier chunk\n    if( rem < ValueArray.CHUNK_SZ && off > 0 ) return null;\n    int sz = (rem >= ValueArray.CHUNK_SZ*2) ? (int)ValueArray.CHUNK_SZ : (int)rem;\n    Value val = new Value(key,sz,Value.HDFS);\n    val.setdsk(); // But its already on disk.\n    return val;\n  }","commit_id":"3edb38294674db29029d9d3a6ae8686837148512","url":"https://github.com/h2oai/h2o-2"},{"original_method":"static public String freeze( Key key, Freezable f ) {\n    String res = null;\n    FSDataOutputStream s = null;\n    try {\n      Path p = getPathForKey(key);\n      _fs.mkdirs(p.getParent());\n      s = _fs.create(p);\n      byte[] b = f.write(new AutoBuffer()).buf();\n      s.write(b);\n    } catch( IOException e ) {\n      res = e.getMessage(); // Just the exception message, throwing the stack trace away\n    } finally {\n      if( s != null )\n        try { s.close(); } catch( IOException e ) { }\n    }\n    return res;\n  }","id":99759,"modified_method":"static public String freeze( Key key, Freezable f ) {\n    String res = null;\n    FSDataOutputStream s = null;\n    try {\n      Path p = getPathForKey(key);\n      FileSystem fs = FileSystem.get(p.toUri(), CONF);\n      fs.mkdirs(p.getParent());\n      s = fs.create(p);\n      byte[] b = f.write(new AutoBuffer()).buf();\n      s.write(b);\n    } catch( IOException e ) {\n      res = e.getMessage(); // Just the exception message, throwing the stack trace away\n    } finally {\n      Closeables.closeQuietly(s);\n    }\n    return res;\n  }","commit_id":"3edb38294674db29029d9d3a6ae8686837148512","url":"https://github.com/h2oai/h2o-2"},{"original_method":"private static String getPathStringForKey_impl(Key k) {\n    return H2O.OPT_ARGS.hdfs+new String(k._kb,KEY_PREFIX_LEN,k._kb.length-KEY_PREFIX_LEN);\n  }","id":99760,"modified_method":"private static String getPathStringForKey_impl(Key k) {\n    return new String(k._kb, KEY_PREFIX_LEN, k._kb.length-KEY_PREFIX_LEN);\n  }","commit_id":"3edb38294674db29029d9d3a6ae8686837148512","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public static byte[] fileLoad(Value v) {\n    byte[] b = MemoryManager.malloc1(v._max);\n    FSDataInputStream s = null;\n    try {\n      long skip = 0;\n      Key k = v._key;\n      // Convert an arraylet chunk into a long-offset from the base file.\n      if( k._kb[0] == Key.ARRAYLET_CHUNK ) {\n        skip = ValueArray.getChunkOffset(k); // The offset\n        k = ValueArray.getArrayKey(k);       // From the base file key\n        if( k.toString().endsWith(\".hex\") ) { // Hex file?\n          int value_len = DKV.get(k).get().length;  // How long is the ValueArray header?\n          skip += value_len;\n        }\n      }\n      s = _fs.open(getPathForKey(k));\n      ByteStreams.skipFully(s, skip);\n      ByteStreams.readFully(s, b);\n      assert v.isPersisted();\n      return b;\n    } catch( IOException e ) { // Broken disk / short-file???\n      System.err.println(e);\n      return null;\n    } finally {\n      Closeables.closeQuietly(s);\n    }\n  }","id":99761,"modified_method":"public static byte[] fileLoad(Value v) {\n    byte[] b = MemoryManager.malloc1(v._max);\n    FSDataInputStream s = null;\n    try {\n      long skip = 0;\n      Key k = v._key;\n      // Convert an arraylet chunk into a long-offset from the base file.\n      if( k._kb[0] == Key.ARRAYLET_CHUNK ) {\n        skip = ValueArray.getChunkOffset(k); // The offset\n        k = ValueArray.getArrayKey(k);       // From the base file key\n        if( k.toString().endsWith(\".hex\") ) { // Hex file?\n          int value_len = DKV.get(k).get().length;  // How long is the ValueArray header?\n          skip += value_len;\n        }\n      }\n      Path p = getPathForKey(k);\n      FileSystem fs = FileSystem.get(p.toUri(), CONF);\n      s = fs.open(p);\n      ByteStreams.skipFully(s, skip);\n      ByteStreams.readFully(s, b);\n      assert v.isPersisted();\n      return b;\n    } catch( IOException e ) { // Broken disk / short-file???\n      System.err.println(e);\n      return null;\n    } finally {\n      Closeables.closeQuietly(s);\n    }\n  }","commit_id":"3edb38294674db29029d9d3a6ae8686837148512","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override\n  public void processCallExpression(JSCallExpression callExpression, JSSymbolVisitor visitor) {\n    JSReferenceExpression callee = (JSReferenceExpression)callExpression.getMethodExpression();\n    JSExpression qualifier = callee.getQualifier();\n\n    if (qualifier == null) return;\n\n    if (DIRECTIVE.equals(callee.getReferencedName())) {\n      JSExpression[] arguments = callExpression.getArguments();\n      if (arguments.length > 0) {\n        JSExpression argument = arguments[0];\n        if (argument instanceof JSLiteralExpression && ((JSLiteralExpression)argument).isQuotedLiteral()) {\n          visitor.storeAdditionalData(AngularDirectivesIndex.INDEX_ID.toString(),\n                                      getAttributeName(argument.getText()), argument.getTextOffset());\n        }\n      }\n    } else if (\"controller\".equals(callee.getReferencedName())) {\n      JSExpression[] arguments = callExpression.getArguments();\n      if (arguments.length > 0) {\n        JSExpression argument = arguments[0];\n        if (argument instanceof JSLiteralExpression && ((JSLiteralExpression)argument).isQuotedLiteral()) {\n          visitor.storeAdditionalData(AngularControllerIndex.INDEX_ID.toString(),\n                                      StringUtil.unquoteString(argument.getText()), argument.getTextOffset());\n        }\n      }\n    }\n  }","id":99762,"modified_method":"@Override\n  public void processCallExpression(JSCallExpression callExpression, JSSymbolVisitor visitor) {\n    JSReferenceExpression callee = (JSReferenceExpression)callExpression.getMethodExpression();\n    JSExpression qualifier = callee.getQualifier();\n\n    if (qualifier == null) return;\n\n    final String command = callee.getReferencedName();\n    if (DIRECTIVE.equals(command)) {\n      JSExpression[] arguments = callExpression.getArguments();\n      if (arguments.length > 0) {\n        JSExpression argument = arguments[0];\n        if (argument instanceof JSLiteralExpression && ((JSLiteralExpression)argument).isQuotedLiteral()) {\n          final String attributeName = getAttributeName(argument.getText());\n          visitor.storeAdditionalData(argument, AngularDirectivesIndex.INDEX_ID.toString(), attributeName, argument.getTextOffset());\n          visitor.storeAdditionalData(argument, AngularSymbolIndex.INDEX_ID.toString(), attributeName, argument.getTextOffset());\n        }\n      }\n    } else if (CONTROLLER.equals(command)) {\n      JSExpression[] arguments = callExpression.getArguments();\n      if (arguments.length > 0) {\n        JSExpression argument = arguments[0];\n        if (argument instanceof JSLiteralExpression && ((JSLiteralExpression)argument).isQuotedLiteral()) {\n          visitor.storeAdditionalData(argument, AngularControllerIndex.INDEX_ID.toString(),\n                                      StringUtil.unquoteString(argument.getText()), argument.getTextOffset());\n        }\n      }\n    }\n    if (INTERESTING_METHODS.contains(command)) {\n      JSExpression[] arguments = callExpression.getArguments();\n      if (arguments.length > 0) {\n        JSExpression argument = arguments[0];\n        if (argument instanceof JSLiteralExpression && ((JSLiteralExpression)argument).isQuotedLiteral()) {\n          visitor.storeAdditionalData(argument, AngularSymbolIndex.INDEX_ID.toString(), StringUtil.unquoteString(argument.getText()),\n                                      argument.getTextOffset());\n        }\n      }\n    }\n  }","commit_id":"1ddd37c13c64ad31d7397d8472b950cb65c8fbc2","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void processCommentMatch(@NotNull final PsiComment comment,\n                                  @NotNull JSDocumentationProcessor.MetaDocType type,\n                                  @Nullable String matchName,\n                                  @Nullable String matchValue,\n                                  @Nullable String remainingLineContent,\n                                  @NotNull String line,\n                                  String patternMatched,\n                                  JSSymbolVisitor visitor) {\n    if (type == JSDocumentationProcessor.MetaDocType.NAME &&\n        matchName != null && matchName.contains(DIRECTIVE) && hasDirectiveName(remainingLineContent)) {\n      assert remainingLineContent != null;\n      visitor.storeAdditionalData(AngularDirectivesIndex.INDEX_ID.toString(), getAttributeName(remainingLineContent.substring(1)),\n                                  comment.getTextOffset() + comment.getText().indexOf(matchName));\n    }\n  }","id":99763,"modified_method":"@Override\n  public void processCommentMatch(@NotNull final PsiComment comment,\n                                  @NotNull JSDocumentationProcessor.MetaDocType type,\n                                  @Nullable String matchName,\n                                  @Nullable String matchValue,\n                                  @Nullable String remainingLineContent,\n                                  @NotNull String line,\n                                  String patternMatched,\n                                  JSSymbolVisitor visitor) {\n    if (type == JSDocumentationProcessor.MetaDocType.NAME &&\n        matchName != null && matchName.contains(DIRECTIVE) && hasDirectiveName(remainingLineContent)) {\n      assert remainingLineContent != null;\n      final int offset = comment.getTextOffset() + comment.getText().indexOf(matchName);\n      final String attributeName = getAttributeName(remainingLineContent.substring(1));\n      visitor.storeAdditionalData(comment, AngularDirectivesIndex.INDEX_ID.toString(), attributeName, offset);\n      visitor.storeAdditionalData(comment, AngularSymbolIndex.INDEX_ID.toString(), attributeName, offset);\n    }\n  }","commit_id":"1ddd37c13c64ad31d7397d8472b950cb65c8fbc2","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void processCommentMatch(@NotNull final PsiComment comment,\n                                  @NotNull JSDocumentationProcessor.MetaDocType type,\n                                  @Nullable String matchName,\n                                  @Nullable String matchValue,\n                                  @Nullable String remainingLineContent,\n                                  @NotNull String line,\n                                  String patternMatched,\n                                  JSSymbolVisitor visitor) {\n    if (type == JSDocumentationProcessor.MetaDocType.NAME &&\n        matchName != null && matchName.contains(DIRECTIVE) && hasDirectiveName(remainingLineContent)) {\n      assert remainingLineContent != null;\n      final int offset = comment.getTextOffset() + comment.getText().indexOf(matchName);\n      final String attributeName = getAttributeName(remainingLineContent.substring(1));\n      visitor.storeAdditionalData(comment, AngularDirectivesIndex.INDEX_ID.toString(), attributeName, offset);\n      visitor.storeAdditionalData(comment, AngularSymbolIndex.INDEX_ID.toString(), attributeName, offset);\n    }\n  }","id":99764,"modified_method":"@Override\n  public void processCommentMatch(@NotNull final PsiComment comment,\n                                  @NotNull JSDocumentationProcessor.MetaDocType type,\n                                  @Nullable String matchName,\n                                  @Nullable String matchValue,\n                                  @Nullable String remainingLineContent,\n                                  @NotNull String line,\n                                  String patternMatched,\n                                  JSSymbolVisitor visitor) {\n    if (type == JSDocumentationProcessor.MetaDocType.NAME &&\n        matchName != null && matchName.contains(DIRECTIVE) && hasDirectiveName(remainingLineContent)) {\n      assert remainingLineContent != null;\n      final int offset = comment.getTextOffset() + comment.getText().indexOf(matchName);\n      final String attributeName = getAttributeName(remainingLineContent.substring(1));\n      visitor.storeAdditionalData(comment, AngularDirectivesIndex.INDEX_ID.toString(), attributeName, offset);\n      visitor.storeAdditionalData(comment, AngularSymbolIndex.INDEX_ID.toString(), attributeName, offset);\n      visitor.storeAdditionalData(comment, AngularSymbolIndex.INDEX_ID.toString(), remainingLineContent.substring(1), offset);\n    }\n  }","commit_id":"40cd4f58d756a66bc8bee46a6e9f04bd4bc0282f","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void processCallExpression(JSCallExpression callExpression, JSSymbolVisitor visitor) {\n    JSReferenceExpression callee = (JSReferenceExpression)callExpression.getMethodExpression();\n    JSExpression qualifier = callee.getQualifier();\n\n    if (qualifier == null) return;\n\n    final String command = callee.getReferencedName();\n    if (DIRECTIVE.equals(command)) {\n      JSExpression[] arguments = callExpression.getArguments();\n      if (arguments.length > 0) {\n        JSExpression argument = arguments[0];\n        if (argument instanceof JSLiteralExpression && ((JSLiteralExpression)argument).isQuotedLiteral()) {\n          final String attributeName = getAttributeName(argument.getText());\n          visitor.storeAdditionalData(argument, AngularDirectivesIndex.INDEX_ID.toString(), attributeName, argument.getTextOffset());\n          visitor.storeAdditionalData(argument, AngularSymbolIndex.INDEX_ID.toString(), attributeName, argument.getTextOffset());\n        }\n      }\n    } else if (CONTROLLER.equals(command)) {\n      JSExpression[] arguments = callExpression.getArguments();\n      if (arguments.length > 0) {\n        JSExpression argument = arguments[0];\n        if (argument instanceof JSLiteralExpression && ((JSLiteralExpression)argument).isQuotedLiteral()) {\n          visitor.storeAdditionalData(argument, AngularControllerIndex.INDEX_ID.toString(),\n                                      StringUtil.unquoteString(argument.getText()), argument.getTextOffset());\n        }\n      }\n    }\n    if (INTERESTING_METHODS.contains(command)) {\n      JSExpression[] arguments = callExpression.getArguments();\n      if (arguments.length > 0) {\n        JSExpression argument = arguments[0];\n        if (argument instanceof JSLiteralExpression && ((JSLiteralExpression)argument).isQuotedLiteral()) {\n          visitor.storeAdditionalData(argument, AngularSymbolIndex.INDEX_ID.toString(), StringUtil.unquoteString(argument.getText()),\n                                      argument.getTextOffset());\n        }\n      }\n    }\n  }","id":99765,"modified_method":"@Override\n  public void processCallExpression(JSCallExpression callExpression, JSSymbolVisitor visitor) {\n    JSReferenceExpression callee = (JSReferenceExpression)callExpression.getMethodExpression();\n    JSExpression qualifier = callee.getQualifier();\n\n    if (qualifier == null) return;\n\n    final String command = callee.getReferencedName();\n    final ID<String, Void> index = INDEXERS.get(command);\n    if (index != null) {\n      JSExpression[] arguments = callExpression.getArguments();\n      if (arguments.length > 0) {\n        JSExpression argument = arguments[0];\n        if (argument instanceof JSLiteralExpression && ((JSLiteralExpression)argument).isQuotedLiteral()) {\n          final Function<String, String> converter = NAME_CONVERTERS.get(command);\n          final String defaultName = StringUtil.unquoteString(argument.getText());\n          final String name = converter != null ? converter.fun(argument.getText()) : defaultName;\n          visitor.storeAdditionalData(argument, index.toString(), name, argument.getTextOffset());\n          visitor.storeAdditionalData(argument, AngularSymbolIndex.INDEX_ID.toString(), name, argument.getTextOffset());\n          if (!StringUtil.equals(defaultName, name)) {\n            visitor.storeAdditionalData(argument, AngularSymbolIndex.INDEX_ID.toString(), defaultName, argument.getTextOffset());\n          }\n        }\n      }\n    }\n\n    if (INTERESTING_METHODS.contains(command)) {\n      JSExpression[] arguments = callExpression.getArguments();\n      if (arguments.length > 0) {\n        JSExpression argument = arguments[0];\n        if (argument instanceof JSLiteralExpression && ((JSLiteralExpression)argument).isQuotedLiteral()) {\n          visitor.storeAdditionalData(argument, AngularSymbolIndex.INDEX_ID.toString(), StringUtil.unquoteString(argument.getText()),\n                                      argument.getTextOffset());\n        }\n      }\n    }\n  }","commit_id":"40cd4f58d756a66bc8bee46a6e9f04bd4bc0282f","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void doRefactor(final RefactoringContext refactoringContext) {\n    {\n      List<SNode> nodes = (List<SNode>)refactoringContext.getSelectedNodes();\n      SModel model = refactoringContext.getSelectedNode().getModel();\n      refactoringContext.setParameter(\"sourceModel\", model.getModelDescriptor());\n      Language sourceLanguage = Language.getLanguageFor(((SModelDescriptor)refactoringContext.getParameter(\"sourceModel\")));\n      Language targetLanguage = Language.getLanguageFor(((SModelDescriptor)refactoringContext.getParameter(\"targetModel\")));\n      List<SNode> editors = ListOperations.<SNode>createList();\n      List<SNode> behaviors = ListOperations.<SNode>createList();\n      List<SNode> constraints = ListOperations.<SNode>createList();\n      List<SNode> dataFlows = ListOperations.<SNode>createList();\n      //       collecting editors:\n      SModelDescriptor editorModelDescriptor = sourceLanguage.getEditorModelDescriptor();\n      if (editorModelDescriptor != null) {\n        for(SNode node : nodes) {\n          if (SNodeOperations.isInstanceOf(node, \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\")) {\n            SNode editor = SModelUtil.findEditorDeclaration(editorModelDescriptor.getSModel(), node);\n            if (editor != null) {\n              ListSequence.fromList(editors).addElement(editor);\n            }\n          }\n        }\n      }\n      //       collecting behaviors:\n      SModelDescriptor behaviorModelDescriptor = sourceLanguage.getBehaviorModelDescriptor();\n      if (behaviorModelDescriptor != null) {\n        for(SNode node : nodes) {\n          SNode behavior = SModelUtil.findBehaviorDeclaration(behaviorModelDescriptor.getSModel(), node);\n          if (behavior != null) {\n            ListSequence.fromList(behaviors).addElement(behavior);\n          }\n        }\n      }\n      //       collecting constraints:\n      SModelDescriptor constraintsModelDescriptor = sourceLanguage.getConstraintsModelDescriptor();\n      if (constraintsModelDescriptor != null) {\n        for(SNode node : nodes) {\n          SNode constraint = SModelUtil.findConstraintsDeclaration(constraintsModelDescriptor.getSModel(), node);\n          if (constraint != null) {\n            ListSequence.fromList(constraints).addElement(constraint);\n          }\n        }\n      }\n      //       collecting data flow:\n      SModelDescriptor dataflowModelDescriptor = sourceLanguage.getDataFlowModelDescriptor();\n      if (dataflowModelDescriptor != null) {\n        for(SNode node : nodes) {\n          SNode dataFlow = SModelUtil.findDataFlowDeclaration(dataflowModelDescriptor.getSModel(), node);\n          if (dataFlow != null) {\n            ListSequence.fromList(dataFlows).addElement(dataFlow);\n          }\n        }\n      }\n      //       refactoring itself\n      for(SNode node : nodes) {\n        refactoringContext.changeFeatureName(node, ((SModelDescriptor)refactoringContext.getParameter(\"targetModel\")).getSModelFqName().toString() + \".\" + SPropertyOperations.getString(node, \"name\"), SPropertyOperations.getString(node, \"name\"));\n      }\n      refactoringContext.moveNodesToModel(nodes, ((SModelDescriptor)refactoringContext.getParameter(\"targetModel\")).getSModel());\n      if (ListSequence.fromList(editors).isNotEmpty()) {\n        SModelDescriptor targetEditorModelDescriptor = targetLanguage.getEditorModelDescriptor();\n        if (targetEditorModelDescriptor == null) {\n          targetEditorModelDescriptor = LanguageAspect.EDITOR.createNew(targetLanguage);\n        }\n        SModel editorModel = targetEditorModelDescriptor.getSModel();\n        refactoringContext.moveNodesToModel(editors, editorModel);\n        refactoringContext.computeCaches();\n        refactoringContext.updateModelWithMaps(editorModel);\n      }\n      if (ListSequence.fromList(behaviors).isNotEmpty()) {\n        SModelDescriptor targetBehaviorModelDescriptor = targetLanguage.getBehaviorModelDescriptor();\n        if (targetBehaviorModelDescriptor == null) {\n          targetBehaviorModelDescriptor = LanguageAspect.BEHAVIOR.createNew(targetLanguage);\n        }\n        SModel behaviorModel = targetBehaviorModelDescriptor.getSModel();\n        refactoringContext.moveNodesToModel(behaviors, behaviorModel);\n        refactoringContext.computeCaches();\n        refactoringContext.updateModelWithMaps(behaviorModel);\n      }\n      if (ListSequence.fromList(constraints).isNotEmpty()) {\n        SModelDescriptor targetConstraintsModelDescriptor = targetLanguage.getConstraintsModelDescriptor();\n        if (targetConstraintsModelDescriptor == null) {\n          targetConstraintsModelDescriptor = LanguageAspect.CONSTRAINTS.createNew(targetLanguage);\n        }\n        SModel constraintsModel = targetConstraintsModelDescriptor.getSModel();\n        refactoringContext.moveNodesToModel(constraints, constraintsModel);\n        refactoringContext.computeCaches();\n        refactoringContext.updateModelWithMaps(constraintsModel);\n      }\n      if (ListSequence.fromList(dataFlows).isNotEmpty()) {\n        SModelDescriptor targetDataFlowModelDescriptor = targetLanguage.getDataFlowModelDescriptor();\n        if (targetDataFlowModelDescriptor == null) {\n          targetDataFlowModelDescriptor = LanguageAspect.DATA_FLOW.createNew(targetLanguage);\n        }\n        SModel dataFlowModel = targetDataFlowModelDescriptor.getSModel();\n        refactoringContext.moveNodesToModel(dataFlows, dataFlowModel);\n        refactoringContext.computeCaches();\n        refactoringContext.updateModelWithMaps(dataFlowModel);\n      }\n      //       todo: move other concept-related aspect stuff\n    }\n  }","id":99766,"modified_method":"public void doRefactor(final RefactoringContext refactoringContext) {\n    {\n      List<SNode> nodes = (List<SNode>)refactoringContext.getSelectedNodes();\n      refactoringContext.setParameter(\"sourceModel\", SNodeOperations.getModel(ListSequence.fromList(refactoringContext.getSelectedNodes()).first()).getModelDescriptor());\n      Language sourceLanguage = Language.getLanguageFor(((SModelDescriptor)refactoringContext.getParameter(\"sourceModel\")));\n      Language targetLanguage = Language.getLanguageFor(((SModelDescriptor)refactoringContext.getParameter(\"targetModel\")));\n      List<SNode> editors = ListOperations.<SNode>createList();\n      List<SNode> behaviors = ListOperations.<SNode>createList();\n      List<SNode> constraints = ListOperations.<SNode>createList();\n      List<SNode> dataFlows = ListOperations.<SNode>createList();\n      //       collecting editors:\n      SModelDescriptor editorModelDescriptor = sourceLanguage.getEditorModelDescriptor();\n      if (editorModelDescriptor != null) {\n        for(SNode node : nodes) {\n          if (SNodeOperations.isInstanceOf(node, \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\")) {\n            SNode editor = SModelUtil.findEditorDeclaration(editorModelDescriptor.getSModel(), node);\n            if (editor != null) {\n              ListSequence.fromList(editors).addElement(editor);\n            }\n          }\n        }\n      }\n      //       collecting behaviors:\n      SModelDescriptor behaviorModelDescriptor = sourceLanguage.getBehaviorModelDescriptor();\n      if (behaviorModelDescriptor != null) {\n        for(SNode node : nodes) {\n          SNode behavior = SModelUtil.findBehaviorDeclaration(behaviorModelDescriptor.getSModel(), node);\n          if (behavior != null) {\n            ListSequence.fromList(behaviors).addElement(behavior);\n          }\n        }\n      }\n      //       collecting constraints:\n      SModelDescriptor constraintsModelDescriptor = sourceLanguage.getConstraintsModelDescriptor();\n      if (constraintsModelDescriptor != null) {\n        for(SNode node : nodes) {\n          SNode constraint = SModelUtil.findConstraintsDeclaration(constraintsModelDescriptor.getSModel(), node);\n          if (constraint != null) {\n            ListSequence.fromList(constraints).addElement(constraint);\n          }\n        }\n      }\n      //       collecting data flow:\n      SModelDescriptor dataflowModelDescriptor = sourceLanguage.getDataFlowModelDescriptor();\n      if (dataflowModelDescriptor != null) {\n        for(SNode node : nodes) {\n          SNode dataFlow = SModelUtil.findDataFlowDeclaration(dataflowModelDescriptor.getSModel(), node);\n          if (dataFlow != null) {\n            ListSequence.fromList(dataFlows).addElement(dataFlow);\n          }\n        }\n      }\n      //       refactoring itself\n      for(SNode node : nodes) {\n        refactoringContext.changeFeatureName(node, ((SModelDescriptor)refactoringContext.getParameter(\"targetModel\")).getSModelFqName().toString() + \".\" + SPropertyOperations.getString(node, \"name\"), SPropertyOperations.getString(node, \"name\"));\n      }\n      refactoringContext.moveNodesToModel(nodes, ((SModelDescriptor)refactoringContext.getParameter(\"targetModel\")).getSModel());\n      if (ListSequence.fromList(editors).isNotEmpty()) {\n        SModelDescriptor targetEditorModelDescriptor = targetLanguage.getEditorModelDescriptor();\n        if (targetEditorModelDescriptor == null) {\n          targetEditorModelDescriptor = LanguageAspect.EDITOR.createNew(targetLanguage);\n        }\n        SModel editorModel = targetEditorModelDescriptor.getSModel();\n        refactoringContext.moveNodesToModel(editors, editorModel);\n        refactoringContext.computeCaches();\n        refactoringContext.updateModelWithMaps(editorModel);\n      }\n      if (ListSequence.fromList(behaviors).isNotEmpty()) {\n        SModelDescriptor targetBehaviorModelDescriptor = targetLanguage.getBehaviorModelDescriptor();\n        if (targetBehaviorModelDescriptor == null) {\n          targetBehaviorModelDescriptor = LanguageAspect.BEHAVIOR.createNew(targetLanguage);\n        }\n        SModel behaviorModel = targetBehaviorModelDescriptor.getSModel();\n        refactoringContext.moveNodesToModel(behaviors, behaviorModel);\n        refactoringContext.computeCaches();\n        refactoringContext.updateModelWithMaps(behaviorModel);\n      }\n      if (ListSequence.fromList(constraints).isNotEmpty()) {\n        SModelDescriptor targetConstraintsModelDescriptor = targetLanguage.getConstraintsModelDescriptor();\n        if (targetConstraintsModelDescriptor == null) {\n          targetConstraintsModelDescriptor = LanguageAspect.CONSTRAINTS.createNew(targetLanguage);\n        }\n        SModel constraintsModel = targetConstraintsModelDescriptor.getSModel();\n        refactoringContext.moveNodesToModel(constraints, constraintsModel);\n        refactoringContext.computeCaches();\n        refactoringContext.updateModelWithMaps(constraintsModel);\n      }\n      if (ListSequence.fromList(dataFlows).isNotEmpty()) {\n        SModelDescriptor targetDataFlowModelDescriptor = targetLanguage.getDataFlowModelDescriptor();\n        if (targetDataFlowModelDescriptor == null) {\n          targetDataFlowModelDescriptor = LanguageAspect.DATA_FLOW.createNew(targetLanguage);\n        }\n        SModel dataFlowModel = targetDataFlowModelDescriptor.getSModel();\n        refactoringContext.moveNodesToModel(dataFlows, dataFlowModel);\n        refactoringContext.computeCaches();\n        refactoringContext.updateModelWithMaps(dataFlowModel);\n      }\n      //       todo: move other concept-related aspect stuff\n    }\n  }","commit_id":"d051a1ed6da0fea48c851b83a09996792713893b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isApplicable(RefactoringContext refactoringContext) {\n    {\n      List<SNode> nodes = refactoringContext.getSelectedNodes();\n      if (ListSequence.fromList(nodes).isEmpty()) {\n        return false;\n      }\n      for(SNode node : nodes) {\n        if (!(SNodeOperations.isInstanceOf(node, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\"))) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }","id":99767,"modified_method":"public boolean isApplicable(RefactoringContext refactoringContext) {\n    {\n      if (ListSequence.fromList(refactoringContext.getSelectedNodes()).isEmpty()) {\n        return false;\n      }\n      SModel model = SNodeOperations.getModel(ListSequence.fromList(refactoringContext.getSelectedNodes()).first());\n      for(SNode node : refactoringContext.getSelectedNodes()) {\n        if (!(SNodeOperations.isInstanceOf(node, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\"))) {\n          return false;\n        }\n        if (SNodeOperations.getModel(node) != model) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }","commit_id":"d051a1ed6da0fea48c851b83a09996792713893b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SearchResults getAffectedNodes(final RefactoringContext refactoringContext) {\n    return FindUtils.getSearchResults(ActionEventData.createProgressIndicator(), refactoringContext.getSelectedNode(), GlobalScope.getInstance(), \"jetbrains.mps.lang.structure.findUsages.ConceptInstances_Finder\", \"jetbrains.mps.lang.structure.findUsages.NodeAndDescendantsUsages_Finder\");\n  }","id":99768,"modified_method":"public SearchResults getAffectedNodes(final RefactoringContext refactoringContext) {\n    {\n      SearchResults searchResults = new SearchResults();\n      for(SNode selNode : ListSequence.fromList(refactoringContext.getSelectedNodes())) {\n        searchResults.addAll(FindUtils.getSearchResults(ActionEventData.createProgressIndicator(), selNode, GlobalScope.getInstance(), \"jetbrains.mps.lang.structure.findUsages.ConceptInstances_Finder\", \"jetbrains.mps.lang.structure.findUsages.NodeAndDescendantsUsages_Finder\"));\n      }\n      return searchResults;\n    }\n  }","commit_id":"d051a1ed6da0fea48c851b83a09996792713893b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SearchResults getAffectedNodes(final RefactoringContext refactoringContext) {\n    return FindUtils.getSearchResults(ActionEventData.createProgressIndicator(), refactoringContext.getSelectedNode(), GlobalScope.getInstance(), \"jetbrains.mps.lang.structure.findUsages.NodeAndDescendantsUsages_Finder\");\n  }","id":99769,"modified_method":"public SearchResults getAffectedNodes(final RefactoringContext refactoringContext) {\n    {\n      SearchResults searchResults = new SearchResults();\n      for(SNode selNode : ListSequence.fromList(refactoringContext.getSelectedNodes())) {\n        searchResults.addAll(FindUtils.getSearchResults(ActionEventData.createProgressIndicator(), selNode, GlobalScope.getInstance(), \"jetbrains.mps.lang.structure.findUsages.NodeAndDescendantsUsages_Finder\"));\n      }\n      return searchResults;\n    }\n  }","commit_id":"d051a1ed6da0fea48c851b83a09996792713893b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      List<SModel> models = ListSequence.fromListWithValues(new ArrayList<SModel>(), Sequence.fromIterable(((Iterable<SModel>) SModelRepository.getInstance().getModelDescriptors())).where(new IWhereFilter<SModel>() {\n        public boolean accept(SModel md) {\n          return SModelStereotype.isUserModel(md);\n        }\n      }));\n      ModelCheckerTool.getInstance(((Project) MapSequence.fromMap(_params).get(\"project\"))).checkModels(models, ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true, new AdapterUsagesFinder());\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"FindAllAdapterUsages\", t);\n      }\n    }\n  }","id":99770,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      List<SModel> models = ListSequence.fromListWithValues(new ArrayList<SModel>(), Sequence.fromIterable(((Iterable<SModel>) SModelRepository.getInstance().getModelDescriptors())).where(new IWhereFilter<SModel>() {\n        public boolean accept(SModel md) {\n          return SModelStereotype.isUserModel(md);\n        }\n      }));\n      ModelCheckerTool.getInstance(((Project) MapSequence.fromMap(_params).get(\"project\"))).checkModels(models, ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true, new ModelCheckerIssueFinder(new AdapterUsagesChecker()));\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"FindAllAdapterUsages\", t);\n      }\n    }\n  }","commit_id":"176f26fa2dd21faf5240b44c6e6dc8c32da82786","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      List<SModel> modelDescriptors = ListSequence.fromListWithValues(new ArrayList<SModel>(), Sequence.fromIterable(((Iterable<SModel>) SModelRepository.getInstance().getModelDescriptors())).where(new IWhereFilter<SModel>() {\n        public boolean accept(SModel md) {\n          return SModelStereotype.isGeneratorModel(md) && SNodeOperations.isGeneratable(md);\n        }\n      }));\n\n      ModelCheckerTool.getInstance(((Project) MapSequence.fromMap(_params).get(\"project\"))).checkModels(modelDescriptors, ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true, new ModelCheckerIssueFinder() {\n        @Override\n        protected List<SpecificChecker> getSpecificCheckers() {\n          return ListSequence.fromListAndArray(new ArrayList<SpecificChecker>(), new GeneratorTemplatesChecker());\n        }\n      });\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"FindCrossTemplateReferences\", t);\n      }\n    }\n  }","id":99771,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      List<SModel> modelDescriptors = ListSequence.fromListWithValues(new ArrayList<SModel>(), Sequence.fromIterable(((Iterable<SModel>) SModelRepository.getInstance().getModelDescriptors())).where(new IWhereFilter<SModel>() {\n        public boolean accept(SModel md) {\n          return SModelStereotype.isGeneratorModel(md) && SNodeOperations.isGeneratable(md);\n        }\n      }));\n\n      ModelCheckerTool.getInstance(((Project) MapSequence.fromMap(_params).get(\"project\"))).checkModels(modelDescriptors, ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true, new ModelCheckerIssueFinder(new GeneratorTemplatesChecker()));\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"FindCrossTemplateReferences\", t);\n      }\n    }\n  }","commit_id":"176f26fa2dd21faf5240b44c6e6dc8c32da82786","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final List<SModel> modelDescriptors = ListSequence.fromListWithValues(new ArrayList<SModel>(), Sequence.fromIterable(((Iterable<SModel>) SModelRepository.getInstance().getModelDescriptors())).where(new IWhereFilter<SModel>() {\n        public boolean accept(SModel md) {\n          return SModelStereotype.isUserModel(md);\n        }\n      }));\n\n      ModelCheckerTool.getInstance(((Project) MapSequence.fromMap(_params).get(\"project\"))).checkModels(modelDescriptors, ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true, new ModelCheckerIssueFinder() {\n        @Override\n        protected List<SpecificChecker> getSpecificCheckers() {\n          return ListSequence.fromListAndArray(new ArrayList<SpecificChecker>(), new ReferenceableConceptsChecker());\n        }\n      });\n\n      // extra debug \n      final Wrappers._int total = new Wrappers._int();\n      final Wrappers._int referenceable = new Wrappers._int();\n      final Map<String, Integer> used = MapSequence.fromMap(new HashMap<String, Integer>());\n\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          ListSequence.fromList(modelDescriptors).visitAll(new IVisitor<SModel>() {\n            public void visit(SModel it) {\n              for (SNode n : it.getRootNodes()) {\n                for (SNode i : SNodeOperations.getNodeDescendants(n, null, true, new SConcept[]{})) {\n                  SNode ccp = SNodeOperations.as(((SNode) ((jetbrains.mps.smodel.SNode) i).getConceptDeclarationNode()), MetaAdapterFactory.getConcept(new UUID(-4094437568663370681l, -8968368868337559369l), 1071489090640l, \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\"));\n                  if (ccp != null) {\n                    total.value++;\n                    if (!(SPropertyOperations.hasValue(ccp, MetaAdapterFactory.getProperty(new UUID(-4094437568663370681l, -8968368868337559369l), 1071489090640l, 5404671619616246344l, \"staticScope\"), \"none\", null))) {\n                      referenceable.value++;\n                      String cname = BehaviorReflection.invokeVirtual(String.class, ccp, \"virtual_getFqName_1213877404258\", new Object[]{});\n                      if (MapSequence.fromMap(used).containsKey(cname)) {\n                        MapSequence.fromMap(used).put(cname, MapSequence.fromMap(used).get(cname) + 1);\n                      } else {\n                        MapSequence.fromMap(used).put(cname, 1);\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          });\n        }\n      });\n      String[] usedNames = SetSequence.fromSet(MapSequence.fromMap(used).keySet()).toGenericArray(String.class);\n      Arrays.sort(usedNames, new Comparator<String>() {\n        public int compare(String a, String b) {\n          return new Integer(MapSequence.fromMap(used).get(a)).compareTo(MapSequence.fromMap(used).get(b));\n        }\n      });\n      System.out.println(\"\" + referenceable.value + \" out of \" + total.value + \" nodes are referenceable\");\n      for (String s : usedNames) {\n        System.out.println(MapSequence.fromMap(used).get(s) + \"  \" + s);\n      }\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"FindReferencesToNonReferenceable\", t);\n      }\n    }\n  }","id":99772,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final List<SModel> modelDescriptors = ListSequence.fromListWithValues(new ArrayList<SModel>(), Sequence.fromIterable(((Iterable<SModel>) SModelRepository.getInstance().getModelDescriptors())).where(new IWhereFilter<SModel>() {\n        public boolean accept(SModel md) {\n          return SModelStereotype.isUserModel(md);\n        }\n      }));\n\n      ModelCheckerTool.getInstance(((Project) MapSequence.fromMap(_params).get(\"project\"))).checkModels(modelDescriptors, ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true, new ModelCheckerIssueFinder(new ReferenceableConceptsChecker()));\n\n      // extra debug \n      final Wrappers._int total = new Wrappers._int();\n      final Wrappers._int referenceable = new Wrappers._int();\n      final Map<String, Integer> used = MapSequence.fromMap(new HashMap<String, Integer>());\n\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          ListSequence.fromList(modelDescriptors).visitAll(new IVisitor<SModel>() {\n            public void visit(SModel it) {\n              for (SNode n : it.getRootNodes()) {\n                for (SNode i : SNodeOperations.getNodeDescendants(n, null, true, new SConcept[]{})) {\n                  SNode ccp = SNodeOperations.as(((SNode) ((jetbrains.mps.smodel.SNode) i).getConceptDeclarationNode()), MetaAdapterFactory.getConcept(new UUID(-4094437568663370681l, -8968368868337559369l), 1071489090640l, \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\"));\n                  if (ccp != null) {\n                    total.value++;\n                    if (!(SPropertyOperations.hasValue(ccp, MetaAdapterFactory.getProperty(new UUID(-4094437568663370681l, -8968368868337559369l), 1071489090640l, 5404671619616246344l, \"staticScope\"), \"none\", null))) {\n                      referenceable.value++;\n                      String cname = BehaviorReflection.invokeVirtual(String.class, ccp, \"virtual_getFqName_1213877404258\", new Object[]{});\n                      if (MapSequence.fromMap(used).containsKey(cname)) {\n                        MapSequence.fromMap(used).put(cname, MapSequence.fromMap(used).get(cname) + 1);\n                      } else {\n                        MapSequence.fromMap(used).put(cname, 1);\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          });\n        }\n      });\n      String[] usedNames = SetSequence.fromSet(MapSequence.fromMap(used).keySet()).toGenericArray(String.class);\n      Arrays.sort(usedNames, new Comparator<String>() {\n        public int compare(String a, String b) {\n          return new Integer(MapSequence.fromMap(used).get(a)).compareTo(MapSequence.fromMap(used).get(b));\n        }\n      });\n      System.out.println(\"\" + referenceable.value + \" out of \" + total.value + \" nodes are referenceable\");\n      for (String s : usedNames) {\n        System.out.println(MapSequence.fromMap(used).get(s) + \"  \" + s);\n      }\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"FindReferencesToNonReferenceable\", t);\n      }\n    }\n  }","commit_id":"176f26fa2dd21faf5240b44c6e6dc8c32da82786","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      List<SModel> models = ListSequence.fromListWithValues(new ArrayList<SModel>(), Sequence.fromIterable(((Iterable<SModel>) SModelRepository.getInstance().getModelDescriptors())).where(new IWhereFilter<SModel>() {\n        public boolean accept(SModel md) {\n          return FindWrongAspectDependencies_Action.this.needsProcessing(md, _params);\n        }\n      }));\n      ModelCheckerTool.getInstance(((Project) MapSequence.fromMap(_params).get(\"project\"))).checkModels(models, ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true, new WrongAspectDependenciesFinder());\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"FindWrongAspectDependencies\", t);\n      }\n    }\n  }","id":99773,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      List<SModel> models = ListSequence.fromListWithValues(new ArrayList<SModel>(), Sequence.fromIterable(((Iterable<SModel>) SModelRepository.getInstance().getModelDescriptors())).where(new IWhereFilter<SModel>() {\n        public boolean accept(SModel md) {\n          return FindWrongAspectDependencies_Action.this.needsProcessing(md, _params);\n        }\n      }));\n      ModelCheckerTool.getInstance(((Project) MapSequence.fromMap(_params).get(\"project\"))).checkModels(models, ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true, new ModelCheckerIssueFinder(new AspectDependenciesChecker()));\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"FindWrongAspectDependencies\", t);\n      }\n    }\n  }","commit_id":"176f26fa2dd21faf5240b44c6e6dc8c32da82786","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      List<SModel> models = ListSequence.fromListWithValues(new ArrayList<SModel>(), Sequence.fromIterable(((Iterable<SModel>) SModelRepository.getInstance().getModelDescriptors())).where(new IWhereFilter<SModel>() {\n        public boolean accept(SModel md) {\n          return SModelStereotype.isUserModel(md);\n        }\n      }));\n      ModelCheckerTool.getInstance(((Project) MapSequence.fromMap(_params).get(\"project\"))).checkModels(models, ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true, new BrokenReferencesFinder());\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"FindlAllBrokenReferences\", t);\n      }\n    }\n  }","id":99774,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      List<SModel> models = ListSequence.fromListWithValues(new ArrayList<SModel>(), Sequence.fromIterable(((Iterable<SModel>) SModelRepository.getInstance().getModelDescriptors())).where(new IWhereFilter<SModel>() {\n        public boolean accept(SModel md) {\n          return SModelStereotype.isUserModel(md);\n        }\n      }));\n      ModelCheckerTool.getInstance(((Project) MapSequence.fromMap(_params).get(\"project\"))).checkModels(models, ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true, new ModelCheckerIssueFinder(new UnresolvedReferencesChecker()));\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"FindlAllBrokenReferences\", t);\n      }\n    }\n  }","commit_id":"176f26fa2dd21faf5240b44c6e6dc8c32da82786","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void checkModel(final SModel model, final ProgressMonitor monitor) {\n    final Wrappers._T<List<SpecificChecker>> specificCheckers = new Wrappers._T<List<SpecificChecker>>(mySpecificCheckers);\n    if (specificCheckers.value == null) {\n      specificCheckers.value = ModelCheckerSettings.getInstance().getSpecificCheckers();\n    }\n\n    monitor.start(\"Checking \" + model.getModelName(), ListSequence.fromList(specificCheckers.value).count());\n    try {\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          SModule module = model.getModule();\n          Project project = myOperationContext.getProject();\n\n          if (module == null) {\n            if (LOG.isEnabledFor(Level.WARN)) {\n              LOG.warn(\"Module is null for \" + model.getModelName() + \" model\");\n            }\n          }\n          if (project == null) {\n            if (LOG.isEnabledFor(Level.WARN)) {\n              LOG.warn(\"Project is null for IOperationContext in \" + model.getModelName() + \" model\");\n            }\n          }\n\n          if (module != null && project != null) {\n            for (SpecificChecker specificChecker : ListSequence.fromList(specificCheckers.value)) {\n              try {\n                List<SearchResult<ModelCheckerIssue>> specificCheckerResults = specificChecker.checkModel(model, monitor.subTask(1, SubProgressKind.AS_COMMENT), project.getRepository());\n                myResults.getSearchResults().addAll(specificCheckerResults);\n              } catch (Throwable t) {\n                if (LOG.isEnabledFor(Level.ERROR)) {\n                  LOG.error(\"Error while \" + model.getModelName() + \" model checking\", t);\n                }\n              }\n              if (monitor.isCanceled()) {\n                break;\n              }\n            }\n          }\n        }\n      });\n    } finally {\n      monitor.done();\n    }\n  }","id":99775,"modified_method":"public void checkModel(final SModel model, final ProgressMonitor monitor) {\n    final Wrappers._T<List<SpecificChecker>> specificCheckers = new Wrappers._T<List<SpecificChecker>>(mySpecificCheckers);\n    if (specificCheckers.value == null) {\n      specificCheckers.value = ModelCheckerSettings.getInstance().getSpecificCheckers();\n    }\n\n    monitor.start(\"Checking \" + model.getModelName(), ListSequence.fromList(specificCheckers.value).count());\n    try {\n\n      myProject.getModelAccess().runReadAction(new Runnable() {\n        public void run() {\n          SModule module = model.getModule();\n\n          if (module == null) {\n            if (LOG.isEnabledFor(Level.WARN)) {\n              LOG.warn(\"Module is null for \" + model.getModelName() + \" model\");\n            }\n          }\n\n          if (module != null) {\n            for (SpecificChecker specificChecker : ListSequence.fromList(specificCheckers.value)) {\n              try {\n                List<SearchResult<ModelCheckerIssue>> specificCheckerResults = specificChecker.checkModel(model, monitor.subTask(1, SubProgressKind.AS_COMMENT), myProject.getRepository());\n                myResults.getSearchResults().addAll(specificCheckerResults);\n              } catch (Throwable t) {\n                if (LOG.isEnabledFor(Level.ERROR)) {\n                  LOG.error(\"Error while \" + model.getModelName() + \" model checking\", t);\n                }\n              }\n              if (monitor.isCanceled()) {\n                break;\n              }\n            }\n          }\n        }\n      });\n    } finally {\n      monitor.done();\n    }\n  }","commit_id":"176f26fa2dd21faf5240b44c6e6dc8c32da82786","url":"https://github.com/JetBrains/MPS"},{"original_method":"private Runnable createProcess(final boolean spawnCommands, final ProgressMonitor monitor) {\n    return new Runnable() {\n      @Override\n      public void run() {\n        IResultProvider resultProvider = FindUtils.makeProvider(new ModelCheckerIssueFinder() {\n          @Override\n          protected List<SpecificChecker> getSpecificCheckers() {\n            return getMySpecificCheckers();\n          }\n        });\n        final ProgressMonitor promon = getOrCreateProgressMonitor(monitor);\n        promon.start(\"Executing Model Fixes\", 200);\n\n        SearchQuery searchQuery = new SearchQuery(new ModulesHolder(modules, context), getMPSProject().getScope());\n        SearchResults searchResults = FindUtils.getSearchResults(promon.subTask(100), searchQuery, resultProvider);\n        searchResults.removeDuplicates();\n\n        List<ModelCheckerIssue> issuesToFix = ListSequence.fromList(((List<SearchResult<ModelCheckerIssue>>) searchResults.getSearchResults())).select(new ISelector<SearchResult<ModelCheckerIssue>, ModelCheckerIssue>() {\n          public ModelCheckerIssue select(SearchResult<ModelCheckerIssue> sr) {\n            return sr.getObject();\n          }\n        }).where(new IWhereFilter<ModelCheckerIssue>() {\n          public boolean accept(ModelCheckerIssue sro) {\n            return sro instanceof ModelCheckerIssue.NodeIssue && sro.isFixable();\n          }\n        }).toListSequence();\n\n\n        ModelCheckerController controller = new ModelCheckerController() {\n          @Override\n          public void runCommand(Runnable cmd) {\n            if (spawnCommands) {\n              getMPSProject().getModelAccess().executeCommandInEDT(cmd);\n            } else {\n              cmd.run();\n            }\n          }\n        };\n        controller.process(promon.subTask(100), issuesToFix);\n\n        promon.done();\n      }\n    };\n  }","id":99776,"modified_method":"private Runnable createProcess(final boolean spawnCommands, final ProgressMonitor monitor) {\n    return new Runnable() {\n      @Override\n      public void run() {\n        IResultProvider resultProvider = FindUtils.makeProvider(new ModelCheckerIssueFinder(getMySpecificCheckers()));\n        final ProgressMonitor promon = getOrCreateProgressMonitor(monitor);\n        promon.start(\"Executing Model Fixes\", 200);\n\n        SearchQuery searchQuery = new SearchQuery(new ModulesHolder(modules, context), getMPSProject().getScope());\n        SearchResults searchResults = FindUtils.getSearchResults(promon.subTask(100), searchQuery, resultProvider);\n        searchResults.removeDuplicates();\n\n        List<ModelCheckerIssue> issuesToFix = ListSequence.fromList(((List<SearchResult<ModelCheckerIssue>>) searchResults.getSearchResults())).select(new ISelector<SearchResult<ModelCheckerIssue>, ModelCheckerIssue>() {\n          public ModelCheckerIssue select(SearchResult<ModelCheckerIssue> sr) {\n            return sr.getObject();\n          }\n        }).where(new IWhereFilter<ModelCheckerIssue>() {\n          public boolean accept(ModelCheckerIssue sro) {\n            return sro instanceof ModelCheckerIssue.NodeIssue && sro.isFixable();\n          }\n        }).toListSequence();\n\n\n        ModelCheckerController controller = new ModelCheckerController() {\n          @Override\n          public void runCommand(Runnable cmd) {\n            if (spawnCommands) {\n              getMPSProject().getModelAccess().executeCommandInEDT(cmd);\n            } else {\n              cmd.run();\n            }\n          }\n        };\n        controller.process(promon.subTask(100), issuesToFix);\n\n        promon.done();\n      }\n    };\n  }","commit_id":"176f26fa2dd21faf5240b44c6e6dc8c32da82786","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public SearchResults find(SearchQuery searchQuery, ProgressMonitor monitor) {\n    IHolder objectHolder = searchQuery.getObjectHolder();\n    IOperationContext operationContext;\n    List<SModel> models;\n    List<SModule> modules = null;\n    if (objectHolder instanceof ModelsHolder) {\n      ModelsHolder modelsHolder = (ModelsHolder) objectHolder;\n      operationContext = modelsHolder.getOperationContext();\n      models = Sequence.fromIterable(((Iterable<SModelReference>) modelsHolder.getObject())).select(new ISelector<SModelReference, SModel>() {\n        public SModel select(SModelReference ref) {\n          return SModelRepository.getInstance().getModelDescriptor(ref);\n        }\n      }).where(new IWhereFilter<SModel>() {\n        public boolean accept(SModel it) {\n          return it != null;\n        }\n      }).toListSequence();\n    } else if (objectHolder instanceof ModulesHolder) {\n      ModulesHolder modulesHolder = (ModulesHolder) objectHolder;\n      operationContext = modulesHolder.getOperationContext();\n      models = ModelCheckerUtils.getModelDescriptors(modulesHolder.getObject());\n      modules = modulesHolder.getObject();\n    } else {\n      throw new IllegalArgumentException();\n    }\n\n    int work = ((modules != null ? ListSequence.fromList(modules).count() : 0)) + ListSequence.fromList(models).count() + 1;\n    monitor.start(\"Checking\", work);\n\n    try {\n      ModuleChecker moduleChecker = null;\n      if (modules != null) {\n        moduleChecker = new ModuleChecker();\n        for (SModule module : ListSequence.fromList(modules)) {\n          moduleChecker.checkModule(module, monitor.subTask(1, SubProgressKind.REPLACING));\n          if (monitor.isCanceled()) {\n            break;\n          }\n        }\n      }\n      monitor.advance(0);\n      ModelChecker modelChecker;\n      if (moduleChecker != null) {\n        modelChecker = new ModelChecker(operationContext, moduleChecker.getSearchResults());\n      } else {\n        modelChecker = new ModelChecker(operationContext);\n      }\n      modelChecker.setSpecificCheckers(getSpecificCheckers());\n      monitor.advance(1);\n\n      for (SModel modelDescriptor : ListSequence.fromList(models)) {\n        modelChecker.checkModel(modelDescriptor, monitor.subTask(1, SubProgressKind.REPLACING));\n        if (monitor.isCanceled()) {\n          break;\n        }\n      }\n      return modelChecker.getSearchResults();\n    } finally {\n      monitor.done();\n    }\n  }","id":99777,"modified_method":"@Override\n  public SearchResults find(SearchQuery searchQuery, ProgressMonitor monitor) {\n    IHolder objectHolder = searchQuery.getObjectHolder();\n    IOperationContext operationContext;\n    List<SModel> models;\n    List<SModule> modules = null;\n    if (objectHolder instanceof ModelsHolder) {\n      ModelsHolder modelsHolder = (ModelsHolder) objectHolder;\n      operationContext = modelsHolder.getOperationContext();\n      models = Sequence.fromIterable(((Iterable<SModelReference>) modelsHolder.getObject())).select(new ISelector<SModelReference, SModel>() {\n        public SModel select(SModelReference ref) {\n          return SModelRepository.getInstance().getModelDescriptor(ref);\n        }\n      }).where(new IWhereFilter<SModel>() {\n        public boolean accept(SModel it) {\n          return it != null;\n        }\n      }).toListSequence();\n    } else if (objectHolder instanceof ModulesHolder) {\n      ModulesHolder modulesHolder = (ModulesHolder) objectHolder;\n      operationContext = modulesHolder.getOperationContext();\n      models = ModelCheckerUtils.getModelDescriptors(modulesHolder.getObject());\n      modules = modulesHolder.getObject();\n    } else {\n      throw new IllegalArgumentException();\n    }\n\n    int work = ((modules != null ? ListSequence.fromList(modules).count() : 0)) + ListSequence.fromList(models).count() + 1;\n    monitor.start(\"Checking\", work);\n\n    try {\n      SearchResults<ModelCheckerIssue> rv = new SearchResults<ModelCheckerIssue>();\n      if (modules != null) {\n        ModuleChecker moduleChecker = new ModuleChecker();\n        for (SModule module : ListSequence.fromList(modules)) {\n          moduleChecker.checkModule(module, monitor.subTask(1, SubProgressKind.REPLACING));\n          if (monitor.isCanceled()) {\n            break;\n          }\n        }\n        rv.addAll(moduleChecker.getSearchResults());\n      }\n      monitor.advance(0);\n\n      Project mpsProject = operationContext.getProject();\n      ModelChecker modelChecker = new ModelChecker(mpsProject);\n      modelChecker.setSpecificCheckers(getSpecificCheckers());\n      monitor.advance(1);\n      for (SModel modelDescriptor : ListSequence.fromList(models)) {\n        modelChecker.checkModel(modelDescriptor, monitor.subTask(1, SubProgressKind.REPLACING));\n        if (monitor.isCanceled()) {\n          break;\n        }\n      }\n      rv.addAll(modelChecker.getSearchResults());\n      return rv;\n    } finally {\n      monitor.done();\n    }\n  }","commit_id":"176f26fa2dd21faf5240b44c6e6dc8c32da82786","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected List<SpecificChecker> getSpecificCheckers() {\n    return null;\n  }","id":99778,"modified_method":"protected List<SpecificChecker> getSpecificCheckers() {\n    return myExtraCheckers;\n  }","commit_id":"176f26fa2dd21faf5240b44c6e6dc8c32da82786","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ModelCheckerIssueFinder() {\n  }","id":99779,"modified_method":"public ModelCheckerIssueFinder() {\n    myExtraCheckers = null;\n  }","commit_id":"176f26fa2dd21faf5240b44c6e6dc8c32da82786","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void runCheck() {\n    try {\n      ProgressManager.getInstance().run(new Task.Modal(myProject, myCheckProgressTitle, true) {\n        @Override\n        public void run(@NotNull ProgressIndicator indicator) {\n          myUsagesView.run(indicator);\n        }\n      });\n    } catch (Throwable t) {\n      LogManager.getLogger(ModelCheckerViewer.class).error(\"An error occured while model checking:\\n\" + t);\n    }\n\n  }","id":99780,"modified_method":"private void runCheck() {\n    try {\n      ProgressManager.getInstance().run(new Task.Modal(myIdeaProject, myCheckProgressTitle, true) {\n        @Override\n        public void run(@NotNull ProgressIndicator indicator) {\n          myUsagesView.run(indicator);\n        }\n      });\n    } catch (Throwable t) {\n      LogManager.getLogger(ModelCheckerViewer.class).error(\"An error occured while model checking:\\n\" + t);\n    }\n\n  }","commit_id":"176f26fa2dd21faf5240b44c6e6dc8c32da82786","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ModelCheckerViewer(Project project, IOperationContext operationContext) {\n    myProject = project;\n    myOperationContext = operationContext;\n\n    setLayout(new BorderLayout());\n    ViewOptions viewOptions = new ViewOptions(true, false, false, false, false);\n    viewOptions.myCategories = new boolean[]{true, false};\n\n    myUsagesView = new UsagesView(project, viewOptions) {\n      @Override\n      public void close() {\n        ModelCheckerViewer.this.close();\n      }\n      @Override\n      protected String getRerunSearchTooltip() {\n        return \"Recheck\";\n      }\n      @Override\n      protected String getSearchProgressTitle() {\n        return myCheckProgressTitle;\n      }\n    };\n    myUsagesView.setCustomNodeRepresentator(new ModelCheckerViewer.MyNodeRepresentator());\n    add(myUsagesView.getComponent(), BorderLayout.CENTER);\n\n    JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));\n\n    myFixButton = new JButton(\"Perform Quick Fixes\");\n    myFixButton.setToolTipText(\"Remove undeclared children and undeclared references, resolve links in included nodes\");\n    myFixButton.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent event) {\n        performQuickFixes();\n      }\n    });\n    buttonPanel.add(myFixButton);\n    add(buttonPanel, BorderLayout.SOUTH);\n  }","id":99781,"modified_method":"public ModelCheckerViewer(Project project, IOperationContext operationContext) {\n    myIdeaProject = project;\n    myProject = ProjectHelper.toMPSProject(project);\n    myOperationContext = operationContext;\n\n    setLayout(new BorderLayout());\n    ViewOptions viewOptions = new ViewOptions(true, false, false, false, false);\n    viewOptions.myCategories = new boolean[]{true, false};\n\n    myUsagesView = new UsagesView(project, viewOptions) {\n      @Override\n      public void close() {\n        ModelCheckerViewer.this.close();\n      }\n      @Override\n      protected String getRerunSearchTooltip() {\n        return \"Recheck\";\n      }\n      @Override\n      protected String getSearchProgressTitle() {\n        return myCheckProgressTitle;\n      }\n    };\n    myUsagesView.setCustomNodeRepresentator(new ModelCheckerViewer.MyNodeRepresentator());\n    add(myUsagesView.getComponent(), BorderLayout.CENTER);\n\n    JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));\n\n    myFixButton = new JButton(\"Perform Quick Fixes\");\n    myFixButton.setToolTipText(\"Remove undeclared children and undeclared references, resolve links in included nodes\");\n    myFixButton.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent event) {\n        performQuickFixes();\n      }\n    });\n    buttonPanel.add(myFixButton);\n    add(buttonPanel, BorderLayout.SOUTH);\n  }","commit_id":"176f26fa2dd21faf5240b44c6e6dc8c32da82786","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void prepareAndCheckModels(List<SModel> modelDescriptors, String taskTargetTitle, Icon taskIcon, ModelCheckerIssueFinder issueFinder) {\n    IResultProvider resultProvider = FindUtils.makeProvider(issueFinder);\n    SearchQuery searchQuery = new SearchQuery(new ModelsHolder(ListSequence.fromList(modelDescriptors).select(new ISelector<SModel, SModelReference>() {\n      public SModelReference select(SModel it) {\n        return it.getReference();\n      }\n    }).toListSequence(), myOperationContext), myProject.getComponent(MPSProject.class).getScope());\n    myUsagesView.setRunOptions(resultProvider, searchQuery, new UsagesView.ButtonConfiguration(true, true, true));\n\n    myCheckProgressTitle = \"Checking \" + taskTargetTitle;\n    setTabProperties(taskTargetTitle, taskIcon);\n\n    runCheck();\n  }","id":99782,"modified_method":"public void prepareAndCheckModels(List<SModel> modelDescriptors, String taskTargetTitle, Icon taskIcon, ModelCheckerIssueFinder issueFinder) {\n    IResultProvider resultProvider = FindUtils.makeProvider(issueFinder);\n    SearchQuery searchQuery = new SearchQuery(new ModelsHolder(ListSequence.fromList(modelDescriptors).select(new ISelector<SModel, SModelReference>() {\n      public SModelReference select(SModel it) {\n        return it.getReference();\n      }\n    }).toListSequence(), myOperationContext), myProject.getScope());\n    myUsagesView.setRunOptions(resultProvider, searchQuery, new UsagesView.ButtonConfiguration(true, true, true));\n\n    myCheckProgressTitle = \"Checking \" + taskTargetTitle;\n    setTabProperties(taskTargetTitle, taskIcon);\n\n    runCheck();\n  }","commit_id":"176f26fa2dd21faf5240b44c6e6dc8c32da82786","url":"https://github.com/JetBrains/MPS"},{"original_method":"private List<ModelCheckerIssue> getIssuesToFix() {\n    final Set<SNodeReference> includedResultNodes = SetSequence.fromSetWithValues(new HashSet<SNodeReference>(), myUsagesView.getIncludedResultNodes());\n    return ListSequence.fromList(((List<SearchResult<ModelCheckerIssue>>) getSearchResults().getSearchResults())).select(new ISelector<SearchResult<ModelCheckerIssue>, ModelCheckerIssue>() {\n      public ModelCheckerIssue select(SearchResult<ModelCheckerIssue> sr) {\n        return sr.getObject();\n      }\n    }).where(new IWhereFilter<ModelCheckerIssue>() {\n      public boolean accept(ModelCheckerIssue sr) {\n        return sr instanceof ModelCheckerIssue.NodeIssue && SetSequence.fromSet(includedResultNodes).contains(new SNodePointer(((ModelCheckerIssue.NodeIssue) sr).getNode())) && sr.isFixable();\n      }\n    }).toListSequence();\n  }","id":99783,"modified_method":"private List<ModelCheckerIssue> getIssuesToFix() {\n    final Set<SNodeReference> includedResultNodes = SetSequence.fromSetWithValues(new HashSet<SNodeReference>(), myUsagesView.getIncludedResultNodes());\n    return ListSequence.fromList(((List<SearchResult<ModelCheckerIssue>>) getSearchResults().getSearchResults())).select(new ISelector<SearchResult<ModelCheckerIssue>, ModelCheckerIssue>() {\n      public ModelCheckerIssue select(SearchResult<ModelCheckerIssue> sr) {\n        return sr.getObject();\n      }\n    }).where(new IWhereFilter<ModelCheckerIssue>() {\n      public boolean accept(ModelCheckerIssue sr) {\n        return sr instanceof ModelCheckerIssue.NodeIssue && SetSequence.fromSet(includedResultNodes).contains(((ModelCheckerIssue.NodeIssue) sr).getNode().getReference()) && sr.isFixable();\n      }\n    }).toListSequence();\n  }","commit_id":"176f26fa2dd21faf5240b44c6e6dc8c32da82786","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void performQuickFixes() {\n    // Ask if need to fix \n\n    // Perform quick fixes \n    final Wrappers._int fixedTotal = new Wrappers._int(0);\n    ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n      public void run() {\n        // Select all fixable issues \n        List<ModelCheckerIssue> issuesToFix = ModelCheckerViewer.this.getIssuesToFix();\n        if (ListSequence.fromList(issuesToFix).isEmpty()) {\n          Messages.showInfoMessage(\"There are no quick fixes for current problems\", \"No Quick Fixes\");\n          return;\n        }\n        int dialogAnswer = Messages.showYesNoDialog(ProjectHelper.toIdeaProject(myOperationContext.getProject()), \"You are going to remove undeclared properties, children from nodes and resolve references. \" + \"You may not be able to undo it. Are you sure?\", \"Warning\", null);\n        if (dialogAnswer != 0) {\n          return;\n        }\n        while (true) {\n          int fixedBefore = fixedTotal.value;\n          for (ModelCheckerIssue issue : ListSequence.fromListWithValues(new ArrayList<ModelCheckerIssue>(), issuesToFix)) {\n            if (issue.fix()) {\n              fixedTotal.value++;\n              ListSequence.fromList(issuesToFix).removeElement(issue);\n            }\n          }\n          if (fixedBefore == fixedTotal.value) {\n            break;\n          }\n        }\n      }\n    });\n\n    // Perform recheck if needed \n    if (fixedTotal.value != 0) {\n      int dialogAnswer1 = Messages.showYesNoDialog(ProjectHelper.toIdeaProject(myOperationContext.getProject()), \"Model checker fixed \" + fixedTotal.value + \" issues. Do you wish to recheck?\", \"Recheck\", null);\n      if (dialogAnswer1 != 0) {\n        return;\n      }\n\n      runCheck();\n    }\n  }","id":99784,"modified_method":"public void performQuickFixes() {\n    // Ask if need to fix \n\n    // Perform quick fixes \n    final Wrappers._int fixedTotal = new Wrappers._int(0);\n    myProject.getModelAccess().executeCommandInEDT(new Runnable() {\n      public void run() {\n        // Select all fixable issues \n        List<ModelCheckerIssue> issuesToFix = ModelCheckerViewer.this.getIssuesToFix();\n        if (ListSequence.fromList(issuesToFix).isEmpty()) {\n          Messages.showInfoMessage(\"There are no quick fixes for current problems\", \"No Quick Fixes\");\n          return;\n        }\n        int dialogAnswer = Messages.showYesNoDialog(myIdeaProject, \"You are going to remove undeclared properties, children from nodes and resolve references. \" + \"You may not be able to undo it. Are you sure?\", \"Warning\", null);\n        if (dialogAnswer != 0) {\n          return;\n        }\n        while (true) {\n          int fixedBefore = fixedTotal.value;\n          for (ModelCheckerIssue issue : ListSequence.fromListWithValues(new ArrayList<ModelCheckerIssue>(), issuesToFix)) {\n            if (issue.fix()) {\n              fixedTotal.value++;\n              ListSequence.fromList(issuesToFix).removeElement(issue);\n            }\n          }\n          if (fixedBefore == fixedTotal.value) {\n            break;\n          }\n        }\n      }\n    });\n\n    // Perform recheck if needed \n    if (fixedTotal.value != 0) {\n      int dialogAnswer1 = Messages.showYesNoDialog(myIdeaProject, \"Model checker fixed \" + fixedTotal.value + \" issues. Do you wish to recheck?\", \"Recheck\", null);\n      if (dialogAnswer1 != 0) {\n        return;\n      }\n\n      runCheck();\n    }\n  }","commit_id":"176f26fa2dd21faf5240b44c6e6dc8c32da82786","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void prepareAndCheckModules(List<SModule> modules, String taskTargetTitle, Icon taskIcon) {\n    IResultProvider resultProvider = FindUtils.makeProvider(new ModelCheckerIssueFinder());\n    SearchQuery searchQuery = new SearchQuery(new ModulesHolder(ListSequence.fromList(modules).toListSequence(), myOperationContext), myProject.getComponent(MPSProject.class).getScope());\n    myUsagesView.setRunOptions(resultProvider, searchQuery, new UsagesView.ButtonConfiguration(true, true, true));\n\n    myCheckProgressTitle = \"Checking \" + taskTargetTitle;\n    setTabProperties(taskTargetTitle, taskIcon);\n\n    runCheck();\n  }","id":99785,"modified_method":"public void prepareAndCheckModules(List<SModule> modules, String taskTargetTitle, Icon taskIcon) {\n    IResultProvider resultProvider = FindUtils.makeProvider(new ModelCheckerIssueFinder());\n    SearchQuery searchQuery = new SearchQuery(new ModulesHolder(ListSequence.fromList(modules).toListSequence(), myOperationContext), myProject.getScope());\n    myUsagesView.setRunOptions(resultProvider, searchQuery, new UsagesView.ButtonConfiguration(true, true, true));\n\n    myCheckProgressTitle = \"Checking \" + taskTargetTitle;\n    setTabProperties(taskTargetTitle, taskIcon);\n\n    runCheck();\n  }","commit_id":"176f26fa2dd21faf5240b44c6e6dc8c32da82786","url":"https://github.com/JetBrains/MPS"},{"original_method":"@VisibleForTesting\n  File saveExcludeConfigXml() throws IOException {\n    StringWriter xml = new StringWriter();\n\n    exporter.exportExclusions(project.getExclusionPatterns(), xml);\n\n    return project.getFileSystem().writeToWorkingDirectory(xml.toString(), \"findbugs-exclude.xml\");\n  }","id":99786,"modified_method":"@VisibleForTesting\n  File saveExcludeConfigXml() throws IOException {\n    String xml = exporter.exportExclusions(project.getExclusionPatterns());\n\n    return project.getFileSystem().writeToWorkingDirectory(xml, \"findbugs-exclude.xml\");\n  }","commit_id":"5d308f5d402522b2a387e30292187d71a3724ba8","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@VisibleForTesting\n  File saveIncludeConfigXml() throws IOException {\n    StringWriter xml = new StringWriter();\n\n    exporter.exportProfile(profile, xml);\n\n    return project.getFileSystem().writeToWorkingDirectory(xml.toString(), \"findbugs-include.xml\");\n  }","id":99787,"modified_method":"@VisibleForTesting\n  File saveIncludeConfigXml() throws IOException {\n    String xml = exporter.exportProfileAndInclusions(profile, project.getInclusionPatterns());\n\n    return project.getFileSystem().writeToWorkingDirectory(xml, \"findbugs-include.xml\");\n  }","commit_id":"5d308f5d402522b2a387e30292187d71a3724ba8","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static void writeXml(FindBugsFilter filter, Writer writer) {\n    try {\n      writer.write(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\");\n      writer.write(\"<!-- Generated by Sonar -->\\n\");\n      writer.write(filter.toXml());\n    } catch (IOException e) {\n      throw new SonarException(\"Fail to export Findbugs configuration\", e);\n    }\n  }","id":99788,"modified_method":"private static String toXml(FindBugsFilter root) {\n    return new StringBuilder()\n        .append(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\")\n        .append(\"<!-- Generated by Sonar -->\\n\")\n        .append(root.toXml())\n        .toString();\n  }","commit_id":"5d308f5d402522b2a387e30292187d71a3724ba8","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void exportProfile(RulesProfile profile, Writer writer) {\n    List<ActiveRule> activeRulesByRepository = profile.getActiveRulesByRepository(FindbugsConstants.REPOSITORY_KEY);\n    FindBugsFilter filter = buildFindbugsFilter(activeRulesByRepository);\n\n    writeXml(filter, writer);\n  }","id":99789,"modified_method":"@Override\n  public void exportProfile(RulesProfile profile, Writer writer) {\n    try {\n      String xml = exportProfileAndInclusions(profile, null);\n      writer.write(xml);\n    } catch (IOException e) {\n      throw new SonarException(\"Fail to export Findbugs profile: \" + profile.getName(), e);\n    }\n  }","commit_id":"5d308f5d402522b2a387e30292187d71a3724ba8","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void exportExclusions(String[] exclusions, Writer writer) {\n    FindBugsFilter filter = new FindBugsFilter();\n    if (exclusions != null) {\n      for (String exclusion : exclusions) {\n        ClassFilter classFilter = new ClassFilter(FindbugsAntConverter.antToJavaRegexpConvertor(exclusion));\n        filter.addMatch(new Match(classFilter));\n      }\n    }\n\n    writeXml(filter, writer);\n  }","id":99790,"modified_method":"public String exportExclusions(String[] exclusions) {\n    FindBugsFilter root = new FindBugsFilter();\n    addPatterns(root, exclusions);\n    return toXml(root);\n  }","commit_id":"5d308f5d402522b2a387e30292187d71a3724ba8","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"protected static FindBugsFilter buildFindbugsFilter(List<ActiveRule> activeRules) {\n    FindBugsFilter root = new FindBugsFilter();\n\n    for (ActiveRule activeRule : activeRules) {\n      if (FindbugsConstants.REPOSITORY_KEY.equals(activeRule.getRepositoryKey())) {\n        Match child = new Match();\n        child.setBug(new Bug(activeRule.getConfigKey()));\n        root.addMatch(child);\n      }\n    }\n\n    return root;\n  }","id":99791,"modified_method":"protected static void addRules(FindBugsFilter root, List<ActiveRule> activeRules) {\n    for (ActiveRule activeRule : activeRules) {\n      if (FindbugsConstants.REPOSITORY_KEY.equals(activeRule.getRepositoryKey())) {\n        Match child = new Match();\n        child.setBug(new Bug(activeRule.getConfigKey()));\n        root.addMatch(child);\n      }\n    }\n  }","commit_id":"5d308f5d402522b2a387e30292187d71a3724ba8","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldBuildTwoModulesEvenIfSameTwoRulesActivated() {\n    ActiveRule activeRule1 = anActiveRule(DLS_DEAD_LOCAL_STORE);\n    ActiveRule activeRule2 = anActiveRule(SS_SHOULD_BE_STATIC);\n    FindBugsFilter filter = FindbugsProfileExporter.buildFindbugsFilter(Arrays.asList(activeRule1, activeRule2));\n\n    List<Match> matches = filter.getMatchs();\n    assertThat(matches).hasSize(2);\n\n    assertThat(matches.get(0).getBug().getPattern()).isEqualTo(\"DLS_DEAD_LOCAL_STORE\");\n    assertThat(matches.get(1).getBug().getPattern()).isEqualTo(\"SS_SHOULD_BE_STATIC\");\n  }","id":99792,"modified_method":"@Test\n  public void shouldBuildTwoModulesEvenIfSameTwoRulesActivated() {\n    ActiveRule activeRule1 = anActiveRule(DLS_DEAD_LOCAL_STORE);\n    ActiveRule activeRule2 = anActiveRule(SS_SHOULD_BE_STATIC);\n\n    FindBugsFilter filter = new FindBugsFilter();\n    FindbugsProfileExporter.addRules(filter, Arrays.asList(activeRule1, activeRule2));\n\n    List<Match> matches = filter.getMatchs();\n    assertThat(matches).hasSize(2);\n\n    assertThat(matches.get(0).getBug().getPattern()).isEqualTo(\"DLS_DEAD_LOCAL_STORE\");\n    assertThat(matches.get(1).getBug().getPattern()).isEqualTo(\"SS_SHOULD_BE_STATIC\");\n  }","commit_id":"5d308f5d402522b2a387e30292187d71a3724ba8","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldBuildOnlyOneModuleWhenNoFindbugsActiveRules() {\n    ActiveRule activeRule1 = anActiveRuleFromAnotherPlugin();\n    ActiveRule activeRule2 = anActiveRuleFromAnotherPlugin();\n\n    FindBugsFilter filter = FindbugsProfileExporter.buildFindbugsFilter(Arrays.asList(activeRule1, activeRule2));\n    assertThat(filter.getMatchs()).hasSize(0);\n  }","id":99793,"modified_method":"@Test\n  public void shouldBuildOnlyOneModuleWhenNoFindbugsActiveRules() {\n    ActiveRule activeRule1 = anActiveRuleFromAnotherPlugin();\n    ActiveRule activeRule2 = anActiveRuleFromAnotherPlugin();\n\n    FindBugsFilter filter = new FindBugsFilter();\n    FindbugsProfileExporter.addRules(filter, Arrays.asList(activeRule1, activeRule2));\n    assertThat(filter.getMatchs()).hasSize(0);\n  }","commit_id":"5d308f5d402522b2a387e30292187d71a3724ba8","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldBuildModuleWithProperties() {\n    ActiveRule activeRule = anActiveRule(DLS_DEAD_LOCAL_STORE);\n    FindBugsFilter filter = FindbugsProfileExporter.buildFindbugsFilter(Arrays.asList(activeRule));\n\n    assertThat(filter.getMatchs()).hasSize(1);\n    assertThat(filter.getMatchs().get(0).getBug().getPattern()).isEqualTo(\"DLS_DEAD_LOCAL_STORE\");\n  }","id":99794,"modified_method":"@Test\n  public void shouldBuildModuleWithProperties() {\n    ActiveRule activeRule = anActiveRule(DLS_DEAD_LOCAL_STORE);\n\n    FindBugsFilter filter = new FindBugsFilter();\n    FindbugsProfileExporter.addRules(filter, Arrays.asList(activeRule));\n\n    assertThat(filter.getMatchs()).hasSize(1);\n    assertThat(filter.getMatchs().get(0).getBug().getPattern()).isEqualTo(\"DLS_DEAD_LOCAL_STORE\");\n  }","commit_id":"5d308f5d402522b2a387e30292187d71a3724ba8","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldBuildOnlyOneModuleWhenNoActiveRules() {\n    FindBugsFilter filter = FindbugsProfileExporter.buildFindbugsFilter(Collections.<ActiveRule> emptyList());\n    assertThat(filter.getMatchs()).hasSize(0);\n  }","id":99795,"modified_method":"@Test\n  public void shouldBuildOnlyOneModuleWhenNoActiveRules() {\n    FindBugsFilter filter = new FindBugsFilter();\n    FindbugsProfileExporter.addRules(filter, Collections.<ActiveRule> emptyList());\n\n    assertThat(filter.getMatchs()).isEmpty();\n  }","commit_id":"5d308f5d402522b2a387e30292187d71a3724ba8","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public static boolean isEnabled() {\n\t\tClusterExecutor clusterExecutor = getClusterExecutor();\n\n\t\tif (clusterExecutor == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}","id":99796,"modified_method":"public static boolean isEnabled() {\n\t\treturn getClusterExecutor().isEnabled();\n\t}","commit_id":"e7328c00b7b941be388b29a77ee91ee937e15b99","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static List<ClusterNode> getClusterNodes() {\n\t\tClusterExecutor clusterExecutor = getClusterExecutor();\n\n\t\tif (clusterExecutor == null) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\n\t\treturn clusterExecutor.getClusterNodes();\n\t}","id":99797,"modified_method":"public static List<ClusterNode> getClusterNodes() {\n\t\treturn getClusterExecutor().getClusterNodes();\n\t}","commit_id":"e7328c00b7b941be388b29a77ee91ee937e15b99","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static FutureClusterResponses execute(\n\t\tClusterRequest clusterRequest) {\n\n\t\tClusterExecutor clusterExecutor = getClusterExecutor();\n\n\t\tif (clusterExecutor == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn clusterExecutor.execute(clusterRequest);\n\t}","id":99798,"modified_method":"public static FutureClusterResponses execute(\n\t\tClusterRequest clusterRequest) {\n\n\t\treturn getClusterExecutor().execute(clusterRequest);\n\t}","commit_id":"e7328c00b7b941be388b29a77ee91ee937e15b99","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void addClusterEventListener(\n\t\tClusterEventListener clusterEventListener) {\n\n\t\tClusterExecutor clusterExecutor = getClusterExecutor();\n\n\t\tif (clusterExecutor == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tclusterExecutor.addClusterEventListener(clusterEventListener);\n\t}","id":99799,"modified_method":"public static void addClusterEventListener(\n\t\tClusterEventListener clusterEventListener) {\n\n\t\tgetClusterExecutor().addClusterEventListener(clusterEventListener);\n\t}","commit_id":"e7328c00b7b941be388b29a77ee91ee937e15b99","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void removeClusterEventListener(\n\t\tClusterEventListener clusterEventListener) {\n\n\t\tClusterExecutor clusterExecutor = getClusterExecutor();\n\n\t\tif (clusterExecutor == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tclusterExecutor.removeClusterEventListener(clusterEventListener);\n\t}","id":99800,"modified_method":"public static void removeClusterEventListener(\n\t\tClusterEventListener clusterEventListener) {\n\n\t\tgetClusterExecutor().removeClusterEventListener(clusterEventListener);\n\t}","commit_id":"e7328c00b7b941be388b29a77ee91ee937e15b99","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static ClusterExecutor getClusterExecutor() {\n\t\tPortalRuntimePermission.checkGetBeanProperty(ClusterExecutorUtil.class);\n\n\t\tif ((_clusterExecutor == null) || !_clusterExecutor.isEnabled()) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\"ClusterExecutorUtil is not initialized\");\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\treturn _clusterExecutor;\n\t}","id":99801,"modified_method":"public static ClusterExecutor getClusterExecutor() {\n\t\tPortalRuntimePermission.checkGetBeanProperty(ClusterExecutorUtil.class);\n\n\t\treturn _clusterExecutor;\n\t}","commit_id":"e7328c00b7b941be388b29a77ee91ee937e15b99","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static ClusterNode getLocalClusterNode() {\n\t\tClusterExecutor clusterExecutor = getClusterExecutor();\n\n\t\tif (clusterExecutor == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn clusterExecutor.getLocalClusterNode();\n\t}","id":99802,"modified_method":"public static ClusterNode getLocalClusterNode() {\n\t\treturn getClusterExecutor().getLocalClusterNode();\n\t}","commit_id":"e7328c00b7b941be388b29a77ee91ee937e15b99","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean isClusterNodeAlive(String clusterNodeId) {\n\t\tClusterExecutor clusterExecutor = getClusterExecutor();\n\n\t\tif (clusterExecutor == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn clusterExecutor.isClusterNodeAlive(clusterNodeId);\n\t}","id":99803,"modified_method":"public static boolean isClusterNodeAlive(String clusterNodeId) {\n\t\treturn getClusterExecutor().isClusterNodeAlive(clusterNodeId);\n\t}","commit_id":"e7328c00b7b941be388b29a77ee91ee937e15b99","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void sendMulticastMessage(\n\t\tMessage message, Priority priority) {\n\n\t\tClusterLink clusterLink = getClusterLink();\n\n\t\tif (clusterLink == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tclusterLink.sendMulticastMessage(message, priority);\n\t}","id":99804,"modified_method":"public static void sendMulticastMessage(\n\t\tMessage message, Priority priority) {\n\n\t\tgetClusterLink().sendMulticastMessage(message, priority);\n\t}","commit_id":"e7328c00b7b941be388b29a77ee91ee937e15b99","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void sendUnicastMessage(\n\t\tAddress address, Message message, Priority priority) {\n\n\t\tClusterLink clusterLink = getClusterLink();\n\n\t\tif (clusterLink == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tclusterLink.sendUnicastMessage(address, message, priority);\n\t}","id":99805,"modified_method":"public static void sendUnicastMessage(\n\t\tAddress address, Message message, Priority priority) {\n\n\t\tgetClusterLink().sendUnicastMessage(address, message, priority);\n\t}","commit_id":"e7328c00b7b941be388b29a77ee91ee937e15b99","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static ClusterLink getClusterLink() {\n\t\tPortalRuntimePermission.checkGetBeanProperty(ClusterLinkUtil.class);\n\n\t\tif ((_clusterLink == null) || !_clusterLink.isEnabled()) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\"ClusterLinkUtil is not initialized\");\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\treturn _clusterLink;\n\t}","id":99806,"modified_method":"public static ClusterLink getClusterLink() {\n\t\tPortalRuntimePermission.checkGetBeanProperty(ClusterLinkUtil.class);\n\n\t\treturn _clusterLink;\n\t}","commit_id":"e7328c00b7b941be388b29a77ee91ee937e15b99","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static ClusterMasterExecutor getClusterMasterExecutor() {\n\t\treturn _instance;\n\t}","id":99807,"modified_method":"public static ClusterMasterExecutor getClusterMasterExecutor() {\n\t\treturn _clusterMasterExecutor;\n\t}","commit_id":"e7328c00b7b941be388b29a77ee91ee937e15b99","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static <T> Future<T> executeOnMaster(MethodHandler methodHandler) {\n\t\tClusterMasterExecutor clusterMasterExecutor =\n\t\t\tgetClusterMasterExecutor();\n\n\t\tif (clusterMasterExecutor == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn clusterMasterExecutor.executeOnMaster(methodHandler);\n\t}","id":99808,"modified_method":"public static <T> Future<T> executeOnMaster(MethodHandler methodHandler) {\n\t\treturn getClusterMasterExecutor().executeOnMaster(methodHandler);\n\t}","commit_id":"e7328c00b7b941be388b29a77ee91ee937e15b99","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean isMaster() {\n\t\tClusterMasterExecutor clusterMasterExecutor =\n\t\t\tgetClusterMasterExecutor();\n\n\t\tif (clusterMasterExecutor == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn clusterMasterExecutor.isMaster();\n\t}","id":99809,"modified_method":"public static boolean isMaster() {\n\t\treturn getClusterMasterExecutor().isMaster();\n\t}","commit_id":"e7328c00b7b941be388b29a77ee91ee937e15b99","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void removeClusterMasterTokenTransitionListener(\n\t\tClusterMasterTokenTransitionListener\n\t\t\tclusterMasterTokenTransitionListener) {\n\n\t\tClusterMasterExecutor clusterMasterExecutor =\n\t\t\tgetClusterMasterExecutor();\n\n\t\tif (clusterMasterExecutor == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tclusterMasterExecutor.removeClusterMasterTokenTransitionListener(\n\t\t\tclusterMasterTokenTransitionListener);\n\t}","id":99810,"modified_method":"public static void removeClusterMasterTokenTransitionListener(\n\t\tClusterMasterTokenTransitionListener\n\t\t\tclusterMasterTokenTransitionListener) {\n\n\t\tgetClusterMasterExecutor().removeClusterMasterTokenTransitionListener(\n\t\t\tclusterMasterTokenTransitionListener);\n\t}","commit_id":"e7328c00b7b941be388b29a77ee91ee937e15b99","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean isEnabled() {\n\t\tClusterMasterExecutor clusterMasterExecutor =\n\t\t\tgetClusterMasterExecutor();\n\n\t\tif (clusterMasterExecutor == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn clusterMasterExecutor.isEnabled();\n\t}","id":99811,"modified_method":"public static boolean isEnabled() {\n\t\treturn getClusterMasterExecutor().isEnabled();\n\t}","commit_id":"e7328c00b7b941be388b29a77ee91ee937e15b99","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void addClusterMasterTokenTransitionListener(\n\t\tClusterMasterTokenTransitionListener\n\t\t\tclusterMasterTokenTransitionListener) {\n\n\t\tClusterMasterExecutor clusterMasterExecutor =\n\t\t\tgetClusterMasterExecutor();\n\n\t\tif (clusterMasterExecutor == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tclusterMasterExecutor.addClusterMasterTokenTransitionListener(\n\t\t\tclusterMasterTokenTransitionListener);\n\t}","id":99812,"modified_method":"public static void addClusterMasterTokenTransitionListener(\n\t\tClusterMasterTokenTransitionListener\n\t\t\tclusterMasterTokenTransitionListener) {\n\n\t\tgetClusterMasterExecutor().addClusterMasterTokenTransitionListener(\n\t\t\tclusterMasterTokenTransitionListener);\n\t}","commit_id":"e7328c00b7b941be388b29a77ee91ee937e15b99","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public CharSequence generateBody(final JvmExecutable op, final ImportManager importManager) {\n      EList<Adapter> _eAdapters = op.eAdapters();\n      Iterable<CompilationStrategyAdapter> _filter = IterableExtensions.<CompilationStrategyAdapter>filter(_eAdapters, org.eclipse.xtext.xbase.compiler.CompilationStrategyAdapter.class);\n      CompilationStrategyAdapter _head = IterableExtensions.<CompilationStrategyAdapter>head(_filter);\n      final CompilationStrategyAdapter adapter = _head;\n      boolean _operator_notEquals = ObjectExtensions.operator_notEquals(adapter, null);\n      if (_operator_notEquals) {\n        Function1<ImportManager,? extends CharSequence> _compilationStrategy = adapter.getCompilationStrategy();\n        CharSequence _apply = _compilationStrategy.apply(importManager);\n        return _apply;\n      } else {\n        {\n          XExpression _associatedExpression = this._iLogicalContainerProvider.getAssociatedExpression(op);\n          final XExpression expression = _associatedExpression;\n          boolean _operator_notEquals_1 = ObjectExtensions.operator_notEquals(expression, null);\n          if (_operator_notEquals_1) {\n            {\n              StringBuilderBasedAppendable _createAppendable = this.createAppendable(op, importManager);\n              final StringBuilderBasedAppendable appendable = _createAppendable;\n              EList<JvmFormalParameter> _parameters = op.getParameters();\n              for (final JvmFormalParameter p : _parameters) {\n                String _simpleName = p.getSimpleName();\n                appendable.declareVariable(p, _simpleName);\n              }\n              JvmTypeReference _switchResult = null;\n              boolean matched = false;\n              if (!matched) {\n                if (op instanceof JvmOperation) {\n                  final JvmOperation _jvmOperation = (JvmOperation)op;\n                  matched=true;\n                  JvmTypeReference _returnType = _jvmOperation.getReturnType();\n                  _switchResult = _returnType;\n                }\n              }\n              if (!matched) {\n                if (op instanceof JvmConstructor) {\n                  final JvmConstructor _jvmConstructor = (JvmConstructor)op;\n                  matched=true;\n                  JvmTypeReference _typeForName = this._typeReferences.getTypeForName(Void.TYPE, _jvmConstructor);\n                  _switchResult = _typeForName;\n                }\n              }\n              if (!matched) {\n                _switchResult = null;\n              }\n              final JvmTypeReference returnType = _switchResult;\n              EList<JvmTypeReference> _exceptions = op.getExceptions();\n              Set<JvmTypeReference> _set = IterableExtensions.<JvmTypeReference>toSet(_exceptions);\n              this.compiler.compile(expression, appendable, returnType, _set);\n              String _string = appendable.toString();\n              String _removeSurroundingCurlies = this.removeSurroundingCurlies(_string);\n              return _removeSurroundingCurlies;\n            }\n          } else {\n            StringConcatenation _builder = new StringConcatenation();\n            _builder.append(\"throw new UnsupportedOperationException(\\\"\");\n            String _simpleName_1 = op.getSimpleName();\n            _builder.append(_simpleName_1, \"\");\n            _builder.append(\" is not implemented\\\");\");\n            return _builder;\n          }\n        }\n      }\n  }","id":99813,"modified_method":"public CharSequence generateBody(final JvmExecutable op, final ImportManager importManager) {\n      EList<Adapter> _eAdapters = op.eAdapters();\n      Iterable<CompilationStrategyAdapter> _filter = IterableExtensions.<CompilationStrategyAdapter>filter(_eAdapters, org.eclipse.xtext.xbase.compiler.CompilationStrategyAdapter.class);\n      CompilationStrategyAdapter _head = IterableExtensions.<CompilationStrategyAdapter>head(_filter);\n      final CompilationStrategyAdapter adapter = _head;\n      boolean _operator_notEquals = ObjectExtensions.operator_notEquals(adapter, null);\n      if (_operator_notEquals) {\n        Function1<ImportManager,? extends CharSequence> _compilationStrategy = adapter.getCompilationStrategy();\n        CharSequence _apply = _compilationStrategy.apply(importManager);\n        return _apply;\n      } else {\n        {\n          XExpression _associatedExpression = this._iLogicalContainerProvider.getAssociatedExpression(op);\n          final XExpression expression = _associatedExpression;\n          boolean _operator_notEquals_1 = ObjectExtensions.operator_notEquals(expression, null);\n          if (_operator_notEquals_1) {\n            {\n              StringBuilderBasedAppendable _createAppendable = this.createAppendable(op, importManager);\n              final StringBuilderBasedAppendable appendable = _createAppendable;\n              EList<JvmFormalParameter> _parameters = op.getParameters();\n              for (final JvmFormalParameter p : _parameters) {\n                String _simpleName = p.getSimpleName();\n                appendable.declareVariable(p, _simpleName);\n              }\n              JvmTypeReference _switchResult = null;\n              boolean matched = false;\n              if (!matched) {\n                if (op instanceof JvmOperation) {\n                  final JvmOperation _jvmOperation = (JvmOperation)op;\n                  matched=true;\n                  JvmTypeReference _returnType = _jvmOperation.getReturnType();\n                  _switchResult = _returnType;\n                }\n              }\n              if (!matched) {\n                if (op instanceof JvmConstructor) {\n                  final JvmConstructor _jvmConstructor = (JvmConstructor)op;\n                  matched=true;\n                  Class<Void> _TYPE = Void.TYPE;\n                  JvmTypeReference _typeForName = this._typeReferences.getTypeForName(_TYPE, _jvmConstructor);\n                  _switchResult = _typeForName;\n                }\n              }\n              if (!matched) {\n                _switchResult = null;\n              }\n              final JvmTypeReference returnType = _switchResult;\n              XbaseCompiler _compiler = this.compiler;\n              EList<JvmTypeReference> _exceptions = op.getExceptions();\n              Set<JvmTypeReference> _set = IterableExtensions.<JvmTypeReference>toSet(_exceptions);\n              _compiler.compile(expression, appendable, returnType, _set);\n              String _string = appendable.toString();\n              String _removeSurroundingCurlies = this.removeSurroundingCurlies(_string);\n              return _removeSurroundingCurlies;\n            }\n          } else {\n            StringConcatenation _builder = new StringConcatenation();\n            _builder.append(\"throw new UnsupportedOperationException(\\\"\");\n            String _simpleName_1 = op.getSimpleName();\n            _builder.append(_simpleName_1, \"\");\n            _builder.append(\" is not implemented\\\");\");\n            return _builder;\n          }\n        }\n      }\n  }","commit_id":"a3896c3422a823470a364bfbc3996c175126ec28","url":"https://github.com/eclipse/xtext"},{"original_method":"public String serialize(final JvmTypeReference it, final ImportManager importManager) {\n    String _xblockexpression = null;\n    {\n      StringBuilderBasedAppendable _createAppendable = this.createAppendable(it, importManager);\n      final StringBuilderBasedAppendable appendable = _createAppendable;\n      EObject _eContainer = it.eContainer();\n      this.typeRefSerializer.serialize(it, _eContainer, appendable);\n      String _string = appendable.toString();\n      _xblockexpression = (_string);\n    }\n    return _xblockexpression;\n  }","id":99814,"modified_method":"public String serialize(final JvmTypeReference it, final ImportManager importManager) {\n    String _xblockexpression = null;\n    {\n      StringBuilderBasedAppendable _createAppendable = this.createAppendable(it, importManager);\n      final StringBuilderBasedAppendable appendable = _createAppendable;\n      TypeReferenceSerializer _typeRefSerializer = this.typeRefSerializer;\n      EObject _eContainer = it.eContainer();\n      _typeRefSerializer.serialize(it, _eContainer, appendable);\n      String _string = appendable.toString();\n      _xblockexpression = (_string);\n    }\n    return _xblockexpression;\n  }","commit_id":"a3896c3422a823470a364bfbc3996c175126ec28","url":"https://github.com/eclipse/xtext"},{"original_method":"public CharSequence generateTypeParameterDeclaration(final JvmTypeParameter it, final ImportManager importManager) {\n    StringConcatenation _builder = new StringConcatenation();\n    CharSequence _serialize = importManager.serialize(it);\n    _builder.append(_serialize, \"\");\n    CharSequence _generateTypeParameterConstraints = this.generateTypeParameterConstraints(it, importManager);\n    _builder.append(_generateTypeParameterConstraints, \"\");\n    return _builder;\n  }","id":99815,"modified_method":"public CharSequence generateTypeParameterDeclaration(final JvmTypeParameter it, final ImportManager importManager) {\n    StringConcatenation _builder = new StringConcatenation();\n    CharSequence _serialize = importManager.serialize(it);\n    _builder.append(_serialize, \"\");\n    String _generateTypeParameterConstraints = this.generateTypeParameterConstraints(it, importManager);\n    _builder.append(_generateTypeParameterConstraints, \"\");\n    return _builder;\n  }","commit_id":"a3896c3422a823470a364bfbc3996c175126ec28","url":"https://github.com/eclipse/xtext"},{"original_method":"protected CharSequence _toJavaLiteral(final JvmCustomAnnotationValue it, final ImportManager importManager) {\n    String _xblockexpression = null;\n    {\n      StringBuilderBasedAppendable _createAppendable = this.createAppendable(it, importManager);\n      final StringBuilderBasedAppendable appendable = _createAppendable;\n      EList<Object> _values = it.getValues();\n      int _size = _values.size();\n      final int __valOfSwitchOver = _size;\n      boolean matched = false;\n      if (!matched) {\n        if (ObjectExtensions.operator_equals(__valOfSwitchOver,0)) {\n          matched=true;\n          appendable.append(\"{}\");\n        }\n      }\n      if (!matched) {\n        if (ObjectExtensions.operator_equals(__valOfSwitchOver,1)) {\n          matched=true;\n          EList<Object> _values_1 = it.getValues();\n          Object _head = IterableExtensions.<Object>head(_values_1);\n          this.compiler.toJavaExpression(((XExpression) _head), appendable);\n        }\n      }\n      if (!matched) {\n        {\n          appendable.append(\"{\");\n          EList<Object> _values_2 = it.getValues();\n          Object _head_1 = IterableExtensions.<Object>head(_values_2);\n          this.compiler.toJavaExpression(((XExpression) _head_1), appendable);\n          EList<Object> _values_3 = it.getValues();\n          Iterable<Object> _tail = IterableExtensions.<Object>tail(_values_3);\n          Iterable<XExpression> _filter = IterableExtensions.<XExpression>filter(_tail, org.eclipse.xtext.xbase.XExpression.class);\n          final Procedure1<XExpression> _function = new Procedure1<XExpression>() {\n              public void apply(final XExpression it) {\n                {\n                  appendable.append(\",\");\n                  JvmModelGenerator.this.compiler.toJavaExpression(it, appendable);\n                }\n              }\n            };\n          IterableExtensions.<XExpression>forEach(_filter, _function);\n          appendable.append(\"}\");\n        }\n      }\n      String _string = appendable.toString();\n      _xblockexpression = (_string);\n    }\n    return _xblockexpression;\n  }","id":99816,"modified_method":"protected CharSequence _toJavaLiteral(final JvmCustomAnnotationValue it, final ImportManager importManager) {\n    String _xblockexpression = null;\n    {\n      StringBuilderBasedAppendable _createAppendable = this.createAppendable(it, importManager);\n      final StringBuilderBasedAppendable appendable = _createAppendable;\n      EList<Object> _values = it.getValues();\n      int _size = _values.size();\n      final int __valOfSwitchOver = _size;\n      boolean matched = false;\n      if (!matched) {\n        if (ObjectExtensions.operator_equals(__valOfSwitchOver,0)) {\n          matched=true;\n          appendable.append(\"{}\");\n        }\n      }\n      if (!matched) {\n        if (ObjectExtensions.operator_equals(__valOfSwitchOver,1)) {\n          matched=true;\n          XbaseCompiler _compiler = this.compiler;\n          EList<Object> _values_1 = it.getValues();\n          Object _head = IterableExtensions.<Object>head(_values_1);\n          _compiler.toJavaExpression(((XExpression) _head), appendable);\n        }\n      }\n      if (!matched) {\n        {\n          appendable.append(\"{\");\n          XbaseCompiler _compiler_1 = this.compiler;\n          EList<Object> _values_2 = it.getValues();\n          Object _head_1 = IterableExtensions.<Object>head(_values_2);\n          _compiler_1.toJavaExpression(((XExpression) _head_1), appendable);\n          EList<Object> _values_3 = it.getValues();\n          Iterable<Object> _tail = IterableExtensions.<Object>tail(_values_3);\n          Iterable<XExpression> _filter = IterableExtensions.<XExpression>filter(_tail, org.eclipse.xtext.xbase.XExpression.class);\n          final Procedure1<XExpression> _function = new Procedure1<XExpression>() {\n              public void apply(final XExpression it) {\n                {\n                  appendable.append(\",\");\n                  XbaseCompiler _compiler = JvmModelGenerator.this.compiler;\n                  _compiler.toJavaExpression(it, appendable);\n                }\n              }\n            };\n          IterableExtensions.<XExpression>forEach(_filter, _function);\n          appendable.append(\"}\");\n        }\n      }\n      String _string = appendable.toString();\n      _xblockexpression = (_string);\n    }\n    return _xblockexpression;\n  }","commit_id":"a3896c3422a823470a364bfbc3996c175126ec28","url":"https://github.com/eclipse/xtext"},{"original_method":"public CharSequence generateInitialization(final JvmField it, final ImportManager importManager) {\n    String _xblockexpression = null;\n    {\n      EList<Adapter> _eAdapters = it.eAdapters();\n      Iterable<CompilationStrategyAdapter> _filter = IterableExtensions.<CompilationStrategyAdapter>filter(_eAdapters, org.eclipse.xtext.xbase.compiler.CompilationStrategyAdapter.class);\n      CompilationStrategyAdapter _head = IterableExtensions.<CompilationStrategyAdapter>head(_filter);\n      final CompilationStrategyAdapter adapter = _head;\n      String _xifexpression = null;\n      boolean _operator_notEquals = ObjectExtensions.operator_notEquals(adapter, null);\n      if (_operator_notEquals) {\n        Function1<ImportManager,? extends CharSequence> _compilationStrategy = adapter.getCompilationStrategy();\n        CharSequence _apply = _compilationStrategy.apply(importManager);\n        String _operator_plus = StringExtensions.operator_plus(\" = \", _apply);\n        _xifexpression = _operator_plus;\n      } else {\n        String _xblockexpression_1 = null;\n        {\n          XExpression _associatedExpression = this._iLogicalContainerProvider.getAssociatedExpression(it);\n          final XExpression expression = _associatedExpression;\n          String _xifexpression_1 = null;\n          boolean _operator_notEquals_1 = ObjectExtensions.operator_notEquals(expression, null);\n          if (_operator_notEquals_1) {\n            {\n              StringBuilderBasedAppendable _createAppendable = this.createAppendable(it, importManager);\n              final StringBuilderBasedAppendable appendable = _createAppendable;\n              JvmTypeReference _type = it.getType();\n              this.compiler.compileAsJavaExpression(expression, appendable, _type);\n              String _string = appendable.toString();\n              String _operator_plus_1 = StringExtensions.operator_plus(\" = \", _string);\n              return _operator_plus_1;\n            }\n          } else {\n            _xifexpression_1 = \"\";\n          }\n          _xblockexpression_1 = (_xifexpression_1);\n        }\n        _xifexpression = _xblockexpression_1;\n      }\n      _xblockexpression = (_xifexpression);\n    }\n    return _xblockexpression;\n  }","id":99817,"modified_method":"public CharSequence generateInitialization(final JvmField it, final ImportManager importManager) {\n    String _xblockexpression = null;\n    {\n      EList<Adapter> _eAdapters = it.eAdapters();\n      Iterable<CompilationStrategyAdapter> _filter = IterableExtensions.<CompilationStrategyAdapter>filter(_eAdapters, org.eclipse.xtext.xbase.compiler.CompilationStrategyAdapter.class);\n      CompilationStrategyAdapter _head = IterableExtensions.<CompilationStrategyAdapter>head(_filter);\n      final CompilationStrategyAdapter adapter = _head;\n      String _xifexpression = null;\n      boolean _operator_notEquals = ObjectExtensions.operator_notEquals(adapter, null);\n      if (_operator_notEquals) {\n        Function1<ImportManager,? extends CharSequence> _compilationStrategy = adapter.getCompilationStrategy();\n        CharSequence _apply = _compilationStrategy.apply(importManager);\n        String _operator_plus = StringExtensions.operator_plus(\" = \", _apply);\n        _xifexpression = _operator_plus;\n      } else {\n        String _xblockexpression_1 = null;\n        {\n          XExpression _associatedExpression = this._iLogicalContainerProvider.getAssociatedExpression(it);\n          final XExpression expression = _associatedExpression;\n          String _xifexpression_1 = null;\n          boolean _operator_notEquals_1 = ObjectExtensions.operator_notEquals(expression, null);\n          if (_operator_notEquals_1) {\n            {\n              StringBuilderBasedAppendable _createAppendable = this.createAppendable(it, importManager);\n              final StringBuilderBasedAppendable appendable = _createAppendable;\n              XbaseCompiler _compiler = this.compiler;\n              JvmTypeReference _type = it.getType();\n              _compiler.compileAsJavaExpression(expression, appendable, _type);\n              String _string = appendable.toString();\n              String _operator_plus_1 = StringExtensions.operator_plus(\" = \", _string);\n              return _operator_plus_1;\n            }\n          } else {\n            _xifexpression_1 = \"\";\n          }\n          _xblockexpression_1 = (_xifexpression_1);\n        }\n        _xifexpression = _xblockexpression_1;\n      }\n      _xblockexpression = (_xifexpression);\n    }\n    return _xblockexpression;\n  }","commit_id":"a3896c3422a823470a364bfbc3996c175126ec28","url":"https://github.com/eclipse/xtext"},{"original_method":"public String javaName(final JvmVisibility visibility) {\n    boolean _operator_notEquals = ObjectExtensions.operator_notEquals(visibility, null);\n    if (_operator_notEquals) {\n      String _switchResult = null;\n      boolean matched = false;\n      if (!matched) {\n        if (ObjectExtensions.operator_equals(visibility,JvmVisibility.PRIVATE)) {\n          matched=true;\n          _switchResult = \"private \";\n        }\n      }\n      if (!matched) {\n        if (ObjectExtensions.operator_equals(visibility,JvmVisibility.PUBLIC)) {\n          matched=true;\n          _switchResult = \"public \";\n        }\n      }\n      if (!matched) {\n        if (ObjectExtensions.operator_equals(visibility,JvmVisibility.PROTECTED)) {\n          matched=true;\n          _switchResult = \"protected \";\n        }\n      }\n      if (!matched) {\n        if (ObjectExtensions.operator_equals(visibility,JvmVisibility.DEFAULT)) {\n          matched=true;\n          _switchResult = \"\";\n        }\n      }\n      return _switchResult;\n    } else {\n      return \"\";\n    }\n  }","id":99818,"modified_method":"public String javaName(final JvmVisibility visibility) {\n    boolean _operator_notEquals = ObjectExtensions.operator_notEquals(visibility, null);\n    if (_operator_notEquals) {\n      String _switchResult = null;\n      boolean matched = false;\n      if (!matched) {\n        JvmVisibility _PRIVATE = JvmVisibility.PRIVATE;\n        if (ObjectExtensions.operator_equals(visibility,_PRIVATE)) {\n          matched=true;\n          _switchResult = \"private \";\n        }\n      }\n      if (!matched) {\n        JvmVisibility _PUBLIC = JvmVisibility.PUBLIC;\n        if (ObjectExtensions.operator_equals(visibility,_PUBLIC)) {\n          matched=true;\n          _switchResult = \"public \";\n        }\n      }\n      if (!matched) {\n        JvmVisibility _PROTECTED = JvmVisibility.PROTECTED;\n        if (ObjectExtensions.operator_equals(visibility,_PROTECTED)) {\n          matched=true;\n          _switchResult = \"protected \";\n        }\n      }\n      if (!matched) {\n        JvmVisibility _DEFAULT = JvmVisibility.DEFAULT;\n        if (ObjectExtensions.operator_equals(visibility,_DEFAULT)) {\n          matched=true;\n          _switchResult = \"\";\n        }\n      }\n      return _switchResult;\n    } else {\n      return \"\";\n    }\n  }","commit_id":"a3896c3422a823470a364bfbc3996c175126ec28","url":"https://github.com/eclipse/xtext"},{"original_method":"public CharSequence generateBody(final JvmGenericType it, final ImportManager importManager) {\n    StringConcatenation _builder = new StringConcatenation();\n    StringConcatenation _generateJavaDoc = this.generateJavaDoc(it);\n    _builder.append(_generateJavaDoc, \"\");\n    _builder.newLineIfNotEmpty();\n    EList<JvmAnnotationReference> _annotations = it.getAnnotations();\n    CharSequence _generateAnnotations = this.generateAnnotations(_annotations, importManager);\n    _builder.append(_generateAnnotations, \"\");\n    _builder.newLineIfNotEmpty();\n    CharSequence _generateModifier = this.generateModifier(it);\n    _builder.append(_generateModifier, \"\");\n    {\n      boolean _isInterface = it.isInterface();\n      if (_isInterface) {\n        _builder.append(\"interface\");\n      } else {\n        _builder.append(\"class\");\n      }\n    }\n    _builder.append(\" \");\n    String _simpleName = it.getSimpleName();\n    _builder.append(_simpleName, \"\");\n    EList<JvmTypeParameter> _typeParameters = it.getTypeParameters();\n    CharSequence _generateTypeParameterDeclaration = this.generateTypeParameterDeclaration(_typeParameters, importManager);\n    _builder.append(_generateTypeParameterDeclaration, \"\");\n    _builder.append(\" \");\n    String _generateExtendsClause = this.generateExtendsClause(it, importManager);\n    _builder.append(_generateExtendsClause, \"\");\n    _builder.append(\"{\");\n    _builder.newLineIfNotEmpty();\n    {\n      EList<JvmMember> _members = it.getMembers();\n      final Function1<JvmMember,CharSequence> _function = new Function1<JvmMember,CharSequence>() {\n          public CharSequence apply(final JvmMember m) {\n            CharSequence _generateMember = JvmModelGenerator.this.generateMember(m, importManager);\n            return _generateMember;\n          }\n        };\n      List<CharSequence> _map = ListExtensions.<JvmMember, CharSequence>map(_members, _function);\n      final Function1<CharSequence,Boolean> _function_1 = new Function1<CharSequence,Boolean>() {\n          public Boolean apply(final CharSequence c) {\n            boolean _operator_notEquals = ObjectExtensions.operator_notEquals(c, null);\n            return Boolean.valueOf(_operator_notEquals);\n          }\n        };\n      Iterable<CharSequence> _filter = IterableExtensions.<CharSequence>filter(_map, _function_1);\n      boolean _hasElements = false;\n      for(final CharSequence memberCode : _filter) {\n        if (!_hasElements) {\n          _hasElements = true;\n        } else {\n          _builder.appendImmediate(\"\\n\", \"  \");\n        }\n        _builder.append(\"  \");\n        _builder.append(memberCode, \"  \");\n        _builder.newLineIfNotEmpty();\n      }\n    }\n    _builder.append(\"}\");\n    _builder.newLine();\n    return _builder;\n  }","id":99819,"modified_method":"public CharSequence generateBody(final JvmGenericType it, final ImportManager importManager) {\n    StringConcatenation _builder = new StringConcatenation();\n    StringConcatenation _generateJavaDoc = this.generateJavaDoc(it);\n    _builder.append(_generateJavaDoc, \"\");\n    _builder.newLineIfNotEmpty();\n    EList<JvmAnnotationReference> _annotations = it.getAnnotations();\n    CharSequence _generateAnnotations = this.generateAnnotations(_annotations, importManager);\n    _builder.append(_generateAnnotations, \"\");\n    _builder.newLineIfNotEmpty();\n    CharSequence _generateModifier = this.generateModifier(it);\n    _builder.append(_generateModifier, \"\");\n    {\n      boolean _isInterface = it.isInterface();\n      if (_isInterface) {\n        _builder.append(\"interface\");\n      } else {\n        _builder.append(\"class\");\n      }\n    }\n    _builder.append(\" \");\n    String _simpleName = it.getSimpleName();\n    _builder.append(_simpleName, \"\");\n    EList<JvmTypeParameter> _typeParameters = it.getTypeParameters();\n    String _generateTypeParameterDeclaration = this.generateTypeParameterDeclaration(_typeParameters, importManager);\n    _builder.append(_generateTypeParameterDeclaration, \"\");\n    _builder.append(\" \");\n    String _generateExtendsClause = this.generateExtendsClause(it, importManager);\n    _builder.append(_generateExtendsClause, \"\");\n    _builder.append(\"{\");\n    _builder.newLineIfNotEmpty();\n    {\n      EList<JvmMember> _members = it.getMembers();\n      final Function1<JvmMember,CharSequence> _function = new Function1<JvmMember,CharSequence>() {\n          public CharSequence apply(final JvmMember m) {\n            CharSequence _generateMember = JvmModelGenerator.this.generateMember(m, importManager);\n            return _generateMember;\n          }\n        };\n      List<CharSequence> _map = ListExtensions.<JvmMember, CharSequence>map(_members, _function);\n      final Function1<CharSequence,Boolean> _function_1 = new Function1<CharSequence,Boolean>() {\n          public Boolean apply(final CharSequence c) {\n            boolean _operator_notEquals = ObjectExtensions.operator_notEquals(c, null);\n            return Boolean.valueOf(_operator_notEquals);\n          }\n        };\n      Iterable<CharSequence> _filter = IterableExtensions.<CharSequence>filter(_map, _function_1);\n      boolean _hasElements = false;\n      for(final CharSequence memberCode : _filter) {\n        if (!_hasElements) {\n          _hasElements = true;\n        } else {\n          _builder.appendImmediate(\"\\n\", \"  \");\n        }\n        _builder.append(\"  \");\n        _builder.append(memberCode, \"  \");\n        _builder.newLineIfNotEmpty();\n      }\n    }\n    _builder.append(\"}\");\n    _builder.newLine();\n    return _builder;\n  }","commit_id":"a3896c3422a823470a364bfbc3996c175126ec28","url":"https://github.com/eclipse/xtext"},{"original_method":"public CharSequence generateAnnotations(final List<JvmAnnotationReference> annotations, final ImportManager importManager) {\n    CharSequence _xblockexpression = null;\n    {\n      boolean _isEmpty = annotations.isEmpty();\n      if (_isEmpty) {\n        return null;\n      }\n      StringConcatenation _builder = new StringConcatenation();\n      {\n        for(final JvmAnnotationReference a : annotations) {\n          _builder.append(\"@\");\n          JvmAnnotationType _annotation = a.getAnnotation();\n          CharSequence _serialize = importManager.serialize(_annotation);\n          _builder.append(_serialize, \"\");\n          {\n            EList<JvmAnnotationValue> _values = a.getValues();\n            boolean _hasElements = false;\n            for(final JvmAnnotationValue value : _values) {\n              if (!_hasElements) {\n                _hasElements = true;\n                _builder.append(\"(\", \"\");\n              } else {\n                _builder.appendImmediate(\", \", \"\");\n              }\n              CharSequence _java = this.toJava(value, importManager);\n              _builder.append(_java, \"\");\n            }\n            if (_hasElements) {\n              _builder.append(\")\", \"\");\n            }\n          }\n          _builder.newLineIfNotEmpty();\n        }\n      }\n      _xblockexpression = (_builder);\n    }\n    return _xblockexpression;\n  }","id":99820,"modified_method":"public CharSequence generateAnnotations(final List<JvmAnnotationReference> annotations, final ImportManager importManager) {\n    CharSequence _xblockexpression = null;\n    {\n      boolean _isEmpty = annotations.isEmpty();\n      if (_isEmpty) {\n        return null;\n      }\n      StringConcatenation _builder = new StringConcatenation();\n      {\n        for(final JvmAnnotationReference a : annotations) {\n          _builder.append(\"@\");\n          JvmAnnotationType _annotation = a.getAnnotation();\n          CharSequence _serialize = importManager.serialize(_annotation);\n          _builder.append(_serialize, \"\");\n          EList<JvmAnnotationValue> _values = a.getValues();\n          final Function1<JvmAnnotationValue,CharSequence> _function = new Function1<JvmAnnotationValue,CharSequence>() {\n              public CharSequence apply(final JvmAnnotationValue it) {\n                CharSequence _java = JvmModelGenerator.this.toJava(it, importManager);\n                return _java;\n              }\n            };\n          String _join = IterableExtensions.<JvmAnnotationValue>join(_values, \"(\", \", \", \")\", _function);\n          _builder.append(_join, \"\");\n          _builder.newLineIfNotEmpty();\n        }\n      }\n      _xblockexpression = (_builder);\n    }\n    return _xblockexpression;\n  }","commit_id":"a3896c3422a823470a364bfbc3996c175126ec28","url":"https://github.com/eclipse/xtext"},{"original_method":"protected CharSequence _generateMember(final JvmOperation it, final ImportManager importManager) {\n    StringConcatenation _builder = new StringConcatenation();\n    StringConcatenation _generateJavaDoc = this.generateJavaDoc(it);\n    _builder.append(_generateJavaDoc, \"\");\n    _builder.newLineIfNotEmpty();\n    {\n      EList<JvmAnnotationReference> _annotations = it.getAnnotations();\n      boolean _isEmpty = _annotations.isEmpty();\n      boolean _operator_not = BooleanExtensions.operator_not(_isEmpty);\n      if (_operator_not) {\n        EList<JvmAnnotationReference> _annotations_1 = it.getAnnotations();\n        CharSequence _generateAnnotations = this.generateAnnotations(_annotations_1, importManager);\n        _builder.append(_generateAnnotations, \"\");\n      }\n    }\n    _builder.newLineIfNotEmpty();\n    CharSequence _generateModifier = this.generateModifier(it);\n    _builder.append(_generateModifier, \"\");\n    EList<JvmTypeParameter> _typeParameters = it.getTypeParameters();\n    CharSequence _generateTypeParameterDeclaration = this.generateTypeParameterDeclaration(_typeParameters, importManager);\n    _builder.append(_generateTypeParameterDeclaration, \"\");\n    String _xifexpression = null;\n    JvmTypeReference _returnType = it.getReturnType();\n    boolean _operator_equals = ObjectExtensions.operator_equals(_returnType, null);\n    if (_operator_equals) {\n      _xifexpression = \"void\";\n    } else {\n      JvmTypeReference _returnType_1 = it.getReturnType();\n      String _serialize = this.serialize(_returnType_1, importManager);\n      _xifexpression = _serialize;\n    }\n    _builder.append(_xifexpression, \"\");\n    _builder.append(\" \");\n    String _simpleName = it.getSimpleName();\n    _builder.append(_simpleName, \"\");\n    _builder.append(\"(\");\n    EList<JvmFormalParameter> _parameters = it.getParameters();\n    final Function1<JvmFormalParameter,String> _function = new Function1<JvmFormalParameter,String>() {\n        public String apply(final JvmFormalParameter p) {\n          String _generateParameter = JvmModelGenerator.this.generateParameter(p, importManager);\n          return _generateParameter;\n        }\n      };\n    List<String> _map = ListExtensions.<JvmFormalParameter, String>map(_parameters, _function);\n    String _join = IterableExtensions.join(_map, \", \");\n    _builder.append(_join, \"\");\n    _builder.append(\")\");\n    String _generateThrowsClause = this.generateThrowsClause(it, importManager);\n    _builder.append(_generateThrowsClause, \"\");\n    {\n      boolean _isAbstract = it.isAbstract();\n      if (_isAbstract) {\n        _builder.append(\";\");\n      } else {\n        _builder.append(\" {\");\n        _builder.newLineIfNotEmpty();\n        _builder.append(\"  \");\n        CharSequence _generateBody = this.generateBody(it, importManager);\n        _builder.append(_generateBody, \"  \");\n        _builder.newLineIfNotEmpty();\n        _builder.append(\"}\");\n        _builder.newLine();\n      }\n    }\n    return _builder;\n  }","id":99821,"modified_method":"protected CharSequence _generateMember(final JvmOperation it, final ImportManager importManager) {\n    StringConcatenation _builder = new StringConcatenation();\n    StringConcatenation _generateJavaDoc = this.generateJavaDoc(it);\n    _builder.append(_generateJavaDoc, \"\");\n    _builder.newLineIfNotEmpty();\n    {\n      EList<JvmAnnotationReference> _annotations = it.getAnnotations();\n      boolean _isEmpty = _annotations.isEmpty();\n      boolean _operator_not = BooleanExtensions.operator_not(_isEmpty);\n      if (_operator_not) {\n        EList<JvmAnnotationReference> _annotations_1 = it.getAnnotations();\n        CharSequence _generateAnnotations = this.generateAnnotations(_annotations_1, importManager);\n        _builder.append(_generateAnnotations, \"\");\n      }\n    }\n    _builder.newLineIfNotEmpty();\n    CharSequence _generateModifier = this.generateModifier(it);\n    _builder.append(_generateModifier, \"\");\n    EList<JvmTypeParameter> _typeParameters = it.getTypeParameters();\n    String _generateTypeParameterDeclaration = this.generateTypeParameterDeclaration(_typeParameters, importManager);\n    _builder.append(_generateTypeParameterDeclaration, \"\");\n    String _xifexpression = null;\n    JvmTypeReference _returnType = it.getReturnType();\n    boolean _operator_equals = ObjectExtensions.operator_equals(_returnType, null);\n    if (_operator_equals) {\n      _xifexpression = \"void\";\n    } else {\n      JvmTypeReference _returnType_1 = it.getReturnType();\n      String _serialize = this.serialize(_returnType_1, importManager);\n      _xifexpression = _serialize;\n    }\n    _builder.append(_xifexpression, \"\");\n    _builder.append(\" \");\n    String _simpleName = it.getSimpleName();\n    _builder.append(_simpleName, \"\");\n    _builder.append(\"(\");\n    EList<JvmFormalParameter> _parameters = it.getParameters();\n    final Function1<JvmFormalParameter,String> _function = new Function1<JvmFormalParameter,String>() {\n        public String apply(final JvmFormalParameter p) {\n          String _generateParameter = JvmModelGenerator.this.generateParameter(p, importManager);\n          return _generateParameter;\n        }\n      };\n    List<String> _map = ListExtensions.<JvmFormalParameter, String>map(_parameters, _function);\n    String _join = IterableExtensions.join(_map, \", \");\n    _builder.append(_join, \"\");\n    _builder.append(\")\");\n    String _generateThrowsClause = this.generateThrowsClause(it, importManager);\n    _builder.append(_generateThrowsClause, \"\");\n    {\n      boolean _isAbstract = it.isAbstract();\n      if (_isAbstract) {\n        _builder.append(\";\");\n      } else {\n        _builder.append(\" {\");\n        _builder.newLineIfNotEmpty();\n        _builder.append(\"  \");\n        CharSequence _generateBody = this.generateBody(it, importManager);\n        _builder.append(_generateBody, \"  \");\n        _builder.newLineIfNotEmpty();\n        _builder.append(\"}\");\n        _builder.newLine();\n      }\n    }\n    return _builder;\n  }","commit_id":"a3896c3422a823470a364bfbc3996c175126ec28","url":"https://github.com/eclipse/xtext"},{"original_method":"public CharSequence generateTypeParameterDeclaration(final List<JvmTypeParameter> typeParameters, final ImportManager importManager) {\n    StringConcatenation _builder = new StringConcatenation();\n    {\n      boolean _hasElements = false;\n      for(final JvmTypeParameter it : typeParameters) {\n        if (!_hasElements) {\n          _hasElements = true;\n          _builder.append(\"<\", \"\");\n        } else {\n          _builder.appendImmediate(\", \", \"\");\n        }\n        CharSequence _generateTypeParameterDeclaration = this.generateTypeParameterDeclaration(it, importManager);\n        _builder.append(_generateTypeParameterDeclaration, \"\");\n      }\n      if (_hasElements) {\n        _builder.append(\"> \", \"\");\n      }\n    }\n    return _builder;\n  }","id":99822,"modified_method":"public String generateTypeParameterDeclaration(final List<JvmTypeParameter> typeParameters, final ImportManager importManager) {\n    final Function1<JvmTypeParameter,CharSequence> _function = new Function1<JvmTypeParameter,CharSequence>() {\n        public CharSequence apply(final JvmTypeParameter it) {\n          CharSequence _generateTypeParameterDeclaration = JvmModelGenerator.this.generateTypeParameterDeclaration(it, importManager);\n          return _generateTypeParameterDeclaration;\n        }\n      };\n    String _join = IterableExtensions.<JvmTypeParameter>join(typeParameters, \"<\", \", \", \">\", _function);\n    return _join;\n  }","commit_id":"a3896c3422a823470a364bfbc3996c175126ec28","url":"https://github.com/eclipse/xtext"},{"original_method":"public CharSequence generateTypeParameterConstraints(final JvmTypeParameter it, final ImportManager importManager) {\n    StringConcatenation _builder = new StringConcatenation();\n    {\n      EList<JvmTypeConstraint> _constraints = it.getConstraints();\n      Iterable<JvmUpperBound> _filter = IterableExtensions.<JvmUpperBound>filter(_constraints, org.eclipse.xtext.common.types.JvmUpperBound.class);\n      boolean _hasElements = false;\n      for(final JvmUpperBound it_1 : _filter) {\n        if (!_hasElements) {\n          _hasElements = true;\n          _builder.append(\" extends \", \"\");\n        } else {\n          _builder.appendImmediate(\" & \", \"\");\n        }\n        JvmTypeReference _typeReference = it_1.getTypeReference();\n        String _serialize = this.serialize(_typeReference, importManager);\n        _builder.append(_serialize, \"\");\n      }\n    }\n    return _builder;\n  }","id":99823,"modified_method":"public String generateTypeParameterConstraints(final JvmTypeParameter it, final ImportManager importManager) {\n    EList<JvmTypeConstraint> _constraints = it.getConstraints();\n    Iterable<JvmUpperBound> _filter = IterableExtensions.<JvmUpperBound>filter(_constraints, org.eclipse.xtext.common.types.JvmUpperBound.class);\n    final Function1<JvmUpperBound,String> _function = new Function1<JvmUpperBound,String>() {\n        public String apply(final JvmUpperBound it) {\n          JvmTypeReference _typeReference = it.getTypeReference();\n          String _serialize = JvmModelGenerator.this.serialize(_typeReference, importManager);\n          return _serialize;\n        }\n      };\n    String _join = IterableExtensions.<JvmUpperBound>join(_filter, \" extends \", \" & \", \"\", _function);\n    return _join;\n  }","commit_id":"a3896c3422a823470a364bfbc3996c175126ec28","url":"https://github.com/eclipse/xtext"},{"original_method":"public static Map createInvoiceForOrder(DispatchContext dctx, Map context) {\n        GenericDelegator delegator = dctx.getDelegator();\n        LocalDispatcher dispatcher = dctx.getDispatcher();\n        GenericValue userLogin = (GenericValue) context.get(\"userLogin\");\n        Locale locale = (Locale) context.get(\"locale\");\n\n        if (decimals == -1 || rounding == -1) {\n            return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingAritmeticPropertiesNotConfigured\",locale));\n        }\n\n        String orderId = (String) context.get(\"orderId\");\n        List billItems = (List) context.get(\"billItems\");\n        boolean previousInvoiceFound = false;\n\n        if (billItems == null || billItems.size() == 0) {\n            Debug.logVerbose(\"No order items to invoice; not creating invoice; returning success\", module);\n            return ServiceUtil.returnSuccess(UtilProperties.getMessage(resource,\"AccountingNoOrderItemsToInvoice\",locale));\n        }\n\n        try {\n            GenericValue orderHeader = delegator.findByPrimaryKey(\"OrderHeader\", UtilMisc.toMap(\"orderId\", orderId));\n            if (orderHeader == null) {\n                return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingNoOrderHeader\",locale));\n            }\n\n            // get list of previous invoices for the order\n            List billedItems = delegator.findByAnd(\"OrderItemBilling\", UtilMisc.toMap(\"orderId\", orderId));\n            if (billedItems != null && billedItems.size() > 0) {\n                boolean nonDigitalInvoice = false;\n                Iterator bii = billedItems.iterator();\n                while (bii.hasNext() && !nonDigitalInvoice) {\n                    GenericValue orderItemBilling = (GenericValue) bii.next();\n                    GenericValue invoiceItem = orderItemBilling.getRelatedOne(\"InvoiceItem\");\n                    if (invoiceItem != null) {\n                        String invoiceItemType = invoiceItem.getString(\"invoiceItemTypeId\");\n                        if (invoiceItemType != null) {\n                            if (\"INV_FPROD_ITEM\".equals(invoiceItemType) || \"INV_PROD_FEATR_ITEM\".equals(invoiceItemType)) {\n                                nonDigitalInvoice = true;\n                            }\n                        }\n                    }\n                }\n                if (nonDigitalInvoice) {\n                    previousInvoiceFound = true;\n                }\n            }\n\n            // figure out the invoice type\n            String invoiceType = null;\n\n            String orderType = orderHeader.getString(\"orderTypeId\");\n            if (orderType.equals(\"SALES_ORDER\")) {\n                invoiceType = \"SALES_INVOICE\";\n            } else if (orderType.equals(\"PURCHASE_ORDER\")) {\n                invoiceType = \"PURCHASE_INVOICE\";\n            }\n\n            // Make an order read helper from the order\n            OrderReadHelper orh = new OrderReadHelper(orderHeader);\n\n            // get the product store\n            GenericValue productStore = delegator.findByPrimaryKey(\"ProductStore\", UtilMisc.toMap(\"productStoreId\", orh.getProductStoreId()));\n\n            // get the shipping adjustment mode (Y = Pro-Rate; N = First-Invoice)\n            String prorateShipping = productStore.getString(\"prorateShipping\");\n            if (prorateShipping == null) {\n                prorateShipping = \"Y\";\n            }\n\n            // get the billing parties\n            String billToCustomerPartyId = orh.getBillToParty().getString(\"partyId\");\n            String billFromVendorPartyId = orh.getBillFromParty().getString(\"partyId\");\n\n            // get some quantity totals\n            BigDecimal totalItemsInOrder = orh.getTotalOrderItemsQuantityBd();\n\n            // get some price totals\n            BigDecimal shippableAmount = orh.getShippableTotalBd(null);\n            BigDecimal orderSubTotal = orh.getOrderItemsSubTotalBd();\n\n            // these variables are for pro-rating order amounts across invoices, so they should not be rounded off for maximum accuracy\n            BigDecimal invoiceShipProRateAmount = ZERO;\n            BigDecimal invoiceSubTotal = ZERO;\n            BigDecimal invoiceQuantity = ZERO;\n\n            GenericValue billingAccount = orderHeader.getRelatedOne(\"BillingAccount\");\n            String billingAccountId = billingAccount != null ? billingAccount.getString(\"billingAccountId\") : null;\n\n            // TODO: ideally this should be the same time as when a shipment is sent and be passed in as a parameter \n            Timestamp invoiceDate = UtilDateTime.nowTimestamp();\n            // TODO: perhaps consider billing account net days term as well?\n            Long orderTermNetDays = orh.getOrderTermNetDays();\n            Timestamp dueDate = null;\n            if (orderTermNetDays != null) {\n                dueDate = UtilDateTime.getDayEnd(invoiceDate, orderTermNetDays.intValue());\n            }\n            \n            // create the invoice record\n            Map createInvoiceContext = FastMap.newInstance();\n            createInvoiceContext.put(\"partyId\", billToCustomerPartyId);\n            createInvoiceContext.put(\"partyIdFrom\", billFromVendorPartyId);\n            createInvoiceContext.put(\"billingAccountId\", billingAccountId);\n            createInvoiceContext.put(\"invoiceDate\", invoiceDate);\n            createInvoiceContext.put(\"dueDate\", dueDate);\n            createInvoiceContext.put(\"invoiceTypeId\", invoiceType);\n            // start with INVOICE_IN_PROCESS, in the INVOICE_READY we can't change the invoice (or shouldn't be able to...)\n            createInvoiceContext.put(\"statusId\", \"INVOICE_IN_PROCESS\");\n            createInvoiceContext.put(\"currencyUomId\", orderHeader.getString(\"currencyUom\"));\n            createInvoiceContext.put(\"userLogin\", userLogin);\n\n            // store the invoice first\n            Map createInvoiceResult = dispatcher.runSync(\"createInvoice\", createInvoiceContext);\n            if (ServiceUtil.isError(createInvoiceResult)) {\n                return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingErrorCreatingInvoiceFromOrder\",locale), null, null, createInvoiceResult);\n            }\n            \n            // call service, not direct entity op: delegator.create(invoice);\n            String invoiceId = (String) createInvoiceResult.get(\"invoiceId\");\n\n            // order roles to invoice roles\n            List orderRoles = orderHeader.getRelated(\"OrderRole\");\n            if (orderRoles != null) {\n                Iterator orderRolesIt = orderRoles.iterator();\n                Map createInvoiceRoleContext = FastMap.newInstance();\n                createInvoiceRoleContext.put(\"invoiceId\", invoiceId);\n                createInvoiceRoleContext.put(\"userLogin\", userLogin);\n                while (orderRolesIt.hasNext()) {\n                    GenericValue orderRole = (GenericValue)orderRolesIt.next();\n                    createInvoiceRoleContext.put(\"partyId\", orderRole.getString(\"partyId\"));\n                    createInvoiceRoleContext.put(\"roleTypeId\", orderRole.getString(\"roleTypeId\"));\n                    Map createInvoiceRoleResult = dispatcher.runSync(\"createInvoiceRole\", createInvoiceRoleContext);\n                    if (ServiceUtil.isError(createInvoiceRoleResult)) {\n                        return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingErrorCreatingInvoiceFromOrder\",locale), null, null, createInvoiceRoleResult);\n                    }\n                }\n            }\n\n            // order terms to invoice terms.  Implemented for purchase orders, although it may be useful\n            // for sales orders as well.  Later it might be nice to filter OrderTerms to only copy over financial terms.\n            List orderTerms = orh.getOrderTerms();\n            createInvoiceTerms(delegator, dispatcher, invoiceId, orderTerms, userLogin, locale);\n\n            // billing accounts\n            List billingAccountTerms = null;\n            // for billing accounts we will use related information\n            if (billingAccount != null) {\n                // get the billing account terms\n                billingAccountTerms = billingAccount.getRelated(\"BillingAccountTerm\");\n\n                // set the invoice terms as defined for the billing account\n                createInvoiceTerms(delegator, dispatcher, invoiceId, billingAccountTerms, userLogin, locale);\n\n                // set the invoice bill_to_customer from the billing account\n                List billToRoles = billingAccount.getRelated(\"BillingAccountRole\", UtilMisc.toMap(\"roleTypeId\", \"BILL_TO_CUSTOMER\"), null);\n                Iterator billToIter = billToRoles.iterator();\n                while (billToIter.hasNext()) {\n                    GenericValue billToRole = (GenericValue) billToIter.next();\n                    if (!(billToRole.getString(\"partyId\").equals(billToCustomerPartyId))) {\n                        Map createInvoiceRoleContext = UtilMisc.toMap(\"invoiceId\", invoiceId, \"partyId\", billToRole.get(\"partyId\"), \n                                                                           \"roleTypeId\", \"BILL_TO_CUSTOMER\", \"userLogin\", userLogin);\n                        Map createInvoiceRoleResult = dispatcher.runSync(\"createInvoiceRole\", createInvoiceRoleContext);\n                        if (ServiceUtil.isError(createInvoiceRoleResult)) {\n                            return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingErrorCreatingInvoiceRoleFromOrder\",locale), null, null, createInvoiceRoleResult);\n                        }\n                    }\n                }\n\n                // set the bill-to contact mech as the contact mech of the billing account\n                if (UtilValidate.isNotEmpty(billingAccount.getString(\"contactMechId\"))) {\n                    Map createBillToContactMechContext = UtilMisc.toMap(\"invoiceId\", invoiceId, \"contactMechId\", billingAccount.getString(\"contactMechId\"), \n                                                                       \"contactMechPurposeTypeId\", \"BILLING_LOCATION\", \"userLogin\", userLogin);\n                    Map createBillToContactMechResult = dispatcher.runSync(\"createInvoiceContactMech\", createBillToContactMechContext);\n                    if (ServiceUtil.isError(createBillToContactMechResult)) {\n                        return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingErrorCreatingInvoiceContactMechFromOrder\",locale), null, null, createBillToContactMechResult);\n                    }\n                }\n            } else {\n                List billingLocations = orh.getBillingLocations();\n                if (billingLocations != null) {\n                    Iterator bli = billingLocations.iterator();\n                    while (bli.hasNext()) {\n                        GenericValue ocm = (GenericValue) bli.next();\n                        Map createBillToContactMechContext = UtilMisc.toMap(\"invoiceId\", invoiceId, \"contactMechId\", ocm.getString(\"contactMechId\"), \n                                                                           \"contactMechPurposeTypeId\", \"BILLING_LOCATION\", \"userLogin\", userLogin);\n                        Map createBillToContactMechResult = dispatcher.runSync(\"createInvoiceContactMech\", createBillToContactMechContext);\n                        if (ServiceUtil.isError(createBillToContactMechResult)) {\n                            return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingErrorCreatingInvoiceContactMechFromOrder\",locale), null, null, createBillToContactMechResult);\n                        }\n                    }\n                }\n            }\n\n            // get a list of the payment method types\n            //DEJ20050705 doesn't appear to be used: List paymentPreferences = orderHeader.getRelated(\"OrderPaymentPreference\");\n\n            // create the bill-from (or pay-to) contact mech as the primary PAYMENT_LOCATION of the party from the store\n            GenericValue payToAddress = null;\n            if (invoiceType.equals(\"PURCHASE_INVOICE\")) {\n                // for purchase orders, the pay to address is the BILLING_LOCATION of the vendor\n                GenericValue billFromVendor = orh.getPartyFromRole(\"BILL_FROM_VENDOR\");\n                if (billFromVendor != null) {\n                    List billingContactMechs = billFromVendor.getRelatedOne(\"Party\").getRelatedByAnd(\"PartyContactMechPurpose\",\n                            UtilMisc.toMap(\"contactMechPurposeTypeId\", \"BILLING_LOCATION\"));\n                    if ((billingContactMechs != null) && (billingContactMechs.size() > 0)) {\n                        payToAddress = (GenericValue) billingContactMechs.get(0);\n                    }\n                }\n            } else {\n                // for sales orders, it is the payment address on file for the store\n                payToAddress = PaymentWorker.getPaymentAddress(delegator, productStore.getString(\"payToPartyId\"));\n            }\n            if (payToAddress != null) {\n                Map createPayToContactMechContext = UtilMisc.toMap(\"invoiceId\", invoiceId, \"contactMechId\", payToAddress.getString(\"contactMechId\"), \n                                                                   \"contactMechPurposeTypeId\", \"PAYMENT_LOCATION\", \"userLogin\", userLogin);\n                Map createPayToContactMechResult = dispatcher.runSync(\"createInvoiceContactMech\", createPayToContactMechContext);\n                if (ServiceUtil.isError(createPayToContactMechResult)) {\n                    return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingErrorCreatingInvoiceContactMechFromOrder\",locale), null, null, createPayToContactMechResult);\n                }\n            }\n\n            // sequence for items - all OrderItems or InventoryReservations + all Adjustments\n            int invoiceItemSeqNum = 1;\n            String invoiceItemSeqId = UtilFormatOut.formatPaddedNumber(invoiceItemSeqNum, 2);\n\n            // create the item records\n            if (billItems != null) {\n                Iterator itemIter = billItems.iterator();\n                while (itemIter.hasNext()) {\n                    GenericValue itemIssuance = null;\n                    GenericValue orderItem = null;\n                    GenericValue shipmentReceipt = null;\n                    GenericValue currentValue = (GenericValue) itemIter.next();\n                    if (\"ItemIssuance\".equals(currentValue.getEntityName())) {\n                        itemIssuance = currentValue;\n                    } else if (\"OrderItem\".equals(currentValue.getEntityName())) {\n                        orderItem = currentValue;\n                    } else if (\"ShipmentReceipt\".equals(currentValue.getEntityName())) {\n                        shipmentReceipt = currentValue;\n                    } else {\n                        Debug.logError(\"Unexpected entity \" + currentValue + \" of type \" + currentValue.getEntityName(), module);\n                    }\n\n                    if (orderItem == null && itemIssuance != null) {\n                        orderItem = itemIssuance.getRelatedOne(\"OrderItem\");\n                    } else if ((orderItem == null) && (shipmentReceipt != null)) {\n                        orderItem = shipmentReceipt.getRelatedOne(\"OrderItem\");\n                    } else if ((orderItem == null) && (itemIssuance == null) && (shipmentReceipt == null)) {\n                        Debug.logError(\"Cannot create invoice when orderItem, itemIssuance, and shipmentReceipt are all null\", module);\n                        return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingIllegalValuesPassedToCreateInvoiceService\",locale));\n                    }\n                    GenericValue product = null;\n                    if (orderItem.get(\"productId\") != null) {\n                        product = orderItem.getRelatedOne(\"Product\");\n                    }\n\n                    // get some quantities\n                    BigDecimal orderedQuantity = orderItem.getBigDecimal(\"quantity\");\n                    BigDecimal billingQuantity = null;\n                    if (itemIssuance != null) {\n                        billingQuantity = itemIssuance.getBigDecimal(\"quantity\");\n                    } else if (shipmentReceipt != null) {\n                        billingQuantity = shipmentReceipt.getBigDecimal(\"quantityAccepted\");\n                    } else {\n                        billingQuantity = orderedQuantity;\n                    }\n                    if (orderedQuantity == null) orderedQuantity = ZERO;\n                    if (billingQuantity == null) billingQuantity = ZERO;\n\n                    // check if shipping applies to this item.  Shipping is calculated for sales invoices, not purchase invoices.\n                    boolean shippingApplies = false;\n                    if ((product != null) && (ProductWorker.shippingApplies(product)) && (invoiceType.equals(\"SALES_INVOICE\"))) {\n                        shippingApplies = true;\n                    }\n\n                    BigDecimal billingAmount = orderItem.getBigDecimal(\"unitPrice\").setScale(decimals, rounding);\n                    \n                    Map createInvoiceItemContext = FastMap.newInstance();\n                    createInvoiceItemContext.put(\"invoiceId\", invoiceId);\n                    createInvoiceItemContext.put(\"invoiceItemSeqId\", invoiceItemSeqId);\n                    createInvoiceItemContext.put(\"invoiceItemTypeId\", getInvoiceItemType(delegator, (orderItem == null ? null : orderItem.getString(\"orderItemTypeId\")), (product == null ? null : product.getString(\"productTypeId\")), invoiceType, \"INV_FPROD_ITEM\"));\n                    createInvoiceItemContext.put(\"description\", orderItem.get(\"itemDescription\"));\n                    createInvoiceItemContext.put(\"quantity\", new Double(billingQuantity.doubleValue()));\n                    createInvoiceItemContext.put(\"amount\", new Double(billingAmount.doubleValue()));\n                    createInvoiceItemContext.put(\"productId\", orderItem.get(\"productId\"));\n                    createInvoiceItemContext.put(\"productFeatureId\", orderItem.get(\"productFeatureId\"));\n                    createInvoiceItemContext.put(\"overrideGlAccountId\", orderItem.get(\"overrideGlAccountId\"));\n                    //createInvoiceItemContext.put(\"uomId\", \"\");\n                    createInvoiceItemContext.put(\"userLogin\", userLogin);\n\n                    String itemIssuanceId = null;\n                    if (itemIssuance != null && itemIssuance.get(\"inventoryItemId\") != null) {\n                        itemIssuanceId = itemIssuance.getString(\"itemIssuanceId\");\n                        createInvoiceItemContext.put(\"inventoryItemId\", itemIssuance.get(\"inventoryItemId\"));\n                    }\n                    // similarly, tax only for purchase invoices\n                    if ((product != null) && (invoiceType.equals(\"SALES_INVOICE\"))) {\n                        createInvoiceItemContext.put(\"taxableFlag\", product.get(\"taxable\"));\n                    }\n\n                    Map createInvoiceItemResult = dispatcher.runSync(\"createInvoiceItem\", createInvoiceItemContext);\n                    if (ServiceUtil.isError(createInvoiceItemResult)) {\n                        return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingErrorCreatingInvoiceItemFromOrder\",locale), null, null, createInvoiceItemResult);\n                    }\n\n                    // this item total\n                    BigDecimal thisAmount = billingAmount.multiply(billingQuantity).setScale(decimals, rounding);\n\n                    // add to the ship amount only if it applies to this item\n                    if (shippingApplies) {\n                        invoiceShipProRateAmount = invoiceShipProRateAmount.add(thisAmount).setScale(decimals, rounding);\n                    }\n\n                    // increment the invoice subtotal\n                    invoiceSubTotal = invoiceSubTotal.add(thisAmount).setScale(100, rounding);\n\n                    // increment the invoice quantity\n                    invoiceQuantity = invoiceQuantity.add(billingQuantity).setScale(decimals, rounding);\n\n                    // create the OrderItemBilling record\n                    Map createOrderItemBillingContext = FastMap.newInstance();\n                    createOrderItemBillingContext.put(\"invoiceId\", invoiceId);\n                    createOrderItemBillingContext.put(\"invoiceItemSeqId\", invoiceItemSeqId);\n                    createOrderItemBillingContext.put(\"orderId\", orderItem.get(\"orderId\"));\n                    createOrderItemBillingContext.put(\"orderItemSeqId\", orderItem.get(\"orderItemSeqId\"));\n                    createOrderItemBillingContext.put(\"itemIssuanceId\", itemIssuanceId);\n                    createOrderItemBillingContext.put(\"quantity\", new Double(billingQuantity.doubleValue()));\n                    createOrderItemBillingContext.put(\"amount\", new Double(billingAmount.doubleValue()));\n                    createOrderItemBillingContext.put(\"userLogin\", userLogin);\n                    if ((shipmentReceipt != null) && (shipmentReceipt.getString(\"receiptId\") != null)) {\n                        createOrderItemBillingContext.put(\"shipmentReceiptId\", shipmentReceipt.getString(\"receiptId\"));\n                    }\n\n                    Map createOrderItemBillingResult = dispatcher.runSync(\"createOrderItemBilling\", createOrderItemBillingContext);\n                    if (ServiceUtil.isError(createOrderItemBillingResult)) {\n                        return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingErrorCreatingOrderItemBillingFromOrder\",locale), null, null, createOrderItemBillingResult);\n                    }\n\n                    String parentInvoiceItemSeqId = invoiceItemSeqId;\n                    // increment the counter\n                    invoiceItemSeqNum++;\n                    invoiceItemSeqId = UtilFormatOut.formatPaddedNumber(invoiceItemSeqNum, 2);\n\n                    // Get the original order item from the DB, in case the quantity has been overridden\n                    GenericValue originalOrderItem = delegator.findByPrimaryKey(\"OrderItem\", UtilMisc.toMap(\"orderId\", orderId, \"orderItemSeqId\", orderItem.getString(\"orderItemSeqId\")));\n\n                    // create the item adjustment as line items\n                    List itemAdjustments = OrderReadHelper.getOrderItemAdjustmentList(orderItem, orh.getAdjustments());\n                    Iterator itemAdjIter = itemAdjustments.iterator();\n                    while (itemAdjIter.hasNext()) {\n                        GenericValue adj = (GenericValue) itemAdjIter.next();\n                        \n                        // Check against OrderAdjustmentBilling to see how much of this adjustment has already been invoiced\n                        BigDecimal adjAlreadyInvoicedAmount = null;\n                        try {\n                            Map checkResult = dispatcher.runSync(\"calculateInvoicedAdjustmentTotal\", UtilMisc.toMap(\"orderAdjustment\", adj));\n                            adjAlreadyInvoicedAmount = (BigDecimal) checkResult.get(\"invoicedTotal\");\n                        } catch (GenericServiceException e) {\n                            String errMsg = UtilProperties.getMessage(resource, \"AccountingTroubleCallingCalculateInvoicedAdjustmentTotalService\", locale);\n                            Debug.logError(e, errMsg, module);\n                            return ServiceUtil.returnError(errMsg);\n                        }\n        \n                        // If the absolute invoiced amount >= the abs of the adjustment amount, the full amount has already been invoiced,\n                        //  so skip this adjustment\n                        if (adjAlreadyInvoicedAmount.abs().compareTo(adj.getBigDecimal(\"amount\").setScale(decimals, rounding).abs()) > 0) {\n                            continue;\n                        }\n        \n                        BigDecimal amount = ZERO;\n                        if (adj.get(\"amount\") != null) { \n                            // pro-rate the amount\n                            // set decimals = 100 means we don't round this intermediate value, which is very important\n                            amount = adj.getBigDecimal(\"amount\").divide(originalOrderItem.getBigDecimal(\"quantity\"), 100, rounding);\n                            amount = amount.multiply(billingQuantity);\n                            amount = amount.setScale(decimals, rounding);\n                        }\n                        else if (adj.get(\"sourcePercentage\") != null) { \n                            // pro-rate the amount\n                            // set decimals = 100 means we don't round this intermediate value, which is very important\n                            BigDecimal percent = adj.getBigDecimal(\"sourcePercentage\");\n                            percent = percent.divide(new BigDecimal(100), 100, rounding);\n                            amount = billingAmount.multiply(percent); \n                            amount = amount.divide(originalOrderItem.getBigDecimal(\"quantity\"), 100, rounding);\n                            amount = amount.multiply(billingQuantity);\n                            amount = amount.setScale(decimals, rounding);\n                        }\n                        if (amount.signum() != 0) {                      \n\t                        Map createInvoiceItemAdjContext = FastMap.newInstance();\n\t                        createInvoiceItemAdjContext.put(\"invoiceId\", invoiceId);\n\t                        createInvoiceItemAdjContext.put(\"invoiceItemSeqId\", invoiceItemSeqId);\n\t                        createInvoiceItemAdjContext.put(\"invoiceItemTypeId\", getInvoiceItemType(delegator, adj.getString(\"orderAdjustmentTypeId\"), null, invoiceType, \"INVOICE_ITM_ADJ\"));\n\t                        createInvoiceItemAdjContext.put(\"description\", adj.get(\"description\"));\n\t                        createInvoiceItemAdjContext.put(\"quantity\", new Double(1));\n\t                        createInvoiceItemAdjContext.put(\"amount\", new Double(amount.doubleValue()));\n\t                        createInvoiceItemAdjContext.put(\"productId\", orderItem.get(\"productId\"));\n\t                        createInvoiceItemAdjContext.put(\"productFeatureId\", orderItem.get(\"productFeatureId\"));\n\t                        createInvoiceItemAdjContext.put(\"overrideGlAccountId\", adj.get(\"overrideGlAccountId\"));\n\t                        createInvoiceItemAdjContext.put(\"parentInvoiceId\", invoiceId);\n\t                        createInvoiceItemAdjContext.put(\"parentInvoiceItemSeqId\", parentInvoiceItemSeqId);\n\t                        //createInvoiceItemAdjContext.put(\"uomId\", \"\");\n\t                        createInvoiceItemAdjContext.put(\"userLogin\", userLogin);\n\t                        createInvoiceItemAdjContext.put(\"taxAuthPartyId\", adj.get(\"taxAuthPartyId\"));\n\t                        createInvoiceItemAdjContext.put(\"taxAuthGeoId\", adj.get(\"taxAuthGeoId\"));\n\t                        createInvoiceItemAdjContext.put(\"taxAuthorityRateSeqId\", adj.get(\"taxAuthorityRateSeqId\"));\n\t    \n\t                        // invoice items for sales tax are not taxable themselves\n\t                        // TODO: This is not an ideal solution. Instead, we need to use OrderAdjustment.includeInTax when it is implemented\n\t                        if (!(adj.getString(\"orderAdjustmentTypeId\").equals(\"SALES_TAX\"))) {\n\t                            createInvoiceItemAdjContext.put(\"taxableFlag\", product.get(\"taxable\"));    \n\t                        }\n\t    \n\t                        Map createInvoiceItemAdjResult = dispatcher.runSync(\"createInvoiceItem\", createInvoiceItemAdjContext);\n\t                        if (ServiceUtil.isError(createInvoiceItemAdjResult)) {\n\t                            return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingErrorCreatingInvoiceItemFromOrder\",locale), null, null, createInvoiceItemAdjResult);\n\t                        }\n\n                            // Create the OrderAdjustmentBilling record\n                            Map createOrderAdjustmentBillingContext = FastMap.newInstance();\n                            createOrderAdjustmentBillingContext.put(\"orderAdjustmentId\", adj.getString(\"orderAdjustmentId\"));\n                            createOrderAdjustmentBillingContext.put(\"invoiceId\", invoiceId);\n                            createOrderAdjustmentBillingContext.put(\"invoiceItemSeqId\", invoiceItemSeqId);\n                            createOrderAdjustmentBillingContext.put(\"amount\", new Double(amount.doubleValue()));\n                            createOrderAdjustmentBillingContext.put(\"userLogin\", userLogin);\n\n                            Map createOrderAdjustmentBillingResult = dispatcher.runSync(\"createOrderAdjustmentBilling\", createOrderAdjustmentBillingContext);\n                            if (ServiceUtil.isError(createOrderAdjustmentBillingResult)) {\n                                return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingErrorCreatingOrderAdjustmentBillingFromOrder\",locale), null, null, createOrderAdjustmentBillingContext);\n                            }\n\n\t                        // this adjustment amount\n\t                        BigDecimal thisAdjAmount = new BigDecimal(amount.doubleValue()).setScale(decimals, rounding);\n\t\n\t                        // adjustments only apply to totals when they are not tax or shipping adjustments\n\t                        if (!\"SALES_TAX\".equals(adj.getString(\"orderAdjustmentTypeId\")) &&\n\t                                !\"SHIPPING_ADJUSTMENT\".equals(adj.getString(\"orderAdjustmentTypeId\"))) {\n\t                            // increment the invoice subtotal\n\t                            invoiceSubTotal = invoiceSubTotal.add(thisAdjAmount).setScale(100, rounding);\n\t\n\t                            // add to the ship amount only if it applies to this item\n\t                            if (shippingApplies) {\n\t                                invoiceShipProRateAmount = invoiceShipProRateAmount.add(thisAdjAmount).setScale(decimals, rounding);\n\t                            }\n\t                        }\n\t\n\t                        // increment the counter\n\t                        invoiceItemSeqNum++;\n\t                        invoiceItemSeqId = UtilFormatOut.formatPaddedNumber(invoiceItemSeqNum, 2);\n                        }\n                    }\n                }\n            }\n\n            // create header adjustments as line items -- always to tax/shipping last\n            Map shipAdjustments = new HashMap();\n            Map taxAdjustments = new HashMap();\n\n            List headerAdjustments = orh.getOrderHeaderAdjustments();\n            Iterator headerAdjIter = headerAdjustments.iterator();\n            while (headerAdjIter.hasNext()) {\n                GenericValue adj = (GenericValue) headerAdjIter.next();\n\n                // Check against OrderAdjustmentBilling to see how much of this adjustment has already been invoiced\n                BigDecimal adjAlreadyInvoicedAmount = null;\n                try {\n                    Map checkResult = dispatcher.runSync(\"calculateInvoicedAdjustmentTotal\", UtilMisc.toMap(\"orderAdjustment\", adj));\n                    adjAlreadyInvoicedAmount = ((BigDecimal) checkResult.get(\"invoicedTotal\")).setScale(decimals, rounding);\n                } catch (GenericServiceException e) {\n                    String errMsg = UtilProperties.getMessage(resource, \"AccountingTroubleCallingCalculateInvoicedAdjustmentTotalService\", locale);\n                    Debug.logError(e, errMsg, module);\n                    return ServiceUtil.returnError(errMsg);\n                }\n\n                // If the absolute invoiced amount >= the abs of the adjustment amount, the full amount has already been invoiced,\n                //  so skip this adjustment\n                if (adjAlreadyInvoicedAmount.abs().compareTo(adj.getBigDecimal(\"amount\").setScale(decimals, rounding).abs()) > 0) {\n                    continue;\n                }\n\n                if (\"SHIPPING_CHARGES\".equals(adj.getString(\"orderAdjustmentTypeId\"))) {\n                    shipAdjustments.put(adj, adjAlreadyInvoicedAmount);\n                } else if (\"SALES_TAX\".equals(adj.getString(\"orderAdjustmentTypeId\"))) {\n                    taxAdjustments.put(adj, adjAlreadyInvoicedAmount);\n                } else {\n                    // these will effect the shipping pro-rate (unless commented)\n                    // other adjustment type\n                    BigDecimal adjAmount = calcHeaderAdj(delegator, adj, invoiceType, invoiceId, invoiceItemSeqId, \n                            orderSubTotal, invoiceSubTotal, adj.getBigDecimal(\"amount\").setScale(decimals, rounding), decimals, rounding, userLogin, dispatcher, locale);\n                    // invoiceShipProRateAmount += adjAmount;\n                    // do adjustments compound or are they based off subtotal? Here we will (unless commented)\n                    // invoiceSubTotal += adjAmount;\n\n                    // increment the counter\n                    invoiceItemSeqNum++;\n                    invoiceItemSeqId = UtilFormatOut.formatPaddedNumber(invoiceItemSeqNum, 2);\n                }\n            }\n\n            // next do the shipping adjustments.  Note that we do not want to add these to the invoiceSubTotal or orderSubTotal for pro-rating tax later, as that would cause\n            // numerator/denominator problems when the shipping is not pro-rated but rather charged all on the first invoice\n            Iterator shipAdjIter = shipAdjustments.keySet().iterator();\n            while (shipAdjIter.hasNext()) {\n                GenericValue adj = (GenericValue) shipAdjIter.next();\n                BigDecimal adjAlreadyInvoicedAmount = (BigDecimal) shipAdjustments.get(adj);\n                \n                if (\"N\".equalsIgnoreCase(prorateShipping)) {\n\n                    // Set the divisor and multiplier to 1 to avoid prorating\n                    BigDecimal divisor = new BigDecimal(\"1\");\n                    BigDecimal multiplier = new BigDecimal(\"1\");\n                    \n                    // The base amount in this case is the adjustment amount minus the total already invoiced for that adjustment, since\n                    //  it won't be prorated\n                    BigDecimal baseAmount = adj.getBigDecimal(\"amount\").setScale(decimals, rounding).subtract(adjAlreadyInvoicedAmount);\n                    BigDecimal adjAmount = calcHeaderAdj(delegator, adj, invoiceType, invoiceId, invoiceItemSeqId, \n                            divisor, multiplier, baseAmount, decimals, rounding, userLogin, dispatcher, locale);\n                } else {\n\n                    // Pro-rate the shipping amount based on shippable information\n                    BigDecimal divisor = shippableAmount;\n                    BigDecimal multiplier = invoiceShipProRateAmount;\n                    \n                    // The base amount in this case is the adjustment amount, since we want to prorate based on the full amount\n                    BigDecimal baseAmount = adj.getBigDecimal(\"amount\").setScale(decimals, rounding);\n                    BigDecimal adjAmount = calcHeaderAdj(delegator, adj, invoiceType, invoiceId, invoiceItemSeqId, \n                            divisor, multiplier, baseAmount, decimals, rounding, userLogin, dispatcher, locale);\n                }\n\n                // Increment the counter\n                invoiceItemSeqNum++;\n                invoiceItemSeqId = UtilFormatOut.formatPaddedNumber(invoiceItemSeqNum, 2);\n            }\n\n            // last do the tax adjustments\n            String prorateTaxes = productStore.getString(\"prorateTaxes\");\n            if (prorateTaxes == null) {\n                prorateTaxes = \"Y\";\n            }            \n            Iterator taxAdjIter = taxAdjustments.keySet().iterator();\n            while (taxAdjIter.hasNext()) {\n                GenericValue adj = (GenericValue) taxAdjIter.next();\n                BigDecimal adjAlreadyInvoicedAmount = (BigDecimal) taxAdjustments.get(adj);\n                BigDecimal adjAmount = null;\n                \n                if (\"N\".equalsIgnoreCase(prorateTaxes)) {\n\n                    // Set the divisor and multiplier to 1 to avoid prorating\n                    BigDecimal divisor = new BigDecimal(\"1\");\n                    BigDecimal multiplier = new BigDecimal(\"1\");\n                    \n                    // The base amount in this case is the adjustment amount minus the total already invoiced for that adjustment, since\n                    //  it won't be prorated\n                    //  Note this should use invoice decimals & rounding instead of taxDecimals and taxRounding for tax adjustments, because it will be added to the invoice \n                    BigDecimal baseAmount = adj.getBigDecimal(\"amount\").setScale(decimals, rounding).subtract(adjAlreadyInvoicedAmount);\n                    adjAmount = calcHeaderAdj(delegator, adj, invoiceType, invoiceId, invoiceItemSeqId, \n                             divisor, multiplier, baseAmount, decimals, rounding, userLogin, dispatcher, locale);\n                } else {\n\n                    // Pro-rate the tax amount based on shippable information\n                    BigDecimal divisor = orderSubTotal;\n                    BigDecimal multiplier = invoiceSubTotal;\n                    \n                    // The base amount in this case is the adjustment amount, since we want to prorate based on the full amount\n                    //  Note this should use invoice decimals & rounding instead of taxDecimals and taxRounding for tax adjustments, because it will be added to the invoice \n                    BigDecimal baseAmount = adj.getBigDecimal(\"amount\").setScale(decimals, rounding);\n                    adjAmount = calcHeaderAdj(delegator, adj, invoiceType, invoiceId, invoiceItemSeqId, \n                            divisor, multiplier, baseAmount, decimals, rounding, userLogin, dispatcher, locale);\n                }\n                invoiceSubTotal = invoiceSubTotal.add(adjAmount).setScale(decimals, rounding);                \n\n                // Increment the counter\n                invoiceItemSeqNum++;\n                invoiceItemSeqId = UtilFormatOut.formatPaddedNumber(invoiceItemSeqNum, 2);\n            }\n\n            // check for previous order payments\n            List orderPaymentPrefs = delegator.findByAnd(\"OrderPaymentPreference\", UtilMisc.toMap(\"orderId\", orderId));\n            if (orderPaymentPrefs != null) {\n                List currentPayments = new ArrayList();\n                Iterator opi = orderPaymentPrefs.iterator();\n                while (opi.hasNext()) {\n                    GenericValue paymentPref = (GenericValue) opi.next();\n                    List payments = paymentPref.getRelated(\"Payment\");\n                    currentPayments.addAll(payments);\n                }\n                if (currentPayments.size() > 0) {\n                    // apply these payments to the invoice; only if they haven't already been applied\n                    Iterator cpi = currentPayments.iterator();\n                    while (cpi.hasNext()) {\n                        GenericValue payment = (GenericValue) cpi.next();\n                        List currentApplications = null;\n                        currentApplications = payment.getRelated(\"PaymentApplication\");\n                        if (currentApplications == null || currentApplications.size() == 0) {\n                            // no applications; okay to apply\n                            Map appl = new HashMap();\n                            appl.put(\"paymentId\", payment.get(\"paymentId\"));\n                            appl.put(\"invoiceId\", invoiceId);\n                            appl.put(\"billingAccountId\", billingAccountId);\n                            appl.put(\"amountApplied\", payment.get(\"amount\"));\n                            appl.put(\"userLogin\", userLogin);\n                            Map createPayApplResult = dispatcher.runSync(\"createPaymentApplication\", appl); \n                            if (ServiceUtil.isError(createPayApplResult)) {\n                                return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingErrorCreatingInvoiceFromOrder\",locale), null, null, createPayApplResult);\n                            }\n                        }\n                    }\n                }\n            }\n\n            // Should all be in place now. Depending on the ProductStore.autoApproveInvoice setting, set status to INVOICE_READY (unless it's a purchase \n            //  invoice, which we set to INVOICE_IN_PROCESS) \n            boolean autoApproveInvoice = UtilValidate.isEmpty(productStore.get(\"autoApproveInvoice\")) || \"Y\".equals(productStore.getString(\"autoApproveInvoice\"));\n            if(autoApproveInvoice) {\n                String nextStatusId = \"INVOICE_READY\";\n                if (invoiceType.equals(\"PURCHASE_INVOICE\")) {\n                    nextStatusId = \"INVOICE_IN_PROCESS\";\n                }\n                Map setInvoiceStatusResult = dispatcher.runSync(\"setInvoiceStatus\", UtilMisc.toMap(\"invoiceId\", invoiceId, \"statusId\", nextStatusId, \"userLogin\", userLogin));\n                if (ServiceUtil.isError(setInvoiceStatusResult)) {\n                    return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingErrorCreatingInvoiceFromOrder\",locale), null, null, setInvoiceStatusResult);\n                }\n            }\n\n            // check to see if we are all paid up\n            Map checkResp = dispatcher.runSync(\"checkInvoicePaymentApplications\", UtilMisc.toMap(\"invoiceId\", invoiceId, \"userLogin\", userLogin));\n            if (ServiceUtil.isError(checkResp)) {\n                return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingErrorCreatingInvoiceFromOrderCheckPaymentAppl\",locale), null, null, checkResp);\n            }\n\n            Map resp = ServiceUtil.returnSuccess();\n            resp.put(\"invoiceId\", invoiceId);\n            return resp;\n        } catch (GenericEntityException e) {\n            String errMsg = UtilProperties.getMessage(resource,\"AccountingEntityDataProblemCreatingInvoiceFromOrderItems\",UtilMisc.toMap(\"reason\",e.toString()),locale);\n            Debug.logError(e, errMsg, module);\n            return ServiceUtil.returnError(errMsg);\n        } catch (GenericServiceException e) {\n            String errMsg = UtilProperties.getMessage(resource,\"AccountingServiceOtherProblemCreatingInvoiceFromOrderItems\",UtilMisc.toMap(\"reason\",e.toString()),locale);\n            Debug.logError(e, errMsg, module);\n            return ServiceUtil.returnError(errMsg);\n        }\n    }","id":99824,"modified_method":"public static Map createInvoiceForOrder(DispatchContext dctx, Map context) {\n        GenericDelegator delegator = dctx.getDelegator();\n        LocalDispatcher dispatcher = dctx.getDispatcher();\n        GenericValue userLogin = (GenericValue) context.get(\"userLogin\");\n        Locale locale = (Locale) context.get(\"locale\");\n\n        if (decimals == -1 || rounding == -1) {\n            return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingAritmeticPropertiesNotConfigured\",locale));\n        }\n\n        String orderId = (String) context.get(\"orderId\");\n        List billItems = (List) context.get(\"billItems\");\n        boolean previousInvoiceFound = false;\n\n        if (billItems == null || billItems.size() == 0) {\n            Debug.logVerbose(\"No order items to invoice; not creating invoice; returning success\", module);\n            return ServiceUtil.returnSuccess(UtilProperties.getMessage(resource,\"AccountingNoOrderItemsToInvoice\",locale));\n        }\n\n        try {\n            GenericValue orderHeader = delegator.findByPrimaryKey(\"OrderHeader\", UtilMisc.toMap(\"orderId\", orderId));\n            if (orderHeader == null) {\n                return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingNoOrderHeader\",locale));\n            }\n\n            // get list of previous invoices for the order\n            List billedItems = delegator.findByAnd(\"OrderItemBilling\", UtilMisc.toMap(\"orderId\", orderId));\n            if (billedItems != null && billedItems.size() > 0) {\n                boolean nonDigitalInvoice = false;\n                Iterator bii = billedItems.iterator();\n                while (bii.hasNext() && !nonDigitalInvoice) {\n                    GenericValue orderItemBilling = (GenericValue) bii.next();\n                    GenericValue invoiceItem = orderItemBilling.getRelatedOne(\"InvoiceItem\");\n                    if (invoiceItem != null) {\n                        String invoiceItemType = invoiceItem.getString(\"invoiceItemTypeId\");\n                        if (invoiceItemType != null) {\n                            if (\"INV_FPROD_ITEM\".equals(invoiceItemType) || \"INV_PROD_FEATR_ITEM\".equals(invoiceItemType)) {\n                                nonDigitalInvoice = true;\n                            }\n                        }\n                    }\n                }\n                if (nonDigitalInvoice) {\n                    previousInvoiceFound = true;\n                }\n            }\n\n            // figure out the invoice type\n            String invoiceType = null;\n\n            String orderType = orderHeader.getString(\"orderTypeId\");\n            if (orderType.equals(\"SALES_ORDER\")) {\n                invoiceType = \"SALES_INVOICE\";\n            } else if (orderType.equals(\"PURCHASE_ORDER\")) {\n                invoiceType = \"PURCHASE_INVOICE\";\n            }\n\n            // Make an order read helper from the order\n            OrderReadHelper orh = new OrderReadHelper(orderHeader);\n\n            // get the product store\n            GenericValue productStore = delegator.findByPrimaryKey(\"ProductStore\", UtilMisc.toMap(\"productStoreId\", orh.getProductStoreId()));\n\n            // get the shipping adjustment mode (Y = Pro-Rate; N = First-Invoice)\n            String prorateShipping = productStore.getString(\"prorateShipping\");\n            if (prorateShipping == null) {\n                prorateShipping = \"Y\";\n            }\n\n            // get the billing parties\n            String billToCustomerPartyId = orh.getBillToParty().getString(\"partyId\");\n            String billFromVendorPartyId = orh.getBillFromParty().getString(\"partyId\");\n\n            // get some quantity totals\n            BigDecimal totalItemsInOrder = orh.getTotalOrderItemsQuantityBd();\n\n            // get some price totals\n            BigDecimal shippableAmount = orh.getShippableTotalBd(null);\n            BigDecimal orderSubTotal = orh.getOrderItemsSubTotalBd();\n\n            // these variables are for pro-rating order amounts across invoices, so they should not be rounded off for maximum accuracy\n            BigDecimal invoiceShipProRateAmount = ZERO;\n            BigDecimal invoiceSubTotal = ZERO;\n            BigDecimal invoiceQuantity = ZERO;\n\n            GenericValue billingAccount = orderHeader.getRelatedOne(\"BillingAccount\");\n            String billingAccountId = billingAccount != null ? billingAccount.getString(\"billingAccountId\") : null;\n\n            // TODO: ideally this should be the same time as when a shipment is sent and be passed in as a parameter \n            Timestamp invoiceDate = UtilDateTime.nowTimestamp();\n            // TODO: perhaps consider billing account net days term as well?\n            Long orderTermNetDays = orh.getOrderTermNetDays();\n            Timestamp dueDate = null;\n            if (orderTermNetDays != null) {\n                dueDate = UtilDateTime.getDayEnd(invoiceDate, orderTermNetDays.intValue());\n            }\n            \n            // create the invoice record\n            Map createInvoiceContext = FastMap.newInstance();\n            createInvoiceContext.put(\"partyId\", billToCustomerPartyId);\n            createInvoiceContext.put(\"partyIdFrom\", billFromVendorPartyId);\n            createInvoiceContext.put(\"billingAccountId\", billingAccountId);\n            createInvoiceContext.put(\"invoiceDate\", invoiceDate);\n            createInvoiceContext.put(\"dueDate\", dueDate);\n            createInvoiceContext.put(\"invoiceTypeId\", invoiceType);\n            // start with INVOICE_IN_PROCESS, in the INVOICE_READY we can't change the invoice (or shouldn't be able to...)\n            createInvoiceContext.put(\"statusId\", \"INVOICE_IN_PROCESS\");\n            createInvoiceContext.put(\"currencyUomId\", orderHeader.getString(\"currencyUom\"));\n            createInvoiceContext.put(\"userLogin\", userLogin);\n\n            // store the invoice first\n            Map createInvoiceResult = dispatcher.runSync(\"createInvoice\", createInvoiceContext);\n            if (ServiceUtil.isError(createInvoiceResult)) {\n                return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingErrorCreatingInvoiceFromOrder\",locale), null, null, createInvoiceResult);\n            }\n            \n            // call service, not direct entity op: delegator.create(invoice);\n            String invoiceId = (String) createInvoiceResult.get(\"invoiceId\");\n\n            // order roles to invoice roles\n            List orderRoles = orderHeader.getRelated(\"OrderRole\");\n            if (orderRoles != null) {\n                Iterator orderRolesIt = orderRoles.iterator();\n                Map createInvoiceRoleContext = FastMap.newInstance();\n                createInvoiceRoleContext.put(\"invoiceId\", invoiceId);\n                createInvoiceRoleContext.put(\"userLogin\", userLogin);\n                while (orderRolesIt.hasNext()) {\n                    GenericValue orderRole = (GenericValue)orderRolesIt.next();\n                    createInvoiceRoleContext.put(\"partyId\", orderRole.getString(\"partyId\"));\n                    createInvoiceRoleContext.put(\"roleTypeId\", orderRole.getString(\"roleTypeId\"));\n                    Map createInvoiceRoleResult = dispatcher.runSync(\"createInvoiceRole\", createInvoiceRoleContext);\n                    if (ServiceUtil.isError(createInvoiceRoleResult)) {\n                        return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingErrorCreatingInvoiceFromOrder\",locale), null, null, createInvoiceRoleResult);\n                    }\n                }\n            }\n\n            // order terms to invoice terms.  Implemented for purchase orders, although it may be useful\n            // for sales orders as well.  Later it might be nice to filter OrderTerms to only copy over financial terms.\n            List orderTerms = orh.getOrderTerms();\n            createInvoiceTerms(delegator, dispatcher, invoiceId, orderTerms, userLogin, locale);\n\n            // billing accounts\n            List billingAccountTerms = null;\n            // for billing accounts we will use related information\n            if (billingAccount != null) {\n                // get the billing account terms\n                billingAccountTerms = billingAccount.getRelated(\"BillingAccountTerm\");\n\n                // set the invoice terms as defined for the billing account\n                createInvoiceTerms(delegator, dispatcher, invoiceId, billingAccountTerms, userLogin, locale);\n\n                // set the invoice bill_to_customer from the billing account\n                List billToRoles = billingAccount.getRelated(\"BillingAccountRole\", UtilMisc.toMap(\"roleTypeId\", \"BILL_TO_CUSTOMER\"), null);\n                Iterator billToIter = billToRoles.iterator();\n                while (billToIter.hasNext()) {\n                    GenericValue billToRole = (GenericValue) billToIter.next();\n                    if (!(billToRole.getString(\"partyId\").equals(billToCustomerPartyId))) {\n                        Map createInvoiceRoleContext = UtilMisc.toMap(\"invoiceId\", invoiceId, \"partyId\", billToRole.get(\"partyId\"), \n                                                                           \"roleTypeId\", \"BILL_TO_CUSTOMER\", \"userLogin\", userLogin);\n                        Map createInvoiceRoleResult = dispatcher.runSync(\"createInvoiceRole\", createInvoiceRoleContext);\n                        if (ServiceUtil.isError(createInvoiceRoleResult)) {\n                            return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingErrorCreatingInvoiceRoleFromOrder\",locale), null, null, createInvoiceRoleResult);\n                        }\n                    }\n                }\n\n                // set the bill-to contact mech as the contact mech of the billing account\n                if (UtilValidate.isNotEmpty(billingAccount.getString(\"contactMechId\"))) {\n                    Map createBillToContactMechContext = UtilMisc.toMap(\"invoiceId\", invoiceId, \"contactMechId\", billingAccount.getString(\"contactMechId\"), \n                                                                       \"contactMechPurposeTypeId\", \"BILLING_LOCATION\", \"userLogin\", userLogin);\n                    Map createBillToContactMechResult = dispatcher.runSync(\"createInvoiceContactMech\", createBillToContactMechContext);\n                    if (ServiceUtil.isError(createBillToContactMechResult)) {\n                        return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingErrorCreatingInvoiceContactMechFromOrder\",locale), null, null, createBillToContactMechResult);\n                    }\n                }\n            } else {\n                List billingLocations = orh.getBillingLocations();\n                if (billingLocations != null) {\n                    Iterator bli = billingLocations.iterator();\n                    while (bli.hasNext()) {\n                        GenericValue ocm = (GenericValue) bli.next();\n                        Map createBillToContactMechContext = UtilMisc.toMap(\"invoiceId\", invoiceId, \"contactMechId\", ocm.getString(\"contactMechId\"), \n                                                                           \"contactMechPurposeTypeId\", \"BILLING_LOCATION\", \"userLogin\", userLogin);\n                        Map createBillToContactMechResult = dispatcher.runSync(\"createInvoiceContactMech\", createBillToContactMechContext);\n                        if (ServiceUtil.isError(createBillToContactMechResult)) {\n                            return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingErrorCreatingInvoiceContactMechFromOrder\",locale), null, null, createBillToContactMechResult);\n                        }\n                    }\n                }\n            }\n\n            // get a list of the payment method types\n            //DEJ20050705 doesn't appear to be used: List paymentPreferences = orderHeader.getRelated(\"OrderPaymentPreference\");\n\n            // create the bill-from (or pay-to) contact mech as the primary PAYMENT_LOCATION of the party from the store\n            GenericValue payToAddress = null;\n            if (invoiceType.equals(\"PURCHASE_INVOICE\")) {\n                // for purchase orders, the pay to address is the BILLING_LOCATION of the vendor\n                GenericValue billFromVendor = orh.getPartyFromRole(\"BILL_FROM_VENDOR\");\n                if (billFromVendor != null) {\n                    List billingContactMechs = billFromVendor.getRelatedOne(\"Party\").getRelatedByAnd(\"PartyContactMechPurpose\",\n                            UtilMisc.toMap(\"contactMechPurposeTypeId\", \"BILLING_LOCATION\"));\n                    if ((billingContactMechs != null) && (billingContactMechs.size() > 0)) {\n                        payToAddress = (GenericValue) billingContactMechs.get(0);\n                    }\n                }\n            } else {\n                // for sales orders, it is the payment address on file for the store\n                payToAddress = PaymentWorker.getPaymentAddress(delegator, productStore.getString(\"payToPartyId\"));\n            }\n            if (payToAddress != null) {\n                Map createPayToContactMechContext = UtilMisc.toMap(\"invoiceId\", invoiceId, \"contactMechId\", payToAddress.getString(\"contactMechId\"), \n                                                                   \"contactMechPurposeTypeId\", \"PAYMENT_LOCATION\", \"userLogin\", userLogin);\n                Map createPayToContactMechResult = dispatcher.runSync(\"createInvoiceContactMech\", createPayToContactMechContext);\n                if (ServiceUtil.isError(createPayToContactMechResult)) {\n                    return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingErrorCreatingInvoiceContactMechFromOrder\",locale), null, null, createPayToContactMechResult);\n                }\n            }\n\n            // sequence for items - all OrderItems or InventoryReservations + all Adjustments\n            int invoiceItemSeqNum = 1;\n            String invoiceItemSeqId = UtilFormatOut.formatPaddedNumber(invoiceItemSeqNum, 2);\n\n            // create the item records\n            if (billItems != null) {\n                Iterator itemIter = billItems.iterator();\n                while (itemIter.hasNext()) {\n                    GenericValue itemIssuance = null;\n                    GenericValue orderItem = null;\n                    GenericValue shipmentReceipt = null;\n                    GenericValue currentValue = (GenericValue) itemIter.next();\n                    if (\"ItemIssuance\".equals(currentValue.getEntityName())) {\n                        itemIssuance = currentValue;\n                    } else if (\"OrderItem\".equals(currentValue.getEntityName())) {\n                        orderItem = currentValue;\n                    } else if (\"ShipmentReceipt\".equals(currentValue.getEntityName())) {\n                        shipmentReceipt = currentValue;\n                    } else {\n                        Debug.logError(\"Unexpected entity \" + currentValue + \" of type \" + currentValue.getEntityName(), module);\n                    }\n\n                    if (orderItem == null && itemIssuance != null) {\n                        orderItem = itemIssuance.getRelatedOne(\"OrderItem\");\n                    } else if ((orderItem == null) && (shipmentReceipt != null)) {\n                        orderItem = shipmentReceipt.getRelatedOne(\"OrderItem\");\n                    } else if ((orderItem == null) && (itemIssuance == null) && (shipmentReceipt == null)) {\n                        Debug.logError(\"Cannot create invoice when orderItem, itemIssuance, and shipmentReceipt are all null\", module);\n                        return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingIllegalValuesPassedToCreateInvoiceService\",locale));\n                    }\n                    GenericValue product = null;\n                    if (orderItem.get(\"productId\") != null) {\n                        product = orderItem.getRelatedOne(\"Product\");\n                    }\n\n                    // get some quantities\n                    BigDecimal orderedQuantity = orderItem.getBigDecimal(\"quantity\");\n                    BigDecimal billingQuantity = null;\n                    if (itemIssuance != null) {\n                        billingQuantity = itemIssuance.getBigDecimal(\"quantity\");\n                    } else if (shipmentReceipt != null) {\n                        billingQuantity = shipmentReceipt.getBigDecimal(\"quantityAccepted\");\n                    } else {\n                        billingQuantity = orderedQuantity;\n                    }\n                    if (orderedQuantity == null) orderedQuantity = ZERO;\n                    if (billingQuantity == null) billingQuantity = ZERO;\n\n                    // check if shipping applies to this item.  Shipping is calculated for sales invoices, not purchase invoices.\n                    boolean shippingApplies = false;\n                    if ((product != null) && (ProductWorker.shippingApplies(product)) && (invoiceType.equals(\"SALES_INVOICE\"))) {\n                        shippingApplies = true;\n                    }\n\n                    BigDecimal billingAmount = orderItem.getBigDecimal(\"unitPrice\").setScale(decimals, rounding);\n                    \n                    Map createInvoiceItemContext = FastMap.newInstance();\n                    createInvoiceItemContext.put(\"invoiceId\", invoiceId);\n                    createInvoiceItemContext.put(\"invoiceItemSeqId\", invoiceItemSeqId);\n                    createInvoiceItemContext.put(\"invoiceItemTypeId\", getInvoiceItemType(delegator, (orderItem == null ? null : orderItem.getString(\"orderItemTypeId\")), (product == null ? null : product.getString(\"productTypeId\")), invoiceType, \"INV_FPROD_ITEM\"));\n                    createInvoiceItemContext.put(\"description\", orderItem.get(\"itemDescription\"));\n                    createInvoiceItemContext.put(\"quantity\", new Double(billingQuantity.doubleValue()));\n                    createInvoiceItemContext.put(\"amount\", new Double(billingAmount.doubleValue()));\n                    createInvoiceItemContext.put(\"productId\", orderItem.get(\"productId\"));\n                    createInvoiceItemContext.put(\"productFeatureId\", orderItem.get(\"productFeatureId\"));\n                    createInvoiceItemContext.put(\"overrideGlAccountId\", orderItem.get(\"overrideGlAccountId\"));\n                    //createInvoiceItemContext.put(\"uomId\", \"\");\n                    createInvoiceItemContext.put(\"userLogin\", userLogin);\n\n                    String itemIssuanceId = null;\n                    if (itemIssuance != null && itemIssuance.get(\"inventoryItemId\") != null) {\n                        itemIssuanceId = itemIssuance.getString(\"itemIssuanceId\");\n                        createInvoiceItemContext.put(\"inventoryItemId\", itemIssuance.get(\"inventoryItemId\"));\n                    }\n                    // similarly, tax only for purchase invoices\n                    if ((product != null) && (invoiceType.equals(\"SALES_INVOICE\"))) {\n                        createInvoiceItemContext.put(\"taxableFlag\", product.get(\"taxable\"));\n                    }\n\n                    Map createInvoiceItemResult = dispatcher.runSync(\"createInvoiceItem\", createInvoiceItemContext);\n                    if (ServiceUtil.isError(createInvoiceItemResult)) {\n                        return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingErrorCreatingInvoiceItemFromOrder\",locale), null, null, createInvoiceItemResult);\n                    }\n\n                    // this item total\n                    BigDecimal thisAmount = billingAmount.multiply(billingQuantity).setScale(decimals, rounding);\n\n                    // add to the ship amount only if it applies to this item\n                    if (shippingApplies) {\n                        invoiceShipProRateAmount = invoiceShipProRateAmount.add(thisAmount).setScale(decimals, rounding);\n                    }\n\n                    // increment the invoice subtotal\n                    invoiceSubTotal = invoiceSubTotal.add(thisAmount).setScale(100, rounding);\n\n                    // increment the invoice quantity\n                    invoiceQuantity = invoiceQuantity.add(billingQuantity).setScale(decimals, rounding);\n\n                    // create the OrderItemBilling record\n                    Map createOrderItemBillingContext = FastMap.newInstance();\n                    createOrderItemBillingContext.put(\"invoiceId\", invoiceId);\n                    createOrderItemBillingContext.put(\"invoiceItemSeqId\", invoiceItemSeqId);\n                    createOrderItemBillingContext.put(\"orderId\", orderItem.get(\"orderId\"));\n                    createOrderItemBillingContext.put(\"orderItemSeqId\", orderItem.get(\"orderItemSeqId\"));\n                    createOrderItemBillingContext.put(\"itemIssuanceId\", itemIssuanceId);\n                    createOrderItemBillingContext.put(\"quantity\", new Double(billingQuantity.doubleValue()));\n                    createOrderItemBillingContext.put(\"amount\", new Double(billingAmount.doubleValue()));\n                    createOrderItemBillingContext.put(\"userLogin\", userLogin);\n                    if ((shipmentReceipt != null) && (shipmentReceipt.getString(\"receiptId\") != null)) {\n                        createOrderItemBillingContext.put(\"shipmentReceiptId\", shipmentReceipt.getString(\"receiptId\"));\n                    }\n\n                    Map createOrderItemBillingResult = dispatcher.runSync(\"createOrderItemBilling\", createOrderItemBillingContext);\n                    if (ServiceUtil.isError(createOrderItemBillingResult)) {\n                        return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingErrorCreatingOrderItemBillingFromOrder\",locale), null, null, createOrderItemBillingResult);\n                    }\n\n                    String parentInvoiceItemSeqId = invoiceItemSeqId;\n                    // increment the counter\n                    invoiceItemSeqNum++;\n                    invoiceItemSeqId = UtilFormatOut.formatPaddedNumber(invoiceItemSeqNum, 2);\n\n                    // Get the original order item from the DB, in case the quantity has been overridden\n                    GenericValue originalOrderItem = delegator.findByPrimaryKey(\"OrderItem\", UtilMisc.toMap(\"orderId\", orderId, \"orderItemSeqId\", orderItem.getString(\"orderItemSeqId\")));\n\n                    // create the item adjustment as line items\n                    List itemAdjustments = OrderReadHelper.getOrderItemAdjustmentList(orderItem, orh.getAdjustments());\n                    Iterator itemAdjIter = itemAdjustments.iterator();\n                    while (itemAdjIter.hasNext()) {\n                        GenericValue adj = (GenericValue) itemAdjIter.next();\n                        \n                        // Check against OrderAdjustmentBilling to see how much of this adjustment has already been invoiced\n                        BigDecimal adjAlreadyInvoicedAmount = null;\n                        try {\n                            Map checkResult = dispatcher.runSync(\"calculateInvoicedAdjustmentTotal\", UtilMisc.toMap(\"orderAdjustment\", adj));\n                            adjAlreadyInvoicedAmount = (BigDecimal) checkResult.get(\"invoicedTotal\");\n                        } catch (GenericServiceException e) {\n                            String errMsg = UtilProperties.getMessage(resource, \"AccountingTroubleCallingCalculateInvoicedAdjustmentTotalService\", locale);\n                            Debug.logError(e, errMsg, module);\n                            return ServiceUtil.returnError(errMsg);\n                        }\n        \n                        // If the absolute invoiced amount >= the abs of the adjustment amount, the full amount has already been invoiced,\n                        //  so skip this adjustment\n                        if (null == adj.get(\"amount\")) { // JLR 17/4/7 : fix a bug coming from POS in case of use of a discount (on item(s) or sale, item(s) here) and a cash amount higher than total (hence issuing change)\n                            continue;\n                        }                        \n                        if (adjAlreadyInvoicedAmount.abs().compareTo(adj.getBigDecimal(\"amount\").setScale(decimals, rounding).abs()) > 0) {\n                            continue;\n                        }\n        \n                        BigDecimal amount = ZERO;\n                        if (adj.get(\"amount\") != null) { \n                            // pro-rate the amount\n                            // set decimals = 100 means we don't round this intermediate value, which is very important\n                            amount = adj.getBigDecimal(\"amount\").divide(originalOrderItem.getBigDecimal(\"quantity\"), 100, rounding);\n                            amount = amount.multiply(billingQuantity);\n                            amount = amount.setScale(decimals, rounding);\n                        }\n                        else if (adj.get(\"sourcePercentage\") != null) { \n                            // pro-rate the amount\n                            // set decimals = 100 means we don't round this intermediate value, which is very important\n                            BigDecimal percent = adj.getBigDecimal(\"sourcePercentage\");\n                            percent = percent.divide(new BigDecimal(100), 100, rounding);\n                            amount = billingAmount.multiply(percent); \n                            amount = amount.divide(originalOrderItem.getBigDecimal(\"quantity\"), 100, rounding);\n                            amount = amount.multiply(billingQuantity);\n                            amount = amount.setScale(decimals, rounding);\n                        }\n                        if (amount.signum() != 0) {                      \n                            Map createInvoiceItemAdjContext = FastMap.newInstance();\n                            createInvoiceItemAdjContext.put(\"invoiceId\", invoiceId);\n                            createInvoiceItemAdjContext.put(\"invoiceItemSeqId\", invoiceItemSeqId);\n                            createInvoiceItemAdjContext.put(\"invoiceItemTypeId\", getInvoiceItemType(delegator, adj.getString(\"orderAdjustmentTypeId\"), null, invoiceType, \"INVOICE_ITM_ADJ\"));\n                            createInvoiceItemAdjContext.put(\"description\", adj.get(\"description\"));\n                            createInvoiceItemAdjContext.put(\"quantity\", new Double(1));\n                            createInvoiceItemAdjContext.put(\"amount\", new Double(amount.doubleValue()));\n                            createInvoiceItemAdjContext.put(\"productId\", orderItem.get(\"productId\"));\n                            createInvoiceItemAdjContext.put(\"productFeatureId\", orderItem.get(\"productFeatureId\"));\n                            createInvoiceItemAdjContext.put(\"overrideGlAccountId\", adj.get(\"overrideGlAccountId\"));\n                            createInvoiceItemAdjContext.put(\"parentInvoiceId\", invoiceId);\n                            createInvoiceItemAdjContext.put(\"parentInvoiceItemSeqId\", parentInvoiceItemSeqId);\n                            //createInvoiceItemAdjContext.put(\"uomId\", \"\");\n                            createInvoiceItemAdjContext.put(\"userLogin\", userLogin);\n                            createInvoiceItemAdjContext.put(\"taxAuthPartyId\", adj.get(\"taxAuthPartyId\"));\n                            createInvoiceItemAdjContext.put(\"taxAuthGeoId\", adj.get(\"taxAuthGeoId\"));\n                            createInvoiceItemAdjContext.put(\"taxAuthorityRateSeqId\", adj.get(\"taxAuthorityRateSeqId\"));\n        \n                            // invoice items for sales tax are not taxable themselves\n                            // TODO: This is not an ideal solution. Instead, we need to use OrderAdjustment.includeInTax when it is implemented\n                            if (!(adj.getString(\"orderAdjustmentTypeId\").equals(\"SALES_TAX\"))) {\n                                createInvoiceItemAdjContext.put(\"taxableFlag\", product.get(\"taxable\"));    \n                            }\n        \n                            Map createInvoiceItemAdjResult = dispatcher.runSync(\"createInvoiceItem\", createInvoiceItemAdjContext);\n                            if (ServiceUtil.isError(createInvoiceItemAdjResult)) {\n                                return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingErrorCreatingInvoiceItemFromOrder\",locale), null, null, createInvoiceItemAdjResult);\n                            }\n\n                            // Create the OrderAdjustmentBilling record\n                            Map createOrderAdjustmentBillingContext = FastMap.newInstance();\n                            createOrderAdjustmentBillingContext.put(\"orderAdjustmentId\", adj.getString(\"orderAdjustmentId\"));\n                            createOrderAdjustmentBillingContext.put(\"invoiceId\", invoiceId);\n                            createOrderAdjustmentBillingContext.put(\"invoiceItemSeqId\", invoiceItemSeqId);\n                            createOrderAdjustmentBillingContext.put(\"amount\", new Double(amount.doubleValue()));\n                            createOrderAdjustmentBillingContext.put(\"userLogin\", userLogin);\n\n                            Map createOrderAdjustmentBillingResult = dispatcher.runSync(\"createOrderAdjustmentBilling\", createOrderAdjustmentBillingContext);\n                            if (ServiceUtil.isError(createOrderAdjustmentBillingResult)) {\n                                return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingErrorCreatingOrderAdjustmentBillingFromOrder\",locale), null, null, createOrderAdjustmentBillingContext);\n                            }\n\n                            // this adjustment amount\n                            BigDecimal thisAdjAmount = new BigDecimal(amount.doubleValue()).setScale(decimals, rounding);\n    \n                            // adjustments only apply to totals when they are not tax or shipping adjustments\n                            if (!\"SALES_TAX\".equals(adj.getString(\"orderAdjustmentTypeId\")) &&\n                                    !\"SHIPPING_ADJUSTMENT\".equals(adj.getString(\"orderAdjustmentTypeId\"))) {\n                                // increment the invoice subtotal\n                                invoiceSubTotal = invoiceSubTotal.add(thisAdjAmount).setScale(100, rounding);\n    \n                                // add to the ship amount only if it applies to this item\n                                if (shippingApplies) {\n                                    invoiceShipProRateAmount = invoiceShipProRateAmount.add(thisAdjAmount).setScale(decimals, rounding);\n                                }\n                            }\n    \n                            // increment the counter\n                            invoiceItemSeqNum++;\n                            invoiceItemSeqId = UtilFormatOut.formatPaddedNumber(invoiceItemSeqNum, 2);\n                        }\n                    }\n                }\n            }\n\n            // create header adjustments as line items -- always to tax/shipping last\n            Map shipAdjustments = new HashMap();\n            Map taxAdjustments = new HashMap();\n\n            List headerAdjustments = orh.getOrderHeaderAdjustments();\n            Iterator headerAdjIter = headerAdjustments.iterator();\n            while (headerAdjIter.hasNext()) {\n                GenericValue adj = (GenericValue) headerAdjIter.next();\n\n                // Check against OrderAdjustmentBilling to see how much of this adjustment has already been invoiced\n                BigDecimal adjAlreadyInvoicedAmount = null;\n                try {\n                    Map checkResult = dispatcher.runSync(\"calculateInvoicedAdjustmentTotal\", UtilMisc.toMap(\"orderAdjustment\", adj));\n                    adjAlreadyInvoicedAmount = ((BigDecimal) checkResult.get(\"invoicedTotal\")).setScale(decimals, rounding);\n                } catch (GenericServiceException e) {\n                    String errMsg = UtilProperties.getMessage(resource, \"AccountingTroubleCallingCalculateInvoicedAdjustmentTotalService\", locale);\n                    Debug.logError(e, errMsg, module);\n                    return ServiceUtil.returnError(errMsg);\n                }\n\n                // If the absolute invoiced amount >= the abs of the adjustment amount, the full amount has already been invoiced,\n                //  so skip this adjustment\n                if (null == adj.get(\"amount\")) { // JLR 17/4/7 : fix a bug coming from POS in case of use of a discount (on item(s) or sale, sale here) and a cash amount higher than total (hence issuing change)\n                    continue;\n                }\n                if (adjAlreadyInvoicedAmount.abs().compareTo(adj.getBigDecimal(\"amount\").setScale(decimals, rounding).abs()) > 0) {\n                    continue;\n                }\n\n                if (\"SHIPPING_CHARGES\".equals(adj.getString(\"orderAdjustmentTypeId\"))) {\n                    shipAdjustments.put(adj, adjAlreadyInvoicedAmount);\n                } else if (\"SALES_TAX\".equals(adj.getString(\"orderAdjustmentTypeId\"))) {\n                    taxAdjustments.put(adj, adjAlreadyInvoicedAmount);\n                } else {\n                    // these will effect the shipping pro-rate (unless commented)\n                    // other adjustment type\n                    BigDecimal adjAmount = calcHeaderAdj(delegator, adj, invoiceType, invoiceId, invoiceItemSeqId, \n                            orderSubTotal, invoiceSubTotal, adj.getBigDecimal(\"amount\").setScale(decimals, rounding), decimals, rounding, userLogin, dispatcher, locale);\n                    // invoiceShipProRateAmount += adjAmount;\n                    // do adjustments compound or are they based off subtotal? Here we will (unless commented)\n                    // invoiceSubTotal += adjAmount;\n\n                    // increment the counter\n                    invoiceItemSeqNum++;\n                    invoiceItemSeqId = UtilFormatOut.formatPaddedNumber(invoiceItemSeqNum, 2);\n                }\n            }\n\n            // next do the shipping adjustments.  Note that we do not want to add these to the invoiceSubTotal or orderSubTotal for pro-rating tax later, as that would cause\n            // numerator/denominator problems when the shipping is not pro-rated but rather charged all on the first invoice\n            Iterator shipAdjIter = shipAdjustments.keySet().iterator();\n            while (shipAdjIter.hasNext()) {\n                GenericValue adj = (GenericValue) shipAdjIter.next();\n                BigDecimal adjAlreadyInvoicedAmount = (BigDecimal) shipAdjustments.get(adj);\n                \n                if (\"N\".equalsIgnoreCase(prorateShipping)) {\n\n                    // Set the divisor and multiplier to 1 to avoid prorating\n                    BigDecimal divisor = new BigDecimal(\"1\");\n                    BigDecimal multiplier = new BigDecimal(\"1\");\n                    \n                    // The base amount in this case is the adjustment amount minus the total already invoiced for that adjustment, since\n                    //  it won't be prorated\n                    BigDecimal baseAmount = adj.getBigDecimal(\"amount\").setScale(decimals, rounding).subtract(adjAlreadyInvoicedAmount);\n                    BigDecimal adjAmount = calcHeaderAdj(delegator, adj, invoiceType, invoiceId, invoiceItemSeqId, \n                            divisor, multiplier, baseAmount, decimals, rounding, userLogin, dispatcher, locale);\n                } else {\n\n                    // Pro-rate the shipping amount based on shippable information\n                    BigDecimal divisor = shippableAmount;\n                    BigDecimal multiplier = invoiceShipProRateAmount;\n                    \n                    // The base amount in this case is the adjustment amount, since we want to prorate based on the full amount\n                    BigDecimal baseAmount = adj.getBigDecimal(\"amount\").setScale(decimals, rounding);\n                    BigDecimal adjAmount = calcHeaderAdj(delegator, adj, invoiceType, invoiceId, invoiceItemSeqId, \n                            divisor, multiplier, baseAmount, decimals, rounding, userLogin, dispatcher, locale);\n                }\n\n                // Increment the counter\n                invoiceItemSeqNum++;\n                invoiceItemSeqId = UtilFormatOut.formatPaddedNumber(invoiceItemSeqNum, 2);\n            }\n\n            // last do the tax adjustments\n            String prorateTaxes = productStore.getString(\"prorateTaxes\");\n            if (prorateTaxes == null) {\n                prorateTaxes = \"Y\";\n            }            \n            Iterator taxAdjIter = taxAdjustments.keySet().iterator();\n            while (taxAdjIter.hasNext()) {\n                GenericValue adj = (GenericValue) taxAdjIter.next();\n                BigDecimal adjAlreadyInvoicedAmount = (BigDecimal) taxAdjustments.get(adj);\n                BigDecimal adjAmount = null;\n                \n                if (\"N\".equalsIgnoreCase(prorateTaxes)) {\n\n                    // Set the divisor and multiplier to 1 to avoid prorating\n                    BigDecimal divisor = new BigDecimal(\"1\");\n                    BigDecimal multiplier = new BigDecimal(\"1\");\n                    \n                    // The base amount in this case is the adjustment amount minus the total already invoiced for that adjustment, since\n                    //  it won't be prorated\n                    //  Note this should use invoice decimals & rounding instead of taxDecimals and taxRounding for tax adjustments, because it will be added to the invoice \n                    BigDecimal baseAmount = adj.getBigDecimal(\"amount\").setScale(decimals, rounding).subtract(adjAlreadyInvoicedAmount);\n                    adjAmount = calcHeaderAdj(delegator, adj, invoiceType, invoiceId, invoiceItemSeqId, \n                             divisor, multiplier, baseAmount, decimals, rounding, userLogin, dispatcher, locale);\n                } else {\n\n                    // Pro-rate the tax amount based on shippable information\n                    BigDecimal divisor = orderSubTotal;\n                    BigDecimal multiplier = invoiceSubTotal;\n                    \n                    // The base amount in this case is the adjustment amount, since we want to prorate based on the full amount\n                    //  Note this should use invoice decimals & rounding instead of taxDecimals and taxRounding for tax adjustments, because it will be added to the invoice \n                    BigDecimal baseAmount = adj.getBigDecimal(\"amount\").setScale(decimals, rounding);\n                    adjAmount = calcHeaderAdj(delegator, adj, invoiceType, invoiceId, invoiceItemSeqId, \n                            divisor, multiplier, baseAmount, decimals, rounding, userLogin, dispatcher, locale);\n                }\n                invoiceSubTotal = invoiceSubTotal.add(adjAmount).setScale(decimals, rounding);                \n\n                // Increment the counter\n                invoiceItemSeqNum++;\n                invoiceItemSeqId = UtilFormatOut.formatPaddedNumber(invoiceItemSeqNum, 2);\n            }\n\n            // check for previous order payments\n            List orderPaymentPrefs = delegator.findByAnd(\"OrderPaymentPreference\", UtilMisc.toMap(\"orderId\", orderId));\n            if (orderPaymentPrefs != null) {\n                List currentPayments = new ArrayList();\n                Iterator opi = orderPaymentPrefs.iterator();\n                while (opi.hasNext()) {\n                    GenericValue paymentPref = (GenericValue) opi.next();\n                    List payments = paymentPref.getRelated(\"Payment\");\n                    currentPayments.addAll(payments);\n                }\n                if (currentPayments.size() > 0) {\n                    // apply these payments to the invoice; only if they haven't already been applied\n                    Iterator cpi = currentPayments.iterator();\n                    while (cpi.hasNext()) {\n                        GenericValue payment = (GenericValue) cpi.next();\n                        List currentApplications = null;\n                        currentApplications = payment.getRelated(\"PaymentApplication\");\n                        if (currentApplications == null || currentApplications.size() == 0) {\n                            // no applications; okay to apply\n                            Map appl = new HashMap();\n                            appl.put(\"paymentId\", payment.get(\"paymentId\"));\n                            appl.put(\"invoiceId\", invoiceId);\n                            appl.put(\"billingAccountId\", billingAccountId);\n                            appl.put(\"amountApplied\", payment.get(\"amount\"));\n                            appl.put(\"userLogin\", userLogin);\n                            Map createPayApplResult = dispatcher.runSync(\"createPaymentApplication\", appl); \n                            if (ServiceUtil.isError(createPayApplResult)) {\n                                return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingErrorCreatingInvoiceFromOrder\",locale), null, null, createPayApplResult);\n                            }\n                        }\n                    }\n                }\n            }\n\n            // Should all be in place now. Depending on the ProductStore.autoApproveInvoice setting, set status to INVOICE_READY (unless it's a purchase \n            //  invoice, which we set to INVOICE_IN_PROCESS) \n            boolean autoApproveInvoice = UtilValidate.isEmpty(productStore.get(\"autoApproveInvoice\")) || \"Y\".equals(productStore.getString(\"autoApproveInvoice\"));\n            if(autoApproveInvoice) {\n                String nextStatusId = \"INVOICE_READY\";\n                if (invoiceType.equals(\"PURCHASE_INVOICE\")) {\n                    nextStatusId = \"INVOICE_IN_PROCESS\";\n                }\n                Map setInvoiceStatusResult = dispatcher.runSync(\"setInvoiceStatus\", UtilMisc.toMap(\"invoiceId\", invoiceId, \"statusId\", nextStatusId, \"userLogin\", userLogin));\n                if (ServiceUtil.isError(setInvoiceStatusResult)) {\n                    return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingErrorCreatingInvoiceFromOrder\",locale), null, null, setInvoiceStatusResult);\n                }\n            }\n\n            // check to see if we are all paid up\n            Map checkResp = dispatcher.runSync(\"checkInvoicePaymentApplications\", UtilMisc.toMap(\"invoiceId\", invoiceId, \"userLogin\", userLogin));\n            if (ServiceUtil.isError(checkResp)) {\n                return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"AccountingErrorCreatingInvoiceFromOrderCheckPaymentAppl\",locale), null, null, checkResp);\n            }\n\n            Map resp = ServiceUtil.returnSuccess();\n            resp.put(\"invoiceId\", invoiceId);\n            return resp;\n        } catch (GenericEntityException e) {\n            String errMsg = UtilProperties.getMessage(resource,\"AccountingEntityDataProblemCreatingInvoiceFromOrderItems\",UtilMisc.toMap(\"reason\",e.toString()),locale);\n            Debug.logError(e, errMsg, module);\n            return ServiceUtil.returnError(errMsg);\n        } catch (GenericServiceException e) {\n            String errMsg = UtilProperties.getMessage(resource,\"AccountingServiceOtherProblemCreatingInvoiceFromOrderItems\",UtilMisc.toMap(\"reason\",e.toString()),locale);\n            Debug.logError(e, errMsg, module);\n            return ServiceUtil.returnError(errMsg);\n        }\n    }","commit_id":"256b33a98c6dea69d25075f3285e787705d8a55b","url":"https://github.com/apache/ofbiz"},{"original_method":"/**\n     * Service to create a payment using an order payment preference.\n     * @return Map\n     */\n    public static Map createPaymentFromPreference(DispatchContext dctx, Map context) {\n        GenericDelegator delegator = dctx.getDelegator();\n        LocalDispatcher dispatcher = dctx.getDispatcher();\n        GenericValue userLogin = (GenericValue) context.get(\"userLogin\");\n\n        String orderPaymentPreferenceId = (String) context.get(\"orderPaymentPreferenceId\");\n        String paymentRefNum = (String) context.get(\"paymentRefNum\");\n        String paymentFromId = (String) context.get(\"paymentFromId\");\n        String comments = (String) context.get(\"comments\");\n        try {\n            // get the order payment preference\n            GenericValue orderPaymentPreference = delegator.findByPrimaryKey(\"OrderPaymentPreference\", UtilMisc.toMap(\"orderPaymentPreferenceId\", orderPaymentPreferenceId));\n            if (orderPaymentPreference == null) {\n                return ServiceUtil.returnError(\"Failed to create Payment: Cannot find OrderPaymentPreference with orderPaymentPreferenceId \" + orderPaymentPreferenceId);\n            }\n\n            // get the order header\n            GenericValue orderHeader = orderPaymentPreference.getRelatedOne(\"OrderHeader\");\n            if (orderHeader == null) {\n                return ServiceUtil.returnError(\"Failed to create Payment: Cannot get related OrderHeader from payment preference\");\n            }\n\n            // get the store for the order.  It will be used to set the currency\n            GenericValue productStore = orderHeader.getRelatedOne(\"ProductStore\");\n            if (productStore == null) {\n                return ServiceUtil.returnError(\"Failed to create Payment: Cannot get the ProductStore for the order header\");\n            }\n\n            // get the partyId billed to \n            OrderReadHelper orh = new OrderReadHelper(orderHeader);\n            GenericValue billToParty = orh.getBillToParty();\n            if (billToParty == null) {\n                return ServiceUtil.returnError(\"Failed to create Payment: cannot find the bill to customer party\");\n            }\n                \n            // set the payToPartyId\n            String payToPartyId = productStore.getString(\"payToPartyId\");\n            if (payToPartyId == null) {\n                return ServiceUtil.returnError(\"Failed to create Payment: Cannot get the ProductStore for the order header\");\n            }\n\n            // create the payment\n            Map paymentParams = new HashMap();\n            paymentParams.put(\"paymentTypeId\", \"CUSTOMER_PAYMENT\");\n            paymentParams.put(\"paymentMethodTypeId\", orderPaymentPreference.getString(\"paymentMethodTypeId\"));\n            paymentParams.put(\"paymentPreferenceId\", orderPaymentPreference.getString(\"orderPaymentPreferenceId\"));\n            paymentParams.put(\"amount\", orderPaymentPreference.getDouble(\"maxAmount\"));\n            paymentParams.put(\"statusId\", \"PMNT_RECEIVED\");\n            paymentParams.put(\"effectiveDate\", UtilDateTime.nowTimestamp());\n            paymentParams.put(\"partyIdFrom\", billToParty.getString(\"partyId\"));\n            paymentParams.put(\"currencyUomId\", productStore.getString(\"defaultCurrencyUomId\"));\n            paymentParams.put(\"partyIdTo\", payToPartyId);\n            if (paymentRefNum != null) {\n                paymentParams.put(\"paymentRefNum\", paymentRefNum);\n            }\n            if (paymentFromId != null) {\n                paymentParams.put(\"partyIdFrom\", paymentFromId);\n            } else {\n                paymentParams.put(\"partyIdFrom\", \"_NA_\");\n            }\n            if (comments != null) {\n                paymentParams.put(\"comments\", comments);\n            }\n            paymentParams.put(\"userLogin\", userLogin);\n\n            return dispatcher.runSync(\"createPayment\", paymentParams);\n\n        } catch (GenericEntityException ex) {\n            Debug.logError(ex, \"Unable to create payment using payment preference.\", module);\n            return(ServiceUtil.returnError(ex.getMessage()));\n        } catch (GenericServiceException ex) {\n            Debug.logError(ex, \"Unable to create payment using payment preference.\", module);\n            return(ServiceUtil.returnError(ex.getMessage()));\n        }\n    }","id":99825,"modified_method":"/**\n     * Service to create a payment using an order payment preference.\n     * @return Map\n     */\n    public static Map createPaymentFromPreference(DispatchContext dctx, Map context) {\n        GenericDelegator delegator = dctx.getDelegator();\n        LocalDispatcher dispatcher = dctx.getDispatcher();\n        GenericValue userLogin = (GenericValue) context.get(\"userLogin\");\n\n        String orderPaymentPreferenceId = (String) context.get(\"orderPaymentPreferenceId\");\n        String paymentRefNum = (String) context.get(\"paymentRefNum\");\n        String paymentFromId = (String) context.get(\"paymentFromId\");\n        String comments = (String) context.get(\"comments\");\n        try {\n            // get the order payment preference\n            GenericValue orderPaymentPreference = delegator.findByPrimaryKey(\"OrderPaymentPreference\", UtilMisc.toMap(\"orderPaymentPreferenceId\", orderPaymentPreferenceId));\n            if (orderPaymentPreference == null) {\n                return ServiceUtil.returnError(\"Failed to create Payment: Cannot find OrderPaymentPreference with orderPaymentPreferenceId \" + orderPaymentPreferenceId);\n            }\n\n            // get the order header\n            GenericValue orderHeader = orderPaymentPreference.getRelatedOne(\"OrderHeader\");\n            if (orderHeader == null) {\n                return ServiceUtil.returnError(\"Failed to create Payment: Cannot get related OrderHeader from payment preference\");\n            }\n\n            // get the store for the order.  It will be used to set the currency\n            GenericValue productStore = orderHeader.getRelatedOne(\"ProductStore\");\n            if (productStore == null) {\n                return ServiceUtil.returnError(\"Failed to create Payment: Cannot get the ProductStore for the order header\");\n            }\n\n            // get the partyId billed to \n            OrderReadHelper orh = new OrderReadHelper(orderHeader);\n            GenericValue billToParty = orh.getBillToParty();\n            if (billToParty == null) {\n                return ServiceUtil.returnError(\"Failed to create Payment: cannot find the bill to customer party\");\n            }\n                \n            // set the payToPartyId\n            String payToPartyId = productStore.getString(\"payToPartyId\");\n            if (payToPartyId == null) {\n                return ServiceUtil.returnError(\"Failed to create Payment: Cannot get the ProductStore for the order header\");\n            }\n\n            // create the payment\n            Map paymentParams = new HashMap();\n            double maxAmount = orderPaymentPreference.getDouble(\"maxAmount\").doubleValue();\n            if (maxAmount > 0.0) {            \n                paymentParams.put(\"paymentTypeId\", \"CUSTOMER_PAYMENT\");\n                paymentParams.put(\"paymentMethodTypeId\", orderPaymentPreference.getString(\"paymentMethodTypeId\"));\n                paymentParams.put(\"paymentPreferenceId\", orderPaymentPreference.getString(\"orderPaymentPreferenceId\"));\n                paymentParams.put(\"amount\", new Double(maxAmount));\n                paymentParams.put(\"statusId\", \"PMNT_RECEIVED\");\n                paymentParams.put(\"effectiveDate\", UtilDateTime.nowTimestamp());\n                paymentParams.put(\"partyIdFrom\", billToParty.getString(\"partyId\"));\n                paymentParams.put(\"currencyUomId\", productStore.getString(\"defaultCurrencyUomId\"));\n                paymentParams.put(\"partyIdTo\", payToPartyId);\n            }\n            else {\n                paymentParams.put(\"paymentTypeId\", \"CUSTOMER_REFUND\"); // JLR 17/7/4 from a suggestion of Si cf. https://issues.apache.org/jira/browse/OFBIZ-828#action_12483045\n                paymentParams.put(\"paymentMethodTypeId\", orderPaymentPreference.getString(\"paymentMethodTypeId\"));\n                paymentParams.put(\"paymentPreferenceId\", orderPaymentPreference.getString(\"orderPaymentPreferenceId\"));\n                paymentParams.put(\"amount\", new Double(Math.abs(maxAmount)));\n                paymentParams.put(\"statusId\", \"PMNT_RECEIVED\");\n                paymentParams.put(\"effectiveDate\", UtilDateTime.nowTimestamp());\n                paymentParams.put(\"partyIdFrom\", payToPartyId);\n                paymentParams.put(\"currencyUomId\", productStore.getString(\"defaultCurrencyUomId\"));\n                paymentParams.put(\"partyIdTo\", billToParty.getString(\"partyId\"));\n            }\n            if (paymentRefNum != null) {\n                paymentParams.put(\"paymentRefNum\", paymentRefNum);\n            }\n            if (paymentFromId != null) {\n                paymentParams.put(\"partyIdFrom\", paymentFromId);\n            } else {\n                paymentParams.put(\"partyIdFrom\", \"_NA_\");\n            }\n            if (comments != null) {\n                paymentParams.put(\"comments\", comments);\n            }\n            paymentParams.put(\"userLogin\", userLogin);\n\n            return dispatcher.runSync(\"createPayment\", paymentParams);\n\n        } catch (GenericEntityException ex) {\n            Debug.logError(ex, \"Unable to create payment using payment preference.\", module);\n            return(ServiceUtil.returnError(ex.getMessage()));\n        } catch (GenericServiceException ex) {\n            Debug.logError(ex, \"Unable to create payment using payment preference.\", module);\n            return(ServiceUtil.returnError(ex.getMessage()));\n        }\n    }","commit_id":"256b33a98c6dea69d25075f3285e787705d8a55b","url":"https://github.com/apache/ofbiz"},{"original_method":"public static Timestamp calculateCompletionDate(GenericValue task, Timestamp startDate) {\n\n\t\tDouble plannedHours = 0.00;\n    \ttry {\n    \t\t// get planned hours\n    \t\tList standards = task.getRelated(\"WorkEffortSkillStandard\");\n    \t\tIterator t = standards.iterator();\n    \t\twhile (t.hasNext()) {\n    \t\t\tGenericValue standard = (GenericValue) t.next();\n    \t\t\tif (standard.getDouble(\"estimatedNumPeople\") == null) {\n    \t\t\t\tstandard.put(\"estimatedNumPeople\", new Double(\"1\"));\n    \t\t\t}\n    \t\t\tplannedHours += standard.getDouble(\"estimatedDuration\") / standard.getDouble(\"estimatedNumPeople\");\n    \t\t}\n\n    \t} catch (GenericEntityException e) {\n    \t\tDebug.logError(\"Could not updte task: \" + e.getMessage(), module);\n    \t}\n    \treturn UtilDateTime.addDaysToTimestamp(startDate, plannedHours / 8); \n    }","id":99826,"modified_method":"public static Timestamp calculateCompletionDate(GenericValue task, Timestamp startDate) {\n\n\t\tDouble plannedHours = 0.00;\n    \ttry {\n    \t\t// get planned hours\n    \t\tList standards = task.getRelated(\"WorkEffortSkillStandard\");\n    \t\tIterator t = standards.iterator();\n    \t\twhile (t.hasNext()) {\n    \t\t\tGenericValue standard = (GenericValue) t.next();\n    \t\t\tif (standard.getDouble(\"estimatedNumPeople\") == null) {\n    \t\t\t\tstandard.put(\"estimatedNumPeople\", new Double(\"1\"));\n    \t\t\t}\n    \t\t\tif (standard.get(\"estimatedDuration\") != null) {\n    \t\t\t\tplannedHours += standard.getDouble(\"estimatedDuration\").doubleValue() / standard.getDouble(\"estimatedNumPeople\").doubleValue();\n    \t\t\t}\n    \t\t}\n\n    \t} catch (GenericEntityException e) {\n    \t\tDebug.logError(\"Could not updte task: \" + e.getMessage(), module);\n    \t}\n    \tif (plannedHours == 0.00) {\n    \t\tplannedHours = new Double(\"24.00\");\n    \t}\n    \treturn UtilDateTime.addDaysToTimestamp(startDate, plannedHours / 8); \n    }","commit_id":"c43d623ad1adce7f98159f6a7e0e133acbc8c179","url":"https://github.com/apache/ofbiz"},{"original_method":"/**\n     * Build a new connection to the given peer.  This blocks if there is no\n     * connection delay, otherwise it returns immediately.\n     *\n     * @param peer Destination to contact\n     * @param opts Connection's options\n     * @return new connection, or null if we have exceeded our limit\n     */\n    public Connection connect(Destination peer, ConnectionOptions opts) {\n        Connection con = null;\n        long receiveId = _context.random().nextLong(Packet.MAX_STREAM_ID-1)+1;\n        long expiration = _context.clock().now() + opts.getConnectTimeout();\n        if (opts.getConnectTimeout() <= 0)\n            expiration = _context.clock().now() + DEFAULT_STREAM_DELAY_MAX;\n        _numWaiting++;\n        while (true) {\n            long remaining = expiration - _context.clock().now();\n            if (remaining <= 0) { \n                if (_log.shouldLog(Log.WARN))\n                _log.warn(\"Refusing to connect since we have exceeded our max of \" \n                          + _maxConcurrentStreams + \" connections\");\n                _numWaiting--;\n                return null;\n            }\n\n                if (locked_tooManyStreams()) {\n                    // allow a full buffer of pending/waiting streams\n                    if (_numWaiting > _maxConcurrentStreams) {\n                        if (_log.shouldLog(Log.WARN))\n                            _log.warn(\"Refusing connection since we have exceeded our max of \"\n                                      + _maxConcurrentStreams + \" and there are \" + _numWaiting\n                                      + \" waiting already\");\n                        _numWaiting--;\n                        return null;\n                    }\n\n                    // no remaining streams, lets wait a bit\n                    // got rid of the lock, so just sleep (fixme?)\n                    // try { _connectionLock.wait(remaining); } catch (InterruptedException ie) {}\n                    try { Thread.sleep(remaining/4); } catch (InterruptedException ie) {}\n                } else { \n                    con = new Connection(_context, this, _schedulerChooser, _outboundQueue, _conPacketHandler, opts);\n                    con.setRemotePeer(peer);\n            \n                    while (_connectionByInboundId.containsKey(Long.valueOf(receiveId))) {\n                        receiveId = _context.random().nextLong(Packet.MAX_STREAM_ID-1)+1;\n                    }\n                    _connectionByInboundId.put(Long.valueOf(receiveId), con);\n                    break; // stop looping as a psuedo-wait\n                }\n\n        }\n\n        // ok we're in...\n        con.setReceiveStreamId(receiveId);        \n        con.eventOccurred();\n        \n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Connect() conDelay = \" + opts.getConnectDelay());\n        if (opts.getConnectDelay() <= 0) {\n            con.waitForConnect();\n        }\n        if (_numWaiting > 0)\n            _numWaiting--;\n        \n        _context.statManager().addRateData(\"stream.connectionCreated\", 1, 0);\n        return con;\n    }","id":99827,"modified_method":"/**\n     * Build a new connection to the given peer.  This blocks if there is no\n     * connection delay, otherwise it returns immediately.\n     *\n     * @param peer Destination to contact\n     * @param opts Connection's options\n     * @return new connection, or null if we have exceeded our limit\n     */\n    public Connection connect(Destination peer, ConnectionOptions opts) {\n        Connection con = null;\n        long receiveId = _context.random().nextLong(Packet.MAX_STREAM_ID-1)+1;\n        long expiration = _context.clock().now() + opts.getConnectTimeout();\n        if (opts.getConnectTimeout() <= 0)\n            expiration = _context.clock().now() + DEFAULT_STREAM_DELAY_MAX;\n        _numWaiting++;\n        while (true) {\n            long remaining = expiration - _context.clock().now();\n            if (remaining <= 0) { \n                _log.logAlways(Log.WARN, \"Refusing to connect since we have exceeded our max of \" \n                          + _maxConcurrentStreams + \" connections\");\n                _numWaiting--;\n                return null;\n            }\n\n                if (locked_tooManyStreams()) {\n                    // allow a full buffer of pending/waiting streams\n                    if (_numWaiting > _maxConcurrentStreams) {\n                        _log.logAlways(Log.WARN, \"Refusing connection since we have exceeded our max of \"\n                                      + _maxConcurrentStreams + \" and there are \" + _numWaiting\n                                      + \" waiting already\");\n                        _numWaiting--;\n                        return null;\n                    }\n\n                    // no remaining streams, lets wait a bit\n                    // got rid of the lock, so just sleep (fixme?)\n                    // try { _connectionLock.wait(remaining); } catch (InterruptedException ie) {}\n                    try { Thread.sleep(remaining/4); } catch (InterruptedException ie) {}\n                } else { \n                    con = new Connection(_context, this, _schedulerChooser, _outboundQueue, _conPacketHandler, opts);\n                    con.setRemotePeer(peer);\n            \n                    while (_connectionByInboundId.containsKey(Long.valueOf(receiveId))) {\n                        receiveId = _context.random().nextLong(Packet.MAX_STREAM_ID-1)+1;\n                    }\n                    _connectionByInboundId.put(Long.valueOf(receiveId), con);\n                    break; // stop looping as a psuedo-wait\n                }\n\n        }\n\n        // ok we're in...\n        con.setReceiveStreamId(receiveId);        \n        con.eventOccurred();\n        \n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Connect() conDelay = \" + opts.getConnectDelay());\n        if (opts.getConnectDelay() <= 0) {\n            con.waitForConnect();\n        }\n        if (_numWaiting > 0)\n            _numWaiting--;\n        \n        _context.statManager().addRateData(\"stream.connectionCreated\", 1, 0);\n        return con;\n    }","commit_id":"75eda7e1b140d181bc35856071593536af759e17","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Create a new connection based on the SYN packet we received.\n     *\n     * @param synPacket SYN packet to process\n     * @return created Connection with the packet's data already delivered to\n     *         it, or null if the syn's streamId was already taken\n     */\n    public Connection receiveConnection(Packet synPacket) {\n        ConnectionOptions opts = new ConnectionOptions(_defaultOptions);\n        opts.setPort(synPacket.getRemotePort());\n        opts.setLocalPort(synPacket.getLocalPort());\n        Connection con = new Connection(_context, this, _schedulerChooser, _outboundQueue, _conPacketHandler, opts);\n        _tcbShare.updateOptsFromShare(con);\n        con.setInbound();\n        long receiveId = _context.random().nextLong(Packet.MAX_STREAM_ID-1)+1;\n        boolean reject = false;\n        int active = 0;\n        int total = 0;\n\n            // just for the stat\n            //total = _connectionByInboundId.size();\n            //for (Iterator iter = _connectionByInboundId.values().iterator(); iter.hasNext(); ) {\n            //    if ( ((Connection)iter.next()).getIsConnected() )\n            //        active++;\n            //}\n            if (locked_tooManyStreams()) {\n                if (_log.shouldLog(Log.WARN))\n                    _log.warn(\"Refusing connection since we have exceeded our max of \" \n                              + _maxConcurrentStreams + \" connections\");\n                reject = true;\n            } else {\n                // this may not be right if more than one is enabled\n                String why = shouldRejectConnection(synPacket);\n                if (why != null) {\n                    _log.logAlways(Log.WARN, \"Refusing connection since peer is \" + why +\n                           (synPacket.getOptionalFrom() == null ? \"\" : \": \" + synPacket.getOptionalFrom().calculateHash().toBase64()));\n                    reject = true;\n                } else { \n                    while (true) {\n                        Connection oldCon = _connectionByInboundId.putIfAbsent(Long.valueOf(receiveId), con);\n                        if (oldCon == null) {\n                            break;\n                        } else { \n                            // receiveId already taken, try another\n                            receiveId = _context.random().nextLong(Packet.MAX_STREAM_ID-1)+1;\n                        }\n                    }\n                }\n            }\n        \n        _context.statManager().addRateData(\"stream.receiveActive\", active, total);\n        \n        if (reject) {\n            PacketLocal reply = new PacketLocal(_context, synPacket.getOptionalFrom());\n            reply.setFlag(Packet.FLAG_RESET);\n            reply.setFlag(Packet.FLAG_SIGNATURE_INCLUDED);\n            reply.setAckThrough(synPacket.getSequenceNum());\n            reply.setSendStreamId(synPacket.getReceiveStreamId());\n            reply.setReceiveStreamId(0);\n            reply.setOptionalFrom(_session.getMyDestination());\n            // this just sends the packet - no retries or whatnot\n            _outboundQueue.enqueue(reply);\n            return null;\n        }\n        \n        con.setReceiveStreamId(receiveId);\n        try {\n            // This validates the packet, and sets the con's SendStreamID and RemotePeer\n            con.getPacketHandler().receivePacket(synPacket, con);\n        } catch (I2PException ie) {\n            _connectionByInboundId.remove(Long.valueOf(receiveId));\n            return null;\n        }\n        \n        _context.statManager().addRateData(\"stream.connectionReceived\", 1, 0);\n        return con;\n    }","id":99828,"modified_method":"/**\n     * Create a new connection based on the SYN packet we received.\n     *\n     * @param synPacket SYN packet to process\n     * @return created Connection with the packet's data already delivered to\n     *         it, or null if the syn's streamId was already taken\n     */\n    public Connection receiveConnection(Packet synPacket) {\n        ConnectionOptions opts = new ConnectionOptions(_defaultOptions);\n        opts.setPort(synPacket.getRemotePort());\n        opts.setLocalPort(synPacket.getLocalPort());\n        Connection con = new Connection(_context, this, _schedulerChooser, _outboundQueue, _conPacketHandler, opts);\n        _tcbShare.updateOptsFromShare(con);\n        con.setInbound();\n        long receiveId = _context.random().nextLong(Packet.MAX_STREAM_ID-1)+1;\n        boolean reject = false;\n        int active = 0;\n        int total = 0;\n\n            // just for the stat\n            //total = _connectionByInboundId.size();\n            //for (Iterator iter = _connectionByInboundId.values().iterator(); iter.hasNext(); ) {\n            //    if ( ((Connection)iter.next()).getIsConnected() )\n            //        active++;\n            //}\n            if (locked_tooManyStreams()) {\n                _log.logAlways(Log.WARN, \"Refusing connection since we have exceeded our max of \" \n                              + _maxConcurrentStreams + \" connections\");\n                reject = true;\n            } else {\n                // this may not be right if more than one is enabled\n                String why = shouldRejectConnection(synPacket);\n                if (why != null) {\n                    _log.logAlways(Log.WARN, \"Refusing connection since peer is \" + why +\n                           (synPacket.getOptionalFrom() == null ? \"\" : \": \" + synPacket.getOptionalFrom().calculateHash().toBase64()));\n                    reject = true;\n                } else { \n                    while (true) {\n                        Connection oldCon = _connectionByInboundId.putIfAbsent(Long.valueOf(receiveId), con);\n                        if (oldCon == null) {\n                            break;\n                        } else { \n                            // receiveId already taken, try another\n                            receiveId = _context.random().nextLong(Packet.MAX_STREAM_ID-1)+1;\n                        }\n                    }\n                }\n            }\n        \n        _context.statManager().addRateData(\"stream.receiveActive\", active, total);\n        \n        if (reject) {\n            PacketLocal reply = new PacketLocal(_context, synPacket.getOptionalFrom());\n            reply.setFlag(Packet.FLAG_RESET);\n            reply.setFlag(Packet.FLAG_SIGNATURE_INCLUDED);\n            reply.setAckThrough(synPacket.getSequenceNum());\n            reply.setSendStreamId(synPacket.getReceiveStreamId());\n            reply.setReceiveStreamId(0);\n            reply.setOptionalFrom(_session.getMyDestination());\n            // this just sends the packet - no retries or whatnot\n            _outboundQueue.enqueue(reply);\n            return null;\n        }\n        \n        con.setReceiveStreamId(receiveId);\n        try {\n            // This validates the packet, and sets the con's SendStreamID and RemotePeer\n            con.getPacketHandler().receivePacket(synPacket, con);\n        } catch (I2PException ie) {\n            _connectionByInboundId.remove(Long.valueOf(receiveId));\n            return null;\n        }\n        \n        _context.statManager().addRateData(\"stream.connectionReceived\", 1, 0);\n        return con;\n    }","commit_id":"75eda7e1b140d181bc35856071593536af759e17","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public Tab getFacetTab(String facetType, SModuleFacet moduleFacet) {\n    if(!myFacetTabs.containsKey(facetType))\n      return null;\n\n    TabFactory<SModuleFacet> tabFactory = myFacetTabs.get(facetType);\n    return tabFactory.getTab(moduleFacet);\n  }","id":99829,"modified_method":"/**\n   * @return newly instantiated or existing tab instance for the given facet, <code>null<\/code> if facet doesn't need an UI.\n   * FIXME take facetType from moduleFacet (move appropriate method into API).\n   */\n  @Nullable\n  public Tab getFacetTab(String facetType, SModuleFacet moduleFacet) {\n    if(!myFacetTabs.containsKey(facetType))\n      return null;\n\n    TabFactory<SModuleFacet> tabFactory = myFacetTabs.get(facetType);\n    return tabFactory.getTab(moduleFacet);\n  }","commit_id":"80453caf058d2e66a504ce89fbf10f3067a141c1","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void init() {\n      final HashMap<String, ModuleFacetBase> facetsTypes = new HashMap<String, ModuleFacetBase>();\n      for (final SModuleFacet moduleFacet : myModule.getFacets()) {\n        if (!(moduleFacet instanceof ModuleFacetBase)) continue;\n        facetsTypes.put(((ModuleFacetBase) moduleFacet).getFacetType(), (ModuleFacetBase) moduleFacet);\n      }\n\n      Set<String> usedLangs = new HashSet<String>();\n      for (SModuleReference reference : myModuleDescriptor.getUsedLanguages()) {\n        usedLangs.add(reference.getModuleName());\n      }\n      Set<String> applicableFacetTypes = FacetsFacade.getInstance().getApplicableFacetTypes(usedLangs);\n\n      for (String facet : FacetsFacade.getInstance().getFacetTypes()) {\n        ModuleFacetBase sModuleFacet = facetsTypes.get(facet);\n        if (sModuleFacet == null) {\n          // i.e. !facetsTypes.contains(facet)\n          SModuleFacet newInstance = FacetsFacade.getInstance().getFacetFactory(facet).create();\n          if (newInstance instanceof ModuleFacetBase) {\n            sModuleFacet = (ModuleFacetBase) newInstance;\n            // FIXME It's not smart to establish one-way association (facet->module)\n            // as facet may get confused (i.e. getModule().getFacets().contains(this) == false)\n            // but this is the easiest way to comply with @NotNull Facet.getModule().\n            // The right way, though bit longer, is not to instantiate facet unless truly created\n            sModuleFacet.setModule(myModule);\n          }\n        }\n        final String facetPresentation = applicableFacetTypes.contains(facet)\n            ? sModuleFacet.getFacetPresentation() + \" (recommended)\"\n            : sModuleFacet.getFacetPresentation();\n        final JBCheckBox checkBox = new JBCheckBox(facetPresentation, facetsTypes.keySet().contains(facet));\n        checkBox.putClientProperty(CHECKBOX_PROPERTY_KEY, sModuleFacet);\n        myCheckBoxes.add(checkBox);\n        checkBox.addItemListener(new FacetCheckBoxItemListener(checkBox));\n      }\n      final JPanel panel = new JPanel();\n      panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));\n      final int i = 5;\n      panel.setBorder(BorderFactory.createEmptyBorder(i, i, i, i));\n      for (JCheckBox checkBox : myCheckBoxes) {\n        panel.add(checkBox);\n      }\n\n      setTabComponent(panel);\n    }","id":99830,"modified_method":"@Override\n    public void init() {\n      final HashMap<String, ModuleFacetBase> existingFacetTypes = new HashMap<String, ModuleFacetBase>();\n      for (final SModuleFacet moduleFacet : myModule.getFacets()) {\n        if (!(moduleFacet instanceof ModuleFacetBase)) continue;\n        existingFacetTypes.put(((ModuleFacetBase) moduleFacet).getFacetType(), (ModuleFacetBase) moduleFacet);\n      }\n\n      Set<String> usedLangs = new ModelAccessHelper(myProject.getModelAccess()).runReadAction(new Computable<Set<String>>() {\n        @Override\n        public Set<String> compute() {\n          HashSet<String> rv = new HashSet<String>();\n          for (SLanguage reference : myModule.getUsedLanguages()) {\n            rv.add(reference.getQualifiedName());\n          }\n          return rv;\n        }\n      });\n      Set<String> applicableFacetTypes = FacetsFacade.getInstance().getApplicableFacetTypes(usedLangs);\n\n      for (String facet : FacetsFacade.getInstance().getFacetTypes()) {\n        ModuleFacetBase sModuleFacet = existingFacetTypes.get(facet);\n        if (sModuleFacet == null) {\n          // i.e. !existingFacetTypes.contains(facet)\n          SModuleFacet newInstance = FacetsFacade.getInstance().getFacetFactory(facet).create();\n          sModuleFacet = (ModuleFacetBase) newInstance;\n        }\n        String facetPresentation = sModuleFacet.getFacetPresentation();\n        facetPresentation = applicableFacetTypes.contains(facet)\n            ? String.format(\"%s (recommended)\", facetPresentation) : facetPresentation;\n        FacetCheckBox checkBox = existingFacetTypes.containsKey(facet)\n            ? new FacetCheckBox(AddFacetsTab.this, sModuleFacet, myFacetTabsPersistence.getFacetTab(facet, sModuleFacet), facetPresentation)\n            : new FacetCheckBox(AddFacetsTab.this, facet, facetPresentation);\n\n        myCheckBoxes.add(checkBox);\n      }\n      Collections.sort(myCheckBoxes);\n      final JPanel panel = new JPanel();\n      panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));\n      final int i = 5;\n      panel.setBorder(BorderFactory.createEmptyBorder(i, i, i, i));\n      for (FacetCheckBox checkBox : myCheckBoxes) {\n        checkBox.addTo(panel);\n      }\n\n      setTabComponent(panel);\n    }","commit_id":"80453caf058d2e66a504ce89fbf10f3067a141c1","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public boolean isModified() {\n      Set<String> facetsTypes = new HashSet<String>();\n      for (SModuleFacet moduleFacet : myModule.getFacets()) {\n        if (!(moduleFacet instanceof ModuleFacetBase))\n          continue;\n        facetsTypes.add(((ModuleFacetBase) moduleFacet).getFacetType());\n      }\n\n      Set<String> newFacetsTypes = new HashSet<String>();\n      for (JCheckBox checkBox : myCheckBoxes) {\n        if (checkBox.isSelected()) {\n          final SModuleFacet facet = (SModuleFacet) checkBox.getClientProperty(CHECKBOX_PROPERTY_KEY);\n          if (!(facet instanceof ModuleFacetBase)) continue;\n          newFacetsTypes.add(((ModuleFacetBase) facet).getFacetType());\n        }\n      }\n\n      return facetsTypes.addAll(newFacetsTypes) && newFacetsTypes.containsAll(facetsTypes);\n    }","id":99831,"modified_method":"@Override\n    public boolean isModified() {\n      for (FacetCheckBox checkBox : myCheckBoxes) {\n        if (checkBox.isExistingToRemove() || checkBox.isNewlyCreated()) {\n          return true;\n        }\n      }\n      return false;\n    }","commit_id":"80453caf058d2e66a504ce89fbf10f3067a141c1","url":"https://github.com/JetBrains/MPS"},{"original_method":"public AddFacetsTab() {\n      super(\"Facets\", AllIcons.General.Settings, \"Add facets\");\n      init();\n\n      addChangeListener(new ChangeListener() {\n        @Override\n        public void stateChanged(ChangeEvent e) {\n          if (!(e.getSource() instanceof JBTabsImpl && ((JBTabsImpl) e.getSource()).getSelectedInfo().getComponent() instanceof TabWrapper))\n            return;\n\n          final JComponent component = ((JBTabsImpl) e.getSource()).getSelectedInfo().getComponent();\n          if (component.getComponentCount() == 0) return;\n          if (component.getComponent(0).equals(getTabComponent())) {\n//            ModulePropertiesConfigurable.this.selectTab(ModulePropertiesConfigurable.this.indexOfTab(AddFacetsTab.this) - 1);\n\n          }\n        }\n      });\n    }","id":99832,"modified_method":"public AddFacetsTab() {\n      super(\"Facets\", AllIcons.General.Settings, \"Add facets\");\n      init();\n    }","commit_id":"80453caf058d2e66a504ce89fbf10f3067a141c1","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void apply() {\n      final HashMap<String, ModuleFacetBase> moduleFacets = new HashMap<String, ModuleFacetBase>();\n      for (final SModuleFacet moduleFacet : myModule.getFacets()) {\n        if (!(moduleFacet instanceof ModuleFacetBase)) continue;\n        moduleFacets.put(((ModuleFacetBase) moduleFacet).getFacetType(), (ModuleFacetBase) moduleFacet);\n      }\n\n      for (JCheckBox checkBox : myCheckBoxes) {\n        if (!(checkBox.getClientProperty(CHECKBOX_PROPERTY_KEY) instanceof ModuleFacetBase)) continue;\n\n        ModuleFacetBase facet = (ModuleFacetBase) checkBox.getClientProperty(CHECKBOX_PROPERTY_KEY);\n\n        if (checkBox.isSelected() && !moduleFacets.keySet().contains(facet.getFacetType())) {\n          Memento memento = new MementoImpl();\n          facet.save(memento);\n          myModuleDescriptor.getModuleFacetDescriptors().add(new ModuleFacetDescriptor(facet.getFacetType(), memento));\n        } else if (!checkBox.isSelected() && moduleFacets.keySet().contains(facet.getFacetType())) {\n          Iterator<ModuleFacetDescriptor> it = myModuleDescriptor.getModuleFacetDescriptors().iterator();\n          while (it.hasNext()) {\n            ModuleFacetDescriptor facetDescriptor = it.next();\n            if (facetDescriptor.getType().equals(facet.getFacetType())) {\n              myModuleDescriptor.getModuleFacetDescriptors().remove(facetDescriptor);\n              break;\n            }\n          }\n\n        }\n      }\n    }","id":99833,"modified_method":"@Override\n    public void apply() {\n      for (FacetCheckBox checkBox : myCheckBoxes) {\n        Collection<ModuleFacetDescriptor> moduleFacetDescriptors = myModuleDescriptor.getModuleFacetDescriptors();\n        ModuleFacetBase facet = checkBox.getFacet();\n        if (checkBox.isNewlyCreated()) {\n          Tab tab = checkBox.getTab();\n          if (tab != null) {\n            // not all facets necessarily feature UI component, but in case they do, let the tab populate facet with updated values.\n            // The reason is that apply() for AddFacetsTab comes earlier than apply to any newly added tab (due to natural order of tab addition).\n            // Should not be an issue to apply twice (here and subsequently from MPSPropertiesConfigurable#apply())\n            tab.apply();\n          }\n          Memento memento = new MementoImpl();\n          facet.save(memento);\n          // some facets may register themselves into descriptors\n          // e.g. due to need to keep actual facet intact (idea plugin facet shall answer\n          // old id for classloading purposes. FIXME instead, facet shall keep both value,\n          // return old but serialize new once. Even in that case, however, this check won't hurt\n          boolean alreadyThere = false;\n          for (ModuleFacetDescriptor d : moduleFacetDescriptors) {\n            if (facet.getFacetType().equals(d.getType())) {\n              alreadyThere = true;\n              break;\n            }\n          }\n          if (!alreadyThere) {\n            moduleFacetDescriptors.add(new ModuleFacetDescriptor(facet.getFacetType(), memento));\n          }\n        } else if (checkBox.isExistingToRemove()) {\n          for (Iterator<ModuleFacetDescriptor> it = moduleFacetDescriptors.iterator(); it.hasNext(); ) {\n            ModuleFacetDescriptor facetDescriptor = it.next();\n            if (facetDescriptor.getType().equals(facet.getFacetType())) {\n              moduleFacetDescriptors.remove(facetDescriptor);\n              break;\n            }\n          }\n        }\n      }\n    }","commit_id":"80453caf058d2e66a504ce89fbf10f3067a141c1","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * Get the service that is mapped to the specified request.\n     */\n    protected String getService(UMOImmutableEndpoint endpoint)\n    {\n        String pathInfo = endpoint.getEndpointURI().getPath();\n\n        if (StringUtils.isEmpty(pathInfo)) {\n            return endpoint.getEndpointURI().getHost();\n        }\n\n        String serviceName;\n\n        int i = pathInfo.lastIndexOf(\"/\");\n\n        if (i > -1) {\n            serviceName = pathInfo.substring(i + 1);\n        }\n        else {\n            serviceName = pathInfo;\n        }\n\n        return serviceName;\n    }","id":99834,"modified_method":"/**\n     * Get the service that is mapped to the specified request.\n     */\n    protected String getServiceName(UMOImmutableEndpoint endpoint)\n    {\n        String pathInfo = endpoint.getEndpointURI().getPath();\n\n        if (StringUtils.isEmpty(pathInfo)) {\n            return endpoint.getEndpointURI().getHost();\n        }\n\n        String serviceName;\n\n        int i = pathInfo.lastIndexOf('/');\n\n        if (i > -1) {\n            serviceName = pathInfo.substring(i + 1);\n        }\n        else {\n            serviceName = pathInfo;\n        }\n\n        return serviceName;\n    }","commit_id":"fa1263b8c56f253bf0c4846ac97ce393cd2e73b5","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void doDispose()\n    {\n        // template method\n    }","id":99835,"modified_method":"protected void doDispose()\n    {\n        connector = null;\n    }","commit_id":"fa1263b8c56f253bf0c4846ac97ce393cd2e73b5","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Make a specific request to the underlying transport\n     *\n     * @param endpoint the endpoint to use when connecting to the resource\n     * @param timeout  the maximum time the operation should block before returning. The call should\n     *                 return immediately if there is data available. If no data becomes available before the timeout\n     *                 elapses, null will be returned\n     * @return the result of the request wrapped in a UMOMessage object. Null will be returned if no data was\n     *         avaialable\n     * @throws Exception if the call to the underlying protocal cuases an exception\n     */\n    protected UMOMessage doReceive(UMOImmutableEndpoint endpoint, long timeout) throws Exception {\n\n        String serviceName = getService(endpoint);\n\n        XFire xfire = connector.getXfire();\n        Service service = xfire.getServiceRegistry().getService(serviceName);\n        Client client = new Client(new MuleUniversalTransport(), service, endpoint.getEndpointURI().toString());\n        client.setXFire(xfire);\n        client.setTimeout((int)timeout);\n        client.setEndpointUri(endpoint.getEndpointURI().toString());\n\n        String method = (String)endpoint.getProperty(SoapConstants.SOAP_METHOD_PROPERTY);\n        OperationInfo op = service.getServiceInfo().getOperation(method);\n\n        Properties params = endpoint.getEndpointURI().getUserParams();\n        String args[] = new String[params.size()];\n        int i = 0;\n        for (Iterator iterator = params.values().iterator(); iterator.hasNext(); i++) {\n            args[i] = iterator.next().toString();\n        }\n\n        Object[] response = client.invoke(op, args);\n\n        if (response != null && response.length == 1) {\n            return new MuleMessage(response[0]);\n        }\n        else {\n            return new MuleMessage(response);\n        }\n    }","id":99836,"modified_method":"/**\n     * Make a specific request to the underlying transport\n     * \n     * @param endpoint\n     *            the endpoint to use when connecting to the resource\n     * @param timeout\n     *            the maximum time the operation should block before returning. The call\n     *            should return immediately if there is data available. If no data becomes\n     *            available before the timeout elapses, null will be returned\n     * @return the result of the request wrapped in a UMOMessage object. Null will be\n     *         returned if no data was avaialable\n     * @throws Exception\n     *             if the call to the underlying protocal cuases an exception\n     */\n    protected UMOMessage doReceive(UMOImmutableEndpoint endpoint, long timeout) throws Exception\n    {\n        String serviceName = getServiceName(endpoint);\n\n        XFire xfire = connector.getXfire();\n        Service service = xfire.getServiceRegistry().getService(serviceName);\n        Client client = new Client(new MuleUniversalTransport(), service, endpoint.getEndpointURI()\n                .toString());\n        client.setXFire(xfire);\n        client.setTimeout((int)timeout);\n        client.setEndpointUri(endpoint.getEndpointURI().toString());\n\n        String method = (String)endpoint.getProperty(SoapConstants.SOAP_METHOD_PROPERTY);\n        OperationInfo op = service.getServiceInfo().getOperation(method);\n\n        Properties params = endpoint.getEndpointURI().getUserParams();\n        String args[] = new String[params.size()];\n        int i = 0;\n        for (Iterator iterator = params.values().iterator(); iterator.hasNext(); i++) {\n            args[i] = iterator.next().toString();\n        }\n\n        Object[] response = client.invoke(op, args);\n\n        if (response != null && response.length == 1) {\n            return new MuleMessage(response[0]);\n        }\n        else {\n            return new MuleMessage(response);\n        }\n    }","commit_id":"fa1263b8c56f253bf0c4846ac97ce393cd2e73b5","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void doDisconnect() throws Exception {\n        client = null;\n    }","id":99837,"modified_method":"protected void doDisconnect() throws Exception\n    {\n        clientPool = null;\n    }","commit_id":"fa1263b8c56f253bf0c4846ac97ce393cd2e73b5","url":"https://github.com/mulesoft/mule"},{"original_method":"protected UMOMessage doSend(UMOEvent event) throws Exception\n    {\n        if (client.getTimeout() != event.getTimeout()) {\n            client.setTimeout(event.getTimeout());\n        }\n        client.setProperty(MuleProperties.MULE_EVENT_PROPERTY, event);\n        String method = getMethod(event);\n        Object[] response = client.invoke(method, getArgs(event));\n        UMOMessage result = null;\n        if (response != null && response.length <= 1) {\n            if (response.length == 1) {\n                result = new MuleMessage(response[0], event.getMessage());\n            }\n        }\n        else {\n            result = new MuleMessage(response, event.getMessage());\n        }\n        return result;\n    }","id":99838,"modified_method":"protected UMOMessage doSend(UMOEvent event) throws Exception\n    {\n        Client client = null;\n\n        try {\n            client = (Client)clientPool.borrowObject();\n            client.setTimeout(event.getTimeout());\n            client.setProperty(MuleProperties.MULE_EVENT_PROPERTY, event);\n            Object[] response = client.invoke(getMethod(event), getArgs(event));\n\n            UMOMessage result = null;\n            if (response != null && response.length <= 1) {\n                if (response.length == 1) {\n                    result = new MuleMessage(response[0], event.getMessage());\n                }\n            }\n            else {\n                result = new MuleMessage(response, event.getMessage());\n            }\n\n            return result;\n        }\n        finally {\n            if (client != null) {\n                clientPool.returnObject(client);\n            }\n        }\n    }","commit_id":"fa1263b8c56f253bf0c4846ac97ce393cd2e73b5","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void doConnect(UMOImmutableEndpoint endpoint) throws Exception {\n        if(client==null)\n        {\n            String serviceName = getService(endpoint);\n            XFire xfire = connector.getXfire();\n            Service service = xfire.getServiceRegistry().getService(serviceName);\n            if(service==null) {\n                throw new FatalConnectException(new Message(\"xfire\", 8, serviceName), this);\n            }\n            client = new Client(new MuleUniversalTransport(), service, endpoint.getEndpointURI().toString());\n            client.setXFire(xfire);\n            client.setEndpointUri(endpoint.getEndpointURI().toString());\n            client.addInHandler(new MuleHeadersInHandler());\n            client.addOutHandler(new MuleHeadersOutHandler());\n        }\n    }","id":99839,"modified_method":"protected void doConnect(final UMOImmutableEndpoint endpoint) throws Exception\n    {\n        if (clientPool == null) {\n            final XFire xfire = connector.getXfire();\n            final String serviceName = getServiceName(endpoint);\n            final Service service = xfire.getServiceRegistry().getService(serviceName);\n\n            if (service == null) {\n                throw new FatalConnectException(new Message(\"xfire\", 8, serviceName), this);\n            }\n\n            try {\n                clientPool = new StackObjectPool(new BasePoolableObjectFactory()\n                {\n                    public Object makeObject() throws Exception\n                    {\n                        Client client = new Client(new MuleUniversalTransport(), service, endpoint\n                                .getEndpointURI().toString());\n                        client.setXFire(xfire);\n                        client.setEndpointUri(endpoint.getEndpointURI().toString());\n                        client.addInHandler(new MuleHeadersInHandler());\n                        client.addOutHandler(new MuleHeadersOutHandler());\n                        return client;\n                    }\n                });\n                clientPool.addObject();\n                clientPool.addObject();\n            }\n            catch (Exception ex) {\n                disconnect();\n                throw ex;\n            }\n        }\n    }","commit_id":"fa1263b8c56f253bf0c4846ac97ce393cd2e73b5","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void doDispatch(UMOEvent event) throws Exception\n    {\n        if (client.getTimeout() != event.getTimeout()) {\n            client.setTimeout(event.getTimeout());\n        }\n        client.setProperty(MuleProperties.MULE_EVENT_PROPERTY, event);\n        String method = getMethod(event);\n        client.invoke(method, getArgs(event));\n    }","id":99840,"modified_method":"protected void doDispatch(UMOEvent event) throws Exception\n    {\n        Client client = null;\n\n        try {\n            client = (Client)clientPool.borrowObject();\n            client.setTimeout(event.getTimeout());\n            client.setProperty(MuleProperties.MULE_EVENT_PROPERTY, event);\n            client.invoke(getMethod(event), getArgs(event));\n        }\n        finally {\n            if (client != null) {\n                clientPool.returnObject(client);\n            }\n        }\n    }","commit_id":"fa1263b8c56f253bf0c4846ac97ce393cd2e73b5","url":"https://github.com/mulesoft/mule"},{"original_method":"protected String getMethod(UMOEvent event) throws DispatchException\n    {\n        UMOEndpointURI endpointUri = event.getEndpoint().getEndpointURI();\n        String method = (String)endpointUri.getParams().remove(\"method\");\n\n        if (method == null) {\n            method = (String)event.getEndpoint().getProperties().get(\"method\");\n            if (method == null) {\n                throw new DispatchException(new org.mule.config.i18n.Message(\"soap\", 4), event\n                        .getMessage(), event.getEndpoint());\n            }\n        }\n        return method;\n    }","id":99841,"modified_method":"protected String getMethod(UMOEvent event) throws DispatchException\n    {\n        UMOEndpointURI endpointUri = event.getEndpoint().getEndpointURI();\n        String method = (String)endpointUri.getParams().get(\"method\");\n\n        if (method == null) {\n            method = (String)event.getEndpoint().getProperties().get(\"method\");\n            if (method == null) {\n                throw new DispatchException(new org.mule.config.i18n.Message(\"soap\", 4), event\n                        .getMessage(), event.getEndpoint());\n            }\n        }\n        return method;\n    }","commit_id":"fa1263b8c56f253bf0c4846ac97ce393cd2e73b5","url":"https://github.com/mulesoft/mule"},{"original_method":"protected Object[] getArgs(UMOEvent event) throws TransformerException\n    {\n        Object payload = event.getTransformedMessage();\n        Object[] args;\n        if (payload instanceof Object[]) {\n            args = (Object[])payload;\n        }\n        else {\n            args = new Object[]{payload};\n        }\n        if (event.getMessage().getAttachmentNames() != null\n                && event.getMessage().getAttachmentNames().size() > 0) {\n            ArrayList attachments = new ArrayList();\n            Iterator i = event.getMessage().getAttachmentNames().iterator();\n            while (i.hasNext()) {\n                attachments.add(event.getMessage().getAttachment((String)i.next()));\n            }\n            ArrayList temp = new ArrayList(Arrays.asList(args));\n            temp.add(attachments.toArray(new DataHandler[0]));\n            args = temp.toArray();\n        }\n        return args;\n    }","id":99842,"modified_method":"protected Object[] getArgs(UMOEvent event) throws TransformerException\n    {\n        Object payload = event.getTransformedMessage();\n        Object[] args;\n\n        if (payload instanceof Object[]) {\n            args = (Object[])payload;\n        }\n        else {\n            args = new Object[]{payload};\n        }\n\n        UMOMessage message = event.getMessage();\n        Set attachmentNames = message.getAttachmentNames();\n        if (attachmentNames != null && !attachmentNames.isEmpty()) {\n            ArrayList attachments = new ArrayList();\n            for (Iterator i = attachmentNames.iterator(); i.hasNext();) {\n                attachments.add(message.getAttachment((String)i.next()));\n            }\n            ArrayList temp = new ArrayList(Arrays.asList(args));\n            temp.add(attachments.toArray(new DataHandler[0]));\n            args = temp.toArray();\n        }\n\n        return args;\n    }","commit_id":"fa1263b8c56f253bf0c4846ac97ce393cd2e73b5","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void doConnect(UMOImmutableEndpoint endpoint) throws Exception {\n\n        if (client == null) {\n            String wsdlUrl = endpoint.getEndpointURI().getAddress();\n            String serviceName = wsdlUrl.substring(0, wsdlUrl.lastIndexOf(\"?\"));\n\n            XFire xfire = connector.getXfire();\n            Service service = xfire.getServiceRegistry().getService(new QName(serviceName));\n            if (service != null) {\n                client = new Client(new MuleUniversalTransport(), service, wsdlUrl);\n            }\n            else {\n                client = new Client(new URL(wsdlUrl));\n                client.getService().setName(new QName(serviceName));\n                xfire.getServiceRegistry().register(client.getService());\n            }\n\n            client.setXFire(xfire);\n        }\n\n        client.setEndpointUri(endpoint.getEndpointURI().toString());\n    }","id":99843,"modified_method":"protected void doConnect(final UMOImmutableEndpoint endpoint) throws Exception\n    {\n        try {\n            clientPool = new StackObjectPool(new BasePoolableObjectFactory()\n            {\n                public Object makeObject() throws Exception\n                {\n                    XFire xfire = connector.getXfire();\n                    String wsdlUrl = endpoint.getEndpointURI().getAddress();\n                    String serviceName = wsdlUrl.substring(0, wsdlUrl.lastIndexOf('?'));\n                    Service service = xfire.getServiceRegistry().getService(new QName(serviceName));\n                    Client client;\n\n                    if (service != null) {\n                        client = new Client(new MuleUniversalTransport(), service, wsdlUrl);\n                    }\n                    else {\n                        client = new Client(new URL(wsdlUrl));\n                        client.getService().setName(new QName(serviceName));\n                        xfire.getServiceRegistry().register(client.getService());\n                    }\n\n                    client.setXFire(xfire);\n                    client.setEndpointUri(endpoint.getEndpointURI().toString());\n                    return client;\n                }\n            });\n            clientPool.addObject();\n            clientPool.addObject();\n        }\n        catch (Exception ex) {\n            disconnect();\n            throw ex;\n        }\n    }","commit_id":"fa1263b8c56f253bf0c4846ac97ce393cd2e73b5","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * @see org.opencms.workplace.editors.CmsDefaultPageEditor#buildGalleryButtons(CmsEditorDisplayOptions, int, Properties)\n     */\n    public String buildGalleryButtons(CmsEditorDisplayOptions options, int buttonStyle, Properties displayOptions) {\n\n        StringBuffer result = new StringBuffer();        \n        Iterator galleries = OpenCms.getWorkplaceManager().getGalleries().entrySet().iterator();\n        while (galleries.hasNext()) {\n            Entry galleryInfo = (Entry)galleries.next();\n            int typeId = ((CmsResourceTypeFolderExtended)galleryInfo.getValue()).getTypeId();\n            String galleryType = ((String)galleryInfo.getKey()).replaceFirst(\"gallery\", \"\");\n            if (options.showElement(\"gallery.\" + galleryType, displayOptions)) {\n                result.append(button(\"javascript:doEditHTML(\" + (typeId+50) + \");\", null, galleryType + \"gallery\", \"button.\" + galleryType + \"list\", buttonStyle));\n            }\n        }\n        return result.toString();\n    }","id":99844,"modified_method":"/**\n     * @see org.opencms.workplace.editors.CmsDefaultPageEditor#buildGalleryButtons(CmsEditorDisplayOptions, int, Properties)\n     */\n    public String buildGalleryButtons(CmsEditorDisplayOptions options, int buttonStyle, Properties displayOptions) {\n\n        StringBuffer result = new StringBuffer();   \n        List l = new ArrayList(OpenCms.getWorkplaceManager().getGalleries().keySet());\n        Collections.sort(l);\n        Iterator galleries = l.iterator();\n        for (int i = C_JS_GALLERY_ACTION_START; galleries.hasNext(); i++) {\n            String galleryType = ((String)galleries.next()).replaceFirst(\"gallery\", \"\");\n            if (options.showElement(\"gallery.\" + galleryType, displayOptions)) {\n                result.append(button(\"javascript:doEditHTML(\" + i + \");\", null, galleryType + \"gallery\", \"button.\" + galleryType + \"list\", buttonStyle));\n            }\n        }\n        return result.toString();\n    }","commit_id":"122ee5a0e0dc95a99387899007c3c76f56228ba6","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private void tryToUpgradeStores()\n    {\n        new StoreUpgrader( getConfig() ).attemptUpgrade( getStorageFileName() );\n    }","id":99845,"modified_method":"private void tryToUpgradeStores()\n    {\n        new StoreUpgrader( getConfig(), new ConfigMapUpgradeConfiguration(getConfig()) ).attemptUpgrade( getStorageFileName() );\n    }","commit_id":"0cfa32e4ea35bb8586b6fa91ff3961d5af14619a","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void attemptUpgrade( String storageFileName )\n    {\n        if ( !configSaysOkToUpgrade() )\n        {\n            throw new UpgradeNotAllowedByConfigurationException(\n                    String.format( \"To enable automatic upgrade, please set %s in configuration properties\",\n                            Config.ALLOW_STORE_UPGRADE ) );\n        }\n        try\n        {\n            File workingDirectory = new File( storageFileName ).getParentFile();\n\n            if ( !new UpgradableStoreVersions().storeFilesUpgradeable( workingDirectory ) )\n            {\n                throw new UnableToUpgradeException();\n            }\n\n            File upgradeDirectory = new File( workingDirectory, \"upgrade\" );\n            File backupDirectory = new File( workingDirectory, \"upgrade_backup\" );\n            upgradeDirectory.mkdir();\n\n            String upgradeFileName = new File( upgradeDirectory, NeoStore.DEFAULT_NAME ).getPath();\n            Map<Object, Object> upgradeConfig = new HashMap<Object, Object>( originalConfig );\n            upgradeConfig.put( \"neo_store\", upgradeFileName );\n\n            NeoStore.createStore( upgradeFileName, upgradeConfig );\n            NeoStore neoStore = new NeoStore( upgradeConfig );\n            new StoreMigrator( new LegacyStore( storageFileName ) ).migrateTo( neoStore );\n            neoStore.close();\n\n            backupDirectory.mkdir();\n            StoreFiles.move( workingDirectory, backupDirectory );\n            LogFiles.move( workingDirectory, backupDirectory );\n            /*\n             * Keep an intact copy of the messages log, but let the new db\n             * append there.\n             */\n            FileUtils.copyFile( new File( workingDirectory, \"messages.log\" ),\n                    new File( backupDirectory, \"messages.log\" ) );\n\n            StoreFiles.move( upgradeDirectory, workingDirectory );\n            LogFiles.move( upgradeDirectory, workingDirectory );\n\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","id":99846,"modified_method":"public void attemptUpgrade( String storageFileName )\n    {\n        upgradeConfiguration.checkConfigurationAllowsAutomaticUpgrade();\n        try\n        {\n            File workingDirectory = new File( storageFileName ).getParentFile();\n\n            if ( !new UpgradableStoreVersions().storeFilesUpgradeable( workingDirectory ) )\n            {\n                throw new UnableToUpgradeException();\n            }\n\n            File upgradeDirectory = new File( workingDirectory, \"upgrade\" );\n            File backupDirectory = new File( workingDirectory, \"upgrade_backup\" );\n            upgradeDirectory.mkdir();\n\n            String upgradeFileName = new File( upgradeDirectory, NeoStore.DEFAULT_NAME ).getPath();\n            Map<Object, Object> upgradeConfig = new HashMap<Object, Object>( originalConfig );\n            upgradeConfig.put( \"neo_store\", upgradeFileName );\n\n            NeoStore.createStore( upgradeFileName, upgradeConfig );\n            NeoStore neoStore = new NeoStore( upgradeConfig );\n            new StoreMigrator( new LegacyStore( storageFileName ) ).migrateTo( neoStore );\n            neoStore.close();\n\n            backupDirectory.mkdir();\n            StoreFiles.move( workingDirectory, backupDirectory );\n            LogFiles.move( workingDirectory, backupDirectory );\n            /*\n             * Keep an intact copy of the messages log, but let the new db\n             * append there.\n             */\n            FileUtils.copyFile( new File( workingDirectory, \"messages.log\" ),\n                    new File( backupDirectory, \"messages.log\" ) );\n\n            StoreFiles.move( upgradeDirectory, workingDirectory );\n            LogFiles.move( upgradeDirectory, workingDirectory );\n\n        } catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"0cfa32e4ea35bb8586b6fa91ff3961d5af14619a","url":"https://github.com/neo4j/neo4j"},{"original_method":"public StoreUpgrader( Map<?, ?> originalConfig )\n    {\n        this.originalConfig = originalConfig;\n    }","id":99847,"modified_method":"public StoreUpgrader( Map<?, ?> originalConfig, UpgradeConfiguration upgradeConfiguration )\n    {\n        this.originalConfig = originalConfig;\n        this.upgradeConfiguration = upgradeConfiguration;\n    }","commit_id":"0cfa32e4ea35bb8586b6fa91ff3961d5af14619a","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldLeaveAllFilesUntouchedIfWrongVersionNumberFound() throws IOException\n    {\n        File workingDirectory = new File( \"target/\" + StoreUpgraderTest.class.getSimpleName() );\n        File comparisonDirectory = new File( \"target/\" + StoreUpgraderTest.class.getSimpleName() + \"-comparison\" );\n        prepareSampleLegacyDatabase( workingDirectory );\n\n        HashMap config = defaultConfig();\n        config.put( Config.ALLOW_STORE_UPGRADE, \"true\" );\n\n        changeVersionNumber( new File( workingDirectory, \"neostore.nodestore.db\" ), \"v0.9.5\" );\n        deleteRecursively( comparisonDirectory );\n        copyRecursively( workingDirectory, comparisonDirectory );\n\n        try\n        {\n            new StoreUpgrader( config ).attemptUpgrade( new File( workingDirectory, NeoStore.DEFAULT_NAME ).getPath() );\n            fail( \"Should throw exception\" );\n        }\n        catch ( StoreUpgrader.UnableToUpgradeException e )\n        {\n            // expected\n        }\n\n        verifyFilesHaveSameContent( comparisonDirectory, workingDirectory );\n    }","id":99848,"modified_method":"@Test\n    public void shouldLeaveAllFilesUntouchedIfWrongVersionNumberFound() throws IOException\n    {\n        File workingDirectory = new File( \"target/\" + StoreUpgraderTest.class.getSimpleName() );\n        File comparisonDirectory = new File( \"target/\" + StoreUpgraderTest.class.getSimpleName() + \"-comparison\" );\n        prepareSampleLegacyDatabase( workingDirectory );\n\n        changeVersionNumber( new File( workingDirectory, \"neostore.nodestore.db\" ), \"v0.9.5\" );\n        deleteRecursively( comparisonDirectory );\n        copyRecursively( workingDirectory, comparisonDirectory );\n\n        try\n        {\n            new StoreUpgrader( defaultConfig(), new AlwaysAllowedUpgradeConfiguration() ).attemptUpgrade( new File( workingDirectory, NeoStore.DEFAULT_NAME ).getPath() );\n            fail( \"Should throw exception\" );\n        } catch ( StoreUpgrader.UnableToUpgradeException e )\n        {\n            // expected\n        }\n\n        verifyFilesHaveSameContent( comparisonDirectory, workingDirectory );\n    }","commit_id":"0cfa32e4ea35bb8586b6fa91ff3961d5af14619a","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldUpgradeAnOldFormatStore() throws IOException\n    {\n        File workingDirectory = new File( \"target/\" + StoreUpgraderTest.class.getSimpleName() );\n        prepareSampleLegacyDatabase( workingDirectory );\n\n        assertTrue( allStoreFilesHaveVersion( workingDirectory, \"v0.9.9\" ) );\n\n        HashMap config = defaultConfig();\n        config.put( Config.ALLOW_STORE_UPGRADE, \"true\" );\n\n        new StoreUpgrader( config ).attemptUpgrade( new File( workingDirectory, NeoStore.DEFAULT_NAME ).getPath() );\n\n        assertTrue( allStoreFilesHaveVersion( workingDirectory, ALL_STORES_VERSION ) );\n    }","id":99849,"modified_method":"@Test\n    public void shouldUpgradeAnOldFormatStore() throws IOException\n    {\n        File workingDirectory = new File( \"target/\" + StoreUpgraderTest.class.getSimpleName() );\n        prepareSampleLegacyDatabase( workingDirectory );\n\n        assertTrue( allStoreFilesHaveVersion( workingDirectory, \"v0.9.9\" ) );\n\n        new StoreUpgrader( defaultConfig(), new AlwaysAllowedUpgradeConfiguration() ).attemptUpgrade( new File( workingDirectory, NeoStore.DEFAULT_NAME ).getPath() );\n\n        assertTrue( allStoreFilesHaveVersion( workingDirectory, ALL_STORES_VERSION ) );\n    }","commit_id":"0cfa32e4ea35bb8586b6fa91ff3961d5af14619a","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldRefuseToUpgradeIfAnyOfTheStoresWeNotShutDownCleanly() throws IOException\n    {\n        File workingDirectory = new File( \"target/\" + StoreUpgraderTest.class.getSimpleName() );\n        File comparisonDirectory = new File( \"target/\" + StoreUpgraderTest.class.getSimpleName() + \"-comparison\" );\n        prepareSampleLegacyDatabase( workingDirectory );\n\n        HashMap config = defaultConfig();\n        config.put( Config.ALLOW_STORE_UPGRADE, \"true\" );\n\n        truncateFile( new File( workingDirectory, \"neostore.propertystore.db.index.keys\" ), \"StringPropertyStore v0.9.9\" );\n        deleteRecursively( comparisonDirectory );\n        copyRecursively( workingDirectory, comparisonDirectory );\n\n        try\n        {\n            new StoreUpgrader( config ).attemptUpgrade( new File( workingDirectory, NeoStore.DEFAULT_NAME ).getPath() );\n            fail( \"Should throw exception\" );\n        }\n        catch ( StoreUpgrader.UnableToUpgradeException e )\n        {\n            // expected\n        }\n\n        verifyFilesHaveSameContent( comparisonDirectory, workingDirectory );\n    }","id":99850,"modified_method":"@Test\n    public void shouldRefuseToUpgradeIfAnyOfTheStoresWeNotShutDownCleanly() throws IOException\n    {\n        File workingDirectory = new File( \"target/\" + StoreUpgraderTest.class.getSimpleName() );\n        File comparisonDirectory = new File( \"target/\" + StoreUpgraderTest.class.getSimpleName() + \"-comparison\" );\n        prepareSampleLegacyDatabase( workingDirectory );\n\n        truncateFile( new File( workingDirectory, \"neostore.propertystore.db.index.keys\" ), \"StringPropertyStore v0.9.9\" );\n        deleteRecursively( comparisonDirectory );\n        copyRecursively( workingDirectory, comparisonDirectory );\n\n        try\n        {\n            new StoreUpgrader( defaultConfig(), new AlwaysAllowedUpgradeConfiguration() ).attemptUpgrade( new File( workingDirectory, NeoStore.DEFAULT_NAME ).getPath() );\n            fail( \"Should throw exception\" );\n        } catch ( StoreUpgrader.UnableToUpgradeException e )\n        {\n            // expected\n        }\n\n        verifyFilesHaveSameContent( comparisonDirectory, workingDirectory );\n    }","commit_id":"0cfa32e4ea35bb8586b6fa91ff3961d5af14619a","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldLeaveACopyOfOriginalStoreFilesInBackupDirectory() throws IOException\n    {\n        File workingDirectory = new File( \"target/\" + StoreUpgraderTest.class.getSimpleName() );\n        prepareSampleLegacyDatabase( workingDirectory );\n\n        HashMap config = defaultConfig();\n        config.put( Config.ALLOW_STORE_UPGRADE, \"true\" );\n\n        new StoreUpgrader( config ).attemptUpgrade( new File( workingDirectory, NeoStore.DEFAULT_NAME ).getPath() );\n\n        verifyFilesHaveSameContent( findOldFormatStoreDirectory(), new File( workingDirectory, \"upgrade_backup\" ) );\n    }","id":99851,"modified_method":"@Test\n    public void shouldLeaveACopyOfOriginalStoreFilesInBackupDirectory() throws IOException\n    {\n        File workingDirectory = new File( \"target/\" + StoreUpgraderTest.class.getSimpleName() );\n        prepareSampleLegacyDatabase( workingDirectory );\n\n        new StoreUpgrader( defaultConfig(), new AlwaysAllowedUpgradeConfiguration() ).attemptUpgrade( new File( workingDirectory, NeoStore.DEFAULT_NAME ).getPath() );\n\n        verifyFilesHaveSameContent( findOldFormatStoreDirectory(), new File( workingDirectory, \"upgrade_backup\" ) );\n    }","commit_id":"0cfa32e4ea35bb8586b6fa91ff3961d5af14619a","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldFailToUpgradeIfConfigParameterIsMissing() throws IOException\n    {\n        File workingDirectory = new File( \"target/\" + StoreUpgraderTest.class.getSimpleName() );\n        prepareSampleLegacyDatabase( workingDirectory );\n\n        HashMap config = defaultConfig();\n        assertFalse( config.containsKey( Config.ALLOW_STORE_UPGRADE ) );\n\n        try {\n            new StoreUpgrader( config ).attemptUpgrade( new File( workingDirectory, NeoStore.DEFAULT_NAME ).getPath() );\n            fail( \"Should throw exception\" );\n        }\n        catch ( UpgradeNotAllowedByConfigurationException e )\n        {\n            // expected\n        }\n    }","id":99852,"modified_method":"@Test\n    public void shouldFailToUpgradeIfConfigParameterIsMissing() throws IOException\n    {\n        File workingDirectory = new File( \"target/\" + StoreUpgraderTest.class.getSimpleName() );\n        prepareSampleLegacyDatabase( workingDirectory );\n\n        HashMap config = defaultConfig();\n        assertFalse( config.containsKey( Config.ALLOW_STORE_UPGRADE ) );\n\n        try\n        {\n            new StoreUpgrader( config, new ConfigMapUpgradeConfiguration( config ) ).attemptUpgrade( new File( workingDirectory, NeoStore.DEFAULT_NAME ).getPath() );\n            fail( \"Should throw exception\" );\n        } catch ( UpgradeNotAllowedByConfigurationException e )\n        {\n            // expected\n        }\n    }","commit_id":"0cfa32e4ea35bb8586b6fa91ff3961d5af14619a","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void testSnapshot(ModelNode addr) throws Exception {\n        final DomainClient masterClient = domainMasterLifecycleUtil.getDomainClient();\n\n        ModelNode snapshotOperation = new ModelNode();\n        snapshotOperation.get(OP).set(SnapshotTakeHandler.OPERATION_NAME);\n        snapshotOperation.get(OP_ADDR).set(addr);\n        ModelNode response = masterClient.execute(snapshotOperation);\n        final String snapshot = validateResponse(response).get(DOMAIN_RESULTS).asString();\n        Assert.assertNotNull(snapshot);\n        Assert.assertFalse(snapshot.isEmpty());\n\n        ModelNode listSnapshotOperation = new ModelNode();\n        listSnapshotOperation.get(OP).set(SnapshotListHandler.OPERATION_NAME);\n        listSnapshotOperation.get(OP_ADDR).set(addr);\n        ModelNode listResult = validateResponse(masterClient.execute(listSnapshotOperation)).get(DOMAIN_RESULTS);\n        Set<String> snapshots = new HashSet<String>();\n        for (ModelNode curr : listResult.get(NAMES).asList()) {\n            snapshots.add(listResult.get(DIRECTORY).asString() + \"/\" + curr.asString());\n        }\n\n        Assert.assertTrue(snapshots.contains(snapshot));\n\n        ModelNode deleteSnapshotOperation = new ModelNode();\n        deleteSnapshotOperation.get(OP).set(SnapshotDeleteHandler.OPERATION_NAME);\n        deleteSnapshotOperation.get(OP_ADDR).set(addr);\n        deleteSnapshotOperation.get(NAME).set(snapshot.substring(snapshot.lastIndexOf(\"/\")  + 1));\n        validateResponse(masterClient.execute(deleteSnapshotOperation));\n\n        listResult = validateResponse(masterClient.execute(listSnapshotOperation)).get(DOMAIN_RESULTS);\n        snapshots = new HashSet<String>();\n        for (ModelNode curr : listResult.get(NAMES).asList()) {\n            snapshots.add(listResult.get(DIRECTORY).asString() + \"/\" + curr.asString());\n        }\n\n        Assert.assertFalse(snapshots.contains(snapshot));\n    }","id":99853,"modified_method":"private void testSnapshot(ModelNode addr) throws Exception {\n        final DomainClient masterClient = domainMasterLifecycleUtil.getDomainClient();\n\n        ModelNode snapshotOperation = new ModelNode();\n        snapshotOperation.get(OP).set(SnapshotTakeHandler.OPERATION_NAME);\n        snapshotOperation.get(OP_ADDR).set(addr);\n        ModelNode response = masterClient.execute(snapshotOperation);\n        final String snapshot = validateResponse(response).asString();\n        Assert.assertNotNull(snapshot);\n        Assert.assertFalse(snapshot.isEmpty());\n\n        ModelNode listSnapshotOperation = new ModelNode();\n        listSnapshotOperation.get(OP).set(SnapshotListHandler.OPERATION_NAME);\n        listSnapshotOperation.get(OP_ADDR).set(addr);\n        ModelNode listResult = validateResponse(masterClient.execute(listSnapshotOperation));\n        Set<String> snapshots = new HashSet<String>();\n        for (ModelNode curr : listResult.get(NAMES).asList()) {\n            snapshots.add(listResult.get(DIRECTORY).asString() + \"/\" + curr.asString());\n        }\n\n        Assert.assertTrue(snapshots.contains(snapshot));\n\n        ModelNode deleteSnapshotOperation = new ModelNode();\n        deleteSnapshotOperation.get(OP).set(SnapshotDeleteHandler.OPERATION_NAME);\n        deleteSnapshotOperation.get(OP_ADDR).set(addr);\n        deleteSnapshotOperation.get(NAME).set(snapshot.substring(snapshot.lastIndexOf(\"/\")  + 1));\n        validateResponse(masterClient.execute(deleteSnapshotOperation));\n\n        listResult = validateResponse(masterClient.execute(listSnapshotOperation));\n        snapshots = new HashSet<String>();\n        for (ModelNode curr : listResult.get(NAMES).asList()) {\n            snapshots.add(listResult.get(DIRECTORY).asString() + \"/\" + curr.asString());\n        }\n\n        Assert.assertFalse(snapshots.contains(snapshot));\n    }","commit_id":"2bb4d366da9be3f9dbc11558ec7db8c10008eb00","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void testCannotInvokeManagedServerOperationsComposite(String host, String server, ModelNode stepAddress) throws Exception {\n        final DomainClient masterClient = domainMasterLifecycleUtil.getDomainClient();\n\n        ModelNode composite = new ModelNode();\n        composite.get(OP).set(CompositeOperationHandler.NAME);\n        composite.get(OP_ADDR).add(HOST, host);\n        composite.get(OP_ADDR).add(SERVER, server);\n        composite.get(OPERATION_HEADERS, ROLLBACK_ON_RUNTIME_FAILURE).set(false);\n\n        ModelNode goodServerOp = new ModelNode();\n        goodServerOp.get(OP).set(READ_RESOURCE_OPERATION);\n        goodServerOp.get(OP_ADDR).set(stepAddress);\n        composite.get(STEPS).add(goodServerOp);\n        composite.get(STEPS).add(getAddThreadFactoryOperation(stepAddress.clone().add(\"thread-factory\", \"test-pool-123abc\")));\n\n        ModelNode result = masterClient.execute(composite);\n\n        validateFailedResponse(result);\n\n        String errorCode = getNotAuthorizedErrorCode();\n\n        List<Property> steps = result.get(RESULT).asPropertyList();\n        Assert.assertEquals(2, steps.size());\n        int i = 0;\n        for (Property property : steps) {\n            ModelNode stepResult = property.getValue();\n            Assert.assertEquals(FAILED, stepResult.get(OUTCOME).asString());\n            if (i == 0) {\n                Assert.assertFalse(stepResult.hasDefined(FAILURE_DESCRIPTION));\n            }\n            if (i++ == 1) {\n                ModelNode desc = validateFailedResponse(stepResult);\n                Assert.assertTrue(desc.toString() + \" does not contain \" + errorCode, desc.toString().contains(errorCode));\n            }\n            i++;\n        }\n    }","id":99854,"modified_method":"private void testCannotInvokeManagedServerOperationsComposite(String host, String server, ModelNode stepAddress) throws Exception {\n        final DomainClient masterClient = domainMasterLifecycleUtil.getDomainClient();\n\n        ModelNode composite = new ModelNode();\n        composite.get(OP).set(CompositeOperationHandler.NAME);\n        composite.get(OP_ADDR).add(HOST, host);\n        composite.get(OP_ADDR).add(SERVER, server);\n        composite.get(OPERATION_HEADERS, ROLLBACK_ON_RUNTIME_FAILURE).set(false);\n\n        ModelNode goodServerOp = new ModelNode();\n        goodServerOp.get(OP).set(READ_RESOURCE_OPERATION);\n        goodServerOp.get(OP_ADDR).set(stepAddress);\n        composite.get(STEPS).add(goodServerOp);\n        composite.get(STEPS).add(getAddThreadFactoryOperation(stepAddress.clone().add(\"thread-factory\", \"test-pool-123abc\")));\n\n        ModelNode result = masterClient.execute(composite);\n\n        validateFailedResponse(result);\n\n        Set<String> keys = new HashSet<String>(result.get(RESULT).keys());\n        keys.remove(SERVER_GROUPS);\n        Assert.assertEquals(2, keys.size());\n\n        String errorCode = getNotAuthorizedErrorCode();\n        List<Property> steps = result.get(RESULT).asPropertyList();\n        int i = 0;\n        for (Property property : steps) {\n            if (property.getName().equals(SERVER_GROUPS)) {\n                continue;\n            }\n            ModelNode stepResult = property.getValue();\n            Assert.assertEquals(FAILED, stepResult.get(OUTCOME).asString());\n            if (i == 0) {\n                Assert.assertFalse(stepResult.hasDefined(FAILURE_DESCRIPTION));\n            }\n            if (i++ == 1) {\n                ModelNode desc = validateFailedResponse(stepResult);\n                Assert.assertTrue(desc.toString() + \" does not contain \" + errorCode, desc.toString().contains(errorCode));\n            }\n            i++;\n        }\n    }","commit_id":"2bb4d366da9be3f9dbc11558ec7db8c10008eb00","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void testCannotInvokeManagedServerOperationsComposite(ModelNode stepAddress) throws Exception {\n        final DomainClient masterClient = domainMasterLifecycleUtil.getDomainClient();\n\n        ModelNode composite = new ModelNode();\n        composite.get(OP).set(CompositeOperationHandler.NAME);\n        composite.get(OP_ADDR).setEmptyList();\n        composite.get(OPERATION_HEADERS, ROLLBACK_ON_RUNTIME_FAILURE).set(false);\n\n        ModelNode goodServerOp = new ModelNode();\n        goodServerOp.get(OP).set(READ_RESOURCE_OPERATION);\n        goodServerOp.get(OP_ADDR).set(stepAddress);\n        composite.get(STEPS).add(goodServerOp);\n        composite.get(STEPS).add(getAddThreadFactoryOperation(stepAddress.clone().add(\"thread-factory\", \"test-pool-123abc\")));\n\n        ModelNode result = masterClient.execute(composite);\n\n        validateFailedResponse(result);\n\n        String errorCode = getNotAuthorizedErrorCode();\n\n        List<Property> steps = result.get(RESULT, DOMAIN_RESULTS).asPropertyList();\n        Assert.assertEquals(2, steps.size());\n        int i = 0;\n        for (Property property : steps) {\n            ModelNode stepResult = property.getValue();\n            Assert.assertEquals(FAILED, stepResult.get(OUTCOME).asString());\n            if (i == 0) {\n                Assert.assertFalse(stepResult.hasDefined(FAILURE_DESCRIPTION));\n            }\n            if (i++ == 1) {\n                ModelNode desc = validateFailedResponse(stepResult);\n                Assert.assertTrue(desc.toString() + \" does not contain \" + errorCode, desc.toString().contains(errorCode));\n            }\n            i++;\n        }\n    }","id":99855,"modified_method":"private void testCannotInvokeManagedServerOperationsComposite(ModelNode stepAddress) throws Exception {\n        final DomainClient masterClient = domainMasterLifecycleUtil.getDomainClient();\n\n        ModelNode composite = new ModelNode();\n        composite.get(OP).set(CompositeOperationHandler.NAME);\n        composite.get(OP_ADDR).setEmptyList();\n        composite.get(OPERATION_HEADERS, ROLLBACK_ON_RUNTIME_FAILURE).set(false);\n\n        ModelNode goodServerOp = new ModelNode();\n        goodServerOp.get(OP).set(READ_RESOURCE_OPERATION);\n        goodServerOp.get(OP_ADDR).set(stepAddress);\n        composite.get(STEPS).add(goodServerOp);\n        composite.get(STEPS).add(getAddThreadFactoryOperation(stepAddress.clone().add(\"thread-factory\", \"test-pool-123abc\")));\n\n        ModelNode result = masterClient.execute(composite);\n\n        validateFailedResponse(result);\n\n        Set<String> keys = new HashSet<String>(result.get(RESULT).keys());\n        keys.remove(SERVER_GROUPS);\n        Assert.assertEquals(2, keys.size());\n\n        String errorCode = getNotAuthorizedErrorCode();\n        List<Property> steps = result.get(RESULT).asPropertyList();\n        int i = 0;\n        for (Property property : steps) {\n            if (property.getName().equals(SERVER_GROUPS)) {\n                continue;\n            }\n            ModelNode stepResult = property.getValue();\n            Assert.assertEquals(FAILED, stepResult.get(OUTCOME).asString());\n            if (i == 0) {\n                Assert.assertFalse(stepResult.hasDefined(FAILURE_DESCRIPTION));\n            }\n            if (i++ == 1) {\n                ModelNode desc = validateFailedResponse(stepResult);\n                Assert.assertTrue(desc.toString() + \" does not contain \" + errorCode, desc.toString().contains(errorCode));\n            }\n            i++;\n        }\n    }","commit_id":"2bb4d366da9be3f9dbc11558ec7db8c10008eb00","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n        context.completeStep();\n\n        // On the way out, fix up the response\n        final boolean isDomain = isDomainOperation(operation);\n        boolean shouldContinue = collectDomainFailure(context, isDomain);\n        shouldContinue = shouldContinue && collectContextFailure(context, isDomain);\n        shouldContinue = shouldContinue && collectHostFailures(context, isDomain);\n        if(shouldContinue){\n            ModelNode contextResult = context.getResult();\n            contextResult.setEmptyObject(); // clear out any old data\n            contextResult.get(DOMAIN_RESULTS).set(getDomainResults(operation));\n            if (domainOperationContext.getServerResults().size() > 0) {\n                populateServerGroupResults(context, context.getResult());\n            }\n        }\n    }","id":99856,"modified_method":"@Override\n    public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n        context.completeStep();\n\n        // On the way out, fix up the response\n        final boolean isDomain = isDomainOperation(operation);\n        boolean shouldContinue = collectDomainFailure(context, isDomain);\n        shouldContinue = shouldContinue && collectContextFailure(context, isDomain);\n        shouldContinue = shouldContinue && collectHostFailures(context, isDomain);\n        if(shouldContinue){\n            ModelNode contextResult = context.getResult();\n            contextResult.setEmptyObject(); // clear out any old data\n            contextResult.set(getDomainResults(operation));\n            if (domainOperationContext.getServerResults().size() > 0) {\n                populateServerGroupResults(context, context.getResult());\n            }\n        }\n    }","commit_id":"2bb4d366da9be3f9dbc11558ec7db8c10008eb00","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testCompositeHostReadAccess() throws IOException {\n\n        ModelNode masterRequest = getEmptyOperation(COMPOSITE, null);\n        ModelNode steps = masterRequest.get(STEPS);\n        steps.add(getReadAttributeOperation(MASTER_ROOT_ADDRESS, NAME));\n        steps.add(getReadAttributeOperation(MASTER_INTERFACE_ADDRESS, INET_ADDRESS));\n        masterRequest.protect();\n\n        ModelNode response = masterClient.execute(masterRequest);\n        System.out.println(response);\n        ModelNode returnVal = validateResponse(response).get(DOMAIN_RESULTS);\n        ModelNode name = validateResponse(returnVal.get(\"step-1\"));\n        Assert.assertEquals(\"master\", name.asString());\n        ModelNode inetAddress = validateResponse(returnVal.get(\"step-2\"));\n        Assert.assertEquals(ModelType.EXPRESSION, inetAddress.getType());\n\n        ModelNode slaveRequest = getEmptyOperation(COMPOSITE, null);\n        steps = slaveRequest.get(STEPS);\n        steps.add(getReadAttributeOperation(SLAVE_ROOT_ADDRESS, NAME));\n        steps.add(getReadAttributeOperation(SLAVE_INTERFACE_ADDRESS, INET_ADDRESS));\n        masterRequest.protect();\n\n        response = slaveClient.execute(slaveRequest);\n        System.out.println(response);\n        ModelNode slaveReturnVal = validateResponse(response).get(DOMAIN_RESULTS);\n        name = validateResponse(slaveReturnVal.get(\"step-1\"));\n        Assert.assertEquals(\"slave\", name.asString());\n        inetAddress = validateResponse(slaveReturnVal.get(\"step-2\"));\n        Assert.assertEquals(ModelType.EXPRESSION, inetAddress.getType());\n\n        // Check we get the same thing via the master\n        response = masterClient.execute(slaveRequest);\n        returnVal = validateResponse(response).get(DOMAIN_RESULTS);\n        Assert.assertEquals(returnVal, slaveReturnVal);\n\n        // Can't access the master via the slave\n        response = slaveClient.execute(masterRequest);\n        validateFailedResponse(response);\n    }","id":99857,"modified_method":"@Test\n    public void testCompositeHostReadAccess() throws IOException {\n\n        ModelNode masterRequest = getEmptyOperation(COMPOSITE, null);\n        ModelNode steps = masterRequest.get(STEPS);\n        steps.add(getReadAttributeOperation(MASTER_ROOT_ADDRESS, NAME));\n        steps.add(getReadAttributeOperation(MASTER_INTERFACE_ADDRESS, INET_ADDRESS));\n        masterRequest.protect();\n\n        ModelNode response = masterClient.execute(masterRequest);\n        System.out.println(response);\n        ModelNode returnVal = validateResponse(response);\n        ModelNode name = validateResponse(returnVal.get(\"step-1\"));\n        Assert.assertEquals(\"master\", name.asString());\n        ModelNode inetAddress = validateResponse(returnVal.get(\"step-2\"));\n        Assert.assertEquals(ModelType.EXPRESSION, inetAddress.getType());\n\n        ModelNode slaveRequest = getEmptyOperation(COMPOSITE, null);\n        steps = slaveRequest.get(STEPS);\n        steps.add(getReadAttributeOperation(SLAVE_ROOT_ADDRESS, NAME));\n        steps.add(getReadAttributeOperation(SLAVE_INTERFACE_ADDRESS, INET_ADDRESS));\n        masterRequest.protect();\n\n        response = slaveClient.execute(slaveRequest);\n        System.out.println(response);\n        ModelNode slaveReturnVal = validateResponse(response);\n        name = validateResponse(slaveReturnVal.get(\"step-1\"));\n        Assert.assertEquals(\"slave\", name.asString());\n        inetAddress = validateResponse(slaveReturnVal.get(\"step-2\"));\n        Assert.assertEquals(ModelType.EXPRESSION, inetAddress.getType());\n\n        // Check we get the same thing via the master\n        response = masterClient.execute(slaveRequest);\n        returnVal = validateResponse(response);\n        Assert.assertEquals(returnVal, slaveReturnVal);\n\n        // Can't access the master via the slave\n        response = slaveClient.execute(masterRequest);\n        validateFailedResponse(response);\n    }","commit_id":"2bb4d366da9be3f9dbc11558ec7db8c10008eb00","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testCompositeCrossHostReadAccess() throws IOException {\n\n        ModelNode masterRequest = getEmptyOperation(COMPOSITE, null);\n        ModelNode steps = masterRequest.get(STEPS);\n        steps.add(getReadAttributeOperation(MASTER_ROOT_ADDRESS, NAME));\n        steps.add(getReadAttributeOperation(MASTER_INTERFACE_ADDRESS, INET_ADDRESS));\n        steps.add(getReadAttributeOperation(SLAVE_ROOT_ADDRESS, NAME));\n        steps.add(getReadAttributeOperation(SLAVE_INTERFACE_ADDRESS, INET_ADDRESS));\n        steps.add(getReadAttributeOperation(MAIN_RUNNING_SERVER_ADDRESS, NAME));\n        steps.add(getReadAttributeOperation(OTHER_RUNNING_SERVER_ADDRESS, NAME));\n        masterRequest.protect();\n\n        System.out.println(masterRequest);\n        ModelNode response = masterClient.execute(masterRequest);\n        System.out.println(response);\n        ModelNode returnVal = validateResponse(response).get(DOMAIN_RESULTS);\n        ModelNode name = validateResponse(returnVal.get(\"step-1\"));\n        Assert.assertEquals(\"master\", name.asString());\n        ModelNode inetAddress = validateResponse(returnVal.get(\"step-2\"));\n        Assert.assertEquals(ModelType.EXPRESSION, inetAddress.getType());\n        name = validateResponse(returnVal.get(\"step-3\"));\n        Assert.assertEquals(\"slave\", name.asString());\n        inetAddress = validateResponse(returnVal.get(\"step-4\"));\n        Assert.assertEquals(ModelType.EXPRESSION, inetAddress.getType());\n        name = validateResponse(returnVal.get(\"step-5\"));\n        Assert.assertEquals(\"main-one\", name.asString());\n        name = validateResponse(returnVal.get(\"step-6\"));\n        Assert.assertEquals(\"other-two\", name.asString());\n\n        // Can't access the master via the slave\n        response = slaveClient.execute(masterRequest);\n        validateFailedResponse(response);\n    }","id":99858,"modified_method":"@Test\n    public void testCompositeCrossHostReadAccess() throws IOException {\n\n        ModelNode masterRequest = getEmptyOperation(COMPOSITE, null);\n        ModelNode steps = masterRequest.get(STEPS);\n        steps.add(getReadAttributeOperation(MASTER_ROOT_ADDRESS, NAME));\n        steps.add(getReadAttributeOperation(MASTER_INTERFACE_ADDRESS, INET_ADDRESS));\n        steps.add(getReadAttributeOperation(SLAVE_ROOT_ADDRESS, NAME));\n        steps.add(getReadAttributeOperation(SLAVE_INTERFACE_ADDRESS, INET_ADDRESS));\n        steps.add(getReadAttributeOperation(MAIN_RUNNING_SERVER_ADDRESS, NAME));\n        steps.add(getReadAttributeOperation(OTHER_RUNNING_SERVER_ADDRESS, NAME));\n        masterRequest.protect();\n\n        System.out.println(masterRequest);\n        ModelNode response = masterClient.execute(masterRequest);\n        System.out.println(response);\n        ModelNode returnVal = validateResponse(response);\n        ModelNode name = validateResponse(returnVal.get(\"step-1\"));\n        Assert.assertEquals(\"master\", name.asString());\n        ModelNode inetAddress = validateResponse(returnVal.get(\"step-2\"));\n        Assert.assertEquals(ModelType.EXPRESSION, inetAddress.getType());\n        name = validateResponse(returnVal.get(\"step-3\"));\n        Assert.assertEquals(\"slave\", name.asString());\n        inetAddress = validateResponse(returnVal.get(\"step-4\"));\n        Assert.assertEquals(ModelType.EXPRESSION, inetAddress.getType());\n        name = validateResponse(returnVal.get(\"step-5\"));\n        Assert.assertEquals(\"main-one\", name.asString());\n        name = validateResponse(returnVal.get(\"step-6\"));\n        Assert.assertEquals(\"other-two\", name.asString());\n\n        // Can't access the master via the slave\n        response = slaveClient.execute(masterRequest);\n        validateFailedResponse(response);\n    }","commit_id":"2bb4d366da9be3f9dbc11558ec7db8c10008eb00","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testCompositeDomainReadAccess() throws IOException {\n\n        ModelNode request = getEmptyOperation(COMPOSITE, null);\n        ModelNode steps = request.get(STEPS);\n        steps.add(getReadAttributeOperation(ROOT_ADDRESS, SCHEMA_LOCATIONS));\n        steps.add(getReadAttributeOperation(OTHER_SERVER_GROUP_ADDRESS, PROFILE));\n        request.protect();\n\n        ModelNode response = masterClient.execute(request);\n        System.out.println(response);\n        ModelNode returnVal = validateResponse(response).get(DOMAIN_RESULTS);\n        validateResponse(returnVal.get(\"step-1\"));\n        ModelNode profile = validateResponse(returnVal.get(\"step-2\"));\n        Assert.assertEquals(\"osgi\", profile.asString());\n\n        response = slaveClient.execute(request);\n        System.out.println(response);\n        ModelNode slaveReturnVal = validateResponse(response).get(DOMAIN_RESULTS);\n        Assert.assertEquals(returnVal, slaveReturnVal);\n    }","id":99859,"modified_method":"@Test\n    public void testCompositeDomainReadAccess() throws IOException {\n\n        ModelNode request = getEmptyOperation(COMPOSITE, null);\n        ModelNode steps = request.get(STEPS);\n        steps.add(getReadAttributeOperation(ROOT_ADDRESS, SCHEMA_LOCATIONS));\n        steps.add(getReadAttributeOperation(OTHER_SERVER_GROUP_ADDRESS, PROFILE));\n        request.protect();\n\n        ModelNode response = masterClient.execute(request);\n        System.out.println(response);\n        ModelNode returnVal = validateResponse(response);\n        validateResponse(returnVal.get(\"step-1\"));\n        ModelNode profile = validateResponse(returnVal.get(\"step-2\"));\n        Assert.assertEquals(\"osgi\", profile.asString());\n\n        response = slaveClient.execute(request);\n        System.out.println(response);\n        ModelNode slaveReturnVal = validateResponse(response);\n        Assert.assertEquals(returnVal, slaveReturnVal);\n    }","commit_id":"2bb4d366da9be3f9dbc11558ec7db8c10008eb00","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void deletePortletPreferences(long portletPreferencesId)\n\t\tthrows Exception {\n\n\t\tConnection con = null;\n\t\tPreparedStatement ps = null;\n\n\t\ttry {\n\t\t\tcon = DataAccess.getConnection();\n\n\t\t\tps = con.prepareStatement(\n\t\t\t\t\"delete from PortletPreferences where portletPreferencesId = \" +\n\t\t\t\t\tportletPreferencesId);\n\n\t\t\tps.executeUpdate();\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(con, ps);\n\t\t}\n\t}","id":99860,"modified_method":"protected void deletePortletPreferences(long portletPreferencesId)\n\t\tthrows Exception {\n\n\t\trunSQL(\n\t\t\t\"delete from PortletPreferences where portletPreferencesId = \" +\n\t\t\t\tportletPreferencesId);\n\t}","commit_id":"4c56e426aead1f57ea0ccfdb6d576daf6ba55080","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void deletePortletPreferences(long portletPreferencesId)\n\t\tthrows Exception {\n\n\t\tConnection con = null;\n\t\tPreparedStatement ps = null;\n\n\t\ttry {\n\t\t\tcon = DataAccess.getConnection();\n\n\t\t\tps = con.prepareStatement(\n\t\t\t\t\"delete from PortletPreferences where portletPreferencesId = \" +\n\t\t\t\t\tportletPreferencesId);\n\n\t\t\tps.executeUpdate();\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(con, ps);\n\t\t}\n\t}","id":99861,"modified_method":"protected void deletePortletPreferences(long portletPreferencesId)\n\t\tthrows Exception {\n\n\t\trunSQL(\n\t\t\t\"delete from PortletPreferences where portletPreferencesId = \" +\n\t\t\t\tportletPreferencesId);\n\t}","commit_id":"4c56e426aead1f57ea0ccfdb6d576daf6ba55080","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void deletePortletPreferences(long portletPreferencesId)\n\t\tthrows Exception {\n\n\t\tConnection con = null;\n\t\tPreparedStatement ps = null;\n\n\t\ttry {\n\t\t\tcon = DataAccess.getConnection();\n\n\t\t\tps = con.prepareStatement(\n\t\t\t\t\"delete from PortletPreferences where portletPreferencesId = \" +\n\t\t\t\t\tportletPreferencesId);\n\n\t\t\tps.executeUpdate();\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(con, ps);\n\t\t}\n\t}","id":99862,"modified_method":"protected void deletePortletPreferences(long portletPreferencesId)\n\t\tthrows Exception {\n\n\t\trunSQL(\n\t\t\t\"delete from PortletPreferences where portletPreferencesId = \" +\n\t\t\t\tportletPreferencesId);\n\t}","commit_id":"4c56e426aead1f57ea0ccfdb6d576daf6ba55080","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public PutObjectResponseType putObject(PutObjectType request) throws EucalyptusCloudException {\n\t\tPutObjectResponseType reply = (PutObjectResponseType) request.getReply();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\t\tLong oldBucketSize = 0L;\n\t\tString md5 = \"\";\n\t\tDate lastModified = null;\n\n\t\tAccessControlListType accessControlList = request.getAccessControlList();\n\t\tif (accessControlList == null) {\n\t\t\taccessControlList = new AccessControlListType();\n\t\t}\n\n\t\tString key = bucketName + \".\" + objectKey;\n\t\tString randomKey = request.getRandomKey();\n\t\tWalrusDataMessenger messenger = WalrusRESTBinding.getWriteMessenger();\n\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.queryEscape(bucketInfo);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\tlong objSize = 0;\n\t\t\ttry {\n\t\t\t\tobjSize = Long.valueOf(request.getContentLength());\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tLOG.error(\"Invalid content length \" + request.getContentLength());\n\t\t\t\t// TODO(wenye): should handle this properly.\n\t\t\t\tobjSize = 1L;\n\t\t\t}\n\t\t\tif (ctx.hasAdministrativePrivileges()\n\t\t\t\t\t|| (bucket.canWrite(account.getAccountNumber()) && (bucket.isGlobalWrite() || Lookups.checkPrivilege(PolicySpec.S3_PUTOBJECT,\n\t\t\t\t\t\t\tPolicySpec.VENDOR_S3, PolicySpec.S3_RESOURCE_BUCKET, bucketName, null)))) {\n\t\t\t\tif (logData != null) {\n\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t}\n\t\t\t\tString objectName = null;\n\t\t\t\tString versionId = null;\n\t\t\t\tLong oldObjectSize = 0L;\n\t\t\t\tObjectInfo objectInfo = null;\n\t\t\t\tif (bucket.isVersioningEnabled()) {\n\t\t\t\t\t// If versioning, add new object with new version id and\n\t\t\t\t\t// make it the 'latest' version.\n\t\t\t\t\tobjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\tobjectInfo.setOwnerId(account.getAccountNumber());\n\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\tobjectInfo.addGrants(account.getAccountNumber(), bucket.getOwnerId(), grantInfos, accessControlList);\n\t\t\t\t\tobjectInfo.setGrants(grantInfos);\n\t\t\t\t\tobjectName = UUID.randomUUID().toString();\n\t\t\t\t\tobjectInfo.setObjectName(objectName);\n\t\t\t\t\tobjectInfo.setSize(0L);\n\t\t\t\t\tversionId = UUID.randomUUID().toString().replaceAll(\"-\", \"\");\n\t\t\t\t\treply.setVersionId(versionId);\n\t\t\t\t} else {\n\t\t\t\t\t// If no versioning enabled, put using a null version id,\n\t\t\t\t\t// this will replace any previous 'null' versioned object\n\t\t\t\t\t// but not one with a version id.\n\t\t\t\t\tversionId = WalrusProperties.NULL_VERSION_ID;\n\t\t\t\t\tObjectInfo searchObject = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\tsearchObject.setVersionId(versionId);\n\t\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tObjectInfo foundObject = dbObject.getUniqueEscape(searchObject);\n\t\t\t\t\t\tif (!foundObject.canWrite(account.getAccountNumber())) {\n\t\t\t\t\t\t\t// Found existing object, but don't have write\n\t\t\t\t\t\t\t// access\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey, logData);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tobjectName = foundObject.getObjectName();\n\t\t\t\t\t\toldObjectSize = foundObject.getSize();\n\t\t\t\t\t\t// Fix for EUCA-2275:\n\t\t\t\t\t\t// If an existing object is overwritten, the size\n\t\t\t\t\t\t// difference must be taken into account. Size of the\n\t\t\t\t\t\t// already existing object was ignored before\n\t\t\t\t\t\toldBucketSize = -oldObjectSize;\n\t\t\t\t\t} catch (AccessDeniedException ex) {\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t} catch (EucalyptusCloudException ex) {\n\t\t\t\t\t\t// No existing object found\n\t\t\t\t\t\tobjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\t\tobjectInfo.setOwnerId(account.getAccountNumber());\n\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\tobjectInfo.addGrants(account.getAccountNumber(), bucket.getOwnerId(), grantInfos, accessControlList);\n\t\t\t\t\t\tobjectInfo.setGrants(grantInfos);\n\t\t\t\t\t\tobjectName = UUID.randomUUID().toString();\n\t\t\t\t\t\tobjectInfo.setObjectName(objectName);\n\t\t\t\t\t\tobjectInfo.setSize(0L);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tString bucketOwnerId = bucket.getOwnerId();\n\t\t\t\tdb.commit();\n\t\t\t\t// writes are unconditional\n\t\t\t\tWalrusDataQueue<WalrusDataMessage> putQueue = messenger.getQueue(key, randomKey);\n\n\t\t\t\ttry {\n\t\t\t\t\tWalrusDataMessage dataMessage;\n\t\t\t\t\tString tempObjectName = objectName;\n\t\t\t\t\tMessageDigest digest = null;\n\t\t\t\t\tlong size = 0;\n\t\t\t\t\tFileIO fileIO = null;\n\t\t\t\t\twhile ((dataMessage = putQueue.take()) != null) {\n\t\t\t\t\t\tif (putQueue.getInterrupted()) {\n\t\t\t\t\t\t\tif (WalrusDataMessage.isEOF(dataMessage)) {\n\t\t\t\t\t\t\t\tWalrusMonitor monitor = messenger.getMonitor(key);\n\t\t\t\t\t\t\t\tif (monitor.getLastModified() == null) {\n\t\t\t\t\t\t\t\t\tLOG.trace(\"Monitor wait: \" + key + \" random: \" + randomKey);\n\t\t\t\t\t\t\t\t\tsynchronized (monitor) {\n\t\t\t\t\t\t\t\t\t\tmonitor.wait();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tLOG.trace(\"Monitor resume: \" + key + \" random: \" + randomKey);\n\t\t\t\t\t\t\t\tlastModified = monitor.getLastModified();\n\t\t\t\t\t\t\t\tmd5 = monitor.getMd5();\n\t\t\t\t\t\t\t\t// ok we are done here\n\t\t\t\t\t\t\t\tif (fileIO != null) {\n\t\t\t\t\t\t\t\t\tfileIO.finish();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tObjectDeleter objectDeleter = new ObjectDeleter(bucketName, tempObjectName, null, null, -1L, ctx.getUser().getName(), ctx\n\t\t\t\t\t\t\t\t\t\t.getUser().getUserId(), ctx.getAccount().getName(), ctx.getAccount().getAccountNumber());\n\t\t\t\t\t\t\t\tThreads.lookup(Walrus.class, WalrusManager.ObjectDeleter.class).limitTo(10).submit(objectDeleter);\n\t\t\t\t\t\t\t\tLOG.info(\"Transfer interrupted: \" + key);\n\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (WalrusDataMessage.isStart(dataMessage)) {\n\t\t\t\t\t\t\ttempObjectName = UUID.randomUUID().toString();\n\t\t\t\t\t\t\tdigest = Digest.MD5.get();\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tfileIO = storageManager.prepareForWrite(bucketName, tempObjectName);\n\t\t\t\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (WalrusDataMessage.isEOF(dataMessage)) {\n\t\t\t\t\t\t\tif (digest != null) {\n\t\t\t\t\t\t\t\tmd5 = Hashes.bytesToHex(digest.digest());\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tWalrusMonitor monitor = messenger.getMonitor(key);\n\t\t\t\t\t\t\t\tmd5 = monitor.getMd5();\n\t\t\t\t\t\t\t\tlastModified = monitor.getLastModified();\n\t\t\t\t\t\t\t\tif (md5 == null) {\n\t\t\t\t\t\t\t\t\tLOG.error(\"ETag did not match for: \" + randomKey + \" Computed MD5 is null\");\n\t\t\t\t\t\t\t\t\tthrow new ContentMismatchException(bucketName + \"/\" + objectKey);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tString contentMD5 = request.getContentMD5();\n\t\t\t\t\t\t\tif (contentMD5 != null) {\n\t\t\t\t\t\t\t\tString contentMD5AsHex = Hashes.bytesToHex(Base64.decode(contentMD5));\n\t\t\t\t\t\t\t\tif (!contentMD5AsHex.equals(md5)) {\n\t\t\t\t\t\t\t\t\tif (fileIO != null) {\n\t\t\t\t\t\t\t\t\t\tfileIO.finish();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcleanupTempObject(ctx, bucketName, tempObjectName);\n\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\tLOG.error(\"ETag did not match for: \" + randomKey + \" Expected: \" + contentMD5AsHex + \" Computed: \" + md5);\n\t\t\t\t\t\t\t\t\tthrow new ContentMismatchException(bucketName + \"/\" + objectKey);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Fix for EUCA-2275:\n\t\t\t\t\t\t\t// Moved up policy and bucket size checks on the\n\t\t\t\t\t\t\t// temporary object. The temp object is committed\n\t\t\t\t\t\t\t// (renamed) only after it clears the checks.\n\t\t\t\t\t\t\t// If any of the checks fail, temp object is cleaned\n\t\t\t\t\t\t\t// up and the process errors out. If the PUT request\n\t\t\t\t\t\t\t// is overwriting an existing object, the object is\n\t\t\t\t\t\t\t// left untouched.\n\t\t\t\t\t\t\t// So the fix ensures proper clean up of temp files\n\t\t\t\t\t\t\t// (no orphaned files) and does not overwrite\n\t\t\t\t\t\t\t// existing data when policy or bucket size checks\n\t\t\t\t\t\t\t// fail\n\n\t\t\t\t\t\t\tif (!ctx.hasAdministrativePrivileges()\n\t\t\t\t\t\t\t\t\t&& !Permissions.canAllocate(PolicySpec.VENDOR_S3, PolicySpec.S3_RESOURCE_OBJECT, bucketName, PolicySpec.S3_PUTOBJECT,\n\t\t\t\t\t\t\t\t\t\t\tctx.getUser(), oldBucketSize + size)) {\n\t\t\t\t\t\t\t\t// dbObject.rollback();\n\t\t\t\t\t\t\t\tcleanupTempObject(ctx, bucketName, tempObjectName);\n\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\tLOG.error(\"Quota exceeded for Walrus putObject\");\n\t\t\t\t\t\t\t\tthrow new EntityTooLargeException(\"Key\", objectKey);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tboolean success = false;\n\t\t\t\t\t\t\tint retryCount = 0;\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tincrementBucketSize(bucketName, objectKey, oldBucketSize, size);\n\t\t\t\t\t\t\t\t\tsuccess = true;\n\t\t\t\t\t\t\t\t} catch (EntityTooLargeException ex) {\n\t\t\t\t\t\t\t\t\tcleanupTempObject(ctx, bucketName, tempObjectName);\n\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\t// dbObject.rollback();\n\t\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t\t} catch (NoSuchBucketException ex) {\n\t\t\t\t\t\t\t\t\t// dbObject.rollback();\n\t\t\t\t\t\t\t\t\tcleanupTempObject(ctx, bucketName, tempObjectName);\n\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t\t} catch (RollbackException ex) {\n\t\t\t\t\t\t\t\t\tretryCount++;\n\t\t\t\t\t\t\t\t\tLOG.trace(\"retrying update: \" + bucketName);\n\t\t\t\t\t\t\t\t} catch (EucalyptusCloudException ex) {\n\t\t\t\t\t\t\t\t\t// dbObject.rollback();\n\t\t\t\t\t\t\t\t\tcleanupTempObject(ctx, bucketName, tempObjectName);\n\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} while (!success && (retryCount < 5));\n\n\t\t\t\t\t\t\t// commit object\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (fileIO != null) {\n\t\t\t\t\t\t\t\t\tfileIO.finish();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tstorageManager.renameObject(bucketName, tempObjectName, objectName);\n\t\t\t\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(objectKey);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlastModified = new Date();\n\t\t\t\t\t\t\tObjectInfo searchObject = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\t\t\tsearchObject.setVersionId(versionId);\n\t\t\t\t\t\t\tEntityWrapper<ObjectInfo> dbObject = EntityWrapper.get(ObjectInfo.class);\n\t\t\t\t\t\t\tObjectInfo foundObject;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tfoundObject = dbObject.getUniqueEscape(searchObject);\n\t\t\t\t\t\t\t\tif (ctx.hasAdministrativePrivileges() || foundObject.canWriteACP(account.getAccountNumber())) {\n\t\t\t\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\t\t\t\tfoundObject.addGrants(account.getAccountNumber(), bucketOwnerId, grantInfos, accessControlList);\n\t\t\t\t\t\t\t\t\tfoundObject.setGrants(grantInfos);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (WalrusProperties.enableTorrents) {\n\t\t\t\t\t\t\t\t\tEntityWrapper<TorrentInfo> dbTorrent = dbObject.recast(TorrentInfo.class);\n\t\t\t\t\t\t\t\t\tTorrentInfo torrentInfo = new TorrentInfo(bucketName, objectKey);\n\t\t\t\t\t\t\t\t\tList<TorrentInfo> torrentInfos = dbTorrent.queryEscape(torrentInfo);\n\t\t\t\t\t\t\t\t\tif (torrentInfos.size() > 0) {\n\t\t\t\t\t\t\t\t\t\tTorrentInfo foundTorrentInfo = torrentInfos.get(0);\n\t\t\t\t\t\t\t\t\t\tTorrentClient torrentClient = Torrents.getClient(bucketName + objectKey);\n\t\t\t\t\t\t\t\t\t\tif (torrentClient != null) {\n\t\t\t\t\t\t\t\t\t\t\ttorrentClient.bye();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tdbTorrent.delete(foundTorrentInfo);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tLOG.warn(\"Bittorrent support has been disabled. Please check pre-requisites\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (EucalyptusCloudException ex) {\n\t\t\t\t\t\t\t\tif (objectInfo != null) {\n\t\t\t\t\t\t\t\t\tfoundObject = objectInfo;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdbObject.rollback();\n\t\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(\"Unable to update object: \" + bucketName + \"/\" + objectKey);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfoundObject.setVersionId(versionId);\n\t\t\t\t\t\t\tfoundObject.replaceMetaData(request.getMetaData());\n\t\t\t\t\t\t\tfoundObject.setEtag(md5);\n\t\t\t\t\t\t\tfoundObject.setSize(size);\n\t\t\t\t\t\t\tfoundObject.setLastModified(lastModified);\n\t\t\t\t\t\t\tfoundObject.setStorageClass(\"STANDARD\");\n\t\t\t\t\t\t\tfoundObject.setContentType(request.getContentType());\n\t\t\t\t\t\t\tfoundObject.setContentDisposition(request.getContentDisposition());\n\t\t\t\t\t\t\tfoundObject.setLast(true);\n\t\t\t\t\t\t\tfoundObject.setDeleted(false);\n\t\t\t\t\t\t\treply.setSize(size);\n\t\t\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\t\t\tlogData.setObjectSize(size);\n\t\t\t\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (objectInfo != null) {\n\t\t\t\t\t\t\t\tdbObject.add(foundObject);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsuccess = false;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tdbObject.commit();\n\t\t\t\t\t\t\t\tsuccess = true;\n\t\t\t\t\t\t\t} catch (RollbackException ex) {\n\t\t\t\t\t\t\t\tdbObject.rollback();\n\t\t\t\t\t\t\t\tLOG.error(ex, ex);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tdbObject = EntityWrapper.get(ObjectInfo.class);\n\t\t\t\t\t\t\tList<ObjectInfo> objectInfos = dbObject.queryEscape(new ObjectInfo(bucketName, objectKey));\n\t\t\t\t\t\t\tfor (ObjectInfo objInfo : objectInfos) {\n\t\t\t\t\t\t\t\tif (!success) {\n\t\t\t\t\t\t\t\t\tif (objInfo.getLast()) {\n\t\t\t\t\t\t\t\t\t\tlastModified = objInfo.getLastModified();\n\t\t\t\t\t\t\t\t\t\tmd5 = objInfo.getEtag();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tsuccess = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!versionId.equals(objInfo.getVersionId())) {\n\t\t\t\t\t\t\t\t\tobjInfo.setLast(false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdbObject.commit();\n\n\t\t\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\t\t\tlogData.setTurnAroundTime(Long.parseLong(new String(dataMessage.getPayload())));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// restart all interrupted puts\n\t\t\t\t\t\t\tWalrusMonitor monitor = messenger.getMonitor(key);\n\t\t\t\t\t\t\tsynchronized (monitor) {\n\t\t\t\t\t\t\t\tmonitor.setLastModified(lastModified);\n\t\t\t\t\t\t\t\tmonitor.setMd5(md5);\n\t\t\t\t\t\t\t\tmonitor.notifyAll();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// messenger.removeMonitor(key);\n\t\t\t\t\t\t\tmessenger.clearQueues(key);\n\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\tLOG.info(\"Transfer complete: \" + key);\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tfireObjectCreationEvent(bucketName, objectKey, versionId, ctx.getUser().getUserId(), size, oldObjectSize);\n\t\t\t\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\t\t\t\tLOG.debug(\"Failed to fire reporting event for walrus PUT object operation\", ex);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tassert (WalrusDataMessage.isData(dataMessage));\n\t\t\t\t\t\t\tbyte[] data = dataMessage.getPayload();\n\t\t\t\t\t\t\t// start writing object (but do not commit yet)\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (fileIO != null)\n\t\t\t\t\t\t\t\t\tfileIO.write(data);\n\t\t\t\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// calculate md5 on the fly\n\t\t\t\t\t\t\tsize += data.length;\n\t\t\t\t\t\t\tif (digest != null) {\n\t\t\t\t\t\t\t\tdigest.update(data);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (InterruptedException ex) {\n\t\t\t\t\tLOG.error(ex, ex);\n\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\tthrow new EucalyptusCloudException(\"Transfer interrupted: \" + key + \".\" + randomKey);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\n\t\treply.setEtag(md5);\n\t\treply.setLastModified(DateUtils.format(lastModified.getTime(), DateUtils.RFC822_DATETIME_PATTERN));\n\t\treturn reply;\n\t}","id":99863,"modified_method":"public PutObjectResponseType putObject(PutObjectType request) throws EucalyptusCloudException {\n\t\tPutObjectResponseType reply = (PutObjectResponseType) request.getReply();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\t\tLong oldBucketSize = 0L;\n\t\tString md5 = \"\";\n\t\tDate lastModified = null;\n\n\t\tAccessControlListType accessControlList = request.getAccessControlList();\n\t\tif (accessControlList == null) {\n\t\t\taccessControlList = new AccessControlListType();\n\t\t}\n\n\t\tString key = bucketName + \".\" + objectKey;\n\t\tString randomKey = request.getRandomKey();\n\t\tWalrusDataMessenger messenger = WalrusRESTBinding.getWriteMessenger();\n\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.queryEscape(bucketInfo);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\tlong objSize = 0;\n\t\t\ttry {\n\t\t\t\tobjSize = Long.valueOf(request.getContentLength());\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tLOG.error(\"Invalid content length \" + request.getContentLength());\n\t\t\t\t// TODO(wenye): should handle this properly.\n\t\t\t\tobjSize = 1L;\n\t\t\t}\n\t\t\tif (ctx.hasAdministrativePrivileges()\n\t\t\t\t\t|| (bucket.canWrite(account.getAccountNumber()) && (bucket.isGlobalWrite() || Lookups.checkPrivilege(PolicySpec.S3_PUTOBJECT,\n\t\t\t\t\t\t\tPolicySpec.VENDOR_S3, PolicySpec.S3_RESOURCE_BUCKET, bucketName, null)))) {\n\t\t\t\tif (logData != null) {\n\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t}\n\t\t\t\tString objectName = null;\n\t\t\t\tString versionId = null;\n\t\t\t\tLong oldObjectSize = 0L;\n\t\t\t\tObjectInfo objectInfo = null;\n\t\t\t\tif (bucket.isVersioningEnabled()) {\n\t\t\t\t\t// If versioning, add new object with new version id and\n\t\t\t\t\t// make it the 'latest' version.\n\t\t\t\t\tobjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\tobjectInfo.setOwnerId(account.getAccountNumber());\n\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\tobjectInfo.addGrants(account.getAccountNumber(), bucket.getOwnerId(), grantInfos, accessControlList);\n\t\t\t\t\tobjectInfo.setGrants(grantInfos);\n\t\t\t\t\tobjectName = UUID.randomUUID().toString();\n\t\t\t\t\tobjectInfo.setObjectName(objectName);\n\t\t\t\t\tobjectInfo.setSize(0L);\n\t\t\t\t\tversionId = UUID.randomUUID().toString().replaceAll(\"-\", \"\");\n\t\t\t\t\treply.setVersionId(versionId);\n\t\t\t\t} else {\n\t\t\t\t\t// If no versioning enabled, put using a null version id,\n\t\t\t\t\t// this will replace any previous 'null' versioned object\n\t\t\t\t\t// but not one with a version id.\n\t\t\t\t\tversionId = WalrusProperties.NULL_VERSION_ID;\n\t\t\t\t\tObjectInfo searchObject = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\tsearchObject.setVersionId(versionId);\n\t\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tObjectInfo foundObject = dbObject.getUniqueEscape(searchObject);\n\t\t\t\t\t\tif (!foundObject.canWrite(account.getAccountNumber())) {\n\t\t\t\t\t\t\t// Found existing object, but don't have write\n\t\t\t\t\t\t\t// access\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey, logData);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tobjectName = foundObject.getObjectName();\n\t\t\t\t\t\toldObjectSize = foundObject.getSize() == null ? 0L : foundObject.getSize();\n\t\t\t\t\t\t// Fix for EUCA-2275:\n\t\t\t\t\t\t// If an existing object is overwritten, the size\n\t\t\t\t\t\t// difference must be taken into account. Size of the\n\t\t\t\t\t\t// already existing object was ignored before\n\t\t\t\t\t\toldBucketSize = -oldObjectSize;\n\t\t\t\t\t} catch (AccessDeniedException ex) {\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t} catch (EucalyptusCloudException ex) {\n\t\t\t\t\t\t// No existing object found\n\t\t\t\t\t\tobjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\t\tobjectInfo.setOwnerId(account.getAccountNumber());\n\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\tobjectInfo.addGrants(account.getAccountNumber(), bucket.getOwnerId(), grantInfos, accessControlList);\n\t\t\t\t\t\tobjectInfo.setGrants(grantInfos);\n\t\t\t\t\t\tobjectName = UUID.randomUUID().toString();\n\t\t\t\t\t\tobjectInfo.setObjectName(objectName);\n\t\t\t\t\t\tobjectInfo.setSize(0L);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tString bucketOwnerId = bucket.getOwnerId();\n\t\t\t\tdb.commit();\n\t\t\t\t// writes are unconditional\n\t\t\t\tWalrusDataQueue<WalrusDataMessage> putQueue = messenger.getQueue(key, randomKey);\n\n\t\t\t\ttry {\n\t\t\t\t\tWalrusDataMessage dataMessage;\n\t\t\t\t\tString tempObjectName = objectName;\n\t\t\t\t\tMessageDigest digest = null;\n\t\t\t\t\tlong size = 0;\n\t\t\t\t\tFileIO fileIO = null;\n\t\t\t\t\twhile ((dataMessage = putQueue.take()) != null) {\n\t\t\t\t\t\tif (putQueue.getInterrupted()) {\n\t\t\t\t\t\t\tif (WalrusDataMessage.isEOF(dataMessage)) {\n\t\t\t\t\t\t\t\tWalrusMonitor monitor = messenger.getMonitor(key);\n\t\t\t\t\t\t\t\tif (monitor.getLastModified() == null) {\n\t\t\t\t\t\t\t\t\tLOG.trace(\"Monitor wait: \" + key + \" random: \" + randomKey);\n\t\t\t\t\t\t\t\t\tsynchronized (monitor) {\n\t\t\t\t\t\t\t\t\t\tmonitor.wait();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tLOG.trace(\"Monitor resume: \" + key + \" random: \" + randomKey);\n\t\t\t\t\t\t\t\tlastModified = monitor.getLastModified();\n\t\t\t\t\t\t\t\tmd5 = monitor.getMd5();\n\t\t\t\t\t\t\t\t// ok we are done here\n\t\t\t\t\t\t\t\tif (fileIO != null) {\n\t\t\t\t\t\t\t\t\tfileIO.finish();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tObjectDeleter objectDeleter = new ObjectDeleter(bucketName, tempObjectName, null, null, -1L, ctx.getUser().getName(), ctx\n\t\t\t\t\t\t\t\t\t\t.getUser().getUserId(), ctx.getAccount().getName(), ctx.getAccount().getAccountNumber());\n\t\t\t\t\t\t\t\tThreads.lookup(Walrus.class, WalrusManager.ObjectDeleter.class).limitTo(10).submit(objectDeleter);\n\t\t\t\t\t\t\t\tLOG.info(\"Transfer interrupted: \" + key);\n\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (WalrusDataMessage.isStart(dataMessage)) {\n\t\t\t\t\t\t\ttempObjectName = UUID.randomUUID().toString();\n\t\t\t\t\t\t\tdigest = Digest.MD5.get();\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tfileIO = storageManager.prepareForWrite(bucketName, tempObjectName);\n\t\t\t\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (WalrusDataMessage.isEOF(dataMessage)) {\n\t\t\t\t\t\t\tif (digest != null) {\n\t\t\t\t\t\t\t\tmd5 = Hashes.bytesToHex(digest.digest());\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tWalrusMonitor monitor = messenger.getMonitor(key);\n\t\t\t\t\t\t\t\tmd5 = monitor.getMd5();\n\t\t\t\t\t\t\t\tlastModified = monitor.getLastModified();\n\t\t\t\t\t\t\t\tif (md5 == null) {\n\t\t\t\t\t\t\t\t\tLOG.error(\"ETag did not match for: \" + randomKey + \" Computed MD5 is null\");\n\t\t\t\t\t\t\t\t\tthrow new ContentMismatchException(bucketName + \"/\" + objectKey);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tString contentMD5 = request.getContentMD5();\n\t\t\t\t\t\t\tif (contentMD5 != null) {\n\t\t\t\t\t\t\t\tString contentMD5AsHex = Hashes.bytesToHex(Base64.decode(contentMD5));\n\t\t\t\t\t\t\t\tif (!contentMD5AsHex.equals(md5)) {\n\t\t\t\t\t\t\t\t\tif (fileIO != null) {\n\t\t\t\t\t\t\t\t\t\tfileIO.finish();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcleanupTempObject(ctx, bucketName, tempObjectName);\n\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\tLOG.error(\"ETag did not match for: \" + randomKey + \" Expected: \" + contentMD5AsHex + \" Computed: \" + md5);\n\t\t\t\t\t\t\t\t\tthrow new ContentMismatchException(bucketName + \"/\" + objectKey);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Fix for EUCA-2275:\n\t\t\t\t\t\t\t// Moved up policy and bucket size checks on the\n\t\t\t\t\t\t\t// temporary object. The temp object is committed\n\t\t\t\t\t\t\t// (renamed) only after it clears the checks.\n\t\t\t\t\t\t\t// If any of the checks fail, temp object is cleaned\n\t\t\t\t\t\t\t// up and the process errors out. If the PUT request\n\t\t\t\t\t\t\t// is overwriting an existing object, the object is\n\t\t\t\t\t\t\t// left untouched.\n\t\t\t\t\t\t\t// So the fix ensures proper clean up of temp files\n\t\t\t\t\t\t\t// (no orphaned files) and does not overwrite\n\t\t\t\t\t\t\t// existing data when policy or bucket size checks\n\t\t\t\t\t\t\t// fail\n\n\t\t\t\t\t\t\tif (!ctx.hasAdministrativePrivileges()\n\t\t\t\t\t\t\t\t\t&& !Permissions.canAllocate(PolicySpec.VENDOR_S3, PolicySpec.S3_RESOURCE_OBJECT, bucketName, PolicySpec.S3_PUTOBJECT,\n\t\t\t\t\t\t\t\t\t\t\tctx.getUser(), oldBucketSize + size)) {\n\t\t\t\t\t\t\t\t// dbObject.rollback();\n\t\t\t\t\t\t\t\tcleanupTempObject(ctx, bucketName, tempObjectName);\n\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\tLOG.error(\"Quota exceeded for Walrus putObject\");\n\t\t\t\t\t\t\t\tthrow new EntityTooLargeException(\"Key\", objectKey);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tboolean success = false;\n\t\t\t\t\t\t\tint retryCount = 0;\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tincrementBucketSize(bucketName, objectKey, oldBucketSize, size);\n\t\t\t\t\t\t\t\t\tsuccess = true;\n\t\t\t\t\t\t\t\t} catch (EntityTooLargeException ex) {\n\t\t\t\t\t\t\t\t\tcleanupTempObject(ctx, bucketName, tempObjectName);\n\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\t// dbObject.rollback();\n\t\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t\t} catch (NoSuchBucketException ex) {\n\t\t\t\t\t\t\t\t\t// dbObject.rollback();\n\t\t\t\t\t\t\t\t\tcleanupTempObject(ctx, bucketName, tempObjectName);\n\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t\t} catch (RollbackException ex) {\n\t\t\t\t\t\t\t\t\tretryCount++;\n\t\t\t\t\t\t\t\t\tLOG.trace(\"retrying update: \" + bucketName);\n\t\t\t\t\t\t\t\t} catch (EucalyptusCloudException ex) {\n\t\t\t\t\t\t\t\t\t// dbObject.rollback();\n\t\t\t\t\t\t\t\t\tcleanupTempObject(ctx, bucketName, tempObjectName);\n\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} while (!success && (retryCount < 5));\n\n\t\t\t\t\t\t\t// commit object\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (fileIO != null) {\n\t\t\t\t\t\t\t\t\tfileIO.finish();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tstorageManager.renameObject(bucketName, tempObjectName, objectName);\n\t\t\t\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(objectKey);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlastModified = new Date();\n\t\t\t\t\t\t\tObjectInfo searchObject = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\t\t\tsearchObject.setVersionId(versionId);\n\t\t\t\t\t\t\tEntityWrapper<ObjectInfo> dbObject = EntityWrapper.get(ObjectInfo.class);\n\t\t\t\t\t\t\tObjectInfo foundObject;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tfoundObject = dbObject.getUniqueEscape(searchObject);\n\t\t\t\t\t\t\t\t// If its a delete marker, fall through the administrative privileges and ACP check\n\t\t\t\t\t\t\t\tif (foundObject.getDeleted() || ctx.hasAdministrativePrivileges() || foundObject.canWriteACP(account.getAccountNumber())) {\n\t\t\t\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\t\t\t\tfoundObject.addGrants(account.getAccountNumber(), bucketOwnerId, grantInfos, accessControlList);\n\t\t\t\t\t\t\t\t\tfoundObject.setGrants(grantInfos);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (WalrusProperties.enableTorrents) {\n\t\t\t\t\t\t\t\t\tEntityWrapper<TorrentInfo> dbTorrent = dbObject.recast(TorrentInfo.class);\n\t\t\t\t\t\t\t\t\tTorrentInfo torrentInfo = new TorrentInfo(bucketName, objectKey);\n\t\t\t\t\t\t\t\t\tList<TorrentInfo> torrentInfos = dbTorrent.queryEscape(torrentInfo);\n\t\t\t\t\t\t\t\t\tif (torrentInfos.size() > 0) {\n\t\t\t\t\t\t\t\t\t\tTorrentInfo foundTorrentInfo = torrentInfos.get(0);\n\t\t\t\t\t\t\t\t\t\tTorrentClient torrentClient = Torrents.getClient(bucketName + objectKey);\n\t\t\t\t\t\t\t\t\t\tif (torrentClient != null) {\n\t\t\t\t\t\t\t\t\t\t\ttorrentClient.bye();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tdbTorrent.delete(foundTorrentInfo);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tLOG.warn(\"Bittorrent support has been disabled. Please check pre-requisites\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (EucalyptusCloudException ex) {\n\t\t\t\t\t\t\t\tif (objectInfo != null) {\n\t\t\t\t\t\t\t\t\tfoundObject = objectInfo;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdbObject.rollback();\n\t\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(\"Unable to update object: \" + bucketName + \"/\" + objectKey);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfoundObject.setVersionId(versionId);\n\t\t\t\t\t\t\tfoundObject.replaceMetaData(request.getMetaData());\n\t\t\t\t\t\t\tfoundObject.setEtag(md5);\n\t\t\t\t\t\t\tfoundObject.setSize(size);\n\t\t\t\t\t\t\tfoundObject.setLastModified(lastModified);\n\t\t\t\t\t\t\tfoundObject.setStorageClass(\"STANDARD\");\n\t\t\t\t\t\t\tfoundObject.setContentType(request.getContentType());\n\t\t\t\t\t\t\tfoundObject.setContentDisposition(request.getContentDisposition());\n\t\t\t\t\t\t\tfoundObject.setLast(true);\n\t\t\t\t\t\t\tfoundObject.setDeleted(false);\n\t\t\t\t\t\t\treply.setSize(size);\n\t\t\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\t\t\tlogData.setObjectSize(size);\n\t\t\t\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (objectInfo != null) {\n\t\t\t\t\t\t\t\tdbObject.add(foundObject);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsuccess = false;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tdbObject.commit();\n\t\t\t\t\t\t\t\tsuccess = true;\n\t\t\t\t\t\t\t} catch (RollbackException ex) {\n\t\t\t\t\t\t\t\tdbObject.rollback();\n\t\t\t\t\t\t\t\tLOG.error(ex, ex);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tdbObject = EntityWrapper.get(ObjectInfo.class);\n\t\t\t\t\t\t\tList<ObjectInfo> objectInfos = dbObject.queryEscape(new ObjectInfo(bucketName, objectKey));\n\t\t\t\t\t\t\tfor (ObjectInfo objInfo : objectInfos) {\n\t\t\t\t\t\t\t\tif (!success) {\n\t\t\t\t\t\t\t\t\tif (objInfo.getLast()) {\n\t\t\t\t\t\t\t\t\t\tlastModified = objInfo.getLastModified();\n\t\t\t\t\t\t\t\t\t\tmd5 = objInfo.getEtag();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tsuccess = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!versionId.equals(objInfo.getVersionId())) {\n\t\t\t\t\t\t\t\t\tobjInfo.setLast(false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdbObject.commit();\n\n\t\t\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\t\t\tlogData.setTurnAroundTime(Long.parseLong(new String(dataMessage.getPayload())));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// restart all interrupted puts\n\t\t\t\t\t\t\tWalrusMonitor monitor = messenger.getMonitor(key);\n\t\t\t\t\t\t\tsynchronized (monitor) {\n\t\t\t\t\t\t\t\tmonitor.setLastModified(lastModified);\n\t\t\t\t\t\t\t\tmonitor.setMd5(md5);\n\t\t\t\t\t\t\t\tmonitor.notifyAll();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// messenger.removeMonitor(key);\n\t\t\t\t\t\t\tmessenger.clearQueues(key);\n\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\tLOG.info(\"Transfer complete: \" + key);\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tfireObjectCreationEvent(bucketName, objectKey, versionId, ctx.getUser().getUserId(), size, oldObjectSize);\n\t\t\t\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\t\t\t\tLOG.debug(\"Failed to fire reporting event for walrus PUT object operation\", ex);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tassert (WalrusDataMessage.isData(dataMessage));\n\t\t\t\t\t\t\tbyte[] data = dataMessage.getPayload();\n\t\t\t\t\t\t\t// start writing object (but do not commit yet)\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (fileIO != null)\n\t\t\t\t\t\t\t\t\tfileIO.write(data);\n\t\t\t\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// calculate md5 on the fly\n\t\t\t\t\t\t\tsize += data.length;\n\t\t\t\t\t\t\tif (digest != null) {\n\t\t\t\t\t\t\t\tdigest.update(data);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (InterruptedException ex) {\n\t\t\t\t\tLOG.error(ex, ex);\n\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\tthrow new EucalyptusCloudException(\"Transfer interrupted: \" + key + \".\" + randomKey);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\n\t\treply.setEtag(md5);\n\t\treply.setLastModified(DateUtils.format(lastModified.getTime(), DateUtils.RFC822_DATETIME_PATTERN));\n\t\treturn reply;\n\t}","commit_id":"2841c3707b6b918bd84b2e849d107d154ad2a2e2","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DeleteObjectResponseType deleteObject(DeleteObjectType request) throws EucalyptusCloudException {\n\t\tDeleteObjectResponseType reply = (DeleteObjectResponseType) request.getReply();\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfos = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.queryEscape(bucketInfos);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucketInfo = bucketList.get(0);\n\t\t\tBucketLogData logData = bucketInfo.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\tif (ctx.hasAdministrativePrivileges()\n\t\t\t\t\t|| (bucketInfo.canWrite(account.getAccountNumber()) && (bucketInfo.isGlobalWrite() || Lookups.checkPrivilege(PolicySpec.S3_DELETEOBJECT,\n\t\t\t\t\t\t\tPolicySpec.VENDOR_S3, PolicySpec.S3_RESOURCE_BUCKET, bucketInfo.getBucketName(), null)))) {\n\n\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\n\t\t\t\tif (bucketInfo.isVersioningEnabled()) {\n\t\t\t\t\t// Versioning is enabled, so place delete marker.\n\t\t\t\t\tObjectInfo searchDeletedObjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\tsearchDeletedObjectInfo.setDeleted(true);\n\t\t\t\t\tsearchDeletedObjectInfo.setLast(true);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdbObject.getUniqueEscape(searchDeletedObjectInfo);\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t// Delete marker already exists, can't double delete\n\t\t\t\t\t\tthrow new NoSuchEntityException(objectKey, logData);\n\t\t\t\t\t} catch (NoSuchEntityException ex) {\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t} catch (EucalyptusCloudException ex) {\n\t\t\t\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\t\tsearchObjectInfo.setLast(true);\n\t\t\t\t\t\tList<ObjectInfo> objectInfos = dbObject.queryEscape(searchObjectInfo);\n\t\t\t\t\t\tfor (ObjectInfo objInfo : objectInfos) {\n\t\t\t\t\t\t\tobjInfo.setLast(false);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Add the delete marker\n\t\t\t\t\t\tObjectInfo deleteMarker = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\t\tdeleteMarker.setDeleted(true);\n\t\t\t\t\t\tdeleteMarker.setLast(true);\n\t\t\t\t\t\tdeleteMarker.setOwnerId(account.getAccountNumber());\n\t\t\t\t\t\tdeleteMarker.setLastModified(new Date());\n\t\t\t\t\t\tdeleteMarker.setVersionId(UUID.randomUUID().toString().replaceAll(\"-\", \"\"));\n\t\t\t\t\t\tdbObject.add(deleteMarker);\n\n\t\t\t\t\t\treply.setCode(\"200\");\n\t\t\t\t\t\treply.setDescription(\"OK\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Versioning disabled or suspended.\n\t\t\t\t\t * \n\t\t\t\t\t * Only delete 'null' versioned objects. If versioning is suspended then insert a delete marker. If versioning is suspended and no 'null'\n\t\t\t\t\t * version object exists then simply insert a delete marker\n\t\t\t\t\t */\n\t\t\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\t// searchObjectInfo.setVersionId(WalrusProperties.NULL_VERSION_ID);\n\t\t\t\t\tsearchObjectInfo.setLast(true);\n\t\t\t\t\tsearchObjectInfo.setDeleted(false);\n\t\t\t\t\tList<ObjectInfo> objectInfos = dbObject.queryEscape(searchObjectInfo);\n\n\t\t\t\t\tif (objectInfos.size() > 0) {\n\t\t\t\t\t\tif (objectInfos.size() > 1) {\n\t\t\t\t\t\t\t// This shouldn't happen, so bail if it does\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new EucalyptusCloudException(\"More than one object set to 'last' found\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tObjectInfo lastObject = objectInfos.get(0);\n\t\t\t\t\t\tif (lastObject.getVersionId().equals(WalrusProperties.NULL_VERSION_ID)) {\n\t\t\t\t\t\t\t// Remove the 'null' versioned object\n\t\t\t\t\t\t\tObjectInfo nullObject = lastObject;\n\t\t\t\t\t\t\tdbObject.delete(nullObject);\n\t\t\t\t\t\t\tString objectName = nullObject.getObjectName();\n\t\t\t\t\t\t\tfor (GrantInfo grantInfo : nullObject.getGrants()) {\n\t\t\t\t\t\t\t\tdb.delete(grantInfo);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tLong size = nullObject.getSize();\n\t\t\t\t\t\t\tboolean success = false;\n\t\t\t\t\t\t\tint retryCount = 0;\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tdecrementBucketSize(bucketName, size);\n\t\t\t\t\t\t\t\t\tsuccess = true;\n\t\t\t\t\t\t\t\t} catch (NoSuchBucketException ex) {\n\t\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t\t} catch (RollbackException ex) {\n\t\t\t\t\t\t\t\t\tretryCount++;\n\t\t\t\t\t\t\t\t\tLOG.trace(\"retrying update: \" + bucketName);\n\t\t\t\t\t\t\t\t} catch (EucalyptusCloudException ex) {\n\t\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} while (!success && (retryCount < 5));\n\t\t\t\t\t\t\tObjectDeleter objectDeleter = new ObjectDeleter(bucketName, objectName, objectKey, WalrusProperties.NULL_VERSION_ID, size, ctx\n\t\t\t\t\t\t\t\t\t.getUser().getName(), ctx.getUser().getUserId(), ctx.getAccount().getName(), ctx.getAccount().getAccountNumber());\n\t\t\t\t\t\t\tThreads.lookup(Walrus.class, WalrusManager.ObjectDeleter.class).limitTo(10).submit(objectDeleter);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (bucketInfo.isVersioningSuspended()) {\n\t\t\t\t\t\t\t\t// Some version found, don't delete it, just\n\t\t\t\t\t\t\t\t// make it not last.\n\t\t\t\t\t\t\t\t// This is possible when versiong was suspended\n\t\t\t\t\t\t\t\t// and no object uploaded since then\n\t\t\t\t\t\t\t\tlastObject.setLast(false);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(\n\t\t\t\t\t\t\t\t\t\t\"Non 'null' versioned object found in a versioning disabled bucket, not sure how to proceed with delete.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treply.setCode(\"200\");\n\t\t\t\t\t\treply.setDescription(\"OK\");\n\t\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\t\tupdateLogData(bucketInfo, logData);\n\t\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (bucketInfo.isVersioningSuspended()) {\n\t\t\t\t\t\t\t// Add the delete marker\n\t\t\t\t\t\t\tObjectInfo deleteMarker = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\t\t\tdeleteMarker.setDeleted(true);\n\t\t\t\t\t\t\tdeleteMarker.setLast(true);\n\t\t\t\t\t\t\tdeleteMarker.setOwnerId(account.getAccountNumber());\n\t\t\t\t\t\t\tdeleteMarker.setLastModified(new Date());\n\t\t\t\t\t\t\tdeleteMarker.setVersionId(UUID.randomUUID().toString().replaceAll(\"-\", \"\"));\n\t\t\t\t\t\t\tdbObject.add(deleteMarker);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// No 'last' record found that isn't 'deleted'\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new NoSuchEntityException(objectKey, logData);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","id":99864,"modified_method":"public DeleteObjectResponseType deleteObject(DeleteObjectType request) throws EucalyptusCloudException {\n\t\tDeleteObjectResponseType reply = (DeleteObjectResponseType) request.getReply();\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfos = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.queryEscape(bucketInfos);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucketInfo = bucketList.get(0);\n\t\t\tBucketLogData logData = bucketInfo.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\tif (ctx.hasAdministrativePrivileges()\n\t\t\t\t\t|| (bucketInfo.canWrite(account.getAccountNumber()) && (bucketInfo.isGlobalWrite() || Lookups.checkPrivilege(PolicySpec.S3_DELETEOBJECT,\n\t\t\t\t\t\t\tPolicySpec.VENDOR_S3, PolicySpec.S3_RESOURCE_BUCKET, bucketInfo.getBucketName(), null)))) {\n\n\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\n\t\t\t\tif (bucketInfo.isVersioningEnabled()) {\n\t\t\t\t\t// Versioning is enabled, look for delete marker. If one is present, do nothing. Otherwise place delete marker.\n\t\t\t\t\tObjectInfo searchDeletedObjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\tsearchDeletedObjectInfo.setDeleted(true);\n\t\t\t\t\tsearchDeletedObjectInfo.setLast(true);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdbObject.getUniqueEscape(searchDeletedObjectInfo);\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t// Delete marker already exists, nothing to do here\n\t\t\t\t\t\tLOG.debug(\"Object \" + objectKey + \" has a delete marker in bucket \" + bucketName + \" that is marked latest. Nothing to delete\");\n\t\t\t\t\t} catch (NoSuchEntityException ex) {\n\t\t\t\t\t\t// No such key found, nothing to do here\n\t\t\t\t\t\tLOG.debug(\"Object \" + objectKey + \" not found in bucket \" + bucketName + \". Nothing to delete\");\n\t\t\t\t\t} catch (EucalyptusCloudException ex) {\n\t\t\t\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\t\tsearchObjectInfo.setLast(true);\n\t\t\t\t\t\tList<ObjectInfo> objectInfos = dbObject.queryEscape(searchObjectInfo);\n\t\t\t\t\t\tfor (ObjectInfo objInfo : objectInfos) {\n\t\t\t\t\t\t\tobjInfo.setLast(false);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Add the delete marker\n\t\t\t\t\t\tObjectInfo deleteMarker = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\t\tdeleteMarker.setDeleted(true);\n\t\t\t\t\t\tdeleteMarker.setLast(true);\n\t\t\t\t\t\tdeleteMarker.setOwnerId(account.getAccountNumber());\n\t\t\t\t\t\tdeleteMarker.setLastModified(new Date());\n\t\t\t\t\t\tdeleteMarker.setVersionId(UUID.randomUUID().toString().replaceAll(\"-\", \"\"));\n\t\t\t\t\t\tdbObject.add(deleteMarker);\n\t\t\t\t\t}\n\n\t\t\t\t\t// In either case, set the response to 200 OK\n\t\t\t\t\treply.setCode(\"200\");\n\t\t\t\t\treply.setDescription(\"OK\");\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Versioning disabled or suspended.\n\t\t\t\t\t * \n\t\t\t\t\t * Only delete 'null' versioned objects. If versioning is suspended then insert a delete marker. If versioning is suspended and no 'null'\n\t\t\t\t\t * version object exists then simply insert a delete marker\n\t\t\t\t\t */\n\t\t\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\t// searchObjectInfo.setVersionId(WalrusProperties.NULL_VERSION_ID);\n\t\t\t\t\tsearchObjectInfo.setLast(true);\n\t\t\t\t\tsearchObjectInfo.setDeleted(false);\n\t\t\t\t\tList<ObjectInfo> objectInfos = dbObject.queryEscape(searchObjectInfo);\n\n\t\t\t\t\tif (objectInfos.size() > 0) {\n\t\t\t\t\t\tif (objectInfos.size() > 1) {\n\t\t\t\t\t\t\t// This shouldn't happen, so bail if it does\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new EucalyptusCloudException(\"More than one object set to 'last' found\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tObjectInfo lastObject = objectInfos.get(0);\n\t\t\t\t\t\tif (lastObject.getVersionId().equals(WalrusProperties.NULL_VERSION_ID)) {\n\t\t\t\t\t\t\t// Remove the 'null' versioned object\n\t\t\t\t\t\t\tObjectInfo nullObject = lastObject;\n\t\t\t\t\t\t\tdbObject.delete(nullObject);\n\t\t\t\t\t\t\tString objectName = nullObject.getObjectName();\n\t\t\t\t\t\t\tfor (GrantInfo grantInfo : nullObject.getGrants()) {\n\t\t\t\t\t\t\t\tdb.delete(grantInfo);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tLong size = nullObject.getSize();\n\t\t\t\t\t\t\tboolean success = false;\n\t\t\t\t\t\t\tint retryCount = 0;\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tdecrementBucketSize(bucketName, size);\n\t\t\t\t\t\t\t\t\tsuccess = true;\n\t\t\t\t\t\t\t\t} catch (NoSuchBucketException ex) {\n\t\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t\t} catch (RollbackException ex) {\n\t\t\t\t\t\t\t\t\tretryCount++;\n\t\t\t\t\t\t\t\t\tLOG.trace(\"retrying update: \" + bucketName);\n\t\t\t\t\t\t\t\t} catch (EucalyptusCloudException ex) {\n\t\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} while (!success && (retryCount < 5));\n\t\t\t\t\t\t\tObjectDeleter objectDeleter = new ObjectDeleter(bucketName, objectName, objectKey, WalrusProperties.NULL_VERSION_ID, size, ctx\n\t\t\t\t\t\t\t\t\t.getUser().getName(), ctx.getUser().getUserId(), ctx.getAccount().getName(), ctx.getAccount().getAccountNumber());\n\t\t\t\t\t\t\tThreads.lookup(Walrus.class, WalrusManager.ObjectDeleter.class).limitTo(10).submit(objectDeleter);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (bucketInfo.isVersioningSuspended()) {\n\t\t\t\t\t\t\t\t// Some version found, don't delete it, just make it not last. This is possible when versioning was suspended and no object\n\t\t\t\t\t\t\t\t// uploaded since then\n\t\t\t\t\t\t\t\tlastObject.setLast(false);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(\n\t\t\t\t\t\t\t\t\t\t\"Non 'null' versioned object found in a versioning disabled bucket, not sure how to proceed with delete.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\t\tupdateLogData(bucketInfo, logData);\n\t\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (bucketInfo.isVersioningSuspended()) {\n\t\t\t\t\t\t\t// Add the delete marker with null versioning ID\n\t\t\t\t\t\t\tObjectInfo deleteMarker = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\t\t\tdeleteMarker.setDeleted(true);\n\t\t\t\t\t\t\tdeleteMarker.setLast(true);\n\t\t\t\t\t\t\tdeleteMarker.setOwnerId(account.getAccountNumber());\n\t\t\t\t\t\t\tdeleteMarker.setLastModified(new Date());\n\t\t\t\t\t\t\tdeleteMarker.setVersionId(WalrusProperties.NULL_VERSION_ID);\n\t\t\t\t\t\t\tdeleteMarker.setSize(0L);\n\t\t\t\t\t\t\tdbObject.add(deleteMarker);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// No 'last' record found that isn't 'deleted'\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tLOG.debug(\"Object \" + objectKey + \" not found in bucket \" + bucketName + \". Nothing to delete\");\n\t\t\t\t\t}\n\t\t\t\t\t// In either case, set the response to 200 OK\n\t\t\t\t\treply.setCode(\"200\");\n\t\t\t\t\treply.setDescription(\"OK\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","commit_id":"2841c3707b6b918bd84b2e849d107d154ad2a2e2","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DeleteVersionResponseType deleteVersion(DeleteVersionType request) throws EucalyptusCloudException {\n\t\tDeleteVersionResponseType reply = (DeleteVersionResponseType) request.getReply();\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfos = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.queryEscape(bucketInfos);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucketInfo = bucketList.get(0);\n\t\t\tBucketLogData logData = bucketInfo.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\tObjectInfo foundObject = null;\n\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\tif (request.getVersionid() == null) {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new EucalyptusCloudException(\"versionId is null\");\n\t\t\t}\n\t\t\tsearchObjectInfo.setVersionId(request.getVersionid());\n\t\t\tList<ObjectInfo> objectInfos = dbObject.queryEscape(searchObjectInfo);\n\t\t\tif (objectInfos.size() > 0) {\n\t\t\t\tfoundObject = objectInfos.get(0);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The admin can always delete object versions, and if versioning is suspended then only the bucket owner can delete a specific version. If bucket\n\t\t\t * versioning is enabled then do the normal permissions check to grant permissions.\n\t\t\t */\n\t\t\tif (foundObject != null) {\n\t\t\t\tif (ctx.hasAdministrativePrivileges()\n\t\t\t\t\t\t|| ((bucketInfo.isVersioningSuspended() && bucketInfo.getOwnerId().equals(ctx.getUser().getUserId())) || (bucketInfo\n\t\t\t\t\t\t\t\t.isVersioningEnabled() && Lookups.checkPrivilege(PolicySpec.S3_DELETEOBJECTVERSION, PolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_OBJECT, PolicySpec.objectFullName(bucketName, objectKey), foundObject.getOwnerId())))) {\n\n\t\t\t\t\tdbObject.delete(foundObject);\n\t\t\t\t\tif (!foundObject.getDeleted()) {\n\t\t\t\t\t\tString objectName = foundObject.getObjectName();\n\t\t\t\t\t\tfor (GrantInfo grantInfo : foundObject.getGrants()) {\n\t\t\t\t\t\t\tdb.delete(grantInfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tLong size = foundObject.getSize();\n\n\t\t\t\t\t\tboolean success = false;\n\t\t\t\t\t\tint retryCount = 0;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tdecrementBucketSize(bucketName, size);\n\t\t\t\t\t\t\t\tsuccess = true;\n\t\t\t\t\t\t\t} catch (NoSuchBucketException ex) {\n\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t} catch (RollbackException ex) {\n\t\t\t\t\t\t\t\tretryCount++;\n\t\t\t\t\t\t\t\tLOG.trace(\"retrying update: \" + bucketName);\n\t\t\t\t\t\t\t} catch (EucalyptusCloudException ex) {\n\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while (!success && (retryCount < 5));\n\n\t\t\t\t\t\tObjectDeleter objectDeleter = new ObjectDeleter(bucketName, objectName, foundObject.getObjectKey(), foundObject.getVersionId(), size,\n\t\t\t\t\t\t\t\tctx.getUser().getName(), ctx.getUser().getUserId(), ctx.getAccount().getName(), ctx.getAccount().getAccountNumber());\n\t\t\t\t\t\tThreads.lookup(Walrus.class, WalrusManager.ObjectDeleter.class).limitTo(10).submit(objectDeleter);\n\t\t\t\t\t}\n\t\t\t\t\treply.setCode(\"200\");\n\t\t\t\t\treply.setDescription(\"OK\");\n\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\tupdateLogData(bucketInfo, logData);\n\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdb.rollback();\n\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey, logData);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new NoSuchEntityException(objectKey, logData);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","id":99865,"modified_method":"public DeleteVersionResponseType deleteVersion(DeleteVersionType request) throws EucalyptusCloudException {\n\t\tDeleteVersionResponseType reply = (DeleteVersionResponseType) request.getReply();\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfos = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.queryEscape(bucketInfos);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucketInfo = bucketList.get(0);\n\t\t\tBucketLogData logData = bucketInfo.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\tObjectInfo foundObject = null;\n\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\tif (request.getVersionid() == null) {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new EucalyptusCloudException(\"versionId is null\");\n\t\t\t}\n\t\t\tsearchObjectInfo.setVersionId(request.getVersionid());\n\t\t\tList<ObjectInfo> objectInfos = dbObject.queryEscape(searchObjectInfo);\n\t\t\tif (objectInfos.size() > 0) {\n\t\t\t\tfoundObject = objectInfos.get(0);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The admin can always delete object versions, and if versioning is suspended then only the bucket owner can delete a specific version. If bucket\n\t\t\t * versioning is enabled then do the normal permissions check to grant permissions.\n\t\t\t */\n\t\t\tif (foundObject != null) {\n\t\t\t\tif (ctx.hasAdministrativePrivileges()\n\t\t\t\t\t\t|| (bucketInfo.getOwnerId().equals(account.getAccountNumber()) && Lookups\n\t\t\t\t\t\t\t\t.checkPrivilege(PolicySpec.S3_DELETEOBJECTVERSION, PolicySpec.VENDOR_S3, PolicySpec.S3_RESOURCE_OBJECT,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.objectFullName(bucketName, objectKey), foundObject.getOwnerId()))) {\n\n\t\t\t\t\tdbObject.delete(foundObject);\n\t\t\t\t\tif (!foundObject.getDeleted()) {\n\t\t\t\t\t\tString objectName = foundObject.getObjectName();\n\t\t\t\t\t\tfor (GrantInfo grantInfo : foundObject.getGrants()) {\n\t\t\t\t\t\t\tdb.delete(grantInfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tLong size = foundObject.getSize();\n\n\t\t\t\t\t\tboolean success = false;\n\t\t\t\t\t\tint retryCount = 0;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tdecrementBucketSize(bucketName, size);\n\t\t\t\t\t\t\t\tsuccess = true;\n\t\t\t\t\t\t\t} catch (NoSuchBucketException ex) {\n\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t} catch (RollbackException ex) {\n\t\t\t\t\t\t\t\tretryCount++;\n\t\t\t\t\t\t\t\tLOG.trace(\"retrying update: \" + bucketName);\n\t\t\t\t\t\t\t} catch (EucalyptusCloudException ex) {\n\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while (!success && (retryCount < 5));\n\n\t\t\t\t\t\tObjectDeleter objectDeleter = new ObjectDeleter(bucketName, objectName, foundObject.getObjectKey(), foundObject.getVersionId(), size,\n\t\t\t\t\t\t\t\tctx.getUser().getName(), ctx.getUser().getUserId(), ctx.getAccount().getName(), ctx.getAccount().getAccountNumber());\n\t\t\t\t\t\tThreads.lookup(Walrus.class, WalrusManager.ObjectDeleter.class).limitTo(10).submit(objectDeleter);\n\t\t\t\t\t}\n\t\t\t\t\treply.setCode(\"200\");\n\t\t\t\t\treply.setDescription(\"OK\");\n\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\tupdateLogData(bucketInfo, logData);\n\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdb.rollback();\n\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey, logData);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new NoSuchEntityException(objectKey, logData);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","commit_id":"2841c3707b6b918bd84b2e849d107d154ad2a2e2","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public CopyObjectResponseType copyObject(CopyObjectType request) throws EucalyptusCloudException {\n\t\tCopyObjectResponseType reply = (CopyObjectResponseType) request.getReply();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\t\tString sourceBucket = request.getSourceBucket();\n\t\tString sourceKey = request.getSourceObject();\n\t\tString sourceVersionId = request.getSourceVersionId();\n\t\tString destinationBucket = request.getDestinationBucket();\n\t\tString destinationKey = request.getDestinationObject();\n\t\tString metadataDirective = request.getMetadataDirective();\n\t\tAccessControlListType accessControlList = request.getAccessControlList();\n\n\t\tString copyIfMatch = request.getCopySourceIfMatch();\n\t\tString copyIfNoneMatch = request.getCopySourceIfNoneMatch();\n\t\tDate copyIfUnmodifiedSince = request.getCopySourceIfUnmodifiedSince();\n\t\tDate copyIfModifiedSince = request.getCopySourceIfModifiedSince();\n\n\t\tif (metadataDirective == null) {\n\t\t\tmetadataDirective = \"COPY\";\n\t\t}\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfo = new BucketInfo(sourceBucket);\n\t\tList<BucketInfo> bucketList = db.queryEscape(bucketInfo);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(sourceBucket, sourceKey);\n\t\t\tsearchObjectInfo.setVersionId(sourceVersionId);\n\t\t\tif (sourceVersionId == null) {\n\t\t\t\tsearchObjectInfo.setLast(true);\n\t\t\t}\n\t\t\tList<ObjectInfo> objectInfos = dbObject.queryEscape(searchObjectInfo);\n\t\t\tif (objectInfos.size() > 0) {\n\t\t\t\tObjectInfo sourceObjectInfo = objectInfos.get(0);\n\t\t\t\tif (ctx.hasAdministrativePrivileges()\n\t\t\t\t\t\t|| (sourceObjectInfo.canRead(account.getAccountNumber()) && (sourceObjectInfo.isGlobalRead() || Lookups.checkPrivilege(\n\t\t\t\t\t\t\t\tPolicySpec.S3_GETOBJECT, PolicySpec.VENDOR_S3, PolicySpec.S3_RESOURCE_OBJECT,\n\t\t\t\t\t\t\t\tPolicySpec.objectFullName(sourceBucket, sourceKey), null)))) {\n\t\t\t\t\tif (copyIfMatch != null) {\n\t\t\t\t\t\tif (!copyIfMatch.equals(sourceObjectInfo.getEtag())) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new PreconditionFailedException(sourceKey + \" CopySourceIfMatch: \" + copyIfMatch);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (copyIfNoneMatch != null) {\n\t\t\t\t\t\tif (copyIfNoneMatch.equals(sourceObjectInfo.getEtag())) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new PreconditionFailedException(sourceKey + \" CopySourceIfNoneMatch: \" + copyIfNoneMatch);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (copyIfUnmodifiedSince != null) {\n\t\t\t\t\t\tlong unmodifiedTime = copyIfUnmodifiedSince.getTime();\n\t\t\t\t\t\tlong objectTime = sourceObjectInfo.getLastModified().getTime();\n\t\t\t\t\t\tif (unmodifiedTime < objectTime) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new PreconditionFailedException(sourceKey + \" CopySourceIfUnmodifiedSince: \" + copyIfUnmodifiedSince.toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (copyIfModifiedSince != null) {\n\t\t\t\t\t\tlong modifiedTime = copyIfModifiedSince.getTime();\n\t\t\t\t\t\tlong objectTime = sourceObjectInfo.getLastModified().getTime();\n\t\t\t\t\t\tif (modifiedTime > objectTime) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new PreconditionFailedException(sourceKey + \" CopySourceIfModifiedSince: \" + copyIfModifiedSince.toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tBucketInfo destinationBucketInfo = new BucketInfo(destinationBucket);\n\t\t\t\t\tList<BucketInfo> destinationBuckets = db.queryEscape(destinationBucketInfo);\n\t\t\t\t\tif (destinationBuckets.size() > 0) {\n\t\t\t\t\t\tBucketInfo foundDestinationBucketInfo = destinationBuckets.get(0);\n\t\t\t\t\t\tif (ctx.hasAdministrativePrivileges()\n\t\t\t\t\t\t\t\t|| (foundDestinationBucketInfo.canWrite(account.getAccountNumber()) && (foundDestinationBucketInfo.isGlobalWrite() || Lookups\n\t\t\t\t\t\t\t\t\t\t.checkPrivilege(PolicySpec.S3_PUTOBJECT, PolicySpec.VENDOR_S3, PolicySpec.S3_RESOURCE_BUCKET, destinationBucket, null)))) {\n\t\t\t\t\t\t\t// all ok\n\t\t\t\t\t\t\tLong destinationObjectOldSize = 0L;\n\t\t\t\t\t\t\tString destinationVersionId = sourceVersionId;\n\t\t\t\t\t\t\tObjectInfo destinationObjectInfo = null;\n\t\t\t\t\t\t\tString destinationObjectName;\n\t\t\t\t\t\t\tObjectInfo destSearchObjectInfo = new ObjectInfo(destinationBucket, destinationKey);\n\t\t\t\t\t\t\tif (foundDestinationBucketInfo.isVersioningEnabled()) {\n\t\t\t\t\t\t\t\tdestinationVersionId = UUID.randomUUID().toString().replaceAll(\"-\", \"\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdestinationVersionId = WalrusProperties.NULL_VERSION_ID;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdestSearchObjectInfo.setVersionId(destinationVersionId);\n\t\t\t\t\t\t\tList<ObjectInfo> destinationObjectInfos = dbObject.queryEscape(destSearchObjectInfo);\n\t\t\t\t\t\t\tif (destinationObjectInfos.size() > 0) {\n\t\t\t\t\t\t\t\tdestinationObjectInfo = destinationObjectInfos.get(0);\n\t\t\t\t\t\t\t\tif (!destinationObjectInfo.canWrite(account.getAccountNumber())) {\n\t\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", destinationKey);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tboolean addNew = false;\n\t\t\t\t\t\t\tif (destinationObjectInfo == null) {\n\t\t\t\t\t\t\t\t// not found. create a new one\n\t\t\t\t\t\t\t\tif (ctx.hasAdministrativePrivileges()\n\t\t\t\t\t\t\t\t\t\t|| (Permissions.isAuthorized(PolicySpec.VENDOR_S3, PolicySpec.S3_RESOURCE_OBJECT, sourceBucket, ctx.getAccount(),\n\t\t\t\t\t\t\t\t\t\t\t\tPolicySpec.S3_PUTOBJECT, ctx.getUser()) && Permissions\n\t\t\t\t\t\t\t\t\t\t\t\t.canAllocate(PolicySpec.VENDOR_S3, PolicySpec.S3_RESOURCE_OBJECT, sourceBucket, PolicySpec.S3_PUTOBJECT,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tctx.getUser(), sourceObjectInfo.getSize()))) {\n\t\t\t\t\t\t\t\t\taddNew = true;\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo = new ObjectInfo();\n\t\t\t\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo.setBucketName(destinationBucket);\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo.setObjectKey(destinationKey);\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo.addGrants(account.getAccountNumber(), foundDestinationBucketInfo.getOwnerId(), grantInfos,\n\t\t\t\t\t\t\t\t\t\t\taccessControlList);\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo.setGrants(grantInfos);\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo.setObjectName(UUID.randomUUID().toString());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (ctx.hasAdministrativePrivileges()\n\t\t\t\t\t\t\t\t\t\t|| (destinationObjectInfo.canWriteACP(account.getAccountNumber()) && (destinationObjectInfo.isGlobalWriteACP() || Lookups\n\t\t\t\t\t\t\t\t\t\t\t\t.checkPrivilege(PolicySpec.S3_PUTOBJECTACL, PolicySpec.VENDOR_S3, PolicySpec.S3_RESOURCE_OBJECT,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPolicySpec.objectFullName(destinationBucket, destinationKey), null)))) {\n\t\t\t\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo.addGrants(account.getAccountNumber(), foundDestinationBucketInfo.getOwnerId(), grantInfos,\n\t\t\t\t\t\t\t\t\t\t\taccessControlList);\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo.setGrants(grantInfos);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdestinationObjectOldSize = destinationObjectInfo.getSize();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdestinationObjectInfo.setSize(sourceObjectInfo.getSize());\n\t\t\t\t\t\t\tdestinationObjectInfo.setStorageClass(sourceObjectInfo.getStorageClass());\n\t\t\t\t\t\t\tdestinationObjectInfo.setOwnerId(sourceObjectInfo.getOwnerId());\n\t\t\t\t\t\t\tdestinationObjectInfo.setContentType(sourceObjectInfo.getContentType());\n\t\t\t\t\t\t\tdestinationObjectInfo.setContentDisposition(sourceObjectInfo.getContentDisposition());\n\t\t\t\t\t\t\tString etag = sourceObjectInfo.getEtag();\n\t\t\t\t\t\t\tDate lastModified = sourceObjectInfo.getLastModified();\n\t\t\t\t\t\t\tdestinationObjectInfo.setEtag(etag);\n\t\t\t\t\t\t\tdestinationObjectInfo.setLastModified(lastModified);\n\t\t\t\t\t\t\tdestinationObjectInfo.setVersionId(destinationVersionId);\n\t\t\t\t\t\t\tdestinationObjectInfo.setLast(true);\n\t\t\t\t\t\t\tdestinationObjectInfo.setDeleted(false);\n\t\t\t\t\t\t\tif (!metadataDirective.equals(\"REPLACE\")) {\n\t\t\t\t\t\t\t\tdestinationObjectInfo.setMetaData(sourceObjectInfo.cloneMetaData());\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tList<MetaDataEntry> metaData = request.getMetaData();\n\t\t\t\t\t\t\t\tif (metaData != null)\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo.replaceMetaData(metaData);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tString sourceObjectName = sourceObjectInfo.getObjectName();\n\t\t\t\t\t\t\tdestinationObjectName = destinationObjectInfo.getObjectName();\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tstorageManager.copyObject(sourceBucket, sourceObjectName, destinationBucket, destinationObjectName);\n\t\t\t\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(\"Could not rename \" + sourceObjectName + \" to \" + destinationObjectName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (addNew)\n\t\t\t\t\t\t\t\tdbObject.add(destinationObjectInfo);\n\n\t\t\t\t\t\t\treply.setEtag(etag);\n\t\t\t\t\t\t\treply.setLastModified(DateUtils.format(lastModified.getTime(), DateUtils.RFC822_DATETIME_PATTERN));\n\n\t\t\t\t\t\t\tif (foundDestinationBucketInfo.isVersioningEnabled()) {\n\t\t\t\t\t\t\t\treply.setCopySourceVersionId(sourceVersionId);\n\t\t\t\t\t\t\t\treply.setVersionId(destinationVersionId);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdb.commit();\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t// Fixes EUCA-3756. Reporting event for copy\n\t\t\t\t\t\t\t\t// objects\n\t\t\t\t\t\t\t\tfireObjectCreationEvent(destinationBucket, destinationObjectName, destinationVersionId, ctx.getUser().getUserId(),\n\t\t\t\t\t\t\t\t\t\tdestinationObjectInfo.getSize(), destinationObjectOldSize);\n\t\t\t\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\t\t\t\tLOG.debug(\"Failed to fire reporting event for walrus COPY object operation\", ex);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn reply;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\", destinationBucket);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new NoSuchBucketException(destinationBucket);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdb.rollback();\n\t\t\t\t\tthrow new AccessDeniedException(\"Key\", sourceKey);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new NoSuchEntityException(sourceKey);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(sourceBucket);\n\t\t}\n\t}","id":99866,"modified_method":"public CopyObjectResponseType copyObject(CopyObjectType request) throws EucalyptusCloudException {\n\t\tCopyObjectResponseType reply = (CopyObjectResponseType) request.getReply();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\t\tString sourceBucket = request.getSourceBucket();\n\t\tString sourceKey = request.getSourceObject();\n\t\tString sourceVersionId = request.getSourceVersionId();\n\t\tString destinationBucket = request.getDestinationBucket();\n\t\tString destinationKey = request.getDestinationObject();\n\t\tString metadataDirective = request.getMetadataDirective();\n\t\tAccessControlListType accessControlList = request.getAccessControlList();\n\n\t\tString copyIfMatch = request.getCopySourceIfMatch();\n\t\tString copyIfNoneMatch = request.getCopySourceIfNoneMatch();\n\t\tDate copyIfUnmodifiedSince = request.getCopySourceIfUnmodifiedSince();\n\t\tDate copyIfModifiedSince = request.getCopySourceIfModifiedSince();\n\n\t\tif (metadataDirective == null) {\n\t\t\tmetadataDirective = \"COPY\";\n\t\t}\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfo = new BucketInfo(sourceBucket);\n\t\tList<BucketInfo> bucketList = db.queryEscape(bucketInfo);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(sourceBucket, sourceKey);\n\t\t\tsearchObjectInfo.setVersionId(sourceVersionId);\n\t\t\tif (sourceVersionId == null) {\n\t\t\t\tsearchObjectInfo.setLast(true);\n\t\t\t}\n\t\t\tList<ObjectInfo> objectInfos = dbObject.queryEscape(searchObjectInfo);\n\t\t\tif (objectInfos.size() > 0) {\n\t\t\t\tObjectInfo sourceObjectInfo = objectInfos.get(0);\n\t\t\t\tif (ctx.hasAdministrativePrivileges()\n\t\t\t\t\t\t|| (sourceObjectInfo.canRead(account.getAccountNumber()) && (sourceObjectInfo.isGlobalRead() || Lookups.checkPrivilege(\n\t\t\t\t\t\t\t\tPolicySpec.S3_GETOBJECT, PolicySpec.VENDOR_S3, PolicySpec.S3_RESOURCE_OBJECT,\n\t\t\t\t\t\t\t\tPolicySpec.objectFullName(sourceBucket, sourceKey), null)))) {\n\t\t\t\t\tif (copyIfMatch != null) {\n\t\t\t\t\t\tif (!copyIfMatch.equals(sourceObjectInfo.getEtag())) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new PreconditionFailedException(sourceKey + \" CopySourceIfMatch: \" + copyIfMatch);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (copyIfNoneMatch != null) {\n\t\t\t\t\t\tif (copyIfNoneMatch.equals(sourceObjectInfo.getEtag())) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new PreconditionFailedException(sourceKey + \" CopySourceIfNoneMatch: \" + copyIfNoneMatch);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (copyIfUnmodifiedSince != null) {\n\t\t\t\t\t\tlong unmodifiedTime = copyIfUnmodifiedSince.getTime();\n\t\t\t\t\t\tlong objectTime = sourceObjectInfo.getLastModified().getTime();\n\t\t\t\t\t\tif (unmodifiedTime < objectTime) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new PreconditionFailedException(sourceKey + \" CopySourceIfUnmodifiedSince: \" + copyIfUnmodifiedSince.toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (copyIfModifiedSince != null) {\n\t\t\t\t\t\tlong modifiedTime = copyIfModifiedSince.getTime();\n\t\t\t\t\t\tlong objectTime = sourceObjectInfo.getLastModified().getTime();\n\t\t\t\t\t\tif (modifiedTime > objectTime) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new PreconditionFailedException(sourceKey + \" CopySourceIfModifiedSince: \" + copyIfModifiedSince.toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tBucketInfo destinationBucketInfo = new BucketInfo(destinationBucket);\n\t\t\t\t\tList<BucketInfo> destinationBuckets = db.queryEscape(destinationBucketInfo);\n\t\t\t\t\tif (destinationBuckets.size() > 0) {\n\t\t\t\t\t\tBucketInfo foundDestinationBucketInfo = destinationBuckets.get(0);\n\t\t\t\t\t\tif (ctx.hasAdministrativePrivileges()\n\t\t\t\t\t\t\t\t|| (foundDestinationBucketInfo.canWrite(account.getAccountNumber()) && (foundDestinationBucketInfo.isGlobalWrite() || Lookups\n\t\t\t\t\t\t\t\t\t\t.checkPrivilege(PolicySpec.S3_PUTOBJECT, PolicySpec.VENDOR_S3, PolicySpec.S3_RESOURCE_BUCKET, destinationBucket, null)))) {\n\t\t\t\t\t\t\t// all ok\n\t\t\t\t\t\t\tLong destinationObjectOldSize = 0L;\n\t\t\t\t\t\t\tString destinationVersionId = sourceVersionId;\n\t\t\t\t\t\t\tObjectInfo destinationObjectInfo = null;\n\t\t\t\t\t\t\tString destinationObjectName;\n\t\t\t\t\t\t\tObjectInfo destSearchObjectInfo = new ObjectInfo(destinationBucket, destinationKey);\n\t\t\t\t\t\t\tif (foundDestinationBucketInfo.isVersioningEnabled()) {\n\t\t\t\t\t\t\t\tdestinationVersionId = UUID.randomUUID().toString().replaceAll(\"-\", \"\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdestinationVersionId = WalrusProperties.NULL_VERSION_ID;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdestSearchObjectInfo.setVersionId(destinationVersionId);\n\t\t\t\t\t\t\tList<ObjectInfo> destinationObjectInfos = dbObject.queryEscape(destSearchObjectInfo);\n\t\t\t\t\t\t\tif (destinationObjectInfos.size() > 0) {\n\t\t\t\t\t\t\t\tdestinationObjectInfo = destinationObjectInfos.get(0);\n\t\t\t\t\t\t\t\t// Check privilege only if its not a delete marker, HACK!!\n\t\t\t\t\t\t\t\tif (!destinationObjectInfo.getDeleted() && !destinationObjectInfo.canWrite(account.getAccountNumber())) {\n\t\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", destinationKey);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tboolean addNew = false;\n\t\t\t\t\t\t\tif (destinationObjectInfo == null) {\n\t\t\t\t\t\t\t\t// not found. create a new one\n\t\t\t\t\t\t\t\tif (ctx.hasAdministrativePrivileges()\n\t\t\t\t\t\t\t\t\t\t|| (Permissions.isAuthorized(PolicySpec.VENDOR_S3, PolicySpec.S3_RESOURCE_OBJECT, sourceBucket, ctx.getAccount(),\n\t\t\t\t\t\t\t\t\t\t\t\tPolicySpec.S3_PUTOBJECT, ctx.getUser()) && Permissions\n\t\t\t\t\t\t\t\t\t\t\t\t.canAllocate(PolicySpec.VENDOR_S3, PolicySpec.S3_RESOURCE_OBJECT, sourceBucket, PolicySpec.S3_PUTOBJECT,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tctx.getUser(), sourceObjectInfo.getSize()))) {\n\t\t\t\t\t\t\t\t\taddNew = true;\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo = new ObjectInfo();\n\t\t\t\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo.setBucketName(destinationBucket);\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo.setObjectKey(destinationKey);\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo.addGrants(account.getAccountNumber(), foundDestinationBucketInfo.getOwnerId(), grantInfos,\n\t\t\t\t\t\t\t\t\t\t\taccessControlList);\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo.setGrants(grantInfos);\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo.setObjectName(UUID.randomUUID().toString());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// If its a delete marker, make the same checks as when the object was not found, HACK!!\n\t\t\t\t\t\t\t\tif (ctx.hasAdministrativePrivileges()\n\t\t\t\t\t\t\t\t\t\t|| (destinationObjectInfo.getDeleted()\n\t\t\t\t\t\t\t\t\t\t\t\t&& Permissions.isAuthorized(PolicySpec.VENDOR_S3, PolicySpec.S3_RESOURCE_OBJECT, sourceBucket,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tctx.getAccount(), PolicySpec.S3_PUTOBJECT, ctx.getUser()) && Permissions.canAllocate(\n\t\t\t\t\t\t\t\t\t\t\t\tPolicySpec.VENDOR_S3, PolicySpec.S3_RESOURCE_OBJECT, sourceBucket, PolicySpec.S3_PUTOBJECT, ctx.getUser(),\n\t\t\t\t\t\t\t\t\t\t\t\tsourceObjectInfo.getSize()))\n\t\t\t\t\t\t\t\t\t\t|| (destinationObjectInfo.canWriteACP(account.getAccountNumber()) && (destinationObjectInfo.isGlobalWriteACP() || Lookups\n\t\t\t\t\t\t\t\t\t\t\t\t.checkPrivilege(PolicySpec.S3_PUTOBJECTACL, PolicySpec.VENDOR_S3, PolicySpec.S3_RESOURCE_OBJECT,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPolicySpec.objectFullName(destinationBucket, destinationKey), null)))) {\n\t\t\t\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo.addGrants(account.getAccountNumber(), foundDestinationBucketInfo.getOwnerId(), grantInfos,\n\t\t\t\t\t\t\t\t\t\t\taccessControlList);\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo.setGrants(grantInfos);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdestinationObjectOldSize = destinationObjectInfo.getSize() == null ? 0L : destinationObjectInfo.getSize();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdestinationObjectInfo.setSize(sourceObjectInfo.getSize());\n\t\t\t\t\t\t\tdestinationObjectInfo.setStorageClass(sourceObjectInfo.getStorageClass());\n\t\t\t\t\t\t\tdestinationObjectInfo.setOwnerId(sourceObjectInfo.getOwnerId());\n\t\t\t\t\t\t\tdestinationObjectInfo.setContentType(sourceObjectInfo.getContentType());\n\t\t\t\t\t\t\tdestinationObjectInfo.setContentDisposition(sourceObjectInfo.getContentDisposition());\n\t\t\t\t\t\t\tString etag = sourceObjectInfo.getEtag();\n\t\t\t\t\t\t\tDate lastModified = sourceObjectInfo.getLastModified();\n\t\t\t\t\t\t\tdestinationObjectInfo.setEtag(etag);\n\t\t\t\t\t\t\tdestinationObjectInfo.setLastModified(lastModified);\n\t\t\t\t\t\t\tdestinationObjectInfo.setVersionId(destinationVersionId);\n\t\t\t\t\t\t\tdestinationObjectInfo.setLast(true);\n\t\t\t\t\t\t\tdestinationObjectInfo.setDeleted(false);\n\t\t\t\t\t\t\tif (!metadataDirective.equals(\"REPLACE\")) {\n\t\t\t\t\t\t\t\tdestinationObjectInfo.setMetaData(sourceObjectInfo.cloneMetaData());\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tList<MetaDataEntry> metaData = request.getMetaData();\n\t\t\t\t\t\t\t\tif (metaData != null)\n\t\t\t\t\t\t\t\t\tdestinationObjectInfo.replaceMetaData(metaData);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tString sourceObjectName = sourceObjectInfo.getObjectName();\n\t\t\t\t\t\t\tdestinationObjectName = destinationObjectInfo.getObjectName();\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tstorageManager.copyObject(sourceBucket, sourceObjectName, destinationBucket, destinationObjectName);\n\t\t\t\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(\"Could not rename \" + sourceObjectName + \" to \" + destinationObjectName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (addNew)\n\t\t\t\t\t\t\t\tdbObject.add(destinationObjectInfo);\n\n\t\t\t\t\t\t\treply.setEtag(etag);\n\t\t\t\t\t\t\treply.setLastModified(DateUtils.format(lastModified.getTime(), DateUtils.RFC822_DATETIME_PATTERN));\n\n\t\t\t\t\t\t\tif (foundDestinationBucketInfo.isVersioningEnabled()) {\n\t\t\t\t\t\t\t\treply.setCopySourceVersionId(sourceVersionId);\n\t\t\t\t\t\t\t\treply.setVersionId(destinationVersionId);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdb.commit();\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t// Fixes EUCA-3756. Reporting event for copy\n\t\t\t\t\t\t\t\t// objects\n\t\t\t\t\t\t\t\tfireObjectCreationEvent(destinationBucket, destinationObjectName, destinationVersionId, ctx.getUser().getUserId(),\n\t\t\t\t\t\t\t\t\t\tdestinationObjectInfo.getSize(), destinationObjectOldSize);\n\t\t\t\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\t\t\t\tLOG.debug(\"Failed to fire reporting event for walrus COPY object operation\", ex);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn reply;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\", destinationBucket);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new NoSuchBucketException(destinationBucket);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdb.rollback();\n\t\t\t\t\tthrow new AccessDeniedException(\"Key\", sourceKey);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new NoSuchEntityException(sourceKey);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(sourceBucket);\n\t\t}\n\t}","commit_id":"2841c3707b6b918bd84b2e849d107d154ad2a2e2","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DeleteBucketResponseType deleteBucket(DeleteBucketType request) throws EucalyptusCloudException {\n\t\tDeleteBucketResponseType reply = (DeleteBucketResponseType) request.getReply();\n\t\tString bucketName = request.getBucket();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo searchBucket = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.queryEscape(searchBucket);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucketFound = bucketList.get(0);\n\t\t\tBucketLogData logData = bucketFound.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\tif (ctx.hasAdministrativePrivileges()\n\t\t\t\t\t|| (Lookups.checkPrivilege(PolicySpec.S3_DELETEBUCKET, PolicySpec.VENDOR_S3, PolicySpec.S3_RESOURCE_BUCKET, bucketName,\n\t\t\t\t\t\t\tbucketFound.getOwnerId()))) {\n\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\tObjectInfo searchObject = new ObjectInfo();\n\t\t\t\tsearchObject.setBucketName(bucketName);\n\t\t\t\tsearchObject.setDeleted(false);\n\t\t\t\tList<ObjectInfo> objectInfos = dbObject.queryEscape(searchObject);\n\t\t\t\tif (objectInfos.size() == 0) {\n\t\t\t\t\t// check if the bucket contains any images\n\t\t\t\t\tEntityWrapper<ImageCacheInfo> dbIC = db.recast(ImageCacheInfo.class);\n\t\t\t\t\tImageCacheInfo searchImageCacheInfo = new ImageCacheInfo();\n\t\t\t\t\tsearchImageCacheInfo.setBucketName(bucketName);\n\t\t\t\t\tList<ImageCacheInfo> foundImageCacheInfos = dbIC.queryEscape(searchImageCacheInfo);\n\n\t\t\t\t\tif (foundImageCacheInfos.size() > 0) {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new BucketNotEmptyException(bucketName, logData);\n\t\t\t\t\t}\n\t\t\t\t\t// remove any delete markers\n\t\t\t\t\tObjectInfo searchDeleteMarker = new ObjectInfo();\n\t\t\t\t\tsearchDeleteMarker.setBucketName(bucketName);\n\t\t\t\t\tsearchDeleteMarker.setDeleted(true);\n\t\t\t\t\tList<ObjectInfo> deleteMarkers = dbObject.queryEscape(searchDeleteMarker);\n\t\t\t\t\tfor (ObjectInfo deleteMarker : deleteMarkers) {\n\t\t\t\t\t\tdbObject.delete(deleteMarker);\n\t\t\t\t\t}\n\t\t\t\t\tdb.delete(bucketFound);\n\t\t\t\t\t// Actually remove the bucket from the backing store\n\t\t\t\t\ttry {\n\t\t\t\t\t\tstorageManager.deleteBucket(bucketName);\n\t\t\t\t\t\t/* Send an event to reporting to report this S3 usage. */\n\n\t\t\t\t\t\t// fireBucketUsageEvent(S3BucketAction.BUCKETDELETE,\n\t\t\t\t\t\t// bucketFound.getNaturalId(),\n\t\t\t\t\t\t// bucketFound.getBucketName(), ctx.getUserFullName(),\n\t\t\t\t\t\t// bucketFound.getBucketSize());\n\n\t\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\t\t// set exception code in reply\n\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t}\n\n\t\t\t\t\tStatus status = new Status();\n\t\t\t\t\tstatus.setCode(204);\n\t\t\t\t\tstatus.setDescription(\"No Content\");\n\t\t\t\t\treply.setStatus(status);\n\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\tupdateLogData(bucketFound, logData);\n\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdb.rollback();\n\t\t\t\t\tthrow new BucketNotEmptyException(bucketName, logData);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","id":99867,"modified_method":"public DeleteBucketResponseType deleteBucket(DeleteBucketType request) throws EucalyptusCloudException {\n\t\tDeleteBucketResponseType reply = (DeleteBucketResponseType) request.getReply();\n\t\tString bucketName = request.getBucket();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo searchBucket = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.queryEscape(searchBucket);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucketFound = bucketList.get(0);\n\t\t\tBucketLogData logData = bucketFound.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\tif (ctx.hasAdministrativePrivileges()\n\t\t\t\t\t|| (Lookups.checkPrivilege(PolicySpec.S3_DELETEBUCKET, PolicySpec.VENDOR_S3, PolicySpec.S3_RESOURCE_BUCKET, bucketName,\n\t\t\t\t\t\t\tbucketFound.getOwnerId()))) {\n\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\tObjectInfo searchObject = new ObjectInfo();\n\t\t\t\tsearchObject.setBucketName(bucketName);\n\t\t\t\tList<ObjectInfo> objectInfos = dbObject.queryEscape(searchObject);\n\t\t\t\tif (objectInfos.size() == 0) {\n\t\t\t\t\t// check if the bucket contains any images\n\t\t\t\t\tEntityWrapper<ImageCacheInfo> dbIC = db.recast(ImageCacheInfo.class);\n\t\t\t\t\tImageCacheInfo searchImageCacheInfo = new ImageCacheInfo();\n\t\t\t\t\tsearchImageCacheInfo.setBucketName(bucketName);\n\t\t\t\t\tList<ImageCacheInfo> foundImageCacheInfos = dbIC.queryEscape(searchImageCacheInfo);\n\n\t\t\t\t\tif (foundImageCacheInfos.size() > 0) {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new BucketNotEmptyException(bucketName, logData);\n\t\t\t\t\t}\n\n\t\t\t\t\tdb.delete(bucketFound);\n\t\t\t\t\t// Actually remove the bucket from the backing store\n\t\t\t\t\ttry {\n\t\t\t\t\t\tstorageManager.deleteBucket(bucketName);\n\t\t\t\t\t\t/* Send an event to reporting to report this S3 usage. */\n\n\t\t\t\t\t\t// fireBucketUsageEvent(S3BucketAction.BUCKETDELETE,\n\t\t\t\t\t\t// bucketFound.getNaturalId(),\n\t\t\t\t\t\t// bucketFound.getBucketName(), ctx.getUserFullName(),\n\t\t\t\t\t\t// bucketFound.getBucketSize());\n\n\t\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\t\t// set exception code in reply\n\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t}\n\n\t\t\t\t\tStatus status = new Status();\n\t\t\t\t\tstatus.setCode(204);\n\t\t\t\t\tstatus.setDescription(\"No Content\");\n\t\t\t\t\treply.setStatus(status);\n\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\tupdateLogData(bucketFound, logData);\n\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdb.rollback();\n\t\t\t\t\tthrow new BucketNotEmptyException(bucketName, logData);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","commit_id":"2841c3707b6b918bd84b2e849d107d154ad2a2e2","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void createVMSnapshotEvent(UsageEventVO event) {\n        Long vmId = event.getResourceId();\n        Long volumeId = event.getTemplateId();\n        Long offeringId = event.getOfferingId();\n        Long zoneId = event.getZoneId();\n        Long accountId = event.getAccountId();\n        long size = event.getSize();\n        Date created = event.getCreateDate();\n        Account acct = _accountDao.findByIdIncludingRemoved(event.getAccountId());\n        Long domainId = acct.getDomainId();\n        UsageVMSnapshotVO vsVO = new UsageVMSnapshotVO(volumeId, zoneId, accountId, domainId, vmId, offeringId, size, created, null);\n        _usageVMSnapshotDao.persist(vsVO);\n    }","id":99868,"modified_method":"private void createVMSnapshotEvent(UsageEventVO event) {\n        Long vmId = event.getResourceId();\n        Long volumeId = event.getTemplateId();\n        Long offeringId = event.getOfferingId();\n        Long zoneId = event.getZoneId();\n        Long accountId = event.getAccountId();\n        //Size could be null for VM snapshot delete events\n        long size = (event.getSize() == null) ? 0 : event.getSize();\n        Date created = event.getCreateDate();\n        Account acct = _accountDao.findByIdIncludingRemoved(event.getAccountId());\n        Long domainId = acct.getDomainId();\n        UsageVMSnapshotVO vsVO = new UsageVMSnapshotVO(volumeId, zoneId, accountId, domainId, vmId, offeringId, size, created, null);\n        _usageVMSnapshotDao.persist(vsVO);\n    }","commit_id":"30ab4d3d6623af3c6075a9dbee4f474932008bf5","url":"https://github.com/apache/cloudstack"},{"original_method":"public edu.ucsb.eucalyptus.msgs.Volume morph( final edu.ucsb.eucalyptus.msgs.Volume vol ) {\n    vol.setAvailabilityZone( this.getCluster() );\n    vol.setCreateTime( this.getBirthday() );\n    vol.setVolumeId( this.getDisplayName() );\n    vol.setSnapshotId( this.getParentSnapshot() );\n    vol.setStatus( this.mapState() );\n    vol.setSize( this.getSize().toString() );\n    return vol;\n  }","id":99869,"modified_method":"public edu.ucsb.eucalyptus.msgs.Volume morph( final edu.ucsb.eucalyptus.msgs.Volume vol ) {\n    vol.setAvailabilityZone( this.getCluster() );\n    vol.setCreateTime( this.getBirthday() );\n    vol.setVolumeId( this.getDisplayName() );\n    vol.setSnapshotId( this.getParentSnapshot() );\n    vol.setStatus( this.mapState() );\n    vol.setSize( (this.getSize() == -1) || (this.getSize() == null)? null : this.getSize().toString() );\n    return vol;\n  }","commit_id":"0b88ebfb226c07d578149c7ef3f8f06d77c75a68","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public CreateVolumeResponseType CreateVolume( CreateVolumeType request ) throws EucalyptusCloudException {\n    if ( !Clusters.getInstance().contains( request.getAvailabilityZone() ) ) {\n      throw new EucalyptusCloudException( \"Zone does not exist: \" + request.getAvailabilityZone() );\n    }\n\n    EntityWrapper<Volume> db = VolumeManager.getEntityWrapper();\n    if ( !( request.getSnapshotId() == null ) ) {\n      String userName = request.isAdministrator() ? null : request.getUserId();\n      try {\n        db.recast( Snapshot.class ).getUnique( new Snapshot( userName, request.getSnapshotId() ) );\n      } catch ( EucalyptusCloudException e ) {\n        LOG.debug( e, e );\n        db.rollback();\n        throw new EucalyptusCloudException( \"Snapshot does not exist: \" + request.getSnapshotId() );\n      }\n    }\n    String newId = null;\n    Volume newVol = null;\n    while ( true ) {\n      newId = Hashes.generateId( request.getUserId(), ID_PREFIX );\n      try {\n        db.getUnique( new Volume( null, newId ) );\n      } catch ( EucalyptusCloudException e ) {\n        newVol = new Volume( request.getUserId(), newId, new Integer( request.getSize() ),\n                             request.getAvailabilityZone(), request.getSnapshotId() );\n        db.add( newVol );\n        break;\n      }\n    }\n    newVol.setState( State.GENERATING );\n    CreateStorageVolumeType scRequest = new CreateStorageVolumeType( newId, request.getSize(), request.getSnapshotId() );\n    CreateStorageVolumeResponseType scReply = null;\n    try {\n      scReply = ( CreateStorageVolumeResponseType ) Messaging.send( StorageProperties.STORAGE_REF, scRequest );\n    } catch ( EucalyptusCloudException e ) {\n      LOG.debug( e, e );\n      db.rollback();\n      throw new EucalyptusCloudException( \"Error calling CreateStorageVolume:\" + e.getMessage() );\n    }\n    db.commit();\n    CreateVolumeResponseType reply = ( CreateVolumeResponseType ) request.getReply();\n    reply.setVolume( newVol.morph( new edu.ucsb.eucalyptus.msgs.Volume() ) );\n    return reply;\n  }","id":99870,"modified_method":"public CreateVolumeResponseType CreateVolume( CreateVolumeType request ) throws EucalyptusCloudException {\n    if ( !Clusters.getInstance().contains( request.getAvailabilityZone() ) ) {\n      throw new EucalyptusCloudException( \"Zone does not exist: \" + request.getAvailabilityZone() );\n    }\n    if( ( request.getSnapshotId() == null && request.getSize() == null ) || ( request.getSnapshotId() != null && request.getSize() != null ) ) {\n      throw new EucalyptusCloudException( \"One of 'snapshotId' or 'size' must be set.\" );\n    }\n\n    EntityWrapper<Volume> db = VolumeManager.getEntityWrapper();\n    if ( !( request.getSnapshotId() == null ) ) {\n      String userName = request.isAdministrator() ? null : request.getUserId();\n      try {\n        db.recast( Snapshot.class ).getUnique( Snapshot.named( userName, request.getSnapshotId() ) );\n      } catch ( EucalyptusCloudException e ) {\n        LOG.debug( e, e );\n        db.rollback();\n        throw new EucalyptusCloudException( \"Snapshot does not exist: \" + request.getSnapshotId() );\n      }\n    }\n    String newId = null;\n    Volume newVol = null;\n    while ( true ) {\n      newId = Hashes.generateId( request.getUserId(), ID_PREFIX );\n      try {\n        db.getUnique( Volume.ownedBy( newId ) );\n      } catch ( EucalyptusCloudException e ) {\n        newVol = new Volume( request.getUserId(), newId, new Integer( request.getSize() != null ? request.getSize() : \"-1\" ),\n                             request.getAvailabilityZone(), request.getSnapshotId() );\n        db.add( newVol );\n        break;\n      }\n    }\n    newVol.setState( State.GENERATING );\n    CreateStorageVolumeType scRequest = new CreateStorageVolumeType( newId, request.getSize(), request.getSnapshotId() );\n    CreateStorageVolumeResponseType scReply = null;\n    try {\n      scReply = ( CreateStorageVolumeResponseType ) Messaging.send( StorageProperties.STORAGE_REF, scRequest );\n    } catch ( EucalyptusCloudException e ) {\n      LOG.debug( e, e );\n      db.rollback();\n      throw new EucalyptusCloudException( \"Error calling CreateStorageVolume:\" + e.getMessage() );\n    }\n    db.commit();\n    CreateVolumeResponseType reply = ( CreateVolumeResponseType ) request.getReply();\n    reply.setVolume( newVol.morph( new edu.ucsb.eucalyptus.msgs.Volume() ) );\n    return reply;\n  }","commit_id":"0b88ebfb226c07d578149c7ef3f8f06d77c75a68","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DescribeVolumesResponseType DescribeVolumes( DescribeVolumesType request ) throws EucalyptusCloudException {\n    DescribeVolumesResponseType reply = ( DescribeVolumesResponseType ) request.getReply();\n    EntityWrapper<Volume> db = getEntityWrapper();\n    String userName = request.isAdministrator() ? null : request.getUserId();\n    LOG.debug( request );\n    Messaging.send( StorageProperties.STORAGE_REF, new DescribeStorageVolumesType(  ) );\n\n    Map<String, AttachedVolume> attachedVolumes = new HashMap<String, AttachedVolume>();\n    for ( VmInstance vm : VmInstances.getInstance().listValues() ) {\n      for ( AttachedVolume av : vm.getVolumes() ) {\n        attachedVolumes.put( av.getVolumeId(), av );\n      }\n    }\n    List<Volume> volumes = db.query( Volume.ownedBy( userName ) );\n    for ( Volume v : volumes ) {\n      if ( request.getVolumeSet().isEmpty() || request.getVolumeSet().contains( v.getDisplayName() ) ) {\n        DescribeStorageVolumesResponseType volState = ( DescribeStorageVolumesResponseType ) Messaging.send( StorageProperties.STORAGE_REF, new DescribeStorageVolumesType( Lists.newArrayList( v.getDisplayName() ) ) );\n        LOG.debug( volState );\n        String volumeState = \"unavailable\";\n        if ( !volState.getVolumeSet().isEmpty() ) {\n          StorageVolume vol = volState.getVolumeSet().get( 0 );\n          volumeState = vol.getStatus();\n          v.setRemoteDevice( vol.getActualDeviceName() );\n        }\n        if ( attachedVolumes.containsKey( v.getDisplayName() ) ) {\n          volumeState = \"in-use\";\n        }\n        v.setMappedState( volumeState );\n        edu.ucsb.eucalyptus.msgs.Volume aVolume = v.morph( new edu.ucsb.eucalyptus.msgs.Volume() );\n        if ( attachedVolumes.containsKey( v.getDisplayName() ) ) {\n          aVolume.setStatus( volumeState );\n          aVolume.getAttachmentSet().add( attachedVolumes.get( aVolume.getVolumeId() ) );\n        }\n        reply.getVolumeSet().add( aVolume );\n      }\n    }\n    db.commit();\n    return reply;\n  }","id":99871,"modified_method":"public DescribeVolumesResponseType DescribeVolumes( DescribeVolumesType request ) throws EucalyptusCloudException {\n    DescribeVolumesResponseType reply = ( DescribeVolumesResponseType ) request.getReply();\n    EntityWrapper<Volume> db = getEntityWrapper();\n    String userName = request.isAdministrator() ? null : request.getUserId();\n    LOG.debug( request );\n    Messaging.send( StorageProperties.STORAGE_REF, new DescribeStorageVolumesType(  ) );\n\n    Map<String, AttachedVolume> attachedVolumes = new HashMap<String, AttachedVolume>();\n    for ( VmInstance vm : VmInstances.getInstance().listValues() ) {\n      for ( AttachedVolume av : vm.getVolumes() ) {\n        attachedVolumes.put( av.getVolumeId(), av );\n      }\n    }\n    List<Volume> volumes = db.query( Volume.ownedBy( userName ) );\n    for ( Volume v : volumes ) {\n      if ( request.getVolumeSet().isEmpty() || request.getVolumeSet().contains( v.getDisplayName() ) ) {\n        DescribeStorageVolumesResponseType volState = ( DescribeStorageVolumesResponseType ) Messaging.send( StorageProperties.STORAGE_REF, new DescribeStorageVolumesType( Lists.newArrayList( v.getDisplayName() ) ) );\n        LOG.debug( volState );\n        String volumeState = \"unavailable\";\n        if ( !volState.getVolumeSet().isEmpty() ) {\n          StorageVolume vol = volState.getVolumeSet().get( 0 );\n          volumeState = vol.getStatus();\n          v.setSize( new Integer( vol.getSize() ) );\n          v.setRemoteDevice( vol.getActualDeviceName() );\n        }\n        if ( attachedVolumes.containsKey( v.getDisplayName() ) ) {\n          volumeState = \"in-use\";\n        }\n        v.setMappedState( volumeState );\n        edu.ucsb.eucalyptus.msgs.Volume aVolume = v.morph( new edu.ucsb.eucalyptus.msgs.Volume() );\n        if ( attachedVolumes.containsKey( v.getDisplayName() ) ) {\n          aVolume.setStatus( volumeState );\n          aVolume.getAttachmentSet().add( attachedVolumes.get( aVolume.getVolumeId() ) );\n        }\n        reply.getVolumeSet().add( aVolume );\n      }\n    }\n    db.commit();\n    return reply;\n  }","commit_id":"0b88ebfb226c07d578149c7ef3f8f06d77c75a68","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        if (depUnit.hasAttachment(OSGiConstants.OSGI_METADATA_KEY))\n            return;\n\n        String runtimeName = depUnit.getName();\n        Manifest manifest = WebBundleURIParser.parse(runtimeName);\n        if (manifest != null) {\n            OSGiMetaData metadata = OSGiMetaDataBuilder.load(manifest);\n            depUnit.putAttachment(OSGiConstants.OSGI_METADATA_KEY, metadata);\n            depUnit.putAttachment(Attachments.OSGI_MANIFEST, manifest);\n        }\n    }","id":99872,"modified_method":"@Override\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        // Generate the OSGi metadata from a webbundle:// URI\n        DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        OSGiMetaData metadata = depUnit.getAttachment(OSGiConstants.OSGI_METADATA_KEY);\n        if (metadata == null) {\n            // [TODO] this should generate OSGiMetaData directly\n            Manifest manifest = WebBundleURIParser.parse(depUnit.getName());\n            if (manifest != null) {\n                metadata = OSGiMetaDataBuilder.load(manifest);\n                depUnit.putAttachment(OSGiConstants.OSGI_METADATA_KEY, metadata);\n                depUnit.putAttachment(Attachments.OSGI_MANIFEST, manifest);\n            }\n        }\n    }","commit_id":"86923b0736b4a17a3237d4e38decc790fa952954","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void performBoottime(final OperationContext context, final ModelNode operation, final ModelNode model,\n            final ServiceVerificationHandler verificationHandler, final List<ServiceController<?>> newControllers) {\n\n        context.addStep(new OperationStepHandler() {\n            @Override\n            public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                ServiceTarget serviceTarget = context.getServiceTarget();\n                newControllers.add(WebContextLifecycleInterceptor.addService(serviceTarget, verificationHandler));\n                context.completeStep(OperationContext.RollbackHandler.NOOP_ROLLBACK_HANDLER);\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        context.addStep(new AbstractDeploymentChainStep() {\n            @Override\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_OSGI_WEBBUNDLE, new WebBundleStructureProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_REMOUNT_EXPLODED, new RemountDeploymentRootProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_WAB_FRAGMENTS, new WabFragmentProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_WAB_DEPLOYMENT, new WebContextActivationProcessor());\n            }\n        }, OperationContext.Stage.RUNTIME);\n    }","id":99873,"modified_method":"@Override\n    public void performBoottime(final OperationContext context, final ModelNode operation, final ModelNode model,\n            final ServiceVerificationHandler verificationHandler, final List<ServiceController<?>> newControllers) {\n\n        context.addStep(new OperationStepHandler() {\n            @Override\n            public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                ServiceTarget serviceTarget = context.getServiceTarget();\n                newControllers.add(WebContextLifecycleInterceptor.addService(serviceTarget, verificationHandler));\n                context.completeStep(OperationContext.RollbackHandler.NOOP_ROLLBACK_HANDLER);\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        context.addStep(new AbstractDeploymentChainStep() {\n            @Override\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_OSGI_WEBBUNDLE, new WebBundleStructureProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_REMOUNT_EXPLODED, new RemountDeploymentRootProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_WAB_CONTEXT_FACTORY, new WebBundleContextProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_WAB_FRAGMENTS, new WebBundleFragmentProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_WAB_DEPLOYMENT, new WebContextActivationProcessor());\n            }\n        }, OperationContext.Stage.RUNTIME);\n    }","commit_id":"86923b0736b4a17a3237d4e38decc790fa952954","url":"https://github.com/wildfly/wildfly"},{"original_method":"private boolean hasValidInjectionPoint(DeploymentUnit depUnit) {\n        boolean result = false;\n        DotName dotName = DotName.createSimple(\"javax.inject.Inject\");\n        CompositeIndex compositeIndex = depUnit.getAttachment(Attachments.COMPOSITE_ANNOTATION_INDEX);\n        List<AnnotationInstance> annotationList = compositeIndex.getAnnotations(dotName);\n        for (AnnotationInstance instance : annotationList) {\n            AnnotationTarget target = instance.target();\n            if (target instanceof FieldInfo) {\n                FieldInfo fieldInfo = (FieldInfo) target;\n                String typeName = fieldInfo.type().toString();\n                if (typeName.startsWith(\"org.osgi.framework\")) {\n                    LOGGER.debugf(\"OSGi injection point of type '%s' detected: %s\", typeName, fieldInfo.declaringClass());\n                    result = true;\n                    break;\n                }\n            }\n        }\n        return result;\n    }","id":99874,"modified_method":"private boolean hasValidInjectionPoint(DeploymentUnit depUnit) {\n        return hasInjectionPoint(depUnit, \"javax.inject.Inject\") || hasInjectionPoint(depUnit, \"javax.annotation.Resource\");\n    }","commit_id":"446bfbe8aff25fb5a95122b2259ca84d0765dc37","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        // Always make the system context & the environment available\n        // [TODO] [AS7-5215] Deployments unecessarily trigger Framework create service\n        phaseContext.addDeploymentDependency(Services.SYSTEM_CONTEXT, OSGiConstants.SYSTEM_CONTEXT_KEY);\n        phaseContext.addDeploymentDependency(Services.ENVIRONMENT, OSGiConstants.ENVIRONMENT_KEY);\n\n        // Check whether this is an OSGi deployment or whether it wants to have an OSGi type injected\n        DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        if (!depUnit.hasAttachment(OSGiConstants.DEPLOYMENT_KEY) && !hasValidInjectionPoint(depUnit))\n            return;\n\n        // Install the {@link FrameworkActivationService} if not done so already\n        ServiceVerificationHandler verificationHandler = depUnit.getAttachment(Attachments.SERVICE_VERIFICATION_HANDLER);\n        FrameworkActivationService.activateOnce(verificationHandler);\n\n        // Setup a dependency on the the next phase. Persistent bundles have a dependency on the bootstrap bundles\n        ServiceName phaseDependency = deploymentTracker.isComplete() ? FRAMEWORK_ACTIVE : BOOTSTRAP_BUNDLES_COMPLETE;\n        phaseContext.addDeploymentDependency(phaseDependency, AttachmentKey.create(Object.class));\n\n        // Make these services available for a bundle deployment only\n        phaseContext.addDeploymentDependency(Services.BUNDLE_MANAGER, OSGiConstants.BUNDLE_MANAGER_KEY);\n        phaseContext.addDeploymentDependency(Services.RESOLVER, OSGiConstants.RESOLVER_KEY);\n    }","id":99875,"modified_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        // Check whether this is an OSGi deployment or whether it wants to have an OSGi type injected\n        DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        Deployment deployment = depUnit.getAttachment(OSGiConstants.DEPLOYMENT_KEY);\n        boolean hasInjectionPoint = hasValidInjectionPoint(depUnit);\n        if (deployment == null && hasInjectionPoint == false)\n            return;\n\n        // Install the {@link FrameworkActivationService} if not done so already\n        ServiceVerificationHandler verificationHandler = depUnit.getAttachment(Attachments.SERVICE_VERIFICATION_HANDLER);\n        FrameworkActivationService.activateOnce(verificationHandler);\n\n        // Setup a dependency on the the next phase. Persistent bundles have a dependency on the bootstrap bundles\n        ServiceName phaseDependency = deploymentTracker.isComplete() ? FRAMEWORK_ACTIVE : MODULE_REGISTRATION_COMPLETE;\n        phaseContext.addDeploymentDependency(phaseDependency, AttachmentKey.create(Object.class));\n\n        // Make these services available for a bundle deployment only\n        phaseContext.addDeploymentDependency(Services.BUNDLE_MANAGER, OSGiConstants.BUNDLE_MANAGER_KEY);\n        phaseContext.addDeploymentDependency(Services.RESOLVER, OSGiConstants.RESOLVER_KEY);\n        phaseContext.addDeploymentDependency(Services.SYSTEM_CONTEXT, OSGiConstants.SYSTEM_CONTEXT_KEY);\n        phaseContext.addDeploymentDependency(Services.ENVIRONMENT, OSGiConstants.ENVIRONMENT_KEY);\n    }","commit_id":"446bfbe8aff25fb5a95122b2259ca84d0765dc37","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Remove the {@link Module} and {@link ModuleSpec} services associated with the given identifier.\n     */\n    @Override\n    public void removeModule(ModuleIdentifier identifier) {\n        ServiceName serviceName = getModuleSpecServiceName(identifier);\n        ServiceController<?> controller = serviceContainer.getService(serviceName);\n        if (controller != null) {\n            LOGGER.debugf(\"Remove module spec fom loader: %s\", serviceName);\n            controller.setMode(Mode.REMOVE);\n        }\n        serviceName = getModuleServiceName(identifier);\n        controller = serviceContainer.getService(serviceName);\n        if (controller != null) {\n            LOGGER.debugf(\"Remove module fom loader: %s\", serviceName);\n            controller.setMode(Mode.REMOVE);\n        }\n    }","id":99876,"modified_method":"/**\n     * Remove the {@link Module} and {@link ModuleSpec} services associated with the given identifier.\n     */\n    @Override\n    public void removeModule(XBundleRevision brev, ModuleIdentifier identifier) {\n        Set<ServiceName> serviceNames = new HashSet<ServiceName>();\n        serviceNames.add(getModuleSpecServiceName(identifier));\n        serviceNames.add(getModuleServiceName(identifier));\n        for (ServiceName serviceName : serviceNames) {\n            ServiceController<?> controller = serviceContainer.getService(serviceName);\n            if (controller != null) {\n                LOGGER.debugf(\"Remove from loader: %s\", serviceName);\n                controller.setMode(Mode.REMOVE);\n            }\n        }\n    }","commit_id":"446bfbe8aff25fb5a95122b2259ca84d0765dc37","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        // Don't register EAR deployments\n        final DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        if (DeploymentTypeMarker.isType(DeploymentType.EAR, depUnit))\n            return;\n\n        // Don't register Bundle deployments\n        if (depUnit.hasAttachment(OSGiConstants.INSTALLED_BUNDLE_KEY))\n            return;\n\n        // Don't register private module deployments\n        final Module module = depUnit.getAttachment(Attachments.MODULE);\n        final ModuleSpecification moduleSpecification = depUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n        if (module == null || moduleSpecification.isPrivateModule())\n            return;\n\n        LOGGER.infoRegisterModule(module.getIdentifier());\n        try {\n            final BundleContext context = depUnit.getAttachment(OSGiConstants.SYSTEM_CONTEXT_KEY);\n            XBundleRevisionBuilderFactory factory = new XBundleRevisionBuilderFactory() {\n                @Override\n                public XBundleRevision createResource() {\n                    return new AbstractBundleRevisionAdaptor(context, module);\n                }\n            };\n            OSGiMetaData metadata = depUnit.getAttachment(OSGiConstants.OSGI_METADATA_KEY);\n            XEnvironment env = depUnit.getAttachment(OSGiConstants.ENVIRONMENT_KEY);\n            XResourceBuilder builder = XBundleRevisionBuilderFactory.create(factory);\n            if (metadata != null) {\n                builder.loadFrom(metadata);\n            } else {\n                builder.loadFrom(module);\n            }\n            XBundleRevision brev = (XBundleRevision) builder.getResource();\n            env.installResources(brev);\n            depUnit.putAttachment(OSGiConstants.REGISTERED_MODULE_KEY, brev);\n        } catch (Throwable th) {\n            throw MESSAGES.deploymentFailedToRegisterModule(th, module);\n        }\n    }","id":99877,"modified_method":"@Override\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        // Don't register EAR deployments\n        final DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        if (DeploymentTypeMarker.isType(DeploymentType.EAR, depUnit))\n            return;\n\n        // Don't register Bundle deployments\n        if (depUnit.hasAttachment(OSGiConstants.INSTALLED_BUNDLE_KEY))\n            return;\n\n        // Don't register private module deployments\n        final Module module = depUnit.getAttachment(Attachments.MODULE);\n        final ModuleSpecification moduleSpecification = depUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n        if (module == null || moduleSpecification.isPrivateModule())\n            return;\n\n        OSGiMetaData metadata = depUnit.getAttachment(OSGiConstants.OSGI_METADATA_KEY);\n        registrationTracker.registerModule(module, metadata);\n    }","commit_id":"446bfbe8aff25fb5a95122b2259ca84d0765dc37","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void undeploy(final DeploymentUnit depUnit) {\n        final XBundleRevision brev = depUnit.removeAttachment(OSGiConstants.REGISTERED_MODULE_KEY);\n        if (brev != null) {\n            LOGGER.infoUnregisterModule(brev.getModuleIdentifier());\n            XEnvironment env = depUnit.getAttachment(OSGiConstants.ENVIRONMENT_KEY);\n            env.uninstallResources(brev);\n        }\n    }","id":99878,"modified_method":"@Override\n    public void undeploy(final DeploymentUnit depUnit) {\n        final Module module = depUnit.getAttachment(Attachments.MODULE);\n        registrationTracker.unregisterModule(module);\n    }","commit_id":"446bfbe8aff25fb5a95122b2259ca84d0765dc37","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performBoottime(final OperationContext context, final ModelNode operation, final ModelNode model,\n            final ServiceVerificationHandler verificationHandler, final List<ServiceController<?>> newControllers) {\n\n        LOGGER.infoActivatingSubsystem();\n\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        final Activation activationMode = getActivationMode(operation);\n        final InitialDeploymentTracker deploymentTracker = new InitialDeploymentTracker(context, verificationHandler);\n\n        context.addStep(new OperationStepHandler() {\n            @Override\n            public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                newControllers.add(FrameworkBootstrapService.addService(serviceTarget, resource, verificationHandler));\n                context.completeStep(OperationContext.RollbackHandler.NOOP_ROLLBACK_HANDLER);\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        context.addStep(new AbstractDeploymentChainStep() {\n            @Override\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_OSGI_MANIFEST, new OSGiManifestStructureProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_BUNDLE_SUB_DEPLOYMENT, new BundleSubDeploymentMarkingProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_BUNDLE_INFO, new OSGiBundleInfoParseProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_PROPERTIES, new OSGiXServiceParseProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_DEPLOYMENT, new BundleDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_SUBSYSTEM_ACTIVATOR, new FrameworkActivateProcessor(deploymentTracker));\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.DEPENDENCIES, Phase.DEPENDENCIES_BUNDLE_CONTEXT, new BundleContextDependencyProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.REGISTER, Phase.REGISTER_BUNDLE_INSTALL, new BundleInstallProcessor(deploymentTracker));\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.CONFIGURE_MODULE, Phase.CONFIGURE_RESOLVE_BUNDLE, new BundleResolveProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.CONFIGURE_MODULE, Phase.CONFIGURE_RESOLVE_SUB_BUNDLE, new BundleResolveSubProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_RESOLVER_MODULE, new ModuleRegisterProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_BUNDLE_ACTIVATE, new BundleActivateProcessor(deploymentTracker));\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        // Perform boottime on subsystem extensions\n        ClassLoader classLoader = OSGiSubsystemExtension.class.getClassLoader();\n        Iterator<OSGiSubsystemExtension> services = ServiceLoader.load(OSGiSubsystemExtension.class, classLoader).iterator();\n        while(services.hasNext()) {\n            OSGiSubsystemExtension extension = services.next();\n            extension.performBoottime(context, operation, model, verificationHandler, newControllers);\n        }\n\n        // Add the subsystem state as a service\n        newControllers.add(SubsystemState.addService(serviceTarget, activationMode));\n    }","id":99879,"modified_method":"@Override\n    protected void performBoottime(final OperationContext context, final ModelNode operation, final ModelNode model,\n            final ServiceVerificationHandler verificationHandler, final List<ServiceController<?>> newControllers) {\n\n        LOGGER.infoActivatingSubsystem();\n\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        final Activation activationMode = getActivationMode(operation);\n        final InitialDeploymentTracker deploymentTracker = new InitialDeploymentTracker(context, verificationHandler);\n        final ModuleRegistrationTracker registrationTracker = new ModuleRegistrationTracker();\n\n        context.addStep(new OperationStepHandler() {\n            @Override\n            public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                newControllers.add(FrameworkBootstrapService.addService(serviceTarget, resource, verificationHandler));\n                newControllers.add(registrationTracker.install(serviceTarget, verificationHandler));\n                context.completeStep(OperationContext.RollbackHandler.NOOP_ROLLBACK_HANDLER);\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        context.addStep(new AbstractDeploymentChainStep() {\n            @Override\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_OSGI_MANIFEST, new OSGiManifestStructureProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_BUNDLE_SUB_DEPLOYMENT, new BundleSubDeploymentMarkingProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_BUNDLE_INFO, new OSGiBundleInfoParseProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_PROPERTIES, new OSGiXServiceParseProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_DEPLOYMENT, new BundleDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_SUBSYSTEM_ACTIVATOR, new FrameworkActivateProcessor(deploymentTracker));\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.DEPENDENCIES, Phase.DEPENDENCIES_BUNDLE_CONTEXT, new BundleContextBindingProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.REGISTER, Phase.REGISTER_BUNDLE_INSTALL, new BundleInstallProcessor(deploymentTracker));\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.CONFIGURE_MODULE, Phase.CONFIGURE_RESOLVE_BUNDLE, new BundleResolveProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.CONFIGURE_MODULE, Phase.CONFIGURE_RESOLVE_SUB_BUNDLE, new BundleResolveSubProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_RESOLVER_MODULE, new ModuleRegisterProcessor(registrationTracker));\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_BUNDLE_ACTIVATE, new BundleActivateProcessor(deploymentTracker));\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        // Perform boottime on subsystem extensions\n        ClassLoader classLoader = OSGiSubsystemExtension.class.getClassLoader();\n        Iterator<OSGiSubsystemExtension> services = ServiceLoader.load(OSGiSubsystemExtension.class, classLoader).iterator();\n        while(services.hasNext()) {\n            OSGiSubsystemExtension extension = services.next();\n            extension.performBoottime(context, operation, model, verificationHandler, newControllers);\n        }\n\n        // Add the subsystem state as a service\n        newControllers.add(SubsystemState.addService(serviceTarget, activationMode));\n    }","commit_id":"446bfbe8aff25fb5a95122b2259ca84d0765dc37","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void addServiceDependencies(ServiceBuilder<Void> builder) {\n        builder.addDependencies(INITIAL_DEPLOYMENTS_COMPLETE);\n    }","id":99880,"modified_method":"@Override\n    protected void addServiceDependencies(ServiceBuilder<Void> builder) {\n        builder.addDependencies(InitialDeploymentTracker.INITIAL_DEPLOYMENTS_COMPLETE);\n        builder.addDependencies(ModuleRegistrationTracker.MODULE_REGISTRATION_COMPLETE);\n    }","commit_id":"446bfbe8aff25fb5a95122b2259ca84d0765dc37","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void errout(String s) {\n        System.err.println(s == null ? \"null\" : s);\n    }","id":99881,"modified_method":"public static void errout(String s) {\n        Log.debug(s == null ? \"null\" : s);\n        //System.err.println(s == null ? \"null\" : s);\n    }","commit_id":"7727d1edd354cef5507701322748ece0e17e5d00","url":"https://github.com/VUE/VUE"},{"original_method":"public static Schema ingestXML(InputSource input, String itemKey)\n    {\n//         // SMF 2008-10-02: E.g. Craigslist XML streams use ISO-8859-1, which is provided in\n//         // HTML headers as \"Content-Type: application/rss+xml; charset=ISO-8859-1\", (tho not\n//         // in a special content-encoding header), and our current XML parser fails unless\n//         // the stream is read with this set: e.g.: [org.xml.sax.SAXParseException: Character\n//         // conversion error: \"Unconvertible UTF-8 character beginning with 0x95\" (line\n//         // number may be too low).]  Actually, in this case it turns out that providing a\n//         // default InputStreamReader (encoding not specified) as opposed to a direct\n//         // InputStream from the URLConnection works, and the XML parser is presumably then\n//         // finding and handling the \"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\" line at\n//         // the top of the XML stream\n//         final XmlSchema schema = new XmlSchema(conn.getURL(), itemKey);\n//         InputStream is = null;\n//         try {\n//             is = conn.getInputStream();\n//             errout(\"GOT INPUT STREAM: \" + Util.tags(is));\n//         } catch (IOException e) {\n//             e.printStackTrace();\n//             return null;\n//         }\n//         final Document doc = parseXML(is, false);\n\n        // Could also use a ROME API XmlReader(URLConnection) for handling\n        // the input, which does it's own magic to figure out the encoding.\n        // For more on the complexity of this issue, see:\n        // http://diveintomark.org/archives/2004/02/13/xml-media-types\n        \n        final XmlSchema schema = new XmlSchema(input, itemKey);\n        \n        final Document doc = parseXML(input, false);\n\n        //doc.normalizeDocument();\n        errout(\"GOT DOC \" + Util.tag(doc) + \" \" + doc);\n        //errout(\"InputEncoding: \" + doc.getInputEncoding()); // AbstractMethodError ?\n        //errout(\"xmlEncoding: \" + doc.getXmlEncoding());\n        //errout(\"xmlVersion: \" + doc.getXmlVersion());\n        errout(\"docType: \" + Util.tags(doc.getDoctype()));\n        errout(\"impl: \" + Util.tags(doc.getImplementation().getClass()));\n        errout(\"docElement: \" + Util.tags(doc.getDocumentElement().getClass())); // toString() can dump whole document!\n        //out(\"element: \" + Util.tags(doc.getDocumentElement()));\n\n        //outln(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\");\n        //outln(\"<!-- created by RSSTest \" + new Date() + \" from \" + src + \" -->\");\n\n        if (false)\n            XPathExtract(schema, doc);\n        else\n            scanNode(schema, doc.getDocumentElement(), null, null);\n\n        schema.dumpSchema(System.err);\n        return schema;\n    }","id":99882,"modified_method":"public static Schema ingestXML(InputSource input, String itemKey)\n    {\n//         // SMF 2008-10-02: E.g. Craigslist XML streams use ISO-8859-1, which is provided in\n//         // HTML headers as \"Content-Type: application/rss+xml; charset=ISO-8859-1\", (tho not\n//         // in a special content-encoding header), and our current XML parser fails unless\n//         // the stream is read with this set: e.g.: [org.xml.sax.SAXParseException: Character\n//         // conversion error: \"Unconvertible UTF-8 character beginning with 0x95\" (line\n//         // number may be too low).]  Actually, in this case it turns out that providing a\n//         // default InputStreamReader (encoding not specified) as opposed to a direct\n//         // InputStream from the URLConnection works, and the XML parser is presumably then\n//         // finding and handling the \"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\" line at\n//         // the top of the XML stream\n//         final XmlSchema schema = new XmlSchema(conn.getURL(), itemKey);\n//         InputStream is = null;\n//         try {\n//             is = conn.getInputStream();\n//             errout(\"GOT INPUT STREAM: \" + Util.tags(is));\n//         } catch (IOException e) {\n//             e.printStackTrace();\n//             return null;\n//         }\n//         final Document doc = parseXML(is, false);\n\n        // Could also use a ROME API XmlReader(URLConnection) for handling\n        // the input, which does it's own magic to figure out the encoding.\n        // For more on the complexity of this issue, see:\n        // http://diveintomark.org/archives/2004/02/13/xml-media-types\n        \n        final XmlSchema schema = new XmlSchema(input, itemKey);\n        \n        final Document doc = parseXML(input, false);\n\n        //doc.normalizeDocument();\n        if (DEBUG.DR) {\n            errout(\"GOT DOC \" + Util.tag(doc) + \" \" + doc);\n            //errout(\"InputEncoding: \" + doc.getInputEncoding()); // AbstractMethodError ?\n            //errout(\"xmlEncoding: \" + doc.getXmlEncoding());\n            //errout(\"xmlVersion: \" + doc.getXmlVersion());\n            errout(\"docType: \" + Util.tags(doc.getDoctype()));\n            errout(\"impl: \" + Util.tags(doc.getImplementation().getClass()));\n            errout(\"docElement: \" + Util.tags(doc.getDocumentElement().getClass())); // toString() can dump whole document!\n        }\n        //out(\"element: \" + Util.tags(doc.getDocumentElement()));\n\n        //outln(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\");\n        //outln(\"<!-- created by RSSTest \" + new Date() + \" from \" + src + \" -->\");\n\n        if (false)\n            XPathExtract(schema, doc);\n        else\n            scanNode(schema, doc.getDocumentElement(), null, null);\n\n        if (DEBUG.DR) schema.dumpSchema(System.err);\n        return schema;\n    }","commit_id":"7727d1edd354cef5507701322748ece0e17e5d00","url":"https://github.com/VUE/VUE"},{"original_method":"@Override\n        public void run() {\n            try {\n                RepositoryUtil.stopRepository();\n            } catch(Exception e) {\n                System.out.println(\"Exception in ShutdownThread:\" + e);\n            }\n        }","id":99883,"modified_method":"@Override\n        public void run() {\n            try {\n                RepositoryUtil.stopRepository();\n            } catch(Exception e) {\n                //ignore for now\n            }\n        }","commit_id":"57307e49c3a4ebf78d6072028de11e2a7a5fd74d","url":"https://github.com/apache/sling"},{"original_method":"public void testPerformance() throws Exception {\n        Helper helper = new Helper();\n        \n        List<AbstractTest> tests = new ArrayList<AbstractTest>();\n        tests.add(new ResolveNonExistingWith1000VanityPathTest(helper));\n        tests.add(new ResolveNonExistingWith5000VanityPathTest(helper));\n        tests.add(new ResolveNonExistingWith10000VanityPathTest(helper));\n        //tests.add(new ResolveNonExistingWith30000VanityPathTest(helper));\n        tests.add(new ResolveNonExistingWith1000AliasTest(helper));\n        tests.add(new ResolveNonExistingWith5000AliasTest(helper));\n        tests.add(new ResolveNonExistingWith10000AliasTest(helper));\n        //tests.add(new ResolveNonExistingWith30000AliasTest(helper));\n        testPerformance(\"jcr.resource-2.0.10\", tests);\n    }","id":99884,"modified_method":"@PerformanceTestSuite\n    public ParameterizedTestList testPerformance() throws Exception {\n        Helper helper = new Helper();\n        \n        ParameterizedTestList testCenter = new ParameterizedTestList();\n        testCenter.setTestSuiteTitle(\"jcr.resource-2.0.10\");\n        testCenter.addTestObject(new ResolveNonExistingWith1000VanityPathTest(helper));\n        testCenter.addTestObject(new ResolveNonExistingWith5000VanityPathTest(helper));\n        testCenter.addTestObject(new ResolveNonExistingWith10000VanityPathTest(helper));\n        //tests.add(new ResolveNonExistingWith30000VanityPathTest(helper));\n        testCenter.addTestObject(new ResolveNonExistingWith1000AliasTest(helper));\n        testCenter.addTestObject(new ResolveNonExistingWith5000AliasTest(helper));\n        testCenter.addTestObject(new ResolveNonExistingWith10000AliasTest(helper));\n        //tests.add(new ResolveNonExistingWith30000AliasTest(helper));\n        \n        return testCenter;\n        \n    }","commit_id":"57307e49c3a4ebf78d6072028de11e2a7a5fd74d","url":"https://github.com/apache/sling"},{"original_method":"public void testPerformance() throws Exception {\n        Helper helper = new Helper();\n        \n        List<AbstractTest> tests = new ArrayList<AbstractTest>();\n        tests.add(new ResolveNonExistingWith1000VanityPathTest(helper));\n        tests.add(new ResolveNonExistingWith5000VanityPathTest(helper));\n        tests.add(new ResolveNonExistingWith10000VanityPathTest(helper));\n        //tests.add(new ResolveNonExistingWith30000VanityPathTest(helper));\n        tests.add(new ResolveNonExistingWith1000AliasTest(helper));\n        tests.add(new ResolveNonExistingWith5000AliasTest(helper));\n        tests.add(new ResolveNonExistingWith10000AliasTest(helper));\n        //tests.add(new ResolveNonExistingWith30000AliasTest(helper));\n        testPerformance(\"jcr.resource-2.1.0\", tests);\n    }","id":99885,"modified_method":"@PerformanceTestSuite\n    public ParameterizedTestList testPerformance() throws Exception {\n        Helper helper = new Helper();\n        \n        ParameterizedTestList testCenter = new ParameterizedTestList();\n        testCenter.setTestSuiteTitle(\"jcr.resource-2.1.0\");\n        testCenter.addTestObject(new ResolveNonExistingWith1000VanityPathTest(helper));\n        testCenter.addTestObject(new ResolveNonExistingWith5000VanityPathTest(helper));\n        testCenter.addTestObject(new ResolveNonExistingWith10000VanityPathTest(helper));\n        //tests.add(new ResolveNonExistingWith30000VanityPathTest(helper));\n        testCenter.addTestObject(new ResolveNonExistingWith1000AliasTest(helper));\n        testCenter.addTestObject(new ResolveNonExistingWith5000AliasTest(helper));\n        testCenter.addTestObject(new ResolveNonExistingWith10000AliasTest(helper));\n        //tests.add(new ResolveNonExistingWith30000AliasTest(helper));\n                \n        return testCenter;\n    }","commit_id":"57307e49c3a4ebf78d6072028de11e2a7a5fd74d","url":"https://github.com/apache/sling"},{"original_method":"public void testPerformance() throws Exception {\n        Helper helper = new Helper();\n        \n        List<AbstractTest> tests = new ArrayList<AbstractTest>();\n        tests.add(new ResolveNonExistingWith1000VanityPathTest(helper));\n        tests.add(new ResolveNonExistingWith5000VanityPathTest(helper));\n        tests.add(new ResolveNonExistingWith10000VanityPathTest(helper));\n        //tests.add(new ResolveNonExistingWith30000VanityPathTest(helper));\n        tests.add(new ResolveNonExistingWith1000AliasTest(helper));\n        tests.add(new ResolveNonExistingWith5000AliasTest(helper));\n        tests.add(new ResolveNonExistingWith10000AliasTest(helper));\n        //tests.add(new ResolveNonExistingWith30000AliasTest(helper));\n        testPerformance(\"jcr.resource-2.2.0\", tests);\n    }","id":99886,"modified_method":"@PerformanceTestSuite\n    public ParameterizedTestList testPerformance() throws Exception {\n        Helper helper = new Helper();\n        \n        ParameterizedTestList testCenter = new ParameterizedTestList();\n        testCenter.setTestSuiteTitle(\"jcr.resource-2.2.0\");\n        testCenter.addTestObject(new ResolveNonExistingWith1000VanityPathTest(helper));\n        testCenter.addTestObject(new ResolveNonExistingWith5000VanityPathTest(helper));\n        testCenter.addTestObject(new ResolveNonExistingWith10000VanityPathTest(helper));\n        //tests.add(new ResolveNonExistingWith30000VanityPathTest(helper));\n        testCenter.addTestObject(new ResolveNonExistingWith1000AliasTest(helper));\n        testCenter.addTestObject(new ResolveNonExistingWith5000AliasTest(helper));\n        testCenter.addTestObject(new ResolveNonExistingWith10000AliasTest(helper));\n        //tests.add(new ResolveNonExistingWith30000AliasTest(helper));\n        \n        return testCenter;\n    }","commit_id":"57307e49c3a4ebf78d6072028de11e2a7a5fd74d","url":"https://github.com/apache/sling"},{"original_method":"public void pushExportBuffer(int partitionId, String signature, long uso, ByteBuffer buffer, boolean sync, boolean endOfStream) {\n        //        System.out.println(\"In generation \" + m_timestamp + \" partition \" + partitionId + \" signature \" + signature + (buffer == null ? \" null buffer \" : (\" buffer length \" + buffer.remaining())));\n        //        for (Integer i : m_dataSourcesByPartition.keySet()) {\n        //            System.out.println(\"Have partition \" + i);\n        //        }\n        assert(m_dataSourcesByPartition.containsKey(partitionId));\n        assert(m_dataSourcesByPartition.get(partitionId).containsKey(signature));\n        HashMap<String, ExportDataSource> sources = m_dataSourcesByPartition.get(partitionId);\n\n        if (sources == null) {\n            exportLog.error(\"Could not find export data sources for partition \"\n                    + partitionId + \" generation \" + m_timestamp + \" the export data is being discarded\");\n            DBBPool.wrapBB(buffer).discard();\n            return;\n        }\n\n        ExportDataSource source = sources.get(signature);\n        if (source == null) {\n            exportLog.error(\"Could not find export data source for partition \" + partitionId +\n                    \" signature \" + signature + \" generation \" +\n                    m_timestamp + \" the export data is being discarded\");\n            DBBPool.wrapBB(buffer).discard();\n            return;\n        }\n\n        source.pushExportBuffer(uso, buffer, sync, endOfStream);\n    }","id":99887,"modified_method":"public void pushExportBuffer(int partitionId, String signature, long uso, ByteBuffer buffer, boolean sync, boolean endOfStream) {\n        //        System.out.println(\"In generation \" + m_timestamp + \" partition \" + partitionId + \" signature \" + signature + (buffer == null ? \" null buffer \" : (\" buffer length \" + buffer.remaining())));\n        //        for (Integer i : m_dataSourcesByPartition.keySet()) {\n        //            System.out.println(\"Have partition \" + i);\n        //        }\n        assert(m_dataSourcesByPartition.containsKey(partitionId));\n        assert(m_dataSourcesByPartition.get(partitionId).containsKey(signature));\n        HashMap<String, ExportDataSource> sources = m_dataSourcesByPartition.get(partitionId);\n\n        if (sources == null) {\n            exportLog.error(\"Could not find export data sources for partition \"\n                    + partitionId + \" generation \" + m_timestamp + \" the export data is being discarded\");\n            if (buffer != null) {\n                DBBPool.wrapBB(buffer).discard();\n            }\n            return;\n        }\n\n        ExportDataSource source = sources.get(signature);\n        if (source == null) {\n            exportLog.error(\"Could not find export data source for partition \" + partitionId +\n                    \" signature \" + signature + \" generation \" +\n                    m_timestamp + \" the export data is being discarded\");\n            if (buffer != null) {\n                DBBPool.wrapBB(buffer).discard();\n            }\n            return;\n        }\n\n        source.pushExportBuffer(uso, buffer, sync, endOfStream);\n    }","commit_id":"a9c10ad414dc1e3362d904e4356f8cf720a965fa","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public static void pushExportBuffer(\n            long exportGeneration,\n            int partitionId,\n            String signature,\n            long uso,\n            long bufferPtr,\n            ByteBuffer buffer,\n            boolean sync,\n            boolean endOfStream) {\n        //For validating that the memory is released\n        if (bufferPtr != 0) DBBPool.registerUnsafeMemory(bufferPtr);\n        ExportManager instance = instance();\n        try {\n            ExportGeneration generation = instance.m_generations.get(exportGeneration);\n            if (generation == null) {\n                DBBPool.wrapBB(buffer).discard();\n                /*\n                 * If the generation was already drained it is fine for a buffer to come late and miss it\n                 */\n                synchronized(instance) {\n                    if (!instance.m_generationGhosts.contains(exportGeneration)) {\n                        assert(false);\n                        exportLog.error(\"Could not a find an export generation \" + exportGeneration +\n                        \". Should be impossible. Discarding export data\");\n                    }\n                }\n                return;\n            }\n\n            generation.pushExportBuffer(partitionId, signature, uso, buffer, sync, endOfStream);\n        } catch (Exception e) {\n            //Don't let anything take down the execution site thread\n            exportLog.error(\"Error pushing export buffer\", e);\n        }\n    }","id":99888,"modified_method":"public static void pushExportBuffer(\n            long exportGeneration,\n            int partitionId,\n            String signature,\n            long uso,\n            long bufferPtr,\n            ByteBuffer buffer,\n            boolean sync,\n            boolean endOfStream) {\n        //For validating that the memory is released\n        if (bufferPtr != 0) DBBPool.registerUnsafeMemory(bufferPtr);\n        ExportManager instance = instance();\n        try {\n            ExportGeneration generation = instance.m_generations.get(exportGeneration);\n            if (generation == null) {\n                if (buffer != null) {\n                    DBBPool.wrapBB(buffer).discard();\n                }\n\n                /*\n                 * If the generation was already drained it is fine for a buffer to come late and miss it\n                 */\n                synchronized(instance) {\n                    if (!instance.m_generationGhosts.contains(exportGeneration)) {\n                        assert(false);\n                        exportLog.error(\"Could not a find an export generation \" + exportGeneration +\n                        \". Should be impossible. Discarding export data\");\n                    }\n                }\n                return;\n            }\n\n            generation.pushExportBuffer(partitionId, signature, uso, buffer, sync, endOfStream);\n        } catch (Exception e) {\n            //Don't let anything take down the execution site thread\n            exportLog.error(\"Error pushing export buffer\", e);\n        }\n    }","commit_id":"a9c10ad414dc1e3362d904e4356f8cf720a965fa","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n  public boolean shouldHighlightErrorElement(@NotNull PsiErrorElement element) {\n    final FileViewProvider viewProvider = element.getContainingFile().getViewProvider();\n    if (!(viewProvider.getClass() == myTemplateFileViewProviderClass)) {\n      return true;\n    }\n    if (isKnownSubLanguage(element.getParent().getLanguage())) {\n      final PsiElement next = viewProvider.findElementAt(element.getTextOffset() + 1, viewProvider.getBaseLanguage());\n      if (next != null && myTemplateExpressionStartTokens.contains(next.getNode().getElementType())) {\n        return false;\n      }\n    }\n    return true;\n  }","id":99889,"modified_method":"@Override\n  public boolean shouldHighlightErrorElement(@NotNull PsiErrorElement element) {        \n    if (isKnownSubLanguage(element.getParent().getLanguage())) {\n      //\n      // Immediately discard filters with non-matching template class if already known\n      //\n      Class templateClass = element.getUserData(TEMPLATE_VIEW_PROVIDER_CLASS_KEY);\n      if (templateClass != null && (templateClass != myTemplateFileViewProviderClass)) return true;\n      \n      PsiFile psiFile = element.getContainingFile();\n      int offset = element.getTextOffset();\n      InjectedLanguageManager injectedLanguageManager = InjectedLanguageManager.getInstance(element.getProject());\n      if (injectedLanguageManager.isInjectedFragment(psiFile)) {\n        PsiElement host = injectedLanguageManager.getInjectionHost(element);\n        if (host != null) {\n          psiFile = host.getContainingFile();\n          offset = injectedLanguageManager.injectedToHost(element, offset);\n        }\n      }\n      final FileViewProvider viewProvider = psiFile.getViewProvider();\n      element.putUserData(TEMPLATE_VIEW_PROVIDER_CLASS_KEY, viewProvider.getClass());\n      if (!(viewProvider.getClass() == myTemplateFileViewProviderClass)) {\n        return true;\n      }\n      //\n      // An error can occur at template element or before it. Check both.\n      //\n      if (shouldIgnoreErrorAt(viewProvider, offset) || shouldIgnoreErrorAt(viewProvider, offset + 1)) return false;\n    }\n    return true;\n  }","commit_id":"520c7efcd2b2e6aa3e0e6154170a9f07dff3e98a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static TextRange range(PsiJavaModule module) {\n    return new TextRange(module.getTextOffset(), module.getNameElement().getTextRange().getEndOffset());\n  }","id":99890,"modified_method":"private static TextRange range(PsiJavaModule module) {\n    PsiKeyword kw = PsiTreeUtil.getChildOfType(module, PsiKeyword.class);\n    return new TextRange(kw != null ? kw.getTextOffset() : module.getTextOffset(), module.getNameElement().getTextRange().getEndOffset());\n  }","commit_id":"7f501ae188d59674464d5e9249593c4d40529ea4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean get(BooleanKey key) {\n\t\treturn Boolean.valueOf(values.getPreference(key));\n\t}","id":99891,"modified_method":"public boolean get(BooleanKey key) {\n\t\tfinal String preference = values.getPreference(key);\n\t\tif (preference != null)\n\t\t\treturn Boolean.valueOf(preference);\n\t\treturn Boolean.valueOf(key.getDefaultValue());\n\t}","commit_id":"c7d950d9984d36a5deda07a210c6e9be0e81b4ae","url":"https://github.com/eclipse/xtext"},{"original_method":"public int get(IntegerKey key) {\n\t\treturn Integer.valueOf(values.getPreference(key));\n\t}","id":99892,"modified_method":"public int get(IntegerKey key) {\n\t\tfinal String preference = values.getPreference(key);\n\t\ttry {\n\t\t\tif (preference != null)\n\t\t\t\treturn Integer.valueOf(preference);\n\t\t} catch (NumberFormatException e) {\n\t\t\tlog.warn(\"Couldn't parse value '\"+preference+\"' of formatting preference '\"+key.getId()+\"'.\");\n\t\t}\n\t\treturn Integer.valueOf(key.getDefaultValue());\n\t}","commit_id":"c7d950d9984d36a5deda07a210c6e9be0e81b4ae","url":"https://github.com/eclipse/xtext"},{"original_method":"public String get(StringKey key) {\n\t\treturn values.getPreference(key);\n\t}","id":99893,"modified_method":"public String get(StringKey key) {\n\t\tfinal String preference = values.getPreference(key);\n\t\tif (preference != null)\n\t\t\treturn preference;\n\t\treturn key.getDefaultValue();\n\t}","commit_id":"c7d950d9984d36a5deda07a210c6e9be0e81b4ae","url":"https://github.com/eclipse/xtext"},{"original_method":"private void handleData(Object sender, int num_bytes) {\n        MemberInfo info=null;\n        boolean do_sleep=false;\n\n        synchronized(this) {\n            if(all_received)\n                return;\n            if(start == 0) {\n                start=System.currentTimeMillis();\n            }\n\n            num_msgs_received++;\n            num_bytes_received+=num_bytes;\n\n            if(num_msgs_received >= num_msgs_expected) {\n                if(stop == 0) {\n                    stop=System.currentTimeMillis();\n                }\n                all_received=true;\n            }\n\n            if(num_msgs_received % log_interval == 0) {\n                System.out.println(new StringBuilder(\"-- received \").append(num_msgs_received).append(\" messages\"));\n            }\n\n            if(counter % log_interval == 0) {\n                output(dumpStats(counter));\n            }\n            info=this.senders.get(sender);\n            if(info != null) {\n                if(info.start == 0)\n                    info.start=System.currentTimeMillis();\n                info.num_msgs_received++;\n                counter++;\n                info.total_bytes_received+=num_bytes;\n                if(info.num_msgs_received >= info.num_msgs_expected) {\n                    info.done=true;\n                    if(info.stop == 0)\n                        info.stop=System.currentTimeMillis();\n                }\n                else {\n                    if(processing_delay > 0)\n                        do_sleep=true;\n                }\n            }\n            else {\n                log.error(\"-- sender \" + sender + \" not found in senders hashmap\");\n            }\n        }\n\n        if(do_sleep && processing_delay > 0) {\n            Util.sleep(processing_delay);\n        }\n\n        synchronized(this) {\n            if(all_received) {\n                if(!this.sender)\n                    dumpSenders();\n                publisher.start();\n            }\n        }\n    }","id":99894,"modified_method":"private void handleData(Object sender, int num_bytes) {\n        MemberInfo info=null;\n        boolean do_sleep=false;\n\n        synchronized(this) {\n            if(all_received)\n                return;\n            if(start == 0) {\n                start=last_interval=System.currentTimeMillis();\n            }\n\n            num_msgs_received++;\n            num_bytes_received+=num_bytes;\n\n            if(num_msgs_received >= num_msgs_expected) {\n                if(stop == 0) {\n                    stop=System.currentTimeMillis();\n                }\n                all_received=true;\n            }\n\n            if(num_msgs_received % log_interval == 0) {\n                long curr=System.currentTimeMillis();\n                long diff=curr - last_interval;\n                last_interval=curr;\n                double msgs_sec=log_interval / (diff / 1000.0);\n                System.out.println(new StringBuilder(\"-- received \").append(num_msgs_received).append(\" messages\")\n                                   .append(\" (time=\" + diff + \" ms, \" + f.format(msgs_sec) + \" msgs/sec)\"));\n            }\n\n            if(counter % log_interval == 0) {\n                output(dumpStats(counter));\n            }\n            info=this.senders.get(sender);\n            if(info != null) {\n                if(info.start == 0)\n                    info.start=System.currentTimeMillis();\n                info.num_msgs_received++;\n                counter++;\n                info.total_bytes_received+=num_bytes;\n                if(info.num_msgs_received >= info.num_msgs_expected) {\n                    info.done=true;\n                    if(info.stop == 0)\n                        info.stop=System.currentTimeMillis();\n                }\n                else {\n                    if(processing_delay > 0)\n                        do_sleep=true;\n                }\n            }\n            else {\n                log.error(\"-- sender \" + sender + \" not found in senders hashmap\");\n            }\n        }\n\n        if(do_sleep && processing_delay > 0) {\n            Util.sleep(processing_delay);\n        }\n\n        synchronized(this) {\n            if(all_received) {\n                if(!this.sender)\n                    dumpSenders();\n                publisher.start();\n            }\n        }\n    }","commit_id":"68f47c1dd86554fd91d7cb010543db8eee44c8fc","url":"https://github.com/belaban/JGroups"},{"original_method":"protected void closeConnection(BinaryMapIndexReader c, String file) {\n\t\tfiles.remove(file);\n\t\tnativeFiles.remove(file);\n\t\ttry {\n\t\t\tc.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}","id":99895,"modified_method":"protected void closeConnection(BinaryMapIndexReader c, String file) {\n\t\tfiles.remove(file);\n\t\tif(nativeFiles.contains(file)){\n\t\t\tNativeOsmandLibrary lib = NativeOsmandLibrary.getLoadedLibrary();\n\t\t\tif(lib != null) {\n\t\t\t\tlib.closeMapFile(file);\n\t\t\t\tnativeFiles.remove(file);\n\t\t\t}\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tc.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}","commit_id":"e36e6110c9a44ddd0c7aebdcd04c45c06310c5f4","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private boolean loadVectorDataNative(RectF dataBox, final int zoom, final RenderingRuleSearchRequest renderingReq, \n\t\t\tNativeOsmandLibrary library) {\n\t\tint leftX = MapUtils.get31TileNumberX(dataBox.left);\n\t\tint rightX = MapUtils.get31TileNumberX(dataBox.right);\n\t\tint bottomY = MapUtils.get31TileNumberY(dataBox.bottom);\n\t\tint topY = MapUtils.get31TileNumberY(dataBox.top);\n\t\tlong now = System.currentTimeMillis();\n\t\t// TODO coastline/land tiles \n\t\tNativeSearchResult resultHandler = null;\n\t\tfor (String mapName : files.keySet()) {\n\t\t\tBinaryMapIndexReader reader = files.get(mapName);\n\t\t\tif(!reader.containsMapData(leftX, topY, rightX, bottomY, zoom)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!nativeFiles.contains(mapName)) {\n\t\t\t\tnativeFiles.add(mapName);\n\t\t\t\tif (!library.initMapFile(mapName)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlog.debug(\"Native resource \" + mapName + \" initialized\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t}\n\t\t\tresultHandler = library.searchObjectsForRendering(leftX, rightX, topY, bottomY, zoom, mapName, renderingReq,\n\t\t\t\t\tPerformanceFlags.checkForDuplicateObjectIds, resultHandler, this);\n\t\t\tif (checkWhetherInterrupted()) {\n\t\t\t\tlibrary.deleteSearchResult(resultHandler);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tcNativeObjects = resultHandler;\n\t\tcObjectsBox = dataBox;\n\t\tlog.info(String.format(\"BLat=%s, TLat=%s, LLong=%s, RLong=%s, zoom=%s\", //$NON-NLS-1$\n\t\t\t\tdataBox.bottom, dataBox.top, dataBox.left, dataBox.right, zoom));\n\t\tlog.info(String.format(\"Native search: %s ms \", System.currentTimeMillis() - now)); //$NON-NLS-1$\n\t\treturn true;\n\t}","id":99896,"modified_method":"private boolean loadVectorDataNative(RectF dataBox, final int zoom, final RenderingRuleSearchRequest renderingReq, \n\t\t\tNativeOsmandLibrary library) {\n\t\tint leftX = MapUtils.get31TileNumberX(dataBox.left);\n\t\tint rightX = MapUtils.get31TileNumberX(dataBox.right);\n\t\tint bottomY = MapUtils.get31TileNumberY(dataBox.bottom);\n\t\tint topY = MapUtils.get31TileNumberY(dataBox.top);\n\t\tlong now = System.currentTimeMillis();\n\n\t\t// additionally initialize\n\t\tNativeSearchResult resultHandler = null;\n\t\tfor (String mapName : files.keySet()) {\n\t\t\tif (!nativeFiles.contains(mapName)) {\n\t\t\t\tnativeFiles.add(mapName);\n\t\t\t\tif (!library.initMapFile(mapName)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlog.debug(\"Native resource \" + mapName + \" initialized\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t}\n\t\t}\n\t\t\n\t\t// TODO coastline/land tiles \n\t\tfor (String mapName : files.keySet()) {\n\t\t\tBinaryMapIndexReader reader = files.get(mapName);\n\t\t\tif(!reader.containsMapData(leftX, topY, rightX, bottomY, zoom)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tresultHandler = library.searchObjectsForRendering(leftX, rightX, topY, bottomY, zoom, mapName, renderingReq,\n\t\t\t\t\tPerformanceFlags.checkForDuplicateObjectIds, resultHandler, this);\n\t\t\tif (checkWhetherInterrupted()) {\n\t\t\t\tlibrary.deleteSearchResult(resultHandler);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tcNativeObjects = resultHandler;\n\t\tcObjectsBox = dataBox;\n\t\tlog.info(String.format(\"BLat=%s, TLat=%s, LLong=%s, RLong=%s, zoom=%s\", //$NON-NLS-1$\n\t\t\t\tdataBox.bottom, dataBox.top, dataBox.left, dataBox.right, zoom));\n\t\tlog.info(String.format(\"Native search: %s ms \", System.currentTimeMillis() - now)); //$NON-NLS-1$\n\t\treturn true;\n\t}","commit_id":"e36e6110c9a44ddd0c7aebdcd04c45c06310c5f4","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public BinaryMapIndexReader initializeNewResource(final IProgress progress, File file) {\n\t\tlong start = System.currentTimeMillis();\n\t\tif (files.containsKey(file.getAbsolutePath())) {\n\t\t\tcloseConnection(files.get(file.getAbsolutePath()), file.getAbsolutePath());\n\t\t\t\n\t\t}\n\t\tRandomAccessFile raf = null;\n\t\tBinaryMapIndexReader reader = null;\n\t\ttry {\n\t\t\traf = new RandomAccessFile(file, \"r\"); //$NON-NLS-1$\n\t\t\treader = new BinaryMapIndexReader(raf);\n\t\t\tif (reader.getVersion() != IndexConstants.BINARY_MAP_VERSION) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tfiles.put(file.getAbsolutePath(), reader);\n\n\t\t} catch (IOException e) {\n\t\t\tlog.error(\"No connection or unsupported version\", e); //$NON-NLS-1$\n\t\t\tif (raf != null) {\n\t\t\t\ttry {\n\t\t\t\t\traf.close();\n\t\t\t\t} catch (IOException e1) {\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t} catch (OutOfMemoryError oome) {\n\t\t\tif (raf != null) {\n\t\t\t\ttry {\n\t\t\t\t\traf.close();\n\t\t\t\t} catch (IOException e1) {\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow oome;\n\t\t}\n\t\tif (log.isDebugEnabled()) {\n\t\t\tlog.debug(\"Initializing db \" + file.getAbsolutePath() + \" \" + (System.currentTimeMillis() - start) + \"ms\"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$\n\t\t}\n\t\treturn reader;\n\t}","id":99897,"modified_method":"public BinaryMapIndexReader initializeNewResource(final IProgress progress, File file) {\n\t\tlong start = System.currentTimeMillis();\n\t\tif (files.containsKey(file.getAbsolutePath())) {\n\t\t\tcloseConnection(files.get(file.getAbsolutePath()), file.getAbsolutePath());\n\t\t\t\n\t\t}\n\t\tRandomAccessFile raf = null;\n\t\tBinaryMapIndexReader reader = null;\n\t\ttry {\n\t\t\traf = new RandomAccessFile(file, \"r\"); //$NON-NLS-1$\n\t\t\treader = new BinaryMapIndexReader(raf);\n\t\t\tif (reader.getVersion() != IndexConstants.BINARY_MAP_VERSION) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tfiles.put(file.getAbsolutePath(), reader);\n\n\t\t} catch (IOException e) {\n\t\t\tlog.error(\"No connection or unsupported version\", e); //$NON-NLS-1$\n\t\t\tif (raf != null) {\n\t\t\t\ttry {\n\t\t\t\t\traf.close();\n\t\t\t\t} catch (IOException e1) {\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t} catch (OutOfMemoryError oome) {\n\t\t\tif (raf != null) {\n\t\t\t\ttry {\n\t\t\t\t\traf.close();\n\t\t\t\t} catch (IOException e1) {\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow oome;\n\t\t}\n\t\tlong val = System.currentTimeMillis();\n\t\tif (log.isDebugEnabled()) {\n\t\t\tlog.debug(\"Initializing db \" + file.getAbsolutePath() + \" \" + (val - start) + \"ms\"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$\n\t\t}\n\t\tNativeOsmandLibrary nativeLib = prefs.NATIVE_RENDERING.get() ? NativeOsmandLibrary.getLoadedLibrary() : null;\n\t\tif (nativeLib != null) {\n\t\t\tstart = val;\n\t\t\tif (!nativeLib.initMapFile(file.getAbsolutePath())) {\n\t\t\t\tlog.debug(\"Initializing native db \" + file.getAbsolutePath() + \" failed!\"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$\n\t\t\t} else {\n\t\t\t\tnativeFiles.add(file.getAbsolutePath());\n\t\t\t\tval = System.currentTimeMillis();\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"Initializing native db \" + file.getAbsolutePath() + \" \" + (val - start) + \"ms\"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn reader;\n\t}","commit_id":"e36e6110c9a44ddd0c7aebdcd04c45c06310c5f4","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public MapRenderRepositories(Context context) {\n\t\tthis.context = context;\n\t\tthis.renderer = new OsmandRenderer(context);\n\t\thandler = new Handler(Looper.getMainLooper());\n\t\tprefs = OsmandApplication.getSettings();\n\t}","id":99898,"modified_method":"public MapRenderRepositories(OsmandApplication context) {\n\t\tthis.context = context;\n\t\tthis.renderer = new OsmandRenderer(context);\n\t\thandler = new Handler(Looper.getMainLooper());\n\t\tprefs = OsmandApplication.getSettings();\n\t}","commit_id":"e36e6110c9a44ddd0c7aebdcd04c45c06310c5f4","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override public Response serve() {\n    JsonObject response = new JsonObject();\n    final H2O cloud = H2O.CLOUD;\n    final H2ONode self = H2O.SELF;\n    response.addProperty(CLOUD_NAME, H2O.NAME);\n    response.addProperty(NODE_NAME, self.toString());\n    response.addProperty(CLOUD_SIZE, cloud._memary.length);\n    JsonArray nodes = new JsonArray();\n    for (H2ONode h2o : cloud._memary) {\n      HeartBeat hb = h2o._heartbeat;\n      JsonObject node = new JsonObject();\n      node.addProperty(NAME,h2o.toString());\n      node.addProperty(NUM_KEYS, hb._keys);\n      node.addProperty(VALUE_SIZE, hb.get_valsz());\n      node.addProperty(FREE_MEM, hb.get_free_mem());\n      node.addProperty(TOT_MEM, hb.get_tot_mem());\n      node.addProperty(MAX_MEM, hb.get_max_mem());\n      node.addProperty(FREE_DISK, hb.get_free_disk());\n      node.addProperty(MAX_DISK, hb.get_max_disk());\n      node.addProperty(NUM_CPUS, (int)hb._num_cpus);\n      node.addProperty(SYSTEM_LOAD, hb._system_load_average);\n\n      JsonArray fjt = new JsonArray();\n      JsonArray fjq = new JsonArray();\n      if( hb._fjthrds_hi != null ) {\n        for( int i=0; i<hb._fjthrds_hi.length; i++ ) {\n          fjt.add(new JsonPrimitive(hb._fjthrds_hi[i]));\n          fjq.add(new JsonPrimitive(hb._fjqueue_hi[i]));\n        }\n      }\n      node.add(FJ_THREADS_HI, fjt);\n      node.add(FJ_QUEUE_HI  , fjq);\n      node.addProperty(FJ_THREADS_LO, (int)hb._fjthrds_lo);\n      node.addProperty(FJ_QUEUE_LO, (int)hb._fjqueue_lo);\n      node.addProperty(RPCS, (int)hb._rpcs);\n      node.addProperty(TCPS_ACTIVE, (int) hb._tcps_active);\n      nodes.add(node);\n    }\n    response.add(NODES,nodes);\n    response.addProperty(CONSENSUS, Paxos._commonKnowledge); // Cloud is globally accepted\n    response.addProperty(LOCKED, Paxos._cloudLocked); // Cloud is locked against changes\n    Response r = Response.done(response);\n    r.setBuilder(CONSENSUS, new BooleanStringBuilder(\"\",\"Voting new members\"));\n    r.setBuilder(LOCKED, new BooleanStringBuilder(\"Locked\",\"Accepting new members\"));\n    r.setBuilder(NODES+\".\"+NAME, new NodeCellBuilder());\n    return r;\n  }","id":99899,"modified_method":"@Override public Response serve() {\n    JsonObject response = new JsonObject();\n    final H2O cloud = H2O.CLOUD;\n    final H2ONode self = H2O.SELF;\n    response.addProperty(CLOUD_NAME, H2O.NAME);\n    response.addProperty(NODE_NAME, self.toString());\n    response.addProperty(CLOUD_SIZE, cloud._memary.length);\n    JsonArray nodes = new JsonArray();\n    for (H2ONode h2o : cloud._memary) {\n      HeartBeat hb = h2o._heartbeat;\n      JsonObject node = new JsonObject();\n      node.addProperty(NAME,h2o.toString());\n      node.addProperty(NUM_KEYS, hb._keys);\n      node.addProperty(VALUE_SIZE, hb.get_valsz());\n      node.addProperty(FREE_MEM, hb.get_free_mem());\n      node.addProperty(TOT_MEM, hb.get_tot_mem());\n      node.addProperty(MAX_MEM, hb.get_max_mem());\n      node.addProperty(FREE_DISK, hb.get_free_disk());\n      node.addProperty(MAX_DISK, hb.get_max_disk());\n      node.addProperty(NUM_CPUS, (int)hb._num_cpus);\n      node.addProperty(SYSTEM_LOAD, hb._system_load_average);\n\n      JsonArray fjt = new JsonArray();\n      JsonArray fjq = new JsonArray();\n      if( hb._fjthrds_hi != null ) {\n        for( int i=0; i<hb._fjthrds_hi.length; i++ ) {\n          fjt.add(new JsonPrimitive(hb._fjthrds_hi[i]));\n          fjq.add(new JsonPrimitive(hb._fjqueue_hi[i]));\n        }\n      }\n      node.add(FJ_THREADS_HI, fjt);\n      node.add(FJ_QUEUE_HI  , fjq);\n      node.addProperty(FJ_THREADS_LO, (int)hb._fjthrds_lo);\n      node.addProperty(FJ_QUEUE_LO, (int)hb._fjqueue_lo);\n      node.addProperty(RPCS, (int)hb._rpcs);\n      node.addProperty(TCPS_ACTIVE, (int) hb._tcps_active);\n      node.addProperty(TCPS_DUTY, (int) hb._tcps_duty);\n      nodes.add(node);\n    }\n    response.add(NODES,nodes);\n    response.addProperty(CONSENSUS, Paxos._commonKnowledge); // Cloud is globally accepted\n    response.addProperty(LOCKED, Paxos._cloudLocked); // Cloud is locked against changes\n    Response r = Response.done(response);\n    r.setBuilder(CONSENSUS, new BooleanStringBuilder(\"\",\"Voting new members\"));\n    r.setBuilder(LOCKED, new BooleanStringBuilder(\"Locked\",\"Accepting new members\"));\n    r.setBuilder(NODES+\".\"+NAME, new NodeCellBuilder());\n    return r;\n  }","commit_id":"6be0d98e68cecdcf03ffd8d12f82513ec46ad97a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"/** Initializes the network services of the local node.\n*\n* Starts the worker threads, receiver threads, heartbeats and all other\n* network related services.\n*/\n  private static void startNetworkServices() {\n    // We've rebooted the JVM recently. Tell other Nodes they can ignore task\n    // prior tasks by us. Do this before we receive any packets\n    UDPRebooted.T.reboot.broadcast();\n\n    // Start the UDPReceiverThread, to listen for requests from other Cloud\n    // Nodes. There should be only 1 of these, and it never shuts down.\n    // Started first, so we can start parsing UDP packets\n    new UDPReceiverThread().start();\n\n    // Start the MultiReceiverThread, to listen for multi-cast requests from\n    // other Cloud Nodes. There should be only 1 of these, and it never shuts\n    // down. Started soon, so we can start parsing multicast UDP packets\n    new MultiReceiverThread().start();\n\n    // Start the Persistent meta-data cleaner thread, which updates the K/V\n    // mappings periodically to disk. There should be only 1 of these, and it\n    // never shuts down.  Needs to start BEFORE the HeartBeatThread to build\n    // an initial histogram state.\n    new Cleaner().start();\n\n    // Start the heartbeat thread, to publish the Clouds' existence to other\n    // Clouds. This will typically trigger a round of Paxos voting so we can\n    // join an existing Cloud.\n    new HeartBeatThread().start();\n\n    // Start a UDP timeout worker thread. This guy only handles requests for\n    // which we have not recieved a timely response and probably need to\n    // arrange for a re-send to cover a dropped UDP packet.\n    new UDPTimeOutThread().start();\n    new H2ONode.AckAckTimeOutThread().start();\n\n    // Start the TCPReceiverThread, to listen for TCP requests from other Cloud\n    // Nodes. There should be only 1 of these, and it never shuts down.\n    new TCPReceiverThread().start();\n    water.api.RequestServer.start();\n  }","id":99900,"modified_method":"/** Initializes the network services of the local node.\n*\n* Starts the worker threads, receiver threads, heartbeats and all other\n* network related services.\n*/\n  private static void startNetworkServices() {\n    // We've rebooted the JVM recently. Tell other Nodes they can ignore task\n    // prior tasks by us. Do this before we receive any packets\n    UDPRebooted.T.reboot.broadcast();\n\n    // Start the UDPReceiverThread, to listen for requests from other Cloud\n    // Nodes. There should be only 1 of these, and it never shuts down.\n    // Started first, so we can start parsing UDP packets\n    new UDPReceiverThread().start();\n\n    // Start the MultiReceiverThread, to listen for multi-cast requests from\n    // other Cloud Nodes. There should be only 1 of these, and it never shuts\n    // down. Started soon, so we can start parsing multicast UDP packets\n    new MultiReceiverThread().start();\n\n    // Start the Persistent meta-data cleaner thread, which updates the K/V\n    // mappings periodically to disk. There should be only 1 of these, and it\n    // never shuts down.  Needs to start BEFORE the HeartBeatThread to build\n    // an initial histogram state.\n    new Cleaner().start();\n\n    // Start the heartbeat thread, to publish the Clouds' existence to other\n    // Clouds. This will typically trigger a round of Paxos voting so we can\n    // join an existing Cloud.\n    new HeartBeatThread().start();\n\n    // Start a UDP timeout worker thread. This guy only handles requests for\n    // which we have not recieved a timely response and probably need to\n    // arrange for a re-send to cover a dropped UDP packet.\n    new UDPTimeOutThread().start();\n    new H2ONode.AckAckTimeOutThread().start();\n\n    // Start the TCPReceiverThread, to listen for TCP requests from other Cloud\n    // Nodes. There should be only 1 of these, and it never shuts down.\n    (TCPReceiverThread.TCPTHR=new TCPReceiverThread()).start();\n    water.api.RequestServer.start();\n  }","commit_id":"6be0d98e68cecdcf03ffd8d12f82513ec46ad97a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public void run() {\n    MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n    ObjectName os;\n    try {\n      os = new ObjectName(\"java.lang:type=OperatingSystem\");\n    } catch( MalformedObjectNameException e ) {\n      throw  Log.errRTExcept(e);\n    }\n    Thread.currentThread().setPriority(Thread.MAX_PRIORITY);\n    while( true ) {\n      // Once per second, for the entire cloud a Node will multi-cast publish\n      // itself, so other unrelated Clouds discover each other and form up.\n      try { Thread.sleep(SLEEP); } // Only once-sec per entire Cloud\n      catch( InterruptedException e ) { }\n\n      // Update the interesting health self-info for publication also\n      H2O cloud = H2O.CLOUD;\n      HeartBeat hb = H2O.SELF._heartbeat;\n      hb._hb_version = HB_VERSION++;\n      hb._jvm_boot_msec= TimeLine.JVM_BOOT_MSEC;\n      final Runtime run = Runtime.getRuntime();\n      hb.set_free_mem  (run. freeMemory());\n      hb.set_max_mem   (run.  maxMemory());\n      hb.set_tot_mem   (run.totalMemory());\n      hb._keys       = (H2O.STORE.size ());\n      hb.set_valsz     (myHisto.histo(false)._cached);\n      hb._num_cpus   = (char)run.availableProcessors();\n      Object load = null;\n      try {\n        load = mbs.getAttribute(os, \"SystemLoadAverage\");\n      } catch( Exception e ) {\n        // Ignore, data probably not available on this VM\n      }\n      hb._system_load_average = load instanceof Double ? ((Double) load).floatValue() : 0;\n      int rpcs = 0;\n      for( H2ONode h2o : cloud._memary )\n        rpcs += h2o.taskSize();\n      hb._rpcs       = (char)rpcs;\n      hb._fjthrds_hi = new short[H2O.MAX_PRIORITY+1-H2O.MIN_HI_PRIORITY];\n      hb._fjqueue_hi = new short[H2O.MAX_PRIORITY+1-H2O.MIN_HI_PRIORITY];\n      for( int i=0; i<hb._fjthrds_hi.length; i++ ) {\n        hb._fjthrds_hi[i] = (short)H2O.hiQPoolSize(i);\n        hb._fjqueue_hi[i] = (short)H2O.getHiQueue(i);\n      }\n      hb._fjthrds_lo = (char)H2O.loQPoolSize();\n      hb._fjqueue_lo = (char)H2O.getLoQueue();\n      hb._tcps_active= (char)AutoBuffer.TCPS.get();\n      // get the usable and total disk storage for the partition where the\n      // persistent KV pairs are stored\n      if (PersistIce.ROOT==null) {\n        hb.set_free_disk(0); // not applicable\n        hb.set_max_disk(0); // not applicable\n      } else {\n        File f = new File(PersistIce.ROOT);\n        hb.set_free_disk(f.getUsableSpace());\n        hb.set_max_disk(f.getTotalSpace());\n      }\n\n      // Announce what Cloud we think we are in.\n      // Publish our health as well.\n      UDPHeartbeat.build_and_multicast(cloud, hb);\n\n      // If we have no internet connection, then the multicast goes\n      // nowhere and we never receive a heartbeat from ourselves!\n      // Fake it now.\n      long now = System.currentTimeMillis();\n      H2O.SELF._last_heard_from = now;\n\n      // Look for napping Nodes & propose removing from Cloud\n      for( H2ONode h2o : cloud._memary ) {\n        if( now - h2o._last_heard_from > SUSPECT ) {  // We suspect this Node has taken a dirt nap\n          Paxos.print(\"hart: announce suspect node\",cloud._memary,h2o.toString());\n          break;\n        }\n      }\n    }\n  }","id":99901,"modified_method":"public void run() {\n    MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n    ObjectName os;\n    try {\n      os = new ObjectName(\"java.lang:type=OperatingSystem\");\n    } catch( MalformedObjectNameException e ) {\n      throw  Log.errRTExcept(e);\n    }\n    Thread.currentThread().setPriority(Thread.MAX_PRIORITY);\n    while( true ) {\n      // Once per second, for the entire cloud a Node will multi-cast publish\n      // itself, so other unrelated Clouds discover each other and form up.\n      try { Thread.sleep(SLEEP); } // Only once-sec per entire Cloud\n      catch( InterruptedException e ) { }\n\n      // Update the interesting health self-info for publication also\n      H2O cloud = H2O.CLOUD;\n      HeartBeat hb = H2O.SELF._heartbeat;\n      hb._hb_version = HB_VERSION++;\n      hb._jvm_boot_msec= TimeLine.JVM_BOOT_MSEC;\n      final Runtime run = Runtime.getRuntime();\n      hb.set_free_mem  (run. freeMemory());\n      hb.set_max_mem   (run.  maxMemory());\n      hb.set_tot_mem   (run.totalMemory());\n      hb._keys       = (H2O.STORE.size ());\n      hb.set_valsz     (myHisto.histo(false)._cached);\n      hb._num_cpus   = (char)run.availableProcessors();\n      Object load = null;\n      try {\n        load = mbs.getAttribute(os, \"SystemLoadAverage\");\n      } catch( Exception e ) {\n        // Ignore, data probably not available on this VM\n      }\n      hb._system_load_average = load instanceof Double ? ((Double) load).floatValue() : 0;\n      int rpcs = 0;\n      for( H2ONode h2o : cloud._memary )\n        rpcs += h2o.taskSize();\n      hb._rpcs       = (char)rpcs;\n      hb._fjthrds_hi = new short[H2O.MAX_PRIORITY+1-H2O.MIN_HI_PRIORITY];\n      hb._fjqueue_hi = new short[H2O.MAX_PRIORITY+1-H2O.MIN_HI_PRIORITY];\n      for( int i=0; i<hb._fjthrds_hi.length; i++ ) {\n        hb._fjthrds_hi[i] = (short)H2O.hiQPoolSize(i);\n        hb._fjqueue_hi[i] = (short)H2O.getHiQueue(i);\n      }\n      hb._fjthrds_lo = (char)H2O.loQPoolSize();\n      hb._fjqueue_lo = (char)H2O.getLoQueue();\n      hb._tcps_active= (char)AutoBuffer.TCPS.get();\n      hb._tcps_duty  = (byte)TCPReceiverThread.TCPTHR.dutyCyclePercent();\n\n      // get the usable and total disk storage for the partition where the\n      // persistent KV pairs are stored\n      if (PersistIce.ROOT==null) {\n        hb.set_free_disk(0); // not applicable\n        hb.set_max_disk(0); // not applicable\n      } else {\n        File f = new File(PersistIce.ROOT);\n        hb.set_free_disk(f.getUsableSpace());\n        hb.set_max_disk(f.getTotalSpace());\n      }\n\n      // Announce what Cloud we think we are in.\n      // Publish our health as well.\n      UDPHeartbeat.build_and_multicast(cloud, hb);\n\n      // If we have no internet connection, then the multicast goes\n      // nowhere and we never receive a heartbeat from ourselves!\n      // Fake it now.\n      long now = System.currentTimeMillis();\n      H2O.SELF._last_heard_from = now;\n\n      // Look for napping Nodes & propose removing from Cloud\n      for( H2ONode h2o : cloud._memary ) {\n        if( now - h2o._last_heard_from > SUSPECT ) {  // We suspect this Node has taken a dirt nap\n          Paxos.print(\"hart: announce suspect node\",cloud._memary,h2o.toString());\n          break;\n        }\n      }\n    }\n  }","commit_id":"6be0d98e68cecdcf03ffd8d12f82513ec46ad97a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@SuppressWarnings(\"resource\")\n  public void run() {\n    Thread.currentThread().setPriority(Thread.MAX_PRIORITY-1);\n    ServerSocketChannel errsock = null;\n    boolean saw_error = false;\n\n    while( true ) {\n      try {\n        // Cleanup from any prior socket failures.  Rare unless we're really sick.\n        if( errsock != null ) { // One time attempt a socket close\n          final ServerSocketChannel tmp2 = errsock; errsock = null;\n          tmp2.close();       // Could throw, but errsock cleared for next pass\n        }\n        if( saw_error ) Thread.sleep(100); // prevent deny-of-service endless socket-creates\n        saw_error = false;\n\n        // ---\n        // More common-case setup of a ServerSocket\n        if( SOCK == null ) {\n          SOCK = ServerSocketChannel.open();\n          SOCK.socket().setReceiveBufferSize(AutoBuffer.BBSIZE);\n          SOCK.socket().bind(H2O.SELF._key);\n        }\n\n        // Block for TCP connection and setup to read from it.\n        AutoBuffer ab = new AutoBuffer(SOCK.accept());\n        int ctrl = ab.getCtrl();\n\n        // Record the last time we heard from any given Node\n        ab._h2o._last_heard_from = System.currentTimeMillis();\n        TimeLine.record_recv(ab, true,0);\n        // Hand off the TCP connection to the proper handler\n        switch( UDP.udp.UDPS[ctrl] ) {\n          //case exec:     H2O.submitTask(new FJPacket(ab,ctrl)); break;\n        case exec:     RPC.remote_exec(ab).close(); break;\n        case ack:      RPC.tcp_ack (ab); break;\n        case timeline: TimeLine.tcp_call(ab); break;\n        default: throw new RuntimeException(\"Unknown TCP Type: \" + ab.getCtrl());\n        }\n\n      } catch( java.nio.channels.AsynchronousCloseException ex ) {\n        break;                  // Socket closed for shutdown\n      } catch( Exception e ) {\n        // On any error from anybody, close all sockets & re-open\n        Log.err(\"IO error on TCP port \"+H2O.UDP_PORT+\": \",e);\n        saw_error = true;\n        errsock = SOCK ;  SOCK = null; // Signal error recovery on the next loop\n      }\n    }\n  }","id":99902,"modified_method":"@SuppressWarnings(\"resource\")\n  public void run() {\n    Thread.currentThread().setPriority(Thread.MAX_PRIORITY-1);\n    ServerSocketChannel errsock = null;\n    boolean saw_error = false;\n    _timeRun = System.currentTimeMillis();\n\n    while( true ) {\n      try {\n        // Cleanup from any prior socket failures.  Rare unless we're really sick.\n        if( errsock != null ) { // One time attempt a socket close\n          final ServerSocketChannel tmp2 = errsock; errsock = null;\n          tmp2.close();       // Could throw, but errsock cleared for next pass\n        }\n        if( saw_error ) Thread.sleep(100); // prevent deny-of-service endless socket-creates\n        saw_error = false;\n\n        // ---\n        // More common-case setup of a ServerSocket\n        if( SOCK == null ) {\n          SOCK = ServerSocketChannel.open();\n          SOCK.socket().setReceiveBufferSize(AutoBuffer.BBSIZE);\n          SOCK.socket().bind(H2O.SELF._key);\n        }\n\n        // Record run-time between connections\n        _timeBlock = System.currentTimeMillis();\n        int runMS   = (int)Math.min(_timeBlock - _timeRun,Integer.MAX_VALUE);\n        _dms[_idx] = runMS;     // Record recent run time\n        _idx = (_idx+1)&(_dms.length-1);\n\n        // Block for TCP connection and setup to read from it.\n        SocketChannel sock = SOCK.accept();\n        _timeRun = System.currentTimeMillis();\n\n        // Record block-time between connections\n        int blockMS = (int)Math.min(_timeRun - _timeBlock,Integer.MAX_VALUE);\n        _dms[_idx] = blockMS;   // Record recent block time\n        _idx = (_idx+1)&(_dms.length-1);\n\n        // Read the TCP connection and handle it\n        AutoBuffer ab = new AutoBuffer(sock);\n        int ctrl = ab.getCtrl();\n\n        // Record the last time we heard from any given Node\n        ab._h2o._last_heard_from = _timeRun;\n        TimeLine.record_recv(ab, true,0);\n        // Hand off the TCP connection to the proper handler\n        switch( UDP.udp.UDPS[ctrl] ) {\n          //case exec:     H2O.submitTask(new FJPacket(ab,ctrl)); break;\n        case exec:     RPC.remote_exec(ab).close(); break;\n        case ack:      RPC.tcp_ack (ab); break;\n        case timeline: TimeLine.tcp_call(ab); break;\n        default: throw new RuntimeException(\"Unknown TCP Type: \" + ab.getCtrl());\n        }\n\n      } catch( java.nio.channels.AsynchronousCloseException ex ) {\n        break;                  // Socket closed for shutdown\n      } catch( Exception e ) {\n        // On any error from anybody, close all sockets & re-open\n        Log.err(\"IO error on TCP port \"+H2O.UDP_PORT+\": \",e);\n        saw_error = true;\n        errsock = SOCK ;  SOCK = null; // Signal error recovery on the next loop\n      }\n    }\n  }","commit_id":"6be0d98e68cecdcf03ffd8d12f82513ec46ad97a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public void run() {\r\n\t\t\t// MM Avoid new calls\r\n\t\t\t//long ourTime = new Date().getTime();\r\n\t\t\tlong ourTime = System.currentTimeMillis();\r\n\t\t\tif ((ourTime - _lastHeartbeat) > HEARTBEAT_PERIOD) {\r\n\t\t\t\t_lastHeartbeat = ourTime;\r\n\t\t\t\theartbeat();\r\n\t\t\t}\r\n\r\n\t\t\tlong minInterestRefreshTime = PERIOD + ourTime;\r\n\t\t\t// Library.finest(\"Refreshing interests (size \" + _myInterests.size() + \")\");\r\n\r\n\t\t\t// Re-express interests that need to be re-expressed\r\n\t\t\ttry {\r\n\t\t\t\tsynchronized (_myInterests) {\r\n\t\t\t\t\tfor (Entry<InterestRegistration> entry : _myInterests.values()) {\r\n\t\t\t\t\t\tInterestRegistration reg = entry.value();\r\n\t\t\t\t\t\tif (ourTime > reg.nextRefresh) {\r\n\t\t\t\t\t\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINER) )\r\n\t\t\t\t\t\t\t\tLog.finer(Log.FAC_NETMANAGER, \"Refresh interest: {0}\", reg.interest);\r\n\t\t\t\t\t\t\t// Temporarily back out refresh period decay\r\n\t\t\t\t\t\t\t//reg.nextRefreshPeriod = (reg.nextRefreshPeriod * 2) > MAX_PERIOD ? MAX_PERIOD\r\n\t\t\t\t\t\t\t//: reg.nextRefreshPeriod * 2;\r\n\t\t\t\t\t\t\treg.nextRefresh += reg.nextRefreshPeriod;\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\twrite(reg.interest);\r\n\t\t\t\t\t\t\t} catch (NotYetConnectedException nyce) {}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (minInterestRefreshTime > reg.nextRefresh)\r\n\t\t\t\t\t\t\tminInterestRefreshTime = reg.nextRefresh;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} catch (ContentEncodingException xmlex) {\r\n\t\t\t\tLog.severe(Log.FAC_NETMANAGER, \"PeriodicWriter interest refresh thread failure (Malformed datagram): {0}\", xmlex.getMessage()); \r\n\t\t\t\tLog.warningStackTrace(xmlex);\r\n\t\t\t}\r\n\r\n\t\t\t// Re-express prefix registrations that need to be re-expressed\r\n\t\t\t// FIXME: The lifetime of a prefix is returned in seconds, not milliseconds.  The refresh code needs\r\n\t\t\t// to understand this.  This isn't a problem for now because the lifetime we request when we register a \r\n\t\t\t// prefix we use Integer.MAX_VALUE as the requested lifetime.\r\n\t\t\tlong minFilterRefreshTime = PERIOD + ourTime;\r\n\t\t\tif (_usePrefixReg) {\r\n\t\t\t\tsynchronized (_registeredPrefixes) {\r\n\t\t\t\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINEST) )\r\n\t\t\t\t\t\tLog.finest(Log.FAC_NETMANAGER, \"Refresh registration.  size: \" + _registeredPrefixes.size());\r\n\t\t\t\t\tfor (ContentName prefix : _registeredPrefixes.keySet()) {\r\n\t\t\t\t\t\tRegisteredPrefix rp = _registeredPrefixes.get(prefix);\r\n\t\t\t\t\t\tif (null != rp._forwarding && rp._lifetime != -1 && rp._nextRefresh != -1) {\r\n\t\t\t\t\t\t\tif (ourTime > rp._nextRefresh) {\r\n\t\t\t\t\t\t\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINER) )\r\n\t\t\t\t\t\t\t\t\tLog.finer(Log.FAC_NETMANAGER, \"Refresh registration: {0}\", prefix);\r\n\t\t\t\t\t\t\t\trp._nextRefresh = -1;\r\n\t\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\t\tForwardingEntry forwarding = _prefixMgr.selfRegisterPrefix(prefix);\r\n\t\t\t\t\t\t\t\t\tif (null != forwarding) {\r\n\t\t\t\t\t\t\t\t\t\trp._lifetime = forwarding.getLifetime();\r\n//\t\t\t\t\t\t\t\t\t\tfilter.nextRefresh = new Date().getTime() + (filter.lifetime / 2);\r\n\t\t\t\t\t\t\t\t\t\trp._nextRefresh = System.currentTimeMillis() + (rp._lifetime / 2);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\trp._forwarding = forwarding;\r\n\r\n\t\t\t\t\t\t\t\t} catch (CCNDaemonException e) {\r\n\t\t\t\t\t\t\t\t\tLog.warning(Log.FAC_NETMANAGER, e.getMessage());\r\n\t\t\t\t\t\t\t\t\t// XXX - don't think this is right\r\n\t\t\t\t\t\t\t\t\trp._forwarding = null;\r\n\t\t\t\t\t\t\t\t\trp._lifetime = -1;\r\n\t\t\t\t\t\t\t\t\trp._nextRefresh = -1;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\t\r\n\t\t\t\t\t\t\tif (minFilterRefreshTime > rp._nextRefresh)\r\n\t\t\t\t\t\t\t\tminFilterRefreshTime = rp._nextRefresh;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} /* for (Entry<Filter> entry : _myFilters.values()) */\r\n\t\t\t\t} /* synchronized (_myFilters) */\r\n\t\t\t} /* _usePrefixReg */\r\n\r\n\t\t\tlong currentTime = System.currentTimeMillis();\r\n\t\t\tlong checkInterestDelay = minInterestRefreshTime - currentTime;\r\n\t\t\tif (checkInterestDelay < 0)\r\n\t\t\t\tcheckInterestDelay = 0;\r\n\t\t\tif (checkInterestDelay > PERIOD)\r\n\t\t\t\tcheckInterestDelay = PERIOD;\r\n\r\n\t\t\tlong checkPrefixDelay = minFilterRefreshTime - currentTime;\r\n\t\t\tif (checkPrefixDelay < 0)\r\n\t\t\t\tcheckPrefixDelay = 0;\r\n\t\t\tif (checkPrefixDelay > PERIOD)\r\n\t\t\t\tcheckPrefixDelay = PERIOD;\r\n\t\t\t\r\n\t\t\tlong useMe;\r\n\t\t\tif (checkInterestDelay < checkPrefixDelay) {\r\n\t\t\t\tuseMe = checkInterestDelay;\r\n\t\t\t} else {\r\n\t\t\t\tuseMe = checkPrefixDelay;\r\n\t\t\t}\r\n\t\t\tif (_run)\r\n\t\t\t\t_periodicTimer.schedule(new PeriodicWriter(), useMe);\r\n\t\t}","id":99903,"modified_method":"public void run() {\r\n\r\n\t\t\t//this method needs to do a few things\r\n\t\t\t// - reopen connection to ccnd if down\r\n\t\t\t// - refresh interests\r\n\t\t\t// - refresh prefix registrations\r\n\t\t\t// - heartbeats\r\n\r\n\t\t\tboolean refreshError = false;\r\n\t\t\tlong ourTime = System.currentTimeMillis();\r\n\t\t\tif (!_connected) {\r\n\t\t\t\t//we are not connected.  reconnect attempt is in the heartbeat function...\r\n\t\t\t\theartbeat();\r\n\t\t\t}\r\n\r\n\t\t\tif (!_connected) {\r\n\t\t\t\t//we tried to reconnect and failed, try again next loop\r\n\t\t\t\tLog.fine(Log.FAC_NETMANAGER, \"Not Connected to ccnd, try again in {0}ms\", SOCKET_TIMEOUT);\r\n\t\t\t\t_lastHeartbeat = 0;\r\n\t\t\t\tif (_run)\r\n\t\t\t\t\t_periodicTimer.schedule(new PeriodicWriter(), SOCKET_TIMEOUT);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tlong minInterestRefreshTime = PERIOD + ourTime;\r\n\t\t\t// Library.finest(\"Refreshing interests (size \" + _myInterests.size() + \")\");\r\n\r\n\t\t\t// Re-express interests that need to be re-expressed\r\n\t\t\ttry {\r\n\t\t\t\tsynchronized (_myInterests) {\r\n\t\t\t\t\tfor (Entry<InterestRegistration> entry : _myInterests.values()) {\r\n\t\t\t\t\t\tInterestRegistration reg = entry.value();\r\n\t\t\t\t\t\tif (ourTime > reg.nextRefresh) {\r\n\t\t\t\t\t\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINER) )\r\n\t\t\t\t\t\t\t\tLog.finer(Log.FAC_NETMANAGER, \"Refresh interest: {0}\", reg.interest);\r\n\t\t\t\t\t\t\t// Temporarily back out refresh period decay\r\n\t\t\t\t\t\t\t//reg.nextRefreshPeriod = (reg.nextRefreshPeriod * 2) > MAX_PERIOD ? MAX_PERIOD\r\n\t\t\t\t\t\t\t//: reg.nextRefreshPeriod * 2;\r\n\t\t\t\t\t\t\treg.nextRefresh += reg.nextRefreshPeriod;\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\twrite(reg.interest);\r\n\t\t\t\t\t\t\t\t_lastHeartbeat = System.currentTimeMillis();\r\n\t\t\t\t\t\t\t} catch (NotYetConnectedException nyce) {\r\n\t\t\t\t\t\t\t\trefreshError = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (minInterestRefreshTime > reg.nextRefresh)\r\n\t\t\t\t\t\t\tminInterestRefreshTime = reg.nextRefresh;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} catch (ContentEncodingException xmlex) {\r\n\t\t\t\tLog.severe(Log.FAC_NETMANAGER, \"PeriodicWriter interest refresh thread failure (Malformed datagram): {0}\", xmlex.getMessage()); \r\n\t\t\t\tLog.warningStackTrace(xmlex);\r\n\t\t\t\trefreshError = true;\r\n\t\t\t}\r\n\r\n\t\t\t// Re-express prefix registrations that need to be re-expressed\r\n\t\t\t// FIXME: The lifetime of a prefix is returned in seconds, not milliseconds.  The refresh code needs\r\n\t\t\t// to understand this.  This isn't a problem for now because the lifetime we request when we register a \r\n\t\t\t// prefix we use Integer.MAX_VALUE as the requested lifetime.\r\n\t\t\tlong minFilterRefreshTime = PERIOD + ourTime;\r\n\t\t\tif (_usePrefixReg) {\r\n\t\t\t\tsynchronized (_registeredPrefixes) {\r\n\t\t\t\t\tfor (ContentName prefix : _registeredPrefixes.keySet()) {\r\n\t\t\t\t\t\tRegisteredPrefix rp = _registeredPrefixes.get(prefix);\r\n\t\t\t\t\t\tif (null != rp._forwarding && rp._lifetime != -1 && rp._nextRefresh != -1) {\r\n\t\t\t\t\t\t\tif (ourTime > rp._nextRefresh) {\r\n\t\t\t\t\t\t\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINE) )\r\n\t\t\t\t\t\t\t\t\tLog.fine(Log.FAC_NETMANAGER, \"Refresh registration: {0}\", prefix);\r\n\t\t\t\t\t\t\t\trp._nextRefresh = -1;\r\n\t\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\t\tForwardingEntry forwarding = _prefixMgr.selfRegisterPrefix(prefix);\r\n\t\t\t\t\t\t\t\t\tif (null != forwarding) {\r\n\t\t\t\t\t\t\t\t\t\trp._lifetime = forwarding.getLifetime();\r\n\t\t\t\t\t\t\t\t\t\t//\t\t\t\t\t\t\t\t\t\tfilter.nextRefresh = new Date().getTime() + (filter.lifetime / 2);\r\n\t\t\t\t\t\t\t\t\t\t_lastHeartbeat = System.currentTimeMillis();\r\n\t\t\t\t\t\t\t\t\t\trp._nextRefresh = _lastHeartbeat + (rp._lifetime / 2);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\trp._forwarding = forwarding;\r\n\r\n\t\t\t\t\t\t\t\t} catch (CCNDaemonException e) {\r\n\t\t\t\t\t\t\t\t\tLog.warning(Log.FAC_NETMANAGER, e.getMessage());\r\n\t\t\t\t\t\t\t\t\t// XXX - don't think this is right\r\n\t\t\t\t\t\t\t\t\trp._forwarding = null;\r\n\t\t\t\t\t\t\t\t\trp._lifetime = -1;\r\n\t\t\t\t\t\t\t\t\trp._nextRefresh = -1;\r\n\r\n\t\t\t\t\t\t\t\t\trefreshError = true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\t\r\n\t\t\t\t\t\t\tif (minFilterRefreshTime > rp._nextRefresh)\r\n\t\t\t\t\t\t\t\tminFilterRefreshTime = rp._nextRefresh;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} /* for (Entry<Filter> entry : _myFilters.values()) */\r\n\t\t\t\t} /* synchronized (_myFilters) */\r\n\t\t\t} /* _usePrefixReg */\r\n\r\n\t\t\tif (refreshError) {\r\n\t\t\t\tLog.warning(Log.FAC_NETMANAGER, \"we have had an error when refreshing an interest or prefix registration...  do we need to reconnect to ccnd?\");\r\n\t\t\t}\r\n\r\n\t\t\tlong currentTime = System.currentTimeMillis();\r\n\t\t\tlong checkInterestDelay = minInterestRefreshTime - currentTime;\r\n\t\t\tif (checkInterestDelay < 0)\r\n\t\t\t\tcheckInterestDelay = 0;\r\n\t\t\tif (checkInterestDelay > PERIOD)\r\n\t\t\t\tcheckInterestDelay = PERIOD;\r\n\r\n\t\t\tlong checkPrefixDelay = minFilterRefreshTime - currentTime;\r\n\t\t\tif (checkPrefixDelay < 0)\r\n\t\t\t\tcheckPrefixDelay = 0;\r\n\t\t\tif (checkPrefixDelay > PERIOD)\r\n\t\t\t\tcheckPrefixDelay = PERIOD;\r\n\r\n\t\t\tlong useMe;\r\n\t\t\tif (checkInterestDelay < checkPrefixDelay) {\r\n\t\t\t\tuseMe = checkInterestDelay;\r\n\t\t\t} else {\r\n\t\t\t\tuseMe = checkPrefixDelay;\r\n\t\t\t}\r\n\t\t\t//we haven't sent anything...  maybe need to send a heartbeat\r\n\t\t\tif ((currentTime - _lastHeartbeat) >= HEARTBEAT_PERIOD) {\r\n\t\t\t\t_lastHeartbeat = currentTime;\r\n\t\t\t\theartbeat();\r\n\t\t\t}\t\t\t\t\r\n\r\n\t\t\t//now factor in heartbeat time\r\n\t\t\tlong timeToHeartbeat = HEARTBEAT_PERIOD - (currentTime - _lastHeartbeat);\r\n\t\t\tif (useMe > timeToHeartbeat)\r\n\t\t\t\tuseMe = timeToHeartbeat;\r\n\r\n\t\t\tif (useMe < 1) {\r\n\t\t\t\tLog.warning(Log.FAC_NETMANAGER, \"PeriodicWriter delay too small {0} ms\", useMe);\r\n\t\t\t\tuseMe = 10;\r\n\t\t\t}\r\n\t\t\tif (_run)\r\n\t\t\t\t_periodicTimer.schedule(new PeriodicWriter(), useMe);\r\n\t\t}","commit_id":"e9ee85f567184ed483761d00e8cef11fcf344706","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\r\n\t * Reregister all current prefixes with ccnd after ccnd goes down and then comes back up\r\n\t */\r\n\tprivate void reregisterPrefixes() throws CCNDaemonException {\r\n\t\tif (_timersSetup)\r\n\t\t\theartbeat();\r\n\t\tTreeMap<ContentName, RegisteredPrefix> newPrefixes = new TreeMap<ContentName, RegisteredPrefix>();\r\n\t\tsynchronized (_registeredPrefixes) {\r\n\t\t\tfor (ContentName prefix : _registeredPrefixes.keySet()) {\r\n\t\t\t\tForwardingEntry entry = _prefixMgr.selfRegisterPrefix(prefix);\r\n\t\t\t\tRegisteredPrefix newPrefixEntry = new RegisteredPrefix(entry);\r\n\t\t\t\tnewPrefixEntry._refCount = _registeredPrefixes.get(prefix)._refCount;\r\n\t\t\t\tnewPrefixes.put(prefix, newPrefixEntry);\r\n\t\t\t}\r\n\t\t\t_registeredPrefixes.clear();\r\n\t\t\t_registeredPrefixes.putAll(newPrefixes);\r\n\t\t}\r\n\t}","id":99904,"modified_method":"/**\r\n\t * Reregister all current prefixes with ccnd after ccnd goes down and then comes back up\r\n\t */\r\n\tprivate void reregisterPrefixes() throws CCNDaemonException {\r\n\t\tif (_timersSetup)\r\n\t\t\ttransmitHeartbeat();\r\n\t\tTreeMap<ContentName, RegisteredPrefix> newPrefixes = new TreeMap<ContentName, RegisteredPrefix>();\r\n\t\tsynchronized (_registeredPrefixes) {\r\n\t\t\tfor (ContentName prefix : _registeredPrefixes.keySet()) {\r\n\t\t\t\tForwardingEntry entry = _prefixMgr.selfRegisterPrefix(prefix);\r\n\t\t\t\tRegisteredPrefix newPrefixEntry = new RegisteredPrefix(entry);\r\n\t\t\t\tnewPrefixEntry._refCount = _registeredPrefixes.get(prefix)._refCount;\r\n\t\t\t\tnewPrefixes.put(prefix, newPrefixEntry);\r\n\t\t\t}\r\n\t\t\t_registeredPrefixes.clear();\r\n\t\t\t_registeredPrefixes.putAll(newPrefixes);\r\n\t\t}\r\n\t}","commit_id":"e9ee85f567184ed483761d00e8cef11fcf344706","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\r\n\t * Open a channel to be used exclusively by the main run thread\r\n\t */\r\n\tprivate void openChannel() throws IOException {\r\n\t\t_channel = DatagramChannel.open();\r\n\t\t_channel.connect(new InetSocketAddress(_host, _port));\r\n\t\t_channel.configureBlocking(false);\r\n\t\ttry {\r\n\t\t\tByteBuffer test = ByteBuffer.allocate(1);\r\n\t\t\t_channel.write(test);\r\n\t\t} catch (IOException io) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t_channel.register(_selector, SelectionKey.OP_READ);\r\n\t\t_localPort = _channel.socket().getLocalPort();\r\n\t\t_connected = true;\r\n\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.INFO) )\r\n\t\t\tLog.info(Log.FAC_NETMANAGER, \"Connection to CCN agent using local port number: \" + _localPort);\r\n\t}","id":99905,"modified_method":"/**\r\n\t * Open a channel to be used exclusively by the main run thread\r\n\t */\r\n\tprivate void openChannel() throws IOException {\r\n\t\t_channel = DatagramChannel.open();\r\n\t\t_channel.connect(new InetSocketAddress(_host, _port));\r\n\t\t_channel.configureBlocking(false);\r\n\t\ttry {\r\n\t\t\tByteBuffer test = ByteBuffer.allocate(1);\r\n\t\t\t_channel.write(test);\r\n\t\t} catch (IOException io) {\r\n\t\t\tLog.finer(Log.FAC_NETMANAGER, \"test channel write to new connection failed...  returning and not connected\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t_selector.wakeup();\r\n\t\t_channel.register(_selector, SelectionKey.OP_READ);\r\n\t\t_localPort = _channel.socket().getLocalPort();\r\n\t\t_connected = true;\r\n\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.INFO) )\r\n\t\t\tLog.info(Log.FAC_NETMANAGER, \"Connection to CCN agent using local port number: \" + _localPort);\r\n\t}","commit_id":"e9ee85f567184ed483761d00e8cef11fcf344706","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\r\n\t * Thread method: this thread will handle reading datagrams and \r\n\t * the periodic re-expressing of standing interests\r\n\t */\r\n\tpublic void run() {\r\n\t\tif (! _run) {\r\n\t\t\tLog.warning(Log.FAC_NETMANAGER, \"CCNNetworkManager run() called after shutdown\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// Allocate datagram buffer: want to wrap array to ensure backed by\r\n\t\t// array to permit decoding\r\n\t\tbyte[] buffer = new byte[MAX_PAYLOAD];\r\n\t\tByteBuffer datagram = ByteBuffer.wrap(buffer);\r\n\t\tWirePacket packet = new WirePacket();\r\n\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.INFO) )\r\n\t\t\tLog.info(Log.FAC_NETMANAGER, \"CCNNetworkManager processing thread started for port: \" + _localPort);\r\n\t\twhile (_run) {\r\n\t\t\ttry {\r\n\t\t\t\t\r\n\t\t\t\t//--------------------------------- Read and decode\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (_selector.select(SOCKET_TIMEOUT) != 0) {\r\n\t\t\t\t\t\t// Note: we're selecting on only one channel to get\r\n\t\t\t\t\t\t// the ability to use wakeup, so there is no need to \r\n\t\t\t\t\t\t// inspect the selected-key set\r\n\t\t\t\t\t\tdatagram.clear(); // make ready for new read\r\n\t\t\t\t\t\tsynchronized (_channel) {\r\n\t\t\t\t\t\t\t_channel.read(datagram); // queue readers and writers\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINEST) )\r\n\t\t\t\t\t\t\tLog.finest(Log.FAC_NETMANAGER, \"Read datagram (\" + datagram.position() + \" bytes) for port: \" + _localPort);\r\n\t\t\t\t\t\t_selector.selectedKeys().clear();\r\n\t\t\t\t\t\tif (null != _error) {\r\n\t\t\t\t\t\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.INFO) )\r\n\t\t\t\t\t\t\t\tLog.info(Log.FAC_NETMANAGER, \"Receive error cleared for port: \" + _localPort);\r\n\t\t\t\t\t\t\t_error = null;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tdatagram.flip(); // make ready to decode\r\n\t\t\t\t\t\tif (null != _tapStreamIn) {\r\n\t\t\t\t\t\t\tbyte [] b = new byte[datagram.limit()];\r\n\t\t\t\t\t\t\tdatagram.get(b);\r\n\t\t\t\t\t\t\t_tapStreamIn.write(b);\r\n\t\t\t\t\t\t\tdatagram.rewind();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tpacket.clear();\r\n\t\t\t\t\t\tpacket.decode(datagram);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// This was a timeout or wakeup, no data\r\n\t\t\t\t\t\tpacket.clear();\r\n\t\t\t\t\t\tif (!_run) {\r\n\t\t\t\t\t\t\t// exit immediately if wakeup for shutdown\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tsynchronized (_connected) {\r\n\t\t\t\t\t\t\tif (! _connected) {\r\n\t\t\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t\t\t * This is the case where we noticed that the connect to ccnd went away.  We\r\n\t\t\t\t\t\t\t\t * try to reconnect, and if successful, we need to re-register our collection\r\n\t\t\t\t\t\t\t\t * of prefix registrations.\r\n\t\t\t\t\t\t\t\t */\r\n\t\t\t\t\t\t\t\topenChannel();\r\n\t\t\t\t\t\t\t\tif (_connected) {\r\n\t\t\t\t\t\t\t\t\t_faceID = null;\r\n\t\t\t\t\t\t\t\t\treregisterPrefixes();\r\n\t\t\t\t\t\t\t\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.INFO) )\r\n\t\t\t\t\t\t\t\t\t\tLog.info(Log.FAC_NETMANAGER, \"Reconnecting to CCN agent at \" + _host + \":\" + _port + \"on local port\" + _localPort);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (IOException io) {\r\n\t\t\t\t\t// We see IOException on receive every time if agent is gone\r\n\t\t\t\t\t// so track it to log only start and end of outages\r\n\t\t\t\t\tif (null == _error) {\r\n\t\t\t\t\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.INFO) )\r\n\t\t\t\t\t\t\tLog.info(Log.FAC_NETMANAGER, \"Unable to receive from agent: is it still running? Port: \" + _localPort);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t_error = io;\r\n\t\t\t\t\tpacket.clear();\r\n\t\t\t\t}\r\n                if (!_run) {\r\n                    // exit immediately if wakeup for shutdown\r\n                    break;\r\n                }\r\n                \r\n                // If we got a data packet, hand it back to all the interested\r\n\t\t\t\t// parties (registered interests and getters).\r\n\t\t\t\t//--------------------------------- Process data from net (if any) \r\n\t\t\t\tfor (ContentObject co : packet.data()) {\r\n\t\t\t\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINER) )\r\n\t\t\t\t\t\tLog.finer(Log.FAC_NETMANAGER, \"Data from net for port: \" + _localPort + \" {0}\", co.name());\r\n\t\t\t\t\t//\tSystemConfiguration.logObject(\"Data from net:\", co);\r\n\t\t\t\t\t\r\n\t\t\t\t\tdeliverData(co);\r\n\t\t\t\t\t// External data never goes back to network, never held onto here\r\n\t\t\t\t\t// External data never has a thread waiting, so no need to release sema\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//--------------------------------- Process interests from net (if any)\r\n\t\t\t\tfor (Interest interest : packet.interests()) {\r\n\t\t\t\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINEST) )\r\n\t\t\t\t\t\tLog.finest(Log.FAC_NETMANAGER, \"Interest from net for port: \" + _localPort + \" {0}\", interest);\r\n\t\t\t\t\tInterestRegistration oInterest = new InterestRegistration(this, interest, null, null);\r\n\t\t\t\t\tdeliverInterest(oInterest);\r\n\t\t\t\t\t// External interests never go back to network\r\n\t\t\t\t} // for interests\r\n\t\t\t\t\r\n\t\t\t} catch (Exception ex) {\r\n\t\t\t\tLog.severe(Log.FAC_NETMANAGER, \"Processing thread failure (UNKNOWN): \" + ex.getMessage() + \" for port: \" + _localPort);\r\n                Log.warningStackTrace(ex);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t_threadpool.shutdown();\r\n\t\tLog.info(Log.FAC_NETMANAGER, \"Shutdown complete for port: \" + _localPort);\r\n\t}","id":99906,"modified_method":"/**\r\n\t * Thread method: this thread will handle reading datagrams and \r\n\t * the periodic re-expressing of standing interests\r\n\t */\r\n\tpublic void run() {\r\n\t\tif (! _run) {\r\n\t\t\tLog.warning(Log.FAC_NETMANAGER, \"CCNNetworkManager run() called after shutdown\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// Allocate datagram buffer: want to wrap array to ensure backed by\r\n\t\t// array to permit decoding\r\n\t\tbyte[] buffer = new byte[MAX_PAYLOAD];\r\n\t\tByteBuffer datagram = ByteBuffer.wrap(buffer);\r\n\t\tWirePacket packet = new WirePacket();\r\n\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.INFO) )\r\n\t\t\tLog.info(Log.FAC_NETMANAGER, \"CCNNetworkManager processing thread started for port: \" + _localPort);\r\n\t\twhile (_run) {\r\n\t\t\ttry {\r\n\r\n\t\t\t\t//--------------------------------- Read and decode\r\n\t\t\t\ttry {\r\n\t\t\t\t\tint selectorResult = _selector.select(SOCKET_TIMEOUT);\r\n\t\t\t\t\tif ( selectorResult != 0) {\r\n\t\t\t\t\t\t// Note: we're selecting on only one channel to get\r\n\t\t\t\t\t\t// the ability to use wakeup, so there is no need to \r\n\t\t\t\t\t\t// inspect the selected-key set\r\n\t\t\t\t\t\tdatagram.clear(); // make ready for new read\r\n\t\t\t\t\t\tsynchronized (_channel) {\r\n\t\t\t\t\t\t\t_channel.read(datagram); // queue readers and writers\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINEST) )\r\n\t\t\t\t\t\t\tLog.finest(Log.FAC_NETMANAGER, \"Read datagram (\" + datagram.position() + \" bytes) for port: \" + _localPort);\r\n\t\t\t\t\t\t_selector.selectedKeys().clear();\r\n\t\t\t\t\t\tif (null != _error) {\r\n\t\t\t\t\t\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.INFO) )\r\n\t\t\t\t\t\t\t\tLog.info(Log.FAC_NETMANAGER, \"Receive error cleared for port: \" + _localPort);\r\n\t\t\t\t\t\t\t_error = null;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tdatagram.flip(); // make ready to decode\r\n\t\t\t\t\t\tif (null != _tapStreamIn) {\r\n\t\t\t\t\t\t\tbyte [] b = new byte[datagram.limit()];\r\n\t\t\t\t\t\t\tdatagram.get(b);\r\n\t\t\t\t\t\t\t_tapStreamIn.write(b);\r\n\t\t\t\t\t\t\tdatagram.rewind();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tpacket.clear();\r\n\t\t\t\t\t\tpacket.decode(datagram);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// This was a timeout or wakeup, no data\r\n\t\t\t\t\t\tpacket.clear();\r\n\t\t\t\t\t\tif (!_run) {\r\n\t\t\t\t\t\t\t// exit immediately if wakeup for shutdown\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// try not to consume all the CPU going around the select loop when we're not connected\r\n\t\t\t\t\t\tif (! _connected) Thread.sleep(100);\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (IOException io) {\r\n\t\t\t\t\t// We see IOException on receive every time if agent is gone\r\n\t\t\t\t\t// so track it to log only start and end of outages\r\n\t\t\t\t\tif (null == _error) {\r\n\t\t\t\t\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.INFO) )\r\n\t\t\t\t\t\t\tLog.info(Log.FAC_NETMANAGER, \"Unable to receive from agent: is it still running? Port: \" + _localPort);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t_error = io;\r\n\t\t\t\t\tpacket.clear();\r\n\t\t\t\t}\r\n\t\t\t\tif (!_run) {\r\n\t\t\t\t\t// exit immediately if wakeup for shutdown\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// If we got a data packet, hand it back to all the interested\r\n\t\t\t\t// parties (registered interests and getters).\r\n\t\t\t\t//--------------------------------- Process data from net (if any) \r\n\t\t\t\tfor (ContentObject co : packet.data()) {\r\n\t\t\t\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINER) )\r\n\t\t\t\t\t\tLog.finer(Log.FAC_NETMANAGER, \"Data from net for port: \" + _localPort + \" {0}\", co.name());\r\n\t\t\t\t\t//\tSystemConfiguration.logObject(\"Data from net:\", co);\r\n\r\n\t\t\t\t\tdeliverData(co);\r\n\t\t\t\t\t// External data never goes back to network, never held onto here\r\n\t\t\t\t\t// External data never has a thread waiting, so no need to release sema\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//--------------------------------- Process interests from net (if any)\r\n\t\t\t\tfor (Interest interest : packet.interests()) {\r\n\t\t\t\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.FINEST) )\r\n\t\t\t\t\t\tLog.finest(Log.FAC_NETMANAGER, \"Interest from net for port: \" + _localPort + \" {0}\", interest);\r\n\t\t\t\t\tInterestRegistration oInterest = new InterestRegistration(this, interest, null, null);\r\n\t\t\t\t\tdeliverInterest(oInterest);\r\n\t\t\t\t\t// External interests never go back to network\r\n\t\t\t\t} // for interests\r\n\r\n\t\t\t} catch (Exception ex) {\r\n\t\t\t\tLog.severe(Log.FAC_NETMANAGER, \"Processing thread failure (UNKNOWN): \" + ex.getMessage() + \" for port: \" + _localPort);\r\n\t\t\t\tLog.warningStackTrace(ex);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t_threadpool.shutdown();\r\n\t\tLog.info(Log.FAC_NETMANAGER, \"Shutdown complete for port: \" + _localPort);\r\n\t}","commit_id":"e9ee85f567184ed483761d00e8cef11fcf344706","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\r\n\t * Send the heartbeat. Also attempt to detect ccnd going down.\r\n\t */\r\n\tprivate void heartbeat() {\r\n\t\tsynchronized (_connected) {\r\n\t\t\tif (_connected) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tByteBuffer heartbeat = ByteBuffer.allocate(1);\r\n\t\t\t\t\t_channel.write(heartbeat);\r\n\t\t\t\t} catch (IOException io) {\r\n\t\t\t\t\t// We do not see errors on send typically even if \r\n\t\t\t\t\t// agent is gone, so log each but do not track\r\n\t\t\t\t\tLog.warning(Log.FAC_NETMANAGER, \"Error sending heartbeat packet: {0}\", io.getMessage());\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\t_channel.close();\r\n\t\t\t\t\t} catch (IOException e) {}\r\n\t\t\t\t\t_connected = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":99907,"modified_method":"/**\r\n\t * Send the heartbeat. Also attempt to detect ccnd going down.\r\n\t */\r\n\tprivate void heartbeat() {\r\n\t\tif (_connected) {\r\n\t\t\ttransmitHeartbeat();\r\n\t\t}\r\n\t\tif (! _connected) {\r\n\t\t\t/*\r\n\t\t\t * This is the case where we noticed that the connect to ccnd went away.  We\r\n\t\t\t * try to reconnect, and if successful, we need to re-register our collection\r\n\t\t\t * of prefix registrations.\r\n\t\t\t */\r\n\t\t\ttry {\r\n\t\t\t\topenChannel();  // may or may not set _connected\r\n\t\t\t\tif (_connected) {\r\n\t\t\t\t\t_faceID = null;\r\n\t\t\t\t\treregisterPrefixes();\r\n\t\t\t\t\tif( Log.isLoggable(Log.FAC_NETMANAGER, Level.INFO) )\r\n\t\t\t\t\t\tLog.info(Log.FAC_NETMANAGER, \"Reconnecting to CCN agent at {0}:{1} on local port {2}\", _host, _port, _localPort);\r\n\t\t\t\t}\r\n\t\t\t} catch (IOException ioe) {\r\n\t\t\t\t// if datagram open fails in openChannel we end up here\r\n\t\t\t\tLog.warning(Log.FAC_NETMANAGER, \"IOException when reconnecting to ccnd: {0}\", ioe.getMessage());\r\n\t\t\t}\r\n\t\t\tcatch (CCNDaemonException ccnde) {\r\n\t\t\t\t// if reregisterPrefixes fails we end up here\r\n\t\t\t\ttry {\r\n\t\t\t\t\t_channel.close();\r\n\t\t\t\t} catch (IOException ioe) {}\r\n\t\t\t\t_connected = false;\r\n\t\t\t\tLog.warning(Log.FAC_NETMANAGER, \"CCNDaemonException: {0}\", ccnde.getMessage());\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"e9ee85f567184ed483761d00e8cef11fcf344706","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"private void handleData(Object sender, int num_bytes) {\n        MemberInfo info=null;\n        boolean do_sleep=false;\n\n        synchronized(this) {\n            if(all_received)\n                return;\n            if(start == 0) {\n                start=System.currentTimeMillis();\n            }\n\n            num_msgs_received++;\n            num_bytes_received+=num_bytes;\n\n            if(num_msgs_received >= num_msgs_expected) {\n                if(stop == 0) {\n                    stop=System.currentTimeMillis();\n                }\n                all_received=true;\n            }\n\n            if(num_msgs_received % log_interval == 0) {\n                System.out.println(new StringBuilder(\"-- received \").append(num_msgs_received).append(\" messages\"));\n            }\n\n            if(counter % log_interval == 0) {\n                output(dumpStats(counter));\n            }\n            info=this.senders.get(sender);\n            if(info != null) {\n                if(info.start == 0)\n                    info.start=System.currentTimeMillis();\n                info.num_msgs_received++;\n                counter++;\n                info.total_bytes_received+=num_bytes;\n                if(info.num_msgs_received >= info.num_msgs_expected) {\n                    info.done=true;\n                    if(info.stop == 0)\n                        info.stop=System.currentTimeMillis();\n                }\n                else {\n                    if(processing_delay > 0)\n                        do_sleep=true;\n                }\n            }\n            else {\n                log.error(\"-- sender \" + sender + \" not found in senders hashmap\");\n            }\n        }\n\n        if(do_sleep && processing_delay > 0) {\n            Util.sleep(processing_delay);\n        }\n\n        synchronized(this) {\n            if(all_received) {\n                if(!this.sender)\n                    dumpSenders();\n                publisher.start();\n            }\n        }\n    }","id":99908,"modified_method":"private void handleData(Object sender, int num_bytes) {\n        MemberInfo info=null;\n        boolean do_sleep=false;\n\n        synchronized(this) {\n            if(all_received)\n                return;\n            if(start == 0) {\n                start=last_interval=System.currentTimeMillis();\n            }\n\n            num_msgs_received++;\n            num_bytes_received+=num_bytes;\n\n            if(num_msgs_received >= num_msgs_expected) {\n                if(stop == 0) {\n                    stop=System.currentTimeMillis();\n                }\n                all_received=true;\n            }\n\n            if(num_msgs_received % log_interval == 0) {\n                long curr=System.currentTimeMillis();\n                long diff=curr - last_interval;\n                last_interval=curr;\n                double msgs_sec=log_interval / (diff / 1000.0);\n                System.out.println(new StringBuilder(\"-- received \").append(num_msgs_received).append(\" messages\")\n                                   .append(\" (time=\" + diff + \" ms, \" + f.format(msgs_sec) + \" msgs/sec)\"));\n            }\n\n            if(counter % log_interval == 0) {\n                output(dumpStats(counter));\n            }\n            info=this.senders.get(sender);\n            if(info != null) {\n                if(info.start == 0)\n                    info.start=System.currentTimeMillis();\n                info.num_msgs_received++;\n                counter++;\n                info.total_bytes_received+=num_bytes;\n                if(info.num_msgs_received >= info.num_msgs_expected) {\n                    info.done=true;\n                    if(info.stop == 0)\n                        info.stop=System.currentTimeMillis();\n                }\n                else {\n                    if(processing_delay > 0)\n                        do_sleep=true;\n                }\n            }\n            else {\n                log.error(\"-- sender \" + sender + \" not found in senders hashmap\");\n            }\n        }\n\n        if(do_sleep && processing_delay > 0) {\n            Util.sleep(processing_delay);\n        }\n\n        synchronized(this) {\n            if(all_received) {\n                if(!this.sender)\n                    dumpSenders();\n                publisher.start();\n            }\n        }\n    }","commit_id":"dc52e318137e6e80391578206f8537b9839b499f","url":"https://github.com/belaban/JGroups"},{"original_method":"@Override\r\n  public void keyTyped(final KeyEvent e) {\r\n    if(editable) e.consume();\r\n  }","id":99909,"modified_method":"@Override\r\n  public void keyTyped(final KeyEvent e) {\r\n    final char ch = e.getKeyChar();\r\n    if(ch == KeyEvent.VK_BACK_SPACE || ch == KeyEvent.VK_DELETE) return;\r\n    \r\n    if(editable) {\r\n      if(!e.isControlDown() && !e.isActionKey()) {\r\n        if(text.start() != -1) text.delete();\r\n        text.add(new char[] { ch });\r\n      }\r\n      e.consume();\r\n      text.setCaret();\r\n      rend.calc();\r\n      showCursor(0);\r\n    }\r\n  }","commit_id":"39fd20814f5271cbfb1a0bfeab75f704285ef5d3","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public void keyPressed(final KeyEvent e) {\r\n    final int c = e.getKeyCode();\r\n    if(e.isAltDown() || e.isMetaDown() || c == KeyEvent.VK_SHIFT ||\r\n        c == KeyEvent.VK_CONTROL || c == KeyEvent.VK_ESCAPE) return;\r\n    \r\n    final byte[] txt = text.text;\r\n    text.pos(text.cursor());\r\n    cursor();\r\n\r\n    final int fh = rend.fontH();\r\n    final int h = getHeight();\r\n\r\n    final boolean ctrl = e.isControlDown();\r\n    final boolean shf = e.isShiftDown();\r\n    boolean down = true;\r\n    boolean key = !ctrl && !e.isActionKey();\r\n    if(c != KeyEvent.VK_DOWN && c != KeyEvent.VK_UP && !key) col = -1;\r\n\r\n    if(ctrl && c == 'A') {\r\n      selectAll();\r\n      e.consume();\r\n      return;\r\n    }\r\n    if(ctrl && c == 'C') {\r\n      copy();\r\n      return;\r\n    }\r\n    if(editable && c == KeyEvent.VK_BACK_SPACE) {\r\n      if(text.start() == -1) {\r\n        if(text.pos() == 0) return;\r\n        text.prev();\r\n      }\r\n      final boolean ch = Character.isLetterOrDigit(text.curr());\r\n      text.delete();\r\n      if(ctrl) {\r\n        while(text.pos() > 0 &&\r\n            ch == Character.isLetterOrDigit(text.prev())) text.delete();\r\n        if(text.pos() != 0) text.next();\r\n      }\r\n      down = false;\r\n    } else if(editable && c == KeyEvent.VK_DELETE) {\r\n      final boolean ch = Character.isLetterOrDigit(text.curr());\r\n      text.delete();\r\n      if(ctrl) {\r\n        while(text.pos() < text.size &&\r\n            ch == Character.isLetterOrDigit(text.curr())) text.delete();\r\n      }\r\n    } else if(editable && key) {\r\n      if(text.start() != -1) text.delete();\r\n      text.add(new char[] { e.getKeyChar() });\r\n    } else if(editable && ctrl && c == 'X') {\r\n      cut();\r\n    } else if(editable && ctrl && c == 'V') {\r\n      paste();\r\n    } else if(editable && ctrl && c == KeyEvent.VK_Z) {\r\n      undo();\r\n    } else if(editable && ctrl && c == KeyEvent.VK_Y) {\r\n      redo();\r\n    } else {\r\n      if(shf && text.start() == -1) text.startMark();\r\n  \r\n      if(c == KeyEvent.VK_RIGHT) {\r\n        if(ctrl) {\r\n          final boolean ch = Character.isLetterOrDigit(text.next(shf));\r\n          while(text.pos() < text.size && ch ==\r\n            Character.isLetterOrDigit(text.curr())) text.next(shf);\r\n        } else {\r\n          text.next(shf);\r\n        }\r\n      } else if(c == KeyEvent.VK_LEFT) {\r\n        if(ctrl) {\r\n          final boolean ch = Character.isLetterOrDigit(text.prev(shf));\r\n          while(text.pos() > 0 && ch ==\r\n            Character.isLetterOrDigit(text.prev(shf)));\r\n          if(text.pos() != 0) text.next(shf);\r\n        } else {\r\n          text.prev(shf);\r\n        }\r\n        down = false;\r\n      } else if(c == KeyEvent.VK_DOWN) {\r\n        if(ctrl) {\r\n          scroll.pos(scroll.pos() + fh);\r\n          return;\r\n        }\r\n        down(1, shf);\r\n      } else if(c == KeyEvent.VK_UP) {\r\n        if(ctrl) {\r\n          scroll.pos(scroll.pos() - fh);\r\n          return;\r\n        }\r\n        up(1, shf);\r\n        down = false;\r\n      } else {\r\n        if(!shf) text.noMark();\r\n  \r\n        if(c == KeyEvent.VK_HOME) {\r\n          if(ctrl) text.pos(0);\r\n          else text.home(shf);\r\n          down = false;\r\n        } else if(c == KeyEvent.VK_END) {\r\n          if(ctrl) text.pos(text.size);\r\n          else text.end(Integer.MAX_VALUE, shf);\r\n        } else if(c == KeyEvent.VK_PAGE_DOWN) {\r\n          down(h / fh, shf);\r\n        } else if(c == KeyEvent.VK_PAGE_UP) {\r\n          up(h / fh, shf);\r\n          down = false;\r\n        }\r\n      }\r\n\r\n      // refresh scroll position\r\n      if(shf) text.endMark();\r\n    }\r\n\r\n    text.setCaret();\r\n    if(txt != text.text) rend.calc();\r\n    showCursor(down ? 2 : 0);\r\n  }","id":99910,"modified_method":"@Override\r\n  public void keyPressed(final KeyEvent e) {\r\n    final int c = e.getKeyCode();\r\n    if(e.isAltDown() || e.isMetaDown() || c == KeyEvent.VK_SHIFT ||\r\n        c == KeyEvent.VK_CONTROL || c == KeyEvent.VK_ESCAPE) return;\r\n    \r\n    final byte[] txt = text.text;\r\n    text.pos(text.cursor());\r\n    cursor();\r\n\r\n    final int fh = rend.fontH();\r\n    final int h = getHeight();\r\n\r\n    final boolean ctrl = e.isControlDown();\r\n    final boolean shf = e.isShiftDown();\r\n    boolean down = true;\r\n    boolean key = !ctrl && !e.isActionKey();\r\n    if(c != KeyEvent.VK_DOWN && c != KeyEvent.VK_UP && !key) col = -1;\r\n\r\n    if(ctrl && c == 'A') {\r\n      selectAll();\r\n      e.consume();\r\n      return;\r\n    }\r\n    if(ctrl && c == 'C') {\r\n      copy();\r\n      return;\r\n    }\r\n    \r\n    if(editable && c == KeyEvent.VK_BACK_SPACE) {\r\n      if(text.start() == -1) {\r\n        if(text.pos() == 0) return;\r\n        text.prev();\r\n      }\r\n      final boolean ch = Character.isLetterOrDigit(text.curr());\r\n      text.delete();\r\n      if(ctrl) {\r\n        while(text.pos() > 0 &&\r\n            ch == Character.isLetterOrDigit(text.prev())) text.delete();\r\n        if(text.pos() != 0) text.next();\r\n      }\r\n      down = false;\r\n    } else if(editable && c == KeyEvent.VK_DELETE) {\r\n      final boolean ch = Character.isLetterOrDigit(text.curr());\r\n      text.delete();\r\n      if(ctrl) {\r\n        while(text.pos() < text.size &&\r\n            ch == Character.isLetterOrDigit(text.curr())) text.delete();\r\n      }\r\n    } else if(editable && ctrl && c == 'X') {\r\n      cut();\r\n    } else if(editable && ctrl && c == 'V') {\r\n      paste();\r\n    } else if(editable && ctrl && c == KeyEvent.VK_Z) {\r\n      undo();\r\n    } else if(editable && ctrl && c == KeyEvent.VK_Y) {\r\n      redo();\r\n    } else if(editable && key) {\r\n      return;\r\n    } else {\r\n      if(shf && text.start() == -1) text.startMark();\r\n  \r\n      if(c == KeyEvent.VK_RIGHT) {\r\n        if(ctrl) {\r\n          final boolean ch = Character.isLetterOrDigit(text.next(shf));\r\n          while(text.pos() < text.size && ch ==\r\n            Character.isLetterOrDigit(text.curr())) text.next(shf);\r\n        } else {\r\n          text.next(shf);\r\n        }\r\n      } else if(c == KeyEvent.VK_LEFT) {\r\n        if(ctrl) {\r\n          final boolean ch = Character.isLetterOrDigit(text.prev(shf));\r\n          while(text.pos() > 0 && ch ==\r\n            Character.isLetterOrDigit(text.prev(shf)));\r\n          if(text.pos() != 0) text.next(shf);\r\n        } else {\r\n          text.prev(shf);\r\n        }\r\n        down = false;\r\n      } else if(c == KeyEvent.VK_DOWN) {\r\n        if(ctrl) {\r\n          scroll.pos(scroll.pos() + fh);\r\n          return;\r\n        }\r\n        down(1, shf);\r\n      } else if(c == KeyEvent.VK_UP) {\r\n        if(ctrl) {\r\n          scroll.pos(scroll.pos() - fh);\r\n          return;\r\n        }\r\n        up(1, shf);\r\n        down = false;\r\n      } else {\r\n        if(!shf) text.noMark();\r\n  \r\n        if(c == KeyEvent.VK_HOME) {\r\n          if(ctrl) text.pos(0);\r\n          else text.home(shf);\r\n          down = false;\r\n        } else if(c == KeyEvent.VK_END) {\r\n          if(ctrl) text.pos(text.size);\r\n          else text.end(Integer.MAX_VALUE, shf);\r\n        } else if(c == KeyEvent.VK_PAGE_DOWN) {\r\n          down(h / fh, shf);\r\n        } else if(c == KeyEvent.VK_PAGE_UP) {\r\n          up(h / fh, shf);\r\n          down = false;\r\n        }\r\n      }\r\n\r\n      // refresh scroll position\r\n      if(shf) text.endMark();\r\n    }\r\n\r\n    text.setCaret();\r\n    if(txt != text.text) rend.calc();\r\n    showCursor(down ? 2 : 0);\r\n  }","commit_id":"39fd20814f5271cbfb1a0bfeab75f704285ef5d3","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Default constructor.\r\n   * @param view main panel\r\n   */\r\n  QueryArea(final QueryView view) {\r\n    main = view;\r\n    area = new BaseXText(HELPQUERYMODE);\r\n    area.setSyntax(new QuerySyntax());\r\n    area.addKeyListener(new KeyAdapter() {\r\n      @Override\r\n      public void keyPressed(final KeyEvent e) {\r\n        String xq = Token.string(area.getText());\r\n        if(!xq.equals(last)) {\r\n          last = xq;\r\n          if(xq.trim().length() == 0) xq = \".\";\r\n          if(GUIProp.execrt) {\r\n            GUI.get().execute(Commands.XQUERY, xq);\r\n          } else {\r\n            final XQueryProcessor proc = new XQueryProcessor(xq);\r\n            try {\r\n              proc.parse();\r\n              info(\"\", true);\r\n            } catch(QueryException ex) {\r\n              info(ex.getMessage(), false);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    });\r\n    south = new BaseXBack(GUIConstants.FILL.NONE);\r\n    south.setLayout(new BorderLayout(8, 8));\r\n    initPanel();\r\n  }","id":99911,"modified_method":"/**\r\n   * Default constructor.\r\n   * @param view main panel\r\n   */\r\n  QueryArea(final QueryView view) {\r\n    main = view;\r\n    area = new BaseXText(HELPQUERYMODE);\r\n    area.setSyntax(new QuerySyntax());\r\n    area.addKeyListener(new KeyAdapter() {\r\n      @Override\r\n      public void keyReleased(final KeyEvent e) {\r\n        String xq = Token.string(area.getText());\r\n        if(!xq.equals(last)) {\r\n          last = xq;\r\n          if(xq.trim().length() == 0) xq = \".\";\r\n          if(GUIProp.execrt) {\r\n            GUI.get().execute(Commands.XQUERY, xq);\r\n          } else {\r\n            final XQueryProcessor proc = new XQueryProcessor(xq);\r\n            try {\r\n              proc.parse();\r\n              info(\"\", true);\r\n            } catch(QueryException ex) {\r\n              info(ex.getMessage(), false);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    });\r\n    south = new BaseXBack(GUIConstants.FILL.NONE);\r\n    south.setLayout(new BorderLayout(8, 8));\r\n    initPanel();\r\n  }","commit_id":"39fd20814f5271cbfb1a0bfeab75f704285ef5d3","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n\tpublic FileEntry updateFileEntry(\n\t\t\tlong userId, long fileEntryId, String sourceFileName,\n\t\t\tString mimeType, String title, String description, String changeLog,\n\t\t\tboolean majorVersion, File file, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tDLFileVersion dlFileVersion = _getWorkflowDLFileVersion(\n\t\t\tfileEntryId, serviceContext);\n\n\t\tFileEntry fileEntry = super.updateFileEntry(\n\t\t\tuserId, fileEntryId, sourceFileName, mimeType, title, description,\n\t\t\tchangeLog, majorVersion, file, serviceContext);\n\n\t\t_startWorkflowInstance(userId, dlFileVersion, serviceContext);\n\n\t\treturn fileEntry;\n\t}","id":99912,"modified_method":"@Override\n\tpublic FileEntry updateFileEntry(\n\t\t\tlong userId, long fileEntryId, String sourceFileName,\n\t\t\tString mimeType, String title, String description, String changeLog,\n\t\t\tboolean majorVersion, File file, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tDLFileVersionReference dlFileVersionReference =\n\t\t\t_getWorkflowDLFileVersion(fileEntryId, serviceContext);\n\n\t\tsuper.updateFileEntry(\n\t\t\tuserId, fileEntryId, sourceFileName, mimeType, title, description,\n\t\t\tchangeLog, majorVersion, file, serviceContext);\n\n\t\t_startWorkflowInstance(\n\t\t\tuserId, dlFileVersionReference.fetchDLFileVersion(),\n\t\t\tserviceContext);\n\n\t\treturn super.getFileEntry(fileEntryId);\n\t}","commit_id":"315d50ab077ab2e8803d738f0705b19cbd291885","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic FileEntry updateFileEntry(\n\t\t\tlong userId, long fileEntryId, String sourceFileName,\n\t\t\tString mimeType, String title, String description, String changeLog,\n\t\t\tboolean majorVersion, InputStream is, long size,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tDLFileVersion dlFileVersion = _getWorkflowDLFileVersion(\n\t\t\tfileEntryId, serviceContext);\n\n\t\tFileEntry fileEntry = super.updateFileEntry(\n\t\t\tuserId, fileEntryId, sourceFileName, mimeType, title, description,\n\t\t\tchangeLog, majorVersion, is, size, serviceContext);\n\n\t\t_startWorkflowInstance(userId, dlFileVersion, serviceContext);\n\n\t\treturn fileEntry;\n\t}","id":99913,"modified_method":"@Override\n\tpublic FileEntry updateFileEntry(\n\t\t\tlong userId, long fileEntryId, String sourceFileName,\n\t\t\tString mimeType, String title, String description, String changeLog,\n\t\t\tboolean majorVersion, InputStream is, long size,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tDLFileVersionReference dlFileVersionReference =\n\t\t\t_getWorkflowDLFileVersion(fileEntryId, serviceContext);\n\n\t\tsuper.updateFileEntry(\n\t\t\tuserId, fileEntryId, sourceFileName, mimeType, title, description,\n\t\t\tchangeLog, majorVersion, is, size, serviceContext);\n\n\t\t_startWorkflowInstance(\n\t\t\tuserId, dlFileVersionReference.fetchDLFileVersion(),\n\t\t\tserviceContext);\n\n\t\treturn super.getFileEntry(fileEntryId);\n\t}","commit_id":"315d50ab077ab2e8803d738f0705b19cbd291885","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * See {@link\n\t * com.liferay.portlet.documentlibrary.service.impl.DLFileEntryLocalServiceImpl#updateFileEntry(\n\t * long, long, String, String, String, String, String, String, boolean,\n\t * String, long, java.util.Map, File, InputStream, long, ServiceContext)}\n\t */\n\tprivate DLFileVersion _getWorkflowDLFileVersion(\n\t\t\tlong fileEntryId, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tDLFileEntry dlFileEntry = DLFileEntryLocalServiceUtil.getDLFileEntry(\n\t\t\tfileEntryId);\n\n\t\tboolean checkedOut = dlFileEntry.isCheckedOut();\n\n\t\tDLFileVersion dlFileVersion =\n\t\t\tDLFileVersionLocalServiceUtil.getLatestFileVersion(\n\t\t\t\tfileEntryId, !checkedOut);\n\n\t\tboolean autoCheckIn = !checkedOut && dlFileVersion.isApproved();\n\n\t\tint workflowAction = serviceContext.getWorkflowAction();\n\n\t\tif (!autoCheckIn && !checkedOut &&\n\t\t\t(workflowAction == WorkflowConstants.ACTION_PUBLISH)) {\n\n\t\t\treturn dlFileVersion;\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}","id":99914,"modified_method":"/**\n\t * See {@link\n\t * com.liferay.portlet.documentlibrary.service.impl.DLFileEntryLocalServiceImpl#updateFileEntry(\n\t * long, long, String, String, String, String, String, String, boolean,\n\t * String, long, java.util.Map, File, InputStream, long, ServiceContext)}\n\t */\n\tprivate DLFileVersionReference _getWorkflowDLFileVersion(\n\t\t\tlong fileEntryId, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tDLFileEntry dlFileEntry = DLFileEntryLocalServiceUtil.getDLFileEntry(\n\t\t\tfileEntryId);\n\n\t\tboolean checkedOut = dlFileEntry.isCheckedOut();\n\n\t\tDLFileVersion dlFileVersion =\n\t\t\tDLFileVersionLocalServiceUtil.getLatestFileVersion(\n\t\t\t\tfileEntryId, !checkedOut);\n\n\t\tboolean autoCheckIn = !checkedOut && dlFileVersion.isApproved();\n\n\t\tif (autoCheckIn) {\n\t\t\treturn new DLFileVersionReference(autoCheckIn, fileEntryId, null);\n\t\t}\n\n\t\tint workflowAction = serviceContext.getWorkflowAction();\n\n\t\tif (!checkedOut &&\n\t\t\t(workflowAction == WorkflowConstants.ACTION_PUBLISH)) {\n\n\t\t\treturn new DLFileVersionReference(\n\t\t\t\tautoCheckIn, fileEntryId, dlFileVersion);\n\t\t}\n\n\t\treturn new DLFileVersionReference(autoCheckIn, fileEntryId, null);\n\t}","commit_id":"315d50ab077ab2e8803d738f0705b19cbd291885","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\t@SuppressWarnings(\"deprecation\")\n\tpublic void revertFileEntry(\n\t\t\tlong fileEntryId, String version, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tDLFileVersion dlFileVersion = _getWorkflowDLFileVersion(\n\t\t\tfileEntryId, serviceContext);\n\n\t\tsuper.revertFileEntry(fileEntryId, version, serviceContext);\n\n\t\t_startWorkflowInstance(\n\t\t\tcom.liferay.portal.kernel.repository.util.RepositoryUserUtil.\n\t\t\t\tgetUserId(),\n\t\t\tdlFileVersion, serviceContext);\n\t}","id":99915,"modified_method":"@Override\n\t@SuppressWarnings(\"deprecation\")\n\tpublic void revertFileEntry(\n\t\t\tlong fileEntryId, String version, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tDLFileVersionReference dlFileVersionReference =\n\t\t\t_getWorkflowDLFileVersion(fileEntryId, serviceContext);\n\n\t\tsuper.revertFileEntry(fileEntryId, version, serviceContext);\n\n\t\t_startWorkflowInstance(\n\t\t\tcom.liferay.portal.kernel.repository.util.RepositoryUserUtil.\n\t\t\t\tgetUserId(),\n\t\t\tdlFileVersionReference.fetchDLFileVersion(), serviceContext);\n\t}","commit_id":"315d50ab077ab2e8803d738f0705b19cbd291885","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic FileEntry updateFileEntry(\n\t\t\tlong userId, long fileEntryId, String sourceFileName,\n\t\t\tString mimeType, String title, String description, String changeLog,\n\t\t\tboolean majorVersion, InputStream is, long size,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tDLFileVersion dlFileVersion = _getWorkflowDLFileVersion(\n\t\t\tfileEntryId, serviceContext);\n\n\t\tFileEntry fileEntry = super.updateFileEntry(\n\t\t\tuserId, fileEntryId, sourceFileName, mimeType, title, description,\n\t\t\tchangeLog, majorVersion, is, size, serviceContext);\n\n\t\t_startWorkflowInstance(userId, dlFileVersion, serviceContext);\n\n\t\treturn fileEntry;\n\t}","id":99916,"modified_method":"@Override\n\tpublic FileEntry updateFileEntry(\n\t\t\tlong userId, long fileEntryId, String sourceFileName,\n\t\t\tString mimeType, String title, String description, String changeLog,\n\t\t\tboolean majorVersion, InputStream is, long size,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tDLFileVersionReference dlFileVersionReference =\n\t\t\t_getWorkflowDLFileVersion(fileEntryId, serviceContext);\n\n\t\tsuper.updateFileEntry(\n\t\t\tuserId, fileEntryId, sourceFileName, mimeType, title, description,\n\t\t\tchangeLog, majorVersion, is, size, serviceContext);\n\n\t\t_startWorkflowInstance(\n\t\t\tuserId, dlFileVersionReference.fetchDLFileVersion(),\n\t\t\tserviceContext);\n\n\t\treturn super.getFileEntry(fileEntryId);\n\t}","commit_id":"315d50ab077ab2e8803d738f0705b19cbd291885","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * See {@link\n\t * com.liferay.portlet.documentlibrary.service.impl.DLFileEntryLocalServiceImpl#updateFileEntry(\n\t * long, long, String, String, String, String, String, String, boolean,\n\t * String, long, java.util.Map, File, InputStream, long, ServiceContext)}\n\t */\n\tprivate DLFileVersion _getWorkflowDLFileVersion(\n\t\t\tlong fileEntryId, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tDLFileEntry dlFileEntry = DLFileEntryLocalServiceUtil.getDLFileEntry(\n\t\t\tfileEntryId);\n\n\t\tboolean checkedOut = dlFileEntry.isCheckedOut();\n\n\t\tDLFileVersion dlFileVersion =\n\t\t\tDLFileVersionLocalServiceUtil.getLatestFileVersion(\n\t\t\t\tfileEntryId, !checkedOut);\n\n\t\tboolean autoCheckIn = !checkedOut && dlFileVersion.isApproved();\n\n\t\tint workflowAction = serviceContext.getWorkflowAction();\n\n\t\tif (!autoCheckIn && !checkedOut &&\n\t\t\t(workflowAction == WorkflowConstants.ACTION_PUBLISH)) {\n\n\t\t\treturn dlFileVersion;\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}","id":99917,"modified_method":"/**\n\t * See {@link\n\t * com.liferay.portlet.documentlibrary.service.impl.DLFileEntryLocalServiceImpl#updateFileEntry(\n\t * long, long, String, String, String, String, String, String, boolean,\n\t * String, long, java.util.Map, File, InputStream, long, ServiceContext)}\n\t */\n\tprivate DLFileVersionReference _getWorkflowDLFileVersion(\n\t\t\tlong fileEntryId, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tDLFileEntry dlFileEntry = DLFileEntryLocalServiceUtil.getDLFileEntry(\n\t\t\tfileEntryId);\n\n\t\tboolean checkedOut = dlFileEntry.isCheckedOut();\n\n\t\tDLFileVersion dlFileVersion =\n\t\t\tDLFileVersionLocalServiceUtil.getLatestFileVersion(\n\t\t\t\tfileEntryId, !checkedOut);\n\n\t\tboolean autoCheckIn = !checkedOut && dlFileVersion.isApproved();\n\n\t\tif (autoCheckIn) {\n\t\t\treturn new DLFileVersionReference(autoCheckIn, fileEntryId, null);\n\t\t}\n\n\t\tint workflowAction = serviceContext.getWorkflowAction();\n\n\t\tif (!checkedOut &&\n\t\t\t(workflowAction == WorkflowConstants.ACTION_PUBLISH)) {\n\n\t\t\treturn new DLFileVersionReference(\n\t\t\t\tautoCheckIn, fileEntryId, dlFileVersion);\n\t\t}\n\n\t\treturn new DLFileVersionReference(autoCheckIn, fileEntryId, null);\n\t}","commit_id":"315d50ab077ab2e8803d738f0705b19cbd291885","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic FileEntry updateFileEntry(\n\t\t\tlong userId, long fileEntryId, String sourceFileName,\n\t\t\tString mimeType, String title, String description, String changeLog,\n\t\t\tboolean majorVersion, File file, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tDLFileVersion dlFileVersion = _getWorkflowDLFileVersion(\n\t\t\tfileEntryId, serviceContext);\n\n\t\tFileEntry fileEntry = super.updateFileEntry(\n\t\t\tuserId, fileEntryId, sourceFileName, mimeType, title, description,\n\t\t\tchangeLog, majorVersion, file, serviceContext);\n\n\t\t_startWorkflowInstance(userId, dlFileVersion, serviceContext);\n\n\t\treturn fileEntry;\n\t}","id":99918,"modified_method":"@Override\n\tpublic FileEntry updateFileEntry(\n\t\t\tlong userId, long fileEntryId, String sourceFileName,\n\t\t\tString mimeType, String title, String description, String changeLog,\n\t\t\tboolean majorVersion, File file, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tDLFileVersionReference dlFileVersionReference =\n\t\t\t_getWorkflowDLFileVersion(fileEntryId, serviceContext);\n\n\t\tsuper.updateFileEntry(\n\t\t\tuserId, fileEntryId, sourceFileName, mimeType, title, description,\n\t\t\tchangeLog, majorVersion, file, serviceContext);\n\n\t\t_startWorkflowInstance(\n\t\t\tuserId, dlFileVersionReference.fetchDLFileVersion(),\n\t\t\tserviceContext);\n\n\t\treturn super.getFileEntry(fileEntryId);\n\t}","commit_id":"315d50ab077ab2e8803d738f0705b19cbd291885","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\r\n   * Create subfile entry for a query result. \r\n   * \r\n   * @param q query\r\n   * @param res result of the query\r\n   * @throws IOException IOException\r\n   */\r\n  private static void createQueryEntry(final int q, final SeqIter res) \r\n  throws IOException {\r\n    xml.openElement(token(\"topic\"),\r\n        token(\"topic-id\"), token(tid[q]),\r\n        token(\"total_time_ms\"), token(qtimes[q])\r\n    );\r\n    xml.openElement(token(\"result\"));\r\n    xml.openElement(token(\"file\"));\r\n    // [SG] which file???\r\n    xml.text(token(\"wikpedia\"));\r\n    xml.closeElement();\r\n\r\n    Item a;\r\n    int r = 1;\r\n    while(res != null && (a = res.next()) != null) {\r\n      if(a instanceof Str) {\r\n        xml.openElement(token(\"path\"));\r\n        xml.text(a.str());\r\n        xml.closeElement();\r\n        xml.openElement(token(\"rank\"));\r\n        xml.text(token(r++));\r\n        xml.closeElement();\r\n      } else if(a instanceof Dbl) {\r\n        xml.openElement(token(\"rsv\"));\r\n        xml.text(a.str());\r\n        xml.closeElement();\r\n      }\r\n    }\r\n    xml.closeElement();\r\n    xml.closeElement();    \r\n  }","id":99919,"modified_method":"/**\r\n   * Create subfile entry for a query result. \r\n   * \r\n   * @param q query\r\n   * @param res result of the query\r\n   * @param k max number of results \r\n   * @throws IOException IOException\r\n   */\r\n  private static void createQueryEntry(final int q, final SeqIter res, \r\n      final int k) \r\n  throws IOException {\r\n    xml.openElement(token(\"topic\"),\r\n        token(\"topic-id\"), token(tid[q]),\r\n        token(\"total_time_ms\"), token(qtimes[q])\r\n    );\r\n\r\n    Item a;\r\n    int r = 1;\r\n    while(res != null && (a = res.next()) != null) {\r\n      if (r == k) break;\r\n      if(a instanceof Str) {\r\n        xml.openElement(token(\"result\"));\r\n        xml.openElement(token(\"file\"));\r\n        xml.text(token(\"pages\"));\r\n        xml.closeElement();\r\n        xml.openElement(token(\"path\"));\r\n        xml.text(a.str());\r\n        xml.closeElement();\r\n        xml.openElement(token(\"rank\"));\r\n        xml.text(token(r++));\r\n        xml.closeElement();\r\n      } else if(a instanceof Dbl) {\r\n        xml.openElement(token(\"rsv\"));\r\n        xml.text(a.str());\r\n        xml.closeElement();\r\n        xml.closeElement();\r\n      }\r\n    }\r\n//    xml.closeElement();\r\n    xml.closeElement();    \r\n  }","commit_id":"243234dc33e7ad5ad3cdf136a9a29ce19e807cea","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Performs a single query.\r\n   * @param db database offset\r\n   * @param qu query offset\r\n   * @return iter for the results\r\n   * @throws Exception exception\r\n   */\r\n  private SeqIter queryNew(final int db, final int qu) throws Exception {\r\n    // query and cache result\r\n    final String que = subfile ? xqm + \"for $i score $s in \" \r\n        + queries.get(qu) \r\n        + \" order by $s descending return (basex:sum-path($i), $s)\"\r\n//        + \" return $i\"\r\n        : queries.get(qu);\r\n    final Process proc = new XQuery(que);\r\n    if(launcher.execute(proc)) {\r\n      launcher.output(new NullOutput());\r\n    }\r\n    final CachedOutput out = new CachedOutput();\r\n    launcher.info(out);\r\n    SeqIter itr = null;\r\n    \r\n    final String time = Pattern.compile(\".*\" +\r\n        (total ? \"Total Time\" : \"Evaluating\") + \": (.*?) ms.*\",\r\n        Pattern.DOTALL).matcher(out.toString()).replaceAll(\"$1\");\r\n    if (subfile) {\r\n      qtimes[qu] += Double.parseDouble(time);\r\n      final Result val = proc.result();\r\n      if(val instanceof SeqIter) {\r\n        itr = (SeqIter) val;\r\n        // update node path\r\n        for (int i = 0; i < itr.size(); i++) {\r\n           if(itr.item[i] instanceof Str) {\r\n             String str = new String(((Str) itr.item[i]).str());\r\n             if(str.startsWith(\"article\")) {\r\n               final int s0 = str.indexOf('[');\r\n               final int s1 = str.indexOf(']');\r\n               final int c = Integer.parseInt(str.substring(s0 + 1, s1)) +  \r\n                 numArt[db];\r\n               final Str tmp = new Str((\"article[\" + c + \r\n                   str.substring(s1)).getBytes(), false);\r\n               itr.item[i] = tmp;  \r\n             }\r\n           }\r\n        }\r\n      }\r\n    }     \r\n    \r\n    // output result\r\n    BaseX.outln(\"Query % on %: %\", qu + 1, databases.get(db), time);\r\n    if(info) {\r\n      BaseX.outln(\"- \" + Pattern.compile(\".*Result: (.*?)\\\\n.*\",\r\n          Pattern.DOTALL).matcher(out.toString()).replaceAll(\"$1\"));\r\n    }\r\n    return itr;\r\n  }","id":99920,"modified_method":"/**\r\n   * Performs a single query.\r\n   * @param db database offset\r\n   * @param qu query offset\r\n   * @return iter for the results\r\n   * @throws Exception exception\r\n   */\r\n  private SeqIter queryNew(final int db, final int qu) throws Exception {\r\n    // query and cache result\r\n    final String que = subfile ? xqm + \"for $i score $s in \" \r\n        + queries.get(qu) \r\n        + \" order by $s descending return (basex:sum-path($i), $s)\"\r\n//        + \" return $i\"\r\n        : queries.get(qu);\r\n    final Process proc = new XQuery(que);\r\n    if(launcher.execute(proc)) {\r\n      launcher.output(new NullOutput());\r\n    }\r\n    final CachedOutput out = new CachedOutput();\r\n    launcher.info(out);\r\n    SeqIter itr = null;\r\n    \r\n    final String time = Pattern.compile(\".*\" +\r\n        (total ? \"Total Time\" : \"Evaluating\") + \": (.*?) ms.*\",\r\n        Pattern.DOTALL).matcher(out.toString()).replaceAll(\"$1\");\r\n    if (subfile) {\r\n      qtimes[qu] += Double.parseDouble(time);\r\n      final Result val = proc.result();\r\n      if(val instanceof SeqIter) {\r\n        itr = (SeqIter) val;\r\n        // update node path\r\n        for (int i = 0; i < itr.size(); i++) {\r\n           if(itr.item[i] instanceof Str) {\r\n             String str = new String(((Str) itr.item[i]).str());\r\n             if(str.startsWith(\"article\")) {\r\n               final int s0 = str.indexOf('[');\r\n               final int s1 = str.indexOf(']');\r\n               final int c = Integer.parseInt(str.substring(s0 + 1, s1)) +  \r\n                 numArt[db];\r\n               final Str tmp = new Str((\"article[\" + c + \r\n                   str.substring(s1)).getBytes(), false);\r\n               itr.item[i] = tmp;  \r\n             }\r\n           }\r\n        }\r\n      }\r\n    }     \r\n    \r\n    // output result\r\n    log.add(\"Query \" + (qu + 1) +\" on \" + databases.get(db) + \":\" + time + NL);\r\n//    BaseX.outln(\"Query % on %: %\", qu + 1, databases.get(db), time);\r\n    if(info) {\r\n      log.add(\"- \" + Pattern.compile(\".*Result: (.*?)\\\\n.*\",\r\n          Pattern.DOTALL).matcher(out.toString()).replaceAll(\"$1\"));\r\n//      BaseX.outln(\"- \" + Pattern.compile(\".*Result: (.*?)\\\\n.*\",\r\n//          Pattern.DOTALL).matcher(out.toString()).replaceAll(\"$1\"));\r\n    }\r\n    return itr;\r\n  }","commit_id":"243234dc33e7ad5ad3cdf136a9a29ce19e807cea","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Default constructor.\r\n   * @param args command-line arguments\r\n   * @throws Exception exception\r\n   */\r\n  private InexDBTestNew(final String[] args) throws Exception { \r\n    if(!parseArguments(args)) return;\r\n    \r\n    // cache queries\r\n    final BufferedReader br = new BufferedReader(new FileReader(QUERIES));\r\n    queries = new StringList();\r\n    final IntList tidl = new IntList();\r\n//    final IntList cidl = new IntList();\r\n    String l;\r\n    while((l = br.readLine()) != null && queries.size() < maxqu) {\r\n      int i = l.indexOf(';');\r\n      tidl.add(Integer.parseInt(l.substring(0, i)));\r\n      int j = l.indexOf(';', i + 1);\r\n//      cidl.add(Integer.parseInt(l.substring(i + 1, j)));\r\n      queries.add(l.substring(j + 1));\r\n    }\r\n    br.close();\r\n\r\n    if (subfile) {\r\n      // alocate space for query times\r\n      qtimes = new double[queries.size()];\r\n      results = new SeqIter[queries.size()];\r\n      tid = tidl.finish();\r\n//      cid = cidl.finish();\r\n    }\r\n    \r\n    // cache database names\r\n    databases = new StringList();\r\n    for(final String s : List.list(ctx)) {\r\n      if(s.startsWith(DBPREFIX) && databases.size() < maxdb) databases.add(s);\r\n    }\r\n\r\n    BaseX.outln(BaseX.name(InexDBTest.class) + \" [\" +\r\n        (server ? CLIENTMODE : LOCALMODE) + \"]\");\r\n    BaseX.outln(\"=> % queries on % databases, % runs: % time in ms\\n\",\r\n        queries.size(), databases.size(), runs, total ? \"total\" : \"evaluation\");\r\n\r\n    // get number of articles for each db\r\n    /*numArt = new int[databases.size()];\r\n    int last = 0;\r\n    for(int d = 0; d < databases.size(); d++) {\r\n      // open database and loop through all queries\r\n      launcher.execute(new Open(databases.get(d)));\r\n      final Names names = ctx.data().tags;\r\n      numArt[d] = last;\r\n      System.out.println(last);\r\n      last += names.stat(names.id(\"article\".getBytes())).counter; \r\n      launcher.execute(new Close());\r\n    }\r\n    */\r\n    // run test\r\n    final Performance p = new Performance();\r\n    if(server) test();\r\n    else testLocalNew();\r\n    System.out.println(\"Total Time: \" + p.getTimer());\r\n    \r\n//    if(subfile) createSubFile();\r\n  }","id":99921,"modified_method":"/**\r\n   * Default constructor.\r\n   * @param args command-line arguments\r\n   * @throws Exception exception\r\n   */\r\n  private InexDBTestNew(final String[] args) throws Exception { \r\n    if(!parseArguments(args)) return;\r\n    \r\n    // cache queries\r\n    final BufferedReader br = new BufferedReader(new FileReader(QUERIES));\r\n    queries = new StringList();\r\n    final IntList tidl = new IntList();\r\n//    final IntList cidl = new IntList();\r\n    String l;\r\n    while((l = br.readLine()) != null && queries.size() < maxqu) {\r\n      int i = l.indexOf(';');\r\n      tidl.add(Integer.parseInt(l.substring(0, i)));\r\n      int j = l.indexOf(';', i + 1);\r\n//      cidl.add(Integer.parseInt(l.substring(i + 1, j)));\r\n      queries.add(l.substring(j + 1));\r\n    }\r\n    br.close();\r\n\r\n    if (subfile) {\r\n      // alocate space for query times\r\n      qtimes = new double[queries.size()];\r\n      results = new SeqIter[queries.size()];\r\n      tid = tidl.finish();\r\n//      cid = cidl.finish();\r\n    }\r\n    \r\n    // cache database names\r\n    databases = new StringList();\r\n    for(final String s : List.list(ctx)) {\r\n      if(s.startsWith(DBPREFIX) && databases.size() < maxdb) databases.add(s);\r\n    }\r\n\r\n//    log.add(BaseX.name(InexDBTest.class) + \" [\" +\r\n//        (server ? CLIENTMODE : LOCALMODE) + \"]\");\r\n    BaseX.outln(BaseX.name(InexDBTest.class) + \" [\" +\r\n        (server ? CLIENTMODE : LOCALMODE) + \"]\");\r\n//    log.add(\"=> \" + queries.size() + \" queries on \" + databases.size() + \r\n//        \" databases, \" + runs + \" runs: \" + (total ? \"total\" : \"evaluation\") + \" time in ms\\n\");\r\n    BaseX.outln(\"=> % queries on % databases, % runs: % time in ms\\n\",\r\n        queries.size(), databases.size(), runs, (total ? \"total\" : \"evaluation\"));\r\n\r\n    // get number of articles for each db\r\n    /*numArt = new int[databases.size()];\r\n    int last = 0;\r\n    for(int d = 0; d < databases.size(); d++) {\r\n      // open database and loop through all queries\r\n      launcher.execute(new Open(databases.get(d)));\r\n      final Names names = ctx.data().tags;\r\n      numArt[d] = last;\r\n      System.out.println(last);\r\n      last += names.stat(names.id(\"article\".getBytes())).counter; \r\n      launcher.execute(new Close());\r\n    }\r\n    */\r\n    // run test\r\n    final Performance p = new Performance();\r\n    if(server) test();\r\n    else testLocalNew();\r\n\r\n//    log.add(\"Total Time: \" + p.getTimer());\r\n//    final String[] s = log.finish();\r\n//    for (String si : s) System.out.println(si);\r\n    System.out.println(\"Total Time: \" + p.getTimer());\r\n    \r\n    if(subfile) {\r\n      openSubFile();\r\n      for (int i = 0; i < results.length; i++) \r\n        createQueryEntry(i, results[i], 1500);\r\n      closeSubFile();      \r\n    }\r\n  }","commit_id":"243234dc33e7ad5ad3cdf136a9a29ce19e807cea","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Performs a single query.\r\n   * @param db database offset\r\n   * @param qu query offset\r\n   * @throws Exception exception\r\n   */\r\n  private void query(final int db, final int qu) throws Exception {\r\n    // query and cache result\r\n    final String que = subfile ? xqm + \"for $i score $s in \" \r\n        + queries.get(qu) \r\n        + \" order by $s descending return (basex:sum-path($i), $s)\"\r\n//        + \" return $i\"\r\n        : queries.get(qu);\r\n    final Process proc = new XQuery(que);\r\n    if(launcher.execute(proc)) {\r\n      launcher.output(new NullOutput());\r\n    }\r\n    final CachedOutput out = new CachedOutput();\r\n    launcher.info(out);\r\n    \r\n    final String time = Pattern.compile(\".*\" +\r\n        (total ? \"Total Time\" : \"Evaluating\") + \": (.*?) ms.*\",\r\n        Pattern.DOTALL).matcher(out.toString()).replaceAll(\"$1\");\r\n    if (subfile) {\r\n      qtimes[qu] += Double.parseDouble(time);\r\n      final Result val = proc.result();\r\n      if(val instanceof SeqIter) {\r\n        final SeqIter itr = (SeqIter) val;\r\n        // update node path\r\n        for (int i = 0; i < itr.size(); i++) {\r\n           if(itr.item[i] instanceof Str) {\r\n             String str = new String(((Str) itr.item[i]).str());\r\n             if(str.startsWith(\"article\")) {\r\n               final int s0 = str.indexOf('[');\r\n               final int s1 = str.indexOf(']');\r\n               final int c = Integer.parseInt(str.substring(s0 + 1, s1)) +  \r\n                 numArt[db];\r\n               final Str tmp = new Str((\"article[\" + c + \r\n                   str.substring(s1)).getBytes(), false);\r\n               itr.item[i] = tmp;  \r\n             }\r\n           }\r\n        }\r\n        if (results[qu] == null) results[qu] = itr; \r\n        else results[qu].add(itr);\r\n//        else results[qu] = addSorted(results[qu], itr);        \r\n      }\r\n    }     \r\n    \r\n    // output result\r\n    BaseX.outln(\"Query % on %: %\", qu + 1, databases.get(db), time);\r\n    if(info) {\r\n      BaseX.outln(\"- \" + Pattern.compile(\".*Result: (.*?)\\\\n.*\",\r\n          Pattern.DOTALL).matcher(out.toString()).replaceAll(\"$1\"));\r\n    }\r\n  }","id":99922,"modified_method":"/**\r\n   * Performs a single query.\r\n   * @param db database offset\r\n   * @param qu query offset\r\n   * @throws Exception exception\r\n   */\r\n  private void query(final int db, final int qu) throws Exception {\r\n    // query and cache result\r\n    final String que = subfile ? xqm + \"for $i score $s in \" \r\n        + queries.get(qu) \r\n        + \" order by $s descending return (basex:sum-path($i), $s)\"\r\n//        + \" return $i\"\r\n        : queries.get(qu);\r\n    final Process proc = new XQuery(que);\r\n    if(launcher.execute(proc)) {\r\n      launcher.output(new NullOutput());\r\n    }\r\n    final CachedOutput out = new CachedOutput();\r\n    launcher.info(out);\r\n    \r\n    final String time = Pattern.compile(\".*\" +\r\n        (total ? \"Total Time\" : \"Evaluating\") + \": (.*?) ms.*\",\r\n        Pattern.DOTALL).matcher(out.toString()).replaceAll(\"$1\");\r\n    if (subfile) {\r\n      qtimes[qu] += Double.parseDouble(time);\r\n      final Result val = proc.result();\r\n      if(val instanceof SeqIter) {\r\n        final SeqIter itr = (SeqIter) val;\r\n        // update node path\r\n        for (int i = 0; i < itr.size(); i++) {\r\n           if(itr.item[i] instanceof Str) {\r\n             String str = new String(((Str) itr.item[i]).str());\r\n             if(str.startsWith(\"article\")) {\r\n               final int s0 = str.indexOf('[');\r\n               final int s1 = str.indexOf(']');\r\n               final int c = Integer.parseInt(str.substring(s0 + 1, s1)) +  \r\n                 numArt[db];\r\n               final Str tmp = new Str((\"article[\" + c + \r\n                   str.substring(s1)).getBytes(), false);\r\n               itr.item[i] = tmp;  \r\n             }\r\n           }\r\n        }\r\n        if (results[qu] == null) results[qu] = itr; \r\n//        else results[qu].add(itr);\r\n        else results[qu] = addSorted(results[qu], itr);        \r\n      }\r\n    }     \r\n    \r\n    // output result\r\n//    log.add(\"Query \" + (qu + 1) +\" on \" + databases.get(db) + \":\" + time);\r\n    BaseX.outln(\"Query % on %: %\", qu + 1, databases.get(db), time);\r\n    if(info) {\r\n//      log.add(\"- \" + Pattern.compile(\".*Result: (.*?)\\\\n.*\",\r\n//          Pattern.DOTALL).matcher(out.toString()).replaceAll(\"$1\"));\r\n      BaseX.outln(\"- \" + Pattern.compile(\".*Result: (.*?)\\\\n.*\",\r\n          Pattern.DOTALL).matcher(out.toString()).replaceAll(\"$1\"));\r\n    }\r\n  }","commit_id":"243234dc33e7ad5ad3cdf136a9a29ce19e807cea","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * First test, caching all databases before running the queries.\r\n   * This version runs only locally.\r\n   * @throws Exception exception\r\n   */\r\n  private void testLocalNew() throws Exception {\r\n    // cache all context nodes\r\n    final Nodes[] roots = new Nodes[databases.size()];\r\n    for(int d = 0; d < databases.size(); d++) {\r\n      final Data data = Open.open(ctx, databases.get(d));\r\n      roots[d] = new Nodes(data.doc(), data);\r\n    }\r\n\r\n    if (subfile) openSubFile();\r\n    // loop through all databases\r\n    for(int q = 0; q < queries.size(); q++) {\r\n      SeqIter s = null;\r\n      // loop through all queries\r\n      for(int d = 0; d < databases.size(); d++) {\r\n        // set cached context nodes and run query\r\n        ctx.current(roots[d]);\r\n        s = s == null ? queryNew(d, q) : addSorted(s, queryNew(d, q));\r\n      }\r\n      if (subfile) createQueryEntry(q, s);\r\n    }\r\n    if (subfile) closeSubFile();\r\n  }","id":99923,"modified_method":"/**\r\n   * First test, caching all databases before running the queries.\r\n   * This version runs only locally.\r\n   * @throws Exception exception\r\n   */\r\n  private void testLocalNew() throws Exception {\r\n    // cache all context nodes\r\n    final Nodes[] roots = new Nodes[databases.size()];\r\n    for(int d = 0; d < databases.size(); d++) {\r\n      final Data data = Open.open(ctx, databases.get(d));\r\n      roots[d] = new Nodes(data.doc(), data);\r\n    }\r\n\r\n    if (subfile) openSubFile();\r\n    // loop through all databases\r\n    for(int q = 0; q < queries.size(); q++) {\r\n      SeqIter s = null;\r\n      // loop through all queries\r\n      for(int d = 0; d < databases.size(); d++) {\r\n        // set cached context nodes and run query\r\n        ctx.current(roots[d]);\r\n        queryNew(d, q);\r\n        s = s == null ? queryNew(d, q) : addSorted(s, queryNew(d, q));\r\n      }\r\n      if (subfile) createQueryEntry(q, s, 1500);\r\n    }\r\n    \r\n    if (subfile) closeSubFile();\r\n  }","commit_id":"243234dc33e7ad5ad3cdf136a9a29ce19e807cea","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Create subfile entry for a query result. \r\n   * \r\n   * @param q query\r\n   * @param res result of the query\r\n   * @param k max number of results \r\n   * @throws IOException IOException\r\n   */\r\n  private static void createQueryEntry(final int q, final SeqIter res, \r\n      final int k) \r\n  throws IOException {\r\n    xml.openElement(token(\"topic\"),\r\n        token(\"topic-id\"), token(tid[q]),\r\n        token(\"total_time_ms\"), token(qtimes[q])\r\n    );\r\n\r\n    Item a;\r\n    int r = 1;\r\n    while(res != null && (a = res.next()) != null) {\r\n      if (r == k) break;\r\n      if(a instanceof Str) {\r\n        xml.openElement(token(\"result\"));\r\n        xml.openElement(token(\"file\"));\r\n        xml.text(token(\"pages\"));\r\n        xml.closeElement();\r\n        xml.openElement(token(\"path\"));\r\n        xml.text(a.str());\r\n        xml.closeElement();\r\n        xml.openElement(token(\"rank\"));\r\n        xml.text(token(r++));\r\n        xml.closeElement();\r\n      } else if(a instanceof Dbl) {\r\n        xml.openElement(token(\"rsv\"));\r\n        xml.text(a.str());\r\n        xml.closeElement();\r\n        xml.closeElement();\r\n      }\r\n    }\r\n//    xml.closeElement();\r\n    xml.closeElement();    \r\n  }","id":99924,"modified_method":"/**\r\n   * Create query entry in the submission file.\r\n   * @param q pointer on the query\r\n   * @param res result set\r\n   * @param k maximum number of results\r\n   * @throws IOException Exception\r\n   */\r\n  private static void createQueryEntry(final int q, final SeqIter res, \r\n      final int k) throws IOException {\r\n    xml.openElement(token(\"topic\"),\r\n        token(\"topic-id\"), token(tid[q]),\r\n        token(\"total_time_ms\"), token(qtimes[q])\r\n    );\r\n\r\n    Item a;\r\n    int r = 1;\r\n    while(res != null && (a = res.next()) != null) {\r\n      if (r == k) break;\r\n      final Item b = res.next();\r\n      if(a instanceof Str && b != null && \r\n          b instanceof Dbl) {\r\n        xml.openElement(token(\"result\"));\r\n        xml.openElement(token(\"file\"));\r\n        xml.text(token(\"pages\"));\r\n        xml.closeElement();\r\n        xml.openElement(token(\"path\"));\r\n        xml.text(a.str());\r\n        xml.closeElement();\r\n        xml.openElement(token(\"rank\"));\r\n        xml.text(token(r++));\r\n        xml.closeElement();\r\n        xml.openElement(token(\"rsv\"));\r\n        xml.text(b.str());\r\n        xml.closeElement();\r\n        xml.closeElement();\r\n      }\r\n    }\r\n    xml.closeElement();    \r\n  }","commit_id":"c5674bc92a73373bdc5ab03308ed0b286549feb8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Performs a single query.\r\n   * @param db database offset\r\n   * @param qu query offset\r\n   * @return iter for the results\r\n   * @throws Exception exception\r\n   */\r\n  private SeqIter queryNew(final int db, final int qu) throws Exception {\r\n    // query and cache result\r\n    final String que = subfile ? xqm + \"for $i score $s in \" \r\n        + queries.get(qu) \r\n        + \" order by $s descending return (basex:sum-path($i), $s)\"\r\n//        + \" return $i\"\r\n        : queries.get(qu);\r\n    final Process proc = new XQuery(que);\r\n    if(launcher.execute(proc)) {\r\n      launcher.output(new NullOutput());\r\n    }\r\n    final CachedOutput out = new CachedOutput();\r\n    launcher.info(out);\r\n    SeqIter itr = null;\r\n    \r\n    final String time = Pattern.compile(\".*\" +\r\n        (total ? \"Total Time\" : \"Evaluating\") + \": (.*?) ms.*\",\r\n        Pattern.DOTALL).matcher(out.toString()).replaceAll(\"$1\");\r\n    if (subfile) {\r\n      qtimes[qu] += Double.parseDouble(time);\r\n      final Result val = proc.result();\r\n      if(val instanceof SeqIter) {\r\n        itr = (SeqIter) val;\r\n        // update node path\r\n        for (int i = 0; i < itr.size(); i++) {\r\n           if(itr.item[i] instanceof Str) {\r\n             String str = new String(((Str) itr.item[i]).str());\r\n             if(str.startsWith(\"article\")) {\r\n               final int s0 = str.indexOf('[');\r\n               final int s1 = str.indexOf(']');\r\n               final int c = Integer.parseInt(str.substring(s0 + 1, s1)) +  \r\n                 numArt[db];\r\n               final Str tmp = new Str((\"article[\" + c + \r\n                   str.substring(s1)).getBytes(), false);\r\n               itr.item[i] = tmp;  \r\n             }\r\n           }\r\n        }\r\n      }\r\n    }     \r\n    \r\n    // output result\r\n    log.add(\"Query \" + (qu + 1) +\" on \" + databases.get(db) + \":\" + time + NL);\r\n//    BaseX.outln(\"Query % on %: %\", qu + 1, databases.get(db), time);\r\n    if(info) {\r\n      log.add(\"- \" + Pattern.compile(\".*Result: (.*?)\\\\n.*\",\r\n          Pattern.DOTALL).matcher(out.toString()).replaceAll(\"$1\"));\r\n//      BaseX.outln(\"- \" + Pattern.compile(\".*Result: (.*?)\\\\n.*\",\r\n//          Pattern.DOTALL).matcher(out.toString()).replaceAll(\"$1\"));\r\n    }\r\n    return itr;\r\n  }","id":99925,"modified_method":"/**\r\n   * Performs a single query.\r\n   * @param db database offset\r\n   * @param qu query offset\r\n   * @return iter for the results\r\n   * @throws Exception exception\r\n   */\r\n  private SeqIter queryNew(final int db, final int qu) throws Exception {\r\n    // query and cache result\r\n    final String que = subfile ? xqm + \"for $i score $s in \" \r\n        + queries.get(qu) \r\n        + \" order by $s descending return (basex:sum-path($i), $s)\"\r\n//        + \" return $i\"\r\n        : queries.get(qu);\r\n    final Process proc = new XQuery(que);\r\n    if(launcher.execute(proc)) {\r\n      launcher.output(new NullOutput());\r\n    }\r\n    final CachedOutput out = new CachedOutput();\r\n    launcher.info(out);\r\n    SeqIter itr = null;\r\n    \r\n    final String time = Pattern.compile(\".*\" +\r\n        (total ? \"Total Time\" : \"Evaluating\") + \": (.*?) ms.*\",\r\n        Pattern.DOTALL).matcher(out.toString()).replaceAll(\"$1\");\r\n    if (subfile) {\r\n      qtimes[qu] += Double.parseDouble(time);\r\n      if(server) {\r\n        \r\n      }\r\n      final Result val = proc.result();\r\n      if(val != null && val instanceof SeqIter) {\r\n        itr = (SeqIter) val;\r\n        // update node path\r\n        for (int i = 0; i < itr.size(); i++) {\r\n           if(itr.item[i] instanceof Str) {\r\n             String str = new String(((Str) itr.item[i]).str());\r\n             if(str.startsWith(\"article\")) {\r\n               final int s0 = str.indexOf('[');\r\n               final int s1 = str.indexOf(']');\r\n               final int c = Integer.parseInt(str.substring(s0 + 1, s1)) +  \r\n                 numArt[db];\r\n               Str tmp;\r\n               if (dbpath) {\r\n                 tmp = new Str((databases.get(db) + \":\" + \"article[\" + \r\n                     (c - numArt[db]) + str.substring(s1)).getBytes(), false);\r\n               } else \r\n                 tmp = new Str((\"article[\" + c + str.substring(s1)).getBytes(), \r\n                     false);  \r\n               itr.item[i] = tmp;  \r\n             }\r\n           }\r\n        }\r\n      }\r\n    }     \r\n    \r\n    // output result    \r\n    BaseX.outln(\"Query % on %: %\", qu + 1, databases.get(db), time);\r\n    if(info) {\r\n      BaseX.outln(\"- \" + Pattern.compile(\".*Result: (.*?)\\\\n.*\",\r\n          Pattern.DOTALL).matcher(out.toString()).replaceAll(\"$1\"));\r\n    }\r\n    return itr;\r\n  }","commit_id":"c5674bc92a73373bdc5ab03308ed0b286549feb8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Default constructor.\r\n   * @param args command-line arguments\r\n   * @throws Exception exception\r\n   */\r\n  private InexDBTestNew(final String[] args) throws Exception { \r\n    if(!parseArguments(args)) return;\r\n    \r\n    // cache queries\r\n    final BufferedReader br = new BufferedReader(new FileReader(QUERIES));\r\n    queries = new StringList();\r\n    final IntList tidl = new IntList();\r\n//    final IntList cidl = new IntList();\r\n    String l;\r\n    while((l = br.readLine()) != null && queries.size() < maxqu) {\r\n      int i = l.indexOf(';');\r\n      tidl.add(Integer.parseInt(l.substring(0, i)));\r\n      int j = l.indexOf(';', i + 1);\r\n//      cidl.add(Integer.parseInt(l.substring(i + 1, j)));\r\n      queries.add(l.substring(j + 1));\r\n    }\r\n    br.close();\r\n\r\n    if (subfile) {\r\n      // alocate space for query times\r\n      qtimes = new double[queries.size()];\r\n      results = new SeqIter[queries.size()];\r\n      tid = tidl.finish();\r\n//      cid = cidl.finish();\r\n    }\r\n    \r\n    // cache database names\r\n    databases = new StringList();\r\n    for(final String s : List.list(ctx)) {\r\n      if(s.startsWith(DBPREFIX) && databases.size() < maxdb) databases.add(s);\r\n    }\r\n\r\n//    log.add(BaseX.name(InexDBTest.class) + \" [\" +\r\n//        (server ? CLIENTMODE : LOCALMODE) + \"]\");\r\n    BaseX.outln(BaseX.name(InexDBTest.class) + \" [\" +\r\n        (server ? CLIENTMODE : LOCALMODE) + \"]\");\r\n//    log.add(\"=> \" + queries.size() + \" queries on \" + databases.size() + \r\n//        \" databases, \" + runs + \" runs: \" + (total ? \"total\" : \"evaluation\") + \" time in ms\\n\");\r\n    BaseX.outln(\"=> % queries on % databases, % runs: % time in ms\\n\",\r\n        queries.size(), databases.size(), runs, (total ? \"total\" : \"evaluation\"));\r\n\r\n    // get number of articles for each db\r\n    /*numArt = new int[databases.size()];\r\n    int last = 0;\r\n    for(int d = 0; d < databases.size(); d++) {\r\n      // open database and loop through all queries\r\n      launcher.execute(new Open(databases.get(d)));\r\n      final Names names = ctx.data().tags;\r\n      numArt[d] = last;\r\n      System.out.println(last);\r\n      last += names.stat(names.id(\"article\".getBytes())).counter; \r\n      launcher.execute(new Close());\r\n    }\r\n    */\r\n    // run test\r\n    final Performance p = new Performance();\r\n    if(server) test();\r\n    else testLocalNew();\r\n\r\n//    log.add(\"Total Time: \" + p.getTimer());\r\n//    final String[] s = log.finish();\r\n//    for (String si : s) System.out.println(si);\r\n    System.out.println(\"Total Time: \" + p.getTimer());\r\n    \r\n    if(subfile) {\r\n      openSubFile();\r\n      for (int i = 0; i < results.length; i++) \r\n        createQueryEntry(i, results[i], 1500);\r\n      closeSubFile();      \r\n    }\r\n  }","id":99926,"modified_method":"/**\r\n   * Default constructor.\r\n   * @param args command-line arguments\r\n   * @throws Exception exception\r\n   */\r\n  private InexDBTestNew(final String[] args) throws Exception { \r\n    if(!parseArguments(args)) return;\r\n    \r\n    // cache queries\r\n    final BufferedReader br = new BufferedReader(new FileReader(QUERIES));\r\n    queries = new StringList();\r\n    final IntList tidl = new IntList();\r\n//    final IntList cidl = new IntList();\r\n    String l;\r\n    while((l = br.readLine()) != null && queries.size() < maxqu) {\r\n      int i = l.indexOf(';');\r\n      tidl.add(Integer.parseInt(l.substring(0, i)));\r\n      int j = l.indexOf(';', i + 1);\r\n//      cidl.add(Integer.parseInt(l.substring(i + 1, j)));\r\n      queries.add(l.substring(j + 1));\r\n    }\r\n    br.close();\r\n\r\n    if (subfile) {\r\n      // alocate space for query times\r\n      qtimes = new double[queries.size()];\r\n      results = new SeqIter[queries.size()];\r\n      tid = tidl.finish();\r\n//      cid = cidl.finish();\r\n    }\r\n    \r\n    // cache database names\r\n    databases = new StringList();\r\n    for(final String s : List.list(ctx)) {\r\n      if(s.startsWith(DBPREFIX) && databases.size() < maxdb) databases.add(s);\r\n    }\r\n\r\n    BaseX.outln(BaseX.name(InexDBTest.class) + \" [\" +\r\n        (server ? CLIENTMODE : LOCALMODE) + \"]\");\r\n    BaseX.outln(\"=> % queries on % databases, % runs: % time in ms\\n\",\r\n        queries.size(), databases.size(), runs, (total ? \"total\" : \"evaluation\"));\r\n\r\n    // get number of articles for each db\r\n    /*numArt = new int[databases.size()];\r\n    int last = 0;\r\n    for(int d = 0; d < databases.size(); d++) {\r\n      // open database and loop through all queries\r\n      launcher.execute(new Open(databases.get(d)));\r\n      final Names names = ctx.data().tags;\r\n      numArt[d] = last;\r\n      System.out.println(last);\r\n      last += names.stat(names.id(\"article\".getBytes())).counter; \r\n      launcher.execute(new Close());\r\n    }\r\n    */\r\n    // run test\r\n    final Performance p = new Performance();\r\n    if(server) test();\r\n    else testLocalNew();\r\n\r\n    System.out.println(\"Total Time: \" + p.getTimer());\r\n    \r\n    if(subfile) {\r\n      openSubFile();\r\n      for (int i = 0; i < results.length; i++) { \r\n        if (server) createQueryEntryServer(i, results[i], 1500);\r\n        else createQueryEntry(i, results[i], 1500);\r\n        }\r\n      closeSubFile();      \r\n    }\r\n  }","commit_id":"c5674bc92a73373bdc5ab03308ed0b286549feb8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Second test, opening each databases before running the queries.\r\n   * @throws Exception exception\r\n   */\r\n  private void test() throws Exception {\r\n    // loop through all databases\r\n    for(int d = 0; d < databases.size(); d++) {\r\n      // open database and loop through all queries\r\n      launcher.execute(new Open(databases.get(d)));\r\n      for(int q = 0; q < queries.size(); q++) query(d, q);\r\n      launcher.execute(new Close());\r\n    }\r\n  }","id":99927,"modified_method":"/**\r\n   * Second test, opening each databases before running the queries.\r\n   * @throws Exception exception\r\n   */\r\n  private void test() throws Exception {\r\n    launcher.execute(new Set(Prop.SERIALIZE, true));\r\n    // loop through all databases\r\n    for(int d = 0; d < databases.size(); d++) {\r\n      // open database and loop through all queries\r\n      launcher.execute(new Open(databases.get(d)));\r\n      for(int q = 0; q < queries.size(); q++) {\r\n        final SeqIter s = queryServer(d, q);\r\n        if (results[q] != null) results[q] = addSortedServer(results[q], s);\r\n        else results[q] = s;\r\n      }\r\n      launcher.execute(new Close());\r\n    }\r\n  }","commit_id":"c5674bc92a73373bdc5ab03308ed0b286549feb8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Performs a single query.\r\n   * @param db database offset\r\n   * @param qu query offset\r\n   * @throws Exception exception\r\n   */\r\n  private void query(final int db, final int qu) throws Exception {\r\n    // query and cache result\r\n    final String que = subfile ? xqm + \"for $i score $s in \" \r\n        + queries.get(qu) \r\n        + \" order by $s descending return (basex:sum-path($i), $s)\"\r\n//        + \" return $i\"\r\n        : queries.get(qu);\r\n    final Process proc = new XQuery(que);\r\n    if(launcher.execute(proc)) {\r\n      launcher.output(new NullOutput());\r\n    }\r\n    final CachedOutput out = new CachedOutput();\r\n    launcher.info(out);\r\n\r\n    final String time = Pattern.compile(\".*\" +\r\n        (total ? \"Total Time\" : \"Evaluating\") + \": (.*?) ms.*\",\r\n        Pattern.DOTALL).matcher(out.toString()).replaceAll(\"$1\");\r\n    \r\n    if (subfile) {\r\n      qtimes[qu] += Double.parseDouble(time);\r\n      final Result val = proc.result();\r\n      if(val instanceof SeqIter) {\r\n        final SeqIter itr = (SeqIter) val;\r\n        // update node path\r\n        for (int i = 0; i < itr.size(); i++) {\r\n           if(itr.item[i] instanceof Str) {\r\n             String str = new String(((Str) itr.item[i]).str());\r\n             if(str.startsWith(\"article\")) {\r\n               final int s0 = str.indexOf('[');\r\n               final int s1 = str.indexOf(']');\r\n               final int c = Integer.parseInt(str.substring(s0 + 1, s1)) +  \r\n                 numArt[db];\r\n               final Str tmp = new Str((\"article[\" + c + \r\n                   str.substring(s1)).getBytes(), false);\r\n               itr.item[i] = tmp;  \r\n             }\r\n           }\r\n        }\r\n        if (results[qu] == null) results[qu] = itr; \r\n//        else results[qu].add(itr);\r\n        else results[qu] = addSorted(results[qu], itr);        \r\n      }\r\n    }     \r\n    \r\n    // output result\r\n//    log.add(\"Query \" + (qu + 1) +\" on \" + databases.get(db) + \":\" + time);\r\n    BaseX.outln(\"Query % on %: %\", qu + 1, databases.get(db), time);\r\n    if(info) {\r\n//      log.add(\"- \" + Pattern.compile(\".*Result: (.*?)\\\\n.*\",\r\n//          Pattern.DOTALL).matcher(out.toString()).replaceAll(\"$1\"));\r\n      BaseX.outln(\"- \" + Pattern.compile(\".*Result: (.*?)\\\\n.*\",\r\n          Pattern.DOTALL).matcher(out.toString()).replaceAll(\"$1\"));\r\n    }\r\n  }","id":99928,"modified_method":"/**\r\n   * Performs a single query within server mode.\r\n   * @param db database offset\r\n   * @param qu query offset\r\n   * @return iter for the results\r\n   * @throws Exception exception\r\n   */\r\n  private SeqIter queryServer(final int db, final int qu) throws Exception {\r\n    // query and cache result\r\n    final String que = subfile ? xqm + \"for $i score $s in \" \r\n        + queries.get(qu) \r\n        + \" order by $s descending return (basex:sum-path($i), $s)\"\r\n        : queries.get(qu);\r\n    final Process proc = new XQuery(que);\r\n    final CachedOutput res = new CachedOutput();\r\n    if(launcher.execute(proc)) {\r\n      launcher.output(res);\r\n    }\r\n    final CachedOutput out = new CachedOutput();\r\n    launcher.info(out);\r\n    SeqIter sq = new SeqIter();\r\n    \r\n    final String time = Pattern.compile(\".*\" +\r\n        (total ? \"Total Time\" : \"Evaluating\") + \": (.*?) ms.*\",\r\n        Pattern.DOTALL).matcher(out.toString()).replaceAll(\"$1\");\r\n    if (subfile) {\r\n      qtimes[qu] += Double.parseDouble(time);\r\n      StringTokenizer st = new StringTokenizer(res.toString(), \" \");\r\n      String lp = new String();\r\n      while (st.hasMoreTokens()) {\r\n        final String p = st.nextToken();\r\n        if (!st.hasMoreTokens()) break;\r\n        final String s = st.nextToken();\r\n        if (!lp.equals(p)) {\r\n          Str str;  \r\n          // update path\r\n            if (p.startsWith(\"article\")) {\r\n              final int s0 = p.indexOf('[');\r\n              final int s1 = p.indexOf(']');\r\n              final int n = Integer.parseInt(p.substring(s0 + 1, s1)) +  \r\n                numArt[db];\r\n              String a;\r\n              if (dbpath) \r\n                a = databases.get(db) + \":\" + \"article[\" + (n - numArt[db])  \r\n                  + p.substring(s1);\r\n              else a = \"article[\" + n + p.substring(s1);\r\n              str = new Str(a.getBytes(), false);\r\n            } else {\r\n              // [SG] wrong Path is set here\r\n              str = new Str(p.getBytes(), false);              \r\n            }\r\n            str.score(Double.parseDouble(s));\r\n            lp = p;\r\n            sq.add(str);\r\n        } \r\n      }\r\n    }     \r\n    \r\n    BaseX.outln(\"Query % on %: %\", qu + 1, databases.get(db), time);\r\n    if(info) {\r\n      BaseX.outln(\"- \" + Pattern.compile(\".*Result: (.*?)\\\\n.*\",\r\n          Pattern.DOTALL).matcher(out.toString()).replaceAll(\"$1\"));\r\n    }\r\n    return sq;\r\n  }","commit_id":"c5674bc92a73373bdc5ab03308ed0b286549feb8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Parses the command line arguments.\r\n   * @param args the command line arguments\r\n   * @return true if all arguments have been correctly parsed\r\n   */\r\n  private boolean parseArguments(final String[] args) {\r\n    final Args arg = new Args(args);\r\n    boolean ok = true;\r\n    try {\r\n      while(arg.more() && ok) {\r\n        if(arg.dash()) {\r\n          final char c = arg.next();\r\n          if(c == 'd') {\r\n            maxdb = Integer.parseInt(arg.string());\r\n          } else if(c == 'q') {\r\n            maxqu = Integer.parseInt(arg.string());\r\n          } else if(c == 'r') {\r\n            runs = Integer.parseInt(arg.string());\r\n          } else if(c == 's') {\r\n            server = true;\r\n          } else if(c == 't') {\r\n            total = true;\r\n          } else if(c == 'c') {\r\n            subfile = true;\r\n          } else if(c == 'v') {\r\n            info = true;          \r\n          } else {\r\n            ok = false;\r\n          }\r\n        } else {\r\n          ok = false;\r\n        }\r\n      }\r\n     \r\n      launcher = server ? new ClientLauncherNew(ctx) : new Launcher(ctx);\r\n      launcher.execute(new Set(Prop.SERIALIZE, total));\r\n      launcher.execute(new Set(Prop.RUNS, runs));\r\n      launcher.execute(new Set(Prop.INFO, true));\r\n      launcher.execute(new Set(Prop.ALLINFO, info));\r\n    } catch(final Exception ex) {\r\n      if(ex instanceof IOException) ex.printStackTrace();\r\n      ok = false;\r\n    }\r\n\r\n    if(!ok) {\r\n      BaseX.outln(\"Usage: InexDBTest [options]\" + NL +\r\n      \"  -c  create submissionfile\" + NL +\r\n      \"  -d<no>  maximum no/database\" + NL +\r\n      \"  -q<no>  maximum no/queries\" + NL +\r\n      \"  -r<no>  number of runs\" + NL +\r\n      \"  -s      use server architecture\" + NL +\r\n      \"  -t      measure total time\" + NL + \r\n      \"  -v      show process info\");\r\n    }\r\n    return ok;\r\n  }","id":99929,"modified_method":"/**\r\n   * Parses the command line arguments.\r\n   * @param args the command line arguments\r\n   * @return true if all arguments have been correctly parsed\r\n   */\r\n  private boolean parseArguments(final String[] args) {\r\n    final Args arg = new Args(args);\r\n    boolean ok = true;\r\n    try {\r\n      while(arg.more() && ok) {\r\n        if(arg.dash()) {\r\n          final char c = arg.next();\r\n          if(c == 'x') {\r\n            readQueries();\r\n            return false;\r\n          } else if(c == 'd') {\r\n            maxdb = Integer.parseInt(arg.string());\r\n          } else if(c == 'q') {\r\n            maxqu = Integer.parseInt(arg.string());\r\n          } else if(c == 'r') {\r\n            runs = Integer.parseInt(arg.string());\r\n          } else if(c == 's') {\r\n            server = true;\r\n          } else if(c == 't') {\r\n            total = true;\r\n          } else if(c == 'c') {\r\n            subfile = true;\r\n          } else if(c == 'v') {\r\n            info = true;          \r\n          } else if(c == 'p') {\r\n            dbpath = true;          \r\n          } else {\r\n            ok = false;\r\n          }\r\n        } else {\r\n          ok = false;\r\n        }\r\n      }\r\n     \r\n      launcher = server ? new ClientLauncherNew(ctx) : new Launcher(ctx);\r\n      launcher.execute(new Set(Prop.SERIALIZE, total));\r\n      launcher.execute(new Set(Prop.RUNS, runs));\r\n      launcher.execute(new Set(Prop.INFO, true));\r\n      launcher.execute(new Set(Prop.ALLINFO, info));\r\n    } catch(final Exception ex) {\r\n      if(ex instanceof IOException) ex.printStackTrace();\r\n      ok = false;\r\n    }\r\n\r\n    if(!ok) {\r\n      BaseX.outln(\"Usage: InexDBTest [options]\" + NL +\r\n      \"  -c  create submissionfile\" + NL +\r\n      \"  -d<no>  maximum no/database\" + NL +\r\n      \"  -q<no>  maximum no/queries\" + NL +\r\n      \"  -r<no>  number of runs\" + NL +\r\n      \"  -s      use server architecture\" + NL +\r\n      \"  -t      measure total time\" + NL + \r\n      \"  -v      show process info\");\r\n    }\r\n    return ok;\r\n  }","commit_id":"c5674bc92a73373bdc5ab03308ed0b286549feb8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * First test, caching all databases before running the queries.\r\n   * This version runs only locally.\r\n   * @throws Exception exception\r\n   */\r\n  private void testLocalNew() throws Exception {\r\n    // cache all context nodes\r\n    final Nodes[] roots = new Nodes[databases.size()];\r\n    for(int d = 0; d < databases.size(); d++) {\r\n      final Data data = Open.open(ctx, databases.get(d));\r\n      roots[d] = new Nodes(data.doc(), data);\r\n    }\r\n\r\n    if (subfile) openSubFile();\r\n    // loop through all databases\r\n    for(int q = 0; q < queries.size(); q++) {\r\n      SeqIter s = null;\r\n      // loop through all queries\r\n      for(int d = 0; d < databases.size(); d++) {\r\n        // set cached context nodes and run query\r\n        ctx.current(roots[d]);\r\n        queryNew(d, q);\r\n        s = s == null ? queryNew(d, q) : addSorted(s, queryNew(d, q));\r\n      }\r\n      if (subfile) createQueryEntry(q, s, 1500);\r\n    }\r\n    \r\n    if (subfile) closeSubFile();\r\n  }","id":99930,"modified_method":"/**\r\n   * First test, caching all databases before running the queries.\r\n   * This version runs only locally.\r\n   * @throws Exception exception\r\n   */\r\n   private void testLocalNew() throws Exception {\r\n    // cache all context nodes\r\n    final Nodes[] roots = new Nodes[databases.size()];\r\n    for(int d = 0; d < databases.size(); d++) {\r\n      final Data data = Open.open(ctx, databases.get(d));\r\n      roots[d] = new Nodes(data.doc(), data);\r\n    }\r\n\r\n    // loop through all databases\r\n    for(int q = 0; q < queries.size(); q++) {\r\n      SeqIter s = null;\r\n      // loop through all queries\r\n      for(int d = 0; d < databases.size(); d++) {\r\n        // set cached context nodes and run query\r\n        ctx.current(roots[d]);\r\n        int oldSize = 0;\r\n        if (s != null) {\r\n          BaseX.outln(\"old:\" + s.size());\r\n          oldSize = s.size();\r\n        } else BaseX.outln(\"old: 0\");\r\n        final SeqIter ni = queryNew(d, q);\r\n        BaseX.outln(\"add:\" + ni.size());\r\n        s = s == null ? ni : addSorted(s, ni);\r\n        if (s != null) \r\n          BaseX.outln(\"new:\" + s.size() + \" \" + \r\n              (s.size() == oldSize + ni.size()));\r\n      }\r\n      if (subfile) results[q] = s; \r\n    }\r\n  }","commit_id":"c5674bc92a73373bdc5ab03308ed0b286549feb8","url":"https://github.com/BaseXdb/basex"},{"original_method":"protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        // set options from component\n        getConfig().setConsumerKey(consumerKey);\n        getConfig().setConsumerSecret(consumerSecret);\n        getConfig().setAccessToken(accessToken);\n        getConfig().setFunction(remaining);\n        \n        // and then override from parameters\n        setProperties(getConfig(), parameters);\n        \n        Endpoint endpoint = new YammerEndpoint(uri, this, getConfig());\n        setProperties(endpoint, parameters);\n        return endpoint;\n    }","id":99931,"modified_method":"protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        // by default use config for each endpoint; use from component level if one has been explicitly set\n        YammerConfiguration endpointConfig = getConfig();\n        if (endpointConfig == null) {\n            endpointConfig = new YammerConfiguration();            \n        }\n        \n        // set options from component\n        endpointConfig.setConsumerKey(consumerKey);\n        endpointConfig.setConsumerSecret(consumerSecret);\n        endpointConfig.setAccessToken(accessToken);\n        endpointConfig.setFunction(remaining);\n        \n        // and then override from parameters\n        setProperties(endpointConfig, parameters);\n        \n        Endpoint endpoint = new YammerEndpoint(uri, this, endpointConfig);\n        setProperties(endpoint, parameters);\n        return endpoint;\n    }","commit_id":"bb4f2e5b5c268fff4bde72d2301c881fe155bae6","url":"https://github.com/apache/camel"},{"original_method":"public YammerConfiguration getConfig() {\n        if (config == null) {\n            config = new YammerConfiguration();\n        }\n        return config;\n    }","id":99932,"modified_method":"public YammerConfiguration getConfig() {\n        return config;\n    }","commit_id":"bb4f2e5b5c268fff4bde72d2301c881fe155bae6","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    @Before\n    public void setUp() throws Exception {\n        super.setUp();\n    \n        yammerComponent = context.getComponent(\"yammer\", YammerComponent.class);\n        YammerConfiguration config = yammerComponent.getConfig();\n        InputStream is = getClass().getResourceAsStream(jsonFile());\n        String messages = context.getTypeConverter().convertTo(String.class, is);\n        config.setRequestor(new TestApiRequestor(messages));\n    }","id":99933,"modified_method":"@Override\n    @Before\n    public void setUp() throws Exception {\n        super.setUp();\n        \n        InputStream is = getClass().getResourceAsStream(jsonFile());        \n        String messages = context.getTypeConverter().convertTo(String.class, is);    \n        \n        yammerComponent = context.getComponent(\"yammer\", YammerComponent.class);\n        \n        Collection<Endpoint> endpoints = context.getEndpoints();\n        for (Endpoint endpoint : endpoints) {\n            if (endpoint instanceof YammerEndpoint) {\n                ((YammerEndpoint)endpoint).getConfig().setRequestor(new TestApiRequestor(messages));\n            }\n        }\n    }","commit_id":"bb4f2e5b5c268fff4bde72d2301c881fe155bae6","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() {\n                from(\"yammer:messages?consumerKey=aConsumerKey&consumerSecret=aConsumerSecretKey&accessToken=aAccessToken&limit=1&threaded=true&olderThan=130&newerThan=127\").to(\"mock:result\");\n            }\n        };\n    }","id":99934,"modified_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() {\n                from(YAMMER_MESSAGES_CONSUMER).to(\"mock:result\");\n            }\n        };\n    }","commit_id":"bb4f2e5b5c268fff4bde72d2301c881fe155bae6","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testOptions() throws Exception {\n        // now check if options got applied\n        assertEquals(1, yammerComponent.getConfig().getLimit());\n        assertEquals(\"true\", yammerComponent.getConfig().getThreaded());\n        assertEquals(130, yammerComponent.getConfig().getOlderThan());\n        assertEquals(127, yammerComponent.getConfig().getNewerThan());\n        //assertEquals(YammerConstants.YAMMER_BASE_API_URL + \"messages.json?limit=1&older_than=130&newer_than=127&threaded=true\", yammerComponent.getConfig().getApiUrl());\n    }","id":99935,"modified_method":"@Test\n    public void testOptions() throws Exception {\n        YammerEndpoint endpoint = context.getEndpoint(YAMMER_MESSAGES_CONSUMER, YammerEndpoint.class);\n        \n        // now check if options got applied\n        assertEquals(1, endpoint.getConfig().getLimit());\n        assertEquals(\"true\", endpoint.getConfig().getThreaded());\n        assertEquals(130, endpoint.getConfig().getOlderThan());\n        assertEquals(127, endpoint.getConfig().getNewerThan());\n    }","commit_id":"bb4f2e5b5c268fff4bde72d2301c881fe155bae6","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() {\n                from(\"yammer:relationships?consumerKey=aConsumerKey&consumerSecret=aConsumerSecretKey&accessToken=aAccessToken&userId=jcamel\").to(\"mock:result\");\n            }\n        };\n    }","id":99936,"modified_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() {\n                from(YAMMER_RELATIONSHIPS_CONSUMER).to(\"mock:result\");\n            }\n        };\n    }","commit_id":"bb4f2e5b5c268fff4bde72d2301c881fe155bae6","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testOptions() throws Exception {\n        // now check if options got applied\n        assertEquals(\"jcamel\", yammerComponent.getConfig().getUserId());\n    }","id":99937,"modified_method":"@Test\n    public void testOptions() throws Exception {\n        YammerEndpoint endpoint = context.getEndpoint(YAMMER_RELATIONSHIPS_CONSUMER, YammerEndpoint.class);\n        \n        // now check if options got applied\n        assertEquals(\"jcamel\", endpoint.getConfig().getUserId());\n    }","commit_id":"bb4f2e5b5c268fff4bde72d2301c881fe155bae6","url":"https://github.com/apache/camel"},{"original_method":"public void afterPropertiesSet() throws MetaDataAccessException {\n        Assert.notNull(dataSource, \"Data source is not set!\");\n        Assert.notNull(vendorNameDialectMappings, \"Vendor name/dialect mappings are not set!\");\n\n        Connection connection = null;\n\n\n        String dbName = (String)JdbcUtils.extractDatabaseMetaData(dataSource, \"getDatabaseProductName\");\n\n        try {\n            connection = DataSourceUtils.getConnection(dataSource);\n\n            try {\n                hibernateDialect = DialectFactory.buildDialect(grailsApplication.getConfig().toProperties(), connection);\n                hibernateDialectClassName = hibernateDialect.getClass().getName();\n            } catch (HibernateException e) {\n                hibernateDialectClassName = vendorNameDialectMappings.getProperty(dbName);\n            }\n\n\n           if (!StringUtils.hasText(hibernateDialectClassName)) {\n                throw new CouldNotDetermineHibernateDialectException(\n                        \"Could not determine Hibernate dialect for database name [\" + dbName + \"]!\");\n           }\n        } finally {\n            DataSourceUtils.releaseConnection(connection,dataSource);\n        }\n\n    }","id":99938,"modified_method":"public void afterPropertiesSet() throws MetaDataAccessException {\n        Assert.notNull(dataSource, \"Data source is not set!\");\n        Assert.notNull(vendorNameDialectMappings, \"Vendor name/dialect mappings are not set!\");\n\n        Connection connection = null;\n\n\n        String dbName = (String)JdbcUtils.extractDatabaseMetaData(dataSource, \"getDatabaseProductName\");\n\n        try {\n            connection = DataSourceUtils.getConnection(dataSource);\n\n            try {\n                ConfigObject config = grailsApplication != null ? grailsApplication.getConfig() : null;\n                Properties properties = config != null ? config.toProperties() : new Properties();\n                hibernateDialect = DialectFactory.buildDialect(properties, connection);\n                hibernateDialectClassName = hibernateDialect.getClass().getName();\n            } catch (HibernateException e) {\n                hibernateDialectClassName = vendorNameDialectMappings.getProperty(dbName);\n            }\n\n\n           if (!StringUtils.hasText(hibernateDialectClassName)) {\n                throw new CouldNotDetermineHibernateDialectException(\n                        \"Could not determine Hibernate dialect for database name [\" + dbName + \"]!\");\n           }\n        } finally {\n            DataSourceUtils.releaseConnection(connection,dataSource);\n        }\n\n    }","commit_id":"a1dd9943a5edc0ae3c48ca01e5784945d27764cd","url":"https://github.com/grails/grails-core"},{"original_method":"@Override\n    public void launch() {\n        AbstractMongoDBServer server = getServer();\n        String host = server.getAttribute(AbstractMongoDBServer.HOSTNAME);\n        Integer port = server.getAttribute(AbstractMongoDBServer.PORT);\n        try {\n            for (String scriptName : entity.getConfig(MongoDBClient.STARTUP_JS_SCRIPTS)) {\n                runScript(\"\", scriptName, host, port);\n            }\n        } catch (NullPointerException e) {\n            // FIXME avoid the null ptr, and do something more intelligent\n            LOG.error(\"startupScripts not specified in MongoDBClientSshDriver launch method;\", e);\n            isRunning = false;\n            return;\n        }\n        isRunning = true;\n    }","id":99939,"modified_method":"@Override\n    public void launch() {\n        AbstractMongoDBServer server = getServer();\n        String host = server.getAttribute(AbstractMongoDBServer.HOSTNAME);\n        Integer port = server.getAttribute(AbstractMongoDBServer.PORT);\n        \n        List<String> scripts = entity.getConfig(MongoDBClient.STARTUP_JS_SCRIPTS);\n        if (scripts!=null) {\n            for (String scriptName : scripts) {\n                try {\n                    LOG.debug(\"Running MongoDB script \"+scriptName+\" at \"+getEntity());\n                    runScript(\"\", scriptName, host, port);\n                } catch (Exception e) {\n                    LOG.warn(\"Error running MongoDB script \"+scriptName+\" at \"+getEntity()+\", throwing: \"+e);\n                    isRunning = false;\n                    Exceptions.propagateIfFatal(e);\n                    throw new IllegalStateException(\"Error running MongoDB script \"+scriptName+\" at \"+entity+\": \"+e, e);\n                }\n            }\n        }\n        isRunning = true;\n    }","commit_id":"92a39ed2abc6624b606e1221636f572c07db26e8","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void start(Collection<? extends Location> locations) {\n        Machines.warnIfLocalhost(locations, \"CassandraCluster does not support multiple nodes on localhost, \" +\n        \t\t\"due to assumptions Cassandra makes about the use of the same port numbers used across the cluster.\");\n        \n        super.start(locations);\n\n        connectSensors();\n\n        // TODO wait until all nodes which we think are up are consistent \n        // i.e. all known nodes use the same schema, as reported by\n        // SshEffectorTasks.ssh(\"echo \\\"describe cluster;\\\" | /bin/cassandra-cli\");\n        // once we've done that we can revert to using 2 seed nodes.\n        // see CassandraCluster.DEFAULT_SEED_QUORUM\n\n        update();\n    }","id":99940,"modified_method":"@Override\n    public void start(Collection<? extends Location> locations) {\n        Machines.warnIfLocalhost(locations, \"CassandraCluster does not support multiple nodes on localhost, \" +\n        \t\t\"due to assumptions Cassandra makes about the use of the same port numbers used across the cluster.\");\n        \n        super.start(locations);\n\n        connectSensors();\n\n        // TODO wait until all nodes which we think are up are consistent \n        // i.e. all known nodes use the same schema, as reported by\n        // SshEffectorTasks.ssh(\"echo \\\"describe cluster;\\\" | /bin/cassandra-cli\");\n        // once we've done that we can revert to using 2 seed nodes.\n        // see CassandraCluster.DEFAULT_SEED_QUORUM\n        Time.sleep(DELAY_BEFORE_ADVERTISING_CLUSTER);\n\n        update();\n    }","commit_id":"40f25ae8b214e2638d3bccdfeaabd753d46c807e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected String gatherSeeds() {\n        Iterable<Entity> members = getMembers();\n        List<String> availableHostnames = Lists.newArrayList();\n        for (Entity node : members) {\n            Optional<String> hostname = Machines.findSubnetOrPublicHostname(node);\n            if (hostname.isPresent()) {\n                availableHostnames.add(hostname.get());\n            }\n        }\n        \n        if (!availableHostnames.isEmpty()) {\n            int quorumSize = getQuorumSize();\n            if (availableHostnames.size()>=quorumSize) {\n                return Joiner.on(\",\").join(Iterables.limit(availableHostnames, quorumSize));\n            }\n        }\n        \n        // not quorate\n        return null;\n    }","id":99941,"modified_method":"protected Set<Entity> gatherSeeds() {\n        Iterable<Entity> members = getMembers();\n        List<Entity> availableEntities = Lists.newArrayList();\n        for (Entity node : members) {\n            Optional<String> hostname = Machines.findSubnetOrPublicHostname(node);\n            if (hostname.isPresent()) {\n                availableEntities.add(node);\n            }\n        }\n        \n        if (!availableEntities.isEmpty()) {\n            int quorumSize = getQuorumSize();\n            if (availableEntities.size()>=quorumSize) {\n                return MutableSet.copyOf(Iterables.limit(availableEntities, quorumSize));\n            }\n        }\n        \n        // not quorate\n        return null;\n    }","commit_id":"40f25ae8b214e2638d3bccdfeaabd753d46c807e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected void checkConnectionRepeatedly(int totalAttemptsAllowed, CassandraNode first, CassandraNode second) throws Exception {\n        int attemptNum = 0;\n        while (true) {\n            try {\n                checkConnection(first, second);\n                return;\n            } catch (Exception e) {\n                attemptNum++;\n                if (attemptNum>=totalAttemptsAllowed) {\n                    log.warn(\"Cassandra not usable, \"+attemptNum+\" attempts; failing: \"+e, e);\n                    throw e;                \n                }\n                log.warn(\"Cassandra not usable (attempt \"+attemptNum+\"), trying again after delay: \"+e, e);\n                Time.sleep(Duration.TEN_SECONDS);\n            }\n        }\n    }","id":99942,"modified_method":"protected void checkConnectionRepeatedly(int totalAttemptsAllowed, int numRetriesPerAttempt, CassandraNode first, CassandraNode second) throws Exception {\n        int attemptNum = 0;\n        while (true) {\n            try {\n                checkConnection(numRetriesPerAttempt, first, second);\n                return;\n            } catch (Exception e) {\n                attemptNum++;\n                if (attemptNum>=totalAttemptsAllowed) {\n                    log.warn(\"Cassandra not usable, \"+attemptNum+\" attempts; failing: \"+e, e);\n                    throw e;                \n                }\n                log.warn(\"Cassandra not usable (attempt \"+attemptNum+\"), trying again after delay: \"+e, e);\n                Time.sleep(Duration.TEN_SECONDS);\n            }\n        }\n    }","commit_id":"40f25ae8b214e2638d3bccdfeaabd753d46c807e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected void checkConnection(CassandraNode first, CassandraNode second) throws ConnectionException {\n        // have been seeing intermittent SchemaDisagreementException errors on AWS, probably due to Astyanax / how we are using it\n        // (confirmed that clocks are in sync)\n        AstyanaxSample astyanaxFirst = new AstyanaxSample(first);\n        Map<String, List<String>> versions = astyanaxFirst.getAstyanaxContextForCluster().getEntity().describeSchemaVersions();\n        log.info(\"Cassandra schema versions are: \"+versions);\n        if (versions.size()>1) {\n            Assert.fail(\"Inconsistent versions on Cassandra start: \"+versions);\n        }\n\n        astyanaxFirst.writeData();\n\n        AstyanaxSample astyanaxSecond = new AstyanaxSample(second);\n        astyanaxSecond.readData();\n    }","id":99943,"modified_method":"protected void checkConnection(int numRetries, CassandraNode first, CassandraNode second) throws ConnectionException {\n        // have been seeing intermittent SchemaDisagreementException errors on AWS, probably due to Astyanax / how we are using it\n        // (confirmed that clocks are in sync)\n        AstyanaxSample astyanaxFirst = new AstyanaxSample(first);\n        Map<String, List<String>> versions = astyanaxFirst.getAstyanaxContextForCluster().getEntity().describeSchemaVersions();\n        log.info(\"Cassandra schema versions are: \"+versions);\n        if (versions.size()>1) {\n            Assert.fail(\"Inconsistent versions on Cassandra start: \"+versions);\n        }\n\n        astyanaxFirst.writeData(numRetries);\n\n        AstyanaxSample astyanaxSecond = new AstyanaxSample(second);\n        astyanaxSecond.readData(numRetries);\n    }","commit_id":"40f25ae8b214e2638d3bccdfeaabd753d46c807e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/**\n     * Test that a two node cluster starts up and allows access via the Astyanax API through both nodes.\n     */\n    @Test(groups = \"Live\")\n    public void canStartupAndShutdown() throws Exception {\n        try {\n            cluster = app.createAndManageChild(EntitySpec.create(CassandraCluster.class)\n                    .configure(\"initialSize\", 2)\n                    .configure(\"clusterName\", \"CassandraClusterLiveTest\"));\n            assertEquals(cluster.getCurrentSize().intValue(), 0);\n\n            app.start(ImmutableList.of(testLocation));\n\n            EntityTestUtils.assertAttributeEqualsEventually(cluster, CassandraCluster.GROUP_SIZE, 2);\n            Entities.dumpInfo(app);\n\n            CassandraNode first = (CassandraNode) Iterables.get(cluster.getMembers(), 0);\n            CassandraNode second = (CassandraNode) Iterables.get(cluster.getMembers(), 1);\n\n            EntityTestUtils.assertAttributeEqualsEventually(first, Startable.SERVICE_UP, true);\n            EntityTestUtils.assertAttributeEqualsEventually(second, Startable.SERVICE_UP, true);\n\n            // may take some time to be consistent (with new thrift_latency checks on the node,\n            // contactability should not be an issue, but consistency still might be) \n            for (int i=0; ; i++) {\n                boolean fo = isSocketOpen(first);\n                Boolean fc = fo ? areVersionsConsistent(first) : null;\n                boolean so = isSocketOpen(second);\n                Boolean sc = so ? areVersionsConsistent(second) : null;\n                Integer fp = first.getAttribute(CassandraNode.PEERS);\n                Integer sp = second.getAttribute(CassandraNode.PEERS);\n                String msg = \"consistency:  \"\n                        + \"1: \"+(!fo ? \"unreachable\" : fc==null ? \"error\" : fc)+\"  \"\n                        + \"2: \"+(!so ? \"unreachable\" : sc==null ? \"error\" : sc)+\";  \"\n                        + \"peer group sizes: \"+fp+\",\"+sp;\n                log.info(msg);\n                if (fo && so && fc==Boolean.TRUE && sc==Boolean.TRUE && fp==2 && sp==2)\n                    break;\n                if (i==0) log.warn(\"NOT yet consistent, waiting\");\n                if (i==120)\n                    Assert.fail(\"Did not become consistent in time: \"+msg);\n                Time.sleep(Duration.ONE_SECOND);\n            }\n\n            EntityTestUtils.assertAttributeEquals(first, CassandraNode.PEERS, 2);\n            EntityTestUtils.assertAttributeEquals(second, CassandraNode.PEERS, 2);\n\n            checkConnectionRepeatedly(1, first, second);\n        } catch (Throwable e) {\n            throw Throwables.propagate(e);\n        }\n    }","id":99944,"modified_method":"/**\n     * Test that a two node cluster starts up and allows access via the Astyanax API through both nodes.\n     */\n    @Test(groups = \"Live\")\n    public void canStartupAndShutdown() throws Exception {\n        try {\n            cluster = app.createAndManageChild(EntitySpec.create(CassandraCluster.class)\n                    .configure(\"initialSize\", 2)\n                    .configure(\"clusterName\", \"CassandraClusterLiveTest\"));\n            assertEquals(cluster.getCurrentSize().intValue(), 0);\n\n            app.start(ImmutableList.of(testLocation));\n\n            EntityTestUtils.assertAttributeEqualsEventually(cluster, CassandraCluster.GROUP_SIZE, 2);\n            Entities.dumpInfo(app);\n\n            CassandraNode first = (CassandraNode) Iterables.get(cluster.getMembers(), 0);\n            CassandraNode second = (CassandraNode) Iterables.get(cluster.getMembers(), 1);\n\n            EntityTestUtils.assertAttributeEqualsEventually(first, Startable.SERVICE_UP, true);\n            EntityTestUtils.assertAttributeEqualsEventually(second, Startable.SERVICE_UP, true);\n\n            // may take some time to be consistent (with new thrift_latency checks on the node,\n            // contactability should not be an issue, but consistency still might be) \n            for (int i=0; ; i++) {\n                boolean fo = isSocketOpen(first);\n                Boolean fc = fo ? areVersionsConsistent(first) : null;\n                boolean so = isSocketOpen(second);\n                Boolean sc = so ? areVersionsConsistent(second) : null;\n                Integer fp = first.getAttribute(CassandraNode.PEERS);\n                Integer sp = second.getAttribute(CassandraNode.PEERS);\n                String msg = \"consistency:  \"\n                        + \"1: \"+(!fo ? \"unreachable\" : fc==null ? \"error\" : fc)+\"  \"\n                        + \"2: \"+(!so ? \"unreachable\" : sc==null ? \"error\" : sc)+\";  \"\n                        + \"peer group sizes: \"+fp+\",\"+sp;\n                log.info(msg);\n                if (fo && so && fc==Boolean.TRUE && sc==Boolean.TRUE && fp==2 && sp==2)\n                    break;\n                if (i==0) log.warn(\"NOT yet consistent, waiting\");\n                if (i==120)\n                    Assert.fail(\"Did not become consistent in time: \"+msg);\n                Time.sleep(Duration.ONE_SECOND);\n            }\n\n            EntityTestUtils.assertAttributeEquals(first, CassandraNode.PEERS, 2);\n            EntityTestUtils.assertAttributeEquals(second, CassandraNode.PEERS, 2);\n\n            checkConnectionRepeatedly(2, 5, first, second);\n        } catch (Throwable e) {\n            throw Throwables.propagate(e);\n        }\n    }","commit_id":"40f25ae8b214e2638d3bccdfeaabd753d46c807e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override public String getSeeds() { return getConfig(CassandraNode.INITIAL_SEEDS); }","id":99945,"modified_method":"@Override public String getSeeds() { \n        Set<Entity> seeds = getConfig(CassandraNode.INITIAL_SEEDS);\n        if (seeds==null) {\n            log.warn(\"No seeds available when requested for \"+this, new Throwable(\"source of no Cassandra seeds when requested\"));\n            return null;\n        }\n        MutableSet<String> seedsHostnames = MutableSet.of();\n        for (Entity e: seeds) {\n            // tried removing ourselves if there are other nodes, but that is a BAD idea!\n            // blows up with a \"java.lang.RuntimeException: No other nodes seen!\"\n            seedsHostnames.add(Machines.findSubnetOrPublicHostname(e).get());\n        }\n        return Strings.join(seedsHostnames, \",\");\n    }","commit_id":"40f25ae8b214e2638d3bccdfeaabd753d46c807e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void customize() {\n        log.debug(\"Customizing {} (Cluster {})\", entity, getClusterName());\n        Networking.checkPortsValid(getPortMap());\n        \n        if (entity.getConfig(CassandraNode.INITIAL_SEEDS)==null) {\n            if (isClustered()) {\n                entity.setConfig(CassandraNode.INITIAL_SEEDS, \n                    DependentConfiguration.attributeWhenReady(entity.getParent(), CassandraCluster.CURRENT_SEEDS));\n            } else {\n                entity.setConfig(CassandraNode.INITIAL_SEEDS, Machines.findSubnetOrPublicHostname(entity).get());\n            }\n        }\n\n        String logFileEscaped = getLogFileLocation().replace(\"/\", \"\\\\/\"); // escape slashes\n\n        ImmutableList.Builder<String> commands = new ImmutableList.Builder<String>()\n                .add(String.format(\"cp -R %s/{bin,conf,lib,interface,pylib,tools} .\", getExpandedInstallDir()))\n                .add(\"mkdir data\")\n                .add(String.format(\"sed -i.bk 's/log4j.appender.R.File=.*/log4j.appender.R.File=%s/g' %s/conf/log4j-server.properties\", logFileEscaped, getRunDir()))\n                .add(String.format(\"sed -i.bk '/JMX_PORT/d' %s/conf/cassandra-env.sh\", getRunDir()))\n                .add(String.format(\"sed -i.bk 's/-Xss180k/-Xss280k/g' %s/conf/cassandra-env.sh\", getRunDir())); // Stack size\n\n        newScript(CUSTOMIZING)\n                .body.append(commands.build())\n                .execute();\n\n        // Copy the configuration file across\n        String configFileContents = processTemplate(getCassandraConfigTemplateUrl());\n        String destinationConfigFile = String.format(\"%s/conf/%s\", getRunDir(), getCassandraConfigFileName());\n        getMachine().copyTo(new ByteArrayInputStream(configFileContents.getBytes()), destinationConfigFile);\n    }","id":99946,"modified_method":"@Override\n    public void customize() {\n        log.debug(\"Customizing {} (Cluster {})\", entity, getClusterName());\n        Networking.checkPortsValid(getPortMap());\n        \n        if (entity.getConfig(CassandraNode.INITIAL_SEEDS)==null) {\n            if (isClustered()) {\n                entity.setConfig(CassandraNode.INITIAL_SEEDS, \n                    DependentConfiguration.attributeWhenReady(entity.getParent(), CassandraCluster.CURRENT_SEEDS));\n            } else {\n                entity.setConfig(CassandraNode.INITIAL_SEEDS, MutableSet.<Entity>of(entity));\n            }\n        }\n\n        String logFileEscaped = getLogFileLocation().replace(\"/\", \"\\\\/\"); // escape slashes\n\n        ImmutableList.Builder<String> commands = new ImmutableList.Builder<String>()\n                .add(String.format(\"cp -R %s/{bin,conf,lib,interface,pylib,tools} .\", getExpandedInstallDir()))\n                .add(\"mkdir data\")\n                .add(String.format(\"sed -i.bk 's/log4j.appender.R.File=.*/log4j.appender.R.File=%s/g' %s/conf/log4j-server.properties\", logFileEscaped, getRunDir()))\n                .add(String.format(\"sed -i.bk '/JMX_PORT/d' %s/conf/cassandra-env.sh\", getRunDir()))\n                .add(String.format(\"sed -i.bk 's/-Xss180k/-Xss280k/g' %s/conf/cassandra-env.sh\", getRunDir())); // Stack size\n\n        newScript(CUSTOMIZING)\n                .body.append(commands.build())\n                .execute();\n\n        // Copy the configuration file across\n        String configFileContents = processTemplate(getCassandraConfigTemplateUrl());\n        String destinationConfigFile = String.format(\"%s/conf/%s\", getRunDir(), getCassandraConfigFileName());\n        getMachine().copyTo(new ByteArrayInputStream(configFileContents.getBytes()), destinationConfigFile);\n    }","commit_id":"40f25ae8b214e2638d3bccdfeaabd753d46c807e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void launch() {\n        String subnetHostname = Machines.findSubnetOrPublicHostname(entity).get();\n        String seeds = ((CassandraNode)getEntity()).getSeeds();\n        log.info(\"Launching \" + entity + \": \" +\n                \"cluster \"+getClusterName()+\", \" +\n        \t\t\"hostname (public) \" + getEntity().getAttribute(Attributes.HOSTNAME) + \", \" +\n        \t\t\"hostname (subnet) \" + subnetHostname + \", \" +\n        \t\t\"seeds \"+seeds);\n        boolean isFirst = seeds.startsWith(subnetHostname);\n        if (isClustered() && !isFirst) {\n            // optionally force a delay before starting subsequent nodes; see comment at CassandraCluster.DELAY_AFTER_FIRST\n            long firstStartTime = Entities.submit(entity, DependentConfiguration.attributeWhenReady(getEntity().getParent(), CassandraCluster.FIRST_NODE_STARTED_TIME_UTC)).getUnchecked();\n            Duration toWait = Duration.millis(firstStartTime + CassandraCluster.DELAY_AFTER_FIRST.toMilliseconds() -  System.currentTimeMillis());\n            if (toWait.toMilliseconds()>0) {\n                log.info(\"Launching \" + entity + \": delaying launch of non-first node by \"+toWait+\" to prevent schema disagreements\");\n                Tasks.setBlockingDetails(\"Pausing to ensure first node has time to start\");\n                Time.sleep(toWait);\n                Tasks.resetBlockingDetails();\n            }\n        }\n        newScript(MutableMap.of(\"usePidFile\", getPidFile()), LAUNCHING)\n                .body.append(\n                        // log the date to attempt to debug occasional http://wiki.apache.org/cassandra/FAQ#schema_disagreement\n                        // (can be caused by machines out of synch time-wise; but in our case it seems to be caused by other things!)\n                        \"echo date on cassandra server `hostname` when launching is `date`\",\n                        String.format(\"nohup ./bin/cassandra -p %s > ./cassandra-console.log 2>&1 &\", getPidFile()))\n                .execute();\n        if (isClustered() && isFirst) {\n            ((EntityLocal)getEntity().getParent()).setAttribute(CassandraCluster.FIRST_NODE_STARTED_TIME_UTC, System.currentTimeMillis());\n        }\n    }","id":99947,"modified_method":"@Override\n    public void launch() {\n        String subnetHostname = Machines.findSubnetOrPublicHostname(entity).get();\n        Set<Entity> seeds = getEntity().getConfig(CassandraNode.INITIAL_SEEDS);\n        log.info(\"Launching \" + entity + \": \" +\n                \"cluster \"+getClusterName()+\", \" +\n        \t\t\"hostname (public) \" + getEntity().getAttribute(Attributes.HOSTNAME) + \", \" +\n        \t\t\"hostname (subnet) \" + subnetHostname + \", \" +\n        \t\t\"seeds \"+((CassandraNode)entity).getSeeds()+\" (from \"+seeds+\")\");\n        boolean isFirst = seeds.iterator().next().equals(entity);\n        if (isClustered() && !isFirst && CassandraCluster.WAIT_FOR_FIRST) {\n            // wait for the first node\n            long firstStartTime = Entities.submit(entity, DependentConfiguration.attributeWhenReady(getEntity().getParent(), CassandraCluster.FIRST_NODE_STARTED_TIME_UTC)).getUnchecked();\n            // optionally force a delay before starting subsequent nodes; see comment at CassandraCluster.DELAY_AFTER_FIRST\n            Duration toWait = Duration.millis(firstStartTime + CassandraCluster.DELAY_AFTER_FIRST.toMilliseconds() -  System.currentTimeMillis());\n            if (toWait.toMilliseconds()>0) {\n                log.info(\"Launching \" + entity + \": delaying launch of non-first node by \"+toWait+\" to prevent schema disagreements\");\n                Tasks.setBlockingDetails(\"Pausing to ensure first node has time to start\");\n                Time.sleep(toWait);\n                Tasks.resetBlockingDetails();\n            }\n        }\n        newScript(MutableMap.of(\"usePidFile\", getPidFile()), LAUNCHING)\n                .body.append(\n                        // log the date to attempt to debug occasional http://wiki.apache.org/cassandra/FAQ#schema_disagreement\n                        // (can be caused by machines out of synch time-wise; but in our case it seems to be caused by other things!)\n                        \"echo date on cassandra server `hostname` when launching is `date`\",\n                        String.format(\"nohup ./bin/cassandra -p %s > ./cassandra-console.log 2>&1 &\", getPidFile()))\n                .execute();\n        if (isClustered() && isFirst) {\n            ((EntityLocal)getEntity().getParent()).setAttribute(CassandraCluster.FIRST_NODE_STARTED_TIME_UTC, System.currentTimeMillis());\n        }\n    }","commit_id":"40f25ae8b214e2638d3bccdfeaabd753d46c807e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static <V> MutableSet<V> of(V v1, V v2, V v3) {\n        MutableSet<V> result = new MutableSet<V>();\n        result.add(v1);\n        result.add(v2);\n        result.add(v3);\n        return result;\n    }","id":99948,"modified_method":"public static <V> MutableSet<V> of(V v1, V v2, V v3, V ...vMore) {\n        MutableSet<V> result = new MutableSet<V>();\n        result.add(v1);\n        result.add(v2);\n        result.add(v3);\n        for (V vi: vMore) result.add(vi);\n        return result;\n    }","commit_id":"40f25ae8b214e2638d3bccdfeaabd753d46c807e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    @Override\n    public Object applyValueToMap(Object value, Map target) {\n        if (value instanceof StructuredModification) {\n            return ((StructuredModification)value).applyToKeyInMap(this, target);\n        } else  if (value instanceof Collection) {\n            String warning = \"Discouraged undecorated setting of a collection to SetConfigKey \"+this+\": use SetModification.{set,add}. \" +\n            \t\t\"Defaulting to 'add'. Look at debug logging for call stack.\";\n            log.warn(warning);\n            if (log.isDebugEnabled())\n                log.debug(\"Trace for: \"+warning, new Throwable(\"Trace for: \"+warning));\n            for (Object v: (Collection)value) \n                applyValueToMap(v, target);\n            return null;\n        } else {\n            // just add to set, using anonymous key\n            target.put(subKey(), value);\n            return null;\n        }\n    }","id":99949,"modified_method":"@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    @Override\n    public Object applyValueToMap(Object value, Map target) {\n        if (value instanceof StructuredModification) {\n            return ((StructuredModification)value).applyToKeyInMap(this, target);\n        } else if (value instanceof Collection) {\n            String warning = \"Discouraged undecorated setting of a collection to SetConfigKey \"+this+\": use SetModification.{set,add}. \" +\n            \t\t\"Defaulting to 'add'. Look at debug logging for call stack.\";\n            log.warn(warning);\n            if (log.isDebugEnabled())\n                log.debug(\"Trace for: \"+warning, new Throwable(\"Trace for: \"+warning));\n            for (Object v: (Collection)value) \n                applyValueToMap(v, target);\n            return null;\n        } else if (value instanceof TaskAdaptable) {\n            String warning = \"Discouraged undecorated setting of a task to SetConfigKey \"+this+\": use SetModification.{set,add}. \" +\n                    \"Defaulting to 'add'. Look at debug logging for call stack.\";\n            log.warn(warning);\n            // just add to set, using anonymous key\n            target.put(subKey(), value);\n            return null;\n        } else {\n            // just add to set, using anonymous key\n            target.put(subKey(), value);\n            return null;\n        }\n    }","commit_id":"40f25ae8b214e2638d3bccdfeaabd753d46c807e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public WorkResult execute(StaticLibraryArchiverSpec spec) {\n        deletePreviousOutput(spec);\n\n        BuildOperationQueue<CommandLineToolInvocation> queue = buildOperationProcessor.newQueue(commandLineToolInvocationWorker, spec.getOperationLogger().getLogLocation());\n        List<String> args = argsTransformer.transform(spec);\n        invocationContext.getArgAction().execute(args);\n        CommandLineToolInvocation invocation = invocationContext.createInvocation(\n                String.format(\"archiving %s\", spec.getOutputFile().getName()), args, spec.getOperationLogger());\n        queue.add(invocation);\n        queue.waitForCompletion();\n        return new SimpleWorkResult(true);\n    }","id":99950,"modified_method":"@Override\n    public WorkResult execute(final StaticLibraryArchiverSpec spec) {\n        deletePreviousOutput(spec);\n\n        List<String> args = argsTransformer.transform(spec);\n        invocationContext.getArgAction().execute(args);\n        final CommandLineToolInvocation invocation = invocationContext.createInvocation(\n                String.format(\"archiving %s\", spec.getOutputFile().getName()), args, spec.getOperationLogger());\n\n        buildOperationProcessor.run(commandLineToolInvocationWorker, new Action<BuildOperationQueue<CommandLineToolInvocation>>() {\n            @Override\n            public void execute(BuildOperationQueue<CommandLineToolInvocation> buildQueue) {\n                buildQueue.setLogLocation(spec.getOperationLogger().getLogLocation());\n                buildQueue.add(invocation);\n            }\n        });\n        return new SimpleWorkResult(true);\n    }","commit_id":"5d3d0929fdef42c12c52b45688df753b0a3b0462","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultBuildOperationProcessor(ExecutorFactory executorFactory, int maxWorkerCount) {\n        this.fixedSizePool = executorFactory.create(\"build operations\", maxWorkerCount);\n    }","id":99951,"modified_method":"public DefaultBuildOperationProcessor(BuildOperationQueueFactory buildOperationQueueFactory, ExecutorFactory executorFactory, int maxWorkerCount) {\n        this.buildOperationQueueFactory = buildOperationQueueFactory;\n        this.fixedSizePool = executorFactory.create(\"build operations\", maxWorkerCount);\n    }","commit_id":"5d3d0929fdef42c12c52b45688df753b0a3b0462","url":"https://github.com/gradle/gradle"},{"original_method":"public <T extends BuildOperation> BuildOperationQueue<T> newQueue(BuildOperationWorker<T> worker, @Nullable String logLocation) {\n        return new DefaultBuildOperationQueue<T>(fixedSizePool, worker, logLocation);\n    }","id":99952,"modified_method":"@Override\n    public <T extends BuildOperation> void run(BuildOperationWorker<T> worker, Action<BuildOperationQueue<T>> generator) {\n        BuildOperationQueue<T> queue = buildOperationQueueFactory.create(fixedSizePool, worker);\n\n        List<GradleException> failures = Lists.newArrayList();\n        try {\n            generator.execute(queue);\n        } catch (Exception e) {\n            failures.add(new BuildOperationQueueFailure(\"There was a failure while populating the build operation queue.\", e));\n            queue.cancel();\n        }\n\n        try {\n            queue.waitForCompletion();\n        } catch (MultipleBuildOperationFailures e) {\n            failures.add(e);\n        }\n\n        if (failures.size() == 1) {\n            throw failures.get(0);\n        } else if (failures.size() > 1) {\n            throw new DefaultMultiCauseException(\"There were failures with both submitting and executing operations in the build operation queue.\", failures);\n        }\n\n    }","commit_id":"5d3d0929fdef42c12c52b45688df753b0a3b0462","url":"https://github.com/gradle/gradle"},{"original_method":"private String getFailureMessage(Collection<Throwable> failures) {\n        if (failures.size() == 1) {\n            return \"A build operation failed.\";\n        }\n        return \"Multiple build operations failed.\";\n    }","id":99953,"modified_method":"private static String getFailureMessage(Collection<? extends Throwable> failures) {\n        if (failures.size() == 1) {\n            return \"A build operation failed.\";\n        }\n        return \"Multiple build operations failed.\";\n    }","commit_id":"5d3d0929fdef42c12c52b45688df753b0a3b0462","url":"https://github.com/gradle/gradle"},{"original_method":"public void waitForCompletion() throws MultipleBuildOperationFailures {\n        waitingForCompletion = true;\n\n        CountDownLatch finished = new CountDownLatch(operations.size());\n        Queue<Throwable> failures = Queues.newConcurrentLinkedQueue();\n\n        for (ListenableFuture operation : operations) {\n            Futures.addCallback(operation, new CompletionCallback(finished, failures));\n        }\n\n        try {\n            finished.await();\n        } catch (InterruptedException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n\n        // all operations are complete, check for errors\n        if (!failures.isEmpty()) {\n            throw new MultipleBuildOperationFailures(getFailureMessage(failures), failures, logLocation);\n        }\n    }","id":99954,"modified_method":"public void waitForCompletion() throws MultipleBuildOperationFailures {\n        waitingForCompletion = true;\n\n        CountDownLatch finished = new CountDownLatch(operations.size());\n        Queue<Throwable> failures = Queues.newConcurrentLinkedQueue();\n\n        for (ListenableFuture operation : operations) {\n            if (operation.isCancelled()) {\n                finished.countDown();\n            } else {\n                Futures.addCallback(operation, new CompletionCallback(finished, failures));\n            }\n        }\n\n        try {\n            finished.await();\n        } catch (InterruptedException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n\n        // all operations are complete, check for errors\n        if (!failures.isEmpty()) {\n            throw new MultipleBuildOperationFailures(getFailureMessage(failures), failures, logLocation);\n        }\n    }","commit_id":"5d3d0929fdef42c12c52b45688df753b0a3b0462","url":"https://github.com/gradle/gradle"},{"original_method":"DefaultBuildOperationQueue(ExecutorService executor, BuildOperationWorker<T> worker, String logLocation) {\n        this.logLocation = logLocation;\n        this.executor = MoreExecutors.listeningDecorator(executor);\n        this.worker = worker;\n        this.operations = Lists.newLinkedList();\n    }","id":99955,"modified_method":"DefaultBuildOperationQueue(ExecutorService executor, BuildOperationWorker<T> worker) {\n        this.executor = MoreExecutors.listeningDecorator(executor);\n        this.worker = worker;\n        this.operations = Lists.newLinkedList();\n    }","commit_id":"5d3d0929fdef42c12c52b45688df753b0a3b0462","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public WorkResult execute(LinkerSpec spec) {\n        BuildOperationQueue<CommandLineToolInvocation> queue = buildOperationProcessor.newQueue(commandLineToolInvocationWorker, spec.getOperationLogger().getLogLocation());\n\n        List<String> args = argsTransformer.transform(spec);\n        invocationContext.getArgAction().execute(args);\n        if (useCommandFile) {\n            new GccOptionsFileArgsWriter(spec.getTempDir()).execute(args);\n        }\n        CommandLineToolInvocation invocation = invocationContext.createInvocation(\n                String.format(\"linking %s\", spec.getOutputFile().getName()), args, spec.getOperationLogger());\n        queue.add(invocation);\n        queue.waitForCompletion();\n        return new SimpleWorkResult(true);\n    }","id":99956,"modified_method":"@Override\n    public WorkResult execute(final LinkerSpec spec) {\n        List<String> args = argsTransformer.transform(spec);\n        invocationContext.getArgAction().execute(args);\n        if (useCommandFile) {\n            new GccOptionsFileArgsWriter(spec.getTempDir()).execute(args);\n        }\n        final CommandLineToolInvocation invocation = invocationContext.createInvocation(\n                String.format(\"linking %s\", spec.getOutputFile().getName()), args, spec.getOperationLogger());\n\n        buildOperationProcessor.run(commandLineToolInvocationWorker, new Action<BuildOperationQueue<CommandLineToolInvocation>>() {\n            @Override\n            public void execute(BuildOperationQueue<CommandLineToolInvocation> buildQueue) {\n                buildQueue.setLogLocation(spec.getOperationLogger().getLogLocation());\n                buildQueue.add(invocation);\n            }\n        });\n\n        return new SimpleWorkResult(true);\n    }","commit_id":"5d3d0929fdef42c12c52b45688df753b0a3b0462","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public WorkResult execute(StaticLibraryArchiverSpec spec) {\n        BuildOperationQueue<CommandLineToolInvocation> queue = buildOperationProcessor.newQueue(commandLineToolInvocationWorker, spec.getOperationLogger().getLogLocation());\n        StaticLibraryArchiverSpec transformedSpec = specTransformer.transform(spec);\n        List<String> args = argsTransformer.transform(transformedSpec);\n        invocationContext.getArgAction().execute(args);\n        new VisualCppOptionsFileArgsWriter(spec.getTempDir()).execute(args);\n        CommandLineToolInvocation invocation = invocationContext.createInvocation(\n                String.format(\"archiving %s\", spec.getOutputFile().getName()), args, spec.getOperationLogger());\n        queue.add(invocation);\n        queue.waitForCompletion();\n        return new SimpleWorkResult(true);\n    }","id":99957,"modified_method":"@Override\n    public WorkResult execute(final StaticLibraryArchiverSpec spec) {\n        final StaticLibraryArchiverSpec transformedSpec = specTransformer.transform(spec);\n        final List<String> args = argsTransformer.transform(transformedSpec);\n        invocationContext.getArgAction().execute(args);\n        new VisualCppOptionsFileArgsWriter(spec.getTempDir()).execute(args);\n        final CommandLineToolInvocation invocation = invocationContext.createInvocation(\n                String.format(\"archiving %s\", spec.getOutputFile().getName()), args, spec.getOperationLogger());\n\n        buildOperationProcessor.run(commandLineToolInvocationWorker, new Action<BuildOperationQueue<CommandLineToolInvocation>>() {\n            @Override\n            public void execute(BuildOperationQueue<CommandLineToolInvocation> buildQueue) {\n                buildQueue.setLogLocation(spec.getOperationLogger().getLogLocation());\n                buildQueue.add(invocation);\n            }\n        });\n\n        return new SimpleWorkResult(true);\n    }","commit_id":"5d3d0929fdef42c12c52b45688df753b0a3b0462","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public WorkResult execute(LinkerSpec spec) {\n        BuildOperationQueue<CommandLineToolInvocation> queue = buildOperationProcessor.newQueue(commandLineToolInvocationWorker, spec.getOperationLogger().getLogLocation());\n        LinkerSpec transformedSpec = specTransformer.transform(spec);\n        List<String> args = argsTransformer.transform(transformedSpec);\n        invocationContext.getArgAction().execute(args);\n        new VisualCppOptionsFileArgsWriter(spec.getTempDir()).execute(args);\n        CommandLineToolInvocation invocation = invocationContext.createInvocation(\n                String.format(\"linking %s\", spec.getOutputFile().getName()), args, spec.getOperationLogger());\n        queue.add(invocation);\n        queue.waitForCompletion();\n        return new SimpleWorkResult(true);\n    }","id":99958,"modified_method":"@Override\n    public WorkResult execute(final LinkerSpec spec) {\n        LinkerSpec transformedSpec = specTransformer.transform(spec);\n        List<String> args = argsTransformer.transform(transformedSpec);\n        invocationContext.getArgAction().execute(args);\n        new VisualCppOptionsFileArgsWriter(spec.getTempDir()).execute(args);\n        final CommandLineToolInvocation invocation = invocationContext.createInvocation(\n                String.format(\"linking %s\", spec.getOutputFile().getName()), args, spec.getOperationLogger());\n\n        buildOperationProcessor.run(commandLineToolInvocationWorker, new Action<BuildOperationQueue<CommandLineToolInvocation>>() {\n            @Override\n            public void execute(BuildOperationQueue<CommandLineToolInvocation> buildQueue) {\n                buildQueue.setLogLocation(spec.getOperationLogger().getLogLocation());\n                buildQueue.add(invocation);\n            }\n        });\n\n        return new SimpleWorkResult(true);\n    }","commit_id":"5d3d0929fdef42c12c52b45688df753b0a3b0462","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public WorkResult execute(T spec) {\n        final T transformedSpec = specTransformer.transform(spec);\n        final List<String> genericArgs = getArguments(transformedSpec);\n        final BuildOperationQueue<CommandLineToolInvocation> buildQueue = buildOperationProcessor.newQueue(commandLineToolInvocationWorker, spec.getOperationLogger().getLogLocation());\n\n        File objectDir = transformedSpec.getObjectFileDir();\n        for (File sourceFile : transformedSpec.getSourceFiles()) {\n            CommandLineToolInvocation perFileInvocation =\n                    createPerFileInvocation(genericArgs, sourceFile, objectDir, spec);\n            buildQueue.add(perFileInvocation);\n        }\n\n        // Wait on all executions to complete or fail\n        buildQueue.waitForCompletion();\n\n        return new SimpleWorkResult(!transformedSpec.getSourceFiles().isEmpty());\n    }","id":99959,"modified_method":"@Override\n    public WorkResult execute(final T spec) {\n        final T transformedSpec = specTransformer.transform(spec);\n        final List<String> genericArgs = getArguments(transformedSpec);\n\n        final File objectDir = transformedSpec.getObjectFileDir();\n        buildOperationProcessor.run(commandLineToolInvocationWorker, new Action<BuildOperationQueue<CommandLineToolInvocation>>() {\n            @Override\n            public void execute(BuildOperationQueue<CommandLineToolInvocation> buildQueue) {\n                buildQueue.setLogLocation(spec.getOperationLogger().getLogLocation());\n                for (File sourceFile : transformedSpec.getSourceFiles()) {\n                    CommandLineToolInvocation perFileInvocation =\n                        createPerFileInvocation(genericArgs, sourceFile, objectDir, spec);\n                    buildQueue.add(perFileInvocation);\n                }\n            }\n        });\n\n        return new SimpleWorkResult(!transformedSpec.getSourceFiles().isEmpty());\n    }","commit_id":"5d3d0929fdef42c12c52b45688df753b0a3b0462","url":"https://github.com/gradle/gradle"},{"original_method":"BuildOperationProcessor createBuildOperationProcessor(StartParameter startParameter, ExecutorFactory executorFactory) {\n        return new DefaultBuildOperationProcessor(executorFactory, startParameter.getMaxWorkerCount());\n    }","id":99960,"modified_method":"BuildOperationProcessor createBuildOperationProcessor(StartParameter startParameter, ExecutorFactory executorFactory) {\n        return new DefaultBuildOperationProcessor(new DefaultBuildOperationQueueFactory(), executorFactory, startParameter.getMaxWorkerCount());\n    }","commit_id":"5d3d0929fdef42c12c52b45688df753b0a3b0462","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n\t * Used for A* routing to predict h(x) : it should be great than (!) any g(x)\n\t * \n\t * @return maximum speed to calculate shortest distance\n\t */\n\tpublic double getMaxDefaultSpeed() {\n\t\treturn 9;\n\t}","id":99961,"modified_method":"/**\n\t * Used for A* routing to predict h(x) : it should be great than (!) any g(x)\n\t * \n\t * @return maximum speed to calculate shortest distance\n\t */\n\tpublic double getMaxDefaultSpeed() {\n\t\treturn 6;\n\t}","commit_id":"eab130e6c8219af5b11ff8c0621180e0132dda68","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/**\n\t * Used for A* routing to predict h(x) : it should be great than (!) any g(x)\n\t * \n\t * @return maximum speed to calculate shortest distance\n\t */\n\tpublic double getMaxDefaultSpeed() {\n\t\treturn 2;\n\t}","id":99962,"modified_method":"/**\n\t * Used for A* routing to predict h(x) : it should be great than (!) any g(x)\n\t * \n\t * @return maximum speed to calculate shortest distance\n\t */\n\tpublic double getMaxDefaultSpeed() {\n\t\treturn 1.8;\n\t}","commit_id":"eab130e6c8219af5b11ff8c0621180e0132dda68","url":"https://github.com/osmandapp/Osmand"},{"original_method":"protected RouteCalculationResult findVectorMapsRoute(Location start, LatLon end, ApplicationMode mode, boolean fast, OsmandApplication app) throws IOException {\n\t\tMapRenderRepositories repositories = app.getResourceManager().getRenderer();\n\t\tCollection<BinaryMapIndexReader> data = repositories.getVectorData();\n\t\tBinaryRoutePlanner router = new BinaryRoutePlanner(data.toArray(new BinaryMapIndexReader[data.size()]));\n\t\tRoutingContext ctx = new RoutingContext();\n\t\tctx.setUsingShortestWay(!fast);\n\t\tif(mode == ApplicationMode.BICYCLE){\n\t\t\tctx.setRouter(new BicycleRouter());\n\t\t} else if(mode == ApplicationMode.PEDESTRIAN){\n\t\t\tctx.setRouter(new PedestrianRouter());\n\t\t} else {\n\t\t\tctx.setRouter(new CarRouter());\n\t\t}\n\t\tRouteSegment st= router.findRouteSegment(start.getLatitude(), start.getLongitude(), ctx);\n\t\tif (st == null) {\n\t\t\treturn new RouteCalculationResult(\"Start point is far from allowed road.\");\n\t\t}\n\t\tRouteSegment en = router.findRouteSegment(end.getLatitude(), end.getLongitude(), ctx);\n\t\tif (en == null) {\n\t\t\treturn new RouteCalculationResult(\"End point is far from allowed road.\");\n\t\t}\n\t\tList<Location> res = new ArrayList<Location>();\n\t\ttry {\n\t\t\tList<RouteSegmentResult> result = router.searchRoute(ctx, st, en);\n\t\t\tfor (RouteSegmentResult s : result) {\n\t\t\t\tboolean plus = s.startPointIndex < s.endPointIndex;\n\t\t\t\tint i = s.startPointIndex;\n\t\t\t\twhile (true) {\n\t\t\t\t\tLocation n = new Location(\"\"); //$NON-NLS-1$\n\t\t\t\t\tn.setLatitude(MapUtils.get31LatitudeY(s.object.getPoint31YTile(i)));\n\t\t\t\t\tn.setLongitude(MapUtils.get31LongitudeX(s.object.getPoint31XTile(i)));\n\t\t\t\t\tres.add(n);\n\t\t\t\t\tif (i == s.endPointIndex) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (plus) {\n\t\t\t\t\t\ti++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new RouteCalculationResult(res, null, start, end, null);\n\t\t} catch (OutOfMemoryError e) {\n\t\t\treturn new RouteCalculationResult(\"No enough memory to calculate route.\");\n\t\t}\n\t}","id":99963,"modified_method":"protected RouteCalculationResult findVectorMapsRoute(Location start, LatLon end, ApplicationMode mode, boolean fast, OsmandApplication app) throws IOException {\n\t\tMapRenderRepositories repositories = app.getResourceManager().getRenderer();\n\t\tCollection<BinaryMapIndexReader> data = repositories.getVectorData();\n\t\tBinaryRoutePlanner router = new BinaryRoutePlanner(data.toArray(new BinaryMapIndexReader[data.size()]));\n\t\tRoutingContext ctx = new RoutingContext();\n\t\tctx.setUsingShortestWay(!fast);\n\t\tif(mode == ApplicationMode.BICYCLE){\n\t\t\tctx.setRouter(new BicycleRouter());\n\t\t\tctx.setUseStrategyOfIncreasingRoadPriorities(false);\n\t\t\tctx.setUseDynamicRoadPrioritising(true);\n\t\t} else if(mode == ApplicationMode.PEDESTRIAN){\n\t\t\tctx.setRouter(new PedestrianRouter());\n\t\t\tctx.setUseStrategyOfIncreasingRoadPriorities(false);\n\t\t\tctx.setUseDynamicRoadPrioritising(false);\n\t\t\tctx.setHeuristicCoefficient(2);\n\t\t} else {\n\t\t\tctx.setRouter(new CarRouter());\n\t\t\tctx.setUseStrategyOfIncreasingRoadPriorities(true);\n\t\t\tctx.setUseDynamicRoadPrioritising(true);\n\t\t}\n\t\tRouteSegment st= router.findRouteSegment(start.getLatitude(), start.getLongitude(), ctx);\n\t\tif (st == null) {\n\t\t\treturn new RouteCalculationResult(\"Start point is far from allowed road.\");\n\t\t}\n\t\tRouteSegment en = router.findRouteSegment(end.getLatitude(), end.getLongitude(), ctx);\n\t\tif (en == null) {\n\t\t\treturn new RouteCalculationResult(\"End point is far from allowed road.\");\n\t\t}\n\t\tList<Location> res = new ArrayList<Location>();\n\t\ttry {\n\t\t\tList<RouteSegmentResult> result = router.searchRoute(ctx, st, en);\n\t\t\tfor (RouteSegmentResult s : result) {\n\t\t\t\tboolean plus = s.startPointIndex < s.endPointIndex;\n\t\t\t\tint i = s.startPointIndex;\n\t\t\t\twhile (true) {\n\t\t\t\t\tLocation n = new Location(\"\"); //$NON-NLS-1$\n\t\t\t\t\tn.setLatitude(MapUtils.get31LatitudeY(s.object.getPoint31YTile(i)));\n\t\t\t\t\tn.setLongitude(MapUtils.get31LongitudeX(s.object.getPoint31XTile(i)));\n\t\t\t\t\tres.add(n);\n\t\t\t\t\tif (i == s.endPointIndex) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (plus) {\n\t\t\t\t\t\ti++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new RouteCalculationResult(res, null, start, end, null);\n\t\t} catch (OutOfMemoryError e) {\n\t\t\treturn new RouteCalculationResult(\"No enough memory to calculate route.\");\n\t\t}\n\t}","commit_id":"eab130e6c8219af5b11ff8c0621180e0132dda68","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@NotNull\n  public ResourceBundle getResourceBundle() {\n    VirtualFile virtualFile = getVirtualFile();\n    if (!isValid() || virtualFile == null) {\n      return ResourceBundleImpl.NULL;\n    }\n    String baseName = PropertiesUtil.getBaseName(virtualFile);\n    return new ResourceBundleImpl(getContainingFile().getContainingDirectory().getVirtualFile(), baseName);\n  }","id":99964,"modified_method":"@NotNull\n  public ResourceBundle getResourceBundle() {\n    VirtualFile virtualFile = getVirtualFile();\n    if (!isValid() || virtualFile == null) {\n      return ResourceBundleImpl.NULL;\n    }\n    String baseName = PropertiesUtil.getBaseName(virtualFile);\n    PsiDirectory directory = getContainingFile().getContainingDirectory();\n    if (directory == null) return ResourceBundleImpl.NULL;\n    return new ResourceBundleImpl(directory.getVirtualFile(), baseName);\n  }","commit_id":"c7d80afc417d7ebbcea09b977a2ef30ff44343cd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public Map<String, String> getNamesMap() {\n    THashMap<String, String> result = new THashMap<String, String>();\n    for (Property property : getProperties()) {\n      result.put(property.getName(), property.getValue());\n    }\n    return result;\n  }","id":99965,"modified_method":"@NotNull\n  public Map<String, String> getNamesMap() {\n    Map<String, String> result = new THashMap<String, String>();\n    for (Property property : getProperties()) {\n      result.put(property.getName(), property.getValue());\n    }\n    return result;\n  }","commit_id":"c7d80afc417d7ebbcea09b977a2ef30ff44343cd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean haveToAddNewLine() {\n    ASTNode lastChild = getPropertiesList().getLastChildNode();\n    if (lastChild == null) return false;\n    return lastChild.getText().indexOf('\\n') == -1;\n  }","id":99966,"modified_method":"private boolean haveToAddNewLine() {\n    ASTNode lastChild = getPropertiesList().getLastChildNode();\n    return lastChild != null && lastChild.getText().indexOf('\\n') == -1;\n  }","commit_id":"c7d80afc417d7ebbcea09b977a2ef30ff44343cd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Must be invoked in AtomicAction\n   * target container can be null => means that container is not determined yet and must be spacify by the user\n   */\n  public static boolean canMove(PsiElement[] elements, PsiElement targetContainer) {\n    if (elements == null) {\n      throw new IllegalArgumentException(\"elements cannot be null\");\n    }\n    int moveType = getMoveType(elements);\n    if (moveType == NOT_SUPPORTED) {\n      return false;\n    }\n    if (targetContainer == null) {\n      return true;\n    }\n    if (moveType == INNER_TO_UPPER) {\n      return targetContainer.equals(MoveInnerImpl.getTargetContainer((PsiClass)elements[0]));\n    }\n    else if (moveType == MEMBERS) {\n      return targetContainer instanceof PsiClass && !(targetContainer instanceof PsiAnonymousClass);\n    }\n    else if (moveType == CLASSES || moveType == PACKAGES) {\n      if (targetContainer instanceof PsiPackage) {\n        return true;\n      }\n      if (targetContainer instanceof PsiDirectory) {\n        return ((PsiDirectory)targetContainer).getPackage() != null;\n      }\n      return false;\n    }\n    else if (moveType == FILES || moveType == DIRECTORIES) {\n      return targetContainer instanceof PsiDirectory;\n    }\n    else {\n      return false;\n    }\n  }","id":99967,"modified_method":"/**\n   * Must be invoked in AtomicAction\n   * target container can be null => means that container is not determined yet and must be spacify by the user\n   */\n  public static boolean canMove(PsiElement[] elements, PsiElement targetContainer) {\n    if (elements == null) {\n      throw new IllegalArgumentException(\"elements cannot be null\");\n    }\n    int moveType = getMoveType(elements);\n    if (moveType == NOT_SUPPORTED) {\n      return false;\n    }\n    if (targetContainer == null) {\n      return true;\n    }\n    if (moveType == INNER_TO_UPPER) {\n      return targetContainer.equals(MoveInnerImpl.getTargetContainer((PsiClass)elements[0], false));\n    }\n    else if (moveType == MEMBERS) {\n      return targetContainer instanceof PsiClass && !(targetContainer instanceof PsiAnonymousClass);\n    }\n    else if (moveType == CLASSES || moveType == PACKAGES) {\n      if (targetContainer instanceof PsiPackage) {\n        return true;\n      }\n      if (targetContainer instanceof PsiDirectory) {\n        return ((PsiDirectory)targetContainer).getPackage() != null;\n      }\n      return false;\n    }\n    else if (moveType == FILES || moveType == DIRECTORIES) {\n      return targetContainer instanceof PsiDirectory;\n    }\n    else {\n      return false;\n    }\n  }","commit_id":"6b36f04e521c106c4edc37a42ae7a319697c4a9b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void doAction() {\n    String message = null;\n    final String className = getClassName();\n    PsiManager manager = PsiManager.getInstance(myProject);\n    if (\"\".equals(className)) {\n      message = RefactoringBundle.message(\"no.class.name.specified\");\n    }\n    else if (!manager.getNameHelper().isIdentifier(className)) {\n      message = RefactoringMessageUtil.getIncorrectIdentifierMessage(className);\n    }\n    else {\n      if (myCbPassOuterClass.isSelected()) {\n        String parameterName = getParameterName();\n        if (\"\".equals(parameterName)) {\n          message = RefactoringBundle.message(\"no.parameter.name.specified\");\n        }\n        else if (!manager.getNameHelper().isIdentifier(parameterName)) {\n          message = RefactoringMessageUtil.getIncorrectIdentifierMessage(parameterName);\n        }\n      }\n      if (message == null) {\n        PsiElement targetContainer = MoveInnerImpl.getTargetContainer(myInnerClass);\n        if (targetContainer instanceof PsiClass) {\n          PsiClass targetClass = (PsiClass)targetContainer;\n          PsiClass[] classes = targetClass.getInnerClasses();\n          if (classes != null) {\n            for (PsiClass aClass : classes) {\n              if (className.equals(aClass.getName())) {\n                message = RefactoringBundle.message(\"inner.class.exists\", className, targetClass.getName());\n                break;\n              }\n            }\n          }\n        }\n        else if (targetContainer instanceof PsiDirectory) {\n          message = RefactoringMessageUtil.checkCanCreateClass((PsiDirectory)targetContainer, className);\n        }\n      }\n    }\n\n    if (message != null) {\n      CommonRefactoringUtil.showErrorMessage(\n        MoveInnerImpl.REFACTORING_NAME,\n        message,\n        HelpID.MOVE_INNER_UPPER,\n        myProject);\n      return;\n    }\n\n    RefactoringSettings.getInstance().MOVE_INNER_PREVIEW_USAGES = isPreviewUsages();\n    if (myCbPassOuterClass.isSelected() && mySuggestedNameInfo != null) {\n      mySuggestedNameInfo.nameChoosen(getParameterName());\n    }\n\n    myProcessor.run(this);\n  }","id":99968,"modified_method":"protected void doAction() {\n    String message = null;\n    final String className = getClassName();\n    PsiManager manager = PsiManager.getInstance(myProject);\n    if (\"\".equals(className)) {\n      message = RefactoringBundle.message(\"no.class.name.specified\");\n    }\n    else if (!manager.getNameHelper().isIdentifier(className)) {\n      message = RefactoringMessageUtil.getIncorrectIdentifierMessage(className);\n    }\n    else {\n      if (myCbPassOuterClass.isSelected()) {\n        String parameterName = getParameterName();\n        if (\"\".equals(parameterName)) {\n          message = RefactoringBundle.message(\"no.parameter.name.specified\");\n        }\n        else if (!manager.getNameHelper().isIdentifier(parameterName)) {\n          message = RefactoringMessageUtil.getIncorrectIdentifierMessage(parameterName);\n        }\n      }\n      if (message == null) {\n        if (myTargetContainer instanceof PsiClass) {\n          PsiClass targetClass = (PsiClass)myTargetContainer;\n          PsiClass[] classes = targetClass.getInnerClasses();\n          if (classes != null) {\n            for (PsiClass aClass : classes) {\n              if (className.equals(aClass.getName())) {\n                message = RefactoringBundle.message(\"inner.class.exists\", className, targetClass.getName());\n                break;\n              }\n            }\n          }\n        }\n        else if (myTargetContainer instanceof PsiDirectory) {\n          message = RefactoringMessageUtil.checkCanCreateClass((PsiDirectory)myTargetContainer, className);\n        }\n      }\n    }\n\n    if (message != null) {\n      CommonRefactoringUtil.showErrorMessage(\n        MoveInnerImpl.REFACTORING_NAME,\n        message,\n        HelpID.MOVE_INNER_UPPER,\n        myProject);\n      return;\n    }\n\n    RefactoringSettings.getInstance().MOVE_INNER_PREVIEW_USAGES = isPreviewUsages();\n    if (myCbPassOuterClass.isSelected() && mySuggestedNameInfo != null) {\n      mySuggestedNameInfo.nameChoosen(getParameterName());\n    }\n\n    myProcessor.run(this);\n  }","commit_id":"6b36f04e521c106c4edc37a42ae7a319697c4a9b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MoveInnerDialog(Project project, PsiClass innerClass, MoveInnerProcessor processor) {\n    super(project, true);\n    myProject = project;\n    myInnerClass = innerClass;\n    myOuterClass = myInnerClass.getContainingClass();\n    myProcessor = processor;\n    setTitle(MoveInnerImpl.REFACTORING_NAME);\n    init();\n  }","id":99969,"modified_method":"public MoveInnerDialog(Project project, PsiClass innerClass, MoveInnerProcessor processor, final PsiElement targetContainer) {\n    super(project, true);\n    myProject = project;\n    myInnerClass = innerClass;\n    myTargetContainer = targetContainer;\n    myOuterClass = myInnerClass.getContainingClass();\n    myProcessor = processor;\n    setTitle(MoveInnerImpl.REFACTORING_NAME);\n    init();\n  }","commit_id":"6b36f04e521c106c4edc37a42ae7a319697c4a9b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * must be called in atomic action\n   */\n  public static PsiElement getTargetContainer(PsiClass innerClass) {\n    PsiElement outerClassParent = innerClass.getParent().getParent();\n    while (outerClassParent != null) {\n      if (outerClassParent instanceof PsiClass && !(outerClassParent instanceof PsiAnonymousClass)) {\n        return outerClassParent;\n      } else if (outerClassParent instanceof PsiFile) {\n        return innerClass.getContainingFile().getContainingDirectory();\n      }\n      outerClassParent = outerClassParent.getParent();\n    }\n    // should not happen\n    LOG.assertTrue(false);\n    return null;\n  }","id":99970,"modified_method":"/**\n   * must be called in atomic action\n   */\n  public static @Nullable PsiElement getTargetContainer(PsiClass innerClass, final boolean chooseIfNotUnderSource) {\n    PsiElement outerClassParent = innerClass.getParent().getParent();\n    while (outerClassParent != null) {\n      if (outerClassParent instanceof PsiClass && !(outerClassParent instanceof PsiAnonymousClass)) {\n        return outerClassParent;\n      } else if (outerClassParent instanceof PsiFile) {\n        final PsiDirectory directory = innerClass.getContainingFile().getContainingDirectory();\n        final PsiPackage aPackage = directory.getPackage();\n        if (aPackage == null) {\n          if (chooseIfNotUnderSource) {\n            PackageChooserDialog chooser = new PackageChooserDialog(\"Select Target Package\", innerClass.getProject());\n            chooser.show();\n            if (!chooser.isOK()) return null;\n            final PsiPackage chosenPackage = chooser.getSelectedPackage();\n            if (chosenPackage == null) return null;\n            return chosenPackage.getDirectories()[0];\n          }\n\n          return null;\n        }\n        return directory;\n      }\n      outerClassParent = outerClassParent.getParent();\n    }\n    // should not happen\n    LOG.assertTrue(false);\n    return null;\n  }","commit_id":"6b36f04e521c106c4edc37a42ae7a319697c4a9b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void doMove(final Project project, PsiElement[] elements, final MoveCallback moveCallback) {\n    if (elements.length != 1) return;\n    final PsiClass aClass = (PsiClass) elements[0];\n    boolean condition = aClass.getParent() instanceof PsiClass;\n    LOG.assertTrue(condition);\n\n    if (!CommonRefactoringUtil.checkReadOnlyStatus(project, aClass)) return;\n\n    final MoveInnerDialog dialog = new MoveInnerDialog(\n            project,\n            aClass,\n            new MoveInnerProcessor(project, moveCallback)\n    );\n    dialog.show();\n\n  }","id":99971,"modified_method":"public static void doMove(final Project project, PsiElement[] elements, final MoveCallback moveCallback) {\n    if (elements.length != 1) return;\n    final PsiClass aClass = (PsiClass) elements[0];\n    boolean condition = aClass.getParent() instanceof PsiClass;\n    LOG.assertTrue(condition);\n\n    if (!CommonRefactoringUtil.checkReadOnlyStatus(project, aClass)) return;\n    final PsiElement targetContainer = getTargetContainer(aClass, true);\n    if (targetContainer == null) return;\n\n    final MoveInnerDialog dialog = new MoveInnerDialog(\n            project,\n            aClass,\n            new MoveInnerProcessor(project, moveCallback),\n            targetContainer);\n    dialog.show();\n\n  }","commit_id":"6b36f04e521c106c4edc37a42ae7a319697c4a9b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setup(final PsiClass innerClass,\n                    final String className,\n                    final boolean passOuterClass,\n                    final String parameterName,\n                    boolean searchInComments,\n                    boolean searchInNonJava) {\n    myNewClassName = className;\n    myInnerClass = innerClass;\n    myDescriptiveName = UsageViewUtil.getDescriptiveName(myInnerClass);\n    myOuterClass = myInnerClass.getContainingClass();\n    myTargetContainer = MoveInnerImpl.getTargetContainer(myInnerClass);\n    CodeStyleManager codeStyleManager = CodeStyleManager.getInstance(myProject);\n    myParameterNameOuterClass = passOuterClass ? parameterName : null;\n    if (myParameterNameOuterClass != null) {\n      myFieldNameOuterClass =\n      codeStyleManager.variableNameToPropertyName(myParameterNameOuterClass, VariableKind.PARAMETER);\n      myFieldNameOuterClass = codeStyleManager.propertyNameToVariableName(myFieldNameOuterClass, VariableKind.FIELD);\n    }\n    mySearchInComments = searchInComments;\n    mySearchInNonJavaFiles = searchInNonJava;\n  }","id":99972,"modified_method":"public void setup(final PsiClass innerClass,\n                    final String className,\n                    final boolean passOuterClass,\n                    final String parameterName,\n                    boolean searchInComments,\n                    boolean searchInNonJava,\n                    final @NotNull PsiElement targetContainer) {\n    myNewClassName = className;\n    myInnerClass = innerClass;\n    myDescriptiveName = UsageViewUtil.getDescriptiveName(myInnerClass);\n    myOuterClass = myInnerClass.getContainingClass();\n    myTargetContainer = targetContainer;\n    CodeStyleManager codeStyleManager = CodeStyleManager.getInstance(myProject);\n    myParameterNameOuterClass = passOuterClass ? parameterName : null;\n    if (myParameterNameOuterClass != null) {\n      myFieldNameOuterClass =\n      codeStyleManager.variableNameToPropertyName(myParameterNameOuterClass, VariableKind.PARAMETER);\n      myFieldNameOuterClass = codeStyleManager.propertyNameToVariableName(myFieldNameOuterClass, VariableKind.FIELD);\n    }\n    mySearchInComments = searchInComments;\n    mySearchInNonJavaFiles = searchInNonJava;\n  }","commit_id":"6b36f04e521c106c4edc37a42ae7a319697c4a9b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  protected UsageInfo[] findUsages() {\n    PsiManager manager = PsiManager.getInstance(myProject);\n    PsiSearchHelper helper = manager.getSearchHelper();\n\n    PsiReference[] innerClassRefs = helper.findReferences(myInnerClass, GlobalSearchScope.projectScope(myProject), false);\n    ArrayList<UsageInfo> usageInfos = new ArrayList<UsageInfo>(innerClassRefs.length);\n    for (PsiReference innerClassRef : innerClassRefs) {\n      PsiElement ref = innerClassRef.getElement();\n      if (!PsiTreeUtil.isAncestor(myInnerClass, ref, true)) { // do not show self-references\n        usageInfos.add(new UsageInfo(ref));\n      }\n    }\n\n    final String newQName;\n    if (myTargetContainer instanceof PsiDirectory) {\n      final PsiDirectory targetDirectory = ((PsiDirectory)myTargetContainer);\n      final PsiPackage aPackage = targetDirectory.getPackage();\n      LOG.assertTrue(aPackage != null);\n      newQName = aPackage.getQualifiedName() + \".\" + myNewClassName;\n    }\n    else if (myTargetContainer instanceof PsiClass) {\n      final String qName = ((PsiClass)myTargetContainer).getQualifiedName();\n      if (qName != null) {\n        newQName = qName + \".\" + myNewClassName;\n      }\n      else {\n        newQName = myNewClassName;\n      }\n    }\n    else {\n      newQName = myNewClassName;\n    }\n    MoveClassesOrPackagesUtil.findNonCodeUsages(mySearchInComments, mySearchInNonJavaFiles,\n                                                myInnerClass, newQName, usageInfos);\n    return usageInfos.toArray(new UsageInfo[usageInfos.size()]);\n  }","id":99973,"modified_method":"@NotNull\n  protected UsageInfo[] findUsages() {\n    PsiManager manager = PsiManager.getInstance(myProject);\n    PsiSearchHelper helper = manager.getSearchHelper();\n\n    LOG.assertTrue(myTargetContainer != null);\n\n    PsiReference[] innerClassRefs = helper.findReferences(myInnerClass, GlobalSearchScope.projectScope(myProject), false);\n    ArrayList<UsageInfo> usageInfos = new ArrayList<UsageInfo>(innerClassRefs.length);\n    for (PsiReference innerClassRef : innerClassRefs) {\n      PsiElement ref = innerClassRef.getElement();\n      if (!PsiTreeUtil.isAncestor(myInnerClass, ref, true)) { // do not show self-references\n        usageInfos.add(new UsageInfo(ref));\n      }\n    }\n\n    final String newQName;\n    if (myTargetContainer instanceof PsiDirectory) {\n      final PsiDirectory targetDirectory = ((PsiDirectory)myTargetContainer);\n      final PsiPackage aPackage = targetDirectory.getPackage();\n      LOG.assertTrue(aPackage != null);\n      newQName = aPackage.getQualifiedName() + \".\" + myNewClassName;\n    }\n    else if (myTargetContainer instanceof PsiClass) {\n      final String qName = ((PsiClass)myTargetContainer).getQualifiedName();\n      if (qName != null) {\n        newQName = qName + \".\" + myNewClassName;\n      }\n      else {\n        newQName = myNewClassName;\n      }\n    }\n    else {\n      newQName = myNewClassName;\n    }\n    MoveClassesOrPackagesUtil.findNonCodeUsages(mySearchInComments, mySearchInNonJavaFiles,\n                                                myInnerClass, newQName, usageInfos);\n    return usageInfos.toArray(new UsageInfo[usageInfos.size()]);\n  }","commit_id":"6b36f04e521c106c4edc37a42ae7a319697c4a9b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void run(final MoveInnerDialog dialog) {\n    myPrepareSuccessfulSwingThreadCallback = new Runnable() {\n      public void run() {\n        dialog.close(DialogWrapper.CANCEL_EXIT_CODE);\n      }\n    };\n\n    final String className = dialog.getClassName();\n    final PsiClass innerClass = dialog.getInnerClass();\n    final boolean passOuterClass = dialog.isPassOuterClass();\n    final String parameterName = dialog.getParameterName();\n\n    setup(innerClass, className, passOuterClass, parameterName,\n          dialog.isSearchInComments(), dialog.isSearchInNonJavaFiles());\n\n    run();\n  }","id":99974,"modified_method":"public void run(final MoveInnerDialog dialog) {\n    myPrepareSuccessfulSwingThreadCallback = new Runnable() {\n      public void run() {\n        dialog.close(DialogWrapper.CANCEL_EXIT_CODE);\n      }\n    };\n\n    final String className = dialog.getClassName();\n    final PsiClass innerClass = dialog.getInnerClass();\n    final boolean passOuterClass = dialog.isPassOuterClass();\n    final String parameterName = dialog.getParameterName();\n    final PsiElement targetContainer = dialog.getTargetContainer();\n\n    setup(innerClass, className, passOuterClass, parameterName,\n          dialog.isSearchInComments(), dialog.isSearchInNonJavaFiles(), targetContainer);\n\n    run();\n  }","commit_id":"6b36f04e521c106c4edc37a42ae7a319697c4a9b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MoveInnerProcessor(Project project, PsiClass innerClass, String name, boolean passOuterClass, String parameterName) {\n    super(project);\n    setup(innerClass, name, passOuterClass, parameterName, true, true);\n  }","id":99975,"modified_method":"public MoveInnerProcessor(Project project,\n                            PsiClass innerClass,\n                            String name,\n                            boolean passOuterClass,\n                            String parameterName,\n                            final PsiElement targetContainer) {\n    super(project);\n    setup(innerClass, name, passOuterClass, parameterName, true, true, targetContainer);\n  }","commit_id":"6b36f04e521c106c4edc37a42ae7a319697c4a9b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MoveInnerRefactoringImpl(Project project, PsiClass innerClass, String name, boolean passOuterClass, String parameterName) {\n    super(new MoveInnerProcessor(project, innerClass, name, passOuterClass, parameterName));\n  }","id":99976,"modified_method":"public MoveInnerRefactoringImpl(Project project,\n                                  PsiClass innerClass,\n                                  String name,\n                                  boolean passOuterClass,\n                                  String parameterName,\n                                  final PsiElement targetContainer) {\n    super(new MoveInnerProcessor(project, innerClass, name, passOuterClass, parameterName, targetContainer));\n  }","commit_id":"6b36f04e521c106c4edc37a42ae7a319697c4a9b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private PerformAction createAction(final String innerClassName,\n                                     final String newClassName,\n                                     final boolean passOuterClass,\n                                     final String parameterName,\n                                     final boolean searchInComments,\n                                     final boolean searchInNonJava) {\n    return new PerformAction() {\n      public void performAction(VirtualFile rootDir, VirtualFile rootAfter) throws Exception {\n        final PsiManager manager = PsiManager.getInstance(myProject);\n        final PsiClass aClass = manager.findClass(innerClassName, GlobalSearchScope.moduleScope(myModule));\n        final MoveInnerProcessor moveInnerProcessor = new MoveInnerProcessor(myProject, null);\n        moveInnerProcessor.setup(aClass, newClassName, passOuterClass, parameterName,\n                                 searchInComments, searchInNonJava);\n        moveInnerProcessor.run();\n        PsiDocumentManager.getInstance(myProject).commitAllDocuments();\n        FileDocumentManager.getInstance().saveAllDocuments();\n      }\n    };\n  }","id":99977,"modified_method":"private PerformAction createAction(final String innerClassName,\n                                     final String newClassName,\n                                     final boolean passOuterClass,\n                                     final String parameterName,\n                                     final boolean searchInComments,\n                                     final boolean searchInNonJava) {\n    return new PerformAction() {\n      public void performAction(VirtualFile rootDir, VirtualFile rootAfter) throws Exception {\n        final PsiManager manager = PsiManager.getInstance(myProject);\n        final PsiClass aClass = manager.findClass(innerClassName, GlobalSearchScope.moduleScope(myModule));\n        final MoveInnerProcessor moveInnerProcessor = new MoveInnerProcessor(myProject, null);\n        final PsiElement targetContainer = MoveInnerImpl.getTargetContainer(aClass, false);\n        assertNotNull(targetContainer);\n        moveInnerProcessor.setup(aClass, newClassName, passOuterClass, parameterName,\n                                 searchInComments, searchInNonJava, targetContainer);\n        moveInnerProcessor.run();\n        PsiDocumentManager.getInstance(myProject).commitAllDocuments();\n        FileDocumentManager.getInstance().saveAllDocuments();\n      }\n    };\n  }","commit_id":"6b36f04e521c106c4edc37a42ae7a319697c4a9b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MoveInnerRefactoring createMoveInner(PsiClass innerClass, String newName, boolean passOuterClass, String parameterName) {\n    return new MoveInnerRefactoringImpl(myProject, innerClass, newName, passOuterClass, parameterName);\n  }","id":99978,"modified_method":"public MoveInnerRefactoring createMoveInner(PsiClass innerClass, String newName, boolean passOuterClass, String parameterName) {\n    final PsiElement targetContainer = MoveInnerImpl.getTargetContainer(innerClass, false);\n    if (targetContainer == null) return null;\n    return new MoveInnerRefactoringImpl(myProject, innerClass, newName, passOuterClass, parameterName, targetContainer);\n  }","commit_id":"6b36f04e521c106c4edc37a42ae7a319697c4a9b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected boolean setupConfigurationFromContext(final PyToxConfiguration configuration,\n                                                  final ConfigurationContext context,\n                                                  final Ref<PsiElement> sourceElement) {\n    final PsiFile file = sourceElement.get().getContainingFile();\n    if (file == null) {\n      return false;\n    }\n    configuration.setWorkingDirectory(file.getContainingDirectory().getVirtualFile().getCanonicalPath());\n    if (TOX_FILE_NAME.equals(file.getName())) {\n      configuration.setName(\"Tox\");\n      return true;\n    }\n    return false;\n  }","id":99979,"modified_method":"@Override\n  protected boolean setupConfigurationFromContext(final PyToxConfiguration configuration,\n                                                  final ConfigurationContext context,\n                                                  final Ref<PsiElement> sourceElement) {\n    final PsiFile file = sourceElement.get().getContainingFile();\n    if (file == null) {\n      return false;\n    }\n    final PsiDirectory directory = file.getContainingDirectory();\n    if (directory == null) {\n      return false;\n    }\n    configuration.setWorkingDirectory(directory.getVirtualFile().getCanonicalPath());\n    if (TOX_FILE_NAME.equals(file.getName())) {\n      configuration.setName(\"Tox\");\n      return true;\n    }\n    return false;\n  }","commit_id":"16cfc8e16afabbe70790768e43301b7ba216927b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected String getContainerText(PsiElement element, String name) {\n    PsiFile file = (PsiFile)element;\n    final VirtualFile virtualFile = file.getContainingDirectory().getVirtualFile();\n    final String prefix = name + \"     \";\n\n    String path = FilePathSplittingPolicy.SPLIT_BY_SEPARATOR.getOptimalTextForComponent(prefix, VfsUtil.virtualToIoFile(virtualFile), this, myMaxWidth);\n    return \"(\" + path + \")\";\n  }","id":99980,"modified_method":"protected String getContainerText(PsiElement element, String name) {\n    PsiFile file = (PsiFile)element;\n    final PsiDirectory psiDirectory = file.getContainingDirectory();\n    LOG.assertTrue(psiDirectory != null);\n    final VirtualFile virtualFile = psiDirectory.getVirtualFile();\n    final String relativePath = getRelativePath(virtualFile, element.getProject());\n    if (relativePath == null) return \"( \" + File.separator + \" )\";\n    String path = FilePathSplittingPolicy.SPLIT_BY_SEPARATOR.getOptimalTextForComponent(name + \"          \", new File(relativePath), this, myMaxWidth);\n    return \"(\" + path + \")\";\n  }","commit_id":"40c3fbaaedd8d201909f63b02dfd571cd9f15197","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CommandLineBuilder getMainArgs(BaseHome baseHome, boolean addJavaInit) throws IOException\n    {\n        CommandLineBuilder cmd = new CommandLineBuilder();\n\n        if (addJavaInit)\n        {\n            cmd.addRawArg(CommandLineBuilder.findJavaBin());\n\n            for (String x : jvmArgs)\n            {\n                cmd.addRawArg(x);\n            }\n\n            cmd.addRawArg(\"-Djava.io.tmpdir=\" + System.getProperty(\"java.io.tmpdir\"));\n            cmd.addRawArg(\"-Djetty.home=\" + baseHome.getHome());\n            cmd.addRawArg(\"-Djetty.base=\" + baseHome.getBase());\n\n            // System Properties\n            for (String propKey : systemPropertyKeys)\n            {\n                String value = System.getProperty(propKey);\n                cmd.addEqualsArg(\"-D\" + propKey,value);\n            }\n\n            cmd.addRawArg(\"-cp\");\n            cmd.addRawArg(classpath.toString());\n            cmd.addRawArg(getMainClassname());\n        }\n\n        // Special Stop/Shutdown properties\n        ensureSystemPropertySet(\"STOP.PORT\");\n        ensureSystemPropertySet(\"STOP.KEY\");\n        ensureSystemPropertySet(\"STOP.WAIT\");\n\n        // pass properties as args or as a file\n        if (dryRun)\n        {\n            for (Prop p : properties)\n                cmd.addRawArg(CommandLineBuilder.quote(p.key) + \"=\" + CommandLineBuilder.quote(p.value));\n        }\n        else if (properties.size() > 0)\n        {\n            Path prop_path = Files.createTempFile(Paths.get(baseHome.getBase()), \"start_\", \".properties\");\n            prop_path.toFile().deleteOnExit();\n            try (OutputStream out = Files.newOutputStream(prop_path))\n            {\n                properties.store(out,\"start.jar properties\");\n            }\n            cmd.addRawArg(prop_path.toAbsolutePath().toString());\n        }\n\n        for (Path xml : xmls)\n        {\n            cmd.addRawArg(xml.toAbsolutePath().toString());\n        }\n\n        for (Path propertyFile : propertyFiles)\n        {\n            cmd.addRawArg(propertyFile.toAbsolutePath().toString());\n        }\n\n        return cmd;\n    }","id":99981,"modified_method":"public CommandLineBuilder getMainArgs(BaseHome baseHome, boolean addJavaInit) throws IOException\n    {\n        CommandLineBuilder cmd = new CommandLineBuilder();\n\n        if (addJavaInit)\n        {\n            cmd.addRawArg(CommandLineBuilder.findJavaBin());\n\n            for (String x : jvmArgs)\n            {\n                cmd.addRawArg(x);\n            }\n\n            cmd.addRawArg(\"-Djava.io.tmpdir=\" + System.getProperty(\"java.io.tmpdir\"));\n            cmd.addRawArg(\"-Djetty.home=\" + baseHome.getHome());\n            cmd.addRawArg(\"-Djetty.base=\" + baseHome.getBase());\n\n            // System Properties\n            for (String propKey : systemPropertyKeys)\n            {\n                String value = System.getProperty(propKey);\n                cmd.addEqualsArg(\"-D\" + propKey,value);\n            }\n\n            cmd.addRawArg(\"-cp\");\n            cmd.addRawArg(classpath.toString());\n            cmd.addRawArg(getMainClassname());\n        }\n\n        // Special Stop/Shutdown properties\n        ensureSystemPropertySet(\"STOP.PORT\");\n        ensureSystemPropertySet(\"STOP.KEY\");\n        ensureSystemPropertySet(\"STOP.WAIT\");\n\n        // pass properties as args or as a file\n        if (dryRun && exec_properties==null)\n        {\n            for (Prop p : properties)\n                cmd.addRawArg(CommandLineBuilder.quote(p.key) + \"=\" + CommandLineBuilder.quote(p.value));\n        }\n        else if (properties.size() > 0)\n        {\n            Path prop_path;\n            if (exec_properties==null)\n            {\n                prop_path=Files.createTempFile(Paths.get(baseHome.getBase()), \"start_\", \".properties\");\n                prop_path.toFile().deleteOnExit();\n            }\n            else\n                prop_path=new File(exec_properties).toPath();\n                \n            try (OutputStream out = Files.newOutputStream(prop_path))\n            {\n                properties.store(out,\"start.jar properties\");\n            }\n            cmd.addRawArg(prop_path.toAbsolutePath().toString());\n        }\n\n        for (Path xml : xmls)\n        {\n            cmd.addRawArg(xml.toAbsolutePath().toString());\n        }\n\n        for (Path propertyFile : propertyFiles)\n        {\n            cmd.addRawArg(propertyFile.toAbsolutePath().toString());\n        }\n\n        return cmd;\n    }","commit_id":"aca2aa56adf8319523e81d96b31a71eb1f30da14","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Parse a single line of argument.\n     *\n     * @param rawarg\n     *            the raw argument to parse\n     * @param source\n     *            the origin of this line of argument\n     * @param replaceProps\n     *            true if properties in this parse replace previous ones, false to not replace.\n     */\n    private void parse(final String rawarg, String source, boolean replaceProps)\n    {\n        if (rawarg == null)\n        {\n            return;\n        }\n\n        StartLog.debug(\"parse(\\\"%s\\\", \\\"%s\\\", %b)\",rawarg,source,replaceProps);\n\n        final String arg = rawarg.trim();\n\n        if (arg.length() <= 0)\n        {\n            return;\n        }\n\n        if (arg.startsWith(\"#\"))\n        {\n            return;\n        }\n\n        if (\"--help\".equals(arg) || \"-?\".equals(arg))\n        {\n            help = true;\n            run = false;\n            return;\n        }\n\n        if (\"--debug\".equals(arg) || arg.startsWith(\"--start-log-file\"))\n        {\n            // valid, but handled in StartLog instead\n            return;\n        }\n\n        if (\"--testing-mode\".equals(arg))\n        {\n            System.setProperty(\"org.eclipse.jetty.start.testing\",\"true\");\n            testingMode = true;\n            return;\n        }\n\n        if (arg.startsWith(\"--include-jetty-dir=\"))\n        {\n            // valid, but handled in ConfigSources instead\n            return;\n        }\n\n        if (\"--stop\".equals(arg))\n        {\n            stopCommand = true;\n            run = false;\n            return;\n        }\n\n        if (arg.startsWith(\"--download=\"))\n        {\n            addFile(null,Props.getValue(arg));\n            run = false;\n            download = true;\n            return;\n        }\n\n        if (arg.equals(\"--create-files\"))\n        {\n            run = false;\n            download = true;\n            licenseCheckRequired = true;\n            return;\n        }\n\n        if (\"--list-classpath\".equals(arg) || \"--version\".equals(arg) || \"-v\".equals(arg) || \"--info\".equals(arg))\n        {\n            listClasspath = true;\n            run = false;\n            return;\n        }\n\n        if (\"--list-config\".equals(arg))\n        {\n            listConfig = true;\n            run = false;\n            return;\n        }\n\n        if (\"--dry-run\".equals(arg) || \"--exec-print\".equals(arg))\n        {\n            dryRun = true;\n            run = false;\n            return;\n        }\n\n        // Enable forked execution of Jetty server\n        if (\"--exec\".equals(arg))\n        {\n            exec = true;\n            return;\n        }\n\n        // Enable forked execution of Jetty server\n        if (\"--approve-all-licenses\".equals(arg))\n        {\n            approveAllLicenses = true;\n            return;\n        }\n\n        // Arbitrary Libraries\n        if (arg.startsWith(\"--lib=\"))\n        {\n            String cp = Props.getValue(arg);\n\n            if (cp != null)\n            {\n                StringTokenizer t = new StringTokenizer(cp,File.pathSeparator);\n                while (t.hasMoreTokens())\n                {\n                    rawLibs.add(t.nextToken());\n                }\n            }\n            return;\n        }\n\n        // Module Management\n        if (\"--list-modules\".equals(arg))\n        {\n            listModules = true;\n            run = false;\n            return;\n        }\n\n        // jetty.base build-out : add to ${jetty.base}/start.d/\n        if (arg.startsWith(\"--add-to-startd=\"))\n        {\n            List<String> moduleNames = Props.getValues(arg);\n            addToStartdIni.addAll(moduleNames);\n            run = false;\n            download = true;\n            licenseCheckRequired = true;\n            return;\n        }\n\n        // jetty.base build-out : add to ${jetty.base}/start.ini\n        if (arg.startsWith(\"--add-to-start=\"))\n        {\n            List<String> moduleNames = Props.getValues(arg);\n            addToStartIni.addAll(moduleNames);\n            run = false;\n            download = true;\n            licenseCheckRequired = true;\n            return;\n        }\n\n        // Enable a module\n        if (arg.startsWith(\"--module=\"))\n        {\n            List<String> moduleNames = Props.getValues(arg);\n            enableModules(source,moduleNames);\n            return;\n        }\n\n        // Skip [files] validation on a module\n        if (arg.startsWith(\"--skip-file-validation=\"))\n        {\n            List<String> moduleNames = Props.getValues(arg);\n            for (String moduleName : moduleNames)\n            {\n                skipFileValidationModules.add(moduleName);\n            }\n            return;\n        }\n\n        // Create graphviz output of module graph\n        if (arg.startsWith(\"--write-module-graph=\"))\n        {\n            this.moduleGraphFilename = Props.getValue(arg);\n            run = false;\n            return;\n        }\n\n        // Start property (syntax similar to System property)\n        if (arg.startsWith(\"-D\"))\n        {\n            String[] assign = arg.substring(2).split(\"=\",2);\n            systemPropertyKeys.add(assign[0]);\n            switch (assign.length)\n            {\n                case 2:\n                    System.setProperty(assign[0],assign[1]);\n                    setProperty(assign[0],assign[1],source,replaceProps);\n                    break;\n                case 1:\n                    System.setProperty(assign[0],\"\");\n                    setProperty(assign[0],\"\",source,replaceProps);\n                    break;\n                default:\n                    break;\n            }\n            return;\n        }\n\n        // Anything else with a \"-\" is considered a JVM argument\n        if (arg.startsWith(\"-\"))\n        {\n            // Only add non-duplicates\n            if (!jvmArgs.contains(arg))\n            {\n                jvmArgs.add(arg);\n            }\n            return;\n        }\n\n        // Is this a raw property declaration?\n        int idx = arg.indexOf('=');\n        if (idx >= 0)\n        {\n            String key = arg.substring(0,idx);\n            String value = arg.substring(idx + 1);\n\n            if (replaceProps)\n            {\n                if (propertySource.containsKey(key))\n                {\n                    StartLog.warn(\"Property %s in %s already set in %s\",key,source,propertySource.get(key));\n                }\n                propertySource.put(key,source);\n            }\n\n            if (\"OPTION\".equals(key) || \"OPTIONS\".equals(key))\n            {\n                StringBuilder warn = new StringBuilder();\n                warn.append(\"The behavior of the argument \");\n                warn.append(arg).append(\" (seen in \").append(source);\n                warn.append(\") has changed, and is now considered a normal property.  \");\n                warn.append(key).append(\" no longer controls what libraries are on your classpath,\");\n                warn.append(\" use --module instead. See --help for details.\");\n                StartLog.warn(warn.toString());\n            }\n\n            setProperty(key,value,source,replaceProps);\n            return;\n        }\n\n        // Is this an xml file?\n        if (FS.isXml(arg))\n        {\n            // only add non-duplicates\n            if (!xmlRefs.contains(arg))\n            {\n                xmlRefs.add(arg);\n            }\n            return;\n        }\n\n        if (FS.isPropertyFile(arg))\n        {\n            // only add non-duplicates\n            if (!propertyFileRefs.contains(arg))\n            {\n                propertyFileRefs.add(arg);\n            }\n            return;\n        }\n\n        // Anything else is unrecognized\n        throw new UsageException(ERR_BAD_ARG,\"Unrecognized argument: \\\"%s\\\" in %s\",arg,source);\n    }","id":99982,"modified_method":"/**\n     * Parse a single line of argument.\n     *\n     * @param rawarg\n     *            the raw argument to parse\n     * @param source\n     *            the origin of this line of argument\n     * @param replaceProps\n     *            true if properties in this parse replace previous ones, false to not replace.\n     */\n    private void parse(final String rawarg, String source, boolean replaceProps)\n    {\n        if (rawarg == null)\n        {\n            return;\n        }\n\n        StartLog.debug(\"parse(\\\"%s\\\", \\\"%s\\\", %b)\",rawarg,source,replaceProps);\n\n        final String arg = rawarg.trim();\n\n        if (arg.length() <= 0)\n        {\n            return;\n        }\n\n        if (arg.startsWith(\"#\"))\n        {\n            return;\n        }\n\n        if (\"--help\".equals(arg) || \"-?\".equals(arg))\n        {\n            help = true;\n            run = false;\n            return;\n        }\n\n        if (\"--debug\".equals(arg) || arg.startsWith(\"--start-log-file\"))\n        {\n            // valid, but handled in StartLog instead\n            return;\n        }\n\n        if (\"--testing-mode\".equals(arg))\n        {\n            System.setProperty(\"org.eclipse.jetty.start.testing\",\"true\");\n            testingMode = true;\n            return;\n        }\n\n        if (arg.startsWith(\"--include-jetty-dir=\"))\n        {\n            // valid, but handled in ConfigSources instead\n            return;\n        }\n\n        if (\"--stop\".equals(arg))\n        {\n            stopCommand = true;\n            run = false;\n            return;\n        }\n\n        if (arg.startsWith(\"--download=\"))\n        {\n            addFile(null,Props.getValue(arg));\n            run = false;\n            download = true;\n            return;\n        }\n\n        if (arg.equals(\"--create-files\"))\n        {\n            run = false;\n            download = true;\n            licenseCheckRequired = true;\n            return;\n        }\n\n        if (\"--list-classpath\".equals(arg) || \"--version\".equals(arg) || \"-v\".equals(arg) || \"--info\".equals(arg))\n        {\n            listClasspath = true;\n            run = false;\n            return;\n        }\n\n        if (\"--list-config\".equals(arg))\n        {\n            listConfig = true;\n            run = false;\n            return;\n        }\n\n        if (\"--dry-run\".equals(arg) || \"--exec-print\".equals(arg))\n        {\n            dryRun = true;\n            run = false;\n            return;\n        }\n\n        // Enable forked execution of Jetty server\n        if (\"--exec\".equals(arg))\n        {\n            exec = true;\n            return;\n        }\n        \n        // Assign a fixed name to the property file for exec\n        if (arg.startsWith(\"--exec-properties=\"))\n        {\n            exec_properties=Props.getValue(arg);\n            if (!exec_properties.endsWith(\".properties\"))\n                throw new UsageException(ERR_BAD_ARG,\"--exec-properties filename must have .properties suffix: %s\",exec_properties);\n            return;\n        }\n\n        // Enable forked execution of Jetty server\n        if (\"--approve-all-licenses\".equals(arg))\n        {\n            approveAllLicenses = true;\n            return;\n        }\n\n        // Arbitrary Libraries\n        if (arg.startsWith(\"--lib=\"))\n        {\n            String cp = Props.getValue(arg);\n\n            if (cp != null)\n            {\n                StringTokenizer t = new StringTokenizer(cp,File.pathSeparator);\n                while (t.hasMoreTokens())\n                {\n                    rawLibs.add(t.nextToken());\n                }\n            }\n            return;\n        }\n\n        // Module Management\n        if (\"--list-modules\".equals(arg))\n        {\n            listModules = true;\n            run = false;\n            return;\n        }\n\n        // jetty.base build-out : add to ${jetty.base}/start.d/\n        if (arg.startsWith(\"--add-to-startd=\"))\n        {\n            List<String> moduleNames = Props.getValues(arg);\n            addToStartdIni.addAll(moduleNames);\n            run = false;\n            download = true;\n            licenseCheckRequired = true;\n            return;\n        }\n\n        // jetty.base build-out : add to ${jetty.base}/start.ini\n        if (arg.startsWith(\"--add-to-start=\"))\n        {\n            List<String> moduleNames = Props.getValues(arg);\n            addToStartIni.addAll(moduleNames);\n            run = false;\n            download = true;\n            licenseCheckRequired = true;\n            return;\n        }\n\n        // Enable a module\n        if (arg.startsWith(\"--module=\"))\n        {\n            List<String> moduleNames = Props.getValues(arg);\n            enableModules(source,moduleNames);\n            return;\n        }\n\n        // Skip [files] validation on a module\n        if (arg.startsWith(\"--skip-file-validation=\"))\n        {\n            List<String> moduleNames = Props.getValues(arg);\n            for (String moduleName : moduleNames)\n            {\n                skipFileValidationModules.add(moduleName);\n            }\n            return;\n        }\n\n        // Create graphviz output of module graph\n        if (arg.startsWith(\"--write-module-graph=\"))\n        {\n            this.moduleGraphFilename = Props.getValue(arg);\n            run = false;\n            return;\n        }\n\n        // Start property (syntax similar to System property)\n        if (arg.startsWith(\"-D\"))\n        {\n            String[] assign = arg.substring(2).split(\"=\",2);\n            systemPropertyKeys.add(assign[0]);\n            switch (assign.length)\n            {\n                case 2:\n                    System.setProperty(assign[0],assign[1]);\n                    setProperty(assign[0],assign[1],source,replaceProps);\n                    break;\n                case 1:\n                    System.setProperty(assign[0],\"\");\n                    setProperty(assign[0],\"\",source,replaceProps);\n                    break;\n                default:\n                    break;\n            }\n            return;\n        }\n\n        // Anything else with a \"-\" is considered a JVM argument\n        if (arg.startsWith(\"-\"))\n        {\n            // Only add non-duplicates\n            if (!jvmArgs.contains(arg))\n            {\n                jvmArgs.add(arg);\n            }\n            return;\n        }\n\n        // Is this a raw property declaration?\n        int idx = arg.indexOf('=');\n        if (idx >= 0)\n        {\n            String key = arg.substring(0,idx);\n            String value = arg.substring(idx + 1);\n\n            if (replaceProps)\n            {\n                if (propertySource.containsKey(key))\n                {\n                    StartLog.warn(\"Property %s in %s already set in %s\",key,source,propertySource.get(key));\n                }\n                propertySource.put(key,source);\n            }\n\n            if (\"OPTION\".equals(key) || \"OPTIONS\".equals(key))\n            {\n                StringBuilder warn = new StringBuilder();\n                warn.append(\"The behavior of the argument \");\n                warn.append(arg).append(\" (seen in \").append(source);\n                warn.append(\") has changed, and is now considered a normal property.  \");\n                warn.append(key).append(\" no longer controls what libraries are on your classpath,\");\n                warn.append(\" use --module instead. See --help for details.\");\n                StartLog.warn(warn.toString());\n            }\n\n            setProperty(key,value,source,replaceProps);\n            return;\n        }\n\n        // Is this an xml file?\n        if (FS.isXml(arg))\n        {\n            // only add non-duplicates\n            if (!xmlRefs.contains(arg))\n            {\n                xmlRefs.add(arg);\n            }\n            return;\n        }\n\n        if (FS.isPropertyFile(arg))\n        {\n            // only add non-duplicates\n            if (!propertyFileRefs.contains(arg))\n            {\n                propertyFileRefs.add(arg);\n            }\n            return;\n        }\n\n        // Anything else is unrecognized\n        throw new UsageException(ERR_BAD_ARG,\"Unrecognized argument: \\\"%s\\\" in %s\",arg,source);\n    }","commit_id":"aca2aa56adf8319523e81d96b31a71eb1f30da14","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public boolean renameTo(File dest) {\n    \t\n    \tSystem.out.println(\"rename from \"+uri+\" to \"+dest.getPath());\n    \t\n        XmldbURI destinationPath = ((Resource)dest).uri;\n\n        DBBroker broker = null; \n        BrokerPool db = null;\n        TransactionManager tm;\n\n        try {\n            try {\n                db = BrokerPool.getInstance();\n                broker = db.get(null);\n            } catch (EXistException e) {\n                return false;\n            }\n    \n            tm = db.getTransactionManager();\n            Txn transaction = null;\n    \n            org.exist.collections.Collection destination = null;\n            org.exist.collections.Collection source = null;\n            XmldbURI newName;\n            try {\n                source = broker.openCollection(uri.removeLastSegment(), Lock.WRITE_LOCK);\n                if(source == null) {\n                    return false;\n                }\n                DocumentImpl doc = source.getDocument(broker, uri.lastSegment());\n                if(doc == null) {\n                    return false;\n                }\n                destination = broker.openCollection(destinationPath.removeLastSegment(), Lock.WRITE_LOCK);\n                if(destination == null) {\n                    return false;\n                }\n                \n                newName = destinationPath.lastSegment();\n    \n                transaction = tm.beginTransaction();\n                moveResource(broker, transaction, doc, source, destination, newName);\n\n//                resource = null;\n//                collection = null;\n//                initialized = false;\n//                uri = ((Resource)dest).uri;\n\n                tm.commit(transaction);\n                return true;\n                \n            } catch ( Exception e ) {\n                e.printStackTrace();\n                if (transaction != null) tm.abort(transaction);\n                return false;\n            } finally {\n                if(source != null) source.release(Lock.WRITE_LOCK);\n                if(destination != null) destination.release(Lock.WRITE_LOCK);\n            }\n        } finally {\n            if (db != null)\n                db.release( broker );\n        }\n    }","id":99983,"modified_method":"public boolean renameTo(File dest) {\n    \t\n//    \tSystem.out.println(\"rename from \"+uri+\" to \"+dest.getPath());\n    \t\n        XmldbURI destinationPath = ((Resource)dest).uri;\n\n        DBBroker broker = null; \n        BrokerPool db = null;\n        TransactionManager tm;\n\n        try {\n            try {\n                db = BrokerPool.getInstance();\n                broker = db.get(null);\n            } catch (EXistException e) {\n                return false;\n            }\n    \n            tm = db.getTransactionManager();\n            Txn transaction = null;\n    \n            org.exist.collections.Collection destination = null;\n            org.exist.collections.Collection source = null;\n            XmldbURI newName;\n            try {\n                source = broker.openCollection(uri.removeLastSegment(), Lock.WRITE_LOCK);\n                if(source == null) {\n                    return false;\n                }\n                DocumentImpl doc = source.getDocument(broker, uri.lastSegment());\n                if(doc == null) {\n                    return false;\n                }\n                destination = broker.openCollection(destinationPath.removeLastSegment(), Lock.WRITE_LOCK);\n                if(destination == null) {\n                    return false;\n                }\n                \n                newName = destinationPath.lastSegment();\n    \n                transaction = tm.beginTransaction();\n                moveResource(broker, transaction, doc, source, destination, newName);\n\n//                resource = null;\n//                collection = null;\n//                initialized = false;\n//                uri = ((Resource)dest).uri;\n\n                tm.commit(transaction);\n                return true;\n                \n            } catch ( Exception e ) {\n                e.printStackTrace();\n                if (transaction != null) tm.abort(transaction);\n                return false;\n            } finally {\n                if(source != null) source.release(Lock.WRITE_LOCK);\n                if(destination != null) destination.release(Lock.WRITE_LOCK);\n            }\n        } finally {\n            if (db != null)\n                db.release( broker );\n        }\n    }","commit_id":"427c41d37af1c73d95d3cd6835f05529b3d3f8ec","url":"https://github.com/eXist-db/exist"},{"original_method":"private File serialize(final DBBroker broker, final DocumentImpl doc) throws IOException {\n    \ttry {\n\t\t\tSerializer serializer = broker.getSerializer();\n\t\t\tserializer.setUser(broker.getSubject());\n\t\t\tserializer.setProperties(XML_OUTPUT_PROPERTIES);\n\t\t\t\n            File file = File.createTempFile(\"eXist\", \".xml\");\n            file.deleteOnExit();\n\n            Writer w = new OutputStreamWriter(new FileOutputStream(file), \"UTF-8\");\n\t\t\t\n\t\t\tserializer.serialize(doc, w);\n\t\t\tw.flush();\n\t\t\tw.close();\n\t\t\t\n\t\t\treturn file;\n\t\t\t\n    \t} catch (Exception e) {\n    \t\tthrow new IOException(e);\n    \t}\n    }","id":99984,"modified_method":"private synchronized File serialize(final DBBroker broker, final DocumentImpl doc) throws IOException {\n    \tif (file != null)\n    \t\tthrow new IOException(doc.getFileURI().toString()+\" locked.\");\n    \t\t\n    \ttry {\n\t\t\tSerializer serializer = broker.getSerializer();\n\t\t\tserializer.setUser(broker.getSubject());\n\t\t\tserializer.setProperties(XML_OUTPUT_PROPERTIES);\n\t\t\t\n            file = File.createTempFile(\"eXist-resource-\", \".xml\");\n            file.deleteOnExit();\n\n            Writer w = new OutputStreamWriter(new FileOutputStream(file), \"UTF-8\");\n\t\t\t\n\t\t\tserializer.serialize(doc, w);\n\t\t\tw.flush();\n\t\t\tw.close();\n\t\t\t\n\t\t\treturn file;\n\t\t\t\n    \t} catch (Exception e) {\n    \t\tthrow new IOException(e);\n    \t}\n    }","commit_id":"427c41d37af1c73d95d3cd6835f05529b3d3f8ec","url":"https://github.com/eXist-db/exist"},{"original_method":"private void moveResource(DBBroker broker, Txn txn, DocumentImpl doc, Collection source, Collection destination, XmldbURI newName) throws PermissionDeniedException, LockException, IOException, SAXException, EXistException {\n        \n        final MimeTable mimeTable = MimeTable.getInstance();\n        \n        final boolean isXML = mimeTable.isXMLContent(newName.toString());\n        \n        final MimeType mimeType = mimeTable.getContentTypeFor(newName);\n        \n    \tif ( mimeType != null && !mimeType.getName().equals( doc.getMetadata().getMimeType()) ) {\n            doc.getMetadata().setMimeType(mimeType.getName());\n            broker.storeXMLResource(txn, doc);\n\n            doc = source.getDocument(broker, uri.lastSegment());\n        }\n        \n    \tif (isXML) {\n            if (doc.getResourceType() == DocumentImpl.XML_FILE) {\n            \t//XML to XML\n                //move to same type as it\n                broker.moveResource(txn, doc, destination, newName);\n\n            } else {\n                //convert BINARY to XML\n                \n                File file = broker.getBinaryFile((BinaryDocument) doc);\n\n                FileInputSource is = new FileInputSource(file);\n                \n                IndexInfo info = destination.validateXMLResource(txn, broker, newName, is);\n                info.getDocument().getMetadata().setMimeType(mimeType.getName());\n\n                is = new FileInputSource(file);\n                destination.store(txn, broker, info, is, false);\n                \n                source.removeBinaryResource(txn, broker, doc);\n            }\n        } else {\n            if (doc.getResourceType() == DocumentImpl.BINARY_FILE) {\n            \t//BINARY to BINARY\n\n            \t//move to same type as it\n                broker.moveResource(txn, doc, destination, newName);\n                \n            } else {\n                //convert XML to BINARY\n                // xml file\n                Serializer serializer = broker.getSerializer();\n                serializer.setUser(broker.getSubject());\n                serializer.setProperties(XML_OUTPUT_PROPERTIES);\n                \n                File tempFile = null;\n                FileInputStream is = null;\n\t\t\t\ttry {\n                    tempFile = File.createTempFile(\"eXist\", \".xml\");\n                    tempFile.deleteOnExit();\n                    \n                    Writer w = new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF-8\");\n\n                    serializer.serialize(doc, w);\n                    w.flush();\n                    w.close();\n                    \n                    is = new FileInputStream(tempFile);\n                    \n                    final DocumentMetadata meta = doc.getMetadata();\n                    \n                    final Date created = new Date(meta.getCreated());\n                    final Date lastModified = new Date(meta.getLastModified());\n    \n                    BinaryDocument binary = destination.validateBinaryResource(txn, broker, newName, is, mimeType.getName(), -1, created, lastModified);\n                    \n                    binary = destination.addBinaryResource(txn, broker, binary, is, mimeType.getName(), -1, created, lastModified);\n                    \n                    source.removeXMLResource(txn, broker, doc.getFileURI());\n                    \n                } finally {\n                \tif (is != null)\n                \t\tis.close();\n\n                \tif (tempFile != null)\n                \t\ttempFile.delete();\n                }\n            }\n        }\n    }","id":99985,"modified_method":"private void moveResource(DBBroker broker, Txn txn, DocumentImpl doc, Collection source, Collection destination, XmldbURI newName) throws PermissionDeniedException, LockException, IOException, SAXException, EXistException {\n        \n        final MimeTable mimeTable = MimeTable.getInstance();\n        \n        final boolean isXML = mimeTable.isXMLContent(newName.toString());\n        \n        final MimeType mimeType = mimeTable.getContentTypeFor(newName);\n        \n    \tif ( mimeType != null && !mimeType.getName().equals( doc.getMetadata().getMimeType()) ) {\n            doc.getMetadata().setMimeType(mimeType.getName());\n            broker.storeXMLResource(txn, doc);\n\n            doc = source.getDocument(broker, uri.lastSegment());\n        }\n        \n    \tif (isXML) {\n            if (doc.getResourceType() == DocumentImpl.XML_FILE) {\n            \t//XML to XML\n                //move to same type as it\n                broker.moveResource(txn, doc, destination, newName);\n\n            } else {\n                //convert BINARY to XML\n                \n                File file = broker.getBinaryFile((BinaryDocument) doc);\n\n                FileInputSource is = new FileInputSource(file);\n                \n                IndexInfo info = destination.validateXMLResource(txn, broker, newName, is);\n                info.getDocument().getMetadata().setMimeType(mimeType.getName());\n\n                is = new FileInputSource(file);\n                destination.store(txn, broker, info, is, false);\n                \n                source.removeBinaryResource(txn, broker, doc);\n            }\n        } else {\n            if (doc.getResourceType() == DocumentImpl.BINARY_FILE) {\n            \t//BINARY to BINARY\n\n            \t//move to same type as it\n                broker.moveResource(txn, doc, destination, newName);\n                \n            } else {\n                //convert XML to BINARY\n                // xml file\n                Serializer serializer = broker.getSerializer();\n                serializer.setUser(broker.getSubject());\n                serializer.setProperties(XML_OUTPUT_PROPERTIES);\n                \n                File tempFile = null;\n                FileInputStream is = null;\n\t\t\t\ttry {\n                    tempFile = File.createTempFile(\"eXist-resource-\", \".xml\");\n                    tempFile.deleteOnExit();\n                    \n                    Writer w = new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF-8\");\n\n                    serializer.serialize(doc, w);\n                    w.flush();\n                    w.close();\n                    \n                    is = new FileInputStream(tempFile);\n                    \n                    final DocumentMetadata meta = doc.getMetadata();\n                    \n                    final Date created = new Date(meta.getCreated());\n                    final Date lastModified = new Date(meta.getLastModified());\n    \n                    BinaryDocument binary = destination.validateBinaryResource(txn, broker, newName, is, mimeType.getName(), -1, created, lastModified);\n                    \n                    binary = destination.addBinaryResource(txn, broker, binary, is, mimeType.getName(), -1, created, lastModified);\n                    \n                    source.removeXMLResource(txn, broker, doc.getFileURI());\n                    \n                } finally {\n                \tif (is != null)\n                \t\tis.close();\n\n                \tif (tempFile != null)\n                \t\ttempFile.delete();\n                }\n            }\n        }\n    }","commit_id":"427c41d37af1c73d95d3cd6835f05529b3d3f8ec","url":"https://github.com/eXist-db/exist"},{"original_method":"public void close() throws IOException {\n\t\tsuper.close();\n\t\t\n\t\tif (resource.isXML()) {\n\t\t\t//XXX: cleanup tmp file\n\t\t}\n\t\t\n\t\t//XXX: locking?\n\t}","id":99986,"modified_method":"public void close() throws IOException {\n\t\tsuper.close();\n\t\t\n\t\tresource.freeFile();\n\t\t\n\t\tif (resource.isXML()) {\n\t\t\t//XXX: cleanup tmp file\n\t\t}\n\t\t\n\t\t//XXX: locking?\n\t}","commit_id":"427c41d37af1c73d95d3cd6835f05529b3d3f8ec","url":"https://github.com/eXist-db/exist"},{"original_method":"public ResourceOutputStream(Resource file) throws FileNotFoundException {\n\t\tsuper(file.getFile());\n\t}","id":99987,"modified_method":"public ResourceOutputStream(Resource file) throws FileNotFoundException {\n\t\tsuper(file.getFile());\n\t\t\n\t\tresource = file;\n\t}","commit_id":"427c41d37af1c73d95d3cd6835f05529b3d3f8ec","url":"https://github.com/eXist-db/exist"},{"original_method":"public ResourceOutputStream(Resource file, boolean append) throws FileNotFoundException {\n\t\tsuper(file.getFile(), append);\n\t}","id":99988,"modified_method":"public ResourceOutputStream(Resource file, boolean append) throws FileNotFoundException {\n\t\tsuper(file.getFile(), append);\n\t\t\n\t\tresource = file;\n\t}","commit_id":"427c41d37af1c73d95d3cd6835f05529b3d3f8ec","url":"https://github.com/eXist-db/exist"},{"original_method":"public void close() throws IOException {\n\t\tsuper.close();\n\t\t\n\t\t//XXX: xml upload back to db\n\t\t\n\t\t//XXX: locking?\n\t}","id":99989,"modified_method":"public void close() throws IOException {\n\t\tsuper.close();\n\n\t\tresource.freeFile();\n\n\t\t//XXX: xml upload back to db\n\t\t\n\t\t//XXX: locking?\n\t}","commit_id":"427c41d37af1c73d95d3cd6835f05529b3d3f8ec","url":"https://github.com/eXist-db/exist"},{"original_method":"public void close() throws IOException {\n\t\tsuper.close();\n\t\t\n\t\t//XXX: xml upload back to db\n\t\t\n\t\t//XXX: locking?\n\t}","id":99990,"modified_method":"public void close() throws IOException {\n\t\tsuper.close();\n\t\t\n\t\tresource.freeFile();\n\t\t\n\t\t//XXX: xml upload back to db\n\t\t\n\t\t//XXX: locking?\n\t}","commit_id":"427c41d37af1c73d95d3cd6835f05529b3d3f8ec","url":"https://github.com/eXist-db/exist"},{"original_method":"public ResourceRandomAccess(Resource resource, String mode) throws FileNotFoundException {\n\t\tsuper(resource.getFile(), mode);\n\t}","id":99991,"modified_method":"public ResourceRandomAccess(Resource resource, String mode) throws FileNotFoundException {\n\t\tsuper(resource.getFile(), mode);\n\t\t\n\t\tthis.resource = resource;\n\t}","commit_id":"427c41d37af1c73d95d3cd6835f05529b3d3f8ec","url":"https://github.com/eXist-db/exist"},{"original_method":"protected File buildDict(File tempFile, Language language) throws Exception {\n    String suffix = language != null ?\n            \"-\" + language.getShortNameWithCountryAndVariant() + \".dict\" : \".dict\";\n    File resultFile = File.createTempFile(DictionaryBuilder.class.getSimpleName(), suffix);\n    String[] buildToolOptions = {\"-f\", \"cfsa2\", \"-i\", tempFile.getAbsolutePath(), \"-o\", resultFile.getAbsolutePath()};\n    System.out.println(\"Running Morfologik FSABuildTool.main with these options: \" + Arrays.toString(buildToolOptions));\n    FSABuildTool.main(buildToolOptions);\n    System.out.println(\"Done. The binary dictionary has been written to \" + resultFile.getAbsolutePath());\n    return resultFile;\n  }","id":99992,"modified_method":"protected File buildDict(File tempFile, Language language) throws Exception {\n    String suffix = language != null ?\n            \"-\" + language.getShortNameWithCountryAndVariant() + \".dict\" : \".dict\";\n    File resultFile = outputFilename != null\n        ? new File(outputFilename)\n        : File.createTempFile(DictionaryBuilder.class.getSimpleName(), suffix);\n        \n    String[] buildToolOptions = {\"-f\", \"cfsa2\", \"-i\", tempFile.getAbsolutePath(), \"-o\", resultFile.getAbsolutePath()};\n    System.out.println(\"Running Morfologik FSABuildTool.main with these options: \" + Arrays.toString(buildToolOptions));\n    FSABuildTool.main(buildToolOptions);\n    System.out.println(\"Done. The binary dictionary has been written to \" + resultFile.getAbsolutePath());\n    return resultFile;\n  }","commit_id":"ae7cdf9730d020819733a997da3b09039d93f6e4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public static void main(String[] args) throws Exception {\n    checkUsageOrExit(SpellDictionaryBuilder.class.getSimpleName(), args);\n    String languageCode = args[0];\n    String plainTextFile = args[1];\n    String infoFile = args[2];\n    SpellDictionaryBuilder builder = new SpellDictionaryBuilder(new File(infoFile));\n    \n    if (args.length == 4) {\n      String freqListFile = args[3];\n      builder.readFreqList(new File(freqListFile));\n      builder.build(languageCode, builder.addFreqData(new File(plainTextFile)));\n    } else {\n      builder.build(languageCode, new File(plainTextFile));\n    }\n  }","id":99993,"modified_method":"public static void main(String[] args) throws Exception {\n    CommandLine cmdLine = SpellDictionaryBuilder.parseArguments(args);\n    checkUsageOrExit(SpellDictionaryBuilder.class.getSimpleName(), cmdLine);\n    \n    String languageCode = args[0];\n    String plainTextFile = args[1];\n    String infoFile = args[2];\n    SpellDictionaryBuilder builder = new SpellDictionaryBuilder(new File(infoFile));\n    builder.setOutputFilename( cmdLine.getOptionValue(\"o\") );\n    \n    if (args.length >= 4) {\n      String freqListFile = args[3];\n      builder.readFreqList(new File(freqListFile));\n      builder.build(languageCode, builder.addFreqData(new File(plainTextFile)));\n    } else {\n      builder.build(languageCode, new File(plainTextFile));\n    }\n  }","commit_id":"ae7cdf9730d020819733a997da3b09039d93f6e4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"protected static void checkUsageOrExit(String className, String[] args) throws IOException {\n    if (args.length < 3 || args.length > 4) {\n      System.out.println(\"Usage: \" + className + \" <languageCode> <dictionary> <infoFile> [frequencyList]\");\n      System.out.println(\"   <languageCode> like 'en-US' or 'de-DE'\");\n      System.out.println(\"   <dictionary> is a plain text dictionary file, e.g. created from a Hunspell dictionary by 'unmunch'\");\n      System.out.println(\"   <infoFile> is the *.info properties file, see http://wiki.languagetool.org/developing-a-tagger-dictionary\");\n      System.out.println(\"   [frequencyList] is the *.xml file with a frequency wordlist, see http://wiki.languagetool.org/developing-a-tagger-dictionary\");\n      System.exit(1);\n    }\n    File dictFile = new File(args[2]);\n    if (!dictFile.exists()) {\n      throw new IOException(\"File does not exist: \" + dictFile);\n    }\n  }","id":99994,"modified_method":"protected static void checkUsageOrExit(String className, CommandLine cmdLine) throws IOException {\n    String[] args = cmdLine.getArgs();\n    if (args.length < 3 || args.length > 4 || ! cmdLine.hasOption(\"o\")) {\n      System.out.println(\"Usage: \" + className + \" <languageCode> <dictionary> <infoFile> [frequencyList] -o <outputFile>\");\n      System.out.println(\"   <languageCode> like 'en-US' or 'de-DE'\");\n      System.out.println(\"   <dictionary> is a plain text dictionary file, e.g. created from a Hunspell dictionary by 'unmunch'\");\n      System.out.println(\"   <infoFile> is the *.info properties file, see http://wiki.languagetool.org/developing-a-tagger-dictionary\");\n      System.out.println(\"   [frequencyList] is the *.xml file with a frequency wordlist, see http://wiki.languagetool.org/developing-a-tagger-dictionary\");\n      System.exit(1);\n    }\n    File dictFile = new File(args[2]);\n    if (!dictFile.exists()) {\n      throw new IOException(\"File does not exist: \" + dictFile);\n    }\n  }","commit_id":"ae7cdf9730d020819733a997da3b09039d93f6e4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Override\n    protected ConfigurationParameters getSecurityConfigParameters() {\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(PermissionConstants.PARAM_READ_PATHS, READ_PATHS);\n        map.put(PermissionConstants.PARAM_ADMINISTRATIVE_PRINCIPALS, new String[] {ADMINISTRATOR_GROUP});\n        ConfigurationParameters acConfig = ConfigurationParameters.of(map);\n\n        return ConfigurationParameters.of(ImmutableMap.of(AuthorizationConfiguration.NAME, acConfig));\n    }","id":99995,"modified_method":"@Override\n    protected ConfigurationParameters getSecurityConfigParameters() {\n        ConfigurationParameters acConfig = ConfigurationParameters.of(\n                PermissionConstants.PARAM_READ_PATHS, READ_PATHS,\n                PermissionConstants.PARAM_ADMINISTRATIVE_PRINCIPALS, new String[] {ADMINISTRATOR_GROUP});\n\n        return ConfigurationParameters.of(ImmutableMap.of(AuthorizationConfiguration.NAME, acConfig));\n    }","commit_id":"7ea452694d74df97ceeab0d5eefdd35f2c23c3c1","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private String translateESNodeIdToName(String id) {\n        NodeInfo[] result = indexer.getClient().admin().cluster().nodesInfo(new NodesInfoRequest(id)).actionGet().getNodes();\n        if (result == null || result.length == 0) {\n            return \"unknown\";\n        }\n\n        return result[0].getNode().getName();\n    }","id":99996,"modified_method":"private String translateESNodeIdToName(String id) {\n        final NodeInfo[] result = indexer.getClient().admin().cluster().nodesInfo(new NodesInfoRequest(id)).actionGet().getNodes();\n        if (result == null || result.length == 0) {\n            return \"unknown\";\n        }\n\n        return result[0].getNode().getName();\n    }","commit_id":"47a0dd7050cdfa5ef469d8679cdadb803052de87","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@GET @Timed\n    @Path(\"/closed\")\n    @ApiOperation(value = \"Get a list of closed indices that can be reopened.\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response closed() {\n        Map<String, Object> result = Maps.newHashMap();\n\n        Set<String> closedIndices = Sets.newHashSet();\n        try {\n            // Get a list of all indices and select those that are closed. This is only possible via metadata.\n            ClusterStateRequest csr = new ClusterStateRequest()\n                    .filterNodes(true)\n                    .filterRoutingTable(true)\n                    .filterBlocks(true)\n                    .filterMetaData(false);\n            ClusterState state = indexer.getClient().admin().cluster().state(csr).actionGet().getState();\n\n            UnmodifiableIterator<IndexMetaData> it = state.getMetaData().getIndices().valuesIt();\n\n            while(it.hasNext()) {\n                IndexMetaData indexMeta = it.next();\n                // Only search in our indices.\n                if (!indexMeta.getIndex().startsWith(configuration.getElasticSearchIndexPrefix())) {\n                    continue;\n                }\n                if (!isPermitted(RestPermissions.INDICES_READ, indexMeta.getIndex())) {\n                    continue;\n                }\n                if(indexMeta.getState().equals(IndexMetaData.State.CLOSE)) {\n                    closedIndices.add(indexMeta.getIndex());\n                }\n            }\n        } catch (Exception e) {\n            LOG.error(\"Could not get closed indices.\", e);\n            return Response.status(500).build();\n        }\n\n        result.put(\"indices\", closedIndices);\n        result.put(\"total\", closedIndices.size());\n\n        return Response.ok().entity(json(result)).build();\n    }","id":99997,"modified_method":"@GET\n    @Timed\n    @Path(\"/closed\")\n    @ApiOperation(value = \"Get a list of closed indices that can be reopened.\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response closed() {\n        final ImmutableSet.Builder<String> closedIndicesBuilder = ImmutableSet.builder();\n\n        try {\n            // Get a list of all indices and select those that are closed. This is only possible via metadata.\n            final ClusterStateRequest csr = new ClusterStateRequest()\n                    .filterNodes(true)\n                    .filterRoutingTable(true)\n                    .filterBlocks(true)\n                    .filterMetaData(false);\n            final ClusterState state = indexer.getClient().admin().cluster().state(csr).actionGet().getState();\n\n            final Iterator<IndexMetaData> it = state.getMetaData().getIndices().valuesIt();\n            while (it.hasNext()) {\n                final IndexMetaData indexMeta = it.next();\n\n                // Only search in our indices.\n                if (!indexMeta.getIndex().startsWith(configuration.getElasticSearchIndexPrefix())) {\n                    continue;\n                }\n                if (!isPermitted(RestPermissions.INDICES_READ, indexMeta.getIndex())) {\n                    continue;\n                }\n                if (indexMeta.getState().equals(IndexMetaData.State.CLOSE)) {\n                    closedIndicesBuilder.add(indexMeta.getIndex());\n                }\n            }\n        } catch (Exception e) {\n            LOG.error(\"Could not get closed indices.\", e);\n            return Response.serverError().build();\n        }\n\n        final Set<String> closedIndices = closedIndicesBuilder.build();\n        final Map<String, Object> result = ImmutableMap.of(\n                \"indices\", closedIndices,\n                \"total\", closedIndices.size());\n\n        return Response.ok().entity(json(result)).build();\n    }","commit_id":"47a0dd7050cdfa5ef469d8679cdadb803052de87","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private Map<String, Object> indexStats(final CommonStats stats) {\n        Map<String, Object> result = Maps.newHashMap();\n\n        result.put(\"flush\", new HashMap<String, Object>() {{\n            put(\"total\", stats.getFlush().getTotal());\n            put(\"time_seconds\", stats.getFlush().getTotalTime().getSeconds());\n        }});\n\n        result.put(\"get\", new HashMap<String, Object>() {{\n            put(\"total\", stats.getGet().getCount());\n            put(\"time_seconds\", stats.getGet().getTime().getSeconds());\n        }});\n\n        result.put(\"index\", new HashMap<String, Object>() {{\n            put(\"total\", stats.getIndexing().getTotal().getIndexCount());\n            put(\"time_seconds\", stats.getIndexing().getTotal().getIndexTime().getSeconds());\n        }});\n\n        result.put(\"merge\", new HashMap<String, Object>() {{\n            put(\"total\", stats.getMerge().getTotal());\n            put(\"time_seconds\", stats.getMerge().getTotalTime().getSeconds());\n        }});\n\n        result.put(\"refresh\", new HashMap<String, Object>() {{\n            put(\"total\", stats.getRefresh().getTotal());\n            put(\"time_seconds\", stats.getRefresh().getTotalTime().getSeconds());\n        }});\n\n        result.put(\"search_query\", new HashMap<String, Object>() {{\n            put(\"total\", stats.getSearch().getTotal().getQueryCount());\n            put(\"time_seconds\", stats.getSearch().getTotal().getQueryTime().getSeconds());\n        }});\n\n        result.put(\"search_fetch\", new HashMap<String, Object>() {{\n            put(\"total\", stats.getSearch().getTotal().getFetchCount());\n            put(\"time_seconds\", stats.getSearch().getTotal().getFetchTime().getSeconds());\n        }});\n\n        result.put(\"open_search_contexts\", stats.getSearch().getOpenContexts());\n        result.put(\"store_size_bytes\", stats.getStore().getSize().getBytes());\n        result.put(\"segments\", stats.getSegments().getCount());\n\n        result.put(\"documents\", new HashMap<String, Object>() {{\n            put(\"count\", stats.getDocs().getCount());\n            put(\"deleted\", stats.getDocs().getDeleted());\n        }});\n\n        return result;\n    }","id":99998,"modified_method":"private Map<String, Object> indexStats(final CommonStats stats) {\n        final ImmutableMap.Builder<String, Object> result = ImmutableMap.builder();\n\n        result.put(\"flush\", ImmutableMap.<String, Object>of(\n                \"total\", stats.getFlush().getTotal(),\n                \"time_seconds\", stats.getFlush().getTotalTime().getSeconds()\n        ));\n\n        result.put(\"get\", ImmutableMap.<String, Object>of(\n                \"total\", stats.getGet().getCount(),\n                \"time_seconds\", stats.getGet().getTime().getSeconds()\n        ));\n\n        result.put(\"index\", ImmutableMap.<String, Object>of(\n                \"total\", stats.getIndexing().getTotal().getIndexCount(),\n                \"time_seconds\", stats.getIndexing().getTotal().getIndexTime().getSeconds()\n        ));\n\n        result.put(\"merge\", ImmutableMap.<String, Object>of(\n                \"total\", stats.getMerge().getTotal(),\n                \"time_seconds\", stats.getMerge().getTotalTime().getSeconds()\n        ));\n\n        result.put(\"refresh\", ImmutableMap.<String, Object>of(\n                \"total\", stats.getRefresh().getTotal(),\n                \"time_seconds\", stats.getRefresh().getTotalTime().getSeconds()\n        ));\n\n        result.put(\"search_query\", ImmutableMap.<String, Object>of(\n                \"total\", stats.getSearch().getTotal().getQueryCount(),\n                \"time_seconds\", stats.getSearch().getTotal().getQueryTime().getSeconds()\n        ));\n\n        result.put(\"search_fetch\", ImmutableMap.<String, Object>of(\n                \"total\", stats.getSearch().getTotal().getFetchCount(),\n                \"time_seconds\", stats.getSearch().getTotal().getFetchTime().getSeconds()\n        ));\n\n        result.put(\"open_search_contexts\", stats.getSearch().getOpenContexts());\n        result.put(\"store_size_bytes\", stats.getStore().getSize().getBytes());\n        result.put(\"segments\", stats.getSegments().getCount());\n\n        result.put(\"documents\", ImmutableMap.<String, Object>of(\n                \"count\", stats.getDocs().getCount(),\n                \"deleted\", stats.getDocs().getDeleted()\n        ));\n\n        return result.build();\n    }","commit_id":"47a0dd7050cdfa5ef469d8679cdadb803052de87","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private Map<String, Object> shardRouting(ShardRouting route) {\n        Map<String, Object> result = Maps.newHashMap();\n\n        result.put(\"id\", route.shardId().getId());\n        result.put(\"state\", route.state().name().toLowerCase());\n        result.put(\"active\", route.active());\n        result.put(\"primary\", route.primary());\n        result.put(\"node_id\", route.currentNodeId());\n        result.put(\"node_name\", translateESNodeIdToName(route.currentNodeId()));\n        result.put(\"node_hostname\", translateESNodeIdToHostname(route.currentNodeId()));\n        result.put(\"relocating_to\", route.relocatingNodeId());\n\n        return result;\n    }","id":99999,"modified_method":"private Map<String, Object> shardRouting(ShardRouting route) {\n        final ImmutableMap.Builder<String, Object> result = ImmutableMap.builder();\n\n        result.put(\"id\", route.shardId().getId());\n        result.put(\"state\", route.state().name().toLowerCase());\n        result.put(\"active\", route.active());\n        result.put(\"primary\", route.primary());\n        result.put(\"node_id\", route.currentNodeId());\n        result.put(\"node_name\", translateESNodeIdToName(route.currentNodeId()));\n        result.put(\"node_hostname\", translateESNodeIdToHostname(route.currentNodeId()));\n        result.put(\"relocating_to\", route.relocatingNodeId());\n\n        return result.build();\n    }","commit_id":"47a0dd7050cdfa5ef469d8679cdadb803052de87","url":"https://github.com/Graylog2/graylog2-server"}]